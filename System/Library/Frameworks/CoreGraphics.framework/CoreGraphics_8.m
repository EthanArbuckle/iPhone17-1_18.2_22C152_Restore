float cmyk64_shade_custom_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float result;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  int v20;
  unsigned char *v21;
  _WORD *v22;
  uint64_t v23;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;

  result = *(float *)(a1 + 280);
  v5 = *(float *)(*(void *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(result * v6));
  v9 = *(float *)(a1 + 284);
  v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  v11 = *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 308);
  v13 = *(float *)(a1 + 312);
  v14 = *(float *)(a1 + 316);
  v15 = *(float *)(a1 + 336);
  v16 = *(float *)(a1 + 348);
  v17 = *(float *)(a1 + 344);
  v18 = *(float *)(a1 + 356);
  v19 = *(void *)(a1 + 376);
  v20 = 5 * *(_DWORD *)(a1 + 48);
  v21 = *(unsigned char **)(a1 + 144);
  v22 = (_WORD *)(*(void *)(a1 + 152) + 8);
  v23 = *(void *)(a1 + 360);
  do
  {
    if (v8 < v11 || v10 < v13)
    {
      v25 = 0;
      v26 = 0;
    }
    else
    {
      v25 = v8 == v12;
      v26 = v8 < v12;
    }
    if (v26 || v25)
    {
      v27 = v10 == v14;
      v28 = v10 < v14;
    }
    else
    {
      v27 = 0;
      v28 = 0;
    }
    if (v28 || v27)
    {
      v29 = v23 + 2 * v20 * (int)(float)(v18 * (float)(v10 - v16)) + 10 * (int)(float)(v17 * (float)(v8 - v15));
LABEL_15:
      v30 = *(void *)v29;
      LOWORD(v29) = *(_WORD *)(v29 + 8);
      *((void *)v22 - 1) = v30;
      *v22 = v29;
      LOBYTE(v29) = -1;
      goto LABEL_16;
    }
    v29 = v19;
    if (v19) {
      goto LABEL_15;
    }
LABEL_16:
    v8 = result + v8;
    v10 = v9 + v10;
    *v21++ = v29;
    v22 += 8;
    --a4;
  }
  while (a4);
  return result;
}

uint64_t cmyk64_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  float v9 = *(float *)(a1 + 284);
  float v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  float v34 = *(float *)(a1 + 336);
  float v35 = *(float *)(a1 + 304);
  float v12 = *(float *)(a1 + 344);
  uint64_t v13 = *(void *)(a1 + 360);
  v15 = *(unsigned char **)(a1 + 144);
  uint64_t v14 = *(void *)(a1 + 152);
  float v16 = *(float *)(a1 + 308) - v35;
  do
  {
    float v17 = v12 * (float)((float)(v35 + (float)((float)((float)(atan2f(v10, v8) * 0.15915) + 0.5) * v16)) - v34);
    unsigned int v18 = vcvtms_s32_f32(v17);
    float v19 = ceilf(v17);
    unsigned int v20 = vcvtms_s32_f32(v12 + v17);
    float v21 = v17 - (float)(int)floorf(v17);
    if (v17 < 0.0) {
      unsigned int v18 = v20;
    }
    BOOL v22 = v17 <= v12;
    float v23 = ceilf(v17 - v12);
    float v24 = (float)(v21 * 255.0) + 0.5;
    if (v22) {
      float v23 = v19;
    }
    v25 = (unsigned __int16 *)(v13 + 2 * (int)(5 * v18));
    int v26 = *v25;
    int v27 = v25[1];
    int v28 = v25[2];
    int v29 = v25[3];
    int v30 = 255 - (int)v24;
    v31 = (unsigned __int16 *)(v13 + 10 * (int)v23);
    uint64_t result = (int)v24 * v31[1];
    LODWORD(v25) = (v31[4] * (int)v24 + v30 * v25[4]) >> 8;
    unint64_t v33 = ((unint64_t)(unsigned __int16)(((int)v24 * v31[2] + v30 * v28) >> 8) << 32) | ((unint64_t)((v31[3] * (int)v24 + v30 * v29) >> 8) << 48) | ((result + v30 * v27) << 8) & 0xFFFF0000 | (unsigned __int16)(((int)v24 * *v31 + v30 * v26) >> 8);
    *(_WORD *)(v14 + 8) = (_WORD)v25;
    *(void *)uint64_t v14 = v33;
    v14 += 16;
    float v8 = v4 + v8;
    float v10 = v9 + v10;
    *v15++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

void cmyk64_shade_radial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(a1 + 284);
  float v6 = *(float *)(*(void *)(a1 + 272) + 4);
  float v7 = v6 * (float)a2;
  float v8 = v6 * (float)a3;
  float v9 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v8) + (float)(v4 * v7));
  float v10 = *(float *)(a1 + 300) + (float)((float)(v8 * *(float *)(a1 + 292)) + (float)(v5 * v7));
  float v12 = *(float **)(a1 + 400);
  float v13 = *(float *)(a1 + 336);
  float v14 = *(float *)(a1 + 344);
  float v15 = *(float *)(a1 + 304);
  float v16 = *(float *)(a1 + 308);
  int v17 = *(_DWORD *)(a1 + 324);
  float v18 = v12[2];
  float v19 = v12[4];
  float v20 = v12[5];
  float v21 = v12[7];
  uint64_t v24 = a1 + 144;
  BOOL v22 = *(unsigned char **)(a1 + 144);
  uint64_t v23 = *(void *)(v24 + 8);
  v25 = *(uint64_t **)(a1 + 376);
  uint64_t v26 = *(void *)(a1 + 360);
  if (v18 != 0.0 || v21 != 0.0 || v5 != 0.0)
  {
    int v30 = *(_DWORD *)(a1 + 320);
    float v31 = v12[3];
    float v32 = v12[8];
    float v33 = -v12[6];
    float v34 = v16 - v15;
    for (i = (_WORD *)(v23 + 8); ; i += 8)
    {
      float v36 = v33 + (float)((float)(v9 + v9) * v18);
      float v37 = (float)((float)(v10 * v10) + (float)(v9 * v9)) - v21;
      if (v20 == 0.0)
      {
        float v44 = v37 / v36;
      }
      else
      {
        float v38 = (float)((float)(v20 * -4.0) * v37) + (float)(v36 * v36);
        if (v38 < 0.0) {
          goto LABEL_39;
        }
        float v39 = sqrtf(v38);
        float v40 = v32 * (float)(v36 - v39);
        float v41 = v36 + v39;
        float v42 = v32 * v41;
        BOOL v43 = (float)(v32 * v41) <= v40;
        if ((float)(v32 * v41) <= v40) {
          float v44 = v32 * v41;
        }
        else {
          float v44 = v40;
        }
        if (v43) {
          float v42 = v40;
        }
        if (v42 < 0.0)
        {
          BOOL v45 = v42 < v31;
LABEL_25:
          int v46 = v30;
          if (v45) {
            goto LABEL_39;
          }
LABEL_26:
          if ((v46 & 0x80000000) == 0) {
            goto LABEL_38;
          }
          goto LABEL_39;
        }
        if (v42 <= 1.0)
        {
          float v47 = v15 + (float)(v42 * v34);
          goto LABEL_37;
        }
        if ((v17 & 0x80000000) == 0)
        {
          int v46 = v17;
          if (v42 <= v19)
          {
LABEL_38:
            v48 = (uint64_t *)(v26 + 10 * v46);
LABEL_40:
            uint64_t v49 = *v48;
            LOWORD(v48) = *((_WORD *)v48 + 4);
            *((void *)i - 1) = v49;
            _WORD *i = (_WORD)v48;
            LOBYTE(v48) = -1;
            goto LABEL_41;
          }
        }
      }
      if (v44 < 0.0)
      {
        BOOL v45 = v44 < v31;
        goto LABEL_25;
      }
      if (v44 > 1.0)
      {
        int v46 = v17;
        if (v44 > v19) {
          goto LABEL_39;
        }
        goto LABEL_26;
      }
      float v47 = v15 + (float)(v44 * v34);
LABEL_37:
      int v46 = (int)(float)(v14 * (float)(v47 - v13));
      if ((v46 & 0x80000000) == 0) {
        goto LABEL_38;
      }
LABEL_39:
      v48 = v25;
      if (v25) {
        goto LABEL_40;
      }
LABEL_41:
      float v9 = v4 + v9;
      float v10 = v5 + v10;
      *v22++ = (_BYTE)v48;
      if (!--a4) {
        return;
      }
    }
  }
  float v27 = v10 * v10;
  float v28 = -v20;
  if (v27 <= (float)-v20)
  {
    float v50 = fabsf(v12[8]);
    float v51 = v20 * -4.0;
    float v52 = v16 - v15;
    v53 = (uint64_t *)(v26 + 10 * v17);
    int v54 = a4 + 2;
    while (1)
    {
      float v55 = v27 + (float)(v9 * v9);
      float v56 = v4 + v9;
      float v57 = v27 + (float)(v56 * v56);
      if (v55 > v28 && v57 > v28)
      {
        if (v17 < 0)
        {
          if (!v25)
          {
            char v72 = 0;
            LOBYTE(v71) = 0;
            goto LABEL_65;
          }
          __int16 v66 = *((_WORD *)v25 + 4);
          uint64_t v67 = *v25;
        }
        else
        {
          __int16 v66 = *((_WORD *)v53 + 4);
          uint64_t v67 = *v53;
        }
        *(void *)uint64_t v23 = v67;
        *(_WORD *)(v23 + 8) = v66;
        goto LABEL_63;
      }
      float v59 = sqrtf(v51 * v57);
      float v60 = v50 * sqrtf(v51 * v55);
      float v61 = v50 * v59;
      int v62 = (int)(float)(v14 * (float)((float)(v15 + (float)(v60 * v52)) - v13));
      int v63 = (int)(float)(v14 * (float)((float)(v15 + (float)((float)(v50 * v59) * v52)) - v13));
      if (v60 <= 1.0 && v61 <= 1.0)
      {
        v68 = (uint64_t *)(v26 + 10 * v62);
        uint64_t v69 = *v68;
        LOWORD(v68) = *((_WORD *)v68 + 4);
        v70 = (uint64_t *)(v26 + 10 * v63);
        uint64_t v67 = *v70;
        __int16 v66 = *((_WORD *)v70 + 4);
        *(void *)uint64_t v23 = v69;
        *(_WORD *)(v23 + 8) = (_WORD)v68;
LABEL_63:
        LOBYTE(v71) = -1;
        goto LABEL_64;
      }
      if (v60 <= 1.0)
      {
        if ((v62 & 0x80000000) == 0)
        {
          uint64_t v65 = 5 * v62;
LABEL_69:
          v71 = (uint64_t *)(v26 + 2 * v65);
LABEL_71:
          uint64_t v73 = *v71;
          LOWORD(v71) = *((_WORD *)v71 + 4);
          *(void *)uint64_t v23 = v73;
          *(_WORD *)(v23 + 8) = (_WORD)v71;
          LOBYTE(v71) = -1;
          goto LABEL_72;
        }
      }
      else if (v60 <= v19)
      {
        uint64_t v65 = 5 * v17;
        if ((v17 & 0x80000000) == 0) {
          goto LABEL_69;
        }
      }
      v71 = v25;
      if (v25) {
        goto LABEL_71;
      }
LABEL_72:
      if (v61 <= 1.0)
      {
        if (v63 < 0) {
          goto LABEL_79;
        }
        uint64_t v74 = 5 * v63;
      }
      else if (v61 > v19 || (uint64_t v74 = 5 * v17, v17 < 0))
      {
LABEL_79:
        if (!v25)
        {
          char v72 = 0;
          goto LABEL_65;
        }
        uint64_t v67 = *v25;
        __int16 v66 = *((_WORD *)v25 + 4);
        goto LABEL_64;
      }
      v75 = (uint64_t *)(v26 + 2 * v74);
      uint64_t v67 = *v75;
      __int16 v66 = *((_WORD *)v75 + 4);
LABEL_64:
      *(void *)(v23 + 16) = v67;
      *(_WORD *)(v23 + 24) = v66;
      char v72 = -1;
LABEL_65:
      float v9 = v4 + v56;
      v23 += 32;
      *BOOL v22 = (_BYTE)v71;
      v22[1] = v72;
      v22 += 2;
      v54 -= 2;
      if (v54 <= 2) {
        return;
      }
    }
  }
  if (v25 || (v17 & 0x80000000) == 0)
  {
    if (v17 >= 0) {
      v76 = (uint64_t *)(v26 + 10 * v17);
    }
    else {
      v76 = *(uint64_t **)(a1 + 376);
    }
    __int16 v77 = *((_WORD *)v76 + 4);
    uint64_t v78 = *v76;
    int v79 = a4 + 4;
    do
    {
      *(void *)uint64_t v23 = v78;
      *(_WORD *)(v23 + 8) = v77;
      *(void *)(v23 + 16) = v78;
      *(_WORD *)(v23 + 24) = v77;
      *(void *)(v23 + 32) = v78;
      *(_WORD *)(v23 + 40) = v77;
      *(void *)(v23 + 48) = v78;
      v79 -= 4;
      *(_WORD *)(v23 + 56) = v77;
      v23 += 64;
      *(_DWORD *)BOOL v22 = -1;
      v22 += 4;
    }
    while (v79 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v29 = 4;
    }
    else {
      int v29 = a4;
    }
    bzero(v22, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t cmyk64_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(v48, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v48) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = 269501476;
  unsigned int v19 = *(_DWORD *)a3;
  *((void *)&v31 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 269501476)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYK16_image_sample[2 * v20 + 2];
      if ((void)v31)
      {
LABEL_28:
        DWORD2(v31) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v32) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              DWORD2(v31) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v26 = cmyk64_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v31) = *(_DWORD *)a3;
              v25 = (unint64_t (*)(unint64_t, int *, int, int, int, int))cmyk64_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v31) = *(_DWORD *)a3;
              v25 = (unint64_t (*)(unint64_t, int *, int, int, int, int))cmyk64_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v31) = *(_DWORD *)a3;
              v25 = cmyk64_image_mark_rgb32;
LABEL_51:
              float v27 = v25;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 0;
              break;
            case 5u:
              DWORD2(v31) = *(_DWORD *)a3;
              uint64_t v26 = cmyk64_image_mark_rgb32;
LABEL_53:
              float v27 = v26;
              uint64_t v28 = (uint64_t)a2;
              int v29 = v8;
              int v30 = 8;
              break;
            default:
              goto LABEL_29;
          }
          cmyk64_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(void, void))v27);
          return 1;
        }
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(void *)&long long v31 = *(void *)&CMYK8_image_sample[2 * v20 + 2];
        if ((void)v31)
        {
          int v18 = 134759444;
          int v23 = 8;
LABEL_27:
          LODWORD(v32) = v23;
          goto LABEL_28;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYKF_image_sample[2 * v20 + 2];
      if ((void)v31)
      {
        int v18 = 538985509;
        int v23 = 20;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v42 && (~DWORD1(v32) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v32) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk64_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v31 = cmyk64_sample_cmyk64;
LABEL_29:
  cmyk64_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

uint64_t cmyk64_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v954 = *MEMORY[0x1E4F143B8];
  float v5 = *(unsigned __int16 **)(v3 + 96);
  uint64_t v6 = *(void *)(v3 + 48);
  int v7 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v3;
  uint64_t v10 = (unint64_t *)*(unsigned int *)(v3 + 4);
  unsigned int v11 = v10 - 1;
  if ((int)v10 < 1) {
    return 0;
  }
  int v12 = *(_DWORD *)(v3 + 8);
  uint64_t v13 = (v12 - 1);
  if (v12 < 1) {
    return 0;
  }
  uint64_t v14 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    int v16 = *(_DWORD *)v3 & 0xFF00;
    int v863 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                     + 16 * *(_DWORD *)v3
                     + 8 * (v5 == 0)
                     + 4 * (v6 == 0));
    uint64_t v858 = v3;
    if (v16 == 1024)
    {
      v953[0] = *(_DWORD *)(v3 + 4);
      v943[0] = v12;
      if (v5) {
        int v17 = *v5;
      }
      else {
        int v17 = 0xFFFF;
      }
      int8x8_t v29 = **(int8x8_t **)(v3 + 88);
      unint64_t v30 = (unint64_t)*(int *)(v3 + 28) >> 3;
      uint64_t v32 = *(int *)(v3 + 12);
      uint64_t v31 = *(int *)(v3 + 16);
      if (v6)
      {
        unint64_t v909 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v905 = (char *)(v6 + 2 * (v32 + v909 * v31));
        unsigned int v901 = 1;
      }
      else
      {
        unint64_t v909 = 0;
        unsigned int v901 = 0;
        v905 = 0;
      }
      long long v38 = (int8x8_t *)(*(void *)(v3 + 40) + 8 * (v32 + v31 * v30));
      v903 = v38;
      unint64_t v899 = (unint64_t)*(int *)(v3 + 28) >> 3;
      if (!v14)
      {
        uint64_t v933 = 0;
        if (v6) {
          long long v42 = v10;
        }
        else {
          long long v42 = 0;
        }
        unint64_t v940 = v909 - (void)v42;
        long long v43 = v10;
        long long v41 = v905;
        goto LABEL_72;
      }
      shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), (int)v10, v12);
      uint64_t v40 = v39;
      unint64_t v940 = v909;
      long long v41 = v905;
      if (v39)
      {
        while (shape_enum_clip_next(v40, (int *)&v942 + 1, &v942, v953, v943))
        {
          uint64_t v933 = v40;
          v38 += v30 * (int)v942 + SHIDWORD(v942);
          long long v43 = (unint64_t *)v953[0];
          unint64_t v63 = v940;
          if (v6) {
            unint64_t v63 = v909 - v953[0];
          }
          unint64_t v940 = v63;
          if (v6) {
            long long v41 = &v905[2 * v909 * (int)v942 + 2 * SHIDWORD(v942)];
          }
          LODWORD(v10) = v953[0];
LABEL_72:
          unint64_t v939 = v30 - (void)v43;
          int v907 = (int)v10;
          switch(v7)
          {
            case 0:
              uint64_t v64 = v939 + (int)v10;
              int v65 = (int)v10;
              unsigned int v66 = v943[0];
              uint64_t v67 = v943[0] - 1;
              uint64_t v68 = (v64 * v67) & (v64 >> 63);
              if (v64 < 0) {
                uint64_t v64 = -v64;
              }
              CGBlt_fillBytes(8 * v65, v943[0], 0, (char *)&v38[v68], 8 * v64);
              if (v6)
              {
                uint64_t v69 = v940 + v65;
                uint64_t v70 = (v69 * v67) & (v69 >> 63);
                if (v69 < 0) {
                  uint64_t v69 = -v69;
                }
                v41 += 2 * v70;
                unint64_t v940 = v69;
                CGBlt_fillBytes(2 * v65, v66, 0, v41, 2 * v69);
              }
              goto LABEL_341;
            case 1:
              uint64_t v71 = (int)v10;
              uint64_t v72 = v939 + (int)v10;
              if (v72 < 0)
              {
                v38 += v72 * (v943[0] - 1);
                uint64_t v72 = -v72;
              }
              uint64_t v73 = *(void *)(v858 + 88);
              if (v73)
              {
                unsigned int v74 = 8 * v10;
                unsigned int v75 = v943[0];
                CGSFillDRAM64((unint64_t)v38, 8 * v72, v74, v943[0], v73, 8, 8, 1, 0, 0);
              }
              else
              {
                int v172 = 8 * v10;
                unsigned int v75 = v943[0];
                CGBlt_fillBytes(v172, v943[0], 0, (char *)v38, 8 * v72);
              }
              long long v38 = v903;
              if (v6)
              {
                v173 = *(int **)(v858 + 96);
                if (!v173) {
                  v173 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
                }
                uint64_t v174 = v940 + v71;
                if ((uint64_t)(v940 + v71) >= 0) {
                  uint64_t v175 = v940 + v71;
                }
                else {
                  uint64_t v175 = -v174;
                }
                v41 += 2 * (((v940 + v71) * (int)(v75 - 1)) & (v174 >> 63));
                unint64_t v940 = v175;
                CGBlt_fillBytes(2 * v907, v75, *v173, v41, 2 * v175);
              }
              goto LABEL_343;
            case 2:
              unsigned int v76 = v10 >> 2;
              int v897 = v10 & 3;
              int v77 = v943[0];
              if (v6)
              {
                unsigned int v894 = v76 + 1;
                do
                {
                  int v936 = v77;
                  if ((int)v10 < 4)
                  {
                    int v82 = (int)v10;
                  }
                  else
                  {
                    uint64_t v78 = (unsigned __int16 *)(v41 + 4);
                    unsigned int v79 = v894;
                    do
                    {
                      cmyk64_DAplusDAM(v38, v78 - 2, *(void *)&v29, v17, (unint64_t)*v38, *(v78 - 2), (unsigned __int16)~(_WORD)v17);
                      cmyk64_DAplusDAM(&v38[1], v78 - 1, *(void *)&v29, v17, *(void *)&v38[1], *(v78 - 1), (unsigned __int16)~(_WORD)v17);
                      cmyk64_DAplusDAM(&v38[2], v78, *(void *)&v29, v17, *(void *)&v38[2], *v78, (unsigned __int16)~(_WORD)v17);
                      unint64_t v81 = (unint64_t)v38[3];
                      v80 = v38 + 3;
                      cmyk64_DAplusDAM(v80, v78 + 1, *(void *)&v29, v17, v81, v78[1], (unsigned __int16)~(_WORD)v17);
                      long long v38 = v80 + 1;
                      v78 += 4 * v901;
                      --v79;
                    }
                    while (v79 > 1);
                    long long v41 = (char *)(v78 - 2);
                    int v82 = v897;
                  }
                  if (v82 < 1)
                  {
                    v84 = (unint64_t *)v38;
                  }
                  else
                  {
                    unsigned int v83 = v82 + 1;
                    v84 = (unint64_t *)v38;
                    do
                    {
                      unint64_t v85 = *v84++;
                      cmyk64_DAplusDAM(v38, v41, *(void *)&v29, v17, v85, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                      --v83;
                      v41 += 2 * v901;
                      long long v38 = (int8x8_t *)v84;
                    }
                    while (v83 > 1);
                  }
                  long long v38 = (int8x8_t *)&v84[v939];
                  v41 += 2 * v940;
                  int v77 = v936 - 1;
                  LODWORD(v10) = v907;
                }
                while (v936 != 1);
              }
              else
              {
                unsigned int v895 = v76 + 1;
                do
                {
                  int v937 = v77;
                  if ((int)v10 < 4)
                  {
                    int v179 = (int)v10;
                  }
                  else
                  {
                    unsigned int v176 = v895;
                    do
                    {
                      cmyk64_DplusDM(v38, *(void *)&v29, (unint64_t)*v38, (unsigned __int16)~(_WORD)v17);
                      cmyk64_DplusDM(&v38[1], *(void *)&v29, *(void *)&v38[1], (unsigned __int16)~(_WORD)v17);
                      cmyk64_DplusDM(&v38[2], *(void *)&v29, *(void *)&v38[2], (unsigned __int16)~(_WORD)v17);
                      unint64_t v178 = (unint64_t)v38[3];
                      v177 = v38 + 3;
                      cmyk64_DplusDM(v177, *(void *)&v29, v178, (unsigned __int16)~(_WORD)v17);
                      long long v38 = v177 + 1;
                      v41 += 8 * v901;
                      --v176;
                    }
                    while (v176 > 1);
                    int v179 = v897;
                  }
                  if (v179 < 1)
                  {
                    v181 = (unint64_t *)v38;
                  }
                  else
                  {
                    unsigned int v180 = v179 + 1;
                    v181 = (unint64_t *)v38;
                    do
                    {
                      unint64_t v182 = *v181++;
                      cmyk64_DplusDM(v38, *(void *)&v29, v182, (unsigned __int16)~(_WORD)v17);
                      --v180;
                      v41 += 2 * v901;
                      long long v38 = (int8x8_t *)v181;
                    }
                    while (v180 > 1);
                  }
                  long long v38 = (int8x8_t *)&v181[v939];
                  v41 += 2 * v940;
                  int v77 = v937 - 1;
                  LODWORD(v10) = v907;
                }
                while (v937 != 1);
              }
              goto LABEL_340;
            case 3:
              v86.i32[0] = HIWORD(v29.i32[0]);
              v86.i32[1] = HIWORD(*(void *)&v29);
              int32x2_t v87 = (int32x2_t)vand_s8(v29, (int8x8_t)0xFFFF0000FFFFLL);
              int v88 = v943[0];
              do
              {
                int v89 = (int)v10;
                do
                {
                  unsigned int v90 = *(unsigned __int16 *)v41;
                  if (v90 == 0xFFFF)
                  {
                    *long long v38 = v29;
                    LOWORD(v90) = v17;
                  }
                  else if (*(_WORD *)v41)
                  {
                    unsigned int v91 = v90 ^ 0xFFFF;
                    int32x2_t v92 = vdup_n_s32(v91);
                    uint32x2_t v93 = (uint32x2_t)vmul_s32(v87, v92);
                    uint32x2_t v94 = (uint32x2_t)vmul_s32(v86, v92);
                    *long long v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)v29, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v93, v93, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v86, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v94, v94, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    unsigned int v90 = v17 - ((v91 * v17 + ((v91 * v17) >> 16) + 1) >> 16);
                  }
                  else
                  {
                    *long long v38 = 0;
                  }
                  *(_WORD *)long long v41 = v90;
                  ++v38;
                  v41 += 2 * v901;
                  --v89;
                }
                while (v89);
                v38 += v939;
                v41 += 2 * v940;
                --v88;
              }
              while (v88);
              goto LABEL_352;
            case 4:
              int32x2_t v95 = (int32x2_t)vand_s8(v29, (int8x8_t)0xFFFF0000FFFFLL);
              v96.i32[0] = HIWORD(v29.i32[0]);
              v96.i32[1] = HIWORD(*(void *)&v29);
              int v97 = v943[0];
              do
              {
                int v98 = (int)v10;
                do
                {
                  unsigned int v99 = *(unsigned __int16 *)v41;
                  if (*(_WORD *)v41)
                  {
                    if (v99 != 0xFFFF)
                    {
                      int32x2_t v101 = vdup_n_s32(v99);
                      uint32x2_t v102 = (uint32x2_t)vmul_s32(v95, v101);
                      uint32x2_t v103 = (uint32x2_t)vmul_s32(v96, v101);
                      *long long v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)v29, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v102, v102, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v96, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v103, v103, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                      unsigned int v100 = v17 - ((v99 * v17 + ((v99 * v17) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      LOWORD(v100) = 0;
                      *long long v38 = 0;
                    }
                  }
                  else
                  {
                    *long long v38 = v29;
                    LOWORD(v100) = v17;
                  }
                  *(_WORD *)long long v41 = v100;
                  ++v38;
                  v41 += 2 * v901;
                  --v98;
                }
                while (v98);
                v38 += v939;
                v41 += 2 * v940;
                --v97;
              }
              while (v97);
              goto LABEL_352;
            case 5:
              int v104 = v943[0];
              do
              {
                int v105 = (int)v10;
                uint64_t v10 = (unint64_t *)v38;
                do
                {
                  unint64_t v106 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(void *)&v29, v17, *(unsigned __int16 *)v41, v106, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                  v41 += 2 * v901;
                  long long v38 = (int8x8_t *)v10;
                  --v105;
                }
                while (v105);
                long long v38 = (int8x8_t *)&v10[v939];
                v41 += 2 * v940;
                --v104;
                LODWORD(v10) = v907;
              }
              while (v104);
              goto LABEL_340;
            case 6:
              int v107 = v943[0];
              do
              {
                int v108 = (int)v10;
                do
                {
                  if (*(_WORD *)v41 != 0xFFFF)
                  {
                    if ((unsigned __int16)~*(_WORD *)v41 == 0xFFFF)
                    {
                      *long long v38 = v29;
                      *(_WORD *)long long v41 = v17;
                    }
                    else
                    {
                      cmyk64_DAplusDAM(v38, v41, (uint64_t)*v38, *(_WORD *)v41, *(void *)&v29, v17, (unsigned __int16)~*(_WORD *)v41);
                    }
                  }
                  ++v38;
                  v41 += 2 * v901;
                  --v108;
                }
                while (v108);
                v38 += v939;
                v41 += 2 * v940;
                --v107;
              }
              while (v107);
              goto LABEL_340;
            case 7:
              int32x2_t v109 = vdup_n_s32((unsigned __int16)~(_WORD)v17);
              int v110 = v943[0];
              if (v6)
              {
                do
                {
                  int v111 = (int)v10;
                  do
                  {
                    int v112 = *(unsigned __int16 *)v41;
                    uint32x2_t v113 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v38, (int8x8_t)0xFFFF0000FFFFLL), v109);
                    v114.i32[0] = HIWORD(v38->u32[0]);
                    v114.i32[1] = HIWORD(*(unint64_t *)v38);
                    uint32x2_t v115 = (uint32x2_t)vmul_s32(v114, v109);
                    *long long v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v38, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v113, v113, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v114, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v115, v115, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    ++v38;
                    *(_WORD *)long long v41 = v112
                                  - (((unsigned __int16)~(_WORD)v17 * v112
                                    + (((unsigned __int16)~(_WORD)v17 * v112) >> 16)
                                    + 1) >> 16);
                    v41 += 2 * v901;
                    --v111;
                  }
                  while (v111);
                  v38 += v939;
                  v41 += 2 * v940;
                  --v110;
                }
                while (v110);
              }
              else
              {
                do
                {
                  int v183 = (int)v10;
                  do
                  {
                    int32x2_t v184 = (int32x2_t)*v38;
                    v185.i32[0] = vshl_u32((uint32x2_t)*v38, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                    v186.i32[0] = v185.i32[0];
                    v186.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v38);
                    int8x8_t v187 = (int8x8_t)vmul_s32(v186, v109);
                    v186.i32[0] = v38->u16[0];
                    v186.i32[1] = HIWORD(*(unint64_t *)v38);
                    uint32x2_t v188 = (uint32x2_t)vmul_s32(v186, v109);
                    v185.i32[1] = HIDWORD(*(unint64_t *)v38);
                    v184.i32[1] = HIWORD(*(unint64_t *)v38);
                    int8x8_t v189 = (int8x8_t)vsub_s32(v184, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v188, v188, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    int32x2_t v190 = vshl_n_s32((int32x2_t)v189, 0x10uLL);
                    v189.i16[1] = 0;
                    v189.i32[1] = v190.i32[1];
                    uint32x2_t v191 = (uint32x2_t)vsub_s32(v185, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)v187, (uint32x2_t)v187, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v187.i32[0] = vshl_u32(v191, (uint32x2_t)0xFFFF00000010).u32[0];
                    v187.i32[1] = v191.u16[2];
                    *v38++ = vorr_s8(v187, v189);
                    v41 += 2 * v901;
                    --v183;
                  }
                  while (v183);
                  v38 += v939;
                  v41 += 2 * v940;
                  --v110;
                }
                while (v110);
              }
              goto LABEL_352;
            case 8:
              int32x2_t v116 = vdup_n_s32(v17);
              int v117 = v943[0];
              uint64_t v118 = 2 * v901;
              if (v6)
              {
                do
                {
                  int v119 = (int)v10;
                  do
                  {
                    int v120 = *(unsigned __int16 *)v41;
                    uint32x2_t v121 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v38, (int8x8_t)0xFFFF0000FFFFLL), v116);
                    v122.i32[0] = HIWORD(v38->u32[0]);
                    v122.i32[1] = HIWORD(*(unint64_t *)v38);
                    uint32x2_t v123 = (uint32x2_t)vmul_s32(v122, v116);
                    *long long v38 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v38, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v121, v121, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v122, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v123, v123, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                    ++v38;
                    *(_WORD *)long long v41 = v120 - ((v17 * v120 + ((v17 * v120) >> 16) + 1) >> 16);
                    v41 += v118;
                    --v119;
                  }
                  while (v119);
                  v38 += v939;
                  v41 += 2 * v940;
                  --v117;
                }
                while (v117);
              }
              else
              {
                do
                {
                  int v192 = (int)v10;
                  do
                  {
                    int32x2_t v193 = (int32x2_t)*v38;
                    v194.i32[0] = vshl_u32((uint32x2_t)*v38, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                    v195.i32[0] = v194.i32[0];
                    v195.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v38);
                    int8x8_t v196 = (int8x8_t)vmul_s32(v195, v116);
                    v195.i32[0] = v38->u16[0];
                    v195.i32[1] = HIWORD(*(unint64_t *)v38);
                    uint32x2_t v197 = (uint32x2_t)vmul_s32(v195, v116);
                    v194.i32[1] = HIDWORD(*(unint64_t *)v38);
                    v193.i32[1] = HIWORD(*(unint64_t *)v38);
                    int8x8_t v198 = (int8x8_t)vsub_s32(v193, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v197, v197, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    int32x2_t v199 = vshl_n_s32((int32x2_t)v198, 0x10uLL);
                    v198.i16[1] = 0;
                    v198.i32[1] = v199.i32[1];
                    uint32x2_t v200 = (uint32x2_t)vsub_s32(v194, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32((uint32x2_t)v196, (uint32x2_t)v196, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                    v196.i32[0] = vshl_u32(v200, (uint32x2_t)0xFFFF00000010).u32[0];
                    v196.i32[1] = v200.u16[2];
                    *v38++ = vorr_s8(v196, v198);
                    v41 += v118;
                    --v192;
                  }
                  while (v192);
                  v38 += v939;
                  v41 += 2 * v940;
                  --v117;
                }
                while (v117);
              }
LABEL_352:
              v943[0] = 0;
              goto LABEL_342;
            case 9:
              int v124 = v943[0];
              do
              {
                int v125 = (int)v10;
                uint64_t v10 = (unint64_t *)v38;
                do
                {
                  unint64_t v126 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(void *)&v29, v17, *(unsigned __int16 *)v41 ^ 0xFFFF, v126, *(unsigned __int16 *)v41, v17);
                  v41 += 2 * v901;
                  long long v38 = (int8x8_t *)v10;
                  --v125;
                }
                while (v125);
                long long v38 = (int8x8_t *)&v10[v939];
                v41 += 2 * v940;
                --v124;
                LODWORD(v10) = v907;
              }
              while (v124);
              goto LABEL_340;
            case 10:
              int v127 = v943[0];
              do
              {
                int v128 = (int)v10;
                uint64_t v10 = (unint64_t *)v38;
                do
                {
                  unint64_t v129 = *v10++;
                  cmyk64_DAMplusDAM((unsigned int *)v38, v41, *(void *)&v29, v17, *(unsigned __int16 *)v41 ^ 0xFFFF, v129, *(unsigned __int16 *)v41, (unsigned __int16)~(_WORD)v17);
                  v41 += 2 * v901;
                  long long v38 = (int8x8_t *)v10;
                  --v128;
                }
                while (v128);
                long long v38 = (int8x8_t *)&v10[v939];
                v41 += 2 * v940;
                --v127;
                LODWORD(v10) = v907;
              }
              while (v127);
              goto LABEL_340;
            case 11:
              int v130 = v943[0];
              uint64_t v131 = 2 * v901;
              if (v6)
              {
                do
                {
                  int v132 = (int)v10;
                  uint64_t v10 = (unint64_t *)v38;
                  do
                  {
                    unint64_t v133 = *v10++;
                    cmyk64_DAplusdDA((int *)v38, (__int16 *)v41, v133, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    v41 += v131;
                    long long v38 = (int8x8_t *)v10;
                    --v132;
                  }
                  while (v132);
                  long long v38 = (int8x8_t *)&v10[v939];
                  v41 += 2 * v940;
                  --v130;
                  LODWORD(v10) = v907;
                }
                while (v130);
              }
              else
              {
                do
                {
                  int v134 = (int)v10;
                  uint64_t v10 = (unint64_t *)v38;
                  do
                  {
                    unint64_t v135 = *v10++;
                    cmyk64_DplusdDA((int *)v38, v135, *(void *)&v29, v17);
                    v41 += v131;
                    long long v38 = (int8x8_t *)v10;
                    --v134;
                  }
                  while (v134);
                  long long v38 = (int8x8_t *)&v10[v939];
                  v41 += 2 * v940;
                  --v130;
                  LODWORD(v10) = v907;
                }
                while (v130);
              }
              goto LABEL_340;
            case 12:
              int v136 = v943[0];
              uint64_t v137 = 2 * v901;
              if (v6)
              {
                do
                {
                  int v138 = (int)v10;
                  uint64_t v10 = (unint64_t *)v38;
                  do
                  {
                    unint64_t v139 = *v10++;
                    cmyk64_DApluslDA((unsigned int *)v38, v41, v139, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    v41 += v137;
                    long long v38 = (int8x8_t *)v10;
                    --v138;
                  }
                  while (v138);
                  long long v38 = (int8x8_t *)&v10[v939];
                  v41 += 2 * v940;
                  --v136;
                  LODWORD(v10) = v907;
                }
                while (v136);
              }
              else
              {
                do
                {
                  int v140 = (int)v10;
                  uint64_t v10 = (unint64_t *)v38;
                  do
                  {
                    unint64_t v141 = *v10++;
                    cmyk64_DpluslD((unsigned int *)v38, v141, *(void *)&v29);
                    v41 += v137;
                    long long v38 = (int8x8_t *)v10;
                    --v140;
                  }
                  while (v140);
                  long long v38 = (int8x8_t *)&v10[v939];
                  v41 += 2 * v940;
                  --v136;
                  LODWORD(v10) = v907;
                }
                while (v136);
              }
LABEL_340:
              v943[0] = 0;
              int v7 = v863;
              goto LABEL_341;
            case 13:
              if (!v17) {
                goto LABEL_342;
              }
              int v142 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAmultiplyPDA_11710((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v143;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAmultiplyPDA_11710((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v142;
                  LODWORD(v10) = v907;
                  if (!v142) {
                    break;
                  }
                }
              }
              break;
            case 14:
              if (!v17) {
                goto LABEL_342;
              }
              int v144 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAscreenPDA_11711((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v145;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAscreenPDA_11711((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v144;
                  LODWORD(v10) = v907;
                  if (!v144) {
                    break;
                  }
                }
              }
              break;
            case 15:
              if (!v17) {
                goto LABEL_342;
              }
              int v146 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAoverlayPDA_11712((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v147;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAoverlayPDA_11712((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v146;
                  LODWORD(v10) = v907;
                  if (!v146) {
                    break;
                  }
                }
              }
              break;
            case 16:
              if (!v17) {
                goto LABEL_342;
              }
              int v148 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAdarkenPDA_11714((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v149;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAdarkenPDA_11714((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v148;
                  LODWORD(v10) = v907;
                  if (!v148) {
                    break;
                  }
                }
              }
              break;
            case 17:
              if (!v17) {
                goto LABEL_342;
              }
              int v150 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAlightenPDA_11713((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v151;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAlightenPDA_11713((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v150;
                  LODWORD(v10) = v907;
                  if (!v150) {
                    break;
                  }
                }
              }
              break;
            case 18:
              if (!v17) {
                goto LABEL_342;
              }
              int v152 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAcolordodgePDA_11715((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v153;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAcolordodgePDA_11715((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v152;
                  LODWORD(v10) = v907;
                  if (!v152) {
                    break;
                  }
                }
              }
              break;
            case 19:
              if (!v17) {
                goto LABEL_342;
              }
              int v154 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAcolorburnPDA_11716((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v155;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAcolorburnPDA_11716((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v154;
                  LODWORD(v10) = v907;
                  if (!v154) {
                    break;
                  }
                }
              }
              break;
            case 20:
              if (!v17) {
                goto LABEL_342;
              }
              int v156 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAsoftlightPDA_11718((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v157;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAsoftlightPDA_11718((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v156;
                  LODWORD(v10) = v907;
                  if (!v156) {
                    break;
                  }
                }
              }
              break;
            case 21:
              if (!v17) {
                goto LABEL_342;
              }
              int v158 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAhardlightPDA_11717((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v159;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAhardlightPDA_11717((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v158;
                  LODWORD(v10) = v907;
                  if (!v158) {
                    break;
                  }
                }
              }
              break;
            case 22:
              if (!v17) {
                goto LABEL_342;
              }
              int v160 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAdifferencePDA_11719((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v161;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAdifferencePDA_11719((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v160;
                  LODWORD(v10) = v907;
                  if (!v160) {
                    break;
                  }
                }
              }
              break;
            case 23:
              if (!v17) {
                goto LABEL_342;
              }
              int v162 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAexclusionPDA_11720((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v163;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAexclusionPDA_11720((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v162;
                  LODWORD(v10) = v907;
                  if (!v162) {
                    break;
                  }
                }
              }
              break;
            case 24:
              if (!v17) {
                goto LABEL_342;
              }
              int v164 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAhuePDA_11721((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v165;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAhuePDA_11721((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v164;
                  LODWORD(v10) = v907;
                  if (!v164) {
                    break;
                  }
                }
              }
              break;
            case 25:
              if (!v17) {
                goto LABEL_342;
              }
              int v166 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAsaturationPDA_11722((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v167;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAsaturationPDA_11722((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v166;
                  LODWORD(v10) = v907;
                  if (!v166) {
                    break;
                  }
                }
              }
              break;
            case 26:
              if (!v17) {
                goto LABEL_342;
              }
              int v168 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAluminosityPDA_11723(*(void *)&v29, v17, (unint64_t)*v38, *(unsigned __int16 *)v41);
                    *(_WORD *)long long v41 = v169;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAluminosityPDA_11723(*(void *)&v29, v17, (unint64_t)*v38, 0xFFFFu);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v168;
                  LODWORD(v10) = v907;
                  if (!v168) {
                    break;
                  }
                }
              }
              break;
            case 27:
              if (!v17) {
                goto LABEL_342;
              }
              int v170 = v943[0];
              while (1)
              {
                if (v6)
                {
                  if (*(_WORD *)v41)
                  {
                    *long long v38 = (int8x8_t)PDAluminosityPDA_11723((unint64_t)*v38, *(unsigned __int16 *)v41, *(void *)&v29, v17);
                    *(_WORD *)long long v41 = v171;
                  }
                  else
                  {
                    *long long v38 = v29;
                    *(_WORD *)long long v41 = v17;
                  }
                }
                else
                {
                  *long long v38 = (int8x8_t)PDAluminosityPDA_11723((unint64_t)*v38, 0xFFFFu, *(void *)&v29, v17);
                }
                ++v38;
                v41 += 2 * v901;
                LODWORD(v10) = v10 - 1;
                if (!v10)
                {
                  v38 += v939;
                  v41 += 2 * v940;
                  --v170;
                  LODWORD(v10) = v907;
                  if (!v170) {
                    break;
                  }
                }
              }
              break;
            default:
              goto LABEL_342;
          }
          v943[0] = 0;
LABEL_341:
          unint64_t v30 = v899;
LABEL_342:
          long long v38 = v903;
LABEL_343:
          uint64_t v40 = v933;
          if (!v933) {
            return 1;
          }
          uint64_t v942 = 0;
        }
        uint64_t v49 = (void *)v40;
LABEL_1080:
        free(v49);
      }
      return 1;
    }
    v953[0] = *(_DWORD *)(v3 + 4);
    v943[0] = v12;
    uint64_t v18 = *(void *)(v3 + 88);
    uint64_t v20 = *(int *)(v3 + 12);
    uint64_t v19 = *(int *)(v3 + 16);
    unint64_t v21 = (unint64_t)*(int *)(v3 + 28) >> 3;
    if (v6)
    {
      unint64_t v861 = (unint64_t)*(int *)(v3 + 32) >> 1;
      v862 = (char *)(v6 + 2 * (v20 + v861 * v19));
      uint64_t v22 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v861 = 0;
      v862 = 0;
      uint64_t v22 = 0;
    }
    unint64_t v860 = *(void *)(v3 + 40) + 8 * (v20 + v19 * v21);
    int v33 = *(_DWORD *)(v3 + 56);
    int v34 = *(_DWORD *)(v3 + 60);
    unint64_t v35 = (unint64_t)*(int *)(v3 + 76) >> 3;
    if (v16 == 256)
    {
      if (v5)
      {
        unint64_t v36 = (unint64_t)*(int *)(v3 + 80) >> 1;
        v5 += v33 + v36 * v34;
        uint64_t v37 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v36 = 0;
        uint64_t v37 = 0;
      }
      v938 = (uint64_t *)(v18 + 8 * (v33 + v34 * v35));
      if (v35 == v21 && (uint64_t)(v860 - (void)v938) >= 1)
      {
        if ((unint64_t)v10 >= (v860 - (unint64_t)v938) >> 3)
        {
          v860 += 8 * v11;
          v938 += v11;
          v862 += 2 * (v22 & v11);
          uint64_t v50 = 0xFFFFFFFFLL;
          unint64_t v35 = (unint64_t)*(int *)(v3 + 28) >> 3;
          v5 += v37 & v11;
          goto LABEL_49;
        }
        if (v860 <= (unint64_t)&v938[v21 * v13 + v11])
        {
          v860 += 8 * v21 * v13;
          unint64_t v35 = -(uint64_t)v21;
          int v62 = &v862[2 * v861 * v13];
          unint64_t v861 = -(uint64_t)v861;
          v862 = v62;
          v5 += v36 * v13;
          v22 &= 1u;
          unint64_t v36 = -(uint64_t)v36;
          v37 &= 1u;
          uint64_t v50 = 1;
          v938 += v21 * v13;
          unint64_t v21 = -(uint64_t)v21;
          goto LABEL_49;
        }
      }
      v22 &= 1u;
      v37 &= 1u;
      uint64_t v50 = 1;
LABEL_49:
      int v816 = *(_DWORD *)(v3 + 60);
      int v817 = *(_DWORD *)(v3 + 56);
      if (v14)
      {
        uint64_t v934 = v22;
        uint64_t v935 = v37;
        unint64_t v902 = 0;
        v904 = 0;
        uint64_t v18 = -1;
        int v867 = v35;
        int v866 = v36;
        goto LABEL_54;
      }
      float v56 = (unint64_t *)((int)v50 * (int)v10);
      unint64_t v900 = v861 - (int)v22 * (int)v10;
      unint64_t v57 = -1;
      int v866 = v36;
      int v867 = v35;
LABEL_62:
      unint64_t v902 = 0;
      uint64_t v868 = 0;
      float v61 = 0;
      v35 -= (unint64_t)v56;
      v36 -= (int)v37 * (int)v10;
      uint64_t v859 = (uint64_t)v938;
      v941 = (int8x8_t *)v860;
      v53 = v862;
      int v54 = v5;
      v906 = v5;
      goto LABEL_353;
    }
    int v867 = *(_DWORD *)(v3 + 64);
    int v866 = *(_DWORD *)(v3 + 68);
    if (v5)
    {
      unint64_t v36 = (unint64_t)*(int *)(v3 + 80) >> 1;
      uint64_t v37 = 1;
    }
    else
    {
      unint64_t v36 = 0;
      uint64_t v37 = 0;
    }
    unint64_t v902 = v18 + 8 * v35 * v866;
    v22 &= 1u;
    if (v14)
    {
      int v816 = *(_DWORD *)(v3 + 60);
      int v817 = *(_DWORD *)(v3 + 56);
      uint64_t v934 = v22;
      uint64_t v935 = v37;
      uint64_t v50 = 1;
      v904 = *(uint64_t **)(v3 + 88);
      v938 = v904;
LABEL_54:
      unint64_t v869 = v21;
      shape_enum_clip_alloc(v2, v3, (int *)v14, v50, v21, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), (int)v10, v12);
      uint64_t v52 = v51;
      uint64_t v859 = (uint64_t)v938;
      v53 = v862;
      unint64_t v900 = v861;
      int v54 = v5;
      v906 = v5;
      unint64_t v55 = v902;
      if (v51) {
        goto LABEL_1058;
      }
      return 1;
    }
    unint64_t v900 = v861 - (v22 * v10);
    if (!v18)
    {
      int v816 = *(_DWORD *)(v3 + 60);
      int v817 = *(_DWORD *)(v3 + 56);
      v938 = 0;
      unint64_t v57 = 0;
      uint64_t v50 = 1;
      float v56 = v10;
      goto LABEL_62;
    }
    uint64_t v58 = v34 % v866;
    int v816 = v34 % v866;
    uint64_t v859 = *(void *)(v3 + 88);
    unint64_t v59 = v18 + 8 * v35 * v58;
    int v60 = v33 % v867;
    v938 = (uint64_t *)(v59 + 8 * v60);
    unint64_t v57 = v59 + 8 * v867;
    int v817 = v60;
    uint64_t v868 = 0;
    if (v5)
    {
      uint64_t v50 = 1;
      uint64_t v37 = 1;
      v941 = (int8x8_t *)v860;
      v53 = v862;
      float v61 = (uint64_t *)(v59 + 8 * v60);
      int v54 = &v5[v36 * v58 + v60];
      v906 = v54;
    }
    else
    {
      int v54 = 0;
      v906 = 0;
      uint64_t v50 = 1;
      v941 = (int8x8_t *)v860;
      v53 = v862;
      float v61 = (uint64_t *)(v59 + 8 * v60);
    }
    float v56 = v10;
LABEL_353:
    uint64_t v934 = v22;
    uint64_t v935 = v37;
    unint64_t v869 = v21;
    unint64_t v896 = v35;
    unint64_t v898 = v21 - (void)v56;
    int v908 = (int)v10;
    unint64_t v893 = v36;
    switch(v863)
    {
      case 0:
        v904 = v61;
        uint64_t v18 = v57;
        uint64_t v201 = v898 - (int)v10;
        v202 = &v941[-(int)v10 + 1];
        if ((int)v50 >= 0)
        {
          v202 = v941;
          uint64_t v201 = v898 + (int)v10;
        }
        unsigned int v203 = v943[0];
        uint64_t v204 = v943[0] - 1;
        v205 = (char *)&v202[(v201 * v204) & (v201 >> 63)];
        if (v201 < 0) {
          uint64_t v201 = -v201;
        }
        CGBlt_fillBytes(8 * v10, v943[0], 0, v205, 8 * v201);
        if (!v22) {
          goto LABEL_1055;
        }
        uint64_t v865 = v50;
        if ((v50 & 0x80000000) != 0)
        {
          uint64_t v206 = v900 - (int)v10;
          v53 += -2 * (int)v10 + 2;
        }
        else
        {
          uint64_t v206 = v900 + (int)v10;
        }
        uint64_t v780 = (v206 * v204) & (v206 >> 63);
        if (v206 < 0) {
          uint64_t v206 = -v206;
        }
        unint64_t v900 = v206;
        v53 += 2 * v780;
        CGBlt_fillBytes(2 * v10, v203, 0, v53, 2 * v206);
        goto LABEL_1053;
      case 1:
        uint64_t v865 = v50;
        int v207 = *(unsigned __int8 *)(v858 + 1);
        if (v207 == 2)
        {
          if ((int)v10 >= 4 && (8 * v867) <= 0x40)
          {
            v4.i32[0] = 8 * v867;
            uint8x8_t v767 = (uint8x8_t)vcnt_s8(v4);
            v767.i16[0] = vaddlv_u8(v767);
            if (v767.i32[0] <= 1u)
            {
              v904 = v61;
              uint64_t v18 = v57;
              int v768 = v943[0];
              CGSFillDRAM64((unint64_t)v941, 8 * (v10 + v898), 8 * v10, v943[0], v859, 8 * v35, 8 * v867, v866, 8 * v817, v816);
              if (!v22) {
                goto LABEL_1054;
              }
              uint64_t v52 = v868;
              if (v935) {
                CGSFillDRAM64((unint64_t)v53, 2 * (v10 + v900), 2 * v10, v768, (uint64_t)v5, 2 * v36, 2 * v867, v866, 2 * v817, v816);
              }
              else {
                CGBlt_fillBytes(2 * v10, v768, -1, v53, 2 * (v10 + v900));
              }
              goto LABEL_1056;
            }
          }
        }
        else if (v207 == 1)
        {
          v904 = v61;
          uint64_t v18 = v57;
          if ((v50 & 0x80000000) != 0)
          {
            uint64_t v208 = v35 - (int)v10;
            v938 += -(int)v10 + 1;
            uint64_t v209 = v898 - (int)v10;
            v941 += -(int)v10 + 1;
          }
          else
          {
            uint64_t v208 = v35 + (int)v10;
            uint64_t v209 = v898 + (int)v10;
          }
          int v799 = v943[0];
          uint64_t v800 = v943[0] - 1;
          if (v208 >= 0) {
            uint64_t v801 = v208;
          }
          else {
            uint64_t v801 = -v208;
          }
          v802 = (char *)&v938[(v208 * v800) & (v208 >> 63)];
          if (v209 >= 0) {
            LODWORD(v803) = v209;
          }
          else {
            uint64_t v803 = -v209;
          }
          unint64_t v804 = v801;
          CGBlt_copyBytes(8 * v10, v943[0], v802, (char *)&v941[(v209 * v800) & (v209 >> 63)], 8 * v801, 8 * v803);
          if (!v22)
          {
            unint64_t v35 = v804;
            goto LABEL_1054;
          }
          unsigned int v805 = v799;
          int v806 = 2 * v10;
          uint64_t v52 = v868;
          if (v935)
          {
            uint64_t v807 = v36 - (int)v10;
            v808 = &v54[-(int)v10 + 1];
            uint64_t v809 = v900 - (int)v10;
            v810 = &v53[-2 * (int)v10 + 2];
            if ((int)v50 >= 0)
            {
              uint64_t v807 = v36 + (int)v10;
              uint64_t v809 = v900 + (int)v10;
              v810 = v53;
              v808 = v54;
            }
            if (v807 >= 0) {
              unint64_t v36 = v807;
            }
            else {
              unint64_t v36 = -v807;
            }
            v811 = (char *)&v808[(v807 * v800) & (v807 >> 63)];
            if (v809 >= 0) {
              uint64_t v812 = v809;
            }
            else {
              uint64_t v812 = -v809;
            }
            unint64_t v900 = v812;
            int v54 = (unsigned __int16 *)v811;
            v53 = &v810[2 * ((v809 * v800) & (v809 >> 63))];
            CGBlt_copyBytes(v806, v805, v811, v53, 2 * v36, 2 * v812);
          }
          else
          {
            uint64_t v813 = v900 - (int)v10;
            v814 = &v53[-2 * (int)v10 + 2];
            if ((int)v50 >= 0)
            {
              uint64_t v813 = v900 + (int)v10;
              v814 = v53;
            }
            if (v813 >= 0) {
              uint64_t v815 = v813;
            }
            else {
              uint64_t v815 = -v813;
            }
            unint64_t v900 = v815;
            v53 = &v814[2 * ((v813 * v800) & (v813 >> 63))];
            CGBlt_fillBytes(v806, v805, -1, v53, 2 * v815);
          }
          unint64_t v35 = v804;
          goto LABEL_1056;
        }
        if (v22)
        {
          uint64_t v769 = 8 * (int)v50;
          uint64_t v770 = 2 * (int)v22;
          if (v37)
          {
            int v771 = v943[0];
            do
            {
              int v772 = (int)v10;
              do
              {
                int8x8_t *v941 = (int8x8_t)*v938;
                *(_WORD *)v53 = *v54;
                v773 = &v938[(int)v50];
                if ((unint64_t)v773 >= v57) {
                  uint64_t v774 = -(uint64_t)v867;
                }
                else {
                  uint64_t v774 = 0;
                }
                v54 += (int)v37 + v774;
                v938 = &v773[v774];
                v941 = (int8x8_t *)((char *)v941 + v769);
                v53 += v770;
                --v772;
              }
              while (v772);
              if (v902)
              {
                v775 = &v61[v35];
                BOOL v776 = (unint64_t)v775 >= v902;
                if ((unint64_t)v775 >= v902) {
                  uint64_t v777 = -(uint64_t)(v35 * v866);
                }
                else {
                  uint64_t v777 = 0;
                }
                float v61 = &v775[v777];
                unint64_t v778 = v57 + 8 * v777;
                if (v776) {
                  uint64_t v779 = -(uint64_t)(v36 * v866);
                }
                else {
                  uint64_t v779 = 0;
                }
                unint64_t v57 = v778 + 8 * v35;
                v938 = v61;
                int v54 = &v906[v36 + v779];
                v906 = v54;
              }
              else
              {
                v938 += v35;
                v54 += v36;
              }
              v941 += v898;
              v53 += 2 * v900;
              --v771;
            }
            while (v771);
          }
          else
          {
            int v790 = v943[0];
            do
            {
              int v791 = (int)v10;
              do
              {
                int8x8_t *v941 = (int8x8_t)*v938;
                *(_WORD *)v53 = -1;
                v792 = &v938[(int)v50];
                if ((unint64_t)v792 >= v57) {
                  uint64_t v793 = -(uint64_t)v867;
                }
                else {
                  uint64_t v793 = 0;
                }
                v54 += v793;
                v938 = &v792[v793];
                v941 = (int8x8_t *)((char *)v941 + v769);
                v53 += v770;
                --v791;
              }
              while (v791);
              if (v902)
              {
                v794 = &v61[v35];
                BOOL v795 = (unint64_t)v794 >= v902;
                if ((unint64_t)v794 >= v902) {
                  uint64_t v796 = -(uint64_t)(v35 * v866);
                }
                else {
                  uint64_t v796 = 0;
                }
                float v61 = &v794[v796];
                unint64_t v797 = v57 + 8 * v796;
                if (v795) {
                  uint64_t v798 = -(uint64_t)(v36 * v866);
                }
                else {
                  uint64_t v798 = 0;
                }
                unint64_t v57 = v797 + 8 * v35;
                v938 = v61;
                int v54 = &v906[v36 + v798];
                v906 = v54;
              }
              else
              {
                v938 += v35;
                v54 += v36;
              }
              v941 += v898;
              v53 += 2 * v900;
              --v790;
            }
            while (v790);
          }
        }
        else
        {
          int v781 = v943[0];
          do
          {
            int v782 = (int)v10;
            do
            {
              int8x8_t *v941 = (int8x8_t)*v938;
              v783 = &v938[(int)v50];
              if ((unint64_t)v783 >= v57) {
                uint64_t v784 = -(uint64_t)v867;
              }
              else {
                uint64_t v784 = 0;
              }
              v54 += (int)v37 + v784;
              v938 = &v783[v784];
              v941 += (int)v50;
              --v782;
            }
            while (v782);
            if (v902)
            {
              v785 = &v61[v35];
              BOOL v786 = (unint64_t)v785 >= v902;
              if ((unint64_t)v785 >= v902) {
                uint64_t v787 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v787 = 0;
              }
              float v61 = &v785[v787];
              unint64_t v788 = v57 + 8 * v787;
              if (v786) {
                uint64_t v789 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v789 = 0;
              }
              unint64_t v57 = v788 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v789];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v781;
          }
          while (v781);
        }
LABEL_1144:
        v904 = v61;
        uint64_t v18 = v57;
        v943[0] = 0;
        goto LABEL_1055;
      case 2:
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v50 = (int)v50;
        v904 = v61;
        if (v22)
        {
          uint64_t v210 = (int)v37;
          int v211 = v943[0];
          uint64_t v212 = 8 * (int)v50;
          uint64_t v910 = (int)v50;
          do
          {
            int v870 = v211;
            int v213 = v908;
            do
            {
              int v214 = *v54;
              if (*v54)
              {
                if (v214 == 0xFFFF)
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = -1;
                }
                else
                {
                  unint64_t v215 = v57;
                  cmyk64_DAplusDAM(v941, v53, *v938, v214, (unint64_t)*v941, *(unsigned __int16 *)v53, v214 ^ 0xFFFF);
                  unint64_t v57 = v215;
                  uint64_t v50 = v910;
                }
              }
              v216 = &v938[v50];
              if ((unint64_t)v216 >= v57) {
                uint64_t v217 = -(uint64_t)v867;
              }
              else {
                uint64_t v217 = 0;
              }
              v54 += v210 + v217;
              v938 = &v216[v217];
              v941 = (int8x8_t *)((char *)v941 + v212);
              v53 += 2 * (int)v22;
              --v213;
            }
            while (v213);
            if (v902)
            {
              v218 = &v904[v35];
              BOOL v219 = (unint64_t)v218 >= v902;
              uint64_t v220 = -(uint64_t)(v35 * v866);
              if ((unint64_t)v218 < v902) {
                uint64_t v220 = 0;
              }
              v221 = &v218[v220];
              unint64_t v222 = v57 + 8 * v220;
              uint64_t v223 = -(uint64_t)(v36 * v866);
              if (!v219) {
                uint64_t v223 = 0;
              }
              unint64_t v57 = v222 + 8 * v35;
              v938 = v221;
              v224 = v221;
              int v54 = &v906[v36 + v223];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
              v224 = v904;
            }
            v904 = v224;
            v941 += v898;
            v53 += 2 * v900;
            int v211 = v870 - 1;
          }
          while (v870 != 1);
        }
        else
        {
          uint64_t v660 = (int)v37;
          uint64_t v836 = -(uint64_t)(v36 * v866);
          int v661 = v943[0];
          do
          {
            int v892 = v661;
            do
            {
              int v662 = *v54;
              if (*v54)
              {
                if (v662 == 0xFFFF)
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                }
                else
                {
                  unint64_t v663 = v57;
                  cmyk64_DplusDM(v941, *v938, (unint64_t)*v941, v662 ^ 0xFFFF);
                  unint64_t v57 = v663;
                }
              }
              v664 = &v938[(int)v50];
              if ((unint64_t)v664 >= v57) {
                uint64_t v665 = -(uint64_t)v867;
              }
              else {
                uint64_t v665 = 0;
              }
              v54 += v660 + v665;
              v938 = &v664[v665];
              v941 += (int)v50;
              LODWORD(v10) = v10 - 1;
            }
            while (v10);
            if (v902)
            {
              v666 = &v904[v896];
              BOOL v667 = (unint64_t)v666 >= v902;
              uint64_t v668 = -(uint64_t)(v896 * v866);
              if ((unint64_t)v666 < v902) {
                uint64_t v668 = 0;
              }
              v669 = &v666[v668];
              unint64_t v670 = v57 + 8 * v668;
              uint64_t v671 = v836;
              if (!v667) {
                uint64_t v671 = 0;
              }
              unint64_t v57 = v670 + 8 * v896;
              v938 = v669;
              v904 = v669;
              v906 += v893 + v671;
              int v54 = v906;
            }
            else
            {
              v938 += v896;
              v54 += v893;
            }
            LODWORD(v10) = v908;
            v941 += v898;
            v53 += 2 * v900;
            int v661 = v892 - 1;
          }
          while (v892 != 1);
        }
        goto LABEL_955;
      case 3:
        if (v37)
        {
          int v225 = v943[0];
          do
          {
            int v226 = (int)v10;
            do
            {
              int v227 = *(unsigned __int16 *)v53;
              if (v227 == 0xFFFF)
              {
                int8x8_t *v941 = (int8x8_t)*v938;
                LOWORD(v227) = *v54;
              }
              else if (*(_WORD *)v53)
              {
                int v228 = *v54;
                unsigned int v229 = v227 ^ 0xFFFF;
                int32x2_t v230 = vdup_n_s32(v229);
                uint32x2_t v231 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v938, (int8x8_t)0xFFFF0000FFFFLL), v230);
                v232.i32[0] = WORD1(*v938);
                v232.i32[1] = HIWORD(*v938);
                uint32x2_t v233 = (uint32x2_t)vmul_s32(v232, v230);
                int8x8_t *v941 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v938, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v231, v231, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v232, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v233, v233, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                int v227 = v228 - ((v229 * v228 + ((v229 * v228) >> 16) + 1) >> 16);
              }
              else
              {
                int8x8_t *v941 = 0;
              }
              *(_WORD *)v53 = v227;
              v234 = &v938[(int)v50];
              if ((unint64_t)v234 >= v57) {
                uint64_t v235 = -(uint64_t)v867;
              }
              else {
                uint64_t v235 = 0;
              }
              v54 += (int)v37 + v235;
              v938 = &v234[v235];
              v941 += (int)v50;
              v53 += 2 * (int)v22;
              --v226;
            }
            while (v226);
            if (v902)
            {
              v236 = &v61[v35];
              BOOL v237 = (unint64_t)v236 >= v902;
              if ((unint64_t)v236 >= v902) {
                uint64_t v238 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v238 = 0;
              }
              float v61 = &v236[v238];
              unint64_t v239 = v57 + 8 * v238;
              if (v237) {
                uint64_t v240 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v240 = 0;
              }
              unint64_t v57 = v239 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v240];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v225;
          }
          while (v225);
        }
        else
        {
          int v672 = v943[0];
          do
          {
            int v673 = (int)v10;
            do
            {
              int v674 = *(unsigned __int16 *)v53;
              if (v674 == 0xFFFF)
              {
                int8x8_t *v941 = (int8x8_t)*v938;
              }
              else if (*(_WORD *)v53)
              {
                int32x2_t v675 = (int32x2_t)*v938;
                v676.i32[0] = vshl_u32(*(uint32x2_t *)v938, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v677.i32[0] = v676.i32[0];
                v677.i32[1] = (unsigned __int16)WORD2(*v938);
                int32x2_t v678 = vdup_n_s32(v674 ^ 0xFFFFu);
                uint32x2_t v679 = (uint32x2_t)vmul_s32(v677, v678);
                v680.i32[0] = (unsigned __int16)*v938;
                v680.i32[1] = HIWORD(*v938);
                uint32x2_t v681 = (uint32x2_t)vmul_s32(v680, v678);
                v676.i32[1] = HIDWORD(*v938);
                uint32x2_t v682 = (uint32x2_t)vsub_s32(v676, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v679, v679, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v675.i32[1] = v680.i32[1];
                int8x8_t v683 = (int8x8_t)vsub_s32(v675, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v681, v681, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                int8x8_t v684 = (int8x8_t)vshl_n_s32((int32x2_t)v683, 0x10uLL);
                v683.i16[1] = 0;
                v683.i32[1] = v684.i32[1];
                v684.i32[0] = vshl_u32(v682, (uint32x2_t)0xFFFF00000010).u32[0];
                v684.i32[1] = v682.u16[2];
                int8x8_t *v941 = vorr_s8(v684, v683);
              }
              else
              {
                int8x8_t *v941 = 0;
              }
              v685 = &v938[(int)v50];
              if ((unint64_t)v685 >= v57) {
                uint64_t v686 = -(uint64_t)v867;
              }
              else {
                uint64_t v686 = 0;
              }
              v938 = &v685[v686];
              v54 += v686;
              v941 += (int)v50;
              v53 += 2 * (int)v22;
              --v673;
            }
            while (v673);
            if (v902)
            {
              v687 = &v61[v35];
              BOOL v688 = (unint64_t)v687 >= v902;
              if ((unint64_t)v687 >= v902) {
                uint64_t v689 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v689 = 0;
              }
              float v61 = &v687[v689];
              unint64_t v690 = v57 + 8 * v689;
              if (v688) {
                uint64_t v691 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v691 = 0;
              }
              unint64_t v57 = v690 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v691];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v672;
          }
          while (v672);
        }
        goto LABEL_1144;
      case 4:
        int v241 = v943[0];
        do
        {
          int v242 = (int)v10;
          do
          {
            unsigned int v243 = *(unsigned __int16 *)v53;
            if (*(_WORD *)v53)
            {
              LOWORD(v244) = ~(_WORD)v243;
              if (v243 != 0xFFFF)
              {
                if (v37) {
                  int v245 = *v54;
                }
                else {
                  int v245 = 0xFFFF;
                }
                int32x2_t v246 = vdup_n_s32(v243);
                uint32x2_t v247 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v938, (int8x8_t)0xFFFF0000FFFFLL), v246);
                v248.i32[0] = WORD1(*v938);
                v248.i32[1] = HIWORD(*v938);
                uint32x2_t v249 = (uint32x2_t)vmul_s32(v248, v246);
                int8x8_t *v941 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v938, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v247, v247, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v248, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v249, v249, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                unsigned int v244 = v245 - ((v243 * v245 + ((v243 * v245) >> 16) + 1) >> 16);
              }
              else
              {
                int8x8_t *v941 = 0;
              }
            }
            else if (v37)
            {
              LOWORD(v244) = *v54;
            }
            else
            {
              LOWORD(v244) = -1;
            }
            *(_WORD *)v53 = v244;
            v250 = &v938[(int)v50];
            if ((unint64_t)v250 >= v57) {
              uint64_t v251 = -(uint64_t)v867;
            }
            else {
              uint64_t v251 = 0;
            }
            v938 = &v250[v251];
            v54 += (int)v37 + v251;
            v941 += (int)v50;
            v53 += 2 * (int)v22;
            --v242;
          }
          while (v242);
          if (v902)
          {
            v252 = &v61[v35];
            BOOL v253 = (unint64_t)v252 >= v902;
            if ((unint64_t)v252 >= v902) {
              uint64_t v254 = -(uint64_t)(v35 * v866);
            }
            else {
              uint64_t v254 = 0;
            }
            float v61 = &v252[v254];
            unint64_t v255 = v57 + 8 * v254;
            if (v253) {
              uint64_t v256 = -(uint64_t)(v36 * v866);
            }
            else {
              uint64_t v256 = 0;
            }
            unint64_t v57 = v255 + 8 * v35;
            v938 = v61;
            int v54 = &v906[v36 + v256];
            v906 = v54;
          }
          else
          {
            v938 += v35;
            v54 += v36;
          }
          v941 += v898;
          v53 += 2 * v900;
          --v241;
        }
        while (v241);
        goto LABEL_1144;
      case 5:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v257 = (int)v50;
        uint64_t v258 = (int)v37;
        uint64_t v818 = -(uint64_t)(v36 * v866);
        uint64_t v837 = -(uint64_t)(v35 * v866);
        int v259 = v943[0];
        do
        {
          int v871 = v259;
          int v260 = v908;
          unint64_t v911 = v57;
          do
          {
            uint64_t v261 = v257;
            cmyk64_DAMplusDAM((unsigned int *)v941, v53, *v938, *v54, *(unsigned __int16 *)v53, (unint64_t)*v941, *(unsigned __int16 *)v53, *v54 ^ 0xFFFF);
            uint64_t v257 = v261;
            unint64_t v57 = v911;
            v262 = &v938[v261];
            if ((unint64_t)v262 >= v911) {
              uint64_t v263 = -(uint64_t)v867;
            }
            else {
              uint64_t v263 = 0;
            }
            v54 += v258 + v263;
            v938 = &v262[v263];
            v941 += (int)v50;
            v53 += 2 * (int)v22;
            --v260;
          }
          while (v260);
          if (v902)
          {
            unint64_t v36 = v893;
            v264 = &v904[v896];
            BOOL v265 = (unint64_t)v264 >= v902;
            uint64_t v266 = v837;
            if ((unint64_t)v264 < v902) {
              uint64_t v266 = 0;
            }
            v267 = &v264[v266];
            unint64_t v268 = v911 + 8 * v266;
            uint64_t v269 = v818;
            if (!v265) {
              uint64_t v269 = 0;
            }
            unint64_t v57 = v268 + 8 * v896;
            v938 = v267;
            v904 = v267;
            v906 += v893 + v269;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v259 = v871 - 1;
        }
        while (v871 != 1);
        goto LABEL_1052;
      case 6:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        unint64_t v270 = v35;
        uint64_t v271 = (int)v37;
        uint64_t v838 = -(uint64_t)(v270 * v866);
        int v272 = v943[0];
        do
        {
          int v872 = v272;
          unint64_t v912 = v57;
          do
          {
            if (*(_WORD *)v53 != 0xFFFF)
            {
              if ((unsigned __int16)~*(_WORD *)v53 == 0xFFFF)
              {
                int8x8_t *v941 = (int8x8_t)*v938;
                if (v37) {
                  __int16 v273 = *v54;
                }
                else {
                  __int16 v273 = -1;
                }
                *(_WORD *)v53 = v273;
              }
              else
              {
                if (v37) {
                  int v274 = *v54;
                }
                else {
                  int v274 = 0xFFFF;
                }
                cmyk64_DAplusDAM(v941, v53, (uint64_t)*v941, *(_WORD *)v53, *v938, v274, (unsigned __int16)~*(_WORD *)v53);
                LODWORD(v37) = v935;
                unint64_t v57 = v912;
              }
            }
            v275 = &v938[(int)v50];
            if ((unint64_t)v275 >= v57) {
              uint64_t v276 = -(uint64_t)v867;
            }
            else {
              uint64_t v276 = 0;
            }
            v54 += v271 + v276;
            v938 = &v275[v276];
            v941 += (int)v50;
            v53 += 2 * (int)v22;
            LODWORD(v10) = v10 - 1;
          }
          while (v10);
          if (v902)
          {
            v277 = &v904[v896];
            BOOL v278 = (unint64_t)v277 >= v902;
            uint64_t v279 = v838;
            if ((unint64_t)v277 < v902) {
              uint64_t v279 = 0;
            }
            v280 = &v277[v279];
            unint64_t v281 = v57 + 8 * v279;
            uint64_t v282 = -(uint64_t)(v36 * v866);
            if (!v278) {
              uint64_t v282 = 0;
            }
            unint64_t v57 = v281 + 8 * v896;
            v938 = v280;
            v904 = v280;
            v906 += v36 + v282;
            int v54 = v906;
          }
          else
          {
            v938 += v896;
            v54 += v36;
          }
          LODWORD(v10) = v908;
          v941 += v898;
          v53 += 2 * v900;
          int v272 = v872 - 1;
        }
        while (v872 != 1);
        goto LABEL_955;
      case 7:
        if (v22)
        {
          int v283 = v943[0];
          do
          {
            int v284 = (int)v10;
            do
            {
              int v285 = *v54;
              if (v285 != 0xFFFF)
              {
                if (*v54)
                {
                  int v286 = *(unsigned __int16 *)v53;
                  unsigned int v287 = v285 ^ 0xFFFF;
                  int32x2_t v288 = vdup_n_s32(v287);
                  uint32x2_t v289 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v941, (int8x8_t)0xFFFF0000FFFFLL), v288);
                  v290.i32[0] = HIWORD(v941->u32[0]);
                  v290.i32[1] = HIWORD(*(unint64_t *)v941);
                  uint32x2_t v291 = (uint32x2_t)vmul_s32(v290, v288);
                  int8x8_t *v941 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v941, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v289, v289, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v290, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v291, v291, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  int v285 = v286 - ((v287 * v286 + ((v287 * v286) >> 16) + 1) >> 16);
                }
                else
                {
                  int8x8_t *v941 = 0;
                }
                *(_WORD *)v53 = v285;
              }
              v292 = &v938[(int)v50];
              if ((unint64_t)v292 >= v57) {
                uint64_t v293 = -(uint64_t)v867;
              }
              else {
                uint64_t v293 = 0;
              }
              v54 += (int)v37 + v293;
              v938 = &v292[v293];
              v941 += (int)v50;
              v53 += 2 * (int)v22;
              --v284;
            }
            while (v284);
            if (v902)
            {
              v294 = &v61[v35];
              BOOL v295 = (unint64_t)v294 >= v902;
              if ((unint64_t)v294 >= v902) {
                uint64_t v296 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v296 = 0;
              }
              float v61 = &v294[v296];
              unint64_t v297 = v57 + 8 * v296;
              if (v295) {
                uint64_t v298 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v298 = 0;
              }
              unint64_t v57 = v297 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v298];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v283;
          }
          while (v283);
        }
        else
        {
          int v692 = v943[0];
          do
          {
            int v693 = (int)v10;
            do
            {
              int v694 = *v54;
              if (v694 != 0xFFFF)
              {
                if (*v54)
                {
                  int32x2_t v695 = (int32x2_t)*v941;
                  v696.i32[0] = vshl_u32((uint32x2_t)*v941, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v697.i32[0] = v696.i32[0];
                  v697.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v941);
                  int32x2_t v698 = vdup_n_s32(v694 ^ 0xFFFFu);
                  uint32x2_t v699 = (uint32x2_t)vmul_s32(v697, v698);
                  v700.i32[0] = v941->u16[0];
                  v700.i32[1] = HIWORD(*(unint64_t *)v941);
                  uint32x2_t v701 = (uint32x2_t)vmul_s32(v700, v698);
                  v696.i32[1] = HIDWORD(*(unint64_t *)v941);
                  uint32x2_t v702 = (uint32x2_t)vsub_s32(v696, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v699, v699, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v695.i32[1] = v700.i32[1];
                  int8x8_t v703 = (int8x8_t)vsub_s32(v695, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v701, v701, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  int8x8_t v704 = (int8x8_t)vshl_n_s32((int32x2_t)v703, 0x10uLL);
                  v703.i16[1] = 0;
                  v703.i32[1] = v704.i32[1];
                  v704.i32[0] = vshl_u32(v702, (uint32x2_t)0xFFFF00000010).u32[0];
                  v704.i32[1] = v702.u16[2];
                  int8x8_t *v941 = vorr_s8(v704, v703);
                }
                else
                {
                  int8x8_t *v941 = 0;
                }
              }
              v705 = &v938[(int)v50];
              if ((unint64_t)v705 >= v57) {
                uint64_t v706 = -(uint64_t)v867;
              }
              else {
                uint64_t v706 = 0;
              }
              v938 = &v705[v706];
              v54 += (int)v37 + v706;
              v941 += (int)v50;
              --v693;
            }
            while (v693);
            if (v902)
            {
              v707 = &v61[v35];
              BOOL v708 = (unint64_t)v707 >= v902;
              if ((unint64_t)v707 >= v902) {
                uint64_t v709 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v709 = 0;
              }
              float v61 = &v707[v709];
              unint64_t v710 = v57 + 8 * v709;
              if (v708) {
                uint64_t v711 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v711 = 0;
              }
              unint64_t v57 = v710 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v711];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v692;
          }
          while (v692);
        }
        goto LABEL_1144;
      case 8:
        if (v22)
        {
          int v299 = v943[0];
          do
          {
            int v300 = (int)v10;
            do
            {
              unsigned int v301 = *v54;
              if (*v54)
              {
                if (v301 != 0xFFFF)
                {
                  int v303 = *(unsigned __int16 *)v53;
                  int32x2_t v304 = vdup_n_s32(v301);
                  uint32x2_t v305 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v941, (int8x8_t)0xFFFF0000FFFFLL), v304);
                  v306.i32[0] = HIWORD(v941->u32[0]);
                  v306.i32[1] = HIWORD(*(unint64_t *)v941);
                  uint32x2_t v307 = (uint32x2_t)vmul_s32(v306, v304);
                  int8x8_t *v941 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v941, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v305, v305, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v306, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v307, v307, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                  int v302 = v303 - ((v301 * v303 + ((v301 * v303) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v302) = 0;
                  int8x8_t *v941 = 0;
                }
                *(_WORD *)v53 = v302;
              }
              v308 = &v938[(int)v50];
              if ((unint64_t)v308 >= v57) {
                uint64_t v309 = -(uint64_t)v867;
              }
              else {
                uint64_t v309 = 0;
              }
              v938 = &v308[v309];
              v54 += (int)v37 + v309;
              v941 += (int)v50;
              v53 += 2 * (int)v22;
              --v300;
            }
            while (v300);
            if (v902)
            {
              v310 = &v61[v35];
              BOOL v311 = (unint64_t)v310 >= v902;
              if ((unint64_t)v310 >= v902) {
                uint64_t v312 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v312 = 0;
              }
              float v61 = &v310[v312];
              unint64_t v313 = v57 + 8 * v312;
              if (v311) {
                uint64_t v314 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v314 = 0;
              }
              unint64_t v57 = v313 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v314];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v299;
          }
          while (v299);
        }
        else
        {
          int v712 = v943[0];
          do
          {
            int v713 = (int)v10;
            do
            {
              unsigned int v714 = *v54;
              if (*v54)
              {
                if (v714 != 0xFFFF)
                {
                  int32x2_t v715 = (int32x2_t)*v941;
                  v716.i32[0] = vshl_u32((uint32x2_t)*v941, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                  v717.i32[0] = v716.i32[0];
                  v717.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v941);
                  int32x2_t v718 = vdup_n_s32(v714);
                  uint32x2_t v719 = (uint32x2_t)vmul_s32(v717, v718);
                  v720.i32[0] = v941->u16[0];
                  v720.i32[1] = HIWORD(*(unint64_t *)v941);
                  uint32x2_t v721 = (uint32x2_t)vmul_s32(v720, v718);
                  v716.i32[1] = HIDWORD(*(unint64_t *)v941);
                  uint32x2_t v722 = (uint32x2_t)vsub_s32(v716, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v719, v719, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  v715.i32[1] = v720.i32[1];
                  int8x8_t v723 = (int8x8_t)vsub_s32(v715, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v721, v721, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                  int8x8_t v724 = (int8x8_t)vshl_n_s32((int32x2_t)v723, 0x10uLL);
                  v723.i16[1] = 0;
                  v723.i32[1] = v724.i32[1];
                  v724.i32[0] = vshl_u32(v722, (uint32x2_t)0xFFFF00000010).u32[0];
                  v724.i32[1] = v722.u16[2];
                  int8x8_t *v941 = vorr_s8(v724, v723);
                }
                else
                {
                  int8x8_t *v941 = 0;
                }
              }
              v725 = &v938[(int)v50];
              if ((unint64_t)v725 >= v57) {
                uint64_t v726 = -(uint64_t)v867;
              }
              else {
                uint64_t v726 = 0;
              }
              v938 = &v725[v726];
              v54 += (int)v37 + v726;
              v941 += (int)v50;
              --v713;
            }
            while (v713);
            if (v902)
            {
              v727 = &v61[v35];
              BOOL v728 = (unint64_t)v727 >= v902;
              if ((unint64_t)v727 >= v902) {
                uint64_t v729 = -(uint64_t)(v35 * v866);
              }
              else {
                uint64_t v729 = 0;
              }
              float v61 = &v727[v729];
              unint64_t v730 = v57 + 8 * v729;
              if (v728) {
                uint64_t v731 = -(uint64_t)(v36 * v866);
              }
              else {
                uint64_t v731 = 0;
              }
              unint64_t v57 = v730 + 8 * v35;
              v938 = v61;
              int v54 = &v906[v36 + v731];
              v906 = v54;
            }
            else
            {
              v938 += v35;
              v54 += v36;
            }
            v941 += v898;
            v53 += 2 * v900;
            --v712;
          }
          while (v712);
        }
        goto LABEL_1144;
      case 9:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v315 = (int)v50;
        uint64_t v316 = (int)v37;
        uint64_t v819 = -(uint64_t)(v36 * v866);
        uint64_t v839 = -(uint64_t)(v35 * v866);
        int v317 = v943[0];
        uint64_t v318 = 8 * (int)v50;
        uint64_t v319 = -(uint64_t)v867;
        do
        {
          int v873 = v317;
          int v320 = v908;
          do
          {
            v913 = v54;
            int v321 = *v54;
            unint64_t v322 = v57;
            uint64_t v323 = v315;
            uint64_t v324 = v319;
            cmyk64_DAMplusDAM((unsigned int *)v941, v53, *v938, v321, *(unsigned __int16 *)v53 ^ 0xFFFF, (unint64_t)*v941, *(unsigned __int16 *)v53, v321);
            uint64_t v319 = v324;
            uint64_t v315 = v323;
            unint64_t v57 = v322;
            v325 = &v938[v323];
            if ((unint64_t)v325 >= v322) {
              uint64_t v326 = v324;
            }
            else {
              uint64_t v326 = 0;
            }
            int v54 = &v913[v316 + v326];
            v938 = &v325[v326];
            v941 = (int8x8_t *)((char *)v941 + v318);
            v53 += 2 * (int)v22;
            --v320;
          }
          while (v320);
          if (v902)
          {
            unint64_t v36 = v893;
            v327 = &v904[v896];
            BOOL v328 = (unint64_t)v327 >= v902;
            uint64_t v329 = v839;
            if ((unint64_t)v327 < v902) {
              uint64_t v329 = 0;
            }
            v330 = &v327[v329];
            unint64_t v331 = v322 + 8 * v329;
            uint64_t v332 = v819;
            if (!v328) {
              uint64_t v332 = 0;
            }
            unint64_t v57 = v331 + 8 * v896;
            v938 = v330;
            v904 = v330;
            v906 += v893 + v332;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v317 = v873 - 1;
        }
        while (v873 != 1);
        goto LABEL_1052;
      case 10:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v333 = (int)v50;
        uint64_t v334 = (int)v37;
        uint64_t v820 = -(uint64_t)(v36 * v866);
        uint64_t v840 = -(uint64_t)(v35 * v866);
        int v335 = v943[0];
        uint64_t v336 = -(uint64_t)v867;
        do
        {
          int v874 = v335;
          int v337 = v908;
          unint64_t v914 = v57;
          do
          {
            v338 = v54;
            int v339 = *v54;
            uint64_t v340 = v333;
            uint64_t v341 = v336;
            cmyk64_DAMplusDAM((unsigned int *)v941, v53, *v938, v339, *(unsigned __int16 *)v53 ^ 0xFFFF, (unint64_t)*v941, *(unsigned __int16 *)v53, v339 ^ 0xFFFF);
            uint64_t v336 = v341;
            uint64_t v333 = v340;
            unint64_t v57 = v914;
            v342 = &v938[v340];
            if ((unint64_t)v342 >= v914) {
              uint64_t v343 = v341;
            }
            else {
              uint64_t v343 = 0;
            }
            int v54 = &v338[v334 + v343];
            v938 = &v342[v343];
            v941 += (int)v50;
            v53 += 2 * (int)v22;
            --v337;
          }
          while (v337);
          if (v902)
          {
            unint64_t v36 = v893;
            v344 = &v904[v896];
            BOOL v345 = (unint64_t)v344 >= v902;
            uint64_t v346 = v840;
            if ((unint64_t)v344 < v902) {
              uint64_t v346 = 0;
            }
            v347 = &v344[v346];
            unint64_t v348 = v914 + 8 * v346;
            uint64_t v349 = v820;
            if (!v345) {
              uint64_t v349 = 0;
            }
            unint64_t v57 = v348 + 8 * v896;
            v938 = v347;
            v904 = v347;
            v906 += v893 + v349;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v335 = v874 - 1;
        }
        while (v874 != 1);
        goto LABEL_1052;
      case 11:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v915 = (int)v50;
        uint64_t v350 = (int)v37;
        if (v22)
        {
          int v351 = v943[0];
          uint64_t v352 = 8 * (int)v50;
          do
          {
            int v875 = v351;
            unint64_t v353 = v57;
            do
            {
              if (v37) {
                int v354 = *v54;
              }
              else {
                int v354 = 0xFFFF;
              }
              cmyk64_DAplusdDA((int *)v941, (__int16 *)v53, (unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v354);
              v355 = &v938[v915];
              if ((unint64_t)v355 >= v353) {
                uint64_t v356 = -(uint64_t)v867;
              }
              else {
                uint64_t v356 = 0;
              }
              v54 += v350 + v356;
              v938 = &v355[v356];
              v941 = (int8x8_t *)((char *)v941 + v352);
              v53 += 2 * (int)v22;
              LODWORD(v10) = v10 - 1;
              LODWORD(v37) = v935;
            }
            while (v10);
            unint64_t v57 = v353;
            if (v902)
            {
              v357 = &v904[v896];
              BOOL v358 = (unint64_t)v357 >= v902;
              uint64_t v359 = -(uint64_t)(v896 * v866);
              if ((unint64_t)v357 < v902) {
                uint64_t v359 = 0;
              }
              v360 = &v357[v359];
              unint64_t v361 = v353 + 8 * v359;
              uint64_t v362 = -(uint64_t)(v36 * v866);
              if (!v358) {
                uint64_t v362 = 0;
              }
              unint64_t v57 = v361 + 8 * v896;
              v938 = v360;
              v904 = v360;
              v906 += v36 + v362;
              int v54 = v906;
            }
            else
            {
              v938 += v896;
              v54 += v36;
            }
            LODWORD(v10) = v908;
            v941 += v898;
            v53 += 2 * v900;
            int v351 = v875 - 1;
          }
          while (v875 != 1);
          goto LABEL_955;
        }
        uint64_t v856 = -(uint64_t)(v36 * v866);
        int v732 = v943[0];
        uint64_t v733 = 8 * (int)v50;
        do
        {
          int v734 = v908;
          unint64_t v735 = v57;
          do
          {
            if (v37) {
              int v736 = *v54;
            }
            else {
              int v736 = 0xFFFF;
            }
            cmyk64_DplusdDA((int *)v941, (unint64_t)*v941, *v938, v736);
            v737 = &v938[v915];
            if ((unint64_t)v737 >= v735) {
              uint64_t v738 = -(uint64_t)v867;
            }
            else {
              uint64_t v738 = 0;
            }
            v54 += v350 + v738;
            v938 = &v737[v738];
            v941 = (int8x8_t *)((char *)v941 + v733);
            --v734;
            LODWORD(v37) = v935;
          }
          while (v734);
          unint64_t v57 = v735;
          if (v902)
          {
            unint64_t v36 = v893;
            v739 = &v904[v896];
            BOOL v740 = (unint64_t)v739 >= v902;
            uint64_t v741 = -(uint64_t)(v896 * v866);
            if ((unint64_t)v739 < v902) {
              uint64_t v741 = 0;
            }
            v742 = &v739[v741];
            unint64_t v743 = v735 + 8 * v741;
            uint64_t v744 = v856;
            if (!v740) {
              uint64_t v744 = 0;
            }
            unint64_t v57 = v743 + 8 * v896;
            v938 = v742;
            v904 = v742;
            v906 += v893 + v744;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          --v732;
        }
        while (v732);
        goto LABEL_1052;
      case 12:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        if (v22)
        {
          uint64_t v916 = (int)v50;
          uint64_t v363 = (int)v37;
          uint64_t v821 = -(uint64_t)(v36 * v866);
          int v364 = v943[0];
          uint64_t v365 = 8 * (int)v50;
          do
          {
            int v876 = v364;
            int v366 = v908;
            unint64_t v367 = v57;
            do
            {
              if (v37) {
                int v368 = *v54;
              }
              else {
                int v368 = 0xFFFF;
              }
              cmyk64_DApluslDA((unsigned int *)v941, v53, (unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v368);
              v369 = &v938[v916];
              if ((unint64_t)v369 >= v367) {
                uint64_t v370 = -(uint64_t)v867;
              }
              else {
                uint64_t v370 = 0;
              }
              v54 += v363 + v370;
              v938 = &v369[v370];
              v941 = (int8x8_t *)((char *)v941 + v365);
              v53 += 2 * (int)v22;
              --v366;
              LODWORD(v37) = v935;
            }
            while (v366);
            unint64_t v57 = v367;
            if (v902)
            {
              unint64_t v36 = v893;
              v371 = &v904[v896];
              BOOL v372 = (unint64_t)v371 >= v902;
              uint64_t v373 = -(uint64_t)(v896 * v866);
              if ((unint64_t)v371 < v902) {
                uint64_t v373 = 0;
              }
              v374 = &v371[v373];
              unint64_t v375 = v367 + 8 * v373;
              uint64_t v376 = v821;
              if (!v372) {
                uint64_t v376 = 0;
              }
              unint64_t v57 = v375 + 8 * v896;
              v938 = v374;
              v904 = v374;
              v906 += v893 + v376;
              int v54 = v906;
            }
            else
            {
              unint64_t v36 = v893;
              v938 += v896;
              v54 += v893;
            }
            v941 += v898;
            v53 += 2 * v900;
            int v364 = v876 - 1;
          }
          while (v876 != 1);
        }
        else
        {
          uint64_t v745 = (int)v37;
          uint64_t v857 = -(uint64_t)(v36 * v866);
          int v746 = v943[0];
          do
          {
            int v932 = v746;
            int v747 = v908;
            do
            {
              unint64_t v748 = v57;
              cmyk64_DpluslD((unsigned int *)v941, (unint64_t)*v941, *v938);
              unint64_t v57 = v748;
              v749 = &v938[(int)v50];
              if ((unint64_t)v749 >= v748) {
                uint64_t v750 = -(uint64_t)v867;
              }
              else {
                uint64_t v750 = 0;
              }
              v54 += v745 + v750;
              v938 = &v749[v750];
              v941 += (int)v50;
              --v747;
            }
            while (v747);
            if (v902)
            {
              unint64_t v36 = v893;
              v751 = &v904[v896];
              BOOL v752 = (unint64_t)v751 >= v902;
              uint64_t v753 = -(uint64_t)(v896 * v866);
              if ((unint64_t)v751 < v902) {
                uint64_t v753 = 0;
              }
              v754 = &v751[v753];
              unint64_t v755 = v748 + 8 * v753;
              uint64_t v756 = v857;
              if (!v752) {
                uint64_t v756 = 0;
              }
              unint64_t v57 = v755 + 8 * v896;
              v938 = v754;
              v904 = v754;
              v906 += v893 + v756;
              int v54 = v906;
            }
            else
            {
              unint64_t v36 = v893;
              v938 += v896;
              v54 += v893;
            }
            v941 += v898;
            v53 += 2 * v900;
            int v746 = v932 - 1;
          }
          while (v932 != 1);
        }
        goto LABEL_1052;
      case 13:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v917 = (int)v50;
        unint64_t v377 = v35;
        uint64_t v378 = (int)v37;
        int v379 = v943[0];
        uint64_t v822 = -(uint64_t)(v36 * v866);
        uint64_t v841 = -(uint64_t)(v377 * v866);
        uint64_t v380 = 8 * (int)v50;
        uint64_t v381 = 2 * (int)v22;
        while (1)
        {
          int v877 = v379;
          int v382 = (int)v10;
          unint64_t v383 = v57;
          do
          {
            if (v37)
            {
              unsigned int v384 = *v54;
              if (!*v54) {
                goto LABEL_600;
              }
              if (v22) {
                goto LABEL_595;
              }
            }
            else
            {
              unsigned int v384 = 0xFFFF;
              if (v22)
              {
LABEL_595:
                if (*(_WORD *)v53)
                {
                  unint64_t v385 = PDAmultiplyPDA_11710((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v384);
                  unint64_t v57 = v383;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v385;
                  *(_WORD *)v53 = v386;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v384;
                }
                goto LABEL_600;
              }
            }
            unint64_t v387 = PDAmultiplyPDA_11710((unint64_t)*v941, 0xFFFFu, *v938, v384);
            unint64_t v57 = v383;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v387;
LABEL_600:
            v388 = &v938[v917];
            if ((unint64_t)v388 >= v57) {
              uint64_t v389 = -(uint64_t)v867;
            }
            else {
              uint64_t v389 = 0;
            }
            v54 += v378 + v389;
            v938 = &v388[v389];
            v941 = (int8x8_t *)((char *)v941 + v380);
            v53 += v381;
            --v382;
          }
          while (v382);
          if (v902)
          {
            unint64_t v36 = v893;
            v390 = &v904[v896];
            BOOL v391 = (unint64_t)v390 >= v902;
            uint64_t v392 = v841;
            if ((unint64_t)v390 < v902) {
              uint64_t v392 = 0;
            }
            v393 = &v390[v392];
            unint64_t v394 = v57 + 8 * v392;
            uint64_t v395 = v822;
            if (!v391) {
              uint64_t v395 = 0;
            }
            unint64_t v57 = v394 + 8 * v896;
            v938 = v393;
            v904 = v393;
            v906 += v893 + v395;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v379 = v877 - 1;
          if (v877 == 1) {
            goto LABEL_1052;
          }
        }
      case 14:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v918 = (int)v50;
        unint64_t v396 = v35;
        uint64_t v397 = (int)v37;
        int v398 = v943[0];
        uint64_t v823 = -(uint64_t)(v36 * v866);
        uint64_t v842 = -(uint64_t)(v396 * v866);
        uint64_t v399 = 8 * (int)v50;
        uint64_t v400 = 2 * (int)v22;
        while (1)
        {
          int v878 = v398;
          int v401 = (int)v10;
          unint64_t v402 = v57;
          do
          {
            if (v37)
            {
              unsigned int v403 = *v54;
              if (!*v54) {
                goto LABEL_623;
              }
              if (v22) {
                goto LABEL_618;
              }
            }
            else
            {
              unsigned int v403 = 0xFFFF;
              if (v22)
              {
LABEL_618:
                if (*(_WORD *)v53)
                {
                  unint64_t v404 = PDAscreenPDA_11711((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v403);
                  unint64_t v57 = v402;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v404;
                  *(_WORD *)v53 = v405;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v403;
                }
                goto LABEL_623;
              }
            }
            unint64_t v406 = PDAscreenPDA_11711((unint64_t)*v941, 0xFFFFu, *v938, v403);
            unint64_t v57 = v402;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v406;
LABEL_623:
            v407 = &v938[v918];
            if ((unint64_t)v407 >= v57) {
              uint64_t v408 = -(uint64_t)v867;
            }
            else {
              uint64_t v408 = 0;
            }
            v54 += v397 + v408;
            v938 = &v407[v408];
            v941 = (int8x8_t *)((char *)v941 + v399);
            v53 += v400;
            --v401;
          }
          while (v401);
          if (v902)
          {
            unint64_t v36 = v893;
            v409 = &v904[v896];
            BOOL v410 = (unint64_t)v409 >= v902;
            uint64_t v411 = v842;
            if ((unint64_t)v409 < v902) {
              uint64_t v411 = 0;
            }
            v412 = &v409[v411];
            unint64_t v413 = v57 + 8 * v411;
            uint64_t v414 = v823;
            if (!v410) {
              uint64_t v414 = 0;
            }
            unint64_t v57 = v413 + 8 * v896;
            v938 = v412;
            v904 = v412;
            v906 += v893 + v414;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v398 = v878 - 1;
          if (v878 == 1) {
            goto LABEL_1052;
          }
        }
      case 15:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v919 = (int)v50;
        unint64_t v415 = v35;
        uint64_t v416 = (int)v37;
        int v417 = v943[0];
        uint64_t v824 = -(uint64_t)(v36 * v866);
        uint64_t v843 = -(uint64_t)(v415 * v866);
        uint64_t v418 = 8 * (int)v50;
        uint64_t v419 = 2 * (int)v22;
        while (1)
        {
          int v879 = v417;
          int v420 = (int)v10;
          unint64_t v421 = v57;
          do
          {
            if (v37)
            {
              unsigned int v422 = *v54;
              if (!*v54) {
                goto LABEL_646;
              }
              if (v22) {
                goto LABEL_641;
              }
            }
            else
            {
              unsigned int v422 = 0xFFFF;
              if (v22)
              {
LABEL_641:
                if (*(_WORD *)v53)
                {
                  unint64_t v423 = PDAoverlayPDA_11712((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v422);
                  unint64_t v57 = v421;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v423;
                  *(_WORD *)v53 = v424;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v422;
                }
                goto LABEL_646;
              }
            }
            unint64_t v425 = PDAoverlayPDA_11712((unint64_t)*v941, 0xFFFFu, *v938, v422);
            unint64_t v57 = v421;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v425;
LABEL_646:
            v426 = &v938[v919];
            if ((unint64_t)v426 >= v57) {
              uint64_t v427 = -(uint64_t)v867;
            }
            else {
              uint64_t v427 = 0;
            }
            v54 += v416 + v427;
            v938 = &v426[v427];
            v941 = (int8x8_t *)((char *)v941 + v418);
            v53 += v419;
            --v420;
          }
          while (v420);
          if (v902)
          {
            unint64_t v36 = v893;
            v428 = &v904[v896];
            BOOL v429 = (unint64_t)v428 >= v902;
            uint64_t v430 = v843;
            if ((unint64_t)v428 < v902) {
              uint64_t v430 = 0;
            }
            v431 = &v428[v430];
            unint64_t v432 = v57 + 8 * v430;
            uint64_t v433 = v824;
            if (!v429) {
              uint64_t v433 = 0;
            }
            unint64_t v57 = v432 + 8 * v896;
            v938 = v431;
            v904 = v431;
            v906 += v893 + v433;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v417 = v879 - 1;
          if (v879 == 1) {
            goto LABEL_1052;
          }
        }
      case 16:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v920 = (int)v50;
        unint64_t v434 = v35;
        uint64_t v435 = (int)v37;
        int v436 = v943[0];
        uint64_t v825 = -(uint64_t)(v36 * v866);
        uint64_t v844 = -(uint64_t)(v434 * v866);
        uint64_t v437 = 8 * (int)v50;
        uint64_t v438 = 2 * (int)v22;
        while (1)
        {
          int v880 = v436;
          int v439 = (int)v10;
          unint64_t v440 = v57;
          do
          {
            if (v37)
            {
              unsigned int v441 = *v54;
              if (!*v54) {
                goto LABEL_669;
              }
              if (v22) {
                goto LABEL_664;
              }
            }
            else
            {
              unsigned int v441 = 0xFFFF;
              if (v22)
              {
LABEL_664:
                if (*(_WORD *)v53)
                {
                  unint64_t v442 = PDAdarkenPDA_11714((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v441);
                  unint64_t v57 = v440;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v442;
                  *(_WORD *)v53 = v443;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v441;
                }
                goto LABEL_669;
              }
            }
            unint64_t v444 = PDAdarkenPDA_11714((unint64_t)*v941, 0xFFFFu, *v938, v441);
            unint64_t v57 = v440;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v444;
LABEL_669:
            v445 = &v938[v920];
            if ((unint64_t)v445 >= v57) {
              uint64_t v446 = -(uint64_t)v867;
            }
            else {
              uint64_t v446 = 0;
            }
            v54 += v435 + v446;
            v938 = &v445[v446];
            v941 = (int8x8_t *)((char *)v941 + v437);
            v53 += v438;
            --v439;
          }
          while (v439);
          if (v902)
          {
            unint64_t v36 = v893;
            v447 = &v904[v896];
            BOOL v448 = (unint64_t)v447 >= v902;
            uint64_t v449 = v844;
            if ((unint64_t)v447 < v902) {
              uint64_t v449 = 0;
            }
            v450 = &v447[v449];
            unint64_t v451 = v57 + 8 * v449;
            uint64_t v452 = v825;
            if (!v448) {
              uint64_t v452 = 0;
            }
            unint64_t v57 = v451 + 8 * v896;
            v938 = v450;
            v904 = v450;
            v906 += v893 + v452;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v436 = v880 - 1;
          if (v880 == 1) {
            goto LABEL_1052;
          }
        }
      case 17:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v921 = (int)v50;
        unint64_t v453 = v35;
        uint64_t v454 = (int)v37;
        int v455 = v943[0];
        uint64_t v826 = -(uint64_t)(v36 * v866);
        uint64_t v845 = -(uint64_t)(v453 * v866);
        uint64_t v456 = 8 * (int)v50;
        uint64_t v457 = 2 * (int)v22;
        while (1)
        {
          int v881 = v455;
          int v458 = (int)v10;
          unint64_t v459 = v57;
          do
          {
            if (v37)
            {
              unsigned int v460 = *v54;
              if (!*v54) {
                goto LABEL_692;
              }
              if (v22) {
                goto LABEL_687;
              }
            }
            else
            {
              unsigned int v460 = 0xFFFF;
              if (v22)
              {
LABEL_687:
                if (*(_WORD *)v53)
                {
                  unint64_t v461 = PDAlightenPDA_11713((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v460);
                  unint64_t v57 = v459;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v461;
                  *(_WORD *)v53 = v462;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v460;
                }
                goto LABEL_692;
              }
            }
            unint64_t v463 = PDAlightenPDA_11713((unint64_t)*v941, 0xFFFFu, *v938, v460);
            unint64_t v57 = v459;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v463;
LABEL_692:
            v464 = &v938[v921];
            if ((unint64_t)v464 >= v57) {
              uint64_t v465 = -(uint64_t)v867;
            }
            else {
              uint64_t v465 = 0;
            }
            v54 += v454 + v465;
            v938 = &v464[v465];
            v941 = (int8x8_t *)((char *)v941 + v456);
            v53 += v457;
            --v458;
          }
          while (v458);
          if (v902)
          {
            unint64_t v36 = v893;
            v466 = &v904[v896];
            BOOL v467 = (unint64_t)v466 >= v902;
            uint64_t v468 = v845;
            if ((unint64_t)v466 < v902) {
              uint64_t v468 = 0;
            }
            v469 = &v466[v468];
            unint64_t v470 = v57 + 8 * v468;
            uint64_t v471 = v826;
            if (!v467) {
              uint64_t v471 = 0;
            }
            unint64_t v57 = v470 + 8 * v896;
            v938 = v469;
            v904 = v469;
            v906 += v893 + v471;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v455 = v881 - 1;
          if (v881 == 1) {
            goto LABEL_1052;
          }
        }
      case 18:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v922 = (int)v50;
        unint64_t v472 = v35;
        uint64_t v473 = (int)v37;
        int v474 = v943[0];
        uint64_t v827 = -(uint64_t)(v36 * v866);
        uint64_t v846 = -(uint64_t)(v472 * v866);
        uint64_t v475 = 8 * (int)v50;
        uint64_t v476 = 2 * (int)v22;
        while (1)
        {
          int v882 = v474;
          int v477 = (int)v10;
          unint64_t v478 = v57;
          do
          {
            if (v37)
            {
              unsigned int v479 = *v54;
              if (!*v54) {
                goto LABEL_715;
              }
              if (v22) {
                goto LABEL_710;
              }
            }
            else
            {
              unsigned int v479 = 0xFFFF;
              if (v22)
              {
LABEL_710:
                if (*(_WORD *)v53)
                {
                  unint64_t v480 = PDAcolordodgePDA_11715((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v479);
                  unint64_t v57 = v478;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v480;
                  *(_WORD *)v53 = v481;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v479;
                }
                goto LABEL_715;
              }
            }
            unint64_t v482 = PDAcolordodgePDA_11715((unint64_t)*v941, 0xFFFFu, *v938, v479);
            unint64_t v57 = v478;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v482;
LABEL_715:
            v483 = &v938[v922];
            if ((unint64_t)v483 >= v57) {
              uint64_t v484 = -(uint64_t)v867;
            }
            else {
              uint64_t v484 = 0;
            }
            v54 += v473 + v484;
            v938 = &v483[v484];
            v941 = (int8x8_t *)((char *)v941 + v475);
            v53 += v476;
            --v477;
          }
          while (v477);
          if (v902)
          {
            unint64_t v36 = v893;
            v485 = &v904[v896];
            BOOL v486 = (unint64_t)v485 >= v902;
            uint64_t v487 = v846;
            if ((unint64_t)v485 < v902) {
              uint64_t v487 = 0;
            }
            v488 = &v485[v487];
            unint64_t v489 = v57 + 8 * v487;
            uint64_t v490 = v827;
            if (!v486) {
              uint64_t v490 = 0;
            }
            unint64_t v57 = v489 + 8 * v896;
            v938 = v488;
            v904 = v488;
            v906 += v893 + v490;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v474 = v882 - 1;
          if (v882 == 1) {
            goto LABEL_1052;
          }
        }
      case 19:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v923 = (int)v50;
        unint64_t v491 = v35;
        uint64_t v492 = (int)v37;
        int v493 = v943[0];
        uint64_t v828 = -(uint64_t)(v36 * v866);
        uint64_t v847 = -(uint64_t)(v491 * v866);
        uint64_t v494 = 8 * (int)v50;
        uint64_t v495 = 2 * (int)v22;
        while (1)
        {
          int v883 = v493;
          int v496 = (int)v10;
          unint64_t v497 = v57;
          do
          {
            if (v37)
            {
              unsigned int v498 = *v54;
              if (!*v54) {
                goto LABEL_738;
              }
              if (v22) {
                goto LABEL_733;
              }
            }
            else
            {
              unsigned int v498 = 0xFFFF;
              if (v22)
              {
LABEL_733:
                if (*(_WORD *)v53)
                {
                  unint64_t v499 = PDAcolorburnPDA_11716((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v498);
                  unint64_t v57 = v497;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v499;
                  *(_WORD *)v53 = v500;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v498;
                }
                goto LABEL_738;
              }
            }
            unint64_t v501 = PDAcolorburnPDA_11716((unint64_t)*v941, 0xFFFFu, *v938, v498);
            unint64_t v57 = v497;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v501;
LABEL_738:
            v502 = &v938[v923];
            if ((unint64_t)v502 >= v57) {
              uint64_t v503 = -(uint64_t)v867;
            }
            else {
              uint64_t v503 = 0;
            }
            v54 += v492 + v503;
            v938 = &v502[v503];
            v941 = (int8x8_t *)((char *)v941 + v494);
            v53 += v495;
            --v496;
          }
          while (v496);
          if (v902)
          {
            unint64_t v36 = v893;
            v504 = &v904[v896];
            BOOL v505 = (unint64_t)v504 >= v902;
            uint64_t v506 = v847;
            if ((unint64_t)v504 < v902) {
              uint64_t v506 = 0;
            }
            v507 = &v504[v506];
            unint64_t v508 = v57 + 8 * v506;
            uint64_t v509 = v828;
            if (!v505) {
              uint64_t v509 = 0;
            }
            unint64_t v57 = v508 + 8 * v896;
            v938 = v507;
            v904 = v507;
            v906 += v893 + v509;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v493 = v883 - 1;
          if (v883 == 1) {
            goto LABEL_1052;
          }
        }
      case 20:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v924 = (int)v50;
        unint64_t v510 = v35;
        uint64_t v511 = (int)v37;
        int v512 = v943[0];
        uint64_t v829 = -(uint64_t)(v36 * v866);
        uint64_t v848 = -(uint64_t)(v510 * v866);
        uint64_t v513 = 8 * (int)v50;
        uint64_t v514 = 2 * (int)v22;
        while (1)
        {
          int v884 = v512;
          int v515 = (int)v10;
          unint64_t v516 = v57;
          do
          {
            if (v37)
            {
              unsigned int v517 = *v54;
              if (!*v54) {
                goto LABEL_761;
              }
              if (v22) {
                goto LABEL_756;
              }
            }
            else
            {
              unsigned int v517 = 0xFFFF;
              if (v22)
              {
LABEL_756:
                if (*(_WORD *)v53)
                {
                  unint64_t v518 = PDAsoftlightPDA_11718((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v517);
                  unint64_t v57 = v516;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v518;
                  *(_WORD *)v53 = v519;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v517;
                }
                goto LABEL_761;
              }
            }
            unint64_t v520 = PDAsoftlightPDA_11718((unint64_t)*v941, 0xFFFFu, *v938, v517);
            unint64_t v57 = v516;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v520;
LABEL_761:
            v521 = &v938[v924];
            if ((unint64_t)v521 >= v57) {
              uint64_t v522 = -(uint64_t)v867;
            }
            else {
              uint64_t v522 = 0;
            }
            v54 += v511 + v522;
            v938 = &v521[v522];
            v941 = (int8x8_t *)((char *)v941 + v513);
            v53 += v514;
            --v515;
          }
          while (v515);
          if (v902)
          {
            unint64_t v36 = v893;
            v523 = &v904[v896];
            BOOL v524 = (unint64_t)v523 >= v902;
            uint64_t v525 = v848;
            if ((unint64_t)v523 < v902) {
              uint64_t v525 = 0;
            }
            v526 = &v523[v525];
            unint64_t v527 = v57 + 8 * v525;
            uint64_t v528 = v829;
            if (!v524) {
              uint64_t v528 = 0;
            }
            unint64_t v57 = v527 + 8 * v896;
            v938 = v526;
            v904 = v526;
            v906 += v893 + v528;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v512 = v884 - 1;
          if (v884 == 1) {
            goto LABEL_1052;
          }
        }
      case 21:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v925 = (int)v50;
        unint64_t v529 = v35;
        uint64_t v530 = (int)v37;
        int v531 = v943[0];
        uint64_t v830 = -(uint64_t)(v36 * v866);
        uint64_t v849 = -(uint64_t)(v529 * v866);
        uint64_t v532 = 8 * (int)v50;
        uint64_t v533 = 2 * (int)v22;
        while (1)
        {
          int v885 = v531;
          int v534 = (int)v10;
          unint64_t v535 = v57;
          do
          {
            if (v37)
            {
              unsigned int v536 = *v54;
              if (!*v54) {
                goto LABEL_784;
              }
              if (v22) {
                goto LABEL_779;
              }
            }
            else
            {
              unsigned int v536 = 0xFFFF;
              if (v22)
              {
LABEL_779:
                if (*(_WORD *)v53)
                {
                  unint64_t v537 = PDAhardlightPDA_11717((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v536);
                  unint64_t v57 = v535;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v537;
                  *(_WORD *)v53 = v538;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v536;
                }
                goto LABEL_784;
              }
            }
            unint64_t v539 = PDAhardlightPDA_11717((unint64_t)*v941, 0xFFFFu, *v938, v536);
            unint64_t v57 = v535;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v539;
LABEL_784:
            v540 = &v938[v925];
            if ((unint64_t)v540 >= v57) {
              uint64_t v541 = -(uint64_t)v867;
            }
            else {
              uint64_t v541 = 0;
            }
            v54 += v530 + v541;
            v938 = &v540[v541];
            v941 = (int8x8_t *)((char *)v941 + v532);
            v53 += v533;
            --v534;
          }
          while (v534);
          if (v902)
          {
            unint64_t v36 = v893;
            v542 = &v904[v896];
            BOOL v543 = (unint64_t)v542 >= v902;
            uint64_t v544 = v849;
            if ((unint64_t)v542 < v902) {
              uint64_t v544 = 0;
            }
            v545 = &v542[v544];
            unint64_t v546 = v57 + 8 * v544;
            uint64_t v547 = v830;
            if (!v543) {
              uint64_t v547 = 0;
            }
            unint64_t v57 = v546 + 8 * v896;
            v938 = v545;
            v904 = v545;
            v906 += v893 + v547;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v531 = v885 - 1;
          if (v885 == 1) {
            goto LABEL_1052;
          }
        }
      case 22:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v926 = (int)v50;
        unint64_t v548 = v35;
        uint64_t v549 = (int)v37;
        int v550 = v943[0];
        uint64_t v831 = -(uint64_t)(v36 * v866);
        uint64_t v850 = -(uint64_t)(v548 * v866);
        uint64_t v551 = 8 * (int)v50;
        uint64_t v552 = 2 * (int)v22;
        while (1)
        {
          int v886 = v550;
          int v553 = (int)v10;
          unint64_t v554 = v57;
          do
          {
            if (v37)
            {
              unsigned int v555 = *v54;
              if (!*v54) {
                goto LABEL_807;
              }
              if (v22) {
                goto LABEL_802;
              }
            }
            else
            {
              unsigned int v555 = 0xFFFF;
              if (v22)
              {
LABEL_802:
                if (*(_WORD *)v53)
                {
                  unint64_t v556 = PDAdifferencePDA_11719((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v555);
                  unint64_t v57 = v554;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v556;
                  *(_WORD *)v53 = v557;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v555;
                }
                goto LABEL_807;
              }
            }
            unint64_t v558 = PDAdifferencePDA_11719((unint64_t)*v941, 0xFFFFu, *v938, v555);
            unint64_t v57 = v554;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v558;
LABEL_807:
            v559 = &v938[v926];
            if ((unint64_t)v559 >= v57) {
              uint64_t v560 = -(uint64_t)v867;
            }
            else {
              uint64_t v560 = 0;
            }
            v54 += v549 + v560;
            v938 = &v559[v560];
            v941 = (int8x8_t *)((char *)v941 + v551);
            v53 += v552;
            --v553;
          }
          while (v553);
          if (v902)
          {
            unint64_t v36 = v893;
            v561 = &v904[v896];
            BOOL v562 = (unint64_t)v561 >= v902;
            uint64_t v563 = v850;
            if ((unint64_t)v561 < v902) {
              uint64_t v563 = 0;
            }
            v564 = &v561[v563];
            unint64_t v565 = v57 + 8 * v563;
            uint64_t v566 = v831;
            if (!v562) {
              uint64_t v566 = 0;
            }
            unint64_t v57 = v565 + 8 * v896;
            v938 = v564;
            v904 = v564;
            v906 += v893 + v566;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v550 = v886 - 1;
          if (v886 == 1) {
            goto LABEL_1052;
          }
        }
      case 23:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v927 = (int)v50;
        unint64_t v567 = v35;
        uint64_t v568 = (int)v37;
        int v569 = v943[0];
        uint64_t v832 = -(uint64_t)(v36 * v866);
        uint64_t v851 = -(uint64_t)(v567 * v866);
        uint64_t v570 = 8 * (int)v50;
        uint64_t v571 = 2 * (int)v22;
        while (1)
        {
          int v887 = v569;
          int v572 = (int)v10;
          unint64_t v573 = v57;
          do
          {
            if (v37)
            {
              unsigned int v574 = *v54;
              if (!*v54) {
                goto LABEL_830;
              }
              if (v22) {
                goto LABEL_825;
              }
            }
            else
            {
              unsigned int v574 = 0xFFFF;
              if (v22)
              {
LABEL_825:
                if (*(_WORD *)v53)
                {
                  unint64_t v575 = PDAexclusionPDA_11720((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v574);
                  unint64_t v57 = v573;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v575;
                  *(_WORD *)v53 = v576;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v574;
                }
                goto LABEL_830;
              }
            }
            unint64_t v577 = PDAexclusionPDA_11720((unint64_t)*v941, 0xFFFFu, *v938, v574);
            unint64_t v57 = v573;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v577;
LABEL_830:
            v578 = &v938[v927];
            if ((unint64_t)v578 >= v57) {
              uint64_t v579 = -(uint64_t)v867;
            }
            else {
              uint64_t v579 = 0;
            }
            v54 += v568 + v579;
            v938 = &v578[v579];
            v941 = (int8x8_t *)((char *)v941 + v570);
            v53 += v571;
            --v572;
          }
          while (v572);
          if (v902)
          {
            unint64_t v36 = v893;
            v580 = &v904[v896];
            BOOL v581 = (unint64_t)v580 >= v902;
            uint64_t v582 = v851;
            if ((unint64_t)v580 < v902) {
              uint64_t v582 = 0;
            }
            v583 = &v580[v582];
            unint64_t v584 = v57 + 8 * v582;
            uint64_t v585 = v832;
            if (!v581) {
              uint64_t v585 = 0;
            }
            unint64_t v57 = v584 + 8 * v896;
            v938 = v583;
            v904 = v583;
            v906 += v893 + v585;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v569 = v887 - 1;
          if (v887 == 1) {
            goto LABEL_1052;
          }
        }
      case 24:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v928 = (int)v50;
        unint64_t v586 = v35;
        uint64_t v587 = (int)v37;
        int v588 = v943[0];
        uint64_t v833 = -(uint64_t)(v36 * v866);
        uint64_t v852 = -(uint64_t)(v586 * v866);
        uint64_t v589 = 8 * (int)v50;
        uint64_t v590 = 2 * (int)v22;
        while (1)
        {
          int v888 = v588;
          int v591 = (int)v10;
          unint64_t v592 = v57;
          do
          {
            if (v37)
            {
              unsigned int v593 = *v54;
              if (!*v54) {
                goto LABEL_853;
              }
              if (v22) {
                goto LABEL_848;
              }
            }
            else
            {
              unsigned int v593 = 0xFFFF;
              if (v22)
              {
LABEL_848:
                if (*(_WORD *)v53)
                {
                  unint64_t v594 = PDAhuePDA_11721((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v593);
                  unint64_t v57 = v592;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v594;
                  *(_WORD *)v53 = v595;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v593;
                }
                goto LABEL_853;
              }
            }
            unint64_t v596 = PDAhuePDA_11721((unint64_t)*v941, 0xFFFFu, *v938, v593);
            unint64_t v57 = v592;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v596;
LABEL_853:
            v597 = &v938[v928];
            if ((unint64_t)v597 >= v57) {
              uint64_t v598 = -(uint64_t)v867;
            }
            else {
              uint64_t v598 = 0;
            }
            v54 += v587 + v598;
            v938 = &v597[v598];
            v941 = (int8x8_t *)((char *)v941 + v589);
            v53 += v590;
            --v591;
          }
          while (v591);
          if (v902)
          {
            unint64_t v36 = v893;
            v599 = &v904[v896];
            BOOL v600 = (unint64_t)v599 >= v902;
            uint64_t v601 = v852;
            if ((unint64_t)v599 < v902) {
              uint64_t v601 = 0;
            }
            v602 = &v599[v601];
            unint64_t v603 = v57 + 8 * v601;
            uint64_t v604 = v833;
            if (!v600) {
              uint64_t v604 = 0;
            }
            unint64_t v57 = v603 + 8 * v896;
            v938 = v602;
            v904 = v602;
            v906 += v893 + v604;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v588 = v888 - 1;
          if (v888 == 1) {
            goto LABEL_1052;
          }
        }
      case 25:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v929 = (int)v50;
        unint64_t v605 = v35;
        uint64_t v606 = (int)v37;
        int v607 = v943[0];
        uint64_t v834 = -(uint64_t)(v36 * v866);
        uint64_t v853 = -(uint64_t)(v605 * v866);
        uint64_t v608 = 8 * (int)v50;
        uint64_t v609 = 2 * (int)v22;
        while (1)
        {
          int v889 = v607;
          int v610 = (int)v10;
          unint64_t v611 = v57;
          do
          {
            if (v37)
            {
              unsigned int v612 = *v54;
              if (!*v54) {
                goto LABEL_876;
              }
              if (v22) {
                goto LABEL_871;
              }
            }
            else
            {
              unsigned int v612 = 0xFFFF;
              if (v22)
              {
LABEL_871:
                if (*(_WORD *)v53)
                {
                  unint64_t v613 = PDAsaturationPDA_11722((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v612);
                  unint64_t v57 = v611;
                  LODWORD(v22) = v934;
                  LODWORD(v37) = v935;
                  int8x8_t *v941 = (int8x8_t)v613;
                  *(_WORD *)v53 = v614;
                }
                else
                {
                  int8x8_t *v941 = (int8x8_t)*v938;
                  *(_WORD *)v53 = v612;
                }
                goto LABEL_876;
              }
            }
            unint64_t v615 = PDAsaturationPDA_11722((unint64_t)*v941, 0xFFFFu, *v938, v612);
            unint64_t v57 = v611;
            LODWORD(v22) = v934;
            LODWORD(v37) = v935;
            int8x8_t *v941 = (int8x8_t)v615;
LABEL_876:
            v616 = &v938[v929];
            if ((unint64_t)v616 >= v57) {
              uint64_t v617 = -(uint64_t)v867;
            }
            else {
              uint64_t v617 = 0;
            }
            v54 += v606 + v617;
            v938 = &v616[v617];
            v941 = (int8x8_t *)((char *)v941 + v608);
            v53 += v609;
            --v610;
          }
          while (v610);
          if (v902)
          {
            unint64_t v36 = v893;
            v618 = &v904[v896];
            BOOL v619 = (unint64_t)v618 >= v902;
            uint64_t v620 = v853;
            if ((unint64_t)v618 < v902) {
              uint64_t v620 = 0;
            }
            v621 = &v618[v620];
            unint64_t v622 = v57 + 8 * v620;
            uint64_t v623 = v834;
            if (!v619) {
              uint64_t v623 = 0;
            }
            unint64_t v57 = v622 + 8 * v896;
            v938 = v621;
            v904 = v621;
            v906 += v893 + v623;
            int v54 = v906;
          }
          else
          {
            unint64_t v36 = v893;
            v938 += v896;
            v54 += v893;
          }
          v941 += v898;
          v53 += 2 * v900;
          int v607 = v889 - 1;
          if (v889 == 1) {
            goto LABEL_1052;
          }
        }
      case 26:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v930 = (int)v50;
        unint64_t v624 = v35;
        uint64_t v625 = (int)v37;
        int v626 = v943[0];
        uint64_t v854 = -(uint64_t)(v624 * v866);
        uint64_t v627 = 8 * (int)v50;
        uint64_t v628 = 2 * (int)v22;
        while (1)
        {
          int v890 = v626;
          unint64_t v629 = v57;
          do
          {
            if (v37)
            {
              unsigned int v630 = *v54;
              if (!*v54) {
                goto LABEL_900;
              }
              if (!v22)
              {
LABEL_898:
                unint64_t v632 = PDAluminosityPDA_11723(*v938, v630, (unint64_t)*v941, 0xFFFFu);
                unint64_t v57 = v629;
                LODWORD(v22) = v934;
                LODWORD(v37) = v935;
                int8x8_t *v941 = (int8x8_t)v632;
                goto LABEL_900;
              }
            }
            else
            {
              unsigned int v630 = 0xFFFF;
              if (!v22) {
                goto LABEL_898;
              }
            }
            unint64_t v631 = *v938;
            if (*(_WORD *)v53)
            {
              unint64_t v631 = PDAluminosityPDA_11723(v631, v630, (unint64_t)*v941, *(unsigned __int16 *)v53);
              unint64_t v57 = v629;
              LODWORD(v22) = v934;
              LODWORD(v37) = v935;
            }
            int8x8_t *v941 = (int8x8_t)v631;
            *(_WORD *)v53 = v630;
LABEL_900:
            v633 = &v938[v930];
            if ((unint64_t)v633 >= v57) {
              uint64_t v634 = -(uint64_t)v867;
            }
            else {
              uint64_t v634 = 0;
            }
            v54 += v625 + v634;
            v938 = &v633[v634];
            v941 = (int8x8_t *)((char *)v941 + v627);
            v53 += v628;
            LODWORD(v10) = v10 - 1;
          }
          while (v10);
          if (v902)
          {
            v635 = &v904[v896];
            BOOL v636 = (unint64_t)v635 >= v902;
            uint64_t v637 = v854;
            if ((unint64_t)v635 < v902) {
              uint64_t v637 = 0;
            }
            v638 = &v635[v637];
            unint64_t v639 = v57 + 8 * v637;
            uint64_t v640 = -(uint64_t)(v36 * v866);
            if (!v636) {
              uint64_t v640 = 0;
            }
            unint64_t v57 = v639 + 8 * v896;
            v938 = v638;
            v904 = v638;
            v906 += v36 + v640;
            int v54 = v906;
          }
          else
          {
            v938 += v896;
            v54 += v36;
          }
          LODWORD(v10) = v908;
          v941 += v898;
          v53 += 2 * v900;
          int v626 = v890 - 1;
          if (v890 == 1)
          {
LABEL_955:
            uint64_t v18 = v57;
            v943[0] = 0;
            float v5 = v864;
            unint64_t v36 = v893;
            goto LABEL_1053;
          }
        }
      case 27:
        v904 = v61;
        v864 = v5;
        uint64_t v865 = v50;
        uint64_t v931 = (int)v50;
        unint64_t v641 = v35;
        uint64_t v642 = (int)v37;
        int v643 = v943[0];
        uint64_t v835 = -(uint64_t)(v36 * v866);
        uint64_t v855 = -(uint64_t)(v641 * v866);
        uint64_t v644 = 8 * (int)v50;
        uint64_t v645 = 2 * (int)v22;
        break;
      default:
        v904 = v61;
        uint64_t v18 = v57;
        goto LABEL_1055;
    }
LABEL_914:
    int v891 = v643;
    int v646 = (int)v10;
    unint64_t v647 = v57;
    while (1)
    {
      if (v37)
      {
        unsigned int v648 = *v54;
        if (!*v54) {
          goto LABEL_923;
        }
        if (!v22) {
          goto LABEL_921;
        }
      }
      else
      {
        unsigned int v648 = 0xFFFF;
        if (!v22)
        {
LABEL_921:
          unint64_t v651 = PDAluminosityPDA_11723((unint64_t)*v941, 0xFFFFu, *v938, v648);
          unint64_t v57 = v647;
          LODWORD(v22) = v934;
          LODWORD(v37) = v935;
          int8x8_t *v941 = (int8x8_t)v651;
          goto LABEL_923;
        }
      }
      if (*(_WORD *)v53)
      {
        unint64_t v649 = PDAluminosityPDA_11723((unint64_t)*v941, *(unsigned __int16 *)v53, *v938, v648);
        unint64_t v57 = v647;
        LODWORD(v22) = v934;
        LODWORD(v37) = v935;
        int8x8_t *v941 = (int8x8_t)v649;
        *(_WORD *)v53 = v650;
      }
      else
      {
        int8x8_t *v941 = (int8x8_t)*v938;
        *(_WORD *)v53 = v648;
      }
LABEL_923:
      v652 = &v938[v931];
      if ((unint64_t)v652 >= v57) {
        uint64_t v653 = -(uint64_t)v867;
      }
      else {
        uint64_t v653 = 0;
      }
      v54 += v642 + v653;
      v938 = &v652[v653];
      v941 = (int8x8_t *)((char *)v941 + v644);
      v53 += v645;
      if (!--v646)
      {
        if (v902)
        {
          unint64_t v36 = v893;
          v654 = &v904[v896];
          BOOL v655 = (unint64_t)v654 >= v902;
          uint64_t v656 = v855;
          if ((unint64_t)v654 < v902) {
            uint64_t v656 = 0;
          }
          v657 = &v654[v656];
          unint64_t v658 = v57 + 8 * v656;
          uint64_t v659 = v835;
          if (!v655) {
            uint64_t v659 = 0;
          }
          unint64_t v57 = v658 + 8 * v896;
          v938 = v657;
          v904 = v657;
          v906 += v893 + v659;
          int v54 = v906;
        }
        else
        {
          unint64_t v36 = v893;
          v938 += v896;
          v54 += v893;
        }
        v941 += v898;
        v53 += 2 * v900;
        int v643 = v891 - 1;
        if (v891 == 1)
        {
LABEL_1052:
          uint64_t v18 = v57;
          v943[0] = 0;
          float v5 = v864;
LABEL_1053:
          unint64_t v35 = v896;
LABEL_1054:
          uint64_t v50 = v865;
LABEL_1055:
          uint64_t v52 = v868;
LABEL_1056:
          unint64_t v55 = v902;
          if (!v52) {
            return 1;
          }
          uint64_t v942 = 0;
LABEL_1058:
          if (!shape_enum_clip_next(v52, (int *)&v942 + 1, &v942, v953, v943))
          {
            uint64_t v49 = (void *)v52;
            goto LABEL_1080;
          }
          uint64_t v868 = v52;
          if (v55)
          {
            unint64_t v902 = v55;
            unint64_t v21 = v869;
            v941 = (int8x8_t *)(v860 + 8 * v869 * (int)v942 + 8 * SHIDWORD(v942));
            int v757 = ((int)v942 + *(_DWORD *)(v858 + 60)) % v866;
            float v56 = (unint64_t *)v953[0];
            int v758 = (HIDWORD(v942) + *(_DWORD *)(v858 + 56)) % v867;
            unint64_t v759 = v859 + 8 * v35 * v757;
            float v61 = (uint64_t *)(v759 + 8 * v758);
            unint64_t v57 = v759 + 8 * v867;
            uint64_t v22 = v934;
            unint64_t v760 = v900;
            if (v934) {
              unint64_t v760 = v861 - v953[0];
            }
            unint64_t v900 = v760;
            if (v934) {
              v53 = &v862[2 * v861 * (int)v942 + 2 * SHIDWORD(v942)];
            }
            if (v935) {
              uint64_t v37 = v935;
            }
            else {
              uint64_t v37 = 0;
            }
            if (v935) {
              int v54 = &v5[v36 * v757 + v758];
            }
            uint64_t v761 = (uint64_t)v906;
            if (v935) {
              uint64_t v761 = (uint64_t)&v5[v36 * v757 + v758];
            }
            v906 = (unsigned __int16 *)v761;
            LODWORD(v10) = v953[0];
            v938 = v61;
            int v816 = ((int)v942 + *(_DWORD *)(v858 + 60)) % v866;
            int v817 = (HIDWORD(v942) + *(_DWORD *)(v858 + 56)) % v867;
          }
          else
          {
            unint64_t v902 = 0;
            int v762 = HIDWORD(v942) * v50;
            LODWORD(v10) = v953[0];
            int v763 = v953[0] * v50;
            unint64_t v21 = v869;
            v941 = (int8x8_t *)(v860 + 8 * v869 * (int)v942 + 8 * HIDWORD(v942) * (int)v50);
            float v56 = (unint64_t *)(v953[0] * (int)v50);
            v938 = (uint64_t *)(v859 + 8 * (int)v942 * v867 + 8 * HIDWORD(v942) * (int)v50);
            unint64_t v35 = v867 - v953[0] * (int)v50;
            uint64_t v22 = v934;
            uint64_t v37 = v935;
            unint64_t v764 = v900;
            if (v934) {
              unint64_t v764 = v861 - v763;
            }
            unint64_t v900 = v764;
            if (v934) {
              v53 = &v862[2 * v861 * (int)v942 + 2 * v762];
            }
            uint64_t v765 = (uint64_t)&v5[(int)v942 * v866 + v762];
            unint64_t v766 = v866 - v763;
            if (v935)
            {
              unint64_t v36 = v766;
              int v54 = (unsigned __int16 *)v765;
            }
            unint64_t v57 = v18;
            float v61 = v904;
          }
          goto LABEL_353;
        }
        goto LABEL_914;
      }
    }
  }
  int v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      cmyk64_mark_constmask(v3, v7);
    }
    else {
      cmyk64_mark_pixelmask(v3, v7);
    }
    return 1;
  }
  int v23 = *(_DWORD *)(v3 + 112);
  int v24 = *(_DWORD *)(v3 + 116);
  unsigned int v25 = (v23 + 15) & 0xFFFFFFF0;
  size_t v26 = v25 * v24;
  if ((int)v26 <= 4096)
  {
    uint64_t v28 = v953;
LABEL_38:
    CGSConvertBitsToMask(v14, *(_DWORD *)(v9 + 124), v28, v25, v23, v24, v15);
    long long v44 = *(_OWORD *)(v9 + 112);
    long long v949 = *(_OWORD *)(v9 + 96);
    long long v950 = v44;
    long long v45 = *(_OWORD *)(v9 + 144);
    long long v951 = *(_OWORD *)(v9 + 128);
    long long v952 = v45;
    long long v46 = *(_OWORD *)(v9 + 48);
    long long v945 = *(_OWORD *)(v9 + 32);
    long long v946 = v46;
    long long v47 = *(_OWORD *)(v9 + 80);
    long long v947 = *(_OWORD *)(v9 + 64);
    long long v948 = v47;
    long long v48 = *(_OWORD *)(v9 + 16);
    *(_OWORD *)v943 = *(_OWORD *)v9;
    long long v944 = v48;
    HIDWORD(v950) = (v23 + 15) & 0xFFFFFFF0;
    *((void *)&v951 + 1) = v28;
    if (BYTE1(v943[0]) << 8 == 1024) {
      cmyk64_mark_constmask((uint64_t)v943, v7);
    }
    else {
      cmyk64_mark_pixelmask((uint64_t)v943, v7);
    }
    if (v28 != (unsigned char *)v953)
    {
      uint64_t v49 = v28;
      goto LABEL_1080;
    }
    return 1;
  }
  float v27 = malloc_type_malloc(v26, 0x8303D2FuLL);
  if (v27)
  {
    uint64_t v28 = v27;
    uint64_t v14 = *(uint16x4_t **)(v9 + 136);
    int v15 = *(_DWORD *)(v9 + 128);
    goto LABEL_38;
  }
  return 1;
}

void cmyk64_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(void, void))
{
  v79[1] = *MEMORY[0x1E4F143B8];
  v8.n128_u64[1] = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v70 = 0u;
  v8.n128_u64[0] = *(unsigned int *)(a2 + 184);
  v8.n128_f32[0] = (float)(v8.n128_f32[0] * 65535.0) + 0.5;
  v67[0] = a3;
  v67[1] = a4;
  LOWORD(v68) = (int)v8.n128_f32[0];
  unint64_t v9 = (unint64_t)*(int *)(a1 + 28) >> 3;
  *(void *)&long long v69 = v9;
  if (*(void *)(a1 + 48)) {
    unint64_t v10 = (unint64_t)*(int *)(a1 + 32) >> 1;
  }
  else {
    unint64_t v10 = 0;
  }
  *(void *)&long long v70 = v10;
  uint64_t v11 = *(void *)(a2 + 120);
  unsigned int v12 = *(_DWORD *)(a2 + 20);
  unsigned int v13 = HIBYTE(v12);
  unsigned int v14 = BYTE2(v12);
  if (v11)
  {
    unint64_t v15 = *(int *)(a2 + 24);
    int v16 = (uint64_t *)(a2 + 104);
    int v17 = (uint64_t *)(a2 + 72);
    uint64_t v18 = (uint64_t *)(a2 + 88);
    unsigned int v19 = v13;
  }
  else
  {
    unint64_t v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int v16 = (uint64_t *)(a2 + 96);
    int v17 = (uint64_t *)(a2 + 64);
    uint64_t v18 = (uint64_t *)(a2 + 80);
    uint64_t v11 = *(void *)(a2 + 112);
    unsigned int v19 = v14;
  }
  uint64_t v20 = *v18;
  uint64_t v21 = *v17;
  uint64_t v22 = *v16;
  char v23 = v19;
  *((void *)&v71 + 1) = v19;
  *((void *)&v70 + 1) = v22;
  *((void *)&v75 + 1) = v15;
  *((void *)&v74 + 1) = v20;
  *((void *)&v73 + 1) = v21;
  *((void *)&v72 + 1) = v11;
  uint64_t v24 = *(void *)(a2 + 128);
  if (v24)
  {
    unint64_t v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    size_t v26 = (uint64_t *)(a2 + 96);
    float v27 = (uint64_t *)(a2 + 64);
    uint64_t v28 = (uint64_t *)(a2 + 80);
    unsigned int v13 = v14;
  }
  else
  {
    unint64_t v25 = *(int *)(a2 + 24);
    size_t v26 = (uint64_t *)(a2 + 104);
    float v27 = (uint64_t *)(a2 + 72);
    uint64_t v28 = (uint64_t *)(a2 + 88);
    uint64_t v24 = *(void *)(a2 + 136);
  }
  unsigned int v66 = &v62;
  uint64_t v29 = *v28;
  uint64_t v30 = *v27;
  uint64_t v31 = *v26;
  *(void *)&long long v72 = v13;
  *(void *)&long long v71 = v31;
  *(void *)&long long v76 = v25;
  *(void *)&long long v75 = v29;
  *(void *)&long long v74 = v30;
  *(void *)&long long v73 = v24;
  uint64_t v32 = *(int *)(a1 + 4);
  MEMORY[0x1F4188790](a1, v8);
  int v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL) {
    uint64_t v37 = (char *)&v62 - v34 - 15;
  }
  else {
    uint64_t v37 = 0;
  }
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    uint64_t v63 = v33;
    uint64_t v64 = a5;
    uint64_t v38 = v36;
    uint64_t v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    uint64_t v33 = v63;
    uint64_t v36 = v38;
    a5 = v64;
  }
  *((void *)&v76 + 1) = v37;
  if (v37)
  {
    uint64_t v39 = v32;
    if (*(void *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        uint64_t v40 = (uint64_t *)(v37 + 8);
        uint64_t v41 = -v33;
        uint64_t v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            unint64_t v45 = 0;
            uint64_t v46 = 0;
          }
          else
          {
            unint64_t v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            char v44 = weights_21383[v43];
            if (v43 - 7 >= 9) {
              unint64_t v45 = -(uint64_t)v15;
            }
            else {
              unint64_t v45 = v15;
            }
            uint64_t v46 = v44 & 0xF;
          }
          uint64_t v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          *uint64_t v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      long long v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *long long v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    long long v48 = v37;
    int v49 = *(_DWORD *)(a1 + 4);
    int v50 = *(_DWORD *)(a1 + 8);
    int v77 = v50;
    int v78 = v49;
    uint64_t v51 = *(int **)(a1 + 136);
    if (v51)
    {
      int v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      int v54 = v53;
      if (v53) {
        goto LABEL_36;
      }
    }
    int v55 = 0;
    int v56 = 0;
    int v54 = 0;
    v79[0] = 0;
    while (1)
    {
      uint64_t v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      uint64_t v58 = *(void *)(a1 + 48);
      int v59 = v55 + *(_DWORD *)(a1 + 12);
      uint64_t v60 = *(void *)(a1 + 40) + 8 * v9 * v57 + 8 * v59;
      uint64_t v61 = v58 + 2 * v10 * v57 + 2 * v59;
      if (!v58) {
        uint64_t v61 = 0;
      }
      *((void *)&v68 + 1) = v60;
      *((void *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54) {
        break;
      }
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      int v56 = v79[0];
      int v55 = HIDWORD(v79[0]);
      unint64_t v9 = v69;
      unint64_t v10 = v70;
    }
    if (v48 != v65) {
      free(v48);
    }
  }
}

unint64_t cmyk64_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  unint64_t v165 = result;
  if (*(void *)(result + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (unint64_t *)*((void *)a2 + 2);
  __n128 v8 = (unsigned __int16 *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v156 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v156 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v155 = *a2;
  uint64_t v154 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v151 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v151 * a4;
  unint64_t v15 = *(unsigned int **)(result + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  uint64_t v17 = 2 * (v8 != 0);
  int v162 = v9;
  int v163 = v6;
  char v161 = v10;
  char v152 = v13;
  uint64_t v153 = v12;
  uint64_t v160 = v17;
  if (*(void *)(result + 176))
  {
    uint64_t v147 = ~(-1 << v13);
    uint64_t v148 = *((void *)a2 + 15);
    uint64_t v149 = *((void *)a2 + 13);
    char v146 = v13 - 4;
    uint64_t v18 = (unsigned int *)(v16 - 4);
    char v19 = 32 - v10;
    int v20 = v9 ^ 0xFFFF;
    uint64_t v144 = a5;
    uint64_t v145 = -v12;
    uint64_t v143 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v148 - v14) | (v14 - v149)) < 0)
      {
        int v25 = 0;
        uint64_t v166 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v147) >> v146) & 0xF;
        char v22 = weights_21383[v21];
        BOOL v23 = (unint64_t)(v21 - 7) >= 9;
        uint64_t v24 = v145;
        if (!v23) {
          uint64_t v24 = v12;
        }
        uint64_t v166 = v24;
        int v25 = v22 & 0xF;
      }
      uint64_t v26 = *(void *)(v165 + 32) + (v14 >> v13) * v12;
      int v158 = a6;
      uint64_t v157 = v14;
      if (v155 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        float v27 = (uint64_t *)v143;
        uint64_t v28 = v144;
        while (1)
        {
          uint64_t v29 = *(v27 - 1);
          uint64_t v30 = *v27;
          uint64_t v31 = v26 + v29;
          if ((unint64_t)v18 >= v26 + v29) {
            uint64_t v32 = (unsigned int *)(v26 + v29);
          }
          else {
            uint64_t v32 = v18;
          }
          if (v32 < v15) {
            uint64_t v32 = v15;
          }
          unsigned int v33 = *v32;
          char v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0) {
            break;
          }
          if (v25)
          {
            unint64_t v45 = (unsigned int *)(v31 + v166);
            if ((unint64_t)v18 < v31 + v166) {
              unint64_t v45 = v18;
            }
            if (v45 < v15) {
              unint64_t v45 = v15;
            }
            int v46 = BLEND8_21385[v25];
            unsigned int v43 = v33 - ((v46 & v33) >> v25);
            unsigned int v44 = (v46 & *v45) >> v25;
            goto LABEL_45;
          }
LABEL_46:
          unsigned int v47 = (v33 << v10) | (v33 >> v19);
          int v48 = BYTE2(v47);
          int v49 = BYTE1(v47);
          int v50 = v47 | v6;
          HIDWORD(v52) = HIBYTE(v47);
          LODWORD(v52) = v47;
          unsigned int v51 = v52 >> 24;
          unsigned int v53 = v48 | (v48 << 8);
          unsigned int v54 = v49 | (v49 << 8);
          int v55 = v50 | (v50 << 8);
          if (v51 <= v53) {
            unsigned int v56 = v53;
          }
          else {
            unsigned int v56 = v51;
          }
          if (v54 <= v56) {
            unsigned int v57 = v56;
          }
          else {
            unsigned int v57 = v54;
          }
          unsigned int v58 = v57 - v51;
          unsigned int v59 = v57 - v53;
          unsigned int v60 = v57 - v54;
          uint64_t v61 = v55 - v57;
          if (v9 != 0xFFFF)
          {
            uint64_t result = v60 * v20 + ((v60 * v20) >> 16) + 1;
            v58 -= (v58 * v20 + ((v58 * v20) >> 16) + 1) >> 16;
            v59 -= (v59 * v20 + ((v59 * v20) >> 16) + 1) >> 16;
            v60 -= WORD1(result);
            uint64_t v61 = v61 - ((v61 * v20 + ((v61 * v20) >> 16) + 1) >> 16);
            v55 -= (v55 * v20 + ((v55 * v20) >> 16) + 1) >> 16;
          }
          if (v8) {
            *__n128 v8 = v55;
          }
          v27 += 2;
          *v7++ = ((unint64_t)(unsigned __int16)v60 << 32) | (v61 << 48) | (v59 << 16) | (unint64_t)(unsigned __int16)v58;
          __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
          if (!--v28) {
            goto LABEL_108;
          }
        }
        unint64_t v35 = (unsigned int *)(v31 + (v30 >> 4));
        if (v18 < v35) {
          unint64_t v35 = v18;
        }
        if (v35 < v15) {
          unint64_t v35 = v15;
        }
        unsigned int v36 = *v35;
        if (v25)
        {
          uint64_t v37 = (unsigned int *)(v31 + v166);
          if (v18 >= v37) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v18;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          unsigned int v39 = *v38;
          uint64_t v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v18 < v40) {
            uint64_t v40 = v18;
          }
          if (v40 < v15) {
            uint64_t v40 = v15;
          }
          int v41 = BLEND8_21385[v25];
          uint64_t result = (v41 & v36) >> v25;
          unsigned int v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          unsigned int v36 = v36 - result + ((v41 & *v40) >> v25);
        }
        int v42 = BLEND8_21385[*v27 & 0xF];
        unsigned int v43 = v33 - ((v42 & v33) >> v34);
        unsigned int v44 = (v42 & v36) >> v34;
LABEL_45:
        unsigned int v33 = v43 + v44;
        goto LABEL_46;
      }
LABEL_108:
      uint64_t v12 = v153;
      v7 += v154;
      LOBYTE(v13) = v152;
      uint64_t v14 = v157 + v151;
      v8 += v156;
      a6 = v158 - 1;
      if (v158 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_108;
    }
    uint64_t v63 = (uint64_t *)v143;
    uint64_t v62 = v144;
    uint64_t result = (unint64_t)BLEND8_21385;
    while (1)
    {
      uint64_t v64 = *(v63 - 1);
      uint64_t v65 = *v63;
      uint64_t v66 = v26 + v64;
      if ((unint64_t)v18 >= v26 + v64) {
        uint64_t v67 = (unsigned int *)(v26 + v64);
      }
      else {
        uint64_t v67 = v18;
      }
      if (v67 < v15) {
        uint64_t v67 = v15;
      }
      unsigned int v68 = *v67;
      char v69 = v65 & 0xF;
      if ((v65 & 0xF) != 0)
      {
        long long v70 = (unsigned int *)(v66 + (v65 >> 4));
        if (v18 < v70) {
          long long v70 = v18;
        }
        if (v70 < v15) {
          long long v70 = v15;
        }
        unsigned int v71 = *v70;
        if (v25)
        {
          long long v72 = (unsigned int *)(v66 + v166);
          if (v18 >= v72) {
            long long v73 = v72;
          }
          else {
            long long v73 = v18;
          }
          if (v73 < v15) {
            long long v73 = v15;
          }
          unsigned int v74 = *v73;
          long long v75 = (unsigned int *)((char *)v72 + (v65 >> 4));
          if (v18 < v75) {
            long long v75 = v18;
          }
          if (v75 < v15) {
            long long v75 = v15;
          }
          int v76 = BLEND8_21385[v25];
          unsigned int v68 = v68 - ((v76 & v68) >> v25) + ((v76 & v74) >> v25);
          unsigned int v71 = v71 - ((v76 & v71) >> v25) + ((v76 & *v75) >> v25);
        }
        int v77 = BLEND8_21385[*v63 & 0xF];
        unsigned int v78 = v68 - ((v77 & v68) >> v69);
        unsigned int v79 = (v77 & v71) >> v69;
      }
      else
      {
        if (!v25) {
          goto LABEL_89;
        }
        v80 = (unsigned int *)(v66 + v166);
        if ((unint64_t)v18 < v66 + v166) {
          v80 = v18;
        }
        if (v80 < v15) {
          v80 = v15;
        }
        int v81 = BLEND8_21385[v25];
        unsigned int v78 = v68 - ((v81 & v68) >> v25);
        unsigned int v79 = (v81 & *v80) >> v25;
      }
      unsigned int v68 = v78 + v79;
LABEL_89:
      unsigned int v82 = (v68 << v10) | (v68 >> v19);
      int v83 = BYTE2(v82);
      int v84 = BYTE1(v82);
      int v85 = v82 | v6;
      HIDWORD(v87) = HIBYTE(v82);
      LODWORD(v87) = v82;
      unsigned int v86 = v87 >> 24;
      unsigned int v88 = v83 | (v83 << 8);
      unsigned int v89 = v84 | (v84 << 8);
      int v90 = v85 | (v85 << 8);
      if (v86 <= v88) {
        unsigned int v91 = v88;
      }
      else {
        unsigned int v91 = v86;
      }
      if (v89 <= v91) {
        unsigned int v92 = v91;
      }
      else {
        unsigned int v92 = v89;
      }
      unsigned int v93 = v92 - v86;
      unsigned int v94 = v92 - v88;
      unsigned int v95 = v92 - v89;
      uint64_t v96 = v90 - v92;
      if (v9 != 0xFFFF)
      {
        v93 -= (v93 * v20 + ((v93 * v20) >> 16) + 1) >> 16;
        v94 -= (v94 * v20 + ((v94 * v20) >> 16) + 1) >> 16;
        v95 -= (v95 * v20 + ((v95 * v20) >> 16) + 1) >> 16;
        uint64_t v96 = v96 - ((v96 * v20 + ((v96 * v20) >> 16) + 1) >> 16);
        v90 -= (v90 * v20 + ((v90 * v20) >> 16) + 1) >> 16;
      }
      unint64_t v97 = ((unint64_t)(unsigned __int16)v95 << 32) | (v96 << 48) | (v94 << 16) | (unint64_t)(unsigned __int16)v93;
      if (v8)
      {
        if ((_WORD)v90)
        {
          if ((unsigned __int16)v90 != 0xFFFF)
          {
            cmyk64_DAplusDAM(v7, v8, v97, v90, *v7, *v8, (unsigned __int16)~(_WORD)v90);
LABEL_106:
            uint64_t result = (unint64_t)BLEND8_21385;
            uint64_t v17 = v160;
            LOBYTE(v10) = v161;
            int v9 = v162;
            int v6 = v163;
            goto LABEL_107;
          }
          *int v7 = v97;
          *__n128 v8 = -1;
        }
      }
      else if ((_WORD)v90)
      {
        if ((unsigned __int16)v90 != 0xFFFF)
        {
          cmyk64_DplusDM(v7, v97, *v7, (unsigned __int16)~(_WORD)v90);
          goto LABEL_106;
        }
        *int v7 = v97;
      }
LABEL_107:
      v63 += 2;
      ++v7;
      __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
      if (!--v62) {
        goto LABEL_108;
      }
    }
  }
  __int16 v167 = (uint64_t *)(v11 + 16 * a3);
  int v98 = v16 - 4;
  char v99 = 32 - v10;
  int v100 = v9 ^ 0xFFFF;
  uint64_t v164 = a5;
  do
  {
    int32x2_t v101 = *(char **)(v165 + 32);
    uint32x2_t v102 = &v101[(v14 >> v13) * v12];
    int v159 = a6;
    if (v155 != 1)
    {
      uint64_t v103 = v14;
      uint32x2_t v123 = v167;
      uint64_t v124 = v164;
      if (a5 < 1) {
        goto LABEL_154;
      }
      while (1)
      {
        uint64_t v125 = *v123;
        v123 += 2;
        unint64_t v126 = &v102[v125];
        if (v98 < &v102[v125]) {
          unint64_t v126 = v98;
        }
        if ((unint64_t)v126 < *(void *)(v165 + 32)) {
          unint64_t v126 = *(char **)(v165 + 32);
        }
        unsigned int v127 = (*(_DWORD *)v126 << v10) | (*(_DWORD *)v126 >> v99);
        int v128 = BYTE2(v127);
        int v129 = BYTE1(v127);
        int v130 = v127 | v6;
        HIDWORD(v132) = HIBYTE(v127);
        LODWORD(v132) = v127;
        unsigned int v131 = v132 >> 24;
        unsigned int v133 = v128 | (v128 << 8);
        unsigned int v134 = v129 | (v129 << 8);
        int v135 = v130 | (v130 << 8);
        if (v131 <= v133) {
          unsigned int v136 = v133;
        }
        else {
          unsigned int v136 = v131;
        }
        if (v134 <= v136) {
          unsigned int v137 = v136;
        }
        else {
          unsigned int v137 = v134;
        }
        unsigned int v138 = v137 - v131;
        unsigned int v139 = v137 - v133;
        unsigned int v140 = v137 - v134;
        uint64_t v141 = v135 - v137;
        if (v9 != 0xFFFF)
        {
          v138 -= (v138 * v100 + ((v138 * v100) >> 16) + 1) >> 16;
          v139 -= (v139 * v100 + ((v139 * v100) >> 16) + 1) >> 16;
          v140 -= (v140 * v100 + ((v140 * v100) >> 16) + 1) >> 16;
          uint64_t v141 = v141 - ((v141 * v100 + ((v141 * v100) >> 16) + 1) >> 16);
          v135 -= (v135 * v100 + ((v135 * v100) >> 16) + 1) >> 16;
        }
        unint64_t v142 = ((unint64_t)(unsigned __int16)v140 << 32) | (v141 << 48) | (v139 << 16) | (unint64_t)(unsigned __int16)v138;
        if (v8)
        {
          if ((_WORD)v135)
          {
            if ((unsigned __int16)v135 != 0xFFFF)
            {
              uint64_t result = (unint64_t)cmyk64_DAplusDAM(v7, v8, v142, v135, *v7, *v8, (unsigned __int16)~(_WORD)v135);
LABEL_152:
              uint64_t v17 = v160;
              LOBYTE(v10) = v161;
              int v9 = v162;
              int v6 = v163;
              goto LABEL_153;
            }
            *int v7 = v142;
            *__n128 v8 = -1;
          }
        }
        else if ((_WORD)v135)
        {
          if ((unsigned __int16)v135 != 0xFFFF)
          {
            uint64_t result = (unint64_t)cmyk64_DplusDM(v7, v142, *v7, (unsigned __int16)~(_WORD)v135);
            goto LABEL_152;
          }
          *int v7 = v142;
        }
LABEL_153:
        ++v7;
        __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
        if (!--v124) {
          goto LABEL_154;
        }
      }
    }
    uint64_t v103 = v14;
    if (a5 >= 1)
    {
      int v104 = v167;
      uint64_t v105 = v164;
      do
      {
        uint64_t v106 = *v104;
        v104 += 2;
        int v107 = &v102[v106];
        if (v98 < &v102[v106]) {
          int v107 = v98;
        }
        if (v107 < v101) {
          int v107 = v101;
        }
        unsigned int v108 = (*(_DWORD *)v107 << v10) | (*(_DWORD *)v107 >> v99);
        int v109 = BYTE2(v108);
        int v110 = BYTE1(v108);
        int v111 = v108 | v6;
        HIDWORD(v113) = HIBYTE(v108);
        LODWORD(v113) = v108;
        unsigned int v112 = v113 >> 24;
        unsigned int v114 = v109 | (v109 << 8);
        unsigned int v115 = v110 | (v110 << 8);
        int v116 = v111 | (v111 << 8);
        if (v112 <= v114) {
          unsigned int v117 = v114;
        }
        else {
          unsigned int v117 = v112;
        }
        if (v115 <= v117) {
          unsigned int v118 = v117;
        }
        else {
          unsigned int v118 = v115;
        }
        unsigned int v119 = v118 - v112;
        unsigned int v120 = v118 - v114;
        unsigned int v121 = v118 - v115;
        uint64_t v122 = v116 - v118;
        if (v9 != 0xFFFF)
        {
          uint64_t result = v121 * v100 + ((v121 * v100) >> 16) + 1;
          v119 -= (v119 * v100 + ((v119 * v100) >> 16) + 1) >> 16;
          v120 -= (v120 * v100 + ((v120 * v100) >> 16) + 1) >> 16;
          v121 -= WORD1(result);
          uint64_t v122 = v122 - ((v122 * v100 + ((v122 * v100) >> 16) + 1) >> 16);
          v116 -= (v116 * v100 + ((v116 * v100) >> 16) + 1) >> 16;
        }
        if (v8) {
          *__n128 v8 = v116;
        }
        *v7++ = ((unint64_t)(unsigned __int16)v121 << 32) | (v122 << 48) | (v120 << 16) | (unint64_t)(unsigned __int16)v119;
        __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
        --v105;
      }
      while (v105);
    }
LABEL_154:
    uint64_t v12 = v153;
    v7 += v154;
    LOBYTE(v13) = v152;
    uint64_t v14 = v103 + v151;
    v8 += v156;
    a6 = v159 - 1;
  }
  while (v159 != 1);
  return result;
}

unint64_t cmyk64_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  unint64_t v167 = result;
  if (*(void *)(result + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (unint64_t *)*((void *)a2 + 2);
  __n128 v8 = (unsigned __int16 *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v158 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v158 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v157 = *a2;
  uint64_t v156 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v153 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v153 * a4;
  unint64_t v15 = *(unsigned int **)(result + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  uint64_t v17 = 2 * (v8 != 0);
  int v164 = v9;
  int v165 = v6;
  char v163 = v10;
  char v154 = v13;
  uint64_t v155 = v12;
  uint64_t v162 = v17;
  if (*(void *)(result + 176))
  {
    uint64_t v149 = ~(-1 << v13);
    uint64_t v150 = *((void *)a2 + 15);
    uint64_t v151 = *((void *)a2 + 13);
    char v148 = v13 - 4;
    uint64_t v18 = (unsigned int *)(v16 - 4);
    char v19 = 32 - v10;
    int v20 = v9 ^ 0xFFFF;
    uint64_t v146 = a5;
    uint64_t v147 = -v12;
    uint64_t v145 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v150 - v14) | (v14 - v151)) < 0)
      {
        int v25 = 0;
        uint64_t v168 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v149) >> v148) & 0xF;
        char v22 = weights_21383[v21];
        BOOL v23 = (unint64_t)(v21 - 7) >= 9;
        uint64_t v24 = v147;
        if (!v23) {
          uint64_t v24 = v12;
        }
        uint64_t v168 = v24;
        int v25 = v22 & 0xF;
      }
      uint64_t v26 = *(void *)(v167 + 32) + (v14 >> v13) * v12;
      int v160 = a6;
      uint64_t v159 = v14;
      if (v157 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        float v27 = (uint64_t *)v145;
        uint64_t v28 = v146;
        while (1)
        {
          uint64_t v29 = *(v27 - 1);
          uint64_t v30 = *v27;
          uint64_t v31 = v26 + v29;
          if ((unint64_t)v18 >= v26 + v29) {
            uint64_t v32 = (unsigned int *)(v26 + v29);
          }
          else {
            uint64_t v32 = v18;
          }
          if (v32 < v15) {
            uint64_t v32 = v15;
          }
          unsigned int v33 = bswap32(*v32);
          char v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0) {
            break;
          }
          if (v25)
          {
            unint64_t v45 = (unsigned int *)(v31 + v168);
            if ((unint64_t)v18 < v31 + v168) {
              unint64_t v45 = v18;
            }
            if (v45 < v15) {
              unint64_t v45 = v15;
            }
            int v46 = BLEND8_21385[v25];
            unsigned int v43 = v33 - ((v46 & v33) >> v25);
            unsigned int v44 = (bswap32(*v45) & v46) >> v25;
            goto LABEL_45;
          }
LABEL_46:
          unsigned int v47 = (v33 << v10) | (v33 >> v19);
          int v48 = BYTE2(v47);
          int v49 = BYTE1(v47);
          int v50 = v47 | v6;
          HIDWORD(v52) = HIBYTE(v47);
          LODWORD(v52) = v47;
          unsigned int v51 = v52 >> 24;
          unsigned int v53 = v48 | (v48 << 8);
          unsigned int v54 = v49 | (v49 << 8);
          int v55 = v50 | (v50 << 8);
          if (v51 <= v53) {
            unsigned int v56 = v53;
          }
          else {
            unsigned int v56 = v51;
          }
          if (v54 <= v56) {
            unsigned int v57 = v56;
          }
          else {
            unsigned int v57 = v54;
          }
          unsigned int v58 = v57 - v51;
          unsigned int v59 = v57 - v53;
          unsigned int v60 = v57 - v54;
          uint64_t v61 = v55 - v57;
          if (v9 != 0xFFFF)
          {
            uint64_t result = v60 * v20 + ((v60 * v20) >> 16) + 1;
            v58 -= (v58 * v20 + ((v58 * v20) >> 16) + 1) >> 16;
            v59 -= (v59 * v20 + ((v59 * v20) >> 16) + 1) >> 16;
            v60 -= WORD1(result);
            uint64_t v61 = v61 - ((v61 * v20 + ((v61 * v20) >> 16) + 1) >> 16);
            v55 -= (v55 * v20 + ((v55 * v20) >> 16) + 1) >> 16;
          }
          if (v8) {
            *__n128 v8 = v55;
          }
          v27 += 2;
          *v7++ = ((unint64_t)(unsigned __int16)v60 << 32) | (v61 << 48) | (v59 << 16) | (unint64_t)(unsigned __int16)v58;
          __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
          if (!--v28) {
            goto LABEL_108;
          }
        }
        unint64_t v35 = (unsigned int *)(v31 + (v30 >> 4));
        if (v18 < v35) {
          unint64_t v35 = v18;
        }
        if (v35 < v15) {
          unint64_t v35 = v15;
        }
        unsigned int v36 = bswap32(*v35);
        if (v25)
        {
          uint64_t v37 = (unsigned int *)(v31 + v168);
          if (v18 >= v37) {
            uint64_t v38 = v37;
          }
          else {
            uint64_t v38 = v18;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          unsigned int v39 = bswap32(*v38);
          uint64_t v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v18 < v40) {
            uint64_t v40 = v18;
          }
          if (v40 < v15) {
            uint64_t v40 = v15;
          }
          int v41 = BLEND8_21385[v25];
          uint64_t result = (v41 & v36) >> v25;
          unsigned int v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          unsigned int v36 = v36 - result + ((bswap32(*v40) & v41) >> v25);
        }
        int v42 = BLEND8_21385[*v27 & 0xF];
        unsigned int v43 = v33 - ((v42 & v33) >> v34);
        unsigned int v44 = (v42 & v36) >> v34;
LABEL_45:
        unsigned int v33 = v43 + v44;
        goto LABEL_46;
      }
LABEL_108:
      uint64_t v12 = v155;
      v7 += v156;
      LOBYTE(v13) = v154;
      uint64_t v14 = v159 + v153;
      v8 += v158;
      a6 = v160 - 1;
      if (v160 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_108;
    }
    uint64_t v63 = (uint64_t *)v145;
    uint64_t v62 = v146;
    uint64_t result = (unint64_t)BLEND8_21385;
    while (1)
    {
      uint64_t v64 = *(v63 - 1);
      uint64_t v65 = *v63;
      uint64_t v66 = v26 + v64;
      if ((unint64_t)v18 >= v26 + v64) {
        uint64_t v67 = (unsigned int *)(v26 + v64);
      }
      else {
        uint64_t v67 = v18;
      }
      if (v67 < v15) {
        uint64_t v67 = v15;
      }
      unsigned int v68 = bswap32(*v67);
      char v69 = v65 & 0xF;
      if ((v65 & 0xF) != 0)
      {
        long long v70 = (unsigned int *)(v66 + (v65 >> 4));
        if (v18 < v70) {
          long long v70 = v18;
        }
        if (v70 < v15) {
          long long v70 = v15;
        }
        unsigned int v71 = bswap32(*v70);
        if (v25)
        {
          long long v72 = (unsigned int *)(v66 + v168);
          if (v18 >= v72) {
            long long v73 = v72;
          }
          else {
            long long v73 = v18;
          }
          if (v73 < v15) {
            long long v73 = v15;
          }
          unsigned int v74 = bswap32(*v73);
          long long v75 = (unsigned int *)((char *)v72 + (v65 >> 4));
          if (v18 < v75) {
            long long v75 = v18;
          }
          if (v75 < v15) {
            long long v75 = v15;
          }
          int v76 = BLEND8_21385[v25];
          unsigned int v68 = v68 - ((v76 & v68) >> v25) + ((v76 & v74) >> v25);
          unsigned int v71 = v71 - ((v76 & v71) >> v25) + ((bswap32(*v75) & v76) >> v25);
        }
        int v77 = BLEND8_21385[*v63 & 0xF];
        unsigned int v78 = v68 - ((v77 & v68) >> v69);
        unsigned int v79 = (v77 & v71) >> v69;
      }
      else
      {
        if (!v25) {
          goto LABEL_89;
        }
        v80 = (unsigned int *)(v66 + v168);
        if ((unint64_t)v18 < v66 + v168) {
          v80 = v18;
        }
        if (v80 < v15) {
          v80 = v15;
        }
        int v81 = BLEND8_21385[v25];
        unsigned int v78 = v68 - ((v81 & v68) >> v25);
        unsigned int v79 = (bswap32(*v80) & v81) >> v25;
      }
      unsigned int v68 = v78 + v79;
LABEL_89:
      unsigned int v82 = (v68 << v10) | (v68 >> v19);
      int v83 = BYTE2(v82);
      int v84 = BYTE1(v82);
      int v85 = v82 | v6;
      HIDWORD(v87) = HIBYTE(v82);
      LODWORD(v87) = v82;
      unsigned int v86 = v87 >> 24;
      unsigned int v88 = v83 | (v83 << 8);
      unsigned int v89 = v84 | (v84 << 8);
      int v90 = v85 | (v85 << 8);
      if (v86 <= v88) {
        unsigned int v91 = v88;
      }
      else {
        unsigned int v91 = v86;
      }
      if (v89 <= v91) {
        unsigned int v92 = v91;
      }
      else {
        unsigned int v92 = v89;
      }
      unsigned int v93 = v92 - v86;
      unsigned int v94 = v92 - v88;
      unsigned int v95 = v92 - v89;
      uint64_t v96 = v90 - v92;
      if (v9 != 0xFFFF)
      {
        v93 -= (v93 * v20 + ((v93 * v20) >> 16) + 1) >> 16;
        v94 -= (v94 * v20 + ((v94 * v20) >> 16) + 1) >> 16;
        v95 -= (v95 * v20 + ((v95 * v20) >> 16) + 1) >> 16;
        uint64_t v96 = v96 - ((v96 * v20 + ((v96 * v20) >> 16) + 1) >> 16);
        v90 -= (v90 * v20 + ((v90 * v20) >> 16) + 1) >> 16;
      }
      unint64_t v97 = ((unint64_t)(unsigned __int16)v95 << 32) | (v96 << 48) | (v94 << 16) | (unint64_t)(unsigned __int16)v93;
      if (v8)
      {
        if ((_WORD)v90)
        {
          if ((unsigned __int16)v90 != 0xFFFF)
          {
            cmyk64_DAplusDAM(v7, v8, v97, v90, *v7, *v8, (unsigned __int16)~(_WORD)v90);
LABEL_106:
            uint64_t result = (unint64_t)BLEND8_21385;
            uint64_t v17 = v162;
            LOBYTE(v10) = v163;
            int v9 = v164;
            int v6 = v165;
            goto LABEL_107;
          }
          *int v7 = v97;
          *__n128 v8 = -1;
        }
      }
      else if ((_WORD)v90)
      {
        if ((unsigned __int16)v90 != 0xFFFF)
        {
          cmyk64_DplusDM(v7, v97, *v7, (unsigned __int16)~(_WORD)v90);
          goto LABEL_106;
        }
        *int v7 = v97;
      }
LABEL_107:
      v63 += 2;
      ++v7;
      __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
      if (!--v62) {
        goto LABEL_108;
      }
    }
  }
  __int16 v169 = (uint64_t *)(v11 + 16 * a3);
  int v98 = (unsigned int *)(v16 - 4);
  char v99 = 32 - v10;
  int v100 = v9 ^ 0xFFFF;
  uint64_t v166 = a5;
  do
  {
    int32x2_t v101 = *(unsigned int **)(v167 + 32);
    uint32x2_t v102 = (char *)v101 + (v14 >> v13) * v12;
    int v161 = a6;
    if (v157 != 1)
    {
      uint64_t v103 = v14;
      uint64_t v124 = v169;
      uint64_t v125 = v166;
      if (a5 < 1) {
        goto LABEL_154;
      }
      while (1)
      {
        uint64_t v126 = *v124;
        v124 += 2;
        unsigned int v127 = (unsigned int *)&v102[v126];
        if (v98 < (unsigned int *)&v102[v126]) {
          unsigned int v127 = v98;
        }
        if ((unint64_t)v127 < *(void *)(v167 + 32)) {
          unsigned int v127 = *(unsigned int **)(v167 + 32);
        }
        unsigned int v128 = bswap32(*v127);
        unsigned int v129 = (v128 << v10) | (v128 >> v99);
        int v130 = BYTE2(v129);
        int v131 = BYTE1(v129);
        int v132 = v129 | v6;
        HIDWORD(v134) = HIBYTE(v129);
        LODWORD(v134) = v129;
        unsigned int v133 = v134 >> 24;
        unsigned int v135 = v130 | (v130 << 8);
        unsigned int v136 = v131 | (v131 << 8);
        int v137 = v132 | (v132 << 8);
        if (v133 <= v135) {
          unsigned int v138 = v135;
        }
        else {
          unsigned int v138 = v133;
        }
        if (v136 <= v138) {
          unsigned int v139 = v138;
        }
        else {
          unsigned int v139 = v136;
        }
        unsigned int v140 = v139 - v133;
        unsigned int v141 = v139 - v135;
        unsigned int v142 = v139 - v136;
        uint64_t v143 = v137 - v139;
        if (v9 != 0xFFFF)
        {
          v140 -= (v140 * v100 + ((v140 * v100) >> 16) + 1) >> 16;
          v141 -= (v141 * v100 + ((v141 * v100) >> 16) + 1) >> 16;
          v142 -= (v142 * v100 + ((v142 * v100) >> 16) + 1) >> 16;
          uint64_t v143 = v143 - ((v143 * v100 + ((v143 * v100) >> 16) + 1) >> 16);
          v137 -= (v137 * v100 + ((v137 * v100) >> 16) + 1) >> 16;
        }
        unint64_t v144 = ((unint64_t)(unsigned __int16)v142 << 32) | (v143 << 48) | (v141 << 16) | (unint64_t)(unsigned __int16)v140;
        if (v8)
        {
          if ((_WORD)v137)
          {
            if ((unsigned __int16)v137 != 0xFFFF)
            {
              uint64_t result = (unint64_t)cmyk64_DAplusDAM(v7, v8, v144, v137, *v7, *v8, (unsigned __int16)~(_WORD)v137);
LABEL_152:
              uint64_t v17 = v162;
              LOBYTE(v10) = v163;
              int v9 = v164;
              int v6 = v165;
              goto LABEL_153;
            }
            *int v7 = v144;
            *__n128 v8 = -1;
          }
        }
        else if ((_WORD)v137)
        {
          if ((unsigned __int16)v137 != 0xFFFF)
          {
            uint64_t result = (unint64_t)cmyk64_DplusDM(v7, v144, *v7, (unsigned __int16)~(_WORD)v137);
            goto LABEL_152;
          }
          *int v7 = v144;
        }
LABEL_153:
        ++v7;
        __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
        if (!--v125) {
          goto LABEL_154;
        }
      }
    }
    uint64_t v103 = v14;
    if (a5 >= 1)
    {
      int v104 = v169;
      uint64_t v105 = v166;
      do
      {
        uint64_t v106 = *v104;
        v104 += 2;
        int v107 = (unsigned int *)&v102[v106];
        if (v98 < (unsigned int *)&v102[v106]) {
          int v107 = v98;
        }
        if (v107 < v101) {
          int v107 = v101;
        }
        unsigned int v108 = bswap32(*v107);
        unsigned int v109 = (v108 << v10) | (v108 >> v99);
        int v110 = BYTE2(v109);
        int v111 = BYTE1(v109);
        int v112 = v109 | v6;
        HIDWORD(v114) = HIBYTE(v109);
        LODWORD(v114) = v109;
        unsigned int v113 = v114 >> 24;
        unsigned int v115 = v110 | (v110 << 8);
        unsigned int v116 = v111 | (v111 << 8);
        int v117 = v112 | (v112 << 8);
        if (v113 <= v115) {
          unsigned int v118 = v115;
        }
        else {
          unsigned int v118 = v113;
        }
        if (v116 <= v118) {
          unsigned int v119 = v118;
        }
        else {
          unsigned int v119 = v116;
        }
        unsigned int v120 = v119 - v113;
        unsigned int v121 = v119 - v115;
        unsigned int v122 = v119 - v116;
        uint64_t v123 = v117 - v119;
        if (v9 != 0xFFFF)
        {
          uint64_t result = v122 * v100 + ((v122 * v100) >> 16) + 1;
          v120 -= (v120 * v100 + ((v120 * v100) >> 16) + 1) >> 16;
          v121 -= (v121 * v100 + ((v121 * v100) >> 16) + 1) >> 16;
          v122 -= WORD1(result);
          uint64_t v123 = v123 - ((v123 * v100 + ((v123 * v100) >> 16) + 1) >> 16);
          v117 -= (v117 * v100 + ((v117 * v100) >> 16) + 1) >> 16;
        }
        if (v8) {
          *__n128 v8 = v117;
        }
        *v7++ = ((unint64_t)(unsigned __int16)v122 << 32) | (v123 << 48) | (v121 << 16) | (unint64_t)(unsigned __int16)v120;
        __n128 v8 = (unsigned __int16 *)((char *)v8 + v17);
        --v105;
      }
      while (v105);
    }
LABEL_154:
    uint64_t v12 = v155;
    v7 += v156;
    LOBYTE(v13) = v154;
    uint64_t v14 = v103 + v153;
    v8 += v158;
    a6 = v161 - 1;
  }
  while (v161 != 1);
  return result;
}

void *cmyk64_image_mark_RGB24(void *result, int *a2, int a3, int a4, int a5, int a6)
{
  uint64_t v162 = result;
  int v6 = (unint64_t *)*((void *)a2 + 2);
  int v7 = (__int16 *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v152 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v152 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v151 = *a2;
  uint64_t v150 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v147 = *((void *)a2 + 11);
  uint64_t v12 = *((void *)a2 + 7) + v147 * a4;
  uint64_t v13 = (unsigned __int8 *)result[4];
  uint64_t v14 = &v13[(*((_DWORD *)result + 65) - 1) * *((_DWORD *)result + 6)
           + (((*((_DWORD *)result + 2) >> 22) * *((_DWORD *)result + 64)) >> 3)];
  uint64_t v15 = 2 * (v7 != 0);
  int v161 = v8;
  char v148 = v11;
  uint64_t v149 = v10;
  uint64_t v160 = v15;
  if (result[22])
  {
    uint64_t v145 = *((void *)a2 + 13);
    uint64_t v144 = *((void *)a2 + 15);
    uint64_t v143 = ~(-1 << v11);
    char v142 = v11 - 4;
    int v16 = v14 - 3;
    int v17 = v8 ^ 0xFFFF;
    uint64_t v140 = a5;
    uint64_t v141 = -v10;
    uint64_t v139 = v9 + 16 * a3 + 8;
    while (1)
    {
      int v154 = a6;
      if (((v144 - v12) | (v12 - v145)) < 0)
      {
        int v20 = 0;
        uint64_t v19 = 0;
      }
      else
      {
        uint64_t v18 = ((v12 & (unint64_t)v143) >> v142) & 0xF;
        uint64_t v19 = (unint64_t)(v18 - 7) >= 9 ? v141 : v10;
        int v20 = weights_21383[v18] & 0xF;
      }
      uint64_t v153 = v12;
      uint64_t v21 = v162[4] + (v12 >> v11) * v10;
      if (v151 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        char v22 = (uint64_t *)v139;
        uint64_t v23 = v140;
        while (1)
        {
          uint64_t v24 = *(v22 - 1);
          uint64_t v25 = *v22;
          uint64_t v26 = v21 + v24;
          if ((unint64_t)v16 >= v21 + v24) {
            float v27 = (unsigned __int8 *)(v21 + v24);
          }
          else {
            float v27 = v16;
          }
          if (v27 < v13) {
            float v27 = v13;
          }
          unsigned int v28 = (*v27 << 24) | (v27[1] << 16) | (v27[2] << 8);
          char v29 = v25 & 0xF;
          if ((v25 & 0xF) != 0) {
            break;
          }
          if (v20)
          {
            uint64_t v40 = (unsigned __int8 *)(v26 + v19);
            if ((unint64_t)v16 < v26 + v19) {
              uint64_t v40 = v16;
            }
            if (v40 < v13) {
              uint64_t v40 = v13;
            }
            unsigned int v41 = BLEND8_21385[v20];
            unsigned int v38 = v28 - ((v41 & v28) >> v20);
            unsigned int v39 = (((*v40 << 24) | (v40[1] << 16) | (v40[2] << 8)) & v41) >> v20;
            goto LABEL_43;
          }
LABEL_44:
          int v42 = BYTE2(v28);
          int v43 = BYTE1(v28);
          HIDWORD(v45) = HIBYTE(v28);
          LODWORD(v45) = v28;
          unsigned int v44 = v45 >> 24;
          unsigned int v46 = v42 | (v42 << 8);
          unsigned int v47 = v43 | (v43 << 8);
          if (v44 <= v46) {
            unsigned int v48 = v46;
          }
          else {
            unsigned int v48 = v44;
          }
          if (v47 > v48) {
            unsigned int v48 = v47;
          }
          unsigned int v49 = v48 - v44;
          unsigned int v50 = v48 - v46;
          unsigned int v51 = v48 - v47;
          uint64_t v52 = v48 ^ 0xFFFF;
          unint64_t v53 = v52 << 48;
          unint64_t v54 = (unint64_t)(unsigned __int16)v51 << 32;
          uint64_t result = (void *)(v50 - ((v50 * v17 + ((v50 * v17) >> 16) + 1) >> 16));
          unint64_t v55 = (unint64_t)(v52
                                 - ((v52 * v17 + ((v52 * v17) >> 16) + 1) >> 16)) << 48;
          unint64_t v56 = (unint64_t)(unsigned __int16)(v51 - ((v51 * v17 + ((v51 * v17) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            unint64_t v56 = v53;
            unint64_t v55 = v54;
            unsigned int v57 = v50;
          }
          else
          {
            unsigned int v57 = v50 - ((v50 * v17 + ((v50 * v17) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF)
          {
            __int16 v58 = -1;
          }
          else
          {
            LOWORD(v49) = v49 - ((v49 * v17 + ((v49 * v17) >> 16) + 1) >> 16);
            __int16 v58 = ~(0xFFFF * v17 + ((0xFFFF * v17) >> 16) + 1) >> 16;
          }
          if (v7) {
            *int v7 = v58;
          }
          v22 += 2;
          *v6++ = v55 | v56 | (v57 << 16) | (unsigned __int16)v49;
          int v7 = (__int16 *)((char *)v7 + v15);
          if (!--v23) {
            goto LABEL_109;
          }
        }
        uint64_t v30 = (unsigned __int8 *)(v26 + (v25 >> 4));
        if (v16 < v30) {
          uint64_t v30 = v16;
        }
        if (v30 < v13) {
          uint64_t v30 = v13;
        }
        int v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
        if (v20)
        {
          uint64_t v32 = (unsigned __int8 *)(v26 + v19);
          if (v16 >= v32) {
            unsigned int v33 = v32;
          }
          else {
            unsigned int v33 = v16;
          }
          if (v33 < v13) {
            unsigned int v33 = v13;
          }
          int v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
          unint64_t v35 = &v32[v25 >> 4];
          if (v16 < v35) {
            unint64_t v35 = v16;
          }
          if (v35 < v13) {
            unint64_t v35 = v13;
          }
          unsigned int v36 = BLEND8_21385[v20];
          unsigned int v28 = v28 - ((v36 & v28) >> v20) + ((v36 & v34) >> v20);
          int v31 = v31 - ((v36 & v31) >> v20) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v20);
        }
        int v37 = BLEND8_21385[*v22 & 0xF];
        unsigned int v38 = v28 - ((v37 & v28) >> v29);
        unsigned int v39 = (v37 & v31) >> v29;
LABEL_43:
        unsigned int v28 = v38 + v39;
        goto LABEL_44;
      }
LABEL_109:
      uint64_t v10 = v149;
      v6 += v150;
      LOBYTE(v11) = v148;
      uint64_t v12 = v153 + v147;
      v7 += v152;
      a6 = v154 - 1;
      if (v154 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_109;
    }
    unsigned int v59 = (uint64_t *)v139;
    uint64_t v60 = v140;
    uint64_t v158 = v19;
    uint64_t v156 = v162[4] + (v12 >> v11) * v10;
    while (1)
    {
      uint64_t v61 = *(v59 - 1);
      uint64_t v62 = *v59;
      uint64_t v63 = v21 + v61;
      if ((unint64_t)v16 >= v21 + v61) {
        uint64_t v64 = (unsigned __int8 *)(v21 + v61);
      }
      else {
        uint64_t v64 = v16;
      }
      if (v64 < v13) {
        uint64_t v64 = v13;
      }
      unsigned int v65 = (*v64 << 24) | (v64[1] << 16) | (v64[2] << 8);
      char v66 = v62 & 0xF;
      if ((v62 & 0xF) != 0)
      {
        uint64_t v67 = (unsigned __int8 *)(v63 + (v62 >> 4));
        if (v16 < v67) {
          uint64_t v67 = v16;
        }
        if (v67 < v13) {
          uint64_t v67 = v13;
        }
        int v68 = (*v67 << 24) | (v67[1] << 16) | (v67[2] << 8);
        if (v20)
        {
          char v69 = (unsigned __int8 *)(v63 + v19);
          if (v16 >= v69) {
            long long v70 = v69;
          }
          else {
            long long v70 = v16;
          }
          if (v70 < v13) {
            long long v70 = v13;
          }
          int v71 = (*v70 << 24) | (v70[1] << 16) | (v70[2] << 8);
          long long v72 = &v69[v62 >> 4];
          if (v16 < v72) {
            long long v72 = v16;
          }
          if (v72 < v13) {
            long long v72 = v13;
          }
          unsigned int v73 = BLEND8_21385[v20];
          unsigned int v65 = v65 - ((v73 & v65) >> v20) + ((v73 & v71) >> v20);
          int v68 = v68 - ((v73 & v68) >> v20) + ((((*v72 << 24) | (v72[1] << 16) | (v72[2] << 8)) & v73) >> v20);
        }
        int v74 = BLEND8_21385[*v59 & 0xF];
        unsigned int v75 = v65 - ((v74 & v65) >> v66);
        unsigned int v76 = (v74 & v68) >> v66;
      }
      else
      {
        if (!v20) {
          goto LABEL_90;
        }
        int v77 = (unsigned __int8 *)(v63 + v19);
        if ((unint64_t)v16 < v63 + v19) {
          int v77 = v16;
        }
        if (v77 < v13) {
          int v77 = v13;
        }
        unsigned int v78 = BLEND8_21385[v20];
        unsigned int v75 = v65 - ((v78 & v65) >> v20);
        unsigned int v76 = (((*v77 << 24) | (v77[1] << 16) | (v77[2] << 8)) & v78) >> v20;
      }
      unsigned int v65 = v75 + v76;
LABEL_90:
      int v79 = BYTE2(v65);
      int v80 = BYTE1(v65);
      HIDWORD(v82) = HIBYTE(v65);
      LODWORD(v82) = v65;
      unsigned int v81 = v82 >> 24;
      unsigned int v83 = v79 | (v79 << 8);
      unsigned int v84 = v80 | (v80 << 8);
      if (v81 <= v83) {
        unsigned int v85 = v83;
      }
      else {
        unsigned int v85 = v81;
      }
      if (v84 > v85) {
        unsigned int v85 = v84;
      }
      unsigned int v86 = v85 - v81;
      unsigned int v87 = v85 - v83;
      unsigned int v88 = v85 - v84;
      uint64_t v89 = v85 ^ 0xFFFF;
      unint64_t v90 = v89 << 48;
      unint64_t v91 = (unint64_t)(unsigned __int16)v88 << 32;
      unint64_t v92 = (unint64_t)(v89 - ((v89 * v17 + ((v89 * v17) >> 16) + 1) >> 16)) << 48;
      unint64_t v93 = (unint64_t)(unsigned __int16)(v88 - ((v88 * v17 + ((v88 * v17) >> 16) + 1) >> 16)) << 32;
      if (v8 == 0xFFFF)
      {
        unint64_t v93 = v90;
        unint64_t v92 = v91;
        unsigned int v94 = 0xFFFF;
      }
      else
      {
        v87 -= (v87 * v17 + ((v87 * v17) >> 16) + 1) >> 16;
        LOWORD(v86) = v86 - ((v86 * v17 + ((v86 * v17) >> 16) + 1) >> 16);
        unsigned int v94 = ~(0xFFFF * v17 + ((0xFFFF * v17) >> 16) + 1) >> 16;
      }
      uint64_t v95 = v92 | v93 | (v87 << 16) | (unsigned __int16)v86;
      if (v7)
      {
        if (v94)
        {
          if (v94 != 0xFFFF)
          {
            uint64_t result = cmyk64_DAplusDAM(v6, v7, v95, v94, *v6, (unsigned __int16)*v7, v94 ^ 0xFFFF);
LABEL_107:
            uint64_t v21 = v156;
            uint64_t v19 = v158;
            uint64_t v15 = v160;
            int v8 = v161;
            goto LABEL_108;
          }
          *int v6 = v95;
          *int v7 = -1;
        }
      }
      else if (v94)
      {
        if (v94 != 0xFFFF)
        {
          uint64_t result = cmyk64_DplusDM(v6, v95, *v6, v94 ^ 0xFFFF);
          goto LABEL_107;
        }
        *int v6 = v95;
      }
LABEL_108:
      v59 += 2;
      ++v6;
      int v7 = (__int16 *)((char *)v7 + v15);
      if (!--v60) {
        goto LABEL_109;
      }
    }
  }
  uint64_t v159 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v96 = v14 - 3;
  int v97 = v8 ^ 0xFFFF;
  uint64_t v157 = a5;
  do
  {
    int v98 = (unsigned __int8 *)v162[4];
    char v99 = &v98[(v12 >> v11) * v10];
    int v155 = a6;
    if (v151 != 1)
    {
      uint64_t v100 = v12;
      unsigned int v121 = v159;
      uint64_t v122 = v157;
      if (a5 < 1) {
        goto LABEL_167;
      }
      while (1)
      {
        uint64_t v123 = *v121;
        v121 += 2;
        uint64_t v124 = &v99[v123];
        if (v96 < &v99[v123]) {
          uint64_t v124 = v96;
        }
        if ((unint64_t)v124 < v162[4]) {
          uint64_t v124 = (unsigned __int8 *)v162[4];
        }
        unsigned int v125 = *v124 | (*v124 << 8);
        unsigned int v126 = v124[1] | (v124[1] << 8);
        unsigned int v127 = v124[2] | (v124[2] << 8);
        if (v125 <= v126) {
          unsigned int v128 = v126;
        }
        else {
          unsigned int v128 = v125;
        }
        if (v127 > v128) {
          unsigned int v128 = v127;
        }
        unsigned int v129 = v128 - v125;
        unsigned int v130 = v128 - v126;
        unsigned int v131 = v128 - v127;
        uint64_t v132 = v128 ^ 0xFFFF;
        unint64_t v133 = v132 << 48;
        unint64_t v134 = (unint64_t)(unsigned __int16)v131 << 32;
        unint64_t v135 = (unint64_t)(v132
                                - ((v132 * v97 + ((v132 * v97) >> 16) + 1) >> 16)) << 48;
        unint64_t v136 = (unint64_t)(unsigned __int16)(v131 - ((v131 * v97 + ((v131 * v97) >> 16) + 1) >> 16)) << 32;
        if (v8 == 0xFFFF)
        {
          unint64_t v136 = v133;
          unint64_t v135 = v134;
          unsigned int v137 = 0xFFFF;
        }
        else
        {
          v130 -= (v130 * v97 + ((v130 * v97) >> 16) + 1) >> 16;
          LOWORD(v129) = v129 - ((v129 * v97 + ((v129 * v97) >> 16) + 1) >> 16);
          unsigned int v137 = ~(0xFFFF * v97 + ((0xFFFF * v97) >> 16) + 1) >> 16;
        }
        uint64_t v138 = v135 | v136 | (v130 << 16) | (unsigned __int16)v129;
        if (v7)
        {
          if (v137)
          {
            if (v137 != 0xFFFF)
            {
              uint64_t result = cmyk64_DAplusDAM(v6, v7, v138, v137, *v6, (unsigned __int16)*v7, v137 ^ 0xFFFF);
LABEL_165:
              uint64_t v15 = v160;
              int v8 = v161;
              goto LABEL_166;
            }
            *int v6 = v138;
            *int v7 = -1;
          }
        }
        else if (v137)
        {
          if (v137 != 0xFFFF)
          {
            uint64_t result = cmyk64_DplusDM(v6, v138, *v6, v137 ^ 0xFFFF);
            goto LABEL_165;
          }
          *int v6 = v138;
        }
LABEL_166:
        ++v6;
        int v7 = (__int16 *)((char *)v7 + v15);
        if (!--v122) {
          goto LABEL_167;
        }
      }
    }
    uint64_t v100 = v12;
    if (a5 >= 1)
    {
      int32x2_t v101 = v159;
      uint64_t v102 = v157;
      do
      {
        uint64_t v103 = *v101;
        v101 += 2;
        int v104 = &v99[v103];
        if (v96 < &v99[v103]) {
          int v104 = v96;
        }
        if (v104 < v98) {
          int v104 = v98;
        }
        unsigned int v105 = *v104 | (*v104 << 8);
        unsigned int v106 = v104[1] | (v104[1] << 8);
        unsigned int v107 = v104[2] | (v104[2] << 8);
        if (v105 <= v106) {
          unsigned int v108 = v106;
        }
        else {
          unsigned int v108 = v105;
        }
        if (v107 > v108) {
          unsigned int v108 = v107;
        }
        unsigned int v109 = v108 - v105;
        unsigned int v110 = v108 - v106;
        unsigned int v111 = v108 - v107;
        uint64_t v112 = v108 ^ 0xFFFF;
        unint64_t v113 = (unint64_t)(unsigned __int16)v111 << 32;
        uint64_t result = (void *)(v110 - ((v110 * v97 + ((v110 * v97) >> 16) + 1) >> 16));
        unint64_t v114 = (unint64_t)(v112
                                - ((v112 * v97 + ((v112 * v97) >> 16) + 1) >> 16)) << 48;
        unint64_t v115 = (unint64_t)(unsigned __int16)(v111 - ((v111 * v97 + ((v111 * v97) >> 16) + 1) >> 16)) << 32;
        if (v8 == 0xFFFF) {
          unint64_t v116 = v112 << 48;
        }
        else {
          unint64_t v116 = v115;
        }
        if (v8 == 0xFFFF) {
          unint64_t v117 = v113;
        }
        else {
          unint64_t v117 = v114;
        }
        if (v8 == 0xFFFF) {
          unsigned int v118 = v110;
        }
        else {
          unsigned int v118 = v110 - ((v110 * v97 + ((v110 * v97) >> 16) + 1) >> 16);
        }
        if (v8 == 0xFFFF) {
          unsigned __int16 v119 = v109;
        }
        else {
          unsigned __int16 v119 = v109 - ((v109 * v97 + ((v109 * v97) >> 16) + 1) >> 16);
        }
        if (v8 == 0xFFFF) {
          __int16 v120 = -1;
        }
        else {
          __int16 v120 = ~(0xFFFF * v97 + ((0xFFFF * v97) >> 16) + 1) >> 16;
        }
        if (v7) {
          *int v7 = v120;
        }
        *v6++ = v117 | v116 | (v118 << 16) | v119;
        int v7 = (__int16 *)((char *)v7 + v15);
        --v102;
      }
      while (v102);
    }
LABEL_167:
    uint64_t v10 = v149;
    v6 += v150;
    LOBYTE(v11) = v148;
    uint64_t v12 = v100 + v147;
    v7 += v152;
    a6 = v155 - 1;
  }
  while (v155 != 1);
  return result;
}

void *cmyk64_image_mark_W8(void *result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v8 = *((unsigned __int16 *)a2 + 4);
  uint64_t v9 = (uint64_t *)*((void *)a2 + 2);
  uint64_t v10 = (unsigned __int16 *)*((void *)a2 + 4);
  if (v10) {
    uint64_t v20 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v20 = 0;
  }
  int v19 = *a2;
  uint64_t v18 = *((void *)a2 + 3) - a5;
  if (v8 == 0xFFFF) {
    uint64_t v11 = 0xFEFE000000000000;
  }
  else {
    uint64_t v11 = (unint64_t)(65278 - ((65278 * (v8 ^ 0xFFFF) + ((65278 * (v8 ^ 0xFFFFu)) >> 16) + 1) >> 16)) << 48;
  }
  if (v8 == 0xFFFF) {
    unsigned __int16 v12 = -1;
  }
  else {
    unsigned __int16 v12 = ~(0xFFFF * (v8 ^ 0xFFFF) + ((0xFFFF * (v8 ^ 0xFFFFu)) >> 16) + 1) >> 16;
  }
  uint64_t v13 = 2 * (v10 != 0);
  if (result[22])
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          int v14 = a5;
          do
          {
            if (v10) {
              *uint64_t v10 = v12;
            }
            *v9++ = v11;
            uint64_t v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v14;
          }
          while (v14);
        }
      }
      else
      {
        int v15 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (v12)
              {
                if (v12 == 0xFFFF)
                {
                  *uint64_t v9 = v11;
                  *uint64_t v10 = -1;
                }
                else
                {
                  uint64_t result = cmyk64_DAplusDAM(v9, v10, v11, v12, *v9, *v10, (unsigned __int16)~v12);
                }
              }
            }
            else if (v12)
            {
              if (v12 == 0xFFFF) {
                *uint64_t v9 = v11;
              }
              else {
                uint64_t result = cmyk64_DplusDM(v9, v11, *v9, (unsigned __int16)~v12);
              }
            }
            ++v9;
            uint64_t v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v15;
          }
          while (v15);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  else
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          int v16 = a5;
          do
          {
            if (v10) {
              *uint64_t v10 = v12;
            }
            *v9++ = v11;
            uint64_t v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        int v17 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (v12)
              {
                if (v12 == 0xFFFF)
                {
                  *uint64_t v9 = v11;
                  *uint64_t v10 = -1;
                }
                else
                {
                  uint64_t result = cmyk64_DAplusDAM(v9, v10, v11, v12, *v9, *v10, (unsigned __int16)~v12);
                }
              }
            }
            else if (v12)
            {
              if (v12 == 0xFFFF) {
                *uint64_t v9 = v11;
              }
              else {
                uint64_t result = cmyk64_DplusDM(v9, v11, *v9, (unsigned __int16)~v12);
              }
            }
            ++v9;
            uint64_t v10 = (unsigned __int16 *)((char *)v10 + v13);
            --v17;
          }
          while (v17);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  return result;
}

unint64_t cmyk64_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  int8x8_t v4 = *(unsigned __int16 **)(a1 + 96);
  if (v4) {
    unsigned int v6 = *v4;
  }
  else {
    unsigned int v6 = 0xFFFF;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 136);
  unint64_t v9 = **(void **)(a1 + 88);
  unint64_t v375 = *(int *)(a1 + 28);
  uint64_t v379 = *(void *)(a1 + 40);
  int v385 = *(_DWORD *)(a1 + 4);
  pthread_mutex_lock(&cmyk64_cacheColorLock);
  uint64_t v10 = cmyk64_cacheColor;
  if (!cmyk64_cacheColor
    || *(void *)(cmyk64_cacheColor + 16) != v9
    || *(unsigned __int16 *)(cmyk64_cacheColor + 24) != v6)
  {
    uint64_t v13 = 0;
    while (1)
    {
      if (!v10) {
        goto LABEL_14;
      }
      uint64_t v14 = v10;
      int v15 = v13;
      if (*(void *)(v10 + 16) == v9 && *(unsigned __int16 *)(v10 + 24) == v6) {
        break;
      }
      uint64_t v10 = *(void *)v10;
      uint64_t v13 = (void *)v14;
      if (!*(void *)v14)
      {
        if (cmyk64_cacheColorCount > 6)
        {
          void *v15 = 0;
        }
        else
        {
LABEL_14:
          int v16 = (char *)cmyk64_cacheColorBase;
          if (cmyk64_cacheColorBase)
          {
            unsigned int v17 = cmyk64_cacheColorCount;
          }
          else
          {
            int v16 = (char *)malloc_type_calloc(1uLL, 0x70E0uLL, 0x102004053D502F9uLL);
            unsigned int v17 = 0;
            cmyk64_cacheColorBase = (uint64_t)v16;
          }
          uint64_t v14 = (uint64_t)&v16[32 * v17];
          *(void *)(v14 + 8) = &v16[4096 * (unint64_t)v17 + 224];
          cmyk64_cacheColorCount = v17 + 1;
        }
        uint64_t v18 = 0;
        *(void *)uint64_t v14 = cmyk64_cacheColor;
        cmyk64_cacheColor = v14;
        *(void *)(v14 + 16) = v9;
        *(_WORD *)(v14 + 24) = v6;
        *(_DWORD *)(v14 + 26) = 0;
        *(_WORD *)(v14 + 30) = 0;
        uint64_t v20 = *(void *)(v14 + 8);
        uint64_t v12 = v14 + 8;
        uint64_t v19 = v20;
        int32x4_t v21 = vdupq_n_s32((unsigned __int16)v9);
        int32x4_t v22 = vdupq_n_s32(WORD1(v9));
        int32x4_t v23 = vdupq_n_s32(WORD2(v9));
        int32x4_t v24 = vdupq_n_s32(HIWORD(v9));
        int32x4_t v25 = vdupq_n_s32(v6);
        int32x4_t v26 = vdupq_n_s32(v9);
        int32x4_t v27 = vdupq_n_s32(HIDWORD(v9));
        int32x4_t v28 = (int32x4_t)xmmword_1850CDCC0;
        int32x4_t v29 = (int32x4_t)xmmword_1850CDC50;
        v30.i64[0] = 0xFFFF0000FFFFLL;
        v30.i64[1] = 0xFFFF0000FFFFLL;
        int16x8_t v31 = vdupq_n_s16(v6);
        v32.i64[0] = 0x800000008;
        v32.i64[1] = 0x800000008;
        int32x4_t v33 = vdupq_n_s32(0x101u);
        do
        {
          int32x4_t v34 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v28, v33), v30);
          int32x4_t v35 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v29, v33), v30);
          int8x16_t v36 = (int8x16_t)vmulq_s32(v35, v21);
          int8x16_t v37 = (int8x16_t)vmulq_s32(v34, v21);
          int8x16_t v38 = (int8x16_t)vmulq_s32(v34, v22);
          int8x16_t v39 = (int8x16_t)vmulq_s32(v35, v22);
          int8x16_t v40 = (int8x16_t)vmulq_s32(v34, v23);
          int8x16_t v41 = (int8x16_t)vmulq_s32(v35, v23);
          int8x16_t v42 = (int8x16_t)vmulq_s32(v35, v24);
          int8x16_t v43 = (int8x16_t)vmulq_s32(v34, v24);
          int8x16_t v44 = (int8x16_t)vmulq_s32(v35, v25);
          int8x16_t v45 = (int8x16_t)vmulq_s32(v34, v25);
          uint64_t v46 = v19 + v18;
          int32x4_t v47 = vsubq_s32(v24, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x10uLL), (int32x4_t)vmvnq_s8(v42)), 0x10uLL));
          int32x4_t v48 = vsubq_s32(v24, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x10uLL), (int32x4_t)vmvnq_s8(v43)), 0x10uLL));
          v49.i64[0] = v48.u32[2];
          v49.i64[1] = v48.u32[3];
          int64x2_t v50 = (int64x2_t)v49;
          v49.i64[0] = v48.u32[0];
          v49.i64[1] = v48.u32[1];
          int64x2_t v51 = (int64x2_t)v49;
          v49.i64[0] = v47.u32[2];
          v49.i64[1] = v47.u32[3];
          int64x2_t v52 = (int64x2_t)v49;
          v49.i64[0] = v47.u32[0];
          v49.i64[1] = v47.u32[1];
          _Q28 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x10uLL), (int32x4_t)vmvnq_s8(v41)), 0x10uLL)), v30);
          _Q27 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x10uLL), (int32x4_t)vmvnq_s8(v40)), 0x10uLL)), v30);
          int8x16_t v55 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q28.i8, 0x20uLL);
          __asm { SHLL2           V28.2D, V28.4S, #0x20 ; ' ' }
          int8x16_t v60 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q27.i8, 0x20uLL);
          __asm { SHLL2           V27.2D, V27.4S, #0x20 ; ' ' }
          int8x16_t v61 = vorrq_s8((int8x16_t)vshlq_n_s64(v50, 0x30uLL), _Q27);
          int8x16_t v62 = vorrq_s8((int8x16_t)vshlq_n_s64(v51, 0x30uLL), v60);
          int8x16_t v63 = vorrq_s8((int8x16_t)vshlq_n_s64(v52, 0x30uLL), _Q28);
          int8x16_t v64 = vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v49, 0x30uLL), v55);
          int32x4_t v65 = vshlq_n_s32(vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x10uLL), (int32x4_t)vmvnq_s8(v39)), 0x10uLL)), 0x10uLL);
          int32x4_t v66 = vshlq_n_s32(vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x10uLL), (int32x4_t)vmvnq_s8(v38)), 0x10uLL)), 0x10uLL);
          v49.i64[0] = v66.u32[2];
          v49.i64[1] = v66.u32[3];
          int8x16_t v67 = v49;
          v49.i64[0] = v66.u32[0];
          v49.i64[1] = v66.u32[1];
          int8x16_t v68 = v49;
          v49.i64[0] = v65.u32[2];
          v49.i64[1] = v65.u32[3];
          int8x16_t v69 = v49;
          v49.i64[0] = v65.u32[0];
          v49.i64[1] = v65.u32[1];
          int8x16_t v70 = v49;
          int8x16_t v71 = vandq_s8((int8x16_t)vsubq_s32(v26, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x10uLL), (int32x4_t)vmvnq_s8(v37)), 0x10uLL)), v30);
          int8x16_t v72 = vandq_s8((int8x16_t)vsubq_s32(v26, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v36, 0x10uLL), (int32x4_t)vmvnq_s8(v36)), 0x10uLL)), v30);
          v49.i64[0] = v72.u32[0];
          v49.i64[1] = v72.u32[1];
          int8x16_t v73 = v49;
          v49.i64[0] = v72.u32[2];
          v49.i64[1] = v72.u32[3];
          int8x16_t v74 = v49;
          v49.i64[0] = v71.u32[0];
          v49.i64[1] = v71.u32[1];
          int8x16_t v75 = v49;
          v49.i64[0] = v71.u32[2];
          v49.i64[1] = v71.u32[3];
          int8x16_t v76 = vorrq_s8(v64, vorrq_s8(v70, v73));
          *(void *)uint64_t v46 = v76.i64[0];
          int8x16_t v77 = vorrq_s8(v63, vorrq_s8(v69, v74));
          *(void *)(v46 + 32) = v77.i64[0];
          int8x16_t v78 = vorrq_s8(v62, vorrq_s8(v68, v75));
          *(void *)(v46 + 64) = v78.i64[0];
          int8x16_t v79 = vorrq_s8(v61, vorrq_s8(v67, v49));
          *(void *)(v46 + 96) = v79.i64[0];
          int16x8_t v80 = vsubq_s16(v31, vsubhn_high_s32(vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x10uLL), (int32x4_t)vmvnq_s8(v44)), (int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x10uLL), (int32x4_t)vmvnq_s8(v45)));
          *(_WORD *)(v46 + 8) = v80.i16[0];
          *(void *)(v19 + v18 + 16) = v76.i64[1];
          *(void *)(v19 + v18 + 48) = v77.i64[1];
          *(void *)(v19 + v18 + 80) = v78.i64[1];
          *(void *)(v19 + v18 + 112) = v79.i64[1];
          *(_WORD *)(v19 + v18 + 24) = v80.i16[1];
          *(_WORD *)(v19 + v18 + 40) = v80.i16[2];
          *(_WORD *)(v19 + v18 + 56) = v80.i16[3];
          *(_WORD *)(v19 + v18 + 72) = v80.i16[4];
          *(_WORD *)(v19 + v18 + 88) = v80.i16[5];
          *(_WORD *)(v19 + v18 + 104) = v80.i16[6];
          *(_WORD *)(v19 + v18 + 120) = v80.i16[7];
          int32x4_t v29 = vaddq_s32(v29, v32);
          v18 += 128;
          int32x4_t v28 = vaddq_s32(v28, v32);
        }
        while (v18 != 4096);
        unint64_t result = pthread_mutex_unlock(&cmyk64_cacheColorLock);
        goto LABEL_25;
      }
    }
    if (v13)
    {
      *uint64_t v13 = *(void *)v10;
      *(void *)uint64_t v10 = cmyk64_cacheColor;
      cmyk64_cacheColor = v10;
    }
  }
  unint64_t result = pthread_mutex_unlock(&cmyk64_cacheColorLock);
  uint64_t v12 = v10 + 8;
LABEL_25:
  int v81 = a2;
  uint64_t v83 = *(int *)(a1 + 12);
  uint64_t v82 = *(int *)(a1 + 16);
  if (v3)
  {
    unint64_t v84 = (unint64_t)*(int *)(a1 + 32) >> 1;
    unsigned int v85 = (unsigned __int16 *)(v3 + 2 * (v83 + v84 * v82));
    uint64_t v86 = 1;
    if (!v8) {
      return result;
    }
  }
  else
  {
    unsigned int v85 = 0;
    unint64_t v84 = 0;
    uint64_t v86 = 0;
    if (!v8) {
      return result;
    }
  }
  unint64_t v87 = v84 - v385;
  if (v3) {
    unint64_t v88 = v84 - v385;
  }
  else {
    unint64_t v88 = v84;
  }
  uint64_t v89 = *(void *)v12;
  unsigned int v90 = *(unsigned __int16 *)(*(void *)v12 + 4088);
  uint64_t v91 = *(void *)(*(void *)v12 + 4080);
  unint64_t v92 = (int8x8_t *)(v379 + 8 * (v83 + (v375 >> 3) * v82));
  uint64_t v93 = *(int *)(a1 + 124);
  unint64_t v94 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v93;
  uint64_t v380 = v93 - v385;
  unint64_t v95 = (v375 >> 3) - v385;
  switch(v81)
  {
    case 0:
      if (v3)
      {
        uint64_t v96 = 2 * v86;
        do
        {
          int v97 = v385;
          do
          {
            int v98 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v98 == 255)
              {
                LOWORD(v99) = 0;
                *unint64_t v92 = 0;
              }
              else
              {
                int v100 = *v85;
                unsigned int v101 = (v98 ^ 0xFF | ((v98 ^ 0xFF) << 8)) ^ 0xFFFF;
                int32x2_t v102 = vdup_n_s32(v101);
                uint32x2_t v103 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v102);
                v104.i32[0] = HIWORD(v92->u32[0]);
                v104.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v105 = (uint32x2_t)vmul_s32(v104, v102);
                *unint64_t v92 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v92, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v103, v103, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v104, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v105, v105, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                int v99 = v100 - ((v101 * v100 + ((v101 * v100) >> 16) + 1) >> 16);
              }
              *unsigned int v85 = v99;
            }
            ++v94;
            ++v92;
            unsigned int v85 = (unsigned __int16 *)((char *)v85 + v96);
            --v97;
          }
          while (v97);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v269 = v385;
          do
          {
            int v270 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v270 == 255)
              {
                *unint64_t v92 = 0;
              }
              else
              {
                int32x2_t v271 = (int32x2_t)*v92;
                v272.i32[0] = vshl_u32((uint32x2_t)*v92, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v273.i32[0] = v272.i32[0];
                v273.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
                int32x2_t v274 = vdup_n_s32((v270 ^ 0xFF | ((v270 ^ 0xFF) << 8)) ^ 0xFFFFu);
                uint32x2_t v275 = (uint32x2_t)vmul_s32(v273, v274);
                v276.i32[0] = v92->u16[0];
                v276.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v277 = (uint32x2_t)vmul_s32(v276, v274);
                v272.i32[1] = HIDWORD(*(unint64_t *)v92);
                uint32x2_t v278 = (uint32x2_t)vsub_s32(v272, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v275, v275, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v271.i32[1] = v276.i32[1];
                int8x8_t v279 = (int8x8_t)vsub_s32(v271, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v277, v277, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                int8x8_t v280 = (int8x8_t)vshl_n_s32((int32x2_t)v279, 0x10uLL);
                v279.i16[1] = 0;
                v279.i32[1] = v280.i32[1];
                v280.i32[0] = vshl_u32(v278, (uint32x2_t)0xFFFF00000010).u32[0];
                v280.i32[1] = v278.u16[2];
                *unint64_t v92 = vorr_s8(v280, v279);
              }
            }
            ++v94;
            ++v92;
            --v269;
          }
          while (v269);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 1:
      unsigned int v106 = v94 & 3;
      if (v3)
      {
        int v107 = v106 + v385;
        unsigned int v108 = &v92[-(v94 & 3)];
        unsigned int v109 = &v85[-(v94 & 3)];
        if ((v94 & 3) != 0) {
          char v110 = v94 & 0xFC;
        }
        else {
          char v110 = v94;
        }
        if ((v94 & 3) != 0) {
          unint64_t result = (-1 << (8 * v106));
        }
        else {
          unint64_t result = 0xFFFFFFFFLL;
        }
        if ((v94 & 3) != 0)
        {
          v94 &= 0xFFFFFFFFFFFFFFFCLL;
          unsigned int v85 = v109;
          unint64_t v92 = v108;
        }
        else
        {
          int v107 = v385;
        }
        if ((((_BYTE)v107 + v110) & 3) != 0)
        {
          int v111 = 4 - (((_BYTE)v107 + v110) & 3);
          v106 += v111;
          unsigned int v112 = 0xFFFFFFFF >> (8 * v111);
          if (v107 >= 4) {
            unsigned int v113 = 0xFFFFFFFF >> (8 * v111);
          }
          else {
            unsigned int v113 = 0;
          }
          unsigned int v386 = v113;
          if (v107 >= 4) {
            unsigned int v112 = -1;
          }
          unint64_t result = v112 & result;
          int v376 = result;
        }
        else
        {
          int v376 = result;
          unsigned int v386 = 0;
        }
        uint64_t v381 = v380 - v106;
        unint64_t v373 = v95 - v106;
        int v370 = v107 >> 2;
        int16x4_t v327 = vdup_n_s16(v90);
        unint64_t v368 = v87 - v106;
        do
        {
          unsigned int v328 = *(_DWORD *)v94 & v376;
          int v329 = v370;
          unsigned int v330 = v386;
          if (!v328) {
            goto LABEL_442;
          }
LABEL_424:
          if (v328 == -1)
          {
            *unint64_t v92 = (int8x8_t)v91;
            v92[1] = (int8x8_t)v91;
            v92[2] = (int8x8_t)v91;
            v92[3] = (int8x8_t)v91;
            *(int16x4_t *)unsigned int v85 = v327;
            goto LABEL_442;
          }
          while (1)
          {
            if ((_BYTE)v328)
            {
              if (v328 == 255)
              {
                *unint64_t v92 = (int8x8_t)v91;
                *unsigned int v85 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v92, v85, *(void *)(v89 + 16 * v328), *(_WORD *)(v89 + 16 * v328 + 8), (unint64_t)*v92, *v85, (v328 | (v328 << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE1(v328))
            {
              unint64_t v331 = (uint64_t *)&v92[1];
              uint64_t v332 = v85 + 1;
              if (BYTE1(v328) == 255)
              {
                *unint64_t v331 = v91;
                *uint64_t v332 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v331, v332, *(void *)(v89 + 16 * BYTE1(v328)), *(_WORD *)(v89 + 16 * BYTE1(v328) + 8), *v331, *v332, (BYTE1(v328) | (BYTE1(v328) << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE2(v328))
            {
              uint64_t v333 = (uint64_t *)&v92[2];
              uint64_t v334 = v85 + 2;
              if (BYTE2(v328) == 255)
              {
                *uint64_t v333 = v91;
                *uint64_t v334 = v90;
              }
              else
              {
                cmyk64_DAplusDAM(v333, v334, *(void *)(v89 + 16 * BYTE2(v328)), *(_WORD *)(v89 + 16 * BYTE2(v328) + 8), *v333, *v334, (BYTE2(v328) | (BYTE2(v328) << 8)) ^ 0xFFFF);
              }
            }
            unint64_t result = (unint64_t)&v92[3];
            int v335 = v85 + 3;
            unsigned int v336 = HIBYTE(v328);
            if (HIBYTE(v328) == 255)
            {
              *(void *)unint64_t result = v91;
              *int v335 = v90;
            }
            else if (v336)
            {
              unint64_t result = (unint64_t)cmyk64_DAplusDAM((void *)result, v335, *(void *)(v89 + 16 * v336), *(_WORD *)(v89 + 16 * v336 + 8), *(void *)result, *v335, (__PAIR64__(v336, v328) >> 24) ^ 0xFFFF);
            }
LABEL_442:
            while (1)
            {
              int v337 = v329;
              v92 += 4;
              v85 += 4;
              --v329;
              v94 += 4;
              if (v337 < 2) {
                break;
              }
              unsigned int v328 = *(_DWORD *)v94;
              if (*(_DWORD *)v94) {
                goto LABEL_424;
              }
            }
            if (!v330) {
              break;
            }
            unsigned int v330 = 0;
            unsigned int v328 = *(_DWORD *)v94 & v386;
          }
          v94 += v381;
          v92 += v373;
          v85 += v368;
          --v7;
        }
        while (v7);
      }
      else
      {
        unint64_t v281 = (v375 >> 3) - v385;
        int v282 = v106 + v385;
        if ((v94 & 3) != 0) {
          char v283 = v94 & 0xFC;
        }
        else {
          char v283 = v94;
        }
        if ((v94 & 3) != 0) {
          int v284 = -1 << (8 * v106);
        }
        else {
          int v284 = -1;
        }
        if ((v94 & 3) != 0) {
          int v285 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else {
          int v285 = (unsigned int *)v94;
        }
        if ((v94 & 3) != 0) {
          v92 -= v94 & 3;
        }
        else {
          int v282 = v385;
        }
        if ((((_BYTE)v282 + v283) & 3) != 0)
        {
          int v286 = 4 - (((_BYTE)v282 + v283) & 3);
          v106 += v286;
          unsigned int v287 = 0xFFFFFFFF >> (8 * v286);
          if (v282 >= 4) {
            unsigned int v288 = 0xFFFFFFFF >> (8 * v286);
          }
          else {
            unsigned int v288 = 0;
          }
          if (v282 >= 4) {
            unsigned int v287 = -1;
          }
          int v388 = v287 & v284;
        }
        else
        {
          int v388 = v284;
          unsigned int v288 = 0;
        }
        int v350 = v282 >> 2;
        unint64_t v378 = v281 - v106;
        uint64_t v383 = v380 - v106;
        do
        {
          unsigned int v351 = *v285 & v388;
          int v352 = v350;
          unsigned int v353 = v288;
          if (!v351) {
            goto LABEL_491;
          }
LABEL_473:
          if (v351 == -1)
          {
            *unint64_t v92 = (int8x8_t)v91;
            v92[1] = (int8x8_t)v91;
            v92[2] = (int8x8_t)v91;
            v92[3] = (int8x8_t)v91;
            goto LABEL_491;
          }
          while (1)
          {
            if ((_BYTE)v351)
            {
              if (v351 == 255) {
                *unint64_t v92 = (int8x8_t)v91;
              }
              else {
                cmyk64_DplusDM(v92, *(void *)(v89 + 16 * v351), (unint64_t)*v92, (v351 | (v351 << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE1(v351))
            {
              int v354 = (uint64_t *)&v92[1];
              if (BYTE1(v351) == 255) {
                *int v354 = v91;
              }
              else {
                cmyk64_DplusDM(v354, *(void *)(v89 + 16 * BYTE1(v351)), *v354, (BYTE1(v351) | (BYTE1(v351) << 8)) ^ 0xFFFF);
              }
            }
            if (BYTE2(v351))
            {
              v355 = (uint64_t *)&v92[2];
              if (BYTE2(v351) == 255) {
                uint64_t *v355 = v91;
              }
              else {
                cmyk64_DplusDM(v355, *(void *)(v89 + 16 * BYTE2(v351)), *v355, (BYTE2(v351) | (BYTE2(v351) << 8)) ^ 0xFFFF);
              }
            }
            unint64_t result = (unint64_t)&v92[3];
            if (HIBYTE(v351) == 255)
            {
              *(void *)unint64_t result = v91;
            }
            else if (HIBYTE(v351))
            {
              unint64_t result = (unint64_t)cmyk64_DplusDM((void *)result, *(void *)(v89 + 16 * HIBYTE(v351)), *(void *)result, (__PAIR64__(HIBYTE(v351), v351) >> 24) ^ 0xFFFF);
            }
LABEL_491:
            while (1)
            {
              int v356 = v352;
              v92 += 4;
              --v352;
              ++v285;
              if (v356 < 2) {
                break;
              }
              unsigned int v351 = *v285;
              if (*v285) {
                goto LABEL_473;
              }
            }
            if (!v353) {
              break;
            }
            unsigned int v353 = 0;
            unsigned int v351 = *v285 & v288;
          }
          int v285 = (unsigned int *)((char *)v285 + v383);
          v92 += v378;
          --v7;
        }
        while (v7);
      }
      return result;
    case 2:
      unsigned __int16 v377 = ~(_WORD)v90;
      unsigned int v114 = v94 & 3;
      if (!v3)
      {
        int v289 = v114 + v385;
        int32x2_t v290 = &v92[-(v94 & 3)];
        if ((v94 & 3) != 0) {
          char v291 = v94 & 0xFC;
        }
        else {
          char v291 = v94;
        }
        if ((v94 & 3) != 0) {
          int v292 = -1 << (8 * v114);
        }
        else {
          int v292 = -1;
        }
        if ((v94 & 3) != 0)
        {
          v94 &= 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v92 = v290;
        }
        else
        {
          int v289 = v385;
        }
        if ((((_BYTE)v289 + v291) & 3) != 0)
        {
          int v293 = 4 - (((_BYTE)v289 + v291) & 3);
          v114 += v293;
          unsigned int v294 = 0xFFFFFFFF >> (8 * v293);
          if (v289 >= 4) {
            unsigned int v295 = -1;
          }
          else {
            unsigned int v295 = 0xFFFFFFFF >> (8 * v293);
          }
          int v389 = v295 & v292;
          if (v289 >= 4) {
            unsigned int v296 = v294;
          }
          else {
            unsigned int v296 = 0;
          }
        }
        else
        {
          int v389 = v292;
          unsigned int v296 = 0;
        }
        uint64_t v384 = v380 - v114;
        int v357 = v289 >> 2;
        unint64_t v374 = v95 - v114;
        while (1)
        {
          unsigned int v358 = *(_DWORD *)v94 & v389;
          unsigned int v359 = v296;
          int v360 = v357;
          if (!v358) {
            goto LABEL_512;
          }
LABEL_501:
          if (v358 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v358) {
              unint64_t result = (unint64_t)cmyk64_DplusDM(v92, *(void *)(v89 + 16 * v358), (unint64_t)*v92, *(unsigned __int16 *)(v89 + 16 * v358 + 8) ^ 0xFFFFu);
            }
            if ((v358 & 0xFF00) != 0) {
              unint64_t result = (unint64_t)cmyk64_DplusDM(&v92[1], *(void *)(v89 + 16 * BYTE1(v358)), *(void *)&v92[1], *(unsigned __int16 *)(v89 + 16 * BYTE1(v358) + 8) ^ 0xFFFFu);
            }
            if ((v358 & 0xFF0000) != 0) {
              unint64_t result = (unint64_t)cmyk64_DplusDM(&v92[2], *(void *)(v89 + 16 * BYTE2(v358)), *(void *)&v92[2], *(unsigned __int16 *)(v89 + 16 * BYTE2(v358) + 8) ^ 0xFFFFu);
            }
            if (HIBYTE(v358))
            {
              uint64_t v365 = v89 + 16 * HIBYTE(v358);
              uint64_t v363 = *(void *)v365;
              unint64_t v361 = v92 + 3;
              unint64_t v362 = (unint64_t)v92[3];
              int v364 = *(unsigned __int16 *)(v365 + 8) ^ 0xFFFF;
              goto LABEL_511;
            }
LABEL_512:
            while (1)
            {
              int v366 = v360;
              v92 += 4;
              --v360;
              v94 += 4;
              if (v366 < 2) {
                break;
              }
              unsigned int v358 = *(_DWORD *)v94;
              if (*(_DWORD *)v94) {
                goto LABEL_501;
              }
            }
            if (!v359) {
              break;
            }
            unsigned int v359 = 0;
            unsigned int v358 = *(_DWORD *)v94 & v296;
          }
          v94 += v384;
          v92 += v374;
          if (!--v7) {
            return result;
          }
        }
        cmyk64_DplusDM(v92, v91, (unint64_t)*v92, v377);
        cmyk64_DplusDM(&v92[1], v91, *(void *)&v92[1], v377);
        cmyk64_DplusDM(&v92[2], v91, *(void *)&v92[2], v377);
        unint64_t v361 = v92 + 3;
        unint64_t v362 = (unint64_t)v92[3];
        uint64_t v363 = v91;
        int v364 = v377;
LABEL_511:
        unint64_t result = (unint64_t)cmyk64_DplusDM(v361, v363, v362, v364);
        goto LABEL_512;
      }
      int v115 = v114 + v385;
      if ((v94 & 3) != 0) {
        char v116 = v94 & 0xFC;
      }
      else {
        char v116 = v94;
      }
      if ((v94 & 3) != 0) {
        unint64_t result = (-1 << (8 * v114));
      }
      else {
        unint64_t result = 0xFFFFFFFFLL;
      }
      if ((v94 & 3) != 0) {
        unint64_t v117 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else {
        unint64_t v117 = (unsigned int *)v94;
      }
      if ((v94 & 3) != 0)
      {
        v85 -= v94 & 3;
        v92 -= v94 & 3;
      }
      else
      {
        int v115 = v385;
      }
      if ((((_BYTE)v115 + v116) & 3) != 0)
      {
        int v118 = 4 - (((_BYTE)v115 + v116) & 3);
        v114 += v118;
        unsigned int v119 = 0xFFFFFFFF >> (8 * v118);
        if (v115 >= 4) {
          unsigned int v120 = -1;
        }
        else {
          unsigned int v120 = 0xFFFFFFFF >> (8 * v118);
        }
        unint64_t result = v120 & result;
        int v372 = result;
        if (v115 < 4) {
          unsigned int v119 = 0;
        }
        unsigned int v387 = v119;
      }
      else
      {
        int v372 = result;
        unsigned int v387 = 0;
      }
      uint64_t v382 = v380 - v114;
      unint64_t v371 = v95 - v114;
      int v369 = v115 >> 2;
      unint64_t v367 = v87 - v114;
      do
      {
        unsigned int v338 = *v117 & v372;
        unsigned int v339 = v387;
        int v340 = v369;
        if (!v338) {
          goto LABEL_463;
        }
LABEL_452:
        if (v338 == -1)
        {
          cmyk64_DAplusDAM(v92, v85, v91, v90, (unint64_t)*v92, *v85, (unsigned __int16)~(_WORD)v90);
          cmyk64_DAplusDAM(&v92[1], v85 + 1, v91, v90, *(void *)&v92[1], v85[1], (unsigned __int16)~(_WORD)v90);
          cmyk64_DAplusDAM(&v92[2], v85 + 2, v91, v90, *(void *)&v92[2], v85[2], (unsigned __int16)~(_WORD)v90);
          uint64_t v341 = v92 + 3;
          unint64_t v342 = (unint64_t)v92[3];
          uint64_t v343 = v85 + 3;
          int v344 = v85[3];
          uint64_t v345 = v91;
          LOWORD(v346) = v90;
          int v347 = (unsigned __int16)~(_WORD)v90;
LABEL_462:
          unint64_t result = (unint64_t)cmyk64_DAplusDAM(v341, v343, v345, v346, v342, v344, v347);
          goto LABEL_463;
        }
        while (1)
        {
          if ((_BYTE)v338) {
            unint64_t result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(void *)(v89 + 16 * v338), *(_WORD *)(v89 + 16 * v338 + 8), (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * v338 + 8) ^ 0xFFFFu);
          }
          if ((v338 & 0xFF00) != 0) {
            unint64_t result = (unint64_t)cmyk64_DAplusDAM(&v92[1], v85 + 1, *(void *)(v89 + 16 * BYTE1(v338)), *(_WORD *)(v89 + 16 * BYTE1(v338) + 8), *(void *)&v92[1], v85[1], *(unsigned __int16 *)(v89 + 16 * BYTE1(v338) + 8) ^ 0xFFFFu);
          }
          if ((v338 & 0xFF0000) != 0) {
            unint64_t result = (unint64_t)cmyk64_DAplusDAM(&v92[2], v85 + 2, *(void *)(v89 + 16 * BYTE2(v338)), *(_WORD *)(v89 + 16 * BYTE2(v338) + 8), *(void *)&v92[2], v85[2], *(unsigned __int16 *)(v89 + 16 * BYTE2(v338) + 8) ^ 0xFFFFu);
          }
          if (HIBYTE(v338))
          {
            uint64_t v348 = v89 + 16 * HIBYTE(v338);
            uint64_t v345 = *(void *)v348;
            int v346 = *(unsigned __int16 *)(v348 + 8);
            uint64_t v341 = v92 + 3;
            unint64_t v342 = (unint64_t)v92[3];
            uint64_t v343 = v85 + 3;
            int v344 = v85[3];
            int v347 = v346 ^ 0xFFFF;
            goto LABEL_462;
          }
LABEL_463:
          while (1)
          {
            int v349 = v340;
            v92 += 4;
            v85 += 4;
            --v340;
            ++v117;
            if (v349 < 2) {
              break;
            }
            unsigned int v338 = *v117;
            if (*v117) {
              goto LABEL_452;
            }
          }
          if (!v339) {
            break;
          }
          unsigned int v339 = 0;
          unsigned int v338 = *v117 & v387;
        }
        unint64_t v117 = (unsigned int *)((char *)v117 + v382);
        v92 += v371;
        v85 += v367;
        --v7;
      }
      while (v7);
      return result;
    case 3:
      uint64_t v121 = 2 * v86;
      do
      {
        int v122 = v385;
        do
        {
          int v123 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94)
          {
            if (v123 == 255)
            {
              uint64_t v124 = (int8x8_t *)(v89 + (((unint64_t)*v85 >> 4) & 0xFF0));
              int8x8_t v125 = *v124;
              LOWORD(v124) = v124[1].i16[0];
              *unint64_t v92 = v125;
              *unsigned int v85 = (unsigned __int16)v124;
            }
            else
            {
              int v126 = v123 | (v123 << 8);
              int v127 = *v85;
              uint64_t v128 = v89 + 16 * ((v127 * v126 + ((v127 * v126) >> 16) + 1) >> 24);
              unint64_t result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(void *)v128, *(_WORD *)(v128 + 8), (unint64_t)*v92, v127, v126 ^ 0xFFFFu);
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v121);
          --v122;
        }
        while (v122);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 4:
      uint64_t v129 = 2 * v86;
      do
      {
        int v130 = v385;
        do
        {
          int v131 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94)
          {
            if (v131 == 255)
            {
              uint64_t v132 = (int8x8_t *)(v89 + 16 * ((unsigned __int16)~*v85 >> 8));
              int8x8_t v133 = *v132;
              LOWORD(v132) = v132[1].i16[0];
              *unint64_t v92 = v133;
              *unsigned int v85 = (unsigned __int16)v132;
            }
            else
            {
              int v134 = v131 | (v131 << 8);
              int v135 = *v85;
              uint64_t v136 = v89 + 16 * (((v135 ^ 0xFFFF) * v134 + (((v135 ^ 0xFFFFu) * v134) >> 16) + 1) >> 24);
              unint64_t result = (unint64_t)cmyk64_DAplusDAM(v92, v85, *(void *)v136, *(_WORD *)(v136 + 8), (unint64_t)*v92, v135, v134 ^ 0xFFFFu);
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v129);
          --v130;
        }
        while (v130);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 5:
      uint64_t v137 = 2 * v86;
      do
      {
        int v138 = v385;
        do
        {
          if (*(unsigned char *)v94) {
            unint64_t result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(void *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8), *v85, (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8) ^ 0xFFFFu);
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v137);
          --v138;
        }
        while (v138);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 6:
      uint64_t v139 = 2 * v86;
      do
      {
        unint64_t v140 = v95;
        int v141 = v385;
        do
        {
          uint64_t v142 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94 && *v85 != 0xFFFF)
          {
            if ((unsigned __int16)~*v85 == 0xFFFF)
            {
              uint64_t v143 = (int8x8_t *)(v89 + 16 * v142);
              int8x8_t v144 = *v143;
              LOWORD(v143) = v143[1].i16[0];
              *unint64_t v92 = v144;
              *unsigned int v85 = (unsigned __int16)v143;
            }
            else
            {
              unint64_t result = (unint64_t)cmyk64_DAplusDAM(v92, v85, (uint64_t)*v92, *v85, *(void *)(v89 + 16 * v142), *(unsigned __int16 *)(v89 + 16 * v142 + 8), (unsigned __int16)~*v85);
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v139);
          --v141;
        }
        while (v141);
        v94 += v380;
        unint64_t v95 = v140;
        v92 += v140;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 7:
      int32x2_t v145 = vdup_n_s32(v90 ^ 0xFFFF);
      if (v3)
      {
        uint64_t v146 = 2 * v86;
        do
        {
          int v147 = v385;
          do
          {
            int v148 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v148 == 255)
              {
                int32x2_t v149 = (int32x2_t)*v92;
                int v150 = *v85;
                unsigned int v151 = (v90 ^ 0xFFFF) * v150 + (((v90 ^ 0xFFFF) * v150) >> 16) + 1;
                uint32x2_t v152 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v145);
                v153.i32[0] = HIWORD(v92->u32[0]);
                v153.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v154 = (uint32x2_t)vmul_s32(v153, v145);
              }
              else
              {
                int v155 = v148 | (v148 << 8);
                int32x2_t v149 = (int32x2_t)*v92;
                int v150 = *v85;
                unsigned int v156 = (unsigned __int16)(v155 - ((v155 * v90 + ((v155 * v90) >> 16) + 1) >> 16));
                unsigned int v151 = v156 * v150 + ((v156 * v150) >> 16) + 1;
                int32x2_t v157 = vdup_n_s32(v156);
                uint32x2_t v152 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v157);
                v153.i32[0] = HIWORD(v92->u32[0]);
                v153.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v154 = (uint32x2_t)vmul_s32(v153, v157);
              }
              *unint64_t v92 = (int8x8_t)vsli_n_s32(vsub_s32(v149, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v152, v152, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v153, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v154, v154, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *unsigned int v85 = v150 - HIWORD(v151);
            }
            ++v94;
            ++v92;
            unsigned int v85 = (unsigned __int16 *)((char *)v85 + v146);
            --v147;
          }
          while (v147);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v297 = v385;
          do
          {
            int v298 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              int32x2_t v299 = (int32x2_t)*v92;
              v300.i32[0] = vshr_n_u32((uint32x2_t)*v92, 0x10uLL).u32[0];
              v300.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
              if (v298 == 255)
              {
                uint32x2_t v301 = (uint32x2_t)vmul_s32(v300, v145);
                v302.i32[0] = v92->u16[0];
                v302.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v303 = (uint32x2_t)vmul_s32(v302, v145);
                v300.i32[1] = HIDWORD(*(unint64_t *)v92);
                int32x2_t v304 = vsub_s32(v300, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v301, v301, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v299.i32[1] = HIWORD(*(unint64_t *)v92);
                int32x2_t v305 = vsub_s32(v299, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v303, v303, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              else
              {
                int32x2_t v306 = vdup_n_s32((unsigned __int16)((v298 | ((_WORD)v298 << 8))
                                                   - (((v298 | (v298 << 8)) * v90
                                                     + (((v298 | (v298 << 8)) * v90) >> 16)
                                                     + 1) >> 16)));
                uint32x2_t v307 = (uint32x2_t)vmul_s32(v300, v306);
                v308.i32[0] = v92->u16[0];
                v308.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v309 = (uint32x2_t)vmul_s32(v308, v306);
                v300.i32[1] = HIDWORD(*(unint64_t *)v92);
                int32x2_t v304 = vsub_s32(v300, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v307, v307, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v299.i32[1] = v308.i32[1];
                int32x2_t v305 = vsub_s32(v299, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v309, v309, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              v310.i32[0] = v305.u16[0];
              v310.i32[1] = vshl_n_s32(v305, 0x10uLL).i32[1];
              v311.i32[0] = vshl_n_s32(v304, 0x10uLL).u32[0];
              v311.i32[1] = v304.u16[2];
              *unint64_t v92 = vorr_s8(v311, v310);
            }
            ++v94;
            ++v92;
            --v297;
          }
          while (v297);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 8:
      int v158 = 257 * v90;
      int32x2_t v159 = vdup_n_s32(v90);
      if (v3)
      {
        uint64_t v160 = 2 * v86;
        do
        {
          int v161 = v385;
          do
          {
            int v162 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              int v163 = *v85;
              if (v162 == 255)
              {
                unsigned int v164 = v90 * v163 + ((v90 * v163) >> 16) + 1;
                uint32x2_t v165 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v159);
                v166.i32[0] = HIWORD(v92->u32[0]);
                v166.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v167 = (uint32x2_t)vmul_s32(v166, v159);
              }
              else
              {
                unsigned int v168 = (v158 * v162 + ((v158 * v162) >> 16) + 1) >> 16;
                unsigned int v164 = v168 * v163 + ((v168 * v163) >> 16) + 1;
                int32x2_t v169 = vdup_n_s32(v168);
                uint32x2_t v165 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v92, (int8x8_t)0xFFFF0000FFFFLL), v169);
                v166.i32[0] = HIWORD(v92->u32[0]);
                v166.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v167 = (uint32x2_t)vmul_s32(v166, v169);
              }
              *unint64_t v92 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v92, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v165, v165, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v166, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v167, v167, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *unsigned int v85 = v163 - HIWORD(v164);
            }
            ++v94;
            ++v92;
            unsigned int v85 = (unsigned __int16 *)((char *)v85 + v160);
            --v161;
          }
          while (v161);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v312 = v385;
          do
          {
            int v313 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              int32x2_t v314 = (int32x2_t)*v92;
              v315.i32[0] = vshr_n_u32((uint32x2_t)*v92, 0x10uLL).u32[0];
              v315.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v92);
              if (v313 == 255)
              {
                uint32x2_t v316 = (uint32x2_t)vmul_s32(v315, v159);
                v317.i32[0] = v92->u16[0];
                v317.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v318 = (uint32x2_t)vmul_s32(v317, v159);
                v315.i32[1] = HIDWORD(*(unint64_t *)v92);
                int32x2_t v319 = vsub_s32(v315, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v316, v316, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v314.i32[1] = HIWORD(*(unint64_t *)v92);
                int32x2_t v320 = vsub_s32(v314, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v318, v318, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              else
              {
                int32x2_t v321 = vdup_n_s32((v158 * v313 + ((v158 * v313) >> 16) + 1) >> 16);
                uint32x2_t v322 = (uint32x2_t)vmul_s32(v315, v321);
                v323.i32[0] = v92->u16[0];
                v323.i32[1] = HIWORD(*(unint64_t *)v92);
                uint32x2_t v324 = (uint32x2_t)vmul_s32(v323, v321);
                v315.i32[1] = HIDWORD(*(unint64_t *)v92);
                int32x2_t v319 = vsub_s32(v315, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v322, v322, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v314.i32[1] = v323.i32[1];
                int32x2_t v320 = vsub_s32(v314, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v324, v324, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              }
              v325.i32[0] = v320.u16[0];
              v325.i32[1] = vshl_n_s32(v320, 0x10uLL).i32[1];
              v326.i32[0] = vshl_n_s32(v319, 0x10uLL).u32[0];
              v326.i32[1] = v319.u16[2];
              *unint64_t v92 = vorr_s8(v326, v325);
            }
            ++v94;
            ++v92;
            --v312;
          }
          while (v312);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 9:
      uint64_t v170 = 2 * v86;
      do
      {
        int v171 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            unsigned int v172 = *(unsigned __int8 *)v94;
            unint64_t result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(void *)(v89 + 16 * v172), *(unsigned __int16 *)(v89 + 16 * v172 + 8), *v85 ^ 0xFFFFu, (unint64_t)*v92, *v85, (unsigned __int16)(*(_WORD *)(v89 + 16 * v172 + 8)+ ~(v172 | ((_WORD)v172 << 8))));
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v170);
          --v171;
        }
        while (v171);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 10:
      uint64_t v173 = 2 * v86;
      do
      {
        int v174 = v385;
        do
        {
          if (*(unsigned char *)v94) {
            unint64_t result = (unint64_t)cmyk64_DAMplusDAM((unsigned int *)v92, v85, *(void *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8), *v85 ^ 0xFFFFu, (unint64_t)*v92, *v85, *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8) ^ 0xFFFFu);
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v173);
          --v174;
        }
        while (v174);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 11:
      if (v3)
      {
        uint64_t v175 = 2 * v86;
        do
        {
          int v176 = v385;
          do
          {
            if (*(unsigned char *)v94) {
              unint64_t result = (unint64_t)cmyk64_DAplusdDA((int *)v92, (__int16 *)v85, (unint64_t)*v92, *v85, *(void *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            unsigned int v85 = (unsigned __int16 *)((char *)v85 + v175);
            --v176;
          }
          while (v176);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v177 = v385;
          do
          {
            if (*(unsigned char *)v94) {
              unint64_t result = (unint64_t)cmyk64_DplusdDA((int *)v92, (unint64_t)*v92, *(void *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            --v177;
          }
          while (v177);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 12:
      if (v3)
      {
        uint64_t v178 = 2 * v86;
        do
        {
          int v179 = v385;
          do
          {
            if (*(unsigned char *)v94) {
              unint64_t result = (unint64_t)cmyk64_DApluslDA((unsigned int *)v92, v85, (unint64_t)*v92, *v85, *(void *)(v89 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v89 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            unsigned int v85 = (unsigned __int16 *)((char *)v85 + v178);
            --v179;
          }
          while (v179);
          v94 += v380;
          v92 += v95;
          v85 += v88;
          --v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v180 = v385;
          do
          {
            if (*(unsigned char *)v94) {
              unint64_t result = (unint64_t)cmyk64_DpluslD((unsigned int *)v92, (unint64_t)*v92, *(void *)(v89 + 16 * *(unsigned __int8 *)v94));
            }
            ++v94;
            ++v92;
            --v180;
          }
          while (v180);
          v94 += v380;
          v92 += v95;
          --v7;
        }
        while (v7);
      }
      return result;
    case 13:
      uint64_t v181 = 2 * v86;
      do
      {
        int v182 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v183 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v184 = *(unsigned __int16 *)(v183 + 8);
            if (*(_WORD *)(v183 + 8))
            {
              unint64_t v185 = *(void *)v183;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAmultiplyPDA_11710((unint64_t)*v92, *v85, v185, v184);
                  unint64_t v185 = result;
                  LOWORD(v184) = v186;
                }
                *unint64_t v92 = (int8x8_t)v185;
                *unsigned int v85 = v184;
              }
              else
              {
                unint64_t result = PDAmultiplyPDA_11710((unint64_t)*v92, 0xFFFFu, v185, v184);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v181);
          --v182;
        }
        while (v182);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 14:
      uint64_t v187 = 2 * v86;
      do
      {
        int v188 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v189 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v190 = *(unsigned __int16 *)(v189 + 8);
            if (*(_WORD *)(v189 + 8))
            {
              unint64_t v191 = *(void *)v189;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAscreenPDA_11711((unint64_t)*v92, *v85, v191, v190);
                  unint64_t v191 = result;
                  LOWORD(v190) = v192;
                }
                *unint64_t v92 = (int8x8_t)v191;
                *unsigned int v85 = v190;
              }
              else
              {
                unint64_t result = PDAscreenPDA_11711((unint64_t)*v92, 0xFFFFu, v191, v190);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v187);
          --v188;
        }
        while (v188);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 15:
      uint64_t v193 = 2 * v86;
      do
      {
        int v194 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v195 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v196 = *(unsigned __int16 *)(v195 + 8);
            if (*(_WORD *)(v195 + 8))
            {
              unint64_t v197 = *(void *)v195;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAoverlayPDA_11712((unint64_t)*v92, *v85, v197, v196);
                  unint64_t v197 = result;
                  LOWORD(v196) = v198;
                }
                *unint64_t v92 = (int8x8_t)v197;
                *unsigned int v85 = v196;
              }
              else
              {
                unint64_t result = PDAoverlayPDA_11712((unint64_t)*v92, 0xFFFFu, v197, v196);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v193);
          --v194;
        }
        while (v194);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 16:
      uint64_t v199 = 2 * v86;
      do
      {
        int v200 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v201 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v202 = *(unsigned __int16 *)(v201 + 8);
            if (*(_WORD *)(v201 + 8))
            {
              unint64_t v203 = *(void *)v201;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAdarkenPDA_11714((unint64_t)*v92, *v85, v203, v202);
                  unint64_t v203 = result;
                  LOWORD(v202) = v204;
                }
                *unint64_t v92 = (int8x8_t)v203;
                *unsigned int v85 = v202;
              }
              else
              {
                unint64_t result = PDAdarkenPDA_11714((unint64_t)*v92, 0xFFFFu, v203, v202);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v199);
          --v200;
        }
        while (v200);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 17:
      uint64_t v205 = 2 * v86;
      do
      {
        int v206 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v207 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v208 = *(unsigned __int16 *)(v207 + 8);
            if (*(_WORD *)(v207 + 8))
            {
              unint64_t v209 = *(void *)v207;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAlightenPDA_11713((unint64_t)*v92, *v85, v209, v208);
                  unint64_t v209 = result;
                  LOWORD(v208) = v210;
                }
                *unint64_t v92 = (int8x8_t)v209;
                *unsigned int v85 = v208;
              }
              else
              {
                unint64_t result = PDAlightenPDA_11713((unint64_t)*v92, 0xFFFFu, v209, v208);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v205);
          --v206;
        }
        while (v206);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 18:
      uint64_t v211 = 2 * v86;
      do
      {
        int v212 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v213 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v214 = *(unsigned __int16 *)(v213 + 8);
            if (*(_WORD *)(v213 + 8))
            {
              unint64_t v215 = *(void *)v213;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAcolordodgePDA_11715((unint64_t)*v92, *v85, v215, v214);
                  unint64_t v215 = result;
                  LOWORD(v214) = v216;
                }
                *unint64_t v92 = (int8x8_t)v215;
                *unsigned int v85 = v214;
              }
              else
              {
                unint64_t result = PDAcolordodgePDA_11715((unint64_t)*v92, 0xFFFFu, v215, v214);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v211);
          --v212;
        }
        while (v212);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 19:
      uint64_t v217 = 2 * v86;
      do
      {
        int v218 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v219 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v220 = *(unsigned __int16 *)(v219 + 8);
            if (*(_WORD *)(v219 + 8))
            {
              unint64_t v221 = *(void *)v219;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAcolorburnPDA_11716((unint64_t)*v92, *v85, v221, v220);
                  unint64_t v221 = result;
                  LOWORD(v220) = v222;
                }
                *unint64_t v92 = (int8x8_t)v221;
                *unsigned int v85 = v220;
              }
              else
              {
                unint64_t result = PDAcolorburnPDA_11716((unint64_t)*v92, 0xFFFFu, v221, v220);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v217);
          --v218;
        }
        while (v218);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 20:
      uint64_t v223 = 2 * v86;
      do
      {
        int v224 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v225 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v226 = *(unsigned __int16 *)(v225 + 8);
            if (*(_WORD *)(v225 + 8))
            {
              unint64_t v227 = *(void *)v225;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAsoftlightPDA_11718((unint64_t)*v92, *v85, v227, v226);
                  unint64_t v227 = result;
                  LOWORD(v226) = v228;
                }
                *unint64_t v92 = (int8x8_t)v227;
                *unsigned int v85 = v226;
              }
              else
              {
                unint64_t result = PDAsoftlightPDA_11718((unint64_t)*v92, 0xFFFFu, v227, v226);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v223);
          --v224;
        }
        while (v224);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 21:
      uint64_t v229 = 2 * v86;
      do
      {
        int v230 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v231 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v232 = *(unsigned __int16 *)(v231 + 8);
            if (*(_WORD *)(v231 + 8))
            {
              unint64_t v233 = *(void *)v231;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAhardlightPDA_11717((unint64_t)*v92, *v85, v233, v232);
                  unint64_t v233 = result;
                  LOWORD(v232) = v234;
                }
                *unint64_t v92 = (int8x8_t)v233;
                *unsigned int v85 = v232;
              }
              else
              {
                unint64_t result = PDAhardlightPDA_11717((unint64_t)*v92, 0xFFFFu, v233, v232);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v229);
          --v230;
        }
        while (v230);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 22:
      uint64_t v235 = 2 * v86;
      do
      {
        int v236 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v237 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v238 = *(unsigned __int16 *)(v237 + 8);
            if (*(_WORD *)(v237 + 8))
            {
              unint64_t v239 = *(void *)v237;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAdifferencePDA_11719((unint64_t)*v92, *v85, v239, v238);
                  unint64_t v239 = result;
                  LOWORD(v238) = v240;
                }
                *unint64_t v92 = (int8x8_t)v239;
                *unsigned int v85 = v238;
              }
              else
              {
                unint64_t result = PDAdifferencePDA_11719((unint64_t)*v92, 0xFFFFu, v239, v238);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v235);
          --v236;
        }
        while (v236);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 23:
      uint64_t v241 = 2 * v86;
      do
      {
        int v242 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v243 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v244 = *(unsigned __int16 *)(v243 + 8);
            if (*(_WORD *)(v243 + 8))
            {
              unint64_t v245 = *(void *)v243;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAexclusionPDA_11720((unint64_t)*v92, *v85, v245, v244);
                  unint64_t v245 = result;
                  LOWORD(v244) = v246;
                }
                *unint64_t v92 = (int8x8_t)v245;
                *unsigned int v85 = v244;
              }
              else
              {
                unint64_t result = PDAexclusionPDA_11720((unint64_t)*v92, 0xFFFFu, v245, v244);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v241);
          --v242;
        }
        while (v242);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 24:
      uint64_t v247 = 2 * v86;
      do
      {
        int v248 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v249 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v250 = *(unsigned __int16 *)(v249 + 8);
            if (*(_WORD *)(v249 + 8))
            {
              unint64_t v251 = *(void *)v249;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAhuePDA_11721((unint64_t)*v92, *v85, v251, v250);
                  unint64_t v251 = result;
                  LOWORD(v250) = v252;
                }
                *unint64_t v92 = (int8x8_t)v251;
                *unsigned int v85 = v250;
              }
              else
              {
                unint64_t result = PDAhuePDA_11721((unint64_t)*v92, 0xFFFFu, v251, v250);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v247);
          --v248;
        }
        while (v248);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 25:
      uint64_t v253 = 2 * v86;
      do
      {
        int v254 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v255 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v256 = *(unsigned __int16 *)(v255 + 8);
            if (*(_WORD *)(v255 + 8))
            {
              unint64_t v257 = *(void *)v255;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAsaturationPDA_11722((unint64_t)*v92, *v85, v257, v256);
                  unint64_t v257 = result;
                  LOWORD(v256) = v258;
                }
                *unint64_t v92 = (int8x8_t)v257;
                *unsigned int v85 = v256;
              }
              else
              {
                unint64_t result = PDAsaturationPDA_11722((unint64_t)*v92, 0xFFFFu, v257, v256);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v253);
          --v254;
        }
        while (v254);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 26:
      uint64_t v259 = 2 * v86;
      do
      {
        int v260 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v261 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v262 = *(unsigned __int16 *)(v261 + 8);
            if (*(_WORD *)(v261 + 8))
            {
              unint64_t result = *(void *)v261;
              if (v3)
              {
                if (*v85) {
                  unint64_t result = PDAluminosityPDA_11723(result, v262, (unint64_t)*v92, *v85);
                }
                *unint64_t v92 = (int8x8_t)result;
                *unsigned int v85 = v262;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_11723(result, v262, (unint64_t)*v92, 0xFFFFu);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v259);
          --v260;
        }
        while (v260);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    case 27:
      uint64_t v263 = 2 * v86;
      do
      {
        int v264 = v385;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v265 = v89 + 16 * *(unsigned __int8 *)v94;
            unsigned int v266 = *(unsigned __int16 *)(v265 + 8);
            if (*(_WORD *)(v265 + 8))
            {
              unint64_t v267 = *(void *)v265;
              if (v3)
              {
                if (*v85)
                {
                  unint64_t result = PDAluminosityPDA_11723((unint64_t)*v92, *v85, v267, v266);
                  unint64_t v267 = result;
                  LOWORD(v266) = v268;
                }
                *unint64_t v92 = (int8x8_t)v267;
                *unsigned int v85 = v266;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_11723((unint64_t)*v92, 0xFFFFu, v267, v266);
                *unint64_t v92 = (int8x8_t)result;
              }
            }
          }
          ++v94;
          ++v92;
          unsigned int v85 = (unsigned __int16 *)((char *)v85 + v263);
          --v264;
        }
        while (v264);
        v94 += v380;
        v92 += v95;
        v85 += v88;
        --v7;
      }
      while (v7);
      return result;
    default:
      return result;
  }
}

uint64_t cmyk64_mark_pixelmask(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  uint64_t v4 = *(int *)(result + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(result + 32) >> 1;
    int v7 = (__int16 *)(v2 + 2 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    int v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v9 = *(_DWORD *)(result + 4);
  int v10 = *(_DWORD *)(result + 8);
  unint64_t v12 = *(void *)(result + 88);
  uint64_t v11 = *(__int16 **)(result + 96);
  unint64_t v13 = (unint64_t)*(int *)(result + 28) >> 3;
  uint64_t v14 = (int8x8_t *)(*(void *)(result + 40) + 8 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(result + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(result + 56);
  uint64_t v18 = *(int *)(result + 60);
  unint64_t v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v21 = *(_DWORD *)(result + 64);
    int v22 = *(_DWORD *)(result + 68);
    uint64_t v732 = v19 >> 3;
    if (v11)
    {
      unint64_t v730 = (unint64_t)*(int *)(result + 80) >> 1;
      int v20 = 1;
    }
    else
    {
      unint64_t v730 = 0;
      int v20 = 0;
    }
    unint64_t result = v12 + 8 * v732 * v22;
    v8 &= 1u;
    int v25 = 1;
    unint64_t v734 = v12;
    int32x4_t v23 = (unint64_t *)v12;
    goto LABEL_19;
  }
  uint64_t v732 = v19 >> 3;
  if (v11)
  {
    unint64_t v730 = (unint64_t)*(int *)(result + 80) >> 1;
    v11 += v17 + v730 * v18;
    int v20 = -1;
  }
  else
  {
    unint64_t v730 = 0;
    int v20 = 0;
  }
  int32x4_t v23 = (unint64_t *)(v12 + 8 * (v17 + v732 * v18));
  if (v732 == v13 && (char *)v14 - (char *)v23 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v23) >> 3))
    {
      v14 += v9 - 1;
      v23 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      int v25 = -1;
      uint64_t v732 = (unint64_t)*(int *)(result + 28) >> 3;
      v11 += v20 & (v9 - 1);
      goto LABEL_16;
    }
    uint64_t v24 = v10 - 1;
    if (v14 <= (int8x8_t *)&v23[v13 * v24 - 1 + v9])
    {
      v14 += v13 * v24;
      v16 += v15 * v24;
      uint64_t v15 = -v15;
      v7 += v6 * v24;
      unint64_t v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v730 * v24;
      unint64_t v730 = -(uint64_t)v730;
      v20 &= 1u;
      int v25 = 1;
      v23 += v13 * v24;
      uint64_t v732 = -(uint64_t)v13;
      unint64_t v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  int v25 = 1;
LABEL_16:
  unint64_t result = 0;
  unint64_t v734 = 0;
  unint64_t v12 = -1;
  int v22 = v730;
  int v21 = v732;
LABEL_19:
  int v26 = v25 * v9;
  int v731 = v9;
  unint64_t v727 = result;
  int v735 = v10;
  if (result)
  {
    uint64_t v27 = (int)v18 % v22;
    int32x4_t v28 = &v23[v732 * v27];
    unint64_t result = (int)v17 % v21;
    int32x4_t v23 = &v28[result];
    unint64_t v12 = (unint64_t)&v28[v21];
    if (v20) {
      v11 += v730 * v27 + result;
    }
    uint64_t v733 = v11;
    unint64_t v734 = (unint64_t)&v28[result];
  }
  else
  {
    v732 -= v26;
    uint64_t v733 = v11;
    v730 -= v20 * v9;
  }
  uint64_t v729 = v15 - v26;
  unint64_t v728 = v13 - v26;
  unint64_t v726 = v6 - v8 * v9;
  int v736 = v8;
  int v750 = v20;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          int v29 = v9;
          int v30 = v735;
          do
          {
            int v31 = *v16;
            if (*v16)
            {
              if (v31 == 255)
              {
                LOWORD(v32) = 0;
                *uint64_t v14 = 0;
              }
              else
              {
                int v33 = (unsigned __int16)*v7;
                unsigned int v34 = v31 | (v31 << 8);
                int32x2_t v35 = vdup_n_s32(v34);
                uint32x2_t v36 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v14, (int8x8_t)0xFFFF0000FFFFLL), v35);
                v37.i32[0] = HIWORD(v14->u32[0]);
                v37.i32[1] = HIWORD(*(unint64_t *)v14);
                uint32x2_t v38 = (uint32x2_t)vmul_s32(v37, v35);
                *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v14, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v36, v36, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v37, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v38, v38, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                int v32 = v33 - ((v34 * v33 + ((v34 * v33) >> 16) + 1) >> 16);
              }
              *int v7 = v32;
            }
            v16 += v25;
            v7 += v8;
            v14 += v25;
            --v29;
          }
          while (v29);
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v30 != 1);
      }
      else
      {
        do
        {
          int v532 = v9;
          int v533 = v735;
          do
          {
            int v534 = *v16;
            if (*v16)
            {
              if (v534 == 255)
              {
                *uint64_t v14 = 0;
              }
              else
              {
                int32x2_t v535 = (int32x2_t)*v14;
                v536.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v537.i32[0] = v536.i32[0];
                v537.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
                int32x2_t v538 = vdup_n_s32(v534 | (v534 << 8));
                uint32x2_t v539 = (uint32x2_t)vmul_s32(v537, v538);
                v540.i32[0] = v14->u16[0];
                v540.i32[1] = HIWORD(*(unint64_t *)v14);
                uint32x2_t v541 = (uint32x2_t)vmul_s32(v540, v538);
                v536.i32[1] = HIDWORD(*(unint64_t *)v14);
                uint32x2_t v542 = (uint32x2_t)vsub_s32(v536, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v539, v539, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v535.i32[1] = v540.i32[1];
                int8x8_t v543 = (int8x8_t)vsub_s32(v535, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v541, v541, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                int8x8_t v544 = (int8x8_t)vshl_n_s32((int32x2_t)v543, 0x10uLL);
                v543.i16[1] = 0;
                v543.i32[1] = v544.i32[1];
                v544.i32[0] = vshl_u32(v542, (uint32x2_t)0xFFFF00000010).u32[0];
                v544.i32[1] = v542.u16[2];
                *uint64_t v14 = vorr_s8(v544, v543);
              }
            }
            v16 += v25;
            v14 += v25;
            --v532;
          }
          while (v532);
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v533 != 1);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v39 = v25;
        if (v20)
        {
          uint64_t v40 = v20;
          uint64_t v41 = -(uint64_t)v21;
          int8x16_t v42 = v733;
          uint64_t v737 = -(v732 * v22);
          uint64_t v751 = v25;
          uint64_t v700 = -(uint64_t)(v730 * v22);
          uint64_t v43 = 2 * v8;
          uint64_t v44 = 8 * v39;
          do
          {
            int v45 = v731;
            unint64_t v758 = v12;
            do
            {
              int v46 = *v16;
              if (*v16)
              {
                if (v46 == 255)
                {
                  *uint64_t v14 = (int8x8_t)*v23;
                  *int v7 = *v42;
                }
                else
                {
                  uint64_t v47 = v43;
                  unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, (unsigned __int16)*v42, v46 | (v46 << 8), (unint64_t)*v14, (unsigned __int16)*v7, (v46 | (v46 << 8)) ^ 0xFFFFu);
                  uint64_t v43 = v47;
                  uint64_t v39 = v751;
                  unint64_t v12 = v758;
                }
              }
              v16 += v39;
              int32x4_t v48 = &v23[v39];
              if ((unint64_t)v48 >= v12) {
                uint64_t v49 = v41;
              }
              else {
                uint64_t v49 = 0;
              }
              v42 += v40 + v49;
              int32x4_t v23 = &v48[v49];
              int v7 = (__int16 *)((char *)v7 + v43);
              uint64_t v14 = (int8x8_t *)((char *)v14 + v44);
              --v45;
            }
            while (v45);
            if (v727)
            {
              unint64_t v50 = v734 + 8 * v732;
              uint64_t v51 = v700;
              if (v50 < v727) {
                uint64_t v51 = 0;
              }
              int8x16_t v42 = &v733[v730 + v51];
              uint64_t v52 = v737;
              if (v50 < v727) {
                uint64_t v52 = 0;
              }
              int32x4_t v23 = (unint64_t *)(v50 + 8 * v52);
              v12 += 8 * v52 + 8 * v732;
              v733 += v730 + v51;
              unint64_t v734 = (unint64_t)v23;
            }
            else
            {
              v23 += v732;
              v42 += v730;
            }
            v16 += v729;
            v14 += v728;
            v7 += v726;
            --v735;
          }
          while (v735);
        }
        else
        {
          uint64_t v652 = -(uint64_t)v21;
          uint64_t v789 = -(v732 * v22);
          uint64_t v653 = 2 * v8;
          do
          {
            int v654 = v731;
            do
            {
              int v655 = *v16;
              if (*v16)
              {
                if (v655 == 255)
                {
                  *uint64_t v14 = (int8x8_t)*v23;
                  *int v7 = -1;
                }
                else
                {
                  unint64_t v656 = v12;
                  unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, 0xFFFF, v655 | (v655 << 8), (unint64_t)*v14, (unsigned __int16)*v7, (v655 | (v655 << 8)) ^ 0xFFFFu);
                  unint64_t v12 = v656;
                }
              }
              v16 += v39;
              v657 = &v23[v39];
              if ((unint64_t)v657 >= v12) {
                uint64_t v658 = v652;
              }
              else {
                uint64_t v658 = 0;
              }
              int32x4_t v23 = &v657[v658];
              int v7 = (__int16 *)((char *)v7 + v653);
              v14 += v39;
              --v654;
            }
            while (v654);
            v16 += v729;
            v14 += v728;
            v7 += v726;
            unint64_t v659 = v734;
            unint64_t v660 = v734 + 8 * v732;
            uint64_t v661 = v789;
            if (v660 < v727) {
              uint64_t v661 = 0;
            }
            int v662 = (unint64_t *)(v660 + 8 * v661);
            uint64_t v663 = v12 + 8 * v661 + 8 * v732;
            if (v727)
            {
              unint64_t v12 = v663;
              unint64_t v659 = (unint64_t)v662;
              int32x4_t v23 = v662;
            }
            else
            {
              v23 += v732;
            }
            BOOL v664 = v735 == 1;
            unint64_t v734 = v659;
            --v735;
          }
          while (!v664);
        }
      }
      else
      {
        uint64_t v545 = v25;
        uint64_t v546 = -(uint64_t)v21;
        uint64_t v784 = -(v732 * v22);
        uint64_t v547 = 8 * v25;
        do
        {
          int v548 = v731;
          int v549 = v735;
          do
          {
            int v550 = *v16;
            if (*v16)
            {
              if (v550 == 255)
              {
                *uint64_t v14 = (int8x8_t)*v23;
              }
              else
              {
                unint64_t v551 = v12;
                unint64_t result = (uint64_t)cmyk64_DMplusDM((unsigned int *)v14, *v23, v550 | (v550 << 8), (unint64_t)*v14, (v550 | (v550 << 8)) ^ 0xFFFFu);
                unint64_t v12 = v551;
              }
            }
            v16 += v545;
            uint64_t v552 = &v23[v545];
            if ((unint64_t)v552 >= v12) {
              uint64_t v553 = v546;
            }
            else {
              uint64_t v553 = 0;
            }
            int32x4_t v23 = &v552[v553];
            uint64_t v14 = (int8x8_t *)((char *)v14 + v547);
            --v548;
          }
          while (v548);
          v16 += v729;
          v14 += v728;
          unint64_t v554 = v734;
          unint64_t v555 = v734 + 8 * v732;
          uint64_t v556 = v784;
          if (v555 < v727) {
            uint64_t v556 = 0;
          }
          __int16 v557 = (unint64_t *)(v555 + 8 * v556);
          uint64_t v558 = v12 + 8 * v556 + 8 * v732;
          if (v727)
          {
            unint64_t v12 = v558;
            unint64_t v554 = (unint64_t)v557;
            int32x4_t v23 = v557;
          }
          else
          {
            v23 += v732;
          }
          unint64_t v734 = v554;
          --v735;
        }
        while (v549 != 1);
      }
      return result;
    case 2:
      uint64_t v53 = v25;
      if (v8)
      {
        uint64_t v54 = v20;
        int8x16_t v55 = v733;
        uint64_t v738 = -(v732 * v22);
        uint64_t v752 = v20;
        uint64_t v701 = -(uint64_t)(v730 * v22);
        uint64_t v56 = 2 * v8;
        uint64_t v57 = -(uint64_t)v21;
        while (1)
        {
          int v58 = v731;
          unint64_t v759 = v12;
          do
          {
            int v59 = *v16;
            if (!*v16) {
              goto LABEL_70;
            }
            if (v59 == 255)
            {
              int v60 = (unsigned __int16)*v55;
              if (!*v55) {
                goto LABEL_70;
              }
              if (v60 == 0xFFFF)
              {
                *uint64_t v14 = (int8x8_t)*v23;
                *int v7 = -1;
                goto LABEL_70;
              }
              uint64_t v64 = *v23;
              unint64_t v65 = (unint64_t)*v14;
              int v66 = (unsigned __int16)*v7;
              int v67 = v60 ^ 0xFFFF;
            }
            else
            {
              int v61 = (unsigned __int16)*v55;
              int v62 = (v59 | (v59 << 8)) ^ 0xFFFF;
              if (v61 == (v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16) {
                goto LABEL_70;
              }
              unsigned int v63 = (unsigned __int16)WORD2(*v23) * v62;
              uint64_t v64 = ((HIWORD(*v23) - ((v62 * HIWORD(*v23) + ((v62 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v63 + HIWORD(v63) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v62 + ((WORD1(*v23) * v62) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v62 + (((unsigned __int16)*v23 * v62) >> 16) + 1) >> 16));
              unint64_t v65 = (unint64_t)*v14;
              int v66 = (unsigned __int16)*v7;
              int v67 = (unsigned __int16)~(v61 - ((v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16));
              LOWORD(v60) = v61 - ((v62 * v61 + ((v62 * v61) >> 16) + 1) >> 16);
            }
            unint64_t result = (uint64_t)cmyk64_DAplusDAM(v14, v7, v64, v60, v65, v66, v67);
            uint64_t v54 = v752;
            unint64_t v12 = v759;
LABEL_70:
            v16 += v53;
            int8x16_t v68 = &v23[v53];
            if ((unint64_t)v68 >= v12) {
              uint64_t v69 = v57;
            }
            else {
              uint64_t v69 = 0;
            }
            v55 += v54 + v69;
            int32x4_t v23 = &v68[v69];
            int v7 = (__int16 *)((char *)v7 + v56);
            v14 += v53;
            --v58;
          }
          while (v58);
          if (v727)
          {
            unint64_t v70 = v734 + 8 * v732;
            uint64_t v71 = v701;
            if (v70 < v727) {
              uint64_t v71 = 0;
            }
            int8x16_t v55 = &v733[v730 + v71];
            uint64_t v72 = v738;
            if (v70 < v727) {
              uint64_t v72 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v70 + 8 * v72);
            v12 += 8 * v72 + 8 * v732;
            v733 += v730 + v71;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v55 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          if (!--v735) {
            return result;
          }
        }
      }
      uint64_t v559 = v20;
      uint64_t v560 = -(uint64_t)v21;
      v561 = v733;
      uint64_t v757 = -(uint64_t)(v730 * v22);
      uint64_t v785 = -(v732 * v22);
      break;
    case 3:
      uint64_t v73 = v25;
      uint64_t v74 = v20;
      int8x16_t v75 = (unsigned __int16 *)v733;
      uint64_t v702 = -(v732 * v22);
      uint64_t v680 = -(uint64_t)(v730 * v22);
      uint64_t v76 = 2 * v8;
      uint64_t v77 = 8 * v25;
      uint64_t v78 = -(uint64_t)v21;
      uint64_t v739 = v20;
      do
      {
        int v79 = v731;
        unint64_t v760 = v12;
        do
        {
          int v80 = *v16;
          if (*v16)
          {
            if (v80 == 255)
            {
              if (v20) {
                int v81 = *v75;
              }
              else {
                int v81 = 0xFFFF;
              }
              unsigned int v83 = (unsigned __int16)*v7 ^ 0xFFFF;
              int32x2_t v84 = vdup_n_s32(v83);
              uint32x2_t v85 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v84);
              v86.i32[0] = WORD1(*v23);
              v86.i32[1] = HIWORD(*v23);
              uint32x2_t v87 = (uint32x2_t)vmul_s32(v86, v84);
              *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v85, v85, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v86, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v87, v87, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *int v7 = v81 - ((v83 * v81 + ((v83 * v81) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20) {
                int v82 = *v75;
              }
              else {
                int v82 = 0xFFFF;
              }
              unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, v82, ((unsigned __int16)*v7 * (v80 | (v80 << 8))+ (((unsigned __int16)*v7 * (v80 | (v80 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v80 | (v80 << 8)) ^ 0xFFFFu);
              int v20 = v750;
              unint64_t v12 = v760;
              uint64_t v74 = v739;
            }
          }
          v16 += v73;
          unint64_t v88 = &v23[v73];
          if ((unint64_t)v88 >= v12) {
            uint64_t v89 = v78;
          }
          else {
            uint64_t v89 = 0;
          }
          v75 += v74 + v89;
          int32x4_t v23 = &v88[v89];
          int v7 = (__int16 *)((char *)v7 + v76);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v77);
          --v79;
        }
        while (v79);
        if (v727)
        {
          unint64_t v90 = v734 + 8 * v732;
          uint64_t v91 = v680;
          if (v90 < v727) {
            uint64_t v91 = 0;
          }
          int8x16_t v75 = (unsigned __int16 *)&v733[v730 + v91];
          uint64_t v92 = v702;
          if (v90 < v727) {
            uint64_t v92 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v90 + 8 * v92);
          v12 += 8 * v92 + 8 * v732;
          v733 += v730 + v91;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v75 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 4:
      uint64_t v93 = v25;
      uint64_t v94 = v20;
      unint64_t v95 = (unsigned __int16 *)v733;
      uint64_t v703 = -(v732 * v22);
      uint64_t v681 = -(uint64_t)(v730 * v22);
      uint64_t v96 = 2 * v8;
      uint64_t v97 = 8 * v25;
      uint64_t v98 = -(uint64_t)v21;
      uint64_t v740 = v20;
      do
      {
        int v99 = v731;
        unint64_t v761 = v12;
        do
        {
          int v100 = *v16;
          if (*v16)
          {
            if (v100 == 255)
            {
              if (v20) {
                int v101 = *v95;
              }
              else {
                int v101 = 0xFFFF;
              }
              unsigned int v103 = (unsigned __int16)*v7;
              int32x2_t v104 = vdup_n_s32(v103);
              uint32x2_t v105 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v104);
              v106.i32[0] = WORD1(*v23);
              v106.i32[1] = HIWORD(*v23);
              uint32x2_t v107 = (uint32x2_t)vmul_s32(v106, v104);
              *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v105, v105, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v106, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v107, v107, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *int v7 = v101 - ((v103 * v101 + ((v103 * v101) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20) {
                int v102 = *v95;
              }
              else {
                int v102 = 0xFFFF;
              }
              unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, *v23, v102, (((unsigned __int16)*v7 ^ 0xFFFF) * (v100 | (v100 << 8))+ ((((unsigned __int16)*v7 ^ 0xFFFF) * (v100 | (v100 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v100 | (v100 << 8)) ^ 0xFFFFu);
              int v20 = v750;
              unint64_t v12 = v761;
              uint64_t v94 = v740;
            }
          }
          v16 += v93;
          unsigned int v108 = &v23[v93];
          if ((unint64_t)v108 >= v12) {
            uint64_t v109 = v98;
          }
          else {
            uint64_t v109 = 0;
          }
          v95 += v94 + v109;
          int32x4_t v23 = &v108[v109];
          int v7 = (__int16 *)((char *)v7 + v96);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v97);
          --v99;
        }
        while (v99);
        if (v727)
        {
          unint64_t v110 = v734 + 8 * v732;
          uint64_t v111 = v681;
          if (v110 < v727) {
            uint64_t v111 = 0;
          }
          unint64_t v95 = (unsigned __int16 *)&v733[v730 + v111];
          uint64_t v112 = v703;
          if (v110 < v727) {
            uint64_t v112 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v110 + 8 * v112);
          v12 += 8 * v112 + 8 * v732;
          v733 += v730 + v111;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v95 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 5:
      uint64_t v113 = v25;
      uint64_t v753 = -(uint64_t)v21;
      uint64_t v762 = v20;
      unsigned int v114 = (unsigned __int16 *)v733;
      uint64_t v741 = -(v732 * v22);
      uint64_t v704 = -(uint64_t)(v730 * v22);
      uint64_t v115 = 2 * v8;
      uint64_t v116 = 8 * v25;
      do
      {
        int v117 = v731;
        do
        {
          if (*v16)
          {
            int v118 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v119 = (unsigned __int16)WORD2(*v23) * v118;
            unint64_t v120 = ((HIWORD(*v23) - ((v118 * HIWORD(*v23) + ((v118 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v119 + HIWORD(v119) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v118 + ((WORD1(*v23) * v118) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v118 + (((unsigned __int16)*v23 * v118) >> 16) + 1) >> 16));
            unsigned int v121 = *v114 - ((v118 * *v114 + ((v118 * *v114) >> 16) + 1) >> 16);
            unint64_t v122 = v12;
            unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v120, (unsigned __int16)v121, (unsigned __int16)*v7, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)~(_WORD)v121);
            unint64_t v12 = v122;
          }
          v16 += v113;
          int v123 = &v23[v113];
          uint64_t v124 = v753;
          if ((unint64_t)v123 < v12) {
            uint64_t v124 = 0;
          }
          v114 += v762 + v124;
          int32x4_t v23 = &v123[v124];
          int v7 = (__int16 *)((char *)v7 + v115);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v116);
          --v117;
        }
        while (v117);
        if (v727)
        {
          unint64_t v125 = v734 + 8 * v732;
          uint64_t v126 = v704;
          if (v125 < v727) {
            uint64_t v126 = 0;
          }
          unsigned int v114 = (unsigned __int16 *)&v733[v730 + v126];
          uint64_t v127 = v741;
          if (v125 < v727) {
            uint64_t v127 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v125 + 8 * v127);
          v12 += 8 * v127 + 8 * v732;
          v733 += v730 + v126;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v114 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 6:
      uint64_t v128 = v25;
      uint64_t v129 = v20;
      int v130 = (unsigned __int16 *)v733;
      uint64_t v705 = -(v732 * v22);
      uint64_t v682 = -(uint64_t)(v730 * v22);
      uint64_t v131 = 2 * v8;
      uint64_t v132 = 8 * v25;
      uint64_t v133 = -(uint64_t)v21;
      uint64_t v742 = v20;
      do
      {
        int v134 = v731;
        unint64_t v763 = v12;
        do
        {
          int v135 = *v16;
          if (*v16 && *v7 != -1)
          {
            if ((unsigned __int16)~*v7 == 0xFFFF)
            {
              if (v20) {
                int v136 = *v130;
              }
              else {
                int v136 = 0xFFFF;
              }
              unsigned int v138 = (v135 | (v135 << 8)) ^ 0xFFFF;
              int32x2_t v139 = vdup_n_s32(v138);
              uint32x2_t v140 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)v23, (int8x8_t)0xFFFF0000FFFFLL), v139);
              v141.i32[0] = WORD1(*v23);
              v141.i32[1] = HIWORD(*v23);
              uint32x2_t v142 = (uint32x2_t)vmul_s32(v141, v139);
              *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32(*(int32x2_t *)v23, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v140, v140, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v141, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v142, v142, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *int v7 = v136 - ((v138 * v136 + ((v138 * v136) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20) {
                int v137 = *v130;
              }
              else {
                int v137 = 0xFFFF;
              }
              unint64_t result = (uint64_t)cmyk64_DAplusDAM(v14, v7, (uint64_t)*v14, *v7, *v23, v137, (257 * v135 * (unsigned __int16)~*v7+ ((257 * v135 * (unsigned __int16)~*v7) >> 16)+ 1) >> 16);
              int v20 = v750;
              unint64_t v12 = v763;
              uint64_t v129 = v742;
            }
          }
          v16 += v128;
          uint64_t v143 = &v23[v128];
          if ((unint64_t)v143 >= v12) {
            uint64_t v144 = v133;
          }
          else {
            uint64_t v144 = 0;
          }
          v130 += v129 + v144;
          int32x4_t v23 = &v143[v144];
          int v7 = (__int16 *)((char *)v7 + v131);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v132);
          --v134;
        }
        while (v134);
        if (v727)
        {
          unint64_t v145 = v734 + 8 * v732;
          uint64_t v146 = v682;
          if (v145 < v727) {
            uint64_t v146 = 0;
          }
          int v130 = (unsigned __int16 *)&v733[v730 + v146];
          uint64_t v147 = v705;
          if (v145 < v727) {
            uint64_t v147 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v145 + 8 * v147);
          v12 += 8 * v147 + 8 * v732;
          v733 += v730 + v146;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v130 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 7:
      uint64_t v148 = v25;
      if (v8)
      {
        uint64_t v149 = v20;
        int v150 = (unsigned __int16 *)v733;
        uint64_t v743 = -(v732 * v22);
        uint64_t v754 = v25;
        uint64_t v706 = -(uint64_t)(v730 * v22);
        uint64_t v151 = 2 * v8;
        uint64_t v152 = 8 * v25;
        uint64_t v153 = -(uint64_t)v21;
        do
        {
          int v154 = v731;
          unint64_t v764 = v12;
          do
          {
            int v155 = *v16;
            if (*v16)
            {
              if (v155 == 255)
              {
                int v156 = (unsigned __int16)*v7;
                unsigned int v157 = *v150 ^ 0xFFFF;
                int32x2_t v158 = vdup_n_s32(v157);
                uint32x2_t v159 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v14, (int8x8_t)0xFFFF0000FFFFLL), v158);
                v160.i32[0] = HIWORD(v14->u32[0]);
                v160.i32[1] = HIWORD(*(unint64_t *)v14);
                uint32x2_t v161 = (uint32x2_t)vmul_s32(v160, v158);
                *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v14, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v159, v159, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v160, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v161, v161, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                *int v7 = v156 - ((v157 * v156 + ((v157 * v156) >> 16) + 1) >> 16);
              }
              else
              {
                uint64_t v162 = v152;
                uint64_t v163 = v153;
                unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, (*v150 * (v155 | (v155 << 8))+ ((*v150 * (v155 | (v155 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (unsigned __int16)*v7, (v155 | (v155 << 8)) ^ 0xFFFFu);
                uint64_t v153 = v163;
                uint64_t v152 = v162;
                uint64_t v148 = v754;
                unint64_t v12 = v764;
              }
            }
            v16 += v148;
            unsigned int v164 = &v23[v148];
            if ((unint64_t)v164 >= v12) {
              uint64_t v165 = v153;
            }
            else {
              uint64_t v165 = 0;
            }
            v150 += v149 + v165;
            int32x4_t v23 = &v164[v165];
            int v7 = (__int16 *)((char *)v7 + v151);
            uint64_t v14 = (int8x8_t *)((char *)v14 + v152);
            --v154;
          }
          while (v154);
          if (v727)
          {
            unint64_t v166 = v734 + 8 * v732;
            uint64_t v167 = v706;
            if (v166 < v727) {
              uint64_t v167 = 0;
            }
            int v150 = (unsigned __int16 *)&v733[v730 + v167];
            uint64_t v168 = v743;
            if (v166 < v727) {
              uint64_t v168 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v166 + 8 * v168);
            v12 += 8 * v168 + 8 * v732;
            v733 += v730 + v167;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v150 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        uint64_t v578 = v20;
        uint64_t v579 = -(uint64_t)v21;
        v580 = (unsigned __int16 *)v733;
        uint64_t v786 = -(v732 * v22);
        uint64_t v748 = -(uint64_t)(v730 * v22);
        do
        {
          int v581 = v731;
          do
          {
            int v582 = *v16;
            if (*v16)
            {
              if (v582 == 255)
              {
                int32x2_t v583 = (int32x2_t)*v14;
                v584.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                v585.i32[0] = v584.i32[0];
                v585.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
                int32x2_t v586 = vdup_n_s32(*v580 ^ 0xFFFFu);
                uint32x2_t v587 = (uint32x2_t)vmul_s32(v585, v586);
                v588.i32[0] = v14->u16[0];
                v588.i32[1] = HIWORD(*(unint64_t *)v14);
                uint32x2_t v589 = (uint32x2_t)vmul_s32(v588, v586);
                v584.i32[1] = HIDWORD(*(unint64_t *)v14);
                uint32x2_t v590 = (uint32x2_t)vsub_s32(v584, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v587, v587, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                v583.i32[1] = v588.i32[1];
                int8x8_t v591 = (int8x8_t)vsub_s32(v583, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v589, v589, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                int8x8_t v592 = (int8x8_t)vshl_n_s32((int32x2_t)v591, 0x10uLL);
                v591.i16[1] = 0;
                v591.i32[1] = v592.i32[1];
                v592.i32[0] = vshl_u32(v590, (uint32x2_t)0xFFFF00000010).u32[0];
                v592.i32[1] = v590.u16[2];
                *uint64_t v14 = vorr_s8(v592, v591);
              }
              else
              {
                unint64_t v593 = v12;
                unint64_t result = (uint64_t)cmyk64_DMplusDM((unsigned int *)v14, (unint64_t)*v14, (*v580 * (v582 | (v582 << 8))+ ((*v580 * (v582 | (v582 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v14, (v582 | (v582 << 8)) ^ 0xFFFFu);
                unint64_t v12 = v593;
              }
            }
            v16 += v148;
            unint64_t v594 = &v23[v148];
            if ((unint64_t)v594 >= v12) {
              uint64_t v595 = v579;
            }
            else {
              uint64_t v595 = 0;
            }
            v580 += v578 + v595;
            int32x4_t v23 = &v594[v595];
            v14 += v148;
            --v581;
          }
          while (v581);
          if (v727)
          {
            unint64_t v596 = v734 + 8 * v732;
            uint64_t v597 = v748;
            if (v596 < v727) {
              uint64_t v597 = 0;
            }
            v580 = (unsigned __int16 *)&v733[v730 + v597];
            uint64_t v598 = v786;
            if (v596 < v727) {
              uint64_t v598 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v596 + 8 * v598);
            v12 += 8 * v598 + 8 * v732;
            v733 += v730 + v597;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v580 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v735);
      }
      return result;
    case 8:
      uint64_t v169 = v25;
      if (v8)
      {
        uint64_t v170 = v20;
        uint64_t v171 = v22;
        unsigned int v172 = (unsigned __int16 *)v733;
        uint64_t v173 = -(v732 * v22);
        uint64_t v174 = -(uint64_t)(v730 * v171);
        uint64_t v175 = -(uint64_t)v21;
        do
        {
          int v176 = v731;
          int v177 = v735;
          uint64_t v178 = v733;
          do
          {
            int v179 = *v16;
            if (*v16)
            {
              int8x8_t v180 = *v14;
              int v181 = (unsigned __int16)*v7;
              if (v179 == 255) {
                unsigned int v182 = *v172;
              }
              else {
                unsigned int v182 = (257 * v179 * *v172 + ((257 * v179 * *v172) >> 16) + 1) >> 16;
              }
              int32x2_t v183 = vdup_n_s32(v182);
              uint32x2_t v184 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v180, (int8x8_t)0xFFFF0000FFFFLL), v183);
              v185.i32[0] = HIWORD(v180.i32[0]);
              v185.i32[1] = HIWORD(*(unint64_t *)v14);
              uint32x2_t v186 = (uint32x2_t)vmul_s32(v185, v183);
              *uint64_t v14 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)v180, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v184, v184, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v185, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v186, v186, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
              *int v7 = v181 - ((v182 * v181 + ((v182 * v181) >> 16) + 1) >> 16);
            }
            v16 += v169;
            uint64_t v187 = &v23[v169];
            int v188 = &v172[v170];
            if ((unint64_t)v187 >= v12) {
              unint64_t result = v175;
            }
            else {
              unint64_t result = 0;
            }
            unsigned int v172 = &v188[result];
            int32x4_t v23 = &v187[result];
            v7 += v8;
            v14 += v169;
            --v176;
          }
          while (v176);
          if (v727)
          {
            unint64_t result = v732;
            unint64_t v189 = v734 + 8 * v732;
            if (v189 >= v727) {
              uint64_t v190 = v174;
            }
            else {
              uint64_t v190 = 0;
            }
            if (v189 >= v727) {
              uint64_t v191 = v173;
            }
            else {
              uint64_t v191 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v189 + 8 * v191);
            v12 += 8 * v191 + 8 * v732;
            v733 += v730 + v190;
            unint64_t v734 = (unint64_t)v23;
            unsigned int v172 = (unsigned __int16 *)&v178[v730 + v190];
          }
          else
          {
            v23 += v732;
            v172 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v177 != 1);
      }
      else
      {
        uint64_t v599 = -(uint64_t)v21;
        uint64_t v600 = v22;
        uint64_t v601 = -(v732 * v22);
        uint64_t v602 = -(uint64_t)(v730 * v600);
        unint64_t v603 = (unsigned __int16 *)v733;
        do
        {
          int v604 = v9;
          int v605 = v735;
          uint64_t v606 = v733;
          do
          {
            int v607 = *v16;
            if (*v16)
            {
              if (v607 == 255) {
                unsigned int v608 = *v603;
              }
              else {
                unsigned int v608 = (257 * v607 * *v603 + ((257 * v607 * *v603) >> 16) + 1) >> 16;
              }
              unint64_t result = HIWORD(*(unint64_t *)v14);
              int32x2_t v609 = (int32x2_t)*v14;
              v610.i32[0] = vshl_u32((uint32x2_t)*v14, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
              v611.i32[0] = v610.i32[0];
              v611.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v14);
              int32x2_t v612 = vdup_n_s32(v608);
              uint32x2_t v613 = (uint32x2_t)vmul_s32(v611, v612);
              v614.i32[0] = v14->u16[0];
              v614.i32[1] = result;
              uint32x2_t v615 = (uint32x2_t)vmul_s32(v614, v612);
              v610.i32[1] = HIDWORD(*(unint64_t *)v14);
              uint32x2_t v616 = (uint32x2_t)vsub_s32(v610, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v613, v613, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              v609.i32[1] = result;
              int8x8_t v617 = (int8x8_t)vsub_s32(v609, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v615, v615, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
              int8x8_t v618 = (int8x8_t)vshl_n_s32((int32x2_t)v617, 0x10uLL);
              v617.i16[1] = 0;
              v617.i32[1] = v618.i32[1];
              v618.i32[0] = vshl_u32(v616, (uint32x2_t)0xFFFF00000010).u32[0];
              v618.i32[1] = v616.u16[2];
              *uint64_t v14 = vorr_s8(v618, v617);
            }
            v16 += v169;
            BOOL v619 = &v23[v169];
            uint64_t v620 = &v603[v20];
            if ((unint64_t)v619 >= v12) {
              uint64_t v621 = v599;
            }
            else {
              uint64_t v621 = 0;
            }
            unint64_t v603 = &v620[v621];
            int32x4_t v23 = &v619[v621];
            v14 += v169;
            --v604;
          }
          while (v604);
          if (v727)
          {
            unint64_t v622 = v734 + 8 * v732;
            if (v622 >= v727) {
              uint64_t v623 = v602;
            }
            else {
              uint64_t v623 = 0;
            }
            unint64_t result = (uint64_t)&v733[v730 + v623];
            if (v622 >= v727) {
              uint64_t v624 = v601;
            }
            else {
              uint64_t v624 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v622 + 8 * v624);
            v12 += 8 * v624 + 8 * v732;
            v733 += v730 + v623;
            unint64_t v734 = (unint64_t)v23;
            unint64_t v603 = (unsigned __int16 *)&v606[v730 + v623];
          }
          else
          {
            v23 += v732;
            v603 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v605 != 1);
      }
      return result;
    case 9:
      uint64_t v192 = v25;
      uint64_t v755 = -(uint64_t)v21;
      uint64_t v765 = v20;
      uint64_t v193 = (unsigned __int16 *)v733;
      uint64_t v744 = -(v732 * v22);
      uint64_t v707 = -(uint64_t)(v730 * v22);
      uint64_t v194 = 2 * v8;
      uint64_t v195 = 8 * v25;
      do
      {
        int v196 = v731;
        do
        {
          if (*v16)
          {
            unint64_t v197 = v12;
            unsigned __int16 v198 = ~(*v16 | (*v16 << 8));
            int v199 = v198;
            unsigned int v200 = (unsigned __int16)WORD2(*v23) * v198;
            unint64_t v201 = ((HIWORD(*v23) - ((HIWORD(*v23) * v199 + ((HIWORD(*v23) * v199) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v200 + HIWORD(v200) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v199 + ((WORD1(*v23) * v199) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v199 + (((unsigned __int16)*v23 * v199) >> 16) + 1) >> 16));
            unsigned int v202 = *v193 - ((*v193 * v199 + ((*v193 * v199) >> 16) + 1) >> 16);
            unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v201, (unsigned __int16)v202, (unsigned __int16)*v7 ^ 0xFFFFu, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)(v202 + v198));
            unint64_t v12 = v197;
          }
          v16 += v192;
          unint64_t v203 = &v23[v192];
          uint64_t v204 = v755;
          if ((unint64_t)v203 < v12) {
            uint64_t v204 = 0;
          }
          v193 += v765 + v204;
          int32x4_t v23 = &v203[v204];
          int v7 = (__int16 *)((char *)v7 + v194);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v195);
          --v196;
        }
        while (v196);
        if (v727)
        {
          unint64_t v205 = v734 + 8 * v732;
          uint64_t v206 = v707;
          if (v205 < v727) {
            uint64_t v206 = 0;
          }
          uint64_t v193 = (unsigned __int16 *)&v733[v730 + v206];
          uint64_t v207 = v744;
          if (v205 < v727) {
            uint64_t v207 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v205 + 8 * v207);
          v12 += 8 * v207 + 8 * v732;
          v733 += v730 + v206;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v193 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 10:
      uint64_t v208 = v25;
      uint64_t v756 = -(uint64_t)v21;
      uint64_t v766 = v20;
      unint64_t v209 = (unsigned __int16 *)v733;
      uint64_t v745 = -(v732 * v22);
      uint64_t v708 = -(uint64_t)(v730 * v22);
      uint64_t v210 = 2 * v8;
      uint64_t v211 = 8 * v25;
      do
      {
        int v212 = v731;
        do
        {
          if (*v16)
          {
            unint64_t v213 = v12;
            int v214 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v215 = (unsigned __int16)WORD2(*v23) * v214;
            unint64_t v216 = ((HIWORD(*v23) - ((v214 * HIWORD(*v23) + ((v214 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v215 + HIWORD(v215) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v214 + ((WORD1(*v23) * v214) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v214 + (((unsigned __int16)*v23 * v214) >> 16) + 1) >> 16));
            unsigned int v217 = *v209 - ((v214 * *v209 + ((v214 * *v209) >> 16) + 1) >> 16);
            unint64_t result = (uint64_t)cmyk64_DAMplusDAM((unsigned int *)v14, v7, v216, (unsigned __int16)v217, (unsigned __int16)*v7 ^ 0xFFFFu, (unint64_t)*v14, (unsigned __int16)*v7, (unsigned __int16)~(_WORD)v217);
            unint64_t v12 = v213;
          }
          v16 += v208;
          int v218 = &v23[v208];
          uint64_t v219 = v756;
          if ((unint64_t)v218 < v12) {
            uint64_t v219 = 0;
          }
          v209 += v766 + v219;
          int32x4_t v23 = &v218[v219];
          int v7 = (__int16 *)((char *)v7 + v210);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v211);
          --v212;
        }
        while (v212);
        if (v727)
        {
          unint64_t v220 = v734 + 8 * v732;
          uint64_t v221 = v708;
          if (v220 < v727) {
            uint64_t v221 = 0;
          }
          unint64_t v209 = (unsigned __int16 *)&v733[v730 + v221];
          uint64_t v222 = v745;
          if (v220 < v727) {
            uint64_t v222 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v220 + 8 * v222);
          v12 += 8 * v222 + 8 * v732;
          v733 += v730 + v221;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v209 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 11:
      uint64_t v223 = v25;
      if (v8)
      {
        uint64_t v767 = v20;
        int v224 = (unsigned __int16 *)v733;
        uint64_t v709 = -(v732 * v22);
        uint64_t v683 = -(uint64_t)(v730 * v22);
        uint64_t v746 = 2 * v8;
        uint64_t v225 = -(uint64_t)v21;
        do
        {
          int v226 = v731;
          unint64_t v227 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                int v228 = *v224;
              }
              else {
                int v228 = 0xFFFF;
              }
              int v229 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v230 = (unsigned __int16)WORD2(*v23) * v229;
              unint64_t result = (uint64_t)cmyk64_DAplusdDA((int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, ((HIWORD(*v23)- ((v229 * HIWORD(*v23) + ((v229 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v230 + HIWORD(v230) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v229 + ((WORD1(*v23) * v229) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v229 + (((unsigned __int16)*v23 * v229) >> 16) + 1) >> 16)), (unsigned __int16)(v228- ((v228 * v229 + ((v228 * v229) >> 16) + 1) >> 16)));
              unint64_t v12 = v227;
              int v20 = v750;
            }
            v16 += v223;
            uint64_t v231 = &v23[v223];
            if ((unint64_t)v231 >= v12) {
              uint64_t v232 = v225;
            }
            else {
              uint64_t v232 = 0;
            }
            v224 += v767 + v232;
            int32x4_t v23 = &v231[v232];
            int v7 = (__int16 *)((char *)v7 + v746);
            v14 += v223;
            --v226;
          }
          while (v226);
          if (v727)
          {
            unint64_t v233 = v734 + 8 * v732;
            uint64_t v234 = v683;
            if (v233 < v727) {
              uint64_t v234 = 0;
            }
            int v224 = (unsigned __int16 *)&v733[v730 + v234];
            uint64_t v235 = v709;
            if (v233 < v727) {
              uint64_t v235 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v233 + 8 * v235);
            v12 += 8 * v235 + 8 * v732;
            v733 += v730 + v234;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v224 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        uint64_t v625 = v20;
        uint64_t v626 = -(uint64_t)v21;
        uint64_t v627 = (unsigned __int16 *)v733;
        uint64_t v787 = -(v732 * v22);
        uint64_t v749 = -(uint64_t)(v730 * v22);
        do
        {
          int v628 = v731;
          unint64_t v629 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                int v630 = *v627;
              }
              else {
                int v630 = 0xFFFF;
              }
              int v631 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v632 = (unsigned __int16)WORD2(*v23) * v631;
              unint64_t result = (uint64_t)cmyk64_DplusdDA((int *)v14, (unint64_t)*v14, ((HIWORD(*v23)- ((v631 * HIWORD(*v23) + ((v631 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v632 + HIWORD(v632) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v631 + ((WORD1(*v23) * v631) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v631 + (((unsigned __int16)*v23 * v631) >> 16) + 1) >> 16)), (unsigned __int16)(v630- ((v630 * v631 + ((v630 * v631) >> 16) + 1) >> 16)));
              unint64_t v12 = v629;
              int v20 = v750;
            }
            v16 += v223;
            v633 = &v23[v223];
            if ((unint64_t)v633 >= v12) {
              uint64_t v634 = v626;
            }
            else {
              uint64_t v634 = 0;
            }
            v627 += v625 + v634;
            int32x4_t v23 = &v633[v634];
            v14 += v223;
            --v628;
          }
          while (v628);
          if (v727)
          {
            unint64_t v635 = v734 + 8 * v732;
            uint64_t v636 = v749;
            if (v635 < v727) {
              uint64_t v636 = 0;
            }
            uint64_t v627 = (unsigned __int16 *)&v733[v730 + v636];
            uint64_t v637 = v787;
            if (v635 < v727) {
              uint64_t v637 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v635 + 8 * v637);
            v12 += 8 * v637 + 8 * v732;
            v733 += v730 + v636;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v627 += v730;
          }
          v16 += v729;
          v14 += v728;
          --v735;
        }
        while (v735);
      }
      return result;
    case 12:
      uint64_t v236 = v25;
      if (v8)
      {
        uint64_t v768 = v20;
        uint64_t v237 = (unsigned __int16 *)v733;
        uint64_t v710 = -(v732 * v22);
        uint64_t v684 = -(uint64_t)(v730 * v22);
        uint64_t v747 = 2 * v8;
        uint64_t v238 = -(uint64_t)v21;
        do
        {
          int v239 = v731;
          unint64_t v240 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                int v241 = *v237;
              }
              else {
                int v241 = 0xFFFF;
              }
              int v242 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v243 = (unsigned __int16)WORD2(*v23) * v242;
              unint64_t result = (uint64_t)cmyk64_DApluslDA((unsigned int *)v14, v7, (unint64_t)*v14, (unsigned __int16)*v7, ((HIWORD(*v23)- ((v242 * HIWORD(*v23) + ((v242 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v243 + HIWORD(v243) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v242 + ((WORD1(*v23) * v242) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v242 + (((unsigned __int16)*v23 * v242) >> 16) + 1) >> 16)), (unsigned __int16)(v241- ((v241 * v242 + ((v241 * v242) >> 16) + 1) >> 16)));
              unint64_t v12 = v240;
              int v20 = v750;
            }
            v16 += v236;
            unsigned int v244 = &v23[v236];
            if ((unint64_t)v244 >= v12) {
              uint64_t v245 = v238;
            }
            else {
              uint64_t v245 = 0;
            }
            v237 += v768 + v245;
            int32x4_t v23 = &v244[v245];
            int v7 = (__int16 *)((char *)v7 + v747);
            v14 += v236;
            --v239;
          }
          while (v239);
          if (v727)
          {
            unint64_t v246 = v734 + 8 * v732;
            uint64_t v247 = v684;
            if (v246 < v727) {
              uint64_t v247 = 0;
            }
            uint64_t v237 = (unsigned __int16 *)&v733[v730 + v247];
            uint64_t v248 = v710;
            if (v246 < v727) {
              uint64_t v248 = 0;
            }
            int32x4_t v23 = (unint64_t *)(v246 + 8 * v248);
            v12 += 8 * v248 + 8 * v732;
            v733 += v730 + v247;
            unint64_t v734 = (unint64_t)v23;
          }
          else
          {
            v23 += v732;
            v237 += v730;
          }
          v16 += v729;
          v14 += v728;
          v7 += v726;
          --v735;
        }
        while (v735);
      }
      else
      {
        uint64_t v638 = -(uint64_t)v21;
        uint64_t v788 = -(v732 * v22);
        do
        {
          int v639 = v731;
          int v640 = v735;
          do
          {
            if (*v16)
            {
              unint64_t v641 = HIWORD(*v23);
              int v642 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v643 = (unsigned __int16)WORD2(*v23) * v642;
              unint64_t v644 = v12;
              unint64_t result = (uint64_t)cmyk64_DpluslD((unsigned int *)v14, (unint64_t)*v14, ((unint64_t)(v641- ((v642 * v641 + ((v642 * v641) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v643 + HIWORD(v643) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v642 + ((WORD1(*v23) * v642) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v642 + (((unsigned __int16)*v23 * v642) >> 16) + 1) >> 16)));
              unint64_t v12 = v644;
            }
            v16 += v236;
            uint64_t v645 = &v23[v236];
            if ((unint64_t)v645 >= v12) {
              uint64_t v646 = v638;
            }
            else {
              uint64_t v646 = 0;
            }
            int32x4_t v23 = &v645[v646];
            v14 += v236;
            --v639;
          }
          while (v639);
          v16 += v729;
          v14 += v728;
          unint64_t v647 = v734;
          unint64_t v648 = v734 + 8 * v732;
          uint64_t v649 = v788;
          if (v648 < v727) {
            uint64_t v649 = 0;
          }
          __int16 v650 = (unint64_t *)(v648 + 8 * v649);
          uint64_t v651 = v12 + 8 * v649 + 8 * v732;
          if (v727)
          {
            unint64_t v12 = v651;
            unint64_t v647 = (unint64_t)v650;
            int32x4_t v23 = v650;
          }
          else
          {
            v23 += v732;
          }
          unint64_t v734 = v647;
          --v735;
        }
        while (v640 != 1);
      }
      return result;
    case 13:
      uint64_t v249 = v25;
      uint64_t v250 = v20;
      unint64_t v251 = (unsigned __int16 *)v733;
      uint64_t v685 = -(v732 * v22);
      uint64_t v711 = v20;
      uint64_t v665 = -(uint64_t)(v730 * v22);
      uint64_t v252 = 2 * v8;
      uint64_t v253 = 8 * v25;
      uint64_t v254 = -(uint64_t)v21;
      do
      {
        int v255 = v731;
        unint64_t v769 = v12;
        do
        {
          if (*v16)
          {
            int v256 = v20 ? *v251 : 0xFFFF;
            int v257 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v258 = v256 - ((v256 * v257 + ((v256 * v257) >> 16) + 1) >> 16);
            __int16 v259 = v258;
            if ((_WORD)v258)
            {
              unint64_t v260 = HIWORD(*v23);
              unsigned int v261 = (unsigned __int16)WORD2(*v23) * v257;
              unint64_t v262 = ((unint64_t)(v260
                                       - ((v257 * v260 + ((v257 * v260) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v261 + HIWORD(v261) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v257 + ((WORD1(*v23) * v257) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v257 + (((unsigned __int16)*v23 * v257) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAmultiplyPDA_11710((unint64_t)*v14, (unsigned __int16)*v7, v262, (unsigned __int16)v258);
                  uint64_t v250 = v711;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v769;
                  unint64_t v262 = result;
                }
                *uint64_t v14 = (int8x8_t)v262;
                *int v7 = v259;
              }
              else
              {
                unint64_t result = PDAmultiplyPDA_11710((unint64_t)*v14, 0xFFFFu, v262, (unsigned __int16)v258);
                uint64_t v250 = v711;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v769;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v249;
          uint64_t v263 = &v23[v249];
          if ((unint64_t)v263 >= v12) {
            uint64_t v264 = v254;
          }
          else {
            uint64_t v264 = 0;
          }
          v251 += v250 + v264;
          int32x4_t v23 = &v263[v264];
          int v7 = (__int16 *)((char *)v7 + v252);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v253);
          --v255;
        }
        while (v255);
        if (v727)
        {
          unint64_t v265 = v734 + 8 * v732;
          uint64_t v266 = v665;
          if (v265 < v727) {
            uint64_t v266 = 0;
          }
          unint64_t v251 = (unsigned __int16 *)&v733[v730 + v266];
          uint64_t v267 = v685;
          if (v265 < v727) {
            uint64_t v267 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v265 + 8 * v267);
          v12 += 8 * v267 + 8 * v732;
          v733 += v730 + v266;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v251 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 14:
      uint64_t v268 = v25;
      uint64_t v269 = v20;
      int v270 = (unsigned __int16 *)v733;
      uint64_t v686 = -(v732 * v22);
      uint64_t v712 = v20;
      uint64_t v666 = -(uint64_t)(v730 * v22);
      uint64_t v271 = 2 * v8;
      uint64_t v272 = 8 * v25;
      uint64_t v273 = -(uint64_t)v21;
      do
      {
        int v274 = v731;
        unint64_t v770 = v12;
        do
        {
          if (*v16)
          {
            int v275 = v20 ? *v270 : 0xFFFF;
            int v276 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v277 = v275 - ((v275 * v276 + ((v275 * v276) >> 16) + 1) >> 16);
            __int16 v278 = v277;
            if ((_WORD)v277)
            {
              unint64_t v279 = HIWORD(*v23);
              unsigned int v280 = (unsigned __int16)WORD2(*v23) * v276;
              unint64_t v281 = ((unint64_t)(v279
                                       - ((v276 * v279 + ((v276 * v279) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v280 + HIWORD(v280) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v276 + ((WORD1(*v23) * v276) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v276 + (((unsigned __int16)*v23 * v276) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAscreenPDA_11711((unint64_t)*v14, (unsigned __int16)*v7, v281, (unsigned __int16)v277);
                  uint64_t v269 = v712;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v770;
                  unint64_t v281 = result;
                }
                *uint64_t v14 = (int8x8_t)v281;
                *int v7 = v278;
              }
              else
              {
                unint64_t result = PDAscreenPDA_11711((unint64_t)*v14, 0xFFFFu, v281, (unsigned __int16)v277);
                uint64_t v269 = v712;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v770;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v268;
          int v282 = &v23[v268];
          if ((unint64_t)v282 >= v12) {
            uint64_t v283 = v273;
          }
          else {
            uint64_t v283 = 0;
          }
          v270 += v269 + v283;
          int32x4_t v23 = &v282[v283];
          int v7 = (__int16 *)((char *)v7 + v271);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v272);
          --v274;
        }
        while (v274);
        if (v727)
        {
          unint64_t v284 = v734 + 8 * v732;
          uint64_t v285 = v666;
          if (v284 < v727) {
            uint64_t v285 = 0;
          }
          int v270 = (unsigned __int16 *)&v733[v730 + v285];
          uint64_t v286 = v686;
          if (v284 < v727) {
            uint64_t v286 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v284 + 8 * v286);
          v12 += 8 * v286 + 8 * v732;
          v733 += v730 + v285;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v270 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 15:
      uint64_t v287 = v25;
      uint64_t v288 = v20;
      int v289 = (unsigned __int16 *)v733;
      uint64_t v687 = -(v732 * v22);
      uint64_t v713 = v20;
      uint64_t v667 = -(uint64_t)(v730 * v22);
      uint64_t v290 = 2 * v8;
      uint64_t v291 = 8 * v25;
      uint64_t v292 = -(uint64_t)v21;
      do
      {
        int v293 = v731;
        unint64_t v771 = v12;
        do
        {
          if (*v16)
          {
            int v294 = v20 ? *v289 : 0xFFFF;
            int v295 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v296 = v294 - ((v294 * v295 + ((v294 * v295) >> 16) + 1) >> 16);
            __int16 v297 = v296;
            if ((_WORD)v296)
            {
              unint64_t v298 = HIWORD(*v23);
              unsigned int v299 = (unsigned __int16)WORD2(*v23) * v295;
              unint64_t v300 = ((unint64_t)(v298
                                       - ((v295 * v298 + ((v295 * v298) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v299 + HIWORD(v299) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v295 + ((WORD1(*v23) * v295) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v295 + (((unsigned __int16)*v23 * v295) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAoverlayPDA_11712((unint64_t)*v14, (unsigned __int16)*v7, v300, (unsigned __int16)v296);
                  uint64_t v288 = v713;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v771;
                  unint64_t v300 = result;
                }
                *uint64_t v14 = (int8x8_t)v300;
                *int v7 = v297;
              }
              else
              {
                unint64_t result = PDAoverlayPDA_11712((unint64_t)*v14, 0xFFFFu, v300, (unsigned __int16)v296);
                uint64_t v288 = v713;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v771;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v287;
          uint32x2_t v301 = &v23[v287];
          if ((unint64_t)v301 >= v12) {
            uint64_t v302 = v292;
          }
          else {
            uint64_t v302 = 0;
          }
          v289 += v288 + v302;
          int32x4_t v23 = &v301[v302];
          int v7 = (__int16 *)((char *)v7 + v290);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v291);
          --v293;
        }
        while (v293);
        if (v727)
        {
          unint64_t v303 = v734 + 8 * v732;
          uint64_t v304 = v667;
          if (v303 < v727) {
            uint64_t v304 = 0;
          }
          int v289 = (unsigned __int16 *)&v733[v730 + v304];
          uint64_t v305 = v687;
          if (v303 < v727) {
            uint64_t v305 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v303 + 8 * v305);
          v12 += 8 * v305 + 8 * v732;
          v733 += v730 + v304;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v289 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 16:
      uint64_t v306 = v25;
      uint64_t v307 = v20;
      int32x2_t v308 = (unsigned __int16 *)v733;
      uint64_t v688 = -(v732 * v22);
      uint64_t v714 = v20;
      uint64_t v668 = -(uint64_t)(v730 * v22);
      uint64_t v309 = 2 * v8;
      uint64_t v310 = 8 * v25;
      uint64_t v311 = -(uint64_t)v21;
      do
      {
        int v312 = v731;
        unint64_t v772 = v12;
        do
        {
          if (*v16)
          {
            int v313 = v20 ? *v308 : 0xFFFF;
            int v314 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v315 = v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16);
            __int16 v316 = v315;
            if ((_WORD)v315)
            {
              unint64_t v317 = HIWORD(*v23);
              unsigned int v318 = (unsigned __int16)WORD2(*v23) * v314;
              unint64_t v319 = ((unint64_t)(v317
                                       - ((v314 * v317 + ((v314 * v317) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v318 + HIWORD(v318) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v314 + ((WORD1(*v23) * v314) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v314 + (((unsigned __int16)*v23 * v314) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAdarkenPDA_11714((unint64_t)*v14, (unsigned __int16)*v7, v319, (unsigned __int16)v315);
                  uint64_t v307 = v714;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v772;
                  unint64_t v319 = result;
                }
                *uint64_t v14 = (int8x8_t)v319;
                *int v7 = v316;
              }
              else
              {
                unint64_t result = PDAdarkenPDA_11714((unint64_t)*v14, 0xFFFFu, v319, (unsigned __int16)v315);
                uint64_t v307 = v714;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v772;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v306;
          int32x2_t v320 = &v23[v306];
          if ((unint64_t)v320 >= v12) {
            uint64_t v321 = v311;
          }
          else {
            uint64_t v321 = 0;
          }
          v308 += v307 + v321;
          int32x4_t v23 = &v320[v321];
          int v7 = (__int16 *)((char *)v7 + v309);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v310);
          --v312;
        }
        while (v312);
        if (v727)
        {
          unint64_t v322 = v734 + 8 * v732;
          uint64_t v323 = v668;
          if (v322 < v727) {
            uint64_t v323 = 0;
          }
          int32x2_t v308 = (unsigned __int16 *)&v733[v730 + v323];
          uint64_t v324 = v688;
          if (v322 < v727) {
            uint64_t v324 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v322 + 8 * v324);
          v12 += 8 * v324 + 8 * v732;
          v733 += v730 + v323;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v308 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 17:
      uint64_t v325 = v25;
      uint64_t v326 = v20;
      int16x4_t v327 = (unsigned __int16 *)v733;
      uint64_t v689 = -(v732 * v22);
      uint64_t v715 = v20;
      uint64_t v669 = -(uint64_t)(v730 * v22);
      uint64_t v328 = 2 * v8;
      uint64_t v329 = 8 * v25;
      uint64_t v330 = -(uint64_t)v21;
      do
      {
        int v331 = v731;
        unint64_t v773 = v12;
        do
        {
          if (*v16)
          {
            int v332 = v20 ? *v327 : 0xFFFF;
            int v333 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v334 = v332 - ((v332 * v333 + ((v332 * v333) >> 16) + 1) >> 16);
            __int16 v335 = v334;
            if ((_WORD)v334)
            {
              unint64_t v336 = HIWORD(*v23);
              unsigned int v337 = (unsigned __int16)WORD2(*v23) * v333;
              unint64_t v338 = ((unint64_t)(v336
                                       - ((v333 * v336 + ((v333 * v336) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v337 + HIWORD(v337) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v333 + ((WORD1(*v23) * v333) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v333 + (((unsigned __int16)*v23 * v333) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAlightenPDA_11713((unint64_t)*v14, (unsigned __int16)*v7, v338, (unsigned __int16)v334);
                  uint64_t v326 = v715;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v773;
                  unint64_t v338 = result;
                }
                *uint64_t v14 = (int8x8_t)v338;
                *int v7 = v335;
              }
              else
              {
                unint64_t result = PDAlightenPDA_11713((unint64_t)*v14, 0xFFFFu, v338, (unsigned __int16)v334);
                uint64_t v326 = v715;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v773;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v325;
          unsigned int v339 = &v23[v325];
          if ((unint64_t)v339 >= v12) {
            uint64_t v340 = v330;
          }
          else {
            uint64_t v340 = 0;
          }
          v327 += v326 + v340;
          int32x4_t v23 = &v339[v340];
          int v7 = (__int16 *)((char *)v7 + v328);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v329);
          --v331;
        }
        while (v331);
        if (v727)
        {
          unint64_t v341 = v734 + 8 * v732;
          uint64_t v342 = v669;
          if (v341 < v727) {
            uint64_t v342 = 0;
          }
          int16x4_t v327 = (unsigned __int16 *)&v733[v730 + v342];
          uint64_t v343 = v689;
          if (v341 < v727) {
            uint64_t v343 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v341 + 8 * v343);
          v12 += 8 * v343 + 8 * v732;
          v733 += v730 + v342;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v327 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 18:
      uint64_t v344 = v25;
      uint64_t v345 = v20;
      int v346 = (unsigned __int16 *)v733;
      uint64_t v690 = -(v732 * v22);
      uint64_t v716 = v20;
      uint64_t v670 = -(uint64_t)(v730 * v22);
      uint64_t v347 = 2 * v8;
      uint64_t v348 = 8 * v25;
      uint64_t v349 = -(uint64_t)v21;
      do
      {
        int v350 = v731;
        unint64_t v774 = v12;
        do
        {
          if (*v16)
          {
            int v351 = v20 ? *v346 : 0xFFFF;
            int v352 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v353 = v351 - ((v351 * v352 + ((v351 * v352) >> 16) + 1) >> 16);
            __int16 v354 = v353;
            if ((_WORD)v353)
            {
              unint64_t v355 = HIWORD(*v23);
              unsigned int v356 = (unsigned __int16)WORD2(*v23) * v352;
              unint64_t v357 = ((unint64_t)(v355
                                       - ((v352 * v355 + ((v352 * v355) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v356 + HIWORD(v356) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v352 + ((WORD1(*v23) * v352) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v352 + (((unsigned __int16)*v23 * v352) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolordodgePDA_11715((unint64_t)*v14, (unsigned __int16)*v7, v357, (unsigned __int16)v353);
                  uint64_t v345 = v716;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v774;
                  unint64_t v357 = result;
                }
                *uint64_t v14 = (int8x8_t)v357;
                *int v7 = v354;
              }
              else
              {
                unint64_t result = PDAcolordodgePDA_11715((unint64_t)*v14, 0xFFFFu, v357, (unsigned __int16)v353);
                uint64_t v345 = v716;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v774;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v344;
          unsigned int v358 = &v23[v344];
          if ((unint64_t)v358 >= v12) {
            uint64_t v359 = v349;
          }
          else {
            uint64_t v359 = 0;
          }
          v346 += v345 + v359;
          int32x4_t v23 = &v358[v359];
          int v7 = (__int16 *)((char *)v7 + v347);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v348);
          --v350;
        }
        while (v350);
        if (v727)
        {
          unint64_t v360 = v734 + 8 * v732;
          uint64_t v361 = v670;
          if (v360 < v727) {
            uint64_t v361 = 0;
          }
          int v346 = (unsigned __int16 *)&v733[v730 + v361];
          uint64_t v362 = v690;
          if (v360 < v727) {
            uint64_t v362 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v360 + 8 * v362);
          v12 += 8 * v362 + 8 * v732;
          v733 += v730 + v361;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v346 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 19:
      uint64_t v363 = v25;
      uint64_t v364 = v20;
      uint64_t v365 = (unsigned __int16 *)v733;
      uint64_t v691 = -(v732 * v22);
      uint64_t v717 = v20;
      uint64_t v671 = -(uint64_t)(v730 * v22);
      uint64_t v366 = 2 * v8;
      uint64_t v367 = 8 * v25;
      uint64_t v368 = -(uint64_t)v21;
      do
      {
        int v369 = v731;
        unint64_t v775 = v12;
        do
        {
          if (*v16)
          {
            int v370 = v20 ? *v365 : 0xFFFF;
            int v371 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v372 = v370 - ((v370 * v371 + ((v370 * v371) >> 16) + 1) >> 16);
            __int16 v373 = v372;
            if ((_WORD)v372)
            {
              unint64_t v374 = HIWORD(*v23);
              unsigned int v375 = (unsigned __int16)WORD2(*v23) * v371;
              unint64_t v376 = ((unint64_t)(v374
                                       - ((v371 * v374 + ((v371 * v374) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v375 + HIWORD(v375) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v371 + ((WORD1(*v23) * v371) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v371 + (((unsigned __int16)*v23 * v371) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolorburnPDA_11716((unint64_t)*v14, (unsigned __int16)*v7, v376, (unsigned __int16)v372);
                  uint64_t v364 = v717;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v775;
                  unint64_t v376 = result;
                }
                *uint64_t v14 = (int8x8_t)v376;
                *int v7 = v373;
              }
              else
              {
                unint64_t result = PDAcolorburnPDA_11716((unint64_t)*v14, 0xFFFFu, v376, (unsigned __int16)v372);
                uint64_t v364 = v717;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v775;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v363;
          unsigned __int16 v377 = &v23[v363];
          if ((unint64_t)v377 >= v12) {
            uint64_t v378 = v368;
          }
          else {
            uint64_t v378 = 0;
          }
          v365 += v364 + v378;
          int32x4_t v23 = &v377[v378];
          int v7 = (__int16 *)((char *)v7 + v366);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v367);
          --v369;
        }
        while (v369);
        if (v727)
        {
          unint64_t v379 = v734 + 8 * v732;
          uint64_t v380 = v671;
          if (v379 < v727) {
            uint64_t v380 = 0;
          }
          uint64_t v365 = (unsigned __int16 *)&v733[v730 + v380];
          uint64_t v381 = v691;
          if (v379 < v727) {
            uint64_t v381 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v379 + 8 * v381);
          v12 += 8 * v381 + 8 * v732;
          v733 += v730 + v380;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v365 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 20:
      uint64_t v382 = v25;
      uint64_t v383 = v20;
      uint64_t v384 = (unsigned __int16 *)v733;
      uint64_t v692 = -(v732 * v22);
      uint64_t v718 = v20;
      uint64_t v672 = -(uint64_t)(v730 * v22);
      uint64_t v385 = 2 * v8;
      uint64_t v386 = 8 * v25;
      uint64_t v387 = -(uint64_t)v21;
      do
      {
        int v388 = v731;
        unint64_t v776 = v12;
        do
        {
          if (*v16)
          {
            int v389 = v20 ? *v384 : 0xFFFF;
            int v390 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v391 = v389 - ((v389 * v390 + ((v389 * v390) >> 16) + 1) >> 16);
            __int16 v392 = v391;
            if ((_WORD)v391)
            {
              unint64_t v393 = HIWORD(*v23);
              unsigned int v394 = (unsigned __int16)WORD2(*v23) * v390;
              unint64_t v395 = ((unint64_t)(v393
                                       - ((v390 * v393 + ((v390 * v393) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v394 + HIWORD(v394) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v390 + ((WORD1(*v23) * v390) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v390 + (((unsigned __int16)*v23 * v390) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAsoftlightPDA_11718((unint64_t)*v14, (unsigned __int16)*v7, v395, (unsigned __int16)v391);
                  uint64_t v383 = v718;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v776;
                  unint64_t v395 = result;
                }
                *uint64_t v14 = (int8x8_t)v395;
                *int v7 = v392;
              }
              else
              {
                unint64_t result = PDAsoftlightPDA_11718((unint64_t)*v14, 0xFFFFu, v395, (unsigned __int16)v391);
                uint64_t v383 = v718;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v776;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v382;
          unint64_t v396 = &v23[v382];
          if ((unint64_t)v396 >= v12) {
            uint64_t v397 = v387;
          }
          else {
            uint64_t v397 = 0;
          }
          v384 += v383 + v397;
          int32x4_t v23 = &v396[v397];
          int v7 = (__int16 *)((char *)v7 + v385);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v386);
          --v388;
        }
        while (v388);
        if (v727)
        {
          unint64_t v398 = v734 + 8 * v732;
          uint64_t v399 = v672;
          if (v398 < v727) {
            uint64_t v399 = 0;
          }
          uint64_t v384 = (unsigned __int16 *)&v733[v730 + v399];
          uint64_t v400 = v692;
          if (v398 < v727) {
            uint64_t v400 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v398 + 8 * v400);
          v12 += 8 * v400 + 8 * v732;
          v733 += v730 + v399;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v384 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 21:
      uint64_t v401 = v25;
      uint64_t v402 = v20;
      unsigned int v403 = (unsigned __int16 *)v733;
      uint64_t v693 = -(v732 * v22);
      uint64_t v719 = v20;
      uint64_t v673 = -(uint64_t)(v730 * v22);
      uint64_t v404 = 2 * v8;
      uint64_t v405 = 8 * v25;
      uint64_t v406 = -(uint64_t)v21;
      do
      {
        int v407 = v731;
        unint64_t v777 = v12;
        do
        {
          if (*v16)
          {
            int v408 = v20 ? *v403 : 0xFFFF;
            int v409 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v410 = v408 - ((v408 * v409 + ((v408 * v409) >> 16) + 1) >> 16);
            __int16 v411 = v410;
            if ((_WORD)v410)
            {
              unint64_t v412 = HIWORD(*v23);
              unsigned int v413 = (unsigned __int16)WORD2(*v23) * v409;
              unint64_t v414 = ((unint64_t)(v412
                                       - ((v409 * v412 + ((v409 * v412) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v413 + HIWORD(v413) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v409 + ((WORD1(*v23) * v409) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v409 + (((unsigned __int16)*v23 * v409) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAhardlightPDA_11717((unint64_t)*v14, (unsigned __int16)*v7, v414, (unsigned __int16)v410);
                  uint64_t v402 = v719;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v777;
                  unint64_t v414 = result;
                }
                *uint64_t v14 = (int8x8_t)v414;
                *int v7 = v411;
              }
              else
              {
                unint64_t result = PDAhardlightPDA_11717((unint64_t)*v14, 0xFFFFu, v414, (unsigned __int16)v410);
                uint64_t v402 = v719;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v777;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v401;
          unint64_t v415 = &v23[v401];
          if ((unint64_t)v415 >= v12) {
            uint64_t v416 = v406;
          }
          else {
            uint64_t v416 = 0;
          }
          v403 += v402 + v416;
          int32x4_t v23 = &v415[v416];
          int v7 = (__int16 *)((char *)v7 + v404);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v405);
          --v407;
        }
        while (v407);
        if (v727)
        {
          unint64_t v417 = v734 + 8 * v732;
          uint64_t v418 = v673;
          if (v417 < v727) {
            uint64_t v418 = 0;
          }
          unsigned int v403 = (unsigned __int16 *)&v733[v730 + v418];
          uint64_t v419 = v693;
          if (v417 < v727) {
            uint64_t v419 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v417 + 8 * v419);
          v12 += 8 * v419 + 8 * v732;
          v733 += v730 + v418;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v403 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 22:
      uint64_t v420 = v25;
      uint64_t v421 = v20;
      unsigned int v422 = (unsigned __int16 *)v733;
      uint64_t v694 = -(v732 * v22);
      uint64_t v720 = v20;
      uint64_t v674 = -(uint64_t)(v730 * v22);
      uint64_t v423 = 2 * v8;
      uint64_t v424 = 8 * v25;
      uint64_t v425 = -(uint64_t)v21;
      do
      {
        int v426 = v731;
        unint64_t v778 = v12;
        do
        {
          if (*v16)
          {
            int v427 = v20 ? *v422 : 0xFFFF;
            int v428 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v429 = v427 - ((v427 * v428 + ((v427 * v428) >> 16) + 1) >> 16);
            __int16 v430 = v429;
            if ((_WORD)v429)
            {
              unint64_t v431 = HIWORD(*v23);
              unsigned int v432 = (unsigned __int16)WORD2(*v23) * v428;
              unint64_t v433 = ((unint64_t)(v431
                                       - ((v428 * v431 + ((v428 * v431) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v432 + HIWORD(v432) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v428 + ((WORD1(*v23) * v428) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v428 + (((unsigned __int16)*v23 * v428) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAdifferencePDA_11719((unint64_t)*v14, (unsigned __int16)*v7, v433, (unsigned __int16)v429);
                  uint64_t v421 = v720;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v778;
                  unint64_t v433 = result;
                }
                *uint64_t v14 = (int8x8_t)v433;
                *int v7 = v430;
              }
              else
              {
                unint64_t result = PDAdifferencePDA_11719((unint64_t)*v14, 0xFFFFu, v433, (unsigned __int16)v429);
                uint64_t v421 = v720;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v778;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v420;
          unint64_t v434 = &v23[v420];
          if ((unint64_t)v434 >= v12) {
            uint64_t v435 = v425;
          }
          else {
            uint64_t v435 = 0;
          }
          v422 += v421 + v435;
          int32x4_t v23 = &v434[v435];
          int v7 = (__int16 *)((char *)v7 + v423);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v424);
          --v426;
        }
        while (v426);
        if (v727)
        {
          unint64_t v436 = v734 + 8 * v732;
          uint64_t v437 = v674;
          if (v436 < v727) {
            uint64_t v437 = 0;
          }
          unsigned int v422 = (unsigned __int16 *)&v733[v730 + v437];
          uint64_t v438 = v694;
          if (v436 < v727) {
            uint64_t v438 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v436 + 8 * v438);
          v12 += 8 * v438 + 8 * v732;
          v733 += v730 + v437;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v422 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 23:
      uint64_t v439 = v25;
      uint64_t v440 = v20;
      unsigned int v441 = (unsigned __int16 *)v733;
      uint64_t v695 = -(v732 * v22);
      uint64_t v721 = v20;
      uint64_t v675 = -(uint64_t)(v730 * v22);
      uint64_t v442 = 2 * v8;
      uint64_t v443 = 8 * v25;
      uint64_t v444 = -(uint64_t)v21;
      do
      {
        int v445 = v731;
        unint64_t v779 = v12;
        do
        {
          if (*v16)
          {
            int v446 = v20 ? *v441 : 0xFFFF;
            int v447 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v448 = v446 - ((v446 * v447 + ((v446 * v447) >> 16) + 1) >> 16);
            __int16 v449 = v448;
            if ((_WORD)v448)
            {
              unint64_t v450 = HIWORD(*v23);
              unsigned int v451 = (unsigned __int16)WORD2(*v23) * v447;
              unint64_t v452 = ((unint64_t)(v450
                                       - ((v447 * v450 + ((v447 * v450) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v451 + HIWORD(v451) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v447 + ((WORD1(*v23) * v447) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v447 + (((unsigned __int16)*v23 * v447) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAexclusionPDA_11720((unint64_t)*v14, (unsigned __int16)*v7, v452, (unsigned __int16)v448);
                  uint64_t v440 = v721;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v779;
                  unint64_t v452 = result;
                }
                *uint64_t v14 = (int8x8_t)v452;
                *int v7 = v449;
              }
              else
              {
                unint64_t result = PDAexclusionPDA_11720((unint64_t)*v14, 0xFFFFu, v452, (unsigned __int16)v448);
                uint64_t v440 = v721;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v779;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v439;
          unint64_t v453 = &v23[v439];
          if ((unint64_t)v453 >= v12) {
            uint64_t v454 = v444;
          }
          else {
            uint64_t v454 = 0;
          }
          v441 += v440 + v454;
          int32x4_t v23 = &v453[v454];
          int v7 = (__int16 *)((char *)v7 + v442);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v443);
          --v445;
        }
        while (v445);
        if (v727)
        {
          unint64_t v455 = v734 + 8 * v732;
          uint64_t v456 = v675;
          if (v455 < v727) {
            uint64_t v456 = 0;
          }
          unsigned int v441 = (unsigned __int16 *)&v733[v730 + v456];
          uint64_t v457 = v695;
          if (v455 < v727) {
            uint64_t v457 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v455 + 8 * v457);
          v12 += 8 * v457 + 8 * v732;
          v733 += v730 + v456;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v441 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 24:
      uint64_t v458 = v25;
      uint64_t v459 = v20;
      unsigned int v460 = (unsigned __int16 *)v733;
      uint64_t v696 = -(v732 * v22);
      uint64_t v722 = v20;
      uint64_t v676 = -(uint64_t)(v730 * v22);
      uint64_t v461 = 2 * v8;
      uint64_t v462 = 8 * v25;
      uint64_t v463 = -(uint64_t)v21;
      do
      {
        int v464 = v731;
        unint64_t v780 = v12;
        do
        {
          if (*v16)
          {
            int v465 = v20 ? *v460 : 0xFFFF;
            int v466 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v467 = v465 - ((v465 * v466 + ((v465 * v466) >> 16) + 1) >> 16);
            __int16 v468 = v467;
            if ((_WORD)v467)
            {
              unint64_t v469 = HIWORD(*v23);
              unsigned int v470 = (unsigned __int16)WORD2(*v23) * v466;
              unint64_t v471 = ((unint64_t)(v469
                                       - ((v466 * v469 + ((v466 * v469) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v470 + HIWORD(v470) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v466 + ((WORD1(*v23) * v466) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v466 + (((unsigned __int16)*v23 * v466) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAhuePDA_11721((unint64_t)*v14, (unsigned __int16)*v7, v471, (unsigned __int16)v467);
                  uint64_t v459 = v722;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v780;
                  unint64_t v471 = result;
                }
                *uint64_t v14 = (int8x8_t)v471;
                *int v7 = v468;
              }
              else
              {
                unint64_t result = PDAhuePDA_11721((unint64_t)*v14, 0xFFFFu, v471, (unsigned __int16)v467);
                uint64_t v459 = v722;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v780;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v458;
          unint64_t v472 = &v23[v458];
          if ((unint64_t)v472 >= v12) {
            uint64_t v473 = v463;
          }
          else {
            uint64_t v473 = 0;
          }
          v460 += v459 + v473;
          int32x4_t v23 = &v472[v473];
          int v7 = (__int16 *)((char *)v7 + v461);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v462);
          --v464;
        }
        while (v464);
        if (v727)
        {
          unint64_t v474 = v734 + 8 * v732;
          uint64_t v475 = v676;
          if (v474 < v727) {
            uint64_t v475 = 0;
          }
          unsigned int v460 = (unsigned __int16 *)&v733[v730 + v475];
          uint64_t v476 = v696;
          if (v474 < v727) {
            uint64_t v476 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v474 + 8 * v476);
          v12 += 8 * v476 + 8 * v732;
          v733 += v730 + v475;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v460 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 25:
      uint64_t v477 = v25;
      uint64_t v478 = v20;
      unsigned int v479 = (unsigned __int16 *)v733;
      uint64_t v697 = -(v732 * v22);
      uint64_t v723 = v20;
      uint64_t v677 = -(uint64_t)(v730 * v22);
      uint64_t v480 = 2 * v8;
      uint64_t v481 = 8 * v25;
      uint64_t v482 = -(uint64_t)v21;
      do
      {
        int v483 = v731;
        unint64_t v781 = v12;
        do
        {
          if (*v16)
          {
            int v484 = v20 ? *v479 : 0xFFFF;
            int v485 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v486 = v484 - ((v484 * v485 + ((v484 * v485) >> 16) + 1) >> 16);
            __int16 v487 = v486;
            if ((_WORD)v486)
            {
              unint64_t v488 = HIWORD(*v23);
              unsigned int v489 = (unsigned __int16)WORD2(*v23) * v485;
              unint64_t v490 = ((unint64_t)(v488
                                       - ((v485 * v488 + ((v485 * v488) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v489 + HIWORD(v489) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v485 + ((WORD1(*v23) * v485) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v485 + (((unsigned __int16)*v23 * v485) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAsaturationPDA_11722((unint64_t)*v14, (unsigned __int16)*v7, v490, (unsigned __int16)v486);
                  uint64_t v478 = v723;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v781;
                  unint64_t v490 = result;
                }
                *uint64_t v14 = (int8x8_t)v490;
                *int v7 = v487;
              }
              else
              {
                unint64_t result = PDAsaturationPDA_11722((unint64_t)*v14, 0xFFFFu, v490, (unsigned __int16)v486);
                uint64_t v478 = v723;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v781;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v477;
          unint64_t v491 = &v23[v477];
          if ((unint64_t)v491 >= v12) {
            uint64_t v492 = v482;
          }
          else {
            uint64_t v492 = 0;
          }
          v479 += v478 + v492;
          int32x4_t v23 = &v491[v492];
          int v7 = (__int16 *)((char *)v7 + v480);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v481);
          --v483;
        }
        while (v483);
        if (v727)
        {
          unint64_t v493 = v734 + 8 * v732;
          uint64_t v494 = v677;
          if (v493 < v727) {
            uint64_t v494 = 0;
          }
          unsigned int v479 = (unsigned __int16 *)&v733[v730 + v494];
          uint64_t v495 = v697;
          if (v493 < v727) {
            uint64_t v495 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v493 + 8 * v495);
          v12 += 8 * v495 + 8 * v732;
          v733 += v730 + v494;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v479 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 26:
      uint64_t v496 = v25;
      uint64_t v497 = v20;
      unsigned int v498 = (unsigned __int16 *)v733;
      uint64_t v698 = -(v732 * v22);
      uint64_t v724 = v20;
      uint64_t v678 = -(uint64_t)(v730 * v22);
      uint64_t v499 = 2 * v8;
      uint64_t v500 = 8 * v25;
      uint64_t v501 = -(uint64_t)v21;
      do
      {
        int v502 = v731;
        unint64_t v782 = v12;
        do
        {
          if (*v16)
          {
            int v503 = v20 ? *v498 : 0xFFFF;
            int v504 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            __int16 v505 = v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16);
            if (v505)
            {
              unint64_t v506 = HIWORD(*v23);
              unsigned int v507 = (unsigned __int16)WORD2(*v23) * v504;
              unint64_t result = ((unint64_t)(v506
                                         - ((v504 * v506 + ((v504 * v506) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v507 + HIWORD(v507) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v504 + ((WORD1(*v23) * v504) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v504 + (((unsigned __int16)*v23 * v504) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_11723(result, (unsigned __int16)(v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16)), (unint64_t)*v14, (unsigned __int16)*v7);
                  uint64_t v497 = v724;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v782;
                }
                *uint64_t v14 = (int8x8_t)result;
                *int v7 = v505;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_11723(result, (unsigned __int16)(v503 - ((v503 * v504 + ((v503 * v504) >> 16) + 1) >> 16)), (unint64_t)*v14, 0xFFFFu);
                uint64_t v497 = v724;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v782;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v496;
          unint64_t v508 = &v23[v496];
          if ((unint64_t)v508 >= v12) {
            uint64_t v509 = v501;
          }
          else {
            uint64_t v509 = 0;
          }
          v498 += v497 + v509;
          int32x4_t v23 = &v508[v509];
          int v7 = (__int16 *)((char *)v7 + v499);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v500);
          --v502;
        }
        while (v502);
        if (v727)
        {
          unint64_t v510 = v734 + 8 * v732;
          uint64_t v511 = v678;
          if (v510 < v727) {
            uint64_t v511 = 0;
          }
          unsigned int v498 = (unsigned __int16 *)&v733[v730 + v511];
          uint64_t v512 = v698;
          if (v510 < v727) {
            uint64_t v512 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v510 + 8 * v512);
          v12 += 8 * v512 + 8 * v732;
          v733 += v730 + v511;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v498 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    case 27:
      uint64_t v513 = v25;
      uint64_t v514 = v20;
      int v515 = (unsigned __int16 *)v733;
      uint64_t v699 = -(v732 * v22);
      uint64_t v725 = v20;
      uint64_t v679 = -(uint64_t)(v730 * v22);
      uint64_t v516 = 2 * v8;
      uint64_t v517 = 8 * v25;
      uint64_t v518 = -(uint64_t)v21;
      do
      {
        int v519 = v731;
        unint64_t v783 = v12;
        do
        {
          if (*v16)
          {
            int v520 = v20 ? *v515 : 0xFFFF;
            int v521 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v522 = v520 - ((v520 * v521 + ((v520 * v521) >> 16) + 1) >> 16);
            __int16 v523 = v522;
            if ((_WORD)v522)
            {
              unint64_t v524 = HIWORD(*v23);
              unsigned int v525 = (unsigned __int16)WORD2(*v23) * v521;
              unint64_t v526 = ((unint64_t)(v524
                                       - ((v521 * v524 + ((v521 * v524) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v525 + HIWORD(v525) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v521 + ((WORD1(*v23) * v521) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v521 + (((unsigned __int16)*v23 * v521) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_11723((unint64_t)*v14, (unsigned __int16)*v7, v526, (unsigned __int16)v522);
                  uint64_t v514 = v725;
                  int v8 = v736;
                  int v20 = v750;
                  unint64_t v12 = v783;
                  unint64_t v526 = result;
                }
                *uint64_t v14 = (int8x8_t)v526;
                *int v7 = v523;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_11723((unint64_t)*v14, 0xFFFFu, v526, (unsigned __int16)v522);
                uint64_t v514 = v725;
                int v8 = v736;
                int v20 = v750;
                unint64_t v12 = v783;
                *uint64_t v14 = (int8x8_t)result;
              }
            }
          }
          v16 += v513;
          unint64_t v527 = &v23[v513];
          if ((unint64_t)v527 >= v12) {
            uint64_t v528 = v518;
          }
          else {
            uint64_t v528 = 0;
          }
          v515 += v514 + v528;
          int32x4_t v23 = &v527[v528];
          int v7 = (__int16 *)((char *)v7 + v516);
          uint64_t v14 = (int8x8_t *)((char *)v14 + v517);
          --v519;
        }
        while (v519);
        if (v727)
        {
          unint64_t v529 = v734 + 8 * v732;
          uint64_t v530 = v679;
          if (v529 < v727) {
            uint64_t v530 = 0;
          }
          int v515 = (unsigned __int16 *)&v733[v730 + v530];
          uint64_t v531 = v699;
          if (v529 < v727) {
            uint64_t v531 = 0;
          }
          int32x4_t v23 = (unint64_t *)(v529 + 8 * v531);
          v12 += 8 * v531 + 8 * v732;
          v733 += v730 + v530;
          unint64_t v734 = (unint64_t)v23;
        }
        else
        {
          v23 += v732;
          v515 += v730;
        }
        v16 += v729;
        v14 += v728;
        v7 += v726;
        --v735;
      }
      while (v735);
      return result;
    default:
      return result;
  }
  do
  {
    int v562 = v731;
    unint64_t v563 = v12;
    do
    {
      int v564 = *v16;
      if (!*v16) {
        goto LABEL_703;
      }
      if (v564 == 255)
      {
        int v565 = (unsigned __int16)*v561;
        if (!*v561) {
          goto LABEL_703;
        }
        if (v565 == 0xFFFF)
        {
          *uint64_t v14 = (int8x8_t)*v23;
          goto LABEL_703;
        }
        uint64_t v570 = *v23;
        unint64_t v571 = (unint64_t)*v14;
        int v572 = v565 ^ 0xFFFF;
      }
      else
      {
        int v566 = (unsigned __int16)*v561;
        int v567 = (v564 | (v564 << 8)) ^ 0xFFFF;
        unsigned int v568 = v567 * v566 + ((v567 * v566) >> 16) + 1;
        if (v566 == HIWORD(v568)) {
          goto LABEL_703;
        }
        unsigned int v569 = (unsigned __int16)WORD2(*v23) * v567;
        uint64_t v570 = ((HIWORD(*v23) - ((v567 * HIWORD(*v23) + ((v567 * HIWORD(*v23)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*v23) - ((v569 + HIWORD(v569) + 1) >> 16)) << 32) | ((WORD1(*v23) - ((WORD1(*v23) * v567 + ((WORD1(*v23) * v567) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*v23 - (((unsigned __int16)*v23 * v567 + (((unsigned __int16)*v23 * v567) >> 16) + 1) >> 16));
        unint64_t v571 = (unint64_t)*v14;
        int v572 = (unsigned __int16)(~(_WORD)v566 + HIWORD(v568));
      }
      unint64_t result = (uint64_t)cmyk64_DplusDM(v14, v570, v571, v572);
      unint64_t v12 = v563;
LABEL_703:
      v16 += v53;
      unint64_t v573 = &v23[v53];
      if ((unint64_t)v573 >= v12) {
        uint64_t v574 = v560;
      }
      else {
        uint64_t v574 = 0;
      }
      v561 += v559 + v574;
      int32x4_t v23 = &v573[v574];
      v14 += v53;
      --v562;
    }
    while (v562);
    if (v727)
    {
      unint64_t v575 = v734 + 8 * v732;
      uint64_t v576 = v757;
      if (v575 < v727) {
        uint64_t v576 = 0;
      }
      v561 = &v733[v730 + v576];
      uint64_t v577 = v785;
      if (v575 < v727) {
        uint64_t v577 = 0;
      }
      int32x4_t v23 = (unint64_t *)(v575 + 8 * v577);
      v12 += 8 * v577 + 8 * v732;
      v733 += v730 + v576;
      unint64_t v734 = (unint64_t)v23;
    }
    else
    {
      v23 += v732;
      v561 += v730;
    }
    v16 += v729;
    v14 += v728;
    --v735;
  }
  while (v735);
  return result;
}

_DWORD *cmyk64_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11 = PIXELCONSTANT_11727(*(float **)(*(void *)a1 + 64), a4, a5, a6, a7, a8, a9);
  unsigned __int16 v13 = v12;
  if (a2 && a3 > 0xB || (a2 = malloc_type_malloc(0x3CuLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDC20;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    *((void *)a2 + 6) = v11;
    *((void *)a2 + 4) = a2 + 12;
    if (v13 > 0xFEu)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[14] = v13 | (v13 << 16);
      *((void *)a2 + 5) = a2 + 14;
    }
  }
  return a2;
}

unint64_t PIXELCONSTANT_11727(float *a1, int a2, float32x2_t *a3, float a4, double a5, double a6, double a7)
{
  *(float *)&a7 = *a1;
  *(float *)&a6 = a1[1];
  float v7 = *(float *)&a6;
  if (*(float *)&a6 >= a4)
  {
    float v7 = a4;
    if (*(float *)&a7 > a4) {
      float v7 = *a1;
    }
  }
  float v8 = a1[3];
  float v9 = v7 * a1[2];
  if (a3) {
    int v10 = a2;
  }
  else {
    int v10 = 0;
  }
  if (v10 == 1)
  {
    float v33 = a1[1];
    if (a3->f32[0] <= *(float *)&a6)
    {
      float v33 = a3->f32[0];
      if (a3->f32[0] < *(float *)&a7) {
        float v33 = *a1;
      }
    }
    LOWORD(v19) = 0;
    unsigned int v20 = 0;
    LOWORD(v21) = 0;
    uint64_t v32 = (float)(v8 + (float)((float)(*(float *)&a6 - v33) * v9));
  }
  else
  {
    if (v10 == 4)
    {
      float v23 = a3->f32[1];
      float v24 = a3[1].f32[0];
      float v25 = a3[1].f32[1];
      if (a3->f32[0] < *(float *)&a7) {
        float v26 = *a1;
      }
      else {
        float v26 = a3->f32[0];
      }
      if (a3->f32[0] <= *(float *)&a6) {
        float v27 = v26;
      }
      else {
        float v27 = a1[1];
      }
      if (v23 < *(float *)&a7) {
        float v28 = *a1;
      }
      else {
        float v28 = a3->f32[1];
      }
      if (v23 <= *(float *)&a6) {
        float v29 = v28;
      }
      else {
        float v29 = a1[1];
      }
      if (v24 < *(float *)&a7) {
        float v30 = *a1;
      }
      else {
        float v30 = a3[1].f32[0];
      }
      if (v24 <= *(float *)&a6) {
        float v31 = v30;
      }
      else {
        float v31 = a1[1];
      }
      if (v25 >= *(float *)&a7) {
        LODWORD(a7) = a3[1].i32[1];
      }
      if (v25 <= *(float *)&a6) {
        *(float *)&a6 = *(float *)&a7;
      }
      unsigned int v19 = (float)(v8 + (float)(v27 * v9));
      unsigned int v20 = (float)(v8 + (float)(v29 * v9));
      unsigned int v21 = (float)(v8 + (float)(v31 * v9));
      float v22 = v8 + (float)(*(float *)&a6 * v9);
    }
    else
    {
      if (v10 != 3)
      {
        LOWORD(v19) = 0;
        unsigned int v20 = 0;
        LOWORD(v21) = 0;
        uint64_t v32 = (float)(v8 + v9);
        return ((unint64_t)(unsigned __int16)v21 << 32) | (v32 << 48) | (v20 << 16) | (unint64_t)(unsigned __int16)v19;
      }
      float v11 = a3[1].f32[0];
      float32x2_t v12 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
      float32x2_t v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
      int8x8_t v14 = vbsl_s8((int8x8_t)vcgt_f32(*a3, v12), (int8x8_t)v13, (int8x8_t)vsub_f32(v12, (float32x2_t)vbic_s8((int8x8_t)*a3, (int8x8_t)vcgt_f32(v13, *a3))));
      float v15 = 0.0;
      if (v11 >= *(float *)&a7) {
        float v15 = a3[1].f32[0];
      }
      float v16 = *(float *)&a6 - v15;
      if (v11 <= *(float *)&a6) {
        float v17 = v16;
      }
      else {
        float v17 = *a1;
      }
      if (*(float *)v14.i32 >= *(float *)&v14.i32[1]) {
        float v18 = *(float *)&v14.i32[1];
      }
      else {
        float v18 = *(float *)v14.i32;
      }
      if (v17 < v18) {
        float v18 = v17;
      }
      unsigned int v19 = (float)(v8 + (float)((float)(*(float *)v14.i32 - v18) * v9));
      unsigned int v20 = (float)(v8 + (float)((float)(*(float *)&v14.i32[1] - v18) * v9));
      unsigned int v21 = (float)(v8 + (float)((float)(v17 - v18) * v9));
      float v22 = v8 + (float)(v18 * v9);
    }
    uint64_t v32 = v22;
  }
  return ((unint64_t)(unsigned __int16)v21 << 32) | (v32 << 48) | (v20 << 16) | (unint64_t)(unsigned __int16)v19;
}

uint64_t CMYK64_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)uint32x2_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(void *)(v5 + 16))
    {
      int8x8_t v14 = cmyk64_shade_radial_CMYK;
    }
    else if (*(void *)(v5 + 24))
    {
      int8x8_t v14 = cmyk64_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      int8x8_t v14 = cmyk64_shade_axial_CMYK;
    }
    else
    {
      int8x8_t v14 = cmyk64_shade_custom_CMYK;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 384)
    {
      float v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    float v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  CMYK64_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void CMYK64_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v641 = a3;
  uint64_t v656 = *MEMORY[0x1E4F143B8];
  uint64_t v647 = *(unsigned int *)(a1 + 4);
  uint64_t v640 = (int)v647;
  unint64_t v4 = ((int)v647 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    float v8 = *(float *)(a2 + 184);
    uint64_t v9 = *(int **)(a1 + 136);
    uint64_t v649 = *(void *)(a2 + 96);
    uint64_t v652 = *(void *)(a2 + 104);
    uint64_t v11 = *(int *)(a1 + 24);
    unint64_t v10 = *(int *)(a1 + 28);
    uint64_t v13 = *(int *)(a1 + 16);
    float32x2_t v12 = (unsigned __int8 *)*(int *)(a1 + 20);
    uint64_t v654 = v6;
    int v655 = v12;
    uint64_t v14 = *(int *)(a1 + 12);
    int v651 = *(_DWORD *)(a1 + 8);
    unsigned int v643 = (void *)a2;
    uint64_t v15 = *(int *)(a2 + 16);
    uint64_t v16 = (v15 + 18) * v4;
    if (v16 > 65439)
    {
      long long v20 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
      long long v18 = v20;
      long long v21 = v643;
      if (!v20) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](a1, a4);
      long long v18 = (char *)&v631 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, v17);
      long long v20 = 0;
      long long v21 = v643;
    }
    uint64_t v639 = a1;
    unint64_t v22 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v23 = v22 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    v21[20] = v23;
    if (v15) {
      uint64_t v24 = 16 * v4;
    }
    else {
      uint64_t v24 = 0;
    }
    unint64_t v25 = v23 + v24;
    uint64_t v26 = v7 + (v11 - 1) * v10;
    unint64_t v27 = v10 >> 3;
    v21[18] = v22;
    v21[19] = v25;
    if (v654)
    {
      uint64_t v28 = v639;
      unint64_t v29 = (unint64_t)*(int *)(v639 + 32) >> 1;
      long long v30 = (unsigned __int16 *)(v654 + 2 * (v14 + v29 * v13));
      uint64_t v645 = v29 - v640;
      uint64_t v31 = v640;
      uint64_t v32 = 1;
    }
    else
    {
      long long v30 = 0;
      uint64_t v645 = 0;
      uint64_t v32 = 0;
      uint64_t v28 = v639;
      uint64_t v31 = v640;
    }
    int v646 = (int)(float)((float)(v8 * 65535.0) + 0.5);
    uint64_t v33 = v26 + 8 * (void)v655;
    long long v34 = (int8x8_t *)(v7 + 8 * (v14 + v27 * v13));
    uint64_t v644 = v27 - v31;
    uint64_t v35 = *(int *)(v28 + 104);
    int v36 = *(_DWORD *)(v28 + 108);
    int v37 = *(unsigned __int8 *)(v28 + 2);
    if (v37 == 6 || v37 == 1)
    {
      int v38 = v641;
      long long v39 = v643;
      uint64_t v40 = v647;
      uint64_t v41 = v649;
      if (v9)
      {
        unint64_t v632 = v27;
        unint64_t v635 = v20;
        int8x16_t v42 = 0;
        int v43 = 0;
        uint64_t v44 = *(int *)(v639 + 124);
        uint64_t v45 = (unsigned __int8 *)v9 + v35 + (int)v44 * (uint64_t)v36;
        uint64_t v31 = v640;
        uint64_t v642 = v44 - v640;
LABEL_21:
        uint64_t v51 = v652;
LABEL_32:
        int v650 = v43;
        int v60 = v646 ^ 0xFFFF;
        uint64_t v637 = (v40 - 1) + 1;
        uint64_t v636 = -v31;
        uint64_t v633 = v33;
        uint64_t v638 = (int8x8_t *)(v33 - 8);
        uint64_t v634 = v32;
        int v61 = v42;
        uint64_t v653 = 2 * v32;
        while (2)
        {
          int v655 = v45;
          unint64_t v648 = v61;
          int v62 = (void (*)(void *, uint64_t, uint64_t, uint64_t))*v39;
          uint64_t v652 = v51;
          v62(v39, v41, v51, v40);
          uint64_t v64 = v39[20];
          unint64_t v65 = (unsigned char *)v39[18];
          unsigned int v66 = *((_DWORD *)v39 + 2);
          if (v66 == *((_DWORD *)v39 + 3))
          {
            if (v646 == 0xFFFF)
            {
              uint64_t v69 = v653;
              uint64_t v45 = v655;
            }
            else
            {
              int v67 = v40;
              int8x16_t v68 = (unsigned char *)v39[18];
              uint64_t v69 = v653;
              uint64_t v45 = v655;
              do
              {
                if (*v68)
                {
                  int v70 = *(unsigned __int16 *)(v64 + 8);
                  unsigned int v71 = (unsigned __int16)WORD2(*(void *)v64) * v60;
                  *(void *)uint64_t v64 = ((HIWORD(*(void *)v64)
                                   - ((HIWORD(*(void *)v64) * v60
                                     + ((HIWORD(*(void *)v64) * v60) >> 16)
                                     + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v64)
                                                                                               - ((v71 + HIWORD(v71) + 1) >> 16)) << 32) | ((WORD1(*(void *)v64) - ((WORD1(*(void *)v64) * v60 + ((WORD1(*(void *)v64) * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v64 - (((unsigned __int16)*(void *)v64 * v60 + (((unsigned __int16)*(void *)v64 * v60) >> 16) + 1) >> 16));
                  *(_WORD *)(v64 + 8) = v70 - ((v70 * v60 + ((v70 * v60) >> 16) + 1) >> 16);
                }
                ++v68;
                v64 += 16;
                --v67;
              }
              while (v67);
              v64 += 16 * v636;
              v65 += v637 + v636;
            }
          }
          else
          {
            uint64_t v72 = v39[19];
            int v73 = HIWORD(v66) & 0x3F;
            if (v73 == 16)
            {
              uint64_t v69 = v653;
              uint64_t v45 = v655;
              uint64_t v87 = 0;
              uint64_t v88 = 0;
              if (v646 == 0xFFFF)
              {
                do
                {
                  if (v65[v87]) {
                    *(_OWORD *)(v64 + v88) = *(_OWORD *)(v72 + v88);
                  }
                  v88 += 16;
                  ++v87;
                }
                while (v40 != v87);
              }
              else
              {
                do
                {
                  if (v65[v87])
                  {
                    int v89 = *(unsigned __int16 *)(v72 + v88 + 8);
                    unint64_t v90 = *(void *)(v72 + v88);
                    uint64_t v91 = v64 + v88;
                    *(void *)uint64_t v91 = ((HIWORD(v90)
                                     - ((HIWORD(v90) * v60 + ((HIWORD(v90) * v60) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v90) - ((WORD2(v90) * v60 + ((WORD2(v90) * v60) >> 16) + 1) >> 16)) << 32) | ((WORD1(v90) - ((WORD1(v90) * v60 + ((WORD1(v90) * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v90 - (((unsigned __int16)v90 * v60 + (((unsigned __int16)v90 * v60) >> 16) + 1) >> 16));
                    *(_WORD *)(v91 + 8) = v89 - ((v89 * v60 + ((v89 * v60) >> 16) + 1) >> 16);
                  }
                  v88 += 16;
                  ++v87;
                }
                while (v40 != v87);
              }
            }
            else
            {
              uint64_t v69 = v653;
              uint64_t v45 = v655;
              if (v73 == 32)
              {
                if (v646 == 0xFFFF)
                {
                  uint64_t v103 = 0;
                  uint64_t v104 = 0;
                  uint64_t v105 = v72 + 8;
                  do
                  {
                    if (v65[v103])
                    {
                      v63.i32[0] = *(_DWORD *)(v105 + 8);
                      if (*(float *)v63.i32 <= 0.0)
                      {
                        LOWORD(v106) = 0;
                        *(void *)(v64 + v104) = 0;
                      }
                      else
                      {
                        LODWORD(v106) = (int)(float)((float)(*(float *)v63.i32 * 65535.0) + 0.5);
                        float v107 = *(float *)(v105 - 8);
                        if (*(float *)v63.i32 <= 1.0) {
                          uint64_t v106 = v106;
                        }
                        else {
                          uint64_t v106 = 0xFFFFLL;
                        }
                        if (*(float *)v63.i32 > 1.0) {
                          *(float *)v63.i32 = 1.0;
                        }
                        LOWORD(v108) = v106;
                        if (v107 <= *(float *)v63.i32)
                        {
                          if (v107 >= 0.0) {
                            int v108 = (int)(float)((float)(v107 * 65535.0) + 0.5);
                          }
                          else {
                            LOWORD(v108) = 0;
                          }
                        }
                        float v109 = *(float *)(v105 - 4);
                        int v110 = v106;
                        if (v109 <= *(float *)v63.i32)
                        {
                          if (v109 >= 0.0) {
                            int v110 = (int)(float)((float)(v109 * 65535.0) + 0.5);
                          }
                          else {
                            int v110 = 0;
                          }
                        }
                        float v111 = *(float *)v105;
                        LOWORD(v112) = v106;
                        if (*(float *)v105 <= *(float *)v63.i32)
                        {
                          if (v111 >= 0.0) {
                            int v112 = (int)(float)((float)(v111 * 65535.0) + 0.5);
                          }
                          else {
                            LOWORD(v112) = 0;
                          }
                        }
                        float v113 = *(float *)(v105 + 4);
                        uint64_t v114 = v106;
                        if (v113 <= *(float *)v63.i32)
                        {
                          if (v113 >= 0.0) {
                            uint64_t v114 = (int)(float)((float)(v113 * 65535.0) + 0.5);
                          }
                          else {
                            uint64_t v114 = 0;
                          }
                        }
                        *(void *)(v64 + v104) = ((unint64_t)(unsigned __int16)v112 << 32) | (v114 << 48) | (v110 << 16) | (unint64_t)(unsigned __int16)v108;
                      }
                      *(_WORD *)(v64 + v104 + 8) = v106;
                    }
                    v104 += 16;
                    v105 += 20;
                    ++v103;
                  }
                  while (v40 != v103);
                }
                else
                {
                  uint64_t v74 = 0;
                  uint64_t v75 = 0;
                  uint64_t v76 = v72 + 8;
                  do
                  {
                    if (v65[v74])
                    {
                      v63.i32[0] = *(_DWORD *)(v76 + 8);
                      if (*(float *)v63.i32 <= 0.0)
                      {
                        LOWORD(v81) = 0;
                        *(void *)(v64 + v75) = 0;
                      }
                      else
                      {
                        float v77 = *(float *)(v76 - 8);
                        int v78 = (int)(float)((float)(*(float *)v63.i32 * 65535.0) + 0.5);
                        if (*(float *)v63.i32 > 1.0) {
                          int v78 = 0xFFFF;
                        }
                        int v79 = v78;
                        if (*(float *)v63.i32 > 1.0) {
                          *(float *)v63.i32 = 1.0;
                        }
                        int v80 = v78;
                        if (v77 <= *(float *)v63.i32)
                        {
                          if (v77 >= 0.0) {
                            int v80 = (int)(float)((float)(v77 * 65535.0) + 0.5);
                          }
                          else {
                            int v80 = 0;
                          }
                        }
                        float v82 = *(float *)(v76 - 4);
                        int v83 = v78;
                        if (v82 <= *(float *)v63.i32)
                        {
                          if (v82 >= 0.0) {
                            int v83 = (int)(float)((float)(v82 * 65535.0) + 0.5);
                          }
                          else {
                            int v83 = 0;
                          }
                        }
                        float v84 = *(float *)v76;
                        int v85 = v78;
                        if (*(float *)v76 <= *(float *)v63.i32)
                        {
                          if (v84 >= 0.0) {
                            int v85 = (int)(float)((float)(v84 * 65535.0) + 0.5);
                          }
                          else {
                            int v85 = 0;
                          }
                        }
                        float v86 = *(float *)(v76 + 4);
                        if (v86 <= *(float *)v63.i32)
                        {
                          if (v86 >= 0.0) {
                            int v79 = (int)(float)((float)(v86 * 65535.0) + 0.5);
                          }
                          else {
                            int v79 = 0;
                          }
                        }
                        unsigned int v81 = v78 - ((v78 * v60 + ((v78 * v60) >> 16) + 1) >> 16);
                        *(void *)(v64 + v75) = ((unint64_t)(unsigned __int16)(v85
                                                                                     - ((v85 * v60
                                                                                       + ((v85 * v60) >> 16)
                                                                                       + 1) >> 16)) << 32) | ((unint64_t)(v79 - ((v79 * v60 + ((v79 * v60) >> 16) + 1) >> 16)) << 48) | ((v83 - ((v83 * v60 + ((v83 * v60) >> 16) + 1) >> 16)) << 16) | (unint64_t)(unsigned __int16)(v80 - ((v80 * v60 + ((v80 * v60) >> 16) + 1) >> 16));
                      }
                      *(_WORD *)(v64 + v75 + 8) = v81;
                    }
                    v75 += 16;
                    v76 += 20;
                    ++v74;
                  }
                  while (v40 != v74);
                }
              }
              else if (v646 == 0xFFFF)
              {
                uint64_t v115 = 0;
                uint64_t v116 = (_WORD *)(v64 + 8);
                do
                {
                  if (v65[v115])
                  {
                    uint64_t v117 = *(void *)(v72 + 8 * v115);
                    HIDWORD(v118) = BYTE3(v117);
                    LODWORD(v118) = v117;
                    *((void *)v116 - 1) = ((unint64_t)(v117 | (v117 << 8)) << 48) | ((unint64_t)(BYTE1(v117) | (BYTE1(v117) << 8)) << 32) | v117 & 0xFF0000 | ((unint64_t)BYTE2(v117) << 24) | (v118 >> 24);
                    *uint64_t v116 = BYTE4(v117) | (unsigned __int16)(WORD2(v117) << 8);
                  }
                  ++v115;
                  v116 += 8;
                }
                while (v40 != v115);
              }
              else
              {
                uint64_t v92 = 0;
                uint64_t v93 = (_WORD *)(v64 + 8);
                do
                {
                  if (v65[v92])
                  {
                    uint64_t v94 = v72 + 8 * v92;
                    int v95 = *(unsigned __int8 *)(v94 + 4);
                    LODWORD(v94) = *(_DWORD *)v94;
                    int v96 = BYTE2(v94);
                    int v97 = BYTE1(v94);
                    int v98 = v94;
                    HIDWORD(v99) = BYTE3(v94);
                    LODWORD(v99) = v94;
                    LODWORD(v94) = v99 >> 24;
                    int v100 = v96 | (v96 << 8);
                    int v101 = v97 | (v97 << 8);
                    int v102 = v98 | (v98 << 8);
                    *((void *)v93 - 1) = ((unint64_t)(v102
                                                             - ((v102 * v60 + ((v102 * v60) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v101 - ((v101 * v60 + ((v101 * v60) >> 16) + 1) >> 16)) << 32) | ((v100 - ((v100 * v60 + ((v100 * v60) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v94 - ((v94 * v60 + ((v94 * v60) >> 16) + 1) >> 16));
                    *uint64_t v93 = (v95 | ((_WORD)v95 << 8))
                         - (((v95 | (v95 << 8)) * v60 + (((v95 | (v95 << 8)) * v60) >> 16) + 1) >> 16);
                  }
                  ++v92;
                  v93 += 8;
                }
                while (v40 != v92);
              }
            }
          }
          switch(v38)
          {
            case 0:
              uint64_t v119 = v41;
              uint64_t v120 = v45 != 0;
              uint64_t v50 = v654;
              if (v654)
              {
                unsigned int v121 = v45;
                do
                {
                  int v122 = *v65;
                  if (*v65)
                  {
                    if (v45) {
                      int v122 = ((unsigned __int16)(*v121 * (_WORD)v122
                    }
                                                                + ((*v121 * v122) >> 8)
                                                                + 1) >> 8);
                    if (v122)
                    {
                      if (v122 == 255)
                      {
                        *long long v34 = 0;
                        *long long v30 = 0;
                      }
                      else
                      {
                        CMYK64_DAM(v34, v30, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(*v30) >> 16, (v122 | (v122 << 8)) ^ 0xFFFF);
                        uint64_t v50 = v654;
                        uint64_t v45 = v655;
                      }
                    }
                  }
                  ++v65;
                  v121 += v120;
                  ++v34;
                  ++v30;
                  LODWORD(v40) = v40 - 1;
                }
                while (v40);
                uint64_t v45 = &v121[v642];
                v34 += v644;
                v30 += v645;
                uint64_t v40 = v647;
              }
              else
              {
                int v468 = v40;
                unint64_t v469 = v45;
                do
                {
                  int v470 = *v65;
                  if (*v65)
                  {
                    if (v45) {
                      int v470 = ((unsigned __int16)(*v469 * (_WORD)v470
                    }
                                                                + ((*v469 * v470) >> 8)
                                                                + 1) >> 8);
                    if (v470)
                    {
                      if (v470 == 255)
                      {
                        *long long v34 = 0;
                      }
                      else
                      {
                        unsigned int v471 = bswap32(v34->u16[1] | (v34->u16[0] << 16));
                        v472.i32[0] = (unsigned __int16)v471;
                        v472.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v471), 0x10uLL).i32[1];
                        v472.i64[1] = __PAIR64__(bswap32(v34->u16[3]) >> 16, bswap32(v34->u16[2]) >> 16);
                        uint32x4_t v473 = (uint32x4_t)vmulq_s32(v472, vdupq_n_s32(v470 | (v470 << 8)));
                        v474.i64[0] = 0x100000001;
                        v474.i64[1] = 0x100000001;
                        v472.i32[0] = v471;
                        *long long v34 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v472, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v473, v473, 0x10uLL), v474), 0x10uLL))));
                      }
                    }
                  }
                  ++v65;
                  v469 += v120;
                  ++v34;
                  --v468;
                }
                while (v468);
                uint64_t v45 = &v469[v642];
                v34 += v644;
                v30 += v645;
              }
              uint64_t v41 = v119;
              goto LABEL_494;
            case 1:
              int v123 = *v65;
              uint64_t v50 = v654;
              if (v654)
              {
                uint64_t v649 = v41;
                if (v45)
                {
                  uint64_t v124 = 0;
                  unint64_t v125 = (unsigned __int16 *)(v64 + 8);
                  uint64_t v126 = v65 + 1;
                  uint64_t v127 = v30;
                  do
                  {
                    uint64_t v128 = (uint64_t)v34;
                    uint64_t v129 = v127;
                    if (v123)
                    {
                      unsigned int v130 = v45[v124] * v123 + ((v45[v124] * v123) >> 8) + 1;
                      if (BYTE1(v130))
                      {
                        if (BYTE1(v130) == 255)
                        {
                          unint64_t v131 = *((void *)v125 - 1);
                          unint64_t v132 = HIDWORD(v131);
                          unint64_t v133 = HIWORD(v131);
                          LODWORD(v131) = bswap32(v131);
                          v34->i16[0] = WORD1(v131);
                          v34->i16[1] = v131;
                          v34->i16[2] = bswap32(v132) >> 16;
                          v34->i16[3] = __rev16(v133);
                          v30[v124] = bswap32(*v125) >> 16;
                        }
                        else
                        {
                          CMYK64_DAMplusDAM(v34, v129, *((void *)v125 - 1), *v125, (unsigned __int16)(257 * (v130 >> 8)), ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(v30[v124]) >> 16, (unsigned __int16)~(257 * (v130 >> 8)));
                          uint64_t v50 = v654;
                          uint64_t v45 = v655;
                        }
                      }
                    }
                    int v123 = v126[v124];
                    ++v34;
                    uint64_t v127 = v129 + 1;
                    ++v124;
                    v125 += 8;
                  }
                  while (v647 != v124);
                  v45 += v124 + v642;
                }
                else
                {
                  uint64_t v558 = 0;
                  unint64_t v559 = 0;
                  uint64_t v560 = v65 + 1;
                  do
                  {
                    if (v123)
                    {
                      v561 = &v30[v558];
                      if (v123 == 255)
                      {
                        unint64_t v562 = *(void *)(v64 + 4 * v558);
                        unint64_t v563 = HIDWORD(v562);
                        unint64_t v564 = HIWORD(v562);
                        LODWORD(v562) = bswap32(v562);
                        int v565 = &v34[v559 / 8];
                        v565->i16[0] = WORD1(v562);
                        v565->i16[1] = v562;
                        v565->i16[2] = bswap32(v563) >> 16;
                        v565->i16[3] = __rev16(v564);
                        unsigned __int16 *v561 = bswap32(*(unsigned __int16 *)(v64 + 2 * v559 + 8)) >> 16;
                      }
                      else
                      {
                        CMYK64_DAMplusDAM(&v34[v559 / 8], v561, *(void *)(v64 + 4 * v558), *(unsigned __int16 *)(v64 + 2 * v559 + 8), v123 | (v123 << 8), ((unint64_t)(bswap32(v34[v559 / 8].u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34[v559 / 8].u16[3]) >> 16) << 48) | bswap32(v34[v559 / 8].u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34[v559 / 8].u16[0]) >> 16), bswap32(*v561) >> 16, (v123 | (v123 << 8)) ^ 0xFFFF);
                        uint64_t v50 = v654;
                      }
                    }
                    int v566 = *v560++;
                    int v123 = v566;
                    v559 += 8;
                    ++v558;
                    LODWORD(v40) = v40 - 1;
                  }
                  while (v40);
                  uint64_t v45 = 0;
                  uint64_t v129 = &v30[v558 - 1];
                  uint64_t v128 = (uint64_t)&v34[v559 / 8 - 1];
                }
                long long v34 = (int8x8_t *)(v128 + 8 * v644 + 8);
                long long v30 = &v129[v645 + 1];
                goto LABEL_492;
              }
              if (v45)
              {
                uint64_t v475 = v65 + 1;
                int v476 = v40;
                int v138 = v651;
                do
                {
                  if (v123)
                  {
                    unsigned int v477 = *v45 * v123 + ((*v45 * v123) >> 8) + 1;
                    uint64_t v478 = *(int8x8_t **)(v639 + 40);
                    unsigned int v479 = v638;
                    if (v638 >= v34) {
                      unsigned int v479 = v34;
                    }
                    if (v479 >= v478) {
                      uint64_t v478 = v479;
                    }
                    if (BYTE1(v477))
                    {
                      if (BYTE1(v477) == 255)
                      {
                        uint64_t v480 = HIDWORD(*(void *)v64);
                        uint64_t v481 = HIWORD(*(void *)v64);
                        unsigned int v482 = bswap32(*(void *)v64);
                        v478->i16[0] = HIWORD(v482);
                        v478->i16[1] = v482;
                        v478->i16[2] = bswap32(v480) >> 16;
                        v478->i16[3] = __rev16(v481);
                      }
                      else
                      {
                        unsigned int v483 = bswap32(v478->u16[1] | (v478->u16[0] << 16));
                        v484.i32[0] = 257 * (v477 >> 8);
                        v484.i32[1] = ~v484.i32[0];
                        *(int8x8_t *)v485.i8 = vand_s8(v484, (int8x8_t)0xFFFF0000FFFFLL);
                        v486.i64[0] = v485.i64[0];
                        v486.i64[1] = v485.i64[0];
                        v487.i32[0] = (unsigned __int16)v483;
                        v487.i32[1] = WORD1(*(void *)v64);
                        v487.i32[2] = bswap32(v478->u16[2]) >> 16;
                        v487.i32[3] = HIWORD(*(void *)v64);
                        v485.i64[1] = v485.i64[0];
                        int32x4_t v488 = vmulq_s32(v487, vrev64q_s32(v485));
                        v487.i32[0] = (unsigned __int16)*(void *)v64;
                        uint64_t v50 = v654;
                        v487.i32[1] = HIWORD(v483);
                        v487.i32[2] = (unsigned __int16)WORD2(*(void *)v64);
                        v487.i32[3] = bswap32(v478->u16[3]) >> 16;
                        int8x16_t v489 = (int8x16_t)vmlaq_s32(v488, v487, v486);
                        *uint64_t v478 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v489, 0x10uLL), (int32x4_t)vmvnq_s8(v489)));
                      }
                    }
                  }
                  else
                  {
                    uint64_t v478 = v34;
                  }
                  int v490 = *v475++;
                  int v123 = v490;
                  v64 += 16;
                  ++v45;
                  long long v34 = v478 + 1;
                  --v476;
                }
                while (v476);
                v45 += v642;
                goto LABEL_620;
              }
              uint64_t v597 = *(int8x8_t **)(v639 + 40);
              uint64_t v598 = v65 + 1;
              int v599 = v40;
              int v138 = v651;
              do
              {
                uint64_t v478 = v638;
                if (v638 >= v34) {
                  uint64_t v478 = v34;
                }
                if (v478 < v597) {
                  uint64_t v478 = v597;
                }
                if (v123)
                {
                  if (v123 == 255)
                  {
                    uint64_t v600 = HIDWORD(*(void *)v64);
                    uint64_t v601 = HIWORD(*(void *)v64);
                    unsigned int v602 = bswap32(*(void *)v64);
                    v478->i16[0] = HIWORD(v602);
                    v478->i16[1] = v602;
                    v478->i16[2] = bswap32(v600) >> 16;
                    v478->i16[3] = __rev16(v601);
                  }
                  else
                  {
                    unsigned int v603 = bswap32(v478->u16[1] | (v478->u16[0] << 16));
                    v63.i8[0] = v123;
                    v63.i8[1] = v123;
                    v63.i32[1] = ~v63.i32[0];
                    uint64_t v50 = v654;
                    *(int8x8_t *)v604.i8 = vand_s8(*(int8x8_t *)v63.i8, (int8x8_t)0xFFFF0000FFFFLL);
                    v605.i64[0] = v604.i64[0];
                    v605.i64[1] = v604.i64[0];
                    v606.i32[0] = (unsigned __int16)v603;
                    v606.i32[1] = WORD1(*(void *)v64);
                    v606.i32[2] = bswap32(v478->u16[2]) >> 16;
                    v606.i32[3] = HIWORD(*(void *)v64);
                    v604.i64[1] = v604.i64[0];
                    int32x4_t v607 = vmulq_s32(v606, vrev64q_s32(v604));
                    v606.i32[0] = (unsigned __int16)*(void *)v64;
                    v606.i32[1] = HIWORD(v603);
                    v606.i32[2] = (unsigned __int16)WORD2(*(void *)v64);
                    v606.i32[3] = bswap32(v478->u16[3]) >> 16;
                    int8x16_t v63 = (int8x16_t)vmlaq_s32(v607, v606, v605);
                    *uint64_t v478 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v63, 0x10uLL), (int32x4_t)vmvnq_s8(v63)));
                  }
                }
                int v608 = *v598++;
                int v123 = v608;
                v64 += 16;
                long long v34 = v478 + 1;
                --v599;
              }
              while (v599);
              goto LABEL_619;
            case 2:
              int v134 = *v65;
              uint64_t v50 = v654;
              if (v654)
              {
                if (v45)
                {
                  uint64_t v135 = 0;
                  uint64_t v136 = (uint64_t)(v30 - 1);
                  int v137 = v34 - 1;
                  int v138 = v651;
                  while (1)
                  {
                    if (!v134) {
                      goto LABEL_157;
                    }
                    unsigned int v139 = v45[v135] * v134 + ((v45[v135] * v134) >> 8) + 1;
                    if (!BYTE1(v139)) {
                      goto LABEL_157;
                    }
                    if (BYTE1(v139) == 255)
                    {
                      int v140 = *(unsigned __int16 *)(v64 + 8);
                      if (*(_WORD *)(v64 + 8))
                      {
                        if (v140 == 0xFFFF)
                        {
                          uint64_t v141 = HIDWORD(*(void *)v64);
                          uint64_t v142 = HIWORD(*(void *)v64);
                          unsigned int v143 = bswap32(*(void *)v64);
                          v137[1].i16[0] = HIWORD(v143);
                          v137[1].i16[1] = v143;
                          v137[1].i16[2] = bswap32(v141) >> 16;
                          v137[1].i16[3] = __rev16(v142);
                          LOWORD(v143) = -1;
                        }
                        else
                        {
                          unsigned int v157 = bswap32(v137[1].u16[1] | (v137[1].u16[0] << 16));
                          v158.i32[0] = (unsigned __int16)v157;
                          v158.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v157), 0x10uLL).i32[1];
                          unsigned int v159 = (unsigned __int16)~(_WORD)v140 * (bswap32(v30[v135]) >> 16);
                          v158.i32[2] = bswap32(v137[1].u16[2]) >> 16;
                          v158.i32[3] = bswap32(v137[1].u16[3]) >> 16;
                          uint64_t v50 = v654;
                          uint32x4_t v160 = (uint32x4_t)vmulq_s32(v158, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v140)));
                          v161.i64[0] = 0x100000001;
                          v161.i64[1] = 0x100000001;
                          uint32x4_t v162 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v160, v160, 0x10uLL), v161);
                          v161.i32[0] = *(void *)v64;
                          v161.i32[1] = v161.u16[1];
                          v137[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v161.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v64), (uint64x2_t)xmmword_1850CDC40)), v162, 0x10uLL)));
                          unsigned int v156 = v140 + ((v159 + HIWORD(v159) + 1) >> 16);
LABEL_155:
                          unsigned int v143 = bswap32(v156) >> 16;
                        }
                        v30[v135] = v143;
                      }
                    }
                    else
                    {
                      int v144 = *(unsigned __int16 *)(v64 + 8);
                      int v145 = (257 * (v139 >> 8)) ^ 0xFFFF;
                      int v146 = v144 - ((v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16);
                      if (v144 != (v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16)
                      {
                        unsigned int v147 = (unsigned __int16)WORD2(*(void *)v64) * v145;
                        unint64_t v148 = ((HIWORD(*(void *)v64)
                               - ((v145 * HIWORD(*(void *)v64)
                                 + ((v145 * HIWORD(*(void *)v64)) >> 16)
                                 + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v64)
                                                                                           - ((v147 + HIWORD(v147) + 1) >> 16)) << 32) | ((WORD1(*(void *)v64) - ((WORD1(*(void *)v64) * v145 + ((WORD1(*(void *)v64) * v145) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v64 - (((unsigned __int16)*(void *)v64 * v145 + (((unsigned __int16)*(void *)v64 * v145) >> 16) + 1) >> 16));
                        unsigned int v149 = bswap32(v137[1].u16[1] | (v137[1].u16[0] << 16));
                        unsigned int v150 = bswap32(v30[v135]);
                        v151.i32[0] = (unsigned __int16)v149;
                        v151.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v149), 0x10uLL).i32[1];
                        unsigned int v152 = (unsigned __int16)~(_WORD)v146 * HIWORD(v150)
                             + (((unsigned __int16)~(_WORD)v146 * HIWORD(v150)) >> 16)
                             + 1;
                        v151.i64[1] = __PAIR64__(bswap32(v137[1].u16[3]) >> 16, bswap32(v137[1].u16[2]) >> 16);
                        uint32x4_t v153 = (uint32x4_t)vmulq_s32(v151, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v146)));
                        v154.i64[0] = 0x100000001;
                        v154.i64[1] = 0x100000001;
                        uint32x4_t v155 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v153, v153, 0x10uLL), v154);
                        v154.i32[0] = v148;
                        v154.i32[1] = WORD1(v148);
                        uint64_t v50 = v654;
                        v137[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v154.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v148), (uint64x2_t)xmmword_1850CDC40)), v155, 0x10uLL)));
                        unsigned int v156 = v146 + HIWORD(v152);
                        goto LABEL_155;
                      }
                    }
LABEL_157:
                    int v134 = v65[v135 + 1];
                    v64 += 16;
                    ++v135;
                    v136 += 2;
                    ++v137;
                    if (v40 == v135)
                    {
                      v45 += v135 + v642;
LABEL_596:
                      long long v34 = &v137[v644 + 1];
                      long long v30 = (unsigned __int16 *)(v136 + 2 * v645 + 2);
                      goto LABEL_621;
                    }
                  }
                }
                unint64_t v567 = 0;
                uint64_t v568 = 0;
                unsigned int v569 = v65 + 1;
                int v570 = v40;
                int v138 = v651;
                while (1)
                {
                  if (v134)
                  {
                    if (v134 == 255)
                    {
                      int v571 = *(unsigned __int16 *)(v64 + 2 * v567 + 8);
                      if (*(_WORD *)(v64 + 2 * v567 + 8))
                      {
                        if (v571 == 0xFFFF)
                        {
                          unint64_t v572 = *(void *)(v64 + 4 * v568);
                          unint64_t v573 = HIDWORD(v572);
                          unint64_t v574 = HIWORD(v572);
                          unsigned int v576 = bswap32(v572);
                          unint64_t v575 = &v34[v567 / 8];
                          v575->i16[0] = HIWORD(v576);
                          v575->i16[1] = v576;
                          v575->i16[2] = bswap32(v573) >> 16;
                          v575->i16[3] = __rev16(v574);
                          LOWORD(v576) = -1;
                        }
                        else
                        {
                          unint64_t v589 = *(void *)(v64 + 4 * v568);
                          unsigned int v590 = bswap32(v34[v567 / 8].u16[1] | (v34[v567 / 8].u16[0] << 16));
                          v591.i32[0] = (unsigned __int16)v590;
                          v591.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v590), 0x10uLL).i32[1];
                          unsigned int v592 = (unsigned __int16)~(_WORD)v571 * (bswap32(v30[v568]) >> 16);
                          v591.i32[2] = bswap32(v34[v567 / 8].u16[2]) >> 16;
                          uint64_t v50 = v654;
                          v591.i32[3] = bswap32(v34[v567 / 8].u16[3]) >> 16;
                          uint32x4_t v593 = (uint32x4_t)vmulq_s32(v591, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v571)));
                          v594.i64[0] = 0x100000001;
                          v594.i64[1] = 0x100000001;
                          uint32x4_t v595 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v593, v593, 0x10uLL), v594);
                          v594.i32[0] = v589;
                          v594.i32[1] = WORD1(v589);
                          v34[v567 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v594.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v589), (uint64x2_t)xmmword_1850CDC40)), v595, 0x10uLL)));
                          unsigned int v588 = v571 + ((v592 + HIWORD(v592) + 1) >> 16);
LABEL_592:
                          unsigned int v576 = bswap32(v588) >> 16;
                        }
                        v30[v568] = v576;
                      }
                    }
                    else
                    {
                      int v577 = *(unsigned __int16 *)(v64 + 2 * v567 + 8);
                      int v578 = (257 * v134) ^ 0xFFFF;
                      int v579 = v577 - ((v578 * v577 + ((v578 * v577) >> 16) + 1) >> 16);
                      if (v577 != (v578 * v577 + ((v578 * v577) >> 16) + 1) >> 16)
                      {
                        unint64_t v580 = *(void *)(v64 + 4 * v568);
                        unint64_t v581 = ((HIWORD(v580)
                               - ((v578 * HIWORD(v580) + ((v578 * HIWORD(v580)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v580) - ((WORD2(v580) * v578 + ((WORD2(v580) * v578) >> 16) + 1) >> 16)) << 32) | ((WORD1(v580) - ((WORD1(v580) * v578 + ((WORD1(v580) * v578) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v580 - (((unsigned __int16)v580 * v578 + (((unsigned __int16)v580 * v578) >> 16) + 1) >> 16));
                        unsigned int v582 = bswap32(v34[v567 / 8].u16[1] | (v34[v567 / 8].u16[0] << 16));
                        v583.i32[0] = (unsigned __int16)v582;
                        v583.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v582), 0x10uLL).i32[1];
                        unsigned int v584 = (unsigned __int16)~(_WORD)v579 * (bswap32(v30[v568]) >> 16);
                        v583.i32[2] = bswap32(v34[v567 / 8].u16[2]) >> 16;
                        v583.i32[3] = bswap32(v34[v567 / 8].u16[3]) >> 16;
                        uint64_t v50 = v654;
                        uint32x4_t v585 = (uint32x4_t)vmulq_s32(v583, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v579)));
                        v586.i64[0] = 0x100000001;
                        v586.i64[1] = 0x100000001;
                        uint32x4_t v587 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v585, v585, 0x10uLL), v586);
                        v586.i32[0] = v581;
                        v586.i32[1] = WORD1(v581);
                        v34[v567 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v586.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v581), (uint64x2_t)xmmword_1850CDC40)), v587, 0x10uLL)));
                        unsigned int v588 = v579 + ((v584 + HIWORD(v584) + 1) >> 16);
                        goto LABEL_592;
                      }
                    }
                  }
                  int v596 = *v569++;
                  int v134 = v596;
                  ++v568;
                  v567 += 8;
                  if (!--v570)
                  {
                    uint64_t v45 = 0;
                    uint64_t v136 = (uint64_t)&v30[v568 - 1];
                    int v137 = &v34[v567 / 8 - 1];
                    goto LABEL_596;
                  }
                }
              }
              if (!v45)
              {
                int32x2_t v609 = v65 + 1;
                uint64_t v478 = v34 - 1;
                int v610 = v40;
                int v138 = v651;
                while (1)
                {
                  if (v134)
                  {
                    if (v134 == 255)
                    {
                      int v611 = *(unsigned __int16 *)(v64 + 8);
                      if (*(_WORD *)(v64 + 8))
                      {
                        if (v611 != 0xFFFF)
                        {
                          unsigned int v627 = bswap32(v478[1].u16[1] | (v478[1].u16[0] << 16));
                          v628.i32[0] = (unsigned __int16)v627;
                          v628.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v627), 0x10uLL).i32[1];
                          v628.i64[1] = __PAIR64__(bswap32(v478[1].u16[3]) >> 16, bswap32(v478[1].u16[2]) >> 16);
                          int64x2_t v622 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v64), (uint64x2_t)xmmword_1850CDC40);
                          uint32x4_t v629 = (uint32x4_t)vmulq_s32(v628, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v611)));
                          int32x4_t v624 = (int32x4_t)vsraq_n_u32(v629, v629, 0x10uLL);
                          v625.i64[0] = 0x100000001;
                          v625.i64[1] = 0x100000001;
                          v626.i32[0] = *(void *)v64;
                          v626.i32[1] = v626.u16[1];
                          goto LABEL_617;
                        }
                        uint64_t v612 = HIDWORD(*(void *)v64);
                        uint64_t v613 = HIWORD(*(void *)v64);
                        unsigned int v614 = bswap32(*(void *)v64);
                        v478[1].i16[0] = HIWORD(v614);
                        v478[1].i16[1] = v614;
                        v478[1].i16[2] = bswap32(v612) >> 16;
                        v478[1].i16[3] = __rev16(v613);
                      }
                    }
                    else
                    {
                      int v615 = *(unsigned __int16 *)(v64 + 8);
                      int v616 = (257 * v134) ^ 0xFFFF;
                      unsigned int v617 = v616 * v615 + ((v616 * v615) >> 16) + 1;
                      if (v615 != HIWORD(v617))
                      {
                        unsigned int v618 = (unsigned __int16)WORD2(*(void *)v64) * v616;
                        unint64_t v619 = ((HIWORD(*(void *)v64)
                               - ((v616 * HIWORD(*(void *)v64)
                                 + ((v616 * HIWORD(*(void *)v64)) >> 16)
                                 + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v64)
                                                                                           - ((v618 + HIWORD(v618) + 1) >> 16)) << 32) | ((WORD1(*(void *)v64) - ((WORD1(*(void *)v64) * v616 + ((WORD1(*(void *)v64) * v616) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v64 - (((unsigned __int16)*(void *)v64 * v616 + (((unsigned __int16)*(void *)v64 * v616) >> 16) + 1) >> 16));
                        uint64_t v50 = v654;
                        unsigned int v620 = bswap32(v478[1].u16[1] | (v478[1].u16[0] << 16));
                        v621.i32[0] = (unsigned __int16)v620;
                        v621.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v620), 0x10uLL).i32[1];
                        v621.i64[1] = __PAIR64__(bswap32(v478[1].u16[3]) >> 16, bswap32(v478[1].u16[2]) >> 16);
                        int64x2_t v622 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v619), (uint64x2_t)xmmword_1850CDC40);
                        uint32x4_t v623 = (uint32x4_t)vmulq_s32(v621, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v615 + HIWORD(v617))));
                        int32x4_t v624 = (int32x4_t)vsraq_n_u32(v623, v623, 0x10uLL);
                        v625.i64[0] = 0x100000001;
                        v625.i64[1] = 0x100000001;
                        v626.i32[0] = v619;
                        v626.i32[1] = WORD1(v619);
LABEL_617:
                        v478[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v626, v622), (uint32x4_t)vaddq_s32(v624, v625), 0x10uLL)));
                      }
                    }
                  }
                  int v630 = *v609++;
                  int v134 = v630;
                  v64 += 16;
                  ++v478;
                  if (!--v610)
                  {
LABEL_619:
                    uint64_t v45 = 0;
                    goto LABEL_620;
                  }
                }
              }
              uint64_t v491 = 0;
              uint64_t v478 = v34 - 1;
              int v138 = v651;
              do
              {
                if (v134)
                {
                  unsigned int v492 = v45[v491] * v134 + ((v45[v491] * v134) >> 8) + 1;
                  if (BYTE1(v492))
                  {
                    if (BYTE1(v492) == 255)
                    {
                      int v493 = *(unsigned __int16 *)(v64 + 8);
                      if (!*(_WORD *)(v64 + 8)) {
                        goto LABEL_532;
                      }
                      if (v493 == 0xFFFF)
                      {
                        uint64_t v494 = HIDWORD(*(void *)v64);
                        uint64_t v495 = HIWORD(*(void *)v64);
                        unsigned int v496 = bswap32(*(void *)v64);
                        v478[1].i16[0] = HIWORD(v496);
                        v478[1].i16[1] = v496;
                        v478[1].i16[2] = bswap32(v494) >> 16;
                        v478[1].i16[3] = __rev16(v495);
                        goto LABEL_532;
                      }
                      unsigned int v510 = bswap32(v478[1].u16[1] | (v478[1].u16[0] << 16));
                      v511.i32[0] = (unsigned __int16)v510;
                      v511.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v510), 0x10uLL).i32[1];
                      v511.i64[1] = __PAIR64__(bswap32(v478[1].u16[3]) >> 16, bswap32(v478[1].u16[2]) >> 16);
                      int64x2_t v505 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v64), (uint64x2_t)xmmword_1850CDC40);
                      uint32x4_t v512 = (uint32x4_t)vmulq_s32(v511, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v493)));
                      int32x4_t v507 = (int32x4_t)vsraq_n_u32(v512, v512, 0x10uLL);
                      v508.i64[0] = 0x100000001;
                      v508.i64[1] = 0x100000001;
                      v509.i32[0] = *(void *)v64;
                      v509.i32[1] = v509.u16[1];
                    }
                    else
                    {
                      unsigned int v497 = v492 >> 8;
                      int v498 = *(unsigned __int16 *)(v64 + 8);
                      int v499 = (257 * v497) ^ 0xFFFF;
                      unsigned int v500 = v499 * v498 + ((v499 * v498) >> 16) + 1;
                      if (v498 == HIWORD(v500)) {
                        goto LABEL_532;
                      }
                      unsigned int v501 = (unsigned __int16)WORD2(*(void *)v64) * v499;
                      unint64_t v502 = ((HIWORD(*(void *)v64)
                             - ((v499 * HIWORD(*(void *)v64)
                               + ((v499 * HIWORD(*(void *)v64)) >> 16)
                               + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v64)
                                                                                         - ((v501 + HIWORD(v501) + 1) >> 16)) << 32) | ((WORD1(*(void *)v64) - ((WORD1(*(void *)v64) * v499 + ((WORD1(*(void *)v64) * v499) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v64 - (((unsigned __int16)*(void *)v64 * v499 + (((unsigned __int16)*(void *)v64 * v499) >> 16) + 1) >> 16));
                      uint64_t v50 = v654;
                      unsigned int v503 = bswap32(v478[1].u16[1] | (v478[1].u16[0] << 16));
                      v504.i32[0] = (unsigned __int16)v503;
                      v504.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v503), 0x10uLL).i32[1];
                      v504.i64[1] = __PAIR64__(bswap32(v478[1].u16[3]) >> 16, bswap32(v478[1].u16[2]) >> 16);
                      int64x2_t v505 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v502), (uint64x2_t)xmmword_1850CDC40);
                      uint32x4_t v506 = (uint32x4_t)vmulq_s32(v504, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v498 + HIWORD(v500))));
                      int32x4_t v507 = (int32x4_t)vsraq_n_u32(v506, v506, 0x10uLL);
                      v508.i64[0] = 0x100000001;
                      v508.i64[1] = 0x100000001;
                      v509.i32[0] = v502;
                      v509.i32[1] = WORD1(v502);
                    }
                    v478[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v509, v505), (uint32x4_t)vaddq_s32(v507, v508), 0x10uLL)));
                  }
                }
LABEL_532:
                int v134 = v65[v491 + 1];
                v64 += 16;
                ++v491;
                ++v478;
              }
              while (v40 != v491);
              v45 += v491 + v642;
LABEL_620:
              long long v34 = &v478[v644 + 1];
              v30 += v645;
LABEL_621:
              uint64_t v167 = v652;
LABEL_565:
              int v550 = v138 - 1;
              if (!v550)
              {
                int8x16_t v42 = v648;
LABEL_623:
                if (v42) {
                  free(v42);
                }
                goto LABEL_625;
              }
              int v61 = 0;
              ++v650;
              int v651 = v550;
              v41 += v39[16];
              uint64_t v51 = v39[17] + v167;
              int8x16_t v42 = v648;
              if (!v648) {
                continue;
              }
              uint64_t v649 = v41;
              uint64_t v49 = v640;
              int v43 = v650;
LABEL_22:
              uint64_t v52 = v45 - 16;
              uint64_t v53 = v645 + v49;
              while (1)
              {
                while (1)
                {
                  int v54 = *(_DWORD *)v52;
                  int v55 = *(_DWORD *)v52 - v43;
                  if (*(_DWORD *)v52 <= v43) {
                    break;
                  }
                  v651 -= v55;
                  if (v651 < 1) {
                    goto LABEL_623;
                  }
                  uint64_t v58 = v39[17];
                  v649 += v39[16] * v55;
                  v51 += v58 * v55;
                  v34 += v632 * v55;
                  uint64_t v59 = v53 * v55;
                  if (!v50) {
                    uint64_t v59 = 0;
                  }
                  v30 += v59;
                  int v43 = v54;
                }
                if (v43 < *((_DWORD *)v45 - 3) + v54) {
                  break;
                }
                uint64_t v56 = v45;
                int v57 = shape_enum_clip_scan((uint64_t)v42, v52);
                uint64_t v45 = v56;
                uint64_t v50 = v654;
                if (!v57) {
                  goto LABEL_623;
                }
              }
              uint64_t v31 = v640;
              uint64_t v41 = v649;
              uint64_t v32 = v634;
              uint64_t v33 = v633;
              int v38 = v641;
              goto LABEL_32;
            case 3:
              uint64_t v649 = v41;
              uint64_t v163 = v45 != 0;
              unsigned int v164 = (unsigned __int16 *)(v64 + 8);
              int v165 = v40;
              unint64_t v166 = v45;
              uint64_t v167 = v652;
              do
              {
                int v168 = *v65;
                if (*v65)
                {
                  if (v45) {
                    int v168 = ((unsigned __int16)(*v166 * (_WORD)v168
                  }
                                                              + ((*v166 * v168) >> 8)
                                                              + 1) >> 8);
                  if (v168)
                  {
                    if (v168 == 255)
                    {
                      CMYK64_DAM(v34, v30, *((void *)v164 - 1), *v164, bswap32(*v30) >> 16);
                    }
                    else
                    {
                      int v169 = v168 | (v168 << 8);
                      unsigned int v170 = bswap32(*v30) >> 16;
                      CMYK64_DAMplusDAM(v34, v30, *((void *)v164 - 1), *v164, (v170 * v169 + ((v170 * v169) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v170, v169 ^ 0xFFFF);
                    }
                    uint64_t v69 = v653;
                    uint64_t v45 = v655;
                  }
                }
                ++v65;
                v166 += v163;
                ++v34;
                v164 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v165;
              }
              while (v165);
              goto LABEL_235;
            case 4:
              uint64_t v649 = v41;
              uint64_t v171 = v45 != 0;
              unsigned int v172 = (unsigned __int16 *)(v64 + 8);
              int v173 = v40;
              unint64_t v166 = v45;
              uint64_t v167 = v652;
              do
              {
                int v174 = *v65;
                if (*v65)
                {
                  if (v45) {
                    int v174 = ((unsigned __int16)(*v166 * (_WORD)v174
                  }
                                                              + ((*v166 * v174) >> 8)
                                                              + 1) >> 8);
                  if (v174)
                  {
                    if (v174 == 255)
                    {
                      CMYK64_DAM(v34, v30, *((void *)v172 - 1), *v172, bswap32(~*v30) >> 16);
                    }
                    else
                    {
                      int v175 = v174 | (v174 << 8);
                      unsigned int v176 = bswap32(*v30) >> 16;
                      CMYK64_DAMplusDAM(v34, v30, *((void *)v172 - 1), *v172, ((v176 ^ 0xFFFF) * v175 + (((v176 ^ 0xFFFF) * v175) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v176, v175 ^ 0xFFFF);
                    }
                    uint64_t v69 = v653;
                    uint64_t v45 = v655;
                  }
                }
                ++v65;
                v166 += v171;
                ++v34;
                v172 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v173;
              }
              while (v173);
              goto LABEL_235;
            case 5:
              uint64_t v649 = v41;
              uint64_t v177 = v45 != 0;
              uint64_t v178 = (unsigned __int16 *)(v64 + 8);
              int v179 = v40;
              unint64_t v166 = v45;
              uint64_t v167 = v652;
              do
              {
                int v180 = *v65;
                if (*v65)
                {
                  if (!v45
                    || (int v180 = ((unsigned __int16)(*v166 * (_WORD)v180
                                                                  + ((*v166 * v180) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unint64_t v181 = *((void *)v178 - 1);
                    int v182 = (v180 | (v180 << 8)) ^ 0xFFFF;
                    unint64_t v183 = ((HIWORD(v181)
                           - ((v182 * HIWORD(v181) + ((v182 * HIWORD(v181)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v181) - ((WORD2(v181) * v182 + ((WORD2(v181) * v182) >> 16) + 1) >> 16)) << 32) | ((WORD1(v181) - ((WORD1(v181) * v182 + ((WORD1(v181) * v182) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v181 - (((unsigned __int16)v181 * v182 + (((unsigned __int16)v181 * v182) >> 16) + 1) >> 16));
                    unsigned int v184 = *v178 - ((v182 * *v178 + ((v182 * *v178) >> 16) + 1) >> 16);
                    unsigned int v185 = bswap32(*v30) >> 16;
                    CMYK64_DAMplusDAM(v34, v30, v183, (unsigned __int16)v184, v185, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v185, (unsigned __int16)~(_WORD)v184);
                    uint64_t v45 = v655;
                    uint64_t v69 = v653;
                  }
                }
                ++v65;
                v166 += v177;
                ++v34;
                v178 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v179;
              }
              while (v179);
              goto LABEL_235;
            case 6:
              uint64_t v649 = v41;
              int v186 = v40;
              uint64_t v187 = 0;
              unint64_t v188 = 0;
              uint64_t v189 = v45 != 0;
              int v190 = v186;
              uint64_t v191 = v45;
              do
              {
                int v192 = *v65;
                if (*v65)
                {
                  if (!v45
                    || (int v192 = ((unsigned __int16)(*v191 * (_WORD)v192
                                                                  + ((*v191 * v192) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unsigned int v193 = bswap32(*v30);
                    if (HIWORD(v193) != 0xFFFF)
                    {
                      if ((unsigned __int16)~HIWORD(v193) == 0xFFFF)
                      {
                        CMYK64_DAM(&v34[v188 / 8], v30, *(void *)(v64 + v187), *(unsigned __int16 *)(v64 + 2 * v188 + 8), v192 | (v192 << 8));
                        uint64_t v45 = v655;
                        uint64_t v69 = v653;
                      }
                      else
                      {
                        unint64_t v194 = ((unint64_t)(bswap32(v34[v188 / 8].u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34[v188 / 8].u16[3]) >> 16) << 48) | bswap32(v34[v188 / 8].u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34[v188 / 8].u16[0]) >> 16);
                        v195.i64[0] = *(void *)(v64 + v187);
                        unsigned int v196 = (257 * v192 * (unsigned __int16)~HIWORD(v193)
                              + ((257 * v192 * (unsigned __int16)~HIWORD(v193)) >> 16)
                              + 1) >> 16;
                        uint32x2_t v197 = (uint32x2_t)vdup_lane_s32(*(int32x2_t *)v195.i8, 0);
                        v195.i16[1] = 0;
                        v195.i32[1] = vshr_n_u32(v197, 0x10uLL).i32[1];
                        unsigned int v198 = v196 * *(unsigned __int16 *)(v64 + 2 * v188 + 8);
                        v195.i64[1] = __PAIR64__(HIWORD(*(void *)(v64 + v187)), (unsigned __int16)WORD2(*(void *)(v64 + v187)));
                        uint32x4_t v199 = (uint32x4_t)vmulq_s32(v195, vdupq_n_s32(v196));
                        v200.i64[0] = 0x100000001;
                        v200.i64[1] = 0x100000001;
                        uint32x4_t v201 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v199, v199, 0x10uLL), v200);
                        v200.i32[0] = v194;
                        v200.i32[1] = WORD1(v194);
                        v34[v188 / 8] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v200.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v194), (uint64x2_t)xmmword_1850CDC40)), v201, 0x10uLL)));
                        *long long v30 = bswap32(HIWORD(v193) + ((v198 + HIWORD(v198) + 1) >> 16)) >> 16;
                      }
                    }
                  }
                }
                ++v65;
                v191 += v189;
                v188 += 8;
                v187 += 16;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v190;
              }
              while (v190);
              long long v39 = v643;
              uint64_t v45 = &v191[v642];
              long long v34 = (int8x8_t *)((char *)v34 + 8 * v644 + v188);
              v30 += v645;
              int v38 = v641;
              uint64_t v40 = v647;
              uint64_t v50 = v654;
              goto LABEL_493;
            case 7:
              uint64_t v202 = v45 != 0;
              uint64_t v50 = v654;
              if (v654)
              {
                uint64_t v649 = v41;
                unint64_t v203 = (unsigned __int16 *)(v64 + 8);
                uint64_t v204 = v45;
                uint64_t v167 = v652;
                do
                {
                  int v205 = *v65;
                  if (*v65)
                  {
                    if (v45) {
                      int v205 = ((unsigned __int16)(*v204 * (_WORD)v205
                    }
                                                                + ((*v204 * v205) >> 8)
                                                                + 1) >> 8);
                    if (v205)
                    {
                      if (v205 == 255)
                      {
                        CMYK64_DAM(v34, v30, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(*v30) >> 16, *v203);
                      }
                      else
                      {
                        unint64_t v206 = ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16);
                        unsigned int v207 = bswap32(*v30) >> 16;
                        CMYK64_DAMplusDAM(v34, v30, v206, v207, (*v203 * (v205 | (v205 << 8)) + ((*v203 * (v205 | (v205 << 8))) >> 16) + 1) >> 16, v206, v207, (v205 | (v205 << 8)) ^ 0xFFFF);
                      }
                      uint64_t v50 = v654;
                      uint64_t v45 = v655;
                    }
                  }
                  ++v65;
                  v204 += v202;
                  ++v34;
                  ++v30;
                  v203 += 8;
                  LODWORD(v40) = v40 - 1;
                }
                while (v40);
                goto LABEL_562;
              }
              uint64_t v513 = (unsigned __int16 *)(v64 + 8);
              int v514 = v40;
              int v515 = v45;
              uint64_t v167 = v652;
              do
              {
                int v516 = *v65;
                if (*v65)
                {
                  if (v45) {
                    int v516 = ((unsigned __int16)(*v515 * (_WORD)v516
                  }
                                                              + ((*v515 * v516) >> 8)
                                                              + 1) >> 8);
                  if (v516)
                  {
                    if (v516 == 255)
                    {
                      unsigned int v517 = bswap32(v34->u16[1] | (v34->u16[0] << 16));
                      v518.i32[0] = (unsigned __int16)v517;
                      v518.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v517), 0x10uLL).i32[1];
                      v518.i64[1] = __PAIR64__(bswap32(v34->u16[3]) >> 16, bswap32(v34->u16[2]) >> 16);
                      uint32x4_t v519 = (uint32x4_t)vmulq_s32(v518, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*v513)));
                      v520.i64[0] = 0x100000001;
                      v520.i64[1] = 0x100000001;
                      v518.i32[0] = v517;
                      int32x4_t v521 = vsubq_s32(v518, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v519, v519, 0x10uLL), v520), 0x10uLL));
                    }
                    else
                    {
                      int v522 = v516 | (v516 << 8);
                      unsigned int v523 = bswap32(v34->u16[1] | (v34->u16[0] << 16));
                      v524.i32[0] = (unsigned __int16)v523;
                      v524.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v523), 0x10uLL).i32[1];
                      v525.i32[0] = (*v513 * v522 + ((*v513 * v522) >> 16) + 1) >> 16;
                      v525.i32[1] = ~v522;
                      *(int8x8_t *)v526.i8 = vand_s8(v525, (int8x8_t)0xFFFF0000FFFFLL);
                      v527.i64[0] = v526.i64[0];
                      v527.i64[1] = v526.i64[0];
                      v524.i32[2] = bswap32(v34->u16[2]) >> 16;
                      v524.i32[3] = bswap32(v34->u16[3]) >> 16;
                      v526.i64[1] = v526.i64[0];
                      int8x16_t v528 = (int8x16_t)vmulq_s32(v524, vaddq_s32(v527, vrev64q_s32(v526)));
                      int32x4_t v521 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v528, 0x10uLL), (int32x4_t)vmvnq_s8(v528)), 0x10uLL);
                    }
                    *long long v34 = vrev16_s8((int8x8_t)vmovn_s32(v521));
                  }
                }
                ++v65;
                v515 += v202;
                ++v34;
                v513 += 8;
                --v514;
              }
              while (v514);
              goto LABEL_555;
            case 8:
              uint64_t v208 = v45 != 0;
              uint64_t v50 = v654;
              if (v654)
              {
                uint64_t v649 = v41;
                unint64_t v209 = (unsigned __int16 *)(v64 + 8);
                uint64_t v204 = v45;
                uint64_t v167 = v652;
                do
                {
                  int v210 = *v65;
                  if (*v65)
                  {
                    if (v45) {
                      int v210 = ((unsigned __int16)(*v204 * (_WORD)v210
                    }
                                                                + ((*v204 * v210) >> 8)
                                                                + 1) >> 8);
                    if (v210)
                    {
                      if (v210 == 255)
                      {
                        CMYK64_DAM(v34, v30, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(*v30) >> 16, *v209 ^ 0xFFFF);
                      }
                      else
                      {
                        unint64_t v211 = ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16);
                        unsigned int v212 = bswap32(*v30) >> 16;
                        CMYK64_DAMplusDAM(v34, v30, v211, v212, ((*v209 ^ 0xFFFF) * (v210 | (v210 << 8))+ (((*v209 ^ 0xFFFF) * (v210 | (v210 << 8))) >> 16)+ 1) >> 16, v211, v212, (v210 | (v210 << 8)) ^ 0xFFFF);
                      }
                      uint64_t v50 = v654;
                      uint64_t v45 = v655;
                    }
                  }
                  ++v65;
                  v204 += v208;
                  ++v34;
                  ++v30;
                  v209 += 8;
                  LODWORD(v40) = v40 - 1;
                }
                while (v40);
                goto LABEL_562;
              }
              unint64_t v529 = (const __int16 *)(v64 + 8);
              int v530 = v40;
              int v515 = v45;
              uint64_t v167 = v652;
              do
              {
                int v531 = *v65;
                if (*v65)
                {
                  if (v45) {
                    int v531 = ((unsigned __int16)(*v515 * (_WORD)v531
                  }
                                                              + ((*v515 * v531) >> 8)
                                                              + 1) >> 8);
                  if (v531)
                  {
                    if (v531 == 255)
                    {
                      unsigned int v532 = bswap32(v34->u16[1] | (v34->u16[0] << 16));
                      v533.i32[0] = (unsigned __int16)v532;
                      v533.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v532), 0x10uLL).i32[1];
                      v533.i64[1] = __PAIR64__(bswap32(v34->u16[3]) >> 16, bswap32(v34->u16[2]) >> 16);
                      uint16x4_t v534 = (uint16x4_t)vld1_dup_s16(v529);
                      uint32x4_t v535 = (uint32x4_t)vmulq_s32(v533, (int32x4_t)vmovl_u16(v534));
                      v536.i64[0] = 0x100000001;
                      v536.i64[1] = 0x100000001;
                      v533.i32[0] = v532;
                      int32x4_t v537 = vsubq_s32(v533, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v535, v535, 0x10uLL), v536), 0x10uLL));
                    }
                    else
                    {
                      int v538 = v531 | (v531 << 8);
                      unsigned int v539 = bswap32(v34->u16[1] | (v34->u16[0] << 16));
                      v540.i32[0] = (unsigned __int16)v539;
                      v540.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v539), 0x10uLL).i32[1];
                      v541.i32[0] = ((*(unsigned __int16 *)v529 ^ 0xFFFF) * v538
                                   + (((*(unsigned __int16 *)v529 ^ 0xFFFFu) * v538) >> 16)
                                   + 1) >> 16;
                      v541.i32[1] = ~v538;
                      *(int8x8_t *)v542.i8 = vand_s8(v541, (int8x8_t)0xFFFF0000FFFFLL);
                      v543.i64[0] = v542.i64[0];
                      v543.i64[1] = v542.i64[0];
                      v540.i32[2] = bswap32(v34->u16[2]) >> 16;
                      v540.i32[3] = bswap32(v34->u16[3]) >> 16;
                      v542.i64[1] = v542.i64[0];
                      int8x16_t v544 = (int8x16_t)vmulq_s32(v540, vaddq_s32(v543, vrev64q_s32(v542)));
                      int32x4_t v537 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v544, 0x10uLL), (int32x4_t)vmvnq_s8(v544)), 0x10uLL);
                    }
                    *long long v34 = vrev16_s8((int8x8_t)vmovn_s32(v537));
                  }
                }
                ++v65;
                v515 += v208;
                ++v34;
                v529 += 8;
                --v530;
              }
              while (v530);
LABEL_555:
              long long v39 = v643;
              uint64_t v45 = &v515[v642];
              v34 += v644;
              v30 += v645;
              goto LABEL_564;
            case 9:
              uint64_t v649 = v41;
              uint64_t v213 = v45 != 0;
              int v214 = (unsigned __int16 *)(v64 + 8);
              int v215 = v40;
              unint64_t v166 = v45;
              uint64_t v167 = v652;
              do
              {
                int v216 = *v65;
                if (*v65)
                {
                  if (!v45
                    || (int v216 = ((unsigned __int16)(*v166 * (_WORD)v216
                                                                  + ((*v166 * v216) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unsigned int v217 = bswap32(*v30) >> 16;
                    unint64_t v218 = *((void *)v214 - 1);
                    unsigned __int16 v219 = ~(v216 | ((_WORD)v216 << 8));
                    int v220 = v219;
                    unint64_t v221 = ((HIWORD(v218)
                           - ((HIWORD(v218) * v220 + ((HIWORD(v218) * v220) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v218) - ((WORD2(v218) * v220 + ((WORD2(v218) * v220) >> 16) + 1) >> 16)) << 32) | ((WORD1(v218) - ((WORD1(v218) * v220 + ((WORD1(v218) * v220) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v218 - (((unsigned __int16)v218 * v219 + (((unsigned __int16)v218 * v219) >> 16) + 1) >> 16));
                    unsigned int v222 = *v214 - ((*v214 * v220 + ((*v214 * v220) >> 16) + 1) >> 16);
                    CMYK64_DAMplusDAM(v34, v30, v221, (unsigned __int16)v222, v217 ^ 0xFFFF, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v217, (unsigned __int16)(v222 + v219));
                    uint64_t v45 = v655;
                    uint64_t v69 = v653;
                  }
                }
                ++v65;
                v166 += v213;
                ++v34;
                v214 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v215;
              }
              while (v215);
              goto LABEL_235;
            case 10:
              uint64_t v649 = v41;
              uint64_t v223 = v45 != 0;
              int v224 = (unsigned __int16 *)(v64 + 8);
              int v225 = v40;
              unint64_t v166 = v45;
              uint64_t v167 = v652;
              do
              {
                int v226 = *v65;
                if (*v65)
                {
                  if (!v45
                    || (int v226 = ((unsigned __int16)(*v166 * (_WORD)v226
                                                                  + ((*v166 * v226) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unsigned int v227 = bswap32(*v30) >> 16;
                    unint64_t v228 = *((void *)v224 - 1);
                    int v229 = (v226 | (v226 << 8)) ^ 0xFFFF;
                    unint64_t v230 = ((HIWORD(v228)
                           - ((v229 * HIWORD(v228) + ((v229 * HIWORD(v228)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v228) - ((WORD2(v228) * v229 + ((WORD2(v228) * v229) >> 16) + 1) >> 16)) << 32) | ((WORD1(v228) - ((WORD1(v228) * v229 + ((WORD1(v228) * v229) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v228 - (((unsigned __int16)v228 * v229 + (((unsigned __int16)v228 * v229) >> 16) + 1) >> 16));
                    unsigned int v231 = *v224 - ((v229 * *v224 + ((v229 * *v224) >> 16) + 1) >> 16);
                    CMYK64_DAMplusDAM(v34, v30, v230, (unsigned __int16)v231, v227 ^ 0xFFFF, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v227, (unsigned __int16)~(_WORD)v231);
                    uint64_t v45 = v655;
                    uint64_t v69 = v653;
                  }
                }
                ++v65;
                v166 += v223;
                ++v34;
                v224 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                --v225;
              }
              while (v225);
LABEL_235:
              uint64_t v45 = &v166[v642];
              v34 += v644;
              v30 += v645;
              int v38 = v641;
              uint64_t v40 = v647;
              uint64_t v50 = v654;
              goto LABEL_563;
            case 11:
              uint64_t v649 = v41;
              uint64_t v232 = v45 != 0;
              uint64_t v50 = v654;
              if (v654)
              {
                unint64_t v233 = (_WORD *)(v64 + 8);
                uint64_t v204 = v45;
                uint64_t v167 = v652;
                do
                {
                  int v234 = *v65;
                  if (*v65)
                  {
                    if (!v45
                      || (int v234 = ((unsigned __int16)(*v204 * (_WORD)v234
                                                                    + ((*v204 * v234) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unint64_t v235 = *((void *)v233 - 1);
                      int v236 = (v234 | (v234 << 8)) ^ 0xFFFF;
                      unsigned int v237 = (unsigned __int16)v235 * v236;
                      CMYK64_DAplusdDA((int *)v34, v30, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(*v30) >> 16, ((HIWORD(v235) - ((v236 * HIWORD(v235) + ((v236 * HIWORD(v235)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v235) - ((WORD2(v235) * v236 + ((WORD2(v235) * v236) >> 16) + 1) >> 16)) << 32) | ((WORD1(v235) - ((WORD1(v235) * v236 + ((WORD1(v235) * v236) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v235 - ((v237 + HIWORD(v237) + 1) >> 16)), (unsigned __int16)(*v233- ((v236 * (unsigned __int16)*v233+ ((v236 * (unsigned __int16)*v233) >> 16)+ 1) >> 16)));
                      uint64_t v50 = v654;
                      uint64_t v45 = v655;
                    }
                  }
                  ++v65;
                  v204 += v232;
                  ++v34;
                  ++v30;
                  v233 += 8;
                  LODWORD(v40) = v40 - 1;
                }
                while (v40);
              }
              else
              {
                uint64_t v545 = (_WORD *)(v64 + 8);
                uint64_t v204 = v45;
                uint64_t v167 = v652;
                do
                {
                  int v546 = *v65;
                  if (*v65)
                  {
                    if (!v45
                      || (int v546 = ((unsigned __int16)(*v204 * (_WORD)v546
                                                                    + ((*v204 * v546) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unint64_t v547 = *((void *)v545 - 1);
                      int v548 = (v546 | (v546 << 8)) ^ 0xFFFF;
                      unsigned int v549 = (unsigned __int16)v547 * v548;
                      CMYK64_DplusdDA(v34, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), ((HIWORD(v547) - ((v548 * HIWORD(v547) + ((v548 * HIWORD(v547)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v547) - ((WORD2(v547) * v548 + ((WORD2(v547) * v548) >> 16) + 1) >> 16)) << 32) | ((WORD1(v547) - ((WORD1(v547) * v548 + ((WORD1(v547) * v548) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v547 - ((v549 + HIWORD(v549) + 1) >> 16)), (unsigned __int16)(*v545- ((v548 * (unsigned __int16)*v545+ ((v548 * (unsigned __int16)*v545) >> 16)+ 1) >> 16)));
                      uint64_t v50 = v654;
                      uint64_t v45 = v655;
                    }
                  }
                  ++v65;
                  v204 += v232;
                  ++v34;
                  v545 += 8;
                  LODWORD(v40) = v40 - 1;
                }
                while (v40);
              }
              goto LABEL_562;
            case 12:
              uint64_t v649 = v41;
              uint64_t v238 = v45 != 0;
              uint64_t v50 = v654;
              if (!v654)
              {
                int v551 = v40;
                uint64_t v552 = v45;
                do
                {
                  int v553 = *v65;
                  if (*v65)
                  {
                    if (!v45
                      || (int v553 = ((unsigned __int16)(*v552 * (_WORD)v553
                                                                    + ((*v552 * v553) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unsigned int v554 = WORD1(*(void *)v64);
                      uint64_t v555 = HIWORD(*(void *)v64);
                      int v556 = (v553 | (v553 << 8)) ^ 0xFFFF;
                      unsigned int v557 = (unsigned __int16)WORD2(*(void *)v64) * v556;
                      CMYK64_DpluslD(v34, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), ((unint64_t)(v555- ((v556 * v555 + ((v556 * v555) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v64) - ((v557 + HIWORD(v557) + 1) >> 16)) << 32) | ((v554 - ((v554 * v556 + ((v554 * v556) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v64 - (((unsigned __int16)*(void *)v64 * v556 + (((unsigned __int16)*(void *)v64 * v556) >> 16) + 1) >> 16)));
                      uint64_t v50 = v654;
                      uint64_t v45 = v655;
                    }
                  }
                  ++v65;
                  v64 += 16;
                  v552 += v238;
                  ++v34;
                  --v551;
                }
                while (v551);
                long long v39 = v643;
                uint64_t v45 = &v552[v642];
                v34 += v644;
                v30 += v645;
                goto LABEL_493;
              }
              int v239 = (_WORD *)(v64 + 8);
              uint64_t v204 = v45;
              uint64_t v167 = v652;
              do
              {
                int v240 = *v65;
                if (*v65)
                {
                  if (!v45
                    || (int v240 = ((unsigned __int16)(*v204 * (_WORD)v240
                                                                  + ((*v204 * v240) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unint64_t v241 = *((void *)v239 - 1);
                    int v242 = (v240 | (v240 << 8)) ^ 0xFFFF;
                    unsigned int v243 = (unsigned __int16)v241 * v242;
                    CMYK64_DApluslDA((unsigned int *)v34, v30, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), bswap32(*v30) >> 16, ((HIWORD(v241) - ((v242 * HIWORD(v241) + ((v242 * HIWORD(v241)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v241) - ((WORD2(v241) * v242 + ((WORD2(v241) * v242) >> 16) + 1) >> 16)) << 32) | ((WORD1(v241) - ((WORD1(v241) * v242 + ((WORD1(v241) * v242) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v241 - ((v243 + HIWORD(v243) + 1) >> 16)), (unsigned __int16)(*v239- ((v242 * (unsigned __int16)*v239+ ((v242 * (unsigned __int16)*v239) >> 16)+ 1) >> 16)));
                    uint64_t v50 = v654;
                    uint64_t v45 = v655;
                  }
                }
                ++v65;
                v204 += v238;
                ++v34;
                ++v30;
                v239 += 8;
                LODWORD(v40) = v40 - 1;
              }
              while (v40);
LABEL_562:
              long long v39 = v643;
              uint64_t v45 = &v204[v642];
              v34 += v644;
              v30 += v645;
              uint64_t v40 = v647;
LABEL_563:
              uint64_t v41 = v649;
              goto LABEL_564;
            case 13:
              uint64_t v649 = v41;
              uint64_t v244 = v45 != 0;
              uint64_t v245 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v247 = *v65;
                if (!*v65) {
                  goto LABEL_266;
                }
                if (v45)
                {
                  int v247 = ((unsigned __int16)(*v246 * (_WORD)v247
                                                            + ((*v246 * v247) >> 8)
                                                            + 1) >> 8);
                  if (!v247) {
                    goto LABEL_266;
                  }
                }
                int v248 = *v245;
                int v249 = (v247 | (v247 << 8)) ^ 0xFFFF;
                int v250 = v248 - ((v249 * v248 + ((v249 * v248) >> 16) + 1) >> 16);
                if (v248 == (v249 * v248 + ((v249 * v248) >> 16) + 1) >> 16) {
                  goto LABEL_266;
                }
                unint64_t v251 = *((void *)v245 - 1);
                unint64_t v252 = ((HIWORD(v251) - ((v249 * HIWORD(v251) + ((v249 * HIWORD(v251)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v251) - ((WORD2(v251) * v249 + ((WORD2(v251) * v249) >> 16) + 1) >> 16)) << 32) | ((WORD1(v251) - ((WORD1(v251) * v249 + ((WORD1(v251) * v249) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v251 - (((unsigned __int16)v251 * v249 + (((unsigned __int16)v251 * v249) >> 16) + 1) >> 16));
                LODWORD(v253) = (unsigned __int16)v250;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_263;
                  }
                  unsigned int v254 = __rev16(*v30);
                }
                else
                {
                  unsigned int v254 = 0xFFFF;
                }
                int v255 = (unsigned __int16 *)v34 + 3;
                unint64_t v256 = PDAmultiplyPDA_11710(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v254, v252, (unsigned __int16)v250);
                unint64_t v252 = v256;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v253 = HIWORD(v256);
                  unsigned int v259 = bswap32(v256);
                  v34->i16[0] = HIWORD(v259);
                  v34->i16[1] = v259;
                  v34->i16[2] = bswap32(HIDWORD(v256)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_265;
                }
                LODWORD(v253) = v257;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_263:
                unsigned int v258 = bswap32(v252);
                v34->i16[0] = HIWORD(v258);
                v34->i16[1] = v258;
                v34->i16[2] = bswap32(HIDWORD(v252)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v252));
                int v255 = v30;
LABEL_265:
                *int v255 = bswap32(v253) >> 16;
LABEL_266:
                ++v65;
                v246 += v244;
                ++v34;
                v245 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 14:
              uint64_t v649 = v41;
              uint64_t v260 = v45 != 0;
              unsigned int v261 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v262 = *v65;
                if (!*v65) {
                  goto LABEL_282;
                }
                if (v45)
                {
                  int v262 = ((unsigned __int16)(*v246 * (_WORD)v262
                                                            + ((*v246 * v262) >> 8)
                                                            + 1) >> 8);
                  if (!v262) {
                    goto LABEL_282;
                  }
                }
                int v263 = *v261;
                int v264 = (v262 | (v262 << 8)) ^ 0xFFFF;
                int v265 = v263 - ((v264 * v263 + ((v264 * v263) >> 16) + 1) >> 16);
                if (v263 == (v264 * v263 + ((v264 * v263) >> 16) + 1) >> 16) {
                  goto LABEL_282;
                }
                unint64_t v266 = *((void *)v261 - 1);
                unint64_t v267 = ((HIWORD(v266) - ((v264 * HIWORD(v266) + ((v264 * HIWORD(v266)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v266) - ((WORD2(v266) * v264 + ((WORD2(v266) * v264) >> 16) + 1) >> 16)) << 32) | ((WORD1(v266) - ((WORD1(v266) * v264 + ((WORD1(v266) * v264) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v266 - (((unsigned __int16)v266 * v264 + (((unsigned __int16)v266 * v264) >> 16) + 1) >> 16));
                LODWORD(v268) = (unsigned __int16)v265;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_279;
                  }
                  unsigned int v269 = __rev16(*v30);
                }
                else
                {
                  unsigned int v269 = 0xFFFF;
                }
                int v270 = (unsigned __int16 *)v34 + 3;
                unint64_t v271 = PDAscreenPDA_11711(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v269, v267, (unsigned __int16)v265);
                unint64_t v267 = v271;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v268 = HIWORD(v271);
                  unsigned int v274 = bswap32(v271);
                  v34->i16[0] = HIWORD(v274);
                  v34->i16[1] = v274;
                  v34->i16[2] = bswap32(HIDWORD(v271)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_281;
                }
                LODWORD(v268) = v272;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_279:
                unsigned int v273 = bswap32(v267);
                v34->i16[0] = HIWORD(v273);
                v34->i16[1] = v273;
                v34->i16[2] = bswap32(HIDWORD(v267)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v267));
                int v270 = v30;
LABEL_281:
                *int v270 = bswap32(v268) >> 16;
LABEL_282:
                ++v65;
                v246 += v260;
                ++v34;
                v261 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 15:
              uint64_t v649 = v41;
              uint64_t v275 = v45 != 0;
              int v276 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v277 = *v65;
                if (!*v65) {
                  goto LABEL_298;
                }
                if (v45)
                {
                  int v277 = ((unsigned __int16)(*v246 * (_WORD)v277
                                                            + ((*v246 * v277) >> 8)
                                                            + 1) >> 8);
                  if (!v277) {
                    goto LABEL_298;
                  }
                }
                int v278 = *v276;
                int v279 = (v277 | (v277 << 8)) ^ 0xFFFF;
                int v280 = v278 - ((v279 * v278 + ((v279 * v278) >> 16) + 1) >> 16);
                if (v278 == (v279 * v278 + ((v279 * v278) >> 16) + 1) >> 16) {
                  goto LABEL_298;
                }
                unint64_t v281 = *((void *)v276 - 1);
                unint64_t v282 = ((HIWORD(v281) - ((v279 * HIWORD(v281) + ((v279 * HIWORD(v281)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v281) - ((WORD2(v281) * v279 + ((WORD2(v281) * v279) >> 16) + 1) >> 16)) << 32) | ((WORD1(v281) - ((WORD1(v281) * v279 + ((WORD1(v281) * v279) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v281 - (((unsigned __int16)v281 * v279 + (((unsigned __int16)v281 * v279) >> 16) + 1) >> 16));
                LODWORD(v283) = (unsigned __int16)v280;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_295;
                  }
                  unsigned int v284 = __rev16(*v30);
                }
                else
                {
                  unsigned int v284 = 0xFFFF;
                }
                uint64_t v285 = (unsigned __int16 *)v34 + 3;
                unint64_t v286 = PDAoverlayPDA_11712(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v284, v282, (unsigned __int16)v280);
                unint64_t v282 = v286;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v283 = HIWORD(v286);
                  unsigned int v289 = bswap32(v286);
                  v34->i16[0] = HIWORD(v289);
                  v34->i16[1] = v289;
                  v34->i16[2] = bswap32(HIDWORD(v286)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_297;
                }
                LODWORD(v283) = v287;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_295:
                unsigned int v288 = bswap32(v282);
                v34->i16[0] = HIWORD(v288);
                v34->i16[1] = v288;
                v34->i16[2] = bswap32(HIDWORD(v282)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v282));
                uint64_t v285 = v30;
LABEL_297:
                *uint64_t v285 = bswap32(v283) >> 16;
LABEL_298:
                ++v65;
                v246 += v275;
                ++v34;
                v276 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 16:
              uint64_t v649 = v41;
              uint64_t v290 = v45 != 0;
              uint64_t v291 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v292 = *v65;
                if (!*v65) {
                  goto LABEL_314;
                }
                if (v45)
                {
                  int v292 = ((unsigned __int16)(*v246 * (_WORD)v292
                                                            + ((*v246 * v292) >> 8)
                                                            + 1) >> 8);
                  if (!v292) {
                    goto LABEL_314;
                  }
                }
                int v293 = *v291;
                int v294 = (v292 | (v292 << 8)) ^ 0xFFFF;
                int v295 = v293 - ((v294 * v293 + ((v294 * v293) >> 16) + 1) >> 16);
                if (v293 == (v294 * v293 + ((v294 * v293) >> 16) + 1) >> 16) {
                  goto LABEL_314;
                }
                unint64_t v296 = *((void *)v291 - 1);
                unint64_t v297 = ((HIWORD(v296) - ((v294 * HIWORD(v296) + ((v294 * HIWORD(v296)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v296) - ((WORD2(v296) * v294 + ((WORD2(v296) * v294) >> 16) + 1) >> 16)) << 32) | ((WORD1(v296) - ((WORD1(v296) * v294 + ((WORD1(v296) * v294) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v296 - (((unsigned __int16)v296 * v294 + (((unsigned __int16)v296 * v294) >> 16) + 1) >> 16));
                LODWORD(v298) = (unsigned __int16)v295;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_311;
                  }
                  unsigned int v299 = __rev16(*v30);
                }
                else
                {
                  unsigned int v299 = 0xFFFF;
                }
                unint64_t v300 = (unsigned __int16 *)v34 + 3;
                unint64_t v301 = PDAdarkenPDA_11714(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v299, v297, (unsigned __int16)v295);
                unint64_t v297 = v301;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v298 = HIWORD(v301);
                  unsigned int v304 = bswap32(v301);
                  v34->i16[0] = HIWORD(v304);
                  v34->i16[1] = v304;
                  v34->i16[2] = bswap32(HIDWORD(v301)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_313;
                }
                LODWORD(v298) = v302;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_311:
                unsigned int v303 = bswap32(v297);
                v34->i16[0] = HIWORD(v303);
                v34->i16[1] = v303;
                v34->i16[2] = bswap32(HIDWORD(v297)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v297));
                unint64_t v300 = v30;
LABEL_313:
                *unint64_t v300 = bswap32(v298) >> 16;
LABEL_314:
                ++v65;
                v246 += v290;
                ++v34;
                v291 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 17:
              uint64_t v649 = v41;
              uint64_t v305 = v45 != 0;
              uint64_t v306 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v307 = *v65;
                if (!*v65) {
                  goto LABEL_330;
                }
                if (v45)
                {
                  int v307 = ((unsigned __int16)(*v246 * (_WORD)v307
                                                            + ((*v246 * v307) >> 8)
                                                            + 1) >> 8);
                  if (!v307) {
                    goto LABEL_330;
                  }
                }
                int v308 = *v306;
                int v309 = (v307 | (v307 << 8)) ^ 0xFFFF;
                int v310 = v308 - ((v309 * v308 + ((v309 * v308) >> 16) + 1) >> 16);
                if (v308 == (v309 * v308 + ((v309 * v308) >> 16) + 1) >> 16) {
                  goto LABEL_330;
                }
                unint64_t v311 = *((void *)v306 - 1);
                unint64_t v312 = ((HIWORD(v311) - ((v309 * HIWORD(v311) + ((v309 * HIWORD(v311)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v311) - ((WORD2(v311) * v309 + ((WORD2(v311) * v309) >> 16) + 1) >> 16)) << 32) | ((WORD1(v311) - ((WORD1(v311) * v309 + ((WORD1(v311) * v309) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v311 - (((unsigned __int16)v311 * v309 + (((unsigned __int16)v311 * v309) >> 16) + 1) >> 16));
                LODWORD(v313) = (unsigned __int16)v310;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_327;
                  }
                  unsigned int v314 = __rev16(*v30);
                }
                else
                {
                  unsigned int v314 = 0xFFFF;
                }
                unsigned int v315 = (unsigned __int16 *)v34 + 3;
                unint64_t v316 = PDAlightenPDA_11713(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v314, v312, (unsigned __int16)v310);
                unint64_t v312 = v316;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v313 = HIWORD(v316);
                  unsigned int v319 = bswap32(v316);
                  v34->i16[0] = HIWORD(v319);
                  v34->i16[1] = v319;
                  v34->i16[2] = bswap32(HIDWORD(v316)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_329;
                }
                LODWORD(v313) = v317;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_327:
                unsigned int v318 = bswap32(v312);
                v34->i16[0] = HIWORD(v318);
                v34->i16[1] = v318;
                v34->i16[2] = bswap32(HIDWORD(v312)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v312));
                unsigned int v315 = v30;
LABEL_329:
                *unsigned int v315 = bswap32(v313) >> 16;
LABEL_330:
                ++v65;
                v246 += v305;
                ++v34;
                v306 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 18:
              uint64_t v649 = v41;
              uint64_t v320 = v45 != 0;
              uint64_t v321 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v322 = *v65;
                if (!*v65) {
                  goto LABEL_346;
                }
                if (v45)
                {
                  int v322 = ((unsigned __int16)(*v246 * (_WORD)v322
                                                            + ((*v246 * v322) >> 8)
                                                            + 1) >> 8);
                  if (!v322) {
                    goto LABEL_346;
                  }
                }
                int v323 = *v321;
                int v324 = (v322 | (v322 << 8)) ^ 0xFFFF;
                int v325 = v323 - ((v324 * v323 + ((v324 * v323) >> 16) + 1) >> 16);
                if (v323 == (v324 * v323 + ((v324 * v323) >> 16) + 1) >> 16) {
                  goto LABEL_346;
                }
                unint64_t v326 = *((void *)v321 - 1);
                unint64_t v327 = ((HIWORD(v326) - ((v324 * HIWORD(v326) + ((v324 * HIWORD(v326)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v326) - ((WORD2(v326) * v324 + ((WORD2(v326) * v324) >> 16) + 1) >> 16)) << 32) | ((WORD1(v326) - ((WORD1(v326) * v324 + ((WORD1(v326) * v324) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v326 - (((unsigned __int16)v326 * v324 + (((unsigned __int16)v326 * v324) >> 16) + 1) >> 16));
                LODWORD(v328) = (unsigned __int16)v325;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_343;
                  }
                  unsigned int v329 = __rev16(*v30);
                }
                else
                {
                  unsigned int v329 = 0xFFFF;
                }
                uint64_t v330 = (unsigned __int16 *)v34 + 3;
                unint64_t v331 = PDAcolordodgePDA_11715(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v329, v327, (unsigned __int16)v325);
                unint64_t v327 = v331;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v328 = HIWORD(v331);
                  unsigned int v334 = bswap32(v331);
                  v34->i16[0] = HIWORD(v334);
                  v34->i16[1] = v334;
                  v34->i16[2] = bswap32(HIDWORD(v331)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_345;
                }
                LODWORD(v328) = v332;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_343:
                unsigned int v333 = bswap32(v327);
                v34->i16[0] = HIWORD(v333);
                v34->i16[1] = v333;
                v34->i16[2] = bswap32(HIDWORD(v327)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v327));
                uint64_t v330 = v30;
LABEL_345:
                unsigned __int16 *v330 = bswap32(v328) >> 16;
LABEL_346:
                ++v65;
                v246 += v320;
                ++v34;
                v321 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 19:
              uint64_t v649 = v41;
              uint64_t v335 = v45 != 0;
              unint64_t v336 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v337 = *v65;
                if (!*v65) {
                  goto LABEL_362;
                }
                if (v45)
                {
                  int v337 = ((unsigned __int16)(*v246 * (_WORD)v337
                                                            + ((*v246 * v337) >> 8)
                                                            + 1) >> 8);
                  if (!v337) {
                    goto LABEL_362;
                  }
                }
                int v338 = *v336;
                int v339 = (v337 | (v337 << 8)) ^ 0xFFFF;
                int v340 = v338 - ((v339 * v338 + ((v339 * v338) >> 16) + 1) >> 16);
                if (v338 == (v339 * v338 + ((v339 * v338) >> 16) + 1) >> 16) {
                  goto LABEL_362;
                }
                unint64_t v341 = *((void *)v336 - 1);
                unint64_t v342 = ((HIWORD(v341) - ((v339 * HIWORD(v341) + ((v339 * HIWORD(v341)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v341) - ((WORD2(v341) * v339 + ((WORD2(v341) * v339) >> 16) + 1) >> 16)) << 32) | ((WORD1(v341) - ((WORD1(v341) * v339 + ((WORD1(v341) * v339) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v341 - (((unsigned __int16)v341 * v339 + (((unsigned __int16)v341 * v339) >> 16) + 1) >> 16));
                LODWORD(v343) = (unsigned __int16)v340;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_359;
                  }
                  unsigned int v344 = __rev16(*v30);
                }
                else
                {
                  unsigned int v344 = 0xFFFF;
                }
                uint64_t v345 = (unsigned __int16 *)v34 + 3;
                unint64_t v346 = PDAcolorburnPDA_11716(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v344, v342, (unsigned __int16)v340);
                unint64_t v342 = v346;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v343 = HIWORD(v346);
                  unsigned int v349 = bswap32(v346);
                  v34->i16[0] = HIWORD(v349);
                  v34->i16[1] = v349;
                  v34->i16[2] = bswap32(HIDWORD(v346)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_361;
                }
                LODWORD(v343) = v347;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_359:
                unsigned int v348 = bswap32(v342);
                v34->i16[0] = HIWORD(v348);
                v34->i16[1] = v348;
                v34->i16[2] = bswap32(HIDWORD(v342)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v342));
                uint64_t v345 = v30;
LABEL_361:
                *uint64_t v345 = bswap32(v343) >> 16;
LABEL_362:
                ++v65;
                v246 += v335;
                ++v34;
                v336 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 20:
              uint64_t v649 = v41;
              uint64_t v350 = v45 != 0;
              int v351 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v352 = *v65;
                if (!*v65) {
                  goto LABEL_378;
                }
                if (v45)
                {
                  int v352 = ((unsigned __int16)(*v246 * (_WORD)v352
                                                            + ((*v246 * v352) >> 8)
                                                            + 1) >> 8);
                  if (!v352) {
                    goto LABEL_378;
                  }
                }
                int v353 = *v351;
                int v354 = (v352 | (v352 << 8)) ^ 0xFFFF;
                int v355 = v353 - ((v354 * v353 + ((v354 * v353) >> 16) + 1) >> 16);
                if (v353 == (v354 * v353 + ((v354 * v353) >> 16) + 1) >> 16) {
                  goto LABEL_378;
                }
                unint64_t v356 = *((void *)v351 - 1);
                unint64_t v357 = ((HIWORD(v356) - ((v354 * HIWORD(v356) + ((v354 * HIWORD(v356)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v356) - ((WORD2(v356) * v354 + ((WORD2(v356) * v354) >> 16) + 1) >> 16)) << 32) | ((WORD1(v356) - ((WORD1(v356) * v354 + ((WORD1(v356) * v354) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v356 - (((unsigned __int16)v356 * v354 + (((unsigned __int16)v356 * v354) >> 16) + 1) >> 16));
                LODWORD(v358) = (unsigned __int16)v355;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_375;
                  }
                  unsigned int v359 = __rev16(*v30);
                }
                else
                {
                  unsigned int v359 = 0xFFFF;
                }
                unint64_t v360 = (unsigned __int16 *)v34 + 3;
                unint64_t v361 = PDAsoftlightPDA_11718(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v359, v357, (unsigned __int16)v355);
                unint64_t v357 = v361;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v358 = HIWORD(v361);
                  unsigned int v364 = bswap32(v361);
                  v34->i16[0] = HIWORD(v364);
                  v34->i16[1] = v364;
                  v34->i16[2] = bswap32(HIDWORD(v361)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_377;
                }
                LODWORD(v358) = v362;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_375:
                unsigned int v363 = bswap32(v357);
                v34->i16[0] = HIWORD(v363);
                v34->i16[1] = v363;
                v34->i16[2] = bswap32(HIDWORD(v357)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v357));
                unint64_t v360 = v30;
LABEL_377:
                unsigned __int16 *v360 = bswap32(v358) >> 16;
LABEL_378:
                ++v65;
                v246 += v350;
                ++v34;
                v351 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 21:
              uint64_t v649 = v41;
              uint64_t v365 = v45 != 0;
              uint64_t v366 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v367 = *v65;
                if (!*v65) {
                  goto LABEL_394;
                }
                if (v45)
                {
                  int v367 = ((unsigned __int16)(*v246 * (_WORD)v367
                                                            + ((*v246 * v367) >> 8)
                                                            + 1) >> 8);
                  if (!v367) {
                    goto LABEL_394;
                  }
                }
                int v368 = *v366;
                int v369 = (v367 | (v367 << 8)) ^ 0xFFFF;
                int v370 = v368 - ((v369 * v368 + ((v369 * v368) >> 16) + 1) >> 16);
                if (v368 == (v369 * v368 + ((v369 * v368) >> 16) + 1) >> 16) {
                  goto LABEL_394;
                }
                unint64_t v371 = *((void *)v366 - 1);
                unint64_t v372 = ((HIWORD(v371) - ((v369 * HIWORD(v371) + ((v369 * HIWORD(v371)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v371) - ((WORD2(v371) * v369 + ((WORD2(v371) * v369) >> 16) + 1) >> 16)) << 32) | ((WORD1(v371) - ((WORD1(v371) * v369 + ((WORD1(v371) * v369) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v371 - (((unsigned __int16)v371 * v369 + (((unsigned __int16)v371 * v369) >> 16) + 1) >> 16));
                LODWORD(v373) = (unsigned __int16)v370;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_391;
                  }
                  unsigned int v374 = __rev16(*v30);
                }
                else
                {
                  unsigned int v374 = 0xFFFF;
                }
                unsigned int v375 = (unsigned __int16 *)v34 + 3;
                unint64_t v376 = PDAhardlightPDA_11717(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v374, v372, (unsigned __int16)v370);
                unint64_t v372 = v376;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v373 = HIWORD(v376);
                  unsigned int v379 = bswap32(v376);
                  v34->i16[0] = HIWORD(v379);
                  v34->i16[1] = v379;
                  v34->i16[2] = bswap32(HIDWORD(v376)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_393;
                }
                LODWORD(v373) = v377;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_391:
                unsigned int v378 = bswap32(v372);
                v34->i16[0] = HIWORD(v378);
                v34->i16[1] = v378;
                v34->i16[2] = bswap32(HIDWORD(v372)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v372));
                unsigned int v375 = v30;
LABEL_393:
                *unsigned int v375 = bswap32(v373) >> 16;
LABEL_394:
                ++v65;
                v246 += v365;
                ++v34;
                v366 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 22:
              uint64_t v649 = v41;
              uint64_t v380 = v45 != 0;
              uint64_t v381 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v382 = *v65;
                if (!*v65) {
                  goto LABEL_410;
                }
                if (v45)
                {
                  int v382 = ((unsigned __int16)(*v246 * (_WORD)v382
                                                            + ((*v246 * v382) >> 8)
                                                            + 1) >> 8);
                  if (!v382) {
                    goto LABEL_410;
                  }
                }
                int v383 = *v381;
                int v384 = (v382 | (v382 << 8)) ^ 0xFFFF;
                int v385 = v383 - ((v384 * v383 + ((v384 * v383) >> 16) + 1) >> 16);
                if (v383 == (v384 * v383 + ((v384 * v383) >> 16) + 1) >> 16) {
                  goto LABEL_410;
                }
                unint64_t v386 = *((void *)v381 - 1);
                unint64_t v387 = ((HIWORD(v386) - ((v384 * HIWORD(v386) + ((v384 * HIWORD(v386)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v386) - ((WORD2(v386) * v384 + ((WORD2(v386) * v384) >> 16) + 1) >> 16)) << 32) | ((WORD1(v386) - ((WORD1(v386) * v384 + ((WORD1(v386) * v384) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v386 - (((unsigned __int16)v386 * v384 + (((unsigned __int16)v386 * v384) >> 16) + 1) >> 16));
                LODWORD(v388) = (unsigned __int16)v385;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_407;
                  }
                  unsigned int v389 = __rev16(*v30);
                }
                else
                {
                  unsigned int v389 = 0xFFFF;
                }
                int v390 = (unsigned __int16 *)v34 + 3;
                unint64_t v391 = PDAdifferencePDA_11719(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v389, v387, (unsigned __int16)v385);
                unint64_t v387 = v391;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v388 = HIWORD(v391);
                  unsigned int v394 = bswap32(v391);
                  v34->i16[0] = HIWORD(v394);
                  v34->i16[1] = v394;
                  v34->i16[2] = bswap32(HIDWORD(v391)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_409;
                }
                LODWORD(v388) = v392;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_407:
                unsigned int v393 = bswap32(v387);
                v34->i16[0] = HIWORD(v393);
                v34->i16[1] = v393;
                v34->i16[2] = bswap32(HIDWORD(v387)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v387));
                int v390 = v30;
LABEL_409:
                unsigned __int16 *v390 = bswap32(v388) >> 16;
LABEL_410:
                ++v65;
                v246 += v380;
                ++v34;
                v381 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 23:
              uint64_t v649 = v41;
              uint64_t v395 = v45 != 0;
              unint64_t v396 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v397 = *v65;
                if (!*v65) {
                  goto LABEL_426;
                }
                if (v45)
                {
                  int v397 = ((unsigned __int16)(*v246 * (_WORD)v397
                                                            + ((*v246 * v397) >> 8)
                                                            + 1) >> 8);
                  if (!v397) {
                    goto LABEL_426;
                  }
                }
                int v398 = *v396;
                int v399 = (v397 | (v397 << 8)) ^ 0xFFFF;
                int v400 = v398 - ((v399 * v398 + ((v399 * v398) >> 16) + 1) >> 16);
                if (v398 == (v399 * v398 + ((v399 * v398) >> 16) + 1) >> 16) {
                  goto LABEL_426;
                }
                unint64_t v401 = *((void *)v396 - 1);
                unint64_t v402 = ((HIWORD(v401) - ((v399 * HIWORD(v401) + ((v399 * HIWORD(v401)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v401) - ((WORD2(v401) * v399 + ((WORD2(v401) * v399) >> 16) + 1) >> 16)) << 32) | ((WORD1(v401) - ((WORD1(v401) * v399 + ((WORD1(v401) * v399) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v401 - (((unsigned __int16)v401 * v399 + (((unsigned __int16)v401 * v399) >> 16) + 1) >> 16));
                LODWORD(v403) = (unsigned __int16)v400;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_423;
                  }
                  unsigned int v404 = __rev16(*v30);
                }
                else
                {
                  unsigned int v404 = 0xFFFF;
                }
                uint64_t v405 = (unsigned __int16 *)v34 + 3;
                unint64_t v406 = PDAexclusionPDA_11720(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v404, v402, (unsigned __int16)v400);
                unint64_t v402 = v406;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v403 = HIWORD(v406);
                  unsigned int v409 = bswap32(v406);
                  v34->i16[0] = HIWORD(v409);
                  v34->i16[1] = v409;
                  v34->i16[2] = bswap32(HIDWORD(v406)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_425;
                }
                LODWORD(v403) = v407;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_423:
                unsigned int v408 = bswap32(v402);
                v34->i16[0] = HIWORD(v408);
                v34->i16[1] = v408;
                v34->i16[2] = bswap32(HIDWORD(v402)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v402));
                uint64_t v405 = v30;
LABEL_425:
                *uint64_t v405 = bswap32(v403) >> 16;
LABEL_426:
                ++v65;
                v246 += v395;
                ++v34;
                v396 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 24:
              uint64_t v649 = v41;
              uint64_t v410 = v45 != 0;
              __int16 v411 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v412 = *v65;
                if (!*v65) {
                  goto LABEL_442;
                }
                if (v45)
                {
                  int v412 = ((unsigned __int16)(*v246 * (_WORD)v412
                                                            + ((*v246 * v412) >> 8)
                                                            + 1) >> 8);
                  if (!v412) {
                    goto LABEL_442;
                  }
                }
                int v413 = *v411;
                int v414 = (v412 | (v412 << 8)) ^ 0xFFFF;
                int v415 = v413 - ((v414 * v413 + ((v414 * v413) >> 16) + 1) >> 16);
                if (v413 == (v414 * v413 + ((v414 * v413) >> 16) + 1) >> 16) {
                  goto LABEL_442;
                }
                unint64_t v416 = *((void *)v411 - 1);
                unint64_t v417 = ((HIWORD(v416) - ((v414 * HIWORD(v416) + ((v414 * HIWORD(v416)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v416) - ((WORD2(v416) * v414 + ((WORD2(v416) * v414) >> 16) + 1) >> 16)) << 32) | ((WORD1(v416) - ((WORD1(v416) * v414 + ((WORD1(v416) * v414) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v416 - (((unsigned __int16)v416 * v414 + (((unsigned __int16)v416 * v414) >> 16) + 1) >> 16));
                LODWORD(v418) = (unsigned __int16)v415;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_439;
                  }
                  unsigned int v419 = __rev16(*v30);
                }
                else
                {
                  unsigned int v419 = 0xFFFF;
                }
                uint64_t v420 = (unsigned __int16 *)v34 + 3;
                unint64_t v421 = PDAhuePDA_11721(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v419, v417, (unsigned __int16)v415);
                unint64_t v417 = v421;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v418 = HIWORD(v421);
                  unsigned int v424 = bswap32(v421);
                  v34->i16[0] = HIWORD(v424);
                  v34->i16[1] = v424;
                  v34->i16[2] = bswap32(HIDWORD(v421)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_441;
                }
                LODWORD(v418) = v422;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_439:
                unsigned int v423 = bswap32(v417);
                v34->i16[0] = HIWORD(v423);
                v34->i16[1] = v423;
                v34->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v417));
                uint64_t v420 = v30;
LABEL_441:
                *uint64_t v420 = bswap32(v418) >> 16;
LABEL_442:
                ++v65;
                v246 += v410;
                ++v34;
                v411 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 25:
              uint64_t v649 = v41;
              uint64_t v425 = v45 != 0;
              int v426 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v427 = *v65;
                if (!*v65) {
                  goto LABEL_458;
                }
                if (v45)
                {
                  int v427 = ((unsigned __int16)(*v246 * (_WORD)v427
                                                            + ((*v246 * v427) >> 8)
                                                            + 1) >> 8);
                  if (!v427) {
                    goto LABEL_458;
                  }
                }
                int v428 = *v426;
                int v429 = (v427 | (v427 << 8)) ^ 0xFFFF;
                int v430 = v428 - ((v429 * v428 + ((v429 * v428) >> 16) + 1) >> 16);
                if (v428 == (v429 * v428 + ((v429 * v428) >> 16) + 1) >> 16) {
                  goto LABEL_458;
                }
                unint64_t v431 = *((void *)v426 - 1);
                unint64_t v432 = ((HIWORD(v431) - ((v429 * HIWORD(v431) + ((v429 * HIWORD(v431)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v431) - ((WORD2(v431) * v429 + ((WORD2(v431) * v429) >> 16) + 1) >> 16)) << 32) | ((WORD1(v431) - ((WORD1(v431) * v429 + ((WORD1(v431) * v429) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v431 - (((unsigned __int16)v431 * v429 + (((unsigned __int16)v431 * v429) >> 16) + 1) >> 16));
                LODWORD(v433) = (unsigned __int16)v430;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_455;
                  }
                  unsigned int v434 = __rev16(*v30);
                }
                else
                {
                  unsigned int v434 = 0xFFFF;
                }
                uint64_t v435 = (unsigned __int16 *)v34 + 3;
                unint64_t v436 = PDAsaturationPDA_11722(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v434, v432, (unsigned __int16)v430);
                unint64_t v432 = v436;
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v433 = HIWORD(v436);
                  unsigned int v439 = bswap32(v436);
                  v34->i16[0] = HIWORD(v439);
                  v34->i16[1] = v439;
                  v34->i16[2] = bswap32(HIDWORD(v436)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_457;
                }
                LODWORD(v433) = v437;
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_455:
                unsigned int v438 = bswap32(v432);
                v34->i16[0] = HIWORD(v438);
                v34->i16[1] = v438;
                v34->i16[2] = bswap32(HIDWORD(v432)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v432));
                uint64_t v435 = v30;
LABEL_457:
                *uint64_t v435 = bswap32(v433) >> 16;
LABEL_458:
                ++v65;
                v246 += v425;
                ++v34;
                v426 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 26:
              uint64_t v649 = v41;
              uint64_t v440 = v45 != 0;
              unsigned int v441 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              while (1)
              {
                int v442 = *v65;
                if (!*v65) {
                  goto LABEL_474;
                }
                if (v45)
                {
                  int v442 = ((unsigned __int16)(*v246 * (_WORD)v442
                                                            + ((*v246 * v442) >> 8)
                                                            + 1) >> 8);
                  if (!v442) {
                    goto LABEL_474;
                  }
                }
                int v443 = *v441;
                int v444 = (v442 | (v442 << 8)) ^ 0xFFFF;
                int v445 = v443 - ((v444 * v443 + ((v444 * v443) >> 16) + 1) >> 16);
                if (v443 == (v444 * v443 + ((v444 * v443) >> 16) + 1) >> 16) {
                  goto LABEL_474;
                }
                unint64_t v446 = *((void *)v441 - 1);
                unint64_t v447 = ((HIWORD(v446) - ((v444 * HIWORD(v446) + ((v444 * HIWORD(v446)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v446) - ((WORD2(v446) * v444 + ((WORD2(v446) * v444) >> 16) + 1) >> 16)) << 32) | ((WORD1(v446) - ((WORD1(v446) * v444 + ((WORD1(v446) * v444) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v446 - (((unsigned __int16)v446 * v444 + (((unsigned __int16)v446 * v444) >> 16) + 1) >> 16));
                LODWORD(v448) = (unsigned __int16)v445;
                if (v50)
                {
                  if (!*v30) {
                    goto LABEL_471;
                  }
                  unsigned int v449 = __rev16(*v30);
                }
                else
                {
                  unsigned int v449 = 0xFFFF;
                }
                unint64_t v450 = (unsigned __int16 *)v34 + 3;
                unint64_t v447 = PDAluminosityPDA_11723(v447, (unsigned __int16)v445, ((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v449);
                uint64_t v50 = v654;
                if (!v654)
                {
                  unint64_t v448 = HIWORD(v447);
                  unsigned int v452 = bswap32(v447);
                  v34->i16[0] = HIWORD(v452);
                  v34->i16[1] = v452;
                  v34->i16[2] = bswap32(HIDWORD(v447)) >> 16;
                  uint64_t v69 = v653;
                  uint64_t v45 = v655;
                  goto LABEL_473;
                }
                uint64_t v69 = v653;
                uint64_t v45 = v655;
LABEL_471:
                unsigned int v451 = bswap32(v447);
                v34->i16[0] = HIWORD(v451);
                v34->i16[1] = v451;
                v34->i16[2] = bswap32(HIDWORD(v447)) >> 16;
                v34->i16[3] = __rev16(HIWORD(v447));
                unint64_t v450 = v30;
LABEL_473:
                unsigned __int16 *v450 = bswap32(v448) >> 16;
LABEL_474:
                ++v65;
                v246 += v440;
                ++v34;
                v441 += 8;
                long long v30 = (unsigned __int16 *)((char *)v30 + v69);
                LODWORD(v40) = v40 - 1;
                if (!v40) {
                  goto LABEL_491;
                }
              }
            case 27:
              uint64_t v649 = v41;
              uint64_t v453 = v45 != 0;
              uint64_t v454 = (unsigned __int16 *)(v64 + 8);
              unint64_t v246 = v45;
              uint64_t v50 = v654;
              break;
            default:
              uint64_t v50 = v654;
              goto LABEL_494;
          }
          break;
        }
        while (1)
        {
          int v455 = *v65;
          if (!*v65) {
            goto LABEL_490;
          }
          if (v45)
          {
            int v455 = ((unsigned __int16)(*v246 * (_WORD)v455 + ((*v246 * v455) >> 8) + 1) >> 8);
            if (!v455) {
              goto LABEL_490;
            }
          }
          int v456 = *v454;
          int v457 = (v455 | (v455 << 8)) ^ 0xFFFF;
          int v458 = v456 - ((v457 * v456 + ((v457 * v456) >> 16) + 1) >> 16);
          if (v456 == (v457 * v456 + ((v457 * v456) >> 16) + 1) >> 16) {
            goto LABEL_490;
          }
          unint64_t v459 = *((void *)v454 - 1);
          unint64_t v460 = ((HIWORD(v459) - ((v457 * HIWORD(v459) + ((v457 * HIWORD(v459)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v459) - ((WORD2(v459) * v457 + ((WORD2(v459) * v457) >> 16) + 1) >> 16)) << 32) | ((WORD1(v459) - ((WORD1(v459) * v457 + ((WORD1(v459) * v457) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v459 - (((unsigned __int16)v459 * v457 + (((unsigned __int16)v459 * v457) >> 16) + 1) >> 16));
          LODWORD(v461) = (unsigned __int16)v458;
          if (v50)
          {
            if (!*v30) {
              goto LABEL_487;
            }
            unsigned int v462 = __rev16(*v30);
          }
          else
          {
            unsigned int v462 = 0xFFFF;
          }
          uint64_t v463 = (unsigned __int16 *)v34 + 3;
          unint64_t v464 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v34->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v34->u16[3]) >> 16) << 48) | bswap32(v34->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v34->u16[0]) >> 16), v462, v460, (unsigned __int16)v458);
          unint64_t v460 = v464;
          uint64_t v50 = v654;
          if (!v654)
          {
            unint64_t v461 = HIWORD(v464);
            unsigned int v467 = bswap32(v464);
            v34->i16[0] = HIWORD(v467);
            v34->i16[1] = v467;
            v34->i16[2] = bswap32(HIDWORD(v464)) >> 16;
            uint64_t v69 = v653;
            uint64_t v45 = v655;
            goto LABEL_489;
          }
          LODWORD(v461) = v465;
          uint64_t v69 = v653;
          uint64_t v45 = v655;
LABEL_487:
          unsigned int v466 = bswap32(v460);
          v34->i16[0] = HIWORD(v466);
          v34->i16[1] = v466;
          v34->i16[2] = bswap32(HIDWORD(v460)) >> 16;
          v34->i16[3] = __rev16(HIWORD(v460));
          uint64_t v463 = v30;
LABEL_489:
          *uint64_t v463 = bswap32(v461) >> 16;
LABEL_490:
          ++v65;
          v246 += v453;
          ++v34;
          v454 += 8;
          long long v30 = (unsigned __int16 *)((char *)v30 + v69);
          LODWORD(v40) = v40 - 1;
          if (!v40)
          {
LABEL_491:
            long long v39 = v643;
            uint64_t v45 = &v246[v642];
            v34 += v644;
            v30 += v645;
LABEL_492:
            uint64_t v40 = v647;
LABEL_493:
            uint64_t v41 = v649;
LABEL_494:
            uint64_t v167 = v652;
LABEL_564:
            int v138 = v651;
            goto LABEL_565;
          }
        }
      }
    }
    else
    {
      unint64_t v632 = v27;
      unint64_t v635 = v20;
      int v38 = v641;
      long long v39 = v643;
      uint64_t v40 = v647;
      if (!v9)
      {
        uint64_t v45 = 0;
        int8x16_t v42 = 0;
        uint64_t v642 = 0;
        int v43 = 0;
        uint64_t v41 = v649;
        goto LABEL_21;
      }
      uint64_t v633 = v33;
      uint64_t v634 = v32;
      shape_enum_clip_alloc((uint64_t)v20, v19, v9, 1, 1, 1, v35, v36, v647, v651);
      if (v46)
      {
        uint64_t v47 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
        if (!v15) {
          uint64_t v47 = 16 * v4;
        }
        unint64_t v48 = v25 + v47;
        int v43 = 0;
        uint64_t v49 = v640;
        uint64_t v642 = -v640;
        uint64_t v45 = (unsigned __int8 *)(v48 + 16);
        uint64_t v50 = v654;
        uint64_t v51 = v652;
        int8x16_t v42 = v46;
        goto LABEL_22;
      }
LABEL_625:
      long long v20 = v635;
    }
    if (v20) {
      free(v20);
    }
  }
}

int8x8_t CMYK64_DAM(int8x8_t *a1, _WORD *a2, unint64_t a3, int a4, int a5)
{
  v5.i32[0] = (unsigned __int16)a3;
  v5.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32((int32x2_t)a3, 0), 0x10uLL).i32[1];
  v5.i32[2] = WORD2(a3);
  v5.i32[3] = HIWORD(a3);
  uint32x4_t v6 = (uint32x4_t)vmulq_s32(v5, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~a5)));
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  v5.i32[2] = HIDWORD(a3);
  v5.i32[0] = a3;
  int8x8_t result = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v5, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v6, v6, 0x10uLL), v7), 0x10uLL))));
  *a1 = result;
  *a2 = bswap32(a4- (((unsigned __int16)~(_WORD)a5 * a4 + (((unsigned __int16)~(_WORD)a5 * a4) >> 16) + 1) >> 16)) >> 16;
  return result;
}

_WORD *CMYK64_DAMplusDAM(_WORD *result, _WORD *a2, unint64_t a3, int a4, int a5, unint64_t a6, int a7, int a8)
{
  unsigned int v8 = WORD1(a3) * a5 + WORD1(a6) * a8;
  unsigned int v9 = WORD2(a3) * a5 + WORD2(a6) * a8;
  unsigned int v10 = a5 * HIWORD(a3) + a8 * HIWORD(a6);
  *int8x8_t result = bswap32((unsigned __int16)a3 * a5+ (unsigned __int16)a6 * a8+ (((unsigned __int16)a3 * a5 + (unsigned __int16)a6 * a8) >> 16)+ 1);
  result[1] = bswap32(v8 + HIWORD(v8) + 1);
  result[2] = bswap32(v9 + HIWORD(v9) + 1);
  result[3] = bswap32(v10 + HIWORD(v10) + 1);
  *a2 = bswap32(a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 16) + 1);
  return result;
}

int *CMYK64_DAplusdDA(int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  int v6 = a4 - (WORD1(a3) + WORD1(a5)) + a6;
  int v7 = a4 + a6 - (WORD2(a3) + WORD2(a5));
  int v8 = a4 - (HIWORD(a3) + HIWORD(a5)) + a6;
  if (v6 >= 0xFFFF) {
    LOWORD(v6) = -1;
  }
  if (v7 >= 0xFFFF) {
    LOWORD(v7) = -1;
  }
  if (v8 >= 0xFFFF) {
    LOWORD(v8) = -1;
  }
  if ((a4 + a6) >= 0xFFFF) {
    unsigned int v9 = 0xFFFF;
  }
  else {
    unsigned int v9 = a4 + a6;
  }
  *int8x8_t result = (unsigned __int16)(v9 - v6) | ((unsigned __int16)(v9 - v6) << 16);
  result[1] = (unsigned __int16)(v9 - v7) | ((unsigned __int16)(v9 - v8) << 16);
  *a2 = bswap32(v9) >> 16;
  return result;
}

_WORD *CMYK64_DplusdDA(_WORD *result, unint64_t a2, unint64_t a3, int a4)
{
  int v4 = a4 - WORD2(a3) + (unsigned __int16)~WORD2(a2);
  int v5 = a4 - HIWORD(a3) + (HIWORD(a2) ^ 0xFFFF);
  if ((int)(a4 - WORD1(a3) + (~a2 >> 16)) >= 0xFFFF) {
    unsigned int v6 = 0xFFFF;
  }
  else {
    unsigned int v6 = a4 - WORD1(a3) + (~a2 >> 16);
  }
  if (v4 >= 0xFFFF) {
    int v4 = 0xFFFF;
  }
  if (v5 >= 0xFFFF) {
    int v5 = 0xFFFF;
  }
  unsigned int v7 = bswap32(~v6) >> 16;
  *int8x8_t result = v7;
  result[1] = v7;
  result[2] = bswap32(~v4) >> 16;
  result[3] = bswap32(~v5) >> 16;
  return result;
}

unsigned int *CMYK64_DApluslDA(unsigned int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  unsigned int v6 = (unsigned __int16)a5 + (unsigned __int16)a3;
  unsigned int v7 = WORD1(a5) + WORD1(a3);
  unsigned int v8 = WORD2(a5) + WORD2(a3);
  unsigned int v9 = HIWORD(a5) + HIWORD(a3);
  unsigned int v10 = a6 + a4;
  if (v6 >= 0xFFFF) {
    unsigned int v6 = 0xFFFF;
  }
  if (v7 >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  if (v8 >= 0xFFFF) {
    unsigned int v8 = 0xFFFF;
  }
  if (v9 >= 0xFFFF) {
    unsigned int v9 = 0xFFFF;
  }
  if (v10 >= 0xFFFF) {
    unsigned int v10 = 0xFFFF;
  }
  *int8x8_t result = v6 | (v7 << 16);
  result[1] = v8 | (v9 << 16);
  *a2 = bswap32(v10) >> 16;
  return result;
}

_WORD *CMYK64_DpluslD(_WORD *result, unint64_t a2, unint64_t a3)
{
  unsigned int v3 = (unsigned __int16)a3 + (unsigned __int16)a2;
  unsigned int v4 = WORD1(a3) + WORD1(a2);
  unsigned int v5 = WORD2(a3) + WORD2(a2);
  unsigned int v6 = HIWORD(a3) + HIWORD(a2);
  if (v3 >= 0xFFFF) {
    unsigned int v3 = 0xFFFF;
  }
  if (v4 >= 0xFFFF) {
    unsigned int v4 = 0xFFFF;
  }
  if (v5 >= 0xFFFF) {
    unsigned int v5 = 0xFFFF;
  }
  if (v6 >= 0xFFFF) {
    unsigned int v6 = 0xFFFF;
  }
  *int8x8_t result = bswap32(v3) >> 16;
  result[1] = bswap32(v4) >> 16;
  result[2] = bswap32(v5) >> 16;
  result[3] = bswap32(v6) >> 16;
  return result;
}

uint64_t CMYK64_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  memset(v48, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v31, (uint64_t)v48) < 1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v18 = *(_DWORD *)a3;
  *((void *)&v31 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v18 != 269501444)
  {
    unsigned int v19 = SAMPLEINDEX(v18, v10, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      if (v19 > 0xB)
      {
LABEL_20:
        int v21 = 255;
        char v20 = 1;
      }
      else
      {
        char v20 = 0;
        int v21 = 0;
        switch(v19)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v20 = 0;
            int v21 = 16;
            break;
          case 5u:
            char v20 = 0;
            int v21 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v20 = 0;
            int v21 = 32;
            break;
          case 8u:
            char v20 = 0;
            int v21 = 8;
            break;
          case 9u:
            char v20 = 0;
            int v21 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYK16_image_sample[2 * v19 + 2];
      if ((void)v31)
      {
        int v22 = 269501476;
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(void *)&long long v31 = *(void *)&CMYK8_image_sample[2 * v19 + 2];
        if ((void)v31)
        {
          int v22 = 134759444;
          int v23 = 8;
LABEL_28:
          LODWORD(v32) = v23;
LABEL_29:
          DWORD2(v31) = v22;
          if ((v20 & 1) == 0
            && (v8 - 1) <= 1
            && (BYTE4(v32) & 7) == 3
            && (a2[2] == 5 || !a2[2])
            && v19 <= 0xB)
          {
            HIDWORD(v24) = v21;
            LODWORD(v24) = v21;
            switch((v24 >> 3))
            {
              case 0u:
                DWORD2(v31) = *(_DWORD *)a3;
                unint64_t v25 = CMYK64_image_mark_RGB32;
                goto LABEL_52;
              case 1u:
                DWORD2(v31) = *(_DWORD *)a3;
                uint64_t v26 = CMYK64_image_mark_RGB32;
                goto LABEL_54;
              case 2u:
                DWORD2(v31) = *(_DWORD *)a3;
                unint64_t v25 = (uint64_t (*)(uint64_t, int *, int, int, int, int, double, double, double, int32x4_t))CMYK64_image_mark_W8;
                goto LABEL_52;
              case 3u:
                DWORD2(v31) = *(_DWORD *)a3;
                unint64_t v25 = (uint64_t (*)(uint64_t, int *, int, int, int, int, double, double, double, int32x4_t))CMYK64_image_mark_RGB24;
                goto LABEL_52;
              case 4u:
                DWORD2(v31) = *(_DWORD *)a3;
                unint64_t v25 = CMYK64_image_mark_rgb32;
LABEL_52:
                unint64_t v27 = v25;
                uint64_t v28 = (uint64_t)a2;
                int v29 = v8;
                int v30 = 0;
                break;
              case 5u:
                DWORD2(v31) = *(_DWORD *)a3;
                uint64_t v26 = CMYK64_image_mark_rgb32;
LABEL_54:
                unint64_t v27 = v26;
                uint64_t v28 = (uint64_t)a2;
                int v29 = v8;
                int v30 = 8;
                break;
              default:
                goto LABEL_30;
            }
            cmyk64_image_mark_image(v28, (uint64_t)&v31, v29, v30, (void (*)(void, void))v27);
            return 1;
          }
          goto LABEL_30;
        }
      }
      *(void *)&long long v31 = *(void *)&CMYKF_image_sample[2 * v19 + 2];
      if ((void)v31)
      {
        int v22 = 538985509;
        int v23 = 20;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v42 && (~DWORD1(v32) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v32) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      CMYK64_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v31 = cmyk64_sample_CMYK64;
LABEL_30:
  CMYK64_image_mark((uint64_t)a2, (uint64_t)&v31, v8, v17);
  return 1;
}

uint64_t CMYK64_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v298 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(unsigned __int16 **)(v3 + 96);
  uint64_t v6 = *(void *)(v3 + 48);
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)v2 + 56)
                       + 16 * *(_DWORD *)v3
                       + 8 * (v5 == 0)
                       + 4 * (v6 == 0));
  if ((int)v7 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = v3;
  uint64_t v10 = *(unsigned int *)(v3 + 4);
  if ((int)v10 < 1) {
    return 0;
  }
  int v11 = *(_DWORD *)(v3 + 8);
  if (v11 < 1) {
    return 0;
  }
  uint64_t v12 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) != 0x50000 && v12)
  {
    int v13 = *(_DWORD *)(v3 + 128);
    if ((v13 | 8) == 8)
    {
      if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
        CMYK64_mark_constmask(v3, v7);
      }
      else {
        CMYK64_mark_pixelmask(v3, v7);
      }
    }
    else
    {
      int v17 = *(_DWORD *)(v3 + 112);
      int v18 = *(_DWORD *)(v3 + 116);
      unsigned int v19 = (v17 + 15) & 0xFFFFFFF0;
      size_t v20 = v19 * v18;
      if ((int)v20 <= 4096)
      {
        int v23 = v297;
      }
      else
      {
        uint64_t v21 = v3;
        int v22 = malloc_type_malloc(v20, 0x8303D2FuLL);
        if (!v22) {
          return 1;
        }
        int v23 = v22;
        uint64_t v9 = v21;
        uint64_t v12 = *(uint16x4_t **)(v21 + 136);
        int v13 = *(_DWORD *)(v21 + 128);
      }
      long long v37 = (_OWORD *)v9;
      CGSConvertBitsToMask(v12, *(_DWORD *)(v9 + 124), v23, v19, v17, v18, v13);
      long long v38 = v37[7];
      long long v293 = v37[6];
      long long v294 = v38;
      long long v39 = v37[9];
      long long v295 = v37[8];
      long long v296 = v39;
      long long v40 = v37[3];
      long long v289 = v37[2];
      long long v290 = v40;
      long long v41 = v37[5];
      long long v291 = v37[4];
      long long v292 = v41;
      long long v42 = v37[1];
      *(_OWORD *)int v287 = *v37;
      long long v288 = v42;
      HIDWORD(v294) = (v17 + 15) & 0xFFFFFFF0;
      *((void *)&v295 + 1) = v23;
      if (BYTE1(v287[0]) << 8 == 1024) {
        CMYK64_mark_constmask((uint64_t)v287, v7);
      }
      else {
        CMYK64_mark_pixelmask((uint64_t)v287, v7);
      }
      if (v23 != (unsigned char *)v297)
      {
        long long v43 = v23;
        goto LABEL_354;
      }
    }
    return 1;
  }
  if ((*(_DWORD *)v3 & 0xFF00) != 0x400)
  {
    CMYK64_mark_pixelshape(v3, v7, v4);
    return 1;
  }
  v297[0] = *(_DWORD *)(v3 + 4);
  v287[0] = v11;
  uint64_t v14 = *(unsigned __int16 **)(v3 + 88);
  unsigned int v285 = *v14;
  unsigned int v284 = v14[1];
  unsigned int v283 = v14[2];
  uint64_t v268 = __rev16(v283);
  unsigned int v282 = v14[3];
  uint64_t v267 = __rev16(v282);
  int32x2_t v15 = (int32x2_t)(__PAIR64__(__rev16(v284), bswap32(v285)) >> 16);
  if (v5) {
    int v16 = bswap32(*v5) >> 16;
  }
  else {
    int v16 = 0xFFFF;
  }
  int32x2_t v270 = v15;
  unint64_t v24 = (v268 << 32) | (v267 << 48) | *(void *)&v15;
  uint64_t v25 = *(void *)(v3 + 40);
  unint64_t v26 = (unint64_t)*(int *)(v3 + 28) >> 3;
  uint64_t v28 = *(int *)(v3 + 12);
  uint64_t v27 = *(int *)(v3 + 16);
  if (v6)
  {
    unint64_t v276 = (unint64_t)*(int *)(v3 + 32) >> 1;
    unsigned int v274 = 1;
    uint64_t v275 = (char *)(v6 + 2 * (v28 + v276 * v27));
  }
  else
  {
    uint64_t v275 = 0;
    unint64_t v276 = 0;
    unsigned int v274 = 0;
  }
  unsigned __int16 v29 = ~(_WORD)v16;
  uint64_t v30 = v25 + 8 * (v28 + v27 * v26);
  int v271 = v7;
  unint64_t v272 = (unint64_t)*(int *)(v3 + 28) >> 3;
  uint64_t v269 = v3;
  uint64_t v273 = v30;
  if (v12)
  {
    shape_enum_clip_alloc(v2, v3, (int *)v12, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v11);
    uint64_t v32 = v31;
    long long v33 = v275;
    unint64_t v281 = v276;
    if (v31) {
      goto LABEL_36;
    }
    return 1;
  }
  uint64_t v32 = 0;
  if (v6) {
    uint64_t v34 = v10;
  }
  else {
    uint64_t v34 = 0;
  }
  long long v33 = v275;
  int v280 = v10;
  unint64_t v281 = v276 - v34;
  uint64_t v35 = v10;
  long long v36 = (int8x8_t *)(v25 + 8 * (v28 + v27 * v26));
  while (2)
  {
    uint64_t v278 = v26 - v35;
    switch((int)v7)
    {
      case 0:
        uint64_t v277 = v32;
        uint64_t v45 = v278 + v280;
        uint64_t v46 = v287[0] - 1;
        uint64_t v47 = (v45 * v46) & (v45 >> 63);
        if (v45 < 0) {
          uint64_t v45 = -v45;
        }
        int v279 = v287[0];
        CGBlt_fillBytes(8 * v280, v287[0], 0, (char *)&v36[v47], 8 * v45);
        if (!v6) {
          goto LABEL_350;
        }
        uint64_t v48 = v281 + v280;
        uint64_t v49 = (v48 * v46) & (v48 >> 63);
        if (v48 < 0) {
          uint64_t v48 = -v48;
        }
        v33 += 2 * v49;
        int v50 = 2 * v280;
        unint64_t v281 = v48;
        int v51 = 2 * v48;
        unsigned int v52 = v279;
        int v53 = 0;
        goto LABEL_364;
      case 1:
        uint64_t v277 = v32;
        uint64_t v54 = v278 + v280;
        if (v54 < 0)
        {
          v36 += v54 * (v287[0] - 1);
          uint64_t v54 = -v54;
        }
        uint64_t v55 = *(void *)(v269 + 88);
        if (v55)
        {
          unint64_t v56 = (unint64_t)v36;
          int v57 = v287[0];
          CGSFillDRAM64(v56, 8 * v54, 8 * v280, v287[0], v55, 8, 8, 1, 0, 0);
        }
        else
        {
          unsigned int v231 = (char *)v36;
          int v57 = v287[0];
          CGBlt_fillBytes(8 * v280, v287[0], 0, v231, 8 * v54);
        }
        if (v6)
        {
          uint64_t v232 = *(int **)(v269 + 96);
          if (!v232) {
            uint64_t v232 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
          }
          uint64_t v233 = v281 + v280;
          if (v233 >= 0) {
            uint64_t v234 = v281 + v280;
          }
          else {
            uint64_t v234 = -v233;
          }
          v33 += 2 * (((v281 + v280) * (v57 - 1)) & (v233 >> 63));
          int v53 = *v232;
          int v50 = 2 * v280;
          unint64_t v281 = v234;
          int v51 = 2 * v234;
          unsigned int v52 = v57;
LABEL_364:
          CGBlt_fillBytes(v50, v52, v53, v33, v51);
        }
        goto LABEL_350;
      case 2:
        unsigned int v58 = v280 >> 2;
        int32x4_t v59 = vdupq_n_s32(v29);
        v60.i32[0] = v270.i32[0];
        v60.i32[1] = v270.u16[1];
        uint32x4_t v61 = (uint32x4_t)vmovn_hight_s64(v60, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v24), (uint64x2_t)xmmword_1850CDC40));
        int v62 = v287[0];
        if (v6)
        {
          unsigned int v63 = v58 + 1;
          v64.i64[0] = 0x100000001;
          v64.i64[1] = 0x100000001;
          do
          {
            int v65 = v280;
            if (v280 >= 4)
            {
              unsigned int v66 = v63;
              do
              {
                unsigned int v67 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
                unsigned int v68 = bswap32(*(unsigned __int16 *)v33);
                v69.i32[0] = (unsigned __int16)v67;
                v69.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v67), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v69.i32[2] = bswap32(v36->u16[2]) >> 16;
                v69.i32[3] = bswap32(v36->u16[3]) >> 16;
                uint32x4_t v70 = (uint32x4_t)vmulq_s32(v69, v59);
                *long long v36 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v70, v70, 0x10uLL), v64), 0x10uLL)));
                *(_WORD *)long long v33 = bswap32(v16 + ((v29 * HIWORD(v68) + ((v29 * HIWORD(v68)) >> 16) + 1) >> 16)) >> 16;
                unsigned int v71 = bswap32(v36[1].u16[1] | (v36[1].u16[0] << 16));
                unsigned int v72 = bswap32(*((unsigned __int16 *)v33 + 1));
                v69.i32[0] = (unsigned __int16)v71;
                v69.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v71), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v69.i32[2] = bswap32(v36[1].u16[2]) >> 16;
                v69.i32[3] = bswap32(v36[1].u16[3]) >> 16;
                uint32x4_t v73 = (uint32x4_t)vmulq_s32(v69, v59);
                v36[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v73, v73, 0x10uLL), v64), 0x10uLL)));
                *((_WORD *)v33 + 1) = bswap32(v16+ ((v29 * HIWORD(v72) + ((v29 * HIWORD(v72)) >> 16) + 1) >> 16)) >> 16;
                unsigned int v74 = bswap32(v36[2].u16[1] | (v36[2].u16[0] << 16));
                unsigned int v75 = bswap32(*((unsigned __int16 *)v33 + 2));
                v69.i32[0] = (unsigned __int16)v74;
                v69.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v74), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v69.i32[2] = bswap32(v36[2].u16[2]) >> 16;
                v69.i32[3] = bswap32(v36[2].u16[3]) >> 16;
                uint32x4_t v76 = (uint32x4_t)vmulq_s32(v69, v59);
                v36[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v76, v76, 0x10uLL), v64), 0x10uLL)));
                *((_WORD *)v33 + 2) = bswap32(v16+ ((v29 * HIWORD(v75) + ((v29 * HIWORD(v75)) >> 16) + 1) >> 16)) >> 16;
                unsigned int v77 = bswap32(v36[3].u16[1] | (v36[3].u16[0] << 16));
                unsigned int v78 = bswap32(*((unsigned __int16 *)v33 + 3));
                v69.i32[0] = (unsigned __int16)v77;
                v69.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v77), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v69.i64[1] = __PAIR64__(bswap32(v36[3].u16[3]) >> 16, bswap32(v36[3].u16[2]) >> 16);
                uint32x4_t v79 = (uint32x4_t)vmulq_s32(v69, v59);
                v36[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v79, v79, 0x10uLL), v64), 0x10uLL)));
                *((_WORD *)v33 + 3) = bswap32(v16+ ((v29 * HIWORD(v78) + ((v29 * HIWORD(v78)) >> 16) + 1) >> 16)) >> 16;
                v36 += 4;
                v33 += 8 * v274;
                --v66;
              }
              while (v66 > 1);
              int v65 = v280 & 3;
            }
            if (v65 >= 1)
            {
              unsigned int v80 = v65 + 1;
              do
              {
                unsigned int v81 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
                unsigned int v82 = bswap32(*(unsigned __int16 *)v33);
                v83.i32[0] = (unsigned __int16)v81;
                v83.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v81), 0x10uLL).i32[1];
                v83.i64[1] = __PAIR64__(bswap32(v36->u16[3]) >> 16, bswap32(v36->u16[2]) >> 16);
                uint32x4_t v84 = (uint32x4_t)vmulq_s32(v83, v59);
                *v36++ = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v84, v84, 0x10uLL), v64), 0x10uLL)));
                *(_WORD *)long long v33 = bswap32(v16 + ((v29 * HIWORD(v82) + ((v29 * HIWORD(v82)) >> 16) + 1) >> 16)) >> 16;
                --v80;
                v33 += 2 * v274;
              }
              while (v80 > 1);
            }
            v36 += v278;
            v33 += 2 * v281;
            --v62;
          }
          while (v62);
        }
        else
        {
          v235.i64[0] = 0x100000001;
          v235.i64[1] = 0x100000001;
          do
          {
            int v236 = v280;
            if (v280 >= 4)
            {
              unsigned int v237 = v58 + 1;
              do
              {
                unsigned int v238 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
                v239.i32[0] = (unsigned __int16)v238;
                v239.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v238), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v239.i32[2] = bswap32(v36->u16[2]) >> 16;
                v239.i32[3] = bswap32(v36->u16[3]) >> 16;
                uint32x4_t v240 = (uint32x4_t)vmulq_s32(v239, v59);
                unsigned int v241 = bswap32(v36[1].u16[1] | (v36[1].u16[0] << 16));
                v242.i32[0] = (unsigned __int16)v241;
                v242.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v241), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v242.i32[2] = bswap32(v36[1].u16[2]) >> 16;
                v242.i32[3] = bswap32(v36[1].u16[3]) >> 16;
                int32x4_t v243 = vmulq_s32(v242, v59);
                *long long v36 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v240, v240, 0x10uLL), v235), 0x10uLL)));
                v36[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32((uint32x4_t)v243, (uint32x4_t)v243, 0x10uLL), v235), 0x10uLL)));
                unsigned int v244 = bswap32(v36[2].u16[1] | (v36[2].u16[0] << 16));
                v243.i32[0] = (unsigned __int16)v244;
                v243.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v244), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v243.i32[2] = bswap32(v36[2].u16[2]) >> 16;
                v243.i32[3] = bswap32(v36[2].u16[3]) >> 16;
                uint32x4_t v245 = (uint32x4_t)vmulq_s32(v243, v59);
                int32x4_t v246 = (int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v245, v245, 0x10uLL), v235), 0x10uLL);
                unsigned int v247 = bswap32(v36[3].u16[1] | (v36[3].u16[0] << 16));
                v242.i32[0] = (unsigned __int16)v247;
                v242.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v247), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
                v242.i32[2] = bswap32(v36[3].u16[2]) >> 16;
                v242.i32[3] = bswap32(v36[3].u16[3]) >> 16;
                uint32x4_t v248 = (uint32x4_t)vmulq_s32(v242, v59);
                v36[2] = vrev16_s8((int8x8_t)vmovn_s32(v246));
                v36[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v248, v248, 0x10uLL), v235), 0x10uLL)));
                v36 += 4;
                v33 += 8 * v274;
                --v237;
              }
              while (v237 > 1);
              int v236 = v280 & 3;
            }
            if (v236 >= 1)
            {
              unsigned int v249 = v236 + 1;
              do
              {
                unsigned int v250 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
                v251.i32[0] = (unsigned __int16)v250;
                v251.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v250), 0x10uLL).i32[1];
                v251.i64[1] = __PAIR64__(bswap32(v36->u16[3]) >> 16, bswap32(v36->u16[2]) >> 16);
                uint32x4_t v252 = (uint32x4_t)vmulq_s32(v251, v59);
                *v36++ = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v61, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v252, v252, 0x10uLL), v235), 0x10uLL)));
                --v249;
                v33 += 2 * v274;
              }
              while (v249 > 1);
            }
            v36 += v278;
            v33 += 2 * v281;
            --v62;
          }
          while (v62);
        }
        goto LABEL_384;
      case 3:
        uint64_t v277 = v32;
        __int16 v85 = __rev16(v16);
        int v86 = v287[0];
        do
        {
          int v87 = v280;
          do
          {
            unsigned int v88 = bswap32(*(unsigned __int16 *)v33) >> 16;
            if (v88 == 0xFFFF)
            {
              v36->i16[0] = v285;
              v36->i16[1] = v284;
              v36->i16[2] = v283;
              v36->i16[3] = v282;
              *(_WORD *)long long v33 = v85;
            }
            else if (v88)
            {
              CMYK64_DAM(v36, v33, v24, v16, v88);
            }
            else
            {
              *long long v36 = 0;
              *(_WORD *)long long v33 = 0;
            }
            ++v36;
            v33 += 2 * v274;
            --v87;
          }
          while (v87);
          v36 += v278;
          v33 += 2 * v281;
          --v86;
        }
        while (v86);
        goto LABEL_81;
      case 4:
        uint64_t v277 = v32;
        __int16 v89 = __rev16(v16);
        int v90 = v287[0];
        do
        {
          int v91 = v280;
          do
          {
            unsigned int v92 = bswap32(~*(unsigned __int16 *)v33) >> 16;
            if (v92 == 0xFFFF)
            {
              v36->i16[0] = v285;
              v36->i16[1] = v284;
              v36->i16[2] = v283;
              v36->i16[3] = v282;
              *(_WORD *)long long v33 = v89;
            }
            else if (v92)
            {
              CMYK64_DAM(v36, v33, v24, v16, v92);
            }
            else
            {
              *long long v36 = 0;
              *(_WORD *)long long v33 = 0;
            }
            ++v36;
            v33 += 2 * v274;
            --v91;
          }
          while (v91);
          v36 += v278;
          v33 += 2 * v281;
          --v90;
        }
        while (v90);
LABEL_81:
        v287[0] = 0;
        LODWORD(v7) = v271;
        goto LABEL_347;
      case 5:
        uint64_t v277 = v32;
        int v93 = v287[0];
        do
        {
          int v94 = v280;
          do
          {
            unsigned int v95 = bswap32(*(unsigned __int16 *)v33) >> 16;
            CMYK64_DAMplusDAM(v36, v33, v24, v16, v95, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v95, (unsigned __int16)~(_WORD)v16);
            ++v36;
            v33 += 2 * v274;
            --v94;
          }
          while (v94);
          v36 += v278;
          v33 += 2 * v281;
          --v93;
        }
        while (v93);
        goto LABEL_118;
      case 6:
        __int16 v96 = __rev16(v16);
        v97.i32[0] = v270.u16[0];
        v97.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32(v270, 0), 0x10uLL).i32[1];
        v97.i64[1] = __PAIR64__(v267, v268);
        int v98 = v287[0];
        v99.i64[0] = 0x100000001;
        v99.i64[1] = 0x100000001;
        do
        {
          int v100 = v280;
          do
          {
            unsigned int v101 = bswap32(*(unsigned __int16 *)v33);
            if (HIWORD(v101) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v101) == 0xFFFF)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                LOWORD(v102) = v96;
                v36->i16[3] = v282;
              }
              else
              {
                unsigned int v103 = HIWORD(v101);
                unsigned int v104 = ~HIWORD(v101);
                unint64_t v105 = ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16);
                uint32x4_t v106 = (uint32x4_t)vmulq_s32(v97, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v104)));
                v107.i32[0] = v105;
                v107.i32[1] = WORD1(v105);
                *long long v36 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v107, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v105), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v106, v106, 0x10uLL), v99), 0x10uLL)));
                unsigned int v102 = bswap32(v103+ (((unsigned __int16)v104 * v16 + (((unsigned __int16)v104 * v16) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)long long v33 = v102;
            }
            ++v36;
            v33 += 2 * v274;
            --v100;
          }
          while (v100);
          v36 += v278;
          v33 += 2 * v281;
          --v98;
        }
        while (v98);
        goto LABEL_384;
      case 7:
        if (v6)
        {
          uint64_t v277 = v32;
          int v108 = v287[0];
          do
          {
            int v109 = v280;
            do
            {
              CMYK64_DAM(v36, v33, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v33) >> 16, v16);
              ++v36;
              v33 += 2 * v274;
              --v109;
            }
            while (v109);
            v36 += v278;
            v33 += 2 * v281;
            --v108;
          }
          while (v108);
LABEL_136:
          v287[0] = 0;
          goto LABEL_348;
        }
        int32x4_t v253 = vdupq_n_s32(v29);
        int v254 = v287[0];
        v255.i64[0] = 0x100000001;
        v255.i64[1] = 0x100000001;
        do
        {
          int v256 = v280;
          do
          {
            unsigned int v257 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
            v258.i32[0] = (unsigned __int16)v257;
            v258.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v257), 0x10uLL).i32[1];
            v258.i32[2] = bswap32(v36->u16[2]) >> 16;
            v258.i32[3] = bswap32(v36->u16[3]) >> 16;
            uint32x4_t v259 = (uint32x4_t)vmulq_s32(v258, v253);
            v258.i32[0] = v257;
            *v36++ = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v258, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v259, v259, 0x10uLL), v255), 0x10uLL))));
            v33 += 2 * v274;
            --v256;
          }
          while (v256);
          v36 += v278;
          v33 += 2 * v281;
          --v254;
        }
        while (v254);
        goto LABEL_384;
      case 8:
        if (v6)
        {
          uint64_t v277 = v32;
          int v110 = v287[0];
          do
          {
            int v111 = v280;
            do
            {
              CMYK64_DAM(v36, v33, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v33) >> 16, (unsigned __int16)~(_WORD)v16);
              ++v36;
              v33 += 2 * v274;
              --v111;
            }
            while (v111);
            v36 += v278;
            v33 += 2 * v281;
            --v110;
          }
          while (v110);
LABEL_118:
          v287[0] = 0;
          unsigned __int16 v29 = ~(_WORD)v16;
          LODWORD(v7) = v271;
          goto LABEL_349;
        }
        int32x4_t v260 = vdupq_n_s32(v16);
        int v261 = v287[0];
        v262.i64[0] = 0x100000001;
        v262.i64[1] = 0x100000001;
        do
        {
          int v263 = v280;
          do
          {
            unsigned int v264 = bswap32(v36->u16[1] | (v36->u16[0] << 16));
            v265.i32[0] = (unsigned __int16)v264;
            v265.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v264), 0x10uLL).i32[1];
            v265.i32[2] = bswap32(v36->u16[2]) >> 16;
            v265.i32[3] = bswap32(v36->u16[3]) >> 16;
            uint32x4_t v266 = (uint32x4_t)vmulq_s32(v265, v260);
            v265.i32[0] = v264;
            *v36++ = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v265, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v266, v266, 0x10uLL), v262), 0x10uLL))));
            v33 += 2 * v274;
            --v263;
          }
          while (v263);
          v36 += v278;
          v33 += 2 * v281;
          --v261;
        }
        while (v261);
LABEL_384:
        v287[0] = 0;
        if (!v32) {
          return 1;
        }
        goto LABEL_352;
      case 9:
        uint64_t v277 = v32;
        int v112 = v287[0];
        do
        {
          int v113 = v280;
          do
          {
            unsigned int v114 = bswap32(*(unsigned __int16 *)v33) >> 16;
            CMYK64_DAMplusDAM(v36, v33, v24, v16, v114 ^ 0xFFFF, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v114, v16);
            ++v36;
            v33 += 2 * v274;
            --v113;
          }
          while (v113);
          v36 += v278;
          v33 += 2 * v281;
          --v112;
        }
        while (v112);
        goto LABEL_136;
      case 10:
        uint64_t v277 = v32;
        int v115 = v287[0];
        do
        {
          int v116 = v280;
          do
          {
            unsigned int v117 = bswap32(*(unsigned __int16 *)v33) >> 16;
            CMYK64_DAMplusDAM(v36, v33, v24, v16, v117 ^ 0xFFFF, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v117, (unsigned __int16)~(_WORD)v16);
            ++v36;
            v33 += 2 * v274;
            --v116;
          }
          while (v116);
          v36 += v278;
          v33 += 2 * v281;
          --v115;
        }
        while (v115);
        goto LABEL_118;
      case 11:
        uint64_t v277 = v32;
        int v118 = v287[0];
        uint64_t v119 = 2 * v274;
        if (v6)
        {
          do
          {
            int v120 = v280;
            do
            {
              CMYK64_DAplusdDA((int *)v36, v33, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v33) >> 16, v24, v16);
              ++v36;
              v33 += v119;
              --v120;
            }
            while (v120);
            v36 += v278;
            v33 += 2 * v281;
            --v118;
          }
          while (v118);
        }
        else
        {
          do
          {
            int v121 = v280;
            do
            {
              CMYK64_DplusdDA(v36, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v24, v16);
              ++v36;
              v33 += v119;
              --v121;
            }
            while (v121);
            v36 += v278;
            v33 += 2 * v281;
            --v118;
          }
          while (v118);
        }
        goto LABEL_136;
      case 12:
        uint64_t v277 = v32;
        int v122 = v287[0];
        uint64_t v123 = 2 * v274;
        if (v6)
        {
          do
          {
            int v124 = v280;
            do
            {
              CMYK64_DApluslDA((unsigned int *)v36, v33, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v33) >> 16, v24, v16);
              ++v36;
              v33 += v123;
              --v124;
            }
            while (v124);
            v36 += v278;
            v33 += 2 * v281;
            --v122;
          }
          while (v122);
        }
        else
        {
          do
          {
            int v125 = v280;
            do
            {
              CMYK64_DpluslD(v36, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v24);
              ++v36;
              v33 += v123;
              --v125;
            }
            while (v125);
            v36 += v278;
            v33 += 2 * v281;
            --v122;
          }
          while (v122);
        }
        goto LABEL_136;
      case 13:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v126 = __rev16(v16);
        int v127 = v287[0];
        while (1)
        {
          int v128 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v126;
                goto LABEL_148;
              }
              unsigned int v129 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v129 = 0xFFFF;
            }
            unint64_t v130 = PDAmultiplyPDA_11710(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v129, v24, v16);
            unsigned int v132 = bswap32(v130);
            v36->i16[0] = HIWORD(v132);
            v36->i16[1] = v132;
            v36->i16[2] = bswap32(HIDWORD(v130)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v130));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v131) >> 16;
            }
LABEL_148:
            ++v36;
            v33 += 2 * v274;
            --v128;
          }
          while (v128);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v127) {
            goto LABEL_346;
          }
        }
      case 14:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v133 = __rev16(v16);
        int v134 = v287[0];
        while (1)
        {
          int v135 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v133;
                goto LABEL_162;
              }
              unsigned int v136 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v136 = 0xFFFF;
            }
            unint64_t v137 = PDAscreenPDA_11711(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v136, v24, v16);
            unsigned int v139 = bswap32(v137);
            v36->i16[0] = HIWORD(v139);
            v36->i16[1] = v139;
            v36->i16[2] = bswap32(HIDWORD(v137)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v137));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v138) >> 16;
            }
LABEL_162:
            ++v36;
            v33 += 2 * v274;
            --v135;
          }
          while (v135);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v134) {
            goto LABEL_346;
          }
        }
      case 15:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v140 = __rev16(v16);
        int v141 = v287[0];
        while (1)
        {
          int v142 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v140;
                goto LABEL_176;
              }
              unsigned int v143 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v143 = 0xFFFF;
            }
            unint64_t v144 = PDAoverlayPDA_11712(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v143, v24, v16);
            unsigned int v146 = bswap32(v144);
            v36->i16[0] = HIWORD(v146);
            v36->i16[1] = v146;
            v36->i16[2] = bswap32(HIDWORD(v144)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v144));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v145) >> 16;
            }
LABEL_176:
            ++v36;
            v33 += 2 * v274;
            --v142;
          }
          while (v142);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v141) {
            goto LABEL_346;
          }
        }
      case 16:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v147 = __rev16(v16);
        int v148 = v287[0];
        while (1)
        {
          int v149 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v147;
                goto LABEL_190;
              }
              unsigned int v150 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v150 = 0xFFFF;
            }
            unint64_t v151 = PDAdarkenPDA_11714(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v150, v24, v16);
            unsigned int v153 = bswap32(v151);
            v36->i16[0] = HIWORD(v153);
            v36->i16[1] = v153;
            v36->i16[2] = bswap32(HIDWORD(v151)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v151));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v152) >> 16;
            }
LABEL_190:
            ++v36;
            v33 += 2 * v274;
            --v149;
          }
          while (v149);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v148) {
            goto LABEL_346;
          }
        }
      case 17:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v154 = __rev16(v16);
        int v155 = v287[0];
        while (1)
        {
          int v156 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v154;
                goto LABEL_204;
              }
              unsigned int v157 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v157 = 0xFFFF;
            }
            unint64_t v158 = PDAlightenPDA_11713(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v157, v24, v16);
            unsigned int v160 = bswap32(v158);
            v36->i16[0] = HIWORD(v160);
            v36->i16[1] = v160;
            v36->i16[2] = bswap32(HIDWORD(v158)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v158));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v159) >> 16;
            }
LABEL_204:
            ++v36;
            v33 += 2 * v274;
            --v156;
          }
          while (v156);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v155) {
            goto LABEL_346;
          }
        }
      case 18:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v161 = __rev16(v16);
        int v162 = v287[0];
        while (1)
        {
          int v163 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v161;
                goto LABEL_218;
              }
              unsigned int v164 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v164 = 0xFFFF;
            }
            unint64_t v165 = PDAcolordodgePDA_11715(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v164, v24, v16);
            unsigned int v167 = bswap32(v165);
            v36->i16[0] = HIWORD(v167);
            v36->i16[1] = v167;
            v36->i16[2] = bswap32(HIDWORD(v165)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v165));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v166) >> 16;
            }
LABEL_218:
            ++v36;
            v33 += 2 * v274;
            --v163;
          }
          while (v163);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v162) {
            goto LABEL_346;
          }
        }
      case 19:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v168 = __rev16(v16);
        int v169 = v287[0];
        while (1)
        {
          int v170 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v168;
                goto LABEL_232;
              }
              unsigned int v171 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v171 = 0xFFFF;
            }
            unint64_t v172 = PDAcolorburnPDA_11716(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v171, v24, v16);
            unsigned int v174 = bswap32(v172);
            v36->i16[0] = HIWORD(v174);
            v36->i16[1] = v174;
            v36->i16[2] = bswap32(HIDWORD(v172)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v172));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v173) >> 16;
            }
LABEL_232:
            ++v36;
            v33 += 2 * v274;
            --v170;
          }
          while (v170);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v169) {
            goto LABEL_346;
          }
        }
      case 20:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v175 = __rev16(v16);
        int v176 = v287[0];
        while (1)
        {
          int v177 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v175;
                goto LABEL_246;
              }
              unsigned int v178 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v178 = 0xFFFF;
            }
            unint64_t v179 = PDAsoftlightPDA_11718(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v178, v24, v16);
            unsigned int v181 = bswap32(v179);
            v36->i16[0] = HIWORD(v181);
            v36->i16[1] = v181;
            v36->i16[2] = bswap32(HIDWORD(v179)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v179));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v180) >> 16;
            }
LABEL_246:
            ++v36;
            v33 += 2 * v274;
            --v177;
          }
          while (v177);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v176) {
            goto LABEL_346;
          }
        }
      case 21:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v182 = __rev16(v16);
        int v183 = v287[0];
        while (1)
        {
          int v184 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v182;
                goto LABEL_260;
              }
              unsigned int v185 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v185 = 0xFFFF;
            }
            unint64_t v186 = PDAhardlightPDA_11717(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v185, v24, v16);
            unsigned int v188 = bswap32(v186);
            v36->i16[0] = HIWORD(v188);
            v36->i16[1] = v188;
            v36->i16[2] = bswap32(HIDWORD(v186)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v186));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v187) >> 16;
            }
LABEL_260:
            ++v36;
            v33 += 2 * v274;
            --v184;
          }
          while (v184);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v183) {
            goto LABEL_346;
          }
        }
      case 22:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v189 = __rev16(v16);
        int v190 = v287[0];
        while (1)
        {
          int v191 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v189;
                goto LABEL_274;
              }
              unsigned int v192 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v192 = 0xFFFF;
            }
            unint64_t v193 = PDAdifferencePDA_11719(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v192, v24, v16);
            unsigned int v195 = bswap32(v193);
            v36->i16[0] = HIWORD(v195);
            v36->i16[1] = v195;
            v36->i16[2] = bswap32(HIDWORD(v193)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v193));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v194) >> 16;
            }
LABEL_274:
            ++v36;
            v33 += 2 * v274;
            --v191;
          }
          while (v191);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v190) {
            goto LABEL_346;
          }
        }
      case 23:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v196 = __rev16(v16);
        int v197 = v287[0];
        while (1)
        {
          int v198 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v196;
                goto LABEL_288;
              }
              unsigned int v199 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v199 = 0xFFFF;
            }
            unint64_t v200 = PDAexclusionPDA_11720(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v199, v24, v16);
            unsigned int v202 = bswap32(v200);
            v36->i16[0] = HIWORD(v202);
            v36->i16[1] = v202;
            v36->i16[2] = bswap32(HIDWORD(v200)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v200));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v201) >> 16;
            }
LABEL_288:
            ++v36;
            v33 += 2 * v274;
            --v198;
          }
          while (v198);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v197) {
            goto LABEL_346;
          }
        }
      case 24:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v203 = __rev16(v16);
        int v204 = v287[0];
        while (1)
        {
          int v205 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v203;
                goto LABEL_302;
              }
              unsigned int v206 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v206 = 0xFFFF;
            }
            unint64_t v207 = PDAhuePDA_11721(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v206, v24, v16);
            unsigned int v209 = bswap32(v207);
            v36->i16[0] = HIWORD(v209);
            v36->i16[1] = v209;
            v36->i16[2] = bswap32(HIDWORD(v207)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v207));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v208) >> 16;
            }
LABEL_302:
            ++v36;
            v33 += 2 * v274;
            --v205;
          }
          while (v205);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v204) {
            goto LABEL_346;
          }
        }
      case 25:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v210 = __rev16(v16);
        int v211 = v287[0];
        while (1)
        {
          int v212 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v210;
                goto LABEL_316;
              }
              unsigned int v213 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v213 = 0xFFFF;
            }
            unint64_t v214 = PDAsaturationPDA_11722(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v213, v24, v16);
            unsigned int v216 = bswap32(v214);
            v36->i16[0] = HIWORD(v216);
            v36->i16[1] = v216;
            v36->i16[2] = bswap32(HIDWORD(v214)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v214));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v215) >> 16;
            }
LABEL_316:
            ++v36;
            v33 += 2 * v274;
            --v212;
          }
          while (v212);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v211) {
            goto LABEL_346;
          }
        }
      case 26:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v217 = __rev16(v16);
        int v218 = v287[0];
        while (1)
        {
          int v219 = v280;
          do
          {
            if (v6)
            {
              if (!*(_WORD *)v33)
              {
                v36->i16[0] = v285;
                v36->i16[1] = v284;
                v36->i16[2] = v283;
                v36->i16[3] = v282;
                *(_WORD *)long long v33 = v217;
                goto LABEL_330;
              }
              unsigned int v220 = __rev16(*(unsigned __int16 *)v33);
            }
            else
            {
              unsigned int v220 = 0xFFFF;
            }
            unint64_t v221 = PDAluminosityPDA_11723(v24, v16, ((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v220);
            unsigned int v223 = bswap32(v221);
            v36->i16[0] = HIWORD(v223);
            v36->i16[1] = v223;
            v36->i16[2] = bswap32(HIDWORD(v221)) >> 16;
            v36->i16[3] = __rev16(HIWORD(v221));
            if (v6) {
              *(_WORD *)long long v33 = bswap32(v222) >> 16;
            }
LABEL_330:
            ++v36;
            v33 += 2 * v274;
            --v219;
          }
          while (v219);
          v36 += v278;
          v33 += 2 * v281;
          if (!--v218) {
            goto LABEL_346;
          }
        }
      case 27:
        if (!v16) {
          goto LABEL_351;
        }
        uint64_t v277 = v32;
        __int16 v224 = __rev16(v16);
        int v225 = v287[0];
        break;
      default:
        goto LABEL_351;
    }
    do
    {
      int v226 = v280;
      do
      {
        if (v6)
        {
          if (!*(_WORD *)v33)
          {
            v36->i16[0] = v285;
            v36->i16[1] = v284;
            v36->i16[2] = v283;
            v36->i16[3] = v282;
            *(_WORD *)long long v33 = v224;
            goto LABEL_344;
          }
          unsigned int v227 = __rev16(*(unsigned __int16 *)v33);
        }
        else
        {
          unsigned int v227 = 0xFFFF;
        }
        unint64_t v228 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v36->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36->u16[3]) >> 16) << 48) | bswap32(v36->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v36->u16[0]) >> 16), v227, v24, v16);
        unsigned int v230 = bswap32(v228);
        v36->i16[0] = HIWORD(v230);
        v36->i16[1] = v230;
        v36->i16[2] = bswap32(HIDWORD(v228)) >> 16;
        v36->i16[3] = __rev16(HIWORD(v228));
        if (v6) {
          *(_WORD *)long long v33 = bswap32(v229) >> 16;
        }
LABEL_344:
        ++v36;
        v33 += 2 * v274;
        --v226;
      }
      while (v226);
      v36 += v278;
      v33 += 2 * v281;
      --v225;
    }
    while (v225);
LABEL_346:
    v287[0] = 0;
LABEL_347:
    unint64_t v26 = v272;
LABEL_348:
    unsigned __int16 v29 = ~(_WORD)v16;
LABEL_349:
    uint64_t v30 = v273;
LABEL_350:
    uint64_t v32 = v277;
LABEL_351:
    if (!v32) {
      return 1;
    }
LABEL_352:
    uint64_t v286 = 0;
LABEL_36:
    if (shape_enum_clip_next(v32, (int *)&v286 + 1, &v286, v297, v287))
    {
      long long v36 = (int8x8_t *)(v30 + 8 * v26 * (int)v286 + 8 * SHIDWORD(v286));
      uint64_t v35 = v297[0];
      unint64_t v44 = v281;
      if (v6)
      {
        unint64_t v44 = v276 - v297[0];
        long long v33 = &v275[2 * v276 * (int)v286 + 2 * SHIDWORD(v286)];
      }
      int v280 = v297[0];
      unint64_t v281 = v44;
      continue;
    }
    break;
  }
  long long v43 = (void *)v32;
LABEL_354:
  free(v43);
  return 1;
}

uint64_t CMYK64_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, int32x4_t a10)
{
  if (*(void *)(a1 + 40)) {
    int v10 = 0;
  }
  else {
    int v10 = 255;
  }
  int v11 = (int8x8_t *)*((void *)a2 + 2);
  uint64_t v12 = (_WORD *)*((void *)a2 + 4);
  if (v12) {
    uint64_t v159 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v159 = 0;
  }
  int v13 = *((unsigned __int16 *)a2 + 4);
  int v14 = a2[1];
  int v158 = *a2;
  uint64_t v157 = *((void *)a2 + 3) - a5;
  uint64_t v16 = *((void *)a2 + 17);
  uint64_t v15 = *((void *)a2 + 18);
  uint64_t v17 = *((void *)a2 + 9);
  uint64_t v154 = *((void *)a2 + 11);
  uint64_t v18 = *((void *)a2 + 7) + v154 * a4;
  unsigned int v19 = *(unsigned int **)(a1 + 32);
  size_t v20 = (char *)v19
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v21 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v12 != 0);
  char v155 = v17;
  uint64_t v156 = v16;
  if (v21)
  {
    uint64_t v151 = *((void *)a2 + 15);
    uint64_t v152 = *((void *)a2 + 13);
    uint64_t v150 = ~(-1 << v17);
    uint64_t v148 = -v16;
    char v149 = v17 - 4;
    int v23 = (unsigned int *)(v20 - 4);
    int v24 = v13 ^ 0xFFFF;
    int32x4_t v25 = vdupq_n_s32(v13 ^ 0xFFFFu);
    uint64_t v146 = v15 + 16 * a3 + 8;
    uint64_t v147 = a5;
    v26.i64[0] = 0x100000001;
    v26.i64[1] = 0x100000001;
    while (1)
    {
      if (((v151 - v18) | (v18 - v152)) < 0)
      {
        int v29 = 0;
        uint64_t v28 = 0;
      }
      else
      {
        uint64_t v27 = ((v18 & (unint64_t)v150) >> v149) & 0xF;
        uint64_t v28 = (unint64_t)(v27 - 7) >= 9 ? v148 : v16;
        int v29 = weights_21383[v27] & 0xF;
      }
      uint64_t v30 = (char *)v19 + (v18 >> v17) * v16;
      if (v158 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v31 = (uint64_t *)v146;
        uint64_t v32 = v147;
        while (1)
        {
          uint64_t v33 = *(v31 - 1);
          uint64_t v34 = *v31;
          uint64_t v35 = &v30[v33];
          if (v23 >= (unsigned int *)&v30[v33]) {
            long long v36 = (unsigned int *)&v30[v33];
          }
          else {
            long long v36 = v23;
          }
          if (v36 < v19) {
            long long v36 = v19;
          }
          unsigned int v37 = *v36;
          char v38 = v34 & 0xF;
          if ((v34 & 0xF) != 0) {
            break;
          }
          if (v29)
          {
            uint64_t v49 = (unsigned int *)&v35[v28];
            if (v23 < (unsigned int *)&v35[v28]) {
              uint64_t v49 = v23;
            }
            if (v49 < v19) {
              uint64_t v49 = v19;
            }
            int v50 = BLEND8_21385[v29];
            unsigned int v47 = v37 - ((v50 & v37) >> v29);
            unsigned int v48 = (v50 & *v49) >> v29;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v51 = __ROL4__(v37, v14);
          HIDWORD(v53) = HIBYTE(v51);
          LODWORD(v53) = v51;
          unsigned int v52 = v53 >> 24;
          unsigned int v54 = BYTE2(v51) | (BYTE2(v51) << 8);
          unsigned int v55 = BYTE1(v51) | (BYTE1(v51) << 8);
          unsigned int v56 = v51 | v10 | ((v51 | v10) << 8);
          if (v52 <= v54) {
            unsigned __int32 v57 = v54;
          }
          else {
            unsigned __int32 v57 = v52;
          }
          if (v55 > v57) {
            unsigned __int32 v57 = v55;
          }
          a10.i64[0] = __PAIR64__(v56, v57);
          int32x4_t v58 = vzip1q_s32(a10, a10);
          v58.i32[2] = v57;
          v59.i64[0] = __PAIR64__(v54, v52);
          v59.i64[1] = __PAIR64__(v57, v55);
          a10 = vsubq_s32(v58, v59);
          if (v13 != 0xFFFF)
          {
            int8x16_t v60 = (int8x16_t)vmulq_s32(a10, v25);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x10uLL), (int32x4_t)vmvnq_s8(v60)), 0x10uLL));
            v56 -= (v56 * v24 + ((v56 * v24) >> 16) + 1) >> 16;
          }
          *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12) {
            *uint64_t v12 = bswap32(v56) >> 16;
          }
          v31 += 2;
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          if (!--v32) {
            goto LABEL_107;
          }
        }
        long long v39 = (unsigned int *)&v35[v34 >> 4];
        if (v23 < v39) {
          long long v39 = v23;
        }
        if (v39 < v19) {
          long long v39 = v19;
        }
        unsigned int v40 = *v39;
        if (v29)
        {
          long long v41 = (unsigned int *)&v35[v28];
          if (v23 >= v41) {
            long long v42 = v41;
          }
          else {
            long long v42 = v23;
          }
          if (v42 < v19) {
            long long v42 = v19;
          }
          unsigned int v43 = *v42;
          unint64_t v44 = (unsigned int *)((char *)v41 + (v34 >> 4));
          if (v23 < v44) {
            unint64_t v44 = v23;
          }
          if (v44 < v19) {
            unint64_t v44 = v19;
          }
          int v45 = BLEND8_21385[v29];
          unsigned int v37 = v37 - ((v45 & v37) >> v29) + ((v45 & v43) >> v29);
          unsigned int v40 = v40 - ((v45 & v40) >> v29) + ((v45 & *v44) >> v29);
        }
        int v46 = BLEND8_21385[*v31 & 0xF];
        unsigned int v47 = v37 - ((v46 & v37) >> v38);
        unsigned int v48 = (v46 & v40) >> v38;
LABEL_46:
        unsigned int v37 = v47 + v48;
        goto LABEL_47;
      }
LABEL_107:
      uint64_t v16 = v156;
      v11 += v157;
      LOBYTE(v17) = v155;
      v18 += v154;
      v12 += v159;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_107;
    }
    int v62 = (uint64_t *)v146;
    uint64_t v61 = v147;
    while (1)
    {
      uint64_t v63 = *(v62 - 1);
      uint64_t v64 = *v62;
      int v65 = &v30[v63];
      if (v23 >= (unsigned int *)&v30[v63]) {
        unsigned int v66 = (unsigned int *)&v30[v63];
      }
      else {
        unsigned int v66 = v23;
      }
      if (v66 < v19) {
        unsigned int v66 = v19;
      }
      unsigned int v67 = *v66;
      char v68 = v64 & 0xF;
      if ((v64 & 0xF) != 0) {
        break;
      }
      if (v29)
      {
        uint32x4_t v79 = (unsigned int *)&v65[v28];
        if (v23 < (unsigned int *)&v65[v28]) {
          uint32x4_t v79 = v23;
        }
        if (v79 < v19) {
          uint32x4_t v79 = v19;
        }
        int v80 = BLEND8_21385[v29];
        unsigned int v77 = v67 - ((v80 & v67) >> v29);
        unsigned int v78 = (v80 & *v79) >> v29;
        goto LABEL_88;
      }
LABEL_89:
      unsigned int v81 = __ROL4__(v67, v14);
      HIDWORD(v83) = HIBYTE(v81);
      LODWORD(v83) = v81;
      unsigned int v82 = v83 >> 24;
      unsigned int v84 = BYTE2(v81) | (BYTE2(v81) << 8);
      unsigned int v85 = BYTE1(v81) | (BYTE1(v81) << 8);
      int v86 = v81 | v10 | ((v81 | v10) << 8);
      if (v82 <= v84) {
        unsigned __int32 v87 = v84;
      }
      else {
        unsigned __int32 v87 = v82;
      }
      if (v85 > v87) {
        unsigned __int32 v87 = v85;
      }
      a10.i64[0] = __PAIR64__(v86, v87);
      int32x4_t v88 = vzip1q_s32(a10, a10);
      v88.i32[2] = v87;
      v89.i64[0] = __PAIR64__(v84, v82);
      v89.i64[1] = __PAIR64__(v87, v85);
      a10 = vsubq_s32(v88, v89);
      if (v13 != 0xFFFF)
      {
        int8x16_t v90 = (int8x16_t)vmulq_s32(a10, v25);
        a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x10uLL), (int32x4_t)vmvnq_s8(v90)), 0x10uLL));
        v86 -= (v86 * v24 + ((v86 * v24) >> 16) + 1) >> 16;
      }
      unsigned __int32 v91 = a10.u32[1];
      uint64_t v92 = a10.u16[0] | (a10.u16[2] << 16);
      unint64_t v93 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v92;
      if (v12)
      {
        if ((_WORD)v86)
        {
          if ((unsigned __int16)v86 == 0xFFFF)
          {
            *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
            *uint64_t v12 = -1;
          }
          else
          {
            unsigned int v94 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
            unsigned int v95 = bswap32((unsigned __int16)*v12);
            v96.i32[0] = (unsigned __int16)v94;
            v96.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v94), 0x10uLL).i32[1];
            a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_1850CDC40);
            v96.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
            uint32x4_t v97 = (uint32x4_t)vmulq_s32(v96, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
            *int v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v97, v97, 0x10uLL), v26), 0x10uLL)));
            *uint64_t v12 = bswap32(v86+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)) >> 16)+ 1) >> 16)) >> 16;
          }
        }
      }
      else if ((_WORD)v86)
      {
        if ((unsigned __int16)v86 == 0xFFFF)
        {
          *(int16x4_t *)a10.i8 = vmovn_s32(a10);
        }
        else
        {
          unsigned int v98 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
          v99.i32[0] = (unsigned __int16)v98;
          v99.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v98), 0x10uLL).i32[1];
          a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_1850CDC40);
          v99.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
          uint32x4_t v100 = (uint32x4_t)vmulq_s32(v99, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
          *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v100, v100, 0x10uLL), v26), 0x10uLL));
        }
        *int v11 = vrev16_s8(*(int8x8_t *)a10.i8);
      }
      v62 += 2;
      ++v11;
      uint64_t v12 = (_WORD *)((char *)v12 + result);
      if (!--v61) {
        goto LABEL_107;
      }
    }
    int32x4_t v69 = (unsigned int *)&v65[v64 >> 4];
    if (v23 < v69) {
      int32x4_t v69 = v23;
    }
    if (v69 < v19) {
      int32x4_t v69 = v19;
    }
    unsigned int v70 = *v69;
    if (v29)
    {
      unsigned int v71 = &v65[v28];
      if (v23 >= (unsigned int *)&v65[v28]) {
        unsigned int v72 = (unsigned int *)&v65[v28];
      }
      else {
        unsigned int v72 = v23;
      }
      if (v72 < v19) {
        unsigned int v72 = v19;
      }
      unsigned int v73 = *v72;
      unsigned int v74 = (unsigned int *)&v71[v64 >> 4];
      if (v23 < v74) {
        unsigned int v74 = v23;
      }
      if (v74 < v19) {
        unsigned int v74 = v19;
      }
      int v75 = BLEND8_21385[v29];
      unsigned int v67 = v67 - ((v75 & v67) >> v29) + ((v75 & v73) >> v29);
      unsigned int v70 = v70 - ((v75 & v70) >> v29) + ((v75 & *v74) >> v29);
    }
    int v76 = BLEND8_21385[*v62 & 0xF];
    unsigned int v77 = v67 - ((v76 & v67) >> v68);
    unsigned int v78 = (v76 & v70) >> v68;
LABEL_88:
    unsigned int v67 = v77 + v78;
    goto LABEL_89;
  }
  unsigned int v101 = (uint64_t *)(v15 + 16 * a3);
  unsigned int v102 = v20 - 4;
  int v103 = v13 ^ 0xFFFF;
  int32x4_t v104 = vdupq_n_s32(v13 ^ 0xFFFFu);
  v105.i64[0] = 0x100000001;
  v105.i64[1] = 0x100000001;
  uint64_t v106 = a5;
  do
  {
    int32x2_t v107 = (char *)v19 + (v18 >> v17) * v16;
    if (v158 == 1)
    {
      if (a5 >= 1)
      {
        int v108 = v101;
        uint64_t v109 = v106;
        do
        {
          uint64_t v110 = *v108;
          v108 += 2;
          int v111 = (unsigned int *)&v107[v110];
          if (v102 < &v107[v110]) {
            int v111 = (unsigned int *)v102;
          }
          if (v111 < v19) {
            int v111 = v19;
          }
          unsigned int v112 = __ROL4__(*v111, v14);
          HIDWORD(v114) = HIBYTE(v112);
          LODWORD(v114) = v112;
          unsigned int v113 = v114 >> 24;
          unsigned int v115 = BYTE2(v112) | (BYTE2(v112) << 8);
          unsigned int v116 = BYTE1(v112) | (BYTE1(v112) << 8);
          unsigned int v117 = v112 | v10 | ((v112 | v10) << 8);
          if (v113 <= v115) {
            unsigned __int32 v118 = v115;
          }
          else {
            unsigned __int32 v118 = v113;
          }
          if (v116 > v118) {
            unsigned __int32 v118 = v116;
          }
          a10.i64[0] = __PAIR64__(v117, v118);
          int32x4_t v119 = vzip1q_s32(a10, a10);
          v119.i32[2] = v118;
          v120.i64[0] = __PAIR64__(v115, v113);
          v120.i64[1] = __PAIR64__(v118, v116);
          a10 = vsubq_s32(v119, v120);
          if (v13 != 0xFFFF)
          {
            int8x16_t v121 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x10uLL), (int32x4_t)vmvnq_s8(v121)), 0x10uLL));
            v117 -= (v117 * v103 + ((v117 * v103) >> 16) + 1) >> 16;
          }
          *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12) {
            *uint64_t v12 = bswap32(v117) >> 16;
          }
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          --v109;
        }
        while (v109);
      }
    }
    else
    {
      int v122 = v101;
      uint64_t v123 = v106;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v124 = *v122;
          v122 += 2;
          int v125 = (unsigned int *)&v107[v124];
          if (v102 < &v107[v124]) {
            int v125 = (unsigned int *)v102;
          }
          if (v125 < v19) {
            int v125 = v19;
          }
          unsigned int v126 = __ROL4__(*v125, v14);
          HIDWORD(v128) = HIBYTE(v126);
          LODWORD(v128) = v126;
          unsigned int v127 = v128 >> 24;
          unsigned int v129 = BYTE2(v126) | (BYTE2(v126) << 8);
          unsigned int v130 = BYTE1(v126) | (BYTE1(v126) << 8);
          int v131 = v126 | v10 | ((v126 | v10) << 8);
          if (v127 <= v129) {
            unsigned __int32 v132 = v129;
          }
          else {
            unsigned __int32 v132 = v127;
          }
          if (v130 > v132) {
            unsigned __int32 v132 = v130;
          }
          a10.i64[0] = __PAIR64__(v131, v132);
          int32x4_t v133 = vzip1q_s32(a10, a10);
          v133.i32[2] = v132;
          v134.i64[0] = __PAIR64__(v129, v127);
          v134.i64[1] = __PAIR64__(v132, v130);
          a10 = vsubq_s32(v133, v134);
          if (v13 != 0xFFFF)
          {
            int8x16_t v135 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v135, 0x10uLL), (int32x4_t)vmvnq_s8(v135)), 0x10uLL));
            v131 -= (v131 * v103 + ((v131 * v103) >> 16) + 1) >> 16;
          }
          unsigned __int32 v136 = a10.u32[1];
          uint64_t v137 = a10.u16[0] | (a10.u16[2] << 16);
          unint64_t v138 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v137;
          if (v12)
          {
            if ((_WORD)v131)
            {
              if ((unsigned __int16)v131 == 0xFFFF)
              {
                *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
                *uint64_t v12 = -1;
              }
              else
              {
                unsigned int v139 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
                unsigned int v140 = bswap32((unsigned __int16)*v12);
                v141.i32[0] = (unsigned __int16)v139;
                v141.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v139), 0x10uLL).i32[1];
                a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_1850CDC40);
                v141.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
                uint32x4_t v142 = (uint32x4_t)vmulq_s32(v141, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
                *int v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v142, v142, 0x10uLL), v105), 0x10uLL)));
                *uint64_t v12 = bswap32(v131+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)) >> 16)+ 1) >> 16)) >> 16;
              }
            }
          }
          else if ((_WORD)v131)
          {
            if ((unsigned __int16)v131 == 0xFFFF)
            {
              *(int16x4_t *)a10.i8 = vmovn_s32(a10);
            }
            else
            {
              unsigned int v143 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
              v144.i32[0] = (unsigned __int16)v143;
              v144.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v143), 0x10uLL).i32[1];
              a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_1850CDC40);
              v144.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
              uint32x4_t v145 = (uint32x4_t)vmulq_s32(v144, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
              *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v145, v145, 0x10uLL), v105), 0x10uLL));
            }
            *int v11 = vrev16_s8(*(int8x8_t *)a10.i8);
          }
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          --v123;
        }
        while (v123);
      }
    }
    uint64_t v16 = v156;
    v11 += v157;
    LOBYTE(v17) = v155;
    v18 += v154;
    v12 += v159;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t CMYK64_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, int32x4_t a10)
{
  if (*(void *)(a1 + 40)) {
    int v10 = 0;
  }
  else {
    int v10 = 255;
  }
  int v11 = (int8x8_t *)*((void *)a2 + 2);
  uint64_t v12 = (_WORD *)*((void *)a2 + 4);
  if (v12) {
    uint64_t v159 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v159 = 0;
  }
  int v13 = *((unsigned __int16 *)a2 + 4);
  int v14 = a2[1];
  int v158 = *a2;
  uint64_t v157 = *((void *)a2 + 3) - a5;
  uint64_t v16 = *((void *)a2 + 17);
  uint64_t v15 = *((void *)a2 + 18);
  uint64_t v17 = *((void *)a2 + 9);
  uint64_t v154 = *((void *)a2 + 11);
  uint64_t v18 = *((void *)a2 + 7) + v154 * a4;
  unsigned int v19 = *(unsigned int **)(a1 + 32);
  size_t v20 = (char *)v19
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v21 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v12 != 0);
  char v155 = v17;
  uint64_t v156 = v16;
  if (v21)
  {
    uint64_t v151 = *((void *)a2 + 15);
    uint64_t v152 = *((void *)a2 + 13);
    uint64_t v150 = ~(-1 << v17);
    uint64_t v148 = -v16;
    char v149 = v17 - 4;
    int v23 = (unsigned int *)(v20 - 4);
    int v24 = v13 ^ 0xFFFF;
    int32x4_t v25 = vdupq_n_s32(v13 ^ 0xFFFFu);
    uint64_t v146 = v15 + 16 * a3 + 8;
    uint64_t v147 = a5;
    v26.i64[0] = 0x100000001;
    v26.i64[1] = 0x100000001;
    while (1)
    {
      if (((v151 - v18) | (v18 - v152)) < 0)
      {
        int v29 = 0;
        uint64_t v28 = 0;
      }
      else
      {
        uint64_t v27 = ((v18 & (unint64_t)v150) >> v149) & 0xF;
        uint64_t v28 = (unint64_t)(v27 - 7) >= 9 ? v148 : v16;
        int v29 = weights_21383[v27] & 0xF;
      }
      uint64_t v30 = (char *)v19 + (v18 >> v17) * v16;
      if (v158 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v31 = (uint64_t *)v146;
        uint64_t v32 = v147;
        while (1)
        {
          uint64_t v33 = *(v31 - 1);
          uint64_t v34 = *v31;
          uint64_t v35 = &v30[v33];
          if (v23 >= (unsigned int *)&v30[v33]) {
            long long v36 = (unsigned int *)&v30[v33];
          }
          else {
            long long v36 = v23;
          }
          if (v36 < v19) {
            long long v36 = v19;
          }
          unsigned int v37 = bswap32(*v36);
          char v38 = v34 & 0xF;
          if ((v34 & 0xF) != 0) {
            break;
          }
          if (v29)
          {
            uint64_t v49 = (unsigned int *)&v35[v28];
            if (v23 < (unsigned int *)&v35[v28]) {
              uint64_t v49 = v23;
            }
            if (v49 < v19) {
              uint64_t v49 = v19;
            }
            int v50 = BLEND8_21385[v29];
            unsigned int v47 = v37 - ((v50 & v37) >> v29);
            unsigned int v48 = (bswap32(*v49) & v50) >> v29;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v51 = __ROL4__(v37, v14);
          HIDWORD(v53) = HIBYTE(v51);
          LODWORD(v53) = v51;
          unsigned int v52 = v53 >> 24;
          unsigned int v54 = BYTE2(v51) | (BYTE2(v51) << 8);
          unsigned int v55 = BYTE1(v51) | (BYTE1(v51) << 8);
          unsigned int v56 = v51 | v10 | ((v51 | v10) << 8);
          if (v52 <= v54) {
            unsigned __int32 v57 = v54;
          }
          else {
            unsigned __int32 v57 = v52;
          }
          if (v55 > v57) {
            unsigned __int32 v57 = v55;
          }
          a10.i64[0] = __PAIR64__(v56, v57);
          int32x4_t v58 = vzip1q_s32(a10, a10);
          v58.i32[2] = v57;
          v59.i64[0] = __PAIR64__(v54, v52);
          v59.i64[1] = __PAIR64__(v57, v55);
          a10 = vsubq_s32(v58, v59);
          if (v13 != 0xFFFF)
          {
            int8x16_t v60 = (int8x16_t)vmulq_s32(a10, v25);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v60, 0x10uLL), (int32x4_t)vmvnq_s8(v60)), 0x10uLL));
            v56 -= (v56 * v24 + ((v56 * v24) >> 16) + 1) >> 16;
          }
          *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12) {
            *uint64_t v12 = bswap32(v56) >> 16;
          }
          v31 += 2;
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          if (!--v32) {
            goto LABEL_107;
          }
        }
        long long v39 = (unsigned int *)&v35[v34 >> 4];
        if (v23 < v39) {
          long long v39 = v23;
        }
        if (v39 < v19) {
          long long v39 = v19;
        }
        unsigned int v40 = bswap32(*v39);
        if (v29)
        {
          long long v41 = (unsigned int *)&v35[v28];
          if (v23 >= v41) {
            long long v42 = v41;
          }
          else {
            long long v42 = v23;
          }
          if (v42 < v19) {
            long long v42 = v19;
          }
          unsigned int v43 = bswap32(*v42);
          unint64_t v44 = (unsigned int *)((char *)v41 + (v34 >> 4));
          if (v23 < v44) {
            unint64_t v44 = v23;
          }
          if (v44 < v19) {
            unint64_t v44 = v19;
          }
          int v45 = BLEND8_21385[v29];
          unsigned int v37 = v37 - ((v45 & v37) >> v29) + ((v45 & v43) >> v29);
          unsigned int v40 = v40 - ((v45 & v40) >> v29) + ((bswap32(*v44) & v45) >> v29);
        }
        int v46 = BLEND8_21385[*v31 & 0xF];
        unsigned int v47 = v37 - ((v46 & v37) >> v38);
        unsigned int v48 = (v46 & v40) >> v38;
LABEL_46:
        unsigned int v37 = v47 + v48;
        goto LABEL_47;
      }
LABEL_107:
      uint64_t v16 = v156;
      v11 += v157;
      LOBYTE(v17) = v155;
      v18 += v154;
      v12 += v159;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_107;
    }
    int v62 = (uint64_t *)v146;
    uint64_t v61 = v147;
    while (1)
    {
      uint64_t v63 = *(v62 - 1);
      uint64_t v64 = *v62;
      int v65 = &v30[v63];
      if (v23 >= (unsigned int *)&v30[v63]) {
        unsigned int v66 = (unsigned int *)&v30[v63];
      }
      else {
        unsigned int v66 = v23;
      }
      if (v66 < v19) {
        unsigned int v66 = v19;
      }
      unsigned int v67 = bswap32(*v66);
      char v68 = v64 & 0xF;
      if ((v64 & 0xF) != 0) {
        break;
      }
      if (v29)
      {
        uint32x4_t v79 = (unsigned int *)&v65[v28];
        if (v23 < (unsigned int *)&v65[v28]) {
          uint32x4_t v79 = v23;
        }
        if (v79 < v19) {
          uint32x4_t v79 = v19;
        }
        int v80 = BLEND8_21385[v29];
        unsigned int v77 = v67 - ((v80 & v67) >> v29);
        unsigned int v78 = (bswap32(*v79) & v80) >> v29;
        goto LABEL_88;
      }
LABEL_89:
      unsigned int v81 = __ROL4__(v67, v14);
      HIDWORD(v83) = HIBYTE(v81);
      LODWORD(v83) = v81;
      unsigned int v82 = v83 >> 24;
      unsigned int v84 = BYTE2(v81) | (BYTE2(v81) << 8);
      unsigned int v85 = BYTE1(v81) | (BYTE1(v81) << 8);
      int v86 = v81 | v10 | ((v81 | v10) << 8);
      if (v82 <= v84) {
        unsigned __int32 v87 = v84;
      }
      else {
        unsigned __int32 v87 = v82;
      }
      if (v85 > v87) {
        unsigned __int32 v87 = v85;
      }
      a10.i64[0] = __PAIR64__(v86, v87);
      int32x4_t v88 = vzip1q_s32(a10, a10);
      v88.i32[2] = v87;
      v89.i64[0] = __PAIR64__(v84, v82);
      v89.i64[1] = __PAIR64__(v87, v85);
      a10 = vsubq_s32(v88, v89);
      if (v13 != 0xFFFF)
      {
        int8x16_t v90 = (int8x16_t)vmulq_s32(a10, v25);
        a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v90, 0x10uLL), (int32x4_t)vmvnq_s8(v90)), 0x10uLL));
        v86 -= (v86 * v24 + ((v86 * v24) >> 16) + 1) >> 16;
      }
      unsigned __int32 v91 = a10.u32[1];
      uint64_t v92 = a10.u16[0] | (a10.u16[2] << 16);
      unint64_t v93 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v92;
      if (v12)
      {
        if ((_WORD)v86)
        {
          if ((unsigned __int16)v86 == 0xFFFF)
          {
            *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
            *uint64_t v12 = -1;
          }
          else
          {
            unsigned int v94 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
            unsigned int v95 = bswap32((unsigned __int16)*v12);
            v96.i32[0] = (unsigned __int16)v94;
            v96.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v94), 0x10uLL).i32[1];
            a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_1850CDC40);
            v96.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
            uint32x4_t v97 = (uint32x4_t)vmulq_s32(v96, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
            *int v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v97, v97, 0x10uLL), v26), 0x10uLL)));
            *uint64_t v12 = bswap32(v86+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)+ (((unsigned __int16)~(_WORD)v86 * HIWORD(v95)) >> 16)+ 1) >> 16)) >> 16;
          }
        }
      }
      else if ((_WORD)v86)
      {
        if ((unsigned __int16)v86 == 0xFFFF)
        {
          *(int16x4_t *)a10.i8 = vmovn_s32(a10);
        }
        else
        {
          unsigned int v98 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
          v99.i32[0] = (unsigned __int16)v98;
          v99.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v98), 0x10uLL).i32[1];
          a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v93), (uint64x2_t)xmmword_1850CDC40);
          v99.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
          uint32x4_t v100 = (uint32x4_t)vmulq_s32(v99, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v86)));
          *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v91, v92), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v100, v100, 0x10uLL), v26), 0x10uLL));
        }
        *int v11 = vrev16_s8(*(int8x8_t *)a10.i8);
      }
      v62 += 2;
      ++v11;
      uint64_t v12 = (_WORD *)((char *)v12 + result);
      if (!--v61) {
        goto LABEL_107;
      }
    }
    int32x4_t v69 = (unsigned int *)&v65[v64 >> 4];
    if (v23 < v69) {
      int32x4_t v69 = v23;
    }
    if (v69 < v19) {
      int32x4_t v69 = v19;
    }
    unsigned int v70 = bswap32(*v69);
    if (v29)
    {
      unsigned int v71 = &v65[v28];
      if (v23 >= (unsigned int *)&v65[v28]) {
        unsigned int v72 = (unsigned int *)&v65[v28];
      }
      else {
        unsigned int v72 = v23;
      }
      if (v72 < v19) {
        unsigned int v72 = v19;
      }
      unsigned int v73 = bswap32(*v72);
      unsigned int v74 = (unsigned int *)&v71[v64 >> 4];
      if (v23 < v74) {
        unsigned int v74 = v23;
      }
      if (v74 < v19) {
        unsigned int v74 = v19;
      }
      int v75 = BLEND8_21385[v29];
      unsigned int v67 = v67 - ((v75 & v67) >> v29) + ((v75 & v73) >> v29);
      unsigned int v70 = v70 - ((v75 & v70) >> v29) + ((bswap32(*v74) & v75) >> v29);
    }
    int v76 = BLEND8_21385[*v62 & 0xF];
    unsigned int v77 = v67 - ((v76 & v67) >> v68);
    unsigned int v78 = (v76 & v70) >> v68;
LABEL_88:
    unsigned int v67 = v77 + v78;
    goto LABEL_89;
  }
  unsigned int v101 = (uint64_t *)(v15 + 16 * a3);
  unsigned int v102 = (unsigned int *)(v20 - 4);
  int v103 = v13 ^ 0xFFFF;
  int32x4_t v104 = vdupq_n_s32(v13 ^ 0xFFFFu);
  v105.i64[0] = 0x100000001;
  v105.i64[1] = 0x100000001;
  uint64_t v106 = a5;
  do
  {
    int32x2_t v107 = (char *)v19 + (v18 >> v17) * v16;
    if (v158 == 1)
    {
      if (a5 >= 1)
      {
        int v108 = v101;
        uint64_t v109 = v106;
        do
        {
          uint64_t v110 = *v108;
          v108 += 2;
          int v111 = (unsigned int *)&v107[v110];
          if (v102 < (unsigned int *)&v107[v110]) {
            int v111 = v102;
          }
          if (v111 < v19) {
            int v111 = v19;
          }
          unsigned int v112 = __ROL4__(bswap32(*v111), v14);
          HIDWORD(v114) = HIBYTE(v112);
          LODWORD(v114) = v112;
          unsigned int v113 = v114 >> 24;
          unsigned int v115 = BYTE2(v112) | (BYTE2(v112) << 8);
          unsigned int v116 = BYTE1(v112) | (BYTE1(v112) << 8);
          unsigned int v117 = v112 | v10 | ((v112 | v10) << 8);
          if (v113 <= v115) {
            unsigned __int32 v118 = v115;
          }
          else {
            unsigned __int32 v118 = v113;
          }
          if (v116 > v118) {
            unsigned __int32 v118 = v116;
          }
          a10.i64[0] = __PAIR64__(v117, v118);
          int32x4_t v119 = vzip1q_s32(a10, a10);
          v119.i32[2] = v118;
          v120.i64[0] = __PAIR64__(v115, v113);
          v120.i64[1] = __PAIR64__(v118, v116);
          a10 = vsubq_s32(v119, v120);
          if (v13 != 0xFFFF)
          {
            int8x16_t v121 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v121, 0x10uLL), (int32x4_t)vmvnq_s8(v121)), 0x10uLL));
            v117 -= (v117 * v103 + ((v117 * v103) >> 16) + 1) >> 16;
          }
          *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
          if (v12) {
            *uint64_t v12 = bswap32(v117) >> 16;
          }
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          --v109;
        }
        while (v109);
      }
    }
    else
    {
      int v122 = v101;
      uint64_t v123 = v106;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v124 = *v122;
          v122 += 2;
          int v125 = (unsigned int *)&v107[v124];
          if (v102 < (unsigned int *)&v107[v124]) {
            int v125 = v102;
          }
          if (v125 < v19) {
            int v125 = v19;
          }
          unsigned int v126 = __ROL4__(bswap32(*v125), v14);
          HIDWORD(v128) = HIBYTE(v126);
          LODWORD(v128) = v126;
          unsigned int v127 = v128 >> 24;
          unsigned int v129 = BYTE2(v126) | (BYTE2(v126) << 8);
          unsigned int v130 = BYTE1(v126) | (BYTE1(v126) << 8);
          int v131 = v126 | v10 | ((v126 | v10) << 8);
          if (v127 <= v129) {
            unsigned __int32 v132 = v129;
          }
          else {
            unsigned __int32 v132 = v127;
          }
          if (v130 > v132) {
            unsigned __int32 v132 = v130;
          }
          a10.i64[0] = __PAIR64__(v131, v132);
          int32x4_t v133 = vzip1q_s32(a10, a10);
          v133.i32[2] = v132;
          v134.i64[0] = __PAIR64__(v129, v127);
          v134.i64[1] = __PAIR64__(v132, v130);
          a10 = vsubq_s32(v133, v134);
          if (v13 != 0xFFFF)
          {
            int8x16_t v135 = (int8x16_t)vmulq_s32(a10, v104);
            a10 = vsubq_s32(a10, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v135, 0x10uLL), (int32x4_t)vmvnq_s8(v135)), 0x10uLL));
            v131 -= (v131 * v103 + ((v131 * v103) >> 16) + 1) >> 16;
          }
          unsigned __int32 v136 = a10.u32[1];
          uint64_t v137 = a10.u16[0] | (a10.u16[2] << 16);
          unint64_t v138 = ((unint64_t)a10.u16[4] << 32) | ((unint64_t)a10.u32[3] << 48) | v137;
          if (v12)
          {
            if ((_WORD)v131)
            {
              if ((unsigned __int16)v131 == 0xFFFF)
              {
                *int v11 = vrev16_s8((int8x8_t)vmovn_s32(a10));
                *uint64_t v12 = -1;
              }
              else
              {
                unsigned int v139 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
                unsigned int v140 = bswap32((unsigned __int16)*v12);
                v141.i32[0] = (unsigned __int16)v139;
                v141.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v139), 0x10uLL).i32[1];
                a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_1850CDC40);
                v141.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
                uint32x4_t v142 = (uint32x4_t)vmulq_s32(v141, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
                *int v11 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v142, v142, 0x10uLL), v105), 0x10uLL)));
                *uint64_t v12 = bswap32(v131+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)+ (((unsigned __int16)~(_WORD)v131 * HIWORD(v140)) >> 16)+ 1) >> 16)) >> 16;
              }
            }
          }
          else if ((_WORD)v131)
          {
            if ((unsigned __int16)v131 == 0xFFFF)
            {
              *(int16x4_t *)a10.i8 = vmovn_s32(a10);
            }
            else
            {
              unsigned int v143 = bswap32(v11->u16[1] | (v11->u16[0] << 16));
              v144.i32[0] = (unsigned __int16)v143;
              v144.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v143), 0x10uLL).i32[1];
              a10 = (int32x4_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v138), (uint64x2_t)xmmword_1850CDC40);
              v144.i64[1] = __PAIR64__(bswap32(v11->u16[3]) >> 16, bswap32(v11->u16[2]) >> 16);
              uint32x4_t v145 = (uint32x4_t)vmulq_s32(v144, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v131)));
              *(int16x4_t *)a10.i8 = vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v136, v137), (int64x2_t)a10), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v145, v145, 0x10uLL), v105), 0x10uLL));
            }
            *int v11 = vrev16_s8(*(int8x8_t *)a10.i8);
          }
          ++v11;
          uint64_t v12 = (_WORD *)((char *)v12 + result);
          --v123;
        }
        while (v123);
      }
    }
    uint64_t v16 = v156;
    v11 += v157;
    LOBYTE(v17) = v155;
    v18 += v154;
    v12 += v159;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t CMYK64_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  uint64_t v6 = (int8x8_t *)*((void *)a2 + 2);
  uint64_t v7 = (_WORD *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v174 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v174 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v173 = *a2;
  uint64_t v172 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v169 = *((void *)a2 + 11);
  char v170 = v11;
  uint64_t v12 = *((void *)a2 + 7) + v169 * a4;
  int v13 = *(unsigned __int8 **)(a1 + 32);
  int v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v7 != 0);
  int v175 = a5;
  uint64_t v171 = v10;
  if (v15)
  {
    uint64_t v168 = *((void *)a2 + 13);
    uint64_t v167 = *((void *)a2 + 15);
    uint64_t v165 = ~(-1 << v11);
    char v164 = v11 - 4;
    uint64_t v17 = v14 - 3;
    int v18 = v8 ^ 0xFFFF;
    unsigned int v166 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1);
    uint64_t v162 = a5;
    uint64_t v163 = -v10;
    uint64_t v161 = v9 + 16 * a3 + 8;
    v19.i64[0] = 0x100000001;
    v19.i64[1] = 0x100000001;
    while (1)
    {
      if (((v167 - v12) | (v12 - v168)) < 0)
      {
        int v22 = 0;
        uint64_t v21 = 0;
      }
      else
      {
        uint64_t v20 = ((v12 & (unint64_t)v165) >> v164) & 0xF;
        uint64_t v21 = (unint64_t)(v20 - 7) >= 9 ? v163 : v10;
        int v22 = weights_21383[v20] & 0xF;
      }
      int v23 = &v13[(v12 >> v11) * v10];
      if (v173 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        int v24 = (uint64_t *)v161;
        uint64_t v25 = v162;
        while (1)
        {
          uint64_t v26 = *(v24 - 1);
          uint64_t v27 = *v24;
          uint64_t v28 = &v23[v26];
          if (v17 >= &v23[v26]) {
            int v29 = &v23[v26];
          }
          else {
            int v29 = v17;
          }
          if (v29 < v13) {
            int v29 = v13;
          }
          unsigned int v30 = (*v29 << 24) | (v29[1] << 16) | (v29[2] << 8);
          char v31 = v27 & 0xF;
          if ((v27 & 0xF) != 0) {
            break;
          }
          if (v22)
          {
            long long v41 = &v28[v21];
            if (v17 < &v28[v21]) {
              long long v41 = v17;
            }
            if (v41 < v13) {
              long long v41 = v13;
            }
            unsigned int v42 = BLEND8_21385[v22];
            unsigned int v39 = v30 - ((v42 & v30) >> v22);
            unsigned int v40 = (((*v41 << 24) | (v41[1] << 16) | (v41[2] << 8)) & v42) >> v22;
            goto LABEL_43;
          }
LABEL_44:
          int v43 = BYTE2(v30);
          int v44 = BYTE1(v30);
          HIDWORD(v46) = HIBYTE(v30);
          LODWORD(v46) = v30;
          unsigned int v45 = v46 >> 24;
          unsigned int v47 = v43 | (v43 << 8);
          unsigned int v48 = v44 | (v44 << 8);
          if (v45 <= v47) {
            unsigned int v49 = v47;
          }
          else {
            unsigned int v49 = v45;
          }
          if (v48 > v49) {
            unsigned int v49 = v48;
          }
          unsigned int v50 = v49 - v45;
          unsigned int v51 = v49 - v47;
          unsigned int v52 = v49 - v48;
          uint64_t v53 = v49 ^ 0xFFFF;
          unint64_t v54 = (unint64_t)(unsigned __int16)v52 << 32;
          unint64_t v55 = (unint64_t)(v53
                                 - ((v53 * v18 + ((v53 * v18) >> 16) + 1) >> 16)) << 48;
          unint64_t v56 = (unint64_t)(unsigned __int16)(v52 - ((v52 * v18 + ((v52 * v18) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            unint64_t v56 = v53 << 48;
            unint64_t v55 = v54;
            unsigned int v57 = v50;
          }
          else
          {
            v51 -= (v51 * v18 + ((v51 * v18) >> 16) + 1) >> 16;
            unsigned int v57 = v50 - ((v50 * v18 + ((v50 * v18) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF) {
            unsigned int v58 = 0xFFFF;
          }
          else {
            unsigned int v58 = HIWORD(v166);
          }
          unint64_t v59 = v55 | v56;
          v6->i16[0] = bswap32(v57) >> 16;
          v6->i16[1] = bswap32(v51) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v59)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v59));
          if (v7) {
            *uint64_t v7 = __rev16(v58);
          }
          v24 += 2;
          ++v6;
          uint64_t v7 = (_WORD *)((char *)v7 + result);
          if (!--v25) {
            goto LABEL_114;
          }
        }
        uint64_t v32 = &v28[v27 >> 4];
        if (v17 < v32) {
          uint64_t v32 = v17;
        }
        if (v32 < v13) {
          uint64_t v32 = v13;
        }
        int v33 = (*v32 << 24) | (v32[1] << 16) | (v32[2] << 8);
        if (v22)
        {
          uint64_t v34 = &v28[v21];
          if (v17 >= &v28[v21]) {
            uint64_t v35 = &v28[v21];
          }
          else {
            uint64_t v35 = v17;
          }
          if (v35 < v13) {
            uint64_t v35 = v13;
          }
          long long v36 = &v34[v27 >> 4];
          if (v17 < v36) {
            long long v36 = v17;
          }
          if (v36 < v13) {
            long long v36 = v13;
          }
          unsigned int v37 = BLEND8_21385[v22];
          unsigned int v30 = v30 - ((v37 & v30) >> v22) + ((v37 & ((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8))) >> v22);
          int v33 = v33 - ((v37 & v33) >> v22) + ((((*v36 << 24) | (v36[1] << 16) | (v36[2] << 8)) & v37) >> v22);
        }
        int v38 = BLEND8_21385[*v24 & 0xF];
        unsigned int v39 = v30 - ((v38 & v30) >> v31);
        unsigned int v40 = (v38 & v33) >> v31;
LABEL_43:
        unsigned int v30 = v39 + v40;
        goto LABEL_44;
      }
LABEL_114:
      uint64_t v10 = v171;
      v6 += v172;
      LOBYTE(v11) = v170;
      v12 += v169;
      a5 = v175;
      v7 += v174;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_114;
    }
    uint64_t v61 = (uint64_t *)v161;
    uint64_t v60 = v162;
    while (1)
    {
      uint64_t v62 = *(v61 - 1);
      uint64_t v63 = *v61;
      uint64_t v64 = &v23[v62];
      if (v17 >= &v23[v62]) {
        int v65 = &v23[v62];
      }
      else {
        int v65 = v17;
      }
      if (v65 < v13) {
        int v65 = v13;
      }
      unsigned int v66 = (*v65 << 24) | (v65[1] << 16) | (v65[2] << 8);
      char v67 = v63 & 0xF;
      if ((v63 & 0xF) != 0) {
        break;
      }
      if (v22)
      {
        unsigned int v77 = &v64[v21];
        if (v17 < &v64[v21]) {
          unsigned int v77 = v17;
        }
        if (v77 < v13) {
          unsigned int v77 = v13;
        }
        unsigned int v78 = BLEND8_21385[v22];
        unsigned int v75 = v66 - ((v78 & v66) >> v22);
        unsigned int v76 = (((*v77 << 24) | (v77[1] << 16) | (v77[2] << 8)) & v78) >> v22;
        goto LABEL_89;
      }
LABEL_90:
      int v79 = BYTE2(v66);
      int v80 = BYTE1(v66);
      HIDWORD(v82) = HIBYTE(v66);
      LODWORD(v82) = v66;
      unsigned int v81 = v82 >> 24;
      unsigned int v83 = v79 | (v79 << 8);
      unsigned int v84 = v80 | (v80 << 8);
      if (v81 <= v83) {
        unsigned int v85 = v83;
      }
      else {
        unsigned int v85 = v81;
      }
      if (v84 > v85) {
        unsigned int v85 = v84;
      }
      unsigned int v86 = v85 - v81;
      unsigned int v87 = v85 - v83;
      unsigned int v88 = v85 - v84;
      uint64_t v89 = v85 ^ 0xFFFF;
      unint64_t v90 = v89 << 48;
      unint64_t v91 = (unint64_t)(unsigned __int16)v88 << 32;
      unint64_t v92 = (unint64_t)(v89 - ((v89 * v18 + ((v89 * v18) >> 16) + 1) >> 16)) << 48;
      unint64_t v93 = (unint64_t)(unsigned __int16)(v88 - ((v88 * v18 + ((v88 * v18) >> 16) + 1) >> 16)) << 32;
      if (v8 == 0xFFFF)
      {
        unint64_t v93 = v90;
        unint64_t v92 = v91;
        unsigned int v94 = v87;
      }
      else
      {
        unsigned int v94 = v87 - ((v87 * v18 + ((v87 * v18) >> 16) + 1) >> 16);
      }
      if (v8 == 0xFFFF) {
        unsigned int v95 = v86;
      }
      else {
        unsigned int v95 = v86 - ((v86 * v18 + ((v86 * v18) >> 16) + 1) >> 16);
      }
      if (v8 == 0xFFFF) {
        int v96 = 0xFFFF;
      }
      else {
        int v96 = HIWORD(v166);
      }
      unint64_t v97 = v92 | v93;
      uint64_t v98 = (unsigned __int16)v95 | ((unsigned __int16)v94 << 16);
      unint64_t v99 = v92 | v93 | v98;
      if (v7)
      {
        if (v96)
        {
          if (v96 == 0xFFFF)
          {
            v6->i16[0] = bswap32(v95) >> 16;
            v6->i16[1] = bswap32(v94) >> 16;
            v6->i16[2] = bswap32(HIDWORD(v97)) >> 16;
            v6->i16[3] = __rev16(HIWORD(v97));
            *uint64_t v7 = -1;
          }
          else
          {
            unsigned int v100 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
            v101.i32[0] = (unsigned __int16)v100;
            v101.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v100), 0x10uLL).i32[1];
            unsigned int v102 = (unsigned __int16)~(_WORD)v96 * (bswap32((unsigned __int16)*v7) >> 16);
            v101.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
            uint32x4_t v103 = (uint32x4_t)vmulq_s32(v101, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v96)));
            *uint64_t v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v94, v98), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v99), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v103, v103, 0x10uLL), v19), 0x10uLL)));
            *uint64_t v7 = bswap32(v96 + ((v102 + HIWORD(v102) + 1) >> 16)) >> 16;
          }
        }
      }
      else if (v96)
      {
        if (v96 == 0xFFFF)
        {
          v6->i16[0] = bswap32(v95) >> 16;
          v6->i16[1] = bswap32(v94) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v97)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v97));
        }
        else
        {
          unsigned int v104 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
          v105.i32[0] = (unsigned __int16)v104;
          v105.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v104), 0x10uLL).i32[1];
          v105.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
          uint32x4_t v106 = (uint32x4_t)vmulq_s32(v105, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v96)));
          *uint64_t v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v94, v98), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v99), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v106, v106, 0x10uLL), v19), 0x10uLL)));
        }
      }
      v61 += 2;
      ++v6;
      uint64_t v7 = (_WORD *)((char *)v7 + result);
      if (!--v60) {
        goto LABEL_114;
      }
    }
    char v68 = &v64[v63 >> 4];
    if (v17 < v68) {
      char v68 = v17;
    }
    if (v68 < v13) {
      char v68 = v13;
    }
    int v69 = (*v68 << 24) | (v68[1] << 16) | (v68[2] << 8);
    if (v22)
    {
      if (v17 >= &v64[v21]) {
        unsigned int v70 = &v64[v21];
      }
      else {
        unsigned int v70 = v17;
      }
      if (v70 < v13) {
        unsigned int v70 = v13;
      }
      int v71 = (*v70 << 24) | (v70[1] << 16) | (v70[2] << 8);
      unsigned int v72 = &v64[v21 + (v63 >> 4)];
      if (v17 < v72) {
        unsigned int v72 = v17;
      }
      if (v72 < v13) {
        unsigned int v72 = v13;
      }
      unsigned int v73 = BLEND8_21385[v22];
      unsigned int v66 = v66 - ((v73 & v66) >> v22) + ((v73 & v71) >> v22);
      int v69 = v69 - ((v73 & v69) >> v22) + ((((*v72 << 24) | (v72[1] << 16) | (v72[2] << 8)) & v73) >> v22);
    }
    int v74 = BLEND8_21385[*v61 & 0xF];
    unsigned int v75 = v66 - ((v74 & v66) >> v67);
    unsigned int v76 = (v74 & v69) >> v67;
LABEL_89:
    unsigned int v66 = v75 + v76;
    goto LABEL_90;
  }
  int32x2_t v107 = (uint64_t *)(v9 + 16 * a3);
  int v108 = v14 - 3;
  int v109 = v8 ^ 0xFFFF;
  unsigned int v110 = ~(0xFFFF * v109 + ((0xFFFF * v109) >> 16) + 1);
  uint64_t v111 = a5;
  v112.i64[0] = 0x100000001;
  v112.i64[1] = 0x100000001;
  do
  {
    unsigned int v113 = &v13[(v12 >> v11) * v10];
    if (v173 == 1)
    {
      if (a5 >= 1)
      {
        unint64_t v114 = v107;
        uint64_t v115 = v111;
        do
        {
          uint64_t v116 = *v114;
          v114 += 2;
          unsigned int v117 = &v113[v116];
          if (v108 < &v113[v116]) {
            unsigned int v117 = v108;
          }
          if (v117 < v13) {
            unsigned int v117 = v13;
          }
          unsigned int v118 = *v117 | (*v117 << 8);
          unsigned int v119 = v117[1] | (v117[1] << 8);
          unsigned int v120 = v117[2] | (v117[2] << 8);
          if (v118 <= v119) {
            unsigned int v121 = v119;
          }
          else {
            unsigned int v121 = v118;
          }
          if (v120 > v121) {
            unsigned int v121 = v120;
          }
          unsigned int v122 = v121 - v118;
          unsigned int v123 = v121 - v119;
          unsigned int v124 = v121 - v120;
          uint64_t v125 = v121 ^ 0xFFFF;
          unint64_t v126 = v125 << 48;
          unint64_t v127 = (unint64_t)(unsigned __int16)v124 << 32;
          unint64_t v128 = (unint64_t)(v125
                                  - ((v125 * v109 + ((v125 * v109) >> 16) + 1) >> 16)) << 48;
          unint64_t v129 = (unint64_t)(unsigned __int16)(v124 - ((v124 * v109 + ((v124 * v109) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF) {
            unint64_t v128 = v127;
          }
          else {
            unint64_t v126 = v129;
          }
          if (v8 == 0xFFFF)
          {
            unsigned int v130 = 0xFFFF;
          }
          else
          {
            v123 -= (v123 * v109 + ((v123 * v109) >> 16) + 1) >> 16;
            v122 -= (v122 * v109 + ((v122 * v109) >> 16) + 1) >> 16;
            unsigned int v130 = HIWORD(v110);
          }
          unint64_t v131 = v128 | v126;
          v6->i16[0] = bswap32(v122) >> 16;
          v6->i16[1] = bswap32(v123) >> 16;
          v6->i16[2] = bswap32(HIDWORD(v131)) >> 16;
          v6->i16[3] = __rev16(HIWORD(v131));
          if (v7) {
            *uint64_t v7 = __rev16(v130);
          }
          ++v6;
          uint64_t v7 = (_WORD *)((char *)v7 + result);
          --v115;
        }
        while (v115);
      }
    }
    else
    {
      unsigned __int32 v132 = v107;
      uint64_t v133 = v111;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v134 = *v132;
          v132 += 2;
          int8x16_t v135 = &v113[v134];
          if (v108 < &v113[v134]) {
            int8x16_t v135 = v108;
          }
          if (v135 < v13) {
            int8x16_t v135 = v13;
          }
          unsigned int v136 = *v135 | (*v135 << 8);
          unsigned int v137 = v135[1] | (v135[1] << 8);
          unsigned int v138 = v135[2] | (v135[2] << 8);
          if (v136 <= v137) {
            unsigned int v139 = v137;
          }
          else {
            unsigned int v139 = v136;
          }
          if (v138 > v139) {
            unsigned int v139 = v138;
          }
          unsigned int v140 = v139 - v136;
          unsigned int v141 = v139 - v137;
          unsigned int v142 = v139 - v138;
          uint64_t v143 = v139 ^ 0xFFFF;
          unint64_t v144 = v143 << 48;
          unint64_t v145 = (unint64_t)(unsigned __int16)v142 << 32;
          unsigned int v146 = v141 - ((v141 * v109 + ((v141 * v109) >> 16) + 1) >> 16);
          unint64_t v147 = (unint64_t)(v143
                                  - ((v143 * v109 + ((v143 * v109) >> 16) + 1) >> 16)) << 48;
          unint64_t v148 = (unint64_t)(unsigned __int16)(v142 - ((v142 * v109 + ((v142 * v109) >> 16) + 1) >> 16)) << 32;
          if (v8 == 0xFFFF)
          {
            unint64_t v148 = v144;
            unint64_t v147 = v145;
            unsigned int v146 = v141;
            unsigned int v149 = v140;
          }
          else
          {
            unsigned int v149 = v140 - ((v140 * v109 + ((v140 * v109) >> 16) + 1) >> 16);
          }
          if (v8 == 0xFFFF) {
            int v150 = 0xFFFF;
          }
          else {
            int v150 = HIWORD(v110);
          }
          unint64_t v151 = v147 | v148;
          uint64_t v152 = (unsigned __int16)v149 | ((unsigned __int16)v146 << 16);
          unint64_t v153 = v151 | v152;
          if (v7)
          {
            if (v150)
            {
              if (v150 == 0xFFFF)
              {
                v6->i16[0] = bswap32(v149) >> 16;
                v6->i16[1] = bswap32(v146) >> 16;
                v6->i16[2] = bswap32(HIDWORD(v151)) >> 16;
                v6->i16[3] = __rev16(HIWORD(v151));
                *uint64_t v7 = -1;
              }
              else
              {
                unsigned int v154 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
                v155.i32[0] = (unsigned __int16)v154;
                v155.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v154), 0x10uLL).i32[1];
                unsigned int v156 = (unsigned __int16)~(_WORD)v150 * (bswap32((unsigned __int16)*v7) >> 16);
                v155.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
                uint32x4_t v157 = (uint32x4_t)vmulq_s32(v155, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v150)));
                *uint64_t v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v146, v152), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v153), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v157, v157, 0x10uLL), v112), 0x10uLL)));
                *uint64_t v7 = bswap32(v150 + ((v156 + HIWORD(v156) + 1) >> 16)) >> 16;
              }
            }
          }
          else if (v150)
          {
            if (v150 == 0xFFFF)
            {
              v6->i16[0] = bswap32(v149) >> 16;
              v6->i16[1] = bswap32(v146) >> 16;
              v6->i16[2] = bswap32(HIDWORD(v151)) >> 16;
              v6->i16[3] = __rev16(HIWORD(v151));
            }
            else
            {
              unsigned int v158 = bswap32(v6->u16[1] | (v6->u16[0] << 16));
              v159.i32[0] = (unsigned __int16)v158;
              v159.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v158), 0x10uLL).i32[1];
              v159.i64[1] = __PAIR64__(bswap32(v6->u16[3]) >> 16, bswap32(v6->u16[2]) >> 16);
              uint32x4_t v160 = (uint32x4_t)vmulq_s32(v159, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v150)));
              *uint64_t v6 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64((int32x2_t)__PAIR64__(v146, v152), (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v153), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v160, v160, 0x10uLL), v112), 0x10uLL)));
            }
          }
          ++v6;
          uint64_t v7 = (_WORD *)((char *)v7 + result);
          --v133;
        }
        while (v133);
      }
    }
    uint64_t v10 = v171;
    v6 += v172;
    LOBYTE(v11) = v170;
    v12 += v169;
    a5 = v175;
    v7 += v174;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t CMYK64_image_mark_W8(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6 = *((unsigned __int16 *)a2 + 4);
  uint64_t v7 = (unsigned __int16 *)*((void *)a2 + 2);
  int v8 = (_WORD *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v9 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v9 = 0;
  }
  int v10 = *a2;
  uint64_t v11 = *((void *)a2 + 3) - a5;
  BOOL v12 = v8 != 0;
  uint64_t v13 = *(void *)(a1 + 176);
  if (v6 == 0xFFFF) {
    unint64_t v14 = 0xFEFE000000000000;
  }
  else {
    unint64_t v14 = (unint64_t)(65278 - ((65278 * (v6 ^ 0xFFFF) + ((65278 * (v6 ^ 0xFFFFu)) >> 16) + 1) >> 16)) << 48;
  }
  if (v6 == 0xFFFF) {
    unsigned int v15 = -1;
  }
  else {
    unsigned int v15 = ~(0xFFFF * (v6 ^ 0xFFFF) + ((0xFFFF * (v6 ^ 0xFFFFu)) >> 16) + 1) >> 16;
  }
  unsigned __int16 v16 = __rev16(HIWORD(v14));
  unsigned int v17 = bswap32(v15) >> 16;
  unsigned int v18 = (unsigned __int16)~(_WORD)v15;
  int32x4_t v19 = vdupq_n_s32(v18);
  uint32x4_t v20 = (uint32x4_t)vmovn_hight_s64(0, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v14), (uint64x2_t)xmmword_1850CDC40));
  if (v13)
  {
    uint64_t result = 2 * v12;
    v22.i64[0] = 0x100000001;
    v22.i64[1] = 0x100000001;
    do
    {
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          int v23 = a5;
          do
          {
            *(_DWORD *)uint64_t v7 = 0;
            v7[2] = 0;
            v7[3] = v16;
            if (v8) {
              *int v8 = v17;
            }
            v7 += 4;
            int v8 = (_WORD *)((char *)v8 + result);
            --v23;
          }
          while (v23);
        }
      }
      else
      {
        int v24 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v8)
            {
              if ((_WORD)v15)
              {
                if ((unsigned __int16)v15 == 0xFFFF)
                {
                  *(_DWORD *)uint64_t v7 = 0;
                  v7[2] = 0;
                  v7[3] = v16;
                  *int v8 = -1;
                }
                else
                {
                  unsigned int v25 = bswap32(v7[1] | (*v7 << 16));
                  unsigned int v26 = bswap32((unsigned __int16)*v8);
                  v27.i32[0] = (unsigned __int16)v25;
                  v27.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v25), 0x10uLL).i32[1];
                  v27.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                  uint32x4_t v28 = (uint32x4_t)vmulq_s32(v27, v19);
                  *(int8x8_t *)uint64_t v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v28, v28, 0x10uLL), v22), 0x10uLL)));
                  *int v8 = bswap32(v15 + ((v18 * HIWORD(v26) + ((v18 * HIWORD(v26)) >> 16) + 1) >> 16)) >> 16;
                }
              }
            }
            else if ((_WORD)v15)
            {
              if ((unsigned __int16)v15 == 0xFFFF)
              {
                *(_DWORD *)uint64_t v7 = 0;
                v7[2] = 0;
                v7[3] = v16;
              }
              else
              {
                unsigned int v29 = bswap32(v7[1] | (*v7 << 16));
                v30.i32[0] = (unsigned __int16)v29;
                v30.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v29), 0x10uLL).i32[1];
                v30.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                uint32x4_t v31 = (uint32x4_t)vmulq_s32(v30, v19);
                *(int8x8_t *)uint64_t v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v31, v31, 0x10uLL), v22), 0x10uLL)));
              }
            }
            v7 += 4;
            int v8 = (_WORD *)((char *)v8 + result);
            --v24;
          }
          while (v24);
        }
      }
      v7 += 4 * v11;
      v8 += v9;
      --a6;
    }
    while (a6);
  }
  else
  {
    uint64_t result = 2 * v12;
    v32.i64[0] = 0x100000001;
    v32.i64[1] = 0x100000001;
    do
    {
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          int v33 = a5;
          do
          {
            *(_DWORD *)uint64_t v7 = 0;
            v7[2] = 0;
            v7[3] = v16;
            if (v8) {
              *int v8 = v17;
            }
            v7 += 4;
            int v8 = (_WORD *)((char *)v8 + result);
            --v33;
          }
          while (v33);
        }
      }
      else
      {
        int v34 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v8)
            {
              if ((_WORD)v15)
              {
                if ((unsigned __int16)v15 == 0xFFFF)
                {
                  *(_DWORD *)uint64_t v7 = 0;
                  v7[2] = 0;
                  v7[3] = v16;
                  *int v8 = -1;
                }
                else
                {
                  unsigned int v35 = bswap32(v7[1] | (*v7 << 16));
                  unsigned int v36 = bswap32((unsigned __int16)*v8);
                  v37.i32[0] = (unsigned __int16)v35;
                  v37.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v35), 0x10uLL).i32[1];
                  v37.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                  uint32x4_t v38 = (uint32x4_t)vmulq_s32(v37, v19);
                  *(int8x8_t *)uint64_t v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v38, v38, 0x10uLL), v32), 0x10uLL)));
                  *int v8 = bswap32(v15 + ((v18 * HIWORD(v36) + ((v18 * HIWORD(v36)) >> 16) + 1) >> 16)) >> 16;
                }
              }
            }
            else if ((_WORD)v15)
            {
              if ((unsigned __int16)v15 == 0xFFFF)
              {
                *(_DWORD *)uint64_t v7 = 0;
                v7[2] = 0;
                v7[3] = v16;
              }
              else
              {
                unsigned int v39 = bswap32(v7[1] | (*v7 << 16));
                v40.i32[0] = (unsigned __int16)v39;
                v40.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v39), 0x10uLL).i32[1];
                v40.i64[1] = __PAIR64__(bswap32(v7[3]) >> 16, bswap32(v7[2]) >> 16);
                uint32x4_t v41 = (uint32x4_t)vmulq_s32(v40, v19);
                *(int8x8_t *)uint64_t v7 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v41, v41, 0x10uLL), v32), 0x10uLL)));
              }
            }
            v7 += 4;
            int v8 = (_WORD *)((char *)v8 + result);
            --v34;
          }
          while (v34);
        }
      }
      v7 += 4 * v11;
      v8 += v9;
      --a6;
    }
    while (a6);
  }
  return result;
}

void CMYK64_mark_pixelshape(uint64_t a1, uint64_t a2, int8x8_t a3)
{
  int v4 = *(_DWORD *)a1;
  int v3 = *(_DWORD *)(a1 + 4);
  uint64_t v5 = *(int *)(a1 + 8);
  uint64_t v6 = *(int *)(a1 + 12);
  unsigned int v816 = *(_DWORD *)(a1 + 8);
  v817[0] = v3;
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v9 = *(int *)(a1 + 16);
  unint64_t v10 = (unint64_t)*(int *)(a1 + 28) >> 3;
  if (v7)
  {
    unint64_t v716 = (unint64_t)*(int *)(a1 + 32) >> 1;
    uint64_t v717 = (char *)(v7 + 2 * (v6 + v716 * v9));
    int v11 = -1;
  }
  else
  {
    unint64_t v716 = 0;
    uint64_t v717 = 0;
    int v11 = 0;
  }
  uint64_t v718 = *(void *)(a1 + 88);
  BOOL v12 = *(int **)(a1 + 136);
  unint64_t v715 = *(void *)(a1 + 40) + 8 * (v6 + v10 * v9);
  int v14 = *(_DWORD *)(a1 + 56);
  int v13 = *(_DWORD *)(a1 + 60);
  unint64_t v15 = *(int *)(a1 + 76);
  if ((v4 & 0xFF00) == 0x100)
  {
    unint64_t v760 = v15 >> 3;
    if (v8)
    {
      unint64_t v761 = (unint64_t)*(int *)(a1 + 80) >> 1;
      v8 += 2 * (v14 + v761 * v13);
      int v16 = -1;
    }
    else
    {
      unint64_t v761 = 0;
      int v16 = 0;
    }
    v718 += 8 * (v14 + v760 * v13);
    if (v760 == v10 && (uint64_t)(v715 - v718) >= 1)
    {
      if (v3 >= (uint64_t)((v715 - v718) >> 3))
      {
        uint64_t v17 = a2;
        int v18 = v3;
        v715 += 8 * (v3 - 1);
        v718 += 8 * (v3 - 1);
        v717 += 2 * (v11 & (v3 - 1));
        int v32 = v16 & (v3 - 1);
        int v21 = -1;
        unint64_t v760 = (unint64_t)*(int *)(a1 + 28) >> 3;
        v8 += 2 * v32;
        goto LABEL_15;
      }
      uint64_t v19 = v5 - 1;
      uint64_t v20 = v10 * (v5 - 1);
      if (v715 <= v718 + 8 * v20 + 8 * (v3 - 1))
      {
        uint64_t v17 = a2;
        int v18 = v3;
        v715 += 8 * v20;
        unint64_t v10 = -(uint64_t)v10;
        int v33 = &v717[2 * v716 * v19];
        unint64_t v716 = -(uint64_t)v716;
        uint64_t v717 = v33;
        v8 += 2 * v761 * v19;
        v11 &= 1u;
        unint64_t v761 = -(uint64_t)v761;
        v16 &= 1u;
        int v21 = 1;
        v718 += 8 * v20;
        unint64_t v760 = v10;
        goto LABEL_15;
      }
    }
    uint64_t v17 = a2;
    int v18 = v3;
    v11 &= 1u;
    v16 &= 1u;
    int v21 = 1;
LABEL_15:
    int32x4_t v22 = 0;
    unint64_t v758 = 0;
    uint64_t v788 = -1;
    int v719 = v761;
    int v720 = v760;
    goto LABEL_18;
  }
  int v720 = *(_DWORD *)(a1 + 64);
  int v719 = *(_DWORD *)(a1 + 68);
  unint64_t v760 = v15 >> 3;
  uint64_t v17 = a2;
  int v18 = v3;
  if (v8)
  {
    unint64_t v761 = (unint64_t)*(int *)(a1 + 80) >> 1;
    int v16 = 1;
  }
  else
  {
    unint64_t v761 = 0;
    int v16 = 0;
  }
  unint64_t v758 = v718 + 8 * v760 * v719;
  v11 &= 1u;
  int v21 = 1;
  int32x4_t v22 = *(int8x8_t **)(a1 + 88);
  uint64_t v788 = (uint64_t)v22;
LABEL_18:
  int v787 = v11;
  int v812 = v16;
  unsigned int v711 = v17;
  unint64_t v712 = v10;
  uint64_t v713 = v8;
  int v714 = v21;
  if (!v12)
  {
    uint64_t v27 = v21 * v18;
    unint64_t v759 = v716 - v11 * v18;
    if (v758)
    {
      uint64_t v28 = v718 + 8 * v760 * (v13 % v719);
      uint64_t v29 = v14 % v720;
      int32x4_t v22 = (int8x8_t *)(v28 + 8 * v29);
      unint64_t v30 = v28 + 8 * v720;
      uint64_t v31 = v8 + 2 * v761 * (v13 % v719) + 2 * v29;
      uint64_t v721 = 0;
      if (v16) {
        unsigned int v26 = (_WORD *)(v8 + 2 * v761 * (v13 % v719) + 2 * v29);
      }
      else {
        unsigned int v26 = (_WORD *)v8;
      }
      if ((v16 & 1) == 0) {
        uint64_t v31 = v8;
      }
      unint64_t v764 = (_WORD *)v31;
      v814 = (int8x8_t *)v715;
      unsigned int v25 = v717;
      uint64_t v813 = (int8x8_t *)(v28 + 8 * v29);
      int v708 = v14 % v720;
      int v709 = v13 % v719;
      goto LABEL_33;
    }
    int v708 = *(_DWORD *)(a1 + 56);
    int v709 = *(_DWORD *)(a1 + 60);
    uint64_t v721 = 0;
    v760 -= v27;
    v761 -= v16 * v18;
    v814 = (int8x8_t *)v715;
    unsigned int v25 = v717;
    uint64_t v813 = (int8x8_t *)v718;
    unsigned int v26 = (_WORD *)v8;
    unint64_t v764 = (_WORD *)v8;
    goto LABEL_32;
  }
  int v708 = *(_DWORD *)(a1 + 56);
  int v709 = *(_DWORD *)(a1 + 60);
  shape_enum_clip_alloc(a1, a2, v12, v21, v10, 1, *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108), v18, v5);
  int v24 = v23;
  unsigned int v25 = v717;
  unint64_t v759 = v716;
  unsigned int v26 = (_WORD *)v8;
  unint64_t v764 = (_WORD *)v8;
  if (v23)
  {
    while (2)
    {
      int v650 = v26;
      if (!shape_enum_clip_next((uint64_t)v24, (int *)&v815 + 1, &v815, v817, &v816))
      {
        free(v24);
        return;
      }
      uint64_t v721 = v24;
      if (v758)
      {
        v814 = (int8x8_t *)(v715 + 8 * v10 * (int)v815 + 8 * SHIDWORD(v815));
        uint64_t v651 = ((int)v815 + *(_DWORD *)(a1 + 60)) % v719;
        int v709 = ((int)v815 + *(_DWORD *)(a1 + 60)) % v719;
        uint64_t v27 = v817[0];
        int v18 = v817[0];
        int v652 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
        uint64_t v653 = v718 + 8 * v760 * v651;
        uint64_t v813 = (int8x8_t *)(v653 + 8 * v652);
        unint64_t v30 = v653 + 8 * v720;
        int v11 = v787;
        unint64_t v654 = v759;
        if (v787) {
          unint64_t v654 = v716 - v817[0];
        }
        unint64_t v759 = v654;
        if (v787) {
          unsigned int v25 = &v717[2 * v716 * (int)v815 + 2 * SHIDWORD(v815)];
        }
        int v16 = v812;
        if (v812)
        {
          unsigned int v26 = (_WORD *)(v8 + 2 * v761 * v651 + 2 * v652);
          int32x4_t v22 = (int8x8_t *)(v653 + 8 * v652);
          unint64_t v764 = v26;
          int v708 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
        }
        else
        {
          int32x4_t v22 = (int8x8_t *)(v653 + 8 * v652);
          int v708 = (HIDWORD(v815) + *(_DWORD *)(a1 + 56)) % v720;
          unsigned int v26 = v650;
        }
        uint64_t v34 = v17;
        int v21 = v714;
      }
      else
      {
        int v21 = v714;
        int v655 = HIDWORD(v815) * v714;
        int v18 = v817[0];
        int v656 = v817[0] * v714;
        v814 = (int8x8_t *)(v715 + 8 * v10 * (int)v815 + 8 * HIDWORD(v815) * v714);
        uint64_t v27 = v817[0] * v714;
        uint64_t v813 = (int8x8_t *)(v718 + 8 * (int)v815 * v720 + 8 * HIDWORD(v815) * v714);
        unint64_t v760 = v720 - v817[0] * v714;
        int v11 = v787;
        unint64_t v657 = v759;
        if (v787) {
          unint64_t v657 = v716 - v656;
        }
        unint64_t v759 = v657;
        if (v787) {
          unsigned int v25 = &v717[2 * v716 * (int)v815 + 2 * v655];
        }
        uint64_t v658 = v8 + 2 * (int)v815 * v719 + 2 * v655;
        unint64_t v659 = v719 - v656;
        int v16 = v812;
        unint64_t v660 = v761;
        if (v812) {
          unint64_t v660 = v659;
        }
        unint64_t v761 = v660;
        if (v812) {
          unsigned int v26 = (_WORD *)v658;
        }
        else {
          unsigned int v26 = v650;
        }
LABEL_32:
        unint64_t v30 = v788;
LABEL_33:
        uint64_t v34 = v17;
      }
      uint64_t v757 = v10 - v27;
      switch((int)v34)
      {
        case 0:
          uint64_t v17 = v34;
          uint64_t v765 = v26;
          uint64_t v762 = v22;
          uint64_t v788 = v30;
          uint64_t v35 = v757 - v18;
          unsigned int v36 = &v814[-v18 + 1];
          if (v21 >= 0)
          {
            unsigned int v36 = v814;
            uint64_t v35 = v757 + v18;
          }
          uint64_t v37 = (int)v816;
          int v38 = v21;
          unsigned int v39 = (char *)&v36[(v35 * ((int)v816 - 1)) & (v35 >> 63)];
          if (v35 < 0) {
            uint64_t v35 = -v35;
          }
          CGBlt_fillBytes(8 * v18, v816, 0, v39, 8 * v35);
          if (v787)
          {
            uint64_t v40 = v759 - v18;
            uint32x4_t v41 = &v25[-2 * v18 + 2];
            if (v38 >= 0)
            {
              uint64_t v40 = v759 + v18;
              uint32x4_t v41 = v25;
            }
            uint64_t v42 = (v40 * (v37 - 1)) & (v40 >> 63);
            if (v40 < 0) {
              uint64_t v40 = -v40;
            }
            unint64_t v759 = v40;
            unsigned int v25 = &v41[2 * v42];
            CGBlt_fillBytes(2 * v18, v37, 0, v25, 2 * v40);
          }
          goto LABEL_45;
        case 1:
          int v43 = *(unsigned __int8 *)(a1 + 1);
          if (v43 == 2)
          {
            if (v18 >= 4 && (8 * v720) <= 0x40)
            {
              a3.i32[0] = 8 * v720;
              uint8x8_t v674 = (uint8x8_t)vcnt_s8(a3);
              v674.i16[0] = vaddlv_u8(v674);
              if (v674.i32[0] <= 1u)
              {
                uint64_t v17 = v34;
                uint64_t v675 = v26;
                uint64_t v788 = v30;
                unsigned int v676 = v816;
                CGSFillDRAM64((unint64_t)v814, 8 * (v18 + v757), 8 * v18, v816, v718, 8 * v760, 8 * v720, v719, 8 * v708, v709);
                if (v787)
                {
                  if (v812) {
                    CGSFillDRAM64((unint64_t)v25, 2 * (v18 + v759), 2 * v18, v676, v8, 2 * v761, 2 * v720, v719, 2 * v708, v709);
                  }
                  else {
                    CGBlt_fillBytes(2 * v18, v676, -1, v25, 2 * (v18 + v759));
                  }
                }
                int v24 = v721;
                unsigned int v26 = v675;
                goto LABEL_814;
              }
            }
LABEL_859:
            if (v11)
            {
              if (v16)
              {
                unsigned int v677 = v816;
                uint64_t v678 = 2 * v11;
                do
                {
                  int v679 = v18;
                  do
                  {
                    int8x8_t *v814 = *v813;
                    *(_WORD *)unsigned int v25 = *v26;
                    uint64_t v680 = (unsigned __int16 *)&v813[v21];
                    if ((unint64_t)v680 >= v30) {
                      uint64_t v681 = -(uint64_t)v720;
                    }
                    else {
                      uint64_t v681 = 0;
                    }
                    v26 += v16 + v681;
                    uint64_t v813 = (int8x8_t *)&v680[4 * v681];
                    v814 += v21;
                    v25 += v678;
                    --v679;
                  }
                  while (v679);
                  if (v758)
                  {
                    uint64_t v682 = (unsigned __int16 *)&v22[v760];
                    BOOL v683 = (unint64_t)v682 >= v758;
                    if ((unint64_t)v682 >= v758) {
                      uint64_t v684 = -(uint64_t)(v760 * v719);
                    }
                    else {
                      uint64_t v684 = 0;
                    }
                    int32x4_t v22 = (int8x8_t *)&v682[4 * v684];
                    unint64_t v685 = v30 + 8 * v684;
                    if (v683) {
                      uint64_t v686 = -(uint64_t)(v761 * v719);
                    }
                    else {
                      uint64_t v686 = 0;
                    }
                    unsigned int v26 = &v764[v761 + v686];
                    unint64_t v30 = v685 + 8 * v760;
                    uint64_t v813 = v22;
                    unint64_t v764 = v26;
                  }
                  else
                  {
                    v813 += v760;
                    v26 += v761;
                  }
                  v814 += v757;
                  v25 += 2 * v759;
                  --v677;
                }
                while (v677);
              }
              else
              {
                unsigned int v696 = v816;
                do
                {
                  int v697 = v18;
                  do
                  {
                    int8x8_t *v814 = *v813;
                    *(_WORD *)unsigned int v25 = -1;
                    uint64_t v698 = (unsigned __int16 *)&v813[v21];
                    if ((unint64_t)v698 >= v30) {
                      uint64_t v699 = -(uint64_t)v720;
                    }
                    else {
                      uint64_t v699 = 0;
                    }
                    v26 += v699;
                    uint64_t v813 = (int8x8_t *)&v698[4 * v699];
                    v814 += v21;
                    v25 += 2 * v11;
                    --v697;
                  }
                  while (v697);
                  if (v758)
                  {
                    uint64_t v700 = (unsigned __int16 *)&v22[v760];
                    BOOL v701 = (unint64_t)v700 >= v758;
                    if ((unint64_t)v700 >= v758) {
                      uint64_t v702 = -(uint64_t)(v760 * v719);
                    }
                    else {
                      uint64_t v702 = 0;
                    }
                    int32x4_t v22 = (int8x8_t *)&v700[4 * v702];
                    unint64_t v703 = v30 + 8 * v702;
                    if (v701) {
                      uint64_t v704 = -(uint64_t)(v761 * v719);
                    }
                    else {
                      uint64_t v704 = 0;
                    }
                    unsigned int v26 = &v764[v761 + v704];
                    unint64_t v30 = v703 + 8 * v760;
                    uint64_t v813 = v22;
                    unint64_t v764 = v26;
                  }
                  else
                  {
                    v813 += v760;
                    v26 += v761;
                  }
                  v814 += v757;
                  v25 += 2 * v759;
                  --v696;
                }
                while (v696);
              }
            }
            else
            {
              unsigned int v687 = v816;
              do
              {
                int v688 = v18;
                do
                {
                  int8x8_t *v814 = *v813;
                  uint64_t v689 = (unsigned __int16 *)&v813[v21];
                  if ((unint64_t)v689 >= v30) {
                    uint64_t v690 = -(uint64_t)v720;
                  }
                  else {
                    uint64_t v690 = 0;
                  }
                  v26 += v16 + v690;
                  uint64_t v813 = (int8x8_t *)&v689[4 * v690];
                  v814 += v21;
                  --v688;
                }
                while (v688);
                if (v758)
                {
                  uint64_t v691 = (unsigned __int16 *)&v22[v760];
                  BOOL v692 = (unint64_t)v691 >= v758;
                  if ((unint64_t)v691 >= v758) {
                    uint64_t v693 = -(uint64_t)(v760 * v719);
                  }
                  else {
                    uint64_t v693 = 0;
                  }
                  int32x4_t v22 = (int8x8_t *)&v691[4 * v693];
                  unint64_t v694 = v30 + 8 * v693;
                  if (v692) {
                    uint64_t v695 = -(uint64_t)(v761 * v719);
                  }
                  else {
                    uint64_t v695 = 0;
                  }
                  unsigned int v26 = &v764[v761 + v695];
                  unint64_t v30 = v694 + 8 * v760;
                  uint64_t v813 = v22;
                  unint64_t v764 = v26;
                }
                else
                {
                  v813 += v760;
                  v26 += v761;
                }
                v814 += v757;
                v25 += 2 * v759;
                --v687;
              }
              while (v687);
            }
            uint64_t v17 = v34;
            uint64_t v788 = v30;
            unsigned int v816 = 0;
            goto LABEL_912;
          }
          if (v43 != 1) {
            goto LABEL_859;
          }
          uint64_t v17 = v34;
          uint64_t v765 = v26;
          uint64_t v762 = v22;
          uint64_t v788 = v30;
          uint64_t v44 = v760 - v18;
          int v45 = v18 - 1;
          unint64_t v46 = (unsigned __int16 *)&v813[-v18 + 1];
          uint64_t v47 = v757 - v18;
          unsigned int v48 = &v814[-v18 + 1];
          int v49 = v21;
          if (v21 >= 0)
          {
            uint64_t v44 = v760 + v18;
            unsigned int v48 = v814;
            unint64_t v46 = (unsigned __int16 *)v813;
            uint64_t v47 = v757 + v18;
          }
          unsigned int v50 = v816;
          uint64_t v51 = (int)v816 - 1;
          if (v44 >= 0) {
            uint64_t v52 = v44;
          }
          else {
            uint64_t v52 = -v44;
          }
          uint64_t v53 = (char *)&v46[4 * ((v44 * ((int)v816 - 1)) & (v44 >> 63))];
          if (v47 >= 0) {
            LODWORD(v54) = v47;
          }
          else {
            uint64_t v54 = -v47;
          }
          unint64_t v760 = v52;
          CGBlt_copyBytes(8 * v18, v816, v53, (char *)&v48[(v47 * v51) & (v47 >> 63)], 8 * v52, 8 * v54);
          if (v787)
          {
            int v55 = 2 * v18;
            if (v812)
            {
              uint64_t v56 = v761 - v18;
              unsigned int v57 = &v765[-v45];
              uint64_t v58 = v759 - v18;
              unint64_t v59 = &v25[-2 * v45];
              if (v49 >= 0)
              {
                uint64_t v56 = v761 + v18;
                uint64_t v58 = v759 + v18;
                unint64_t v59 = v25;
                unsigned int v57 = v765;
              }
              if (v56 >= 0) {
                unint64_t v60 = v56;
              }
              else {
                unint64_t v60 = -v56;
              }
              uint64_t v61 = (char *)&v57[(v56 * v51) & (v56 >> 63)];
              if (v58 >= 0) {
                uint64_t v62 = v58;
              }
              else {
                uint64_t v62 = -v58;
              }
              unint64_t v761 = v60;
              unint64_t v759 = v62;
              unsigned int v25 = &v59[2 * ((v58 * v51) & (v58 >> 63))];
              CGBlt_copyBytes(v55, v50, v61, v25, 2 * v60, 2 * v62);
              unsigned int v26 = v61;
            }
            else
            {
              uint64_t v705 = v759 - v18;
              uint64_t v706 = &v25[-2 * v45];
              if (v49 >= 0)
              {
                uint64_t v705 = v759 + v18;
                uint64_t v706 = v25;
              }
              if (v705 >= 0) {
                uint64_t v707 = v705;
              }
              else {
                uint64_t v707 = -v705;
              }
              unint64_t v759 = v707;
              unsigned int v25 = &v706[2 * ((v705 * v51) & (v705 >> 63))];
              CGBlt_fillBytes(v55, v50, -1, v25, 2 * v707);
              unsigned int v26 = v765;
            }
            goto LABEL_812;
          }
          unint64_t v10 = v712;
          uint64_t v8 = v713;
LABEL_45:
          int v24 = v721;
          int32x4_t v22 = v762;
          unsigned int v26 = v765;
LABEL_814:
          if (!v24) {
            return;
          }
          uint64_t v815 = 0;
          continue;
        case 2:
          uint64_t v63 = v21;
          uint64_t v64 = 8 * v21;
          if (v11)
          {
            unsigned int v65 = v816;
            v66.i64[0] = 0x100000001;
            v66.i64[1] = 0x100000001;
            do
            {
              int v67 = v18;
              do
              {
                unsigned int v68 = (unsigned __int16)*v26;
                unsigned int v69 = __rev16(v68);
                if (v69)
                {
                  if (v69 == 0xFFFF)
                  {
                    int8x8_t *v814 = *v813;
                  }
                  else
                  {
                    unint64_t v70 = ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16);
                    int v71 = v26;
                    unsigned int v72 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                    unsigned int v73 = bswap32(*(unsigned __int16 *)v25);
                    v74.i32[0] = (unsigned __int16)v72;
                    v74.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v72), 0x10uLL).i32[1];
                    v74.i32[2] = bswap32(v814->u16[2]) >> 16;
                    v74.i32[3] = bswap32(v814->u16[3]) >> 16;
                    unsigned int v75 = (unsigned __int16)~(_WORD)v69 * HIWORD(v73)
                        + (((unsigned __int16)~(_WORD)v69 * HIWORD(v73)) >> 16)
                        + 1;
                    unsigned int v26 = v71;
                    uint32x4_t v76 = (uint32x4_t)vmulq_s32(v74, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v69)));
                    v77.i32[0] = v70;
                    v77.i32[1] = WORD1(v70);
                    int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v77, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v70), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v76, v76, 0x10uLL), v66), 0x10uLL)));
                    unsigned int v68 = bswap32(v69 + HIWORD(v75)) >> 16;
                  }
                  *(_WORD *)unsigned int v25 = v68;
                }
                unsigned int v78 = (unsigned __int16 *)&v813[v63];
                if ((unint64_t)v78 >= v30) {
                  uint64_t v79 = -(uint64_t)v720;
                }
                else {
                  uint64_t v79 = 0;
                }
                v26 += v16 + v79;
                uint64_t v813 = (int8x8_t *)&v78[4 * v79];
                v814 = (int8x8_t *)((char *)v814 + v64);
                v25 += 2 * v11;
                --v67;
              }
              while (v67);
              if (v758)
              {
                int v80 = (unsigned __int16 *)&v22[v760];
                BOOL v81 = (unint64_t)v80 >= v758;
                if ((unint64_t)v80 >= v758) {
                  uint64_t v82 = -(uint64_t)(v760 * v719);
                }
                else {
                  uint64_t v82 = 0;
                }
                int32x4_t v22 = (int8x8_t *)&v80[4 * v82];
                unint64_t v83 = v30 + 8 * v82;
                if (v81) {
                  uint64_t v84 = -(uint64_t)(v761 * v719);
                }
                else {
                  uint64_t v84 = 0;
                }
                unsigned int v26 = &v764[v761 + v84];
                unint64_t v30 = v83 + 8 * v760;
                uint64_t v813 = v22;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v65;
            }
            while (v65);
          }
          else
          {
            unsigned int v575 = v816;
            v576.i64[0] = 0x100000001;
            v576.i64[1] = 0x100000001;
            do
            {
              int v577 = v18;
              do
              {
                unsigned int v578 = bswap32((unsigned __int16)*v26) >> 16;
                if (v578)
                {
                  if (v578 == 0xFFFF)
                  {
                    int8x8_t *v814 = *v813;
                  }
                  else
                  {
                    unint64_t v579 = ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16);
                    unsigned int v580 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                    v581.i32[0] = (unsigned __int16)v580;
                    v581.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v580), 0x10uLL).i32[1];
                    v581.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                    uint32x4_t v582 = (uint32x4_t)vmulq_s32(v581, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v578)));
                    v583.i32[0] = v579;
                    v583.i32[1] = WORD1(v579);
                    int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v583, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v579), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v582, v582, 0x10uLL), v576), 0x10uLL)));
                  }
                }
                unsigned int v584 = (unsigned __int16 *)&v813[v21];
                if ((unint64_t)v584 >= v30) {
                  uint64_t v585 = -(uint64_t)v720;
                }
                else {
                  uint64_t v585 = 0;
                }
                uint64_t v813 = (int8x8_t *)&v584[4 * v585];
                v26 += v16 + v585;
                v814 = (int8x8_t *)((char *)v814 + v64);
                --v577;
              }
              while (v577);
              if (v758)
              {
                int32x4_t v586 = (unsigned __int16 *)&v22[v760];
                BOOL v587 = (unint64_t)v586 >= v758;
                if ((unint64_t)v586 >= v758) {
                  uint64_t v588 = -(uint64_t)(v760 * v719);
                }
                else {
                  uint64_t v588 = 0;
                }
                int32x4_t v22 = (int8x8_t *)&v586[4 * v588];
                unint64_t v589 = v30 + 8 * v588;
                if (v587) {
                  uint64_t v590 = -(uint64_t)(v761 * v719);
                }
                else {
                  uint64_t v590 = 0;
                }
                unsigned int v26 = &v764[v761 + v590];
                unint64_t v30 = v589 + 8 * v760;
                uint64_t v813 = v22;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v575;
            }
            while (v575);
          }
          uint64_t v17 = v34;
          goto LABEL_729;
        case 3:
          uint64_t v762 = v22;
          uint64_t v85 = v21;
          if (!v16)
          {
            unsigned int v591 = v816;
            uint64_t v592 = 2 * v11;
            v593.i64[0] = 0x100000001;
            v593.i64[1] = 0x100000001;
            do
            {
              int v594 = v18;
              do
              {
                unsigned int v595 = bswap32(*(unsigned __int16 *)v25) >> 16;
                if (v595 == 0xFFFF)
                {
                  int8x8_t *v814 = *v813;
                }
                else if (v595)
                {
                  unsigned int v596 = bswap32(v813->u16[1] | (v813->u16[0] << 16));
                  v597.i32[0] = (unsigned __int16)v596;
                  v597.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v596), 0x10uLL).i32[1];
                  v597.i64[1] = __PAIR64__(bswap32(v813->u16[3]) >> 16, bswap32(v813->u16[2]) >> 16);
                  uint32x4_t v598 = (uint32x4_t)vmulq_s32(v597, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v595)));
                  v597.i32[0] = v596;
                  int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v597, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v598, v598, 0x10uLL), v593), 0x10uLL))));
                }
                else
                {
                  int8x8_t *v814 = 0;
                }
                int v599 = (unsigned __int16 *)&v813[v21];
                if ((unint64_t)v599 >= v30) {
                  uint64_t v600 = -(uint64_t)v720;
                }
                else {
                  uint64_t v600 = 0;
                }
                uint64_t v813 = (int8x8_t *)&v599[4 * v600];
                v26 += v600;
                v814 += v21;
                v25 += v592;
                --v594;
              }
              while (v594);
              if (v758)
              {
                unint64_t v601 = (unint64_t)&v762[v760];
                BOOL v602 = v601 >= v758;
                if (v601 >= v758) {
                  uint64_t v603 = -(uint64_t)(v760 * v719);
                }
                else {
                  uint64_t v603 = 0;
                }
                int32x4_t v604 = (int8x8_t *)(v601 + 8 * v603);
                unint64_t v605 = v30 + 8 * v603;
                if (v602) {
                  uint64_t v606 = -(uint64_t)(v761 * v719);
                }
                else {
                  uint64_t v606 = 0;
                }
                unsigned int v26 = &v764[v761 + v606];
                unint64_t v30 = v605 + 8 * v760;
                uint64_t v813 = v604;
                uint64_t v762 = v604;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v591;
            }
            while (v591);
            goto LABEL_793;
          }
          unsigned int v86 = v816;
          uint64_t v87 = 2 * v11;
          do
          {
            unsigned int v789 = v86;
            int v88 = v18;
            do
            {
              unsigned int v89 = bswap32(*(unsigned __int16 *)v25) >> 16;
              if (v89 == 0xFFFF)
              {
                int8x8_t *v814 = *v813;
                *(_WORD *)unsigned int v25 = *v26;
              }
              else if (v89)
              {
                unint64_t v90 = v30;
                unint64_t v91 = v26;
                CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), bswap32((unsigned __int16)*v26) >> 16, v89);
                unsigned int v26 = v91;
                unint64_t v30 = v90;
              }
              else
              {
                int8x8_t *v814 = 0;
                *(_WORD *)unsigned int v25 = 0;
              }
              unint64_t v92 = (unsigned __int16 *)&v813[v85];
              if ((unint64_t)v92 >= v30) {
                uint64_t v93 = -(uint64_t)v720;
              }
              else {
                uint64_t v93 = 0;
              }
              v26 += v16 + v93;
              uint64_t v813 = (int8x8_t *)&v92[4 * v93];
              v814 += v85;
              v25 += v87;
              --v88;
            }
            while (v88);
            if (v758)
            {
              unint64_t v94 = (unint64_t)&v762[v760];
              BOOL v95 = v94 >= v758;
              uint64_t v96 = -(uint64_t)(v760 * v719);
              if (v94 < v758) {
                uint64_t v96 = 0;
              }
              unint64_t v97 = (int8x8_t *)(v94 + 8 * v96);
              unint64_t v98 = v30 + 8 * v96;
              uint64_t v99 = -(uint64_t)(v761 * v719);
              if (!v95) {
                uint64_t v99 = 0;
              }
              unsigned int v26 = &v764[v761 + v99];
              unint64_t v30 = v98 + 8 * v760;
              uint64_t v813 = v97;
              uint64_t v762 = v97;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v86 = v789 - 1;
          }
          while (v789 != 1);
          goto LABEL_811;
        case 4:
          uint64_t v762 = v22;
          uint64_t v100 = v21;
          uint64_t v101 = v16;
          unsigned int v102 = v816;
          uint64_t v103 = 8 * v21;
          uint64_t v104 = 2 * v11;
          do
          {
            unsigned int v766 = v102;
            int v105 = v18;
            unint64_t v790 = v30;
            do
            {
              unsigned int v106 = bswap32(~*(unsigned __int16 *)v25) >> 16;
              if (v106 == 0xFFFF)
              {
                if (v16) {
                  unsigned int v107 = bswap32((unsigned __int16)*v26) >> 16;
                }
                else {
                  unsigned int v107 = 0xFFFF;
                }
                *(_WORD *)unsigned int v25 = __rev16(v107);
              }
              else if (v106)
              {
                int v108 = v26;
                if (v16) {
                  unsigned int v109 = bswap32((unsigned __int16)*v26) >> 16;
                }
                else {
                  unsigned int v109 = 0xFFFF;
                }
                CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v109, v106);
                unint64_t v30 = v790;
                int v16 = v812;
                unsigned int v26 = v108;
              }
              else
              {
                int8x8_t *v814 = 0;
                *(_WORD *)unsigned int v25 = 0;
              }
              unsigned int v110 = (unsigned __int16 *)&v813[v100];
              if ((unint64_t)v110 >= v30) {
                uint64_t v111 = -(uint64_t)v720;
              }
              else {
                uint64_t v111 = 0;
              }
              v26 += v101 + v111;
              uint64_t v813 = (int8x8_t *)&v110[4 * v111];
              v814 = (int8x8_t *)((char *)v814 + v103);
              v25 += v104;
              --v105;
            }
            while (v105);
            if (v758)
            {
              unint64_t v112 = (unint64_t)&v762[v760];
              BOOL v113 = v112 >= v758;
              uint64_t v114 = -(uint64_t)(v760 * v719);
              if (v112 < v758) {
                uint64_t v114 = 0;
              }
              uint64_t v115 = (int8x8_t *)(v112 + 8 * v114);
              unint64_t v116 = v30 + 8 * v114;
              uint64_t v117 = -(uint64_t)(v761 * v719);
              if (!v113) {
                uint64_t v117 = 0;
              }
              unsigned int v26 = &v764[v761 + v117];
              unint64_t v30 = v116 + 8 * v760;
              uint64_t v813 = v115;
              uint64_t v762 = v115;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v102 = v766 - 1;
          }
          while (v766 != 1);
          goto LABEL_811;
        case 5:
          uint64_t v762 = v22;
          uint64_t v118 = v21;
          int v737 = v18;
          unsigned int v119 = v816;
          uint64_t v120 = 8 * v21;
          uint64_t v121 = 2 * v11;
          do
          {
            unsigned int v791 = v119;
            int v122 = v737;
            do
            {
              uint64_t v767 = v26;
              unsigned int v123 = bswap32((unsigned __int16)*v26) >> 16;
              unint64_t v124 = v30;
              unsigned int v125 = bswap32(*(unsigned __int16 *)v25) >> 16;
              CMYK64_DAMplusDAM(v814, v25, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v123, v125, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v125, v123 ^ 0xFFFF);
              unint64_t v30 = v124;
              unint64_t v126 = (unsigned __int16 *)&v813[v118];
              if ((unint64_t)v126 >= v124) {
                uint64_t v127 = -(uint64_t)v720;
              }
              else {
                uint64_t v127 = 0;
              }
              unsigned int v26 = &v767[v16 + v127];
              uint64_t v813 = (int8x8_t *)&v126[4 * v127];
              v814 = (int8x8_t *)((char *)v814 + v120);
              v25 += v121;
              --v122;
            }
            while (v122);
            if (v758)
            {
              unint64_t v128 = (unint64_t)&v762[v760];
              BOOL v129 = v128 >= v758;
              uint64_t v130 = -(uint64_t)(v760 * v719);
              if (v128 < v758) {
                uint64_t v130 = 0;
              }
              unint64_t v131 = (int8x8_t *)(v128 + 8 * v130);
              unint64_t v132 = v124 + 8 * v130;
              uint64_t v133 = -(uint64_t)(v761 * v719);
              if (!v129) {
                uint64_t v133 = 0;
              }
              unsigned int v26 = &v764[v761 + v133];
              unint64_t v30 = v132 + 8 * v760;
              uint64_t v813 = v131;
              uint64_t v762 = v131;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v119 = v791 - 1;
          }
          while (v791 != 1);
          goto LABEL_811;
        case 6:
          uint64_t v17 = v34;
          uint64_t v134 = v21;
          unsigned int v135 = v816;
          uint64_t v136 = 8 * v21;
          v137.i64[0] = 0x100000001;
          v137.i64[1] = 0x100000001;
          do
          {
            unsigned int v138 = v22;
            int v139 = v18;
            unint64_t v140 = v30;
            do
            {
              unsigned int v141 = bswap32(*(unsigned __int16 *)v25);
              if (HIWORD(v141) != 0xFFFF)
              {
                if ((unsigned __int16)~HIWORD(v141) == 0xFFFF)
                {
                  int8x8_t *v814 = *v813;
                  if (v16) {
                    unsigned int v142 = bswap32((unsigned __int16)*v26) >> 16;
                  }
                  else {
                    unsigned int v142 = 0xFFFF;
                  }
                }
                else
                {
                  uint64_t v143 = v26;
                  if (v16) {
                    unsigned int v144 = bswap32((unsigned __int16)*v26) >> 16;
                  }
                  else {
                    unsigned int v144 = 0xFFFF;
                  }
                  unsigned int v145 = HIWORD(v141);
                  unsigned int v146 = ~HIWORD(v141);
                  unint64_t v147 = ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16);
                  unsigned int v148 = bswap32(v813->u16[1] | (v813->u16[0] << 16));
                  v149.i32[0] = (unsigned __int16)v148;
                  v149.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v148), 0x10uLL).i32[1];
                  v149.i32[2] = bswap32(v813->u16[2]) >> 16;
                  v149.i32[3] = bswap32(v813->u16[3]) >> 16;
                  uint32x4_t v150 = (uint32x4_t)vmulq_s32(v149, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v146)));
                  v151.i32[0] = v147;
                  v151.i32[1] = WORD1(v147);
                  int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v151, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v147), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v150, v150, 0x10uLL), v137), 0x10uLL)));
                  unsigned int v142 = v145 + (((unsigned __int16)v146 * v144 + (((unsigned __int16)v146 * v144) >> 16) + 1) >> 16);
                  unint64_t v30 = v140;
                  unsigned int v26 = v143;
                }
                *(_WORD *)unsigned int v25 = bswap32(v142) >> 16;
              }
              uint64_t v152 = (unsigned __int16 *)&v813[v134];
              if ((unint64_t)v152 >= v30) {
                uint64_t v153 = -(uint64_t)v720;
              }
              else {
                uint64_t v153 = 0;
              }
              v26 += v16 + v153;
              uint64_t v813 = (int8x8_t *)&v152[4 * v153];
              v814 = (int8x8_t *)((char *)v814 + v136);
              v25 += 2 * v11;
              --v139;
            }
            while (v139);
            if (v758)
            {
              unint64_t v154 = (unint64_t)&v138[v760];
              BOOL v155 = v154 >= v758;
              if (v154 >= v758) {
                uint64_t v156 = -(uint64_t)(v760 * v719);
              }
              else {
                uint64_t v156 = 0;
              }
              int32x4_t v22 = (int8x8_t *)(v154 + 8 * v156);
              unint64_t v157 = v30 + 8 * v156;
              if (v155) {
                uint64_t v158 = -(uint64_t)(v761 * v719);
              }
              else {
                uint64_t v158 = 0;
              }
              unsigned int v26 = &v764[v761 + v158];
              unint64_t v30 = v157 + 8 * v760;
              uint64_t v813 = v22;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
              int32x4_t v22 = v138;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v135;
          }
          while (v135);
LABEL_729:
          uint64_t v788 = v30;
          unsigned int v816 = 0;
          int v24 = v721;
          uint64_t v8 = v713;
          goto LABEL_814;
        case 7:
          uint64_t v762 = v22;
          uint64_t v159 = v21;
          if (v11)
          {
            unsigned int v160 = v816;
            uint64_t v161 = 2 * v11;
            do
            {
              int v162 = v18;
              do
              {
                unsigned int v163 = bswap32((unsigned __int16)*v26) >> 16;
                if (v163 != 0xFFFF)
                {
                  if (v163)
                  {
                    unint64_t v164 = v30;
                    uint64_t v165 = v26;
                    CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, v163);
                    unsigned int v26 = v165;
                    unint64_t v30 = v164;
                  }
                  else
                  {
                    int8x8_t *v814 = 0;
                    *(_WORD *)unsigned int v25 = 0;
                  }
                }
                unsigned int v166 = (unsigned __int16 *)&v813[v159];
                if ((unint64_t)v166 >= v30) {
                  uint64_t v167 = -(uint64_t)v720;
                }
                else {
                  uint64_t v167 = 0;
                }
                v26 += v16 + v167;
                uint64_t v813 = (int8x8_t *)&v166[4 * v167];
                v814 += v159;
                v25 += v161;
                --v162;
              }
              while (v162);
              if (v758)
              {
                unint64_t v168 = (unint64_t)&v762[v760];
                BOOL v169 = v168 >= v758;
                uint64_t v170 = -(uint64_t)(v760 * v719);
                if (v168 < v758) {
                  uint64_t v170 = 0;
                }
                uint64_t v171 = (int8x8_t *)(v168 + 8 * v170);
                unint64_t v172 = v30 + 8 * v170;
                uint64_t v173 = -(uint64_t)(v761 * v719);
                if (!v169) {
                  uint64_t v173 = 0;
                }
                unsigned int v26 = &v764[v761 + v173];
                unint64_t v30 = v172 + 8 * v760;
                uint64_t v813 = v171;
                uint64_t v762 = v171;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v160;
            }
            while (v160);
            goto LABEL_811;
          }
          unsigned int v607 = v816;
          v608.i64[0] = 0x100000001;
          v608.i64[1] = 0x100000001;
          do
          {
            int v609 = v18;
            do
            {
              unsigned int v610 = bswap32((unsigned __int16)*v26) >> 16;
              if (v610 != 0xFFFF)
              {
                if (v610)
                {
                  unsigned int v611 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                  v612.i32[0] = (unsigned __int16)v611;
                  v612.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v611), 0x10uLL).i32[1];
                  v612.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                  uint32x4_t v613 = (uint32x4_t)vmulq_s32(v612, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v610)));
                  v612.i32[0] = v611;
                  int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v612, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v613, v613, 0x10uLL), v608), 0x10uLL))));
                }
                else
                {
                  int8x8_t *v814 = 0;
                }
              }
              unsigned int v614 = (unsigned __int16 *)&v813[v21];
              if ((unint64_t)v614 >= v30) {
                uint64_t v615 = -(uint64_t)v720;
              }
              else {
                uint64_t v615 = 0;
              }
              uint64_t v813 = (int8x8_t *)&v614[4 * v615];
              v26 += v16 + v615;
              v814 += v21;
              --v609;
            }
            while (v609);
            if (v758)
            {
              unint64_t v616 = (unint64_t)&v762[v760];
              BOOL v617 = v616 >= v758;
              if (v616 >= v758) {
                uint64_t v618 = -(uint64_t)(v760 * v719);
              }
              else {
                uint64_t v618 = 0;
              }
              unint64_t v619 = (int8x8_t *)(v616 + 8 * v618);
              unint64_t v620 = v30 + 8 * v618;
              if (v617) {
                uint64_t v621 = -(uint64_t)(v761 * v719);
              }
              else {
                uint64_t v621 = 0;
              }
              unsigned int v26 = &v764[v761 + v621];
              unint64_t v30 = v620 + 8 * v760;
              uint64_t v813 = v619;
              uint64_t v762 = v619;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v607;
          }
          while (v607);
          goto LABEL_793;
        case 8:
          uint64_t v762 = v22;
          uint64_t v174 = v21;
          if (v11)
          {
            unsigned int v175 = v816;
            uint64_t v176 = 2 * v11;
            do
            {
              int v177 = v18;
              do
              {
                unsigned int v178 = bswap32(~(unsigned __int16)*v26) >> 16;
                if (v178 != 0xFFFF)
                {
                  if (v178)
                  {
                    unint64_t v179 = v30;
                    unsigned int v180 = v26;
                    CMYK64_DAM(v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, v178);
                    unsigned int v26 = v180;
                    unint64_t v30 = v179;
                  }
                  else
                  {
                    int8x8_t *v814 = 0;
                    *(_WORD *)unsigned int v25 = 0;
                  }
                }
                unsigned int v181 = (unsigned __int16 *)&v813[v174];
                if ((unint64_t)v181 >= v30) {
                  uint64_t v182 = -(uint64_t)v720;
                }
                else {
                  uint64_t v182 = 0;
                }
                v26 += v16 + v182;
                uint64_t v813 = (int8x8_t *)&v181[4 * v182];
                v814 += v174;
                v25 += v176;
                --v177;
              }
              while (v177);
              if (v758)
              {
                unint64_t v183 = (unint64_t)&v762[v760];
                BOOL v184 = v183 >= v758;
                uint64_t v185 = -(uint64_t)(v760 * v719);
                if (v183 < v758) {
                  uint64_t v185 = 0;
                }
                unint64_t v186 = (int8x8_t *)(v183 + 8 * v185);
                unint64_t v187 = v30 + 8 * v185;
                uint64_t v188 = -(uint64_t)(v761 * v719);
                if (!v184) {
                  uint64_t v188 = 0;
                }
                unsigned int v26 = &v764[v761 + v188];
                unint64_t v30 = v187 + 8 * v760;
                uint64_t v813 = v186;
                uint64_t v762 = v186;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v175;
            }
            while (v175);
            goto LABEL_811;
          }
          unsigned int v622 = v816;
          v623.i64[0] = 0x100000001;
          v623.i64[1] = 0x100000001;
          do
          {
            int v624 = v18;
            do
            {
              unsigned int v625 = bswap32(~(unsigned __int16)*v26) >> 16;
              if (v625 != 0xFFFF)
              {
                if (v625)
                {
                  unsigned int v626 = bswap32(v814->u16[1] | (v814->u16[0] << 16));
                  v627.i32[0] = (unsigned __int16)v626;
                  v627.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v626), 0x10uLL).i32[1];
                  v627.i64[1] = __PAIR64__(bswap32(v814->u16[3]) >> 16, bswap32(v814->u16[2]) >> 16);
                  uint32x4_t v628 = (uint32x4_t)vmulq_s32(v627, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v625)));
                  v627.i32[0] = v626;
                  int8x8_t *v814 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v627, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v628, v628, 0x10uLL), v623), 0x10uLL))));
                }
                else
                {
                  int8x8_t *v814 = 0;
                }
              }
              uint32x4_t v629 = (unsigned __int16 *)&v813[v21];
              if ((unint64_t)v629 >= v30) {
                uint64_t v630 = -(uint64_t)v720;
              }
              else {
                uint64_t v630 = 0;
              }
              uint64_t v813 = (int8x8_t *)&v629[4 * v630];
              v26 += v16 + v630;
              v814 += v21;
              --v624;
            }
            while (v624);
            if (v758)
            {
              unint64_t v631 = (unint64_t)&v762[v760];
              BOOL v632 = v631 >= v758;
              if (v631 >= v758) {
                uint64_t v633 = -(uint64_t)(v760 * v719);
              }
              else {
                uint64_t v633 = 0;
              }
              uint64_t v634 = (int8x8_t *)(v631 + 8 * v633);
              unint64_t v635 = v30 + 8 * v633;
              if (v632) {
                uint64_t v636 = -(uint64_t)(v761 * v719);
              }
              else {
                uint64_t v636 = 0;
              }
              unsigned int v26 = &v764[v761 + v636];
              unint64_t v30 = v635 + 8 * v760;
              uint64_t v813 = v634;
              uint64_t v762 = v634;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            --v622;
          }
          while (v622);
LABEL_793:
          uint64_t v17 = v34;
          uint64_t v788 = v30;
          unsigned int v816 = 0;
          goto LABEL_813;
        case 9:
          uint64_t v762 = v22;
          uint64_t v189 = v21;
          int v738 = v18;
          unsigned int v190 = v816;
          uint64_t v191 = 8 * v21;
          uint64_t v192 = 2 * v11;
          uint64_t v193 = -(uint64_t)v720;
          do
          {
            unsigned int v792 = v190;
            int v194 = v738;
            do
            {
              uint64_t v768 = v26;
              unsigned int v195 = v25;
              unsigned int v196 = bswap32(*(unsigned __int16 *)v25) >> 16;
              unsigned int v197 = bswap32((unsigned __int16)*v26) >> 16;
              int v198 = v25;
              unint64_t v199 = v30;
              uint64_t v200 = v193;
              CMYK64_DAMplusDAM(v814, v198, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v197, v196 ^ 0xFFFF, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v196, v197);
              uint64_t v193 = v200;
              unint64_t v30 = v199;
              unsigned int v201 = (unsigned __int16 *)&v813[v189];
              if ((unint64_t)v201 >= v199) {
                uint64_t v202 = v200;
              }
              else {
                uint64_t v202 = 0;
              }
              unsigned int v26 = &v768[v16 + v202];
              uint64_t v813 = (int8x8_t *)&v201[4 * v202];
              v814 = (int8x8_t *)((char *)v814 + v191);
              unsigned int v25 = &v195[v192];
              --v194;
            }
            while (v194);
            if (v758)
            {
              unint64_t v203 = (unint64_t)&v762[v760];
              BOOL v204 = v203 >= v758;
              uint64_t v205 = -(uint64_t)(v760 * v719);
              if (v203 < v758) {
                uint64_t v205 = 0;
              }
              unsigned int v206 = (int8x8_t *)(v203 + 8 * v205);
              unint64_t v207 = v199 + 8 * v205;
              uint64_t v208 = -(uint64_t)(v761 * v719);
              if (!v204) {
                uint64_t v208 = 0;
              }
              unsigned int v26 = &v764[v761 + v208];
              unint64_t v30 = v207 + 8 * v760;
              uint64_t v813 = v206;
              uint64_t v762 = v206;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v190 = v792 - 1;
          }
          while (v792 != 1);
          goto LABEL_811;
        case 10:
          uint64_t v762 = v22;
          uint64_t v209 = v21;
          int v739 = v18;
          unsigned int v210 = v816;
          uint64_t v211 = 8 * v21;
          uint64_t v212 = 2 * v11;
          uint64_t v213 = -(uint64_t)v720;
          do
          {
            unsigned int v793 = v210;
            int v214 = v739;
            do
            {
              unint64_t v769 = v26;
              unsigned int v215 = bswap32(*(unsigned __int16 *)v25) >> 16;
              unsigned int v216 = bswap32((unsigned __int16)*v26) >> 16;
              unint64_t v217 = v30;
              int v218 = v25;
              int v219 = v25;
              uint64_t v220 = v213;
              CMYK64_DAMplusDAM(v814, v218, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v216, v215 ^ 0xFFFF, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v215, v216 ^ 0xFFFF);
              uint64_t v213 = v220;
              unint64_t v30 = v217;
              unint64_t v221 = (unsigned __int16 *)&v813[v209];
              if ((unint64_t)v221 >= v217) {
                uint64_t v222 = v220;
              }
              else {
                uint64_t v222 = 0;
              }
              unsigned int v26 = &v769[v16 + v222];
              uint64_t v813 = (int8x8_t *)&v221[4 * v222];
              v814 = (int8x8_t *)((char *)v814 + v211);
              unsigned int v25 = &v219[v212];
              --v214;
            }
            while (v214);
            if (v758)
            {
              unint64_t v223 = (unint64_t)&v762[v760];
              BOOL v224 = v223 >= v758;
              uint64_t v225 = -(uint64_t)(v760 * v719);
              if (v223 < v758) {
                uint64_t v225 = 0;
              }
              int v226 = (int8x8_t *)(v223 + 8 * v225);
              unint64_t v227 = v217 + 8 * v225;
              uint64_t v228 = -(uint64_t)(v761 * v719);
              if (!v224) {
                uint64_t v228 = 0;
              }
              unsigned int v26 = &v764[v761 + v228];
              unint64_t v30 = v227 + 8 * v760;
              uint64_t v813 = v226;
              uint64_t v762 = v226;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v210 = v793 - 1;
          }
          while (v793 != 1);
          goto LABEL_811;
        case 11:
          uint64_t v762 = v22;
          int v740 = v18;
          uint64_t v229 = v21;
          uint64_t v794 = 8 * v21;
          uint64_t v230 = v16;
          if (v11)
          {
            unsigned int v231 = v816;
            uint64_t v232 = 2 * v11;
            do
            {
              unsigned int v770 = v231;
              int v233 = v740;
              unint64_t v234 = v30;
              do
              {
                int32x4_t v235 = v26;
                if (v16) {
                  unsigned int v236 = bswap32((unsigned __int16)*v26) >> 16;
                }
                else {
                  unsigned int v236 = 0xFFFF;
                }
                CMYK64_DAplusdDA((int *)v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v236);
                unsigned int v237 = (unsigned __int16 *)&v813[v229];
                if ((unint64_t)v237 >= v234) {
                  uint64_t v238 = -(uint64_t)v720;
                }
                else {
                  uint64_t v238 = 0;
                }
                unsigned int v26 = &v235[v230 + v238];
                int v16 = v812;
                uint64_t v813 = (int8x8_t *)&v237[4 * v238];
                v814 = (int8x8_t *)((char *)v814 + v794);
                v25 += v232;
                --v233;
              }
              while (v233);
              unint64_t v30 = v234;
              if (v758)
              {
                unint64_t v239 = (unint64_t)&v762[v760];
                BOOL v240 = v239 >= v758;
                uint64_t v241 = -(uint64_t)(v760 * v719);
                if (v239 < v758) {
                  uint64_t v241 = 0;
                }
                int32x4_t v242 = (int8x8_t *)(v239 + 8 * v241);
                unint64_t v243 = v234 + 8 * v241;
                uint64_t v244 = -(uint64_t)(v761 * v719);
                if (!v240) {
                  uint64_t v244 = 0;
                }
                unsigned int v26 = &v764[v761 + v244];
                unint64_t v30 = v243 + 8 * v760;
                uint64_t v813 = v242;
                uint64_t v762 = v242;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              unsigned int v231 = v770 - 1;
            }
            while (v770 != 1);
          }
          else
          {
            unsigned int v637 = v816;
            do
            {
              int v638 = v740;
              unint64_t v639 = v30;
              do
              {
                if (v16) {
                  unsigned int v640 = bswap32((unsigned __int16)*v26) >> 16;
                }
                else {
                  unsigned int v640 = 0xFFFF;
                }
                int v641 = v26;
                CMYK64_DplusdDA(v814, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v640);
                uint64_t v642 = (unsigned __int16 *)&v813[v229];
                if ((unint64_t)v642 >= v639) {
                  uint64_t v643 = -(uint64_t)v720;
                }
                else {
                  uint64_t v643 = 0;
                }
                unsigned int v26 = &v641[v230 + v643];
                int v16 = v812;
                uint64_t v813 = (int8x8_t *)&v642[4 * v643];
                v814 = (int8x8_t *)((char *)v814 + v794);
                --v638;
              }
              while (v638);
              unint64_t v30 = v639;
              if (v758)
              {
                unint64_t v644 = (unint64_t)&v762[v760];
                BOOL v645 = v644 >= v758;
                uint64_t v646 = -(uint64_t)(v760 * v719);
                if (v644 < v758) {
                  uint64_t v646 = 0;
                }
                uint64_t v647 = (int8x8_t *)(v644 + 8 * v646);
                unint64_t v648 = v639 + 8 * v646;
                uint64_t v649 = -(uint64_t)(v761 * v719);
                if (!v645) {
                  uint64_t v649 = 0;
                }
                unsigned int v26 = &v764[v761 + v649];
                unint64_t v30 = v648 + 8 * v760;
                uint64_t v813 = v647;
                uint64_t v762 = v647;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              --v637;
            }
            while (v637);
          }
          goto LABEL_811;
        case 12:
          int v741 = v18;
          if (v11)
          {
            uint64_t v762 = v22;
            uint64_t v795 = v21;
            uint64_t v245 = v16;
            unsigned int v246 = v816;
            uint64_t v247 = 8 * v21;
            uint64_t v248 = 2 * v11;
            do
            {
              unsigned int v771 = v246;
              int v249 = v18;
              unint64_t v250 = v30;
              do
              {
                int32x4_t v251 = v26;
                if (v16) {
                  unsigned int v252 = bswap32((unsigned __int16)*v26) >> 16;
                }
                else {
                  unsigned int v252 = 0xFFFF;
                }
                CMYK64_DApluslDA((unsigned int *)v814, v25, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), bswap32(*(unsigned __int16 *)v25) >> 16, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v252);
                int v16 = v812;
                int32x4_t v253 = (unsigned __int16 *)&v813[v795];
                if ((unint64_t)v253 >= v250) {
                  uint64_t v254 = -(uint64_t)v720;
                }
                else {
                  uint64_t v254 = 0;
                }
                unsigned int v26 = &v251[v245 + v254];
                uint64_t v813 = (int8x8_t *)&v253[4 * v254];
                v814 = (int8x8_t *)((char *)v814 + v247);
                v25 += v248;
                --v249;
              }
              while (v249);
              unint64_t v30 = v250;
              if (v758)
              {
                unint64_t v255 = (unint64_t)&v762[v760];
                BOOL v256 = v255 >= v758;
                uint64_t v257 = -(uint64_t)(v760 * v719);
                if (v255 < v758) {
                  uint64_t v257 = 0;
                }
                int32x4_t v258 = (int8x8_t *)(v255 + 8 * v257);
                unint64_t v259 = v250 + 8 * v257;
                uint64_t v260 = -(uint64_t)(v761 * v719);
                if (!v256) {
                  uint64_t v260 = 0;
                }
                unsigned int v26 = &v764[v761 + v260];
                unint64_t v30 = v259 + 8 * v760;
                uint64_t v813 = v258;
                uint64_t v762 = v258;
                unint64_t v764 = v26;
              }
              else
              {
                v813 += v760;
                v26 += v761;
              }
              v814 += v757;
              v25 += 2 * v759;
              unsigned int v246 = v771 - 1;
            }
            while (v771 != 1);
            goto LABEL_811;
          }
          uint64_t v661 = v21;
          unsigned int v662 = v816;
          uint64_t v663 = 8 * v21;
          do
          {
            unsigned int v811 = v662;
            unint64_t v763 = v22;
            int v664 = v741;
            do
            {
              unint64_t v665 = v30;
              uint64_t v666 = v26;
              CMYK64_DpluslD(v814, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16));
              unint64_t v30 = v665;
              uint64_t v667 = (unsigned __int16 *)&v813[v661];
              if ((unint64_t)v667 >= v665) {
                uint64_t v668 = -(uint64_t)v720;
              }
              else {
                uint64_t v668 = 0;
              }
              unsigned int v26 = &v666[v16 + v668];
              uint64_t v813 = (int8x8_t *)&v667[4 * v668];
              v814 = (int8x8_t *)((char *)v814 + v663);
              --v664;
            }
            while (v664);
            if (v758)
            {
              unint64_t v669 = (unint64_t)&v763[v760];
              BOOL v670 = v669 >= v758;
              uint64_t v671 = -(uint64_t)(v760 * v719);
              if (v669 < v758) {
                uint64_t v671 = 0;
              }
              int32x4_t v22 = (int8x8_t *)(v669 + 8 * v671);
              unint64_t v672 = v665 + 8 * v671;
              uint64_t v673 = -(uint64_t)(v761 * v719);
              if (!v670) {
                uint64_t v673 = 0;
              }
              unsigned int v26 = &v764[v761 + v673];
              unint64_t v30 = v672 + 8 * v760;
              uint64_t v813 = v22;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              int32x4_t v22 = v763;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v662 = v811 - 1;
          }
          while (v811 != 1);
          uint64_t v788 = v30;
          unsigned int v816 = 0;
          uint64_t v17 = v711;
          unint64_t v10 = v712;
          uint64_t v8 = v713;
LABEL_912:
          int v24 = v721;
          goto LABEL_814;
        case 13:
          uint64_t v762 = v22;
          int v742 = v18;
          uint64_t v772 = v21;
          uint64_t v261 = v16;
          unsigned int v262 = v816;
          uint64_t v263 = 8 * v21;
          uint64_t v264 = 2 * v11;
          while (1)
          {
            unsigned int v722 = v262;
            int v265 = v742;
            unint64_t v796 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_303;
                }
                LODWORD(v266) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_296:
                  uint64_t v267 = v26;
                  unsigned int v268 = 0xFFFF;
                  goto LABEL_297;
                }
              }
              else
              {
                LODWORD(v266) = 0xFFFF;
                if (!v11) {
                  goto LABEL_296;
                }
              }
              if (*(_WORD *)v25)
              {
                uint64_t v267 = v26;
                unsigned int v268 = __rev16(*(unsigned __int16 *)v25);
LABEL_297:
                uint64_t v269 = (char *)v814 + 6;
                unint64_t v270 = PDAmultiplyPDA_11710(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v268, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v266);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v266) = v271;
                  unsigned int v272 = bswap32(v270);
                  v814->i16[0] = HIWORD(v272);
                  v814->i16[1] = v272;
                  v814->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v270));
                  uint64_t v269 = v25;
                }
                else
                {
                  unint64_t v266 = HIWORD(v270);
                  unsigned int v273 = bswap32(v270);
                  v814->i16[0] = HIWORD(v273);
                  v814->i16[1] = v273;
                  v814->i16[2] = bswap32(HIDWORD(v270)) >> 16;
                }
                unint64_t v30 = v796;
                int v16 = v812;
                unsigned int v26 = v267;
                goto LABEL_302;
              }
              int8x8_t *v814 = *v813;
              uint64_t v269 = v25;
LABEL_302:
              *(_WORD *)uint64_t v269 = bswap32(v266) >> 16;
LABEL_303:
              v25 += v264;
              unsigned int v274 = (unsigned __int16 *)&v813[v772];
              if ((unint64_t)v274 >= v30) {
                uint64_t v275 = -(uint64_t)v720;
              }
              else {
                uint64_t v275 = 0;
              }
              v26 += v261 + v275;
              uint64_t v813 = (int8x8_t *)&v274[4 * v275];
              v814 = (int8x8_t *)((char *)v814 + v263);
              --v265;
            }
            while (v265);
            if (v758)
            {
              unint64_t v276 = (unint64_t)&v762[v760];
              BOOL v277 = v276 >= v758;
              uint64_t v278 = -(uint64_t)(v760 * v719);
              if (v276 < v758) {
                uint64_t v278 = 0;
              }
              int v279 = (int8x8_t *)(v276 + 8 * v278);
              unint64_t v280 = v30 + 8 * v278;
              uint64_t v281 = -(uint64_t)(v761 * v719);
              if (!v277) {
                uint64_t v281 = 0;
              }
              unsigned int v26 = &v764[v761 + v281];
              unint64_t v30 = v280 + 8 * v760;
              uint64_t v813 = v279;
              uint64_t v762 = v279;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v262 = v722 - 1;
            if (v722 == 1) {
              goto LABEL_811;
            }
          }
        case 14:
          uint64_t v762 = v22;
          int v743 = v18;
          uint64_t v773 = v21;
          uint64_t v282 = v16;
          unsigned int v283 = v816;
          uint64_t v284 = 8 * v21;
          uint64_t v285 = 2 * v11;
          while (1)
          {
            unsigned int v723 = v283;
            int v286 = v743;
            unint64_t v797 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_331;
                }
                LODWORD(v287) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_324:
                  long long v288 = v26;
                  unsigned int v289 = 0xFFFF;
                  goto LABEL_325;
                }
              }
              else
              {
                LODWORD(v287) = 0xFFFF;
                if (!v11) {
                  goto LABEL_324;
                }
              }
              if (*(_WORD *)v25)
              {
                long long v288 = v26;
                unsigned int v289 = __rev16(*(unsigned __int16 *)v25);
LABEL_325:
                long long v290 = (char *)v814 + 6;
                unint64_t v291 = PDAscreenPDA_11711(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v289, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v287);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v287) = v292;
                  unsigned int v293 = bswap32(v291);
                  v814->i16[0] = HIWORD(v293);
                  v814->i16[1] = v293;
                  v814->i16[2] = bswap32(HIDWORD(v291)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v291));
                  long long v290 = v25;
                }
                else
                {
                  unsigned int v294 = bswap32(v291);
                  v814->i16[0] = HIWORD(v294);
                  v814->i16[1] = v294;
                  v814->i16[2] = bswap32(HIDWORD(v291)) >> 16;
                  unint64_t v287 = HIWORD(v291);
                }
                unint64_t v30 = v797;
                int v16 = v812;
                unsigned int v26 = v288;
                goto LABEL_330;
              }
              int8x8_t *v814 = *v813;
              long long v290 = v25;
LABEL_330:
              *(_WORD *)long long v290 = bswap32(v287) >> 16;
LABEL_331:
              v25 += v285;
              long long v295 = (unsigned __int16 *)&v813[v773];
              if ((unint64_t)v295 >= v30) {
                uint64_t v296 = -(uint64_t)v720;
              }
              else {
                uint64_t v296 = 0;
              }
              v26 += v282 + v296;
              uint64_t v813 = (int8x8_t *)&v295[4 * v296];
              v814 = (int8x8_t *)((char *)v814 + v284);
              --v286;
            }
            while (v286);
            if (v758)
            {
              unint64_t v297 = (unint64_t)&v762[v760];
              BOOL v298 = v297 >= v758;
              uint64_t v299 = -(uint64_t)(v760 * v719);
              if (v297 < v758) {
                uint64_t v299 = 0;
              }
              unint64_t v300 = (int8x8_t *)(v297 + 8 * v299);
              unint64_t v301 = v30 + 8 * v299;
              uint64_t v302 = -(uint64_t)(v761 * v719);
              if (!v298) {
                uint64_t v302 = 0;
              }
              unsigned int v26 = &v764[v761 + v302];
              unint64_t v30 = v301 + 8 * v760;
              uint64_t v813 = v300;
              uint64_t v762 = v300;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v283 = v723 - 1;
            if (v723 == 1) {
              goto LABEL_811;
            }
          }
        case 15:
          uint64_t v762 = v22;
          int v744 = v18;
          uint64_t v774 = v21;
          uint64_t v303 = v16;
          unsigned int v304 = v816;
          uint64_t v305 = 8 * v21;
          uint64_t v306 = 2 * v11;
          while (1)
          {
            unsigned int v724 = v304;
            int v307 = v744;
            unint64_t v798 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_359;
                }
                LODWORD(v308) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_352:
                  int v309 = v26;
                  unsigned int v310 = 0xFFFF;
                  goto LABEL_353;
                }
              }
              else
              {
                LODWORD(v308) = 0xFFFF;
                if (!v11) {
                  goto LABEL_352;
                }
              }
              if (*(_WORD *)v25)
              {
                int v309 = v26;
                unsigned int v310 = __rev16(*(unsigned __int16 *)v25);
LABEL_353:
                unint64_t v311 = (char *)v814 + 6;
                unint64_t v312 = PDAoverlayPDA_11712(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v310, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v308);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v308) = v313;
                  unsigned int v314 = bswap32(v312);
                  v814->i16[0] = HIWORD(v314);
                  v814->i16[1] = v314;
                  v814->i16[2] = bswap32(HIDWORD(v312)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v312));
                  unint64_t v311 = v25;
                }
                else
                {
                  unsigned int v315 = bswap32(v312);
                  v814->i16[0] = HIWORD(v315);
                  v814->i16[1] = v315;
                  v814->i16[2] = bswap32(HIDWORD(v312)) >> 16;
                  unint64_t v308 = HIWORD(v312);
                }
                unint64_t v30 = v798;
                int v16 = v812;
                unsigned int v26 = v309;
                goto LABEL_358;
              }
              int8x8_t *v814 = *v813;
              unint64_t v311 = v25;
LABEL_358:
              *(_WORD *)unint64_t v311 = bswap32(v308) >> 16;
LABEL_359:
              v25 += v306;
              unint64_t v316 = (unsigned __int16 *)&v813[v774];
              if ((unint64_t)v316 >= v30) {
                uint64_t v317 = -(uint64_t)v720;
              }
              else {
                uint64_t v317 = 0;
              }
              v26 += v303 + v317;
              uint64_t v813 = (int8x8_t *)&v316[4 * v317];
              v814 = (int8x8_t *)((char *)v814 + v305);
              --v307;
            }
            while (v307);
            if (v758)
            {
              unint64_t v318 = (unint64_t)&v762[v760];
              BOOL v319 = v318 >= v758;
              uint64_t v320 = -(uint64_t)(v760 * v719);
              if (v318 < v758) {
                uint64_t v320 = 0;
              }
              uint64_t v321 = (int8x8_t *)(v318 + 8 * v320);
              unint64_t v322 = v30 + 8 * v320;
              uint64_t v323 = -(uint64_t)(v761 * v719);
              if (!v319) {
                uint64_t v323 = 0;
              }
              unsigned int v26 = &v764[v761 + v323];
              unint64_t v30 = v322 + 8 * v760;
              uint64_t v813 = v321;
              uint64_t v762 = v321;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v304 = v724 - 1;
            if (v724 == 1) {
              goto LABEL_811;
            }
          }
        case 16:
          uint64_t v762 = v22;
          int v745 = v18;
          uint64_t v775 = v21;
          uint64_t v324 = v16;
          unsigned int v325 = v816;
          uint64_t v326 = 8 * v21;
          uint64_t v327 = 2 * v11;
          while (1)
          {
            unsigned int v725 = v325;
            int v328 = v745;
            unint64_t v799 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_387;
                }
                LODWORD(v329) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_380:
                  uint64_t v330 = v26;
                  unsigned int v331 = 0xFFFF;
                  goto LABEL_381;
                }
              }
              else
              {
                LODWORD(v329) = 0xFFFF;
                if (!v11) {
                  goto LABEL_380;
                }
              }
              if (*(_WORD *)v25)
              {
                uint64_t v330 = v26;
                unsigned int v331 = __rev16(*(unsigned __int16 *)v25);
LABEL_381:
                int v332 = (char *)v814 + 6;
                unint64_t v333 = PDAdarkenPDA_11714(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v331, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v329);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v329) = v334;
                  unsigned int v335 = bswap32(v333);
                  v814->i16[0] = HIWORD(v335);
                  v814->i16[1] = v335;
                  v814->i16[2] = bswap32(HIDWORD(v333)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v333));
                  int v332 = v25;
                }
                else
                {
                  unsigned int v336 = bswap32(v333);
                  v814->i16[0] = HIWORD(v336);
                  v814->i16[1] = v336;
                  v814->i16[2] = bswap32(HIDWORD(v333)) >> 16;
                  unint64_t v329 = HIWORD(v333);
                }
                unint64_t v30 = v799;
                int v16 = v812;
                unsigned int v26 = v330;
                goto LABEL_386;
              }
              int8x8_t *v814 = *v813;
              int v332 = v25;
LABEL_386:
              *(_WORD *)int v332 = bswap32(v329) >> 16;
LABEL_387:
              v25 += v327;
              int v337 = (unsigned __int16 *)&v813[v775];
              if ((unint64_t)v337 >= v30) {
                uint64_t v338 = -(uint64_t)v720;
              }
              else {
                uint64_t v338 = 0;
              }
              v26 += v324 + v338;
              uint64_t v813 = (int8x8_t *)&v337[4 * v338];
              v814 = (int8x8_t *)((char *)v814 + v326);
              --v328;
            }
            while (v328);
            if (v758)
            {
              unint64_t v339 = (unint64_t)&v762[v760];
              BOOL v340 = v339 >= v758;
              uint64_t v341 = -(uint64_t)(v760 * v719);
              if (v339 < v758) {
                uint64_t v341 = 0;
              }
              unint64_t v342 = (int8x8_t *)(v339 + 8 * v341);
              unint64_t v343 = v30 + 8 * v341;
              uint64_t v344 = -(uint64_t)(v761 * v719);
              if (!v340) {
                uint64_t v344 = 0;
              }
              unsigned int v26 = &v764[v761 + v344];
              unint64_t v30 = v343 + 8 * v760;
              uint64_t v813 = v342;
              uint64_t v762 = v342;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v325 = v725 - 1;
            if (v725 == 1) {
              goto LABEL_811;
            }
          }
        case 17:
          uint64_t v762 = v22;
          int v746 = v18;
          uint64_t v776 = v21;
          uint64_t v345 = v16;
          unsigned int v346 = v816;
          uint64_t v347 = 8 * v21;
          uint64_t v348 = 2 * v11;
          while (1)
          {
            unsigned int v726 = v346;
            int v349 = v746;
            unint64_t v800 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_415;
                }
                LODWORD(v350) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_408:
                  int v351 = v26;
                  unsigned int v352 = 0xFFFF;
                  goto LABEL_409;
                }
              }
              else
              {
                LODWORD(v350) = 0xFFFF;
                if (!v11) {
                  goto LABEL_408;
                }
              }
              if (*(_WORD *)v25)
              {
                int v351 = v26;
                unsigned int v352 = __rev16(*(unsigned __int16 *)v25);
LABEL_409:
                int v353 = (char *)v814 + 6;
                unint64_t v354 = PDAlightenPDA_11713(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v352, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v350);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v350) = v355;
                  unsigned int v356 = bswap32(v354);
                  v814->i16[0] = HIWORD(v356);
                  v814->i16[1] = v356;
                  v814->i16[2] = bswap32(HIDWORD(v354)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v354));
                  int v353 = v25;
                }
                else
                {
                  unint64_t v350 = HIWORD(v354);
                  unsigned int v357 = bswap32(v354);
                  v814->i16[0] = HIWORD(v357);
                  v814->i16[1] = v357;
                  v814->i16[2] = bswap32(HIDWORD(v354)) >> 16;
                }
                unint64_t v30 = v800;
                int v16 = v812;
                unsigned int v26 = v351;
                goto LABEL_414;
              }
              int8x8_t *v814 = *v813;
              int v353 = v25;
LABEL_414:
              *(_WORD *)int v353 = bswap32(v350) >> 16;
LABEL_415:
              v25 += v348;
              unint64_t v358 = (unsigned __int16 *)&v813[v776];
              if ((unint64_t)v358 >= v30) {
                uint64_t v359 = -(uint64_t)v720;
              }
              else {
                uint64_t v359 = 0;
              }
              v26 += v345 + v359;
              uint64_t v813 = (int8x8_t *)&v358[4 * v359];
              v814 = (int8x8_t *)((char *)v814 + v347);
              --v349;
            }
            while (v349);
            if (v758)
            {
              unint64_t v360 = (unint64_t)&v762[v760];
              BOOL v361 = v360 >= v758;
              uint64_t v362 = -(uint64_t)(v760 * v719);
              if (v360 < v758) {
                uint64_t v362 = 0;
              }
              unsigned int v363 = (int8x8_t *)(v360 + 8 * v362);
              unint64_t v364 = v30 + 8 * v362;
              uint64_t v365 = -(uint64_t)(v761 * v719);
              if (!v361) {
                uint64_t v365 = 0;
              }
              unsigned int v26 = &v764[v761 + v365];
              unint64_t v30 = v364 + 8 * v760;
              uint64_t v813 = v363;
              uint64_t v762 = v363;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v346 = v726 - 1;
            if (v726 == 1) {
              goto LABEL_811;
            }
          }
        case 18:
          uint64_t v762 = v22;
          int v747 = v18;
          uint64_t v777 = v21;
          uint64_t v366 = v16;
          unsigned int v367 = v816;
          uint64_t v368 = 8 * v21;
          uint64_t v369 = 2 * v11;
          while (1)
          {
            unsigned int v727 = v367;
            int v370 = v747;
            unint64_t v801 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_443;
                }
                LODWORD(v371) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_436:
                  unint64_t v372 = v26;
                  unsigned int v373 = 0xFFFF;
                  goto LABEL_437;
                }
              }
              else
              {
                LODWORD(v371) = 0xFFFF;
                if (!v11) {
                  goto LABEL_436;
                }
              }
              if (*(_WORD *)v25)
              {
                unint64_t v372 = v26;
                unsigned int v373 = __rev16(*(unsigned __int16 *)v25);
LABEL_437:
                unsigned int v374 = (char *)v814 + 6;
                unint64_t v375 = PDAcolordodgePDA_11715(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v373, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v371);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v371) = v376;
                  unsigned int v377 = bswap32(v375);
                  v814->i16[0] = HIWORD(v377);
                  v814->i16[1] = v377;
                  v814->i16[2] = bswap32(HIDWORD(v375)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v375));
                  unsigned int v374 = v25;
                }
                else
                {
                  unint64_t v371 = HIWORD(v375);
                  unsigned int v378 = bswap32(v375);
                  v814->i16[0] = HIWORD(v378);
                  v814->i16[1] = v378;
                  v814->i16[2] = bswap32(HIDWORD(v375)) >> 16;
                }
                unint64_t v30 = v801;
                int v16 = v812;
                unsigned int v26 = v372;
                goto LABEL_442;
              }
              int8x8_t *v814 = *v813;
              unsigned int v374 = v25;
LABEL_442:
              *(_WORD *)unsigned int v374 = bswap32(v371) >> 16;
LABEL_443:
              v25 += v369;
              unsigned int v379 = (unsigned __int16 *)&v813[v777];
              if ((unint64_t)v379 >= v30) {
                uint64_t v380 = -(uint64_t)v720;
              }
              else {
                uint64_t v380 = 0;
              }
              v26 += v366 + v380;
              uint64_t v813 = (int8x8_t *)&v379[4 * v380];
              v814 = (int8x8_t *)((char *)v814 + v368);
              --v370;
            }
            while (v370);
            if (v758)
            {
              unint64_t v381 = (unint64_t)&v762[v760];
              BOOL v382 = v381 >= v758;
              uint64_t v383 = -(uint64_t)(v760 * v719);
              if (v381 < v758) {
                uint64_t v383 = 0;
              }
              int v384 = (int8x8_t *)(v381 + 8 * v383);
              unint64_t v385 = v30 + 8 * v383;
              uint64_t v386 = -(uint64_t)(v761 * v719);
              if (!v382) {
                uint64_t v386 = 0;
              }
              unsigned int v26 = &v764[v761 + v386];
              unint64_t v30 = v385 + 8 * v760;
              uint64_t v813 = v384;
              uint64_t v762 = v384;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v367 = v727 - 1;
            if (v727 == 1) {
              goto LABEL_811;
            }
          }
        case 19:
          uint64_t v762 = v22;
          int v748 = v18;
          uint64_t v778 = v21;
          uint64_t v387 = v16;
          unsigned int v388 = v816;
          uint64_t v389 = 8 * v21;
          uint64_t v390 = 2 * v11;
          while (1)
          {
            unsigned int v728 = v388;
            int v391 = v748;
            unint64_t v802 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_471;
                }
                LODWORD(v392) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_464:
                  unsigned int v393 = v26;
                  unsigned int v394 = 0xFFFF;
                  goto LABEL_465;
                }
              }
              else
              {
                LODWORD(v392) = 0xFFFF;
                if (!v11) {
                  goto LABEL_464;
                }
              }
              if (*(_WORD *)v25)
              {
                unsigned int v393 = v26;
                unsigned int v394 = __rev16(*(unsigned __int16 *)v25);
LABEL_465:
                uint64_t v395 = (char *)v814 + 6;
                unint64_t v396 = PDAcolorburnPDA_11716(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v394, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v392);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v392) = v397;
                  unsigned int v398 = bswap32(v396);
                  v814->i16[0] = HIWORD(v398);
                  v814->i16[1] = v398;
                  v814->i16[2] = bswap32(HIDWORD(v396)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v396));
                  uint64_t v395 = v25;
                }
                else
                {
                  unint64_t v392 = HIWORD(v396);
                  unsigned int v399 = bswap32(v396);
                  v814->i16[0] = HIWORD(v399);
                  v814->i16[1] = v399;
                  v814->i16[2] = bswap32(HIDWORD(v396)) >> 16;
                }
                unint64_t v30 = v802;
                int v16 = v812;
                unsigned int v26 = v393;
                goto LABEL_470;
              }
              int8x8_t *v814 = *v813;
              uint64_t v395 = v25;
LABEL_470:
              *(_WORD *)uint64_t v395 = bswap32(v392) >> 16;
LABEL_471:
              v25 += v390;
              int v400 = (unsigned __int16 *)&v813[v778];
              if ((unint64_t)v400 >= v30) {
                uint64_t v401 = -(uint64_t)v720;
              }
              else {
                uint64_t v401 = 0;
              }
              v26 += v387 + v401;
              uint64_t v813 = (int8x8_t *)&v400[4 * v401];
              v814 = (int8x8_t *)((char *)v814 + v389);
              --v391;
            }
            while (v391);
            if (v758)
            {
              unint64_t v402 = (unint64_t)&v762[v760];
              BOOL v403 = v402 >= v758;
              uint64_t v404 = -(uint64_t)(v760 * v719);
              if (v402 < v758) {
                uint64_t v404 = 0;
              }
              uint64_t v405 = (int8x8_t *)(v402 + 8 * v404);
              unint64_t v406 = v30 + 8 * v404;
              uint64_t v407 = -(uint64_t)(v761 * v719);
              if (!v403) {
                uint64_t v407 = 0;
              }
              unsigned int v26 = &v764[v761 + v407];
              unint64_t v30 = v406 + 8 * v760;
              uint64_t v813 = v405;
              uint64_t v762 = v405;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v388 = v728 - 1;
            if (v728 == 1) {
              goto LABEL_811;
            }
          }
        case 20:
          uint64_t v762 = v22;
          int v749 = v18;
          uint64_t v779 = v21;
          uint64_t v408 = v16;
          unsigned int v409 = v816;
          uint64_t v410 = 8 * v21;
          uint64_t v411 = 2 * v11;
          while (1)
          {
            unsigned int v729 = v409;
            int v412 = v749;
            unint64_t v803 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_499;
                }
                LODWORD(v413) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_492:
                  int v414 = v26;
                  unsigned int v415 = 0xFFFF;
                  goto LABEL_493;
                }
              }
              else
              {
                LODWORD(v413) = 0xFFFF;
                if (!v11) {
                  goto LABEL_492;
                }
              }
              if (*(_WORD *)v25)
              {
                int v414 = v26;
                unsigned int v415 = __rev16(*(unsigned __int16 *)v25);
LABEL_493:
                unint64_t v416 = (char *)v814 + 6;
                unint64_t v417 = PDAsoftlightPDA_11718(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v415, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v413);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v413) = v418;
                  unsigned int v419 = bswap32(v417);
                  v814->i16[0] = HIWORD(v419);
                  v814->i16[1] = v419;
                  v814->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v417));
                  unint64_t v416 = v25;
                }
                else
                {
                  unint64_t v413 = HIWORD(v417);
                  unsigned int v420 = bswap32(v417);
                  v814->i16[0] = HIWORD(v420);
                  v814->i16[1] = v420;
                  v814->i16[2] = bswap32(HIDWORD(v417)) >> 16;
                }
                unint64_t v30 = v803;
                int v16 = v812;
                unsigned int v26 = v414;
                goto LABEL_498;
              }
              int8x8_t *v814 = *v813;
              unint64_t v416 = v25;
LABEL_498:
              *(_WORD *)unint64_t v416 = bswap32(v413) >> 16;
LABEL_499:
              v25 += v411;
              unint64_t v421 = (unsigned __int16 *)&v813[v779];
              if ((unint64_t)v421 >= v30) {
                uint64_t v422 = -(uint64_t)v720;
              }
              else {
                uint64_t v422 = 0;
              }
              v26 += v408 + v422;
              uint64_t v813 = (int8x8_t *)&v421[4 * v422];
              v814 = (int8x8_t *)((char *)v814 + v410);
              --v412;
            }
            while (v412);
            if (v758)
            {
              unint64_t v423 = (unint64_t)&v762[v760];
              BOOL v424 = v423 >= v758;
              uint64_t v425 = -(uint64_t)(v760 * v719);
              if (v423 < v758) {
                uint64_t v425 = 0;
              }
              int v426 = (int8x8_t *)(v423 + 8 * v425);
              unint64_t v427 = v30 + 8 * v425;
              uint64_t v428 = -(uint64_t)(v761 * v719);
              if (!v424) {
                uint64_t v428 = 0;
              }
              unsigned int v26 = &v764[v761 + v428];
              unint64_t v30 = v427 + 8 * v760;
              uint64_t v813 = v426;
              uint64_t v762 = v426;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v409 = v729 - 1;
            if (v729 == 1) {
              goto LABEL_811;
            }
          }
        case 21:
          uint64_t v762 = v22;
          int v750 = v18;
          uint64_t v780 = v21;
          uint64_t v429 = v16;
          unsigned int v430 = v816;
          uint64_t v431 = 8 * v21;
          uint64_t v432 = 2 * v11;
          while (1)
          {
            unsigned int v730 = v430;
            int v433 = v750;
            unint64_t v804 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_527;
                }
                LODWORD(v434) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_520:
                  uint64_t v435 = v26;
                  unsigned int v436 = 0xFFFF;
                  goto LABEL_521;
                }
              }
              else
              {
                LODWORD(v434) = 0xFFFF;
                if (!v11) {
                  goto LABEL_520;
                }
              }
              if (*(_WORD *)v25)
              {
                uint64_t v435 = v26;
                unsigned int v436 = __rev16(*(unsigned __int16 *)v25);
LABEL_521:
                int v437 = (char *)v814 + 6;
                unint64_t v438 = PDAhardlightPDA_11717(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v436, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v434);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v434) = v439;
                  unsigned int v440 = bswap32(v438);
                  v814->i16[0] = HIWORD(v440);
                  v814->i16[1] = v440;
                  v814->i16[2] = bswap32(HIDWORD(v438)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v438));
                  int v437 = v25;
                }
                else
                {
                  unint64_t v434 = HIWORD(v438);
                  unsigned int v441 = bswap32(v438);
                  v814->i16[0] = HIWORD(v441);
                  v814->i16[1] = v441;
                  v814->i16[2] = bswap32(HIDWORD(v438)) >> 16;
                }
                unint64_t v30 = v804;
                int v16 = v812;
                unsigned int v26 = v435;
                goto LABEL_526;
              }
              int8x8_t *v814 = *v813;
              int v437 = v25;
LABEL_526:
              *(_WORD *)int v437 = bswap32(v434) >> 16;
LABEL_527:
              v25 += v432;
              int v442 = (unsigned __int16 *)&v813[v780];
              if ((unint64_t)v442 >= v30) {
                uint64_t v443 = -(uint64_t)v720;
              }
              else {
                uint64_t v443 = 0;
              }
              v26 += v429 + v443;
              uint64_t v813 = (int8x8_t *)&v442[4 * v443];
              v814 = (int8x8_t *)((char *)v814 + v431);
              --v433;
            }
            while (v433);
            if (v758)
            {
              unint64_t v444 = (unint64_t)&v762[v760];
              BOOL v445 = v444 >= v758;
              uint64_t v446 = -(uint64_t)(v760 * v719);
              if (v444 < v758) {
                uint64_t v446 = 0;
              }
              unint64_t v447 = (int8x8_t *)(v444 + 8 * v446);
              unint64_t v448 = v30 + 8 * v446;
              uint64_t v449 = -(uint64_t)(v761 * v719);
              if (!v445) {
                uint64_t v449 = 0;
              }
              unsigned int v26 = &v764[v761 + v449];
              unint64_t v30 = v448 + 8 * v760;
              uint64_t v813 = v447;
              uint64_t v762 = v447;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v430 = v730 - 1;
            if (v730 == 1) {
              goto LABEL_811;
            }
          }
        case 22:
          uint64_t v762 = v22;
          int v751 = v18;
          uint64_t v781 = v21;
          uint64_t v450 = v16;
          unsigned int v451 = v816;
          uint64_t v452 = 8 * v21;
          uint64_t v453 = 2 * v11;
          while (1)
          {
            unsigned int v731 = v451;
            int v454 = v751;
            unint64_t v805 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_555;
                }
                LODWORD(v455) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_548:
                  int v456 = v26;
                  unsigned int v457 = 0xFFFF;
                  goto LABEL_549;
                }
              }
              else
              {
                LODWORD(v455) = 0xFFFF;
                if (!v11) {
                  goto LABEL_548;
                }
              }
              if (*(_WORD *)v25)
              {
                int v456 = v26;
                unsigned int v457 = __rev16(*(unsigned __int16 *)v25);
LABEL_549:
                int v458 = (char *)v814 + 6;
                unint64_t v459 = PDAdifferencePDA_11719(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v457, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v455);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v455) = v460;
                  unsigned int v461 = bswap32(v459);
                  v814->i16[0] = HIWORD(v461);
                  v814->i16[1] = v461;
                  v814->i16[2] = bswap32(HIDWORD(v459)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v459));
                  int v458 = v25;
                }
                else
                {
                  unint64_t v455 = HIWORD(v459);
                  unsigned int v462 = bswap32(v459);
                  v814->i16[0] = HIWORD(v462);
                  v814->i16[1] = v462;
                  v814->i16[2] = bswap32(HIDWORD(v459)) >> 16;
                }
                unint64_t v30 = v805;
                int v16 = v812;
                unsigned int v26 = v456;
                goto LABEL_554;
              }
              int8x8_t *v814 = *v813;
              int v458 = v25;
LABEL_554:
              *(_WORD *)int v458 = bswap32(v455) >> 16;
LABEL_555:
              v25 += v453;
              uint64_t v463 = (unsigned __int16 *)&v813[v781];
              if ((unint64_t)v463 >= v30) {
                uint64_t v464 = -(uint64_t)v720;
              }
              else {
                uint64_t v464 = 0;
              }
              v26 += v450 + v464;
              uint64_t v813 = (int8x8_t *)&v463[4 * v464];
              v814 = (int8x8_t *)((char *)v814 + v452);
              --v454;
            }
            while (v454);
            if (v758)
            {
              unint64_t v465 = (unint64_t)&v762[v760];
              BOOL v466 = v465 >= v758;
              uint64_t v467 = -(uint64_t)(v760 * v719);
              if (v465 < v758) {
                uint64_t v467 = 0;
              }
              int v468 = (int8x8_t *)(v465 + 8 * v467);
              unint64_t v469 = v30 + 8 * v467;
              uint64_t v470 = -(uint64_t)(v761 * v719);
              if (!v466) {
                uint64_t v470 = 0;
              }
              unsigned int v26 = &v764[v761 + v470];
              unint64_t v30 = v469 + 8 * v760;
              uint64_t v813 = v468;
              uint64_t v762 = v468;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v451 = v731 - 1;
            if (v731 == 1) {
              goto LABEL_811;
            }
          }
        case 23:
          uint64_t v762 = v22;
          int v752 = v18;
          uint64_t v782 = v21;
          uint64_t v471 = v16;
          unsigned int v472 = v816;
          uint64_t v473 = 8 * v21;
          uint64_t v474 = 2 * v11;
          while (1)
          {
            unsigned int v732 = v472;
            int v475 = v752;
            unint64_t v806 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_583;
                }
                LODWORD(v476) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_576:
                  unsigned int v477 = v26;
                  unsigned int v478 = 0xFFFF;
                  goto LABEL_577;
                }
              }
              else
              {
                LODWORD(v476) = 0xFFFF;
                if (!v11) {
                  goto LABEL_576;
                }
              }
              if (*(_WORD *)v25)
              {
                unsigned int v477 = v26;
                unsigned int v478 = __rev16(*(unsigned __int16 *)v25);
LABEL_577:
                unsigned int v479 = (char *)v814 + 6;
                unint64_t v480 = PDAexclusionPDA_11720(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v478, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v476);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v476) = v481;
                  unsigned int v482 = bswap32(v480);
                  v814->i16[0] = HIWORD(v482);
                  v814->i16[1] = v482;
                  v814->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v480));
                  unsigned int v479 = v25;
                }
                else
                {
                  unint64_t v476 = HIWORD(v480);
                  unsigned int v483 = bswap32(v480);
                  v814->i16[0] = HIWORD(v483);
                  v814->i16[1] = v483;
                  v814->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                }
                unint64_t v30 = v806;
                int v16 = v812;
                unsigned int v26 = v477;
                goto LABEL_582;
              }
              int8x8_t *v814 = *v813;
              unsigned int v479 = v25;
LABEL_582:
              *(_WORD *)unsigned int v479 = bswap32(v476) >> 16;
LABEL_583:
              v25 += v474;
              int8x8_t v484 = (unsigned __int16 *)&v813[v782];
              if ((unint64_t)v484 >= v30) {
                uint64_t v485 = -(uint64_t)v720;
              }
              else {
                uint64_t v485 = 0;
              }
              v26 += v471 + v485;
              uint64_t v813 = (int8x8_t *)&v484[4 * v485];
              v814 = (int8x8_t *)((char *)v814 + v473);
              --v475;
            }
            while (v475);
            if (v758)
            {
              unint64_t v486 = (unint64_t)&v762[v760];
              BOOL v487 = v486 >= v758;
              uint64_t v488 = -(uint64_t)(v760 * v719);
              if (v486 < v758) {
                uint64_t v488 = 0;
              }
              int8x16_t v489 = (int8x8_t *)(v486 + 8 * v488);
              unint64_t v490 = v30 + 8 * v488;
              uint64_t v491 = -(uint64_t)(v761 * v719);
              if (!v487) {
                uint64_t v491 = 0;
              }
              unsigned int v26 = &v764[v761 + v491];
              unint64_t v30 = v490 + 8 * v760;
              uint64_t v813 = v489;
              uint64_t v762 = v489;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v472 = v732 - 1;
            if (v732 == 1) {
              goto LABEL_811;
            }
          }
        case 24:
          uint64_t v762 = v22;
          int v753 = v18;
          uint64_t v783 = v21;
          uint64_t v492 = v16;
          unsigned int v493 = v816;
          uint64_t v494 = 8 * v21;
          uint64_t v495 = 2 * v11;
          while (1)
          {
            unsigned int v733 = v493;
            int v496 = v753;
            unint64_t v807 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_611;
                }
                LODWORD(v497) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_604:
                  int v498 = v26;
                  unsigned int v499 = 0xFFFF;
                  goto LABEL_605;
                }
              }
              else
              {
                LODWORD(v497) = 0xFFFF;
                if (!v11) {
                  goto LABEL_604;
                }
              }
              if (*(_WORD *)v25)
              {
                int v498 = v26;
                unsigned int v499 = __rev16(*(unsigned __int16 *)v25);
LABEL_605:
                unsigned int v500 = (char *)v814 + 6;
                unint64_t v501 = PDAhuePDA_11721(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v499, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v497);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v497) = v502;
                  unsigned int v503 = bswap32(v501);
                  v814->i16[0] = HIWORD(v503);
                  v814->i16[1] = v503;
                  v814->i16[2] = bswap32(HIDWORD(v501)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v501));
                  unsigned int v500 = v25;
                }
                else
                {
                  unsigned int v504 = bswap32(v501);
                  v814->i16[0] = HIWORD(v504);
                  v814->i16[1] = v504;
                  v814->i16[2] = bswap32(HIDWORD(v501)) >> 16;
                  unint64_t v497 = HIWORD(v501);
                }
                unint64_t v30 = v807;
                int v16 = v812;
                unsigned int v26 = v498;
                goto LABEL_610;
              }
              int8x8_t *v814 = *v813;
              unsigned int v500 = v25;
LABEL_610:
              *(_WORD *)unsigned int v500 = bswap32(v497) >> 16;
LABEL_611:
              v25 += v495;
              int64x2_t v505 = (unsigned __int16 *)&v813[v783];
              if ((unint64_t)v505 >= v30) {
                uint64_t v506 = -(uint64_t)v720;
              }
              else {
                uint64_t v506 = 0;
              }
              v26 += v492 + v506;
              uint64_t v813 = (int8x8_t *)&v505[4 * v506];
              v814 = (int8x8_t *)((char *)v814 + v494);
              --v496;
            }
            while (v496);
            if (v758)
            {
              unint64_t v507 = (unint64_t)&v762[v760];
              BOOL v508 = v507 >= v758;
              uint64_t v509 = -(uint64_t)(v760 * v719);
              if (v507 < v758) {
                uint64_t v509 = 0;
              }
              unsigned int v510 = (int8x8_t *)(v507 + 8 * v509);
              unint64_t v511 = v30 + 8 * v509;
              uint64_t v512 = -(uint64_t)(v761 * v719);
              if (!v508) {
                uint64_t v512 = 0;
              }
              unsigned int v26 = &v764[v761 + v512];
              unint64_t v30 = v511 + 8 * v760;
              uint64_t v813 = v510;
              uint64_t v762 = v510;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v493 = v733 - 1;
            if (v733 == 1) {
              goto LABEL_811;
            }
          }
        case 25:
          uint64_t v762 = v22;
          int v754 = v18;
          uint64_t v784 = v21;
          uint64_t v513 = v16;
          unsigned int v514 = v816;
          uint64_t v515 = 8 * v21;
          uint64_t v516 = 2 * v11;
          while (1)
          {
            unsigned int v734 = v514;
            int v517 = v754;
            unint64_t v808 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_639;
                }
                LODWORD(v518) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_632:
                  uint32x4_t v519 = v26;
                  unsigned int v520 = 0xFFFF;
                  goto LABEL_633;
                }
              }
              else
              {
                LODWORD(v518) = 0xFFFF;
                if (!v11) {
                  goto LABEL_632;
                }
              }
              if (*(_WORD *)v25)
              {
                uint32x4_t v519 = v26;
                unsigned int v520 = __rev16(*(unsigned __int16 *)v25);
LABEL_633:
                int32x4_t v521 = (char *)v814 + 6;
                unint64_t v522 = PDAsaturationPDA_11722(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v520, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v518);
                int v11 = v787;
                if (v787)
                {
                  LODWORD(v518) = v523;
                  unsigned int v524 = bswap32(v522);
                  v814->i16[0] = HIWORD(v524);
                  v814->i16[1] = v524;
                  v814->i16[2] = bswap32(HIDWORD(v522)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v522));
                  int32x4_t v521 = v25;
                }
                else
                {
                  unsigned int v525 = bswap32(v522);
                  v814->i16[0] = HIWORD(v525);
                  v814->i16[1] = v525;
                  v814->i16[2] = bswap32(HIDWORD(v522)) >> 16;
                  unint64_t v518 = HIWORD(v522);
                }
                unint64_t v30 = v808;
                int v16 = v812;
                unsigned int v26 = v519;
                goto LABEL_638;
              }
              int8x8_t *v814 = *v813;
              int32x4_t v521 = v25;
LABEL_638:
              *(_WORD *)int32x4_t v521 = bswap32(v518) >> 16;
LABEL_639:
              v25 += v516;
              int32x4_t v526 = (unsigned __int16 *)&v813[v784];
              if ((unint64_t)v526 >= v30) {
                uint64_t v527 = -(uint64_t)v720;
              }
              else {
                uint64_t v527 = 0;
              }
              v26 += v513 + v527;
              uint64_t v813 = (int8x8_t *)&v526[4 * v527];
              v814 = (int8x8_t *)((char *)v814 + v515);
              --v517;
            }
            while (v517);
            if (v758)
            {
              unint64_t v528 = (unint64_t)&v762[v760];
              BOOL v529 = v528 >= v758;
              uint64_t v530 = -(uint64_t)(v760 * v719);
              if (v528 < v758) {
                uint64_t v530 = 0;
              }
              int v531 = (int8x8_t *)(v528 + 8 * v530);
              unint64_t v532 = v30 + 8 * v530;
              uint64_t v533 = -(uint64_t)(v761 * v719);
              if (!v529) {
                uint64_t v533 = 0;
              }
              unsigned int v26 = &v764[v761 + v533];
              unint64_t v30 = v532 + 8 * v760;
              uint64_t v813 = v531;
              uint64_t v762 = v531;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v514 = v734 - 1;
            if (v734 == 1) {
              goto LABEL_811;
            }
          }
        case 26:
          uint64_t v762 = v22;
          int v755 = v18;
          uint64_t v785 = v21;
          uint64_t v534 = v16;
          unsigned int v535 = v816;
          uint64_t v536 = 8 * v21;
          uint64_t v537 = 2 * v11;
          while (1)
          {
            unsigned int v735 = v535;
            int v538 = v755;
            unint64_t v809 = v30;
            do
            {
              if (v16)
              {
                if (!*v26) {
                  goto LABEL_667;
                }
                LODWORD(v539) = __rev16((unsigned __int16)*v26);
                if (!v11)
                {
LABEL_660:
                  int32x4_t v540 = v26;
                  unsigned int v541 = 0xFFFF;
                  goto LABEL_661;
                }
              }
              else
              {
                LODWORD(v539) = 0xFFFF;
                if (!v11) {
                  goto LABEL_660;
                }
              }
              if (*(_WORD *)v25)
              {
                int32x4_t v540 = v26;
                unsigned int v541 = __rev16(*(unsigned __int16 *)v25);
LABEL_661:
                int32x4_t v542 = (char *)v814 + 6;
                unint64_t v543 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v539, ((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v541);
                int v11 = v787;
                if (v787)
                {
                  unsigned int v544 = bswap32(v543);
                  v814->i16[0] = HIWORD(v544);
                  v814->i16[1] = v544;
                  v814->i16[2] = bswap32(HIDWORD(v543)) >> 16;
                  v814->i16[3] = __rev16(HIWORD(v543));
                  int32x4_t v542 = v25;
                }
                else
                {
                  unint64_t v539 = HIWORD(v543);
                  unsigned int v545 = bswap32(v543);
                  v814->i16[0] = HIWORD(v545);
                  v814->i16[1] = v545;
                  v814->i16[2] = bswap32(HIDWORD(v543)) >> 16;
                }
                unint64_t v30 = v809;
                int v16 = v812;
                unsigned int v26 = v540;
                goto LABEL_666;
              }
              int8x8_t *v814 = *v813;
              int32x4_t v542 = v25;
LABEL_666:
              *(_WORD *)int32x4_t v542 = bswap32(v539) >> 16;
LABEL_667:
              v25 += v537;
              int v546 = (unsigned __int16 *)&v813[v785];
              if ((unint64_t)v546 >= v30) {
                uint64_t v547 = -(uint64_t)v720;
              }
              else {
                uint64_t v547 = 0;
              }
              v26 += v534 + v547;
              uint64_t v813 = (int8x8_t *)&v546[4 * v547];
              v814 = (int8x8_t *)((char *)v814 + v536);
              --v538;
            }
            while (v538);
            if (v758)
            {
              unint64_t v548 = (unint64_t)&v762[v760];
              BOOL v549 = v548 >= v758;
              uint64_t v550 = -(uint64_t)(v760 * v719);
              if (v548 < v758) {
                uint64_t v550 = 0;
              }
              int v551 = (int8x8_t *)(v548 + 8 * v550);
              unint64_t v552 = v30 + 8 * v550;
              uint64_t v553 = -(uint64_t)(v761 * v719);
              if (!v549) {
                uint64_t v553 = 0;
              }
              unsigned int v26 = &v764[v761 + v553];
              unint64_t v30 = v552 + 8 * v760;
              uint64_t v813 = v551;
              uint64_t v762 = v551;
              unint64_t v764 = v26;
            }
            else
            {
              v813 += v760;
              v26 += v761;
            }
            v814 += v757;
            v25 += 2 * v759;
            unsigned int v535 = v735 - 1;
            if (v735 == 1) {
              goto LABEL_811;
            }
          }
        case 27:
          uint64_t v762 = v22;
          int v756 = v18;
          uint64_t v786 = v21;
          uint64_t v554 = v16;
          unsigned int v555 = v816;
          uint64_t v556 = 8 * v21;
          uint64_t v557 = 2 * v11;
          break;
        default:
          uint64_t v17 = v34;
          uint64_t v788 = v30;
          goto LABEL_912;
      }
      break;
    }
LABEL_681:
    unsigned int v736 = v555;
    int v558 = v756;
    unint64_t v810 = v30;
    while (v16)
    {
      if (*v26)
      {
        LODWORD(v559) = __rev16((unsigned __int16)*v26);
        if (v11) {
          goto LABEL_685;
        }
LABEL_688:
        uint64_t v560 = v26;
        unsigned int v561 = 0xFFFF;
LABEL_689:
        unint64_t v562 = (char *)v814 + 6;
        unint64_t v563 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v814->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v814->u16[3]) >> 16) << 48) | bswap32(v814->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v814->u16[0]) >> 16), v561, ((unint64_t)(bswap32(v813->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v813->u16[3]) >> 16) << 48) | bswap32(v813->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v813->u16[0]) >> 16), v559);
        int v11 = v787;
        if (v787)
        {
          LODWORD(v559) = v564;
          unsigned int v565 = bswap32(v563);
          v814->i16[0] = HIWORD(v565);
          v814->i16[1] = v565;
          v814->i16[2] = bswap32(HIDWORD(v563)) >> 16;
          v814->i16[3] = __rev16(HIWORD(v563));
          unint64_t v562 = v25;
        }
        else
        {
          unsigned int v566 = bswap32(v563);
          v814->i16[0] = HIWORD(v566);
          v814->i16[1] = v566;
          v814->i16[2] = bswap32(HIDWORD(v563)) >> 16;
          unint64_t v559 = HIWORD(v563);
        }
        unint64_t v30 = v810;
        int v16 = v812;
        unsigned int v26 = v560;
        goto LABEL_694;
      }
LABEL_695:
      v25 += v557;
      unint64_t v567 = (unsigned __int16 *)&v813[v786];
      if ((unint64_t)v567 >= v30) {
        uint64_t v568 = -(uint64_t)v720;
      }
      else {
        uint64_t v568 = 0;
      }
      v26 += v554 + v568;
      uint64_t v813 = (int8x8_t *)&v567[4 * v568];
      v814 = (int8x8_t *)((char *)v814 + v556);
      if (!--v558)
      {
        if (v758)
        {
          unint64_t v569 = (unint64_t)&v762[v760];
          BOOL v570 = v569 >= v758;
          uint64_t v571 = -(uint64_t)(v760 * v719);
          if (v569 < v758) {
            uint64_t v571 = 0;
          }
          unint64_t v572 = (int8x8_t *)(v569 + 8 * v571);
          unint64_t v573 = v30 + 8 * v571;
          uint64_t v574 = -(uint64_t)(v761 * v719);
          if (!v570) {
            uint64_t v574 = 0;
          }
          unsigned int v26 = &v764[v761 + v574];
          unint64_t v30 = v573 + 8 * v760;
          uint64_t v813 = v572;
          uint64_t v762 = v572;
          unint64_t v764 = v26;
        }
        else
        {
          v813 += v760;
          v26 += v761;
        }
        v814 += v757;
        v25 += 2 * v759;
        unsigned int v555 = v736 - 1;
        if (v736 == 1)
        {
LABEL_811:
          uint64_t v788 = v30;
          unsigned int v816 = 0;
          uint64_t v17 = v711;
LABEL_812:
          unint64_t v10 = v712;
          uint64_t v8 = v713;
LABEL_813:
          int v24 = v721;
          int32x4_t v22 = v762;
          goto LABEL_814;
        }
        goto LABEL_681;
      }
    }
    LODWORD(v559) = 0xFFFF;
    if (!v11) {
      goto LABEL_688;
    }
LABEL_685:
    if (*(_WORD *)v25)
    {
      uint64_t v560 = v26;
      unsigned int v561 = __rev16(*(unsigned __int16 *)v25);
      goto LABEL_689;
    }
    int8x8_t *v814 = *v813;
    unint64_t v562 = v25;
LABEL_694:
    *(_WORD *)unint64_t v562 = bswap32(v559) >> 16;
    goto LABEL_695;
  }
}

void CMYK64_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v5 = *(unsigned __int16 **)(a1 + 88);
  int v4 = *(unsigned __int16 **)(a1 + 96);
  uint64_t v6 = bswap32(v5[3]) >> 16;
  unint64_t v7 = ((unint64_t)(bswap32(v5[2]) >> 16) << 32) | (v6 << 48);
  uint64_t v8 = (__PAIR64__(bswap32(v5[1]) >> 16, bswap32(*v5)) >> 16);
  if (v4) {
    unsigned int v9 = bswap32(*v4) >> 16;
  }
  else {
    unsigned int v9 = 0xFFFF;
  }
  int v10 = *(_DWORD *)(a1 + 8);
  uint64_t v606 = *(void *)(a1 + 136);
  int v608 = *(_DWORD *)(a1 + 4);
  unint64_t v11 = v7 | v8;
  unint64_t v602 = *(int *)(a1 + 28);
  uint64_t v604 = *(void *)(a1 + 40);
  pthread_mutex_lock(&CMYK64_cacheColorLock);
  uint64_t v12 = CMYK64_cacheColor;
  if (!CMYK64_cacheColor
    || *(void *)(CMYK64_cacheColor + 16) != v11
    || *(unsigned __int16 *)(CMYK64_cacheColor + 24) != v9)
  {
    int v14 = 0;
    while (1)
    {
      if (!v12) {
        goto LABEL_14;
      }
      uint64_t v15 = v12;
      int v16 = v14;
      if (*(void *)(v12 + 16) == v11 && *(unsigned __int16 *)(v12 + 24) == v9) {
        break;
      }
      uint64_t v12 = *(void *)v12;
      int v14 = (void *)v15;
      if (!*(void *)v15)
      {
        if (CMYK64_cacheColorCount > 6)
        {
          *int v16 = 0;
        }
        else
        {
LABEL_14:
          uint64_t v17 = (char *)CMYK64_cacheColorBase;
          if (CMYK64_cacheColorBase)
          {
            unsigned int v18 = CMYK64_cacheColorCount;
          }
          else
          {
            uint64_t v17 = (char *)malloc_type_calloc(1uLL, 0x70E0uLL, 0x102004053D502F9uLL);
            unsigned int v18 = 0;
            CMYK64_cacheColorBase = (uint64_t)v17;
          }
          uint64_t v15 = (uint64_t)&v17[32 * v18];
          *(void *)(v15 + 8) = &v17[4096 * (unint64_t)v18 + 224];
          CMYK64_cacheColorCount = v18 + 1;
        }
        uint64_t v19 = 0;
        *(void *)uint64_t v15 = CMYK64_cacheColor;
        CMYK64_cacheColor = v15;
        *(void *)(v15 + 16) = v11;
        *(_WORD *)(v15 + 24) = v9;
        *(_DWORD *)(v15 + 26) = 0;
        *(_WORD *)(v15 + 30) = 0;
        uint64_t v21 = *(void *)(v15 + 8);
        uint64_t v13 = v15 + 8;
        uint64_t v20 = v21;
        int32x4_t v22 = vdupq_n_s32((unsigned __int16)v8);
        int32x4_t v23 = vdupq_n_s32(WORD1(v8));
        int32x4_t v24 = vdupq_n_s32(WORD2(v7));
        int32x4_t v25 = vdupq_n_s32(v6);
        int32x4_t v26 = vdupq_n_s32(v9);
        int32x4_t v27 = vdupq_n_s32(v8);
        int32x4_t v28 = vdupq_n_s32(HIDWORD(v7));
        int32x4_t v29 = (int32x4_t)xmmword_1850CDCC0;
        int32x4_t v30 = (int32x4_t)xmmword_1850CDC50;
        v31.i64[0] = 0xFFFF0000FFFFLL;
        v31.i64[1] = 0xFFFF0000FFFFLL;
        int16x8_t v32 = vdupq_n_s16(v9);
        v33.i64[0] = 0x800000008;
        v33.i64[1] = 0x800000008;
        int32x4_t v34 = vdupq_n_s32(0x101u);
        do
        {
          int32x4_t v35 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v29, v34), v31);
          int32x4_t v36 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v30, v34), v31);
          int8x16_t v37 = (int8x16_t)vmulq_s32(v36, v22);
          int8x16_t v38 = (int8x16_t)vmulq_s32(v35, v22);
          int8x16_t v39 = (int8x16_t)vmulq_s32(v35, v23);
          int8x16_t v40 = (int8x16_t)vmulq_s32(v36, v23);
          int8x16_t v41 = (int8x16_t)vmulq_s32(v35, v24);
          int8x16_t v42 = (int8x16_t)vmulq_s32(v36, v24);
          int8x16_t v43 = (int8x16_t)vmulq_s32(v36, v25);
          int8x16_t v44 = (int8x16_t)vmulq_s32(v35, v25);
          int8x16_t v45 = (int8x16_t)vmulq_s32(v36, v26);
          int8x16_t v46 = (int8x16_t)vmulq_s32(v35, v26);
          uint64_t v47 = v20 + v19;
          int32x4_t v48 = vsubq_s32(v25, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v43, 0x10uLL), (int32x4_t)vmvnq_s8(v43)), 0x10uLL));
          int32x4_t v49 = vsubq_s32(v25, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v44, 0x10uLL), (int32x4_t)vmvnq_s8(v44)), 0x10uLL));
          v50.i64[0] = v49.u32[2];
          v50.i64[1] = v49.u32[3];
          int64x2_t v51 = (int64x2_t)v50;
          v50.i64[0] = v49.u32[0];
          v50.i64[1] = v49.u32[1];
          int64x2_t v52 = (int64x2_t)v50;
          v50.i64[0] = v48.u32[2];
          v50.i64[1] = v48.u32[3];
          int64x2_t v53 = (int64x2_t)v50;
          v50.i64[0] = v48.u32[0];
          v50.i64[1] = v48.u32[1];
          _Q28 = vandq_s8((int8x16_t)vsubq_s32(v28, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v42, 0x10uLL), (int32x4_t)vmvnq_s8(v42)), 0x10uLL)), v31);
          _Q27 = vandq_s8((int8x16_t)vsubq_s32(v28, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v41, 0x10uLL), (int32x4_t)vmvnq_s8(v41)), 0x10uLL)), v31);
          int8x16_t v56 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q28.i8, 0x20uLL);
          __asm { SHLL2           V28.2D, V28.4S, #0x20 ; ' ' }
          int8x16_t v61 = (int8x16_t)vshll_n_s32(*(int32x2_t *)_Q27.i8, 0x20uLL);
          __asm { SHLL2           V27.2D, V27.4S, #0x20 ; ' ' }
          int8x16_t v62 = vorrq_s8((int8x16_t)vshlq_n_s64(v51, 0x30uLL), _Q27);
          int8x16_t v63 = vorrq_s8((int8x16_t)vshlq_n_s64(v52, 0x30uLL), v61);
          int8x16_t v64 = vorrq_s8((int8x16_t)vshlq_n_s64(v53, 0x30uLL), _Q28);
          int8x16_t v65 = vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v50, 0x30uLL), v56);
          int32x4_t v66 = vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v40, 0x10uLL), (int32x4_t)vmvnq_s8(v40)), 0x10uLL)), 0x10uLL);
          int32x4_t v67 = vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v39, 0x10uLL), (int32x4_t)vmvnq_s8(v39)), 0x10uLL)), 0x10uLL);
          v50.i64[0] = v67.u32[2];
          v50.i64[1] = v67.u32[3];
          int8x16_t v68 = v50;
          v50.i64[0] = v67.u32[0];
          v50.i64[1] = v67.u32[1];
          int8x16_t v69 = v50;
          v50.i64[0] = v66.u32[2];
          v50.i64[1] = v66.u32[3];
          int8x16_t v70 = v50;
          v50.i64[0] = v66.u32[0];
          v50.i64[1] = v66.u32[1];
          int8x16_t v71 = v50;
          int8x16_t v72 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v38, 0x10uLL), (int32x4_t)vmvnq_s8(v38)), 0x10uLL)), v31);
          int8x16_t v73 = vandq_s8((int8x16_t)vsubq_s32(v27, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v37, 0x10uLL), (int32x4_t)vmvnq_s8(v37)), 0x10uLL)), v31);
          v50.i64[0] = v73.u32[0];
          v50.i64[1] = v73.u32[1];
          int8x16_t v74 = v50;
          v50.i64[0] = v73.u32[2];
          v50.i64[1] = v73.u32[3];
          int8x16_t v75 = v50;
          v50.i64[0] = v72.u32[0];
          v50.i64[1] = v72.u32[1];
          int8x16_t v76 = v50;
          v50.i64[0] = v72.u32[2];
          v50.i64[1] = v72.u32[3];
          int8x16_t v77 = vorrq_s8(v65, vorrq_s8(v71, v74));
          *(void *)uint64_t v47 = v77.i64[0];
          int8x16_t v78 = vorrq_s8(v64, vorrq_s8(v70, v75));
          *(void *)(v47 + 32) = v78.i64[0];
          int8x16_t v79 = vorrq_s8(v63, vorrq_s8(v69, v76));
          *(void *)(v47 + 64) = v79.i64[0];
          int8x16_t v80 = vorrq_s8(v62, vorrq_s8(v68, v50));
          *(void *)(v47 + 96) = v80.i64[0];
          int16x8_t v81 = vsubq_s16(v32, vsubhn_high_s32(vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v45, 0x10uLL), (int32x4_t)vmvnq_s8(v45)), (int32x4_t)vshrq_n_u32((uint32x4_t)v46, 0x10uLL), (int32x4_t)vmvnq_s8(v46)));
          *(_WORD *)(v47 + 8) = v81.i16[0];
          *(void *)(v20 + v19 + 16) = v77.i64[1];
          *(void *)(v20 + v19 + 48) = v78.i64[1];
          *(void *)(v20 + v19 + 80) = v79.i64[1];
          *(void *)(v20 + v19 + 112) = v80.i64[1];
          *(_WORD *)(v20 + v19 + 24) = v81.i16[1];
          *(_WORD *)(v20 + v19 + 40) = v81.i16[2];
          *(_WORD *)(v20 + v19 + 56) = v81.i16[3];
          *(_WORD *)(v20 + v19 + 72) = v81.i16[4];
          *(_WORD *)(v20 + v19 + 88) = v81.i16[5];
          *(_WORD *)(v20 + v19 + 104) = v81.i16[6];
          *(_WORD *)(v20 + v19 + 120) = v81.i16[7];
          int32x4_t v30 = vaddq_s32(v30, v33);
          v19 += 128;
          int32x4_t v29 = vaddq_s32(v29, v33);
        }
        while (v19 != 4096);
        pthread_mutex_unlock(&CMYK64_cacheColorLock);
        goto LABEL_25;
      }
    }
    if (v14)
    {
      *int v14 = *(void *)v12;
      *(void *)uint64_t v12 = CMYK64_cacheColor;
      CMYK64_cacheColor = v12;
    }
  }
  pthread_mutex_unlock(&CMYK64_cacheColorLock);
  uint64_t v13 = v12 + 8;
LABEL_25:
  uint64_t v82 = *(void *)v13;
  unint64_t v83 = *(void *)(*(void *)v13 + 4080);
  unsigned int v84 = *(unsigned __int16 *)(*(void *)v13 + 4088);
  uint64_t v86 = *(int *)(a1 + 12);
  uint64_t v85 = *(int *)(a1 + 16);
  if (v3)
  {
    unint64_t v87 = (unint64_t)*(int *)(a1 + 32) >> 1;
    int v88 = (unsigned __int16 *)(v3 + 2 * (v86 + v87 * v85));
    uint64_t v89 = 1;
    if (!v606) {
      return;
    }
  }
  else
  {
    int v88 = 0;
    unint64_t v87 = 0;
    uint64_t v89 = 0;
    if (!v606) {
      return;
    }
  }
  unint64_t v90 = v87 - v608;
  if (v3) {
    unint64_t v91 = v87 - v608;
  }
  else {
    unint64_t v91 = v87;
  }
  unint64_t v92 = (int8x8_t *)(v604 + 8 * (v86 + (v602 >> 3) * v85));
  uint64_t v93 = *(int *)(a1 + 124);
  unint64_t v94 = v606 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v93;
  uint64_t v605 = v93 - v608;
  unint64_t v607 = (v602 >> 3) - v608;
  switch(a2)
  {
    case 0:
      if (v3)
      {
        uint64_t v95 = 2 * v89;
        do
        {
          int v96 = v608;
          do
          {
            int v97 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v97 == 255)
              {
                *unint64_t v92 = 0;
                *int v88 = 0;
              }
              else
              {
                CMYK64_DAM(v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, v97 ^ 0xFF | ((v97 ^ 0xFF) << 8));
              }
            }
            ++v94;
            ++v92;
            int v88 = (unsigned __int16 *)((char *)v88 + v95);
            --v96;
          }
          while (v96);
          v94 += v605;
          v92 += v607;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        v370.i64[0] = 0x100000001;
        v370.i64[1] = 0x100000001;
        do
        {
          int v371 = v608;
          do
          {
            int v372 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v372 == 255)
              {
                *unint64_t v92 = 0;
              }
              else
              {
                unsigned int v373 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v374.i32[0] = (unsigned __int16)v373;
                v374.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v373), 0x10uLL).i32[1];
                v374.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                uint32x4_t v375 = (uint32x4_t)vmulq_s32(v374, vdupq_n_s32((v372 ^ 0xFF | ((v372 ^ 0xFF) << 8)) ^ 0xFFFFu));
                v374.i32[0] = v373;
                *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v374, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v375, v375, 0x10uLL), v370), 0x10uLL))));
              }
            }
            ++v94;
            ++v92;
            --v371;
          }
          while (v371);
          v94 += v605;
          v92 += v607;
          --v10;
        }
        while (v10);
      }
      return;
    case 1:
      unsigned int v98 = v94 & 3;
      if (!v3)
      {
        int v376 = v98 + v608;
        int v377 = -1 << (8 * v98);
        if ((v94 & 3) != 0) {
          char v378 = v94 & 0xFC;
        }
        else {
          char v378 = v94;
        }
        if ((v94 & 3) != 0)
        {
          unsigned int v379 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v377 = -1;
          unsigned int v379 = (unsigned int *)v94;
        }
        if ((v94 & 3) != 0) {
          uint64_t v380 = &v92[-(v94 & 3)];
        }
        else {
          uint64_t v380 = v92;
        }
        if ((v94 & 3) == 0) {
          int v376 = v608;
        }
        if ((((_BYTE)v376 + v378) & 3) != 0)
        {
          int v381 = 4 - (((_BYTE)v376 + v378) & 3);
          v98 += v381;
          unsigned int v382 = 0xFFFFFFFF >> (8 * v381);
          if (v376 >= 4) {
            unsigned int v383 = v382;
          }
          else {
            unsigned int v383 = 0;
          }
          if (v376 >= 4) {
            unsigned int v382 = -1;
          }
          v377 &= v382;
        }
        else
        {
          unsigned int v383 = 0;
        }
        int v524 = v376 >> 2;
        unsigned int v525 = bswap32(v83);
        uint64_t v526 = v605 - v98;
        unsigned int v527 = bswap32(HIDWORD(v83)) >> 16;
        unsigned __int16 v528 = __rev16(HIWORD(v83));
        v529.i64[0] = 0x100000001;
        v529.i64[1] = 0x100000001;
        unint64_t v530 = v607 - v98;
        while (1)
        {
          unsigned int v531 = *v379 & v377;
          int v532 = v524;
          unsigned int v533 = v383;
          if (!v531) {
            goto LABEL_562;
          }
LABEL_544:
          if (v531 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v531)
            {
              if (v531 == 255)
              {
                v380->i16[0] = HIWORD(v525);
                v380->i16[1] = v525;
                v380->i16[2] = v527;
                v380->i16[3] = v528;
              }
              else
              {
                unint64_t v534 = *(void *)(v82 + 16 * v531);
                unsigned int v535 = bswap32(v380->u16[1] | (v380->u16[0] << 16));
                v536.i32[0] = (unsigned __int16)v535;
                v536.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v535), 0x10uLL).i32[1];
                v536.i64[1] = __PAIR64__(bswap32(v380->u16[3]) >> 16, bswap32(v380->u16[2]) >> 16);
                uint32x4_t v537 = (uint32x4_t)vmulq_s32(v536, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(v531 | (v531 << 8)))));
                v538.i32[0] = v534;
                v538.i32[1] = WORD1(v534);
                *uint64_t v380 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v538, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v534), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v537, v537, 0x10uLL), v529), 0x10uLL)));
              }
            }
            if (BYTE1(v531))
            {
              if (BYTE1(v531) == 255)
              {
                v380[1].i16[0] = HIWORD(v525);
                v380[1].i16[1] = v525;
                v380[1].i16[2] = v527;
                v380[1].i16[3] = v528;
              }
              else
              {
                unint64_t v539 = *(void *)(v82 + 16 * BYTE1(v531));
                unsigned int v540 = bswap32(v380[1].u16[1] | (v380[1].u16[0] << 16));
                v541.i32[0] = (unsigned __int16)v540;
                v541.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v540), 0x10uLL).i32[1];
                v541.i64[1] = __PAIR64__(bswap32(v380[1].u16[3]) >> 16, bswap32(v380[1].u16[2]) >> 16);
                uint32x4_t v542 = (uint32x4_t)vmulq_s32(v541, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(BYTE1(v531) | (BYTE1(v531) << 8)))));
                v543.i32[0] = v539;
                v543.i32[1] = WORD1(v539);
                v380[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v543, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v539), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v542, v542, 0x10uLL), v529), 0x10uLL)));
              }
            }
            if (BYTE2(v531))
            {
              if (BYTE2(v531) == 255)
              {
                v380[2].i16[0] = HIWORD(v525);
                v380[2].i16[1] = v525;
                v380[2].i16[2] = v527;
                v380[2].i16[3] = v528;
              }
              else
              {
                unint64_t v544 = *(void *)(v82 + 16 * BYTE2(v531));
                unsigned int v545 = bswap32(v380[2].u16[1] | (v380[2].u16[0] << 16));
                v546.i32[0] = (unsigned __int16)v545;
                v546.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v545), 0x10uLL).i32[1];
                v546.i64[1] = __PAIR64__(bswap32(v380[2].u16[3]) >> 16, bswap32(v380[2].u16[2]) >> 16);
                uint32x4_t v547 = (uint32x4_t)vmulq_s32(v546, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~(BYTE2(v531) | (BYTE2(v531) << 8)))));
                v548.i32[0] = v544;
                v548.i32[1] = WORD1(v544);
                v380[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v548, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v544), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v547, v547, 0x10uLL), v529), 0x10uLL)));
              }
            }
            unsigned int v549 = HIBYTE(v531);
            if (v549 == 255) {
              goto LABEL_559;
            }
            if (v549)
            {
              int v550 = v549 | (v549 << 8);
              unint64_t v551 = *(void *)(v82 + 16 * v549);
              unsigned int v552 = bswap32(v380[3].u16[1] | (v380[3].u16[0] << 16));
              v553.i32[0] = (unsigned __int16)v552;
              v553.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v552), 0x10uLL).i32[1];
              v553.i64[1] = __PAIR64__(bswap32(v380[3].u16[3]) >> 16, bswap32(v380[3].u16[2]) >> 16);
              uint32x4_t v554 = (uint32x4_t)vmulq_s32(v553, vdupq_n_s32(v550 ^ 0xFFFFu));
              v555.i32[0] = v551;
              v555.i32[1] = WORD1(v551);
              v380[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v555, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v551), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v554, v554, 0x10uLL), v529), 0x10uLL)));
            }
LABEL_562:
            while (1)
            {
              int v556 = v532;
              v380 += 4;
              --v532;
              ++v379;
              if (v556 < 2) {
                break;
              }
              unsigned int v531 = *v379;
              if (*v379) {
                goto LABEL_544;
              }
            }
            if (!v533) {
              break;
            }
            unsigned int v533 = 0;
            unsigned int v531 = *v379 & v383;
          }
          unsigned int v379 = (unsigned int *)((char *)v379 + v526);
          v380 += v530;
          if (!--v10) {
            return;
          }
        }
        v380->i16[0] = HIWORD(v525);
        v380->i16[1] = v525;
        v380->i16[2] = v527;
        v380->i16[3] = v528;
        v380[1].i16[0] = HIWORD(v525);
        v380[1].i16[1] = v525;
        v380[1].i16[2] = v527;
        v380[1].i16[3] = v528;
        v380[2].i16[0] = HIWORD(v525);
        v380[2].i16[1] = v525;
        v380[2].i16[2] = v527;
        v380[2].i16[3] = v528;
LABEL_559:
        v380[3].i16[0] = HIWORD(v525);
        v380[3].i16[1] = v525;
        v380[3].i16[2] = v527;
        v380[3].i16[3] = v528;
        goto LABEL_562;
      }
      int v99 = v98 + v608;
      int v100 = -1 << (8 * v98);
      uint64_t v101 = &v92[-(v94 & 3)];
      if ((v94 & 3) != 0) {
        char v102 = v94 & 0xFC;
      }
      else {
        char v102 = v94;
      }
      if ((v94 & 3) != 0)
      {
        uint64_t v103 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v100 = -1;
        uint64_t v103 = (unsigned int *)v94;
      }
      if ((v94 & 3) != 0) {
        uint64_t v104 = &v88[-(v94 & 3)];
      }
      else {
        uint64_t v104 = v88;
      }
      if ((v94 & 3) == 0)
      {
        uint64_t v101 = v92;
        int v99 = v608;
      }
      if ((((_BYTE)v99 + v102) & 3) != 0)
      {
        int v105 = 4 - (((_BYTE)v99 + v102) & 3);
        v98 += v105;
        unsigned int v106 = 0xFFFFFFFF >> (8 * v105);
        if (v99 >= 4) {
          unsigned int v107 = v106;
        }
        else {
          unsigned int v107 = 0;
        }
        if (v99 >= 4) {
          unsigned int v106 = -1;
        }
        v100 &= v106;
      }
      else
      {
        unsigned int v107 = 0;
      }
      int v417 = v99 >> 2;
      unsigned int v418 = bswap32(v83);
      LOWORD(v83) = __rev16(HIWORD(v83));
      unsigned __int16 v419 = __rev16(v84);
      unint64_t v420 = v90 - v98;
      v421.i64[0] = 0x100000001;
      v421.i64[1] = 0x100000001;
      unsigned int v422 = bswap32(HIDWORD(v83)) >> 16;
      do
      {
        unsigned int v423 = *v103 & v100;
        int v424 = v417;
        unsigned int v425 = v107;
        if (!v423) {
          goto LABEL_513;
        }
LABEL_492:
        if (v423 == -1)
        {
          v101->i16[0] = HIWORD(v418);
          v101->i16[1] = v418;
          v101->i16[2] = v422;
          v101->i16[3] = v83;
          *uint64_t v104 = v419;
          v101[1].i16[0] = HIWORD(v418);
          v101[1].i16[1] = v418;
          v101[1].i16[2] = v422;
          v101[1].i16[3] = v83;
          v104[1] = v419;
          v101[2].i16[0] = HIWORD(v418);
          v101[2].i16[1] = v418;
          v101[2].i16[2] = v422;
          v101[2].i16[3] = v83;
          v104[2] = v419;
LABEL_510:
          v101[3].i16[0] = HIWORD(v418);
          v101[3].i16[1] = v418;
          v101[3].i16[2] = v422;
          v101[3].i16[3] = v83;
          v104[3] = v419;
          goto LABEL_513;
        }
        while (1)
        {
          if ((_BYTE)v423)
          {
            if (v423 == 255)
            {
              v101->i16[0] = HIWORD(v418);
              v101->i16[1] = v418;
              v101->i16[2] = v422;
              LOWORD(v426) = v419;
              v101->i16[3] = v83;
            }
            else
            {
              int v427 = v423 | (v423 << 8);
              uint64_t v428 = v82 + 16 * v423;
              unint64_t v429 = *(void *)v428;
              LODWORD(v428) = *(unsigned __int16 *)(v428 + 8);
              unsigned int v430 = bswap32(v101->u16[1] | (v101->u16[0] << 16));
              v431.i32[0] = (unsigned __int16)v430;
              v431.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v430), 0x10uLL).i32[1];
              unsigned int v432 = ~v427;
              unsigned int v433 = (unsigned __int16)~(_WORD)v427 * (bswap32(*v104) >> 16);
              v431.i64[1] = __PAIR64__(bswap32(v101->u16[3]) >> 16, bswap32(v101->u16[2]) >> 16);
              uint32x4_t v434 = (uint32x4_t)vmulq_s32(v431, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v432)));
              v435.i32[0] = v429;
              v435.i32[1] = WORD1(v429);
              *uint64_t v101 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v435, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v429), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v434, v434, 0x10uLL), v421), 0x10uLL)));
              unsigned int v426 = bswap32(v428 + ((v433 + HIWORD(v433) + 1) >> 16)) >> 16;
            }
            *uint64_t v104 = v426;
          }
          if (BYTE1(v423))
          {
            if (BYTE1(v423) == 255)
            {
              v101[1].i16[0] = HIWORD(v418);
              v101[1].i16[1] = v418;
              v101[1].i16[2] = v422;
              LOWORD(v436) = v419;
              v101[1].i16[3] = v83;
            }
            else
            {
              int v437 = BYTE1(v423) | (BYTE1(v423) << 8);
              uint64_t v438 = v82 + 16 * BYTE1(v423);
              unint64_t v439 = *(void *)v438;
              LODWORD(v438) = *(unsigned __int16 *)(v438 + 8);
              unsigned int v440 = bswap32(v101[1].u16[1] | (v101[1].u16[0] << 16));
              v441.i32[0] = (unsigned __int16)v440;
              v441.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v440), 0x10uLL).i32[1];
              unsigned int v442 = ~v437;
              unsigned int v443 = (unsigned __int16)~(_WORD)v437 * (bswap32(v104[1]) >> 16);
              v441.i64[1] = __PAIR64__(bswap32(v101[1].u16[3]) >> 16, bswap32(v101[1].u16[2]) >> 16);
              uint32x4_t v444 = (uint32x4_t)vmulq_s32(v441, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v442)));
              v445.i32[0] = v439;
              v445.i32[1] = WORD1(v439);
              v101[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v445, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v439), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v444, v444, 0x10uLL), v421), 0x10uLL)));
              unsigned int v436 = bswap32(v438 + ((v443 + HIWORD(v443) + 1) >> 16)) >> 16;
            }
            v104[1] = v436;
          }
          if (BYTE2(v423))
          {
            if (BYTE2(v423) == 255)
            {
              v101[2].i16[0] = HIWORD(v418);
              v101[2].i16[1] = v418;
              v101[2].i16[2] = v422;
              LOWORD(v446) = v419;
              v101[2].i16[3] = v83;
            }
            else
            {
              int v447 = BYTE2(v423) | (BYTE2(v423) << 8);
              uint64_t v448 = v82 + 16 * BYTE2(v423);
              unint64_t v449 = *(void *)v448;
              LODWORD(v448) = *(unsigned __int16 *)(v448 + 8);
              unsigned int v450 = bswap32(v101[2].u16[1] | (v101[2].u16[0] << 16));
              v451.i32[0] = (unsigned __int16)v450;
              v451.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v450), 0x10uLL).i32[1];
              unsigned int v452 = ~v447;
              unsigned int v453 = (unsigned __int16)~(_WORD)v447 * (bswap32(v104[2]) >> 16);
              v451.i64[1] = __PAIR64__(bswap32(v101[2].u16[3]) >> 16, bswap32(v101[2].u16[2]) >> 16);
              uint32x4_t v454 = (uint32x4_t)vmulq_s32(v451, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v452)));
              v455.i32[0] = v449;
              v455.i32[1] = WORD1(v449);
              v101[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v455, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v449), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v454, v454, 0x10uLL), v421), 0x10uLL)));
              unsigned int v446 = bswap32(v448 + ((v453 + HIWORD(v453) + 1) >> 16)) >> 16;
            }
            v104[2] = v446;
          }
          unsigned int v456 = HIBYTE(v423);
          if (v456 == 255) {
            goto LABEL_510;
          }
          if (v456)
          {
            unsigned int v457 = v456 | (v456 << 8);
            uint64_t v458 = v82 + 16 * v456;
            unint64_t v459 = *(void *)v458;
            LODWORD(v458) = *(unsigned __int16 *)(v458 + 8);
            unsigned int v460 = bswap32(v101[3].u16[1] | (v101[3].u16[0] << 16));
            v457 ^= 0xFFFFu;
            v461.i32[0] = (unsigned __int16)v460;
            v461.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v460), 0x10uLL).i32[1];
            unsigned int v462 = v457 * (bswap32(v104[3]) >> 16);
            v461.i64[1] = __PAIR64__(bswap32(v101[3].u16[3]) >> 16, bswap32(v101[3].u16[2]) >> 16);
            uint32x4_t v463 = (uint32x4_t)vmulq_s32(v461, vdupq_n_s32(v457));
            v464.i32[0] = v459;
            v464.i32[1] = WORD1(v459);
            v101[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v464, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v459), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v463, v463, 0x10uLL), v421), 0x10uLL)));
            v104[3] = bswap32(v458 + ((v462 + HIWORD(v462) + 1) >> 16)) >> 16;
          }
LABEL_513:
          while (1)
          {
            int v465 = v424;
            v101 += 4;
            v104 += 4;
            --v424;
            ++v103;
            if (v465 < 2) {
              break;
            }
            unsigned int v423 = *v103;
            if (*v103) {
              goto LABEL_492;
            }
          }
          if (!v425) {
            break;
          }
          unsigned int v425 = 0;
          unsigned int v423 = *v103 & v107;
        }
        uint64_t v103 = (unsigned int *)((char *)v103 + v605 - v98);
        v101 += v607 - v98;
        v104 += v420;
        --v10;
      }
      while (v10);
      return;
    case 2:
      unsigned int v108 = v94 & 3;
      if (v3)
      {
        int v109 = -1 << (8 * v108);
        unsigned int v110 = &v92[-(v94 & 3)];
        if ((v94 & 3) != 0) {
          char v111 = v94 & 0xFC;
        }
        else {
          char v111 = v94;
        }
        if ((v94 & 3) != 0)
        {
          unint64_t v112 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v109 = -1;
          unint64_t v112 = (unsigned int *)v94;
        }
        if ((v94 & 3) != 0) {
          BOOL v113 = &v88[-(v94 & 3)];
        }
        else {
          BOOL v113 = v88;
        }
        if ((v94 & 3) != 0)
        {
          int v114 = v108 + v608;
        }
        else
        {
          unsigned int v110 = v92;
          int v114 = v608;
        }
        if ((((_BYTE)v114 + v111) & 3) != 0)
        {
          int v115 = 4 - (((_BYTE)v114 + v111) & 3);
          v108 += v115;
          unsigned int v116 = 0xFFFFFFFF >> (8 * v115);
          if (v114 >= 4) {
            unsigned int v117 = -1;
          }
          else {
            unsigned int v117 = 0xFFFFFFFF >> (8 * v115);
          }
          v109 &= v117;
          if (v114 < 4) {
            unsigned int v116 = 0;
          }
        }
        else
        {
          unsigned int v116 = 0;
        }
        uint64_t v466 = v605 - v108;
        unint64_t v467 = v607 - v108;
        unint64_t v468 = v90 - v108;
        int v469 = v114 >> 2;
        unsigned int v470 = (unsigned __int16)~(_WORD)v84;
        int32x4_t v471 = vdupq_n_s32(v470);
        v472.i32[0] = v83;
        v472.i32[1] = WORD1(v83);
        uint32x4_t v473 = (uint32x4_t)vmovn_hight_s64(v472, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v83), (uint64x2_t)xmmword_1850CDC40));
        v474.i64[0] = 0x100000001;
        v474.i64[1] = 0x100000001;
        while (1)
        {
          unsigned int v475 = *v112 & v109;
          unsigned int v476 = v116;
          int v477 = v469;
          if (!v475) {
            goto LABEL_534;
          }
LABEL_523:
          if (v475 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v475)
            {
              uint64_t v494 = v82 + 16 * v475;
              unint64_t v495 = *(void *)v494;
              LODWORD(v494) = *(unsigned __int16 *)(v494 + 8);
              unsigned int v496 = bswap32(v110->u16[1] | (v110->u16[0] << 16));
              v497.i32[0] = (unsigned __int16)v496;
              v497.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v496), 0x10uLL).i32[1];
              unsigned int v498 = (unsigned __int16)~(_WORD)v494 * (bswap32(*v113) >> 16);
              v497.i64[1] = __PAIR64__(bswap32(v110->u16[3]) >> 16, bswap32(v110->u16[2]) >> 16);
              uint32x4_t v499 = (uint32x4_t)vmulq_s32(v497, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v494)));
              v500.i32[0] = v495;
              v500.i32[1] = WORD1(v495);
              *unsigned int v110 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v500, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v495), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v499, v499, 0x10uLL), v474), 0x10uLL)));
              *BOOL v113 = bswap32(v494 + ((v498 + HIWORD(v498) + 1) >> 16)) >> 16;
            }
            if ((v475 & 0xFF00) != 0)
            {
              uint64_t v501 = v82 + 16 * BYTE1(v475);
              unint64_t v502 = *(void *)v501;
              LODWORD(v501) = *(unsigned __int16 *)(v501 + 8);
              unsigned int v503 = bswap32(v110[1].u16[1] | (v110[1].u16[0] << 16));
              v504.i32[0] = (unsigned __int16)v503;
              v504.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v503), 0x10uLL).i32[1];
              unsigned int v505 = (unsigned __int16)~(_WORD)v501 * (bswap32(v113[1]) >> 16);
              v504.i64[1] = __PAIR64__(bswap32(v110[1].u16[3]) >> 16, bswap32(v110[1].u16[2]) >> 16);
              uint32x4_t v506 = (uint32x4_t)vmulq_s32(v504, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v501)));
              v507.i32[0] = v502;
              v507.i32[1] = WORD1(v502);
              v110[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v507, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v502), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v506, v506, 0x10uLL), v474), 0x10uLL)));
              v113[1] = bswap32(v501 + ((v505 + HIWORD(v505) + 1) >> 16)) >> 16;
            }
            if ((v475 & 0xFF0000) != 0)
            {
              uint64_t v508 = v82 + 16 * BYTE2(v475);
              unint64_t v509 = *(void *)v508;
              LODWORD(v508) = *(unsigned __int16 *)(v508 + 8);
              unsigned int v510 = bswap32(v110[2].u16[1] | (v110[2].u16[0] << 16));
              v511.i32[0] = (unsigned __int16)v510;
              v511.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v510), 0x10uLL).i32[1];
              unsigned int v512 = (unsigned __int16)~(_WORD)v508 * (bswap32(v113[2]) >> 16);
              v511.i64[1] = __PAIR64__(bswap32(v110[2].u16[3]) >> 16, bswap32(v110[2].u16[2]) >> 16);
              uint32x4_t v513 = (uint32x4_t)vmulq_s32(v511, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v508)));
              v514.i32[0] = v509;
              v514.i32[1] = WORD1(v509);
              v110[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v514, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v509), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v513, v513, 0x10uLL), v474), 0x10uLL)));
              v113[2] = bswap32(v508 + ((v512 + HIWORD(v512) + 1) >> 16)) >> 16;
            }
            unsigned int v515 = HIBYTE(v475);
            if (v515)
            {
              uint64_t v516 = v82 + 16 * v515;
              unint64_t v517 = *(void *)v516;
              unsigned int v493 = *(unsigned __int16 *)(v516 + 8);
              unsigned int v518 = bswap32(v110[3].u16[1] | (v110[3].u16[0] << 16));
              v519.i32[0] = (unsigned __int16)v518;
              v519.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v518), 0x10uLL).i32[1];
              unsigned int v520 = (unsigned __int16)~(_WORD)v493 * (bswap32(v113[3]) >> 16);
              v519.i64[1] = __PAIR64__(bswap32(v110[3].u16[3]) >> 16, bswap32(v110[3].u16[2]) >> 16);
              unsigned int v490 = v520 + HIWORD(v520) + 1;
              uint32x4_t v521 = (uint32x4_t)vmulq_s32(v519, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v493)));
              uint32x4_t v522 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v521, v521, 0x10uLL), v474);
              v521.i32[0] = v517;
              v521.i32[1] = WORD1(v517);
              int32x4_t v492 = (int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v521.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v517), (uint64x2_t)xmmword_1850CDC40)), v522, 0x10uLL);
              goto LABEL_533;
            }
LABEL_534:
            while (1)
            {
              int v523 = v477;
              v110 += 4;
              v113 += 4;
              --v477;
              ++v112;
              if (v523 < 2) {
                break;
              }
              unsigned int v475 = *v112;
              if (*v112) {
                goto LABEL_523;
              }
            }
            if (!v476) {
              break;
            }
            unsigned int v476 = 0;
            unsigned int v475 = *v112 & v116;
          }
          unint64_t v112 = (unsigned int *)((char *)v112 + v466);
          v110 += v467;
          v113 += v468;
          if (!--v10) {
            return;
          }
        }
        unsigned int v478 = bswap32(v110->u16[1] | (v110->u16[0] << 16));
        unsigned int v479 = bswap32(*v113);
        v480.i32[0] = (unsigned __int16)v478;
        v480.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v478), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v480.i32[2] = bswap32(v110->u16[2]) >> 16;
        v480.i32[3] = bswap32(v110->u16[3]) >> 16;
        uint32x4_t v481 = (uint32x4_t)vmulq_s32(v480, v471);
        *unsigned int v110 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v473, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v481, v481, 0x10uLL), v474), 0x10uLL)));
        *BOOL v113 = bswap32(v84 + ((v470 * HIWORD(v479) + ((v470 * HIWORD(v479)) >> 16) + 1) >> 16)) >> 16;
        unsigned int v482 = bswap32(v110[1].u16[1] | (v110[1].u16[0] << 16));
        unsigned int v483 = bswap32(v113[1]);
        v480.i32[0] = (unsigned __int16)v482;
        v480.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v482), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v480.i32[2] = bswap32(v110[1].u16[2]) >> 16;
        v480.i32[3] = bswap32(v110[1].u16[3]) >> 16;
        uint32x4_t v484 = (uint32x4_t)vmulq_s32(v480, v471);
        v110[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v473, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v484, v484, 0x10uLL), v474), 0x10uLL)));
        v113[1] = bswap32(v84 + ((v470 * HIWORD(v483) + ((v470 * HIWORD(v483)) >> 16) + 1) >> 16)) >> 16;
        unsigned int v485 = bswap32(v110[2].u16[1] | (v110[2].u16[0] << 16));
        unsigned int v486 = bswap32(v113[2]);
        v480.i32[0] = (unsigned __int16)v485;
        v480.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v485), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        v480.i32[2] = bswap32(v110[2].u16[2]) >> 16;
        v480.i32[3] = bswap32(v110[2].u16[3]) >> 16;
        uint32x4_t v487 = (uint32x4_t)vmulq_s32(v480, v471);
        v110[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v473, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v487, v487, 0x10uLL), v474), 0x10uLL)));
        v113[2] = bswap32(v84 + ((v470 * HIWORD(v486) + ((v470 * HIWORD(v486)) >> 16) + 1) >> 16)) >> 16;
        unsigned int v488 = bswap32(v110[3].u16[1] | (v110[3].u16[0] << 16));
        unsigned int v489 = bswap32(v113[3]);
        v480.i32[0] = (unsigned __int16)v488;
        v480.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v488), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
        unsigned int v490 = v470 * HIWORD(v489) + ((v470 * HIWORD(v489)) >> 16) + 1;
        v480.i64[1] = __PAIR64__(bswap32(v110[3].u16[3]) >> 16, bswap32(v110[3].u16[2]) >> 16);
        uint32x4_t v491 = (uint32x4_t)vmulq_s32(v480, v471);
        int32x4_t v492 = (int32x4_t)vsraq_n_u32(v473, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v491, v491, 0x10uLL), v474), 0x10uLL);
        unsigned int v493 = v84;
LABEL_533:
        v110[3] = vrev16_s8((int8x8_t)vmovn_s32(v492));
        v113[3] = bswap32(v493 + HIWORD(v490)) >> 16;
        goto LABEL_534;
      }
      int v384 = -1 << (8 * v108);
      if ((v94 & 3) != 0) {
        char v385 = v94 & 0xFC;
      }
      else {
        char v385 = v94;
      }
      if ((v94 & 3) != 0)
      {
        uint64_t v386 = (unsigned int *)(v94 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v384 = -1;
        uint64_t v386 = (unsigned int *)v94;
      }
      if ((v94 & 3) != 0) {
        uint64_t v387 = &v92[-(v94 & 3)];
      }
      else {
        uint64_t v387 = v92;
      }
      if ((v94 & 3) != 0) {
        int v388 = v108 + v608;
      }
      else {
        int v388 = v608;
      }
      if ((((_BYTE)v388 + v385) & 3) != 0)
      {
        int v389 = 4 - (((_BYTE)v388 + v385) & 3);
        v108 += v389;
        unsigned int v390 = 0xFFFFFFFF >> (8 * v389);
        if (v388 >= 4) {
          unsigned int v391 = -1;
        }
        else {
          unsigned int v391 = 0xFFFFFFFF >> (8 * v389);
        }
        v384 &= v391;
        if (v388 < 4) {
          unsigned int v390 = 0;
        }
      }
      else
      {
        unsigned int v390 = 0;
      }
      uint64_t v557 = v605 - v108;
      unint64_t v558 = v607 - v108;
      int v559 = v388 >> 2;
      int32x4_t v560 = vdupq_n_s32((unsigned __int16)~(_WORD)v84);
      v561.i32[0] = v83;
      v561.i32[1] = WORD1(v83);
      uint32x4_t v562 = (uint32x4_t)vmovn_hight_s64(v561, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v83), (uint64x2_t)xmmword_1850CDC40));
      v563.i64[0] = 0x100000001;
      v563.i64[1] = 0x100000001;
      while (1)
      {
        unsigned int v564 = *v386 & v384;
        unsigned int v565 = v390;
        int v566 = v559;
        if (!v564) {
          goto LABEL_583;
        }
LABEL_572:
        if (v564 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v564)
          {
            uint64_t v581 = v82 + 16 * v564;
            unsigned int v582 = bswap32(v387->u16[1] | (v387->u16[0] << 16));
            v583.i32[0] = (unsigned __int16)v582;
            v583.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v582), 0x10uLL).i32[1];
            v583.i64[1] = __PAIR64__(bswap32(v387->u16[3]) >> 16, bswap32(v387->u16[2]) >> 16);
            uint32x4_t v584 = (uint32x4_t)vmulq_s32(v583, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v581 + 8))));
            v585.i32[0] = *(void *)v581;
            v585.i32[1] = v585.u16[1];
            *uint64_t v387 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v585, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v581), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v584, v584, 0x10uLL), v563), 0x10uLL)));
          }
          if ((v564 & 0xFF00) != 0)
          {
            uint64_t v586 = v82 + 16 * BYTE1(v564);
            unsigned int v587 = bswap32(v387[1].u16[1] | (v387[1].u16[0] << 16));
            v588.i32[0] = (unsigned __int16)v587;
            v588.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v587), 0x10uLL).i32[1];
            v588.i64[1] = __PAIR64__(bswap32(v387[1].u16[3]) >> 16, bswap32(v387[1].u16[2]) >> 16);
            uint32x4_t v589 = (uint32x4_t)vmulq_s32(v588, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v586 + 8))));
            v590.i32[0] = *(void *)v586;
            v590.i32[1] = v590.u16[1];
            v387[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v590, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v586), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v589, v589, 0x10uLL), v563), 0x10uLL)));
          }
          if ((v564 & 0xFF0000) != 0)
          {
            uint64_t v591 = v82 + 16 * BYTE2(v564);
            unsigned int v592 = bswap32(v387[2].u16[1] | (v387[2].u16[0] << 16));
            v593.i32[0] = (unsigned __int16)v592;
            v593.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v592), 0x10uLL).i32[1];
            v593.i64[1] = __PAIR64__(bswap32(v387[2].u16[3]) >> 16, bswap32(v387[2].u16[2]) >> 16);
            uint32x4_t v594 = (uint32x4_t)vmulq_s32(v593, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v591 + 8))));
            v595.i32[0] = *(void *)v591;
            v595.i32[1] = v595.u16[1];
            v387[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v595, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v591), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v594, v594, 0x10uLL), v563), 0x10uLL)));
          }
          unsigned int v596 = HIBYTE(v564);
          if (v596)
          {
            uint64_t v597 = v82 + 16 * v596;
            unsigned int v598 = bswap32(v387[3].u16[1] | (v387[3].u16[0] << 16));
            v599.i32[0] = (unsigned __int16)v598;
            v599.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v598), 0x10uLL).i32[1];
            v599.i64[1] = __PAIR64__(bswap32(v387[3].u16[3]) >> 16, bswap32(v387[3].u16[2]) >> 16);
            uint32x4_t v600 = (uint32x4_t)vmulq_s32(v599, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~*(unsigned __int16 *)(v597 + 8))));
            uint32x4_t v579 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v600, v600, 0x10uLL), v563);
            v600.i32[0] = *(void *)v597;
            v600.i32[1] = v600.u16[1];
            uint32x4_t v580 = (uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v600.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(void *)v597), (uint64x2_t)xmmword_1850CDC40));
            goto LABEL_582;
          }
LABEL_583:
          while (1)
          {
            int v601 = v566;
            v387 += 4;
            --v566;
            ++v386;
            if (v601 < 2) {
              break;
            }
            unsigned int v564 = *v386;
            if (*v386) {
              goto LABEL_572;
            }
          }
          if (!v565) {
            break;
          }
          unsigned int v565 = 0;
          unsigned int v564 = *v386 & v390;
        }
        uint64_t v386 = (unsigned int *)((char *)v386 + v557);
        v387 += v558;
        if (!--v10) {
          return;
        }
      }
      unsigned int v567 = bswap32(v387->u16[1] | (v387->u16[0] << 16));
      v568.i32[0] = (unsigned __int16)v567;
      v568.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v567), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v568.i32[2] = bswap32(v387->u16[2]) >> 16;
      v568.i32[3] = bswap32(v387->u16[3]) >> 16;
      uint32x4_t v569 = (uint32x4_t)vmulq_s32(v568, v560);
      int32x4_t v570 = (int32x4_t)vsraq_n_u32(v562, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v569, v569, 0x10uLL), v563), 0x10uLL);
      unsigned int v571 = bswap32(v387[1].u16[1] | (v387[1].u16[0] << 16));
      v572.i32[0] = (unsigned __int16)v571;
      v572.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v571), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v572.i32[2] = bswap32(v387[1].u16[2]) >> 16;
      v572.i32[3] = bswap32(v387[1].u16[3]) >> 16;
      uint32x4_t v573 = (uint32x4_t)vmulq_s32(v572, v560);
      unsigned int v574 = bswap32(v387[2].u16[1] | (v387[2].u16[0] << 16));
      v575.i32[0] = (unsigned __int16)v574;
      v575.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v574), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v575.i32[2] = bswap32(v387[2].u16[2]) >> 16;
      v575.i32[3] = bswap32(v387[2].u16[3]) >> 16;
      *uint64_t v387 = vrev16_s8((int8x8_t)vmovn_s32(v570));
      v387[1] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v562, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v573, v573, 0x10uLL), v563), 0x10uLL)));
      uint32x4_t v576 = (uint32x4_t)vmulq_s32(v575, v560);
      unsigned int v577 = bswap32(v387[3].u16[1] | (v387[3].u16[0] << 16));
      v572.i32[0] = (unsigned __int16)v577;
      v572.i32[1] = vshl_u32((uint32x2_t)vdup_n_s32(v577), (uint32x2_t)0xFFFFFFF0FFFF0001).i32[1];
      v572.i64[1] = __PAIR64__(bswap32(v387[3].u16[3]) >> 16, bswap32(v387[3].u16[2]) >> 16);
      v387[2] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v562, (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v576, v576, 0x10uLL), v563), 0x10uLL)));
      uint32x4_t v578 = (uint32x4_t)vmulq_s32(v572, v560);
      uint32x4_t v579 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v578, v578, 0x10uLL), v563);
      uint32x4_t v580 = v562;
LABEL_582:
      v387[3] = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32(v580, v579, 0x10uLL)));
      goto LABEL_583;
    case 3:
      uint64_t v118 = 2 * v89;
      v119.i64[0] = 0x100000001;
      v119.i64[1] = 0x100000001;
      do
      {
        int v120 = v608;
        do
        {
          int v121 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94)
          {
            if (v121 == 255)
            {
              int v122 = (unint64_t *)(v82 + 16 * *(unsigned __int8 *)v88);
              unint64_t v123 = *v122;
              unsigned int v124 = *((unsigned __int16 *)v122 + 4);
              unint64_t v125 = HIDWORD(v123);
              unint64_t v126 = HIWORD(v123);
              LODWORD(v123) = bswap32(v123);
              v92->i16[0] = WORD1(v123);
              v92->i16[1] = v123;
              v92->i16[2] = bswap32(v125) >> 16;
              v92->i16[3] = __rev16(v126);
            }
            else
            {
              int v127 = v121 | (v121 << 8);
              unsigned int v128 = bswap32(*v88) >> 16;
              uint64_t v129 = v82 + 16 * ((v128 * v127 + ((v128 * v127) >> 16) + 1) >> 24);
              unint64_t v130 = *(void *)v129;
              LODWORD(v129) = *(unsigned __int16 *)(v129 + 8);
              unsigned int v131 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
              v132.i32[0] = (unsigned __int16)v131;
              v132.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v131), 0x10uLL).i32[1];
              v132.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
              uint32x4_t v133 = (uint32x4_t)vmulq_s32(v132, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v127)));
              v134.i32[0] = v130;
              v134.i32[1] = WORD1(v130);
              *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v134, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v130), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v133, v133, 0x10uLL), v119), 0x10uLL)));
              unsigned int v124 = v129
                   + (((unsigned __int16)~(_WORD)v127 * v128 + (((unsigned __int16)~(_WORD)v127 * v128) >> 16) + 1) >> 16);
            }
            *int v88 = bswap32(v124) >> 16;
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v118);
          --v120;
        }
        while (v120);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 4:
      uint64_t v135 = 2 * v89;
      v136.i64[0] = 0x100000001;
      v136.i64[1] = 0x100000001;
      do
      {
        int v137 = v608;
        do
        {
          int v138 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94)
          {
            if (v138 == 255)
            {
              int v139 = (unint64_t *)(v82 + 16 * ~*(unsigned char *)v88);
              unint64_t v140 = *v139;
              unsigned int v141 = *((unsigned __int16 *)v139 + 4);
              unint64_t v142 = HIDWORD(v140);
              unint64_t v143 = HIWORD(v140);
              LODWORD(v140) = bswap32(v140);
              v92->i16[0] = WORD1(v140);
              v92->i16[1] = v140;
              v92->i16[2] = bswap32(v142) >> 16;
              v92->i16[3] = __rev16(v143);
            }
            else
            {
              int v144 = v138 | (v138 << 8);
              unsigned int v145 = bswap32(*v88) >> 16;
              uint64_t v146 = v82 + 16 * (((v145 ^ 0xFFFF) * v144 + (((v145 ^ 0xFFFF) * v144) >> 16) + 1) >> 24);
              unint64_t v147 = *(void *)v146;
              LODWORD(v146) = *(unsigned __int16 *)(v146 + 8);
              unsigned int v148 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
              v149.i32[0] = (unsigned __int16)v148;
              v149.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v148), 0x10uLL).i32[1];
              v149.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
              uint32x4_t v150 = (uint32x4_t)vmulq_s32(v149, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v144)));
              v151.i32[0] = v147;
              v151.i32[1] = WORD1(v147);
              *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v151, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v147), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v150, v150, 0x10uLL), v136), 0x10uLL)));
              unsigned int v141 = v146
                   + (((unsigned __int16)~(_WORD)v144 * v145 + (((unsigned __int16)~(_WORD)v144 * v145) >> 16) + 1) >> 16);
            }
            *int v88 = bswap32(v141) >> 16;
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v135);
          --v137;
        }
        while (v137);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 5:
      uint64_t v152 = 2 * v89;
      do
      {
        int v153 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v154 = v82 + 16 * *(unsigned __int8 *)v94;
            unsigned int v155 = bswap32(*v88) >> 16;
            CMYK64_DAMplusDAM(v92, v88, *(void *)v154, *(unsigned __int16 *)(v154 + 8), v155, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v155, *(unsigned __int16 *)(v154 + 8) ^ 0xFFFF);
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v152);
          --v153;
        }
        while (v153);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 6:
      uint64_t v156 = 2 * v89;
      v157.i64[0] = 0x100000001;
      v157.i64[1] = 0x100000001;
      do
      {
        int v158 = v608;
        do
        {
          uint64_t v159 = *(unsigned __int8 *)v94;
          if (*(unsigned char *)v94)
          {
            unsigned int v160 = bswap32(*v88);
            if (HIWORD(v160) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v160) == 0xFFFF)
              {
                uint64_t v161 = (unint64_t *)(v82 + 16 * v159);
                unint64_t v162 = *v161;
                unsigned int v163 = *((unsigned __int16 *)v161 + 4);
                unint64_t v164 = HIDWORD(v162);
                unint64_t v165 = HIWORD(v162);
                LODWORD(v162) = bswap32(v162);
                v92->i16[0] = WORD1(v162);
                v92->i16[1] = v162;
                v92->i16[2] = bswap32(v164) >> 16;
                v92->i16[3] = __rev16(v165);
              }
              else
              {
                unsigned int v166 = HIWORD(v160);
                unsigned int v167 = ~HIWORD(v160);
                unint64_t v168 = (int32x2_t *)(v82 + 16 * v159);
                unsigned int v169 = (unsigned __int16)WORD2(*(unint64_t *)v168);
                unint64_t v170 = HIWORD(*(unint64_t *)v168);
                *(int32x2_t *)v171.i8 = *v168;
                unint64_t v172 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
                v171.i16[1] = 0;
                v171.i32[1] = vshr_n_u32((uint32x2_t)vdup_lane_s32(*v168, 0), 0x10uLL).i32[1];
                LODWORD(v168) = (unsigned __int16)v167 * v168[1].u16[0];
                v171.i64[1] = __PAIR64__(v170, v169);
                uint32x4_t v173 = (uint32x4_t)vmulq_s32(v171, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v167)));
                v174.i32[0] = v172;
                v174.i32[1] = WORD1(v172);
                *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v174, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v172), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v173, v173, 0x10uLL), v157), 0x10uLL)));
                unsigned int v163 = v166 + ((v168 + (v168 >> 16) + 1) >> 16);
              }
              *int v88 = bswap32(v163) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v156);
          --v158;
        }
        while (v158);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 7:
      if (v3)
      {
        uint64_t v175 = 2 * v89;
        do
        {
          int v176 = v608;
          do
          {
            int v177 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              unint64_t v178 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
              unsigned int v179 = bswap32(*v88) >> 16;
              if (v177 == 255)
              {
                unsigned int v180 = v92;
                unsigned int v181 = v88;
                int v182 = v84;
              }
              else
              {
                int v182 = (unsigned __int16)(~(v177 | ((_WORD)v177 << 8))
                                        + (((v177 | (v177 << 8)) * v84 + (((v177 | (v177 << 8)) * v84) >> 16) + 1) >> 16));
                unsigned int v180 = v92;
                unsigned int v181 = v88;
              }
              CMYK64_DAM(v180, v181, v178, v179, v182);
            }
            ++v94;
            ++v92;
            int v88 = (unsigned __int16 *)((char *)v88 + v175);
            --v176;
          }
          while (v176);
          v94 += v605;
          v92 += v607;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        int32x4_t v392 = vdupq_n_s32(v84 ^ 0xFFFF);
        v393.i64[0] = 0x100000001;
        v393.i64[1] = 0x100000001;
        do
        {
          int v394 = v608;
          do
          {
            int v395 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v395 == 255)
              {
                unsigned int v396 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v397.i32[0] = (unsigned __int16)v396;
                v397.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v396), 0x10uLL).i32[1];
                v397.i32[2] = bswap32(v92->u16[2]) >> 16;
                v397.i32[3] = bswap32(v92->u16[3]) >> 16;
                uint32x4_t v398 = (uint32x4_t)vmulq_s32(v397, v392);
                v397.i32[0] = v396;
                int32x4_t v399 = vsubq_s32(v397, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v398, v398, 0x10uLL), v393), 0x10uLL));
              }
              else
              {
                unsigned int v400 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                v401.i32[0] = (unsigned __int16)v400;
                v401.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v400), 0x10uLL).i32[1];
                v401.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                uint32x4_t v402 = (uint32x4_t)vmulq_s32(v401, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((v395 | (v395 << 8))- (((v395 | (v395 << 8)) * v84+ (((v395 | (v395 << 8)) * v84) >> 16)+ 1) >> 16))));
                v401.i32[0] = v400;
                int32x4_t v399 = vsubq_s32(v401, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v402, v402, 0x10uLL), v393), 0x10uLL));
              }
              *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32(v399));
            }
            ++v94;
            ++v92;
            --v394;
          }
          while (v394);
          v94 += v605;
          v92 += v607;
          --v10;
        }
        while (v10);
      }
      return;
    case 8:
      int v183 = 257 * v84;
      if (v3)
      {
        uint64_t v184 = 2 * v89;
        unsigned int v185 = (unsigned __int16)~(_WORD)v84;
        do
        {
          int v186 = v608;
          do
          {
            int v187 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              unint64_t v188 = ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16);
              unsigned int v189 = bswap32(*v88) >> 16;
              if (v187 == 255)
              {
                unsigned int v190 = v92;
                uint64_t v191 = v88;
                unsigned int v192 = v185;
              }
              else
              {
                unsigned int v192 = ~(v183 * v187 + ((v183 * v187) >> 16) + 1) >> 16;
                unsigned int v190 = v92;
                uint64_t v191 = v88;
              }
              CMYK64_DAM(v190, v191, v188, v189, v192);
            }
            ++v94;
            ++v92;
            int v88 = (unsigned __int16 *)((char *)v88 + v184);
            --v186;
          }
          while (v186);
          v94 += v605;
          v92 += v607;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        int32x4_t v403 = vdupq_n_s32(v84);
        v404.i64[0] = 0x100000001;
        v404.i64[1] = 0x100000001;
        do
        {
          int v405 = v608;
          do
          {
            int v406 = *(unsigned __int8 *)v94;
            if (*(unsigned char *)v94)
            {
              if (v406 == 255)
              {
                unsigned int v407 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                __int16 v408 = v407;
                __int16 v409 = 0;
                v412.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v407), 0x10uLL).i32[1];
                v412.i32[2] = bswap32(v92->u16[2]) >> 16;
                v412.i32[3] = bswap32(v92->u16[3]) >> 16;
                uint32x4_t v410 = (uint32x4_t)vmulq_s32(v412, v403);
                int32x4_t v411 = (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v410, v410, 0x10uLL), v404), 0x10uLL);
                v412.i32[0] = v407;
              }
              else
              {
                unsigned int v413 = bswap32(v92->u16[1] | (v92->u16[0] << 16));
                __int16 v414 = v413;
                __int16 v415 = 0;
                v412.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v413), 0x10uLL).i32[1];
                v412.i64[1] = __PAIR64__(bswap32(v92->u16[3]) >> 16, bswap32(v92->u16[2]) >> 16);
                uint32x4_t v416 = (uint32x4_t)vmulq_s32(v412, vdupq_n_s32((v183 * v406 + ((v183 * v406) >> 16) + 1) >> 16));
                int32x4_t v411 = (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v416, v416, 0x10uLL), v404), 0x10uLL);
                v412.i32[0] = v413;
              }
              *unint64_t v92 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v412, v411)));
            }
            ++v94;
            ++v92;
            --v405;
          }
          while (v405);
          v94 += v605;
          v92 += v607;
          --v10;
        }
        while (v10);
      }
      return;
    case 9:
      uint64_t v193 = 2 * v89;
      do
      {
        int v194 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            unsigned int v195 = bswap32(*v88) >> 16;
            uint64_t v196 = v82 + 16 * *(unsigned __int8 *)v94;
            CMYK64_DAMplusDAM(v92, v88, *(void *)v196, *(unsigned __int16 *)(v196 + 8), v195 ^ 0xFFFF, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v195, (unsigned __int16)(*(_WORD *)(v196 + 8) + ~(*(unsigned __int8 *)v94 | (*(unsigned __int8 *)v94 << 8))));
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v193);
          --v194;
        }
        while (v194);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 10:
      uint64_t v197 = 2 * v89;
      do
      {
        int v198 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            unsigned int v199 = bswap32(*v88) >> 16;
            uint64_t v200 = v82 + 16 * *(unsigned __int8 *)v94;
            CMYK64_DAMplusDAM(v92, v88, *(void *)v200, *(unsigned __int16 *)(v200 + 8), v199 ^ 0xFFFF, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v199, *(unsigned __int16 *)(v200 + 8) ^ 0xFFFF);
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v197);
          --v198;
        }
        while (v198);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        --v10;
      }
      while (v10);
      return;
    case 11:
      if (v3)
      {
        uint64_t v201 = 2 * v89;
        do
        {
          int v202 = v608;
          do
          {
            if (*(unsigned char *)v94) {
              CMYK64_DAplusdDA((int *)v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, *(void *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            int v88 = (unsigned __int16 *)((char *)v88 + v201);
            --v202;
          }
          while (v202);
          v94 += v605;
          v92 += v607;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v203 = v608;
          do
          {
            if (*(unsigned char *)v94) {
              CMYK64_DplusdDA(v92, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), *(void *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            --v203;
          }
          while (v203);
          v94 += v605;
          v92 += v607;
          --v10;
        }
        while (v10);
      }
      return;
    case 12:
      if (v3)
      {
        uint64_t v204 = 2 * v89;
        do
        {
          int v205 = v608;
          do
          {
            if (*(unsigned char *)v94) {
              CMYK64_DApluslDA((unsigned int *)v92, v88, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), bswap32(*v88) >> 16, *(void *)(v82 + 16 * *(unsigned __int8 *)v94), *(unsigned __int16 *)(v82 + 16 * *(unsigned __int8 *)v94 + 8));
            }
            ++v94;
            ++v92;
            int v88 = (unsigned __int16 *)((char *)v88 + v204);
            --v205;
          }
          while (v205);
          v94 += v605;
          v92 += v607;
          v88 += v91;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v206 = v608;
          do
          {
            if (*(unsigned char *)v94) {
              CMYK64_DpluslD(v92, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), *(void *)(v82 + 16 * *(unsigned __int8 *)v94));
            }
            ++v94;
            ++v92;
            --v206;
          }
          while (v206);
          v94 += v605;
          v92 += v607;
          --v10;
        }
        while (v10);
      }
      return;
    case 13:
      uint64_t v207 = 2 * v89;
      while (1)
      {
        int v208 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v209 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v210) = *(unsigned __int16 *)(v209 + 8);
            if (*(_WORD *)(v209 + 8))
            {
              unint64_t v211 = *(void *)v209;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v212 = __rev16(*v88);
                  goto LABEL_192;
                }
LABEL_194:
                unsigned int v216 = bswap32(v211);
                v92->i16[0] = HIWORD(v216);
                v92->i16[1] = v216;
                v92->i16[2] = bswap32(HIDWORD(v211)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v211));
                uint64_t v213 = v88;
              }
              else
              {
                unsigned int v212 = 0xFFFF;
LABEL_192:
                uint64_t v213 = (unsigned __int16 *)v92 + 3;
                unint64_t v214 = PDAmultiplyPDA_11710(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v212, v211, v210);
                unint64_t v211 = v214;
                if (v3)
                {
                  LODWORD(v210) = v215;
                  goto LABEL_194;
                }
                unint64_t v210 = HIWORD(v214);
                unsigned int v217 = bswap32(v214);
                v92->i16[0] = HIWORD(v217);
                v92->i16[1] = v217;
                v92->i16[2] = bswap32(HIDWORD(v214)) >> 16;
              }
              *uint64_t v213 = bswap32(v210) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v207);
          --v208;
        }
        while (v208);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 14:
      uint64_t v218 = 2 * v89;
      while (1)
      {
        int v219 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v220 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v221) = *(unsigned __int16 *)(v220 + 8);
            if (*(_WORD *)(v220 + 8))
            {
              unint64_t v222 = *(void *)v220;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v223 = __rev16(*v88);
                  goto LABEL_208;
                }
LABEL_210:
                unsigned int v227 = bswap32(v222);
                v92->i16[0] = HIWORD(v227);
                v92->i16[1] = v227;
                v92->i16[2] = bswap32(HIDWORD(v222)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v222));
                BOOL v224 = v88;
              }
              else
              {
                unsigned int v223 = 0xFFFF;
LABEL_208:
                BOOL v224 = (unsigned __int16 *)v92 + 3;
                unint64_t v225 = PDAscreenPDA_11711(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v223, v222, v221);
                unint64_t v222 = v225;
                if (v3)
                {
                  LODWORD(v221) = v226;
                  goto LABEL_210;
                }
                unint64_t v221 = HIWORD(v225);
                unsigned int v228 = bswap32(v225);
                v92->i16[0] = HIWORD(v228);
                v92->i16[1] = v228;
                v92->i16[2] = bswap32(HIDWORD(v225)) >> 16;
              }
              unsigned __int16 *v224 = bswap32(v221) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v218);
          --v219;
        }
        while (v219);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 15:
      uint64_t v229 = 2 * v89;
      while (1)
      {
        int v230 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v231 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v232) = *(unsigned __int16 *)(v231 + 8);
            if (*(_WORD *)(v231 + 8))
            {
              unint64_t v233 = *(void *)v231;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v234 = __rev16(*v88);
                  goto LABEL_224;
                }
LABEL_226:
                unsigned int v238 = bswap32(v233);
                v92->i16[0] = HIWORD(v238);
                v92->i16[1] = v238;
                v92->i16[2] = bswap32(HIDWORD(v233)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v233));
                int32x4_t v235 = v88;
              }
              else
              {
                unsigned int v234 = 0xFFFF;
LABEL_224:
                int32x4_t v235 = (unsigned __int16 *)v92 + 3;
                unint64_t v236 = PDAoverlayPDA_11712(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v234, v233, v232);
                unint64_t v233 = v236;
                if (v3)
                {
                  LODWORD(v232) = v237;
                  goto LABEL_226;
                }
                unint64_t v232 = HIWORD(v236);
                unsigned int v239 = bswap32(v236);
                v92->i16[0] = HIWORD(v239);
                v92->i16[1] = v239;
                v92->i16[2] = bswap32(HIDWORD(v236)) >> 16;
              }
              *int32x4_t v235 = bswap32(v232) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v229);
          --v230;
        }
        while (v230);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 16:
      uint64_t v240 = 2 * v89;
      while (1)
      {
        int v241 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v242 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v243) = *(unsigned __int16 *)(v242 + 8);
            if (*(_WORD *)(v242 + 8))
            {
              unint64_t v244 = *(void *)v242;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v245 = __rev16(*v88);
                  goto LABEL_240;
                }
LABEL_242:
                unsigned int v249 = bswap32(v244);
                v92->i16[0] = HIWORD(v249);
                v92->i16[1] = v249;
                v92->i16[2] = bswap32(HIDWORD(v244)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v244));
                unsigned int v246 = v88;
              }
              else
              {
                unsigned int v245 = 0xFFFF;
LABEL_240:
                unsigned int v246 = (unsigned __int16 *)v92 + 3;
                unint64_t v247 = PDAdarkenPDA_11714(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v245, v244, v243);
                unint64_t v244 = v247;
                if (v3)
                {
                  LODWORD(v243) = v248;
                  goto LABEL_242;
                }
                unint64_t v243 = HIWORD(v247);
                unsigned int v250 = bswap32(v247);
                v92->i16[0] = HIWORD(v250);
                v92->i16[1] = v250;
                v92->i16[2] = bswap32(HIDWORD(v247)) >> 16;
              }
              *unsigned int v246 = bswap32(v243) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v240);
          --v241;
        }
        while (v241);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 17:
      uint64_t v251 = 2 * v89;
      while (1)
      {
        int v252 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v253 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v254) = *(unsigned __int16 *)(v253 + 8);
            if (*(_WORD *)(v253 + 8))
            {
              unint64_t v255 = *(void *)v253;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v256 = __rev16(*v88);
                  goto LABEL_256;
                }
LABEL_258:
                unsigned int v260 = bswap32(v255);
                v92->i16[0] = HIWORD(v260);
                v92->i16[1] = v260;
                v92->i16[2] = bswap32(HIDWORD(v255)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v255));
                uint64_t v257 = v88;
              }
              else
              {
                unsigned int v256 = 0xFFFF;
LABEL_256:
                uint64_t v257 = (unsigned __int16 *)v92 + 3;
                unint64_t v258 = PDAlightenPDA_11713(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v256, v255, v254);
                unint64_t v255 = v258;
                if (v3)
                {
                  LODWORD(v254) = v259;
                  goto LABEL_258;
                }
                unint64_t v254 = HIWORD(v258);
                unsigned int v261 = bswap32(v258);
                v92->i16[0] = HIWORD(v261);
                v92->i16[1] = v261;
                v92->i16[2] = bswap32(HIDWORD(v258)) >> 16;
              }
              *uint64_t v257 = bswap32(v254) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v251);
          --v252;
        }
        while (v252);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 18:
      uint64_t v262 = 2 * v89;
      while (1)
      {
        int v263 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v264 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v265) = *(unsigned __int16 *)(v264 + 8);
            if (*(_WORD *)(v264 + 8))
            {
              unint64_t v266 = *(void *)v264;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v267 = __rev16(*v88);
                  goto LABEL_272;
                }
LABEL_274:
                unsigned int v271 = bswap32(v266);
                v92->i16[0] = HIWORD(v271);
                v92->i16[1] = v271;
                v92->i16[2] = bswap32(HIDWORD(v266)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v266));
                unsigned int v268 = v88;
              }
              else
              {
                unsigned int v267 = 0xFFFF;
LABEL_272:
                unsigned int v268 = (unsigned __int16 *)v92 + 3;
                unint64_t v269 = PDAcolordodgePDA_11715(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v267, v266, v265);
                unint64_t v266 = v269;
                if (v3)
                {
                  LODWORD(v265) = v270;
                  goto LABEL_274;
                }
                unint64_t v265 = HIWORD(v269);
                unsigned int v272 = bswap32(v269);
                v92->i16[0] = HIWORD(v272);
                v92->i16[1] = v272;
                v92->i16[2] = bswap32(HIDWORD(v269)) >> 16;
              }
              *unsigned int v268 = bswap32(v265) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v262);
          --v263;
        }
        while (v263);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 19:
      uint64_t v273 = 2 * v89;
      while (1)
      {
        int v274 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v275 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v276) = *(unsigned __int16 *)(v275 + 8);
            if (*(_WORD *)(v275 + 8))
            {
              unint64_t v277 = *(void *)v275;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v278 = __rev16(*v88);
                  goto LABEL_288;
                }
LABEL_290:
                unsigned int v282 = bswap32(v277);
                v92->i16[0] = HIWORD(v282);
                v92->i16[1] = v282;
                v92->i16[2] = bswap32(HIDWORD(v277)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v277));
                int v279 = v88;
              }
              else
              {
                unsigned int v278 = 0xFFFF;
LABEL_288:
                int v279 = (unsigned __int16 *)v92 + 3;
                unint64_t v280 = PDAcolorburnPDA_11716(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v278, v277, v276);
                unint64_t v277 = v280;
                if (v3)
                {
                  LODWORD(v276) = v281;
                  goto LABEL_290;
                }
                unint64_t v276 = HIWORD(v280);
                unsigned int v283 = bswap32(v280);
                v92->i16[0] = HIWORD(v283);
                v92->i16[1] = v283;
                v92->i16[2] = bswap32(HIDWORD(v280)) >> 16;
              }
              *int v279 = bswap32(v276) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v273);
          --v274;
        }
        while (v274);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 20:
      uint64_t v284 = 2 * v89;
      while (1)
      {
        int v285 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v286 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v287) = *(unsigned __int16 *)(v286 + 8);
            if (*(_WORD *)(v286 + 8))
            {
              unint64_t v288 = *(void *)v286;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v289 = __rev16(*v88);
                  goto LABEL_304;
                }
LABEL_306:
                unsigned int v293 = bswap32(v288);
                v92->i16[0] = HIWORD(v293);
                v92->i16[1] = v293;
                v92->i16[2] = bswap32(HIDWORD(v288)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v288));
                long long v290 = v88;
              }
              else
              {
                unsigned int v289 = 0xFFFF;
LABEL_304:
                long long v290 = (unsigned __int16 *)v92 + 3;
                unint64_t v291 = PDAsoftlightPDA_11718(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v289, v288, v287);
                unint64_t v288 = v291;
                if (v3)
                {
                  LODWORD(v287) = v292;
                  goto LABEL_306;
                }
                unint64_t v287 = HIWORD(v291);
                unsigned int v294 = bswap32(v291);
                v92->i16[0] = HIWORD(v294);
                v92->i16[1] = v294;
                v92->i16[2] = bswap32(HIDWORD(v291)) >> 16;
              }
              *long long v290 = bswap32(v287) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v284);
          --v285;
        }
        while (v285);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 21:
      uint64_t v295 = 2 * v89;
      while (1)
      {
        int v296 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v297 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v298) = *(unsigned __int16 *)(v297 + 8);
            if (*(_WORD *)(v297 + 8))
            {
              unint64_t v299 = *(void *)v297;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v300 = __rev16(*v88);
                  goto LABEL_320;
                }
LABEL_322:
                unsigned int v304 = bswap32(v299);
                v92->i16[0] = HIWORD(v304);
                v92->i16[1] = v304;
                v92->i16[2] = bswap32(HIDWORD(v299)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v299));
                unint64_t v301 = v88;
              }
              else
              {
                unsigned int v300 = 0xFFFF;
LABEL_320:
                unint64_t v301 = (unsigned __int16 *)v92 + 3;
                unint64_t v302 = PDAhardlightPDA_11717(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v300, v299, v298);
                unint64_t v299 = v302;
                if (v3)
                {
                  LODWORD(v298) = v303;
                  goto LABEL_322;
                }
                unint64_t v298 = HIWORD(v302);
                unsigned int v305 = bswap32(v302);
                v92->i16[0] = HIWORD(v305);
                v92->i16[1] = v305;
                v92->i16[2] = bswap32(HIDWORD(v302)) >> 16;
              }
              *unint64_t v301 = bswap32(v298) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v295);
          --v296;
        }
        while (v296);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 22:
      uint64_t v306 = 2 * v89;
      while (1)
      {
        int v307 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v308 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v309) = *(unsigned __int16 *)(v308 + 8);
            if (*(_WORD *)(v308 + 8))
            {
              unint64_t v310 = *(void *)v308;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v311 = __rev16(*v88);
                  goto LABEL_336;
                }
LABEL_338:
                unsigned int v315 = bswap32(v310);
                v92->i16[0] = HIWORD(v315);
                v92->i16[1] = v315;
                v92->i16[2] = bswap32(HIDWORD(v310)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v310));
                unint64_t v312 = v88;
              }
              else
              {
                unsigned int v311 = 0xFFFF;
LABEL_336:
                unint64_t v312 = (unsigned __int16 *)v92 + 3;
                unint64_t v313 = PDAdifferencePDA_11719(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v311, v310, v309);
                unint64_t v310 = v313;
                if (v3)
                {
                  LODWORD(v309) = v314;
                  goto LABEL_338;
                }
                unint64_t v309 = HIWORD(v313);
                unsigned int v316 = bswap32(v313);
                v92->i16[0] = HIWORD(v316);
                v92->i16[1] = v316;
                v92->i16[2] = bswap32(HIDWORD(v313)) >> 16;
              }
              *unint64_t v312 = bswap32(v309) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v306);
          --v307;
        }
        while (v307);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 23:
      uint64_t v317 = 2 * v89;
      while (1)
      {
        int v318 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v319 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v320) = *(unsigned __int16 *)(v319 + 8);
            if (*(_WORD *)(v319 + 8))
            {
              unint64_t v321 = *(void *)v319;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v322 = __rev16(*v88);
                  goto LABEL_352;
                }
LABEL_354:
                unsigned int v326 = bswap32(v321);
                v92->i16[0] = HIWORD(v326);
                v92->i16[1] = v326;
                v92->i16[2] = bswap32(HIDWORD(v321)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v321));
                uint64_t v323 = v88;
              }
              else
              {
                unsigned int v322 = 0xFFFF;
LABEL_352:
                uint64_t v323 = (unsigned __int16 *)v92 + 3;
                unint64_t v324 = PDAexclusionPDA_11720(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v322, v321, v320);
                unint64_t v321 = v324;
                if (v3)
                {
                  LODWORD(v320) = v325;
                  goto LABEL_354;
                }
                unint64_t v320 = HIWORD(v324);
                unsigned int v327 = bswap32(v324);
                v92->i16[0] = HIWORD(v327);
                v92->i16[1] = v327;
                v92->i16[2] = bswap32(HIDWORD(v324)) >> 16;
              }
              *uint64_t v323 = bswap32(v320) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v317);
          --v318;
        }
        while (v318);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 24:
      uint64_t v328 = 2 * v89;
      while (1)
      {
        int v329 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v330 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v331) = *(unsigned __int16 *)(v330 + 8);
            if (*(_WORD *)(v330 + 8))
            {
              unint64_t v332 = *(void *)v330;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v333 = __rev16(*v88);
                  goto LABEL_368;
                }
LABEL_370:
                unsigned int v337 = bswap32(v332);
                v92->i16[0] = HIWORD(v337);
                v92->i16[1] = v337;
                v92->i16[2] = bswap32(HIDWORD(v332)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v332));
                int v334 = v88;
              }
              else
              {
                unsigned int v333 = 0xFFFF;
LABEL_368:
                int v334 = (unsigned __int16 *)v92 + 3;
                unint64_t v335 = PDAhuePDA_11721(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v333, v332, v331);
                unint64_t v332 = v335;
                if (v3)
                {
                  LODWORD(v331) = v336;
                  goto LABEL_370;
                }
                unint64_t v331 = HIWORD(v335);
                unsigned int v338 = bswap32(v335);
                v92->i16[0] = HIWORD(v338);
                v92->i16[1] = v338;
                v92->i16[2] = bswap32(HIDWORD(v335)) >> 16;
              }
              *int v334 = bswap32(v331) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v328);
          --v329;
        }
        while (v329);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 25:
      uint64_t v339 = 2 * v89;
      while (1)
      {
        int v340 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v341 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v342) = *(unsigned __int16 *)(v341 + 8);
            if (*(_WORD *)(v341 + 8))
            {
              unint64_t v343 = *(void *)v341;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v344 = __rev16(*v88);
                  goto LABEL_384;
                }
LABEL_386:
                unsigned int v348 = bswap32(v343);
                v92->i16[0] = HIWORD(v348);
                v92->i16[1] = v348;
                v92->i16[2] = bswap32(HIDWORD(v343)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v343));
                uint64_t v345 = v88;
              }
              else
              {
                unsigned int v344 = 0xFFFF;
LABEL_384:
                uint64_t v345 = (unsigned __int16 *)v92 + 3;
                unint64_t v346 = PDAsaturationPDA_11722(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v344, v343, v342);
                unint64_t v343 = v346;
                if (v3)
                {
                  LODWORD(v342) = v347;
                  goto LABEL_386;
                }
                unint64_t v342 = HIWORD(v346);
                unsigned int v349 = bswap32(v346);
                v92->i16[0] = HIWORD(v349);
                v92->i16[1] = v349;
                v92->i16[2] = bswap32(HIDWORD(v346)) >> 16;
              }
              *uint64_t v345 = bswap32(v342) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v339);
          --v340;
        }
        while (v340);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 26:
      uint64_t v350 = 2 * v89;
      while (1)
      {
        int v351 = v608;
        do
        {
          if (*(unsigned char *)v94)
          {
            uint64_t v352 = v82 + 16 * *(unsigned __int8 *)v94;
            LODWORD(v353) = *(unsigned __int16 *)(v352 + 8);
            if (*(_WORD *)(v352 + 8))
            {
              unint64_t v354 = *(void *)v352;
              if (v3)
              {
                if (*v88)
                {
                  unsigned int v355 = __rev16(*v88);
                  goto LABEL_400;
                }
                goto LABEL_401;
              }
              unsigned int v355 = 0xFFFF;
LABEL_400:
              unsigned int v356 = (unsigned __int16 *)v92 + 3;
              unint64_t v354 = PDAluminosityPDA_11723(v354, v353, ((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v355);
              if (v3)
              {
LABEL_401:
                unsigned int v357 = bswap32(v354);
                v92->i16[0] = HIWORD(v357);
                v92->i16[1] = v357;
                v92->i16[2] = bswap32(HIDWORD(v354)) >> 16;
                v92->i16[3] = __rev16(HIWORD(v354));
                unsigned int v356 = v88;
              }
              else
              {
                unint64_t v353 = HIWORD(v354);
                unsigned int v358 = bswap32(v354);
                v92->i16[0] = HIWORD(v358);
                v92->i16[1] = v358;
                v92->i16[2] = bswap32(HIDWORD(v354)) >> 16;
              }
              *unsigned int v356 = bswap32(v353) >> 16;
            }
          }
          ++v94;
          ++v92;
          int v88 = (unsigned __int16 *)((char *)v88 + v350);
          --v351;
        }
        while (v351);
        v94 += v605;
        v92 += v607;
        v88 += v91;
        if (!--v10) {
          return;
        }
      }
    case 27:
      uint64_t v359 = 2 * v89;
      break;
    default:
      return;
  }
  do
  {
    int v360 = v608;
    do
    {
      if (*(unsigned char *)v94)
      {
        uint64_t v361 = v82 + 16 * *(unsigned __int8 *)v94;
        LODWORD(v362) = *(unsigned __int16 *)(v361 + 8);
        if (*(_WORD *)(v361 + 8))
        {
          unint64_t v363 = *(void *)v361;
          if (v3)
          {
            if (*v88)
            {
              unsigned int v364 = __rev16(*v88);
              goto LABEL_415;
            }
LABEL_417:
            unsigned int v368 = bswap32(v363);
            v92->i16[0] = HIWORD(v368);
            v92->i16[1] = v368;
            v92->i16[2] = bswap32(HIDWORD(v363)) >> 16;
            v92->i16[3] = __rev16(HIWORD(v363));
            uint64_t v365 = v88;
          }
          else
          {
            unsigned int v364 = 0xFFFF;
LABEL_415:
            uint64_t v365 = (unsigned __int16 *)v92 + 3;
            unint64_t v366 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v92->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v92->u16[3]) >> 16) << 48) | bswap32(v92->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v92->u16[0]) >> 16), v364, v363, v362);
            unint64_t v363 = v366;
            if (v3)
            {
              LODWORD(v362) = v367;
              goto LABEL_417;
            }
            unint64_t v362 = HIWORD(v366);
            unsigned int v369 = bswap32(v366);
            v92->i16[0] = HIWORD(v369);
            v92->i16[1] = v369;
            v92->i16[2] = bswap32(HIDWORD(v366)) >> 16;
          }
          *uint64_t v365 = bswap32(v362) >> 16;
        }
      }
      ++v94;
      ++v92;
      int v88 = (unsigned __int16 *)((char *)v88 + v359);
      --v360;
    }
    while (v360);
    v94 += v605;
    v92 += v607;
    v88 += v91;
    --v10;
  }
  while (v10);
}

void CMYK64_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v5 = *(int *)(a1 + 12);
  uint64_t v4 = *(int *)(a1 + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(a1 + 32) >> 1;
    unint64_t v7 = (unsigned __int16 *)(v2 + 2 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return;
    }
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return;
    }
  }
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  unint64_t v12 = *(void *)(a1 + 88);
  unint64_t v11 = *(_WORD **)(a1 + 96);
  unint64_t v13 = (unint64_t)*(int *)(a1 + 28) >> 3;
  int v14 = (int8x8_t *)(*(void *)(a1 + 40) + 8 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(a1 + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(a1 + 56);
  uint64_t v18 = *(int *)(a1 + 60);
  unint64_t v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) != 0x100)
  {
    int v21 = *(_DWORD *)(a1 + 64);
    int v22 = *(_DWORD *)(a1 + 68);
    uint64_t v879 = v19 >> 3;
    if (v11)
    {
      unint64_t v877 = (unint64_t)*(int *)(a1 + 80) >> 1;
      int v20 = 1;
    }
    else
    {
      unint64_t v877 = 0;
      int v20 = 0;
    }
    unint64_t v26 = v12 + 8 * v879 * v22;
    v8 &= 1u;
    int v25 = 1;
    int v881 = (unsigned __int16 *)v12;
    int32x4_t v23 = (char *)v12;
    goto LABEL_19;
  }
  uint64_t v879 = v19 >> 3;
  if (v11)
  {
    unint64_t v877 = (unint64_t)*(int *)(a1 + 80) >> 1;
    v11 += v17 + v877 * v18;
    int v20 = -1;
  }
  else
  {
    unint64_t v877 = 0;
    int v20 = 0;
  }
  int32x4_t v23 = (char *)(v12 + 8 * (v17 + v879 * v18));
  if (v879 == v13 && (char *)v14 - v23 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - v23) >> 3))
    {
      v14 += v9 - 1;
      v23 += 8 * v9 - 8;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      int v25 = -1;
      uint64_t v879 = (unint64_t)*(int *)(a1 + 28) >> 3;
      v11 += v20 & (v9 - 1);
      goto LABEL_16;
    }
    uint64_t v24 = v10 - 1;
    if (v14 <= (int8x8_t *)&v23[8 * v13 * v24 - 8 + 8 * v9])
    {
      v14 += v13 * v24;
      v16 += v15 * v24;
      uint64_t v15 = -v15;
      v7 += v6 * v24;
      unint64_t v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v877 * v24;
      unint64_t v877 = -(uint64_t)v877;
      v20 &= 1u;
      int v25 = 1;
      v23 += 8 * v13 * v24;
      uint64_t v879 = -(uint64_t)v13;
      unint64_t v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  int v25 = 1;
LABEL_16:
  unint64_t v26 = 0;
  int v881 = 0;
  unint64_t v12 = -1;
  int v22 = v877;
  int v21 = v879;
LABEL_19:
  int v27 = v25 * v9;
  int v878 = v9;
  unint64_t v874 = v26;
  int v882 = v10;
  if (v26)
  {
    uint64_t v28 = (int)v18 % v22;
    int32x4_t v29 = (unsigned __int16 *)&v23[8 * v879 * v28];
    uint64_t v30 = (int)v17 % v21;
    int32x4_t v23 = (char *)&v29[4 * v30];
    unint64_t v12 = (unint64_t)&v29[4 * v21];
    if (v20) {
      v11 += v877 * v28 + v30;
    }
    int v880 = v11;
    int v881 = &v29[4 * v30];
  }
  else
  {
    v879 -= v27;
    int v880 = v11;
    v877 -= v20 * v9;
  }
  uint64_t v876 = v15 - v27;
  unint64_t v875 = v13 - v27;
  unint64_t v873 = v6 - v8 * v9;
  int v923 = v20;
  int v883 = v8;
  switch(a2)
  {
    case 0:
      uint64_t v31 = v25;
      if (v8)
      {
        uint64_t v32 = 2 * v8;
        do
        {
          int v33 = v878;
          int v34 = v882;
          do
          {
            int v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *int v14 = 0;
                *unint64_t v7 = 0;
              }
              else
              {
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, (v35 | (v35 << 8)) ^ 0xFFFF);
              }
            }
            v16 += v31;
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v32);
            v14 += v31;
            --v33;
          }
          while (v33);
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v34 != 1);
      }
      else
      {
        v643.i64[0] = 0x100000001;
        v643.i64[1] = 0x100000001;
        do
        {
          int v644 = v9;
          int v645 = v882;
          do
          {
            int v646 = *v16;
            if (*v16)
            {
              if (v646 == 255)
              {
                *int v14 = 0;
              }
              else
              {
                unsigned int v647 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v648.i32[0] = (unsigned __int16)v647;
                v648.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v647), 0x10uLL).i32[1];
                v648.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                uint32x4_t v649 = (uint32x4_t)vmulq_s32(v648, vdupq_n_s32(v646 | (v646 << 8)));
                v648.i32[0] = v647;
                *int v14 = vrev16_s8((int8x8_t)vmovn_s32(vsubq_s32(v648, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v649, v649, 0x10uLL), v643), 0x10uLL))));
              }
            }
            v16 += v31;
            v14 += v31;
            --v644;
          }
          while (v644);
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v645 != 1);
      }
      return;
    case 1:
      if (v8)
      {
        uint64_t v36 = v25;
        if (v20)
        {
          uint64_t v37 = v20;
          uint64_t v38 = -(uint64_t)v21;
          uint64_t v884 = -(v879 * v22);
          uint64_t v848 = -(uint64_t)(v877 * v22);
          uint64_t v39 = 2 * v8;
          uint64_t v40 = 8 * v36;
          int8x16_t v41 = v880;
          uint64_t v896 = v36;
          do
          {
            int v42 = v878;
            do
            {
              int v43 = *v16;
              if (*v16)
              {
                if (v43 == 255)
                {
                  *int v14 = *(int8x8_t *)v23;
                  *unint64_t v7 = *v41;
                }
                else
                {
                  int v44 = v43 | (v43 << 8);
                  uint64_t v45 = v39;
                  uint64_t v46 = v40;
                  uint64_t v924 = v41;
                  CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), bswap32((unsigned __int16)*v41) >> 16, v44, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v44 ^ 0xFFFF);
                  uint64_t v40 = v46;
                  uint64_t v39 = v45;
                  uint64_t v36 = v896;
                  int8x16_t v41 = v924;
                }
              }
              v16 += v36;
              uint64_t v47 = (unsigned __int16 *)&v23[8 * v36];
              if ((unint64_t)v47 >= v12) {
                uint64_t v48 = v38;
              }
              else {
                uint64_t v48 = 0;
              }
              v41 += v37 + v48;
              int32x4_t v23 = (char *)&v47[4 * v48];
              unint64_t v7 = (unsigned __int16 *)((char *)v7 + v39);
              int v14 = (int8x8_t *)((char *)v14 + v40);
              --v42;
            }
            while (v42);
            if (v874)
            {
              int32x4_t v49 = (char *)&v881[4 * v879];
              uint64_t v50 = v848;
              if ((unint64_t)v49 < v874) {
                uint64_t v50 = 0;
              }
              uint64_t v51 = (uint64_t)&v880[v877 + v50];
              uint64_t v52 = v884;
              if ((unint64_t)v49 < v874) {
                uint64_t v52 = 0;
              }
              int32x4_t v23 = &v49[8 * v52];
              v12 += 8 * v52 + 8 * v879;
              v880 += v877 + v50;
              int v881 = (unsigned __int16 *)v23;
              int8x16_t v41 = (_WORD *)v51;
            }
            else
            {
              v23 += 8 * v879;
              v41 += v877;
            }
            v16 += v876;
            v14 += v875;
            v7 += v873;
            --v882;
          }
          while (v882);
        }
        else
        {
          uint64_t v784 = -(uint64_t)v21;
          uint64_t v931 = -(v879 * v22);
          uint64_t v785 = 2 * v8;
          do
          {
            int v786 = v878;
            do
            {
              int v787 = *v16;
              if (*v16)
              {
                if (v787 == 255)
                {
                  *int v14 = *(int8x8_t *)v23;
                  *unint64_t v7 = -1;
                }
                else
                {
                  int v788 = v787 | (v787 << 8);
                  CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), 0xFFFF, v788, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, v788 ^ 0xFFFF);
                }
              }
              v16 += v36;
              unsigned int v789 = (unsigned __int16 *)&v23[8 * v36];
              if ((unint64_t)v789 >= v12) {
                uint64_t v790 = v784;
              }
              else {
                uint64_t v790 = 0;
              }
              int32x4_t v23 = (char *)&v789[4 * v790];
              unint64_t v7 = (unsigned __int16 *)((char *)v7 + v785);
              v14 += v36;
              --v786;
            }
            while (v786);
            v16 += v876;
            v14 += v875;
            v7 += v873;
            unsigned int v791 = v881;
            unsigned int v792 = (char *)&v881[4 * v879];
            uint64_t v793 = v931;
            if ((unint64_t)v792 < v874) {
              uint64_t v793 = 0;
            }
            uint64_t v794 = &v792[8 * v793];
            uint64_t v795 = v12 + 8 * v793 + 8 * v879;
            if (v874)
            {
              unint64_t v12 = v795;
              unsigned int v791 = (unsigned __int16 *)v794;
              int32x4_t v23 = v794;
            }
            else
            {
              v23 += 8 * v879;
            }
            BOOL v796 = v882 == 1;
            int v881 = v791;
            --v882;
          }
          while (!v796);
        }
      }
      else
      {
        uint64_t v650 = -(uint64_t)v21;
        uint64_t v651 = -(v879 * v22);
        do
        {
          int v652 = v9;
          int v653 = v882;
          do
          {
            int v654 = *v16;
            if (*v16)
            {
              if (v654 == 255)
              {
                *int v14 = *(int8x8_t *)v23;
              }
              else
              {
                unsigned int v655 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
                unsigned int v656 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v657.i32[0] = v654 | (v654 << 8);
                v657.i32[1] = ~v657.i32[0];
                *(int8x8_t *)v658.i8 = vand_s8(v657, (int8x8_t)0xFFFF0000FFFFLL);
                v659.i64[0] = v658.i64[0];
                v659.i64[1] = v658.i64[0];
                v660.i32[0] = (unsigned __int16)v656;
                v660.i32[1] = HIWORD(v655);
                v660.i64[1] = __PAIR64__(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16, bswap32(v14->u16[2]) >> 16);
                v658.i64[1] = v658.i64[0];
                int32x4_t v661 = vmulq_s32(v660, vrev64q_s32(v658));
                v660.i32[0] = (unsigned __int16)v655;
                v660.i32[1] = HIWORD(v656);
                v660.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(*((unsigned __int16 *)v23 + 2)) >> 16);
                int8x16_t v662 = (int8x16_t)vmlaq_s32(v661, v660, v659);
                *int v14 = vrev16_s8((int8x8_t)vsubhn_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v662, 0x10uLL), (int32x4_t)vmvnq_s8(v662)));
              }
            }
            v16 += v25;
            uint64_t v663 = (unsigned __int16 *)&v23[8 * v25];
            if ((unint64_t)v663 >= v12) {
              uint64_t v664 = v650;
            }
            else {
              uint64_t v664 = 0;
            }
            int32x4_t v23 = (char *)&v663[4 * v664];
            v14 += v25;
            --v652;
          }
          while (v652);
          v16 += v876;
          v14 += v875;
          unint64_t v665 = v881;
          uint64_t v666 = (char *)&v881[4 * v879];
          if ((unint64_t)v666 >= v874) {
            uint64_t v667 = v651;
          }
          else {
            uint64_t v667 = 0;
          }
          uint64_t v668 = &v666[8 * v667];
          uint64_t v669 = v12 + 8 * v667 + 8 * v879;
          if (v874)
          {
            unint64_t v12 = v669;
            unint64_t v665 = (unsigned __int16 *)v668;
            int32x4_t v23 = v668;
          }
          else
          {
            v23 += 8 * v879;
          }
          int v881 = v665;
          --v882;
        }
        while (v653 != 1);
      }
      return;
    case 2:
      uint64_t v53 = v25;
      uint64_t v54 = v22;
      if (v8)
      {
        uint64_t v55 = -(v879 * v22);
        uint64_t v56 = -(uint64_t)(v877 * v54);
        uint64_t v57 = 2 * v8;
        uint64_t v58 = -(uint64_t)v21;
        v59.i64[0] = 0x100000001;
        v59.i64[1] = 0x100000001;
        unint64_t v60 = v880;
        while (1)
        {
          int v61 = v878;
          int v62 = v882;
          do
          {
            int v63 = *v16;
            if (!*v16) {
              goto LABEL_71;
            }
            if (v63 != 255)
            {
              unsigned int v66 = bswap32(*v60) >> 16;
              int v67 = (v63 | (v63 << 8)) ^ 0xFFFF;
              unsigned int v65 = v66 - ((v67 * v66 + ((v67 * v66) >> 16) + 1) >> 16);
              if (v66 == (v67 * v66 + ((v67 * v66) >> 16) + 1) >> 16) {
                goto LABEL_71;
              }
              unsigned int v68 = bswap32(*((unsigned __int16 *)v23 + 2));
              unsigned int v69 = bswap32(*((unsigned __int16 *)v23 + 3));
              unint64_t v70 = ((unint64_t)(HIWORD(v69)
                                      - ((v67 * HIWORD(v69) + ((v67 * HIWORD(v69)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIWORD(v68) - ((v67 * HIWORD(v68) + ((v67 * HIWORD(v68)) >> 16) + 1) >> 16)) << 32);
              unsigned int v71 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unint64_t v72 = v70 | ((HIWORD(v71) - ((HIWORD(v71) * v67 + ((HIWORD(v71) * v67) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v71 - (((unsigned __int16)v71 * v67 + (((unsigned __int16)v71 * v67) >> 16) + 1) >> 16));
              goto LABEL_69;
            }
            unsigned int v64 = *v60;
            unsigned int v65 = __rev16(v64);
            if (!v65) {
              goto LABEL_71;
            }
            if (v65 != 0xFFFF)
            {
              unint64_t v72 = ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16);
LABEL_69:
              unsigned int v73 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              unsigned int v74 = bswap32(*v7);
              v75.i32[0] = (unsigned __int16)v73;
              v75.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v73), 0x10uLL).i32[1];
              v75.i32[2] = bswap32(v14->u16[2]) >> 16;
              v75.i32[3] = bswap32(v14->u16[3]) >> 16;
              uint32x4_t v76 = (uint32x4_t)vmulq_s32(v75, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v65)));
              v77.i32[0] = v72;
              v77.i32[1] = WORD1(v72);
              *int v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v77, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v72), (uint64x2_t)xmmword_1850CDC40)), (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v76, v76, 0x10uLL), v59), 0x10uLL)));
              unsigned int v64 = bswap32(v65+ (((unsigned __int16)~(_WORD)v65 * HIWORD(v74)+ (((unsigned __int16)~(_WORD)v65 * HIWORD(v74)) >> 16)+ 1) >> 16)) >> 16;
              goto LABEL_70;
            }
            *int v14 = *(int8x8_t *)v23;
LABEL_70:
            *unint64_t v7 = v64;
LABEL_71:
            v16 += v25;
            int8x16_t v78 = (unsigned __int16 *)&v23[8 * v25];
            int8x16_t v79 = &v60[v20];
            if ((unint64_t)v78 >= v12) {
              uint64_t v80 = v58;
            }
            else {
              uint64_t v80 = 0;
            }
            unint64_t v60 = &v79[v80];
            int32x4_t v23 = (char *)&v78[4 * v80];
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v57);
            v14 += v25;
            --v61;
          }
          while (v61);
          if (v874)
          {
            int16x8_t v81 = (char *)&v881[4 * v879];
            if ((unint64_t)v81 >= v874) {
              uint64_t v82 = v56;
            }
            else {
              uint64_t v82 = 0;
            }
            uint64_t v83 = (uint64_t)&v880[v877 + v82];
            if ((unint64_t)v81 >= v874) {
              uint64_t v84 = v55;
            }
            else {
              uint64_t v84 = 0;
            }
            int32x4_t v23 = &v81[8 * v84];
            v12 += 8 * v84 + 8 * v879;
            v880 += v877 + v82;
            int v881 = (unsigned __int16 *)v23;
            unint64_t v60 = (unsigned __int16 *)v83;
          }
          else
          {
            v23 += 8 * v879;
            v60 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
          if (v62 == 1) {
            return;
          }
        }
      }
      uint64_t v670 = -(v879 * v22);
      uint64_t v671 = -(uint64_t)(v877 * v54);
      v672.i64[0] = 0x100000001;
      v672.i64[1] = 0x100000001;
      uint64_t v673 = v880;
      uint64_t v674 = -(uint64_t)v21;
LABEL_759:
      int v675 = v878;
      int v676 = v882;
      unsigned int v677 = v880;
      while (1)
      {
        int v678 = *v16;
        if (*v16)
        {
          if (v678 == 255)
          {
            unsigned int v679 = bswap32(*v673) >> 16;
            if (v679)
            {
              if (v679 != 0xFFFF)
              {
                unint64_t v693 = ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16);
                unsigned int v694 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v695.i32[0] = (unsigned __int16)v694;
                v695.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v694), 0x10uLL).i32[1];
                int64x2_t v689 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v693), (uint64x2_t)xmmword_1850CDC40);
                v695.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                uint32x4_t v696 = (uint32x4_t)vmulq_s32(v695, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v679)));
                int32x4_t v691 = (int32x4_t)vsraq_n_u32(v696, v696, 0x10uLL);
                v692.i32[0] = v693;
                v692.i32[1] = WORD1(v693);
                goto LABEL_768;
              }
              *int v14 = *(int8x8_t *)v23;
            }
          }
          else
          {
            unsigned int v680 = bswap32(*v673) >> 16;
            int v681 = (v678 | (v678 << 8)) ^ 0xFFFF;
            unsigned int v682 = v681 * v680 + ((v681 * v680) >> 16) + 1;
            if (v680 != HIWORD(v682))
            {
              unsigned int v683 = bswap32(*((unsigned __int16 *)v23 + 2));
              unsigned int v684 = bswap32(*((unsigned __int16 *)v23 + 3));
              unint64_t v685 = ((unint64_t)(HIWORD(v684)
                                       - ((v681 * HIWORD(v684) + ((v681 * HIWORD(v684)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIWORD(v683) - ((v681 * HIWORD(v683) + ((v681 * HIWORD(v683)) >> 16) + 1) >> 16)) << 32);
              unsigned int v686 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unint64_t v687 = v685 | ((HIWORD(v686)
                            - ((HIWORD(v686) * v681 + ((HIWORD(v686) * v681) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v686 - (((unsigned __int16)v686 * v681 + (((unsigned __int16)v686 * v681) >> 16) + 1) >> 16));
              LODWORD(v685) = bswap32(v14->u16[1] | (v14->u16[0] << 16));
              v688.i32[0] = (unsigned __int16)v685;
              v688.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v685), 0x10uLL).i32[1];
              int64x2_t v689 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v687), (uint64x2_t)xmmword_1850CDC40);
              v688.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
              uint32x4_t v690 = (uint32x4_t)vmulq_s32(v688, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(~v680 + HIWORD(v682))));
              int32x4_t v691 = (int32x4_t)vsraq_n_u32(v690, v690, 0x10uLL);
              v692.i32[0] = v687;
              v692.i32[1] = WORD1(v687);
LABEL_768:
              *int v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(v692, v689), (uint32x4_t)vaddq_s32(v691, v672), 0x10uLL)));
            }
          }
        }
        v16 += v53;
        int v697 = (unsigned __int16 *)&v23[8 * v53];
        uint64_t v698 = &v673[v20];
        if ((unint64_t)v697 >= v12) {
          uint64_t v699 = v674;
        }
        else {
          uint64_t v699 = 0;
        }
        uint64_t v673 = &v698[v699];
        int32x4_t v23 = (char *)&v697[4 * v699];
        v14 += v53;
        if (!--v675)
        {
          if (v874)
          {
            uint64_t v700 = (char *)&v881[4 * v879];
            if ((unint64_t)v700 >= v874) {
              uint64_t v701 = v671;
            }
            else {
              uint64_t v701 = 0;
            }
            if ((unint64_t)v700 >= v874) {
              uint64_t v702 = v670;
            }
            else {
              uint64_t v702 = 0;
            }
            int32x4_t v23 = &v700[8 * v702];
            v12 += 8 * v702 + 8 * v879;
            v880 += v877 + v701;
            int v881 = (unsigned __int16 *)v23;
            uint64_t v673 = &v677[v877 + v701];
          }
          else
          {
            v23 += 8 * v879;
            v673 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
          if (v676 == 1) {
            return;
          }
          goto LABEL_759;
        }
      }
    case 3:
      uint64_t v85 = v25;
      uint64_t v897 = v20;
      uint64_t v849 = -(v879 * v22);
      uint64_t v828 = -(uint64_t)(v877 * v22);
      uint64_t v885 = 2 * v8;
      uint64_t v86 = 8 * v25;
      unint64_t v87 = v880;
      uint64_t v88 = -(uint64_t)v21;
      do
      {
        int v89 = v878;
        unint64_t v90 = v12;
        do
        {
          int v91 = *v16;
          if (*v16)
          {
            if (v91 == 255)
            {
              if (v20) {
                unsigned int v92 = bswap32(*v87) >> 16;
              }
              else {
                unsigned int v92 = 0xFFFF;
              }
              CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v92, bswap32(*v7) >> 16);
            }
            else
            {
              if (v20) {
                unsigned int v93 = bswap32(*v87) >> 16;
              }
              else {
                unsigned int v93 = 0xFFFF;
              }
              int v94 = v91 | (v91 << 8);
              unsigned int v95 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v93, (v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v95, v94 ^ 0xFFFF);
            }
            unint64_t v12 = v90;
            int v20 = v923;
          }
          v16 += v85;
          int v96 = (unsigned __int16 *)&v23[8 * v85];
          if ((unint64_t)v96 >= v12) {
            uint64_t v97 = v88;
          }
          else {
            uint64_t v97 = 0;
          }
          v87 += v897 + v97;
          int32x4_t v23 = (char *)&v96[4 * v97];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v885);
          int v14 = (int8x8_t *)((char *)v14 + v86);
          --v89;
        }
        while (v89);
        if (v874)
        {
          unsigned int v98 = (char *)&v881[4 * v879];
          uint64_t v99 = v828;
          if ((unint64_t)v98 < v874) {
            uint64_t v99 = 0;
          }
          unint64_t v87 = &v880[v877 + v99];
          uint64_t v100 = v849;
          if ((unint64_t)v98 < v874) {
            uint64_t v100 = 0;
          }
          int32x4_t v23 = &v98[8 * v100];
          v12 += 8 * v100 + 8 * v879;
          v880 += v877 + v99;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v87 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 4:
      uint64_t v101 = v25;
      uint64_t v898 = v20;
      uint64_t v850 = -(v879 * v22);
      uint64_t v829 = -(uint64_t)(v877 * v22);
      uint64_t v886 = 2 * v8;
      uint64_t v102 = 8 * v25;
      uint64_t v103 = v880;
      uint64_t v104 = -(uint64_t)v21;
      do
      {
        int v105 = v878;
        unint64_t v106 = v12;
        do
        {
          int v107 = *v16;
          if (*v16)
          {
            if (v107 == 255)
            {
              if (v20) {
                unsigned int v108 = bswap32(*v103) >> 16;
              }
              else {
                unsigned int v108 = 0xFFFF;
              }
              CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v108, bswap32(~*v7) >> 16);
            }
            else
            {
              if (v20) {
                unsigned int v109 = bswap32(*v103) >> 16;
              }
              else {
                unsigned int v109 = 0xFFFF;
              }
              int v110 = v107 | (v107 << 8);
              unsigned int v111 = bswap32(*v7) >> 16;
              CMYK64_DAMplusDAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v109, ((v111 ^ 0xFFFF) * v110 + (((v111 ^ 0xFFFF) * v110) >> 16) + 1) >> 16, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v111, v110 ^ 0xFFFF);
            }
            unint64_t v12 = v106;
            int v20 = v923;
          }
          v16 += v101;
          unint64_t v112 = (unsigned __int16 *)&v23[8 * v101];
          if ((unint64_t)v112 >= v12) {
            uint64_t v113 = v104;
          }
          else {
            uint64_t v113 = 0;
          }
          v103 += v898 + v113;
          int32x4_t v23 = (char *)&v112[4 * v113];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v886);
          int v14 = (int8x8_t *)((char *)v14 + v102);
          --v105;
        }
        while (v105);
        if (v874)
        {
          int v114 = (char *)&v881[4 * v879];
          uint64_t v115 = v829;
          if ((unint64_t)v114 < v874) {
            uint64_t v115 = 0;
          }
          uint64_t v103 = &v880[v877 + v115];
          uint64_t v116 = v850;
          if ((unint64_t)v114 < v874) {
            uint64_t v116 = 0;
          }
          int32x4_t v23 = &v114[8 * v116];
          v12 += 8 * v116 + 8 * v879;
          v880 += v877 + v115;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v103 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 5:
      uint64_t v117 = v25;
      uint64_t v899 = -(uint64_t)v21;
      uint64_t v925 = v20;
      uint64_t v887 = -(v879 * v22);
      uint64_t v851 = -(uint64_t)(v877 * v22);
      uint64_t v118 = 2 * v8;
      uint64_t v119 = 8 * v25;
      int v120 = v880;
      do
      {
        int v121 = v878;
        do
        {
          if (*v16)
          {
            unsigned int v122 = bswap32(*v120);
            unsigned int v123 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
            unsigned int v124 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            unsigned int v125 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            int v126 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unint64_t v127 = ((unint64_t)(v123 - ((v126 * v123 + ((v126 * v123) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v124 - ((v126 * v124 + ((v126 * v124) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v125) - ((HIWORD(v125) * v126 + ((HIWORD(v125) * v126) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v125 - (((unsigned __int16)v125 * v126 + (((unsigned __int16)v125 * v126) >> 16) + 1) >> 16));
            unsigned int v128 = HIWORD(v122) - ((v126 * HIWORD(v122) + ((v126 * HIWORD(v122)) >> 16) + 1) >> 16);
            unsigned int v129 = bswap32(*v7) >> 16;
            CMYK64_DAMplusDAM(v14, v7, v127, (unsigned __int16)v128, v129, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v129, (unsigned __int16)~(_WORD)v128);
          }
          v16 += v117;
          unint64_t v130 = (unsigned __int16 *)&v23[8 * v117];
          uint64_t v131 = v899;
          if ((unint64_t)v130 < v12) {
            uint64_t v131 = 0;
          }
          v120 += v925 + v131;
          int32x4_t v23 = (char *)&v130[4 * v131];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v118);
          int v14 = (int8x8_t *)((char *)v14 + v119);
          --v121;
        }
        while (v121);
        if (v874)
        {
          int32x4_t v132 = (char *)&v881[4 * v879];
          uint64_t v133 = v851;
          if ((unint64_t)v132 < v874) {
            uint64_t v133 = 0;
          }
          int v120 = &v880[v877 + v133];
          uint64_t v134 = v887;
          if ((unint64_t)v132 < v874) {
            uint64_t v134 = 0;
          }
          int32x4_t v23 = &v132[8 * v134];
          v12 += 8 * v134 + 8 * v879;
          v880 += v877 + v133;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v120 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 6:
      uint64_t v135 = v25;
      uint64_t v136 = v20;
      int v137 = v880;
      uint64_t v830 = -(v879 * v22);
      uint64_t v812 = -(uint64_t)(v877 * v22);
      uint64_t v138 = 2 * v8;
      uint64_t v139 = 8 * v25;
      uint64_t v140 = -(uint64_t)v21;
      uint64_t v888 = v20;
      do
      {
        int v141 = v878;
        unint64_t v900 = v12;
        do
        {
          int v142 = *v16;
          if (*v16)
          {
            unsigned int v143 = bswap32(*v7);
            if (HIWORD(v143) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v143) == 0xFFFF)
              {
                if (v20) {
                  unsigned int v144 = bswap32(*v137) >> 16;
                }
                else {
                  unsigned int v144 = 0xFFFF;
                }
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 2)) >> 16) << 32) | ((unint64_t)(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16) << 48) | bswap32(*((unsigned __int16 *)v23 + 1)) & 0xFFFF0000 | (unint64_t)(bswap32(*(unsigned __int16 *)v23) >> 16), v144, v142 | (v142 << 8));
                unint64_t v12 = v900;
                int v20 = v923;
                uint64_t v136 = v888;
              }
              else
              {
                if (v20) {
                  unsigned int v145 = bswap32(*v137) >> 16;
                }
                else {
                  unsigned int v145 = 0xFFFF;
                }
                unint64_t v146 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
                unsigned int v147 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
                unsigned int v148 = (257 * v142 * (unsigned __int16)~HIWORD(v143)
                      + ((257 * v142 * (unsigned __int16)~HIWORD(v143)) >> 16)
                      + 1) >> 16;
                v149.i32[0] = (unsigned __int16)v147;
                v149.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v147), 0x10uLL).i32[1];
                v149.i64[1] = __PAIR64__(bswap32(*((unsigned __int16 *)v23 + 3)) >> 16, bswap32(*((unsigned __int16 *)v23 + 2)) >> 16);
                uint32x4_t v150 = (uint32x4_t)vmulq_s32(v149, vdupq_n_s32(v148));
                v151.i64[0] = 0x100000001;
                v151.i64[1] = 0x100000001;
                uint32x4_t v152 = (uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v150, v150, 0x10uLL), v151);
                v151.i32[0] = v146;
                v151.i32[1] = WORD1(v146);
                *int v14 = vrev16_s8((int8x8_t)vmovn_s32((int32x4_t)vsraq_n_u32((uint32x4_t)vmovn_hight_s64(*(int32x2_t *)v151.i8, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v146), (uint64x2_t)xmmword_1850CDC40)), v152, 0x10uLL)));
                *unint64_t v7 = bswap32(HIWORD(v143) + ((v148 * v145 + ((v148 * v145) >> 16) + 1) >> 16)) >> 16;
              }
            }
          }
          v16 += v135;
          int v153 = (unsigned __int16 *)&v23[8 * v135];
          if ((unint64_t)v153 >= v12) {
            uint64_t v154 = v140;
          }
          else {
            uint64_t v154 = 0;
          }
          v137 += v136 + v154;
          int32x4_t v23 = (char *)&v153[4 * v154];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v138);
          int v14 = (int8x8_t *)((char *)v14 + v139);
          --v141;
        }
        while (v141);
        if (v874)
        {
          unsigned int v155 = (char *)&v881[4 * v879];
          uint64_t v156 = v812;
          if ((unint64_t)v155 < v874) {
            uint64_t v156 = 0;
          }
          int v137 = &v880[v877 + v156];
          uint64_t v157 = v830;
          if ((unint64_t)v155 < v874) {
            uint64_t v157 = 0;
          }
          int32x4_t v23 = &v155[8 * v157];
          v12 += 8 * v157 + 8 * v879;
          v880 += v877 + v156;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v137 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 7:
      uint64_t v158 = v25;
      if (v8)
      {
        uint64_t v926 = v20;
        uint64_t v889 = -(v879 * v22);
        uint64_t v852 = -(uint64_t)(v877 * v22);
        uint64_t v901 = 2 * v8;
        uint64_t v159 = v880;
        uint64_t v160 = -(uint64_t)v21;
        do
        {
          int v161 = v878;
          unint64_t v162 = v12;
          do
          {
            int v163 = *v16;
            if (*v16)
            {
              if (v163 == 255)
              {
                CMYK64_DAM(v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, bswap32(*v159) >> 16);
              }
              else
              {
                unsigned int v164 = bswap32(*v159);
                unint64_t v165 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
                unsigned int v166 = bswap32(*v7) >> 16;
                CMYK64_DAMplusDAM(v14, v7, v165, v166, (HIWORD(v164) * (v163 | (v163 << 8)) + ((HIWORD(v164) * (v163 | (v163 << 8))) >> 16) + 1) >> 16, v165, v166, (v163 | (v163 << 8)) ^ 0xFFFF);
              }
              unint64_t v12 = v162;
            }
            v16 += v158;
            unsigned int v167 = (unsigned __int16 *)&v23[8 * v158];
            if ((unint64_t)v167 >= v12) {
              uint64_t v168 = v160;
            }
            else {
              uint64_t v168 = 0;
            }
            v159 += v926 + v168;
            int32x4_t v23 = (char *)&v167[4 * v168];
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v901);
            v14 += v158;
            --v161;
          }
          while (v161);
          if (v874)
          {
            unsigned int v169 = (char *)&v881[4 * v879];
            uint64_t v170 = v852;
            if ((unint64_t)v169 < v874) {
              uint64_t v170 = 0;
            }
            uint64_t v159 = &v880[v877 + v170];
            uint64_t v171 = v889;
            if ((unint64_t)v169 < v874) {
              uint64_t v171 = 0;
            }
            int32x4_t v23 = &v169[8 * v171];
            v12 += 8 * v171 + 8 * v879;
            v880 += v877 + v170;
            int v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v159 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        uint64_t v703 = -(uint64_t)v21;
        uint64_t v704 = v22;
        uint64_t v705 = v880;
        uint64_t v706 = -(v879 * v22);
        uint64_t v707 = -(uint64_t)(v877 * v704);
        v708.i64[0] = 0x100000001;
        v708.i64[1] = 0x100000001;
        do
        {
          int v709 = v878;
          int v710 = v882;
          do
          {
            int v711 = *v16;
            if (*v16)
            {
              if (v711 == 255)
              {
                unsigned int v712 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v713.i32[0] = (unsigned __int16)v712;
                v713.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v712), 0x10uLL).i32[1];
                v713.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                uint32x4_t v714 = (uint32x4_t)vmulq_s32(v713, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(bswap32(~*v705) >> 16)));
                v713.i32[0] = v712;
                int32x4_t v715 = vsubq_s32(v713, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v714, v714, 0x10uLL), v708), 0x10uLL));
              }
              else
              {
                int v716 = v711 | (v711 << 8);
                unsigned int v717 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                unsigned int v718 = bswap32(*v705);
                v719.i32[0] = (unsigned __int16)v717;
                v719.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v717), 0x10uLL).i32[1];
                v720.i32[0] = (HIWORD(v718) * v716 + ((HIWORD(v718) * v716) >> 16) + 1) >> 16;
                v720.i32[1] = ~v716;
                *(int8x8_t *)v721.i8 = vand_s8(v720, (int8x8_t)0xFFFF0000FFFFLL);
                v722.i64[0] = v721.i64[0];
                v722.i64[1] = v721.i64[0];
                v719.i32[2] = bswap32(v14->u16[2]) >> 16;
                v719.i32[3] = bswap32(v14->u16[3]) >> 16;
                v721.i64[1] = v721.i64[0];
                int8x16_t v723 = (int8x16_t)vmulq_s32(v719, vaddq_s32(v722, vrev64q_s32(v721)));
                int32x4_t v715 = (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v723, 0x10uLL), (int32x4_t)vmvnq_s8(v723)), 0x10uLL);
              }
              *int v14 = vrev16_s8((int8x8_t)vmovn_s32(v715));
            }
            v16 += v158;
            unsigned int v724 = (unsigned __int16 *)&v23[8 * v158];
            unsigned int v725 = &v705[v20];
            if ((unint64_t)v724 >= v12) {
              uint64_t v726 = v703;
            }
            else {
              uint64_t v726 = 0;
            }
            uint64_t v705 = &v725[v726];
            int32x4_t v23 = (char *)&v724[4 * v726];
            v14 += v158;
            --v709;
          }
          while (v709);
          if (v874)
          {
            unsigned int v727 = (char *)&v881[4 * v879];
            if ((unint64_t)v727 >= v874) {
              uint64_t v728 = v707;
            }
            else {
              uint64_t v728 = 0;
            }
            uint64_t v729 = (uint64_t)&v880[v877 + v728];
            if ((unint64_t)v727 >= v874) {
              uint64_t v730 = v706;
            }
            else {
              uint64_t v730 = 0;
            }
            int32x4_t v23 = &v727[8 * v730];
            v12 += 8 * v730 + 8 * v879;
            v880 += v877 + v728;
            int v881 = (unsigned __int16 *)v23;
            uint64_t v705 = (unsigned __int16 *)v729;
          }
          else
          {
            v23 += 8 * v879;
            v705 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v710 != 1);
      }
      return;
    case 8:
      uint64_t v172 = v25;
      if (v8)
      {
        uint64_t v927 = v20;
        uint64_t v890 = -(v879 * v22);
        uint64_t v853 = -(uint64_t)(v877 * v22);
        uint64_t v902 = 2 * v8;
        uint32x4_t v173 = v880;
        uint64_t v174 = -(uint64_t)v21;
        do
        {
          int v175 = v878;
          unint64_t v176 = v12;
          do
          {
            int v177 = *v16;
            if (*v16)
            {
              unint64_t v178 = ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16);
              unsigned int v179 = bswap32(*v7) >> 16;
              if (v177 == 255)
              {
                unsigned int v180 = bswap32(~*v173);
              }
              else
              {
                unsigned int v181 = bswap32(*v173) >> 16;
                unsigned int v180 = ~(257 * v177 * v181 + ((257 * v177 * v181) >> 16) + 1);
              }
              CMYK64_DAM(v14, v7, v178, v179, HIWORD(v180));
              unint64_t v12 = v176;
            }
            v16 += v172;
            int v182 = (unsigned __int16 *)&v23[8 * v172];
            if ((unint64_t)v182 >= v12) {
              uint64_t v183 = v174;
            }
            else {
              uint64_t v183 = 0;
            }
            v173 += v927 + v183;
            int32x4_t v23 = (char *)&v182[4 * v183];
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v902);
            v14 += v172;
            --v175;
          }
          while (v175);
          if (v874)
          {
            uint64_t v184 = (char *)&v881[4 * v879];
            uint64_t v185 = v853;
            if ((unint64_t)v184 < v874) {
              uint64_t v185 = 0;
            }
            uint32x4_t v173 = &v880[v877 + v185];
            uint64_t v186 = v890;
            if ((unint64_t)v184 < v874) {
              uint64_t v186 = 0;
            }
            int32x4_t v23 = &v184[8 * v186];
            v12 += 8 * v186 + 8 * v879;
            v880 += v877 + v185;
            int v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v173 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        uint64_t v731 = -(uint64_t)v21;
        uint64_t v732 = v22;
        unsigned int v733 = v880;
        uint64_t v734 = -(v879 * v22);
        uint64_t v735 = -(uint64_t)(v877 * v732);
        v736.i64[0] = 0x100000001;
        v736.i64[1] = 0x100000001;
        do
        {
          int v737 = v878;
          int v738 = v882;
          do
          {
            int v739 = *v16;
            if (*v16)
            {
              if (v739 == 255)
              {
                unsigned int v740 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                v741.i32[0] = (unsigned __int16)v740;
                v741.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v740), 0x10uLL).i32[1];
                v741.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                uint32x4_t v742 = (uint32x4_t)vmulq_s32(v741, (int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(bswap32(*v733) >> 16)));
                v741.i32[0] = v740;
                int32x4_t v743 = vsubq_s32(v741, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v742, v742, 0x10uLL), v736), 0x10uLL));
              }
              else
              {
                unsigned int v744 = bswap32(v14->u16[1] | (v14->u16[0] << 16));
                unsigned int v745 = bswap32(*v733) >> 16;
                v746.i32[0] = (unsigned __int16)v744;
                v746.i32[1] = vshr_n_u32((uint32x2_t)vdup_n_s32(v744), 0x10uLL).i32[1];
                v746.i64[1] = __PAIR64__(bswap32(v14->u16[3]) >> 16, bswap32(v14->u16[2]) >> 16);
                uint32x4_t v747 = (uint32x4_t)vmulq_s32(v746, vdupq_n_s32((257 * v739 * v745 + ((257 * v739 * v745) >> 16) + 1) >> 16));
                v746.i32[0] = v744;
                int32x4_t v743 = vsubq_s32(v746, (int32x4_t)vshrq_n_u32((uint32x4_t)vaddq_s32((int32x4_t)vsraq_n_u32(v747, v747, 0x10uLL), v736), 0x10uLL));
              }
              *int v14 = vrev16_s8((int8x8_t)vmovn_s32(v743));
            }
            v16 += v172;
            int v748 = (unsigned __int16 *)&v23[8 * v172];
            int v749 = &v733[v20];
            if ((unint64_t)v748 >= v12) {
              uint64_t v750 = v731;
            }
            else {
              uint64_t v750 = 0;
            }
            unsigned int v733 = &v749[v750];
            int32x4_t v23 = (char *)&v748[4 * v750];
            v14 += v172;
            --v737;
          }
          while (v737);
          if (v874)
          {
            int v751 = (char *)&v881[4 * v879];
            if ((unint64_t)v751 >= v874) {
              uint64_t v752 = v735;
            }
            else {
              uint64_t v752 = 0;
            }
            uint64_t v753 = (uint64_t)&v880[v877 + v752];
            if ((unint64_t)v751 >= v874) {
              uint64_t v754 = v734;
            }
            else {
              uint64_t v754 = 0;
            }
            int32x4_t v23 = &v751[8 * v754];
            v12 += 8 * v754 + 8 * v879;
            v880 += v877 + v752;
            int v881 = (unsigned __int16 *)v23;
            unsigned int v733 = (unsigned __int16 *)v753;
          }
          else
          {
            v23 += 8 * v879;
            v733 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v738 != 1);
      }
      return;
    case 9:
      uint64_t v187 = v25;
      uint64_t v903 = -(uint64_t)v21;
      uint64_t v928 = v20;
      uint64_t v891 = -(v879 * v22);
      uint64_t v854 = -(uint64_t)(v877 * v22);
      uint64_t v188 = 2 * v8;
      uint64_t v189 = 8 * v25;
      unsigned int v190 = v880;
      do
      {
        int v191 = v878;
        do
        {
          if (*v16)
          {
            unsigned int v192 = bswap32(*v7) >> 16;
            unsigned int v193 = bswap32(*v190);
            unsigned int v194 = bswap32(*((unsigned __int16 *)v23 + 3));
            unsigned int v195 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            unsigned int v196 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            unsigned __int16 v197 = ~(*v16 | (*v16 << 8));
            int v198 = v197;
            unint64_t v199 = ((unint64_t)(HIWORD(v194)
                                     - ((HIWORD(v194) * v198 + ((HIWORD(v194) * v198) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v195 - ((v195 * v198 + ((v195 * v198) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v196) - ((HIWORD(v196) * v198 + ((HIWORD(v196) * v198) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v196 - (((unsigned __int16)v196 * v198 + (((unsigned __int16)v196 * v198) >> 16) + 1) >> 16));
            unsigned int v200 = HIWORD(v193) - ((HIWORD(v193) * v198 + ((HIWORD(v193) * v198) >> 16) + 1) >> 16);
            CMYK64_DAMplusDAM(v14, v7, v199, (unsigned __int16)v200, v192 ^ 0xFFFF, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v192, (unsigned __int16)(v200 + v197));
          }
          v16 += v187;
          uint64_t v201 = (unsigned __int16 *)&v23[8 * v187];
          uint64_t v202 = v903;
          if ((unint64_t)v201 < v12) {
            uint64_t v202 = 0;
          }
          v190 += v928 + v202;
          int32x4_t v23 = (char *)&v201[4 * v202];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v188);
          int v14 = (int8x8_t *)((char *)v14 + v189);
          --v191;
        }
        while (v191);
        if (v874)
        {
          int v203 = (char *)&v881[4 * v879];
          uint64_t v204 = v854;
          if ((unint64_t)v203 < v874) {
            uint64_t v204 = 0;
          }
          unsigned int v190 = &v880[v877 + v204];
          uint64_t v205 = v891;
          if ((unint64_t)v203 < v874) {
            uint64_t v205 = 0;
          }
          int32x4_t v23 = &v203[8 * v205];
          v12 += 8 * v205 + 8 * v879;
          v880 += v877 + v204;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v190 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 10:
      uint64_t v206 = v25;
      uint64_t v904 = -(uint64_t)v21;
      uint64_t v929 = v20;
      uint64_t v892 = -(v879 * v22);
      uint64_t v855 = -(uint64_t)(v877 * v22);
      uint64_t v207 = 2 * v8;
      uint64_t v208 = 8 * v25;
      uint64_t v209 = v880;
      do
      {
        int v210 = v878;
        do
        {
          if (*v16)
          {
            unsigned int v211 = bswap32(*v7) >> 16;
            unsigned int v212 = bswap32(*v209);
            unsigned int v213 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
            unsigned int v214 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
            unsigned int v215 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
            int v216 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unint64_t v217 = ((unint64_t)(v213 - ((v216 * v213 + ((v216 * v213) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v214 - ((v216 * v214 + ((v216 * v214) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v215) - ((HIWORD(v215) * v216 + ((HIWORD(v215) * v216) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v215 - (((unsigned __int16)v215 * v216 + (((unsigned __int16)v215 * v216) >> 16) + 1) >> 16));
            unsigned int v218 = HIWORD(v212) - ((v216 * HIWORD(v212) + ((v216 * HIWORD(v212)) >> 16) + 1) >> 16);
            CMYK64_DAMplusDAM(v14, v7, v217, (unsigned __int16)v218, v211 ^ 0xFFFF, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v211, (unsigned __int16)~(_WORD)v218);
          }
          v16 += v206;
          int v219 = (unsigned __int16 *)&v23[8 * v206];
          uint64_t v220 = v904;
          if ((unint64_t)v219 < v12) {
            uint64_t v220 = 0;
          }
          v209 += v929 + v220;
          int32x4_t v23 = (char *)&v219[4 * v220];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v207);
          int v14 = (int8x8_t *)((char *)v14 + v208);
          --v210;
        }
        while (v210);
        if (v874)
        {
          unint64_t v221 = (char *)&v881[4 * v879];
          uint64_t v222 = v855;
          if ((unint64_t)v221 < v874) {
            uint64_t v222 = 0;
          }
          uint64_t v209 = &v880[v877 + v222];
          uint64_t v223 = v892;
          if ((unint64_t)v221 < v874) {
            uint64_t v223 = 0;
          }
          int32x4_t v23 = &v221[8 * v223];
          v12 += 8 * v223 + 8 * v879;
          v880 += v877 + v222;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v209 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        --v882;
      }
      while (v882);
      return;
    case 11:
      uint64_t v224 = v25;
      if (v8)
      {
        uint64_t v905 = v20;
        uint64_t v856 = -(v879 * v22);
        uint64_t v831 = -(uint64_t)(v877 * v22);
        uint64_t v893 = 2 * v8;
        unint64_t v225 = v880;
        uint64_t v226 = -(uint64_t)v21;
        do
        {
          int v227 = v878;
          unint64_t v228 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v229 = bswap32(*v225) >> 16;
              }
              else {
                unsigned int v229 = 0xFFFF;
              }
              unsigned int v230 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v231 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v232 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              int v233 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DAplusdDA((int *)v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((unint64_t)(v230 - ((v233 * v230 + ((v233 * v230) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v231 - ((v233 * v231 + ((v233 * v231) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v232) - ((HIWORD(v232) * v233 + ((HIWORD(v232) * v233) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v232 - (((unsigned __int16)v232 * v233 + (((unsigned __int16)v232 * v233) >> 16) + 1) >> 16)), (unsigned __int16)(v229 - ((v229 * v233 + ((v229 * v233) >> 16) + 1) >> 16)));
              unint64_t v12 = v228;
              int v20 = v923;
            }
            v16 += v224;
            unsigned int v234 = (unsigned __int16 *)&v23[8 * v224];
            if ((unint64_t)v234 >= v12) {
              uint64_t v235 = v226;
            }
            else {
              uint64_t v235 = 0;
            }
            v225 += v905 + v235;
            int32x4_t v23 = (char *)&v234[4 * v235];
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v893);
            v14 += v224;
            --v227;
          }
          while (v227);
          if (v874)
          {
            unint64_t v236 = (char *)&v881[4 * v879];
            uint64_t v237 = v831;
            if ((unint64_t)v236 < v874) {
              uint64_t v237 = 0;
            }
            unint64_t v225 = &v880[v877 + v237];
            uint64_t v238 = v856;
            if ((unint64_t)v236 < v874) {
              uint64_t v238 = 0;
            }
            int32x4_t v23 = &v236[8 * v238];
            v12 += 8 * v238 + 8 * v879;
            v880 += v877 + v237;
            int v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v225 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        uint64_t v755 = v20;
        uint64_t v756 = -(uint64_t)v21;
        uint64_t v922 = -(v879 * v22);
        uint64_t v895 = -(uint64_t)(v877 * v22);
        uint64_t v757 = v880;
        do
        {
          int v758 = v878;
          unint64_t v759 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v760 = bswap32(*v757) >> 16;
              }
              else {
                unsigned int v760 = 0xFFFF;
              }
              unsigned int v761 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v762 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v763 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              int v764 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DplusdDA(v14, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), ((unint64_t)(v761 - ((v764 * v761 + ((v764 * v761) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v762 - ((v764 * v762 + ((v764 * v762) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v763) - ((HIWORD(v763) * v764 + ((HIWORD(v763) * v764) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v763 - (((unsigned __int16)v763 * v764 + (((unsigned __int16)v763 * v764) >> 16) + 1) >> 16)), (unsigned __int16)(v760 - ((v760 * v764 + ((v760 * v764) >> 16) + 1) >> 16)));
              unint64_t v12 = v759;
              int v20 = v923;
            }
            v16 += v224;
            uint64_t v765 = (unsigned __int16 *)&v23[8 * v224];
            if ((unint64_t)v765 >= v12) {
              uint64_t v766 = v756;
            }
            else {
              uint64_t v766 = 0;
            }
            v757 += v755 + v766;
            int32x4_t v23 = (char *)&v765[4 * v766];
            v14 += v224;
            --v758;
          }
          while (v758);
          if (v874)
          {
            uint64_t v767 = (char *)&v881[4 * v879];
            uint64_t v768 = v895;
            if ((unint64_t)v767 < v874) {
              uint64_t v768 = 0;
            }
            uint64_t v757 = &v880[v877 + v768];
            uint64_t v769 = v922;
            if ((unint64_t)v767 < v874) {
              uint64_t v769 = 0;
            }
            int32x4_t v23 = &v767[8 * v769];
            v12 += 8 * v769 + 8 * v879;
            v880 += v877 + v768;
            int v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v757 += v877;
          }
          v16 += v876;
          v14 += v875;
          --v882;
        }
        while (v882);
      }
      return;
    case 12:
      uint64_t v239 = v25;
      if (v8)
      {
        uint64_t v906 = v20;
        uint64_t v857 = -(v879 * v22);
        uint64_t v832 = -(uint64_t)(v877 * v22);
        uint64_t v894 = 2 * v8;
        uint64_t v240 = v880;
        uint64_t v241 = -(uint64_t)v21;
        do
        {
          int v242 = v878;
          unint64_t v243 = v12;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v244 = bswap32(*v240) >> 16;
              }
              else {
                unsigned int v244 = 0xFFFF;
              }
              unsigned int v245 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v246 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v247 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              int v248 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DApluslDA((unsigned int *)v14, v7, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), bswap32(*v7) >> 16, ((unint64_t)(v245 - ((v248 * v245 + ((v248 * v245) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v246 - ((v248 * v246 + ((v248 * v246) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v247) - ((HIWORD(v247) * v248 + ((HIWORD(v247) * v248) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v247 - (((unsigned __int16)v247 * v248 + (((unsigned __int16)v247 * v248) >> 16) + 1) >> 16)), (unsigned __int16)(v244 - ((v244 * v248 + ((v244 * v248) >> 16) + 1) >> 16)));
              unint64_t v12 = v243;
              int v20 = v923;
            }
            v16 += v239;
            unsigned int v249 = (unsigned __int16 *)&v23[8 * v239];
            if ((unint64_t)v249 >= v12) {
              uint64_t v250 = v241;
            }
            else {
              uint64_t v250 = 0;
            }
            v240 += v906 + v250;
            int32x4_t v23 = (char *)&v249[4 * v250];
            unint64_t v7 = (unsigned __int16 *)((char *)v7 + v894);
            v14 += v239;
            --v242;
          }
          while (v242);
          if (v874)
          {
            uint64_t v251 = (char *)&v881[4 * v879];
            uint64_t v252 = v832;
            if ((unint64_t)v251 < v874) {
              uint64_t v252 = 0;
            }
            uint64_t v240 = &v880[v877 + v252];
            uint64_t v253 = v857;
            if ((unint64_t)v251 < v874) {
              uint64_t v253 = 0;
            }
            int32x4_t v23 = &v251[8 * v253];
            v12 += 8 * v253 + 8 * v879;
            v880 += v877 + v252;
            int v881 = (unsigned __int16 *)v23;
          }
          else
          {
            v23 += 8 * v879;
            v240 += v877;
          }
          v16 += v876;
          v14 += v875;
          v7 += v873;
          --v882;
        }
        while (v882);
      }
      else
      {
        uint64_t v770 = -(uint64_t)v21;
        uint64_t v930 = -(v879 * v22);
        do
        {
          int v771 = v878;
          int v772 = v882;
          do
          {
            if (*v16)
            {
              unsigned int v773 = bswap32(*((unsigned __int16 *)v23 + 3));
              unsigned int v774 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v775 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              int v776 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              CMYK64_DpluslD(v14, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), ((unint64_t)(HIWORD(v773)- ((v776 * HIWORD(v773) + ((v776 * HIWORD(v773)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v774 - ((v776 * v774 + ((v776 * v774) >> 16) + 1) >> 16)) << 32) | ((HIWORD(v775) - ((HIWORD(v775) * v776 + ((HIWORD(v775) * v776) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v775 - (((unsigned __int16)v775 * v776 + (((unsigned __int16)v775 * v776) >> 16) + 1) >> 16)));
            }
            v16 += v239;
            uint64_t v777 = (unsigned __int16 *)&v23[8 * v239];
            if ((unint64_t)v777 >= v12) {
              uint64_t v778 = v770;
            }
            else {
              uint64_t v778 = 0;
            }
            int32x4_t v23 = (char *)&v777[4 * v778];
            v14 += v239;
            --v771;
          }
          while (v771);
          v16 += v876;
          v14 += v875;
          uint64_t v779 = v881;
          uint64_t v780 = (char *)&v881[4 * v879];
          uint64_t v781 = v930;
          if ((unint64_t)v780 < v874) {
            uint64_t v781 = 0;
          }
          uint64_t v782 = &v780[8 * v781];
          uint64_t v783 = v12 + 8 * v781 + 8 * v879;
          if (v874)
          {
            unint64_t v12 = v783;
            uint64_t v779 = (unsigned __int16 *)v782;
            int32x4_t v23 = v782;
          }
          else
          {
            v23 += 8 * v879;
          }
          int v881 = v779;
          --v882;
        }
        while (v772 != 1);
      }
      return;
    case 13:
      uint64_t v254 = v25;
      uint64_t v255 = v20;
      unsigned int v256 = v880;
      uint64_t v813 = -(v879 * v22);
      uint64_t v797 = -(uint64_t)(v877 * v22);
      uint64_t v257 = 2 * v8;
      uint64_t v258 = 8 * v25;
      uint64_t v259 = -(uint64_t)v21;
      uint64_t v833 = v257;
      uint64_t v858 = v20;
      while (1)
      {
        int v260 = v878;
        unint64_t v907 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v261 = v20 ? bswap32(*v256) >> 16 : 0xFFFF;
            int v262 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v263 = v261 - ((v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16);
            LODWORD(v264) = (unsigned __int16)(v261 - ((v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16));
            if ((_WORD)v261 != (v261 * v262 + ((v261 * v262) >> 16) + 1) >> 16)
            {
              unsigned int v265 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v266 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v267 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v268 = HIWORD(v267);
              unint64_t v269 = ((unint64_t)(v265 - ((v262 * v265 + ((v262 * v265) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v266 - ((v262 * v266 + ((v262 * v266) >> 16) + 1) >> 16)) << 32) | ((v268 - ((v268 * v262 + ((v268 * v262) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v267 - (((unsigned __int16)v267 * v262 + (((unsigned __int16)v267 * v262) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v270 = __rev16(*v7);
                  goto LABEL_307;
                }
LABEL_309:
                unsigned int v273 = bswap32(v269);
                v14->i16[0] = HIWORD(v273);
                v14->i16[1] = v273;
                v14->i16[2] = bswap32(HIDWORD(v269)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v269));
                unsigned int v271 = v7;
              }
              else
              {
                unsigned int v270 = 0xFFFF;
LABEL_307:
                unsigned int v271 = (_WORD *)v14 + 3;
                unint64_t v272 = PDAmultiplyPDA_11710(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v270, v269, (unsigned __int16)v263);
                unint64_t v269 = v272;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v907;
                  int v20 = v923;
                  uint64_t v257 = v833;
                  uint64_t v255 = v858;
                  goto LABEL_309;
                }
                unint64_t v264 = HIWORD(v272);
                unsigned int v274 = bswap32(v272);
                v14->i16[0] = HIWORD(v274);
                v14->i16[1] = v274;
                v14->i16[2] = bswap32(HIDWORD(v272)) >> 16;
                unint64_t v12 = v907;
                int v20 = v923;
                uint64_t v257 = v833;
                uint64_t v255 = v858;
              }
              *unsigned int v271 = bswap32(v264) >> 16;
            }
          }
          v16 += v254;
          int v14 = (int8x8_t *)((char *)v14 + v258);
          uint64_t v275 = (unsigned __int16 *)&v23[8 * v254];
          if ((unint64_t)v275 >= v12) {
            uint64_t v276 = v259;
          }
          else {
            uint64_t v276 = 0;
          }
          v256 += v255 + v276;
          int32x4_t v23 = (char *)&v275[4 * v276];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v257);
          --v260;
        }
        while (v260);
        if (v874)
        {
          unint64_t v277 = (char *)&v881[4 * v879];
          uint64_t v278 = v797;
          if ((unint64_t)v277 < v874) {
            uint64_t v278 = 0;
          }
          unsigned int v256 = &v880[v877 + v278];
          uint64_t v279 = v813;
          if ((unint64_t)v277 < v874) {
            uint64_t v279 = 0;
          }
          int32x4_t v23 = &v277[8 * v279];
          v12 += 8 * v279 + 8 * v879;
          v880 += v877 + v278;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v256 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 14:
      uint64_t v280 = v25;
      uint64_t v281 = v20;
      unsigned int v282 = v880;
      uint64_t v814 = -(v879 * v22);
      uint64_t v798 = -(uint64_t)(v877 * v22);
      uint64_t v283 = 2 * v8;
      uint64_t v284 = 8 * v25;
      uint64_t v285 = -(uint64_t)v21;
      uint64_t v834 = v283;
      uint64_t v859 = v20;
      while (1)
      {
        int v286 = v878;
        unint64_t v908 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v287 = v20 ? bswap32(*v282) >> 16 : 0xFFFF;
            int v288 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v289 = v287 - ((v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16);
            LODWORD(v290) = (unsigned __int16)(v287 - ((v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16));
            if ((_WORD)v287 != (v287 * v288 + ((v287 * v288) >> 16) + 1) >> 16)
            {
              unsigned int v291 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v292 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v293 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v294 = HIWORD(v293);
              unint64_t v295 = ((unint64_t)(v291 - ((v288 * v291 + ((v288 * v291) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v292 - ((v288 * v292 + ((v288 * v292) >> 16) + 1) >> 16)) << 32) | ((v294 - ((v294 * v288 + ((v294 * v288) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v293 - (((unsigned __int16)v293 * v288 + (((unsigned __int16)v293 * v288) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v296 = __rev16(*v7);
                  goto LABEL_336;
                }
LABEL_338:
                unsigned int v299 = bswap32(v295);
                v14->i16[0] = HIWORD(v299);
                v14->i16[1] = v299;
                v14->i16[2] = bswap32(HIDWORD(v295)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v295));
                uint64_t v297 = v7;
              }
              else
              {
                unsigned int v296 = 0xFFFF;
LABEL_336:
                uint64_t v297 = (_WORD *)v14 + 3;
                unint64_t v298 = PDAscreenPDA_11711(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v296, v295, (unsigned __int16)v289);
                unint64_t v295 = v298;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v908;
                  int v20 = v923;
                  uint64_t v283 = v834;
                  uint64_t v281 = v859;
                  goto LABEL_338;
                }
                unint64_t v290 = HIWORD(v298);
                unsigned int v300 = bswap32(v298);
                v14->i16[0] = HIWORD(v300);
                v14->i16[1] = v300;
                v14->i16[2] = bswap32(HIDWORD(v298)) >> 16;
                unint64_t v12 = v908;
                int v20 = v923;
                uint64_t v283 = v834;
                uint64_t v281 = v859;
              }
              *uint64_t v297 = bswap32(v290) >> 16;
            }
          }
          v16 += v280;
          int v14 = (int8x8_t *)((char *)v14 + v284);
          unint64_t v301 = (unsigned __int16 *)&v23[8 * v280];
          if ((unint64_t)v301 >= v12) {
            uint64_t v302 = v285;
          }
          else {
            uint64_t v302 = 0;
          }
          v282 += v281 + v302;
          int32x4_t v23 = (char *)&v301[4 * v302];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v283);
          --v286;
        }
        while (v286);
        if (v874)
        {
          int v303 = (char *)&v881[4 * v879];
          uint64_t v304 = v798;
          if ((unint64_t)v303 < v874) {
            uint64_t v304 = 0;
          }
          unsigned int v282 = &v880[v877 + v304];
          uint64_t v305 = v814;
          if ((unint64_t)v303 < v874) {
            uint64_t v305 = 0;
          }
          int32x4_t v23 = &v303[8 * v305];
          v12 += 8 * v305 + 8 * v879;
          v880 += v877 + v304;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v282 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 15:
      uint64_t v306 = v25;
      uint64_t v307 = v20;
      uint64_t v308 = v880;
      uint64_t v815 = -(v879 * v22);
      uint64_t v799 = -(uint64_t)(v877 * v22);
      uint64_t v309 = 2 * v8;
      uint64_t v310 = 8 * v25;
      uint64_t v311 = -(uint64_t)v21;
      uint64_t v835 = v309;
      uint64_t v860 = v20;
      while (1)
      {
        int v312 = v878;
        unint64_t v909 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v313 = v20 ? bswap32(*v308) >> 16 : 0xFFFF;
            int v314 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v315 = v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16);
            LODWORD(v316) = (unsigned __int16)(v313 - ((v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16));
            if ((_WORD)v313 != (v313 * v314 + ((v313 * v314) >> 16) + 1) >> 16)
            {
              unsigned int v317 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v318 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v319 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v320 = HIWORD(v319);
              unint64_t v321 = ((unint64_t)(v317 - ((v314 * v317 + ((v314 * v317) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v318 - ((v314 * v318 + ((v314 * v318) >> 16) + 1) >> 16)) << 32) | ((v320 - ((v320 * v314 + ((v320 * v314) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v319 - (((unsigned __int16)v319 * v314 + (((unsigned __int16)v319 * v314) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v322 = __rev16(*v7);
                  goto LABEL_365;
                }
LABEL_367:
                unsigned int v325 = bswap32(v321);
                v14->i16[0] = HIWORD(v325);
                v14->i16[1] = v325;
                v14->i16[2] = bswap32(HIDWORD(v321)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v321));
                uint64_t v323 = v7;
              }
              else
              {
                unsigned int v322 = 0xFFFF;
LABEL_365:
                uint64_t v323 = (_WORD *)v14 + 3;
                unint64_t v324 = PDAoverlayPDA_11712(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v322, v321, (unsigned __int16)v315);
                unint64_t v321 = v324;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v909;
                  int v20 = v923;
                  uint64_t v309 = v835;
                  uint64_t v307 = v860;
                  goto LABEL_367;
                }
                unint64_t v316 = HIWORD(v324);
                unsigned int v326 = bswap32(v324);
                v14->i16[0] = HIWORD(v326);
                v14->i16[1] = v326;
                v14->i16[2] = bswap32(HIDWORD(v324)) >> 16;
                unint64_t v12 = v909;
                int v20 = v923;
                uint64_t v309 = v835;
                uint64_t v307 = v860;
              }
              *uint64_t v323 = bswap32(v316) >> 16;
            }
          }
          v16 += v306;
          int v14 = (int8x8_t *)((char *)v14 + v310);
          unsigned int v327 = (unsigned __int16 *)&v23[8 * v306];
          if ((unint64_t)v327 >= v12) {
            uint64_t v328 = v311;
          }
          else {
            uint64_t v328 = 0;
          }
          v308 += v307 + v328;
          int32x4_t v23 = (char *)&v327[4 * v328];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v309);
          --v312;
        }
        while (v312);
        if (v874)
        {
          int v329 = (char *)&v881[4 * v879];
          uint64_t v330 = v799;
          if ((unint64_t)v329 < v874) {
            uint64_t v330 = 0;
          }
          uint64_t v308 = &v880[v877 + v330];
          uint64_t v331 = v815;
          if ((unint64_t)v329 < v874) {
            uint64_t v331 = 0;
          }
          int32x4_t v23 = &v329[8 * v331];
          v12 += 8 * v331 + 8 * v879;
          v880 += v877 + v330;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v308 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 16:
      uint64_t v332 = v25;
      uint64_t v333 = v20;
      int v334 = v880;
      uint64_t v816 = -(v879 * v22);
      uint64_t v800 = -(uint64_t)(v877 * v22);
      uint64_t v335 = 2 * v8;
      uint64_t v336 = 8 * v25;
      uint64_t v337 = -(uint64_t)v21;
      uint64_t v836 = v335;
      uint64_t v861 = v20;
      while (1)
      {
        int v338 = v878;
        unint64_t v910 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v339 = v20 ? bswap32(*v334) >> 16 : 0xFFFF;
            int v340 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v341 = v339 - ((v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16);
            LODWORD(v342) = (unsigned __int16)(v339 - ((v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16));
            if ((_WORD)v339 != (v339 * v340 + ((v339 * v340) >> 16) + 1) >> 16)
            {
              unsigned int v343 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v344 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v345 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v346 = HIWORD(v345);
              unint64_t v347 = ((unint64_t)(v343 - ((v340 * v343 + ((v340 * v343) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v344 - ((v340 * v344 + ((v340 * v344) >> 16) + 1) >> 16)) << 32) | ((v346 - ((v346 * v340 + ((v346 * v340) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v345 - (((unsigned __int16)v345 * v340 + (((unsigned __int16)v345 * v340) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v348 = __rev16(*v7);
                  goto LABEL_394;
                }
LABEL_396:
                unsigned int v351 = bswap32(v347);
                v14->i16[0] = HIWORD(v351);
                v14->i16[1] = v351;
                v14->i16[2] = bswap32(HIDWORD(v347)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v347));
                unsigned int v349 = v7;
              }
              else
              {
                unsigned int v348 = 0xFFFF;
LABEL_394:
                unsigned int v349 = (_WORD *)v14 + 3;
                unint64_t v350 = PDAdarkenPDA_11714(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v348, v347, (unsigned __int16)v341);
                unint64_t v347 = v350;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v910;
                  int v20 = v923;
                  uint64_t v335 = v836;
                  uint64_t v333 = v861;
                  goto LABEL_396;
                }
                unint64_t v342 = HIWORD(v350);
                unsigned int v352 = bswap32(v350);
                v14->i16[0] = HIWORD(v352);
                v14->i16[1] = v352;
                v14->i16[2] = bswap32(HIDWORD(v350)) >> 16;
                unint64_t v12 = v910;
                int v20 = v923;
                uint64_t v335 = v836;
                uint64_t v333 = v861;
              }
              *unsigned int v349 = bswap32(v342) >> 16;
            }
          }
          v16 += v332;
          int v14 = (int8x8_t *)((char *)v14 + v336);
          unint64_t v353 = (unsigned __int16 *)&v23[8 * v332];
          if ((unint64_t)v353 >= v12) {
            uint64_t v354 = v337;
          }
          else {
            uint64_t v354 = 0;
          }
          v334 += v333 + v354;
          int32x4_t v23 = (char *)&v353[4 * v354];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v335);
          --v338;
        }
        while (v338);
        if (v874)
        {
          unsigned int v355 = (char *)&v881[4 * v879];
          uint64_t v356 = v800;
          if ((unint64_t)v355 < v874) {
            uint64_t v356 = 0;
          }
          int v334 = &v880[v877 + v356];
          uint64_t v357 = v816;
          if ((unint64_t)v355 < v874) {
            uint64_t v357 = 0;
          }
          int32x4_t v23 = &v355[8 * v357];
          v12 += 8 * v357 + 8 * v879;
          v880 += v877 + v356;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v334 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 17:
      uint64_t v358 = v25;
      uint64_t v359 = v20;
      int v360 = v880;
      uint64_t v817 = -(v879 * v22);
      uint64_t v801 = -(uint64_t)(v877 * v22);
      uint64_t v361 = 2 * v8;
      uint64_t v362 = 8 * v25;
      uint64_t v363 = -(uint64_t)v21;
      uint64_t v837 = v361;
      uint64_t v862 = v20;
      while (1)
      {
        int v364 = v878;
        unint64_t v911 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v365 = v20 ? bswap32(*v360) >> 16 : 0xFFFF;
            int v366 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v367 = v365 - ((v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16);
            LODWORD(v368) = (unsigned __int16)(v365 - ((v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16));
            if ((_WORD)v365 != (v365 * v366 + ((v365 * v366) >> 16) + 1) >> 16)
            {
              unsigned int v369 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v370 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v371 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v372 = HIWORD(v371);
              unint64_t v373 = ((unint64_t)(v369 - ((v366 * v369 + ((v366 * v369) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v370 - ((v366 * v370 + ((v366 * v370) >> 16) + 1) >> 16)) << 32) | ((v372 - ((v372 * v366 + ((v372 * v366) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v371 - (((unsigned __int16)v371 * v366 + (((unsigned __int16)v371 * v366) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v374 = __rev16(*v7);
                  goto LABEL_423;
                }
LABEL_425:
                unsigned int v377 = bswap32(v373);
                v14->i16[0] = HIWORD(v377);
                v14->i16[1] = v377;
                v14->i16[2] = bswap32(HIDWORD(v373)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v373));
                uint32x4_t v375 = v7;
              }
              else
              {
                unsigned int v374 = 0xFFFF;
LABEL_423:
                uint32x4_t v375 = (_WORD *)v14 + 3;
                unint64_t v376 = PDAlightenPDA_11713(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v374, v373, (unsigned __int16)v367);
                unint64_t v373 = v376;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v911;
                  int v20 = v923;
                  uint64_t v361 = v837;
                  uint64_t v359 = v862;
                  goto LABEL_425;
                }
                unint64_t v368 = HIWORD(v376);
                unsigned int v378 = bswap32(v376);
                v14->i16[0] = HIWORD(v378);
                v14->i16[1] = v378;
                v14->i16[2] = bswap32(HIDWORD(v376)) >> 16;
                unint64_t v12 = v911;
                int v20 = v923;
                uint64_t v361 = v837;
                uint64_t v359 = v862;
              }
              *uint32x4_t v375 = bswap32(v368) >> 16;
            }
          }
          v16 += v358;
          int v14 = (int8x8_t *)((char *)v14 + v362);
          unsigned int v379 = (unsigned __int16 *)&v23[8 * v358];
          if ((unint64_t)v379 >= v12) {
            uint64_t v380 = v363;
          }
          else {
            uint64_t v380 = 0;
          }
          v360 += v359 + v380;
          int32x4_t v23 = (char *)&v379[4 * v380];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v361);
          --v364;
        }
        while (v364);
        if (v874)
        {
          int v381 = (char *)&v881[4 * v879];
          uint64_t v382 = v801;
          if ((unint64_t)v381 < v874) {
            uint64_t v382 = 0;
          }
          int v360 = &v880[v877 + v382];
          uint64_t v383 = v817;
          if ((unint64_t)v381 < v874) {
            uint64_t v383 = 0;
          }
          int32x4_t v23 = &v381[8 * v383];
          v12 += 8 * v383 + 8 * v879;
          v880 += v877 + v382;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v360 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 18:
      uint64_t v384 = v25;
      uint64_t v385 = v20;
      uint64_t v386 = v880;
      uint64_t v818 = -(v879 * v22);
      uint64_t v802 = -(uint64_t)(v877 * v22);
      uint64_t v387 = 2 * v8;
      uint64_t v388 = 8 * v25;
      uint64_t v389 = -(uint64_t)v21;
      uint64_t v838 = v387;
      uint64_t v863 = v20;
      while (1)
      {
        int v390 = v878;
        unint64_t v912 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v391 = v20 ? bswap32(*v386) >> 16 : 0xFFFF;
            int v392 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v393 = v391 - ((v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16);
            LODWORD(v394) = (unsigned __int16)(v391 - ((v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16));
            if ((_WORD)v391 != (v391 * v392 + ((v391 * v392) >> 16) + 1) >> 16)
            {
              unsigned int v395 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v396 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v397 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v398 = HIWORD(v397);
              unint64_t v399 = ((unint64_t)(v395 - ((v392 * v395 + ((v392 * v395) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v396 - ((v392 * v396 + ((v392 * v396) >> 16) + 1) >> 16)) << 32) | ((v398 - ((v398 * v392 + ((v398 * v392) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v397 - (((unsigned __int16)v397 * v392 + (((unsigned __int16)v397 * v392) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v400 = __rev16(*v7);
                  goto LABEL_452;
                }
LABEL_454:
                unsigned int v403 = bswap32(v399);
                v14->i16[0] = HIWORD(v403);
                v14->i16[1] = v403;
                v14->i16[2] = bswap32(HIDWORD(v399)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v399));
                int32x4_t v401 = v7;
              }
              else
              {
                unsigned int v400 = 0xFFFF;
LABEL_452:
                int32x4_t v401 = (_WORD *)v14 + 3;
                unint64_t v402 = PDAcolordodgePDA_11715(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v400, v399, (unsigned __int16)v393);
                unint64_t v399 = v402;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v912;
                  int v20 = v923;
                  uint64_t v387 = v838;
                  uint64_t v385 = v863;
                  goto LABEL_454;
                }
                unint64_t v394 = HIWORD(v402);
                unsigned int v404 = bswap32(v402);
                v14->i16[0] = HIWORD(v404);
                v14->i16[1] = v404;
                v14->i16[2] = bswap32(HIDWORD(v402)) >> 16;
                unint64_t v12 = v912;
                int v20 = v923;
                uint64_t v387 = v838;
                uint64_t v385 = v863;
              }
              *int32x4_t v401 = bswap32(v394) >> 16;
            }
          }
          v16 += v384;
          int v14 = (int8x8_t *)((char *)v14 + v388);
          int v405 = (unsigned __int16 *)&v23[8 * v384];
          if ((unint64_t)v405 >= v12) {
            uint64_t v406 = v389;
          }
          else {
            uint64_t v406 = 0;
          }
          v386 += v385 + v406;
          int32x4_t v23 = (char *)&v405[4 * v406];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v387);
          --v390;
        }
        while (v390);
        if (v874)
        {
          unsigned int v407 = (char *)&v881[4 * v879];
          uint64_t v408 = v802;
          if ((unint64_t)v407 < v874) {
            uint64_t v408 = 0;
          }
          uint64_t v386 = &v880[v877 + v408];
          uint64_t v409 = v818;
          if ((unint64_t)v407 < v874) {
            uint64_t v409 = 0;
          }
          int32x4_t v23 = &v407[8 * v409];
          v12 += 8 * v409 + 8 * v879;
          v880 += v877 + v408;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v386 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 19:
      uint64_t v410 = v25;
      uint64_t v411 = v20;
      int32x4_t v412 = v880;
      uint64_t v819 = -(v879 * v22);
      uint64_t v803 = -(uint64_t)(v877 * v22);
      uint64_t v413 = 2 * v8;
      uint64_t v414 = 8 * v25;
      uint64_t v415 = -(uint64_t)v21;
      uint64_t v839 = v413;
      uint64_t v864 = v20;
      while (1)
      {
        int v416 = v878;
        unint64_t v913 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v417 = v20 ? bswap32(*v412) >> 16 : 0xFFFF;
            int v418 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v419 = v417 - ((v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16);
            LODWORD(v420) = (unsigned __int16)(v417 - ((v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16));
            if ((_WORD)v417 != (v417 * v418 + ((v417 * v418) >> 16) + 1) >> 16)
            {
              unsigned int v421 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v422 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v423 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v424 = HIWORD(v423);
              unint64_t v425 = ((unint64_t)(v421 - ((v418 * v421 + ((v418 * v421) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v422 - ((v418 * v422 + ((v418 * v422) >> 16) + 1) >> 16)) << 32) | ((v424 - ((v424 * v418 + ((v424 * v418) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v423 - (((unsigned __int16)v423 * v418 + (((unsigned __int16)v423 * v418) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v426 = __rev16(*v7);
                  goto LABEL_481;
                }
LABEL_483:
                unsigned int v429 = bswap32(v425);
                v14->i16[0] = HIWORD(v429);
                v14->i16[1] = v429;
                v14->i16[2] = bswap32(HIDWORD(v425)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v425));
                int v427 = v7;
              }
              else
              {
                unsigned int v426 = 0xFFFF;
LABEL_481:
                int v427 = (_WORD *)v14 + 3;
                unint64_t v428 = PDAcolorburnPDA_11716(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v426, v425, (unsigned __int16)v419);
                unint64_t v425 = v428;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v913;
                  int v20 = v923;
                  uint64_t v413 = v839;
                  uint64_t v411 = v864;
                  goto LABEL_483;
                }
                unint64_t v420 = HIWORD(v428);
                unsigned int v430 = bswap32(v428);
                v14->i16[0] = HIWORD(v430);
                v14->i16[1] = v430;
                v14->i16[2] = bswap32(HIDWORD(v428)) >> 16;
                unint64_t v12 = v913;
                int v20 = v923;
                uint64_t v413 = v839;
                uint64_t v411 = v864;
              }
              *int v427 = bswap32(v420) >> 16;
            }
          }
          v16 += v410;
          int v14 = (int8x8_t *)((char *)v14 + v414);
          int32x4_t v431 = (unsigned __int16 *)&v23[8 * v410];
          if ((unint64_t)v431 >= v12) {
            uint64_t v432 = v415;
          }
          else {
            uint64_t v432 = 0;
          }
          v412 += v411 + v432;
          int32x4_t v23 = (char *)&v431[4 * v432];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v413);
          --v416;
        }
        while (v416);
        if (v874)
        {
          unsigned int v433 = (char *)&v881[4 * v879];
          uint64_t v434 = v803;
          if ((unint64_t)v433 < v874) {
            uint64_t v434 = 0;
          }
          int32x4_t v412 = &v880[v877 + v434];
          uint64_t v435 = v819;
          if ((unint64_t)v433 < v874) {
            uint64_t v435 = 0;
          }
          int32x4_t v23 = &v433[8 * v435];
          v12 += 8 * v435 + 8 * v879;
          v880 += v877 + v434;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v412 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 20:
      uint64_t v436 = v25;
      uint64_t v437 = v20;
      uint64_t v438 = v880;
      uint64_t v820 = -(v879 * v22);
      uint64_t v804 = -(uint64_t)(v877 * v22);
      uint64_t v439 = 2 * v8;
      uint64_t v440 = 8 * v25;
      uint64_t v441 = -(uint64_t)v21;
      uint64_t v840 = v439;
      uint64_t v865 = v20;
      while (1)
      {
        int v442 = v878;
        unint64_t v914 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v443 = v20 ? bswap32(*v438) >> 16 : 0xFFFF;
            int v444 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v445 = v443 - ((v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16);
            LODWORD(v446) = (unsigned __int16)(v443 - ((v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16));
            if ((_WORD)v443 != (v443 * v444 + ((v443 * v444) >> 16) + 1) >> 16)
            {
              unsigned int v447 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v448 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v449 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v450 = HIWORD(v449);
              unint64_t v451 = ((unint64_t)(v447 - ((v444 * v447 + ((v444 * v447) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v448 - ((v444 * v448 + ((v444 * v448) >> 16) + 1) >> 16)) << 32) | ((v450 - ((v450 * v444 + ((v450 * v444) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v449 - (((unsigned __int16)v449 * v444 + (((unsigned __int16)v449 * v444) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v452 = __rev16(*v7);
                  goto LABEL_510;
                }
LABEL_512:
                unsigned int v455 = bswap32(v451);
                v14->i16[0] = HIWORD(v455);
                v14->i16[1] = v455;
                v14->i16[2] = bswap32(HIDWORD(v451)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v451));
                unsigned int v453 = v7;
              }
              else
              {
                unsigned int v452 = 0xFFFF;
LABEL_510:
                unsigned int v453 = (_WORD *)v14 + 3;
                unint64_t v454 = PDAsoftlightPDA_11718(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v452, v451, (unsigned __int16)v445);
                unint64_t v451 = v454;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v914;
                  int v20 = v923;
                  uint64_t v439 = v840;
                  uint64_t v437 = v865;
                  goto LABEL_512;
                }
                unint64_t v446 = HIWORD(v454);
                unsigned int v456 = bswap32(v454);
                v14->i16[0] = HIWORD(v456);
                v14->i16[1] = v456;
                v14->i16[2] = bswap32(HIDWORD(v454)) >> 16;
                unint64_t v12 = v914;
                int v20 = v923;
                uint64_t v439 = v840;
                uint64_t v437 = v865;
              }
              *unsigned int v453 = bswap32(v446) >> 16;
            }
          }
          v16 += v436;
          int v14 = (int8x8_t *)((char *)v14 + v440);
          unsigned int v457 = (unsigned __int16 *)&v23[8 * v436];
          if ((unint64_t)v457 >= v12) {
            uint64_t v458 = v441;
          }
          else {
            uint64_t v458 = 0;
          }
          v438 += v437 + v458;
          int32x4_t v23 = (char *)&v457[4 * v458];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v439);
          --v442;
        }
        while (v442);
        if (v874)
        {
          unint64_t v459 = (char *)&v881[4 * v879];
          uint64_t v460 = v804;
          if ((unint64_t)v459 < v874) {
            uint64_t v460 = 0;
          }
          uint64_t v438 = &v880[v877 + v460];
          uint64_t v461 = v820;
          if ((unint64_t)v459 < v874) {
            uint64_t v461 = 0;
          }
          int32x4_t v23 = &v459[8 * v461];
          v12 += 8 * v461 + 8 * v879;
          v880 += v877 + v460;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v438 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 21:
      uint64_t v462 = v25;
      uint64_t v463 = v20;
      int32x2_t v464 = v880;
      uint64_t v821 = -(v879 * v22);
      uint64_t v805 = -(uint64_t)(v877 * v22);
      uint64_t v465 = 2 * v8;
      uint64_t v466 = 8 * v25;
      uint64_t v467 = -(uint64_t)v21;
      uint64_t v841 = v465;
      uint64_t v866 = v20;
      while (1)
      {
        int v468 = v878;
        unint64_t v915 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v469 = v20 ? bswap32(*v464) >> 16 : 0xFFFF;
            int v470 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v471 = v469 - ((v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16);
            LODWORD(v472) = (unsigned __int16)(v469 - ((v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16));
            if ((_WORD)v469 != (v469 * v470 + ((v469 * v470) >> 16) + 1) >> 16)
            {
              unsigned int v473 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v474 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v475 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v476 = HIWORD(v475);
              unint64_t v477 = ((unint64_t)(v473 - ((v470 * v473 + ((v470 * v473) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v474 - ((v470 * v474 + ((v470 * v474) >> 16) + 1) >> 16)) << 32) | ((v476 - ((v476 * v470 + ((v476 * v470) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v475 - (((unsigned __int16)v475 * v470 + (((unsigned __int16)v475 * v470) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v478 = __rev16(*v7);
                  goto LABEL_539;
                }
LABEL_541:
                unsigned int v481 = bswap32(v477);
                v14->i16[0] = HIWORD(v481);
                v14->i16[1] = v481;
                v14->i16[2] = bswap32(HIDWORD(v477)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v477));
                unsigned int v479 = v7;
              }
              else
              {
                unsigned int v478 = 0xFFFF;
LABEL_539:
                unsigned int v479 = (_WORD *)v14 + 3;
                unint64_t v480 = PDAhardlightPDA_11717(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v478, v477, (unsigned __int16)v471);
                unint64_t v477 = v480;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v915;
                  int v20 = v923;
                  uint64_t v465 = v841;
                  uint64_t v463 = v866;
                  goto LABEL_541;
                }
                unint64_t v472 = HIWORD(v480);
                unsigned int v482 = bswap32(v480);
                v14->i16[0] = HIWORD(v482);
                v14->i16[1] = v482;
                v14->i16[2] = bswap32(HIDWORD(v480)) >> 16;
                unint64_t v12 = v915;
                int v20 = v923;
                uint64_t v465 = v841;
                uint64_t v463 = v866;
              }
              *unsigned int v479 = bswap32(v472) >> 16;
            }
          }
          v16 += v462;
          int v14 = (int8x8_t *)((char *)v14 + v466);
          unsigned int v483 = (unsigned __int16 *)&v23[8 * v462];
          if ((unint64_t)v483 >= v12) {
            uint64_t v484 = v467;
          }
          else {
            uint64_t v484 = 0;
          }
          v464 += v463 + v484;
          int32x4_t v23 = (char *)&v483[4 * v484];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v465);
          --v468;
        }
        while (v468);
        if (v874)
        {
          unsigned int v485 = (char *)&v881[4 * v879];
          uint64_t v486 = v805;
          if ((unint64_t)v485 < v874) {
            uint64_t v486 = 0;
          }
          int32x2_t v464 = &v880[v877 + v486];
          uint64_t v487 = v821;
          if ((unint64_t)v485 < v874) {
            uint64_t v487 = 0;
          }
          int32x4_t v23 = &v485[8 * v487];
          v12 += 8 * v487 + 8 * v879;
          v880 += v877 + v486;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v464 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 22:
      uint64_t v488 = v25;
      uint64_t v489 = v20;
      unsigned int v490 = v880;
      uint64_t v822 = -(v879 * v22);
      uint64_t v806 = -(uint64_t)(v877 * v22);
      uint64_t v491 = 2 * v8;
      uint64_t v492 = 8 * v25;
      uint64_t v493 = -(uint64_t)v21;
      uint64_t v842 = v491;
      uint64_t v867 = v20;
      while (1)
      {
        int v494 = v878;
        unint64_t v916 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v495 = v20 ? bswap32(*v490) >> 16 : 0xFFFF;
            int v496 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v497 = v495 - ((v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16);
            LODWORD(v498) = (unsigned __int16)(v495 - ((v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16));
            if ((_WORD)v495 != (v495 * v496 + ((v495 * v496) >> 16) + 1) >> 16)
            {
              unsigned int v499 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v500 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v501 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v502 = HIWORD(v501);
              unint64_t v503 = ((unint64_t)(v499 - ((v496 * v499 + ((v496 * v499) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v500 - ((v496 * v500 + ((v496 * v500) >> 16) + 1) >> 16)) << 32) | ((v502 - ((v502 * v496 + ((v502 * v496) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v501 - (((unsigned __int16)v501 * v496 + (((unsigned __int16)v501 * v496) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v504 = __rev16(*v7);
                  goto LABEL_568;
                }
LABEL_570:
                unsigned int v507 = bswap32(v503);
                v14->i16[0] = HIWORD(v507);
                v14->i16[1] = v507;
                v14->i16[2] = bswap32(HIDWORD(v503)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v503));
                unsigned int v505 = v7;
              }
              else
              {
                unsigned int v504 = 0xFFFF;
LABEL_568:
                unsigned int v505 = (_WORD *)v14 + 3;
                unint64_t v506 = PDAdifferencePDA_11719(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v504, v503, (unsigned __int16)v497);
                unint64_t v503 = v506;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v916;
                  int v20 = v923;
                  uint64_t v491 = v842;
                  uint64_t v489 = v867;
                  goto LABEL_570;
                }
                unint64_t v498 = HIWORD(v506);
                unsigned int v508 = bswap32(v506);
                v14->i16[0] = HIWORD(v508);
                v14->i16[1] = v508;
                v14->i16[2] = bswap32(HIDWORD(v506)) >> 16;
                unint64_t v12 = v916;
                int v20 = v923;
                uint64_t v491 = v842;
                uint64_t v489 = v867;
              }
              *unsigned int v505 = bswap32(v498) >> 16;
            }
          }
          v16 += v488;
          int v14 = (int8x8_t *)((char *)v14 + v492);
          unint64_t v509 = (unsigned __int16 *)&v23[8 * v488];
          if ((unint64_t)v509 >= v12) {
            uint64_t v510 = v493;
          }
          else {
            uint64_t v510 = 0;
          }
          v490 += v489 + v510;
          int32x4_t v23 = (char *)&v509[4 * v510];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v491);
          --v494;
        }
        while (v494);
        if (v874)
        {
          int32x4_t v511 = (char *)&v881[4 * v879];
          uint64_t v512 = v806;
          if ((unint64_t)v511 < v874) {
            uint64_t v512 = 0;
          }
          unsigned int v490 = &v880[v877 + v512];
          uint64_t v513 = v822;
          if ((unint64_t)v511 < v874) {
            uint64_t v513 = 0;
          }
          int32x4_t v23 = &v511[8 * v513];
          v12 += 8 * v513 + 8 * v879;
          v880 += v877 + v512;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v490 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 23:
      uint64_t v514 = v25;
      uint64_t v515 = v20;
      uint64_t v516 = v880;
      uint64_t v823 = -(v879 * v22);
      uint64_t v807 = -(uint64_t)(v877 * v22);
      uint64_t v517 = 2 * v8;
      uint64_t v518 = 8 * v25;
      uint64_t v519 = -(uint64_t)v21;
      uint64_t v843 = v517;
      uint64_t v868 = v20;
      while (1)
      {
        int v520 = v878;
        unint64_t v917 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v521 = v20 ? bswap32(*v516) >> 16 : 0xFFFF;
            int v522 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v523 = v521 - ((v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16);
            LODWORD(v524) = (unsigned __int16)(v521 - ((v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16));
            if ((_WORD)v521 != (v521 * v522 + ((v521 * v522) >> 16) + 1) >> 16)
            {
              unsigned int v525 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v526 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v527 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v528 = HIWORD(v527);
              unint64_t v529 = ((unint64_t)(v525 - ((v522 * v525 + ((v522 * v525) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v526 - ((v522 * v526 + ((v522 * v526) >> 16) + 1) >> 16)) << 32) | ((v528 - ((v528 * v522 + ((v528 * v522) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v527 - (((unsigned __int16)v527 * v522 + (((unsigned __int16)v527 * v522) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v530 = __rev16(*v7);
                  goto LABEL_597;
                }
LABEL_599:
                unsigned int v533 = bswap32(v529);
                v14->i16[0] = HIWORD(v533);
                v14->i16[1] = v533;
                v14->i16[2] = bswap32(HIDWORD(v529)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v529));
                unsigned int v531 = v7;
              }
              else
              {
                unsigned int v530 = 0xFFFF;
LABEL_597:
                unsigned int v531 = (_WORD *)v14 + 3;
                unint64_t v532 = PDAexclusionPDA_11720(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v530, v529, (unsigned __int16)v523);
                unint64_t v529 = v532;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v917;
                  int v20 = v923;
                  uint64_t v517 = v843;
                  uint64_t v515 = v868;
                  goto LABEL_599;
                }
                unint64_t v524 = HIWORD(v532);
                unsigned int v534 = bswap32(v532);
                v14->i16[0] = HIWORD(v534);
                v14->i16[1] = v534;
                v14->i16[2] = bswap32(HIDWORD(v532)) >> 16;
                unint64_t v12 = v917;
                int v20 = v923;
                uint64_t v517 = v843;
                uint64_t v515 = v868;
              }
              *unsigned int v531 = bswap32(v524) >> 16;
            }
          }
          v16 += v514;
          int v14 = (int8x8_t *)((char *)v14 + v518);
          unsigned int v535 = (unsigned __int16 *)&v23[8 * v514];
          if ((unint64_t)v535 >= v12) {
            uint64_t v536 = v519;
          }
          else {
            uint64_t v536 = 0;
          }
          v516 += v515 + v536;
          int32x4_t v23 = (char *)&v535[4 * v536];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v517);
          --v520;
        }
        while (v520);
        if (v874)
        {
          uint32x4_t v537 = (char *)&v881[4 * v879];
          uint64_t v538 = v807;
          if ((unint64_t)v537 < v874) {
            uint64_t v538 = 0;
          }
          uint64_t v516 = &v880[v877 + v538];
          uint64_t v539 = v823;
          if ((unint64_t)v537 < v874) {
            uint64_t v539 = 0;
          }
          int32x4_t v23 = &v537[8 * v539];
          v12 += 8 * v539 + 8 * v879;
          v880 += v877 + v538;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v516 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 24:
      uint64_t v540 = v25;
      uint64_t v541 = v20;
      uint32x4_t v542 = v880;
      uint64_t v824 = -(v879 * v22);
      uint64_t v808 = -(uint64_t)(v877 * v22);
      uint64_t v543 = 2 * v8;
      uint64_t v544 = 8 * v25;
      uint64_t v545 = -(uint64_t)v21;
      uint64_t v844 = v543;
      uint64_t v869 = v20;
      while (1)
      {
        int v546 = v878;
        unint64_t v918 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v547 = v20 ? bswap32(*v542) >> 16 : 0xFFFF;
            int v548 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v549 = v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16);
            LODWORD(v550) = (unsigned __int16)(v547 - ((v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16));
            if ((_WORD)v547 != (v547 * v548 + ((v547 * v548) >> 16) + 1) >> 16)
            {
              unsigned int v551 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v552 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v553 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v554 = HIWORD(v553);
              unint64_t v555 = ((unint64_t)(v551 - ((v548 * v551 + ((v548 * v551) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v552 - ((v548 * v552 + ((v548 * v552) >> 16) + 1) >> 16)) << 32) | ((v554 - ((v554 * v548 + ((v554 * v548) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v553 - (((unsigned __int16)v553 * v548 + (((unsigned __int16)v553 * v548) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v556 = __rev16(*v7);
                  goto LABEL_626;
                }
LABEL_628:
                unsigned int v559 = bswap32(v555);
                v14->i16[0] = HIWORD(v559);
                v14->i16[1] = v559;
                v14->i16[2] = bswap32(HIDWORD(v555)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v555));
                uint64_t v557 = v7;
              }
              else
              {
                unsigned int v556 = 0xFFFF;
LABEL_626:
                uint64_t v557 = (_WORD *)v14 + 3;
                unint64_t v558 = PDAhuePDA_11721(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v556, v555, (unsigned __int16)v549);
                unint64_t v555 = v558;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v918;
                  int v20 = v923;
                  uint64_t v543 = v844;
                  uint64_t v541 = v869;
                  goto LABEL_628;
                }
                unint64_t v550 = HIWORD(v558);
                unsigned int v560 = bswap32(v558);
                v14->i16[0] = HIWORD(v560);
                v14->i16[1] = v560;
                v14->i16[2] = bswap32(HIDWORD(v558)) >> 16;
                unint64_t v12 = v918;
                int v20 = v923;
                uint64_t v543 = v844;
                uint64_t v541 = v869;
              }
              *uint64_t v557 = bswap32(v550) >> 16;
            }
          }
          v16 += v540;
          int v14 = (int8x8_t *)((char *)v14 + v544);
          int32x2_t v561 = (unsigned __int16 *)&v23[8 * v540];
          if ((unint64_t)v561 >= v12) {
            uint64_t v562 = v545;
          }
          else {
            uint64_t v562 = 0;
          }
          v542 += v541 + v562;
          int32x4_t v23 = (char *)&v561[4 * v562];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v543);
          --v546;
        }
        while (v546);
        if (v874)
        {
          int32x4_t v563 = (char *)&v881[4 * v879];
          uint64_t v564 = v808;
          if ((unint64_t)v563 < v874) {
            uint64_t v564 = 0;
          }
          uint32x4_t v542 = &v880[v877 + v564];
          uint64_t v565 = v824;
          if ((unint64_t)v563 < v874) {
            uint64_t v565 = 0;
          }
          int32x4_t v23 = &v563[8 * v565];
          v12 += 8 * v565 + 8 * v879;
          v880 += v877 + v564;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v542 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 25:
      uint64_t v566 = v25;
      uint64_t v567 = v20;
      int32x4_t v568 = v880;
      uint64_t v825 = -(v879 * v22);
      uint64_t v809 = -(uint64_t)(v877 * v22);
      uint64_t v569 = 2 * v8;
      uint64_t v570 = 8 * v25;
      uint64_t v571 = -(uint64_t)v21;
      uint64_t v845 = v569;
      uint64_t v870 = v20;
      while (1)
      {
        int v572 = v878;
        unint64_t v919 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v573 = v20 ? bswap32(*v568) >> 16 : 0xFFFF;
            int v574 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v575 = v573 - ((v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16);
            LODWORD(v576) = (unsigned __int16)(v573 - ((v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16));
            if ((_WORD)v573 != (v573 * v574 + ((v573 * v574) >> 16) + 1) >> 16)
            {
              unsigned int v577 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v578 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v579 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v580 = HIWORD(v579);
              unint64_t v581 = ((unint64_t)(v577 - ((v574 * v577 + ((v574 * v577) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v578 - ((v574 * v578 + ((v574 * v578) >> 16) + 1) >> 16)) << 32) | ((v580 - ((v580 * v574 + ((v580 * v574) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v579 - (((unsigned __int16)v579 * v574 + (((unsigned __int16)v579 * v574) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v582 = __rev16(*v7);
                  goto LABEL_655;
                }
LABEL_657:
                unsigned int v585 = bswap32(v581);
                v14->i16[0] = HIWORD(v585);
                v14->i16[1] = v585;
                v14->i16[2] = bswap32(HIDWORD(v581)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v581));
                int32x4_t v583 = v7;
              }
              else
              {
                unsigned int v582 = 0xFFFF;
LABEL_655:
                int32x4_t v583 = (_WORD *)v14 + 3;
                unint64_t v584 = PDAsaturationPDA_11722(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v582, v581, (unsigned __int16)v575);
                unint64_t v581 = v584;
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v919;
                  int v20 = v923;
                  uint64_t v569 = v845;
                  uint64_t v567 = v870;
                  goto LABEL_657;
                }
                unint64_t v576 = HIWORD(v584);
                unsigned int v586 = bswap32(v584);
                v14->i16[0] = HIWORD(v586);
                v14->i16[1] = v586;
                v14->i16[2] = bswap32(HIDWORD(v584)) >> 16;
                unint64_t v12 = v919;
                int v20 = v923;
                uint64_t v569 = v845;
                uint64_t v567 = v870;
              }
              _WORD *v583 = bswap32(v576) >> 16;
            }
          }
          v16 += v566;
          int v14 = (int8x8_t *)((char *)v14 + v570);
          unsigned int v587 = (unsigned __int16 *)&v23[8 * v566];
          if ((unint64_t)v587 >= v12) {
            uint64_t v588 = v571;
          }
          else {
            uint64_t v588 = 0;
          }
          v568 += v567 + v588;
          int32x4_t v23 = (char *)&v587[4 * v588];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v569);
          --v572;
        }
        while (v572);
        if (v874)
        {
          uint32x4_t v589 = (char *)&v881[4 * v879];
          uint64_t v590 = v809;
          if ((unint64_t)v589 < v874) {
            uint64_t v590 = 0;
          }
          int32x4_t v568 = &v880[v877 + v590];
          uint64_t v591 = v825;
          if ((unint64_t)v589 < v874) {
            uint64_t v591 = 0;
          }
          int32x4_t v23 = &v589[8 * v591];
          v12 += 8 * v591 + 8 * v879;
          v880 += v877 + v590;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v568 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 26:
      uint64_t v592 = v25;
      uint64_t v593 = v20;
      uint32x4_t v594 = v880;
      uint64_t v826 = -(v879 * v22);
      uint64_t v810 = -(uint64_t)(v877 * v22);
      uint64_t v595 = 2 * v8;
      uint64_t v596 = 8 * v25;
      uint64_t v597 = -(uint64_t)v21;
      uint64_t v846 = v595;
      uint64_t v871 = v20;
      while (1)
      {
        int v598 = v878;
        unint64_t v920 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v599 = v20 ? bswap32(*v594) >> 16 : 0xFFFF;
            int v600 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v601 = v599 - ((v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16);
            LODWORD(v602) = (unsigned __int16)(v599 - ((v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16));
            if ((_WORD)v599 != (v599 * v600 + ((v599 * v600) >> 16) + 1) >> 16)
            {
              unsigned int v603 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
              unsigned int v604 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
              unsigned int v605 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
              unsigned int v606 = HIWORD(v605);
              unint64_t v607 = ((unint64_t)(v603 - ((v600 * v603 + ((v600 * v603) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v604 - ((v600 * v604 + ((v600 * v604) >> 16) + 1) >> 16)) << 32) | ((v606 - ((v606 * v600 + ((v606 * v600) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v605 - (((unsigned __int16)v605 * v600 + (((unsigned __int16)v605 * v600) >> 16) + 1) >> 16));
              if (v8)
              {
                if (*v7)
                {
                  unsigned int v608 = __rev16(*v7);
                  goto LABEL_684;
                }
LABEL_686:
                unsigned int v610 = bswap32(v607);
                v14->i16[0] = HIWORD(v610);
                v14->i16[1] = v610;
                v14->i16[2] = bswap32(HIDWORD(v607)) >> 16;
                v14->i16[3] = __rev16(HIWORD(v607));
                int v609 = v7;
              }
              else
              {
                unsigned int v608 = 0xFFFF;
LABEL_684:
                int v609 = (_WORD *)v14 + 3;
                unint64_t v607 = PDAluminosityPDA_11723(v607, (unsigned __int16)v601, ((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v608);
                int v8 = v883;
                if (v883)
                {
                  unint64_t v12 = v920;
                  int v20 = v923;
                  uint64_t v595 = v846;
                  uint64_t v593 = v871;
                  goto LABEL_686;
                }
                unint64_t v602 = HIWORD(v607);
                unsigned int v611 = bswap32(v607);
                v14->i16[0] = HIWORD(v611);
                v14->i16[1] = v611;
                v14->i16[2] = bswap32(HIDWORD(v607)) >> 16;
                unint64_t v12 = v920;
                int v20 = v923;
                uint64_t v595 = v846;
                uint64_t v593 = v871;
              }
              *int v609 = bswap32(v602) >> 16;
            }
          }
          v16 += v592;
          int v14 = (int8x8_t *)((char *)v14 + v596);
          int32x4_t v612 = (unsigned __int16 *)&v23[8 * v592];
          if ((unint64_t)v612 >= v12) {
            uint64_t v613 = v597;
          }
          else {
            uint64_t v613 = 0;
          }
          v594 += v593 + v613;
          int32x4_t v23 = (char *)&v612[4 * v613];
          unint64_t v7 = (unsigned __int16 *)((char *)v7 + v595);
          --v598;
        }
        while (v598);
        if (v874)
        {
          unsigned int v614 = (char *)&v881[4 * v879];
          uint64_t v615 = v810;
          if ((unint64_t)v614 < v874) {
            uint64_t v615 = 0;
          }
          uint32x4_t v594 = &v880[v877 + v615];
          uint64_t v616 = v826;
          if ((unint64_t)v614 < v874) {
            uint64_t v616 = 0;
          }
          int32x4_t v23 = &v614[8 * v616];
          v12 += 8 * v616 + 8 * v879;
          v880 += v877 + v615;
          int v881 = (unsigned __int16 *)v23;
        }
        else
        {
          v23 += 8 * v879;
          v594 += v877;
        }
        v16 += v876;
        v14 += v875;
        v7 += v873;
        if (!--v882) {
          return;
        }
      }
    case 27:
      uint64_t v617 = v25;
      uint64_t v618 = v20;
      unint64_t v619 = v880;
      uint64_t v827 = -(v879 * v22);
      uint64_t v811 = -(uint64_t)(v877 * v22);
      uint64_t v620 = 2 * v8;
      uint64_t v621 = 8 * v25;
      uint64_t v622 = -(uint64_t)v21;
      uint64_t v847 = v620;
      uint64_t v872 = v20;
      break;
    default:
      return;
  }
  do
  {
    int v623 = v878;
    unint64_t v921 = v12;
    do
    {
      if (*v16)
      {
        unsigned int v624 = v20 ? bswap32(*v619) >> 16 : 0xFFFF;
        int v625 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        unsigned int v626 = v624 - ((v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16);
        LODWORD(v627) = (unsigned __int16)(v624 - ((v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16));
        if ((_WORD)v624 != (v624 * v625 + ((v624 * v625) >> 16) + 1) >> 16)
        {
          unsigned int v628 = bswap32(*((unsigned __int16 *)v23 + 3)) >> 16;
          unsigned int v629 = bswap32(*((unsigned __int16 *)v23 + 2)) >> 16;
          unsigned int v630 = bswap32(*((unsigned __int16 *)v23 + 1) | (*(unsigned __int16 *)v23 << 16));
          unsigned int v631 = HIWORD(v630);
          unint64_t v632 = ((unint64_t)(v628 - ((v625 * v628 + ((v625 * v628) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v629 - ((v625 * v629 + ((v625 * v629) >> 16) + 1) >> 16)) << 32) | ((v631 - ((v631 * v625 + ((v631 * v625) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v630 - (((unsigned __int16)v630 * v625 + (((unsigned __int16)v630 * v625) >> 16) + 1) >> 16));
          if (v8)
          {
            if (!*v7) {
              goto LABEL_715;
            }
            unsigned int v633 = __rev16(*v7);
          }
          else
          {
            unsigned int v633 = 0xFFFF;
          }
          uint64_t v634 = (_WORD *)v14 + 3;
          unint64_t v635 = PDAluminosityPDA_11723(((unint64_t)(bswap32(v14->u16[2]) >> 16) << 32) | ((unint64_t)(bswap32(v14->u16[3]) >> 16) << 48) | bswap32(v14->u16[1]) & 0xFFFF0000 | (unint64_t)(bswap32(v14->u16[0]) >> 16), v633, v632, (unsigned __int16)v626);
          unint64_t v632 = v635;
          int v8 = v883;
          if (!v883)
          {
            unint64_t v627 = HIWORD(v635);
            unsigned int v637 = bswap32(v635);
            v14->i16[0] = HIWORD(v637);
            v14->i16[1] = v637;
            v14->i16[2] = bswap32(HIDWORD(v635)) >> 16;
            unint64_t v12 = v921;
            int v20 = v923;
            uint64_t v620 = v847;
            uint64_t v618 = v872;
            goto LABEL_717;
          }
          unint64_t v12 = v921;
          int v20 = v923;
          uint64_t v620 = v847;
          uint64_t v618 = v872;
LABEL_715:
          unsigned int v636 = bswap32(v632);
          v14->i16[0] = HIWORD(v636);
          v14->i16[1] = v636;
          v14->i16[2] = bswap32(HIDWORD(v632)) >> 16;
          v14->i16[3] = __rev16(HIWORD(v632));
          uint64_t v634 = v7;
LABEL_717:
          *uint64_t v634 = bswap32(v627) >> 16;
        }
      }
      v16 += v617;
      int v14 = (int8x8_t *)((char *)v14 + v621);
      int v638 = (unsigned __int16 *)&v23[8 * v617];
      if ((unint64_t)v638 >= v12) {
        uint64_t v639 = v622;
      }
      else {
        uint64_t v639 = 0;
      }
      v619 += v618 + v639;
      int32x4_t v23 = (char *)&v638[4 * v639];
      unint64_t v7 = (unsigned __int16 *)((char *)v7 + v620);
      --v623;
    }
    while (v623);
    if (v874)
    {
      unsigned int v640 = (char *)&v881[4 * v879];
      uint64_t v641 = v811;
      if ((unint64_t)v640 < v874) {
        uint64_t v641 = 0;
      }
      unint64_t v619 = &v880[v877 + v641];
      uint64_t v642 = v827;
      if ((unint64_t)v640 < v874) {
        uint64_t v642 = 0;
      }
      int32x4_t v23 = &v640[8 * v642];
      v12 += 8 * v642 + 8 * v879;
      v880 += v877 + v641;
      int v881 = (unsigned __int16 *)v23;
    }
    else
    {
      v23 += 8 * v879;
      v619 += v877;
    }
    v16 += v876;
    v14 += v875;
    v7 += v873;
    --v882;
  }
  while (v882);
}

_DWORD *CMYK64_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11 = PIXELCONSTANT_11727(*(float **)(*(void *)a1 + 64), a4, a5, a6, a7, a8, a9);
  unsigned __int16 v13 = v12;
  if (a2 && a3 > 0xB || (a2 = malloc_type_malloc(0x3CuLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDC20;
    a2[6] = 0;
    unsigned int v14 = bswap32(v11);
    *((_WORD *)a2 + 24) = HIWORD(v14);
    *((void *)a2 + 2) = 1;
    *((void *)a2 + 4) = a2 + 12;
    *((_WORD *)a2 + 25) = v14;
    *((_WORD *)a2 + 26) = bswap32(HIDWORD(v11)) >> 16;
    *((_WORD *)a2 + 27) = __rev16(HIWORD(v11));
    if (v13 == 0xFFFF)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[14] = bswap32(v13 | (v13 << 16));
      *((void *)a2 + 5) = a2 + 14;
    }
  }
  return a2;
}

CFStringRef CGPDFArchiveCopyDebugDesc(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CGPDFArchive (%p)>", a1);
}

void CGPDFArchiveFinalize(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
}

uint64_t CGPDFArchiveCreate()
{
  if (!CGPDFArchiveGetTypeID_id) {
    CGPDFArchiveGetTypeID_id = _CFRuntimeRegisterClass();
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = objc_alloc_init(CPArchive);
  return Instance;
}

CFTypeRef CGPDFArchiveRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void CGPDFArchiveRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFArchiveAddSelection(uint64_t result, uint64_t a2)
{
  if (result) {
    return [*(id *)(result + 16) addSelection:a2];
  }
  return result;
}

uint64_t CGPDFArchiveGetPlainText(uint64_t result)
{
  if (result) {
    return [*(id *)(result + 16) plainText];
  }
  return result;
}

uint64_t CGPDFArchiveGetHTML(uint64_t result)
{
  if (result) {
    return [*(id *)(result + 16) html];
  }
  return result;
}

uint64_t CGPDFArchiveGetWebArchiveData(uint64_t result)
{
  if (result) {
    return [*(id *)(result + 16) webArchiveData];
  }
  return result;
}

uint64_t CGPDFArchiveGetStructuredString(uint64_t result)
{
  if (result) {
    return [*(id *)(result + 16) structuredString];
  }
  return result;
}

uint64_t CGPDFArchiveGetRTFDData(uint64_t result)
{
  if (result) {
    return [*(id *)(result + 16) RTFDData];
  }
  return result;
}

char *lzw_decoder_create(const void *a1, char a2)
{
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x4450uLL, 0x1030040EB8D5A71uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    unint64_t v6 = v4 + 17444;
    if (a1) {
      CFRetain(a1);
    }
    *(void *)uint64_t v5 = a1;
    v5[10] = a2;
    *((_DWORD *)v5 + 264) = 9;
    *unint64_t v6 = 258;
    *((_WORD *)v5 + 8724) = 0;
  }
  return v5;
}

void lzw_decoder_release(void **a1)
{
  if (a1)
  {
    CFAllocatorRef v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1[2185]);
    free(a1);
  }
}

uint64_t lzw_read_code(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (unsigned int *)(a1 + 17452);
  int v9 = *(_DWORD *)(a1 + 17456);
  int v10 = *(_DWORD *)(a1 + 1056);
  if (v9 >= v10)
  {
    unsigned int v13 = *v8;
LABEL_6:
    unsigned int v14 = v9 - v10;
    v8[1] = v14;
    return (unsigned __int16)((v13 >> v14) & ~(-1 << v10));
  }
  else
  {
    while (1)
    {
      int v12 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (v12 == -1) {
        break;
      }
      unsigned int v13 = v12 | (*v8 << 8);
      int v9 = v8[1] + 8;
      *int v8 = v13;
      v8[1] = v9;
      int v10 = *(_DWORD *)(a1 + 1056);
      if (v9 >= v10) {
        goto LABEL_6;
      }
    }
    pdf_error("LZW decode: encountered unexpected EOF.");
    *(unsigned char *)(a1 + 9) = 1;
    LOWORD(v15) = 257;
  }
  return (unsigned __int16)v15;
}

void *lzw_push(void *result, char a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *((void *)result + 2183);
  size_t v5 = *((void *)result + 2184);
  if (v4 == v5)
  {
    size_t v5 = 2 * v4 + 10;
    unint64_t v6 = (char *)malloc_type_realloc(*((void **)result + 2185), v5, 0x82892DD4uLL);
    v3[2185] = v6;
    uint64_t result = memmove(&v6[v5 - v3[2184]], v6, v3[2184]);
    v3[2184] = v5;
    uint64_t v4 = v3[2183];
  }
  uint64_t v7 = v4 + 1;
  v3[2183] = v7;
  *(unsigned char *)(v3[2185] + v5 - v7) = a2;
  return result;
}

uint64_t CGPDFFormCreate(CGPDFDictionary *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (CGPDFFormGetTypeID_onceToken != -1) {
    dispatch_once(&CGPDFFormGetTypeID_onceToken, &__block_literal_global_11840);
  }
  uint64_t cftype = pdf_create_cftype();
  uint64_t v3 = cftype;
  if (cftype)
  {
    CGPDFInteger value = 0;
    *(void *)(cftype + 16) = a1;
    if (a1) {
      a1 = (CGPDFDictionary *)*((void *)a1 + 6);
    }
    if (CGPDFDictionaryGetInteger(a1, "FormType", &value) && value != 1)
    {
LABEL_13:
      CFRelease((CFTypeRef)v3);
      return 0;
    }
    if (!CGPDFDictionaryGetRect(a1, "BBox", (double *)(v3 + 24)))
    {
      goto LABEL_13;
    }
    if (CGPDFDictionaryGetNumbers(a1, "Matrix", (uint64_t)v7, (CGPDFArray *)6))
    {
      long long v4 = v7[1];
      *(_OWORD *)(v3 + 56) = v7[0];
      *(_OWORD *)(v3 + 72) = v4;
      *(_OWORD *)(v3 + 88) = v7[2];
    }
    else
    {
      *(CGAffineTransform *)(v3 + 56) = CGAffineTransformIdentity;
    }
    if (!CGPDFDictionaryGetDictionary(a1, "Resources", (CGPDFDictionaryRef *)(v3 + 104))) {
      *(void *)(v3 + 104) = 0;
    }
  }
  return v3;
}

uint64_t __CGPDFFormGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFFormGetTypeID_class);
  CGPDFFormGetTypeID_id = result;
  return result;
}

void CGPDFFormRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFTypeRef CGPDFFormRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t CGPDFFormGetStream(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

CGFloat CGPDFFormGetBBox(uint64_t a1)
{
  v1 = &CGRectNull;
  if (a1) {
    v1 = (const CGRect *)(a1 + 24);
  }
  return v1->origin.x;
}

__n128 CGPDFFormGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  CFAllocatorRef v2 = (const CGAffineTransform *)(a1 + 56);
  if (!a1) {
    CFAllocatorRef v2 = &CGAffineTransformIdentity;
  }
  long long v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGPDFFormGetResources(uint64_t result)
{
  if (result) {
    return *(void *)(result + 104);
  }
  return result;
}

void shape_enum_alloc(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  unint64_t v6 = a2;
  shape_enum_allocate(a2, 0, a4);
  if (v6 != (_DWORD *)&the_empty_shape && v6[v6[1]] != 0x7FFFFFFF)
  {
    *(_DWORD *)(v7 + 4) = a3;
    if (a4 < 0)
    {
      uint64_t v8 = (_DWORD *)(v7 + 56);
      while (*v6 != 0x7FFFFFFF)
      {
        uint64_t v9 = (int)v6[1];
        *v8++ = -(int)v9;
        v6 += v9;
      }
      *(void *)(v7 + 32) = v6 - 2;
      *(void *)(v7 + 40) = v6;
      *(void *)(v7 + 48) = v8 - 1;
    }
    else
    {
      *(void *)(v7 + 32) = v6;
      *(void *)(v7 + 40) = v6 + 2;
    }
  }
}

uint64_t shape_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  size_t v5 = *(_DWORD **)(a1 + 32);
  if (v5)
  {
    int v6 = *(_DWORD *)(a1 + 8);
    uint64_t v7 = *(void *)(a1 + 48);
    if (v7)
    {
      if (!v6)
      {
        uint64_t v8 = (int *)(v7 - 4);
        while (1)
        {
          uint64_t v9 = v5;
          int v10 = v8;
          uint64_t v11 = *v8;
          v5 += v11;
          if (*v5 == 0x80000000) {
            break;
          }
          --v8;
          if (v11 != -2)
          {
            int v6 = -2 - v11;
            *(void *)(a1 + 32) = v5;
            *(void *)(a1 + 40) = v9;
            *(void *)(a1 + 48) = v10;
            goto LABEL_13;
          }
        }
        size_t v5 = 0;
        *(void *)(a1 + 48) = v8;
LABEL_20:
        *(void *)(a1 + 32) = 0;
        *(void *)(a1 + 40) = v9;
        return (uint64_t)v5;
      }
    }
    else if (!v6)
    {
      uint64_t v9 = *(_DWORD **)(a1 + 40);
      while (1)
      {
        size_t v5 = v9;
        uint64_t v12 = (int)v9[1];
        v9 += v12;
        if (*v9 == 0x7FFFFFFF) {
          break;
        }
        int v6 = v12 - 2;
        if (v6)
        {
          *(void *)(a1 + 32) = v5;
          *(void *)(a1 + 40) = v9;
          goto LABEL_13;
        }
      }
      size_t v5 = 0;
      goto LABEL_20;
    }
LABEL_13:
    *(_DWORD *)(a1 + 8) = v6 - 2;
    if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
    {
      unsigned int v14 = &v5[v6];
      unsigned int v13 = *(_DWORD **)(a1 + 40);
    }
    else
    {
      unsigned int v13 = *(_DWORD **)(a1 + 40);
      unsigned int v14 = &v13[-v6];
    }
    *a2 = *v14;
    *a4 = v14[1];
    *a3 = *v5;
    *a5 = *v13;
    return 1;
  }
  return (uint64_t)v5;
}

double shape_enum_allocate(_DWORD *a1, int a2, int a3)
{
  if (a3 < 0 && *a1 != 0x7FFFFFFF)
  {
    uint64_t v5 = 0;
    do
    {
      ++v5;
      a1 += (int)a1[1];
    }
    while (*a1 != 0x7FFFFFFF);
    size_t v4 = 4 * v5 + 56;
  }
  else
  {
    size_t v4 = 56;
  }
  int v6 = (char *)malloc_type_malloc(v4, 0xEB07EEC6uLL);
  *(_DWORD *)int v6 = a2;
  *(void *)&double result = 1;
  *(_OWORD *)(v6 + 4) = xmmword_1850CDCD0;
  *(int32x2_t *)(v6 + 20) = vdup_n_s32(0x7FFFFFFEu);
  *((void *)v6 + 5) = 0;
  *((void *)v6 + 6) = 0;
  *((void *)v6 + 4) = 0;
  return result;
}

void shape_enum_free(int a1, void *a2)
{
}

uint64_t shape_forward_enum@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  a2[2] = 0;
  if ((_UNKNOWN *)result == &the_empty_shape)
  {
    CFAllocatorRef v2 = &unk_185293428;
    BOOL v3 = 1;
    goto LABEL_5;
  }
  CFAllocatorRef v2 = (void *)(result + 8);
  BOOL v3 = *(_DWORD *)(result + 4 * *(int *)(result + 4)) == 0x7FFFFFFF;
  if (*(_DWORD *)(result + 4 * *(int *)(result + 4)) == 0x7FFFFFFF) {
LABEL_5:
  }
    double result = 0;
  if (v3) {
    CFAllocatorRef v2 = 0;
  }
  *a2 = result;
  a2[1] = v2;
  return result;
}

uint64_t shape_forward_enum_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v5 = *(_DWORD **)a1;
  if (*(void *)a1)
  {
    int v6 = *(_DWORD *)(a1 + 16);
    uint64_t v7 = *(_DWORD **)(a1 + 8);
    if (v6)
    {
LABEL_6:
      *(_DWORD *)(a1 + 16) = v6 - 2;
      uint64_t v9 = &v7[-v6];
      *a2 = *v9;
      *a4 = v9[1];
      *a3 = *v5;
      *a5 = *v7;
      return 1;
    }
    else
    {
      while (1)
      {
        uint64_t v5 = v7;
        uint64_t v8 = (int)v7[1];
        v7 += v8;
        if (*v7 == 0x7FFFFFFF) {
          break;
        }
        int v6 = v8 - 2;
        if (v6)
        {
          *(void *)a1 = v5;
          *(void *)(a1 + 8) = v7;
          goto LABEL_6;
        }
      }
      uint64_t v5 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = v7;
    }
  }
  return (uint64_t)v5;
}

void *shape_enum_binary_init(void *result, uint64_t a2)
{
  CFAllocatorRef v2 = (_DWORD *)(a2 + 4 * *(int *)(a2 + 4));
  if (*v2 == 0x7FFFFFFF || (v3 = (int)v2[1], size_t v4 = &v2[v3], *v4 == 0x7FFFFFFF))
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      int v5 = v5 + (int)v3 / 2 - 1;
      uint64_t v3 = (int)v4[1];
      v4 += v3;
    }
    while (*v4 != 0x7FFFFFFF);
  }
  do
  {
    int v6 = v5;
    v5 &= v5 - 1;
  }
  while (v5);
  result[1] = 0;
  result[2] = a2;
  *double result = 0;
  result[3] = (4 * v6);
  return result;
}

uint64_t shape_enum_binary_next(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v5 = *(_DWORD *)(a1 + 24);
  if ((int)v5 < 2) {
    return 0;
  }
  uint64_t v7 = *(_DWORD **)a1;
  if (*(void *)a1)
  {
    uint64_t v8 = *(_DWORD **)(a1 + 8);
    int v9 = *(_DWORD *)(a1 + 28);
    int v10 = 2 * v5;
    unsigned int v11 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    unsigned int v11 = v5 >> 1;
    uint64_t v7 = *(_DWORD **)(a1 + 16);
    uint64_t v12 = (int)v7[1];
    *(_DWORD *)(a1 + 24) = v5 >> 1;
    if (v5 < 4) {
      return 0;
    }
    uint64_t v8 = &v7[v12];
    int v9 = v12 - 2;
    int v10 = v11 - 2;
  }
  if (v9 <= v10)
  {
    do
    {
      uint64_t v14 = (int)v8[1];
      unsigned int v13 = &v8[v14];
      if (*v13 == 0x7FFFFFFF)
      {
        uint64_t v8 = *(_DWORD **)(a1 + 16);
        uint64_t v15 = (int)v8[1];
        *(_DWORD *)(a1 + 24) = v11 >> 1;
        if (v11 < 4) {
          return 0;
        }
        int v10 = (v11 >> 1) - 2;
        v11 >>= 1;
        LODWORD(v14) = v15;
        unsigned int v13 = &v8[v15];
      }
      else
      {
        v10 -= v9;
      }
      uint64_t v7 = v8;
      int v9 = v14 - 2;
      uint64_t v8 = v13;
    }
    while ((int)v14 - 2 <= v10);
  }
  else
  {
    unsigned int v13 = v8;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v13;
  *(_DWORD *)(a1 + 28) = v9 - v10;
  int v16 = &v13[-(v9 - v10)];
  *a3 = *v7;
  *a5 = *v13;
  *a2 = *v16;
  *a4 = v16[1];
  return 1;
}

double shape_enum_clip_alloc(uint64_t a1, uint64_t a2, int *a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  if (!a3) {
    return result;
  }
  int v10 = a3;
  if (*a3 != 0x80000000) {
    return result;
  }
  uint64_t v11 = a3[1];
  if ((int)v11 < 1) {
    return result;
  }
  BOOL v18 = a9 < 1 || a10 < 1;
  if (a3 == (int *)&the_empty_shape)
  {
    BOOL v19 = 1;
    if (v18)
    {
LABEL_18:
      return shape_enum_allocate(a3, 2, a5);
    }
  }
  else
  {
    BOOL v19 = a3[v11] == 0x7FFFFFFF;
    if (v18) {
      goto LABEL_18;
    }
  }
  char v20 = !v19;
  if (a6 < 1) {
    char v20 = 1;
  }
  if ((v20 & 1) == 0) {
    goto LABEL_18;
  }
  if (v19)
  {
    if (a6 >= 0) {
      int v22 = 3;
    }
    else {
      int v22 = 4;
    }
    double result = shape_enum_allocate(a3, v22, a5);
    *(_DWORD *)(v23 + 4) = 0;
    *(_DWORD *)(v23 + 12) = a7;
    *(_DWORD *)(v23 + 16) = a8;
    *(_DWORD *)(v23 + 20) = a9 + a7;
    *(_DWORD *)(v23 + 24) = a10 + a8;
    *(void *)(v23 + 32) = &the_empty_shape;
    *(void *)(v23 + 40) = &the_empty_shape;
  }
  else
  {
    if (a6) {
      int v24 = 4;
    }
    else {
      int v24 = 3;
    }
    if (a6 <= 0) {
      int v25 = v24;
    }
    else {
      int v25 = 2;
    }
    double result = shape_enum_allocate(a3, v25, a5);
    *(_DWORD *)(v26 + 4) = a4;
    *(_DWORD *)(v26 + 12) = a7;
    *(_DWORD *)(v26 + 16) = a8;
    *(_DWORD *)(v26 + 20) = a9 + a7;
    *(_DWORD *)(v26 + 24) = a10 + a8;
    if (a5 < 0)
    {
      int v27 = (_DWORD *)(v26 + 56);
      for (int i = *v10; i != 0x7FFFFFFF; int i = *v10)
      {
        uint64_t v29 = v10[1];
        *v27++ = -(int)v29;
        v10 += v29;
      }
      *(void *)(v26 + 40) = v10;
      if (a6 < 1)
      {
        *(void *)(v26 + 32) = v10;
      }
      else
      {
        *(void *)(v26 + 32) = v10 - 2;
        --v27;
      }
      *(void *)(v26 + 48) = v27;
    }
    else
    {
      *(void *)(v26 + 32) = v10;
      *(void *)(v26 + 40) = &v10[2 * (a6 > 0)];
    }
  }
  return result;
}

uint64_t shape_enum_clip_next(uint64_t a1, int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v5 = *(char **)(a1 + 32);
  if (!v5) {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  int v7 = *(_DWORD *)(a1 + 8);
  int v8 = *(_DWORD *)a1;
  int v10 = *(char **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  if (*(_DWORD *)a1 != 2)
  {
    if (v8 < 3) {
      return 0;
    }
    uint64_t v27 = *(void *)(a1 + 48);
    if (v7) {
      goto LABEL_42;
    }
    while (1)
    {
      if (v9)
      {
        uint64_t v29 = *(int *)(v27 - 4);
        v27 -= 4;
        *(void *)(a1 + 40) = v5;
        *(void *)(a1 + 48) = v27;
        int v10 = &v5[4 * v29];
        if (*(_DWORD *)v10 == 0x80000000) {
          uint64_t v30 = 0;
        }
        else {
          uint64_t v30 = v10;
        }
      }
      else
      {
        uint64_t v30 = 0;
        unsigned int v5 = &v10[4 * *((int *)v10 + 1)];
        *(void *)(a1 + 32) = v10;
        *(void *)(a1 + 40) = v5;
        if (*(_DWORD *)v5 != 0x7FFFFFFF) {
          goto LABEL_39;
        }
      }
      *(void *)(a1 + 32) = v30;
LABEL_39:
      uint64_t v31 = v5;
      unint64_t v32 = (unint64_t)(v5 - v10) >> 2;
      int v7 = v32 - 1;
      if (v32 == 2) {
        int v7 = 0;
      }
      unsigned int v5 = v10;
      int v10 = v31;
LABEL_42:
      int v33 = *(_DWORD *)(a1 + 16);
      int v34 = *(_DWORD *)v10;
      int v35 = *(_DWORD *)(a1 + 24);
      int v36 = *(_DWORD *)v5;
      if (v9)
      {
        if (v36 < v35)
        {
          if (v34 > v33) {
            goto LABEL_48;
          }
          return 0;
        }
      }
      else if (v34 > v33)
      {
        if (v36 < v35)
        {
LABEL_48:
          if (v34 >= v35) {
            int v34 = *(_DWORD *)(a1 + 24);
          }
          if (v36 <= v33) {
            int v36 = *(_DWORD *)(a1 + 16);
          }
          *a5 = v34 - v36;
          int v37 = v35 - v34;
          int v38 = v36 - v33;
          if (v9) {
            int v38 = v37;
          }
          *a3 = v38;
          int v22 = *(_DWORD *)(a1 + 12);
          int v25 = *(_DWORD *)(a1 + 20);
          if (!v7 || *((_DWORD *)v5 + 2) >= v25 || *((_DWORD *)v10 - 1) <= v22)
          {
            *(_DWORD *)(a1 + 8) = 0;
            *a2 = 0;
            *a4 = v25 - v22;
            return 0xFFFFFFFFLL;
          }
          uint64_t v39 = (int *)&v5[4 * v7];
          uint64_t v40 = (int *)&v10[-4 * v7--];
LABEL_58:
          if (v6 >= 0) {
            int8x16_t v41 = v40;
          }
          else {
            int8x16_t v41 = v39;
          }
          if (v41 == (int *)(v5 + 4))
          {
            int v24 = -2147483647;
            int v23 = *((_DWORD *)v5 + 2);
          }
          else if (v41 == (int *)(v10 - 4))
          {
            int v23 = 2147483646;
            int v24 = *((_DWORD *)v10 - 1);
          }
          else
          {
            int v42 = v41;
            int v24 = *v41;
            int v23 = v42[1];
          }
          if (v6 < 1)
          {
            if (v24 < v25)
            {
              if (v23 <= v22) {
                continue;
              }
              goto LABEL_72;
            }
          }
          else if (v23 > v22)
          {
            if (v24 >= v25) {
              continue;
            }
LABEL_72:
            if ((v7 & 1) == 0 || v8 != 4)
            {
              if (v7) {
                uint64_t v26 = 254;
              }
              else {
                uint64_t v26 = 0xFFFFFFFFLL;
              }
              goto LABEL_78;
            }
          }
          --v7;
          --v39;
          ++v40;
          goto LABEL_58;
        }
        return 0;
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 48);
  while (1)
  {
    if (!v7)
    {
      while (1)
      {
        if (v9)
        {
          uint64_t v12 = *(int *)(v11 - 4);
          v11 -= 4;
          *(void *)(a1 + 40) = v5;
          *(void *)(a1 + 48) = v11;
          unsigned int v13 = &v5[4 * v12];
          *(void *)(a1 + 32) = v13;
          if (*(_DWORD *)v13 == 0x80000000) {
            goto LABEL_30;
          }
          int v10 = v5;
        }
        else
        {
          *(void *)(a1 + 32) = v10;
          unsigned int v13 = v10;
          v10 += 4 * *((int *)v10 + 1);
          *(void *)(a1 + 40) = v10;
          if (*(_DWORD *)v10 == 0x7FFFFFFF)
          {
LABEL_30:
            uint64_t v26 = 0;
            *(void *)(a1 + 32) = 0;
            return v26;
          }
        }
        unsigned int v5 = v13;
        int v7 = ((unint64_t)(v10 - v13) >> 2) - 2;
        if (((unint64_t)(v10 - v13) >> 2) != 2)
        {
          unsigned int v5 = v13;
          break;
        }
      }
    }
    int v14 = *(_DWORD *)(a1 + 16);
    int v15 = *(_DWORD *)v10;
    int v16 = *(_DWORD *)(a1 + 24);
    int v17 = *(_DWORD *)v5;
    BOOL v18 = (int *)&v10[-4 * v7];
    if (v6 <= 0) {
      BOOL v18 = (int *)&v5[4 * v7];
    }
    v7 -= 2;
    if (v15 > v14 && v17 < v16)
    {
      if (v15 >= v16) {
        int v15 = *(_DWORD *)(a1 + 24);
      }
      if (v17 <= v14) {
        int v17 = *(_DWORD *)(a1 + 16);
      }
      *a5 = v15 - v17;
      int v20 = v16 - v15;
      int v21 = v17 - v14;
      if (v9) {
        int v21 = v20;
      }
      *a3 = v21;
      int v22 = *(_DWORD *)(a1 + 12);
      int v23 = v18[1];
      if (v23 > v22)
      {
        int v24 = *v18;
        int v25 = *(_DWORD *)(a1 + 20);
        if (v24 < v25) {
          break;
        }
      }
    }
  }
  uint64_t v26 = 2;
LABEL_78:
  if (v23 >= v25) {
    int v43 = v25;
  }
  else {
    int v43 = v23;
  }
  if (v24 <= v22) {
    int v44 = v22;
  }
  else {
    int v44 = v24;
  }
  *a4 = v43 - v44;
  int v45 = v25 - v43;
  int v46 = v44 - v22;
  if (v6 >= 0) {
    int v47 = v46;
  }
  else {
    int v47 = v45;
  }
  *a2 = v47;
  *(_DWORD *)(a1 + 8) = v7;
  return v26;
}

uint64_t shape_enum_clip_scan(uint64_t a1, _DWORD *a2)
{
  CFAllocatorRef v2 = *(int **)(a1 + 32);
  if (*(int *)a1 < 2 || v2 == 0) {
    return 0;
  }
  uint64_t v5 = a1;
  int v38 = (char *)(a2 + 4);
  int v7 = *(int **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  int v36 = a2;
  uint64_t v34 = v6;
  while (v6)
  {
    uint64_t v8 = *(void *)(v5 + 48);
    uint64_t v9 = *(int *)(v8 - 4);
    *(void *)(v5 + 40) = v2;
    *(void *)(v5 + 48) = v8 - 4;
    int v10 = &v2[v9];
    *(void *)(v5 + 32) = v10;
    int v7 = v2;
    if (*v10 == 0x80000000) {
      goto LABEL_54;
    }
LABEL_11:
    uint64_t v11 = v10 + 2;
    CFAllocatorRef v2 = v10;
    if (v10 + 2 != v7)
    {
      int v12 = *(_DWORD *)(v5 + 16);
      int v13 = *(_DWORD *)(v5 + 24);
      int v14 = *v10;
      BOOL v15 = *v7 > v12 && v14 < v13;
      CFAllocatorRef v2 = v10;
      if (v15)
      {
        if (*v7 >= v13) {
          int v16 = *(_DWORD *)(v5 + 24);
        }
        else {
          int v16 = *v7;
        }
        if (v14 <= v12) {
          int v17 = *(_DWORD *)(v5 + 16);
        }
        else {
          int v17 = *v10;
        }
        int v18 = v16 - v17;
        int v19 = v16 - v13;
        int v20 = v17 - v12;
        if (v6) {
          int v20 = v19;
        }
        *a2 = v20;
        a2[1] = v18;
        CFAllocatorRef v2 = v10;
        if (v11 < v7)
        {
          int v21 = *(_DWORD *)(v5 + 12);
          int v22 = *(_DWORD *)(v5 + 20);
          int v37 = v10;
          int v23 = -1;
          int v39 = -1;
          do
          {
            int v24 = *v11;
            int v25 = v11[1];
            if (v25 > v21 && v24 < v22)
            {
              int v27 = v25 >= v22 ? v22 : v11[1];
              int v28 = v24 <= v21 ? v21 : *v11;
              int v29 = v27 - v28;
              if (v27 != v28)
              {
                int v30 = v39;
                if (v39 < 0)
                {
                  bzero(v38, v22 - v21);
                  int v30 = v28;
                }
                int v39 = v30;
                uint64_t v31 = &v38[v28 - v21];
                do
                {
                  if ((v31 & 3) == 0)
                  {
                    if (v29 >= 4)
                    {
                      if (v29 >= 7) {
                        int v32 = 7;
                      }
                      else {
                        int v32 = v29;
                      }
                      uint64_t v33 = (v29 - v32 + 3) & 0xFFFFFFFC;
                      memset(v31, 255, v33 + 4);
                      int v29 = v29 - v33 - 4;
                      v31 += v33 + 4;
                    }
                    if (!v29) {
                      break;
                    }
                  }
                  *v31++ = -1;
                  --v29;
                }
                while (v29);
                int v23 = v27;
              }
            }
            v11 += 2;
          }
          while (v11 < v7);
          a2 = v36;
          CFAllocatorRef v2 = v37;
          uint64_t v6 = v34;
          uint64_t v5 = a1;
          if ((v39 & 0x80000000) == 0)
          {
            v36[2] = v39 - v21;
            v36[3] = v23 - v39;
            return 1;
          }
        }
      }
    }
  }
  *(void *)(v5 + 32) = v7;
  int v10 = v7;
  v7 += v7[1];
  *(void *)(v5 + 40) = v7;
  if (*v7 != 0x7FFFFFFF) {
    goto LABEL_11;
  }
LABEL_54:
  uint64_t result = 0;
  *(void *)(v5 + 32) = 0;
  return result;
}

uint64_t img_decode_read_alpha(uint64_t a1, unsigned int a2, uint64_t a3, uint16x4_t **a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t v12 = img_decode_read(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  if ((int)v12 < 1) {
    return 0;
  }
  uint64_t v15 = v12;
  int v16 = *(_DWORD *)(a1 + 40);
  if (v16 == 16) {
    int v17 = 2;
  }
  else {
    int v17 = 1;
  }
  if (v16 == 32) {
    int v18 = 4;
  }
  else {
    int v18 = v17;
  }
  if (*(_DWORD *)(a1 + 208) == 5) {
    int v19 = 5;
  }
  else {
    int v19 = v18;
  }
  uint64_t v20 = *(unsigned int *)(a1 + 44);
  if (v20 == 9) {
    int v21 = 8;
  }
  else {
    int v21 = *(_DWORD *)(a1 + 44);
  }
  if (v20 == 4) {
    int v22 = 2;
  }
  else {
    int v22 = v21;
  }
  if (v20 == 3) {
    int v23 = 1;
  }
  else {
    int v23 = v22;
  }
  img_alpha(*(_DWORD *)(a1 + 48), v12, *(unsigned int *)(a1 + 36), v23, (unsigned __int8 **)a4, a5, v20, (unsigned __int8 **)a4, v13, v14, a5, v19);
  uint64_t v26 = *(int **)(a1 + 168);
  if (v26) {
    decode_data(v26, *(unsigned int *)(a1 + 48), v15, (char *)*a4, *a5, *a4, *a5, a4[1], v24, v25, a5[1]);
  }
  int v27 = *(int **)(a1 + 176);
  if (v27) {
    decode_data(v27, *(unsigned int *)(a1 + 48), v15, (char *)a4[1], a5[1], a4[1], a5[1], 0, v24, v25, 0);
  }
  return v15;
}

void img_alpha(int a1, int a2, uint64_t a3, int a4, unsigned __int8 **a5, int *a6, uint64_t a7, unsigned __int8 **a8, float _S0, float _S1, int *a11, int a12)
{
  uint64_t v15 = a3;
  unsigned int v16 = a4 - 1;
  int v377 = a2;
  if ((a4 - 1) > 7)
  {
    uint64_t v18 = 0;
    int v17 = -1;
  }
  else
  {
    int v17 = dword_1852117C8[v16];
    uint64_t v18 = dword_1852117E8[v16];
  }
  unsigned int v19 = a7 - 1;
  if ((a7 - 1) > 7)
  {
    int v21 = 0;
    uint64_t v20 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v20 = dword_1852117C8[v19];
    int v21 = dword_1852117E8[v19];
  }
  if (v21 == v18 && *a5 == *a8 && *a6 == *a11 && a5[1] == a8[1] && a6[1] == a11[1])
  {
    if (v17 + v20) {
      return;
    }
  }
  else if (v20 + v17)
  {
    uint64_t v20 = 0;
  }
  else
  {
    uint64_t v20 = v20;
  }
  switch(a12)
  {
    case 1:
      if (v21 != v18)
      {
        int v42 = *a8;
        if (a3 != 3 || v18)
        {
          int v43 = a8[1];
          int v44 = *a11;
        }
        else
        {
          int v43 = a8[1];
          int v44 = *a11;
          if (v42 == v43)
          {
            int v43 = *a8;
            if (v44 == a11[1])
            {
              uint64_t v45 = v44;
              if ((int)v20 >= 0) {
                int v46 = 0;
              }
              else {
                int v46 = inverted_8bit_alpha;
              }
              uint64_t v47 = a6[1];
              uint64_t v48 = *a6 - (uint64_t)(3 * a1);
              BOOL v49 = v21 < 1;
              uint64_t v50 = *a5;
              uint64_t v51 = a5[1];
              if (v21 >= 1) {
                uint64_t v52 = 3;
              }
              else {
                uint64_t v52 = 0;
              }
              uint64_t v53 = 2;
              if (v21 < 1) {
                uint64_t v53 = 3;
              }
              uint64_t v54 = 1;
              if (v21 < 1) {
                uint64_t v54 = 2;
              }
              uint64_t v55 = v52 | 0xC;
              uint64_t v56 = v45 - 4 * a1;
              uint64_t v57 = v47 - a1;
              do
              {
                int v58 = v50 & 3;
                if (v58 > a1 || (((_BYTE)v51 + (_BYTE)v50) & 3) != 0) {
                  int v58 = a1;
                }
                int v59 = v377;
                if (v58 >= 1)
                {
                  unsigned int v60 = v58 + 1;
                  do
                  {
                    unsigned int v62 = *v51++;
                    uint64_t v61 = v62;
                    if (v62)
                    {
                      if (v61 == 255 || !v20)
                      {
                        *(_WORD *)&v42[v49] = *(_WORD *)v50;
                        LOBYTE(v65) = v50[2];
                      }
                      else
                      {
                        if ((int)v20 < 1)
                        {
                          int v66 = v46[v61];
                          __int16 v67 = v50[1] * (_WORD)v66;
                          v42[v49] = (unsigned __int16)(*v50 * (_WORD)v66) >> 8;
                          v42[v54] = HIBYTE(v67);
                          unsigned int v64 = v50[2] * v66;
                        }
                        else
                        {
                          unsigned int v63 = v50[1] * v61 + ((v50[1] * v61) >> 8) + 1;
                          v42[v49] = (unsigned __int16)(*v50 * (_WORD)v61 + ((*v50 * v61) >> 8) + 1) >> 8;
                          v42[v54] = BYTE1(v63);
                          unsigned int v64 = v50[2] * v61 + ((v50[2] * v61) >> 8) + 1;
                        }
                        unsigned int v65 = v64 >> 8;
                      }
                    }
                    else
                    {
                      LOBYTE(v65) = 0;
                      *(_WORD *)&v42[v49] = 0;
                    }
                    v42[v53] = v65;
                    v50 += 3;
                    v42[v52] = v61;
                    v42 += 4;
                    --v60;
                  }
                  while (v60 > 1);
                }
                int v68 = a1 - v58;
                int v69 = v68 >> 2;
                if (v20)
                {
                  if (v68 >= 4)
                  {
                    int v70 = v69 + 1;
                    do
                    {
                      unsigned int v72 = *(_DWORD *)v51;
                      v51 += 4;
                      unint64_t v71 = v72;
                      if (v72)
                      {
                        if (v71 == -1)
                        {
                          unsigned int v74 = *(_DWORD *)v50;
                          unsigned int v73 = *((_DWORD *)v50 + 1);
                          unsigned int v75 = *((_DWORD *)v50 + 2);
                          if (v21 < 1)
                          {
                            *(_DWORD *)int v42 = (v74 << 8) | 0xFF;
                            *((_DWORD *)v42 + 1) = (__PAIR64__(v73, v74) >> 16) | 0xFF;
                            *((_DWORD *)v42 + 2) = (__PAIR64__(v75, v73) >> 8) | 0xFF;
                            *((_DWORD *)v42 + 3) = v75 | 0xFF;
                          }
                          else
                          {
                            *(_DWORD *)int v42 = v74 | 0xFF000000;
                            *((_DWORD *)v42 + 1) = (__PAIR64__(v73, v74) >> 24) | 0xFF000000;
                            *((_DWORD *)v42 + 2) = (__PAIR64__(v75, v73) >> 16) | 0xFF000000;
                            *((_DWORD *)v42 + 3) = (v75 >> 8) | 0xFF000000;
                          }
                        }
                        else
                        {
                          LOBYTE(v76) = v71;
                          if ((v20 & 0x80000000) != 0)
                          {
                            if ((_BYTE)v71)
                            {
                              if (v71 == 255)
                              {
                                *(_WORD *)&v42[v49] = *(_WORD *)v50;
                                LOBYTE(v76) = v50[2];
                              }
                              else
                              {
                                int v89 = inverted_8bit_alpha[v71];
                                __int16 v90 = v50[1] * (_WORD)v89;
                                int v91 = &v42[v49];
                                *int v91 = (unsigned __int16)(*v50 * (_WORD)v89) >> 8;
                                v91[1] = HIBYTE(v90);
                                unsigned int v76 = (v50[2] * v89) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49] = 0;
                            }
                            v42[v49 + 2] = v76;
                            v42[v55 - 12] = v71;
                            LOBYTE(v76) = BYTE1(v71);
                            if (BYTE1(v71))
                            {
                              if (BYTE1(v71) == 255)
                              {
                                *(_WORD *)&v42[v49 + 4] = *(_WORD *)(v50 + 3);
                                LOBYTE(v76) = v50[5];
                              }
                              else
                              {
                                int v92 = inverted_8bit_alpha[BYTE1(v71)];
                                __int16 v93 = v50[4] * (_WORD)v92;
                                int v94 = &v42[v49];
                                v94[4] = (unsigned __int16)(v50[3] * (_WORD)v92) >> 8;
                                v94[5] = HIBYTE(v93);
                                unsigned int v76 = (v50[5] * v92) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49 + 4] = 0;
                            }
                            v42[v49 + 6] = v76;
                            v42[v55 - 8] = BYTE1(v71);
                            LOBYTE(v95) = BYTE2(v71);
                            if (BYTE2(v71))
                            {
                              if (BYTE2(v71) == 255)
                              {
                                *(_WORD *)&v42[v49 + 8] = *((_WORD *)v50 + 3);
                                LOBYTE(v95) = v50[8];
                              }
                              else
                              {
                                int v96 = inverted_8bit_alpha[BYTE2(v71)];
                                __int16 v97 = v50[7] * (_WORD)v96;
                                unsigned int v98 = &v42[v49];
                                v98[8] = (unsigned __int16)(v50[6] * (_WORD)v96) >> 8;
                                v98[9] = HIBYTE(v97);
                                unsigned int v95 = (v50[8] * v96) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49 + 8] = 0;
                            }
                            v42[v49 + 10] = v95;
                            v42[v55 - 4] = BYTE2(v71);
                            if ((v71 >> 24) == 255)
                            {
                              *(_WORD *)&v42[v49 + 12] = *(_WORD *)(v50 + 9);
                              LOBYTE(v86) = v50[11];
                            }
                            else if (BYTE3(v71))
                            {
                              int v99 = inverted_8bit_alpha[v71 >> 24];
                              __int16 v100 = v50[10] * (_WORD)v99;
                              uint64_t v101 = &v42[v49];
                              v101[12] = (unsigned __int16)(v50[9] * (_WORD)v99) >> 8;
                              v101[13] = HIBYTE(v100);
                              unsigned int v86 = (v50[11] * v99) >> 8;
                            }
                            else
                            {
                              LOBYTE(v86) = 0;
                              *(_WORD *)&v42[v49 + 12] = 0;
                            }
                            LOBYTE(v71) = BYTE3(v71);
                          }
                          else
                          {
                            if ((_BYTE)v71)
                            {
                              if (v71 == 255)
                              {
                                *(_WORD *)&v42[v49] = *(_WORD *)v50;
                                LOBYTE(v76) = v50[2];
                              }
                              else
                              {
                                unsigned int v77 = v71 * v50[1];
                                int8x16_t v78 = &v42[v49];
                                *int8x16_t v78 = (unsigned __int16)(v71 * *v50
                                                        + ((v71 * *v50) >> 8)
                                                        + 1) >> 8;
                                v78[1] = (unsigned __int16)(v77 + (v77 >> 8) + 1) >> 8;
                                unsigned int v76 = (v71 * v50[2]
                                     + ((v71 * v50[2]) >> 8)
                                     + 1) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49] = 0;
                            }
                            v42[v49 + 2] = v76;
                            v42[v55 - 12] = v71;
                            LOBYTE(v76) = BYTE1(v71);
                            if (BYTE1(v71))
                            {
                              if (BYTE1(v71) == 255)
                              {
                                *(_WORD *)&v42[v49 + 4] = *(_WORD *)(v50 + 3);
                                LOBYTE(v76) = v50[5];
                              }
                              else
                              {
                                unsigned int v79 = BYTE1(v71) * v50[3];
                                unsigned int v80 = BYTE1(v71) * v50[4];
                                int16x8_t v81 = &v42[v49];
                                v81[4] = (unsigned __int16)(v79 + (v79 >> 8) + 1) >> 8;
                                v81[5] = (unsigned __int16)(v80 + (v80 >> 8) + 1) >> 8;
                                unsigned int v76 = (BYTE1(v71) * v50[5] + ((BYTE1(v71) * v50[5]) >> 8) + 1) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49 + 4] = 0;
                            }
                            v42[v49 + 6] = v76;
                            v42[v55 - 8] = BYTE1(v71);
                            LOBYTE(v82) = BYTE2(v71);
                            if (BYTE2(v71))
                            {
                              if (BYTE2(v71) == 255)
                              {
                                *(_WORD *)&v42[v49 + 8] = *((_WORD *)v50 + 3);
                                LOBYTE(v82) = v50[8];
                              }
                              else
                              {
                                unsigned int v83 = BYTE2(v71) * v50[6];
                                unsigned int v84 = BYTE2(v71) * v50[7];
                                uint64_t v85 = &v42[v49];
                                v85[8] = (unsigned __int16)(v83 + (v83 >> 8) + 1) >> 8;
                                v85[9] = (unsigned __int16)(v84 + (v84 >> 8) + 1) >> 8;
                                unsigned int v82 = (BYTE2(v71) * v50[8] + ((BYTE2(v71) * v50[8]) >> 8) + 1) >> 8;
                              }
                            }
                            else
                            {
                              *(_WORD *)&v42[v49 + 8] = 0;
                            }
                            v42[v49 + 10] = v82;
                            v42[v55 - 4] = BYTE2(v71);
                            LODWORD(v71) = BYTE3(v71);
                            if (v71 == 255)
                            {
                              *(_WORD *)&v42[v49 + 12] = *(_WORD *)(v50 + 9);
                              LOBYTE(v86) = v50[11];
                            }
                            else if (v71)
                            {
                              int v87 = v71 * v50[10] + ((v71 * v50[10]) >> 8) + 1;
                              uint64_t v88 = &v42[v49];
                              v88[12] = (unsigned __int16)(v71 * v50[9] + ((v71 * v50[9]) >> 8) + 1) >> 8;
                              v88[13] = BYTE1(v87);
                              unsigned int v86 = (v71 * v50[11] + ((v71 * v50[11]) >> 8) + 1) >> 8;
                            }
                            else
                            {
                              LOBYTE(v86) = 0;
                              *(_WORD *)&v42[v49 + 12] = 0;
                            }
                          }
                          v42[v49 + 14] = v86;
                          v42[v55] = v71;
                        }
                      }
                      else
                      {
                        *(void *)int v42 = 0;
                        *((void *)v42 + 1) = 0;
                      }
                      v50 += 12;
                      v42 += 16;
                      --v70;
                    }
                    while (v70 > 1);
                  }
                }
                else if (v68 >= 4)
                {
                  int v102 = v69 + 1;
                  do
                  {
                    unsigned int v104 = *(_DWORD *)v51;
                    v51 += 4;
                    unsigned int v103 = v104;
                    int v105 = v50;
                    __int32 v106 = *(_DWORD *)v50;
                    uint32x2_t v107 = *(uint32x2_t *)(v105 + 4);
                    unsigned __int32 v108 = v107.u32[1];
                    if (v21 < 1)
                    {
                      int8x8_t v111 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)__PAIR64__(v103, v106), 0x10uLL), (int8x8_t)0xFF0000FF00), (int8x8_t)vshl_u32(v107, (uint32x2_t)0x1800000010)), (int8x8_t)vrev64_s32((int32x2_t)vand_s8((int8x8_t)vshr_n_u32((uint32x2_t)__PAIR64__(v103, v107.u32[0]), 8uLL), (int8x8_t)0xFF00FFFF00)));
                      int v110 = v103 | (v106 << 8);
                      unsigned int v112 = v108 & 0xFFFFFF00 | HIBYTE(v103);
                    }
                    else
                    {
                      v109.i32[0] = *(void *)(v105 + 4);
                      v109.i32[1] = v106;
                      int v110 = v106 & 0xFFFFFF | (v103 << 24);
                      int8x8_t v111 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v103), (uint32x2_t)0x800000010), (int8x8_t)0xFF000000FF000000), (int8x8_t)vrev64_s32((int32x2_t)vshl_u32(v109, (uint32x2_t)0xFFFFFFE8FFFFFFF0))), vand_s8((int8x8_t)vshl_u32(v107, (uint32x2_t)0x1000000008), (int8x8_t)0xFF000000FFFF00));
                      unsigned int v112 = v103 & 0xFF000000 | (v108 >> 8);
                    }
                    *(_DWORD *)int v42 = v110;
                    *(int8x8_t *)(v42 + 4) = v111;
                    *((_DWORD *)v42 + 3) = v112;
                    v42 += 16;
                    --v102;
                    uint64_t v50 = v105 + 12;
                  }
                  while (v102 > 1);
                  uint64_t v50 = v105 + 12;
                }
                int v113 = v68 & 3;
                if (v113)
                {
                  unsigned int v114 = v113 + 1;
                  do
                  {
                    unsigned int v116 = *v51++;
                    uint64_t v115 = v116;
                    if (v116)
                    {
                      if (v115 == 255 || !v20)
                      {
                        *(_WORD *)&v42[v49] = *(_WORD *)v50;
                        LOBYTE(v119) = v50[2];
                      }
                      else
                      {
                        if ((int)v20 < 1)
                        {
                          int v120 = v46[v115];
                          __int16 v121 = v50[1] * (_WORD)v120;
                          v42[v49] = (unsigned __int16)(*v50 * (_WORD)v120) >> 8;
                          v42[v54] = HIBYTE(v121);
                          unsigned int v118 = v50[2] * v120;
                        }
                        else
                        {
                          unsigned int v117 = v50[1] * v115 + ((v50[1] * v115) >> 8) + 1;
                          v42[v49] = (unsigned __int16)(*v50 * (_WORD)v115 + ((*v50 * v115) >> 8) + 1) >> 8;
                          v42[v54] = BYTE1(v117);
                          unsigned int v118 = v50[2] * v115 + ((v50[2] * v115) >> 8) + 1;
                        }
                        unsigned int v119 = v118 >> 8;
                      }
                    }
                    else
                    {
                      LOBYTE(v119) = 0;
                      *(_WORD *)&v42[v49] = 0;
                    }
                    v42[v53] = v119;
                    v50 += 3;
                    v42[v52] = v115;
                    v42 += 4;
                    --v114;
                  }
                  while (v114 > 1);
                }
                v50 += v48;
                v51 += v57;
                v42 += v56;
                --v377;
              }
              while (v59 > 1);
              return;
            }
          }
        }
        CGSConvertAlphaByteInterleved(v20, a1, a2, a3, *a5, a5[1], *a6, a6[1], v18, v42, v43, v44, a11[1], v21);
        return;
      }
      if (v18)
      {
        int v22 = *a5;
        int v23 = a5[1];
        int v24 = *a6;
        if (*a5 == v23)
        {
          int v25 = a6[1];
          uint64_t v26 = *a8;
          if (v24 == v25)
          {
            if (v26 == a8[1])
            {
              int v219 = *a11;
              if (*a11 == a11[1])
              {
                if (a3 == 3)
                {
                  uint64_t v220 = *a5;
                  int v221 = *a6;
                  uint64_t v222 = (unsigned int *)*a8;
                  int v223 = *a11;
                  CGSConvertAlphaByteMeshedXXXX(v20, a1, a2, (unsigned int *)v220, v221, v222, v223, v18);
                }
                else
                {
                  int v352 = *a6;
                  CGSConvertAlphaByteMeshed(v20, a1, a2, a3, (uint64_t *)a5, v352, a8, v219, v18);
                }
                return;
              }
            }
            int v25 = *a6;
          }
        }
        else
        {
          int v25 = a6[1];
          uint64_t v26 = *a8;
        }
        CGSConvertAlphaByteInterleved(v20, a1, a2, a3, v22, v23, v24, v25, v18, v26, a8[1], *a11, a11[1], v18);
        return;
      }
      int v372 = a3 * a1;
      unsigned int v124 = *a5;
      unsigned int v123 = (char *)a5[1];
      unsigned int v125 = *a8;
      uint64_t v360 = *a11;
      size_t v364 = *a6;
      uint64_t v368 = a6[1];
      CGBlt_copyBytes(a1, a2, v123, (char *)a8[1], v368, a11[1]);
      if (v20)
      {
        int v126 = v377;
        _ZF = a1 > 3 && v15 == 1;
        int v128 = _ZF;
        do
        {
          if (v15 == 3)
          {
            int v129 = a1;
            int v130 = v126;
            if (a1 >= 4)
            {
              uint64_t v131 = 0;
              do
              {
                int v132 = v129;
                uint64_t v133 = &v125[v131];
                if (*(_DWORD *)v123 == -1)
                {
                  uint64_t v147 = *(void *)&v124[v131];
                  *((_DWORD *)v133 + 2) = *(_DWORD *)&v124[v131 + 8];
                  *(void *)uint64_t v133 = v147;
                }
                else if (*(_DWORD *)v123)
                {
                  uint64_t v134 = &v124[v131];
                  int v135 = v124[v131];
                  uint64_t v136 = &v125[v131];
                  if (v20 == 1)
                  {
                    *uint64_t v136 = (unsigned __int16)(*v123 * (_WORD)v135
                                             + ((*v123 * v135) >> 8)
                                             + 1) >> 8;
                    unsigned int v137 = *v123 * v134[1];
                    v136[1] = (unsigned __int16)(v137 + (v137 >> 8) + 1) >> 8;
                    unsigned int v138 = *v123 * v134[2];
                    v136[2] = (unsigned __int16)(v138 + (v138 >> 8) + 1) >> 8;
                    unsigned int v139 = v123[1] * v134[3];
                    v136[3] = (unsigned __int16)(v139 + (v139 >> 8) + 1) >> 8;
                    unsigned int v140 = v123[1] * v134[4];
                    v136[4] = (unsigned __int16)(v140 + (v140 >> 8) + 1) >> 8;
                    unsigned int v141 = v123[1] * v134[5];
                    v136[5] = (unsigned __int16)(v141 + (v141 >> 8) + 1) >> 8;
                    unsigned int v142 = v123[2] * v134[6];
                    v136[6] = (unsigned __int16)(v142 + (v142 >> 8) + 1) >> 8;
                    unsigned int v143 = v123[2] * v134[7];
                    v136[7] = (unsigned __int16)(v143 + (v143 >> 8) + 1) >> 8;
                    unsigned int v144 = v123[2] * v134[8];
                    v136[8] = (unsigned __int16)(v144 + (v144 >> 8) + 1) >> 8;
                    unsigned int v145 = v123[3] * v134[9];
                    v136[9] = (unsigned __int16)(v145 + (v145 >> 8) + 1) >> 8;
                    v136[10] = (unsigned __int16)(v123[3] * v134[10]
                                                + ((v123[3] * v134[10]) >> 8)
                                                + 1) >> 8;
                    unsigned int v146 = v123[3] * v134[11]
                         + ((v123[3] * v134[11]) >> 8)
                         + 1;
                  }
                  else
                  {
                    *uint64_t v136 = (unsigned __int16)(inverted_8bit_alpha[*v123] * v135) >> 8;
                    v136[1] = (unsigned __int16)(inverted_8bit_alpha[*v123] * v134[1]) >> 8;
                    v136[2] = (unsigned __int16)(inverted_8bit_alpha[*v123] * v134[2]) >> 8;
                    v136[3] = (unsigned __int16)(inverted_8bit_alpha[v123[1]] * v134[3]) >> 8;
                    v136[4] = (unsigned __int16)(inverted_8bit_alpha[v123[1]] * v134[4]) >> 8;
                    v136[5] = (unsigned __int16)(inverted_8bit_alpha[v123[1]] * v134[5]) >> 8;
                    v136[6] = (unsigned __int16)(inverted_8bit_alpha[v123[2]] * v134[6]) >> 8;
                    v136[7] = (unsigned __int16)(inverted_8bit_alpha[v123[2]] * v134[7]) >> 8;
                    v136[8] = (unsigned __int16)(inverted_8bit_alpha[v123[2]] * v134[8]) >> 8;
                    v136[9] = (unsigned __int16)(inverted_8bit_alpha[v123[3]] * v134[9]) >> 8;
                    v136[10] = (unsigned __int16)(inverted_8bit_alpha[v123[3]] * v134[10]) >> 8;
                    LOWORD(v146) = inverted_8bit_alpha[v123[3]] * v134[11];
                  }
                  v136[11] = BYTE1(v146);
                }
                else
                {
                  *((_DWORD *)v133 + 2) = 0;
                  *(void *)uint64_t v133 = 0;
                }
                int v129 = v132 - 4;
                v123 += 4;
                v131 += 12;
              }
              while (v132 > 7);
              v125 += v131;
              v124 += v131;
            }
          }
          else
          {
            int v130 = v126;
            if (v128)
            {
              uint64_t v148 = 0;
              int v149 = a1 + 4;
              do
              {
                if (*(_DWORD *)&v123[v148] == -1)
                {
                  *(_DWORD *)&v125[v148] = *(_DWORD *)&v124[v148];
                }
                else if (*(_DWORD *)&v123[v148])
                {
                  uint32x4_t v150 = &v124[v148];
                  int v151 = v124[v148];
                  uint32x4_t v152 = (unsigned __int8 *)&v123[v148];
                  int v153 = &v125[v148];
                  if (v20 == 1)
                  {
                    *int v153 = (unsigned __int16)(v123[v148] * (_WORD)v151
                                             + ((v123[v148] * v151) >> 8)
                                             + 1) >> 8;
                    unsigned int v154 = v152[1] * v150[1];
                    v153[1] = (unsigned __int16)(v154 + (v154 >> 8) + 1) >> 8;
                    v153[2] = (unsigned __int16)(v152[2] * v150[2] + ((v152[2] * v150[2]) >> 8) + 1) >> 8;
                    unsigned int v155 = v152[3] * v150[3] + ((v152[3] * v150[3]) >> 8) + 1;
                  }
                  else
                  {
                    *int v153 = (unsigned __int16)(inverted_8bit_alpha[v123[v148]] * v151) >> 8;
                    v153[1] = (unsigned __int16)(inverted_8bit_alpha[v152[1]] * v150[1]) >> 8;
                    v153[2] = (unsigned __int16)(inverted_8bit_alpha[v152[2]] * v150[2]) >> 8;
                    LOWORD(v155) = inverted_8bit_alpha[v152[3]] * v150[3];
                  }
                  v153[3] = BYTE1(v155);
                }
                else
                {
                  *(_DWORD *)&v125[v148] = 0;
                }
                v149 -= 4;
                v148 += 4;
              }
              while (v149 > 7);
              int v129 = a1 - v148;
              v124 += v148;
              v125 += v148;
              v123 += v148;
            }
            else
            {
              int v129 = a1;
            }
          }
          if (v129 >= 1)
          {
            do
            {
              uint64_t v156 = *v123;
              if (v20 == 1)
              {
                if ((int)v15 >= 1)
                {
                  uint64_t v157 = 0;
                  do
                  {
                    v125[v157] = (unsigned __int16)(v124[v157] * (_WORD)v156
                                                  + ((v124[v157] * v156) >> 8)
                                                  + 1) >> 8;
                    ++v157;
                  }
                  while (v15 != v157);
                }
              }
              else if ((int)v15 >= 1)
              {
                uint64_t v158 = 0;
                unsigned __int16 v159 = inverted_8bit_alpha[v156];
                do
                {
                  v125[v158] = (unsigned __int16)(v124[v158] * v159) >> 8;
                  ++v158;
                }
                while (v15 != v158);
              }
              v124 += (int)v15;
              v125 += (int)v15;
              ++v123;
              _VF = __OFSUB__(v129--, 1);
            }
            while (!((v129 < 0) ^ _VF | (v129 == 0)));
          }
          int v126 = v130 - 1;
          v124 += v364 - v372;
          v123 += v368 - a1;
          v125 += v360 - v372;
        }
        while (v130 > 1);
      }
      else
      {
        int v227 = *a5;
        unint64_t v228 = (char *)*a8;
        int v229 = *a6;
        int v230 = *a11;
        CGBlt_copyBytes(v372, v377, (char *)v227, v228, v229, v230);
      }
      return;
    case 2:
      if (v21 != v18)
      {
        CGSConvertAlphaWordInterleved(v20, a1, a2, a3, (unsigned __int16 *)*a5, a5[1], *a6, a6[1], v18, (unsigned __int16 *)*a8, a8[1], *a11, a11[1], v21);
        return;
      }
      if (v18)
      {
        int v37 = *a5;
        int v38 = a5[1];
        int v39 = *a6;
        if (*a5 == v38)
        {
          int v40 = a6[1];
          int8x16_t v41 = (unsigned __int16 *)*a8;
          if (v39 == v40)
          {
            if (v41 == (unsigned __int16 *)a8[1])
            {
              int v226 = *a11;
              if (*a11 == a11[1])
              {
                CGSConvertAlphaWordMeshed(v20, a1, a2, a3, (uint64_t)v37, v39, (uint64_t)v41, v226, v18);
                return;
              }
            }
            int v40 = *a6;
          }
        }
        else
        {
          int v40 = a6[1];
          int8x16_t v41 = (unsigned __int16 *)*a8;
        }
        CGSConvertAlphaWordInterleved(v20, a1, a2, a3, (unsigned __int16 *)v37, v38, v39, v40, v18, v41, a8[1], *a11, a11[1], v18);
        return;
      }
      uint64_t v193 = *a6 - 2 * (int)a3 * a1;
      uint64_t v194 = a6[1] - 2 * a1;
      uint64_t v195 = *a11 - 2 * (int)a3 * a1;
      uint64_t v196 = a11[1] - 2 * a1;
      unsigned __int16 v197 = *a5;
      int v198 = a5[1];
      unsigned int v200 = *a8;
      unint64_t v199 = a8[1];
      if (a3 == 3)
      {
        int v277 = a1 & 3;
        int v278 = (a1 >> 2) + 1;
        while (a1 < 4)
        {
LABEL_457:
          if (v277)
          {
            uint64_t v318 = 0;
            int v319 = v277 + 1;
            do
            {
              unsigned int v321 = *(unsigned __int16 *)v198;
              v198 += 2;
              unsigned int v320 = v321;
              *(_WORD *)unint64_t v199 = v321;
              v199 += 2;
              if (v321)
              {
                if (v320 == 0xFFFF || !v20)
                {
                  *(_DWORD *)&v200[v318] = *(_DWORD *)&v197[v318];
                  LOWORD(v320) = *(_WORD *)&v197[v318 + 4];
                }
                else
                {
                  if ((int)v20 < 1)
                  {
                    unsigned int v325 = 0xFFFFFFFF / v320;
                    int v326 = v325 * *(unsigned __int16 *)&v197[v318 + 2];
                    unsigned int v327 = &v200[v318];
                    *(_WORD *)unsigned int v327 = (v325 * *(unsigned __int16 *)&v197[v318]) >> 16;
                    *((_WORD *)v327 + 1) = HIWORD(v326);
                    unsigned int v324 = v325 * *(unsigned __int16 *)&v197[v318 + 4];
                  }
                  else
                  {
                    unsigned int v322 = *(unsigned __int16 *)&v197[v318 + 2] * v320;
                    uint64_t v323 = &v200[v318];
                    *(_WORD *)uint64_t v323 = (*(unsigned __int16 *)&v197[v318] * v320
                                    + ((*(unsigned __int16 *)&v197[v318] * v320) >> 16)
                                    + 1) >> 16;
                    *((_WORD *)v323 + 1) = (v322 + HIWORD(v322) + 1) >> 16;
                    unsigned int v324 = *(unsigned __int16 *)&v197[v318 + 4] * v320
                         + ((*(unsigned __int16 *)&v197[v318 + 4] * v320) >> 16)
                         + 1;
                  }
                  unsigned int v320 = HIWORD(v324);
                }
              }
              else
              {
                *(_DWORD *)&v200[v318] = 0;
              }
              *(_WORD *)&v200[v318 + 4] = v320;
              --v319;
              v318 += 6;
            }
            while (v319 > 1);
            v197 += v318;
            v200 += v318;
          }
          v197 += v193;
          v198 += v194;
          v200 += v195;
          v199 += v196;
          if (!--v377) {
            return;
          }
        }
        uint64_t v279 = 0;
        int v280 = v278;
        while (1)
        {
          uint64_t v281 = &v200[v279];
          unint64_t v283 = *(void *)v198;
          v198 += 8;
          unint64_t v282 = v283;
          *(void *)unint64_t v199 = v283;
          v199 += 8;
          if (!v20 || v282 == 0xFFFFFFFF)
          {
            uint64_t v285 = *(void *)&v197[v279 + 16];
            *(_OWORD *)uint64_t v281 = *(_OWORD *)&v197[v279];
            *((void *)v281 + 2) = v285;
          }
          else if (v282)
          {
            if ((int)v20 < 1)
            {
              LOWORD(v286) = v282;
              if ((_WORD)v282)
              {
                if ((unsigned __int16)v282 == 0xFFFF)
                {
                  *(_DWORD *)uint64_t v281 = *(_DWORD *)&v197[v279];
                  LOWORD(v286) = *(_WORD *)&v197[v279 + 4];
                }
                else
                {
                  unsigned int v304 = 0xFFFFFFFF / (unsigned __int16)v282;
                  int v305 = v304 * *(unsigned __int16 *)&v197[v279 + 2];
                  uint64_t v306 = &v200[v279];
                  *(_WORD *)uint64_t v306 = (v304 * *(unsigned __int16 *)&v197[v279]) >> 16;
                  *((_WORD *)v306 + 1) = HIWORD(v305);
                  unsigned int v286 = (v304 * *(unsigned __int16 *)&v197[v279 + 4]) >> 16;
                }
              }
              else
              {
                *(_DWORD *)uint64_t v281 = 0;
              }
              *(_WORD *)&v200[v279 + 4] = v286;
              unsigned int v307 = WORD1(v282);
              if (WORD1(v282) == 0xFFFF)
              {
                *(_DWORD *)&v200[v279 + 6] = *(_DWORD *)&v197[v279 + 6];
                LOWORD(v308) = *(_WORD *)&v197[v279 + 10];
              }
              else if (v307)
              {
                unsigned int v309 = 0xFFFFFFFF / v307 * *(unsigned __int16 *)&v197[v279 + 8];
                uint64_t v310 = &v200[v279];
                *((_WORD *)v310 + 3) = (0xFFFFFFFF / v307 * *(unsigned __int16 *)&v197[v279 + 6]) >> 16;
                *((_WORD *)v310 + 4) = HIWORD(v309);
                unsigned int v308 = (0xFFFFFFFF / v307 * *(unsigned __int16 *)&v197[v279 + 10]) >> 16;
              }
              else
              {
                LOWORD(v308) = 0;
                *(_DWORD *)&v200[v279 + 6] = 0;
              }
              *(_WORD *)&v200[v279 + 10] = v308;
              LOWORD(v308) = WORD2(v282);
              if (WORD2(v282))
              {
                if (WORD2(v282) == 0xFFFF)
                {
                  *(_DWORD *)&v200[v279 + 12] = *(_DWORD *)&v197[v279 + 12];
                  LOWORD(v308) = *(_WORD *)&v197[v279 + 16];
                }
                else
                {
                  unsigned int v311 = 0xFFFFFFFF / WORD2(v282);
                  int v312 = v311 * *(unsigned __int16 *)&v197[v279 + 14];
                  unsigned int v313 = &v200[v279];
                  *((_WORD *)v313 + 6) = (v311 * *(unsigned __int16 *)&v197[v279 + 12]) >> 16;
                  *((_WORD *)v313 + 7) = HIWORD(v312);
                  unsigned int v308 = (v311 * *(unsigned __int16 *)&v197[v279 + 16]) >> 16;
                }
              }
              else
              {
                *(_DWORD *)&v200[v279 + 12] = 0;
              }
              unint64_t v298 = &v200[v279];
              *(_WORD *)&v200[v279 + 16] = v308;
              unint64_t v314 = HIWORD(v282);
              if (!v314)
              {
LABEL_452:
                *(_DWORD *)(v298 + 18) = 0;
                *((_WORD *)v298 + 11) = 0;
                goto LABEL_455;
              }
              if (v314 != 0xFFFF)
              {
                unsigned int v316 = 0xFFFFFFFF / v314;
                int v317 = v316 * *(unsigned __int16 *)&v197[v279 + 20];
                uint64_t v302 = &v200[v279];
                *((_WORD *)v302 + 9) = (v316 * *(unsigned __int16 *)&v197[v279 + 18]) >> 16;
                *((_WORD *)v302 + 10) = HIWORD(v317);
                unsigned int v303 = v316 * *(unsigned __int16 *)&v197[v279 + 22];
                goto LABEL_454;
              }
            }
            else
            {
              LOWORD(v284) = v282;
              if ((_WORD)v282)
              {
                if ((unsigned __int16)v282 == 0xFFFF)
                {
                  *(_DWORD *)uint64_t v281 = *(_DWORD *)&v197[v279];
                  LOWORD(v284) = *(_WORD *)&v197[v279 + 4];
                }
                else
                {
                  unsigned int v287 = (unsigned __int16)v282 * *(unsigned __int16 *)&v197[v279];
                  unsigned int v288 = (unsigned __int16)v282 * *(unsigned __int16 *)&v197[v279 + 2];
                  unsigned int v289 = &v200[v279];
                  *(_WORD *)unsigned int v289 = (v287 + HIWORD(v287) + 1) >> 16;
                  *((_WORD *)v289 + 1) = (v288 + HIWORD(v288) + 1) >> 16;
                  unsigned int v290 = (unsigned __int16)v282 * *(unsigned __int16 *)&v197[v279 + 4];
                  unsigned int v284 = (v290 + HIWORD(v290) + 1) >> 16;
                }
              }
              else
              {
                *(_DWORD *)uint64_t v281 = 0;
              }
              *(_WORD *)&v200[v279 + 4] = v284;
              unsigned int v291 = WORD1(v282);
              if (WORD1(v282) == 0xFFFF)
              {
                *(_DWORD *)&v200[v279 + 6] = *(_DWORD *)&v197[v279 + 6];
                LOWORD(v291) = *(_WORD *)&v197[v279 + 10];
              }
              else if (v291)
              {
                unsigned int v292 = v291 * *(unsigned __int16 *)&v197[v279 + 6];
                unsigned int v293 = v291 * *(unsigned __int16 *)&v197[v279 + 8];
                unsigned int v294 = &v200[v279];
                *((_WORD *)v294 + 3) = (v292 + HIWORD(v292) + 1) >> 16;
                *((_WORD *)v294 + 4) = (v293 + HIWORD(v293) + 1) >> 16;
                unsigned int v291 = (v291 * *(unsigned __int16 *)&v197[v279 + 10]
                      + ((v291 * *(unsigned __int16 *)&v197[v279 + 10]) >> 16)
                      + 1) >> 16;
              }
              else
              {
                *(_DWORD *)&v200[v279 + 6] = 0;
              }
              *(_WORD *)&v200[v279 + 10] = v291;
              LOWORD(v291) = WORD2(v282);
              if (WORD2(v282))
              {
                if (WORD2(v282) == 0xFFFF)
                {
                  *(_DWORD *)&v200[v279 + 12] = *(_DWORD *)&v197[v279 + 12];
                  LOWORD(v291) = *(_WORD *)&v197[v279 + 16];
                }
                else
                {
                  unsigned int v295 = WORD2(v282) * *(unsigned __int16 *)&v197[v279 + 12];
                  unsigned int v296 = WORD2(v282) * *(unsigned __int16 *)&v197[v279 + 14];
                  uint64_t v297 = &v200[v279];
                  *((_WORD *)v297 + 6) = (v295 + HIWORD(v295) + 1) >> 16;
                  *((_WORD *)v297 + 7) = (v296 + HIWORD(v296) + 1) >> 16;
                  unsigned int v291 = (WORD2(v282) * *(unsigned __int16 *)&v197[v279 + 16]
                        + ((WORD2(v282) * *(unsigned __int16 *)&v197[v279 + 16]) >> 16)
                        + 1) >> 16;
                }
              }
              else
              {
                *(_DWORD *)&v200[v279 + 12] = 0;
              }
              unint64_t v298 = &v200[v279];
              *(_WORD *)&v200[v279 + 16] = v291;
              unint64_t v299 = HIWORD(v282);
              if (!v299) {
                goto LABEL_452;
              }
              if (v299 != 0xFFFF)
              {
                unsigned int v300 = *(unsigned __int16 *)&v197[v279 + 18] * v299;
                unsigned int v301 = *(unsigned __int16 *)&v197[v279 + 20] * v299;
                uint64_t v302 = &v200[v279];
                *((_WORD *)v302 + 9) = (v300 + HIWORD(v300) + 1) >> 16;
                *((_WORD *)v302 + 10) = (v301 + HIWORD(v301) + 1) >> 16;
                unsigned int v303 = *(unsigned __int16 *)&v197[v279 + 22] * v299
                     + ((*(unsigned __int16 *)&v197[v279 + 22] * v299) >> 16)
                     + 1;
LABEL_454:
                *((_WORD *)v302 + 11) = HIWORD(v303);
                goto LABEL_455;
              }
            }
            unsigned int v315 = &v200[v279];
            *(_DWORD *)(v315 + 18) = *(_DWORD *)&v197[v279 + 18];
            *((_WORD *)v315 + 11) = *(_WORD *)&v197[v279 + 22];
          }
          else
          {
            *(void *)uint64_t v281 = 0;
            *((void *)v281 + 1) = 0;
            *((void *)v281 + 2) = 0;
          }
LABEL_455:
          --v280;
          v279 += 24;
          if (v280 <= 1)
          {
            v200 += v279;
            v197 += v279;
            goto LABEL_457;
          }
        }
      }
      uint64_t v201 = (a3 - 1);
      if (a3 != 1)
      {
        uint64_t v328 = (int)v201;
        uint64_t v329 = (int)a3;
        uint64_t v363 = *a6 - 2 * (int)a3 * a1;
        uint64_t v367 = 2 * a3;
        uint64_t v330 = 2 * (int)a3;
        int v371 = a3 - 2;
        uint64_t v356 = *a11 - 2 * (int)a3 * a1;
        uint64_t v359 = v194;
        uint64_t v353 = a11[1] - 2 * a1;
        while (1)
        {
          int v331 = a1;
          if (a1 >= 1) {
            break;
          }
LABEL_506:
          v197 += v363;
          v198 += v359;
          v200 += v356;
          v199 += v353;
          BOOL v242 = v377-- <= 1;
          if (v242) {
            return;
          }
        }
        while (1)
        {
          unsigned int v333 = *(unsigned __int16 *)v198;
          v198 += 2;
          unsigned int v332 = v333;
          *(_WORD *)unint64_t v199 = v333;
          v199 += 2;
          if (v333 == 0xFFFF)
          {
            __int16 v339 = *(_WORD *)&v197[2 * v328];
            if ((int)v15 < 2)
            {
              __int16 v342 = *(_WORD *)&v197[2 * v328];
            }
            else
            {
              int v340 = v371;
              uint64_t v341 = v201;
              do
              {
                __int16 v342 = *(_WORD *)&v197[2 * v340];
                *(_WORD *)&v200[2 * v341] = v339;
                --v340;
                __int16 v339 = v342;
                BOOL v242 = v341-- <= 1;
              }
              while (!v242);
            }
          }
          else
          {
            if (!v332)
            {
              if ((int)v15 >= 1)
              {
                uint64_t v334 = v20;
                uint64_t v335 = v201;
                uint64_t v336 = v15;
                uint64_t v337 = v328;
                uint32x4_t v375 = v199;
                uint64_t v338 = v329;
                bzero(v200, v367);
                uint64_t v329 = v338;
                unint64_t v199 = v375;
                uint64_t v328 = v337;
                uint64_t v15 = v336;
                uint64_t v201 = v335;
                uint64_t v20 = v334;
              }
              goto LABEL_504;
            }
            int v343 = *(unsigned __int16 *)&v197[2 * v328];
            if (v20)
            {
              if ((int)v20 < 1)
              {
                unsigned int v349 = 0xFFFFFFFF / v332;
                if ((int)v15 > 1)
                {
                  uint64_t v350 = v201;
                  do
                  {
                    int v351 = v343 * v349;
                    BOOL v242 = v350 <= 1;
                    int v343 = *(unsigned __int16 *)&v197[2 * (v350 - 1)];
                    *(_WORD *)&v200[2 * v350--] = HIWORD(v351);
                  }
                  while (!v242);
                }
                unsigned int v346 = v343 * v349;
              }
              else
              {
                if ((int)v15 >= 2)
                {
                  uint64_t v344 = v201;
                  do
                  {
                    unsigned int v345 = v343 * v332;
                    BOOL v242 = v344 <= 1;
                    int v343 = *(unsigned __int16 *)&v197[2 * (v344 - 1)];
                    *(_WORD *)&v200[2 * v344--] = (v345 + HIWORD(v345) + 1) >> 16;
                  }
                  while (!v242);
                }
                unsigned int v346 = v343 * v332 + ((v343 * v332) >> 16) + 1;
              }
              *(_WORD *)unsigned int v200 = HIWORD(v346);
              goto LABEL_504;
            }
            if ((int)v15 < 2)
            {
              __int16 v342 = *(_WORD *)&v197[2 * v328];
            }
            else
            {
              int v347 = v371;
              uint64_t v348 = v201;
              do
              {
                __int16 v342 = *(_WORD *)&v197[2 * v347];
                *(_WORD *)&v200[2 * v348] = v343;
                --v347;
                LOWORD(v343) = v342;
                BOOL v242 = v348-- <= 1;
              }
              while (!v242);
            }
          }
          *(_WORD *)unsigned int v200 = v342;
LABEL_504:
          v197 += 2 * v329;
          v200 += v330;
          BOOL v242 = v331-- <= 1;
          if (v242) {
            goto LABEL_506;
          }
        }
      }
      do
      {
        if (a1 < 4) {
          goto LABEL_273;
        }
        uint64_t v202 = 0;
        int v203 = (a1 >> 2) + 1;
        do
        {
          unint64_t v204 = *(void *)&v198[v202];
          *(void *)&v199[v202] = v204;
          if (!v20 || v204 == 0xFFFFFFFF)
          {
            *(void *)&v200[v202] = *(void *)&v197[v202];
            goto LABEL_271;
          }
          if (!v204)
          {
            *(void *)&v200[v202] = 0;
            goto LABEL_271;
          }
          LOWORD(v205) = v204;
          if ((int)v20 < 1)
          {
            if ((_WORD)v204)
            {
              if ((unsigned __int16)v204 == 0xFFFF) {
                LOWORD(v205) = *(_WORD *)&v197[v202];
              }
              else {
                unsigned int v205 = (0xFFFFFFFF / (unsigned __int16)v204 * *(unsigned __int16 *)&v197[v202]) >> 16;
              }
            }
            *(_WORD *)&v200[v202] = v205;
            if (WORD1(v204) == 0xFFFF)
            {
              LOWORD(v211) = *(_WORD *)&v197[v202 + 2];
            }
            else if (v204 >= 0x10000)
            {
              unsigned int v211 = (0xFFFFFFFF / WORD1(v204) * *(unsigned __int16 *)&v197[v202 + 2]) >> 16;
            }
            else
            {
              LOWORD(v211) = 0;
            }
            *(_WORD *)&v200[v202 + 2] = v211;
            if (WORD2(v204))
            {
              if (WORD2(v204) == 0xFFFF) {
                LOWORD(v212) = *(_WORD *)&v197[v202 + 4];
              }
              else {
                LODWORD(v212) = (0xFFFFFFFF / WORD2(v204) * *(unsigned __int16 *)&v197[v202 + 4]) >> 16;
              }
            }
            else
            {
              unint64_t v212 = HIDWORD(v204);
            }
            *(_WORD *)&v200[v202 + 4] = v212;
            unint64_t v213 = HIWORD(v204);
            if (!v213)
            {
LABEL_267:
              *(_WORD *)&v200[v202 + 6] = 0;
              goto LABEL_271;
            }
            if (v213 != 0xFFFF)
            {
              unsigned int v210 = 0xFFFFFFFF / v213 * *(unsigned __int16 *)&v197[v202 + 6];
              goto LABEL_269;
            }
          }
          else
          {
            if ((_WORD)v204)
            {
              if ((unsigned __int16)v204 == 0xFFFF) {
                LOWORD(v205) = *(_WORD *)&v197[v202];
              }
              else {
                unsigned int v205 = ((unsigned __int16)v204 * *(unsigned __int16 *)&v197[v202]
              }
                      + (((unsigned __int16)v204 * *(unsigned __int16 *)&v197[v202]) >> 16)
                      + 1) >> 16;
            }
            *(_WORD *)&v200[v202] = v205;
            if (WORD1(v204) == 0xFFFF)
            {
              LOWORD(v206) = *(_WORD *)&v197[v202 + 2];
            }
            else if (v204 >= 0x10000)
            {
              unsigned int v207 = WORD1(v204) * *(unsigned __int16 *)&v197[v202 + 2];
              unsigned int v206 = (v207 + HIWORD(v207) + 1) >> 16;
            }
            else
            {
              LOWORD(v206) = 0;
            }
            *(_WORD *)&v200[v202 + 2] = v206;
            if (WORD2(v204))
            {
              if (WORD2(v204) == 0xFFFF) {
                LOWORD(v208) = *(_WORD *)&v197[v202 + 4];
              }
              else {
                LODWORD(v208) = (WORD2(v204) * *(unsigned __int16 *)&v197[v202 + 4]
              }
                               + ((WORD2(v204) * *(unsigned __int16 *)&v197[v202 + 4]) >> 16)
                               + 1) >> 16;
            }
            else
            {
              unint64_t v208 = HIDWORD(v204);
            }
            *(_WORD *)&v200[v202 + 4] = v208;
            unint64_t v209 = HIWORD(v204);
            if (!v209) {
              goto LABEL_267;
            }
            if (v209 != 0xFFFF)
            {
              unsigned int v210 = *(unsigned __int16 *)&v197[v202 + 6] * v209
                   + ((*(unsigned __int16 *)&v197[v202 + 6] * v209) >> 16)
                   + 1;
LABEL_269:
              unsigned int v214 = HIWORD(v210);
              goto LABEL_270;
            }
          }
          LOWORD(v214) = *(_WORD *)&v197[v202 + 6];
LABEL_270:
          *(_WORD *)&v200[v202 + 6] = v214;
LABEL_271:
          --v203;
          v202 += 8;
        }
        while (v203 > 1);
        v199 += v202;
        v197 += v202;
        v198 += v202;
        v200 += v202;
LABEL_273:
        if ((a1 & 3) != 0)
        {
          int v215 = (a1 & 3) + 1;
          do
          {
            unsigned int v217 = *(unsigned __int16 *)v198;
            v198 += 2;
            unsigned int v216 = v217;
            *(_WORD *)unint64_t v199 = v217;
            v199 += 2;
            if (v217)
            {
              if (v216 == 0xFFFF || !v20)
              {
                LOWORD(v216) = *(_WORD *)v197;
              }
              else
              {
                if ((int)v20 < 1) {
                  unsigned int v218 = 0xFFFFFFFF / v216 * *(unsigned __int16 *)v197;
                }
                else {
                  unsigned int v218 = *(unsigned __int16 *)v197 * v216 + ((*(unsigned __int16 *)v197 * v216) >> 16) + 1;
                }
                unsigned int v216 = HIWORD(v218);
              }
            }
            *(_WORD *)unsigned int v200 = v216;
            v200 += 2;
            v197 += 2;
            --v215;
          }
          while (v215 > 1);
        }
        v197 += v193;
        v198 += v194;
        v200 += v195;
        v199 += v196;
        --v377;
      }
      while (v377);
      return;
    case 4:
      if (v21 != v18)
      {
        CGSConvertAlphaFloatInterleved(v20, a1, a2, a3, (uint64_t)*a5, (float *)a5[1], *a6, a6[1], v18, (float *)*a8, (float *)a8[1], *a11, a11[1], v21);
        return;
      }
      if (v18)
      {
        int v27 = *a5;
        int v28 = (float *)a5[1];
        int v29 = *a6;
        if (*a5 == (unsigned __int8 *)v28)
        {
          int v30 = a6[1];
          uint64_t v31 = (float *)*a8;
          if (v29 == v30)
          {
            if (v31 == (float *)a8[1])
            {
              int v224 = *a11;
              if (*a11 == a11[1])
              {
                CGSConvertAlphaFloatMeshed(v20, a1, a2, a3, (uint64_t)v27, v29, (uint64_t)v31, v224, v18);
                return;
              }
            }
            int v30 = *a6;
          }
        }
        else
        {
          int v30 = a6[1];
          uint64_t v31 = (float *)*a8;
        }
        CGSConvertAlphaFloatInterleved(v20, a1, a2, a3, (uint64_t)v27, v28, v29, v30, v18, v31, (float *)a8[1], *a11, a11[1], v18);
        return;
      }
      uint64_t v161 = *a6 - 4 * (int)a3 * a1;
      uint64_t v162 = a6[1] - 4 * a1;
      uint64_t v163 = *a11 - 4 * (int)a3 * a1;
      uint64_t v164 = a11[1] - 4 * a1;
      unint64_t v165 = (float32x2_t *)*a5;
      unsigned int v166 = (float *)a5[1];
      unsigned int v167 = (float *)*a8;
      uint64_t v168 = (float *)a8[1];
      if (a3 != 3)
      {
        if (a3 != 1)
        {
          size_t v365 = *a6 - 4 * (int)a3 * a1;
          uint64_t v369 = (a3 - 1);
          uint64_t v373 = (int)a3 - 1;
          uint64_t v357 = *a11 - 4 * (int)a3 * a1;
          uint64_t v361 = a6[1] - 4 * a1;
          uint64_t v354 = a11[1] - 4 * a1;
          do
          {
            int v236 = a1;
            if (a1 >= 1)
            {
              do
              {
                float v237 = *v166++;
                float v238 = v237;
                *v168++ = v237;
                if (v237 == 0.0)
                {
                  if ((int)v15 >= 1) {
                    bzero(v167, 4 * v15);
                  }
                }
                else
                {
                  float v239 = v165->f32[v373];
                  if (!v20 || v238 == 1.0)
                  {
                    if ((int)v15 < 2)
                    {
                      float32_t v244 = v165->f32[v373];
                    }
                    else
                    {
                      uint64_t v243 = v369;
                      do
                      {
                        BOOL v242 = v243 <= 1;
                        float32_t v244 = v165->f32[(v243 - 1)];
                        v167[v243--] = v239;
                        float v239 = v244;
                      }
                      while (!v242);
                    }
                    *unsigned int v167 = v244;
                  }
                  else
                  {
                    if ((int)v20 < 1)
                    {
                      float v238 = 1.0 / v238;
                      if ((int)v15 > 1)
                      {
                        uint64_t v245 = v369;
                        do
                        {
                          float v246 = v238 * v239;
                          BOOL v242 = v245 <= 1;
                          float v239 = v165->f32[(v245 - 1)];
                          v167[v245--] = v246;
                        }
                        while (!v242);
                      }
                    }
                    else if ((int)v15 >= 2)
                    {
                      uint64_t v240 = v369;
                      do
                      {
                        float v241 = v238 * v239;
                        BOOL v242 = v240 <= 1;
                        float v239 = v165->f32[(v240 - 1)];
                        v167[v240--] = v241;
                      }
                      while (!v242);
                    }
                    *unsigned int v167 = v238 * v239;
                  }
                }
                unint64_t v165 = (float32x2_t *)((char *)v165 + 4 * (int)v15);
                v167 += (int)v15;
                BOOL v242 = v236-- <= 1;
              }
              while (!v242);
            }
            unint64_t v165 = (float32x2_t *)((char *)v165 + v365);
            unsigned int v166 = (float *)((char *)v166 + v361);
            unsigned int v167 = (float *)((char *)v167 + v357);
            uint64_t v168 = (float *)((char *)v168 + v354);
            BOOL v242 = v377-- <= 1;
          }
          while (!v242);
          return;
        }
        while (a1 < 1)
        {
          int v170 = v377;
LABEL_204:
          unint64_t v165 = (float32x2_t *)((char *)v165 + v161);
          unsigned int v166 = (float *)((char *)v166 + v162);
          unsigned int v167 = (float *)((char *)v167 + v163);
          uint64_t v168 = (float *)((char *)v168 + v164);
          int v377 = v170 - 1;
          if (v170 == 1) {
            return;
          }
        }
        int v169 = a1 + 1;
        int v170 = v377;
        while (1)
        {
          float v171 = *v166++;
          float v172 = v171;
          *v168++ = v171;
          if (v171 != 1.0)
          {
            float v173 = 0.0;
            if (v172 == 0.0) {
              goto LABEL_201;
            }
            if (v20)
            {
              if ((int)v20 < 1) {
                float v172 = 1.0 / v172;
              }
              float v173 = v172 * v165->f32[0];
              goto LABEL_201;
            }
          }
          float v173 = v165->f32[0];
LABEL_201:
          *v167++ = v173;
          unint64_t v165 = (float32x2_t *)((char *)v165 + 4);
          if (--v169 <= 1) {
            goto LABEL_204;
          }
        }
      }
      while (a1 < 1)
      {
        int v232 = v377;
LABEL_327:
        unint64_t v165 = (float32x2_t *)((char *)v165 + v161);
        unsigned int v166 = (float *)((char *)v166 + v162);
        unsigned int v167 = (float *)((char *)v167 + v163);
        uint64_t v168 = (float *)((char *)v168 + v164);
        int v377 = v232 - 1;
        if (v232 == 1) {
          return;
        }
      }
      int v231 = a1 + 1;
      int v232 = v377;
      while (1)
      {
        float v233 = *v166++;
        float v234 = v233;
        *v168++ = v233;
        if (v233 != 1.0)
        {
          if (v234 == 0.0)
          {
            *(void *)unsigned int v167 = 0;
            float v235 = 0.0;
            goto LABEL_324;
          }
          if (v20)
          {
            if ((int)v20 < 1) {
              float v234 = 1.0 / v234;
            }
            *(float32x2_t *)unsigned int v167 = vmul_n_f32(*v165, v234);
            float v235 = v234 * v165[1].f32[0];
            goto LABEL_324;
          }
        }
        *(float32x2_t *)unsigned int v167 = *v165;
        float v235 = v165[1].f32[0];
LABEL_324:
        v167[2] = v235;
        unint64_t v165 = (float32x2_t *)((char *)v165 + 12);
        v167 += 3;
        if (--v231 <= 1) {
          goto LABEL_327;
        }
      }
    case 5:
      if (v21 != v18)
      {
        convert_alpha_float16_interleved(v20, a1, a2, a3, (short float *)*a5, (short float *)a5[1], *a6, a6[1], _S0, _S1, v18, (char *)*a8, (short float *)a8[1], *a11, a11[1], v21);
        return;
      }
      if (v18)
      {
        int v32 = *a5;
        uint64_t v33 = (short float *)a5[1];
        int v34 = *a6;
        if (*a5 == (unsigned __int8 *)v33)
        {
          int v35 = a6[1];
          int v36 = (char *)*a8;
          if (v34 == v35)
          {
            if (v36 == (char *)a8[1])
            {
              int v225 = *a11;
              if (*a11 == a11[1])
              {
                convert_alpha_float16_meshed(v20, a1, a2, a3, (uint64_t)v32, v34, (uint64_t)v36, v225, _S0, _S1, v18);
                return;
              }
            }
            int v35 = *a6;
          }
        }
        else
        {
          int v35 = a6[1];
          int v36 = (char *)*a8;
        }
        convert_alpha_float16_interleved(v20, a1, a2, a3, (short float *)v32, v33, v34, v35, _S0, _S1, v18, v36, (short float *)a8[1], *a11, a11[1], v18);
        return;
      }
      uint64_t v174 = *a6 - 2 * (int)a3 * a1;
      uint64_t v175 = a6[1] - 2 * a1;
      uint64_t v176 = *a11 - 2 * (int)a3 * a1;
      uint64_t v177 = a11[1] - 2 * a1;
      unint64_t v178 = *a5;
      unsigned int v179 = (short float *)a5[1];
      unsigned int v180 = *a8;
      unsigned int v181 = (short float *)a8[1];
      if (a3 != 3)
      {
        if (a3 != 1)
        {
          size_t v366 = *a6 - 2 * (int)a3 * a1;
          uint64_t v370 = (a3 - 1);
          uint64_t v374 = (int)a3 - 1;
          uint64_t v358 = *a11 - 2 * (int)a3 * a1;
          uint64_t v362 = a6[1] - 2 * a1;
          uint64_t v355 = a11[1] - 2 * a1;
          do
          {
            int v263 = a1;
            if (a1 >= 1)
            {
              do
              {
                short float v264 = *v179++;
                *v181++ = v264;
                __asm { FCMP            H1, #0 }
                if (_ZF)
                {
                  if ((int)v15 >= 1) {
                    bzero(v180, 2 * v15);
                  }
                }
                else
                {
                  LOWORD(_S0) = *(_WORD *)&v178[2 * v374];
                  if (!v20 || _H1 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                  {
                    if ((int)v15 < 2)
                    {
                      _S1 = _S0;
                    }
                    else
                    {
                      uint64_t v271 = v370;
                      do
                      {
                        BOOL v242 = v271 <= 1;
                        LOWORD(_S1) = *(_WORD *)&v178[2 * (v271 - 1)];
                        *(_WORD *)&v180[2 * v271--] = LOWORD(_S0);
                        _S0 = _S1;
                      }
                      while (!v242);
                    }
                    *(_WORD *)unsigned int v180 = LOWORD(_S1);
                  }
                  else
                  {
                    __asm
                    {
                      FCVT            S1, H1
                      FCVT            S0, H0
                    }
                    if ((int)v20 < 1)
                    {
                      _S1 = 1.0 / _S1;
                      if ((int)v15 > 1)
                      {
                        uint64_t v272 = v370;
                        do
                        {
                          _H2 = *(_WORD *)&v178[2 * (v272 - 1)];
                          _S3 = _S1 * _S0;
                          __asm
                          {
                            FCVT            S0, H2
                            FCVT            H2, S3
                          }
                          *(_WORD *)&v180[2 * v272--] = _H2;
                        }
                        while (!(_NF ^ _VF | _ZF));
                      }
                      _S0 = _S1 * _S0;
                    }
                    else
                    {
                      if ((int)v15 >= 2)
                      {
                        uint64_t v267 = v370;
                        do
                        {
                          _H2 = *(_WORD *)&v178[2 * (v267 - 1)];
                          _S3 = _S0 * _S1;
                          __asm
                          {
                            FCVT            S0, H2
                            FCVT            H2, S3
                          }
                          *(_WORD *)&v180[2 * v267--] = _H2;
                        }
                        while (!(_NF ^ _VF | _ZF));
                      }
                      _S0 = _S0 * _S1;
                    }
                    __asm { FCVT            H0, S0 }
                    *(_WORD *)unsigned int v180 = _H0;
                  }
                }
                v178 += 2 * (int)v15;
                v180 += 2 * (int)v15;
                BOOL v242 = v263-- <= 1;
              }
              while (!v242);
            }
            v178 += v366;
            unsigned int v179 = (short float *)((char *)v179 + v362);
            v180 += v358;
            unsigned int v181 = (short float *)((char *)v181 + v355);
            BOOL v242 = v377-- <= 1;
          }
          while (!v242);
          return;
        }
        while (a1 < 1)
        {
          int v183 = v377;
LABEL_221:
          v178 += v174;
          unsigned int v179 = (short float *)((char *)v179 + v175);
          v180 += v176;
          unsigned int v181 = (short float *)((char *)v181 + v177);
          int v377 = v183 - 1;
          if (v183 == 1) {
            return;
          }
        }
        int v182 = a1 + 1;
        int v183 = v377;
        while (1)
        {
          short float v184 = *v179++;
          *v181++ = v184;
          if (v184 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            LOWORD(_H3) = 0;
            __asm { FCMP            H2, #0 }
            if (_ZF) {
              goto LABEL_214;
            }
            if (v20)
            {
              if ((int)v20 < 1)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *(short float *)v178;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 / _S2) * _S3;
                __asm { FCVT            H3, S2 }
              }
              else
              {
                _H3 = _H2 * *(short float *)v178;
              }
              goto LABEL_214;
            }
          }
          _H3 = *(short float *)v178;
LABEL_214:
          *(short float *)unsigned int v180 = _H3;
          v180 += 2;
          v178 += 2;
          if (--v182 <= 1) {
            goto LABEL_221;
          }
        }
      }
      while (a1 < 1)
      {
        int v248 = v377;
LABEL_373:
        v178 += v174;
        unsigned int v179 = (short float *)((char *)v179 + v175);
        v180 += v176;
        unsigned int v181 = (short float *)((char *)v181 + v177);
        int v377 = v248 - 1;
        if (v248 == 1) {
          return;
        }
      }
      int v247 = a1 + 1;
      int v248 = v377;
      break;
    default:
      _CGHandleAssert("img_alpha", 159, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "0", "unhandled component type %d", (uint64_t)a6, a7, v18, a12);
  }
  while (1)
  {
    short float v249 = *v179++;
    *v181++ = v249;
    if (v249 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
    {
      __asm { FCMP            H2, #0 }
      if (_ZF)
      {
        *(_DWORD *)unsigned int v180 = 0;
        LOWORD(_H2) = 0;
        goto LABEL_366;
      }
      if (v20)
      {
        if ((int)v20 < 1)
        {
          __asm { FCVT            S2, H2 }
          float v254 = 1.0 / _S2;
          _H3 = *(short float *)v178;
          __asm { FCVT            S3, H3 }
          _H4 = *((_WORD *)v178 + 1);
          __asm { FCVT            S4, H4 }
          _S3 = v254 * _S3;
          _S4 = v254 * _S4;
          __asm { FCVT            H3, S3 }
          *(_WORD *)unsigned int v180 = LOWORD(_S3);
          __asm { FCVT            H3, S4 }
          *((_WORD *)v180 + 1) = LOWORD(_S3);
          LOWORD(_S3) = *((_WORD *)v178 + 2);
          __asm { FCVT            S3, H3 }
          _S2 = v254 * _S3;
          __asm { FCVT            H2, S2 }
        }
        else
        {
          short float v252 = *((short float *)v178 + 1);
          *(short float *)unsigned int v180 = _H2 * *(short float *)v178;
          *((short float *)v180 + 1) = _H2 * v252;
          _H2 = _H2 * *((short float *)v178 + 2);
        }
        goto LABEL_366;
      }
    }
    *(_DWORD *)unsigned int v180 = *(_DWORD *)v178;
    _H2 = *((short float *)v178 + 2);
LABEL_366:
    *((short float *)v180 + 2) = _H2;
    v178 += 6;
    v180 += 6;
    if (--v247 <= 1) {
      goto LABEL_373;
    }
  }
}

void img_blocks_error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    uint64_t v8 = "%s: %s\n"
  }
         "CGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g])"
         ");\n"
         "\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count %ld) [%ld];\n"
         "\t\t<CGImageBlock %p> (rect = (%g, %g) x [%g, %g], data = %p, bytes-per-row = %ld)";
  else {
    uint64_t v8 = "%s: %s\n"
  }
         "CGImageProviderCopyImageBlockSet(<CGImageProvider %p> (component-type = %s, pixel-size = %ld, size = [%g x %g])"
         ");\n"
         "\t<CGImageBlockSet %p> (size = [%g x %g], rect = (%g, %g) x [%g, %g], count = %ld) [%ld]";
  CGPostError((uint64_t)v8, a2, a3, a4, a5, a6, a7, a8, (char)"img_blocks_create");
}

uint64_t img_extent(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result) {
    return (*(uint64_t (**)(void))(result + 8))();
  }
  return result;
}

uint64_t img_raw_data(uint64_t a1, signed int a2, uint64_t a3, void *a4, _DWORD *a5)
{
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 == -1)
  {
    int v17 = *(void **)(a1 + 184);
    if (!v17) {
      return 0;
    }
    uint64_t v18 = v17[5];
    if (v18 != v17[6] || v18 < 1) {
      return 0;
    }
    uint64_t v20 = 0;
    for (int i = (_DWORD *)(v17[9] + 12); ; i += 4)
    {
      int v22 = *(i - 2);
      int v23 = a2 - v22;
      if (a2 >= v22)
      {
        int v24 = *i + v22;
        if (v24 > a2) {
          break;
        }
      }
      if (v18 == ++v20) {
        return 0;
      }
    }
    uint64_t v31 = *(void *)(v17[11] + 8 * v20);
    uint64_t v32 = (int)v31 * (uint64_t)v23;
    if (v32 != (int)v32) {
      return 0;
    }
    uint64_t v33 = *(void *)(v17[10] + 8 * v20) + v32;
    if (a4[1] == *a4)
    {
      a4[1] = v33;
      a5[1] = v31;
    }
    *a4 = v33;
    *a5 = v31;
    int v34 = a3 + a2;
    if ((int)a3 + a2 >= v24) {
      int v34 = v24;
    }
    *(void *)(a1 + 88) = v34;
    return (v34 - a2);
  }
  else
  {
    if (v10)
    {
      uint64_t v26 = *(int **)(a1 + 136);
      int v25 = *(void **)(a1 + 144);
      if (v10 == 2 && a4[1] && (*(_DWORD *)(a1 + 44) & 0xFFFFFFFE) == 8)
      {
        int v27 = v26[1];
        uint64_t v28 = v27 * (uint64_t)a2;
        if (v28 != (int)v28) {
          return 0;
        }
        a4[1] = v25[1] + v28;
        a5[1] = v27;
      }
      int v29 = *v26;
      uint64_t v30 = v29 * (uint64_t)a2;
      if (v30 == (int)v30)
      {
        *a4 = *v25 + v30;
        *a5 = v29;
        uint64_t v16 = (int)a3 + a2;
LABEL_28:
        *(void *)(a1 + 88) = v16;
        return a3;
      }
      return 0;
    }
    uint64_t image_pointer = get_image_pointer((void *)a1);
    uint64_t result = 0;
    if ((int)a3 >= 1 && (a2 & 0x80000000) == 0 && image_pointer)
    {
      uint64_t v13 = *(void *)(a1 + 136);
      unint64_t v14 = (int)v13 * (unint64_t)a2;
      if (v14 == (int)v14 && (v14 & 0x80000000) == 0)
      {
        unint64_t v15 = image_pointer + v14;
        if (a4[1] == *a4)
        {
          a4[1] = v15;
          a5[1] = v13;
        }
        *a4 = v15;
        *a5 = v13;
        uint64_t v16 = (a3 + a2);
        goto LABEL_28;
      }
      return 0;
    }
  }
  return result;
}

uint64_t img_interpolate_extent(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v3 = a1[11];
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  size_t v4 = *(uint64_t (**)(uint64_t, void))(v2 + 8);
  if (!v4) {
    return 0;
  }
  if (a2)
  {
    int v7 = *(uint64_t (**)(uint64_t, uint64_t *))(v2 + 8);
    LODWORD(v9) = resample_range(v3, 1, *(_DWORD *)a2, *(_DWORD *)(a2 + 8), (int *)&v8);
    if ((v9 & 0x80000000) != 0) {
      return 0xFFFFFFFFLL;
    }
    HIDWORD(v9) = resample_range(v3, 2, *(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 12), (int *)&v8 + 1);
    if (v9 < 0) {
      return 0xFFFFFFFFLL;
    }
    else {
      return v7(v2, &v8);
    }
  }
  else
  {
    return v4(v2, 0);
  }
}

uint64_t img_alphamerge_end(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result) {
    return (*(uint64_t (**)(void))(result + 24))();
  }
  return result;
}

uint64_t img_alphamerge_read(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 **a4, int *a5, uint64_t a6)
{
  uint64_t v9 = a3;
  v38[1] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)a1;
  int v13 = *(_DWORD *)(a1 + 88);
  v38[0] = 0;
  long long v37 = 0uLL;
  switch(v13)
  {
    case 0:
      int v23 = 0;
      goto LABEL_25;
    case 1:
      if (!*(void *)v12
        && *(uint64_t (**)(uint64_t, unsigned int, uint64_t, char **, int *, uint64_t, uint64_t, uint64_t))(v12 + 16) == img_raw_read)
      {
        int v23 = img_raw_access(v12, 0);
      }
      else
      {
        int v23 = 0;
      }
      int v24 = *a5 * ((int)v9 - 1) / *(_DWORD *)(a1 + 56);
      if (v24 >= (int)v9)
      {
        uint64_t v9 = (v9 - 1);
      }
      else
      {
        int v25 = *(_DWORD *)(a1 + 64);
        if (v25 >= (int)v9) {
          unsigned int v26 = v9;
        }
        else {
          unsigned int v26 = *(_DWORD *)(a1 + 64);
        }
        if (v24 >= v25) {
          uint64_t v9 = v24;
        }
        else {
          uint64_t v9 = v26;
        }
      }
LABEL_25:
      if (!*(void *)v12
        && *(uint64_t (**)(uint64_t, unsigned int, uint64_t, char **, int *, uint64_t, uint64_t, uint64_t))(v12 + 16) == img_raw_read)
      {
        char v30 = img_raw_access(v12, 0);
        long long v37 = *(_OWORD *)a4;
        v38[0] = *(void *)a5;
        if ((v30 & 1) == 0) {
          break;
        }
      }
      else
      {
        long long v37 = *(_OWORD *)a4;
        v38[0] = *(void *)a5;
        if (!v23) {
          break;
        }
      }
      uint64_t v27 = img_raw_data(v12, a2, v9, &v37, v38);
      goto LABEL_31;
    case 2:
      unint64_t v14 = *a4;
      int v15 = *a5;
      unsigned int v16 = *(_DWORD *)(a1 + 56);
      unsigned int v17 = *(_DWORD *)(a1 + 60);
      v38[0] = __PAIR64__(v17, v16);
      uint64_t v18 = (a3 - 1);
      int v19 = v15 * (int)v18 / (int)(v17 + v15);
      if (v19 >= (int)a3
        || (v20 = *(_DWORD *)(a1 + 64), uint64_t v18 = (v15 * (int)v18 / (int)(v17 + v15)), v19 >= v20))
      {
        int v21 = &v14[v15 * (int)a3 - (int)(v18 * v17)];
        *((void *)&v37 + 1) = v21;
        uint64_t v9 = v18;
      }
      else
      {
        if (v20 >= (int)a3) {
          uint64_t v9 = a3;
        }
        else {
          uint64_t v9 = v20;
        }
        uint64_t v22 = *(void *)(a1 + 72);
        int v21 = *(unsigned __int8 **)(a1 + 80);
        *((void *)&v37 + 1) = v21;
        if (v22)
        {
          *(void *)&long long v37 = v22;
          break;
        }
      }
      *(void *)&long long v37 = &v21[-(int)(v9 * v16)];
      break;
  }
  uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, long long *, void *, uint64_t))(v12 + 16))(v12, a2, v9, &v37, v38, a6);
LABEL_31:
  uint64_t v31 = v27;
  if ((int)v27 < 1) {
    return 0;
  }
  int v32 = *(_DWORD *)(v12 + 40);
  if (v32 == 16) {
    int v33 = 2;
  }
  else {
    int v33 = 1;
  }
  if (v32 == 32) {
    int v34 = 4;
  }
  else {
    int v34 = v33;
  }
  if (*(_DWORD *)(a1 + 112) == 5) {
    int v35 = 5;
  }
  else {
    int v35 = v34;
  }
  img_alpha(*(_DWORD *)(v12 + 48), v27, *(unsigned int *)(v12 + 36), *(_DWORD *)(v12 + 44), (unsigned __int8 **)&v37, (int *)v38, *(unsigned int *)(a1 + 44), a4, v28, v29, a5, v35);
  return v31;
}

uint64_t img_blocks_read(void *a1, int a2, unsigned int a3, void *a4, int *a5)
{
  uint64_t v5 = a1[23];
  int v26 = 0;
  int v27 = a2;
  int v28 = a1[15];
  unsigned int v29 = a3;
  if ((int)*(void *)(v5 + 40) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v9 = *(_DWORD *)(v5 + 32);
    uint64_t v10 = 16 * *(void *)(v5 + 40);
    do
    {
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      long long v23 = 0uLL;
      long long v23 = *(_OWORD *)(*(void *)(v5 + 72) + v8);
      if (CGSBoundsIntersection(&v26, (int *)&v23, &v24))
      {
        uint64_t v11 = *(void *)(*(void *)(v5 + 80) + v7);
        uint64_t v12 = *(void *)(*(void *)(v5 + 88) + v7);
        int v13 = (char *)(*a4 + (HIDWORD(v24) - v27) * *a5 + ((int)v24 - (uint64_t)v26) * v9);
        if (!v11) {
          CGBlt_fillBytes(v25 * v9, HIDWORD(v25), 0, v13, *a5);
        }
        uint64_t v14 = a1[14];
        if (v14)
        {
          CGBlt_swapBytes(v25 * v9, HIDWORD(v25), (void *)(v11 + v12 * (SHIDWORD(v24) - (uint64_t)SDWORD1(v23)) + ((int)v24 - (uint64_t)(int)v23) * v9), v13, v12, *a5, v14);
        }
        else
        {
          if (*(void *)(v5 + 48) != *(void *)(v5 + 40))
          {
            int v16 = v24;
            int v17 = HIDWORD(v24);
            LODWORD(v15) = *a5;
LABEL_13:
            CGBlt_copyBytes(v25 * v9, SHIDWORD(v25), (char *)(v11 + v12 * (v17 - (uint64_t)SDWORD1(v23)) + (v16 - (uint64_t)(int)v23) * v9), v13, v12, v15);
            goto LABEL_14;
          }
          uint64_t v15 = *a5;
          int v16 = v24;
          int v17 = HIDWORD(v24);
          if ((v15 & 0x80000000) != 0 || v12 != v15) {
            goto LABEL_13;
          }
          memcpy(v13, (const void *)(v11 + v12 * (SHIDWORD(v24) - (uint64_t)SDWORD1(v23)) + ((int)v24 - (int)v23) * v9), v12 * SHIDWORD(v25));
        }
      }
LABEL_14:
      v8 += 16;
      v7 += 8;
    }
    while (v10 != v8);
  }
  uint64_t result = a3;
  a1[11] = (int)(a3 + a2);
  return result;
}

uint64_t CGSImageDataLockPixels(size_t a1, size_t a2, uint64_t a3, int *a4, _DWORD *a5, CGColorSpace *a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, void *cf, int a12, int *a13)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    _CGHandleAssert("CGSImageDataLockPixels", 5886, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "destination != NULL && CFGetTypeID(destination) == CGColorTransformGetTypeID()", "color transform (%p) invalid (%s)", (uint64_t)a6, a7, a8, 0);
  }
  CFTypeID v28 = CFGetTypeID(cf);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v28 != CGColorTransformGetTypeID_type_id)
  {
    CFTypeID v86 = CFGetTypeID(cf);
    CFStringRef v87 = CFCopyTypeIDDescription(v86);
    CFStringGetCStringPtr(v87, 0x8000100u);
    _CGHandleAssert("CGSImageDataLockPixels", 5886, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "destination != NULL && CFGetTypeID(destination) == CGColorTransformGetTypeID()", "color transform (%p) invalid (%s)", v88, v89, v90, (char)cf);
  }
  uint64_t v96 = a7;
  if (!a4) {
    goto LABEL_53;
  }
  if (!a3) {
    goto LABEL_53;
  }
  if (!a5) {
    goto LABEL_53;
  }
  unsigned int v29 = *(const void **)a3;
  if (!*(void *)a3) {
    goto LABEL_53;
  }
  size_t v30 = *a4;
  if (!v30) {
    goto LABEL_53;
  }
  memset((char *)v97 + 8, 0, 144);
  *(void *)&v97[0] = a1;
  if (!a1) {
    goto LABEL_53;
  }
  *((void *)&v97[0] + 1) = a2;
  if (!a2) {
    goto LABEL_53;
  }
  unint64_t v31 = *a5;
  uint64_t v92 = a8;
  if (!*(void *)(a3 + 8)) {
    goto LABEL_16;
  }
  unsigned int v32 = (v31 >> 2) & 3;
  if (v32 == 2)
  {
    int v34 = v31 >> 6;
    if (v34 == 1) {
      int v33 = 2;
    }
    else {
      int v33 = v34 == 2;
    }
    goto LABEL_20;
  }
  if (v32 != 1)
  {
LABEL_16:
    int v94 = 0;
    goto LABEL_21;
  }
  int v33 = 8;
LABEL_20:
  int v94 = v33;
LABEL_21:
  uint64_t v95 = (v31 >> 16) & 0x3F;
  size_t bitsPerPixel = v31 >> 22;
  check_clients_buffer("CGDataProviderCreateWithData", v29, v30 * a2);
  int v35 = CGDataProviderCreateWithDataInternal(0, (uint64_t)v29, v30 * a2, 0, 0);
  if (a6)
  {
    int v36 = bitmap_info_from_depth(*a5, v95);
    if (v94 == 8) {
      int v37 = 0;
    }
    else {
      int v37 = v94;
    }
    __int16 v38 = v36 | v37;
    CGImageRef v39 = CGImageCreate(a1, a2, v95, bitsPerPixel, v30, a6, v36 | v37, v35, 0, 1, kCGRenderingIntentDefault);
    CGDataProviderRelease(v35);
    if (v94 == 8)
    {
      size_t v40 = a4[1];
      size_t v41 = ((_BYTE)v95 + 7) & 0x78;
      int v42 = *(const void **)(a3 + 8);
      check_clients_buffer("CGDataProviderCreateWithData", v42, v40 * a2);
      int v43 = CGDataProviderCreateWithDataInternal(0, (uint64_t)v42, v40 * a2, 0, 0);
      DeviceGray = CGColorSpaceCreateDeviceGray();
      if (v41 <= 8) {
        CGBitmapInfo v45 = 0;
      }
      else {
        CGBitmapInfo v45 = v38 & 0x7100;
      }
      CGImageRef v46 = CGImageCreate(a1, a2, v41, v41, v40, DeviceGray, v45, v43, 0, 0, kCGRenderingIntentDefault);
      memset(__src, 0, 32);
      CGColorSpaceRelease(DeviceGray);
      CGDataProviderRelease(v43);
      CGImageRef v47 = CGImageCreateWithMaskAndMatte((uint64_t)v39, (uint64_t)v46, (uint64_t *)__src);
      if (v46) {
        CFRelease(v46);
      }
      if (v39) {
        CFRelease(v39);
      }
      CGImageRef v39 = v47;
    }
  }
  else
  {
    __src[0] = xmmword_185293280;
    CGImageRef v39 = mask_create(a1, a2, v95, bitsPerPixel, v30, v35, (double *)__src, 1, 4);
    CGDataProviderRelease(v35);
    if (v94 == 8) {
      _CGHandleAssert("img_pixels_for_destination", 4029, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "cs != NULL", "colorspace missing", v25, v26, v27, decode);
    }
  }
  if (!v39) {
    goto LABEL_52;
  }
  Cache = CGColorTransformGetCache(cf);
  if (Cache && (uint64_t v56 = Cache[2]) != 0) {
    uint64_t v57 = *(void *)(*(void *)(v56 + 24) + 48);
  }
  else {
    uint64_t v57 = 0;
  }
  int v58 = (*a13 >> 2) & 3;
  if (v58 == 2)
  {
    int v60 = *a13 >> 6;
    int v59 = v60 == 1 ? 2 : v60 == 2;
  }
  else
  {
    int v59 = v58 == 1 ? 8 : 0;
  }
  uint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(a12, v49, v50, v51, v52, v53, v54, v55);
  int v62 = *a13;
  uint64_t v73 = CGPixelComponentGetBitsPerComponent(a12, v63, v64, v65, v66, v67, v68, v69);
  if ((unint64_t)(v73 - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v70, v71, v72, v73);
  }
  int v74 = bitmap_info_from_depth(v62, BitsPerComponent) & 0x3000;
  memset(__src, 0, sizeof(__src));
  CGBitmapPixelInfoInitializeWithImage(__src, __src, v39);
  int v99 = a12;
  int v100 = 0;
  uint64_t v101 = v73;
  uint64_t v102 = v57;
  int v103 = v59;
  int v104 = v74;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  memcpy(__dst, __src, sizeof(__dst));
  BOOL v75 = data_conversion_required(cf, (uint64_t *)v39, &v99, __dst);
  char v76 = v75;
  int v99 = a12;
  int v100 = 0;
  uint64_t v101 = v73;
  uint64_t v102 = v57;
  int v103 = v59;
  int v104 = v74;
  long long v105 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  uint64_t v77 = img_image((uint64_t)v97, (uint64_t)a13, cf, v75, &v99, (uint64_t)v39, a10);
  if (v77)
  {
    long long v79 = *(_OWORD *)(v77 + 112);
    __n128 v78 = *(__n128 *)(v77 + 128);
    uint64_t v80 = *(void *)(v77 + 144);
    v97[6] = *(_OWORD *)(v77 + 96);
    long long v81 = *(_OWORD *)(v77 + 16);
    v97[0] = *(_OWORD *)v77;
    v97[1] = v81;
    long long v82 = *(_OWORD *)(v77 + 32);
    long long v83 = *(_OWORD *)(v77 + 48);
    long long v84 = *(_OWORD *)(v77 + 80);
    v97[4] = *(_OWORD *)(v77 + 64);
    v97[5] = v84;
    v97[2] = v82;
    v97[3] = v83;
    *(void *)&v97[9] = v80;
    v97[7] = v79;
    v97[8] = v78;
    BYTE8(v97[6]) = 1;
    uint64_t v23 = v92;
    if (*(void *)&v97[0] && *((void *)&v97[0] + 1)) {
      return img_data_lock((uint64_t)"CGSImageDataLockPixels", v78, (uint64_t)v97, v96, v92, a9, 1, a10, (uint64_t)cf, v76, (uint64_t)a13, a12, 1u, 3u);
    }
  }
  else
  {
LABEL_52:
    v97[0] = 0uLL;
  }
LABEL_53:
  CGPostError((uint64_t)"%s: Bad pixel image source", v21, v22, v23, v24, v25, v26, v27, (char)"CGSImageDataLockPixels");
  return 0;
}

uint64_t bitmap_info_from_depth(char a1, uint64_t a2)
{
  int v2 = (a1 & 0x30) == 32;
  int v3 = v2 << 13;
  int v4 = v2 << 12;
  int v5 = ((a1 & 0x30) == 16) << 13;
  if (a2 != 8) {
    int v5 = 0;
  }
  if (a2 == 16) {
    int v5 = v4;
  }
  if (a2 == 32) {
    int v5 = v3;
  }
  return v5 | ((a1 & 1) << 8);
}

void AddPdfOperators(CGPDFOperatorTable *a1)
{
  CGPDFOperatorTableSetCallback(a1, "b", (CGPDFOperatorCallback)op_b_12256);
  CGPDFOperatorTableSetCallback(a1, "B", (CGPDFOperatorCallback)op_B_12255);
  CGPDFOperatorTableSetCallback(a1, "BMC", (CGPDFOperatorCallback)op_BMC_12254);
  CGPDFOperatorTableSetCallback(a1, "BDC", (CGPDFOperatorCallback)op_BDC_12253);
  CGPDFOperatorTableSetCallback(a1, "EMC", (CGPDFOperatorCallback)op_EMC_12252);
  CGPDFOperatorTableSetCallback(a1, "BT", (CGPDFOperatorCallback)op_BT_12251);
  CGPDFOperatorTableSetCallback(a1, "b*", (CGPDFOperatorCallback)op_bstar_12250);
  CGPDFOperatorTableSetCallback(a1, "B*", (CGPDFOperatorCallback)op_Bstar_12249);
  CGPDFOperatorTableSetCallback(a1, "c", (CGPDFOperatorCallback)op_c_12248);
  CGPDFOperatorTableSetCallback(a1, "cm", (CGPDFOperatorCallback)op_cm_12247);
  CGPDFOperatorTableSetCallback(a1, "cs", (CGPDFOperatorCallback)op_cs_12246);
  CGPDFOperatorTableSetCallback(a1, "CS", (CGPDFOperatorCallback)op_CS_12245);
  CGPDFOperatorTableSetCallback(a1, "Do", (CGPDFOperatorCallback)op_Do_12242);
  CGPDFOperatorTableSetCallback(a1, "d", (CGPDFOperatorCallback)op_d_12241);
  CGPDFOperatorTableSetCallback(a1, "DP", (CGPDFOperatorCallback)op_DP_12240);
  CGPDFOperatorTableSetCallback(a1, "d0", (CGPDFOperatorCallback)op_d0_12239);
  CGPDFOperatorTableSetCallback(a1, "d1", (CGPDFOperatorCallback)op_d1_12238);
  CGPDFOperatorTableSetCallback(a1, "EI", (CGPDFOperatorCallback)op_EI_12216);
  CGPDFOperatorTableSetCallback(a1, "ET", (CGPDFOperatorCallback)op_ET_12215);
  CGPDFOperatorTableSetCallback(a1, "f", (CGPDFOperatorCallback)op_f_12214);
  CGPDFOperatorTableSetCallback(a1, "F", (CGPDFOperatorCallback)op_f_12214);
  CGPDFOperatorTableSetCallback(a1, "f*", (CGPDFOperatorCallback)op_fstar_12213);
  CGPDFOperatorTableSetCallback(a1, "g", (CGPDFOperatorCallback)op_g_12212);
  CGPDFOperatorTableSetCallback(a1, "G", (CGPDFOperatorCallback)op_G_12211);
  CGPDFOperatorTableSetCallback(a1, "gs", (CGPDFOperatorCallback)op_gs_12207);
  CGPDFOperatorTableSetCallback(a1, "h", (CGPDFOperatorCallback)op_h_12190);
  CGPDFOperatorTableSetCallback(a1, "i", (CGPDFOperatorCallback)op_i_12206);
  CGPDFOperatorTableSetCallback(a1, "j", (CGPDFOperatorCallback)op_j_12205);
  CGPDFOperatorTableSetCallback(a1, "J", (CGPDFOperatorCallback)op_J_12204);
  CGPDFOperatorTableSetCallback(a1, "k", (CGPDFOperatorCallback)op_k_12203);
  CGPDFOperatorTableSetCallback(a1, "K", (CGPDFOperatorCallback)op_K_12202);
  CGPDFOperatorTableSetCallback(a1, "l", (CGPDFOperatorCallback)op_l_12201);
  CGPDFOperatorTableSetCallback(a1, "m", (CGPDFOperatorCallback)op_m_12200);
  CGPDFOperatorTableSetCallback(a1, "M", (CGPDFOperatorCallback)op_M_12199);
  CGPDFOperatorTableSetCallback(a1, "MP", (CGPDFOperatorCallback)op_MP_12198);
  CGPDFOperatorTableSetCallback(a1, "n", (CGPDFOperatorCallback)op_n_12197);
  CGPDFOperatorTableSetCallback(a1, "q", (CGPDFOperatorCallback)op_q_12196);
  CGPDFOperatorTableSetCallback(a1, "Q", (CGPDFOperatorCallback)op_Q_12195);
  CGPDFOperatorTableSetCallback(a1, "re", (CGPDFOperatorCallback)op_re_12194);
  CGPDFOperatorTableSetCallback(a1, "RG", (CGPDFOperatorCallback)op_RG_12193);
  CGPDFOperatorTableSetCallback(a1, "rg", (CGPDFOperatorCallback)op_rg_12192);
  CGPDFOperatorTableSetCallback(a1, "ri", (CGPDFOperatorCallback)op_ri_12191);
  CGPDFOperatorTableSetCallback(a1, "s", (CGPDFOperatorCallback)op_s_12189);
  CGPDFOperatorTableSetCallback(a1, "S", (CGPDFOperatorCallback)op_S_12188);
  CGPDFOperatorTableSetCallback(a1, "sc", (CGPDFOperatorCallback)op_sc_12187);
  CGPDFOperatorTableSetCallback(a1, "SC", (CGPDFOperatorCallback)op_SC_12186);
  CGPDFOperatorTableSetCallback(a1, "SCN", (CGPDFOperatorCallback)op_SCN_12185);
  CGPDFOperatorTableSetCallback(a1, "scn", (CGPDFOperatorCallback)op_scn_12184);
  CGPDFOperatorTableSetCallback(a1, "sh", (CGPDFOperatorCallback)op_sh_12183);
  CGPDFOperatorTableSetCallback(a1, "Tc", (CGPDFOperatorCallback)op_Tc_12182);
  CGPDFOperatorTableSetCallback(a1, "Td", (CGPDFOperatorCallback)op_Td_12181);
  CGPDFOperatorTableSetCallback(a1, "TD", (CGPDFOperatorCallback)op_TD_12180);
  CGPDFOperatorTableSetCallback(a1, "Tf", (CGPDFOperatorCallback)op_Tf_12178);
  CGPDFOperatorTableSetCallback(a1, "Tj", (CGPDFOperatorCallback)op_Tj_12177);
  CGPDFOperatorTableSetCallback(a1, "TJ", (CGPDFOperatorCallback)op_TJ_12176);
  CGPDFOperatorTableSetCallback(a1, "TL", (CGPDFOperatorCallback)op_TL_12175);
  CGPDFOperatorTableSetCallback(a1, "Tm", (CGPDFOperatorCallback)op_Tm_12174);
  CGPDFOperatorTableSetCallback(a1, "Tr", (CGPDFOperatorCallback)op_Tr_12173);
  CGPDFOperatorTableSetCallback(a1, "T*", (CGPDFOperatorCallback)op_Tstar_12163);
  CGPDFOperatorTableSetCallback(a1, "Ts", (CGPDFOperatorCallback)op_Ts_12172);
  CGPDFOperatorTableSetCallback(a1, "Tw", (CGPDFOperatorCallback)op_Tw_12171);
  CGPDFOperatorTableSetCallback(a1, "Tz", (CGPDFOperatorCallback)op_Tz_12170);
  CGPDFOperatorTableSetCallback(a1, "v", (CGPDFOperatorCallback)op_v_12169);
  CGPDFOperatorTableSetCallback(a1, "W", (CGPDFOperatorCallback)op_W_12168);
  CGPDFOperatorTableSetCallback(a1, "w", (CGPDFOperatorCallback)op_w_12167);
  CGPDFOperatorTableSetCallback(a1, "W*", (CGPDFOperatorCallback)op_Wstar_12166);
  CGPDFOperatorTableSetCallback(a1, "y", (CGPDFOperatorCallback)op_y_12165);
  CGPDFOperatorTableSetCallback(a1, "'", (CGPDFOperatorCallback)op_quo_12164);

  CGPDFOperatorTableSetCallback(a1, "\"", (CGPDFOperatorCallback)op_quoquo_12162);
}

void op_quoquo_12162(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  BOOL v4 = CGPDFScannerPopString(a1, &value);
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 184)))
  {
    BOOL v5 = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 192));
    if (v5 && v4)
    {
      op_Tstar_12163(v5, a2);
      ShowText(a2, (uint64_t)value);
    }
  }
}

__n128 op_Tstar_12163(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  float64x2_t v3 = *(float64x2_t *)(v2 + 136);
  float64x2_t v4 = *(float64x2_t *)(v2 + 152);
  double v5 = *(double *)(v2 + 144) + vmuld_lane_f64(0.0, v4, 1);
  float64x2_t v6 = vaddq_f64(*(float64x2_t *)(v2 + 168), vmlaq_f64(vmulq_n_f64(v4, -*(double *)(v2 + 208)), (float64x2_t)0, v3));
  *(double *)(v2 + 88) = v3.f64[0] + 0.0 * v4.f64[0];
  *(double *)(v2 + 96) = v5;
  *(float64x2_t *)(v2 + 104) = vmlaq_f64(v4, (float64x2_t)0, v3);
  *(float64x2_t *)(v2 + 120) = v6;
  *(_OWORD *)(v2 + 152) = *(_OWORD *)(v2 + 104);
  *(_OWORD *)(v2 + 136) = *(_OWORD *)(v2 + 88);
  __n128 result = *(__n128 *)(v2 + 120);
  *(__n128 *)(v2 + 168) = result;
  return result;
}

void op_quo_12164(CGPDFScanner *a1, uint64_t a2)
{
  op_Tstar_12163((uint64_t)a1, a2);
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value)) {
    ShowText(a2, (uint64_t)value);
  }
}

void op_y_12165(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  CGPDFReal v7 = 0.0;
  CGFloat v4 = 0.0;
  CGPDFReal v5 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &v5)
    && !CGPathIsEmpty(*(CGPathRef *)(*(void *)(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(*(void *)(a2 + 40) + 64), (const CGAffineTransform *)(*(void *)(a2 + 40) + 16), v5, v4, v7, value, v7, value);
  }
}

uint64_t op_Wstar_12166(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddClip(a2, 0);
}

BOOL op_w_12167(CGPDFScanner *a1, uint64_t a2)
{
  BOOL result = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 296));
  if (result) {
    *(unsigned char *)(*(void *)(a2 + 40) + 9) = 1;
  }
  return result;
}

uint64_t op_W_12168(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddClip(a2, 1);
}

void op_v_12169(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  CGPDFReal v9 = 0.0;
  double v6 = 0.0;
  CGPDFReal v7 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7)
    && !CGPathIsEmpty(*(CGPathRef *)(*(void *)(a2 + 40) + 64)))
  {
    CGPoint CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*(void *)(*(void *)(a2 + 40) + 64));
    uint64_t v5 = *(void *)(a2 + 40);
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(v5 + 64), 0, CurrentPoint.x, CurrentPoint.y, *(double *)(v5 + 48) + v6 * *(double *)(v5 + 32) + *(double *)(v5 + 16) * v7, *(double *)(v5 + 56) + v6 * *(double *)(v5 + 40) + *(double *)(v5 + 24) * v7, *(double *)(v5 + 48) + *(double *)(v5 + 32) * value + *(double *)(v5 + 16) * v9, *(double *)(v5 + 56) + *(double *)(v5 + 40) * value + *(double *)(v5 + 24) * v9);
  }
}

BOOL op_Tz_12170(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 200));
}

BOOL op_Tw_12171(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 192));
}

BOOL op_Ts_12172(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 232));
}

BOOL op_Tr_12173(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopInteger(a1, (CGPDFInteger *)(*(void *)(a2 + 40) + 224));
}

__n128 op_Tm_12174(CGPDFScanner *a1, uint64_t a2)
{
  *(CGAffineTransform *)(*(void *)(a2 + 40) + 88) = CGAffineTransformIdentity;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 128))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 120))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 112))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 104))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 96))
    && CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 88)))
  {
    uint64_t v5 = *(void *)(a2 + 40);
    *(_OWORD *)(v5 + 136) = *(_OWORD *)(v5 + 88);
    *(_OWORD *)(v5 + 152) = *(_OWORD *)(v5 + 104);
    __n128 result = *(__n128 *)(v5 + 120);
    *(__n128 *)(v5 + 168) = result;
    *(unsigned char *)(*(void *)(a2 + 40) + 9) = 1;
  }
  return result;
}

BOOL op_TL_12175(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 208));
}

void op_TJ_12176(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFArrayRef value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (value)
    {
      uint64_t v3 = *((void *)value + 2);
      if (v3)
      {
        for (size_t i = 0; i != v3; ++i)
        {
          double v6 = 0;
          if (CGPDFArrayGetObject(value, i, (CGPDFObjectRef *)&v6) && v6)
          {
            switch(*((_DWORD *)v6 + 2))
            {
              case 3:
              case 0xC:
                double v5 = (double)v6[4];
                goto LABEL_10;
              case 4:
                double v5 = *((double *)v6 + 4);
LABEL_10:
                AdjustPosition(a2, v5);
                break;
              case 6:
                ShowText(a2, v6[4]);
                break;
              default:
                continue;
            }
          }
        }
      }
    }
  }
}

void op_Tj_12177(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value)) {
    ShowText(a2, (uint64_t)value);
  }
}

void op_Tf_12178(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v11 = 0;
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11) && CGPDFScannerPopName(a1, (const char **)&value))
  {
    CGFloat v4 = (CGPDFContentStream *)*((void *)a1 + 7);
    if (v4)
    {
      CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v4, "Font", value);
      if (Resource)
      {
        if (*((_DWORD *)Resource + 2) == 8)
        {
          double v6 = (const void *)*((void *)Resource + 4);
          if (v6)
          {
            CGPDFReal v7 = (CPFont *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 2240), v6);
            if (!v7)
            {
              CGPDFReal v7 = [[CPFont alloc] initWith:v6];
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 2240), v6, v7);
            }
            uint64_t v8 = *(void *)(a2 + 40);
            uint64_t v9 = v11;
            uint64_t v10 = *(CPFont **)(v8 + 248);
            if (v10 != v7)
            {

              *(void *)(v8 + 248) = v7;
            }
            *(void *)(v8 + 216) = v9;
            *(unsigned char *)(v8 + 9) = 1;
          }
        }
        *(unsigned char *)(*(void *)(a2 + 40) + 9) = 1;
      }
    }
  }
}

__n128 op_TD_12180(CGPDFScanner *a1, uint64_t a2)
{
  long long v14 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v14 + 1) && CGPDFScannerPopNumber(a1, (CGPDFReal *)&v14))
  {
    double v5 = *((double *)&v14 + 1);
    double v6 = *(double *)&v14;
    CGPDFReal v7 = *(double **)(a2 + 40);
    v7[26] = -*((double *)&v14 + 1);
    double v8 = v7[17];
    double v9 = v7[18];
    double v10 = v7[19];
    double v11 = v7[20];
    double v12 = v7[22];
    double v13 = v7[21] + v10 * v5 + v6 * v8;
    v7[11] = 0.0 * v10 + 1.0 * v8;
    v7[12] = 0.0 * v11 + 1.0 * v9;
    v7[13] = 1.0 * v10 + 0.0 * v8;
    v7[14] = 1.0 * v11 + 0.0 * v9;
    v7[15] = v13;
    v7[16] = v11 * v5 + v6 * v9 + v12;
    *(_OWORD *)(v7 + 19) = *(_OWORD *)(v7 + 13);
    *(_OWORD *)(v7 + 17) = *(_OWORD *)(v7 + 11);
    __n128 result = *(__n128 *)(v7 + 15);
    *(__n128 *)(v7 + 21) = result;
  }
  return result;
}

__n128 op_Td_12181(CGPDFScanner *a1, uint64_t a2)
{
  long long v12 = *(_OWORD *)&CGAffineTransformIdentity.tx;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12 + 1) && CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12))
  {
    double v5 = *(double **)(a2 + 40);
    double v6 = v5[17];
    double v7 = v5[18];
    double v8 = v5[19];
    double v9 = v5[20];
    double v10 = v5[21] + v8 * *((double *)&v12 + 1) + *(double *)&v12 * v6;
    double v11 = v9 * *((double *)&v12 + 1) + *(double *)&v12 * v7 + v5[22];
    v5[11] = 0.0 * v8 + 1.0 * v6;
    v5[12] = 0.0 * v9 + 1.0 * v7;
    v5[13] = 1.0 * v8 + 0.0 * v6;
    v5[14] = 1.0 * v9 + 0.0 * v7;
    v5[15] = v10;
    v5[16] = v11;
    *(_OWORD *)(v5 + 17) = *(_OWORD *)(v5 + 11);
    *(_OWORD *)(v5 + 19) = *(_OWORD *)(v5 + 13);
    __n128 result = *(__n128 *)(v5 + 15);
    *(__n128 *)(v5 + 21) = result;
  }
  return result;
}

BOOL op_Tc_12182(CGPDFScanner *a1, uint64_t a2)
{
  return CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 184));
}

void op_sh_12183(CGPDFScanner *a1, uint64_t a2)
{
  double v6 = 0;
  uint64_t v7 = 0;
  if (common_op_sh(a1, (double *)a2, &v7, &v6))
  {
    CPPDFContextSaveGState(a2);
    uint64_t v3 = *(void *)(a2 + 40);
    *(void *)(v3 + 376) = v7;
    CGFloat v4 = *(const void **)(v3 + 64);
    if (v4)
    {
      CFRelease(v4);
      uint64_t v3 = *(void *)(a2 + 40);
    }
    *(void *)(v3 + 64) = v6;
    char v5 = *(unsigned char *)(v3 + 8);
    *(unsigned char *)(v3 + 8) = 1;
    CPPDFContextAddShape(a2, 1, 1);
    *(unsigned char *)(*(void *)(a2 + 40) + 8) = v5;
    CPPDFContextRestoreGState(a2);
  }
}

void op_scn_12184(CGPDFScanner *a1, uint64_t a2)
{
}

void op_SCN_12185(CGPDFScanner *a1, uint64_t a2)
{
}

void op_SC_12186(CGPDFScanner *a1, uint64_t a2)
{
}

void op_sc_12187(CGPDFScanner *a1, uint64_t a2)
{
}

uint64_t op_S_12188(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStroke(a2);
}

uint64_t op_s_12189(uint64_t a1, uint64_t a2)
{
  op_h_12190(a1, a2);

  return CPPDFContextAddStroke(a2);
}

void op_h_12190(uint64_t a1, uint64_t a2)
{
  if (!CGPathIsEmpty(*(CGPathRef *)(*(void *)(a2 + 40) + 64)))
  {
    uint64_t v3 = *(CGPath **)(*(void *)(a2 + 40) + 64);
    CGPathCloseSubpath(v3);
  }
}

void op_rg_12192(CGPDFScanner *a1, uint64_t a2)
{
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGColorRef v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(const void **)(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 256) = v5;
  double v8 = *(CGColorSpace **)(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 264) = DeviceRGB;
  *(unsigned char *)(v6 + 9) = 1;
}

void op_RG_12193(CGPDFScanner *a1, uint64_t a2)
{
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  CGColorRef v5 = common_PopRGBAlphaCGColorCreate(a1, DeviceRGB);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(const void **)(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 272) = v5;
  double v8 = *(CGColorSpace **)(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 280) = DeviceRGB;
  *(unsigned char *)(v6 + 9) = 1;
}

void op_re_12194(CGPDFScanner *a1, uint64_t a2)
{
  memset(&v3, 0, sizeof(v3));
  if (common_ReadCGRect(a1, &v3.origin.x)) {
    CGPathAddRect(*(CGMutablePathRef *)(*(void *)(a2 + 40) + 64), (const CGAffineTransform *)(*(void *)(a2 + 40) + 16), v3);
  }
}

void op_Q_12195(uint64_t a1, uint64_t a2)
{
}

void op_q_12196(uint64_t a1, uint64_t a2)
{
}

CGMutablePathRef op_n_12197(uint64_t a1, uint64_t a2)
{
  CPPDFContextAddPathToClip(a2, 0);
  CGRect v3 = *(const void **)(*(void *)(a2 + 40) + 64);
  if (v3) {
    CFRelease(v3);
  }
  CGMutablePathRef result = CGPathCreateMutable();
  *(void *)(*(void *)(a2 + 40) + 64) = result;
  return result;
}

BOOL op_MP_12198(CGPDFScanner *a1)
{
  CGPDFStringRef value = 0;
  return CGPDFScannerPopName(a1, (const char **)&value);
}

BOOL op_M_12199(CGPDFScanner *a1, uint64_t a2)
{
  BOOL result = CGPDFScannerPopNumber(a1, (CGPDFReal *)(*(void *)(a2 + 40) + 288));
  if (result) {
    *(unsigned char *)(*(void *)(a2 + 40) + 9) = 1;
  }
  return result;
}

void op_m_12200(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat y = 0.0;
  CGPDFReal value = 0.0;
  if (!CGPDFScannerPopNumber(a1, &y)) {
    CGFloat y = 0.0;
  }
  if (CGPDFScannerPopNumber(a1, &value))
  {
    CGFloat v4 = value;
  }
  else
  {
    CGPDFReal value = 0.0;
    CGFloat v4 = 0.0;
  }
  CGPathMoveToPoint(*(CGMutablePathRef *)(*(void *)(a2 + 40) + 64), (const CGAffineTransform *)(*(void *)(a2 + 40) + 16), v4, y);
}

void op_l_12201(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &value)
    && !CGPathIsEmpty(*(CGPathRef *)(*(void *)(a2 + 40) + 64)))
  {
    CGPathAddLineToPoint(*(CGMutablePathRef *)(*(void *)(a2 + 40) + 64), (const CGAffineTransform *)(*(void *)(a2 + 40) + 16), value, v4);
  }
}

void op_K_12202(CGPDFScanner *a1, uint64_t a2)
{
  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  CGColorRef v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(const void **)(v6 + 272);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 272) = v5;
  double v8 = *(CGColorSpace **)(v6 + 280);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 280) = DeviceCMYK;
  *(unsigned char *)(v6 + 9) = 1;
}

void op_k_12203(CGPDFScanner *a1, uint64_t a2)
{
  DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
  CGColorRef v5 = common_PopCMYKAlphaCGColorCreate(a1, DeviceCMYK);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(const void **)(v6 + 256);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 256) = v5;
  double v8 = *(CGColorSpace **)(v6 + 264);
  if (v8)
  {
    CGColorSpaceRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 264) = DeviceCMYK;
  *(unsigned char *)(v6 + 9) = 1;
}

BOOL op_J_12204(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  BOOL result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 40);
    *(unsigned char *)(v4 + 304) = value;
    *(unsigned char *)(v4 + 9) = 1;
  }
  return result;
}

BOOL op_j_12205(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  BOOL result = CGPDFScannerPopInteger(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 40);
    *(unsigned char *)(v4 + 305) = value;
    *(unsigned char *)(v4 + 9) = 1;
  }
  return result;
}

CGPDFReal op_i_12206(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    CGPDFReal result = value;
    uint64_t v4 = *(void *)(a2 + 40);
    *(CGPDFReal *)(v4 + 312) = value;
    *(unsigned char *)(v4 + 9) = 1;
  }
  return result;
}

CGPDFDictionary *op_gs_12207(CGPDFObjectRef *a1, uint64_t a2)
{
  CGPDFReal value = 0;
  CGPDFReal result = (CGPDFDictionary *)CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value);
  if (result)
  {
    CGPDFReal result = common_GetResourceDictionary(a1[7], "ExtGState", value);
    if (result)
    {
      CGColorRef v5 = result;
      CGPDFReal result = (CGPDFDictionary *)common_op_gs(a2, result);
      if (result)
      {
        arraCGFloat y = 0;
        if (CGPDFDictionaryGetArray(v5, "D", &array))
        {
          uint64_t v8 = 0;
          CGPDFArrayRef v9 = 0;
          if (CGPDFArrayGetArray(array, 0, &v9) && CGPDFArrayGetNumber(array, 1uLL, (CGPDFReal *)&v8))
          {
            uint64_t v6 = *(void *)(a2 + 40);
            *(void *)(v6 + 360) = v9;
            *(void *)(v6 + 352) = v8;
          }
        }
        CGPDFArrayRef v9 = 0;
        CGPDFReal result = (CGPDFDictionary *)CGPDFDictionaryGetDictionary(v5, "SMask", &v9);
        uint64_t v7 = *(void *)(a2 + 40);
        if (result) {
          *(void *)(v7 + 368) = v9;
        }
        *(unsigned char *)(v7 + 9) = 1;
      }
    }
  }
  return result;
}

void op_G_12211(CGPDFScanner *a1, uint64_t a2)
{
  value[2] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value)) {
    value[0] = 0.0;
  }
  value[1] = 1.0;
  CGColorRef v5 = CGColorCreate(DeviceGray, value);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(CGColorSpace **)(v6 + 280);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 280) = DeviceGray;
  uint64_t v8 = *(const void **)(v6 + 272);
  if (v8)
  {
    CFRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 272) = v5;
  *(unsigned char *)(v6 + 9) = 1;
}

void op_g_12212(CGPDFScanner *a1, uint64_t a2)
{
  value[2] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
  if (!CGPDFScannerPopNumber(a1, value)) {
    value[0] = 0.0;
  }
  value[1] = 1.0;
  CGColorRef v5 = CGColorCreate(DeviceGray, value);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *(CGColorSpace **)(v6 + 264);
  if (v7)
  {
    CGColorSpaceRelease(v7);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 264) = DeviceGray;
  uint64_t v8 = *(const void **)(v6 + 256);
  if (v8)
  {
    CFRelease(v8);
    uint64_t v6 = *(void *)(a2 + 40);
  }
  *(void *)(v6 + 256) = v5;
  *(unsigned char *)(v6 + 9) = 1;
}

uint64_t op_fstar_12213(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddFill(a2, 0);
}

uint64_t op_f_12214(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddFill(a2, 1);
}

void op_EI_12216(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStreamRef value = 0;
  if (!CGPDFScannerPopStream(a1, &value)) {
    return;
  }
  if (!value) {
    return;
  }
  CGRect v3 = (CGPDFDictionary *)*((void *)value + 6);
  if (!v3) {
    return;
  }
  CGPDFInteger v47 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "W", &v47) && !CGPDFDictionaryGetInteger(v3, "Width", &v47)) {
    return;
  }
  CGPDFInteger v46 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "H", &v46) && !CGPDFDictionaryGetInteger(v3, "Height", &v46)) {
    return;
  }
  CGPDFInteger v45 = 0;
  if (!CGPDFDictionaryGetInteger(v3, "BPC", &v45) && !CGPDFDictionaryGetInteger(v3, "BitsPerComponent", &v45)) {
    CGPDFInteger v45 = 0;
  }
  CGPDFObjectRef v44 = 0;
  if (!CGPDFDictionaryGetObject(v3, "CS", &v44) && !CGPDFDictionaryGetObject(v3, "ColorSpace", &v44)) {
    CGPDFObjectRef v44 = 0;
  }
  CGPDFBoolean v43 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "IM", &v43) && !CGPDFDictionaryGetBoolean(v3, "ImageMask", &v43)) {
    CGPDFBoolean v43 = 0;
  }
  CGPDFBoolean v42 = 0;
  if (!CGPDFDictionaryGetBoolean(v3, "I", &v42) && !CGPDFDictionaryGetBoolean(v3, "Interpolate", &v42)) {
    CGPDFBoolean v42 = 0;
  }
  CGPDFArrayRef v41 = 0;
  BOOL v4 = CGPDFDictionaryGetArray(v3, "D", &v41) || CGPDFDictionaryGetArray(v3, "Decode", &v41);
  size_t v40 = 0;
  if (v44 && !v43) {
    CreateColorSpaceFromInlineObject((uint64_t)v44, &v40);
  }
  if (!v4)
  {
    char decode = 0;
    goto LABEL_50;
  }
  if (v41) {
    uint64_t v5 = *((void *)v41 + 2);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v7 = v40;
  if (v40) {
    uint64_t v8 = *(void *)(*((void *)v40 + 3) + 48);
  }
  else {
    uint64_t v8 = 0;
  }
  char decode = 0;
  if (v5 && v5 == 2 * v8)
  {
    char decode = (CGFloat *)malloc_type_malloc(8 * v5, 0x100004000313F17uLL);
    for (size_t i = 0; i != v5; ++i)
    {
      v28[0] = 0.0;
      CGPDFArrayGetNumber(v41, i, v28);
      decode[i] = v28[0];
    }
  }
  if (v43) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = v7 == 0;
  }
  if (v10)
  {
    switch(v5)
    {
      case 8:
        DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
        break;
      case 6:
        DeviceCMYK = CGColorSpaceCreateDeviceRGB();
        break;
      case 2:
        DeviceCMYK = CGColorSpaceCreateDeviceGray();
        break;
      default:
        goto LABEL_50;
    }
    size_t v40 = DeviceCMYK;
  }
LABEL_50:
  CGPDFDataFormat format = CGPDFDataFormatRaw;
  CFDataRef v12 = CGPDFStreamCopyData(value, &format);
  if (v12)
  {
    CFDataRef v13 = v12;
    long long v14 = CGDataProviderCreateWithCFData(v12);
    if (!v14)
    {
      CGImageRef v18 = 0;
LABEL_72:
      CFRelease(v13);
      goto LABEL_73;
    }
    uint64_t v15 = v14;
    CGColorRenderingIntent intent = *(_DWORD *)(*(void *)(a2 + 40) + 308);
    if (format)
    {
      if (format == CGPDFDataFormatJPEG2000)
      {
        CFDictionaryRef v19 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&kCGImageSourceTypeIdentifierHint, (const void **)&kUTTypeJPEG2000, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (op_EI_predicate != -1) {
          dispatch_once(&op_EI_predicate, &__block_literal_global_12228);
        }
        int v20 = (const void *)op_EI_f(v13, v19);
        CFRelease(v19);
        if (v20)
        {
          if (op_EI_predicate_86 != -1) {
            dispatch_once(&op_EI_predicate_86, &__block_literal_global_88);
          }
          CGImageRef v18 = (CGImageRef)op_EI_f_85(v20, 0, 0);
          CFRelease(v20);
          goto LABEL_71;
        }
      }
      else if (format == CGPDFDataFormatJPEGEncoded)
      {
        CGImageRef v17 = CGImageCreateWithJPEGDataProvider2((uint64_t)v14, 0, 0, v42 != 0, *(_DWORD *)(*(void *)(a2 + 40) + 308));
LABEL_60:
        CGImageRef v18 = v17;
LABEL_71:
        CGDataProviderRelease(v15);
        goto LABEL_72;
      }
    }
    else
    {
      if (v43)
      {
        CGPDFInteger v45 = 1;
        CGImageRef v17 = mask_create(v47, v46, 1uLL, 1uLL, vcvtps_u32_f32((float)v47 * 0.125), v14, 0, v42 != 0, 4);
        goto LABEL_60;
      }
      CGImageRef v18 = 0;
      uint64_t v21 = v40;
      if (!v40) {
        goto LABEL_71;
      }
      CGPDFInteger v22 = v45;
      if (v45 < 1) {
        goto LABEL_71;
      }
      uint64_t v23 = *(void *)(*((void *)v40 + 3) + 48);
      CGPDFInteger v24 = v47;
      CGPDFInteger Length = CFDataGetLength(v13);
      if (Length >= v47 * v23 * v46 * v45 / 8)
      {
        CGImageRef v17 = CGImageCreate(v47, v46, v45, v22 * v23, vcvtps_u32_f32((float)(unint64_t)(v22 * v23 * v24) * 0.125), v21, 0, v15, decode, v42 != 0, intent);
        goto LABEL_60;
      }
    }
    CGImageRef v18 = 0;
    goto LABEL_71;
  }
  CGImageRef v18 = 0;
LABEL_73:
  if (v40) {
    CGColorSpaceRelease(v40);
  }
  if (decode) {
    free(decode);
  }
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  v28[0] = 0.0;
  v28[1] = 0.0;
  v28[2] = (double)v47;
  v28[3] = (double)v46;
  uint64_t v26 = *(void *)(a2 + 40);
  DWORD2(v32) = *(_DWORD *)(v26 + 308);
  *(void *)&long long v33 = v18;
  *((void *)&v36 + 1) = *(void *)(v26 + 368);
  if (v43) {
    uint64_t v27 = *(void *)(v26 + 256);
  }
  else {
    uint64_t v27 = 0;
  }
  *((void *)&v37 + 1) = v27;
  CPPDFContextAddImage(a2, (long long *)v28);
  if (v18) {
    CFRelease(v18);
  }
}

void op_DP_12240(CGPDFScanner *a1)
{
  int v1 = *((_DWORD *)a1 + 18);
  if (v1 <= 0)
  {
    pdf_error("stack underflow.");
  }
  else
  {
    CGPDFStreamRef value = 0;
    *((_DWORD *)a1 + 18) = v1 - 1;
    CGPDFScannerPopName(a1, (const char **)&value);
  }
}

CGPDFReal op_d_12241(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    CGPDFArrayRef v6 = 0;
    if (CGPDFScannerPopArray(a1, &v6))
    {
      uint64_t v5 = *(void *)(a2 + 40);
      *(void *)(v5 + 360) = v6;
      CGPDFReal result = value;
      *(CGPDFReal *)(v5 + 352) = value;
      *(unsigned char *)(v5 + 9) = 1;
    }
  }
  return result;
}

void op_Do_12242(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFDictionaryRef v27 = 0;
  CFTypeID v28 = 0;
  uint64_t v26 = 0;
  if (common_op_Do(a1, &v28, &v27, (uint64_t)&v26))
  {
    CGRect v3 = v28;
    if (!strcmp(v28, "Image"))
    {
      CGPDFReal v24 = 0.0;
      CGPDFReal value = 0.0;
      BOOL v4 = v27;
      if (!CGPDFDictionaryGetNumber(v27, "Width", &value)) {
        CGPDFReal value = 0.0;
      }
      if (!CGPDFDictionaryGetNumber(v4, "Height", &v24)) {
        CGPDFReal v24 = 0.0;
      }
      CGPDFBoolean v23 = 0;
      if (CGPDFDictionaryGetBoolean(v4, "ImageMask", &v23))
      {
        BOOL v5 = v23 == 0;
      }
      else
      {
        CGPDFBoolean v23 = 0;
        BOOL v5 = 1;
      }
      uint64_t v6 = 0;
      long long v15 = 0u;
      uint64_t v7 = *(void *)(a2 + 40);
      DWORD2(v15) = *(_DWORD *)(v7 + 308);
      *(void *)&long long v15 = v26;
      uint64_t v8 = *(void *)(v7 + 368);
      uint64_t v19 = 0;
      uint64_t v20 = v8;
      uint64_t v22 = 0;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v17 = 0u;
      long long v16 = 0u;
      long long v14 = 0u;
      long long v13 = 0u;
      long long v12 = 0u;
      long long v9 = 0uLL;
      CGPDFReal v10 = value;
      CGPDFReal v11 = v24;
      if (!v5) {
        uint64_t v6 = *(void *)(v7 + 256);
      }
      *((void *)&v21 + 1) = v6;
      CPPDFContextAddImage(a2, &v9);
    }
    else if (!strcmp(v3, "Form"))
    {
      DoPdfForm(a2, v26, 0);
    }
  }
}

void op_CS_12245(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpaceRef v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    CGColorSpaceRef v4 = v3;
    uint64_t v5 = *(void *)(a2 + 40);
    uint64_t v6 = *(CGColorSpace **)(v5 + 280);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      uint64_t v5 = *(void *)(a2 + 40);
    }
    *(void *)(v5 + 280) = v4;
    *(unsigned char *)(v5 + 9) = 1;
  }
}

CGColorSpaceRef CPPDFCreateColorSpace(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0;
  CGColorSpaceRef v4 = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    if (value)
    {
      CGColorSpaceRef v10 = 0;
      CreateColorSpaceFromName(value, &v10);
      CGColorSpaceRef v4 = v10;
      if (!v10)
      {
        uint64_t v5 = (CGPDFContentStream *)*((void *)a1 + 7);
        if (v5 && (CGPDFObjectRef Resource = CGPDFContentStreamGetResource(v5, "ColorSpace", value)) != 0)
        {
          uint64_t v7 = Resource;
          uint64_t v8 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 2248), Resource);
          long long v12 = v8;
          if (v8)
          {
            CGColorSpaceRef v4 = (CGColorSpaceRef)v8;
            CFRetain(v8);
          }
          else
          {
            CreateColorSpaceFromObject(v7, (CGColorSpaceRef *)&v12);
            CGColorSpaceRef v4 = (CGColorSpaceRef)v12;
            if (v12) {
              CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 2248), v7, v12);
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v4;
}

void op_cs_12246(CGPDFScanner *a1, uint64_t a2)
{
  CGColorSpaceRef v3 = CPPDFCreateColorSpace(a1, a2);
  if (v3)
  {
    CGColorSpaceRef v4 = v3;
    uint64_t v5 = *(void *)(a2 + 40);
    uint64_t v6 = *(CGColorSpace **)(v5 + 264);
    if (v6)
    {
      CGColorSpaceRelease(v6);
      uint64_t v5 = *(void *)(a2 + 40);
    }
    *(void *)(v5 + 264) = v4;
    *(unsigned char *)(v5 + 9) = 1;
  }
}

double op_cm_12247(CGPDFScanner *a1, uint64_t a2)
{
  CGAffineTransform v5 = CGAffineTransformIdentity;
  if (common_ReadCGAffineTransform(a1, &v5.a))
  {
    CGAffineTransform v4 = v5;
    return CPPDFContextConcatCTM(*(double **)(a2 + 40), &v4.a);
  }
  return result;
}

void op_c_12248(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v8 = 0.0;
  CGFloat v6 = 0.0;
  CGFloat v7 = 0.0;
  CGFloat v4 = 0.0;
  CGFloat v5 = 0.0;
  CGFloat y = 0.0;
  if (common_ReadCGPathCurve(a1, &v8, &v7, &v6, &v5, &v4, &y)
    && !CGPathIsEmpty(*(CGPathRef *)(*(void *)(a2 + 40) + 64)))
  {
    CGPathAddCurveToPoint(*(CGMutablePathRef *)(*(void *)(a2 + 40) + 64), (const CGAffineTransform *)(*(void *)(a2 + 40) + 16), v8, v7, v6, v5, v4, y);
  }
}

uint64_t op_Bstar_12249(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStrokeAndFill(a2, 0);
}

uint64_t op_bstar_12250(uint64_t a1, uint64_t a2)
{
  op_h_12190(a1, a2);

  return CPPDFContextAddStrokeAndFill(a2, 0);
}

CGFloat op_BT_12251(uint64_t a1, uint64_t a2)
{
  CGFloat result = CGAffineTransformIdentity.a;
  *(CGAffineTransform *)(*(void *)(a2 + 40) + 88) = CGAffineTransformIdentity;
  *(CGAffineTransform *)(*(void *)(a2 + 40) + 136) = CGAffineTransformIdentity;
  return result;
}

uint64_t op_EMC_12252(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 2344);
    if (v2)
    {
      CGColorSpaceRef v3 = *(uint64_t **)(v2 + 16);
      if (v3) {
        return TaggedParser::EndMarkedContentSequence(*v3, *(CGPDFPage **)(a2 + 2288));
      }
    }
  }
  return result;
}

void op_BDC_12253(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.");
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 80);
    unsigned int v4 = v2 - 1;
    *(_DWORD *)(a1 + 72) = v4;
    if (!v3) {
      return;
    }
    int v6 = *(_DWORD *)(v3 + 40 * v4 + 8);
    if (v6 == 8)
    {
      CGFloat v8 = 0;
      CGFloat v7 = *(CGPDFDictionary **)(v3 + 40 * v4 + 32);
    }
    else
    {
      if (v6 != 5) {
        return;
      }
      CGFloat v7 = 0;
      CGFloat v8 = *(const char **)(v3 + 40 * v4 + 32);
    }
    CGPDFReal value = 0;
    BOOL v9 = CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value);
    if (a2)
    {
      if (v9)
      {
        uint64_t v11 = *(void *)(a2 + 2344);
        if (v11)
        {
          long long v12 = *(CGPDFPage **)(a2 + 2288);
          long long v13 = *(TaggedParser **)(v11 + 16);
          if (v8)
          {
            if (v13) {
              TaggedParser::BeginMarkedContentSequence(v13, v12, v8, v10);
            }
          }
          else if (v13)
          {
            TaggedParser::BeginMarkedContentSequence(v13, v12, v7, (CGPDFDictionary *)v10);
          }
        }
      }
    }
  }
}

void op_BMC_12254(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0;
  BOOL v3 = CGPDFScannerPopName(a1, (const char **)&value);
  if (a2)
  {
    if (v3)
    {
      uint64_t v5 = *(void *)(a2 + 2344);
      if (v5)
      {
        int v6 = *(TaggedParser **)(v5 + 16);
        if (v6) {
          TaggedParser::BeginMarkedContentSequence(v6, *(CGPDFPage **)(a2 + 2288), 0, v4);
        }
      }
    }
  }
}

uint64_t op_B_12255(uint64_t a1, uint64_t a2)
{
  return CPPDFContextAddStrokeAndFill(a2, 1);
}

uint64_t op_b_12256(uint64_t a1, uint64_t a2)
{
  op_h_12190(a1, a2);

  return CPPDFContextAddStrokeAndFill(a2, 1);
}

uint64_t path_add(unsigned __int8 **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (CGColorSpaceRef v10 = *a1) == 0) {
    _CGHandleAssert("path_add", 94, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path-internal.c", "pathp != NULL && *pathp != NULL", "Element type (%d) added to NULL path %p", a6, a7, a8, a2);
  }
  if (a2 > 0xFFFFFFFD) {
    return 0;
  }
  if (a2 + 3 >= 8) {
    abort();
  }
  uint64_t v12 = dword_185211808[a2 + 3];
  uint64_t v13 = *((void *)v10 + 5);
  if ((a2 | 4) == 4)
  {
    long long v14 = (unsigned __int8 *)*((void *)v10 + 2);
    if (v14 < &v10[v13 + 48] && *v14 == a2) {
      return *((void *)v10 + 4);
    }
  }
  else
  {
    long long v14 = (unsigned __int8 *)*((void *)v10 + 2);
  }
  if (*((void *)v10 + 3) + 16 * v12 > (unint64_t)(v14 - 1))
  {
    if ((unint64_t)(2 * v13) >= 0x7D1) {
      uint64_t v15 = *((void *)v10 + 5);
    }
    else {
      uint64_t v15 = 2 * v13;
    }
    long long v16 = (unsigned __int8 *)malloc_type_malloc(v15 + 48, 0x65B64981uLL);
    *(void *)long long v16 = v10;
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 2) = &v16[v15 + 48];
    *((void *)v16 + 3) = (unint64_t)(v16 + 55) & 0xFFFFFFFFFFFFFFF8;
    *((void *)v10 + 1) = v16;
    *((void *)v16 + 4) = *((void *)v10 + 4);
    *((void *)v16 + 5) = v15;
    *a1 = v16;
    long long v14 = (unsigned __int8 *)*((void *)v16 + 2);
    CGColorSpaceRef v10 = v16;
  }
  *((void *)v10 + 2) = v14 - 1;
  *(v14 - 1) = a2;
  uint64_t result = *((void *)v10 + 3);
  *((void *)v10 + 3) = result + 16 * v12;
  if (!a2 || a2 == -3) {
    *((void *)v10 + 4) = result;
  }
  return result;
}

void *path_reset(void *result)
{
  if (result)
  {
    int v1 = result;
    uint64_t result = (void *)*result;
    if (result)
    {
      int v2 = (void *)*result;
      if (*result)
      {
        do
        {
          BOOL v3 = v2;
          free(result);
          v3[1] = 0;
          int v2 = (void *)*v3;
          uint64_t result = v3;
        }
        while (*v3);
      }
      else
      {
        BOOL v3 = result;
      }
      void *v1 = v3;
      unsigned int v4 = (char *)v3 + v3[5];
      v3[3] = ((unint64_t)v3 + 55) & 0xFFFFFFFFFFFFFFF8;
      v3[4] = 0;
      v3[2] = v4 + 48;
    }
  }
  return result;
}

void path_free(void *a1)
{
  int v1 = a1;
  if (a1)
  {
    path_reset(&v1);
    if (v1) {
      free(v1);
    }
  }
}

uint64_t path_element(uint64_t result)
{
  if (result)
  {
    int v1 = *(void **)result;
    if (!*(void *)result)
    {
      *(void *)(result + 16) = 0;
      *(void *)(result + 24) = 0;
      *(_DWORD *)(result + 8) = 4;
      return 0;
    }
    uint64_t v2 = *(void *)(result + 24);
    if (v2 && (uint64_t v3 = *(void *)(result + 16)) != 0)
    {
      unsigned int v4 = *(_DWORD *)(result + 8) + 3;
      if (v4 >= 8) {
        abort();
      }
      uint64_t v5 = (unsigned __int8 *)(v2 - 1);
      *(void *)(result + 16) = v3 + 16 * dword_185211808[v4];
      *(void *)(result + 24) = v5;
      if ((unint64_t)v5 >= v1[2])
      {
        *(_DWORD *)(result + 8) = *v5;
        return result;
      }
      int v6 = (void *)v1[1];
      *(void *)uint64_t result = v6;
      if (!v6)
      {
        *(_DWORD *)(result + 8) = 4;
        *(void *)(result + 16) = 0;
        *(void *)(result + 24) = 0;
        return 0;
      }
    }
    else
    {
      do
      {
        int v6 = v1;
        int v1 = (void *)*v1;
      }
      while (v1);
    }
    CGFloat v7 = (unsigned __int8 *)v6 + v6[5] + 47;
    *(void *)(result + 24) = v7;
    if ((unint64_t)v7 < v6[2])
    {
      *(void *)uint64_t result = 0;
      *(_DWORD *)(result + 8) = 4;
      *(void *)(result + 16) = 0;
      *(void *)(result + 24) = 0;
      return 0;
    }
    *(void *)uint64_t result = v6;
    *(_DWORD *)(result + 8) = *v7;
    *(void *)(result + 16) = ((unint64_t)v6 + 55) & 0xFFFFFFFFFFFFFFF8;
  }
  return result;
}

void *path_iterator_iterate(void *result, uint64_t a2)
{
  if (result && a2)
  {
    uint64_t v2 = result;
    v5[0] = a2;
    v5[1] = 4;
    v5[2] = 0;
    v5[3] = 0;
    uint64_t v3 = (void (*)(void, void, void))result[2];
    if (v3) {
      v3(result[1], 0, result[6]);
    }
    while (1)
    {
      uint64_t result = (void *)path_element((uint64_t)v5);
      if (!result) {
        break;
      }
      ((void (*)(void, void, void, void))v2[3])(v2[1], *((unsigned int *)result + 2), result[2], v2[6]);
    }
    unsigned int v4 = (uint64_t (*)(void, void))v2[4];
    if (v4) {
      return (void *)v4(v2[1], v2[6]);
    }
  }
  return result;
}

void *path_iterator_unrollpath(void *result, unsigned __int8 **a2)
{
  if (a2)
  {
    uint64_t v3 = *a2;
    if (*a2)
    {
      unsigned int v4 = result;
      do
      {
        while (1)
        {
          uint64_t v5 = (unsigned __int8 *)*((void *)v3 + 2);
          if (v5 >= &v3[*((void *)v3 + 5) + 48]) {
            break;
          }
          *((void *)v3 + 2) = v5 + 1;
          uint64_t v6 = *v5;
          if (v6 >= 5) {
            abort();
          }
          *((void *)v3 + 3) -= 16 * dword_185211808[v6 + 3];
          ((void (*)(void))v4[3])(v4[1]);
        }
        uint64_t v3 = *(unsigned __int8 **)v3;
      }
      while (v3);
      return path_reset(a2);
    }
  }
  return result;
}

uint64_t ___ZL24CGPDFPageLayoutGetTypeIDv_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFPageLayoutGetTypeID(void)::CGPDFPageLayoutType);
  CGPDFPageLayoutGetTypeID(void)::typeID = result;
  return result;
}

void CGPDFPageLayoutFinalize(char *a1)
{
}

void PageLayout::~PageLayout(PageLayout *this)
{
  uint64_t v2 = (void *)*((void *)this + 57);
  if (v2)
  {
    *((void *)this + 58) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 54);
  if (v3)
  {
    *((void *)this + 55) = v3;
    operator delete(v3);
  }
  unsigned int v4 = (void *)*((void *)this + 51);
  if (v4)
  {
    *((void *)this + 52) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 48);
  if (v5)
  {
    *((void *)this + 49) = v5;
    operator delete(v5);
  }
  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table((uint64_t)this + 336);

  uint64_t v6 = (void *)*((void *)this + 37);
  if (v6)
  {
    *((void *)this + 38) = v6;
    operator delete(v6);
  }
  CGFloat v7 = (void *)*((void *)this + 34);
  if (v7)
  {
    *((void *)this + 35) = v7;
    operator delete(v7);
  }
  long long v16 = (void **)((char *)this + 248);
  std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:fe180100](&v16);
  CGFloat v8 = (void *)*((void *)this + 28);
  if (v8)
  {
    *((void *)this + 29) = v8;
    operator delete(v8);
  }
  BOOL v9 = (void *)*((void *)this + 25);
  if (v9)
  {
    *((void *)this + 26) = v9;
    operator delete(v9);
  }
  long long v16 = (void **)((char *)this + 176);
  std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:fe180100](&v16);
  CGColorSpaceRef v10 = (void *)*((void *)this + 19);
  if (v10)
  {
    *((void *)this + 20) = v10;
    operator delete(v10);
  }
  uint64_t v11 = (void *)*((void *)this + 16);
  if (v11)
  {
    *((void *)this + 17) = v11;
    operator delete(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 13);
  if (v12)
  {
    *((void *)this + 14) = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 10);
  if (v13)
  {
    *((void *)this + 11) = v13;
    operator delete(v13);
  }
  long long v14 = (void *)*((void *)this + 7);
  if (v14)
  {
    *((void *)this + 8) = v14;
    operator delete(v14);
  }
  uint64_t v15 = (void *)*((void *)this + 4);
  if (v15)
  {
    *((void *)this + 5) = v15;
    operator delete(v15);
  }
}

CFTypeRef CGPDFPageLayoutRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void CGPDFPageLayoutRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFPageLayoutEqualToPageLayout(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(unsigned __int8 *)(a1 + 24) != *(unsigned __int8 *)(a2 + 24)) {
      return 0;
    }
    uint64_t result = [*(id *)(a1 + 40) isEqualToString:*(void *)(a2 + 40)];
    if (!result) {
      return result;
    }
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v7 = *(void *)(a2 + 48);
    if (v5 - v6 != *(void *)(a2 + 56) - v7) {
      return 0;
    }
    for (; v6 != v5; v7 += 72)
    {
      BOOL v8 = *(void *)v6 == *(void *)v7 && *(void *)(v6 + 8) == *(void *)(v7 + 8);
      if (!v8 || *(void *)(v6 + 16) != *(void *)(v7 + 16)) {
        return 0;
      }
      uint64_t result = CGRectEqualToRect(*(CGRect *)(v6 + 24), *(CGRect *)(v7 + 24));
      if (!result) {
        return result;
      }
      if (vabdd_f64(*(double *)(v6 + 56), *(double *)(v7 + 56)) > 0.00000011920929) {
        return 0;
      }
      v6 += 72;
    }
    BOOL v9 = *(const void **)(a1 + 72);
    size_t v10 = *(void *)(a1 + 80) - (void)v9;
    uint64_t v11 = *(const void **)(a2 + 72);
    if (v10 != *(void *)(a2 + 80) - (void)v11) {
      return 0;
    }
    if (memcmp(v9, v11, v10)) {
      return 0;
    }
    uint64_t v12 = *(const void **)(a1 + 96);
    size_t v13 = *(void *)(a1 + 104) - (void)v12;
    long long v14 = *(const void **)(a2 + 96);
    if (v13 != *(void *)(a2 + 104) - (void)v14) {
      return 0;
    }
    if (memcmp(v12, v14, v13)) {
      return 0;
    }
    uint64_t v15 = *(CGRect **)(a1 + 120);
    long long v16 = *(CGRect **)(a1 + 128);
    long long v17 = *(CGRect **)(a2 + 120);
    if ((char *)v16 - (char *)v15 != *(void *)(a2 + 128) - (void)v17) {
      return 0;
    }
    while (v15 != v16)
    {
      uint64_t result = std::__equal_to::operator()[abi:fe180100]<CGRect,CGRect>(v15, v17);
      if (!result) {
        return result;
      }
      ++v15;
      ++v17;
    }
    long long v18 = *(CGRect **)(a1 + 144);
    uint64_t v19 = *(CGRect **)(a1 + 152);
    uint64_t v20 = *(CGRect **)(a2 + 144);
    if ((char *)v19 - (char *)v18 != *(void *)(a2 + 152) - (void)v20) {
      return 0;
    }
    if (v18 == v19) {
      goto LABEL_31;
    }
    do
    {
      uint64_t result = std::__equal_to::operator()[abi:fe180100]<CGRect,CGRect>(v18, v20);
      if (!result) {
        break;
      }
      ++v18;
      ++v20;
    }
    while (v18 != v19);
    if (result)
    {
LABEL_31:
      long long v21 = *(const void **)(a1 + 168);
      size_t v22 = *(void *)(a1 + 176) - (void)v21;
      CGPDFBoolean v23 = *(const void **)(a2 + 168);
      if (v22 == *(void *)(a2 + 176) - (void)v23 && !memcmp(v21, v23, v22))
      {
        CGPDFReal v24 = *(const void **)(a1 + 216);
        size_t v25 = *(void *)(a1 + 224) - (void)v24;
        uint64_t v26 = *(const void **)(a2 + 216);
        if (v25 == *(void *)(a2 + 224) - (void)v26 && !memcmp(v24, v26, v25))
        {
          CFTypeID v28 = *(double **)(a1 + 240);
          CGPDFDictionaryRef v27 = *(double **)(a1 + 248);
          long long v29 = *(double **)(a2 + 240);
          if ((char *)v27 - (char *)v28 == *(void *)(a2 + 248) - (void)v29)
          {
            while (v28 != v27)
            {
              if (*v28 != *v29) {
                return 0;
              }
              ++v28;
              ++v29;
            }
            uint64_t v31 = *(void *)(a1 + 264);
            uint64_t v30 = *(void *)(a1 + 272);
            long long v32 = *(unsigned __int8 ***)(a2 + 264);
            if (v30 - v31 == *(void *)(a2 + 272) - (void)v32)
            {
              if (v31 == v30)
              {
LABEL_69:
                CGPDFBoolean v43 = *(const void **)(a1 + 288);
                size_t v44 = *(void *)(a1 + 296) - (void)v43;
                CGPDFInteger v45 = *(const void **)(a2 + 288);
                if (v44 == *(void *)(a2 + 296) - (void)v45 && !memcmp(v43, v45, v44))
                {
                  CGPDFInteger v46 = *(const void **)(a1 + 312);
                  size_t v47 = *(void *)(a1 + 320) - (void)v46;
                  uint64_t v48 = *(const void **)(a2 + 312);
                  if (v47 == *(void *)(a2 + 320) - (void)v48) {
                    return memcmp(v46, v48, v47) == 0;
                  }
                }
              }
              else
              {
                while (1)
                {
                  uint64_t v33 = *(unsigned __int8 *)(v31 + 23);
                  if ((v33 & 0x80u) == 0) {
                    long long v34 = (unsigned __int8 *)*(unsigned __int8 *)(v31 + 23);
                  }
                  else {
                    long long v34 = *(unsigned __int8 **)(v31 + 8);
                  }
                  long long v35 = (unsigned __int8 *)*((unsigned __int8 *)v32 + 23);
                  int v36 = (char)v35;
                  if ((char)v35 < 0) {
                    long long v35 = v32[1];
                  }
                  if (v34 != v35) {
                    break;
                  }
                  if (v36 >= 0) {
                    long long v37 = (unsigned __int8 *)v32;
                  }
                  else {
                    long long v37 = *v32;
                  }
                  if ((v33 & 0x80) != 0)
                  {
                    BOOL v40 = memcmp(*(const void **)v31, v37, *(void *)(v31 + 8)) == 0;
                  }
                  else if (*(unsigned char *)(v31 + 23))
                  {
                    uint64_t v38 = 0;
                    uint64_t v39 = v33 - 1;
                    do
                    {
                      BOOL v40 = *(unsigned __int8 *)(v31 + v38) == v37[v38];
                      BOOL v41 = *(unsigned __int8 *)(v31 + v38) != v37[v38] || v39 == v38;
                      ++v38;
                    }
                    while (!v41);
                  }
                  else
                  {
                    BOOL v40 = 1;
                  }
                  if (*(_DWORD *)(v31 + 24) != *((_DWORD *)v32 + 6)) {
                    BOOL v40 = 0;
                  }
                  v31 += 32;
                  v32 += 4;
                  if (!v40 || v31 == v30)
                  {
                    if (!v40) {
                      return 0;
                    }
                    goto LABEL_69;
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFPageLayoutCreateEncodedData(uint64_t a1)
{
  if (a1)
  {
    unsigned int v4 = &unk_1ED094660;
    int v25 = 1;
    long long v21 = 0u;
    long long v22 = 0u;
    *(_OWORD *)__p = 0u;
    long long v6 = 0u;
    long long v7 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    uint64_t v23 = 0;
    char v24 = *(unsigned char *)(a1 + 24);
    int v1 = (char *)[*(id *)(a1 + 40) UTF8String];
    size_t v2 = strlen(v1);
    std::string::basic_string[abi:fe180100](&__dst, v1, v2);
    operator new();
  }
  return 0;
}

void sub_184F414CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, char a17)
{
  if (*(char *)(v17 - 169) < 0) {
    operator delete(*(void **)(v17 - 192));
  }
  PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&a17);
  _Unwind_Resume(a1);
}

uint64_t CGPDFLayoutCreateFromEncodedData(const __CFData *a1)
{
  if (!a1) {
    return 0;
  }
  if (CGPDFPageLayoutGetTypeID(void)::onceToken != -1) {
    dispatch_once(&CGPDFPageLayoutGetTypeID(void)::onceToken, &__block_literal_global_12270);
  }
  uint64_t cftype = pdf_create_cftype();
  uint64_t v3 = cftype;
  if (cftype)
  {
    *(_OWORD *)(cftype + 240) = 0u;
    *(void *)(cftype + 16) = 0;
    *(unsigned char *)(cftype + 24) = 0;
    *(_OWORD *)(cftype + 32) = 0u;
    unsigned int v4 = (_OWORD *)(cftype + 32);
    *(_OWORD *)(cftype + 96) = 0u;
    unsigned int v181 = (void **)(cftype + 96);
    *(_OWORD *)(cftype + 144) = 0u;
    unsigned int v179 = (void **)(cftype + 144);
    unsigned int v180 = (void **)(cftype + 120);
    *(_OWORD *)(cftype + 192) = 0u;
    int v182 = (int64x2_t *)(cftype + 192);
    uint64_t v177 = (void **)(cftype + 216);
    unint64_t v178 = (void **)(cftype + 168);
    int v183 = (uint64_t *)(cftype + 264);
    uint64_t v174 = (void **)(cftype + 72);
    uint64_t v175 = (void **)(cftype + 288);
    *(_OWORD *)(cftype + 48) = 0u;
    *(_OWORD *)(cftype + 64) = 0u;
    uint64_t v173 = cftype + 352;
    *(_OWORD *)(cftype + 80) = 0u;
    *(_OWORD *)(cftype + 112) = 0u;
    *(_OWORD *)(cftype + 128) = 0u;
    *(_OWORD *)(cftype + 160) = 0u;
    *(_OWORD *)(cftype + 176) = 0u;
    *(_OWORD *)(cftype + 208) = 0u;
    *(_OWORD *)(cftype + 224) = 0u;
    *(_OWORD *)(cftype + 256) = 0u;
    *(_OWORD *)(cftype + 272) = 0u;
    *(_OWORD *)(cftype + 288) = 0u;
    *(_OWORD *)(cftype + 304) = 0u;
    *(_OWORD *)(cftype + 320) = 0u;
    *(_OWORD *)(cftype + 336) = 0u;
    *(_OWORD *)(cftype + 352) = 0u;
    *(_OWORD *)(cftype + 368) = 0u;
    *(_DWORD *)(cftype + 384) = 1065353216;
    *(_DWORD *)(cftype + 392) = 0;
    uint64_t v5 = (_OWORD *)(cftype + 400);
    *(_OWORD *)(cftype + 400) = 0u;
    *(_OWORD *)(cftype + 416) = 0u;
    *(_OWORD *)(cftype + 432) = 0u;
    *(_OWORD *)(cftype + 448) = 0u;
    *(_OWORD *)(cftype + 464) = 0u;
    *(_OWORD *)(cftype + 480) = 0u;
    uint64_t v176 = cftype + 240;
    uint64_t v172 = cftype + 400;
    BytePtr = CFDataGetBytePtr(a1);
    CFDataGetLength(a1);
    PB::Reader::Reader((PB::Reader *)v206, BytePtr);
    short float v184 = &unk_1ED094660;
    int v205 = 0;
    long long v201 = 0u;
    long long v202 = 0u;
    long long v185 = 0u;
    long long v186 = 0u;
    long long v187 = 0u;
    long long v188 = 0u;
    long long v189 = 0u;
    long long v190 = 0u;
    long long v191 = 0u;
    long long v192 = 0u;
    long long v193 = 0u;
    long long v194 = 0u;
    long long v195 = 0u;
    long long v196 = 0u;
    long long v197 = 0u;
    long long v198 = 0u;
    long long v199 = 0u;
    long long v200 = 0u;
    uint64_t v203 = 0;
    PBPageLayoutPkg::PBPageLayout::readFrom((PBPageLayoutPkg::PBPageLayout *)&v184, (PB::Reader *)v206);
    *(void *)(v3 + 16) = 0;
    *unsigned int v4 = 0u;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 128) = 0u;
    *(_OWORD *)(v3 + 144) = 0u;
    *(_OWORD *)(v3 + 160) = 0u;
    *(_OWORD *)(v3 + 176) = 0u;
    *(_OWORD *)(v3 + 192) = 0u;
    *(_OWORD *)(v3 + 208) = 0u;
    *(_OWORD *)(v3 + 224) = 0u;
    *(_OWORD *)(v3 + 240) = 0u;
    *(_OWORD *)(v3 + 256) = 0u;
    *(_OWORD *)(v3 + 272) = 0u;
    *(_OWORD *)(v3 + 288) = 0u;
    *(_OWORD *)(v3 + 304) = 0u;
    *(_OWORD *)(v3 + 320) = 0u;
    *(_OWORD *)(v3 + 336) = 0u;
    *(_OWORD *)(v3 + 352) = 0u;
    *(_OWORD *)(v3 + 368) = 0u;
    *(_DWORD *)(v3 + 384) = 1065353216;
    *(_DWORD *)(v3 + 392) = 0;
    *(_OWORD *)(v3 + 464) = 0u;
    *(_OWORD *)(v3 + 480) = 0u;
    *(_OWORD *)(v3 + 432) = 0u;
    *(_OWORD *)(v3 + 448) = 0u;
    *uint64_t v5 = 0u;
    *(_OWORD *)(v3 + 416) = 0u;
    *(unsigned char *)(v3 + 24) = v204;
    uint64_t v7 = objc_msgSend(NSString, "stringWithUTF8String:", v172, v173);
    long long v8 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v7;

    uint64_t v9 = *((void *)&v202 + 1) - v202;
    uint64_t v10 = *(void *)(v3 + 48);
    if (0x8E38E38E38E38E39 * ((*(void *)(v3 + 64) - v10) >> 3) < (uint64_t)(*((void *)&v202 + 1) - v202) >> 3)
    {
      if ((unint64_t)v9 >= 0x1C71C71C71C71C71) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v11 = *(void *)(v3 + 56);
      long long v12 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v9 >> 3);
      long long v13 = &v12[72 * ((v11 - v10) / 72)];
      long long v15 = &v12[72 * v14];
      uint64_t v17 = *(char **)(v3 + 48);
      long long v16 = *(char **)(v3 + 56);
      long long v18 = v13;
      if (v16 != v17)
      {
        do
        {
          *(_OWORD *)(v18 - 72) = *(_OWORD *)(v16 - 72);
          long long v19 = *(_OWORD *)(v16 - 56);
          long long v20 = *(_OWORD *)(v16 - 40);
          long long v21 = *(_OWORD *)(v16 - 24);
          *((void *)v18 - 1) = *((void *)v16 - 1);
          *(_OWORD *)(v18 - 24) = v21;
          *(_OWORD *)(v18 - 40) = v20;
          *(_OWORD *)(v18 - 56) = v19;
          v18 -= 72;
          v16 -= 72;
        }
        while (v16 != v17);
        long long v16 = *(char **)(v3 + 48);
      }
      *(void *)(v3 + 48) = v18;
      *(void *)(v3 + 56) = v13;
      *(void *)(v3 + 64) = v15;
      if (v16) {
        operator delete(v16);
      }
    }
    uint64_t v23 = *((void *)&v202 + 1);
    uint64_t v22 = v202;
    if ((void)v202 != *((void *)&v202 + 1))
    {
      char v24 = *(char **)(v3 + 56);
      do
      {
        uint64_t v26 = *(void **)(*(void *)v22 + 8);
        uint64_t v25 = *(void *)(*(void *)v22 + 16);
        uint64_t v28 = *(void *)(v25 + 8);
        uint64_t v27 = *(void *)(v25 + 16);
        uint64_t v29 = *(void *)(*(void *)v22 + 24);
        uint64_t v31 = v26[3];
        uint64_t v30 = v26[4];
        uint64_t v32 = v26[1];
        uint64_t v33 = v26[2];
        double v34 = *(float *)(*(void *)v22 + 32);
        uint64_t v35 = *(void *)(v3 + 32);
        *(void *)(v3 + 32) = v35 + 1;
        unint64_t v36 = *(void *)(v3 + 64);
        if ((unint64_t)v24 >= v36)
        {
          long long v37 = *(char **)(v3 + 48);
          unint64_t v38 = 0x8E38E38E38E38E39 * ((v24 - v37) >> 3);
          unint64_t v39 = v38 + 1;
          if (v38 + 1 > 0x38E38E38E38E38ELL) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          unint64_t v40 = 0x8E38E38E38E38E39 * ((uint64_t)(v36 - (void)v37) >> 3);
          if (2 * v40 > v39) {
            unint64_t v39 = 2 * v40;
          }
          if (v40 >= 0x1C71C71C71C71C7) {
            unint64_t v41 = 0x38E38E38E38E38ELL;
          }
          else {
            unint64_t v41 = v39;
          }
          if (v41)
          {
            unint64_t v41 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v41);
            long long v37 = *(char **)(v3 + 48);
            char v24 = *(char **)(v3 + 56);
          }
          else
          {
            uint64_t v42 = 0;
          }
          unint64_t v43 = v41 + 72 * v38;
          *(void *)unint64_t v43 = v27;
          *(void *)(v43 + 8) = v28;
          *(void *)(v43 + 16) = v29;
          *(void *)(v43 + 24) = v33;
          *(void *)(v43 + 32) = v31;
          *(void *)(v43 + 40) = v30;
          *(void *)(v43 + 48) = v32;
          *(double *)(v43 + 56) = v34;
          *(void *)(v43 + 64) = v35;
          unint64_t v44 = v43;
          if (v24 != v37)
          {
            do
            {
              *(_OWORD *)(v44 - 72) = *(_OWORD *)(v24 - 72);
              long long v45 = *(_OWORD *)(v24 - 56);
              long long v46 = *(_OWORD *)(v24 - 40);
              long long v47 = *(_OWORD *)(v24 - 24);
              *(void *)(v44 - 8) = *((void *)v24 - 1);
              *(_OWORD *)(v44 - 24) = v47;
              *(_OWORD *)(v44 - 40) = v46;
              *(_OWORD *)(v44 - 56) = v45;
              v44 -= 72;
              v24 -= 72;
            }
            while (v24 != v37);
            long long v37 = *(char **)(v3 + 48);
          }
          char v24 = (char *)(v43 + 72);
          *(void *)(v3 + 48) = v44;
          *(void *)(v3 + 56) = v43 + 72;
          *(void *)(v3 + 64) = v41 + 72 * v42;
          if (v37) {
            operator delete(v37);
          }
        }
        else
        {
          *(void *)char v24 = v27;
          *((void *)v24 + 1) = v28;
          *((void *)v24 + 2) = v29;
          *((void *)v24 + 3) = v33;
          *((void *)v24 + 4) = v31;
          *((void *)v24 + 5) = v30;
          *((void *)v24 + 6) = v32;
          *((double *)v24 + 7) = v34;
          *((void *)v24 + 8) = v35;
          v24 += 72;
        }
        *(void *)(v3 + 56) = v24;
        v22 += 8;
      }
      while (v22 != v23);
    }
    std::vector<unsigned short>::reserve(v174, (uint64_t)(*((void *)&v194 + 1) - v194) >> 2);
    uint64_t v49 = (int *)*((void *)&v194 + 1);
    uint64_t v48 = (int *)v194;
    if ((void)v194 != *((void *)&v194 + 1))
    {
      uint64_t v50 = *(char **)(v3 + 80);
      do
      {
        int v51 = *v48;
        unint64_t v52 = *(void *)(v3 + 88);
        if ((unint64_t)v50 >= v52)
        {
          uint64_t v54 = (char *)*v174;
          uint64_t v55 = v50 - (unsigned char *)*v174;
          if (v55 <= -3) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v56 = v55 >> 1;
          unint64_t v57 = v52 - (void)v54;
          if (v57 <= (v55 >> 1) + 1) {
            unint64_t v58 = v56 + 1;
          }
          else {
            unint64_t v58 = v57;
          }
          if (v57 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v59 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v59 = v58;
          }
          if (v59)
          {
            uint64_t v59 = (uint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<unsigned short>>(v59);
            uint64_t v54 = *(char **)(v3 + 72);
            uint64_t v50 = *(char **)(v3 + 80);
          }
          else
          {
            uint64_t v60 = 0;
          }
          uint64_t v61 = (_WORD *)(v59 + 2 * v56);
          *uint64_t v61 = v51;
          uint64_t v53 = (char *)(v61 + 1);
          while (v50 != v54)
          {
            __int16 v62 = *((_WORD *)v50 - 1);
            v50 -= 2;
            *--uint64_t v61 = v62;
          }
          *(void *)(v3 + 72) = v61;
          *(void *)(v3 + 80) = v53;
          *(void *)(v3 + 88) = v59 + 2 * v60;
          if (v54) {
            operator delete(v54);
          }
        }
        else
        {
          *(_WORD *)uint64_t v50 = v51;
          uint64_t v53 = v50 + 2;
        }
        *(void *)(v3 + 80) = v53;
        ++v48;
        uint64_t v50 = v53;
      }
      while (v48 != v49);
    }
    std::vector<unsigned long>::reserve(v181, (uint64_t)(v193 - *((void *)&v192 + 1)) >> 2);
    uint64_t v63 = (unsigned int *)*((void *)&v192 + 1);
    uint64_t v64 = (unsigned int *)v193;
    for (size_t i = (char *)v181; v63 != v64; ++v63)
    {
      *(void *)&v207[0] = *v63;
      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
    }
    std::vector<CGRect>::reserve(v180, (uint64_t)(v201 - *((void *)&v200 + 1)) >> 3);
    uint64_t v65 = *((void *)&v200 + 1);
    uint64_t v66 = v201;
    if (*((void *)&v200 + 1) != (void)v201)
    {
      uint64_t v67 = *(char **)(v3 + 128);
      do
      {
        uint64_t v69 = *(void *)(*(void *)v65 + 24);
        uint64_t v68 = *(void *)(*(void *)v65 + 32);
        uint64_t v70 = *(void *)(*(void *)v65 + 8);
        uint64_t v71 = *(void *)(*(void *)v65 + 16);
        unint64_t v72 = *(void *)(v3 + 136);
        if ((unint64_t)v67 >= v72)
        {
          uint64_t v73 = (char *)*v180;
          uint64_t v74 = (v67 - (unsigned char *)*v180) >> 5;
          unint64_t v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 59) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v76 = v72 - (void)v73;
          if (v76 >> 4 > v75) {
            unint64_t v75 = v76 >> 4;
          }
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v77 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v77 = v75;
          }
          if (v77)
          {
            unint64_t v77 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v77);
            uint64_t v73 = *(char **)(v3 + 120);
            uint64_t v67 = *(char **)(v3 + 128);
          }
          else
          {
            uint64_t v78 = 0;
          }
          long long v79 = (void *)(v77 + 32 * v74);
          *long long v79 = v71;
          v79[1] = v69;
          v79[2] = v68;
          void v79[3] = v70;
          uint64_t v80 = v79;
          if (v67 != v73)
          {
            do
            {
              long long v81 = *((_OWORD *)v67 - 1);
              *((_OWORD *)v80 - 2) = *((_OWORD *)v67 - 2);
              *((_OWORD *)v80 - 1) = v81;
              v80 -= 4;
              v67 -= 32;
            }
            while (v67 != v73);
            uint64_t v73 = (char *)*v180;
          }
          uint64_t v67 = (char *)(v79 + 4);
          *(void *)(v3 + 120) = v80;
          *(void *)(v3 + 128) = v79 + 4;
          *(void *)(v3 + 136) = v77 + 32 * v78;
          if (v73) {
            operator delete(v73);
          }
        }
        else
        {
          *(void *)uint64_t v67 = v71;
          *((void *)v67 + 1) = v69;
          *((void *)v67 + 2) = v68;
          *((void *)v67 + 3) = v70;
          v67 += 32;
        }
        *(void *)(v3 + 128) = v67;
        v65 += 8;
      }
      while (v65 != v66);
    }
    std::vector<CGRect>::reserve(v179, (uint64_t)(*((void *)&v199 + 1) - v199) >> 3);
    uint64_t v83 = *((void *)&v199 + 1);
    uint64_t v82 = v199;
    if ((void)v199 != *((void *)&v199 + 1))
    {
      long long v84 = *(char **)(v3 + 152);
      do
      {
        uint64_t v86 = *(void *)(*(void *)v82 + 24);
        uint64_t v85 = *(void *)(*(void *)v82 + 32);
        uint64_t v87 = *(void *)(*(void *)v82 + 8);
        uint64_t v88 = *(void *)(*(void *)v82 + 16);
        unint64_t v89 = *(void *)(v3 + 160);
        if ((unint64_t)v84 >= v89)
        {
          uint64_t v90 = (char *)*v179;
          uint64_t v91 = (v84 - (unsigned char *)*v179) >> 5;
          unint64_t v92 = v91 + 1;
          if ((unint64_t)(v91 + 1) >> 59) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v93 = v89 - (void)v90;
          if (v93 >> 4 > v92) {
            unint64_t v92 = v93 >> 4;
          }
          if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v94 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v94 = v92;
          }
          if (v94)
          {
            unint64_t v94 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v94);
            uint64_t v90 = *(char **)(v3 + 144);
            long long v84 = *(char **)(v3 + 152);
          }
          else
          {
            uint64_t v95 = 0;
          }
          uint64_t v96 = (void *)(v94 + 32 * v91);
          *uint64_t v96 = v88;
          v96[1] = v86;
          v96[2] = v85;
          v96[3] = v87;
          __int16 v97 = v96;
          if (v84 != v90)
          {
            do
            {
              long long v98 = *((_OWORD *)v84 - 1);
              *((_OWORD *)v97 - 2) = *((_OWORD *)v84 - 2);
              *((_OWORD *)v97 - 1) = v98;
              v97 -= 4;
              v84 -= 32;
            }
            while (v84 != v90);
            uint64_t v90 = (char *)*v179;
          }
          long long v84 = (char *)(v96 + 4);
          *(void *)(v3 + 144) = v97;
          *(void *)(v3 + 152) = v96 + 4;
          *(void *)(v3 + 160) = v94 + 32 * v95;
          if (v90) {
            operator delete(v90);
          }
        }
        else
        {
          *(void *)long long v84 = v88;
          *((void *)v84 + 1) = v86;
          *((void *)v84 + 2) = v85;
          *((void *)v84 + 3) = v87;
          v84 += 32;
        }
        *(void *)(v3 + 152) = v84;
        v82 += 8;
      }
      while (v82 != v83);
    }
    std::vector<unsigned long>::reserve(v178, (uint64_t)(*((void *)&v191 + 1) - v191) >> 2);
    int v100 = (unsigned int *)*((void *)&v191 + 1);
    int v99 = (unsigned int *)v191;
    size_t i = (char *)v178;
    while (v99 != v100)
    {
      *(void *)&v207[0] = *v99;
      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
      ++v99;
    }
    uint64_t v101 = (uint64_t *)*((void *)&v197 + 1);
    uint64_t v102 = (uint64_t *)v197;
    uint64_t v103 = *((void *)&v197 + 1) - v197;
    uint64_t v104 = *(void *)(v3 + 192);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v3 + 208) - v104) >> 3) < (uint64_t)(*((void *)&v197 + 1) - v197) >> 3)
    {
      if ((unint64_t)v103 >= 0x5555555555555551) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v105 = *(void *)(v3 + 200);
      uint64_t v212 = v3 + 208;
      long long v106 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v103 >> 3);
      uint64_t v109 = *(void *)(v3 + 192);
      unint64_t v108 = *(void *)(v3 + 200);
      if (v108 == v109)
      {
        int64x2_t v111 = vdupq_n_s64(v108);
        long long v110 = &v106[v105 - v104];
      }
      else
      {
        long long v110 = &v106[v105 - v104];
        do
        {
          *(_OWORD *)(v110 - 24) = *(_OWORD *)(v108 - 24);
          *((void *)v110 - 1) = *(void *)(v108 - 8);
          v110 -= 24;
          *(void *)(v108 - 8) = 0;
          v108 -= 24;
        }
        while (v108 != v109);
        int64x2_t v111 = *v182;
      }
      *(void *)(v3 + 192) = v110;
      *(void *)(v3 + 200) = &v106[v105 - v104];
      int64x2_t v210 = v111;
      long long v112 = *(char **)(v3 + 208);
      *(void *)(v3 + 208) = &v106[24 * v107];
      unsigned int v211 = v112;
      size_t i = (char *)v111.i64[0];
      std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer((uint64_t)&i);
      uint64_t v101 = (uint64_t *)*((void *)&v197 + 1);
      uint64_t v102 = (uint64_t *)v197;
    }
    if (v102 != v101)
    {
      CFAllocatorRef v113 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFAllocatorRef v114 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
      do
      {
        uint64_t v115 = *v102;
        CFDictionaryRef v208 = 0;
        uint64_t v116 = *(void *)(v115 + 8);
        v207[0] = *(double *)(v115 + 16);
        v207[1] = *(float *)(v115 + 28);
        CFDataRef v117 = CFDataCreateWithBytesNoCopy(v113, **(const UInt8 ***)(v116 + 8), *(void *)(*(void *)(v116 + 8) + 8), v114);
        CFDictionaryRef v118 = (const __CFDictionary *)CFPropertyListCreateWithData(v113, v117, 0, 0, 0);
        CFDictionaryRef v208 = CGColorCreateWithPropertyList(v118);
        unint64_t v119 = *(void *)(v3 + 200);
        unint64_t v120 = *(void *)(v3 + 208);
        if (v119 >= v120)
        {
          unint64_t v122 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v119 - v182->i64[0]) >> 3);
          unint64_t v123 = v122 + 1;
          if (v122 + 1 > 0xAAAAAAAAAAAAAAALL) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          unint64_t v124 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v120 - v182->i64[0]) >> 3);
          if (2 * v124 > v123) {
            unint64_t v123 = 2 * v124;
          }
          if (v124 >= 0x555555555555555) {
            unint64_t v125 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v125 = v123;
          }
          uint64_t v212 = v3 + 208;
          if (v125)
          {
            unint64_t v127 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v125);
          }
          else
          {
            unint64_t v127 = 0;
            uint64_t v126 = 0;
          }
          uint64_t v128 = (uint64_t)&v127[24 * v122];
          int v129 = &v127[24 * v126];
          unsigned int v211 = v129;
          uint64_t v130 = std::construct_at[abi:fe180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(v128, (uint64_t)v207);
          uint64_t v121 = v130 + 24;
          v210.i64[1] = v130 + 24;
          uint64_t v132 = *(void *)(v3 + 192);
          unint64_t v131 = *(void *)(v3 + 200);
          if (v131 == v132)
          {
            int64x2_t v133 = vdupq_n_s64(v131);
          }
          else
          {
            do
            {
              *(_OWORD *)(v130 - 24) = *(_OWORD *)(v131 - 24);
              *(void *)(v130 - 8) = *(void *)(v131 - 8);
              v130 -= 24;
              *(void *)(v131 - 8) = 0;
              v131 -= 24;
            }
            while (v131 != v132);
            int64x2_t v133 = *v182;
            uint64_t v121 = v210.i64[1];
            int v129 = v211;
          }
          *(void *)(v3 + 192) = v130;
          *(void *)(v3 + 200) = v121;
          int64x2_t v210 = v133;
          uint64_t v134 = *(char **)(v3 + 208);
          *(void *)(v3 + 208) = v129;
          unsigned int v211 = v134;
          size_t i = (char *)v133.i64[0];
          std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer((uint64_t)&i);
        }
        else
        {
          uint64_t v121 = std::construct_at[abi:fe180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(v119, (uint64_t)v207)+ 24;
        }
        *(void *)(v3 + 200) = v121;
        if (v118) {
          CFRelease(v118);
        }
        if (v117) {
          CFRelease(v117);
        }
        if (v208) {
          CFRelease(v208);
        }
        ++v102;
      }
      while (v102 != v101);
    }
    std::vector<unsigned long>::reserve(v177, (uint64_t)(v187 - *((void *)&v186 + 1)) >> 2);
    int v135 = (unsigned int *)*((void *)&v186 + 1);
    uint64_t v136 = (unsigned int *)v187;
    size_t i = (char *)v177;
    while (v135 != v136)
    {
      *(void *)&v207[0] = *v135;
      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
      ++v135;
    }
    unint64_t v137 = (uint64_t)(*((void *)&v185 + 1) - v185) >> 2;
    uint64_t v138 = *(void *)(v3 + 240);
    if (v137 > (*(void *)(v3 + 256) - v138) >> 3)
    {
      if (*((void *)&v185 + 1) - (void)v185 >= 0x7FFFFFFFFFFFFFFDuLL) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v139 = *(void *)(v3 + 248);
      unsigned int v140 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v137);
      unsigned int v141 = &v140[(v139 - v138) & 0xFFFFFFFFFFFFFFF8];
      unsigned int v143 = &v140[8 * v142];
      unsigned int v144 = *(char **)(v3 + 240);
      unsigned int v145 = *(char **)(v3 + 248);
      unsigned int v146 = v141;
      if (v145 != v144)
      {
        unsigned int v146 = v141;
        do
        {
          uint64_t v147 = *((void *)v145 - 1);
          v145 -= 8;
          *((void *)v146 - 1) = v147;
          v146 -= 8;
        }
        while (v145 != v144);
      }
      *(void *)(v3 + 240) = v146;
      *(void *)(v3 + 248) = v141;
      *(void *)(v3 + 256) = v143;
      if (v144) {
        operator delete(v144);
      }
    }
    int v149 = (float *)*((void *)&v185 + 1);
    uint64_t v148 = (float *)v185;
    size_t i = (char *)v176;
    while (v148 != v149)
    {
      v207[0] = *v148;
      std::back_insert_iterator<std::vector<double>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
      ++v148;
    }
    uint64_t v150 = *((void *)&v195 + 1);
    uint64_t v151 = v196;
    unint64_t v152 = (uint64_t)(v196 - *((void *)&v195 + 1)) >> 3;
    uint64_t v153 = *(void *)(v3 + 264);
    if (v152 > (*(void *)(v3 + 280) - v153) >> 5)
    {
      if ((void)v196 - *((void *)&v195 + 1) >= 0x3FFFFFFFFFFFFFF9uLL) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v154 = *(void *)(v3 + 272);
      uint64_t v212 = v3 + 280;
      size_t i = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v152);
      v210.i64[0] = (uint64_t)&i[v154 - v153];
      v210.i64[1] = v210.i64[0];
      unsigned int v211 = &i[32 * v155];
      std::vector<std::pair<std::string,unsigned int>>::__swap_out_circular_buffer(v183, &i);
      std::__split_buffer<std::pair<std::string,unsigned int>>::~__split_buffer((uint64_t)&i);
      uint64_t v150 = *((void *)&v195 + 1);
      uint64_t v151 = v196;
    }
    for (; v150 != v151; v150 += 8)
    {
      uint64_t v156 = *(char **)(*(void *)v150 + 8);
      if (v156[23] < 0) {
        uint64_t v156 = *(char **)v156;
      }
      int v157 = *(_DWORD *)(*(void *)v150 + 16);
      unint64_t v159 = *(void *)(v3 + 272);
      unint64_t v158 = *(void *)(v3 + 280);
      if (v159 >= v158)
      {
        uint64_t v161 = (uint64_t)(v159 - *v183) >> 5;
        if ((unint64_t)(v161 + 1) >> 59) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v162 = v158 - *v183;
        uint64_t v163 = v162 >> 4;
        if (v162 >> 4 <= (unint64_t)(v161 + 1)) {
          uint64_t v163 = v161 + 1;
        }
        if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v164 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v164 = v163;
        }
        uint64_t v212 = v3 + 280;
        if (v164) {
          unint64_t v164 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v164);
        }
        else {
          uint64_t v165 = 0;
        }
        unint64_t v166 = v164 + 32 * v161;
        size_t i = (char *)v164;
        v210.i64[0] = v166;
        v210.i64[1] = v166;
        unsigned int v211 = (char *)(v164 + 32 * v165);
        std::string::basic_string[abi:fe180100]<0>((void *)v166, v156);
        *(_DWORD *)(v166 + 24) = v157;
        v210.i64[1] += 32;
        std::vector<std::pair<std::string,unsigned int>>::__swap_out_circular_buffer(v183, &i);
        unint64_t v160 = *(void *)(v3 + 272);
        std::__split_buffer<std::pair<std::string,unsigned int>>::~__split_buffer((uint64_t)&i);
      }
      else
      {
        std::string::basic_string[abi:fe180100]<0>(*(void **)(v3 + 272), v156);
        *(_DWORD *)(v159 + 24) = v157;
        unint64_t v160 = v159 + 32;
        *(void *)(v3 + 272) = v159 + 32;
      }
      *(void *)(v3 + 272) = v160;
    }
    std::vector<unsigned long>::reserve(v175, (uint64_t)(v190 - *((void *)&v189 + 1)) >> 3);
    unsigned int v167 = (double *)*((void *)&v189 + 1);
    uint64_t v168 = (double *)v190;
    size_t i = (char *)v175;
    while (v167 != v168)
    {
      v207[0] = *v167;
      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
      ++v167;
    }
    std::vector<unsigned long>::reserve((void **)(v176 + 72), (uint64_t)(*((void *)&v188 + 1) - v188) >> 3);
    int v170 = (double *)*((void *)&v188 + 1);
    int v169 = (double *)v188;
    size_t i = (char *)(v176 + 72);
    while (v169 != v170)
    {
      v207[0] = *v169;
      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&i, v207);
      ++v169;
    }
    PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&v184);
  }
  return v3;
}

void sub_184F424C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16, void **a17, void **a18, uint64_t a19, void **a20,void **a21,void **a22)
{
  PBPageLayoutPkg::PBPageLayout::~PBPageLayout((PBPageLayoutPkg::PBPageLayout *)&a22);
  char v24 = *(void **)(v22 + 472);
  if (v24)
  {
    *(void *)(v22 + 480) = v24;
    operator delete(v24);
  }
  uint64_t v25 = *(void **)(v22 + 448);
  if (v25)
  {
    *(void *)(v22 + 456) = v25;
    operator delete(v25);
  }
  uint64_t v26 = *(void **)(v22 + 424);
  if (v26)
  {
    *(void *)(v22 + 432) = v26;
    operator delete(v26);
  }
  uint64_t v27 = *a9;
  if (*a9)
  {
    *(void *)(v22 + 408) = v27;
    operator delete(v27);
  }
  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table(a10);

  uint64_t v28 = *(void **)(v22 + 312);
  if (v28)
  {
    *(void *)(v22 + 320) = v28;
    operator delete(v28);
  }
  uint64_t v29 = *a12;
  if (*a12)
  {
    *(void *)(v22 + 296) = v29;
    operator delete(v29);
  }
  a22 = a21;
  std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:fe180100](&a22);
  uint64_t v30 = *a13;
  if (*a13)
  {
    *(void *)(v22 + 248) = v30;
    operator delete(v30);
  }
  uint64_t v31 = *a14;
  if (*a14)
  {
    *(void *)(v22 + 224) = v31;
    operator delete(v31);
  }
  a22 = a20;
  std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:fe180100](&a22);
  uint64_t v32 = *a15;
  if (*a15)
  {
    *(void *)(v22 + 176) = v32;
    operator delete(v32);
  }
  uint64_t v33 = *a16;
  if (*a16)
  {
    *(void *)(v22 + 152) = v33;
    operator delete(v33);
  }
  double v34 = *a17;
  if (*a17)
  {
    *(void *)(v22 + 128) = v34;
    operator delete(v34);
  }
  uint64_t v35 = *a18;
  if (*a18)
  {
    *(void *)(v22 + 104) = v35;
    operator delete(v35);
  }
  unint64_t v36 = *a11;
  if (*a11)
  {
    *(void *)(v22 + 80) = v36;
    operator delete(v36);
  }
  long long v37 = *(void **)(v22 + 48);
  if (v37)
  {
    *(void *)(v22 + 56) = v37;
    operator delete(v37);
  }

  _Unwind_Resume(a1);
}

unint64_t CGPDFPageLayoutGetCharacterSelectionBoundingBox(unint64_t result, unint64_t a2, _OWORD *a3, uint64_t a4)
{
  if (result)
  {
    if (a2 < (uint64_t)(*(void *)(result + 128) - *(void *)(result + 120)) >> 5)
    {
      if (a3)
      {
        uint64_t v5 = *(void *)(result + 144);
        if (a2 >= (*(void *)(result + 152) - v5) >> 5)
        {
LABEL_12:
          __break(1u);
          return result;
        }
        long long v6 = (_OWORD *)(v5 + 32 * a2);
        long long v7 = v6[1];
        *a3 = *v6;
        a3[1] = v7;
      }
      if (!a4) {
        return 1;
      }
      long long v8 = *(PageLayout **)(result + 48);
      uint64_t v9 = *(PageLayout **)(result + 56);
      uint64_t result = PageLayout::getLineIndex(v8, v9, a2);
      if (0x8E38E38E38E38E39 * ((v9 - v8) >> 3) > result)
      {
        __double2 v10 = __sincos_stret(*((double *)v8 + 9 * result + 7));
        *(double *)a4 = v10.__cosval;
        *(double *)(a4 + 8) = v10.__sinval;
        *(double *)(a4 + 16) = -v10.__sinval;
        *(double *)(a4 + 24) = v10.__cosval;
        *(void *)(a4 + 32) = 0;
        *(void *)(a4 + 40) = 0;
        return 1;
      }
      goto LABEL_12;
    }
    return 0;
  }
  return result;
}

BOOL CGPDFPageLayoutGetColumnBoundsAtPointWithCompletion(uint64_t a1, void *a2, void *a3, CGFloat a4, CGFloat a5)
{
  id v9 = a2;
  id v10 = a3;
  if (a1)
  {
    uint64_t v11 = v9;
    long long v12 = (void (**)(void, double, double, double, double))v10;
    long long v13 = (os_unfair_lock_s *)(a1 + 392);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 392));
    if (*(unsigned char *)(a1 + 396))
    {
      uint64_t v15 = *(void *)(a1 + 400);
      uint64_t v14 = *(void *)(a1 + 408);
      if (v15 == v14)
      {
        uint64_t v17 = &CGRectNull;
      }
      else
      {
        uint64_t v16 = 0;
        do
        {
          v30.x = a4;
          v30.CGFloat y = a5;
          if (CGRectContainsPoint(*(CGRect *)v15, v30) && (!v16 || *(void *)(v15 + 32) >= *(void *)(v16 + 32))) {
            uint64_t v16 = v15;
          }
          v15 += 40;
        }
        while (v15 != v14);
        uint64_t v17 = &CGRectNull;
        if (v16) {
          uint64_t v17 = (const CGRect *)v16;
        }
      }
      v12[2](v12, v17->origin.x, v17->origin.y, v17->size.width, v17->size.height);
      os_unfair_lock_unlock(v13);
      BOOL v18 = 1;
    }
    else
    {
      os_unfair_lock_unlock(v13);
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke;
      aBlock[3] = &unk_1E52C8210;
      uint64_t v26 = a1 + 16;
      uint64_t v25 = v12;
      uint64_t v27 = a1 + 16;
      CGFloat v28 = a4;
      CGFloat v29 = a5;
      long long v19 = (void (**)(void))_Block_copy(aBlock);
      long long v20 = v19;
      BOOL v18 = v11 == 0;
      if (v11)
      {
        v22[0] = MEMORY[0x1E4F143A8];
        v22[1] = 3221225472;
        v22[2] = ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke_2;
        v22[3] = &unk_1E52C8238;
        uint64_t v23 = v19;
        dispatch_async(v11, v22);
      }
      else
      {
        v19[2](v19);
      }
    }
  }
  else
  {
    BOOL v18 = 0;
  }

  return v18;
}

void sub_184F42B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t CGPDFPageLayoutGetTextRangeIndexAtPoint(uint64_t a1, double a2, double a3)
{
  if (!a1) {
    return -1;
  }
  PageLayout::getTextRangeIndex(a1 + 16, 0, 2u, a2, a3);
  return v3;
}

uint64_t CGPDFPageLayoutGetStringRangeIndexNearestPoint(uint64_t a1, double a2, double a3)
{
  if (!a1) {
    return -1;
  }
  uint64_t v3 = a1 + 16;
  PageLayout::getTextRangeIndex(a1 + 16, 0, 3u, a2, a3);
  if (v4 == -1) {
    return -1;
  }
  v12[0] = v4;
  v12[1] = 1;
  id v9 = 0;
  id v10 = 0;
  uint64_t v11 = 0;
  v8[0] = v12;
  v8[1] = 1;
  long long v7 = (void **)&v9;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(v3, (uint64_t)v8, &v7);
  if (v9 != v10)
  {
    uint64_t v5 = *v9;
LABEL_7:
    id v10 = v9;
    operator delete(v9);
    return v5;
  }
  uint64_t v5 = -1;
  if (v9) {
    goto LABEL_7;
  }
  return v5;
}

void sub_184F42C30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFPageLayoutGetAreaOfInterestAtPoint(uint64_t result, double a2, double a3)
{
  if (result)
  {
    uint64_t v5 = result;
    PageLayout::getTextRangeIndex(result + 16, 0, 2u, a2, a3);
    uint64_t v7 = v6;
    id v9 = *(CGRect **)(v5 + 424);
    long long v8 = *(CGRect **)(v5 + 432);
    while (1)
    {
      if (v9 == v8) {
        return v7 != -1;
      }
      v10.x = a2;
      v10.CGFloat y = a3;
      if (CGRectContainsPoint(*v9, v10)) {
        break;
      }
      ++v9;
    }
    return (v7 != -1) | 2u;
  }
  return result;
}

uint64_t CGPDFPageLayoutGetNumberOfCharacterBoundingBoxes(uint64_t result)
{
  if (result) {
    return (uint64_t)(*(void *)(result + 152) - *(void *)(result + 144)) >> 5;
  }
  return result;
}

void CGPDFPageLayoutGetCharacterPreciseBoundingBoxes(void *a1, void *__dst, uint64_t a3)
{
  if (a1)
  {
    uint64_t v5 = (unsigned char *)a1[18];
    uint64_t v6 = (unsigned char *)a1[19];
    if (v6 != v5) {
      memmove(__dst, v5, v6 - v5);
    }
    uint64_t v8 = a1[6];
    uint64_t v7 = a1[7];
    if (v8 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = *(void *)(v8 + 8);
        __double2 v11 = __sincos_stret(*(double *)(v8 + 56));
        if (v10 >= 1)
        {
          uint64_t v12 = a3 + 48 * v9;
          unint64_t v13 = v10 + 1;
          do
          {
            *(double *)uint64_t v12 = v11.__cosval;
            *(double *)(v12 + 8) = v11.__sinval;
            *(double *)(v12 + 16) = -v11.__sinval;
            *(double *)(v12 + 24) = v11.__cosval;
            --v13;
            *(void *)(v12 + 32) = 0;
            *(void *)(v12 + 40) = 0;
            v12 += 48;
          }
          while (v13 > 1);
        }
        v9 += v10;
        v8 += 72;
      }
      while (v8 != v7);
    }
  }
}

void CGPDFPageLayoutGetCharacterSelectionBoundingBoxes(void *a1, void *__dst, uint64_t a3)
{
  if (a1)
  {
    uint64_t v5 = (unsigned char *)a1[15];
    uint64_t v6 = (unsigned char *)a1[16];
    if (v6 != v5) {
      memmove(__dst, v5, v6 - v5);
    }
    uint64_t v8 = a1[6];
    uint64_t v7 = a1[7];
    if (v8 != v7)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = *(void *)(v8 + 8);
        __double2 v11 = __sincos_stret(*(double *)(v8 + 56));
        if (v10 >= 1)
        {
          uint64_t v12 = a3 + 48 * v9;
          unint64_t v13 = v10 + 1;
          do
          {
            *(double *)uint64_t v12 = v11.__cosval;
            *(double *)(v12 + 8) = v11.__sinval;
            *(double *)(v12 + 16) = -v11.__sinval;
            *(double *)(v12 + 24) = v11.__cosval;
            --v13;
            *(void *)(v12 + 32) = 0;
            *(void *)(v12 + 40) = 0;
            v12 += 48;
          }
          while (v13 > 1);
        }
        v9 += v10;
        v8 += 72;
      }
      while (v8 != v7);
    }
  }
}

void CGPDFPageLayoutEnumerateLineRects(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v12 = v3;
    uint64_t v4 = (void (**)(id, void *, double, double, double, double))v3;
    uint64_t v6 = *(double **)(a1 + 48);
    for (size_t i = *(double **)(a1 + 56); v6 != i; v6 += 9)
    {
      __double2 v7 = __sincos_stret(v6[7]);
      double v8 = v6[3];
      double v9 = v6[4];
      double v10 = v6[5];
      double v11 = v6[6];
      v13[0] = *(void *)&v7.__cosval;
      v13[1] = *(void *)&v7.__sinval;
      *(double *)&v13[2] = -v7.__sinval;
      v13[3] = *(void *)&v7.__cosval;
      v13[4] = 0;
      v13[5] = 0;
      v4[2](v4, v13, v8, v9, v10, v11);
    }

    id v3 = v12;
  }
}

void sub_184F42F20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CGPDFPageLayoutInsertTableDescriptions(uint64_t a1, void *a2)
{
  uint64_t v209 = *MEMORY[0x1E4F143B8];
  if (a1 && TextRecognitionLibraryCore(0))
  {
    id v122 = a2;
    uint64_t v4 = (PageLayout *)(a1 + 16);
    CGRect BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(void *)(a1 + 16), kCGPDFCropBox);
    double height = BoxRect.size.height;
    double width = BoxRect.size.width;
    memset(&v198, 0, sizeof(v198));
    *(float64x2_t *)&v197.a = vmulq_n_f64((float64x2_t)xmmword_1850CD830, BoxRect.size.width);
    *(float64x2_t *)&v197.c = vmulq_n_f64((float64x2_t)xmmword_1850CD8C0, -BoxRect.size.height);
    v197.tx = BoxRect.origin.x;
    v197.tdouble y = BoxRect.origin.y + BoxRect.size.height;
    CGAffineTransformInvert(&v198, &v197);
    unint64_t v124 = (void *)[objc_alloc((Class)getCRCTLDClass()) init];
    unsigned int v145 = objc_opt_new();
    uint64_t v130 = a1;
    if ([*(id *)(a1 + 344) count])
    {
      long long v196 = 0u;
      long long v195 = 0u;
      long long v194 = 0u;
      long long v193 = 0u;
      id v5 = *(id *)(a1 + 344);
      uint64_t v6 = [v5 countByEnumeratingWithState:&v193 objects:v208 count:16];
      if (v6)
      {
        obuint64_t j = v5;
        uint64_t v127 = v6;
        uint64_t v129 = *(void *)v194;
        do
        {
          for (id i = 0; i != (id)v127; id i = (char *)i + 1)
          {
            if (*(void *)v194 != v129) {
              objc_enumerationMutation(obj);
            }
            id v7 = *(id *)(*((void *)&v193 + 1) + 8 * i);
            long long v189 = 0u;
            long long v190 = 0u;
            long long v191 = 0u;
            long long v192 = 0u;
            id v131 = v7;
            id v140 = [v7 subregions];
            uint64_t v8 = [v140 countByEnumeratingWithState:&v189 objects:v207 count:16];
            if (v8)
            {
              id v9 = *(id *)v190;
              id v136 = *(id *)v190;
              do
              {
                for (uint64_t j = 0; j != v8; ++j)
                {
                  if (*(id *)v190 != v9) {
                    objc_enumerationMutation(v140);
                  }
                  double v11 = *(void **)(*((void *)&v189 + 1) + 8 * j);
                  if ([v11 type] == 4)
                  {
                    if (v11)
                    {
                      [v11 textLines];
                      id v12 = (char *)__p;
                      unint64_t v13 = v206;
                      if (__p != v206)
                      {
                        do
                        {
                          $5CFEE62CA76FAE445C6F9DBCEE669C70 v203 = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v12;
                          unint64_t v204 = *((void *)v12 + 2);
                          CGFloat v14 = *((double *)v12 + 3);
                          CGFloat v15 = *((double *)v12 + 4);
                          CGFloat v16 = *((double *)v12 + 5);
                          CGFloat v17 = *((double *)v12 + 6);
                          *(_OWORD *)long long v202 = *(_OWORD *)(v12 + 56);
                          CGAffineTransform v188 = v198;
                          v212.origin.x = v14;
                          v212.origin.double y = v15;
                          v212.size.double width = v16;
                          v212.size.double height = v17;
                          CGRect v213 = CGRectApplyAffineTransform(v212, &v188);
                          BOOL v18 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v213.origin.x, v213.origin.y, v213.size.width, v213.size.height, width, height);
                          long long v19 = [PDFTextLineElement alloc];
                          $5CFEE62CA76FAE445C6F9DBCEE669C70 v181 = v203;
                          unint64_t v182 = v204;
                          CGFloat v183 = v14;
                          CGFloat v184 = v15;
                          CGFloat v185 = v16;
                          CGFloat v186 = v17;
                          long long v187 = *(_OWORD *)v202;
                          long long v20 = [(PDFTextLineElement *)v19 initWithTextLine:&v181 boundingBox:v18];
                          v180.textRange = v203;
                          v180.uniCharStart = v204;
                          v180.bbox.origin.x = v14;
                          v180.bbox.origin.double y = v15;
                          v180.bbox.size.double width = v16;
                          v180.bbox.size.double height = v17;
                          *(_OWORD *)&v180.rotatiouint64_t n = *(_OWORD *)v202;
                          PageLayout::addCTLDMapping(v4, &v180, v20);
                          [v145 addObject:v20];

                          v12 += 72;
                        }
                        while (v12 != v13);
                        id v12 = (char *)__p;
                      }
                      id v9 = v136;
                      if (v12)
                      {
                        unsigned int v206 = v12;
                        operator delete(v12);
                      }
                    }
                  }
                  else
                  {
                    [v145 addObject:v11];
                  }
                }
                uint64_t v8 = [v140 countByEnumeratingWithState:&v189 objects:v207 count:16];
              }
              while (v8);
            }
          }
          uint64_t v127 = [obj countByEnumeratingWithState:&v193 objects:v208 count:16];
        }
        while (v127);
        id v5 = obj;
      }
    }
    else
    {
      PageLayout::createAtomicElements((PageLayout *)(a1 + 16), 0);
      v145 = id v5 = v145;
    }

    long long v178 = 0u;
    long long v179 = 0u;
    long long v176 = 0u;
    long long v177 = 0u;
    id v134 = v122;
    uint64_t v21 = [v134 countByEnumeratingWithState:&v176 objects:&__p count:16];
    if (v21)
    {
      id v137 = *(id *)v177;
      do
      {
        id v141 = (id)v21;
        for (k = 0; k != v141; k = (char *)k + 1)
        {
          if (*(id *)v177 != v137) {
            objc_enumerationMutation(v134);
          }
          id v23 = *(id *)(*((void *)&v176 + 1) + 8 * (void)k);
          char v24 = [v23 valueForKey:@"Cells"];
          long long v174 = 0u;
          long long v175 = 0u;
          long long v172 = 0u;
          long long v173 = 0u;
          id v25 = v24;
          uint64_t v26 = [v25 countByEnumeratingWithState:&v172 objects:&v203 count:16];
          if (v26)
          {
            uint64_t v27 = *(void *)v173;
            do
            {
              for (uint64_t m = 0; m != v26; ++m)
              {
                if (*(void *)v173 != v27) {
                  objc_enumerationMutation(v25);
                }
                id v29 = *(id *)(*((void *)&v172 + 1) + 8 * m);
                CGPoint v30 = [v29 valueForKey:@"Rect"];
                [v30 rectValue];
                double v32 = v31;
                double v34 = v33;
                double v36 = v35;
                double v38 = v37;

                if (v36 < 0.0 || v38 < 0.0)
                {
                  v214.origin.x = v32;
                  v214.origin.double y = v34;
                  v214.size.double width = v36;
                  v214.size.double height = v38;
                  CGRect v215 = CGRectStandardize(v214);
                  double v41 = v215.origin.x + v215.size.width;
                  v215.origin.x = v32;
                  v215.origin.double y = v34;
                  v215.size.double width = v36;
                  v215.size.double height = v38;
                  *(CGRect *)(&v42 - 1) = CGRectStandardize(v215);
                  double v38 = v43;
                }
                else
                {
                  double v41 = v32 + v36;
                  double v42 = v34;
                }
                double v44 = v42 + v38;
                PageLayout::addVertEdge(v4, v39, v40, v32, v34, v42 + v38);
                PageLayout::addVertEdge(v4, v45, v46, v41, v34, v44);
              }
              uint64_t v26 = [v25 countByEnumeratingWithState:&v172 objects:&v203 count:16];
            }
            while (v26);
          }
        }
        uint64_t v21 = [v134 countByEnumeratingWithState:&v176 objects:&__p count:16];
      }
      while (v21);
    }

    v171[1] = 0;
    v171[0] = 0;
    int v170 = (uint64_t *)v171;
    PageLayout::splitLines(v4, 1, &v170, v47, v48, v49, v50, v51);
    unint64_t v52 = v170;
    if (v170 != (uint64_t *)v171)
    {
      do
      {
        unint64_t v53 = v52[4];
        uint64_t v54 = *(void *)(v130 + 48);
        if (0x8E38E38E38E38E39 * ((*(void *)(v130 + 56) - v54) >> 3) <= v53) {
          goto LABEL_94;
        }
        uint64_t v55 = v54 + 72 * v53;
        CGRect v216 = *(CGRect *)(v55 + 24);
        CGAffineTransform v169 = v198;
        CGRect v217 = CGRectApplyAffineTransform(v216, &v169);
        uint64_t v56 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v217.origin.x, v217.origin.y, v217.size.width, v217.size.height, width, height);
        unint64_t v57 = [PDFTextLineElement alloc];
        v167[0] = *(_OWORD *)v55;
        long long v58 = *(_OWORD *)(v55 + 16);
        long long v59 = *(_OWORD *)(v55 + 32);
        long long v60 = *(_OWORD *)(v55 + 48);
        uint64_t v168 = *(void *)(v55 + 64);
        v167[2] = v59;
        v167[3] = v60;
        v167[1] = v58;
        uint64_t v61 = [(PDFTextLineElement *)v57 initWithTextLine:v167 boundingBox:v56];
        [v145 addObject:v61];
        long long v62 = *(_OWORD *)(v55 + 48);
        *(_OWORD *)&v166.bbox.origin.double y = *(_OWORD *)(v55 + 32);
        *(_OWORD *)&v166.bbox.size.double height = v62;
        v166.identifier = *(void *)(v55 + 64);
        long long v63 = *(_OWORD *)(v55 + 16);
        v166.textRange = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v55;
        *(_OWORD *)&v166.uniCharStart = v63;
        PageLayout::addCTLDMapping(v4, &v166, v61);
        unint64_t v64 = v53 - 1;
        uint64_t v65 = *(void *)(v130 + 48);
        if (0x8E38E38E38E38E39 * ((*(void *)(v130 + 56) - v65) >> 3) <= v64) {
LABEL_94:
        }
          __break(1u);
        uint64_t v66 = v65 + 72 * v64;
        v202[0] = *(_DWORD *)(v66 + 64);
        id v67 = (id)std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v130 + 352, v202[0], v202)[3];
        CGRect v218 = *(CGRect *)(v66 + 24);
        CGAffineTransform v165 = v198;
        CGRect v219 = CGRectApplyAffineTransform(v218, &v165);
        uint64_t v68 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v219.origin.x, v219.origin.y, v219.size.width, v219.size.height, width, height);

        memmove(__dst, (const void *)v66, 0x48uLL);
        [v67 setTextLine:__dst];
        [v67 setBoundingQuad:v68];

        uint64_t v69 = (uint64_t *)v52[1];
        if (v69)
        {
          do
          {
            uint64_t v70 = v69;
            uint64_t v69 = (uint64_t *)*v69;
          }
          while (v69);
        }
        else
        {
          do
          {
            uint64_t v70 = (uint64_t *)v52[2];
            BOOL v71 = *v70 == (void)v52;
            unint64_t v52 = v70;
          }
          while (!v71);
        }
        unint64_t v52 = v70;
      }
      while (v70 != (uint64_t *)v171);
    }
    long long v162 = 0u;
    long long v163 = 0u;
    long long v160 = 0u;
    long long v161 = 0u;
    id v118 = v134;
    uint64_t v72 = [v118 countByEnumeratingWithState:&v160 objects:v202 count:16];
    if (v72)
    {
      uint64_t v121 = 0;
      uint64_t v117 = *(void *)v161;
      do
      {
        uint64_t v119 = 0;
        uint64_t v115 = v72;
        do
        {
          if (*(void *)v161 != v117) {
            objc_enumerationMutation(v118);
          }
          id v116 = *(id *)(*((void *)&v160 + 1) + 8 * v119);
          uint64_t v73 = [v116 valueForKey:@"Cells"];
          long long v158 = 0u;
          long long v159 = 0u;
          long long v156 = 0u;
          long long v157 = 0u;
          id v123 = v73;
          uint64_t v74 = [v123 countByEnumeratingWithState:&v156 objects:v201 count:16];
          if (v74)
          {
            uint64_t v120 = *(void *)v157;
            do
            {
              for (uint64_t n = 0; n != v74; ++n)
              {
                if (*(void *)v157 != v120) {
                  objc_enumerationMutation(v123);
                }
                id obja = *(id *)(*((void *)&v156 + 1) + 8 * n);
                unint64_t v75 = [obja valueForKey:@"Rect"];
                [v75 rectValue];
                id v135 = v76;
                CGFloat v78 = v77;
                double v80 = v79;
                double v82 = v81;

                uint64_t v83 = objc_opt_new();
                uint64_t v132 = (void *)v83;
                uint64_t v84 = *(void *)(v130 + 48);
                uint64_t v85 = *(void *)(v130 + 56);
                while (v84 != v85)
                {
                  double v86 = *(double *)(v84 + 40);
                  double v87 = *(double *)(v84 + 48);
                  double v88 = *(double *)(v84 + 24);
                  double y = *(double *)(v84 + 32);
                  if (v86 < 0.0 || v87 < 0.0)
                  {
                    CGRect v220 = CGRectStandardize(*(CGRect *)(v84 + 24));
                    double v92 = v220.origin.x + v220.size.width * 0.5;
                    v220.origin.x = v88;
                    v220.origin.double y = y;
                    v220.size.double width = v86;
                    double v91 = 0.5;
                    v220.size.double height = v87;
                    CGRect v221 = CGRectStandardize(v220);
                    double y = v221.origin.y;
                    double v87 = v221.size.height;
                  }
                  else
                  {
                    double v90 = v86 * 0.5;
                    double v91 = 0.5;
                    double v92 = v88 + v90;
                  }
                  v210.double y = y + v87 * v91;
                  *(void *)&v222.origin.x = v135;
                  v222.origin.double y = v78;
                  v222.size.double width = v80;
                  v222.size.double height = v82;
                  v210.x = v92;
                  uint64_t v83 = CGRectContainsPoint(v222, v210);
                  if (v83)
                  {
                    unsigned int v155 = *(_DWORD *)(v84 + 64);
                    id v93 = (id)std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v130 + 352, v155, &v155)[3];
                    [v132 addObject:v93];
                    [v145 removeObject:v93];
                  }
                  v84 += 72;
                }
                unint64_t v94 = PageLayout::createFineCTLDConfig((PageLayout *)v83);
                id v138 = [v124 groupAndOrderRegions:v132 config:v94 delegate:0];

                uint64_t v95 = objc_opt_new();
                long long v153 = 0u;
                long long v154 = 0u;
                long long v151 = 0u;
                long long v152 = 0u;
                id v139 = v138;
                uint64_t v96 = [v139 countByEnumeratingWithState:&v151 objects:v200 count:16];
                if (v96)
                {
                  id v142 = *(id *)v152;
                  do
                  {
                    for (iid i = 0; ii != v96; ++ii)
                    {
                      if (*(id *)v152 != v142) {
                        objc_enumerationMutation(v139);
                      }
                      id v98 = *(id *)(*((void *)&v151 + 1) + 8 * ii);
                      long long v147 = 0u;
                      long long v148 = 0u;
                      long long v149 = 0u;
                      long long v150 = 0u;
                      int v99 = [v98 subregions];
                      uint64_t v100 = v74;
                      uint64_t v101 = [v99 countByEnumeratingWithState:&v147 objects:v199 count:16];
                      if (v101)
                      {
                        uint64_t v102 = *(void *)v148;
                        do
                        {
                          for (juint64_t j = 0; jj != v101; ++jj)
                          {
                            if (*(void *)v148 != v102) {
                              objc_enumerationMutation(v99);
                            }
                            [v95 addObject:*(void *)(*((void *)&v147 + 1) + 8 * jj)];
                          }
                          uint64_t v101 = [v99 countByEnumeratingWithState:&v147 objects:v199 count:16];
                        }
                        while (v101);
                      }

                      uint64_t v74 = v100;
                    }
                    uint64_t v96 = [v139 countByEnumeratingWithState:&v151 objects:v200 count:16];
                  }
                  while (v96);
                }

                v223.size.double width = v80 + -0.001;
                v223.size.double height = v82 + -0.001;
                CGAffineTransform v146 = v198;
                *(void *)&v223.origin.x = v135;
                v223.origin.double y = v78;
                CGRect v224 = CGRectApplyAffineTransform(v223, &v146);
                uint64_t v104 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v224.origin.x, v224.origin.y, v224.size.width, v224.size.height, width, height);
                uint64_t v105 = [obja valueForKey:@"Row Index"];
                int v106 = [v105 intValue];

                uint64_t v107 = [[PDFCRGroupRegionCell alloc] initWithBoundingQuad:v104 layoutDirection:1 subregions:v95 parent:0 groupID:v121 rowIndex:v106];
                [v145 addObject:v107];
              }
              uint64_t v74 = [v123 countByEnumeratingWithState:&v156 objects:v201 count:16];
            }
            while (v74);
          }

          ++v121;
          ++v119;
        }
        while (v119 != v115);
        uint64_t v72 = [v118 countByEnumeratingWithState:&v160 objects:v202 count:16];
      }
      while (v72);
    }

    unint64_t v108 = objc_alloc_init(PDFCTLDDelegateForTables);
    uint64_t v109 = [*(id *)(v130 + 336) boundingQuad];
    [v109 boundingBox];
    id v114 = PageLayout::getOrderedLayout((uint64_t)v4, v145, v108, v110, v111, v112, v113);

    std::__tree<unsigned long>::destroy(v171[0]);
  }
}

void sub_184F43D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  std::__tree<unsigned long>::destroy((void *)STACK[0x360]);
  _Unwind_Resume(a1);
}

const void **CGOrderedSetCreate()
{
  v0 = (const void **)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (v0)
  {
    CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *v0 = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v1, 0, 0);
    v0[1] = Mutable;
    if (*v0) {
      BOOL v3 = Mutable == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (v3)
    {
      CGOrderedSetRelease(v0);
      return 0;
    }
  }
  return v0;
}

void CGOrderedSetRelease(const void **a1)
{
  if (a1)
  {
    size_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    BOOL v3 = a1[1];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void CGOrderedSetAddValue(CFSetRef *a1, const void *a2)
{
  CFIndex Count = CFSetGetCount(*a1);
  CFSetAddValue(*a1, a2);
  if (CFSetGetCount(*a1) > Count)
  {
    id v5 = a1[1];
    CFArrayAppendValue(v5, a2);
  }
}

double CGRenderingStateSynchronize(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    long long v2 = *(_OWORD *)(a2 + 24);
    long long v3 = *(_OWORD *)(a2 + 40);
    *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v3;
    *(_OWORD *)(a1 + 24) = v2;
    double result = *(double *)(a2 + 72);
    *(double *)(a1 + 72) = result;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    *(_WORD *)(a1 + 84) = *(_WORD *)(a2 + 84);
    *(unsigned char *)(a1 + 86) = *(unsigned char *)(a2 + 86);
  }
  return result;
}

atomic_uint *CGRenderingStateRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void CGRenderingStateRelease(void *a1)
{
  if (a1)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(a1);
    }
  }
}

uint64_t CGRenderingStateGetBaseCTM(uint64_t a1)
{
  return a1 + 24;
}

__n128 CGRenderingStateSetBaseCTM(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

double CGRenderingStateGetRenderingResolution(uint64_t a1)
{
  return *(double *)(a1 + 8);
}

uint64_t CGRenderingStateSetRenderingResolution(uint64_t result, double a2, double a3)
{
  double v3 = 432.0;
  if (a2 <= 432.0) {
    double v3 = a2;
  }
  if (a2 >= 72.0) {
    double v4 = v3;
  }
  else {
    double v4 = 72.0;
  }
  double v5 = 72.0;
  if (a3 >= 72.0)
  {
    double v5 = a3;
    if (a3 > 432.0) {
      double v5 = 432.0;
    }
  }
  *(double *)(result + 8) = v4;
  *(double *)(result + 16) = v5;
  return result;
}

uint64_t CGRenderingStateGetMinInterpolationQuality(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t CGRenderingStateSetMinInterpolationQuality(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t CGRenderingStateGetMaxInterpolationQuality(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t CGRenderingStateSetMaxInterpolationQuality(uint64_t result, int a2)
{
  *(_DWORD *)(result + 76) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsAcceleration(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

uint64_t CGRenderingStateSetAllowsAcceleration(uint64_t result, char a2)
{
  *(unsigned char *)(result + 80) = a2;
  return result;
}

uint64_t CGRenderingStateSetAllowsAntialiasing(uint64_t result, char a2)
{
  *(unsigned char *)(result + 81) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsDithering(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 82);
}

uint64_t CGRenderingStateSetAllowsDithering(uint64_t result, char a2)
{
  *(unsigned char *)(result + 82) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontAntialiasing(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 83);
}

uint64_t CGRenderingStateSetAllowsFontAntialiasing(uint64_t result, char a2)
{
  *(unsigned char *)(result + 83) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSmoothing(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 84);
}

uint64_t CGRenderingStateSetAllowsFontSmoothing(uint64_t result, char a2)
{
  *(unsigned char *)(result + 84) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSubpixelPositioning(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 85);
}

uint64_t CGRenderingStateSetAllowsFontSubpixelPositioning(uint64_t result, char a2)
{
  *(unsigned char *)(result + 85) = a2;
  return result;
}

uint64_t CGRenderingStateGetAllowsFontSubpixelQuantization(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 86);
}

uint64_t CGRenderingStateSetAllowsFontSubpixelQuantization(uint64_t result, char a2)
{
  *(unsigned char *)(result + 86) = a2;
  return result;
}

uint64_t CGRenderingStateGetVectorCapabilities(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 4);
  }
  else {
    return 3;
  }
}

uint64_t CGRenderingStateSetVectorCapabilities(uint64_t result, unsigned int a2)
{
  if (result)
  {
    int v2 = a2 | ~(-1 << -(char)__clz(a2));
    if (a2 < 2) {
      LOBYTE(v2) = a2;
    }
    *(_DWORD *)(result + 4) = v2 & 3;
  }
  return result;
}

uint64_t colorsync_smart_null_12379()
{
  return 0;
}

uint64_t __get_cache_block_invoke_12383()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  get_cache_transform_cache = (uint64_t)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040C6685353uLL);
  if (!get_cache_transform_cache) {
    _CGHandleAssert("get_cache_block_invoke", 120, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorSyncTransformCache.c", "transform_cache != NULL", "cache missing", v0, v1, v2, v8);
  }
  v10.__sig = 0;
  *(void *)v10.__opaque = 0;
  pthread_mutexattr_init(&v10);
  pthread_mutexattr_settype(&v10, 2);
  pthread_mutex_init((pthread_mutex_t *)get_cache_transform_cache, &v10);
  pthread_mutexattr_destroy(&v10);
  cache_attributes_t attrs = *(cache_attributes_t *)byte_1ED09C5B8;
  int v3 = cache_create("com.apple.CoreGraphics.colorsync_transform_cache", &attrs, (cache_t **)(get_cache_transform_cache + 64));
  if (v3) {
    _CGHandleAssert("get_cache_block_invoke", 142, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorSyncTransformCache.c", "cacheError == 0", "err %d", v4, v5, v6, v3);
  }
  return cache_set_count_hint();
}

void md5_creator_12392(int a1, const __CFString *cf, CC_MD5_CTX *a3)
{
  data[129] = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (md5_creator_cglibrarypredicate != -1) {
      dispatch_once(&md5_creator_cglibrarypredicate, &__block_literal_global_18_12393);
    }
    if (v5 == md5_creator_f())
    {
      if (md5_creator_cglibrarypredicate_21 != -1) {
        dispatch_once(&md5_creator_cglibrarypredicate_21, &__block_literal_global_24_12394);
      }
      data[0] = md5_creator_f_20(cf);
      data[1] = v6;
      if (a3)
      {
        id v7 = a3;
        CC_LONG v8 = 16;
LABEL_9:
        CC_MD5_Update(v7, data, v8);
      }
    }
    else
    {
      CFTypeID v9 = CFGetTypeID(cf);
      if (v9 == CFStringGetTypeID())
      {
        CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
        if (CStringPtr)
        {
          if (a3)
          {
            uint64_t v11 = (char *)CStringPtr;
            size_t v12 = strlen(CStringPtr);
            md5_update(a3, v11, v12);
          }
        }
        else
        {
          bzero(data, 0x401uLL);
          CFIndex Length = CFStringGetLength(cf);
          if (!CFStringGetCString(cf, (char *)data, 1024, 0x600u))
          {
            v24.locatiouint64_t n = 0;
            v24.length = Length;
            CFStringGetBytes(cf, v24, 0x600u, 0x3Fu, 0, (UInt8 *)data, 1024, 0);
          }
          size_t v15 = strlen((const char *)data);
          if (v15)
          {
            if (a3) {
              md5_update(a3, (char *)data, v15);
            }
          }
          else
          {
            CGLog(3, (uint64_t)"md5_creator failed for CFString %p", v16, v17, v18, v19, v20, v21, (char)cf);
          }
        }
      }
      else
      {
        CFTypeID v13 = CFGetTypeID(cf);
        if (v13 == CFBooleanGetTypeID())
        {
          LODWORD(data[0]) = *MEMORY[0x1E4F1CFD0] == (void)cf;
          if (a3)
          {
            id v7 = a3;
            CC_LONG v8 = 4;
            goto LABEL_9;
          }
        }
      }
    }
  }
}

void subpath_release(void *a1)
{
  uint64_t v2 = (void *)a1[2];
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }

  free(a1);
}

__n128 process_subpath_split(void **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unsigned int v5 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 - 1) < 3)
  {
    uint64_t v6 = path_list_create(v5, *(void *)(a2 + 8));
    *(void *)uint64_t v6 = v4[2];
LABEL_6:
    v4[2] = v6;
    return result;
  }
  if (v5 != 4)
  {
    if (v5) {
      return result;
    }
    uint64_t v4 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
    *uint64_t v4 = 0;
    v4[1] = 0xFFFFFFFEFFFFFFFFLL;
    v4[2] = 0;
    v4[3] = 0;
    *uint64_t v4 = *a1;
    *a1 = v4;
    uint64_t v6 = path_list_create(*(_DWORD *)a2, *(void *)(a2 + 8));
    goto LABEL_6;
  }
  CC_LONG v8 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x64A29F66uLL);
  CFTypeID v9 = 0;
  *((_DWORD *)v8 + 4) = 4;
  *(void *)CC_LONG v8 = 0;
  *((void *)v8 + 1) = 1;
  *(void *)CC_LONG v8 = v4[2];
  v4[2] = v8;
  pthread_mutexattr_t v10 = v8;
  do
  {
    uint64_t v11 = v10;
    pthread_mutexattr_t v10 = (void *)*v10;
    *uint64_t v11 = v9;
    CFTypeID v9 = v11;
  }
  while (v10);
  v4[2] = v11;
  __n128 result = *(__n128 *)(v11 + 3);
  *(__n128 *)(v8 + 24) = result;
  return result;
}

_DWORD *path_list_create(unsigned int a1, uint64_t a2)
{
  if (a1 > 4) {
    return 0;
  }
  uint64_t v4 = qword_1852119E0[a1];
  __n128 result = malloc_type_calloc(1uLL, 16 * v4 + 24, 0x64A29F66uLL);
  result[4] = a1;
  *(void *)__n128 result = 0;
  *((void *)result + 1) = v4;
  if (a2)
  {
    uint64_t v6 = 0;
    do
    {
      *(_OWORD *)&result[v6 + 6] = *(_OWORD *)(a2 + v6 * 4);
      v6 += 4;
      --v4;
    }
    while (v4);
  }
  return result;
}

id CGPDFPageCopyString(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(a1, 1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  id v3 = v1[5];
  CFRelease(v2);
  return v3;
}

void CGContextSetImageReplacer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      *(void *)(a1 + 64) = a3;
      *(void *)(a1 + 72) = a2;
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetImageReplacer", v8, a3, a4, a5, a6, a7, a8);
}

void CGContextSetInterpolationQualityRange(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 112);
      *(_DWORD *)(v8 + 72) = a2;
      *(_DWORD *)(v8 + 76) = a3;
      return;
    }
    uint64_t v9 = a1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  handle_invalid_context((char)"CGContextSetInterpolationQualityRange", v9, a3, a4, a5, a6, a7, a8);
}

void CGContextGetInterpolationQualityRange(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v8 = 0;
LABEL_9:
    handle_invalid_context((char)"CGContextGetInterpolationQualityRange", v8, (uint64_t)a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v8 = a1;
    goto LABEL_9;
  }
  if (a2) {
    *a2 = *(_DWORD *)(*(void *)(a1 + 112) + 72);
  }
  if (a3) {
    *a3 = *(_DWORD *)(*(void *)(a1 + 112) + 76);
  }
}

BOOL is_2x_scale(CGContext *a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  CGRect v15 = CGContextConvertRectToDeviceSpace(a1, *(CGRect *)&a3);
  CGFloat x = v15.origin.x;
  CGFloat y = v15.origin.y;
  CGFloat width = v15.size.width;
  double height = v15.size.height;
  BOOL v11 = v15.size.height < 0.0 || v15.size.width < 0.0;
  if (v11) {
    CGRect v15 = CGRectStandardize(v15);
  }
  if (a2) {
    double v12 = (double)*(unint64_t *)(a2 + 40);
  }
  else {
    double v12 = 0.0;
  }
  if (fabs(v15.size.width / v12 + -2.0) >= 1.0) {
    return 0;
  }
  if (v11)
  {
    v16.origin.CGFloat x = x;
    v16.origin.CGFloat y = y;
    v16.size.CGFloat width = width;
    v16.size.double height = height;
    CGRect v17 = CGRectStandardize(v16);
    double height = v17.size.height;
  }
  double v13 = a2 ? (double)*(unint64_t *)(a2 + 48) : 0.0;
  return fabs(height / v13 + -2.0) < 1.0;
}

float CGGetFloatValue(const void *a1)
{
  float v1 = 0.0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      float valuePtr = 0.0;
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloatType, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

void CGContextDrawTiledImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  if (!c)
  {
    CGContextRef v18 = 0;
LABEL_12:
    handle_invalid_context((char)"CGContextDrawTiledImage", (uint64_t)v18, v3, v4, v5, v6, v7, v8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v18 = c;
    goto LABEL_12;
  }
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  double y = rect.origin.y;
  CGFloat x = rect.origin.x;
  BOOL v15 = rect.size.height < 0.0 || rect.size.width < 0.0;
  double v16 = rect.size.width;
  if (v15)
  {
    CGRect v81 = CGRectStandardize(rect);
    double v16 = v81.size.width;
  }
  if (image) {
    unint64_t v17 = *((void *)image + 5);
  }
  else {
    unint64_t v17 = 0;
  }
  double v19 = height;
  if (v15)
  {
    v82.origin.CGFloat x = x;
    v82.origin.double y = y;
    v82.size.CGFloat width = width;
    v82.size.CGFloat height = height;
    *(CGRect *)(&v19 - 3) = CGRectStandardize(v82);
  }
  if (image) {
    double v20 = (double)*((unint64_t *)image + 6);
  }
  else {
    double v20 = 0.0;
  }
  double v21 = v16 / (double)v17;
  double v22 = v19 / v20;
  if (v15)
  {
    v83.origin.CGFloat x = x;
    v83.origin.double y = y;
    v83.size.CGFloat width = width;
    v83.size.CGFloat height = height;
    *(void *)&double v23 = (unint64_t)CGRectStandardize(v83);
    v84.origin.CGFloat x = x;
    v84.origin.double y = y;
    v84.size.CGFloat width = width;
    v84.size.CGFloat height = height;
    CGRect v85 = CGRectStandardize(v84);
    double y = v85.origin.y;
  }
  else
  {
    double v23 = x;
  }
  CFRange v24 = (double *)*((void *)c + 12);
  double v25 = v24[3];
  double v26 = v24[4];
  double v27 = v24[5];
  double v28 = v24[6];
  double v29 = v24[8];
  *(double *)&long long v30 = v22 * v28 + v26 * 0.0;
  *((double *)&v30 + 1) = v24[7] + v27 * y + v23 * v25;
  v78.b = v28 * 0.0 + v21 * v26;
  v78.c = v22 * v27 + v25 * 0.0;
  v78.a = v27 * 0.0 + v21 * v25;
  *(_OWORD *)&v78.d = v30;
  v78.tdouble y = v28 * y + v23 * v26 + v29;
  CGPatternRef v31 = CGPatternCreateWithImage2((unint64_t *)image, &v78, kCGPatternTilingConstantSpacing);
  if (v31)
  {
    unint64_t v39 = v31;
    uint64_t v77 = 0x3FF0000000000000;
    if (image && (*((unsigned char *)image + 39) & 2) != 0)
    {
      FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor((uint64_t)c, v32, v33, v34, v35, v36, v37, v38);
      if (!FillColorAsColor) {
        goto LABEL_35;
      }
      unint64_t v54 = (unint64_t)FillColorAsColor;
      Components = CGColorGetComponents(FillColorAsColor);
      if ((v54 & 0x8000000000000000) != 0) {
        ColorSpace = CGTaggedColorGetColorSpace(v54, v55, v56, v57, v58, v59, v60, v61);
      }
      else {
        ColorSpace = *(CGColorSpace **)(v54 + 24);
      }
    }
    else
    {
      ColorSpace = 0;
      Components = (const CGFloat *)&v77;
    }
    Patteruint64_t n = CGColorSpaceCreatePattern(ColorSpace);
    if (Pattern)
    {
      double v43 = Pattern;
      double v44 = CGColorCreateWithPattern(Pattern, v39, Components);
      CGColorSpaceRelease(v43);
      CFRelease(v39);
      if (!v44) {
        return;
      }
      if (*((_DWORD *)c + 4) == 1129601108)
      {
        uint64_t v51 = *((void *)c + 14);
        long long v52 = *(_OWORD *)(v51 + 40);
        *(_OWORD *)&v78.a = *(_OWORD *)(v51 + 24);
        *(_OWORD *)&v78.c = v52;
        *(_OWORD *)&v78.tCGFloat x = *(_OWORD *)(v51 + 56);
      }
      else
      {
        handle_invalid_context((char)"CGContextGetBaseCTM", (uint64_t)c, v45, v46, v47, v48, v49, v50);
        CGAffineTransform v78 = CGAffineTransformIdentity;
        if (*((_DWORD *)c + 4) != 1129601108)
        {
          handle_invalid_context((char)"CGContextSetBaseCTM", (uint64_t)c, v63, v64, v65, v66, v67, v68);
          goto LABEL_40;
        }
      }
      *(CGAffineTransform *)(*((void *)c + 14) + 24) = CGAffineTransformIdentity;
LABEL_40:
      CGContextSaveGState(c);
      v80.CGFloat width = 0.0;
      v80.CGFloat height = 0.0;
      CGContextSetPatternPhase(c, v80);
      CGContextSetFillColorWithColor(c, v44);
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(c);
      CGContextFillRect(c, ClipBoundingBox);
      CGContextRestoreGState(c);
      if (*((_DWORD *)c + 4) == 1129601108)
      {
        uint64_t v75 = *((void *)c + 14);
        long long v76 = *(_OWORD *)&v78.c;
        *(_OWORD *)(v75 + 24) = *(_OWORD *)&v78.a;
        *(_OWORD *)(v75 + 40) = v76;
        *(_OWORD *)(v75 + 56) = *(_OWORD *)&v78.tx;
      }
      else
      {
        handle_invalid_context((char)"CGContextSetBaseCTM", (uint64_t)c, v69, v70, v71, v72, v73, v74);
      }
      long long v62 = v44;
      goto LABEL_44;
    }
LABEL_35:
    long long v62 = v39;
LABEL_44:
    CFRelease(v62);
  }
}

void CGContextDrawImages(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!c)
  {
    CGContextRef v18 = 0;
LABEL_17:
    handle_invalid_context((char)"CGContextDrawImages", (uint64_t)v18, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v18 = c;
    goto LABEL_17;
  }
  if (a2 && a3 && a5)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      BOOL v15 = *(void **)(a3 + 8 * v13);
      if (v15)
      {
        ++v14;
        if (CGImageGetClipPath(v15))
        {
          if (!v14) {
            return;
          }
          goto LABEL_21;
        }
      }
      ++v13;
    }
    while (a5 != v13);
    if (!v14) {
      return;
    }
    uint64_t v16 = *((void *)c + 5);
    if (!v16) {
      return;
    }
    unint64_t v17 = *(unsigned int (**)(void))(v16 + 136);
    if (v17)
    {
      if (v17() != 1006) {
        return;
      }
    }
LABEL_21:
    if (a4)
    {
      BOOL v19 = *(void *)(*(void *)(*((void *)c + 12) + 120) + 16) != 0;
      CGFloat height = 0.0;
      *(double *)&uint64_t v21 = INFINITY;
      CGFloat width = 0.0;
      *(double *)&uint64_t v23 = INFINITY;
    }
    else
    {
      *(CGRect *)&uint64_t v23 = CGContextGetClipBoundingBox(c);
      if (v81.size.width == 0.0) {
        return;
      }
      CGFloat height = v81.size.height;
      if (v81.size.height == 0.0) {
        return;
      }
      CGFloat width = v81.size.width;
      BOOL v19 = 0;
    }
    uint64_t v24 = 0;
    if (a5 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = a5;
    }
    uint64_t v78 = v21;
    double v79 = height;
    uint64_t v76 = v23;
    double v77 = width;
    do
    {
      double v26 = *(CGImage **)(a3 + 8 * v24);
      if (!v26) {
        goto LABEL_33;
      }
      double v27 = (CGFloat *)(a2 + 32 * v24);
      double v28 = v27[2];
      if (v28 == 0.0) {
        goto LABEL_33;
      }
      double v29 = v27[3];
      if (v29 == 0.0) {
        goto LABEL_33;
      }
      double x = *(double *)&v23;
      double y = *(double *)&v21;
      double v32 = width;
      double v33 = height;
      if (a4)
      {
        uint64_t v34 = a4 + 32 * v24;
        double v35 = *(double *)(v34 + 16);
        if (v35 == 0.0) {
          goto LABEL_33;
        }
        double v36 = *(double *)(v34 + 24);
        if (v36 == 0.0) {
          goto LABEL_33;
        }
        uint64_t v37 = *(void *)v34;
        uint64_t v38 = *(void *)(v34 + 8);
        CGRect v82 = CGRectStandardize(*(CGRect *)(&v35 - 2));
        double x = v82.origin.x;
        double y = v82.origin.y;
        double v32 = v82.size.width;
        double v33 = v82.size.height;
      }
      v83.origin.double x = *v27;
      v83.origin.double y = v27[1];
      v83.size.CGFloat width = v28;
      v83.size.CGFloat height = v29;
      CGRect v84 = CGRectStandardize(v83);
      double v39 = v84.origin.x;
      double v40 = v84.origin.y;
      double v41 = v84.size.width;
      double v42 = v84.size.height;
      v102.origin.double x = x;
      v102.origin.double y = y;
      v102.size.CGFloat width = v32;
      v102.size.CGFloat height = v33;
      if (CGRectEqualToRect(v84, v102))
      {
        v85.origin.double x = v39;
        v85.origin.double y = v40;
        v85.size.CGFloat width = v41;
        v85.size.CGFloat height = v42;
        CGContextDrawImage(c, v85, v26);
      }
      else
      {
        v86.origin.double x = v39;
        v86.origin.double y = v40;
        v86.size.CGFloat width = v41;
        v86.size.CGFloat height = v42;
        v103.origin.double x = x;
        v103.origin.double y = y;
        v103.size.CGFloat width = v32;
        v103.size.CGFloat height = v33;
        if (CGRectContainsRect(v86, v103))
        {
          if (!v19) {
            goto LABEL_63;
          }
          goto LABEL_43;
        }
        uint64_t v21 = v78;
        CGFloat height = v79;
        uint64_t v23 = v76;
        CGFloat width = v77;
        if (v41 == 0.0 || v42 == 0.0) {
          goto LABEL_33;
        }
        if (v41 < 0.0 || v42 < 0.0)
        {
          v87.origin.double x = v39;
          v87.origin.double y = v40;
          v87.size.CGFloat width = v41;
          v87.size.CGFloat height = v42;
          unint64_t v48 = (unint64_t)CGRectStandardize(v87);
          v88.origin.double x = v39;
          double v39 = *(double *)&v48;
          v88.origin.double y = v40;
          v88.size.CGFloat width = v41;
          v88.size.CGFloat height = v42;
          CGRect v89 = CGRectStandardize(v88);
          double v40 = v89.origin.y;
        }
        double v49 = fabs(v42);
        double v50 = fabs(v41);
        if (v32 < 0.0 || v33 < 0.0)
        {
          v90.origin.double x = x;
          double v74 = v50;
          double v75 = v49;
          v90.origin.double y = y;
          v90.size.CGFloat width = v32;
          v90.size.CGFloat height = v33;
          double v39 = v39 + v74 * floor((COERCE_DOUBLE(CGRectStandardize(v90)) - v39) / v74);
          v91.origin.double x = x;
          v91.origin.double y = y;
          v91.size.CGFloat width = v32;
          v91.size.CGFloat height = v33;
          CGRect v92 = CGRectStandardize(v91);
          double v40 = v40 + v75 * floor((v92.origin.y - v40) / v75);
          v92.origin.double x = x;
          v92.origin.double y = y;
          v92.size.CGFloat width = v32;
          v92.size.CGFloat height = v33;
          CGRect v93 = CGRectStandardize(v92);
          unint64_t v51 = vcvtmd_u64_f64((v93.origin.x + v93.size.width - v39) / v74);
          v93.origin.double x = x;
          v93.origin.double y = y;
          v93.size.CGFloat width = v32;
          v93.size.CGFloat height = v33;
          *(CGRect *)(&v52 - 1) = CGRectStandardize(v93);
          double v49 = v75;
        }
        else
        {
          double v39 = v39 + v50 * floor((x - v39) / v50);
          double v40 = v40 + v49 * floor((y - v40) / v49);
          unint64_t v51 = vcvtmd_u64_f64((x + v32 - v39) / v50);
          double v52 = y;
          double v53 = v33;
        }
        unint64_t v54 = vcvtmd_u64_f64((v52 + v53 - v40) / v49);
        if (!(v51 | v54))
        {
          v95.origin.double x = v39;
          v95.origin.double y = v40;
          v95.size.CGFloat width = v41;
          v95.size.CGFloat height = v42;
          v104.origin.double x = x;
          v104.origin.double y = y;
          v104.size.CGFloat width = v32;
          v104.size.CGFloat height = v33;
          if (CGRectEqualToRect(v95, v104))
          {
            v96.origin.double x = v39;
            v96.origin.double y = v40;
            v96.size.CGFloat width = v41;
            v96.size.CGFloat height = v42;
            CGContextDrawImage(c, v96, v26);
LABEL_83:
            uint64_t v21 = v78;
            CGFloat height = v79;
            uint64_t v23 = v76;
            CGFloat width = v77;
            goto LABEL_33;
          }
          if (!v19)
          {
LABEL_63:
            CGContextSaveGState(c);
LABEL_64:
            v97.origin.double x = x;
            v97.origin.double y = y;
            v97.size.CGFloat width = v32;
            v97.size.CGFloat height = v33;
            CGContextClipToRect(c, v97);
            v98.origin.double x = v39;
            v98.origin.double y = v40;
            v98.size.CGFloat width = v41;
            v98.size.CGFloat height = v42;
            CGContextDrawImage(c, v98, *(CGImageRef *)(a3 + 8 * v24));
            if (v19) {
              CGContextEndTransparencyLayer(c);
            }
            else {
              CGContextRestoreGState(c);
            }
            goto LABEL_72;
          }
LABEL_43:
          if (a4)
          {
            double v43 = c;
            unint64_t v44 = *(void *)&x;
            unint64_t v45 = *(void *)&y;
            uint64_t v46 = *(void *)&v32;
            uint64_t v47 = *(void *)&v33;
          }
          else
          {
            unint64_t v44 = 0xFFDFFFFFFFFFFFFFLL;
            uint64_t v46 = 0x7FEFFFFFFFFFFFFFLL;
            double v43 = c;
            unint64_t v45 = 0xFFDFFFFFFFFFFFFFLL;
            uint64_t v47 = 0x7FEFFFFFFFFFFFFFLL;
          }
          CGContextBeginTransparencyLayerWithRect(v43, *(CGRect *)&v44, 0);
          goto LABEL_64;
        }
        image_patteruint64_t n = create_image_pattern(c, (uint64_t)v26, v39, v40, v41, v42);
        if (!image_pattern)
        {
          BOOL v73 = v19;
          if (v19)
          {
            if (a4)
            {
              uint64_t v66 = c;
              unint64_t v67 = *(void *)&x;
              unint64_t v68 = *(void *)&y;
              uint64_t v69 = *(void *)&v32;
              uint64_t v70 = *(void *)&v33;
            }
            else
            {
              unint64_t v67 = 0xFFDFFFFFFFFFFFFFLL;
              uint64_t v69 = 0x7FEFFFFFFFFFFFFFLL;
              uint64_t v66 = c;
              unint64_t v68 = 0xFFDFFFFFFFFFFFFFLL;
              uint64_t v70 = 0x7FEFFFFFFFFFFFFFLL;
            }
            CGContextBeginTransparencyLayerWithRect(v66, *(CGRect *)&v67, 0);
          }
          else
          {
            CGContextSaveGState(c);
          }
          v100.origin.double x = x;
          v100.origin.double y = y;
          v100.size.CGFloat width = v32;
          v100.size.CGFloat height = v33;
          CGContextClipToRect(c, v100);
          unint64_t v71 = 0;
          do
          {
            unint64_t v72 = 0;
            do
            {
              v101.origin.double x = v39 + v41 * (double)v72;
              v101.origin.double y = v40 + v42 * (double)v71;
              v101.size.CGFloat width = v41;
              v101.size.CGFloat height = v42;
              CGContextDrawImage(c, v101, *(CGImageRef *)(a3 + 8 * v24));
              ++v72;
            }
            while (v72 <= v51);
            ++v71;
          }
          while (v71 <= v54);
          BOOL v19 = v73;
          if (v73) {
            CGContextEndTransparencyLayer(c);
          }
          else {
            CGContextRestoreGState(c);
          }
          goto LABEL_83;
        }
        uint64_t v63 = image_pattern;
        FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor((uint64_t)c, v56, v57, v58, v59, v60, v61, v62);
        uint64_t v65 = FillColorAsColor;
        if (FillColorAsColor)
        {
          CFRetain(FillColorAsColor);
          CGContextSetFillColorWithColor(c, v63);
          v94.origin.double x = x;
          v94.origin.double y = y;
          v94.size.CGFloat width = v32;
          v94.size.CGFloat height = v33;
          CGContextFillRect(c, v94);
          CGContextSetFillColorWithColor(c, v65);
          CFRelease(v65);
        }
        else
        {
          CGContextSetFillColorWithColor(c, v63);
          v99.origin.double x = x;
          v99.origin.double y = y;
          v99.size.CGFloat width = v32;
          v99.size.CGFloat height = v33;
          CGContextFillRect(c, v99);
          CGContextSetFillColorWithColor(c, 0);
        }
        CFRelease(v63);
      }
LABEL_72:
      uint64_t v21 = v78;
      CGFloat height = v79;
      uint64_t v23 = v76;
      CGFloat width = v77;
LABEL_33:
      ++v24;
    }
    while (v24 != v25);
  }
}

CGColorRef create_image_pattern(CGContext *a1, uint64_t a2, CGFloat a3, CGFloat y, CGFloat a5, CGFloat a6)
{
  BOOL v12 = a6 < 0.0 || a5 < 0.0;
  double width = a5;
  if (v12)
  {
    CGRect v75 = CGRectStandardize(*(CGRect *)&a3);
    double width = v75.size.width;
  }
  if (a2) {
    double v14 = (double)*(unint64_t *)(a2 + 40);
  }
  else {
    double v14 = 0.0;
  }
  double v15 = a6;
  if (v12)
  {
    v76.origin.double x = a3;
    v76.origin.double y = y;
    v76.size.double width = a5;
    v76.size.CGFloat height = a6;
    *(CGRect *)(&v15 - 3) = CGRectStandardize(v76);
  }
  if (a2) {
    double v16 = (double)*(unint64_t *)(a2 + 48);
  }
  else {
    double v16 = 0.0;
  }
  double v17 = width / v14;
  double v18 = v15 / v16;
  if (v12)
  {
    v77.origin.double x = a3;
    v77.origin.double y = y;
    v77.size.double width = a5;
    v77.size.CGFloat height = a6;
    *(void *)&double v19 = (unint64_t)CGRectStandardize(v77);
    v78.origin.double x = a3;
    v78.origin.double y = y;
    v78.size.double width = a5;
    v78.size.CGFloat height = a6;
    CGRect v79 = CGRectStandardize(v78);
    double y = v79.origin.y;
  }
  else
  {
    double v19 = a3;
  }
  uint64_t v74 = 0;
  CGContextGetCTM(&v70, a1);
  double v20 = v70.c * 0.0 + v17 * v70.a;
  double v21 = v70.d * 0.0 + v17 * v70.b;
  double v22 = v18 * v70.c + v70.a * 0.0;
  double v23 = v18 * v70.d + v70.b * 0.0;
  double v24 = v70.tx + v70.c * y + v19 * v70.a;
  double v25 = v70.d * y + v19 * v70.b + v70.ty;
  CGContextGetBaseCTM((uint64_t)a1, v26, v27, v28, v29, v30, v31, (uint64_t)&v71);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v71, (float64x2_t)xmmword_1850CD830), (int32x4_t)vceqq_f64(v72, (float64x2_t)xmmword_1850CD8C0))))) & 1) != 0|| *(double *)&v73 != 0.0|| *((double *)&v73 + 1) != 0.0)
  {
    *(float64x2_t *)&v68.a = v71;
    *(float64x2_t *)&v68.c = v72;
    *(_OWORD *)&v68.tdouble x = v73;
    CGAffineTransformInvert(&v69, &v68);
    double v39 = v21 * v69.c;
    double v21 = v21 * v69.d + v20 * v69.b;
    double v20 = v39 + v20 * v69.a;
    double v40 = v23 * v69.c;
    double v23 = v23 * v69.d + v22 * v69.b;
    double v22 = v40 + v22 * v69.a;
    CGFloat v41 = v69.d * v25 + v24 * v69.b;
    double v24 = v69.tx + v69.c * v25 + v24 * v69.a;
    double v25 = v41 + v69.ty;
  }
  double PatternPhase = CGContextGetPatternPhase((uint64_t)a1, v32, v33, v34, v35, v36, v37, v38);
  v68.a = v20;
  v68.b = v21;
  v68.c = v22;
  v68.d = v23;
  v68.tdouble x = v24 - PatternPhase;
  v68.tdouble y = v25 - v43;
  CGPatternRef v44 = CGPatternCreateWithImage2((unint64_t *)a2, &v68, kCGPatternTilingNoDistortion);
  if (v44)
  {
    double v52 = v44;
    if (a2 && (*(unsigned char *)(a2 + 39) & 2) != 0)
    {
      uint64_t FillColorAsColor = CGContextGetFillColorAsColor((uint64_t)a1, v45, v46, v47, v48, v49, v50, v51);
      if (!FillColorAsColor) {
        goto LABEL_31;
      }
      unint64_t v59 = FillColorAsColor;
      if (FillColorAsColor >= 1)
      {
        if (*(void *)(FillColorAsColor + 32)) {
          goto LABEL_31;
        }
      }
      Components = CGColorGetComponents((CGColorRef)FillColorAsColor);
      if ((v59 & 0x8000000000000000) != 0) {
        ColorSpace = CGTaggedColorGetColorSpace(v59, v61, v62, v63, v64, v65, v66, v67);
      }
      else {
        ColorSpace = *(CGColorSpace **)(v59 + 24);
      }
    }
    else
    {
      ColorSpace = 0;
      uint64_t v74 = 0x3FF0000000000000;
      Components = (const CGFloat *)&v74;
    }
    Patteruint64_t n = CGColorSpaceCreatePattern(ColorSpace);
    if (Pattern)
    {
      uint64_t v56 = Pattern;
      CGColorRef v57 = CGColorCreateWithPattern(Pattern, v52, Components);
      CGColorSpaceRelease(v56);
LABEL_32:
      CFRelease(v52);
      return v57;
    }
LABEL_31:
    CGColorRef v57 = 0;
    goto LABEL_32;
  }
  return 0;
}

void CGContextDrawImageFromRect(CGContext *a1, CGImageRef image, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9, __n128 a10)
{
  uint64_t v11 = *((void *)a1 + 5);
  if (v11)
  {
    CGFloat v12 = a10.n128_f64[0];
    CGFloat v13 = a9.n128_f64[0];
    CGFloat v14 = a8.n128_f64[0];
    CGFloat v15 = a7.n128_f64[0];
    CGFloat v17 = a6.n128_f64[0];
    CGFloat v18 = a5.n128_f64[0];
    CGFloat v19 = a4.n128_f64[0];
    CGFloat v20 = a3.n128_f64[0];
    double v21 = *(unsigned int (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))(v11 + 144);
    if (!v21 || v21(a3, a4, a5, a6, a7, a8, a9, a10) == 1006)
    {
      v25.origin.double x = v15;
      v25.origin.double y = v14;
      v25.size.double width = v13;
      v25.size.CGFloat height = v12;
      double v22 = CGImageCreateWithImageInRect(image, v25);
      if (v22)
      {
        double v23 = v22;
        v26.origin.double x = v20;
        v26.origin.double y = v19;
        v26.size.double width = v18;
        v26.size.CGFloat height = v17;
        CGContextDrawImage(a1, v26, v22);
        CFRelease(v23);
      }
    }
  }
}

uint64_t CGContextDrawImageApplyingToneMapping(CGContext *c, CGImageRef image, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  if (!c)
  {
    CGContextRef v41 = 0;
LABEL_23:
    handle_invalid_context((char)"CGContextDrawImageApplyingToneMapping", (uint64_t)v41, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v41 = c;
    goto LABEL_23;
  }
  CGImageRef v13 = image;
  if (a3)
  {
    float HeadroomInfo = CGImageGetHeadroomInfo(image, 0);
    if (HeadroomInfo >= 1.0 || HeadroomInfo <= 0.0) {
      float v27 = HeadroomInfo;
    }
    else {
      float v27 = 1.0;
    }
    if (HeadroomInfo >= 0.0) {
      float v28 = v27;
    }
    else {
      float v28 = 0.0;
    }
    if (v28 < 1.0)
    {
      CGPostError((uint64_t)"%s: image doesn't have a valid headroom value", v18, v19, v20, v21, v22, v23, v24, (char)"CGContextDrawImageApplyingToneMapping");
    }
    else
    {
      if (v13) {
        CFRetain(v13);
      }
      CopyWithProtectedDataProvider = CGImageCreateCopyWithProtectedDataProvider(v13);
      if (CopyWithProtectedDataProvider)
      {
        uint64_t v37 = CopyWithProtectedDataProvider;
        CFRelease(v13);
        CGImageRef v13 = v37;
      }
      uint64_t v38 = *((void *)c + 5);
      BOOL v40 = v38
         && (double v39 = *(unsigned int (**)(double, double, double, double))(v38 + 272)) != 0
         && v39(a9, a10, a11, a12) == 0;
      if (v13) {
        CFRelease(v13);
      }
      if (v40) {
        return 1;
      }
    }
    CGPostError((uint64_t)"%s failed", v30, v31, v32, v33, v34, v35, v36, (char)"CGContextDrawImageApplyingToneMapping");
    return 0;
  }
  CGContextDrawImage(c, *(CGRect *)&a9, image);
  return 1;
}

uint64_t CGDataProviderCreateWithSoftMaskAndMatte(void *a1, void *a2, vImagePixelCount a3, CGDataProvider *a4, CGImage *a5, unsigned int a6)
{
  CopyWithCGColorSpaceRef ColorSpace = a5;
  uint64_t v344 = *MEMORY[0x1E4F143B8];
  if (!CGImageGetMask(a5))
  {
    CGImageGetMask(CopyWithColorSpace);
    _CGHandleAssert("CGDataProviderCreateWithSoftMaskAndMatte", 1214, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image != NULL && CGImageGetMask(image) != NULL", "image %p  mask %p", v300, v301, v302, (char)CopyWithColorSpace);
  }
  uint64_t v11 = malloc_type_calloc(1uLL, 0x518uLL, 0xA3729uLL);
  if (!v11) {
    return 0;
  }
  CGFloat v12 = v11;
  int v312 = a1;
  Mask = (CGImage *)CGImageGetMask(CopyWithColorSpace);
  unsigned int UpscaledComponentType = CGImageGetUpscaledComponentType(CopyWithColorSpace);
  unsigned int v15 = CGImageGetUpscaledComponentType(Mask);
  if (UpscaledComponentType > 5 || ((1 << UpscaledComponentType) & 0x36) == 0) {
    _CGHandleAssert("choose_component_type", 1120, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_component_type == kCGImageComponent8BitInteger || image_component_type == kCGImageComponent16BitInteger || image_component_type == kCGImageComponent16BitFloat || image_component_type == kCGImageComponent32BitFloat", "component type %d", v16, v17, v18, UpscaledComponentType);
  }
  if (v15 > 5 || ((1 << v15) & 0x36) == 0) {
    _CGHandleAssert("choose_component_type", 1125, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_component_type == kCGImageComponent8BitInteger || smask_component_type == kCGImageComponent16BitInteger || smask_component_type == kCGImageComponent16BitFloat || smask_component_type == kCGImageComponent32BitFloat", "mask component type %d", v16, v17, v18, v15);
  }
  int v317 = a4;
  switch(UpscaledComponentType)
  {
    case 1u:
      unsigned int UpscaledComponentType = v15;
      break;
    case 2u:
      if (v15 - 3 >= 0xFFFFFFFE) {
        unsigned int UpscaledComponentType = 2;
      }
      else {
        unsigned int UpscaledComponentType = v15;
      }
      break;
    case 4u:
      break;
    case 5u:
      if (v15 == 4) {
        unsigned int UpscaledComponentType = 4;
      }
      else {
        unsigned int UpscaledComponentType = 5;
      }
      break;
    default:
      _CGHandleAssert("choose_component_type", 1147, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v16, v17, v18, v303);
  }
  Matte = (double *)CGImageGetMatte(CopyWithColorSpace);
  if (Matte)
  {
    uint64_t v20 = Matte;
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(CopyWithColorSpace);
    uint64_t v22 = (uint64_t)ColorSpace;
    if (ColorSpace) {
      uint64_t v23 = *(void *)(*((void *)ColorSpace + 3) + 48);
    }
    else {
      uint64_t v23 = 0;
    }
    v12[1065] = 1;
    int Type = CGColorSpaceGetType(ColorSpace);
    if ((Type - 10) < 2 || Type == 6)
    {
      if (!v22 || !*(unsigned char *)(*(void *)(v22 + 24) + 13))
      {
        uint64_t v32 = (unsigned char *)CGColorSpaceICCGetRange(v22, v25, v26, v27, v28, v29, v30, v31);
        if (v32) {
          goto LABEL_31;
        }
      }
    }
    else if (Type == 5)
    {
      memset(v325, 0, 64);
      long long v323 = 0u;
      long long v324 = 0u;
      CGColorSpaceGetLabData(v22, v29, v30, v31, &v323);
      *(_OWORD *)long long __dst = xmmword_1850CDCF0;
      *(_OWORD *)&__dst[16] = v325[1];
      *(_OWORD *)&__dst[32] = v325[2];
LABEL_30:
      uint64_t v32 = __dst;
      goto LABEL_31;
    }
    if (!v23) {
      goto LABEL_30;
    }
    for (uint64_t i = 0; i != v23; ++i)
    {
      uint64_t v32 = __dst;
      *(_OWORD *)&__dst[16 * i] = xmmword_1850CD8C0;
    }
LABEL_31:
    uint64_t v34 = v12 + 1072;
    switch(UpscaledComponentType)
    {
      case 1u:
        if (v23)
        {
          uint64_t v35 = (double *)(v32 + 8);
          do
          {
            double v36 = *v20++;
            *(unsigned char *)uint64_t v34 = (int)fmax(fmin(round((v36 - *(v35 - 1)) / (*v35 - *(v35 - 1)) * 255.0), 255.0), 0.0);
            uint64_t v34 = (_WORD *)((char *)v34 + 1);
            v35 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 2u:
        if (v23)
        {
          uint64_t v37 = (double *)(v32 + 8);
          do
          {
            double v38 = *v20++;
            *v34++ = (int)fmax(fmin(round((v38 - *(v37 - 1)) / (*v37 - *(v37 - 1)) * 65535.0), 65535.0), 0.0);
            v37 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 4u:
        if (v23)
        {
          double v39 = (double *)(v32 + 8);
          do
          {
            double v40 = *v20++;
            float v41 = (v40 - *(v39 - 1)) / (*v39 - *(v39 - 1));
            *(float *)uint64_t v34 = v41;
            v34 += 2;
            v39 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      case 5u:
        if (v23)
        {
          double v42 = (double *)(v32 + 8);
          do
          {
            double v43 = *v20++;
            _S0 = (v43 - *(v42 - 1)) / (*v42 - *(v42 - 1));
            __asm { FCVT            H0, S0 }
            *v34++ = LOWORD(_S0);
            v42 += 2;
            --v23;
          }
          while (v23);
        }
        break;
      default:
        _CGHandleAssert("copy_matte", 1109, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v29, v30, v31, v303);
    }
  }
  DataProviderInternal = CGImageGetDataProviderInternal((char *)CopyWithColorSpace, 0);
  uint64_t v49 = CGImageGetDataProviderInternal((char *)Mask, 0);
  if (!DataProviderInternal) {
    goto LABEL_223;
  }
  double v53 = (CFIndex *)v49;
  unsigned int v54 = *((_DWORD *)DataProviderInternal + 5) & 0xFFFFFFFD;
  if (!v49) {
    goto LABEL_223;
  }
  if (CopyWithColorSpace)
  {
    uint64_t v55 = *((void *)CopyWithColorSpace + 9);
    uint64_t v56 = *((void *)CopyWithColorSpace + 8) * *((void *)CopyWithColorSpace + 5);
  }
  else
  {
    uint64_t v55 = 0;
    uint64_t v56 = 0;
  }
  CGColorRef v57 = (uint64_t *)Mask;
  if (Mask)
  {
    uint64_t v58 = *((void *)Mask + 9);
    uint64_t v59 = *((void *)Mask + 8) * *((void *)Mask + 5);
  }
  else
  {
    uint64_t v58 = 0;
    uint64_t v59 = 0;
  }
  unsigned int v314 = UpscaledComponentType;
  unint64_t v60 = v56 + 7;
  uint64_t v61 = a2;
  if (CopyWithColorSpace) {
    uint64_t v62 = (uint64_t *)*((void *)CopyWithColorSpace + 6);
  }
  else {
    uint64_t v62 = 0;
  }
  unint64_t v63 = v59 + 7;
  unsigned int v64 = *((_DWORD *)v49 + 5) & 0xFFFFFFFD;
  uint64_t v65 = v55 - (v60 >> 3);
  uint64_t v66 = v57;
  if (v57) {
    uint64_t v66 = (uint64_t *)v57[6];
  }
  uint64_t v67 = v58 - (v63 >> 3);
  vImagePixelCount v318 = a3;
  if ((v54 != 0) == (v64 != 0) && v62 == v66 && v65 == v67)
  {
    BOOL v306 = (*((_DWORD *)DataProviderInternal + 5) & 0xFFFFFFFD) != 0;
    cf = 0;
    CGAffineTransform v68 = 0;
    uint64_t v304 = v55 - (v60 >> 3);
    uint64_t v305 = v304;
  }
  else
  {
    if (v65) {
      _ZF = v65 == v67;
    }
    else {
      _ZF = 1;
    }
    int v70 = !_ZF;
    if (v54 || v70)
    {
      if (CopyWithColorSpace)
      {
        uint64_t v72 = *((void *)CopyWithColorSpace + 5);
        uint64_t v73 = *((void *)CopyWithColorSpace + 6);
        uint64_t v74 = *((void *)CopyWithColorSpace + 8);
        unint64_t v75 = *((void *)CopyWithColorSpace + 9);
      }
      else
      {
        uint64_t v74 = 0;
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        unint64_t v75 = 0;
      }
      CGRect v76 = CGDataProviderCopyPixelData((CFIndex *)DataProviderInternal, v72, v73, v74, v75);
      CGRect v77 = CGDataProviderCreateWithCFData(v76);
      if (v76) {
        CFRelease(v76);
      }
      if (CopyWithColorSpace) {
        uint64_t v78 = *((void *)CopyWithColorSpace + 8) * *((void *)CopyWithColorSpace + 5);
      }
      else {
        uint64_t v78 = 0;
      }
      CopyWithCGColorSpaceRef ColorSpace = (CGImage *)copy_image_with_new_provider(CopyWithColorSpace, v77, (unint64_t)(v78 + 7) >> 3);
      CGDataProviderRelease(v77);
      uint64_t v71 = 0;
      cf = CopyWithColorSpace;
    }
    else
    {
      cf = 0;
      uint64_t v71 = v55 - (v60 >> 3);
    }
    BOOL v80 = v65 != v67 && v67 != 0;
    uint64_t v304 = v71;
    if (v64 || v80)
    {
      CGRect v81 = v61;
      if (v57)
      {
        uint64_t v84 = v57[5];
        uint64_t v85 = v57[6];
        uint64_t v86 = v57[8];
        unint64_t v87 = v57[9];
      }
      else
      {
        uint64_t v86 = 0;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        unint64_t v87 = 0;
      }
      unsigned int v82 = v314;
      CGRect v88 = CGDataProviderCopyPixelData(v53, v84, v85, v86, v87);
      CGRect v89 = CGDataProviderCreateWithCFData(v88);
      if (v88) {
        CFRelease(v88);
      }
      if (v57) {
        uint64_t v90 = v57[8] * v57[5];
      }
      else {
        uint64_t v90 = 0;
      }
      CGRect v83 = v317;
      CGAffineTransform v68 = copy_image_with_new_provider((CGImage *)v57, v89, (unint64_t)(v90 + 7) >> 3);
      CGDataProviderRelease(v89);
      BOOL v306 = 0;
      uint64_t v305 = 0;
      CGColorRef v57 = v68;
      goto LABEL_101;
    }
    BOOL v306 = 0;
    CGAffineTransform v68 = 0;
    uint64_t v305 = v67;
  }
  CGRect v81 = v61;
  unsigned int v82 = v314;
  CGRect v83 = v317;
LABEL_101:
  if (CGImageGetAlphaInfo(CopyWithColorSpace)) {
    v12[1064] = 1;
  }
  if (!v312)
  {
    unsigned int v308 = 0;
    goto LABEL_129;
  }
  CGRect v91 = v83;
  CGColorSpaceRef v92 = CGImageGetColorSpace(CopyWithColorSpace);
  int v93 = CGColorSpaceGetType(v92);
  int v97 = v93;
  CGColorSpaceRef v98 = v92;
  if (v93 == 8) {
    goto LABEL_112;
  }
  if (v93 != 7) {
    goto LABEL_128;
  }
  if (v92 && (uint64_t v99 = *((void *)v92 + 3), (*(_DWORD *)(v99 + 28) - 5) <= 1)) {
    CGColorSpaceRef v98 = **(CGColorSpaceRef **)(v99 + 96);
  }
  else {
    CGColorSpaceRef v98 = 0;
  }
  if (CGColorSpaceGetType(v98) == 8)
  {
LABEL_112:
    if (v98)
    {
      uint64_t v100 = *((void *)v98 + 3);
      int v101 = *(_DWORD *)(v100 + 24);
      switch(v101)
      {
        case 6:
          CGRect v102 = (CGColorSpaceRef *)(*(void *)(v100 + 96) + 56);
          goto LABEL_119;
        case 10:
          CGRect v102 = (CGColorSpaceRef *)(*(void *)(v100 + 96) + 48);
          goto LABEL_119;
        case 8:
          CGRect v102 = (CGColorSpaceRef *)(*(void *)(v100 + 96) + 8);
LABEL_119:
          CGColorSpaceRef v98 = *v102;
          goto LABEL_120;
      }
    }
LABEL_128:
    unsigned int v308 = 0;
    CGRect v83 = v91;
    goto LABEL_129;
  }
LABEL_120:
  if (!v98) {
    goto LABEL_128;
  }
  uint64_t v103 = *((void *)v98 + 3);
  if (*(unsigned char *)(v103 + 10))
  {
LABEL_122:
    CGRect v104 = (void *)color_transform_create(v98, 0);
LABEL_123:
    unsigned int v308 = 0;
    goto LABEL_124;
  }
  uint64_t v266 = *(void *)(v103 + 48);
  switch(v266)
  {
    case 1:
      CFStringRef v267 = @"kCGColorSpaceGenericGrayGamma2_2";
      break;
    case 4:
      CFStringRef v267 = @"kCGColorSpaceGenericCMYK";
      break;
    case 3:
      CFStringRef v267 = @"kCGColorSpaceSRGB";
      break;
    default:
      _CGHandleAssert("create_intermediate_color_transform_if_needed", 959, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v94, v95, v96, v303);
  }
  CGColorSpaceRef v98 = CGColorSpaceCreateWithName(v267);
  if (v97 == 8)
  {
    if (v92) {
      unint64_t v310 = *(void *)(*((void *)v92 + 3) + 48);
    }
    else {
      unint64_t v310 = 0;
    }
    uint64_t Names = CGColorSpaceGetNames((uint64_t)v92, v268, v269, v270, v271, v272, v273, v274);
    TintTransforuint64_t m = (void *)CGColorSpaceGetTintTransform((uint64_t)v92, v281, v282, v283, v284, v285, v286, v287);
    uint64_t Colorants = CGColorSpaceGetColorants((uint64_t)v92, v289, v290, v291, v292, v293, v294, v295);
    DeviceN = (CGColorSpace *)CGColorSpaceCreateDeviceN(v310, Names, v98, TintTransform, Colorants, v297, v298, v299);
  }
  else
  {
    if (v97 != 7) {
      goto LABEL_122;
    }
    CFDataRef v275 = CGColorSpaceCopyColorTable((uint64_t)v92);
    if (v92 && (uint64_t v276 = *((void *)v92 + 3), *(_DWORD *)(v276 + 28) == 5)) {
      size_t v277 = *(void *)(*(void *)(v276 + 96) + 8);
    }
    else {
      size_t v277 = -1;
    }
    CFDataRef v278 = v275;
    BytePtr = CFDataGetBytePtr(v275);
    DeviceN = CGColorSpaceCreateIndexed(v98, v277, BytePtr);
    CFRelease(v278);
  }
  CGRect v104 = (void *)color_transform_create(v98, 0);
  if (!DeviceN) {
    goto LABEL_123;
  }
  CopyWithCGColorSpaceRef ColorSpace = CGImageCreateCopyWithColorSpace(CopyWithColorSpace, DeviceN);
  CGColorSpaceRelease(DeviceN);
  unsigned int v308 = (uint64_t *)CopyWithColorSpace;
LABEL_124:
  CGRect v83 = v91;
  if (v104)
  {
    Cache = CGColorTransformGetCache(v104);
    char v113 = 0;
    if (!Cache) {
      goto LABEL_127;
    }
    CGColorSpaceRef v114 = (CGColorSpaceRef)Cache[2];
    if (!v114) {
      goto LABEL_127;
    }
    goto LABEL_130;
  }
LABEL_129:
  CGColorSpaceRef v114 = CGImageGetColorSpace(CopyWithColorSpace);
  CGRect v104 = 0;
  char v113 = 1;
  if (!v114)
  {
LABEL_127:
    uint64_t v115 = 0;
    goto LABEL_131;
  }
LABEL_130:
  uint64_t v115 = *(void *)(*((void *)v114 + 3) + 48);
LABEL_131:
  uint64_t v315 = v115;
  unsigned int v309 = v68;
  if (v82 - 2 > 3) {
    int v116 = 0;
  }
  else {
    int v116 = dword_1850CE100[v82 - 2];
  }
  uint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(v82, v106, v107, v108, v109, v110, v111, v112);
  long long v328 = 0u;
  long long v329 = 0u;
  long long v330 = 0u;
  long long v331 = 0u;
  long long v332 = 0u;
  long long v333 = 0u;
  long long v334 = 0u;
  long long v335 = 0u;
  long long v336 = 0u;
  long long v337 = 0u;
  long long v338 = 0u;
  long long v339 = 0u;
  long long v340 = 0u;
  long long v341 = 0u;
  long long v342 = 0u;
  long long v343 = 0u;
  if ((unint64_t)(BitsPerComponent - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v118, v119, v120, BitsPerComponent);
  }
  *(void *)long long __dst = v82;
  uint64_t v307 = BitsPerComponent;
  *(void *)&__dst[8] = BitsPerComponent;
  *(void *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  memset(&__dst[32], 0, 272);
  uint64_t v121 = CGDataProviderCreateForDestinationWithImage(v104, __dst, v318, v83, CopyWithColorSpace, a6, 1);
  *((void *)v12 + 1) = v121;
  if (!v121)
  {
    if (cf) {
      CFRelease(cf);
    }
    id v142 = v68;
    if (!v68) {
      goto LABEL_179;
    }
    goto LABEL_178;
  }
  memcpy(__dst, v81, 0x130uLL);
  *((void *)v12 + 49) = CGImageGetImageBytesPerRowForPixelInfo((uint64_t)CopyWithColorSpace, v318, (uint64_t)__dst, v122, v123, v124, v125, v126);
  memcpy(__dst, v81, 0x130uLL);
  *((void *)v12 + 50) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v127, v128, v129, v130, v131, v132, v133)
                         * v318
                         + 7) >> 3;
  if (v113)
  {
    CGColorSpaceRef v134 = CGImageGetColorSpace(CopyWithColorSpace);
    goto LABEL_144;
  }
  unsigned int v143 = CGColorTransformGetCache(v104);
  if (v143)
  {
    CGColorSpaceRef v134 = (CGColorSpaceRef)v143[2];
LABEL_144:
    vImagePixelCount v144 = v318;
    *((void *)v12 + 6) = v134;
    if (v134) {
      CFRetain(v134);
    }
    if (v104) {
      goto LABEL_147;
    }
    goto LABEL_148;
  }
  *((void *)v12 + 6) = 0;
  vImagePixelCount v144 = v318;
  if (v104) {
LABEL_147:
  }
    CFRelease(v104);
LABEL_148:
  uint64_t v145 = CGPixelComponentGetBitsPerComponent(v82, v135, v136, v137, v138, v139, v140, v141);
  uint64_t v149 = v145;
  memset(__src, 0, 268);
  if ((unint64_t)(v145 - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v146, v147, v148, v145);
  }
  *(void *)long long __dst = v82;
  *(void *)&__dst[8] = v145;
  *(void *)&__dst[16] = 1;
  *(_DWORD *)&__dst[24] = 0;
  *(_DWORD *)&__dst[28] = v116;
  memset(&__dst[32], 0, 272);
  uint64_t v150 = CGDataProviderCreateForDestinationWithImage(0, __dst, v144, v83, v57, a6, 1);
  *((void *)v12 + 2) = v150;
  if (!v150)
  {
    CGRect v215 = (CGDataProvider *)*((void *)v12 + 1);
LABEL_172:
    CGDataProviderRelease(v215);
    if (cf) {
      CFRelease(cf);
    }
    if (v309) {
      CFRelease(v309);
    }
    if (!v308) {
      goto LABEL_179;
    }
    id v142 = v308;
LABEL_178:
    CFRelease(v142);
LABEL_179:
    free(v12);
    return 0;
  }
  long long v156 = v340;
  long long v157 = v341;
  long long v158 = v341;
  *(_OWORD *)(v12 + 648) = v340;
  *(_OWORD *)(v12 + 664) = v157;
  long long v159 = v342;
  long long v160 = v343;
  long long v161 = v343;
  *(_OWORD *)(v12 + 680) = v342;
  *(_OWORD *)(v12 + 696) = v160;
  long long v162 = v336;
  long long v163 = v337;
  long long v164 = v337;
  *(_OWORD *)(v12 + 584) = v336;
  *(_OWORD *)(v12 + 600) = v163;
  long long v165 = v338;
  long long v166 = v339;
  long long v167 = v339;
  *(_OWORD *)(v12 + 616) = v338;
  *(_OWORD *)(v12 + 632) = v166;
  long long v168 = v332;
  long long v169 = v333;
  long long v170 = v333;
  *(_OWORD *)(v12 + 520) = v332;
  *(_OWORD *)(v12 + 536) = v169;
  long long v171 = v334;
  long long v172 = v335;
  long long v173 = v335;
  *(_OWORD *)(v12 + 552) = v334;
  *(_OWORD *)(v12 + 568) = v172;
  long long v174 = v328;
  long long v175 = v329;
  long long v176 = v329;
  *(_OWORD *)(v12 + 456) = v328;
  *(_OWORD *)(v12 + 472) = v175;
  long long v177 = v330;
  long long v178 = v331;
  long long v179 = v331;
  *(_OWORD *)(v12 + 488) = v330;
  *(_OWORD *)(v12 + 504) = v178;
  *((_OWORD *)v12 + 48) = 0u;
  *((_OWORD *)v12 + 49) = 0u;
  *((_OWORD *)v12 + 50) = 0u;
  *((_OWORD *)v12 + 51) = 0u;
  *((_OWORD *)v12 + 52) = 0u;
  *((_OWORD *)v12 + 53) = 0u;
  *((_OWORD *)v12 + 54) = 0u;
  *((_OWORD *)v12 + 55) = 0u;
  *((_OWORD *)v12 + 56) = 0u;
  *((_OWORD *)v12 + 57) = 0u;
  *((_OWORD *)v12 + 58) = 0u;
  *((_OWORD *)v12 + 59) = 0u;
  *((_OWORD *)v12 + 60) = 0u;
  *((_OWORD *)v12 + 61) = 0u;
  *((_OWORD *)v12 + 62) = 0u;
  *((_OWORD *)v12 + 63) = 0u;
  *((_OWORD *)v12 + 64) = 0u;
  *(_OWORD *)&__dst[240] = v156;
  *(_OWORD *)&__dst[256] = v158;
  *(_OWORD *)&__dst[272] = v159;
  *(_OWORD *)&__dst[288] = v161;
  *(_OWORD *)&__dst[176] = v162;
  *(_OWORD *)&__dst[192] = v164;
  *(_OWORD *)&__dst[208] = v165;
  *(_OWORD *)&__dst[224] = v167;
  *(_OWORD *)&__dst[112] = v168;
  *(_OWORD *)&__dst[128] = v170;
  *(_OWORD *)&__dst[144] = v171;
  *(_OWORD *)&__dst[160] = v173;
  *(_OWORD *)&__dst[48] = v174;
  *(_OWORD *)&__dst[64] = v176;
  *((_DWORD *)v12 + 102) = v82;
  *((_DWORD *)v12 + 103) = 0;
  *((void *)v12 + 52) = v307;
  *((void *)v12 + 53) = v315;
  *((_DWORD *)v12 + 108) = 3;
  *((_DWORD *)v12 + 109) = v116;
  *((void *)v12 + 55) = 0;
  *((void *)v12 + 56) = 0;
  *((_DWORD *)v12 + 184) = v82;
  *((_DWORD *)v12 + 185) = 0;
  *((void *)v12 + 93) = v149;
  *((void *)v12 + 94) = 1;
  *((_DWORD *)v12 + 190) = 0;
  *((_DWORD *)v12 + 191) = v116;
  *(void *)long long __dst = v82;
  *(void *)&__dst[8] = v307;
  *(void *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  *(_OWORD *)&__dst[32] = 0uLL;
  *(_OWORD *)&__dst[80] = v177;
  *(_OWORD *)&__dst[96] = v179;
  *((void *)v12 + 89) = CGImageGetImageBytesPerRowForPixelInfo((uint64_t)CopyWithColorSpace, v144, (uint64_t)__dst, v151, v152, v153, v154, v155);
  *(void *)long long __dst = v82;
  *(void *)&__dst[8] = v307;
  *(void *)&__dst[16] = v315;
  *(_DWORD *)&__dst[24] = 3;
  *(_DWORD *)&__dst[28] = v116;
  *(_OWORD *)&__dst[32] = 0uLL;
  *(_OWORD *)&__dst[240] = v340;
  *(_OWORD *)&__dst[256] = v341;
  *(_OWORD *)&__dst[272] = v342;
  *(_OWORD *)&__dst[288] = v343;
  *(_OWORD *)&__dst[176] = v336;
  *(_OWORD *)&__dst[192] = v337;
  *(_OWORD *)&__dst[208] = v338;
  *(_OWORD *)&__dst[224] = v339;
  *(_OWORD *)&__dst[112] = v332;
  *(_OWORD *)&__dst[128] = v333;
  *(_OWORD *)&__dst[144] = v334;
  *(_OWORD *)&__dst[160] = v335;
  *(_OWORD *)&__dst[48] = v328;
  *(_OWORD *)&__dst[64] = v329;
  *(_OWORD *)&__dst[80] = v330;
  *(_OWORD *)&__dst[96] = v331;
  *((void *)v12 + 90) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v180, v181, v182, v183, v184, v185, v186)
                         * v144
                         + 7) >> 3;
  unint64_t v194 = (CGPixelComponentGetBitsPerComponent(v82, v187, v188, v189, v190, v191, v192, v193) * v144 + 7) >> 3;
  long long v195 = (char *)CGImageGetMask(CopyWithColorSpace);
  if (v195)
  {
    long long v196 = v195;
    CGAffineTransform v197 = CGImageGetDataProviderInternal(v195, 0);
    if (v197)
    {
      if (*((_DWORD *)v197 + 5)) {
        unint64_t v194 = *((void *)v196 + 9)
      }
             + v194
             - ((unint64_t)(*((void *)v196 + 5) * *((void *)v196 + 8) + 7) >> 3);
      goto LABEL_154;
    }
LABEL_223:
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", v50, v51, v52, v303);
  }
LABEL_154:
  if (!v194) {
    _CGHandleAssert("CGImageGetMaskBytesPerRowForPixelInfo", 4053, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "bytes_per_row != 0", "zero rowBytes", v50, v51, v52, v303);
  }
  *((void *)v12 + 130) = v194;
  *(void *)long long __dst = v82;
  *(void *)&__dst[8] = v149;
  *(void *)&__dst[16] = 1;
  *(_DWORD *)&__dst[24] = 0;
  *(_DWORD *)&__dst[28] = v116;
  *(_DWORD *)&__dst[32] = 0;
  memcpy(&__dst[36], __src, 0x10CuLL);
  vImagePixelCount v205 = v318;
  *((void *)v12 + 131) = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v198, v199, v200, v201, v202, v203, v204)
                          * v318
                          + 7) >> 3;
  if (v306)
  {
    uint64_t SequentialWithInternalCallbacks = CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v12, (uint64_t)&sequential_provider_with_softmask_callbacks, v206, v207, v208, v209, v210, v211);
    CGRect v213 = v317;
    if (SequentialWithInternalCallbacks)
    {
      uint64_t v214 = SequentialWithInternalCallbacks;
      CGDataProviderLock(*((void *)v12 + 1));
      CGDataProviderLock(*((void *)v12 + 2));
      goto LABEL_160;
    }
    goto LABEL_171;
  }
  *CGFloat v12 = 1;
  CGRect v213 = v317;
  CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v12, *((void *)v12 + 49) * (void)v317, (uint64_t)&direct_provider_with_softmask_callbacks, v207, v208, v209, v210, v211);
  uint64_t v214 = v216;
  if (!v216)
  {
LABEL_171:
    CGDataProviderRelease(*((CGDataProviderRef *)v12 + 1));
    CGRect v215 = (CGDataProvider *)*((void *)v12 + 2);
    goto LABEL_172;
  }
LABEL_160:
  if (v312)
  {
    CFRetain(v312);
    *((void *)v12 + 3) = v312;
    *((void *)v12 + 4) = CGColorTransformCreateCGCMSConverter(v312, *((void **)v12 + 6), a6);
    unint64_t v224 = *((void *)v12 + 89);
    unint64_t v225 = v224;
    uint64_t v226 = v315;
    uint64_t v227 = v307;
    if (v224) {
      goto LABEL_163;
    }
    *(void *)long long __dst = v82;
    *(void *)&__dst[8] = v307;
    *(void *)&__dst[16] = v315;
    *(_DWORD *)&__dst[24] = 3;
    *(_DWORD *)&__dst[28] = v116;
    *(_OWORD *)&__dst[32] = 0uLL;
    *(_OWORD *)&__dst[240] = v340;
    *(_OWORD *)&__dst[256] = v341;
    *(_OWORD *)&__dst[272] = v342;
    *(_OWORD *)&__dst[288] = v343;
    *(_OWORD *)&__dst[176] = v336;
    *(_OWORD *)&__dst[192] = v337;
    *(_OWORD *)&__dst[208] = v338;
    *(_OWORD *)&__dst[224] = v339;
    *(_OWORD *)&__dst[112] = v332;
    *(_OWORD *)&__dst[128] = v333;
    *(_OWORD *)&__dst[144] = v334;
    *(_OWORD *)&__dst[160] = v335;
    *(_OWORD *)&__dst[48] = v328;
    *(_OWORD *)&__dst[64] = v329;
    *(_OWORD *)&__dst[80] = v330;
    *(_OWORD *)&__dst[96] = v331;
    uint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v217, v218, v219, v220, v221, v222, v223);
    uint64_t v226 = v315;
    unint64_t v224 = (BitsPerPixel * v318 + 7) >> 3;
    unint64_t v225 = *((void *)v12 + 89);
    unint64_t v229 = v318;
    if (v225)
    {
LABEL_163:
      unint64_t v313 = 8 * v225;
      *(void *)long long __dst = v82;
      *(void *)&__dst[8] = v307;
      *(void *)&__dst[16] = v226;
      *(_DWORD *)&__dst[24] = 3;
      *(_DWORD *)&__dst[28] = v116;
      *(_OWORD *)&__dst[32] = 0uLL;
      *(_OWORD *)&__dst[240] = v340;
      *(_OWORD *)&__dst[256] = v341;
      *(_OWORD *)&__dst[272] = v342;
      *(_OWORD *)&__dst[288] = v343;
      *(_OWORD *)&__dst[176] = v336;
      *(_OWORD *)&__dst[192] = v337;
      *(_OWORD *)&__dst[208] = v338;
      *(_OWORD *)&__dst[224] = v339;
      *(_OWORD *)&__dst[112] = v332;
      *(_OWORD *)&__dst[128] = v333;
      *(_OWORD *)&__dst[144] = v334;
      *(_OWORD *)&__dst[160] = v335;
      *(_OWORD *)&__dst[48] = v328;
      *(_OWORD *)&__dst[64] = v329;
      *(_OWORD *)&__dst[80] = v330;
      *(_OWORD *)&__dst[96] = v331;
      uint64_t v230 = v226;
      unint64_t v231 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v217, v218, v219, v220, v221, v222, v223);
      uint64_t v226 = v230;
      uint64_t v227 = v307;
      unint64_t v229 = (v313 / v231 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)long long __dst = 0;
    *(void *)&__dst[8] = v229;
    *(void *)&__dst[16] = 1;
    *(void *)&__dst[24] = v224;
    *(void *)&__dst[32] = a6;
    *(void *)&__dst[40] = v82;
    *(void *)&__dst[48] = v227;
    *(void *)&__dst[56] = v226;
    *(_DWORD *)&__dst[64] = 3;
    *(_DWORD *)&__dst[68] = v116;
    *(void *)&__dst[80] = 0;
    *(void *)&unsigned char __dst[72] = 0;
    *(_OWORD *)&__dst[312] = v342;
    *(_OWORD *)&__dst[328] = v343;
    *(_OWORD *)&__dst[280] = v340;
    *(_OWORD *)&__dst[296] = v341;
    *(_OWORD *)&__dst[264] = v339;
    *(_OWORD *)&__dst[136] = v331;
    *(_OWORD *)&__dst[120] = v330;
    *(_OWORD *)&__dst[104] = v329;
    *(_OWORD *)&__dst[88] = v328;
    *(_OWORD *)&__dst[200] = v335;
    *(_OWORD *)&__dst[184] = v334;
    *(_OWORD *)&__dst[168] = v333;
    *(_OWORD *)&__dst[152] = v332;
    *(_OWORD *)&__dst[248] = v338;
    *(_OWORD *)&__dst[232] = v337;
    *(_OWORD *)&__dst[216] = v336;
    *(void *)&long long v323 = 0;
    *((void *)&v323 + 1) = v229;
    long long v324 = 1uLL;
    *((void *)&v324 + 1) = *((void *)v12 + 49);
    *(void *)&v325[0] = a6;
    int v232 = v81;
    memcpy((char *)v325 + 8, v81, 0x130uLL);
    if (v81[5]) {
      *(void *)&v325[3] = (char *)&v325[3] + 8;
    }
    *(_OWORD *)size = 0u;
    memset(v322, 0, 56);
    long long v320 = 0u;
    CGCMSConverterConvertGetConverterInfo((uint64_t)&v320, *((uint64_t (***)(CFTypeRef, uint64_t, uint64_t))v12 + 4), (uint64_t)__dst, (uint64_t)&v323);
    size_t v233 = size[0];
    *((void *)v12 + 5) = v320;
    vImagePixelCount v205 = v318;
    if (v233 >= 0x401)
    {
      *((void *)v12 + 155) = v233;
      *((void *)v12 + 154) = malloc_type_calloc(1uLL, v233, 0xA3729uLL);
    }
    CGRect v213 = v317;
    if (size[1]) {
      *((void *)v12 + 156) = size[1];
    }
    long long v234 = *(_OWORD *)((char *)&v322[1] + 8);
    *(_OWORD *)(v12 + 1256) = *(_OWORD *)((char *)v322 + 8);
    *(_OWORD *)(v12 + 1272) = v234;
    *(_OWORD *)(v12 + 1288) = *(_OWORD *)((char *)&v322[2] + 8);
  }
  else
  {
    *((void *)v12 + 3) = 0;
    int v232 = v81;
  }
  *((_DWORD *)v12 + 14) = a6;
  memcpy(v12 + 88, v232, 0x130uLL);
  if (v232[5]) {
    *((void *)v12 + 16) = v12 + 136;
  }
  *((void *)v12 + 8) = v205;
  *((void *)v12 + 9) = v213;
  if (cf) {
    CFRelease(cf);
  }
  if (v309) {
    CFRelease(v309);
  }
  if (v308) {
    CFRelease(v308);
  }
  unint64_t v236 = *((void *)v12 + 49);
  unint64_t v237 = *((void *)v12 + 89);
  if (!v237)
  {
    uint64_t v238 = *((void *)v12 + 8);
    memcpy(__dst, v12 + 408, 0x130uLL);
    unint64_t v237 = (unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v239, v240, v241, v242, v243, v244, v245)
                            * v238
                            + 7) >> 3;
  }
  if (v236 > v237) {
    unint64_t v237 = v236;
  }
  size_t v246 = (v304 + v237 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((void *)v12 + 151) = v246;
  *((void *)v12 + 150) = malloc_type_calloc(1uLL, v246, 0xA3729uLL);
  unint64_t v247 = *((void *)v12 + 49);
  unint64_t v248 = *((void *)v12 + 130);
  if (!v248)
  {
    uint64_t v249 = *((void *)v12 + 8);
    memcpy(__dst, v12 + 736, 0x130uLL);
    unint64_t v248 = (unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v250, v251, v252, v253, v254, v255, v256)
                            * v249
                            + 7) >> 3;
  }
  if (v247 > v248) {
    unint64_t v248 = v247;
  }
  size_t v257 = (v305 + v248 + 15) & 0xFFFFFFFFFFFFFFF0;
  *((void *)v12 + 153) = v257;
  uint64_t v258 = malloc_type_calloc(1uLL, v257, 0xA3729uLL);
  *((void *)v12 + 152) = v258;
  if (!*((void *)v12 + 150) || !v258)
  {
    provider_with_softmask_release_info(v12);
    CGPostError((uint64_t)"%s failed", v259, v260, v261, v262, v263, v264, v265, (char)"CGDataProviderCreateWithSoftMaskAndMatte");
    return 0;
  }
  return v214;
}

uint64_t *copy_image_with_new_provider(CGImage *image, CGDataProvider *a2, size_t a3)
{
  if (image)
  {
    size_t v5 = *((void *)image + 5);
    size_t v6 = *((void *)image + 6);
    size_t v7 = *((void *)image + 7);
    size_t v8 = *((void *)image + 8);
  }
  else
  {
    size_t v7 = 0;
    size_t v5 = 0;
    size_t v6 = 0;
    size_t v8 = 0;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(image);
  char decode = CGImageGetDecode(image);
  BOOL shouldInterpolate = CGImageGetShouldInterpolate(image);
  CGColorRenderingIntent intent = CGImageGetRenderingIntent(image);
  CGFloat v14 = (uint64_t *)CGImageCreate(v5, v6, v7, v8, a3, ColorSpace, BitmapInfo, a2, decode, shouldInterpolate, intent);
  CGImageCopyHeadroomFromOriginal(v14, image, v15, v16, v17, v18, v19, v20);
  return v14;
}

void provider_with_softmask_release_info(void *a1)
{
  if (!*(unsigned char *)a1)
  {
    CGDataProviderUnlock(*((void *)a1 + 1));
    CGDataProviderUnlock(*((void *)a1 + 2));
  }
  CGDataProviderRelease(*((CGDataProviderRef *)a1 + 1));
  CGDataProviderRelease(*((CGDataProviderRef *)a1 + 2));
  uint64_t v2 = (const void *)*((void *)a1 + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)a1 + 4);
  if (v3) {
    CFRelease(v3);
  }
  CGColorSpaceRelease(*((CGColorSpaceRef *)a1 + 6));
  uint64_t v4 = (char *)*((void *)a1 + 5);
  if (v4) {
    CGvImageConverterCacheRelease(v4);
  }
  size_t v5 = (void *)*((void *)a1 + 150);
  if (v5) {
    free(v5);
  }
  size_t v6 = (void *)*((void *)a1 + 152);
  if (v6) {
    free(v6);
  }
  size_t v7 = (void *)*((void *)a1 + 154);
  if (v7) {
    free(v7);
  }
  size_t v8 = (void *)*((void *)a1 + 156);
  if (v8) {
    free(v8);
  }
  uint64_t v9 = (vImageConverter *)*((void *)a1 + 157);
  if (v9) {
    vImageConverter_Release(v9);
  }
  pthread_mutexattr_t v10 = (vImageConverter *)*((void *)a1 + 158);
  if (v10) {
    vImageConverter_Release(v10);
  }
  uint64_t v11 = (void *)*((void *)a1 + 159);
  if (v11) {
    free(v11);
  }
  CGFloat v12 = (void *)*((void *)a1 + 160);
  if (v12) {
    free(v12);
  }
  CGImageRef v13 = (void *)*((void *)a1 + 161);
  if (v13) {
    free(v13);
  }
  CGFloat v14 = (void *)*((void *)a1 + 162);
  if (v14) {
    free(v14);
  }

  free(a1);
}

uint64_t provider_with_softmask_get_softmask_work_buffer_size(uint64_t a1)
{
  return *(void *)(a1 + 1224);
}

uint64_t provider_with_softmask_get_image_work_buffer_size(uint64_t a1)
{
  return *(void *)(a1 + 1208);
}

uint64_t provider_with_softmask_get_bytes_per_row_count(uint64_t a1)
{
  return *(void *)(a1 + 392);
}

uint64_t provider_with_softmask_release_data(uint64_t a1)
{
  CGDataProviderReleaseBytePtr(*(void *)(a1 + 8));
  CGDataProviderReleaseBytePtr(*(void *)(a1 + 16));
  CGDataProviderReleaseData(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 16);

  return CGDataProviderReleaseData(v2);
}

uint64_t provider_with_softmask_retain_data(uint64_t a1)
{
  CGDataProviderRetainBytePtr(*(void *)(a1 + 8));
  CGDataProviderRetainBytePtr(*(void *)(a1 + 16));
  CGDataProviderRetainData(*(void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 16);

  return CGDataProviderRetainData(v2);
}

unint64_t provider_with_softmask_get_bytes_at_position(unsigned char *a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*a1) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position", 684, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "info->src_provider_uses_random_access == true", "", a6, a7, a8, vars0);
  }

  return provider_with_softmask_get_bytes_at_position_inner((uint64_t)a1, a2, a3, a4, 0, a6, a7, a8);
}

unint64_t provider_with_softmask_get_bytes_at_position_inner(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 0x8000000000000000) != 0) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 511, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "pos >= 0", "pos = %lld", a6, a7, a8, a3);
  }
  CGImageRef v13 = (void *)(a1 + 88);
  memcpy(__dst, (const void *)(a1 + 88), 0x130uLL);
  unint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v14, v15, v16, v17, v18, v19, v20);
  if ((BitsPerPixel & 7) != 0) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 515, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "((dst_bits_per_pixel >> 3) << 3) == dst_bits_per_pixel", "bpp = %zu", v21, v22, v23, BitsPerPixel);
  }
  memcpy(__dst, (const void *)(a1 + 408), 0x130uLL);
  unint64_t v32 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v25, v26, v27, v28, v29, v30, v31);
  memcpy(__dst, (const void *)(a1 + 736), 0x130uLL);
  unint64_t v40 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v33, v34, v35, v36, v37, v38, v39);
  unint64_t v43 = destination_position_to_source_position(BitsPerPixel, *(void *)(a1 + 392), *(void *)(a1 + 400), v32, *(void *)(a1 + 712), a3, v41, v42);
  unint64_t v46 = destination_position_to_source_position(BitsPerPixel, *(void *)(a1 + 392), *(void *)(a1 + 400), v40, *(void *)(a1 + 1040), a3, v44, v45);
  if ((v43 & 0x8000000000000000) != 0) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 574, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_src_pos >= 0", "position %lld", v47, v48, v49, v43);
  }
  uint64_t v50 = v46;
  unint64_t v55 = byte_count_to_byte_count(BitsPerPixel, *(void *)(a1 + 392), *(void *)(a1 + 400), *(void *)(a1 + 80), v32, *(void *)(a1 + 712), a4, v49);
  if (v55 > *(void *)(a1 + 1208)) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 586, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_bytes_to_read <= info->image_work_buffer_size", "%s: image_bytes_to_read %zd > image_work_buffer_size %zd", v52, v53, v54, (char)"provider_with_softmask_get_bytes_at_position_inner");
  }
  uint64_t v56 = *(void **)(a1 + 8);
  CGColorRef v57 = *(char **)(a1 + 1200);
  if (*(unsigned char *)a1)
  {
    uint64_t v58 = v43;
    size_t v59 = v55;
    size_t BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v56, v57, v58, v55, v51, v52, v53, v54);
  }
  else
  {
    size_t v59 = v55;
    size_t BytesAtPositionInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v56, (uint64_t)v57, v55);
  }
  if (BytesAtPositionInternal > v59) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 594, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_bytes_read <= image_bytes_to_read", "%zu %zu", v61, v62, v63, BytesAtPositionInternal);
  }
  long long v196 = v13;
  unint64_t v64 = 8 * a4 / BitsPerPixel;
  unint64_t v65 = v64;
  size_t v197 = v59;
  if (v59 != BytesAtPositionInternal) {
    unint64_t v65 = 8 * BytesAtPositionInternal / v32;
  }
  unint64_t v201 = v65;
  __uint64_t n = BytesAtPositionInternal;
  unint64_t v70 = byte_count_to_byte_count(BitsPerPixel, *(void *)(a1 + 392), *(void *)(a1 + 400), *(void *)(a1 + 80), v40, *(void *)(a1 + 1040), a4, v63);
  if (v70 > *(void *)(a1 + 1224)) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 608, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_bytes_to_read <= info->smask_work_buffer_size", "%s: smask_bytes_to_read %zd > smask_work_buffer_size %zd", v67, v68, v69, (char)"provider_with_softmask_get_bytes_at_position_inner");
  }
  uint64_t v71 = *(void **)(a1 + 16);
  uint64_t v72 = *(char **)(a1 + 1216);
  if (*(unsigned char *)a1) {
    size_t BytesInternal = CGDataProviderDirectGetBytesAtPositionInternal(v71, v72, v50, v70, v66, v67, v68, v69);
  }
  else {
    size_t BytesInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v71, (uint64_t)v72, v70);
  }
  size_t v77 = BytesInternal;
  unint64_t v78 = v201;
  if (BytesInternal > v70) {
    _CGHandleAssert("provider_with_softmask_get_bytes_at_position_inner", 615, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_bytes_read <= smask_bytes_to_read", "bytes read %zu to read %zu", v74, v75, v76, BytesInternal);
  }
  if (v70 != BytesInternal) {
    unint64_t v64 = 8 * BytesInternal / v40;
  }
  unint64_t result = 0;
  if (v201 && v64 && v201 == v64)
  {
    uint64_t v192 = a2;
    uint64_t v80 = *(void *)(a1 + 1200);
    uint64_t v81 = *(void *)(a1 + 1216);
    uint64_t v82 = *(void *)(a1 + 424);
    uint64_t v199 = v82;
    uint64_t v200 = v81;
    int v195 = a5;
    unint64_t v193 = BitsPerPixel;
    unint64_t v194 = a4;
    size_t v191 = v77;
    switch(*(_DWORD *)(a1 + 408))
    {
      case 1:
        int v83 = *(unsigned __int8 *)(a1 + 1065);
        uint64_t v84 = (unsigned __int8 *)(a1 + 1072);
        if (!*(unsigned char *)(a1 + 1065)) {
          uint64_t v84 = 0;
        }
        uint64_t v85 = v82 + 1;
        if (*(unsigned char *)(a1 + 1064))
        {
          uint64_t v86 = 0;
          uint64_t v87 = 0;
          uint64_t v88 = *(void *)(a1 + 424);
          do
          {
            uint64_t v89 = *(unsigned __int8 *)(v81 + v87);
            if (v83)
            {
              if (v82)
              {
                uint64_t v90 = (unsigned char *)(v80 + v86);
                unsigned __int16 v91 = inverted_8bit_alpha[v89];
                CGColorSpaceRef v92 = v84;
                uint64_t v93 = v82;
                do
                {
                  __int16 v94 = *v92++;
                  *uint64_t v90 = v94 + ((unsigned __int16)((*v90 - v94) * v91) >> 8);
                  ++v90;
                  --v93;
                }
                while (v93);
              }
              v86 += v85;
            }
            if (v89) {
              LODWORD(v89) = (*(unsigned __int8 *)(v80 + v88) * v89
            }
                            + ((*(unsigned __int8 *)(v80 + v88) * v89) >> 8)
                            + 1) >> 8;
            *(unsigned char *)(v80 + v88) = v89;
            v88 += v85;
            ++v87;
          }
          while (v87 != v201);
        }
        else
        {
          uint64_t v160 = 0;
          uint64_t v161 = 0;
          uint64_t v162 = *(void *)(a1 + 424);
          do
          {
            uint64_t v163 = *(unsigned __int8 *)(v81 + v161);
            if (v83)
            {
              if (v82)
              {
                long long v164 = (unsigned char *)(v80 + v160);
                unsigned __int16 v165 = inverted_8bit_alpha[v163];
                long long v166 = v84;
                uint64_t v167 = v82;
                do
                {
                  __int16 v168 = *v166++;
                  *long long v164 = v168 + ((unsigned __int16)((*v164 - v168) * v165) >> 8);
                  ++v164;
                  --v167;
                }
                while (v167);
              }
              v160 += v85;
            }
            *(unsigned char *)(v80 + v162) = v163;
            v162 += v85;
            ++v161;
          }
          while (v161 != v201);
        }
        break;
      case 2:
        int v147 = *(unsigned __int8 *)(a1 + 1065);
        if (*(unsigned char *)(a1 + 1065)) {
          uint64_t v148 = (unsigned __int16 *)(a1 + 1072);
        }
        else {
          uint64_t v148 = 0;
        }
        uint64_t v149 = v82 + 1;
        __leuint64_t n = 2 * v82;
        if (*(unsigned char *)(a1 + 1064))
        {
          uint64_t v150 = 0;
          uint64_t v151 = 0;
          uint64_t v152 = *(void *)(a1 + 424);
          do
          {
            unsigned int v153 = *(unsigned __int16 *)(v81 + 2 * v151);
            if (v147)
            {
              uint64_t v154 = (_WORD *)(v80 + 2 * v150);
              if (*(_WORD *)(v81 + 2 * v151))
              {
                if (v82)
                {
                  uint64_t v155 = v148;
                  uint64_t v156 = v82;
                  do
                  {
                    int v157 = *v155++;
                    *uint64_t v154 = v157 + ((((unsigned __int16)*v154 - v157) * (0xFFFFFFFF / v153)) >> 16);
                    ++v154;
                    --v156;
                  }
                  while (v156);
                }
              }
              else if (v82)
              {
                memset(v154, 255, __len);
                uint64_t v82 = v199;
                uint64_t v81 = v200;
                unint64_t v78 = v201;
              }
              v150 += v149;
            }
            if (v153)
            {
              unsigned int v158 = *(unsigned __int16 *)(v80 + 2 * v152) * v153;
              unsigned int v159 = (v158 + HIWORD(v158) + 1) >> 16;
            }
            else
            {
              LOWORD(v159) = 0;
            }
            *(_WORD *)(v80 + 2 * v152) = v159;
            v152 += v149;
            ++v151;
          }
          while (v151 != v78);
        }
        else
        {
          uint64_t v169 = 0;
          uint64_t v170 = 0;
          uint64_t v171 = *(void *)(a1 + 424);
          long long v172 = v148;
          do
          {
            unsigned int v173 = *(unsigned __int16 *)(v81 + 2 * v170);
            if (v147)
            {
              long long v174 = (_WORD *)(v80 + 2 * v169);
              if (*(_WORD *)(v81 + 2 * v170))
              {
                if (v82)
                {
                  long long v175 = v172;
                  uint64_t v176 = v82;
                  do
                  {
                    int v177 = *v175++;
                    *long long v174 = v177 + ((((unsigned __int16)*v174 - v177) * (0xFFFFFFFF / v173)) >> 16);
                    ++v174;
                    --v176;
                  }
                  while (v176);
                }
              }
              else if (v82)
              {
                memset(v174, 255, __len);
                uint64_t v82 = v199;
                uint64_t v81 = v200;
                unint64_t v78 = v201;
              }
              v169 += v149;
            }
            *(_WORD *)(v80 + 2 * v171) = v173;
            v171 += v149;
            ++v170;
          }
          while (v170 != v78);
        }
        break;
      case 4:
        uint64_t v95 = v82 + 1;
        size_t v96 = 4 * v82;
        uint64_t v97 = 0;
        uint64_t v98 = 0;
        uint64_t v99 = 4 * v82 + 4;
        uint64_t v100 = *(float **)(a1 + 1200);
        uint64_t v101 = *(void *)(a1 + 424);
        if (*(unsigned char *)(a1 + 1064))
        {
          do
          {
            float v102 = *(float *)(v81 + 4 * v98);
            if (v102 == 0.0)
            {
              if (v82)
              {
                memset_pattern16((void *)(v80 + 4 * v97), &unk_1850CE0F0, v96);
                uint64_t v82 = v199;
                uint64_t v81 = v200;
                unint64_t v78 = v201;
              }
            }
            else if (v82)
            {
              uint64_t v103 = v100;
              CGRect v104 = (float *)(a1 + 1072);
              uint64_t v105 = v82;
              do
              {
                float v106 = *v104++;
                *uint64_t v103 = v106 + (float)((float)(1.0 / v102) * (float)(*v103 - v106));
                ++v103;
                --v105;
              }
              while (v105);
            }
            v97 += v95;
            *(float *)(v80 + 4 * v101) = v102 * *(float *)(v80 + 4 * v101);
            v101 += v95;
            ++v98;
            uint64_t v100 = (float *)((char *)v100 + v99);
          }
          while (v98 != v78);
        }
        else
        {
          do
          {
            float v107 = *(float *)(v81 + 4 * v98);
            if (v107 == 0.0)
            {
              if (v82)
              {
                memset_pattern16((void *)(v80 + 4 * v97), &unk_1850CE0F0, v96);
                uint64_t v82 = v199;
                uint64_t v81 = v200;
                unint64_t v78 = v201;
              }
            }
            else if (v82)
            {
              uint64_t v108 = v100;
              uint64_t v109 = (float *)(a1 + 1072);
              uint64_t v110 = v82;
              do
              {
                float v111 = *v109++;
                *uint64_t v108 = v111 + (float)((float)(1.0 / v107) * (float)(*v108 - v111));
                ++v108;
                --v110;
              }
              while (v110);
            }
            v97 += v95;
            *(float *)(v80 + 4 * v101) = v107;
            v101 += v95;
            ++v98;
            uint64_t v100 = (float *)((char *)v100 + v99);
          }
          while (v98 != v78);
        }
        break;
      case 5:
        int v112 = *(unsigned __int8 *)(a1 + 1065);
        if (*(unsigned char *)(a1 + 1065)) {
          char v113 = (__int16 *)(a1 + 1072);
        }
        else {
          char v113 = 0;
        }
        uint64_t v114 = v82 + 1;
        size_t v115 = 2 * v82;
        uint64_t v116 = 0;
        uint64_t v117 = 0;
        uint64_t v118 = *(void *)(a1 + 424);
        if (*(unsigned char *)(a1 + 1064))
        {
          do
          {
            _H9 = *(short float *)(v81 + 2 * v117);
            if (v112)
            {
              uint64_t v120 = (__int16 *)(v80 + 2 * v116);
              __asm { FCMP            H9, #0 }
              if (_ZF)
              {
                if (v82)
                {
                  memset_pattern16(v120, &unk_1850CE0E0, v115);
                  uint64_t v82 = v199;
                  uint64_t v81 = v200;
                  unint64_t v78 = v201;
                }
              }
              else if (v82)
              {
                __asm { FCVT            S0, H9 }
                uint64_t v126 = v113;
                uint64_t v127 = v82;
                float v128 = 1.0 / _S0;
                do
                {
                  _H1 = *v120;
                  __asm { FCVT            S1, H1 }
                  __int16 v131 = *v126++;
                  _H2 = v131;
                  __asm { FCVT            S2, H2 }
                  _S1 = (float)(v128 * (float)(_S1 - _S2)) + _S2;
                  __asm { FCVT            H1, S1 }
                  *v120++ = LOWORD(_S1);
                  --v127;
                }
                while (v127);
              }
              v116 += v114;
            }
            *(short float *)(v80 + 2 * v118) = _H9 * *(short float *)(v80 + 2 * v118);
            v118 += v114;
            ++v117;
          }
          while (v117 != v78);
        }
        else
        {
          do
          {
            _H9 = *(_WORD *)(v81 + 2 * v117);
            if (v112)
            {
              uint64_t v136 = (__int16 *)(v80 + 2 * v116);
              __asm { FCMP            H9, #0 }
              if (_ZF)
              {
                if (v82)
                {
                  memset_pattern16(v136, &unk_1850CE0E0, v115);
                  uint64_t v82 = v199;
                  uint64_t v81 = v200;
                  unint64_t v78 = v201;
                }
              }
              else if (v82)
              {
                __asm { FCVT            S0, H9 }
                uint64_t v138 = v113;
                uint64_t v139 = v82;
                float v140 = 1.0 / _S0;
                do
                {
                  _H1 = *v136;
                  __asm { FCVT            S1, H1 }
                  __int16 v143 = *v138++;
                  _H2 = v143;
                  __asm { FCVT            S2, H2 }
                  _S1 = (float)(v140 * (float)(_S1 - _S2)) + _S2;
                  __asm { FCVT            H1, S1 }
                  *v136++ = LOWORD(_S1);
                  --v139;
                }
                while (v139);
              }
              v116 += v114;
            }
            *(_WORD *)(v80 + 2 * v118) = _H9;
            v118 += v114;
            ++v117;
          }
          while (v117 != v78);
        }
        break;
      default:
        _CGHandleAssert("merge_mask_to_image", 500, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", v81, v82, v76, v189);
    }
    long long v178 = *(void **)(a1 + 24);
    if (v178)
    {
      long long v179 = *(_OWORD *)(a1 + 1272);
      long long v212 = *(_OWORD *)(a1 + 1256);
      uint64_t v180 = *(unsigned int *)(a1 + 56);
      uint64_t v181 = *(void *)(a1 + 1200);
      uint64_t v183 = *(void **)(a1 + 32);
      unint64_t v182 = *(void *)(a1 + 40);
      uint64_t v184 = *(void *)(a1 + 1248);
      long long v213 = v179;
      long long v214 = *(_OWORD *)(a1 + 1288);
      uint64_t v185 = *(void **)(a1 + 48);
      long long v208 = v182;
      uint64_t v209 = 0;
      uint64_t v210 = v184;
      uint64_t v211 = 0;
      *(void *)long long __dst = v181;
      *(void *)&__dst[8] = v78;
      *(_OWORD *)&__dst[16] = xmmword_1850CDD00;
      *(_DWORD *)&__dst[32] = v180;
      *(_DWORD *)&__dst[36] = 0;
      memcpy(&__dst[40], (const void *)(a1 + 408), 0x130uLL);
      v202[0] = v192;
      v202[1] = v201;
      long long v203 = xmmword_1850CDD00;
      int v204 = v180;
      int v205 = 0;
      memcpy(v206, v196, sizeof(v206));
      CGColorTransformConvertUsingCMSConverter(v178, v185, v180, v183, &v208, (uint64_t)__dst, (uint64_t)v202);
      unint64_t v78 = v201;
      unint64_t v187 = v193;
      unint64_t v186 = v194;
    }
    else
    {
      unint64_t v187 = v193;
      unint64_t v186 = v194;
      size_t v188 = __n;
      if (!__n)
      {
LABEL_123:
        if (v197 == v188) {
          unint64_t result = v186;
        }
        else {
          unint64_t result = (v78 * v187 + 7) >> 3;
        }
        if (v195)
        {
          *(void *)(a1 + 728) += v188;
          *(void *)(a1 + 1056) += v191;
          *(void *)(a1 + 80) += result;
        }
        return result;
      }
      memcpy(v192, *(const void **)(a1 + 1200), __n);
      unint64_t v78 = v201;
    }
    size_t v188 = __n;
    goto LABEL_123;
  }
  return result;
}

uint64_t provider_with_softmask_unlock(uint64_t a1)
{
  int v2 = CGDataProviderUnlock(*(void *)(a1 + 8));
  return CGDataProviderUnlock(*(void *)(a1 + 16)) + v2;
}

uint64_t provider_with_softmask_lock(uint64_t a1)
{
  int v2 = CGDataProviderLock(*(void *)(a1 + 8));
  return CGDataProviderLock(*(void *)(a1 + 16)) + v2;
}

void provider_with_softmask_rewind(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[1];
  if (!v9 || (uint64_t v10 = a1[2]) == 0) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, v23);
  }
  int v11 = *(_DWORD *)(v9 + 20);
  if (v11 != *(_DWORD *)(v10 + 20))
  {
    char Type = CGDataProviderGetType(v9, a2, a3, a4, a5, a6, a7, a8);
    CGDataProviderGetType(v10, v13, v14, v15, v16, v17, v18, v19);
    _CGHandleAssert("provider_with_softmask_rewind", 783, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "CGDataProviderGetType(image_provider) == CGDataProviderGetType(smask_provider)", "image type %d  mask type %d", v20, v21, v22, Type);
  }
  if ((v11 | 2) != 3) {
    _CGHandleAssert("provider_with_softmask_rewind", 793, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "", "Unimplemented", a6, a7, a8, v23);
  }
  CGDataProviderRewind(v9);
  CGDataProviderRewind(v10);
  a1[10] = 0;
  a1[132] = 0;
  a1[91] = 0;
}

unint64_t provider_with_softmask_skip_forward(void *a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  memcpy(__dst, a1 + 11, sizeof(__dst));
  uint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v6, v7, v8, v9, v10, v11, v12);
  memcpy(__dst, a1 + 51, sizeof(__dst));
  uint64_t v21 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v14, v15, v16, v17, v18, v19, v20);
  memcpy(__dst, a1 + 92, sizeof(__dst));
  uint64_t v29 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v22, v23, v24, v25, v26, v27, v28);
  if ((a2 & 0x8000000000000000) != 0) {
    _CGHandleAssert("provider_with_softmask_skip_forward", 709, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "count >= 0", "count: %lld", v30, v31, v32, a2);
  }
  uint64_t v33 = v29;
  unint64_t v34 = byte_count_to_byte_count(BitsPerPixel, a1[49], a1[50], a1[10], v21, a1[89], a2, v32);
  uint64_t v38 = CGDataProviderSkipForwardInternal(v5, v34);
  if (v38 < 0) {
    _CGHandleAssert("provider_with_softmask_skip_forward", 723, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "image_skipped >= 0", "skipped %lld", v35, v36, v37, v38);
  }
  unint64_t v39 = byte_count_to_byte_count(BitsPerPixel, a1[49], a1[50], a1[10], v33, a1[130], a2, v37);
  uint64_t v43 = CGDataProviderSkipForwardInternal(v4, v39);
  if (v43 < 0) {
    _CGHandleAssert("provider_with_softmask_skip_forward", 738, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "smask_skipped >= 0", "smask_skipped %lld", v40, v41, v42, v43);
  }
  if (v38 != v34) {
    a2 = byte_count_to_byte_count(v21, a1[89], a1[90], a1[91], BitsPerPixel, a1[49], v38, v42);
  }
  a1[91] += v38;
  a1[132] += v43;
  a1[10] += a2;
  return a2;
}

unint64_t provider_with_softmask_get_bytes(unsigned char *a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1) {
    _CGHandleAssert("provider_with_softmask_get_bytes", 692, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithSoftmaskAndMatte.c", "info->src_provider_uses_random_access == false", "", a6, a7, a8, vars0);
  }

  return provider_with_softmask_get_bytes_at_position_inner((uint64_t)a1, a2, 0, a3, 1, a6, a7, a8);
}

void *PDFFormSetCreate(uint64_t a1)
{
  int v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2) {
    *int v2 = a1;
  }
  return v2;
}

uint64_t formHash(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) > 1u) {
    return 0;
  }
  else {
    return *(unsigned int *)(a1 + 32);
  }
}

BOOL formEqual(uint64_t a1, uint64_t a2)
{
  BOOL result = 1;
  if (a1 != a2)
  {
    unsigned int v2 = *(_DWORD *)(a1 + 24);
    if (v2 != *(_DWORD *)(a2 + 24) || v2 > 1 || *(void *)(a1 + 32) != *(void *)(a2 + 32)) {
      return 0;
    }
  }
  return result;
}

void formRelease(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

_DWORD *formRetain(uint64_t a1, _DWORD *a2)
{
  BOOL result = a2;
  if (a2) {
    ++*a2;
  }
  return result;
}

unsigned char *emitFormDefinition(unsigned char *result, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!result[56])
  {
    uint64_t v9 = result;
    int v10 = *((_DWORD *)result + 6);
    if (v10 == 1)
    {
      uint64_t v43 = *((void *)result + 4);
      if (!v43) {
        goto LABEL_2;
      }
      uint64_t v44 = *((void *)result + 1);
      uint64_t v12 = *((void *)result + 2);
      PDFContentStreamBegin(v12, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v229);
      PDFDocumentPrintf(v44, (uint64_t)"/Type /XObject", v45, v46, v47, v48, v49, v50, v233);
      PDFDocumentPrintf(v44, (uint64_t)"/Subtype /Form", v51, v52, v53, v54, v55, v56, v234);
      PDFDocumentPrintf(v44, (uint64_t)"/FormType 1", v57, v58, v59, v60, v61, v62, v235);
      if (v12) {
        uint64_t v68 = *(void *)(v12 + 112);
      }
      else {
        uint64_t v68 = 0;
      }
      PDFDocumentPrintReference(v44, (uint64_t)"/Resources %R", *(void *)(v68 + 16), v63, v64, v65, v66, v67);
      CGSize v78 = *(CGSize *)(v43 + 88);
      v252.origiuint64_t n = *(CGPoint *)(v43 + 72);
      v252.size = v78;
      PDFDocumentPrintf(v44, (uint64_t)"/BBox %r", v79, v80, v81, v82, v83, v84, (uint64_t)&v252);
      float64x2_t v91 = *(float64x2_t *)(v43 + 24);
      long long v92 = *(_OWORD *)(v43 + 56);
      float64x2_t v254 = *(float64x2_t *)(v43 + 40);
      long long v255 = v92;
      float64x2_t v253 = v91;
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v91, (float64x2_t)xmmword_1850CD830), (int32x4_t)vceqq_f64(v254, (float64x2_t)xmmword_1850CD8C0))))) & 1) != 0|| *(double *)&v255 != 0.0|| *((double *)&v255 + 1) != 0.0)
      {
        PDFDocumentPrintf(v44, (uint64_t)"/Matrix %m", v85, v86, v87, v88, v89, v90, (uint64_t)&v253);
      }
      PDFDocumentPrintf(v44, (uint64_t)"/Group <<", v85, v86, v87, v88, v89, v90, v237);
      PDFDocumentPrintf(v44, (uint64_t)"/S /Transparency ", v93, v94, v95, v96, v97, v98, v238);
      unint64_t v106 = *(void *)(v43 + 104);
      if (v106)
      {
        if ((v106 & 0x8000000000000000) != 0) {
          CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v106, v99, v100, v101, v102, v103, v104, v105);
        }
        else {
          CGColorSpaceRef ColorSpace = *(CGColorSpace **)(v106 + 24);
        }
        uint64_t v123 = PDFDocumentResolveColorSpace(v44, ColorSpace);
        uint64_t v124 = PDFDocumentAddColorSpace(v44, v123);
        PDFDocumentPrintf(v44, (uint64_t)"/CS", v125, v126, v127, v128, v129, v130, v239);
        PDFColorSpaceEmitReference(v124, v131, v132, v133, v134, v135, v136, v137);
      }
      else
      {
        PDFDocumentPrintf(v44, (uint64_t)"/CS /DeviceGray", v100, v101, v102, v103, v104, v105, v239);
      }
      PDFDocumentPrintf(v44, (uint64_t)"/I true", v117, v118, v119, v120, v121, v122, v240);
      PDFDocumentPrintf(v44, (uint64_t)"/K false", v138, v139, v140, v141, v142, v143, v241);
      PDFDocumentPrintf(v44, (uint64_t)">>", v144, v145, v146, v147, v148, v149, v242);
      PDFContentStreamBeginData((uint64_t *)v12, v150, v151, v152, v153, v154, v155, v156, v243);
      PDFDocumentPushContentStream(v44, (void *)v12);
      CGSoftMaskDelegateDrawSoftMask(*(const void **)(v44 + 16), 0, 0, v43, v157, v158, v159, v160);
      uint64_t v161 = v44;
      goto LABEL_50;
    }
    if (v10) {
      goto LABEL_2;
    }
    uint64_t v11 = (void *)*((void *)result + 4);
    if (!v11) {
      goto LABEL_2;
    }
    uint64_t v13 = *((void *)result + 1);
    uint64_t v12 = *((void *)result + 2);
    PDFContentStreamBegin(v12, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v229);
    PDFDocumentPrintf(v13, (uint64_t)"/Type /XObject", v14, v15, v16, v17, v18, v19, v230);
    PDFDocumentPrintf(v13, (uint64_t)"/Subtype /Form", v20, v21, v22, v23, v24, v25, v231);
    PDFDocumentPrintf(v13, (uint64_t)"/FormType 1", v26, v27, v28, v29, v30, v31, v232);
    if (*((void *)v9 + 10) != -1) {
      PDFDocumentPrintf(v13, (uint64_t)"/StructParent %d", v32, v33, v34, v35, v36, v37, *((void *)v9 + 10));
    }
    memset(&v252, 0, sizeof(v252));
    CGColorSpaceRef space = 0;
    CFDictionaryRef v38 = (const __CFDictionary *)v11[4];
    if (v11[74] == v11[75])
    {
      unint64_t v39 = &CGRectNull;
      p_CGFloat height = &CGRectNull.size.height;
      p_double y = &CGRectNull.origin.y;
      p_size = &CGRectNull.size;
    }
    else
    {
      unint64_t v39 = (const CGRect *)(v11 + 11);
      p_double y = (CGFloat *)(v11 + 12);
      p_size = (CGSize *)(v11 + 13);
      p_CGFloat height = (CGFloat *)(v11 + 14);
    }
    CGFloat v69 = *p_height;
    CGFloat x = v39->origin.x;
    CGFloat v71 = *p_y;
    CGFloat width = p_size->width;
    v251.origin.CGFloat x = v39->origin.x;
    v251.origin.double y = v71;
    v251.size.CGFloat width = width;
    v251.size.CGFloat height = v69;
    if (v38 && CGCFDictionaryGetRect(v38, @"kCGContextBoundingBox", (UInt8 *)&v252))
    {
      v256.origin.CGFloat x = x;
      v256.origin.double y = v71;
      v256.size.CGFloat width = width;
      v256.size.CGFloat height = v69;
      CGRect v251 = CGRectIntersection(v256, v252);
    }
    PDFDocumentPrintf(v13, (uint64_t)"/BBox %r", v32, v33, v34, v35, v36, v37, (uint64_t)&v251);
    if (v12) {
      uint64_t v68 = *(void *)(v12 + 112);
    }
    else {
      uint64_t v68 = 0;
    }
    PDFDocumentPrintReference(v13, (uint64_t)"/Resources %R", *(void *)(v68 + 16), v73, v74, v75, v76, v77);
    if (!v38
      || !CFDictionaryGetValue(v38, @"kCGContextGroup")
      && !CFDictionaryGetValue(v38, @"kCGContextColorSpace"))
    {
LABEL_47:
      PDFContentStreamBeginData((uint64_t *)v12, v108, v109, v110, v111, v112, v113, v114, v236);
      double v206 = *((double *)v9 + 8);
      double v207 = *((double *)v9 + 9);
      if (v206 > 0.0 || v207 > 0.0)
      {
        float64x2_t v253 = (float64x2_t)0x3FF0000000000000uLL;
        v254.f64[0] = 0.0;
        v254.f64[1] = 1.0;
        *(double *)&long long v255 = v206;
        *((double *)&v255 + 1) = v207;
        if (v12)
        {
          PDFWriterPrintf(*(unsigned char ***)(v12 + 64), (uint64_t)"%*m cm q", v200, v201, v202, v203, v204, v205, (uint64_t)&v253);
          PDFDocumentPushContentStream(v13, (void *)v12);
          CGDisplayListDrawInContextDelegate((uint64_t)v11, *(void *)(v13 + 16), 0, 0, 0);
          PDFDocumentPopContentStream(v13);
          uint64_t v221 = *(unsigned char ***)(v12 + 64);
        }
        else
        {
          PDFWriterPrintf(0, (uint64_t)"%*m cm q", v200, v201, v202, v203, v204, v205, (uint64_t)&v253);
          PDFDocumentPushContentStream(v13, 0);
          CGDisplayListDrawInContextDelegate((uint64_t)v11, *(void *)(v13 + 16), 0, 0, 0);
          PDFDocumentPopContentStream(v13);
          uint64_t v221 = 0;
        }
        PDFWriterPrintf(v221, (uint64_t)"Q", v215, v216, v217, v218, v219, v220, v249);
        goto LABEL_55;
      }
      PDFDocumentPushContentStream(v13, (void *)v12);
      CGDisplayListDrawInContextDelegate((uint64_t)v11, *(void *)(v13 + 16), 0, 0, 0);
      uint64_t v161 = v13;
LABEL_50:
      PDFDocumentPopContentStream(v161);
LABEL_55:
      PDFContentStreamEndData(v12, v208, v209, v210, v211, v212, v213, v214);
      PDFContentStreamEnd((CFDataRef *)v12);
      BOOL result = PDFResourceSetEmit(v68, v222, v223, v224, v225, v226, v227, v228);
      v9[56] = 1;
      goto LABEL_2;
    }
    int v115 = *(_DWORD *)(v13 + 4);
    if (v115 <= 0)
    {
      *(_DWORD *)(v13 + 4) = 1;
      uint64_t v116 = (_DWORD *)(v13 + 8);
    }
    else
    {
      if (v115 != 1) {
        goto LABEL_41;
      }
      uint64_t v116 = (_DWORD *)(v13 + 8);
      if (*(int *)(v13 + 8) > 3) {
        goto LABEL_41;
      }
    }
    *uint64_t v116 = 4;
LABEL_41:
    PDFDocumentPrintf(v13, (uint64_t)"/Group <<", v109, v110, v111, v112, v113, v114, v236);
    PDFDocumentPrintf(v13, (uint64_t)"/S /Transparency", v162, v163, v164, v165, v166, v167, v244);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (CGCFDictionaryGetCFTypeRef(v38, @"kCGContextColorSpace", CGColorSpaceGetTypeID_type_id, (uint64_t *)&space))
    {
      CGColorSpaceRef space = PDFDocumentResolveColorSpace(v13, space);
      long long v174 = PDFDocumentAddColorSpace(v13, space);
    }
    else
    {
      CGColorSpaceRef space = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericRGB");
      long long v174 = PDFDocumentAddColorSpace(v13, space);
      CGColorSpaceRelease(space);
    }
    PDFDocumentPrintf(v13, (uint64_t)"/CS", v168, v169, v170, v171, v172, v173, v245);
    PDFColorSpaceEmitReference(v174, v175, v176, v177, v178, v179, v180, v181);
    PDFDocumentPrintf(v13, (uint64_t)"/I true", v182, v183, v184, v185, v186, v187, v246);
    PDFDocumentPrintf(v13, (uint64_t)"/K false", v188, v189, v190, v191, v192, v193, v247);
    PDFDocumentPrintf(v13, (uint64_t)">>", v194, v195, v196, v197, v198, v199, v248);
    goto LABEL_47;
  }
LABEL_2:
  *a2 = 1;
  return result;
}

const void *CGPropertiesCopyProperty(uint64_t a1, const void *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  uint64_t v6 = Value;
  if (Value) {
    CFRetain(Value);
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

void CGPropertiesRemoveProperty(uint64_t a1, const void *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 8), a2);

  os_unfair_lock_unlock(v4);
}

double CGSBoundingShapeCreate()
{
  uint64_t v0 = (char *)malloc_type_malloc(0x200uLL, 0x705560E0uLL);
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_OWORD *)(v0 + 136) = 0u;
  *(_OWORD *)(v0 + 152) = 0u;
  *(_OWORD *)(v0 + 168) = 0u;
  *(_OWORD *)(v0 + 184) = 0u;
  *(_OWORD *)(v0 + 200) = 0u;
  *(_OWORD *)(v0 + 216) = 0u;
  *(_OWORD *)(v0 + 232) = 0u;
  *(_OWORD *)(v0 + 248) = 0u;
  *((void *)v0 + 33) = 0;
  *(void *)&double result = 8;
  *(void *)uint64_t v0 = 8;
  *((void *)v0 + 2) = v0 + 32;
  *((void *)v0 + 3) = v0 + 160;
  return result;
}

uint64_t CGSBoundingShapeRelease(void *a1)
{
  if (a1) {
    free(a1);
  }
  return 0;
}

uint64_t CGSBoundingShapeReset(int *a1)
{
  if (a1)
  {
    uint64_t v1 = *a1;
    a1[1] = 0;
    a1[2] = 0;
    bzero(a1 + 8, ((2 * v1 * (v1 - 1)) & 0xFFFFFFFFFFFFFFFCLL) + 16 * v1);
  }
  return 0;
}

unsigned int *CGSBoundingShapeAdd(unsigned int *result, unsigned int a2, unsigned int a3, int a4, int a5)
{
  if (result && a4 && a5)
  {
    unsigned int v5 = a4 + a2;
    if (a4 >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = v5;
    }
    if (a4 >= 0) {
      uint64_t v7 = v5;
    }
    else {
      uint64_t v7 = a2;
    }
    unsigned int v8 = a5 + a3;
    if (a5 >= 0) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = v8;
    }
    if (a5 >= 0) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = a3;
    }
    return (unsigned int *)shape_accum_add(result, v6, v9, v7, v10);
  }
  return result;
}

uint64_t CGSBoundingShapeAddRect(unsigned int *a1, double *a2)
{
  if (a1)
  {
    if (a2)
    {
      double v3 = *a2;
      double v4 = a2[1];
      double v5 = a2[2];
      double v6 = a2[3];
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      if ((rect_to_bounds_18558((signed int *)&v9 + 1, (signed int *)&v9, (signed int *)&v8 + 1, (signed int *)&v8, v3, v4, v5, v6) & 0x80000000) == 0)shape_accum_add(a1, HIDWORD(v9), v9, HIDWORD(v8), v8); {
    }
      }
  }
  return 0;
}

uint64_t CGSBoundingShapeAddRegion(unsigned int *a1, void *cf)
{
  if (a1)
  {
    if (region_check(cf))
    {
      double v4 = (unsigned int *)cf[2];
      if (v4 != (unsigned int *)&the_empty_shape && v4[v4[1]] != 0x7FFFFFFF && v4 && (int)*a1 >= 3)
      {
        uint64_t v5 = v4[1];
        BOOL v6 = *v4 != 0x80000000 || (int)v5 < 1;
        if (!v6 && v4[v5] != 0x7FFFFFFF)
        {
          uint64_t v8 = 0x80000000;
          while (1)
          {
            uint64_t v9 = v4;
            uint64_t v10 = (int)v4[1];
            v4 += v10;
            uint64_t v11 = *v4;
            if ((int)v10 >= 3) {
              break;
            }
LABEL_19:
            uint64_t v8 = v11;
            if (v11 == 0x7FFFFFFF) {
              return 0;
            }
          }
          uint64_t v12 = v9 + 2;
          while ((shape_accum_add(a1, *v12, v8, v12[1], v11) & 0x80000000) == 0)
          {
            v12 += 2;
            if (v12 >= v4)
            {
              uint64_t v11 = *v4;
              goto LABEL_19;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t CGSBoundingShapeAddRegionWithScale(uint64_t result, void *cf, double a3)
{
  if (result)
  {
    uint64_t v5 = (unsigned int *)result;
    double result = (uint64_t)region_check(cf);
    if (result)
    {
      BOOL v6 = (unsigned int *)cf[2];
      if (v6 != (unsigned int *)&the_empty_shape)
      {
        if (v6)
        {
          if ((int)*v5 >= 3 && *v6 == 0x80000000)
          {
            uint64_t v7 = v6[1];
            if ((int)v7 >= 1 && v6[v7] != 0x7FFFFFFF)
            {
              unsigned int v8 = vcvtd_n_s64_f64(a3, 8uLL);
              unsigned int v9 = 0x80000000;
              do
              {
                uint64_t v10 = v6 + 2;
                v6 += (int)v6[1];
                uint64_t v11 = ((int)(v9 * v8 + 1) >> 8);
                uint64_t v12 = ((int)(*v6 * v8 + 255) >> 8);
                while (v10 < v6)
                {
                  unsigned int v13 = *v10;
                  unsigned int v14 = v10[1];
                  v10 += 2;
                  double result = shape_accum_add(v5, ((int)(v13 * v8 + 1) >> 8), v11, ((int)(v14 * v8 + 255) >> 8), v12);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
                unsigned int v9 = *v6;
              }
              while (*v6 != 0x7FFFFFFF);
            }
          }
        }
      }
    }
  }
  return result;
}

int *CGSRegionCreateWithBoundingShape(int *result)
{
  if (result)
  {
    uint64_t v1 = shape_accum_shape(result);
    return (int *)region_create_with_shape(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  return result;
}

uint64_t CGSBoundingShapeGetRegion(int *a1, int **a2)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v3 = shape_accum_shape(a1);
      a1 = (int *)region_create_with_shape(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    *a2 = a1;
  }
  return 0;
}

uint64_t CGSBoundingShapeGetBounds(int *a1, double *a2)
{
  if (a2)
  {
    if (a1 && (uint64_t v2 = *a1, (int)v2 >= 3))
    {
      char v3 = 0;
      uint64_t v4 = (int *)*((void *)a1 + 2);
      uint64_t v5 = &v4[4 * v2];
      int v6 = 0x7FFFFFFF;
      int v7 = -2147483647;
      int v8 = -2147483647;
      int v9 = 0x7FFFFFFF;
      int v10 = 0x7FFFFFFF;
      do
      {
        while (1)
        {
          int v11 = v4[1];
          if (*v4 >= v11) {
            break;
          }
          int v12 = v4[2];
          if (v12 <= -2147483647) {
            int v12 = -2147483647;
          }
          int v13 = v4[3] - (v4[3] >= v10);
          if (v12 >= v13) {
            break;
          }
          int v10 = 0;
          if (*v4 < v9) {
            int v9 = *v4;
          }
          if (v11 > v8) {
            int v8 = v4[1];
          }
          if (v12 < v6) {
            int v6 = v12;
          }
          if (v13 > v7) {
            int v7 = v13;
          }
          v4 += 4;
          char v3 = 1;
          if (v4 >= v5) {
            goto LABEL_22;
          }
        }
        v4 += 4;
      }
      while (v4 < v5);
      if ((v3 & 1) == 0) {
        goto LABEL_23;
      }
LABEL_22:
      *a2 = (double)v9;
      a2[1] = (double)v6;
      a2[2] = (double)(v8 - v9);
      a2[3] = (double)(v7 - v6);
    }
    else
    {
LABEL_23:
      *(CGRect *)a2 = CGRectNull;
    }
  }
  return 0;
}

uint64_t CGPDFGetBaseEncodingForName(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (const char *)result;
    if (!strcmp((const char *)result, "MacRomanEncoding"))
    {
      return 2;
    }
    else if (!strcmp(v1, "WinAnsiEncoding"))
    {
      return 3;
    }
    else if (!strcmp(v1, "MacExpertEncoding"))
    {
      return 4;
    }
    else if (!strcmp(v1, "StandardEncoding"))
    {
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *CGPDFGetNameForBaseEncoding(int a1)
{
  if ((a1 + 1) >= 8) {
    abort();
  }
  return off_1E52CBCC8[a1 + 1];
}

uint64_t CGPDFGetNameVectorForBaseEncoding(int a1)
{
  if ((a1 - 1) > 6) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_1E52CBD08 + (a1 - 1));
  }
}

uint64_t CGPDFGetUnicharVectorForBaseEncoding(int a1)
{
  if ((a1 - 1) > 6) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_1E52CBD40 + (a1 - 1));
  }
}

double *CGFontAutohintTransformCreate(uint64_t a1, double *a2, int a3, double a4)
{
  if (CGFontAutohintTransformCreate_once != -1) {
    dispatch_once_f(&CGFontAutohintTransformCreate_once, 0, (dispatch_function_t)defaults_setup);
  }
  int v8 = 0;
  if (a1 && autohinting_enabled)
  {
    int v9 = *(_DWORD *)(a1 + 104);
    if (v9 < 0)
    {
      int v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 136))(*(void *)(a1 + 112));
      *(_DWORD *)(a1 + 104) = v10;
      if (!v10) {
        return 0;
      }
    }
    else if (!v9)
    {
      return 0;
    }
    double v11 = *a2;
    if (*a2 > 0.0 && v11 == a2[3] && a2[1] == 0.0 && a2[2] == 0.0)
    {
      int v12 = v11 == (double)(int)v11 ? (int)v11 : 0;
      if ((v12 - 19) >= 0xFFFFFFF4)
      {
        int v8 = (double *)malloc_type_malloc(0x78uLL, 0x1000040BC1FB88EuLL);
        *(_DWORD *)int v8 = 1;
        *((unsigned char *)v8 + 5) = a3;
        void v8[2] = a4;
        FontBBoCGFloat x = CGFontGetFontBBox((CGFontRef)a1);
        double y = FontBBox.origin.y;
        if (FontBBox.origin.x != INFINITY && FontBBox.origin.y != INFINITY)
        {
          double height = FontBBox.size.height;
          if (FontBBox.size.width < 0.0 || FontBBox.size.height < 0.0)
          {
            CGRect v72 = CGRectStandardize(FontBBox);
            double y = v72.origin.y;
            double height = v72.size.height;
          }
          *(_DWORD *)glyphs = 0;
          memset(&bboxes, 0, sizeof(bboxes));
          (*(void (**)(void, CGGlyph *, CGGlyph *))(*(void *)(a1 + 16) + 272))(*(void *)(a1 + 112), &glyphs[1], glyphs);
          if ((__int16)glyphs[1] != -1
            && glyphs[0] != 0xFFFF
            && CGFontGetGlyphBBoxes((CGFontRef)a1, glyphs, 1uLL, &bboxes))
          {
            CGFloat x = bboxes.origin.x;
            double v16 = 0.0;
            if (bboxes.origin.x != INFINITY)
            {
              double v17 = bboxes.origin.y;
              if (bboxes.origin.y != INFINITY)
              {
                CGFloat width = bboxes.size.width;
                if (bboxes.size.width != 0.0)
                {
                  double v19 = bboxes.size.height;
                  if (bboxes.size.height != 0.0)
                  {
                    if (bboxes.size.width < 0.0 || bboxes.size.height < 0.0) {
                      *(CGRect *)(&v17 - 1) = CGRectStandardize(*(CGRect *)&x);
                    }
                    double v16 = v17 + v19;
                  }
                }
              }
            }
            if (CGFontGetGlyphBBoxes((CGFontRef)a1, &glyphs[1], 1uLL, &bboxes))
            {
              CGFloat v20 = bboxes.origin.x;
              double v21 = 0.0;
              if (bboxes.origin.x != INFINITY)
              {
                double v22 = bboxes.origin.y;
                if (bboxes.origin.y != INFINITY)
                {
                  CGFloat v23 = bboxes.size.width;
                  if (bboxes.size.width != 0.0)
                  {
                    double v24 = bboxes.size.height;
                    if (bboxes.size.height != 0.0)
                    {
                      if (bboxes.size.width < 0.0 || bboxes.size.height < 0.0) {
                        *(CGRect *)(&v22 - 1) = CGRectStandardize(*(CGRect *)&v20);
                      }
                      double v21 = v22 + v24;
                    }
                  }
                }
              }
              if (v16 != v21)
              {
                font_info = get_font_info((void *)a1);
                if (font_info)
                {
                  int v27 = font_info[2];
                  if (v27)
                  {
                    int v46 = v12;
                    double v28 = (double)v12 * 0.015125;
                    if (v28 > 0.3) {
                      double v28 = 0.3;
                    }
                    double v29 = (double)v12 / (float)v27;
                    if (a3) {
                      double v30 = v28;
                    }
                    else {
                      double v30 = 0.0;
                    }
                    int v31 = (int)(v30 + v30 + v16 * v29 + 0.5);
                    int v32 = (int)(v30 + v30 + v21 * v29 + 0.5);
                    uint64_t v53 = 0;
                    long long v51 = 0u;
                    long long v52 = 0u;
                    long long v49 = 0u;
                    long long v50 = 0u;
                    long long v48 = 0u;
                    memset(&bboxes, 0, sizeof(bboxes));
                    if (!CGFontGetDescriptor((void *)a1, (uint64_t)&bboxes))
                    {
                      uint64_t v53 = 0;
                      long long v51 = 0u;
                      long long v52 = 0u;
                      long long v49 = 0u;
                      long long v50 = 0u;
                      long long v48 = 0u;
                      memset(&bboxes, 0, sizeof(bboxes));
                    }
                    double v33 = y + height;
                    if ((int)(v16 * v29 + 0.5) != v31)
                    {
                      long long v34 = *((_OWORD *)v8 + 5);
                      v66[4] = *((_OWORD *)v8 + 4);
                      long long v67 = v34;
                      long long v68 = *((_OWORD *)v8 + 6);
                      uint64_t v69 = *((void *)v8 + 14);
                      long long v35 = *((_OWORD *)v8 + 1);
                      v66[0] = *(_OWORD *)v8;
                      v66[1] = v35;
                      long long v36 = *((_OWORD *)v8 + 3);
                      v66[2] = *((_OWORD *)v8 + 2);
                      v66[3] = v36;
                      evaluate_autohint_transform((uint64_t)v66, v31, (int)(v30 + v30 + v21 * v29 + 0.5), *((double *)&v50 + 1), v30, v16, v21, v29, v33);
                      long long v37 = *((_OWORD *)v8 + 5);
                      v62[4] = *((_OWORD *)v8 + 4);
                      long long v63 = v37;
                      long long v64 = *((_OWORD *)v8 + 6);
                      uint64_t v65 = *((void *)v8 + 14);
                      long long v38 = *((_OWORD *)v8 + 1);
                      v62[0] = *(_OWORD *)v8;
                      v62[1] = v38;
                      long long v39 = *((_OWORD *)v8 + 3);
                      v62[2] = *((_OWORD *)v8 + 2);
                      v62[3] = v39;
                      evaluate_autohint_transform((uint64_t)v62, v31, (int)(v30 + v30 + v21 * v29 + 0.5), *((double *)&v50 + 1), 0.0, v16, v21, v29, v33);
                      long long v40 = *((_OWORD *)v8 + 5);
                      v58[4] = *((_OWORD *)v8 + 4);
                      long long v59 = v40;
                      long long v60 = *((_OWORD *)v8 + 6);
                      uint64_t v61 = *((void *)v8 + 14);
                      long long v41 = *((_OWORD *)v8 + 1);
                      v58[0] = *(_OWORD *)v8;
                      v58[1] = v41;
                      long long v42 = *((_OWORD *)v8 + 3);
                      v58[2] = *((_OWORD *)v8 + 2);
                      v58[3] = v42;
                      evaluate_autohint_transform((uint64_t)v58, (int)(v16 * v29 + 0.5), (int)(v21 * v29 + 0.5), *((double *)&v50 + 1), v30, v16, v21, v29, v33);
                      long long v43 = *((_OWORD *)v8 + 5);
                      v54[4] = *((_OWORD *)v8 + 4);
                      long long v55 = v43;
                      long long v56 = *((_OWORD *)v8 + 6);
                      uint64_t v57 = *((void *)v8 + 14);
                      long long v44 = *((_OWORD *)v8 + 1);
                      v54[0] = *(_OWORD *)v8;
                      v54[1] = v44;
                      long long v45 = *((_OWORD *)v8 + 3);
                      v54[2] = *((_OWORD *)v8 + 2);
                      v54[3] = v45;
                      evaluate_autohint_transform((uint64_t)v54, (int)(v16 * v29 + 0.5), (int)(v21 * v29 + 0.5), *((double *)&v50 + 1), 0.0, v16, v21, v29, v33);
                      if (fabs(*((double *)&v67 + 1) + -1.0)
                         + fabs(*(double *)&v68 + -1.0)
                         + fabs(*((double *)&v63 + 1) + -1.0)
                         + fabs(*(double *)&v64 + -1.0) > fabs(*((double *)&v59 + 1) + -1.0)
                                                        + fabs(*(double *)&v60 + -1.0)
                                                        + fabs(*((double *)&v55 + 1) + -1.0)
                                                        + fabs(*(double *)&v56 + -1.0))
                      {
                        int v31 = (int)(v16 * v29 + 0.5);
                        int v32 = (int)(v21 * v29 + 0.5);
                      }
                    }
                    evaluate_autohint_transform((uint64_t)v8, v31, v32, *((double *)&v50 + 1), a4, v16, v21, v29, v33);
                    if (v16 / v21 <= 0.85 || v8[12] >= 0.33)
                    {
                      *((unsigned char *)v8 + 4) = 1;
                      *((_DWORD *)v8 + 2) = v46;
                      return v8;
                    }
                  }
                }
              }
            }
          }
        }
        *((unsigned char *)v8 + 4) = 0;
        if (atomic_fetch_add_explicit((atomic_uint *volatile)v8, 0xFFFFFFFF, memory_order_relaxed) == 1) {
          free(v8);
        }
      }
    }
    return 0;
  }
  return v8;
}

uint64_t evaluate_autohint_transform(uint64_t result, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (!preserve_text_stems)
  {
    *(double *)(result + 24) = -a5;
    double v23 = a5 + a6 * a8;
    double v24 = a5 + a7 * a8;
    double v25 = (float)a2 - a5;
    *(double *)(result + 40) = v23;
    *(double *)(result + 48) = v25;
    double v26 = (float)a3 - a5;
    *(double *)(result + 72) = v24;
    *(double *)(result + 80) = v26;
    double v27 = 0.0;
    double v28 = 0.0;
    if (v23 != -a5) {
      double v28 = (v25 + a5) / (v23 + a5);
    }
    double v29 = a5 + a9 * a8;
    *(double *)(result + 88) = v28;
    if (v24 != v23) {
      double v27 = (v26 - v25) / (v24 - v23);
    }
    *(double *)(result + 96) = v27;
    double v30 = 0.0;
    if (v29 != v24) {
      double v30 = (v29 - v26) / (v29 - v24);
    }
    *(double *)(result + 104) = v30;
    double v21 = (void *)(result + 104);
    if (v27 >= 0.75 && v27 - v28 <= 0.3)
    {
      char v22 = 0;
      goto LABEL_37;
    }
    *(double *)(result + 80) = v24;
    double v34 = 0.0;
    double v35 = 0.0;
    if (v23 != -a5) {
      double v35 = (v25 + a5) / (v23 + a5);
    }
    *(double *)(result + 88) = v35;
    if (v24 != v23) {
      double v34 = (v24 - v25) / (v24 - v23);
    }
    char v22 = 0;
    *(double *)(result + 96) = v34;
LABEL_36:
    *double v21 = 0x3FF0000000000000;
    goto LABEL_37;
  }
  if (a4 == 0.0) {
    a4 = a7;
  }
  if (a4 > a6 * 0.333) {
    a4 = a6 * 0.333;
  }
  if (a4 > (a7 - a6) * 0.5) {
    a4 = (a7 - a6) * 0.5;
  }
  double v9 = a4 * a8;
  double v10 = a4 * a8 + a5;
  *(double *)(result + 24) = -a5;
  *(double *)(result + 32) = v10;
  double v11 = a5 + a6 * a8;
  double v12 = -(v9 - a7 * a8) - a5;
  double v13 = a5 + a7 * a8;
  double v14 = (float)a2 - a5;
  *(double *)(result + 40) = v11;
  *(double *)(result + 48) = v14;
  double v15 = (float)a3 - a5;
  *(double *)(result + 72) = v13;
  *(double *)(result + 80) = v15;
  double v16 = v15 - v9 + a5 * -2.0;
  *(double *)(result + 56) = v12;
  *(double *)(result + 64) = v16;
  double v17 = 0.0;
  double v18 = 0.0;
  if (v11 != v9 + a5) {
    double v18 = (v14 - v10) / (v11 - v10);
  }
  double v19 = a5 + a9 * a8;
  *(double *)(result + 88) = v18;
  if (v12 != v11) {
    double v17 = (v16 - v14) / (v12 - v11);
  }
  *(double *)(result + 96) = v17;
  double v20 = 0.0;
  if (v19 != v13) {
    double v20 = (v19 - v15) / (v19 - v13);
  }
  *(double *)(result + 104) = v20;
  double v21 = (void *)(result + 104);
  if (v17 < 0.75 || v17 - v18 > 0.3)
  {
    *(double *)(result + 80) = v13;
    double v31 = v13 - v9 + a5 * -2.0;
    *(double *)(result + 64) = v31;
    double v32 = 0.0;
    double v33 = 0.0;
    if (v11 != v10) {
      double v33 = (v14 - v10) / (v11 - v10);
    }
    *(double *)(result + 88) = v33;
    if (v12 != v11) {
      double v32 = (v31 - v14) / (v12 - v11);
    }
    *(double *)(result + 96) = v32;
    char v22 = 1;
    goto LABEL_36;
  }
  char v22 = 1;
LABEL_37:
  *(unsigned char *)(result + 112) = v22;
  return result;
}

const void *defaults_setup()
{
  get_BOOLean_property("CGFontAutohintingEnabled", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&autohinting_enabled);
  get_BOOLean_property("CGFontAutohintingAdjustDilation", (const void *(*)(const char *))copy_local_domain_value, adjust_dilation);

  return get_BOOLean_property("CGFontAutohintingPreserveTextStems", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&preserve_text_stems);
}

double *CGFontAutohinterIteratorCreate(atomic_ullong *a1, double *a2, double a3)
{
  Autohinter = CGFontGetAutohinter(a1);
  double result = CGFontAutohinterCreateAutohintTransform(Autohinter, a2, 1, a3);
  if (result) {
    operator new();
  }
  return result;
}

void autohinter_iterator_release_data(void *a1)
{
  if (a1)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(a1);
    }
  }
}

uint64_t autohinter_iterator_end(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = (uint64_t (*)(void, void))a2[4];
    if (v2) {
      return v2(a2[1], a2[6]);
    }
  }
  return result;
}

void autohinter_iterate(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  switch(a2)
  {
    case -1:
      if (a4)
      {
        int v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 16);
        if (v6)
        {
          uint64_t v7 = *(void *)(a4 + 8);
          uint64_t v8 = *(void *)(a4 + 48);
          v6(v7, a3, v8);
        }
      }
      break;
    case 0:
      CGFontAutohintTransformApply();
      uint64_t v26 = v9;
      uint64_t v27 = v10;
      if (a4) {
        (*(void (**)(void, void, uint64_t *, void))(a4 + 24))(*(void *)(a4 + 8), 0, &v26, *(void *)(a4 + 48));
      }
      break;
    case 1:
      CGFontAutohintTransformApply();
      uint64_t v26 = v11;
      uint64_t v27 = v12;
      if (a4) {
        (*(void (**)(void, uint64_t, uint64_t *, void))(a4 + 24))(*(void *)(a4 + 8), 1, &v26, *(void *)(a4 + 48));
      }
      break;
    case 3:
      if (a4)
      {
        CGFontAutohintTransformApply();
        uint64_t v14 = v13;
        uint64_t v16 = v15;
        CGFontAutohintTransformApply();
        uint64_t v18 = v17;
        uint64_t v20 = v19;
        CGFontAutohintTransformApply();
        uint64_t v26 = v21;
        uint64_t v27 = v22;
        uint64_t v28 = v18;
        uint64_t v29 = v20;
        uint64_t v30 = v14;
        uint64_t v31 = v16;
        (*(void (**)(void, uint64_t, uint64_t *, void))(a4 + 24))(*(void *)(a4 + 8), 3, &v26, *(void *)(a4 + 48));
      }
      break;
    case 4:
      if (a4)
      {
        double v23 = *(void (**)(uint64_t, uint64_t, void, uint64_t))(a4 + 24);
        uint64_t v24 = *(void *)(a4 + 8);
        uint64_t v25 = *(void *)(a4 + 48);
        v23(v24, 4, 0, v25);
      }
      break;
    default:
      abort();
  }
}

uint64_t autohinter_iterator_begin(uint64_t a1, uint64_t a2, void *a3)
{
  if (a3)
  {
    char v3 = (uint64_t (*)(void, uint64_t, void))a3[2];
    if (v3) {
      return v3(a3[1], a2, a3[6]);
    }
  }
  return result;
}

void *PDFColorSpaceCreate(uint64_t a1, const void *a2, int a3)
{
  int v6 = malloc_type_calloc(1uLL, 0x38uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(_DWORD *)int v6 = 1;
  *((void *)v6 + 1) = a1;
  if (a2) {
    CFRetain(a2);
  }
  *((void *)v6 + 3) = a2;
  *((void *)v6 + 4) = 0;
  *((void *)v6 + 2) = 0;
  snprintf_l((char *)v6 + 40, 0x10uLL, 0, "Cs%d", a3);
  switch(CGColorSpaceGetType(*((void **)v6 + 3)))
  {
    case 0u:
      uint64_t v7 = "DeviceGray";
      goto LABEL_12;
    case 1u:
      uint64_t v7 = "DeviceRGB";
      goto LABEL_12;
    case 2u:
      uint64_t v7 = "DeviceCMYK";
      goto LABEL_12;
    case 9u:
      uint64_t v8 = *((void *)v6 + 3);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 24);
        if ((*(_DWORD *)(v9 + 28) - 5) <= 1)
        {
          if (**(void **)(v9 + 96)) {
            goto LABEL_10;
          }
        }
      }
      uint64_t v7 = "Pattern";
LABEL_12:
      *((void *)v6 + 4) = v7;
      break;
    default:
LABEL_10:
      *((void *)v6 + 2) = PDFXRefTableAddObject(*(void **)(*((void *)v6 + 1) + 464));
      break;
  }
  return v6;
}

void PDFColorSpaceRelease(CGColorSpaceRef *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CGColorSpaceRelease(a1[3]);
    free(a1);
  }
}

void PDFColorSpaceEmitReference(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v9 = a1[4];
    uint64_t v10 = a1[1];
    if (v9)
    {
      PDFDocumentPrintf(v10, (uint64_t)"/%N", a3, a4, a5, a6, a7, a8, v9);
    }
    else
    {
      uint64_t v11 = a1[2];
      PDFDocumentPrintReference(v10, (uint64_t)"%R", v11, a4, a5, a6, a7, a8);
    }
  }
}

void emit_array(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = a4;
  uint64_t v10 = (uint64_t *)a3;
  PDFDocumentPrintf(a1, (uint64_t)"%s [", a3, a4, a5, a6, a7, a8, a2);
  for (; v9; --v9)
  {
    uint64_t v18 = *v10++;
    PDFDocumentPrintf(a1, (uint64_t)"%f", v12, v13, v14, v15, v16, v17, v18);
  }

  PDFDocumentPrintf(a1, (uint64_t)"]", v12, v13, v14, v15, v16, v17, a9);
}

CGPDFObjectType CGPDFObjectGetType(CGPDFObjectRef object)
{
  if (!object) {
    return 1;
  }
  if (*((_DWORD *)object + 2) == 12) {
    return 3;
  }
  return *((_DWORD *)object + 2);
}

BOOL CGPDFObjectGetValue(CGPDFObjectRef object, CGPDFObjectType type, void *value)
{
  if (!object) {
    return (char)object;
  }
  CGPDFObjectRef v3 = object;
  if (type == kCGPDFObjectTypeInteger || type == (kCGPDFObjectTypeDictionary|kCGPDFObjectTypeReal))
  {
    int v6 = *((_DWORD *)object + 2);
    if (v6 == 12 || v6 == 3)
    {
      if (value) {
        *(void *)CGPDFReal value = *((void *)object + 4);
      }
      goto LABEL_24;
    }
    goto LABEL_21;
  }
  if (type == kCGPDFObjectTypeReal)
  {
    int v4 = *((_DWORD *)object + 2);
    switch(v4)
    {
      case 12:
        goto LABEL_8;
      case 4:
        double v5 = *((double *)object + 4);
        if (!value)
        {
LABEL_24:
          LOBYTE(object) = 1;
          return (char)object;
        }
LABEL_23:
        *(double *)CGPDFReal value = v5;
        goto LABEL_24;
      case 3:
LABEL_8:
        double v5 = (double)*((uint64_t *)object + 4);
        if (!value) {
          goto LABEL_24;
        }
        goto LABEL_23;
    }
    goto LABEL_21;
  }
  if (*((_DWORD *)object + 2) != type)
  {
LABEL_21:
    LOBYTE(object) = 0;
    return (char)object;
  }
  LOBYTE(object) = 1;
  switch(type)
  {
    case kCGPDFObjectTypeNull:
      return (char)object;
    case kCGPDFObjectTypeBoolean:
      if (value) {
        *(unsigned char *)CGPDFReal value = *((unsigned char *)v3 + 32);
      }
      break;
    case kCGPDFObjectTypeName:
    case kCGPDFObjectTypeString:
    case kCGPDFObjectTypeArray:
    case kCGPDFObjectTypeDictionary:
    case kCGPDFObjectTypeStream:
      if (value) {
        *(void *)CGPDFReal value = *((void *)v3 + 4);
      }
      break;
    case kCGPDFObjectTypeDictionary|kCGPDFObjectTypeBoolean:
      if (value) {
        *(_OWORD *)CGPDFReal value = *((_OWORD *)v3 + 1);
      }
      break;
    case kCGPDFObjectTypeStream|kCGPDFObjectTypeBoolean:
      if (value) {
        *(_DWORD *)CGPDFReal value = *((_DWORD *)v3 + 8);
      }
      break;
    default:
      pdf_error("invalid object type: %d.", type);
      abort();
  }
  return (char)object;
}

uint64_t CGPDFObjectPrint(uint64_t a1, FILE *a2)
{
  return CGPDFObjectPrintWithIndent(a1, a2, 0);
}

uint64_t CGPDFObjectPrintWithIndent(uint64_t result, FILE *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    if (a2) {
      int v4 = a2;
    }
    else {
      int v4 = (FILE *)*MEMORY[0x1E4F143C8];
    }
    switch(*(_DWORD *)(result + 8))
    {
      case 1:
        uint64_t result = fwrite("null object", 0xBuLL, 1uLL, v4);
        break;
      case 2:
        uint64_t result = fprintf(v4, "Boolean: %s");
        break;
      case 3:
        uint64_t result = fprintf(v4, "Integer: %ld");
        break;
      case 4:
        uint64_t result = fprintf(v4, "Real: %g");
        break;
      case 5:
        fwrite("Name: ", 6uLL, 1uLL, v4);
        int v6 = *(const char **)(v3 + 32);
        size_t v7 = strlen(v6);
        for (uint64_t result = fputc(47, v4); v7; --v7)
        {
          int v9 = *(unsigned __int8 *)v6++;
          int v8 = v9;
          if ((v9 - 127) <= 0xFFFFFFA1
            || ((v8 - 35) <= 0x3A
              ? (BOOL v10 = ((1 << (v8 - 35)) & 0x50000000A001065) == 0)
              : (BOOL v10 = 1),
                !v10 || v8 == 125 || v8 == 123))
          {
            uint64_t result = fprintf(v4, "#%02x", v8);
          }
          else
          {
            uint64_t result = fputc(v8, v4);
          }
        }
        break;
      case 6:
        fwrite("String: ", 8uLL, 1uLL, v4);
        uint64_t v11 = *(void *)(v3 + 32);
        uint64_t result = CGPDFStringPrint(v11, v4);
        break;
      case 7:
        fwrite("Array: ", 7uLL, 1uLL, v4);
        uint64_t v12 = *(void *)(v3 + 32);
        uint64_t result = CGPDFArrayPrintWithIndent(v12, v4, a3);
        break;
      case 8:
        fwrite("Dictionary: ", 0xCuLL, 1uLL, v4);
        uint64_t v13 = *(void *)(v3 + 32);
        uint64_t result = CGPDFDictionaryPrintWithIndent(v13, v4, a3);
        break;
      case 9:
        fwrite("Stream: ", 8uLL, 1uLL, v4);
        uint64_t v14 = *(void *)(v3 + 32);
        uint64_t result = stream_print(v14, v4, a3, 0);
        break;
      case 0xA:
        uint64_t result = fprintf(v4, "Object Reference: R(%lu,%hu)");
        break;
      case 0xB:
        uint64_t result = fprintf(v4, "Operator: %d");
        break;
      case 0xC:
        uint64_t result = fprintf(v4, "Offset: %lld");
        break;
      default:
        uint64_t result = fprintf(v4, "UNKNOWN OBJECT TYPE: %d");
        break;
    }
  }
  return result;
}

void pdf_softmask_release_info(CFTypeRef *a1)
{
  CFTypeRef v2 = a1[2];
  if (v2) {
    CFRelease(v2);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  CFTypeRef v3 = a1[1];
  if (v3) {
    CFRelease(v3);
  }

  free(a1);
}

void pdf_softmask_draw_softmask(CGPDFStream **a1, uint64_t a2)
{
  CFTypeRef v3 = *a1;
  if (*a1)
  {
    int v4 = (CGPDFStream **)*((void *)v3 + 4);
    if (v4)
    {
      CFTypeRef v3 = *v4;
      double v5 = v4[11];
      goto LABEL_6;
    }
    CFTypeRef v3 = 0;
  }
  double v5 = 0;
LABEL_6:
  CGPDFContentStreamRef v6 = CGPDFContentStreamCreateWithStream(v3, v5, a1[2]);
  uint64_t v13 = CGPDFDrawingContextCreateWithContentStream(v6, 0);
  if (v6) {
    CFRelease(v6);
  }
  CGPDFDrawingContextDraw((uint64_t)v13, a2, v7, v8, v9, v10, v11, v12);

  CGPDFDrawingContextRelease(v13);
}

CFStringRef _ripdata_copy_description(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<RIPData %p>", a1);
}

CFStringRef _ripdata_copy_format_description(uint64_t a1, const __CFDictionary *a2)
{
  return CFStringCreateWithFormat(0, a2, @"<RIPData %p>", a1);
}

uint64_t RIPShouldCachePatterns()
{
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  return *(unsigned __int8 *)(RIPGetCacheState_cache_state + 33);
}

void RIPCacheEntryRemove(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v1 = (void *)a1[1];
  *(void *)(v2 + 8) = v1;
  CFTypeRef v3 = (void *)a1[3];
  --*(void *)(a1[4] + 40);
  void *v1 = v2;
  uint64_t v4 = a1[5];
  a1[5] = 0;
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  --*(void *)(v4 + 16);
  uint64_t v5 = a1[2];
  *(void *)(v5 + 8) = v3;
  *CFTypeRef v3 = v5;
  a1[2] = (uint64_t)(a1 + 2);
  a1[3] = (uint64_t)(a1 + 2);
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  --*(void *)(RIPGetCacheState_cache_state + 16);
}

void RIPPrint()
{
  uint64_t v0 = (FILE *)*MEMORY[0x1E4F143C8];
  fputc(10, (FILE *)*MEMORY[0x1E4F143C8]);
  fwrite("RIP\n", 4uLL, 1uLL, v0);
  fwrite("===\n\n", 5uLL, 1uLL, v0);
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v1 = RIPGetCacheState_cache_state;
  RIPLockCacheState();
  pthread_mutex_lock(&contexts_mutex);
  uint64_t v2 = (uint64_t *)contexts;
  if (contexts)
  {
    unint64_t v3 = 0;
    uint64_t v4 = contexts;
    do
    {
      ++v3;
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
  }
  else
  {
    unint64_t v3 = 0;
  }
  uint64_t v13 = malloc_type_calloc(v3 + 1, 0x68uLL, 0x10200409CB08D46uLL);
  fprintf(v0, "%-18s %-10s %.10s %-18s %-18s %-6s %-6s %-8s\n", "Context", "Usage", "Generation", "Reference", "Address", "Width", "Height", "Type");
  fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "====================", "====================", "====================", "====================", "====================", "====================", "====================", "====================");
  if (v2)
  {
    uint64_t v5 = v13;
    do
    {
      RIPPrintCache(v0, v1, *v2, v5);
      fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------", "--------------------");
      uint64_t v2 = (uint64_t *)v2[1];
      v5 += 13;
    }
    while (v2);
  }
  pthread_mutex_unlock(&contexts_mutex);
  uint64_t v11 = v1;
  RIPPrintCache(v0, v1, 0, &v13[13 * v3]);
  RIPUnlockCacheState();
  fprintf(v0, "%.18s %.10s %.10s %.18s %.18s %.6s %.6s %.8s\n", "====================", "====================", "====================", "====================", "====================", "====================", "====================", "====================");
  fputc(10, v0);
  fprintf(v0, "%-18s %-10s %-10s %-10s\n", "Context", "Count", "Size", "Type");
  fprintf(v0, "%.18s %.10s %.10s %.10s\n", "====================", "====================", "====================", "====================");
  unint64_t v6 = 0;
  uint64_t v7 = v13 + 3;
  unint64_t v12 = v3;
  do
  {
    unint64_t v8 = 0;
    uint64_t v9 = v7;
    do
    {
      if (*v9)
      {
        if (v13[13 * v6]) {
          fprintf(v0, "%18p");
        }
        else {
          fprintf(v0, "%18s");
        }
        uint64_t v10 = "Unknown";
        if (v8 <= 2) {
          uint64_t v10 = off_1E52CBE58[v8];
        }
        fprintf(v0, " %10lu %10lu %s\n", *v9, v9[1], v10);
      }
      ++v8;
      v9 += 2;
    }
    while (v8 != 5);
    if (v6 < v12) {
      fprintf(v0, "%.18s %.10s %.10s %.10s\n", "--------------------", "--------------------", "--------------------", "--------------------");
    }
    ++v6;
    v7 += 13;
  }
  while (v6 <= v12);
  fprintf(v0, "%.18s %.10s %.10s %.10s\n", "====================", "====================", "====================", "====================");
  fprintf(v0, "%-18s %10zu Total\n", "", *(void *)(v11 + 16));

  free(v13);
}

FILE *RIPPrintCache(FILE *result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (uint64_t *)(a3 + 208);
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v5 = (uint64_t *)(a2 + 8);
  uint64_t v6 = v7;
  if (!a3) {
    uint64_t v4 = v5;
  }
  uint64_t v8 = *v4;
  *a4 = a3;
  uint64_t v9 = *(void *)(v6 + 8);
  if (v9 != v6)
  {
    unint64_t v12 = result;
    do
    {
      if (*(void *)(v9 + 24) == v8)
      {
        ++a4[1];
        uint64_t v13 = *(int *)(v9 + 32);
        ++a4[2 * v13 + 3];
        switch(v13)
        {
          case 2:
            if (a3) {
              fprintf(v12, "%18p");
            }
            else {
              fprintf(v12, "%18s");
            }
            uint64_t result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6u %6u PatternImage\n");
            break;
          case 1:
            if (a3) {
              fprintf(v12, "%18p");
            }
            else {
              fprintf(v12, "%18s");
            }
            uint64_t result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6u %6u Pattern\n");
            break;
          case 0:
            if (a3) {
              fprintf(v12, "%18p");
            }
            else {
              fprintf(v12, "%18s");
            }
            uint64_t result = (FILE *)fprintf(v12, " %10u %10u %18p %18p %6zu %6zu Function\n");
            break;
        }
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while (v9 != v6);
  }
  return result;
}

void *CGColorTransformCreateParametricCodeFragment(void *a1, void *a2, uint64_t a3)
{
  calibrated_parametric_data_f = 0;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    Cache = CGColorTransformGetCache(a1);
    if (Cache)
    {
      uint64_t v8 = Cache[2];
      if (v8)
      {
        if (*(void *)(*(void *)(v8 + 24) + 48) == 3)
        {
          *(void *)&long long v57 = MEMORY[0x1E4F143A8];
          *((void *)&v57 + 1) = 0x40000000;
          *(void *)&long long v58 = __create_resolved_source_space_block_invoke;
          *((void *)&v58 + 1) = &__block_descriptor_tmp_36_17179;
          long long v59 = a1;
          ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)&v57);
          uint64_t v10 = CGColorTransformGetCache(a1);
          Converter = (unsigned __int8 *)CGColorTransformCacheCreateConverter((uint64_t)v10, ResolvedColorSpace, a3);
          BOOL v12 = CGColorTransformUsesCalibratedColor(a1);
          if (!Converter)
          {
            calibrated_parametric_data_f = 0;
LABEL_75:
            CGColorSpaceRelease(ResolvedColorSpace);
            return calibrated_parametric_data_f;
          }
          BOOL v13 = v12;
          CFTypeID v17 = CFGetTypeID(Converter);
          uint64_t v18 = kCGCMSConverterID;
          if (!kCGCMSConverterID)
          {
            pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
            uint64_t v18 = kCGCMSConverterID;
          }
          if (v17 == v18)
          {
            if (!v13)
            {
              if (*((void *)Converter + 6) != 3 || *((void *)Converter + 5) != 3) {
                _CGHandleAssert("create_linear_parametric_data", 5778, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "converter != NULL && converter->nSrcComp == 3 && converter->nDstComp == 3", "converter: %p  src components: %lu  destComponents %lu", v14, v15, v16, (char)Converter);
              }
              uint64_t v24 = (char *)malloc_type_malloc(0x16CuLL, 0x10000403884A0CCuLL);
              *(void *)uint64_t v24 = 0;
              *((_DWORD *)v24 + 2) = 1065353216;
              *(void *)(v24 + 12) = 0;
              *(void *)(v24 + 28) = 0;
              *(void *)(v24 + 20) = 0;
              *(void *)(v24 + 52) = 0x100000000;
              *((_DWORD *)v24 + 15) = 1065353216;
              *((void *)v24 + 9) = 0;
              *((void *)v24 + 10) = 0;
              *((void *)v24 + 8) = 0;
              *((void *)v24 + 13) = 0x200000000;
              *((_DWORD *)v24 + 28) = 1065353216;
              *(void *)(v24 + 116) = 0;
              *(void *)(v24 + 132) = 0;
              *(void *)(v24 + 124) = 0;
              *((_DWORD *)v24 + 40) = 1065353216;
              *(void *)(v24 + 172) = 0;
              *(void *)(v24 + 164) = 0;
              *((_DWORD *)v24 + 45) = 1065353216;
              *((void *)v24 + 23) = 0;
              *((void *)v24 + 24) = 0;
              *((void *)v24 + 25) = 1065353216;
              *((void *)v24 + 26) = 0x100000000;
              *((_DWORD *)v24 + 54) = 1065353216;
              *(void *)(v24 + 236) = 0;
              *(void *)(v24 + 220) = 0;
              *(void *)(v24 + 228) = 0;
              *(void *)(v24 + 260) = 0x200000000;
              *((_DWORD *)v24 + 67) = 1065353216;
              *((void *)v24 + 34) = 0;
              *((void *)v24 + 35) = 0;
              *((void *)v24 + 36) = 0;
              *((void *)v24 + 39) = 0x300000000;
              *((_DWORD *)v24 + 80) = 1065353216;
              *(void *)(v24 + 332) = 0;
              *(void *)(v24 + 324) = 0;
              unsigned int v25 = 7;
              *(void *)(v24 + 340) = 0;
LABEL_72:
              calibrated_parametric_data_f = malloc_type_calloc(1uLL, 0x38uLL, 0x10E20400F34DD07uLL);
              *(_DWORD *)calibrated_parametric_data_f = 1;
              *(void *)((char *)calibrated_parametric_data_f + 12) = 0;
              *(void *)((char *)calibrated_parametric_data_f + 4) = 0;
              calibrated_parametric_data_f[3] = v25;
              calibrated_parametric_data_f[4] = v24;
LABEL_74:
              CFRelease(Converter);
              goto LABEL_75;
            }
            CFArrayRef Retained = (const __CFArray *)*((void *)Converter + 11);
            if (!Retained)
            {
              CFDictionaryRef v20 = (const __CFDictionary *)*((void *)Converter + 9);
              colorsync_profile_sequence = create_colorsync_profile_sequence(*((CGColorSpace **)Converter + 3), *((CGColorSpace **)Converter + 4), *((_DWORD *)Converter + 21), Converter[80]);
              if (colorsync_profile_sequence)
              {
                uint64_t v22 = colorsync_profile_sequence;
                CFArrayRef Retained = CGColorSyncTransformCacheGetRetained(colorsync_profile_sequence, v20);
                CFRelease(v22);
              }
              else
              {
                CFArrayRef Retained = 0;
              }
            }
            if (create_calibrated_parametric_data_cglibrarypredicate != -1) {
              dispatch_once(&create_calibrated_parametric_data_cglibrarypredicate, &__block_literal_global_145);
            }
            calibrated_parametric_data_f = (void *)create_calibrated_parametric_data_f(Retained, @"com.apple.cmm.ParametricConversion", 0);
            if (!*((void *)Converter + 11)) {
              CGColorSyncTransformCacheRelease(Retained);
            }
            if (!calibrated_parametric_data_f) {
              goto LABEL_74;
            }
            CFTypeID v26 = CFGetTypeID(calibrated_parametric_data_f);
            if (v26 == CFArrayGetTypeID())
            {
              unsigned int Count = CFArrayGetCount((CFArrayRef)calibrated_parametric_data_f);
              uint64_t v24 = (char *)malloc_type_malloc(52 * Count, 0x10000403884A0CCuLL);
              if (Count)
              {
                CFIndex v27 = 0;
                long long v56 = calibrated_parametric_data_f;
                do
                {
                  ValueAtIndeCGFloat x = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)calibrated_parametric_data_f, v27);
                  if (!ValueAtIndex) {
                    goto LABEL_67;
                  }
                  CFDictionaryRef v29 = ValueAtIndex;
                  CFTypeID v30 = CFGetTypeID(ValueAtIndex);
                  if (v30 != CFDictionaryGetTypeID()) {
                    goto LABEL_67;
                  }
                  uint64_t v31 = (int *)&v24[52 * v27];
                  if (CFDictionaryContainsKey(v29, @"com.apple.cmm.Matrix"))
                  {
                    int *v31 = 1836348024;
                    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v29, @"com.apple.cmm.Matrix");
                    CFIndex v33 = 0;
                    double v34 = &v57;
                    do
                    {
                      CFIndex v35 = 0;
                      long long v36 = (char *)v34;
                      do
                      {
                        CFArrayRef v37 = (const __CFArray *)CFArrayGetValueAtIndex(Value, v33);
                        CFNumberRef v38 = (const __CFNumber *)CFArrayGetValueAtIndex(v37, v35);
                        CFNumberGetValue(v38, kCFNumberFloat32Type, v36);
                        ++v35;
                        v36 += 4;
                      }
                      while (v35 != 3);
                      CFArrayRef v39 = (const __CFArray *)CFArrayGetValueAtIndex(Value, v33);
                      CFNumberRef v40 = (const __CFNumber *)CFArrayGetValueAtIndex(v39, 3);
                      CFNumberGetValue(v40, kCFNumberFloat32Type, &valuePtr[v33++]);
                      double v34 = (long long *)((char *)v34 + 12);
                    }
                    while (v33 != 3);
                    long long v41 = &v24[52 * v27];
                    *(void *)(v41 + 4) = v57;
                    *((_DWORD *)v41 + 3) = DWORD2(v57);
                    *((_DWORD *)v41 + 4) = valuePtr[0];
                    *((_DWORD *)v41 + 5) = HIDWORD(v57);
                    *((void *)v41 + 3) = v58;
                    *((_DWORD *)v41 + 8) = valuePtr[1];
                    *(void *)(v41 + 36) = *((void *)&v58 + 1);
                    *((_DWORD *)v41 + 11) = v59;
                    *((_DWORD *)v41 + 12) = valuePtr[2];
                  }
                  else
                  {
                    long long v42 = @"com.apple.cmm.ParamCurve0";
                    if (!CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve0")
                      && !CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve1")
                      && !CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve2")
                      && !CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve3")
                      && !CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve4"))
                    {
                      int *v31 = -1;
                      goto LABEL_67;
                    }
                    if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve0"))
                    {
                      int v43 = 0;
                    }
                    else if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve1"))
                    {
                      int v43 = 1;
                    }
                    else if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve2"))
                    {
                      int v43 = 2;
                    }
                    else if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve3"))
                    {
                      int v43 = 3;
                    }
                    else if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve4"))
                    {
                      int v43 = 4;
                    }
                    else
                    {
                      int v43 = -1;
                    }
                    int *v31 = v43;
                    if (CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve0")
                      || (long long v42 = @"com.apple.cmm.ParamCurve1",
                          CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve1"))
                      || (long long v42 = @"com.apple.cmm.ParamCurve2",
                          CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve2"))
                      || (long long v42 = @"com.apple.cmm.ParamCurve3",
                          CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve3"))
                      || (long long v42 = @"com.apple.cmm.ParamCurve4",
                          CFDictionaryContainsKey(v29, @"com.apple.cmm.ParamCurve4")))
                    {
                      CFArrayRef v44 = (const __CFArray *)CFDictionaryGetValue(v29, v42);
                    }
                    else
                    {
                      CFArrayRef v44 = 0;
                    }
                    CFNumberRef v45 = (const __CFNumber *)CFDictionaryGetValue(v29, @"com.apple.cmm.ChannelID");
                    unsigned int v46 = CFArrayGetCount(v44);
                    if (!v44) {
                      goto LABEL_67;
                    }
                    if (!v45) {
                      goto LABEL_67;
                    }
                    unsigned int v47 = v46;
                    if (v46 - 7 > 1) {
                      goto LABEL_67;
                    }
                    valuePtr[0] = 0;
                    CFNumberGetValue(v45, kCFNumberSInt32Type, valuePtr);
                    CFIndex v48 = 0;
                    long long v57 = 0u;
                    long long v58 = 0u;
                    uint64_t v49 = v47;
                    long long v50 = &v57;
                    do
                    {
                      CFNumberRef v51 = (const __CFNumber *)CFArrayGetValueAtIndex(v44, v48);
                      CFNumberGetValue(v51, kCFNumberFloat32Type, v50);
                      ++v48;
                      long long v50 = (long long *)((char *)v50 + 4);
                    }
                    while (v49 != v48);
                    long long v52 = &v24[52 * v27];
                    long long v53 = v57;
                    long long v54 = v58;
                    *((_DWORD *)v52 + 1) = valuePtr[0];
                    *(_OWORD *)(v52 + 8) = v53;
                    *(_OWORD *)(v52 + 24) = v54;
                  }
                  calibrated_parametric_data_f = v56;
LABEL_67:
                  ++v27;
                }
                while (v27 != Count);
              }
              CFRelease(calibrated_parametric_data_f);
              unsigned int v25 = Count;
              if (v24) {
                goto LABEL_72;
              }
            }
          }
          calibrated_parametric_data_f = 0;
          goto LABEL_74;
        }
      }
    }
    return 0;
  }
  return calibrated_parametric_data_f;
}

void *CGColorTransformCreateLookupTextureCodeFragment(void *a1, void *a2, uint64_t a3, int a4, unint64_t a5)
{
  uint64_t v5 = 0;
  if (a1 && a2)
  {
    Cache = CGColorTransformGetCache(a1);
    if (Cache)
    {
      uint64_t v12 = Cache[2];
      if (v12)
      {
        if (*(void *)(*(void *)(v12 + 24) + 48) == 3)
        {
          v78[0] = MEMORY[0x1E4F143A8];
          v78[1] = 0x40000000;
          v78[2] = __create_resolved_source_space_block_invoke;
          v78[3] = &__block_descriptor_tmp_36_17179;
          v78[4] = a1;
          ResolvedCGColorSpaceRef ColorSpace = CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v78);
          uint64_t v14 = (CGColorSpace *)ResolvedColorSpace;
          if (ResolvedColorSpace)
          {
            uint64_t v15 = *(void *)(*(void *)(ResolvedColorSpace + 24) + 48);
            if (a4 == 3)
            {
              if (v15 != 1) {
                goto LABEL_32;
              }
            }
            else if (v15 != 3)
            {
              goto LABEL_32;
            }
            CFTypeID v17 = CGColorTransformGetCache(a1);
            Converter = (unsigned __int8 *)CGColorTransformCacheCreateConverter((uint64_t)v17, v14, a3);
            BOOL v19 = CGColorTransformUsesCalibratedColor(a1);
            if (Converter)
            {
              BOOL v20 = v19;
              CFTypeID v28 = CFGetTypeID(Converter);
              uint64_t v29 = kCGCMSConverterID;
              if (!kCGCMSConverterID)
              {
                pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
                uint64_t v29 = kCGCMSConverterID;
              }
              if (v28 != v29) {
                goto LABEL_64;
              }
              if (!v20)
              {
                if ((a4 != 3 || a5 <= 0x100) && (a4 == 3 || a5 <= 0x80))
                {
                  switch(a4)
                  {
                    case 0:
                      long long v36 = (char *)malloc_type_calloc(4 * a5 * a5 * a5, 1uLL, 0x145A0EA4uLL);
                      CFArrayRef v37 = v36;
                      if (!a5 || !v36) {
                        goto LABEL_61;
                      }
                      uint64_t v38 = 0;
                      float v39 = (float)(a5 - 1);
                      CFNumberRef v40 = v36 + 3;
                      do
                      {
                        uint64_t v41 = 0;
                        unsigned int v42 = ((int)((float)((float)(unint64_t)(255 * v38) / v39) + 0.5) + 128) >> 8;
                        if (v42 >= 0xFF) {
                          LOBYTE(v42) = -1;
                        }
                        int v43 = v40;
                        do
                        {
                          unint64_t v44 = 0;
                          unsigned int v45 = ((int)((float)((float)(unint64_t)(255 * v41) / v39) + 0.5) + 128) >> 8;
                          if (v45 >= 0xFF) {
                            LOBYTE(v45) = -1;
                          }
                          unsigned int v46 = v43;
                          unint64_t v47 = a5;
                          do
                          {
                            unsigned int v48 = ((int)((float)((float)v44 / v39) + 0.5) + 128) >> 8;
                            *(v46 - 3) = v42;
                            *(v46 - 2) = v45;
                            if (v48 >= 0xFF) {
                              LOBYTE(v48) = -1;
                            }
                            *(v46 - 1) = v48;
                            *unsigned int v46 = -1;
                            v46 += 4;
                            v44 += 255;
                            --v47;
                          }
                          while (v47);
                          ++v41;
                          v43 += 4 * a5;
                        }
                        while (v41 != a5);
                        ++v38;
                        v40 += 4 * a5 * a5;
                      }
                      while (v38 != a5);
                      break;
                    case 1:
                      long long v52 = (char *)malloc_type_calloc(8 * a5 * a5 * a5, 1uLL, 0x3598B074uLL);
                      CFArrayRef v37 = v52;
                      if (!a5 || !v52) {
                        goto LABEL_61;
                      }
                      uint64_t v53 = 0;
                      float v54 = (float)(a5 - 1);
                      long long v55 = v52 + 4;
                      do
                      {
                        uint64_t v56 = 0;
                        long long v57 = v55;
                        do
                        {
                          unint64_t v58 = 0;
                          long long v59 = v57;
                          unint64_t v60 = a5;
                          do
                          {
                            *(v59 - 2) = (int)((float)((float)(unint64_t)(0xFFFF * v53) / v54)
                                                              + 0.5);
                            *(v59 - 1) = (int)((float)((float)(unint64_t)(0xFFFF * v56) / v54)
                                                              + 0.5);
                            *long long v59 = (int)((float)((float)v58 / v54) + 0.5);
                            v59[1] = -1;
                            v58 += 0xFFFFLL;
                            v59 += 4;
                            --v60;
                          }
                          while (v60);
                          ++v56;
                          v57 += 4 * a5;
                        }
                        while (v56 != a5);
                        ++v53;
                        v55 += 8 * a5 * a5;
                      }
                      while (v53 != a5);
                      break;
                    case 2:
                      uint64_t v61 = (char *)malloc_type_calloc(16 * a5 * a5 * a5, 1uLL, 0x8831B299uLL);
                      CFArrayRef v37 = v61;
                      if (!a5 || !v61) {
                        goto LABEL_61;
                      }
                      unint64_t v62 = 0;
                      float v63 = (float)(a5 - 1);
                      long long v64 = (float *)(v61 + 8);
                      do
                      {
                        unint64_t v65 = 0;
                        float v66 = (float)v62 / v63;
                        if (v66 > 1.0) {
                          float v66 = 1.0;
                        }
                        long long v67 = v64;
                        do
                        {
                          unint64_t v68 = 0;
                          float v69 = (float)v65 / v63;
                          if (v69 > 1.0) {
                            float v69 = 1.0;
                          }
                          unint64_t v70 = v67;
                          do
                          {
                            float v71 = (float)v68 / v63;
                            if (v71 > 1.0) {
                              float v71 = 1.0;
                            }
                            *(v70 - 2) = v66;
                            *(v70 - 1) = v69;
                            float *v70 = v71;
                            v70[1] = 1.0;
                            ++v68;
                            v70 += 4;
                          }
                          while (a5 != v68);
                          ++v65;
                          v67 += 4 * a5;
                        }
                        while (v65 != a5);
                        ++v62;
                        v64 += 4 * a5 * a5;
                      }
                      while (v62 != a5);
                      break;
                    case 3:
                      CGRect v72 = (char *)malloc_type_calloc(4 * a5, 1uLL, 0x3683490uLL);
                      CFArrayRef v37 = v72;
                      if (!a5 || !v72) {
                        goto LABEL_61;
                      }
                      unint64_t v73 = 0;
                      uint64_t v74 = v72 + 3;
                      unint64_t v75 = a5;
                      do
                      {
                        unsigned int v76 = ((int)((float)((float)v73 / (float)(a5 - 1)) + 0.5) + 128) >> 8;
                        if (v76 >= 0xFF) {
                          LOBYTE(v76) = -1;
                        }
                        *(v74 - 3) = v76;
                        *(v74 - 2) = v76;
                        *(v74 - 1) = v76;
                        *uint64_t v74 = -1;
                        v74 += 4;
                        v73 += 255;
                        --v75;
                      }
                      while (v75);
                      break;
                    default:
                      goto LABEL_63;
                  }
                  goto LABEL_62;
                }
                goto LABEL_63;
              }
              CFArrayRef Retained = (const __CFArray *)*((void *)Converter + 11);
              if (!Retained)
              {
                CFDictionaryRef v49 = (const __CFDictionary *)*((void *)Converter + 9);
                colorsync_profile_sequence = create_colorsync_profile_sequence(*((CGColorSpace **)Converter + 3), *((CGColorSpace **)Converter + 4), *((_DWORD *)Converter + 21), Converter[80]);
                if (!colorsync_profile_sequence)
                {
                  CFArrayRef Retained = 0;
                  goto LABEL_58;
                }
                CFNumberRef v51 = colorsync_profile_sequence;
                CFArrayRef Retained = CGColorSyncTransformCacheGetRetained(colorsync_profile_sequence, v49);
                CFRelease(v51);
                if (!Retained) {
                  goto LABEL_58;
                }
              }
              if ((a4 != 3 || a5 <= 0x100) && (a4 == 3 || a5 <= 0x80))
              {
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                CGCFDictionarySetInteger(Mutable, @"com.apple.cmm.GridPointCount", a5);
                if (create_calibrated_lookup_texture_cglibrarypredicate != -1) {
                  dispatch_once(&create_calibrated_lookup_texture_cglibrarypredicate, &__block_literal_global_134);
                }
                CFArrayRef calibrated_lookup_texture_f = (const __CFArray *)create_calibrated_lookup_texture_f(Retained, @"com.apple.cmm.SimplifiedConversion", Mutable);
                if (Mutable) {
                  CFRelease(Mutable);
                }
                if (calibrated_lookup_texture_f)
                {
                  ValueAtIndeCGFloat x = (const __CFDictionary *)CFArrayGetValueAtIndex(calibrated_lookup_texture_f, 0);
                  if (ValueAtIndex
                    && (CFDataRef Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"com.apple.cmm.3D-LUT")) != 0)
                  {
                    switch(a4)
                    {
                      case 0:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBX8_texture(Value, a5);
                        break;
                      case 1:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBX16_texture(Value, a5);
                        break;
                      case 2:
                        RGB_to_RGBX8_texture = create_RGB_to_RGBXF_texture(Value, a5);
                        break;
                      case 3:
                        RGB_to_RGBX8_texture = create_gray_to_RGBX8_texture(Value, a5);
                        break;
                      default:
                        goto LABEL_66;
                    }
                    CFArrayRef v37 = RGB_to_RGBX8_texture;
                  }
                  else
                  {
LABEL_66:
                    CFArrayRef v37 = 0;
                  }
                  CFRelease(calibrated_lookup_texture_f);
                  goto LABEL_59;
                }
              }
LABEL_58:
              CFArrayRef v37 = 0;
LABEL_59:
              if (!*((void *)Converter + 11)) {
                CGColorSyncTransformCacheRelease(Retained);
              }
LABEL_61:
              if (v37)
              {
LABEL_62:
                uint64_t v5 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E20400F34DD07uLL);
                *uint64_t v5 = 0;
                v5[1] = 0;
                *((_DWORD *)v5 + 4) = 0;
                *((_DWORD *)v5 + 8) = a4;
                v5[5] = a5;
                v5[6] = v37;
LABEL_65:
                CFRelease(Converter);
                goto LABEL_33;
              }
LABEL_63:
              CGPostError((uint64_t)"Failed to create a 3D texture", v21, v22, v23, v24, v25, v26, v27, v77);
LABEL_64:
              uint64_t v5 = 0;
              goto LABEL_65;
            }
          }
LABEL_32:
          uint64_t v5 = 0;
LABEL_33:
          CGColorSpaceRelease(v14);
          return v5;
        }
      }
    }
    return 0;
  }
  return v5;
}

void *CGColorTransformCreateCodeFragment(void *a1, void *a2, uint64_t a3, int a4, int a5, unint64_t a6)
{
  if (a4)
  {
    if (a4 != 1) {
      abort();
    }
    return CGColorTransformCreateParametricCodeFragment(a1, a2, a3);
  }
  else
  {
    return CGColorTransformCreateLookupTextureCodeFragment(a1, a2, a3, a5, a6);
  }
}

uint64_t CGColorCodeFragmentGetTextureFormat(_DWORD *a1)
{
  if (a1 && !*a1) {
    return a1[8];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CGColorCodeFragmentGetTextureGridPoints(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result) {
      return 0;
    }
    else {
      return *(void *)(result + 40);
    }
  }
  return result;
}

uint64_t CGColorCodeFragmentGetTextureData(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result) {
      return 0;
    }
    else {
      return *(void *)(result + 48);
    }
  }
  return result;
}

uint64_t CGColorCodeFragmentGetParametricCount(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1) {
      return *(void *)(result + 24);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGColorCodeFragmentGetParametricConversion(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1) {
      return *(void *)(result + 32);
    }
    else {
      return 0;
    }
  }
  return result;
}

void CGColorCodeFragmentRelease(void *a1)
{
  if (!a1) {
    return;
  }
  if (*(_DWORD *)a1)
  {
    uint64_t v2 = (void *)a1[4];
LABEL_6:
    free(v2);
    goto LABEL_7;
  }
  uint64_t v2 = (void *)a1[6];
  if (v2) {
    goto LABEL_6;
  }
LABEL_7:

  free(a1);
}

const void *CGDefaultsGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

uint64_t CGDefaultsGetInteger(const char *a1, int *a2)
{
  return get_integer_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

uint64_t CGDefaultsCopyString(const char *a1, const __CFString **a2)
{
  return copy_string_property(a1, (const void *(*)(const char *))copy_local_domain_value, a2);
}

const void *CGPreferencesGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, copy_preference_value, a2);
}

uint64_t CGPreferencesGetInteger(const char *a1, int *a2)
{
  return get_integer_property(a1, copy_preference_value, a2);
}

uint64_t CGPreferencesGetCGFloat(const char *a1, double *a2)
{
  CFNumberRef v3 = (const __CFNumber *)copy_preference_value(a1);
  if (v3)
  {
    CFNumberRef v4 = v3;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID())
    {
      double valuePtr = 0.0;
      if (CFNumberGetValue(v4, kCFNumberCGFloatType, &valuePtr))
      {
        if (a2)
        {
          DoubleCFDataRef Value = valuePtr;
LABEL_10:
          *a2 = DoubleValue;
          goto LABEL_11;
        }
        goto LABEL_11;
      }
    }
    else if (v5 == CFStringGetTypeID())
    {
      if (a2)
      {
        DoubleCFDataRef Value = CFStringGetDoubleValue((CFStringRef)v4);
        goto LABEL_10;
      }
LABEL_11:
      uint64_t v7 = 1;
LABEL_13:
      CFRelease(v4);
      return v7;
    }
    uint64_t v7 = 0;
    goto LABEL_13;
  }
  return 0;
}

uint64_t CGPreferencesCopyString(const char *a1, const __CFString **a2)
{
  return copy_string_property(a1, copy_preference_value, a2);
}

const void *CGApplicationPropertyGetBoolean(const char *a1, BOOL *a2)
{
  return get_BOOLean_property(a1, copy_application_property_value, a2);
}

CFTypeRef copy_application_property_value(const char *a1)
{
  CFBundleRef MainBundle = CFBundleGetMainBundle();
  if (!MainBundle) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  CFNumberRef v3 = MainBundle;
  CFStringRef v4 = CFStringCreateWithCString(0, a1, 0x600u);
  if (!v4) {
    return 0;
  }
  CFStringRef v5 = v4;
  ValueForInfoDictionaryKedouble y = CFBundleGetValueForInfoDictionaryKey(v3, v4);
  CFRelease(v5);
  if (!ValueForInfoDictionaryKey) {
    return 0;
  }

  return CFRetain(ValueForInfoDictionaryKey);
}

uint64_t CGDefaultsCheck<CGResamplingAllowTemplateMethod>()
{
  if (CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_13614);
  }
  return CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::result;
}

const void *___Z15CGDefaultsCheckI31CGResamplingAllowTemplateMethodENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGResamplingAllowTemplateMethod", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGResamplingAllowTemplateMethod>(void)::uint64_t result = 1;
  }
  return result;
}

uint64_t CGPreferencesCheck<CGResamplingAllowTemplateMethod>()
{
  if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_3_13621);
  }
  return CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result;
}

uint64_t CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>()
{
  if (CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_6_13624);
  }
  return CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
}

const void *___Z15CGDefaultsCheckI32CGImageMarkAllowTemplateMethodFPENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGImageMarkAllowTemplateMethodFP", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGImageMarkAllowTemplateMethodFP>(void)::uint64_t result = 1;
  }
  return result;
}

uint64_t CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>()
{
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_9_13630);
  }
  return CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
}

const void *___Z18CGPreferencesCheckI32CGImageMarkAllowTemplateMethodFPENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGImageMarkAllowTemplateMethodFP", copy_preference_value, (BOOL *)&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::uint64_t result = 1;
  }
  return result;
}

uint64_t CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>()
{
  if (CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_12_13633);
  }
  return CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result;
}

const void *___Z15CGDefaultsCheckI37CGImageMarkAllowTemplateMethodIntegerENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGImageMarkAllowTemplateMethodInteger", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGImageMarkAllowTemplateMethodInteger>(void)::uint64_t result = 1;
  }
  return result;
}

uint64_t CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>()
{
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_15_13639);
  }
  return CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result;
}

uint64_t CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>()
{
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken, &__block_literal_global_18_13644);
  }
  return CGDefaultsCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result;
}

uint64_t CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>()
{
  if (CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::onceToken, &__block_literal_global_21_13648);
  }
  return CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result;
}

uint64_t ___Z18CGPreferencesCheckI35CGPDFDocumentPageResourcesCacheSizeENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_integer_property("CGPDFDocumentPageResourcesCacheSize", copy_preference_value, &CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGPDFDocumentPageResourcesCacheSize>(void)::uint64_t result = 16;
  }
  return result;
}

uint64_t CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>()
{
  if (CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken, &__block_literal_global_24_13653);
  }
  return CGDefaultsCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result;
}

uint64_t CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>()
{
  if (CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::onceToken, &__block_literal_global_27_13657);
  }
  return CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result;
}

const void *___Z18CGPreferencesCheckI38CGPDFDocumentPageResourcesCacheLoggingENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGPDFDocumentPageResourcesCacheLogging", copy_preference_value, (BOOL *)&CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGPDFDocumentPageResourcesCacheLogging>(void)::uint64_t result = 0;
  }
  return result;
}

uint64_t CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>()
{
  if (CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken != -1) {
    dispatch_once(&CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken, &__block_literal_global_30);
  }
  return CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result;
}

const void *___Z15CGDefaultsCheckI37CGPDFPageLayoutSimpleSelectionEnabledENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGPDFPageLayoutSimpleSelectionEnabled", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result);
  if ((result & 1) == 0) {
    CGDefaultsCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::uint64_t result = 1;
  }
  return result;
}

uint64_t CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>()
{
  if (CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::onceToken, &__block_literal_global_33_13661);
  }
  return CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result;
}

const void *___Z18CGPreferencesCheckI37CGPDFPageLayoutSimpleSelectionEnabledENT_10ResultTypeEv_block_invoke()
{
  uint64_t result = get_BOOLean_property("CGPDFPageLayoutSimpleSelectionEnabled", copy_preference_value, (BOOL *)&CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::result);
  if ((result & 1) == 0) {
    CGPreferencesCheck<CGPDFPageLayoutSimpleSelectionEnabled>(void)::uint64_t result = 1;
  }
  return result;
}

char *CGPDFShadingCreateShadingFunction(uint64_t a1, size_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  CGPDFObjectRef value = (CGPDFObjectRef)a1;
  if (!a1 || *(_DWORD *)(a1 + 8) != 7)
  {
    return CGPDFFunctionCreateFunction((char *)a1);
  }
  uint64_t v2 = *(CGPDFArray **)(a1 + 32);
  if (!v2) {
    return 0;
  }
  size_t v3 = *((void *)v2 + 2);
  if (!v3) {
    return 0;
  }
  CFStringRef v5 = (unint64_t *)malloc_type_calloc(1uLL, 8 * v3 + 8, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v5) {
    return 0;
  }
  size_t v6 = 0;
  *CFStringRef v5 = v3;
  do
  {
    if (!CGPDFArrayGetObject(v2, v6, &value)) {
      goto LABEL_36;
    }
    Functiouint64_t n = CGPDFFunctionCreateFunction((char *)value);
    v5[v6 + 1] = (unint64_t)Function;
    if (!Function) {
      goto LABEL_36;
    }
    if (*((void *)Function + 4) != a2)
    {
      pdf_error("invalid shading function domain dimension.");
LABEL_36:
      shading_function_array_release(v5);
      return 0;
    }
    if (*((void *)Function + 6) != 1)
    {
      pdf_error("invalid shading function range dimension.");
      goto LABEL_36;
    }
    ++v6;
  }
  while (v3 != v6);
  *(_OWORD *)domaiuint64_t n = xmmword_1850CDD20;
  if (a2 == 2) {
    long long v22 = xmmword_1850CDD20;
  }
  uint64_t v8 = 0;
  if (v3 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = v3;
  }
  double v10 = 1.79769313e308;
  double v11 = -1.79769313e308;
  double v12 = -1.79769313e308;
  double v13 = 1.79769313e308;
  do
  {
    uint64_t v14 = *(double **)(v5[v8 + 1] + 40);
    double v15 = *v14;
    if (*v14 < v13)
    {
      domain[0] = *v14;
      double v13 = v15;
    }
    double v16 = v14[1];
    if (v16 > v12)
    {
      domain[1] = v14[1];
      double v12 = v16;
    }
    if (a2 != 2) {
      goto LABEL_27;
    }
    double v17 = v14[2];
    if (v17 < v10)
    {
      *(double *)&long long v22 = v14[2];
      double v10 = v17;
    }
    double v18 = v14[3];
    if (v18 > v11) {
      *((double *)&v22 + 1) = v14[3];
    }
    else {
LABEL_27:
    }
      double v18 = v11;
    ++v8;
    double v11 = v18;
  }
  while (v9 != v8);
  uint64_t result = (char *)CGFunctionCreate(v5, a2, domain, v3, 0, &CGPDFShadingCreateShadingFunction_callbacks);
  if (!result) {
    goto LABEL_36;
  }
  return result;
}

void shading_function_array_release(unint64_t *a1)
{
  unint64_t v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = 0;
    do
    {
      CFStringRef v4 = (const void *)a1[v3 + 1];
      if (v4)
      {
        CFRelease(v4);
        unint64_t v2 = *a1;
      }
      ++v3;
    }
    while (v3 < v2);
  }

  free(a1);
}

unint64_t *shading_function_array_evaluate(unint64_t *result, char *a2, double *a3)
{
  if (*result)
  {
    CFStringRef v5 = result;
    unint64_t v6 = 0;
    do
      uint64_t result = (unint64_t *)CGFunctionEvaluate(v5[++v6], a2, a3++);
    while (v6 < *v5);
  }
  return result;
}

void *CPMultiUnicodesCreate()
{
  uint64_t v0 = malloc_type_malloc(0x20uLL, 0x1020040A5B76CDFuLL);
  v0[1] = 0;
  v0[2] = 0;
  *uint64_t v0 = 1;
  v0[3] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  return v0;
}

void CPMultiUnicodesRelease(void *a1)
{
  if (a1)
  {
    if ((*(void *)a1)-- == 1)
    {
      CFArrayRef v3 = (const __CFArray *)*((void *)a1 + 3);
      if (v3)
      {
        CFIndex Count = CFArrayGetCount(v3);
        if (Count >= 1)
        {
          CFIndex v5 = Count;
          for (CFIndex i = 0; i != v5; ++i)
          {
            ValueAtIndeCGFloat x = (void **)CFArrayGetValueAtIndex(*((CFArrayRef *)a1 + 3), i);
            if (ValueAtIndex)
            {
              uint64_t v8 = ValueAtIndex;
              free(ValueAtIndex[3]);
              free(v8);
            }
          }
        }
        CFRelease(*((CFTypeRef *)a1 + 3));
      }
      free(a1);
    }
  }
}

void CPMultiUnicodesAppend(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  if (a1)
  {
    CFArrayRef v5 = *(const __CFArray **)(a1 + 24);
    if (v5)
    {
      CFIndex Count = CFArrayGetCount(v5);
      CFIndex v10 = Count - 1;
      if (Count >= 1)
      {
        uint64_t v11 = *(void *)(a1 + 8);
        if (v11 > a2)
        {
          if (a2 + 1 != v11) {
            return;
          }
          unint64_t v12 = Count;
          ValueAtIndeCGFloat x = (void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v10);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), v10);
          if (ValueAtIndex)
          {
            free(ValueAtIndex[3]);
            free(ValueAtIndex);
          }
          if (v12 < 2)
          {
            *(void *)(a1 + 8) = 0;
            *(void *)(a1 + 16) = 0;
          }
          else
          {
            uint64_t v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v12 - 2);
            if (v14)
            {
              uint64_t v15 = v14[2] + v14[1];
              *(void *)(a1 + 8) = *v14 + 1;
              *(void *)(a1 + 16) = v15;
            }
          }
        }
      }
      double v16 = malloc_type_malloc(0x20uLL, 0x1010040313BCFEBuLL);
      if (v16)
      {
        double v17 = v16;
        *double v16 = a2;
        double v18 = malloc_type_malloc(2 * a3, 0x1000040BDFB0063uLL);
        v17[3] = v18;
        if (v18)
        {
          _OWORD v17[2] = a3;
          memcpy(v18, a4, 2 * a3);
        }
        else
        {
          _OWORD v17[2] = 0;
        }
        v17[1] = *(void *)(a1 + 16) + a2 - *(void *)(a1 + 8);
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), v17);
        uint64_t v19 = v17[2] + v17[1];
        *(void *)(a1 + 8) = a2 + 1;
        *(void *)(a1 + 16) = v19;
      }
    }
  }
}

uint64_t CPMultiUnicodesGetCharacterIndexAtUnicodeIndex(uint64_t a1, unint64_t a2)
{
  if (a1)
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 24);
    if (v4)
    {
      CFIndex Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        CFIndex v6 = Count;
        uint64_t v7 = 0;
        uint64_t v8 = -1;
        do
        {
          uint64_t v9 = v6 + v8;
          if (v6 + v8 < 0 != __OFADD__(v6, v8)) {
            ++v9;
          }
          uint64_t v10 = v9 >> 1;
          ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v9 >> 1);
          if (!ValueAtIndex) {
            break;
          }
          uint64_t v12 = ValueAtIndex[1];
          if (v12 <= (uint64_t)a2)
          {
            if (ValueAtIndex[2] + v12 > a2) {
              return *ValueAtIndex;
            }
            uint64_t v8 = v10;
            uint64_t v10 = v6;
            uint64_t v7 = ValueAtIndex;
          }
          else
          {
            CFIndex v6 = v10;
          }
        }
        while (v8 + 1 < v10);
        if (v7) {
          return a2 + *v7 - (v7[1] + v7[2]) + 1;
        }
      }
    }
  }
  return a2;
}

uint64_t CPMultiUnicodesGetUnicodeRangeAtCharacterIndex(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    CFArrayRef v4 = *(const __CFArray **)(a1 + 24);
    if (v4)
    {
      CFIndex Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        CFIndex v6 = Count;
        uint64_t v7 = 0;
        uint64_t v8 = -1;
        do
        {
          uint64_t v9 = v6 + v8;
          if (v6 + v8 < 0 != __OFADD__(v6, v8)) {
            ++v9;
          }
          uint64_t v10 = v9 >> 1;
          ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v9 >> 1);
          if (!ValueAtIndex) {
            break;
          }
          if (*ValueAtIndex == a2) {
            return ValueAtIndex[1];
          }
          if (*ValueAtIndex >= a2) {
            CFIndex v6 = v10;
          }
          else {
            uint64_t v8 = v10;
          }
          if (*ValueAtIndex < a2) {
            uint64_t v7 = ValueAtIndex;
          }
        }
        while (v8 + 1 < v6);
        if (v7) {
          a2 += ~*v7 + v7[1] + v7[2];
        }
      }
    }
  }
  return a2;
}

uint64_t CPMultiUnicodesGetRangeInCharacterRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 24);
  if (v5) {
    BOOL v6 = a3 < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  CFIndex Count = CFArrayGetCount(v5);
  CFIndex v10 = Count;
  uint64_t v11 = Count - 1;
  if (Count >= 1)
  {
    uint64_t v12 = a3 + a2 - 1;
    uint64_t v13 = -1;
    CFIndex v14 = Count;
    do
    {
      uint64_t v15 = v14 + v13;
      if (v14 + v13 < 0 != __OFADD__(v14, v13)) {
        ++v15;
      }
      uint64_t v16 = v15 >> 1;
      ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v15 >> 1);
      if (!ValueAtIndex) {
        break;
      }
      if (*ValueAtIndex == a2)
      {
        CFIndex v14 = v16;
        break;
      }
      if (*ValueAtIndex >= a2) {
        CFIndex v14 = v16;
      }
      else {
        uint64_t v13 = v16;
      }
    }
    while (v13 + 1 < v14);
    uint64_t v11 = v14 - 1;
    if (v14 < v10)
    {
      do
      {
        uint64_t v18 = v10 + v11;
        if (v10 + v11 < 0 != __OFADD__(v10, v11)) {
          ++v18;
        }
        uint64_t v19 = v18 >> 1;
        BOOL v20 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v18 >> 1);
        if (!v20) {
          break;
        }
        if (*v20 == v12)
        {
          CFIndex v10 = v14;
          uint64_t v11 = v19;
          goto LABEL_31;
        }
        if (*v20 >= v12) {
          CFIndex v10 = v19;
        }
        else {
          uint64_t v11 = v19;
        }
      }
      while (v11 + 1 < v10);
    }
    CFIndex v10 = v14;
  }
LABEL_31:
  if ((unint64_t)(v11 - v10) <= 0x7FFFFFFFFFFFFFFELL) {
    return v10;
  }
  else {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
}

uint64_t CG::Path::append_uneven_rounded_rect(uint64_t this, const CGRect *a2, const CGSize *a3, float64x2_t *a4)
{
  uint64_t v7 = (int *)this;
  if (*(_DWORD *)this)
  {
    CG::Path::reserve_space((CG::Path *)this, 0x12uLL, 0xAuLL);
    double x = a2->origin.x;
    CGFloat v43 = a2->origin.x + a2->size.width;
    double y = a2->origin.y;
    CGFloat v41 = y + a2->size.height;
    v8.n128_f64[0] = v43;
    v8.n128_f64[1] = (v41 + y + a3[2].height - a3[1].height) * 0.5;
    CG::Path::move_to_point(v7, a4, v9, v8);
    CG::Path::add_line_to_point((CG::Path *)v7, (const CGPoint *)a4, v10);
    double width = a3[1].width;
    v12.f64[0] = v43;
    v12.f64[1] = v41 - a3[1].height * 0.44771525;
    v46.double x = v43 - width * 0.44771525;
    v46.double y = v41;
    v45.double x = v43 - width;
    v45.double y = v41;
    CG::Path::add_curve_to_point((CG::Path *)v7, (float64x2_t *)&v46, (float64x2_t *)&v45, a4, v13, v12);
    CG::Path::add_line_to_point((CG::Path *)v7, (const CGPoint *)a4, v14);
    double height = a3->height;
    v16.f64[0] = x + a3->width * 0.44771525;
    v16.f64[1] = v41;
    v46.double x = x;
    v46.double y = v41 - height * 0.44771525;
    v45.double x = x;
    v45.double y = v41 - height;
    CG::Path::add_curve_to_point((CG::Path *)v7, (float64x2_t *)&v46, (float64x2_t *)&v45, a4, v17, v16);
    CG::Path::add_line_to_point((CG::Path *)v7, (const CGPoint *)a4, v18);
    double v19 = a3[3].width;
    v20.f64[0] = x;
    v20.f64[1] = y + a3[3].height * 0.44771525;
    v46.double x = x + v19 * 0.44771525;
    v46.double y = y;
    v45.double x = x + v19;
    v45.double y = y;
    CG::Path::add_curve_to_point((CG::Path *)v7, (float64x2_t *)&v46, (float64x2_t *)&v45, a4, v21, v20);
    CG::Path::add_line_to_point((CG::Path *)v7, (const CGPoint *)a4, v22);
    double v23 = a3[2].height;
    v24.f64[0] = v43 - a3[2].width * 0.44771525;
    v24.f64[1] = y;
    v46.double x = v43;
    v46.double y = y + v23 * 0.44771525;
    v45.double x = v43;
    v45.double y = y + v23;
    CG::Path::add_curve_to_point((CG::Path *)v7, (float64x2_t *)&v46, (float64x2_t *)&v45, a4, v25, v24);
    return CG::Path::close_subpath((uint64_t)v7);
  }
  else
  {
    *(_DWORD *)this = 3;
    origiuint64_t n = a2->origin;
    _D2 = a2->size.width;
    _D1 = a2->size.height;
    if (a4)
    {
      _Q5 = *a4;
      float64x2_t v30 = a4[1];
      _D16 = 0;
      __asm { FMLA            D4, D2, V5.D[1] }
      double v37 = vmlad_n_f64(_D1 * v30.f64[0], 0.0, a4->f64[0]);
      __asm { FMLA            D1, D16, V5.D[1] }
      origiuint64_t n = (CGPoint)vaddq_f64(a4[2], vmlaq_n_f64(vmulq_laneq_f64(v30, (float64x2_t)origin, 1), *a4, origin.x));
      _D2 = vmlad_n_f64(0.0 * v30.f64[0], _D2, a4->f64[0]);
    }
    else
    {
      double v37 = 0.0;
      _D4 = 0;
    }
    uint64_t v38 = 0;
    *(double *)(this + 8) = _D2;
    *(void *)(this + 16) = _D4;
    *(double *)(this + 24) = v37;
    *(double *)(this + 32) = _D1;
    *(CGPoint *)(this + 40) = origin;
    __asm { FMOV            V1.2D, #1.0 }
    float64x2_t v40 = vdivq_f64(_Q1, (float64x2_t)a2->size);
    do
    {
      *(float64x2_t *)(this + 56 + v38 * 16) = vmulq_f64(v40, (float64x2_t)a3[v38]);
      ++v38;
    }
    while (v38 != 4);
  }
  return this;
}

uint64_t CG::Path::append_line_segment(uint64_t this, __n128 *a2, const CGPoint *a3, const CGAffineTransform *a4)
{
  CFArrayRef v4 = (int *)this;
  if (a4)
  {
    double v5 = a2->n128_f64[1];
    double b = a4->b;
    double c = a4->c;
    double d = a4->d;
    tdouble x = a4->tx;
    tdouble y = a4->ty;
    v11.n128_f64[0] = tx + v5 * c + a4->a * a2->n128_f64[0];
    v11.n128_f64[1] = ty + v5 * d + b * a2->n128_f64[0];
    double y = a3->y;
    *(double *)&long long v13 = tx + y * c + a4->a * a3->x;
    *((double *)&v13 + 1) = ty + y * d + b * a3->x;
  }
  else
  {
    __n128 v11 = *a2;
    long long v13 = (__int128)*a3;
  }
  if (*(_DWORD *)this == 8)
  {
    uint64_t v14 = *(unsigned __int16 *)(this + 8);
    if (v14 <= 5)
    {
      *(__n128 *)(this + 16 + 16 * v14) = v11;
      *(_WORD *)(this + 8) = v14 + 2;
      *(_OWORD *)(this + 16 + 16 * v14 + 16) = v13;
      __int16 v15 = *(_WORD *)(this + 10);
      *(_DWORD *)(this + 12) |= 8 << (3 * v15);
      *(_WORD *)(this + 10) = v15 + 2;
      return this;
    }
  }
  else if (!*(_DWORD *)this)
  {
    *(_DWORD *)this = 5;
    *(__n128 *)(this + 8) = v11;
    *(_OWORD *)(this + 24) = v13;
    return this;
  }
  __n128 v18 = v11;
  CG::Path::reserve_space((CG::Path *)this, 2uLL, 2uLL);
  CG::Path::move_to_point(v4, 0, v16, v18);

  return CG::Path::add_line_to_point((CG::Path *)v4, 0, v17);
}

void *CG::Path::append_region(CG::Path *this, void *cf, float64x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)this != 9)
  {
    if (!*(_DWORD *)this)
    {
      if (a3)
      {
        if (fabs(a3->f64[0]) != 1.0 || fabs(a3[1].f64[1]) != 1.0 || a3->f64[1] != 0.0 || a3[1].f64[0] != 0.0) {
          goto LABEL_12;
        }
        double v11 = a3[2].f64[1];
        double v12 = floor(v11);
        if (floor(a3[2].f64[0]) != a3[2].f64[0] || v12 != v11) {
          goto LABEL_12;
        }
        *(_DWORD *)this = 7;
        float64x2_t v19 = a3[1];
        v21[0] = *a3;
        v21[1] = v19;
        v21[2] = a3[2];
        uint64_t result = CGRegionCreateByTransformingRegion(cf, (uint64_t)v21, 1, a4, a5, a6, a7, a8);
      }
      else
      {
        *(_DWORD *)this = 7;
        if (cf) {
          uint64_t result = (void *)CFRetain(cf);
        }
        else {
          uint64_t result = 0;
        }
      }
      *((void *)this + 1) = result;
      return result;
    }
LABEL_12:
    CG::Path::convert_to_huge_(this);
  }
  uint64_t v14 = (const void *)CGSRegionPathEnumerator(cf);
  char v15 = 0;
  while (1)
  {
    int v16 = CGSNextPoint((uint64_t)v14, v20.n128_f64);
    if (!v16) {
      break;
    }
    if (a3) {
      __n128 v20 = (__n128)vaddq_f64(a3[2], vmlaq_n_f64(vmulq_n_f64(a3[1], v20.n128_f64[1]), *a3, v20.n128_f64[0]));
    }
    if (v16 < 0)
    {
      if (v15) {
        CG::Path::close_subpath((uint64_t)this);
      }
      CG::Path::move_to_point((int *)this, 0, v17, v20);
      char v15 = 1;
    }
    else
    {
      CG::Path::add_line_to_point(this, 0, v17);
    }
  }
  if (v15) {
    CG::Path::close_subpath((uint64_t)this);
  }
  return (void *)CGSReleaseRegionEnumerator(v14);
}

uint64_t CG::Path::append_continuous_rounded_rect(CG::Path *this, const CGRect *a2, CGSize a3, float64x2_t *a4)
{
  double height = a3.height;
  double width = a3.width;
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  CG::Path::reserve_space(this, 41, 17);
  uint64_t v10 = 0;
  double x = a2->origin.x;
  double y = a2->origin.y;
  double v13 = a2->size.width;
  double v14 = a2->size.height;
  double v15 = (v14 * 0.5 / height + -1.52866) / -0.52866;
  if (v15 > 1.0) {
    double v15 = 1.0;
  }
  if (v15 < 0.0) {
    double v15 = 0.0;
  }
  double v16 = (v13 * 0.5 / width + -1.52866) / -0.52866;
  if (v16 > 1.0) {
    double v16 = 1.0;
  }
  if (v16 < 0.0) {
    double v16 = 0.0;
  }
  float64x2_t v17 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - v16), 0);
  float64x2_t v18 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(1.0 - v15), 0);
  do
  {
    float64x2_t v19 = (float64x2_t)CG::Path::append_continuous_rounded_rect(CGRect const&,CGSize,CGAffineTransform const*)::continuous[v10];
    float64x2_t v20 = (float64x2_t)CG::Path::append_continuous_rounded_rect(CGRect const&,CGSize,CGAffineTransform const*)::circular[v10];
    *(float64x2_t *)((char *)&v103 + v10 * 16) = vmlaq_f64(vmulq_n_f64(v20, v16), v17, v19);
    *(float64x2_t *)((char *)&v93 + v10 * 16) = vmlaq_f64(vmulq_n_f64(v20, v15), v18, v19);
    ++v10;
  }
  while (v10 != 5);
  double v21 = y + v14;
  double v22 = x + v13;
  double v83 = v102;
  double v90 = v93;
  v23.n128_f64[0] = x + width * v102;
  CGFloat v82 = y + height * v93;
  v23.n128_f64[1] = v82;
  CG::Path::move_to_point((int *)this, a4, v9, v23);
  double v75 = v101;
  double v71 = v100;
  v24.f64[0] = x + width * v101;
  double v87 = v94;
  double v89 = v95;
  CGFloat v74 = y + height * v94;
  v24.f64[1] = v74;
  CGFloat v73 = y + height * v95;
  v92.double x = x + width * v100;
  v92.double y = v73;
  double v66 = v99;
  double v88 = v96;
  CGFloat v65 = y + height * v96;
  v91.double x = x + width * v99;
  v91.double y = v65;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v25, v24);
  double v85 = v97;
  v26.f64[0] = x + width * v98;
  double v79 = v98;
  CGFloat v64 = y + height * v97;
  v26.f64[1] = v64;
  double v61 = v106;
  double v62 = v107;
  v92.double x = x + width * v107;
  v92.double y = y + height * v98;
  double v81 = v109;
  CGFloat v60 = y + height * v109;
  v91.double x = x + width * v106;
  v91.double y = v60;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v27, v26);
  double v28 = v104;
  double v67 = v105;
  double v80 = v110;
  v29.f64[0] = x + width * v105;
  CGFloat v59 = y + height * v110;
  v29.f64[1] = v59;
  double v30 = v103;
  double v77 = v111;
  double v78 = v112;
  CGFloat v58 = y + height * v111;
  v92.double x = x + width * v104;
  v92.double y = v58;
  CGFloat v86 = x + width * v103;
  CGFloat v69 = y + height * v112;
  v91.double x = v86;
  v91.double y = v69;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v31, v29);
  v32.f64[0] = v22 - width * v30;
  v32.f64[1] = v69;
  CG::Path::add_line_to_point(this, a4, v33, v32);
  v34.f64[0] = v22 - width * v28;
  CGFloat v70 = v34.f64[0];
  v34.f64[1] = v58;
  CGFloat v68 = v22 - width * v67;
  v92.double x = v68;
  v92.double y = v59;
  v91.double x = v22 - width * v61;
  v91.double y = v60;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v35, v34);
  CGFloat v63 = v22 - width * v62;
  v36.f64[0] = v63;
  double v37 = v108;
  v36.f64[1] = y + height * v108;
  v92.double x = v22 - width * v108;
  v92.double y = v64;
  v91.double x = v22 - width * v66;
  v91.double y = v65;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v38, v36);
  CGFloat v72 = v22 - width * v71;
  v39.f64[0] = v72;
  v39.f64[1] = v73;
  CGFloat v76 = v22 - width * v75;
  v92.double x = v76;
  v92.double y = v74;
  CGFloat v84 = v22 - width * v83;
  v91.double x = v84;
  v91.double y = v82;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v40, v39);
  v41.f64[0] = v84;
  v41.f64[1] = v21 - height * v90;
  CG::Path::add_line_to_point(this, a4, v42, v41);
  v43.f64[0] = v76;
  v43.f64[1] = v21 - height * v87;
  v92.double x = v72;
  v92.double y = v21 - height * v89;
  v91.double x = v22 - width * v66;
  v91.double y = v21 - height * v88;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v44, v43);
  v45.f64[0] = v22 - width * v79;
  v45.f64[1] = v21 - height * v85;
  v92.double x = v63;
  v92.double y = v21 - height * v79;
  v91.double x = v22 - width * v61;
  v91.double y = v21 - height * v81;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v46, v45);
  v47.f64[0] = v68;
  v47.f64[1] = v21 - height * v80;
  v92.double x = v70;
  v92.double y = v21 - height * v77;
  v91.double x = v22 - width * v30;
  v91.double y = v21 - height * v78;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v48, v47);
  v49.f64[0] = v86;
  v49.f64[1] = v21 - height * v78;
  CG::Path::add_line_to_point(this, a4, v50, v49);
  v51.f64[0] = x + width * v104;
  v51.f64[1] = v21 - height * v111;
  v92.double x = x + width * v105;
  v92.double y = v21 - height * v110;
  v91.double x = x + width * v106;
  v91.double y = v21 - height * v109;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v52, v51);
  v53.f64[0] = x + width * v107;
  v53.f64[1] = v21 - height * v37;
  v92.double x = x + width * v37;
  v92.double y = v21 - height * v97;
  v91.double x = x + width * v99;
  v91.double y = v21 - height * v96;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v54, v53);
  v55.f64[0] = x + width * v100;
  v55.f64[1] = v21 - height * v95;
  v92.double x = x + width * v101;
  v92.double y = v21 - height * v94;
  v91.double x = x + width * v102;
  v91.double y = v21 - height * v93;
  CG::Path::add_curve_to_point(this, (float64x2_t *)&v92, (float64x2_t *)&v91, a4, v56, v55);

  return CG::Path::close_subpath((uint64_t)this);
}

uint64_t CG::Path::is_rounded_rect(CG::Path *this, CGRect *a2, float64x2_t *a3, CGAffineTransform *a4)
{
  if (*(_DWORD *)this == 2)
  {
    if (a4)
    {
      if (a2) {
        *a2 = unit_rect;
      }
      if (a3) {
        *a3 = *(float64x2_t *)((char *)this + 56);
      }
      long long v7 = *(_OWORD *)((char *)this + 8);
      long long v8 = *(_OWORD *)((char *)this + 40);
      *(_OWORD *)&a4->double c = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&a4->tdouble x = v8;
      *(_OWORD *)&a4->a = v7;
      return 1;
    }
    uint64_t v9 = (_OWORD *)((char *)this + 8);
    if (*((double *)this + 2) == 0.0 && *((double *)this + 3) == 0.0
      || *(double *)v9 == 0.0 && *((double *)this + 4) == 0.0)
    {
      if (a2)
      {
        long long v10 = *(_OWORD *)((char *)this + 24);
        *(_OWORD *)&v15.a = *v9;
        *(_OWORD *)&v15.double c = v10;
        *(_OWORD *)&v15.tdouble x = *(_OWORD *)((char *)this + 40);
        a2->origin.double x = transform_unit_rect(&v15);
        a2->origin.double y = v11;
        a2->size.double width = v12;
        a2->size.double height = v13;
      }
      if (a3) {
        *a3 = vabsq_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)((char *)this + 24), *((double *)this + 8)), *(float64x2_t *)((char *)this + 8), *((double *)this + 7)));
      }
      return 1;
    }
  }
  return 0;
}

uint64_t CG::Path::is_ellipse(CG::Path *this, CGRect *a2, BOOL *a3, BOOL *a4, CGAffineTransform *a5)
{
  if (*(_DWORD *)this == 4)
  {
    if (a4)
    {
      if (a2) {
        *a2 = unit_rect;
      }
      if (a3) {
        *a3 = *((unsigned char *)this + 56);
      }
      long long v8 = *(_OWORD *)((char *)this + 8);
      long long v9 = *(_OWORD *)((char *)this + 40);
      *((_OWORD *)a4 + 1) = *(_OWORD *)((char *)this + 24);
      *((_OWORD *)a4 + 2) = v9;
      *(_OWORD *)a4 = v8;
      return 1;
    }
    long long v10 = (_OWORD *)((char *)this + 8);
    if (*((double *)this + 2) == 0.0 && *((double *)this + 3) == 0.0
      || *(double *)v10 == 0.0 && *((double *)this + 4) == 0.0)
    {
      long long v11 = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&v16.a = *v10;
      *(_OWORD *)&v16.double c = v11;
      *(_OWORD *)&v16.tdouble x = *(_OWORD *)((char *)this + 40);
      if (a2)
      {
        a2->origin.double x = transform_unit_rect(&v16);
        a2->origin.double y = v12;
        a2->size.double width = v13;
        a2->size.double height = v14;
      }
      if (a3) {
        *a3 = *((unsigned char *)this + 56);
      }
      return 1;
    }
  }
  return 0;
}

BOOL CG::Path::contains_point(CG::Path *this, const CGPoint *a2, BOOL a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  switch(*(_DWORD *)this)
  {
    case 0:
      return v11;
    case 1:
      if (*((double *)this + 2) != 0.0 || *((double *)this + 3) != 0.0) {
        goto LABEL_12;
      }
      long long v12 = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&v37.a = *(_OWORD *)((char *)this + 8);
      *(_OWORD *)&v37.double c = v12;
      *(_OWORD *)&v37.tdouble x = *(_OWORD *)((char *)this + 40);
      double v13 = transform_unit_rect(&v37);
      double v17 = v13 + v16;
      if (a2->x < v13 || a2->x > v17) {
        return 0;
      }
      double y = a2->y;
      return y >= v14 && y <= v14 + v15;
    case 8:
      if (!*((_WORD *)this + 5)) {
        return 0;
      }
      goto LABEL_12;
    case 9:
      if (!*((void *)this + 2)) {
        return 0;
      }
      uint64_t v20 = 0;
      unint64_t v21 = 0;
      v34[0] = 0;
      int v35 = 0;
      float64x2_t v36 = *(float64x2_t *)a2;
      CGPoint v33 = (CGPoint)0;
      uint64_t v22 = -1;
      break;
    default:
LABEL_12:
      CG::Path::Path((CG::Path *)&v38, this);
      if (LODWORD(v38.x) != 9) {
        CG::Path::convert_to_huge_((CG::Path *)&v38);
      }
      uint64_t v11 = CG::Path::contains_point((CG::Path *)&v38, a2, a3);
      CG::Path::~Path((void **)&v38);
      return v11;
  }
  do
  {
    uint64_t v23 = *((void *)this + 4);
    switch(*(unsigned char *)(v23 + *((void *)this + 3) + v22))
    {
      case 0:
        uint64_t v24 = 0;
        CGPoint v38 = (CGPoint)vsubq_f64(*(float64x2_t *)(v23 + 16 * v20), v36);
        break;
      case 1:
      case 4:
        CGPoint v38 = v33;
        float64x2_t v39 = vsubq_f64(*(float64x2_t *)(v23 + 16 * v20), v36);
        uint64_t v24 = 1;
        break;
      case 2:
        CGPoint v38 = v33;
        float64x2_t v26 = *(float64x2_t *)(v23 + 16 * v20++);
        float64x2_t v39 = vsubq_f64(v26, v36);
        float64x2_t v40 = vsubq_f64(*(float64x2_t *)(v23 + 16 * v20), v36);
        uint64_t v24 = 2;
        break;
      case 3:
        CGPoint v38 = v33;
        uint64_t v25 = (float64x2_t *)(v23 + 16 * v20);
        float64x2_t v39 = vsubq_f64(*v25, v36);
        v20 += 2;
        float64x2_t v40 = vsubq_f64(v25[1], v36);
        float64x2_t v41 = vsubq_f64(*(float64x2_t *)(v23 + 16 * v20), v36);
        uint64_t v24 = 3;
        break;
      default:
        abort();
    }
    uint64_t v27 = &v38 + v24;
    CGPoint v33 = *v27;
    if (v34[0]) {
      return 1;
    }
    ++v20;
    ++v21;
    unint64_t v28 = *((void *)this + 2);
    --v22;
  }
  while (v21 < v28);
  uint64_t v29 = *((void *)this + 4);
  if (*(unsigned char *)(v29 + *((void *)this + 3) - v28) == 4
    || (CGPoint v38 = *v27,
        float64x2_t v39 = vsubq_f64(*(float64x2_t *)(v29 + 16 * *((void *)this + 9)), v36),
        uint64_t v11 = 1,
        !v34[0]))
  {
    int v30 = v35;
    int v31 = v35 & 1;
    if (v35 < 0) {
      int v31 = -v31;
    }
    if (a3) {
      int v30 = v31;
    }
    return v30 != 0;
  }
  return v11;
}

void sub_184F4F0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  CG::Path::~Path((void **)va);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::Crossings::evaluate_crossings(uint64_t this, uint64_t a2, float64x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)this)
  {
    uint64_t v8 = this;
    long long v9 = &a3->f64[1];
    uint64_t v10 = -1;
    while ((*(void *)(v9 - 1) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
         && (*(void *)v9 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
    {
      v9 += 2;
      if (a2 == ++v10)
      {
        if (a2)
        {
          this = crossing_count(a3, a2, (unsigned char *)this, a4, a5, a6, a7, a8);
          *(_DWORD *)(v8 + 4) += this;
        }
        return this;
      }
    }
  }
  return this;
}

unint64_t CG::Path::point_count(CG::Path *this, int32x2_t a2)
{
  switch(*(_DWORD *)this)
  {
    case 1:
      unint64_t v2 = 4;
      goto LABEL_16;
    case 2:
    case 3:
      unint64_t v2 = 17;
      goto LABEL_16;
    case 4:
      unint64_t v2 = 13;
      goto LABEL_16;
    case 5:
      unint64_t v2 = 2;
      goto LABEL_16;
    case 6:
      unint64_t v2 = (unint64_t)(ceil(fmax(*((double *)this + 7) + -0.00000001, 0.0) / 1.57079633) * 3.0 + 1.0);
      goto LABEL_16;
    case 7:
      CG::Path::Path((CG::Path *)v14, this);
      if (LODWORD(v14[0]) != 9) {
        CG::Path::convert_to_huge_((CG::Path *)v14);
      }
      unint64_t v2 = CG::Path::point_count((CG::Path *)v14);
      CG::Path::~Path(v14);
      goto LABEL_16;
    case 8:
      unint64_t v2 = *((unsigned __int16 *)this + 4);
      int v3 = *((unsigned __int16 *)this + 5);
      if (!*((_WORD *)this + 5)) {
        goto LABEL_16;
      }
      CFArrayRef v4 = (const float *)((char *)this + 12);
      int v5 = (v3 + 1) & 0x1FFFE;
      int8x16_t v6 = (int8x16_t)*((unsigned __int16 *)this + 4);
      int32x2_t v7 = (int32x2_t)0x100000000;
      uint32x2_t v8 = (uint32x2_t)vld1_dup_f32(v4);
      do
      {
        int8x16_t v9 = v6;
        uint32x2_t v10 = (uint32x2_t)v7;
        int8x16_t v6 = (int8x16_t)vaddw_s32((int64x2_t)v6, vceq_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32(v8, (uint32x2_t)vneg_s32(vmul_s32(v7, (int32x2_t)0x300000003))), (int8x8_t)0x700000007), (int32x2_t)0x400000004));
        int32x2_t v7 = vadd_s32(v7, (int32x2_t)0x200000002);
        v5 -= 2;
      }
      while (v5);
      a2.i32[0] = v3 - 1;
      uint32x2_t v11 = vcgt_u32(v10, (uint32x2_t)vdup_lane_s32(a2, 0));
      v12.i64[0] = v11.i32[0];
      v12.i64[1] = v11.i32[1];
      unint64_t result = vaddvq_s64((int64x2_t)vbslq_s8(v12, v9, v6));
      break;
    case 9:
      unint64_t v2 = *((void *)this + 1) - *((void *)this + 10);
      goto LABEL_16;
    default:
      unint64_t v2 = 0;
LABEL_16:
      unint64_t result = v2;
      break;
  }
  return result;
}

void sub_184F4F374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void create_initialized_encoding_buffer(uint64_t a1, CFIndex a2, int a3)
{
  *(_DWORD *)int8x16_t v6 = a3;
  CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  *(void *)a1 = Mutable;
  if (*(unsigned char *)(a1 + 8)) {
    int v5 = 65537;
  }
  else {
    int v5 = 1;
  }
  *(_DWORD *)bytes = v5;
  CFDataAppendBytes(Mutable, bytes, 4);
  CFDataAppendBytes(*(CFMutableDataRef *)a1, v6, 1);
}

void encode_CGAffineTransform(uint64_t a1, double *a2)
{
  encode_CGFloat(a1, *a2);
  encode_CGFloat(a1, a2[1]);
  encode_CGFloat(a1, a2[2]);
  encode_CGFloat(a1, a2[3]);
  encode_CGFloat(a1, a2[4]);
  double v4 = a2[5];

  encode_CGFloat(a1, v4);
}

void encode_CGFloat(uint64_t a1, double a2)
{
  *(double *)bytes = a2;
  if (*(unsigned char *)(a1 + 8))
  {
    float v5 = a2;
    float v6 = v5;
    unint64_t v2 = *(__CFData **)a1;
    int v3 = (UInt8 *)&v6;
    CFIndex v4 = 4;
  }
  else
  {
    unint64_t v2 = *(__CFData **)a1;
    int v3 = bytes;
    CFIndex v4 = 8;
  }
  CFDataAppendBytes(v2, v3, v4);
}

uint64_t decode_CGAffineTransform(uint64_t a1, double *a2)
{
  int v4 = decode_CGFloat(a1, a2);
  int v5 = v4 & decode_CGFloat(a1, a2 + 1);
  int v6 = decode_CGFloat(a1, a2 + 2);
  int v7 = v5 & v6 & decode_CGFloat(a1, a2 + 3);
  int v8 = decode_CGFloat(a1, a2 + 4);
  return v7 & v8 & decode_CGFloat(a1, a2 + 5);
}

uint64_t decode_CGFloat(uint64_t a1, double *a2)
{
  unint64_t v2 = *(void *)(a1 + 24);
  if (*(unsigned char *)(a1 + 8))
  {
    double v5 = 0.0;
    if ((v2 & 0x8000000000000000) != 0 || (uint64_t v6 = *(void *)(a1 + 16), v6 + 4 > v2))
    {
      uint64_t result = 0;
    }
    else
    {
      float v7 = *(float *)(*(void *)a1 + v6);
      *(void *)(a1 + 16) = v6 + 4;
      double v5 = v7;
      uint64_t result = 1;
    }
    *a2 = v5;
  }
  else
  {
    if ((v2 & 0x8000000000000000) != 0) {
      return 0;
    }
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3 + 8 > v2)
    {
      return 0;
    }
    else
    {
      *a2 = *(double *)(*(void *)a1 + v3);
      *(void *)(a1 + 16) += 8;
      return 1;
    }
  }
  return result;
}

void *text_layout_reset(void *result)
{
  uint64_t v1 = (void **)result;
  unint64_t v2 = (void *)*result;
  if (*result)
  {
    do
    {
      text_chunk_release((void **)v2[1]);
      unint64_t v2 = (void *)*v2;
    }
    while (v2);
    uint64_t result = *v1;
    if (*v1)
    {
      do
      {
        uint64_t v3 = (void *)*result;
        free(result);
        uint64_t result = v3;
      }
      while (v3);
    }
  }
  void *v1 = 0;
  return result;
}

void text_chunk_release(void **a1)
{
  if (a1)
  {
    free(a1[14]);
    free(a1[15]);
    free(a1[16]);
    free(a1[17]);
    free(a1);
  }
}

void CGPDFTextLayoutAppendString(uint64_t *a1, uint64_t a2, uint64_t a3, double *a4)
{
  if (a1)
  {
    float v7 = (double *)text_chunk_create(a1, a2);
    if (v7)
    {
      int v8 = v7;
      if (*((unsigned char *)v7 + 17))
      {
        text_chunk_append_cids(v7, a2, a3);
        if (!a4) {
          return;
        }
      }
      else
      {
        text_chunk_append_simple((uint64_t)v7, a2, a3);
        if (!a4) {
          return;
        }
      }
      double v9 = v8[6];
      if (*((unsigned char *)v8 + 16))
      {
        double v10 = v9 * v8[7] * v8[3];
        double v11 = 0.0;
      }
      else
      {
        double v11 = v9 * v8[4];
        double v10 = 0.0;
      }
      *a4 = v10;
      a4[1] = v11;
    }
  }
}

void *text_chunk_create(uint64_t *a1, uint64_t a2)
{
  int v4 = malloc_type_calloc(1uLL, 0x90uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *(void *)int v4 = 0;
  *((void *)v4 + 1) = 0;
  unint64_t v5 = *(void *)(a2 + 48);
  *((void *)v4 + 5) = v5;
  double v6 = *(double *)(a2 + 56);
  *((double *)v4 + 6) = v6;
  if (!v5 || v6 == 0.0)
  {
    text_chunk_release((void **)v4);
    return 0;
  }
  else
  {
    *((double *)v4 + 7) = *(double *)(a2 + 16) / 100.0;
    unint64_t CMap = CGPDFFontGetCMap(v5);
    unint64_t v8 = CMap;
    BOOL v10 = !CMap
       || !cmap_vtable
       || (double v9 = *(unsigned int (**)(void))(cmap_vtable + 40)) == 0
       || v9(*(void *)(CMap + 16)) == 0;
    *((unsigned char *)v4 + 16) = v10;
    *((unsigned char *)v4 + 17) = v8 != 0;
    double v11 = *((double *)v4 + 6);
    float64x2_t v12 = *(float64x2_t *)(a2 + 120);
    float64x2_t v13 = *(float64x2_t *)(a2 + 136);
    float64x2_t v14 = vaddq_f64(*(float64x2_t *)(a2 + 152), vmlaq_f64(vmulq_n_f64(v13, *(double *)(a2 + 32)), (float64x2_t)0, v12));
    *((float64x2_t *)v4 + 4) = vmlaq_n_f64(vmulq_f64(v13, (float64x2_t)0), v12, v11 * *((double *)v4 + 7));
    *((float64x2_t *)v4 + 5) = vmlaq_f64(vmulq_n_f64(v13, v11), (float64x2_t)0, v12);
    *((float64x2_t *)v4 + 6) = v14;
    *((_OWORD *)v4 + 7) = 0u;
    *((_OWORD *)v4 + 8) = 0u;
    uint64_t v15 = *a1;
    double v16 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    *double v16 = v15;
    v16[1] = v4;
    *a1 = (uint64_t)v16;
  }
  return v4;
}

void text_chunk_append_cids(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (*(void *)(a3 + 24)) {
      decrypt_string(a3);
    }
    size_t v6 = *(void *)(a3 + 72);
  }
  else
  {
    size_t v6 = 0;
  }
  uint64_t v7 = text_chunk_require_size((uint64_t)a1, a1[1] + v6);
  if (v7)
  {
    double v61 = &v59;
    MEMORY[0x1F4188790](v7, v8);
    CGFloat v60 = (char *)&v59 - v9;
    if (v6 == -1) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = (char *)&v59 - v9;
    }
    if (v6 + 1 >= 0x66) {
      BOOL v10 = (char *)malloc_type_malloc(v6, 0x1780CF22uLL);
    }
    double v11 = (unsigned __int16 *)(a1[15] + 2 * a1[1]);
    unint64_t CMap = CGPDFFontGetCMap(a1[5]);
    if (a3)
    {
      if (*(void *)(a3 + 24)) {
        decrypt_string(a3);
      }
      float64x2_t v14 = (unsigned char *)(a3 + 80);
    }
    else
    {
      float64x2_t v14 = 0;
    }
    uint64_t CIDsForText = CGPDFCMapGetCIDsForText(CMap, v14, v6, (uint64_t)v11, (uint64_t)v10, v13);
    uint64_t v16 = a1[1];
    uint64_t v17 = a1[16];
    uint64_t v18 = a1[17];
    float64x2_t v19 = (double *)(v18 + 8 * v16);
    *(void *)&long long v20 = a1[3];
    long long v65 = v20;
    *(void *)&long long v20 = a1[4];
    long long v64 = v20;
    unint64_t v21 = CGPDFFontGetCMap(*(void *)(a2 + 48));
    double v62 = a1;
    uint64_t v59 = CIDsForText;
    if (v21
      && cmap_vtable
      && (uint64_t v22 = *(unsigned int (**)(void))(cmap_vtable + 40)) != 0
      && v22(*(void *)(v21 + 16)))
    {
      uint64_t v23 = *(void ****)(a2 + 48);
      float64x2_t v66 = 0uLL;
      uint64_t v24 = (const CGAffineTransform *)(v23 + 7);
      if (!v23) {
        uint64_t v24 = &CGAffineTransformIdentity;
      }
      double a = v24->a;
      double v26 = *(double *)(a2 + 56);
      double v27 = *(double *)a2;
      double v28 = *(double *)(a2 + 8);
      Advances = CGPDFFontGetAdvances(v23);
      if (CIDsForText)
      {
        uint64_t v30 = (uint64_t)Advances;
        int v31 = (float64x2_t *)(v17 + 16 * v16);
        double v32 = v27 / v26;
        float64x2_t v63 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(-a), 0);
        CGPoint v33 = v10;
        double v34 = v28 / v26;
        long long v35 = v64;
        do
        {
          long long v64 = v35;
          unsigned int v37 = *v11++;
          unint64_t v36 = v37;
          if (v18) {
            *float64x2_t v19 = a * CGPDFAdvancesGetHorizontalAdvance(v30, v36);
          }
          double VerticalAdvance = CGPDFAdvancesGetVerticalAdvance(v30, v36, (uint64_t)&v66);
          long long v35 = v64;
          if (v17)
          {
            *(void *)&v39.f64[0] = v65;
            *(void *)&v39.f64[1] = v64;
            float64x2_t *v31 = vmlaq_f64(v39, v66, v63);
          }
          *(double *)&long long v35 = *(double *)&v35 + v32 + a * VerticalAdvance;
          if (v10)
          {
            double v40 = -0.0;
            if (*v33) {
              double v40 = v34;
            }
            *(double *)&long long v35 = *(double *)&v35 + v40;
          }
          ++v33;
          ++v31;
          ++v19;
          --CIDsForText;
        }
        while (CIDsForText);
      }
      else
      {
        *(void *)&long long v35 = v64;
      }
      CGFloat v58 = v62;
      v62[3] = v65;
      v58[4] = v35;
    }
    else
    {
      float64x2_t v41 = *(void ****)(a2 + 48);
      uint64_t v42 = (const CGAffineTransform *)(v41 + 7);
      if (!v41) {
        uint64_t v42 = &CGAffineTransformIdentity;
      }
      double v43 = v42->a;
      double v44 = *(double *)(a2 + 56);
      double v45 = *(double *)a2;
      double v46 = *(double *)(a2 + 8);
      float64x2_t v47 = CGPDFFontGetAdvances(v41);
      if (CIDsForText)
      {
        uint64_t v48 = (uint64_t)v47;
        uint64_t v49 = CIDsForText;
        double v50 = v45 / v44;
        float64x2_t v51 = (void *)(v17 + 16 * v16 + 8);
        long long v52 = v10;
        double v53 = v46 / v44;
        uint64_t v54 = v64;
        long long v55 = v65;
        do
        {
          if (v17)
          {
            *(v51 - 1) = v55;
            *float64x2_t v51 = v54;
          }
          long long v65 = v55;
          double v56 = v43 * CGPDFAdvancesGetHorizontalAdvance(v48, *v11);
          if (v18) {
            *float64x2_t v19 = v56;
          }
          *((void *)&v55 + 1) = *((void *)&v65 + 1);
          *(double *)&long long v55 = *(double *)&v65 + v50 + v56;
          if (v10)
          {
            double v57 = -0.0;
            if (*v52) {
              double v57 = v53;
            }
            *(double *)&long long v55 = *(double *)&v55 + v57;
          }
          uint64_t v54 = v64;
          ++v52;
          ++v19;
          ++v11;
          v51 += 2;
          --v49;
        }
        while (v49);
      }
      else
      {
        uint64_t v54 = v64;
        *(void *)&long long v55 = v65;
      }
      CGFloat v58 = v62;
      v62[3] = v55;
      v58[4] = v54;
    }
    v58[1] += v59;
    if (v10 != v60) {
      free(v10);
    }
  }
}

void text_chunk_append_simple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
  {
    if (text_chunk_require_size(a1, *(void *)(a1 + 8)))
    {
      size_t v6 = 0;
      uint64_t v7 = 0;
      goto LABEL_10;
    }
LABEL_22:
    abort();
  }
  if (*(void *)(a3 + 24)) {
    decrypt_string(a3);
  }
  size_t v6 = *(void *)(a3 + 72);
  if ((text_chunk_require_size(a1, *(void *)(a1 + 8) + v6) & 1) == 0) {
    goto LABEL_22;
  }
  if (*(void *)(a3 + 24)) {
    decrypt_string(a3);
  }
  uint64_t v7 = (unsigned __int8 *)(a3 + 80);
LABEL_10:
  memmove((void *)(*(void *)(a1 + 112) + *(void *)(a1 + 8)), v7, v6);
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 128);
  uint64_t v10 = *(void *)(a1 + 136);
  double v12 = *(double *)(a1 + 24);
  uint64_t v11 = *(void *)(a1 + 32);
  __n128 v13 = *(void ****)(a2 + 48);
  float64x2_t v14 = (const CGAffineTransform *)(v13 + 7);
  if (!v13) {
    float64x2_t v14 = &CGAffineTransformIdentity;
  }
  double a = v14->a;
  double v16 = *(double *)(a2 + 56);
  double v17 = *(double *)a2;
  double v18 = *(double *)(a2 + 8);
  Advances = CGPDFFontGetAdvances(v13);
  size_t v30 = v6;
  if (v6)
  {
    uint64_t v20 = (uint64_t)Advances;
    unint64_t v21 = (double *)(v10 + 8 * v8);
    double v22 = v17 / v16;
    uint64_t v23 = (double *)(v9 + 16 * v8 + 8);
    size_t v24 = v6;
    double v25 = v18 / v16;
    do
    {
      if (v9)
      {
        *(v23 - 1) = v12;
        *(void *)uint64_t v23 = v11;
      }
      int v26 = *v7;
      double v27 = a * CGPDFAdvancesGetHorizontalAdvance(v20, *v7);
      if (v10)
      {
        *unint64_t v21 = v27;
        int v26 = *v7;
      }
      double v28 = v12 + v22 + v27;
      double v29 = -0.0;
      if (v26 == 32) {
        double v29 = v25;
      }
      double v12 = v28 + v29;
      ++v21;
      ++v7;
      v23 += 2;
      --v24;
    }
    while (v24);
  }
  *(double *)(a1 + 24) = v12;
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 8) += v30;
}

uint64_t text_chunk_require_size(uint64_t a1, unint64_t a2)
{
  if (*(void *)a1 >= a2) {
    return 1;
  }
  unint64_t v3 = a2 + 20;
  uint64_t result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 112), a2 + 20, 0x100004077774924uLL);
  if (result)
  {
    *(void *)(a1 + 112) = result;
    uint64_t result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 120), 2 * v3, 0x1000040BDFB0063uLL);
    if (result)
    {
      *(void *)(a1 + 120) = result;
      uint64_t result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 128), 16 * v3, 0x1000040451B5BE8uLL);
      if (result)
      {
        *(void *)(a1 + 128) = result;
        uint64_t result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 136), 8 * v3, 0x100004000313F17uLL);
        if (result)
        {
          *(void *)(a1 + 136) = result;
          *(void *)a1 = v3;
          return 1;
        }
      }
    }
  }
  return result;
}

void CGPDFTextLayoutAppendStrings(uint64_t *a1, uint64_t a2, CGPDFArray *a3, double *a4)
{
  if (a1)
  {
    uint64_t v7 = text_chunk_create(a1, a2);
    if (v7)
    {
      uint64_t v8 = (uint64_t)v7;
      if (a3)
      {
        uint64_t v9 = *((void *)a3 + 2);
        if (v9)
        {
          size_t v10 = 0;
          uint64_t v15 = 0;
          CGPDFReal value = 0.0;
          do
          {
            if (CGPDFArrayGetString(a3, v10, (CGPDFStringRef *)&v15))
            {
              if (*(unsigned char *)(v8 + 17)) {
                text_chunk_append_cids((void *)v8, a2, v15);
              }
              else {
                text_chunk_append_simple(v8, a2, v15);
              }
            }
            else if (CGPDFArrayGetNumber(a3, v10, &value))
            {
              double v11 = value / 1000.0;
              if (*(unsigned char *)(v8 + 16)) {
                *(double *)(v8 + 24) = *(double *)(v8 + 24) - v11;
              }
              else {
                *(double *)(v8 + 32) = *(double *)(v8 + 32) - v11;
              }
            }
            ++v10;
          }
          while (v9 != v10);
        }
      }
      if (a4)
      {
        double v12 = *(double *)(v8 + 48);
        if (*(unsigned char *)(v8 + 16))
        {
          double v13 = v12 * *(double *)(v8 + 56) * *(double *)(v8 + 24);
          double v14 = 0.0;
        }
        else
        {
          double v14 = v12 * *(double *)(v8 + 32);
          double v13 = 0.0;
        }
        *a4 = v13;
        a4[1] = v14;
      }
    }
  }
}

void *CGPDFTextLayoutDrawGlyphs(void *result, void (*a2)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, char *, char *, void, uint64_t), uint64_t a3, __n128 a4)
{
  if (result && a2)
  {
    unint64_t v5 = result;
    size_t v6 = (void *)*result;
    if (*result)
    {
      uint64_t v8 = 0;
      do
      {
        uint64_t v9 = v6;
        size_t v6 = (void *)*v6;
        *uint64_t v9 = v8;
        uint64_t v8 = v9;
      }
      while (v6);
      *uint64_t result = v9;
      do
      {
        uint64_t v10 = v9[1];
        if (*(unsigned char *)(v10 + 17)) {
          cid_draw(v10, a2, a3, a4);
        }
        else {
          simple_draw(v10, (void (*)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, char *, void, uint64_t, uint64_t))a2, a3, a4);
        }
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      *uint64_t result = 0;
    }
    return text_layout_reset(v5);
  }
  return result;
}

void cid_draw(uint64_t a1, void (*a2)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, char *, char *, void, uint64_t), uint64_t a3, __n128 a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a4);
  uint64_t v10 = (char *)&v25 - v9;
  if (v8 <= 0x7FFFFFFFFFFFFFFELL) {
    double v11 = (char *)&v25 - v9;
  }
  else {
    double v11 = 0;
  }
  if (v8 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000066) {
    double v11 = (char *)malloc_type_malloc(2 * v7, 0x9D9DABE0uLL);
  }
  CIDToGlyphMap = (__int16 *)CGPDFFontGetCIDToGlyphMap(*(void *)(a1 + 40));
  if (CIDToGlyphMap)
  {
    CGFontIndexMapGetValues(CIDToGlyphMap, *(unsigned __int16 **)(a1 + 120), *(void *)(a1 + 8), v11);
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v14 = *(void *)(a1 + 128);
    uint64_t v15 = *(void *)(a1 + 136);
    double v16 = *(char **)(a1 + 120);
    uint64_t v17 = *(void *)(a1 + 8);
    long long v18 = *(_OWORD *)(a1 + 80);
    long long v25 = *(_OWORD *)(a1 + 64);
    long long v26 = v18;
    long long v19 = *(_OWORD *)(a1 + 96);
LABEL_10:
    long long v27 = v19;
    a2(a3, v13, &v25, v14, v15, v11, v16, 0, v17);
    goto LABEL_11;
  }
  Font = (void *)CGPDFFontGetFont(*(void *)(a1 + 40));
  int GlyphsForCIDs = CGFontGetGlyphsForCIDs(Font, *(unsigned __int16 **)(a1 + 120), *(void *)(a1 + 8), v11);
  uint64_t v13 = *(void *)(a1 + 40);
  double v22 = (long long *)(a1 + 64);
  uint64_t v14 = *(void *)(a1 + 128);
  uint64_t v15 = *(void *)(a1 + 136);
  double v16 = *(char **)(a1 + 120);
  uint64_t v17 = *(void *)(a1 + 8);
  if (GlyphsForCIDs)
  {
    long long v23 = *(_OWORD *)(a1 + 80);
    long long v25 = *v22;
    long long v26 = v23;
    long long v19 = *(_OWORD *)(a1 + 96);
    goto LABEL_10;
  }
  long long v24 = *(_OWORD *)(a1 + 80);
  long long v25 = *v22;
  long long v26 = v24;
  long long v27 = *(_OWORD *)(a1 + 96);
  a2(a3, v13, &v25, v14, v15, v16, v16, 0, v17);
LABEL_11:
  if (v11 != v10) {
    free(v11);
  }
}

void simple_draw(uint64_t a1, void (*a2)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, char *, void, uint64_t, uint64_t), uint64_t a3, __n128 a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a4);
  uint64_t v10 = (char *)v22 - v9;
  if (v8 <= 0x7FFFFFFFFFFFFFFELL) {
    double v11 = (char *)v22 - v9;
  }
  else {
    double v11 = 0;
  }
  if (v8 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000066) {
    double v11 = (char *)malloc_type_malloc(2 * v7, 0x307BE51uLL);
  }
  Encoding = CGPDFFontGetEncoding(*(atomic_ullong **)(a1 + 40));
  GlyphVector = CGPDFEncodingGetGlyphVector(Encoding);
  uint64_t v14 = *(void *)(a1 + 8);
  if (GlyphVector)
  {
    if (v14)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)(a1 + 112);
      do
      {
        *(_WORD *)&v11[2 * v15] = *((_WORD *)GlyphVector + *(unsigned __int8 *)(v16 + v15));
        ++v15;
      }
      while (v14 != v15);
    }
  }
  else if (v14)
  {
    bzero(v11, 2 * v14);
  }
  uint64_t v17 = *(void *)(a1 + 40);
  uint64_t v18 = *(void *)(a1 + 128);
  uint64_t v19 = *(void *)(a1 + 136);
  uint64_t v20 = *(void *)(a1 + 112);
  long long v21 = *(_OWORD *)(a1 + 80);
  v22[0] = *(_OWORD *)(a1 + 64);
  v22[1] = v21;
  v22[2] = *(_OWORD *)(a1 + 96);
  a2(a3, v17, v22, v18, v19, v11, 0, v20, v14);
  if (v11 != v10) {
    free(v11);
  }
}

uint64_t blt_bitmap_copy_XXXX32(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  do
  {
    uint64_t v11 = a7 + 4 * a10 * a8;
    uint64_t v12 = result;
    uint64_t v13 = a9;
    if (result > 1)
    {
      do
      {
        unint64_t v14 = v12;
        int v15 = *(_DWORD *)(v11 + 4 * v13);
        if (v13 + 1 < a5) {
          uint64_t v16 = v13 + 1;
        }
        else {
          uint64_t v16 = 0;
        }
        int v17 = *(_DWORD *)(v11 + 4 * v16);
        *a3 = v15;
        a3[1] = v17;
        a3 += 2;
        if (v16 + 1 < a5) {
          uint64_t v13 = v16 + 1;
        }
        else {
          uint64_t v13 = 0;
        }
        uint64_t v12 = v14 - 2;
      }
      while (v14 > 3);
    }
    if (v12 >= 1) {
      *a3++ = *(_DWORD *)(v11 + 4 * v13);
    }
    a3 += a4 - result;
    if (a10 + 1 < a6) {
      ++a10;
    }
    else {
      a10 = 0;
    }
  }
  while (a2-- > 1);
  return result;
}

uint64_t blt_bitmap_blend_XXXA32(uint64_t result, uint64_t a2, uint32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = a4 - result;
  do
  {
    uint64_t v12 = a7 + 4 * a10 * a8;
    uint64_t v13 = a9;
    uint64_t v14 = result;
    if (result > 1)
    {
      do
      {
        __int32 v15 = *(_DWORD *)(v12 + 4 * v13);
        if (v13 + 1 < a5) {
          uint64_t v16 = v13 + 1;
        }
        else {
          uint64_t v16 = 0;
        }
        __int32 v17 = *(_DWORD *)(v12 + 4 * v16);
        if ((v17 & v15) == 0xFF)
        {
          a3->i32[0] = v15;
          a3->i32[1] = v17;
        }
        else if (v17 | v15)
        {
          v18.i16[0] = a3->u8[0];
          v18.i16[1] = BYTE2(a3->u32[0]);
          v18.i16[2] = BYTE4(*(unint64_t *)a3);
          v18.i16[3] = BYTE6(*(unint64_t *)a3);
          v19.i32[0] = v15;
          v19.i32[1] = *(_DWORD *)(v12 + 4 * v16);
          int32x2_t v20 = (int32x2_t)veor_s8(v19, (int8x8_t)0xFF000000FFLL);
          int32x2_t v21 = vmul_s32((int32x2_t)(*(void *)&vshr_n_u32(*a3, 8uLL) & 0xFFFF00FFFFFF00FFLL), v20);
          int32x2_t v22 = vmul_s32(v18, v20);
          *a3 = (uint32x2_t)vadd_s32((int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32(v22, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v22, 8uLL) & 0xFFFF00FFFFFF00FFLL)), 8uLL) & 0xFFFF00FFFFFF00FFLL), vadd_s32((int32x2_t)__PAIR64__(v17, v15), (int32x2_t)(*(void *)&vadd_s32(vadd_s32(v21, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v21, 8uLL) & 0xFFFF00FFFFFF00FFLL)) & 0xFF00FF00FF00FF00)));
        }
        ++a3;
        if (v16 + 1 < a5) {
          uint64_t v13 = v16 + 1;
        }
        else {
          uint64_t v13 = 0;
        }
        BOOL v23 = (unint64_t)v14 > 3;
        v14 -= 2;
      }
      while (v23);
    }
    if (v14 >= 1)
    {
      __int32 v24 = *(_DWORD *)(v12 + 4 * v13);
      if ((_BYTE)v24)
      {
        if (v24 != 255)
        {
          int v25 = ~(_BYTE)v24;
          v24 += ((((a3->i32[0] & 0xFF00FF) * v25 + 65537 + ((((a3->i32[0] & 0xFF00FFu) * v25) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
               + (((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * v25
                 + 65537
                 + ((((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * v25) >> 8) & 0xFF00FF)) & 0xFF00FF00);
        }
        a3->i32[0] = v24;
      }
      a3 = (uint32x2_t *)((char *)a3 + 4);
    }
    a3 = (uint32x2_t *)((char *)a3 + 4 * v11);
    if (a10 + 1 < a6) {
      ++a10;
    }
    else {
      a10 = 0;
    }
    BOOL v23 = a2-- <= 1;
  }
  while (!v23);
  return result;
}

uint64_t blt_bitmap_blend_AXXX32(uint64_t result, uint64_t a2, uint32x2_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  do
  {
    uint64_t v11 = a7 + 4 * a10 * a8;
    uint64_t v12 = a9;
    uint64_t v13 = result;
    if (result > 1)
    {
      do
      {
        __int32 v14 = *(_DWORD *)(v11 + 4 * v12);
        if (v12 + 1 < a5) {
          uint64_t v15 = v12 + 1;
        }
        else {
          uint64_t v15 = 0;
        }
        __int32 v16 = *(_DWORD *)(v11 + 4 * v15);
        int8x8_t v17 = (int8x8_t)vshr_n_u32((uint32x2_t)__PAIR64__(v16, v14), 0x18uLL);
        if ((v17.i32[1] & v17.i32[0]) == 255)
        {
          a3->i32[0] = v14;
          a3->i32[1] = v16;
        }
        else if (v17)
        {
          int32x2_t v18 = (int32x2_t)veor_s8(v17, (int8x8_t)0xFF000000FFLL);
          v19.i16[0] = a3->u8[0];
          v19.i16[1] = BYTE2(a3->u32[0]);
          v19.i16[2] = BYTE4(*(unint64_t *)a3);
          v19.i16[3] = BYTE6(*(unint64_t *)a3);
          int32x2_t v20 = vmul_s32((int32x2_t)(*(void *)&vshr_n_u32(*a3, 8uLL) & 0xFFFF00FFFFFF00FFLL), v18);
          int32x2_t v21 = vmul_s32(v19, v18);
          *a3 = (uint32x2_t)vadd_s32((int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32(v21, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v21, 8uLL) & 0xFFFF00FFFFFF00FFLL)), 8uLL) & 0xFFFF00FFFFFF00FFLL), vadd_s32((int32x2_t)__PAIR64__(v16, v14), (int32x2_t)(*(void *)&vadd_s32(vadd_s32(v20, (int32x2_t)0x1000100010001), (int32x2_t)(*(void *)&vshr_n_u32((uint32x2_t)v20, 8uLL) & 0xFFFF00FFFFFF00FFLL)) & 0xFF00FF00FF00FF00)));
        }
        ++a3;
        if (v15 + 1 < a5) {
          uint64_t v12 = v15 + 1;
        }
        else {
          uint64_t v12 = 0;
        }
        BOOL v22 = (unint64_t)v13 > 3;
        v13 -= 2;
      }
      while (v22);
    }
    if (v13 >= 1)
    {
      unsigned __int32 v23 = *(_DWORD *)(v11 + 4 * v12);
      unsigned __int32 v24 = HIBYTE(v23);
      if (HIBYTE(v23) != 255)
      {
        if (!v24)
        {
LABEL_18:
          a3 = (uint32x2_t *)((char *)a3 + 4);
          goto LABEL_19;
        }
        v23 += ((((a3->i32[0] & 0xFF00FF) * (v24 ^ 0xFF)
                + 65537
                + ((((a3->i32[0] & 0xFF00FF) * (v24 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
             + (((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * (v24 ^ 0xFF)
               + 65537
               + ((((((unsigned __int32)a3->i32[0] >> 8) & 0xFF00FF) * (v24 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
      }
      a3->i32[0] = v23;
      goto LABEL_18;
    }
LABEL_19:
    a3 = (uint32x2_t *)((char *)a3 + 4 * (a4 - result));
    if (a10 + 1 < a6) {
      ++a10;
    }
    else {
      a10 = 0;
    }
    BOOL v22 = a2-- <= 1;
  }
  while (!v22);
  return result;
}

uint64_t CGGetHardwareVectorCapabilities()
{
  return 3;
}

uint64_t CGContextGetVectorCapabilities(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 112);
  if (v1) {
    return *(unsigned int *)(v1 + 4);
  }
  else {
    return 3;
  }
}

uint64_t CGContextSetVectorCapabilities(uint64_t result, unsigned int a2)
{
  unsigned int v2 = (a2 | ~(-1 << -(char)__clz(a2))) & 3;
  if (a2 < 2) {
    unsigned int v2 = a2;
  }
  if (*(_DWORD *)(result + 24) == 4)
  {
    uint64_t v3 = *(void *)(result + 32);
    if (v3) {
      *(_DWORD *)(v3 + 96) = v2;
    }
  }
  uint64_t v4 = *(void *)(result + 112);
  if (v4)
  {
    int v5 = v2 | ~(-1 << -(char)__clz(v2));
    if (v2 >= 2) {
      LOBYTE(v2) = v5;
    }
    *(_DWORD *)(v4 + 4) = v2 & 3;
  }
  return result;
}

uint64_t is_smaller_stop(double *a1, double *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t gradient_hash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

BOOL gradient_equal(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

CFTypeID CGGradientGetTypeID(void)
{
  if (kCGGradientInterpolatesPremultiplied_block_invoke_once != -1) {
    dispatch_once(&kCGGradientInterpolatesPremultiplied_block_invoke_once, &__block_literal_global_20_13777);
  }
  return CGGradientGetTypeID_gradient_type_id;
}

CGGradientRef CGGradientRetain(CGGradientRef gradient)
{
  if (gradient) {
    CFRetain(gradient);
  }
  return gradient;
}

void *gradient_evaluate_premul(void *result, double *a2, double *a3)
{
  unint64_t v3 = result[2];
  unint64_t v4 = v3 - 2;
  if (v3 >= 2)
  {
    double v5 = *a2;
    uint64_t v6 = result[1];
    uint64_t v7 = result[3];
    uint64_t v8 = v6 + 1;
    uint64_t v9 = (double *)(v7 + 8 * (v6 + 1));
    double v10 = *v9;
    double v11 = 0.0;
    uint64_t v12 = 0;
    if (*a2 <= *v9)
    {
      double v15 = 0.0;
LABEL_9:
      double v16 = (v5 - v15) / (v10 - v15);
      uint64_t v17 = v7 + 8 * v12 * v8;
      double v18 = *(double *)(v17 + 8 * v6);
      double v19 = v9[v6];
      double v20 = v16 * v19 + (1.0 - v16) * v18;
      if (v20 != 0.0) {
        double v11 = 1.0 / v20;
      }
      uint64_t v21 = v6 - 1;
      if (v21)
      {
        BOOL v22 = (double *)(v17 + 8);
        unsigned __int32 v23 = v9 + 1;
        do
        {
          double v24 = *v22++;
          double v25 = (1.0 - v16) * v24;
          double v26 = *v23++;
          *a3++ = v11 * (v19 * (v16 * v26) + v25 * v18);
          --v21;
        }
        while (v21);
      }
      *a3 = v20;
    }
    else
    {
      uint64_t v13 = (double *)(v7 + 16 * v6 + 16);
      uint64_t v14 = v6 + 1;
      while (v4 != v12)
      {
        double v15 = v10;
        double v10 = *v13;
        ++v12;
        v14 += v8;
        v13 += v6 + 1;
        if (v5 <= v10)
        {
          uint64_t v9 = (double *)(v7 + 8 * v14);
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

uint64_t CGGradientUsesPremultipliedInterpolation(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 20);
}

uint64_t CGGradientGetLocationCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

double *CGGradientPrint(uint64_t a1, FILE *a2)
{
  fprintf(a2, "gradient %u\n", *(_DWORD *)(a1 + 16));
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    uint64_t v5 = *(void *)(*(void *)(v4 + 24) + 48);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (double *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  if (*(void *)(a1 + 48))
  {
    uint64_t v7 = result;
    unint64_t v8 = 0;
    do
    {
      double v9 = *v7++;
      fprintf(a2, "%zu: %g -> (", v8, v9);
      if (v5 != -1)
      {
        uint64_t v10 = v5 + 1;
        do
        {
          double v11 = *v7++;
          fprintf(a2, " %g", v11);
          --v10;
        }
        while (v10);
      }
      uint64_t result = (double *)fwrite(")\n", 2uLL, 1uLL, a2);
      ++v8;
    }
    while (v8 < *(void *)(a1 + 48));
  }
  return result;
}

const UInt8 *CGGradientApply(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, const UInt8 *, double))
{
  uint64_t v6 = *(void *)(a1 + 24);
  if (v6) {
    uint64_t v7 = *(void *)(*(void *)(v6 + 24) + 48) + 2;
  }
  else {
    uint64_t v7 = 2;
  }
  uint64_t result = CFDataGetBytePtr(*(CFDataRef *)(a1 + 40));
  if (*(void *)(a1 + 48))
  {
    unint64_t v9 = 0;
    uint64_t v10 = result + 8;
    uint64_t v11 = 8 * v7;
    do
    {
      uint64_t result = (const UInt8 *)a3(a2, v10, *((double *)v10 - 1));
      ++v9;
      v10 += v11;
    }
    while (v9 < *(void *)(a1 + 48));
  }
  return result;
}

uint64_t CGGradientGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t error(int a1, const char *a2, ...)
{
  va_start(va, a2);
  unint64_t v3 = (FILE **)MEMORY[0x1E4F143C8];
  uint64_t v4 = (FILE *)*MEMORY[0x1E4F143C8];
  if (a1 < 0) {
    fwrite("Error: ", 7uLL, 1uLL, v4);
  }
  else {
    fprintf(v4, "Error (%d): ", a1);
  }
  vfprintf(*v3, a2, va);
  fputc(10, *v3);
  return fflush(*v3);
}

BOOL __CheckPageForSpecialBlends_block_invoke(uint64_t a1, CGPDFDictionary *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CheckExtGStateForSpecialBlends(a2);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL __CheckPageForSpecialBlends_block_invoke_2(uint64_t a1, CGPDFDictionaryRef dict)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __CheckPageForSpecialBlends_block_invoke_3;
  block[3] = &unk_1E52CC088;
  block[4] = *(void *)(a1 + 32);
  CGPDFDictionaryApplyBlock(dict, block, 0);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

BOOL __CheckPageForSpecialBlends_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a3 + 8) == 9)
  {
    uint64_t v4 = *(void *)(a3 + 32);
    CGPDFDictionaryRef value = 0;
    if (v4) {
      uint64_t v5 = *(CGPDFDictionary **)(v4 + 48);
    }
    else {
      uint64_t v5 = 0;
    }
    if (CGPDFDictionaryGetDictionary(v5, "Resources", &value)) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CheckExtGStateForSpecialBlends(value);
    }
  }
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t CheckExtGStateForSpecialBlends(CGPDFDictionary *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __CheckExtGStateForSpecialBlends_block_invoke;
  block[3] = &unk_1E52CC0D8;
  block[4] = &v4;
  CGPDFDictionaryApplyBlock(a1, block, 0);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __CheckExtGStateForSpecialBlends_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
  }
  if (*(_DWORD *)(a3 + 8) != 8) {
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
  }
  uint64_t v4 = *(CGPDFDictionary **)(a3 + 32);
  CGPDFObjectRef value = 0;
  if (!CGPDFDictionaryGetObject(v4, "BM", &value)
    || CGPDFBlendModeFromCGPDFObject((uint64_t)value) + 1 < 2)
  {
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
  }
  BOOL result = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t assembleClusterGaps(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v6 = *(double *)(a3 + 96) - *(double *)(a2 + 96);
  double v7 = *(double *)(a2 + 144);
  double v8 = *(double *)(a3 + 144);
  BOOL v9 = v8 < 0.0;
  double v10 = v6 + v8;
  if (v8 > 0.0) {
    double v11 = v6 + v8;
  }
  else {
    double v11 = *(double *)(a3 + 96) - *(double *)(a2 + 96);
  }
  if (v8 <= 0.0) {
    double v8 = -v8;
  }
  if (v9) {
    double v6 = v10;
  }
  if (v7 >= 0.0) {
    double v12 = v6;
  }
  else {
    double v12 = v11;
  }
  if (v7 >= 0.0) {
    double v13 = *(double *)(a2 + 144);
  }
  else {
    double v13 = v8;
  }
  uint64_t v14 = *(void *)(a2 + 160);
  double v15 = *(double *)(v14 + 72);
  if (v15 == 0.0)
  {
    unsigned int v16 = -1;
    double v17 = 0.0;
    double v18 = 0.0;
  }
  else
  {
    uint64_t v21 = *(void **)(v14 + 64);
    uint64_t v22 = *(void *)(a3 + 160);
    unsigned __int32 v23 = *(void **)(v22 + 64);
    double v24 = *(double *)(v22 + 72);
    double v25 = 0.0;
    if (v15 == v24 && objc_msgSend(v21, "isSameFontAs:", *(void *)(v22 + 64), v6))
    {
      [v21 kernBetweenUnicode:*(unsigned __int16 *)(a2 + 72) andUnicode:*(unsigned __int16 *)(a3 + 72)];
      double v25 = v26;
    }
    [v21 kernBetweenUnicode:*(unsigned __int16 *)(a2 + 72) andUnicode:32];
    double v28 = v27;
    [v23 kernBetweenUnicode:32 andUnicode:*(unsigned __int16 *)(a3 + 72)];
    double v30 = v24 / v15 * v29;
    [v21 spaceWidth];
    double v32 = v31;
    [v23 spaceWidth];
    double v34 = (v32 + v33) * 0.5;
    double v35 = 0.277832031 / v34;
    if (v34 <= 0.0) {
      double v35 = 1.0;
    }
    double v17 = (v28 + v30) * v35 + 0.277832031;
    unsigned int v16 = *(_DWORD *)(a3 + 176);
    if (v12 > v13 * 0.5
      || !*(_WORD *)(a2 + 72)
      || *(unsigned __int16 *)(a2 + 72) != *(unsigned __int16 *)(a3 + 72)
      || ((v36 = v13 + v25 * v15, double v18 = 0.0, v36 > 0.0) ? (v37 = v12 > v36 * 0.5) : (v37 = 1), v37))
    {
      double v18 = (v12 / v15 - (v13 / v15 + (v25 + v28 + v30) * 0.5)) * v35;
    }
  }
  CGPoint v38 = (double *)(a4 + 16);
  *(double *)(*(void *)a4 + 8 * a1) = v18;
  if (!a1)
  {
    *(double *)(a4 + 16) = v17;
    *(double *)(a4 + 24) = v17;
    float64x2_t v39 = *(_OWORD **)(a4 + 8);
    *float64x2_t v39 = 0u;
    v39[1] = 0u;
    uint64_t v40 = *(void *)(a4 + 8);
    *(_OWORD *)(v40 + 32) = 0u;
    *(_OWORD *)(v40 + 48) = 0u;
    if ((v16 & 0x80000000) != 0) {
      return 1;
    }
    goto LABEL_38;
  }
  if (*v38 > v17 || (CGPoint v38 = (double *)(a4 + 24), *(double *)(a4 + 24) < v17)) {
    *CGPoint v38 = v17;
  }
  if ((v16 & 0x80000000) == 0)
  {
LABEL_38:
    if (v16 <= 2)
    {
      uint64_t v41 = *(void *)(a4 + 8);
      uint64_t v42 = v16;
      uint64_t v43 = v41 + 32 * v16;
      double v45 = (double *)(v43 + 8);
      unsigned int v44 = *(_DWORD *)v43;
      if (*(_DWORD *)v43)
      {
        if (*v45 > v18 || (v46 = v41 + 32 * v42, v47 = *(double *)(v46 + 16), double v45 = (double *)(v46 + 16), v47 < v18)) {
          *double v45 = v18;
        }
        uint64_t v48 = v41 + 32 * v42;
        int v49 = v44 + 1;
        *(double *)(v48 + 24) = (v18 + *(double *)(v48 + 24) * (double)v44) / (double)(v44 + 1);
      }
      else
      {
        *(int64x2_t *)double v45 = vdupq_lane_s64(*(uint64_t *)&v18, 0);
        *(double *)(v43 + 24) = v18;
        int v49 = 1;
      }
      *(_DWORD *)uint64_t v43 = v49;
    }
  }
  return 1;
}

BOOL isCharacterOverlay(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a2 + 96) - *(double *)(a1 + 96);
  double v5 = *(double *)(a1 + 144);
  double v6 = *(double *)(a2 + 144);
  if (v5 >= 0.0)
  {
    if (v6 < 0.0) {
      double v4 = v4 + v6;
    }
  }
  else if (v6 <= 0.0)
  {
    double v5 = -v6;
  }
  else
  {
    double v4 = v4 + v6;
    double v5 = *(double *)(a2 + 144);
  }
  BOOL result = 0;
  if (v4 <= v5 * 0.5 && *(_WORD *)(a1 + 72) && *(unsigned __int16 *)(a1 + 72) == *(unsigned __int16 *)(a2 + 72))
  {
    uint64_t v8 = *(void *)(a1 + 160);
    double v9 = *(double *)(v8 + 72);
    uint64_t v10 = *(void *)(a2 + 160);
    double v11 = 0.0;
    if (v9 == *(double *)(v10 + 72))
    {
      double v12 = *(void **)(v8 + 64);
      if ([v12 isSameFontAs:*(void *)(v10 + 64)])
      {
        [v12 kernBetweenUnicode:*(unsigned __int16 *)(a1 + 72) andUnicode:*(unsigned __int16 *)(a2 + 72)];
        double v11 = v13;
      }
    }
    double v14 = v5 + v11 * v9;
    return v4 <= v14 * 0.5 && v14 > 0.0;
  }
  return result;
}

uint64_t PBPageLayoutPkg::PBColor::formatText(PBPageLayoutPkg::PBColor *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((void *)this + 1)) {
    PB::TextFormatter::format();
  }

  return MEMORY[0x1F4147498](a2);
}

uint64_t PBPageLayoutPkg::PBColor::writeTo(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2) {
    return MEMORY[0x1F4147538](a2, v2, 1);
  }
  return result;
}

uint64_t PBPageLayoutPkg::PBColor::readFrom(PBPageLayoutPkg::PBColor *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v7 = *(void *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        unint64_t v11 = v2 + 1;
        *((void *)a2 + 1) = v2 + 1;
        char v12 = *(unsigned char *)(v7 + v2);
        v10 |= (unint64_t)(v12 & 0x7F) << v8;
        if ((v12 & 0x80) == 0) {
          break;
        }
        v8 += 7;
        unint64_t v2 = v11;
        BOOL v13 = v9++ > 8;
        if (v13) {
          goto LABEL_23;
        }
      }
LABEL_20:
      if ((v10 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v10 >> 3) == 1) {
        operator new();
      }
LABEL_23:
      uint64_t result = PB::Reader::skip(a2);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)a2 + 1);
      unint64_t v3 = *((void *)a2 + 2);
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v14 = 0;
    unsigned int v15 = 0;
    unint64_t v10 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v16 = v2 + 1;
      char v17 = *(unsigned char *)(v7 + v2);
      *((void *)a2 + 1) = v16;
      v10 |= (unint64_t)(v17 & 0x7F) << v14;
      if ((v17 & 0x80) == 0) {
        goto LABEL_20;
      }
      v14 += 7;
      unint64_t v2 = v16;
      BOOL v13 = v15++ > 8;
      if (v13) {
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void PBPageLayoutPkg::PBColor::~PBColor(void ***this)
{
  *this = (void **)&unk_1ED094740;
  std::unique_ptr<PB::Data>::reset[abi:fe180100](this + 1, 0);
  PB::Base::~Base((PB::Base *)this);

  JUMPOUT(0x18532A2A0);
}

{
  uint64_t vars8;

  *this = (void **)&unk_1ED094740;
  std::unique_ptr<PB::Data>::reset[abi:fe180100](this + 1, 0);

  PB::Base::~Base((PB::Base *)this);
}

uint64_t create_rgb_bitmap(double *a1, int a2, int a3)
{
  v65[1] = *MEMORY[0x1E4F143B8];
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  CGSScanconverterGetBoundingBox(a1, (_DWORD *)&v63 + 1, &v63, (_DWORD *)&v62 + 1, &v62);
  int v8 = v62;
  uint64_t v7 = HIDWORD(v62);
  if ((HIDWORD(v62) - 1) > 0x3FFFFFFB || (int)v62 < 1) {
    return 0;
  }
  uint64_t v10 = (2 * HIDWORD(v62) + 3) & 0x3FFFFFFFCLL;
  if (0x7FFFFFFF / v10 <= v62) {
    return 0;
  }
  double v56 = v53;
  size_t v11 = MEMORY[0x1F4188790](v10 * v62, v6);
  BOOL v13 = &v53[-v12];
  long long v55 = &v53[-v12];
  if (v11 >= 0x259) {
    BOOL v13 = (char *)malloc_type_malloc(v11, 0x76A840EFuLL);
  }
  int v54 = a3;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  unint64_t v64 = 0;
  v65[0] = 0;
  char v14 = delta_create((uint64_t)a1, (_DWORD *)v65 + 1, v65, &v64);
  double v57 = v13;
  if (v14)
  {
    int v15 = v64;
    int v17 = v65[0];
    uint64_t v16 = HIDWORD(v65[0]);
    if (CGSScanConvolveAndIntegrateRGB_onceToken != -1)
    {
      long long v52 = v14;
      dispatch_once(&CGSScanConvolveAndIntegrateRGB_onceToken, &__block_literal_global_2968);
      char v14 = v52;
    }
    if ((int)v16 >= 1)
    {
      uint64_t v18 = 0;
      double v19 = &v57[(v17 - 1) * (int)v10];
      uint64_t v20 = CGSScanConvolveAndIntegrateRGB_redKernel;
      uint64_t v21 = CGSScanConvolveAndIntegrateRGB_greenKernel;
      uint64_t v22 = CGSScanConvolveAndIntegrateRGB_blueKernel;
      uint64_t v23 = v15;
      do
      {
        if (v17 >= 1)
        {
          int v24 = 0;
          int v25 = 0;
          int v26 = 0;
          int v27 = 0;
          double v28 = &v19[2 * v18];
          double v29 = &v14[(4 * v18)];
          do
          {
            for (uint64_t i = 0; i != 19; ++i)
            {
              int v31 = (__int16)v29[i];
              v27 += v31 * *(__int16 *)(v20 + i * 2);
              v26 += *(__int16 *)(v21 + i * 2) * v31;
              v25 += *(__int16 *)(v22 + i * 2) * v31;
            }
            int v32 = (v27 + 7168) >> 14;
            int v33 = (v26 + 7168) >> 14;
            int v34 = (v25 + 7168) >> 14;
            if (v27 < -1154048 || v26 < -1154048 || v25 < -1154048)
            {
              int v32 = -v32;
              int v33 = -v33;
              int v34 = -v34;
            }
            if (v32 >= 255) {
              int v32 = 255;
            }
            int v38 = v32 & ~(v32 >> 31);
            if (v33 >= 255) {
              int v33 = 255;
            }
            int v39 = v33 & ~(v33 >> 31);
            if (v34 >= 255) {
              int v34 = 255;
            }
            *(_WORD *)double v28 = (4 * v39) & 0x3E0 | ((v34 & ~(v34 >> 31)) >> 3) | ((_WORD)v38 << 7) & 0x7C00;
            double v29 = (_WORD *)((char *)v29 + v23);
            v28 -= (int)v10;
            ++v24;
          }
          while (v24 != v17);
        }
        ++v18;
      }
      while (v18 != v16);
    }
    free(v14);
    BOOL v13 = v57;
  }
  CGGlyphGetTrimRegion((uint64_t)v13, (int)v7, v8, (2 * v7 + 3) & 0x3FFFFFFFCLL, &v61, &v60, &v59, &v58);
  uint64_t v40 = v59;
  uint64_t v41 = (int)v7 - (v59 + v58);
  uint64_t v42 = v61;
  uint64_t v43 = v61 + v60;
  unint64_t v44 = v8 - (v61 + v60);
  size_t v45 = 2 * v41;
  unint64_t v46 = (2 * v41 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  double v47 = CGGlyphBitmapCreate(a2, v54, HIDWORD(v63) + (int)v59, v8 - (int)v61 + (int)v63, v41, v44, v46, 0);
  uint64_t v48 = (uint64_t)v47;
  if (v47)
  {
    if (v8 != v43)
    {
      int v49 = &v57[2 * v40 + v42 * v10];
      double v50 = (char *)(v47 + 10);
      do
      {
        memcpy(v50, v49, v45);
        v49 += v10;
        v50 += v46;
        --v44;
      }
      while (v44);
    }
    if (default_glyph_bitmap_debugging) {
      CGGlyphBitmapWriteToFile(v48);
    }
  }
  if (v57 != v55) {
    free(v57);
  }
  return v48;
}

uint64_t create_gray_bitmap(double *a1, int a2, int a3)
{
  v51[1] = *MEMORY[0x1E4F143B8];
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  CGSScanconverterGetBoundingBox(a1, (_DWORD *)&v49 + 1, &v49, (_DWORD *)&v48 + 1, &v48);
  int v8 = v48;
  uint64_t v7 = HIDWORD(v48);
  if ((HIDWORD(v48) - 1) > 0x3FFFFFFB || (int)v48 < 1) {
    return 0;
  }
  uint64_t v10 = (2 * HIDWORD(v48) + 3) & 0x3FFFFFFFCLL;
  if (0x7FFFFFFF / v10 <= v48) {
    return 0;
  }
  uint64_t v43 = &v39;
  size_t v11 = MEMORY[0x1F4188790](v10 * v48, v6);
  BOOL v13 = (char *)&v39 - v12;
  uint64_t v42 = (char *)&v39 - v12;
  if (v11 >= 0x259) {
    BOOL v13 = (char *)malloc_type_malloc(v11, 0x4008D2F1uLL);
  }
  int v41 = a3;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  unint64_t v50 = 0;
  v51[0] = 0;
  char v14 = delta_create((uint64_t)a1, (_DWORD *)v51 + 1, v51, &v50);
  if (v14)
  {
    uint64_t v15 = HIDWORD(v51[0]);
    if (SHIDWORD(v51[0]) >= 1)
    {
      uint64_t v16 = 0;
      int v17 = v51[0];
      uint64_t v18 = (int)v50;
      do
      {
        if (v17 >= 1)
        {
          int v19 = 0;
          int v20 = 0;
          uint64_t v21 = &v13[2 * v16 + (v17 - 1) * (int)v10];
          uint64_t v22 = &v14[(4 * v16)];
          do
          {
            for (uint64_t i = 0; i != 19; ++i)
              v20 += (__int16)v22[i] * mKernel[i];
            int v24 = (v20 + 7168) >> 14;
            if (v20 < -1154048) {
              int v24 = -v24;
            }
            if (v24 >= 255) {
              int v24 = 255;
            }
            *(_WORD *)uint64_t v21 = (4 * (v24 & ~(unsigned __int16)(v24 >> 31) & 0xF8)) & 0x83E0 | ((((v24 & ~(v24 >> 31) & 0xF8u) >> 3) & 0x1F) << 10) | ((v24 & ~(v24 >> 31)) >> 3);
            uint64_t v22 = (_WORD *)((char *)v22 + v18);
            v21 -= (int)v10;
            ++v19;
          }
          while (v19 != v17);
        }
        ++v16;
      }
      while (v16 != v15);
    }
    free(v14);
  }
  CGGlyphGetTrimRegion((uint64_t)v13, (int)v7, v8, (2 * v7 + 3) & 0x3FFFFFFFCLL, &v47, &v46, &v45, &v44);
  uint64_t v25 = v45;
  uint64_t v26 = (int)v7 - (v45 + v44);
  uint64_t v27 = v47;
  uint64_t v28 = v47 + v46;
  unint64_t v29 = v8 - (v47 + v46);
  size_t v30 = 2 * v26;
  uint64_t v40 = v8;
  unint64_t v31 = (2 * v26 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  int v32 = CGGlyphBitmapCreate(a2, v41, HIDWORD(v49) + (int)v45, v8 - (int)v47 + (int)v49, v26, v29, v31, 0);
  uint64_t v33 = (uint64_t)v32;
  if (!v32)
  {
    BOOL v37 = v13;
    if (v13 == v42) {
      return v33;
    }
    goto LABEL_29;
  }
  int v34 = v13;
  if (v40 != v28)
  {
    double v35 = &v13[2 * v25 + v27 * v10];
    double v36 = (char *)(v32 + 10);
    do
    {
      memcpy(v36, v35, v30);
      v35 += v10;
      v36 += v31;
      --v29;
    }
    while (v29);
  }
  if (default_glyph_bitmap_debugging) {
    CGGlyphBitmapWriteToFile(v33);
  }
  BOOL v37 = v34;
  if (v34 != v42) {
LABEL_29:
  }
    free(v37);
  return v33;
}

char *scan_converter_iterate(char *result, int a2, uint64_t a3, double a4, double a5, __n128 a6, __n128 a7, __n128 a8, __n128 a9)
{
  unsigned int v9 = result;
  switch(a2)
  {
    case 0:
      float64x2_t v10 = *(float64x2_t *)a3;
      *(_OWORD *)(result + 24) = *(_OWORD *)a3;
      *(_OWORD *)(result + 8) = *(_OWORD *)(result + 24);
      *(float64x2_t *)(result + 40) = vminnmq_f64(*(float64x2_t *)(result + 40), v10);
      *(float64x2_t *)(result + 56) = vmaxnmq_f64(*(float64x2_t *)(result + 56), v10);
      return result;
    case 1:
      double v17 = *(double *)a3;
      double v18 = *(double *)(a3 + 8);
      goto LABEL_10;
    case 3:
      a6.n128_u64[0] = *(void *)a3;
      a7.n128_u64[0] = *(void *)(a3 + 8);
      a8.n128_u64[0] = *(void *)(a3 + 16);
      a9.n128_u64[0] = *(void *)(a3 + 24);
      double v12 = *(double *)(a3 + 32);
      double v11 = *(double *)(a3 + 40);
      double v13 = *((double *)result + 1);
      if (vabdd_f64(*(double *)a3, a8.n128_f64[0]) + vabdd_f64(a7.n128_f64[0], a9.n128_f64[0]) >= 0.0001)
      {
        double v14 = *((double *)result + 2);
LABEL_14:
        double v19 = a6.n128_f64[0] * (a6.n128_f64[0] - a8.n128_f64[0])
            + a8.n128_f64[0] * (a8.n128_f64[0] - v13)
            + v12 * (v13 - a6.n128_f64[0]);
        if (v19 >= 0.0)
        {
          double v20 = v12 - v13 + (a6.n128_f64[0] - a8.n128_f64[0]) * 3.0;
          double v21 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
          if (v20 == 0.0)
          {
            if (v21 == 0.0)
            {
              double v23 = 0.0;
              double v22 = 0.0;
            }
            else
            {
              double v22 = (v14 - a7.n128_f64[0]) * 0.5 / v21;
              double v23 = 2.0;
            }
          }
          else if (v21 != 0.0 || (v23 = 0.0, double v22 = 0.0, v19 != 0.0))
          {
            double v24 = 1.0;
            if (v21 < 0.0) {
              double v24 = -1.0;
            }
            double v25 = -(v21 + v24 * sqrt(v19));
            double v26 = v25 / v20;
            double v27 = (a7.n128_f64[0] - v14) / v25;
            if (v26 >= v27) {
              double v22 = v27;
            }
            else {
              double v22 = v26;
            }
            if (v26 <= v27) {
              double v23 = v27;
            }
            else {
              double v23 = v26;
            }
          }
          double v28 = 2.0;
          if (v22 < 1.0e-10) {
            double v22 = v23;
          }
          else {
            double v28 = v23;
          }
          if (v22 >= 1.0e-10 && v22 <= 1.0)
          {
            if (1.0 - v28 >= 1.0e-10)
            {
              double v42 = 1.0 - v22;
              double v43 = (v28 - v22) / (1.0 - v22);
              double v44 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
              double v45 = v13 + (v44 * v22 + (a6.n128_f64[0] - v13) * 2.0) * v22;
              double v46 = a9.n128_f64[0] + v14 + a7.n128_f64[0] * -2.0;
              double v47 = v14 + (v46 * v22 + (a7.n128_f64[0] - v14) * 2.0) * v22;
              double v48 = v13
                  + (v22 * ((v12 + (a8.n128_f64[0] - a6.n128_f64[0]) * -3.0 - v13) * v22 + v44 * 3.0)
                   + (a6.n128_f64[0] - v13) * 3.0)
                  * v22;
              double v49 = v14
                  + (v22 * ((v11 + (a9.n128_f64[0] - a7.n128_f64[0]) * -3.0 - v14) * v22 + v46 * 3.0)
                   + (a7.n128_f64[0] - v14) * 3.0)
                  * v22;
              double v71 = v12 + ((a6.n128_f64[0] + v12 + a8.n128_f64[0] * -2.0) * v42 + (v12 - a8.n128_f64[0]) * -2.0) * v42;
              double v50 = v11 + ((a7.n128_f64[0] + v11 + a9.n128_f64[0] * -2.0) * v42 + (v11 - a9.n128_f64[0]) * -2.0) * v42;
              double v51 = v12 - (v12 - a8.n128_f64[0]) * (1.0 - v22);
              double v52 = v11 - (v11 - a9.n128_f64[0]) * (1.0 - v22);
              a6.n128_f64[0] = v13 + (a6.n128_f64[0] - v13) * v22;
              a7.n128_f64[0] = v14 + (a7.n128_f64[0] - v14) * v22;
              a8.n128_f64[0] = v45;
              a9.n128_f64[0] = v47;
              approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v48, v49);
              double v53 = v12 - v51;
              v54.n128_f64[0] = v48 + (v71 - v48) * v43;
              v55.n128_f64[0] = v49 + (v50 - v49) * v43;
              double v56 = v51 + v48 + v71 * -2.0;
              v57.n128_f64[0] = v48 + (v43 * v56 + (v71 - v48) * 2.0) * v43;
              double v58 = v52 + v49 + v50 * -2.0;
              v59.n128_f64[0] = v49 + (v43 * v58 + (v50 - v49) * 2.0) * v43;
              double v60 = v48 + (v43 * (v43 * (v12 + (v51 - v71) * -3.0 - v48) + v56 * 3.0) + (v71 - v48) * 3.0) * v43;
              double v61 = v49 + (v43 * (v43 * (v11 + (v52 - v50) * -3.0 - v49) + v58 * 3.0) + (v50 - v49) * 3.0) * v43;
              double v62 = 1.0 - v43;
              double v63 = v12 + ((1.0 - v43) * (v12 + v51 * -2.0 + v71) + (v12 - v51) * -2.0) * (1.0 - v43);
              double v64 = v11 + ((1.0 - v43) * (v11 + v52 * -2.0 + v50) + (v11 - v52) * -2.0) * (1.0 - v43);
              double v65 = v12 - v53 * v62;
              double v66 = v11 - (v11 - v52) * v62;
              double v67 = v48;
              double v68 = v49;
              double v69 = v60;
              double v70 = v61;
              approximateMonotonicCube(v9, 0, v67, v68, v54, v55, v57, v59, v60, v61);
              uint64_t result = v9;
              double v13 = v69;
              double v14 = v70;
              a6.n128_f64[0] = v63;
              a7.n128_f64[0] = v64;
              a8.n128_f64[0] = v65;
              a9.n128_f64[0] = v66;
            }
            else
            {
              double v29 = v13 + (a6.n128_f64[0] - v13) * v22;
              double v30 = v14 + (a7.n128_f64[0] - v14) * v22;
              double v31 = a8.n128_f64[0] + v13 + a6.n128_f64[0] * -2.0;
              double v32 = v13 + (v31 * v22 + (a6.n128_f64[0] - v13) * 2.0) * v22;
              double v33 = a9.n128_f64[0] + v14 + a7.n128_f64[0] * -2.0;
              double v34 = v14 + (v33 * v22 + (a7.n128_f64[0] - v14) * 2.0) * v22;
              double v35 = v13
                  + (v22 * ((v12 + (a8.n128_f64[0] - a6.n128_f64[0]) * -3.0 - v13) * v22 + v31 * 3.0)
                   + (a6.n128_f64[0] - v13) * 3.0)
                  * v22;
              double v36 = v14
                  + (v22 * ((v11 + (a9.n128_f64[0] - a7.n128_f64[0]) * -3.0 - v14) * v22 + v33 * 3.0)
                   + (a7.n128_f64[0] - v14) * 3.0)
                  * v22;
              double v37 = 1.0 - v22;
              double v38 = v12 + ((a6.n128_f64[0] + v12 + a8.n128_f64[0] * -2.0) * v37 + (v12 - a8.n128_f64[0]) * -2.0) * v37;
              double v39 = v11 + ((a7.n128_f64[0] + v11 + a9.n128_f64[0] * -2.0) * v37 + (v11 - a9.n128_f64[0]) * -2.0) * v37;
              double v40 = v12 - (v12 - a8.n128_f64[0]) * v37;
              double v41 = v11 - (v11 - a9.n128_f64[0]) * v37;
              a6.n128_f64[0] = v29;
              a7.n128_f64[0] = v30;
              a8.n128_f64[0] = v32;
              a9.n128_f64[0] = v34;
              approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v35, v36);
              uint64_t result = v9;
              double v13 = v35;
              double v14 = v36;
              a6.n128_f64[0] = v38;
              a7.n128_f64[0] = v39;
              a8.n128_f64[0] = v40;
              a9.n128_f64[0] = v41;
            }
          }
        }
        uint64_t result = approximateMonotonicCube(result, 0, v13, v14, a6, a7, a8, a9, v12, v11);
        *((double *)v9 + 1) = v12;
        *((double *)v9 + 2) = v11;
        return result;
      }
      double v14 = *((double *)result + 2);
      double v15 = vabdd_f64(v13, a6.n128_f64[0]) + vabdd_f64(v14, a7.n128_f64[0]);
      double v16 = vabdd_f64(a8.n128_f64[0], v12) + vabdd_f64(a9.n128_f64[0], v11);
      if (v16 + v15 < 0.0002) {
        return result;
      }
      if (v16 >= 0.0001 && v15 >= 0.0001) {
        goto LABEL_14;
      }
      double v17 = *(double *)(a3 + 32);
      double v18 = *(double *)(a3 + 40);
LABEL_10:
      return CGSScanconverterAddLineToPoint(result, v17, v18);
    case 4:
      double v17 = *((double *)result + 3);
      double v18 = *((double *)result + 4);
      goto LABEL_10;
    default:
      abort();
  }
}

int64x2_t scan_converter_begin(uint64_t a1)
{
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(int64x2_t *)(a1 + 40) = vdupq_n_s64(0x47EFFFFFE0000000uLL);
  int64x2_t result = vdupq_n_s64(0xC7EFFFFFE0000000);
  *(int64x2_t *)(a1 + 56) = result;
  return result;
}

uint64_t ripc_DrawImageApplyingToneMapping(uint64_t a1, uint64_t a2, uint64_t a3, CGImage *a4, unsigned int a5, const void *a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  uint64_t ColorSpace = ripc_GetColorSpace(a1);
  if (!ColorSpace) {
    return 1000;
  }
  double v21 = (void *)ColorSpace;
  float v22 = 0.0;
  float v23 = 0.0;
  if (a5 - 3 >= 3)
  {
    float v24 = *(float *)(*(void *)(a3 + 120) + 48);
    double v25 = (void *)ripc_GetColorSpace(a1);
    if (CGColorSpaceSanitizeHeadroom(v25, v24) == 0.0) {
      CGPostError((uint64_t)"CGContextDrawImageApplyingToneMapping: EDR Target headroom unspecified", v26, v27, v28, v29, v30, v31, v32, v58);
    }
    float v33 = *(float *)(*(void *)(a3 + 120) + 48);
    double v34 = (void *)ripc_GetColorSpace(a1);
    float v35 = CGColorSpaceSanitizeHeadroom(v34, v33);
    if (v35 >= 1.0 || v35 <= 0.0) {
      float v37 = v35;
    }
    else {
      float v37 = 1.0;
    }
    if (v35 >= 0.0) {
      float v22 = v37;
    }
    else {
      float v22 = 0.0;
    }
    float HeadroomInfo = CGImageGetHeadroomInfo(a4, 0);
    if (HeadroomInfo >= 1.0 || HeadroomInfo <= 0.0) {
      float v40 = HeadroomInfo;
    }
    else {
      float v40 = 1.0;
    }
    if (HeadroomInfo >= 0.0) {
      float v23 = v40;
    }
    else {
      float v23 = 0.0;
    }
  }
  CGColorSpaceRef v44 = CGImageGetColorSpace(a4);
  if (CGImageDefaultReferenceWhite_once != -1) {
    dispatch_once(&CGImageDefaultReferenceWhite_once, &__block_literal_global_268);
  }
  CFNumberRef v45 = (const __CFNumber *)CGImageDefaultReferenceWhite_media_white;
  float v46 = 0.0;
  if (CGImageDefaultReferenceWhite_media_white)
  {
    CFTypeID v47 = CFGetTypeID((CFTypeRef)CGImageDefaultReferenceWhite_media_white);
    if (v47 == CFNumberGetTypeID())
    {
      float valuePtr = 0.0;
      CFNumberGetValue(v45, kCFNumberFloatType, &valuePtr);
      float v46 = valuePtr;
    }
  }
  float v59 = v46;
  if (a6)
  {
    CFTypeID v48 = CFGetTypeID(a6);
    if (v48 == CFDictionaryGetTypeID())
    {
      if (a5 == 2) {
        double v49 = @"kCGRWTMSourceReferenceWhite";
      }
      else {
        double v49 = @"kCGHDRMediaReferenceWhite";
      }
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a6, v49);
      if (Value)
      {
        CFNumberRef v51 = Value;
        CFTypeID v52 = CFGetTypeID(Value);
        if (v52 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v51, kCFNumberFloatType, &v59);
          float v46 = v59;
        }
      }
    }
  }
  CFDictionaryRef OptionsForToneMapping = CGColorConversionInfoCreateOptionsForToneMapping(a5, v21, v44, a6, 0, v22, v23, v46, v41, v42, v43);
  CopyWithResolvedOptions = (void *)CGImageCreateCopyWithResolvedOptions((uint64_t)a4, OptionsForToneMapping);
  __n128 v55 = CopyWithResolvedOptions;
  if (OptionsForToneMapping && CopyWithResolvedOptions)
  {
    uint64_t v56 = ripc_DrawImage(a1, a2, a3, CopyWithResolvedOptions, a7, a8, a9, a10);
  }
  else
  {
    if (!OptionsForToneMapping)
    {
      uint64_t v56 = ripc_DrawImage(a1, a2, a3, a4, a7, a8, a9, a10);
      if (!v55) {
        return v56;
      }
      goto LABEL_43;
    }
    uint64_t v56 = 1000;
  }
  CFRelease(OptionsForToneMapping);
  if (v55) {
LABEL_43:
  }
    CFRelease(v55);
  return v56;
}

uint64_t ripc_GetColorSpace(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 288) + 8);
  if (!v1 || (uint64_t v2 = *(void *)(v1 + 32)) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 288);
    ripc_InitializeColorTransform(v3);
    Cache = CGColorTransformGetCache(*(void **)(v3 + 120));
    if (Cache) {
      return Cache[2];
    }
    else {
      return 0;
    }
  }
  return v2;
}

CFDictionaryRef __get_flattening_options_block_invoke()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = @"kCGColorTransformFlattenImage";
  values = (void *)*MEMORY[0x1E4F1CFD0];
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  get_flattening_options_options = (uint64_t)result;
  return result;
}

const char *ripc_GetName()
{
  return "RIPContextDelegate";
}

uint64_t ripc_DrawLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6, double a7, double a8)
{
  if (a1)
  {
    uint64_t v15 = *(void *)(a1 + 288);
    if (a4)
    {
LABEL_3:
      char v16 = *(void *)(a4 + 80) != (void)ripc_DrawImage;
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v15 = 0;
    if (a4) {
      goto LABEL_3;
    }
  }
  char v16 = 1;
LABEL_6:
  uint64_t v17 = *(void *)(v15 + 48);
  Cache = CGColorTransformGetCache(*(void **)(v15 + 16));
  if (Cache) {
    double v19 = (CGColorSpace *)Cache[2];
  }
  else {
    double v19 = 0;
  }
  Image = RIPLayerCreateImage(v17, v19, v16);
  if (!Image) {
    return 1000;
  }
  double v21 = Image;
  if (a4)
  {
    float v22 = *(void (**)(uint64_t, uint64_t, uint64_t, CGDataProvider *, double, double, double, double))(a4 + 80);
    if (v22) {
      v22(a4, a2, a3, Image, a5, a6, a7, a8);
    }
  }
  CFRelease(v21);
  return 0;
}

const void *ripc_GetLayer(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12)
{
  if (a1) {
    uint64_t v18 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v18 = 0;
  }
  __n128 v55 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  long long v54 = *(_OWORD *)(v18 + 24);
  if (theDict)
  {
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    CGCFDictionaryGetCFTypeRef(theDict, @"kCGContextColorSpace", CGColorSpaceGetTypeID_type_id, (uint64_t *)&v55);
    if (v55 && !*(unsigned char *)(*((void *)v55 + 3) + 10)) {
      __n128 v55 = 0;
    }
    CGCFDictionaryGetSize(theDict, @"kCGContextResolution", (UInt8 *)&v54);
  }
  double v19 = *(void **)(v18 + 88);
  if (v19)
  {
    do
    {
      double v20 = v19;
      double v19 = (void *)*v19;
    }
    while (v19);
    uint64_t v21 = v20[4];
    if (v21) {
      float v22 = *(unsigned int **)(v21 + 32);
    }
    else {
      float v22 = 0;
    }
    float v23 = (void **)(v20 + 1);
  }
  else
  {
    float v23 = (void **)(v18 + 16);
    uint64_t v24 = *(void *)(v18 + 48);
    if (v24) {
      float v22 = *(unsigned int **)(v24 + 32);
    }
    else {
      float v22 = 0;
    }
  }
  double v25 = *v23;
  if (v55
    && (dispatch_once_t v26 = RIPLayerDepthForModel(*(_DWORD *)(*((void *)v55 + 3) + 28), *v22, a3, (uint64_t)theDict, a5, a6, a7, a8)) != 0)
  {
    uint64_t v27 = (unsigned int *)v26;
    Cache = v55;
    float v22 = v27;
  }
  else
  {
    Cache = (CGColorSpace *)CGColorTransformGetCache(v25);
    if (Cache)
    {
      Cache = (CGColorSpace *)*((void *)Cache + 2);
      __n128 v55 = Cache;
    }
    else
    {
      __n128 v55 = 0;
    }
  }
  CFDictionaryRef result = (const void *)color_transform_create(Cache, theDict);
  if (result)
  {
    uint64_t v30 = result;
    double v31 = *(double *)(v18 + 40);
    v56.origin.double x = a9;
    v56.origin.double y = a10;
    v56.size.double width = a11;
    v56.size.double height = a12;
    CGRect v57 = CGRectStandardize(v56);
    if (v31 != 1.0)
    {
      v57.origin.double x = v31 * v57.origin.x;
      v57.origin.double y = v31 * v57.origin.y;
      v57.size.double width = v31 * v57.size.width;
      v57.size.double height = v31 * v57.size.height;
    }
    double v35 = v57.size.width + v57.origin.x;
    double v36 = v57.origin.x + 0.0;
    if (v57.origin.x + 0.0 <= 1073741820.0)
    {
      unsigned int v38 = vcvtmd_s64_f64(v36);
      if (v36 >= -1073741820.0) {
        int v37 = v38;
      }
      else {
        int v37 = -1073741823;
      }
    }
    else
    {
      int v37 = 0x3FFFFFFF;
    }
    LODWORD(v52) = v37;
    if (v35 <= 1073741820.0)
    {
      unsigned int v40 = vcvtpd_s64_f64(v35);
      if (v35 >= -1073741820.0) {
        int v39 = v40;
      }
      else {
        int v39 = -1073741823;
      }
    }
    else
    {
      int v39 = 0x3FFFFFFF;
    }
    LODWORD(v53) = v39 - v37;
    double v41 = v57.size.height + v57.origin.y;
    double v42 = v57.origin.y + 0.0;
    if (v42 <= 1073741820.0)
    {
      unsigned int v44 = vcvtmd_s64_f64(v42);
      if (v42 >= -1073741820.0) {
        int v43 = v44;
      }
      else {
        int v43 = -1073741823;
      }
    }
    else
    {
      int v43 = 0x3FFFFFFF;
    }
    HIDWORD(v52) = v43;
    if (v41 <= 1073741820.0)
    {
      unsigned int v45 = vcvtpd_s64_f64(v41);
      if (v41 < -1073741820.0) {
        unsigned int v45 = -1073741823;
      }
    }
    else
    {
      unsigned int v45 = 0x3FFFFFFF;
    }
    HIDWORD(v53) = v45 - v43;
    if (a2) {
      uint64_t v46 = *(unsigned int *)(a2 + 4);
    }
    else {
      uint64_t v46 = 3;
    }
    CFTypeID v47 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v52, 17, (uint64_t)v22, v46, v32, v33, v34);
    if (v47)
    {
      CFTypeID v48 = v47;
      int v49 = *(_DWORD *)(v18 + 216);
      double v50 = ripc_Initialize();
      *((void *)v50 + 6) = v48;
      *((void *)v50 + 2) = v30;
      *(_OWORD *)(v50 + 24) = v54;
      *((double *)v50 + 5) = v31;
      *((_DWORD *)v50 + 54) = v49;
      if (a2)
      {
        uint64_t v51 = *((void *)v50 + 1);
        if (v51) {
          *(_DWORD *)(v51 + 96) = *(_DWORD *)(a2 + 4);
        }
      }
      return *(const void **)v50;
    }
    else
    {
      CFRelease(v30);
      return 0;
    }
  }
  return result;
}

uint64_t ripc_DrawImages(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12 = a2;
  if (a1) {
    double v13 = *(void **)(a1 + 288);
  }
  else {
    double v13 = 0;
  }
  long long v230 = 0u;
  long long v231 = 0u;
  long long v229 = 0u;
  if (ripc_GetRenderingState((uint64_t)v13, a2, a3, (uint64_t)&v229))
  {
    v14.f64[0] = (float64_t)v13[5];
    v15.f64[0] = 1.0;
    int8x16_t v16 = (int8x16_t)vdupq_lane_s64(vceqq_f64(v14, v15).i64[0], 0);
    float64x2_t v209 = (float64x2_t)vbslq_s8(v16, *(int8x16_t *)(a3 + 56), (int8x16_t)vmulq_n_f64(*(float64x2_t *)(a3 + 56), v14.f64[0]));
    float64x2_t v208 = (float64x2_t)vbslq_s8(v16, *(int8x16_t *)(a3 + 24), (int8x16_t)vmulq_n_f64(*(float64x2_t *)(a3 + 24), v14.f64[0]));
    float64x2_t v210 = (float64x2_t)vbslq_s8(v16, *(int8x16_t *)(a3 + 40), (int8x16_t)vmulq_n_f64(*(float64x2_t *)(a3 + 40), v14.f64[0]));
    double v17 = 0.0;
    double v18 = 0.0;
    double v19 = 0.0;
    *(double *)&unint64_t v20 = 0.0;
    if (!a6)
    {
      float64x2_t v216 = v208;
      float64x2_t v217 = v210;
      float64x2_t v218 = v209;
      unint64_t v20 = CGRectApplyInverseAffineTransform(v216.f64, COERCE__N64((double)SDWORD2(v230)), (double)SHIDWORD(v230), (double)(int)v231, (double)SDWORD1(v231)).n64_u64[0];
      double v19 = v21;
      double v18 = v22;
      double v17 = v23;
    }
    if (*v13)
    {
      uint64_t v24 = *(uint64_t (**)(void))(*v13 + 248);
      if (v24)
      {
        uint64_t v25 = v24();
        if (v25)
        {
          BOOL v211 = *(_DWORD *)(v25 + 40) == 7;
          if (!a7) {
            return 0;
          }
          goto LABEL_13;
        }
      }
    }
    BOOL v211 = 0;
    if (a7)
    {
LABEL_13:
      uint64_t v206 = (uint64_t)v13;
      float64x2_t v26 = 0uLL;
      uint64_t v27 = (double *)(a4 + 24);
      uint64_t v28 = (double *)(a6 + 16);
      float64x2_t v207 = vmulq_f64(v210, (float64x2_t)0);
      while (1)
      {
        float64x2_t v227 = v26;
        float64x2_t v228 = v26;
        float64x2_t v226 = v26;
        unint64_t v224 = 0;
        unint64_t v225 = 0;
        uint64_t v220 = 0;
        uint64_t v221 = 0;
        uint64_t v219 = 0;
        float64x2_t v217 = v26;
        float64x2_t v218 = v26;
        float64x2_t v215 = v26;
        float64x2_t v216 = v26;
        float64x2_t v214 = v26;
        uint64_t v29 = *a5;
        if (!*a5 || *(v27 - 1) == 0.0 || *v27 == 0.0) {
          goto LABEL_29;
        }
        EPSRep = CGImageGetEPSRep((void *)*a5);
        if (EPSRep) {
          uint64_t v29 = EPSRep[3];
        }
        alternate_image = create_alternate_image(v29, v211);
        uint64_t v32 = alternate_image;
        uint64_t v33 = alternate_image ? (CGImage *)alternate_image : (CGImage *)v29;
        if (ripc_GetImageSize((uint64_t)v33, &v225, &v224))
        {
          unint64_t v34 = v224;
          unint64_t v35 = v225;
          unint64_t v222 = v224;
          unint64_t v223 = v225;
          double height = v17;
          double width = v18;
          double y = v19;
          double x = *(double *)&v20;
          if (!a6) {
            goto LABEL_32;
          }
          if (*v28 != 0.0)
          {
            double v41 = v28[1];
            if (v41 != 0.0) {
              break;
            }
          }
        }
        float64x2_t v26 = 0uLL;
        if (v32)
        {
          CFRelease(v32);
LABEL_28:
          float64x2_t v26 = 0uLL;
        }
LABEL_29:
        ++a5;
        v27 += 4;
        v28 += 4;
        if (!--a7) {
          return 0;
        }
      }
      uint64_t v42 = *((void *)v28 - 2);
      uint64_t v43 = *((void *)v28 - 1);
      uint64_t v204 = v33;
      unint64_t v44 = v225;
      unint64_t v45 = v224;
      double v40 = *v28;
      CGRect v232 = CGRectStandardize(*(CGRect *)(&v41 - 3));
      unint64_t v34 = v45;
      unint64_t v35 = v44;
      uint64_t v33 = v204;
      double x = v232.origin.x;
      double y = v232.origin.y;
      double width = v232.size.width;
      double height = v232.size.height;
LABEL_32:
      unint64_t v203 = v34;
      uint64_t v205 = v12;
      unint64_t v197 = v20;
      double v198 = v19;
      double v199 = v18;
      double v200 = v17;
      CGRect v233 = CGRectStandardize(*(CGRect *)(v27 - 3));
      double v46 = v233.origin.x;
      double v47 = v233.origin.y;
      double v48 = v233.size.width;
      double v49 = v233.size.height;
      v237.origin.double x = x;
      v237.origin.double y = y;
      v237.size.double width = width;
      v237.size.double height = height;
      BOOL v50 = CGRectEqualToRect(v233, v237);
      uint64_t v202 = a6;
      if (v50) {
        goto LABEL_34;
      }
      v234.origin.double x = v46;
      v234.origin.double y = v47;
      v234.size.double width = v48;
      v234.size.double height = v49;
      v238.origin.double x = x;
      v238.origin.double y = y;
      v238.size.double width = width;
      v238.size.double height = height;
      if (CGRectContainsRect(v234, v238))
      {
LABEL_34:
        long long v213 = 0uLL;
        v212[0] = 0;
        v212[1] = 0;
        if (v48 < 0.0 || v49 < 0.0)
        {
          v235.origin.double x = v46;
          v235.origin.double y = v47;
          v235.size.double width = v48;
          v235.size.double height = v49;
          *(CGRect *)&double v51 = CGRectStandardize(v235);
        }
        else
        {
          double v51 = v46;
          double v52 = v47;
          double v53 = v48;
          double v54 = v49;
        }
        float64x2_t v226 = vmlaq_n_f64(v207, v208, v53);
        float64x2_t v227 = vmlaq_f64(vmulq_n_f64(v210, v54), (float64x2_t)0, v208);
        float64x2_t v228 = vaddq_f64(v209, vmlaq_n_f64(vmulq_n_f64(v210, v52), v208, v51));
        if (v50)
        {
          __n128 v55 = 0;
        }
        else
        {
          v214.f64[0] = (x - v46) * (1.0 / v48);
          v214.f64[1] = (y - v47) * (1.0 / v49);
          v215.f64[0] = 1.0 / v48 * (width + x - v46) - v214.f64[0];
          v215.f64[1] = 1.0 / v49 * (height + y - v47) - v214.f64[1];
          __n128 v55 = (double *)&v214;
        }
        double v18 = v199;
        double v17 = v200;
        unint64_t v20 = v197;
        double v19 = v198;
        ImageTransformatiouint64_t n = ripc_GetImageTransformation(v33, (int *)&v230 + 2, v35, v203, v55, v226.f64, (uint64_t)&v213, (int *)v212, (uint64_t)&v220);
        if (!ImageTransformation) {
          goto LABEL_75;
        }
        unint64_t v57 = ImageTransformation;
        unint64_t v195 = v35;
        if (ImageTransformation >= 4)
        {
          BOOL ShouldInterpolate = CGImageGetShouldInterpolate(v33);
          ImageInterpolatiouint64_t n = ripc_GetImageInterpolation(v205, *(_DWORD *)(*(void *)(a3 + 120) + 4), ShouldInterpolate);
          int v201 = ImageInterpolation;
          if (ImageInterpolation >= 3)
          {
            LODWORD(v58) = ImageInterpolation;
            if ((v57 & 2) != 0) {
              double v69 = 0;
            }
            else {
              double v69 = (int *)&v213;
            }
            if (ripc_GetImageInterpolationSize(v226.f64, (int64_t *)&v223, &v222, v69)) {
              uint64_t v58 = v58;
            }
            else {
              uint64_t v58 = 1;
            }
          }
          else
          {
            uint64_t v58 = 1;
          }
        }
        else
        {
          uint64_t v58 = 1;
          int v201 = 1;
        }
        uint64_t RenderingIntent = CGImageGetRenderingIntent(v33);
        if (!RenderingIntent)
        {
          unsigned int v71 = *(_DWORD *)(*(void *)(a3 + 120) + 4);
          int v72 = v71 << 12;
          if (((v71 >> 20) & 0xF) != 0) {
            int v73 = v71 << 8;
          }
          else {
            int v73 = v71 << 12;
          }
          if (!(v73 >> 28)) {
            int v73 = v72;
          }
          uint64_t RenderingIntent = (v73 >> 28);
        }
        CGFloat v74 = (v57 & 2) != 0 ? 0 : &v213;
        double v75 = (double *)ripc_AcquireRIPImageData(v206, v33, v223, v222, (uint64_t)v74, 0, v58, RenderingIntent);
        if (!v75)
        {
LABEL_75:
          uint64_t v12 = v205;
          if (v32) {
            CFRelease(v32);
          }
          a6 = v202;
          goto LABEL_28;
        }
        double v79 = v75;
        if (v57 >= 4) {
          double v80 = &v226;
        }
        else {
          double v80 = 0;
        }
        ripc_InitializeImage((uint64_t)&v216, (uint64_t)v212, v75, v201, v195, v203, v80->f64, v55, v76, v77, v78);
        goto LABEL_72;
      }
      double v59 = v46 + floor((x - v46) / v48) * v48;
      double v60 = v47 + floor((y - v47) / v49) * v49;
      _D30 = ceil((width + x - v59) / v48);
      _D31 = ceil((height + y - v60) / v49);
      if (_D30 <= 0.0 && _D31 <= 0.0) {
        goto LABEL_249;
      }
      if (v48 < 0.0 || v49 < 0.0)
      {
        v236.origin.double x = v59;
        v236.origin.double y = v60;
        v236.size.double width = v48;
        v236.size.double height = v49;
        double v193 = _D31;
        double v194 = _D30;
        *(CGRect *)&double v63 = CGRectStandardize(v236);
        _D31 = v193;
        _D30 = v194;
      }
      else
      {
        double v63 = v59;
        double v64 = v60;
        double v65 = v48;
        double v66 = v49;
      }
      _Q4 = vmlaq_n_f64(v207, v208, v65);
      _Q2 = vmlaq_f64(vmulq_n_f64(v210, v66), (float64x2_t)0, v208);
      float64x2_t v226 = _Q4;
      float64x2_t v227 = _Q2;
      float64x2_t v85 = vaddq_f64(v209, vmlaq_n_f64(vmulq_n_f64(v210, v64), v208, v63));
      float64x2_t v228 = v85;
      double v86 = 1.0 / (v48 * _D30);
      double v87 = 1.0 / (v49 * _D31);
      double v88 = (x - v59) * v86;
      double v89 = (y - v60) * v87;
      v214.f64[0] = v88;
      v214.f64[1] = v89;
      double v90 = (height + y - v60) * v87;
      double v91 = (width + x - v59) * v86 - v88;
      double v92 = v90 - v89;
      v215.f64[0] = v91;
      v215.f64[1] = v92;
      double v93 = vmlad_n_f64(v85.f64[0], _D30, _Q4.f64[0]);
      __asm { FMLA            D0, D30, V4.D[1] }
      double v99 = v93 > v85.f64[0] ? v93 : v85.f64[0];
      if (v93 >= v85.f64[0])
      {
        double v100 = v85.f64[0];
      }
      else
      {
        double v99 = v85.f64[0];
        double v100 = v93;
      }
      double v101 = _D0 > v85.f64[1] ? _D0 : v85.f64[1];
      if (_D0 >= v85.f64[1])
      {
        double v102 = v85.f64[1];
      }
      else
      {
        double v101 = v85.f64[1];
        double v102 = _D0;
      }
      double v103 = vmlad_n_f64(v93, _D31, _Q2.f64[0]);
      __asm { FMLA            D0, D31, V2.D[1] }
      double v105 = v103 > v99 ? v103 : v99;
      double v106 = v103 >= v100 ? v105 : v99;
      double v107 = v103 >= v100 ? v100 : v103;
      double v108 = _D0 > v101 ? _D0 : v101;
      if (_D0 >= v102)
      {
        double v109 = v102;
      }
      else
      {
        double v108 = v101;
        double v109 = _D0;
      }
      double v110 = v103 - _Q4.f64[0] * _D30;
      if (v110 >= v107)
      {
        if (v110 > v106) {
          double v106 = v110;
        }
      }
      else
      {
        double v107 = v110;
      }
      double v111 = _D0 - _Q4.f64[1] * _D30;
      double v112 = v111 > v108 ? v111 : v108;
      if (v111 >= v109)
      {
        double v113 = v109;
      }
      else
      {
        double v112 = v108;
        double v113 = v111;
      }
      double v114 = v107 >= (double)SDWORD2(v230) ? v107 : (double)SDWORD2(v230);
      double v115 = v106 <= (double)(int)v231 + (double)SDWORD2(v230) ? v106 : (double)(int)v231 + (double)SDWORD2(v230);
      if (v114 >= v115) {
        goto LABEL_249;
      }
      double v116 = (double)SHIDWORD(v230);
      if (v113 >= (double)SHIDWORD(v230)) {
        double v116 = v113;
      }
      double v117 = v112 <= (double)SDWORD1(v231) + (double)SHIDWORD(v230)
           ? v112
           : (double)SDWORD1(v231) + (double)SHIDWORD(v230);
      if (v116 >= v117)
      {
LABEL_249:
        uint64_t v12 = v205;
        if (v32) {
          CFRelease(v32);
        }
        a6 = v202;
        double v18 = v199;
        double v17 = v200;
        unint64_t v20 = v197;
        double v19 = v198;
        goto LABEL_28;
      }
      double v118 = v107 + 0.00390625;
      if (v107 + 0.00390625 <= 1073741820.0)
      {
        unint64_t v120 = v203;
        if (v118 >= -1073741820.0) {
          unsigned int v119 = vcvtmd_s64_f64(v118);
        }
        else {
          unsigned int v119 = -1073741823;
        }
      }
      else
      {
        unsigned int v119 = 0x3FFFFFFF;
        unint64_t v120 = v203;
      }
      LODWORD(v213) = v119;
      double v121 = v107 + v106 - v107 + -0.00390625;
      if (v121 <= 1073741820.0)
      {
        if (v121 >= -1073741820.0) {
          unsigned int v122 = vcvtpd_s64_f64(v121);
        }
        else {
          unsigned int v122 = -1073741823;
        }
      }
      else
      {
        unsigned int v122 = 0x3FFFFFFF;
      }
      int v123 = v122 - v119;
      DWORD2(v213) = v123;
      double v124 = v113 + 0.00390625;
      if (v113 + 0.00390625 <= 1073741820.0)
      {
        unsigned int v125 = vcvtmd_s64_f64(v124);
        if (v124 < -1073741820.0) {
          unsigned int v125 = -1073741823;
        }
      }
      else
      {
        unsigned int v125 = 0x3FFFFFFF;
      }
      DWORD1(v213) = v125;
      double v126 = v113 + v112 - v113 + -0.00390625;
      if (v126 <= 1073741820.0)
      {
        unsigned int v127 = vcvtpd_s64_f64(v126);
        if (v126 < -1073741820.0) {
          unsigned int v127 = -1073741823;
        }
      }
      else
      {
        unsigned int v127 = 0x3FFFFFFF;
      }
      double v128 = (double)v35;
      double v129 = (double)v120;
      int v130 = v127 - v125;
      HIDWORD(v213) = v130;
      double v131 = _D30 * (double)v35;
      if (v131 == (double)v123)
      {
        double v132 = _D31 * v129;
        double v133 = fabs(_Q4.f64[1]);
        BOOL v134 = _D31 * v129 == (double)v130 && v133 <= 0.00390625;
        double v135 = vabdd_f64(_Q4.f64[0], v128);
        double v136 = fabs(_Q2.f64[0]);
        BOOL v138 = v134 && v135 <= 0.00390625 && v136 <= 0.00390625;
        double v139 = vabdd_f64(_Q2.f64[1], v129);
        if (v138 && v139 <= 0.00390625)
        {
          int v141 = 1;
LABEL_163:
          double v142 = 1.0 / v128;
          double v143 = 1.0 / v129;
          double v144 = v142 * _Q4.f64[0];
          _Q4.f64[0] = v142 * _Q4.f64[1];
          v226.f64[0] = v144;
          v226.f64[1] = v142 * _Q4.f64[1];
          double v145 = v143 * _Q2.f64[0];
          double v146 = v143 * _Q2.f64[1];
          v227.f64[0] = v143 * _Q2.f64[0];
          v227.f64[1] = v143 * _Q2.f64[1];
          double v147 = v131 * v88;
          double v148 = v132 * v89;
          _Q2.f64[0] = v131 * v91;
          double v149 = v132 * v92;
          v85.f64[0] = v85.f64[0] + v144 * v147 + v145 * v148;
          double v150 = v85.f64[1] + v142 * _Q4.f64[1] * v147 + v143 * _Q2.f64[1] * v148;
          double v151 = v85.f64[0] + v144 * _Q2.f64[0];
          double v152 = v150 + v142 * _Q4.f64[1] * _Q2.f64[0];
          if (v151 > v85.f64[0]) {
            double v153 = v85.f64[0] + v144 * _Q2.f64[0];
          }
          else {
            double v153 = v85.f64[0];
          }
          if (v151 >= v85.f64[0])
          {
            double v154 = v85.f64[0];
          }
          else
          {
            double v153 = v85.f64[0];
            double v154 = v85.f64[0] + v144 * _Q2.f64[0];
          }
          if (v152 > v150) {
            double v155 = v150 + _Q4.f64[0] * _Q2.f64[0];
          }
          else {
            double v155 = v150;
          }
          if (v152 >= v150) {
            double v156 = v155;
          }
          else {
            double v156 = v150;
          }
          if (v152 >= v150) {
            double v157 = v150;
          }
          else {
            double v157 = v150 + _Q4.f64[0] * _Q2.f64[0];
          }
          double v158 = v151 + v145 * v149;
          double v159 = v152 + v146 * v149;
          if (v158 > v153) {
            double v160 = v158;
          }
          else {
            double v160 = v153;
          }
          if (v158 >= v154)
          {
            double v161 = v154;
          }
          else
          {
            double v160 = v153;
            double v161 = v158;
          }
          if (v159 > v156) {
            double v162 = v152 + v146 * v149;
          }
          else {
            double v162 = v156;
          }
          if (v159 >= v157)
          {
            double v163 = v157;
          }
          else
          {
            double v162 = v156;
            double v163 = v159;
          }
          double v164 = v158 - v144 * _Q2.f64[0];
          if (v164 >= v161)
          {
            if (v164 > v160) {
              double v160 = v158 - v144 * _Q2.f64[0];
            }
          }
          else
          {
            double v161 = v158 - v144 * _Q2.f64[0];
          }
          double v165 = v159 - _Q4.f64[0] * _Q2.f64[0];
          if (v165 > v162) {
            double v166 = v165;
          }
          else {
            double v166 = v162;
          }
          if (v165 >= v163)
          {
            double v167 = v163;
          }
          else
          {
            double v166 = v162;
            double v167 = v165;
          }
          if (v114 >= v161) {
            double v168 = v114;
          }
          else {
            double v168 = v161;
          }
          if (v115 <= v160) {
            double v169 = v115;
          }
          else {
            double v169 = v160;
          }
          if (v168 < v169)
          {
            if (v116 >= v167) {
              double v170 = v116;
            }
            else {
              double v170 = v167;
            }
            if (v117 <= v166) {
              double v166 = v117;
            }
            if (v170 < v166)
            {
              double v171 = v168 + 0.00390625;
              if (v168 + 0.00390625 <= 1073741820.0)
              {
                unsigned int v172 = vcvtmd_s64_f64(v171);
                if (v171 < -1073741820.0) {
                  unsigned int v172 = -1073741823;
                }
              }
              else
              {
                unsigned int v172 = 0x3FFFFFFF;
              }
              LODWORD(v220) = v172;
              double v173 = v168 + v169 - v168 + -0.00390625;
              if (v173 <= 1073741820.0)
              {
                unsigned int v174 = vcvtpd_s64_f64(v173);
                if (v173 < -1073741820.0) {
                  unsigned int v174 = -1073741823;
                }
              }
              else
              {
                unsigned int v174 = 0x3FFFFFFF;
              }
              LODWORD(v221) = v174 - v172;
              double v175 = v170 + 0.00390625;
              if (v170 + 0.00390625 <= 1073741820.0)
              {
                unsigned int v176 = vcvtmd_s64_f64(v175);
                if (v175 < -1073741820.0) {
                  unsigned int v176 = -1073741823;
                }
              }
              else
              {
                unsigned int v176 = 0x3FFFFFFF;
              }
              HIDWORD(v220) = v176;
              double v177 = v170 + v166 - v170 + -0.00390625;
              if (v177 <= 1073741820.0)
              {
                if (v177 >= -1073741820.0) {
                  unsigned int v178 = vcvtpd_s64_f64(v177);
                }
                else {
                  unsigned int v178 = -1073741823;
                }
              }
              else
              {
                unsigned int v178 = 0x3FFFFFFF;
              }
              double v179 = _D31;
              double v180 = _D30;
              HIDWORD(v221) = v178 - v176;
              unint64_t v196 = v35;
              if (v141)
              {
                uint64_t v181 = 1;
                int v182 = 1;
              }
              else
              {
                BOOL v183 = CGImageGetShouldInterpolate(v33);
                int v182 = ripc_GetImageInterpolation(v205, *(_DWORD *)(*(void *)(a3 + 120) + 4), v183);
                if (v182 >= 3)
                {
                  if (ripc_GetImageInterpolationSize(v226.f64, (int64_t *)&v223, &v222, 0)) {
                    uint64_t v181 = v182;
                  }
                  else {
                    uint64_t v181 = 0;
                  }
                }
                else
                {
                  uint64_t v181 = 0;
                }
              }
              uint64_t v184 = CGImageGetRenderingIntent(v33);
              if (!v184)
              {
                unsigned int v185 = *(_DWORD *)(*(void *)(a3 + 120) + 4);
                int v186 = v185 << 12;
                if (((v185 >> 20) & 0xF) != 0) {
                  int v187 = v185 << 8;
                }
                else {
                  int v187 = v185 << 12;
                }
                if (!(v187 >> 28)) {
                  int v187 = v186;
                }
                uint64_t v184 = (v187 >> 28);
              }
              uint64_t v188 = (double *)ripc_AcquireRIPImageData(v206, v33, v223, v222, 0, *(void *)(*(void *)(v206 + 48) + 32), v181, v184);
              if (v188)
              {
                double v79 = v188;
                if (v141) {
                  uint64_t v191 = 0;
                }
                else {
                  uint64_t v191 = &v226;
                }
                ripc_InitializeImageTile((uint64_t)&v216, &v213, (uint64_t)v188, v182, v196, v203, v191->f64, v214.f64, v180, v179, v189, v190);
                double v18 = v199;
                double v17 = v200;
                unint64_t v20 = v197;
                double v19 = v198;
LABEL_72:
                a6 = v202;
                uint64_t v12 = v205;
                if (v32) {
                  CFRelease(v32);
                }
                ripc_RenderImage(v206, v205, a3, (uint64_t *)&v229, (int *)&v220, (uint64_t)&v216, v81, v82);
                ripc_ReleaseRIPImageData(v79);
                goto LABEL_28;
              }
            }
          }
          goto LABEL_249;
        }
      }
      else
      {
        double v132 = _D31 * v129;
      }
      int v141 = 0;
      goto LABEL_163;
    }
  }
  return 0;
}

double ripc_InitializeImageTile(uint64_t a1, long long *a2, uint64_t a3, int a4, unint64_t a5, unint64_t a6, double *a7, double *a8, double result, double a10, double a11, double a12)
{
  *(void *)(a1 + 16) = a3;
  *(_WORD *)(a1 + 42) = -1;
  long long v12 = *a2;
  *(_OWORD *)a1 = *a2;
  if (!a7)
  {
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 40) = 0;
    goto LABEL_18;
  }
  uint64_t v13 = *(unsigned int *)(a3 + 40);
  if (v13 != a5)
  {
    double v21 = *a7;
    double v22 = a7[1];
    double v23 = a7[2];
    double v24 = a7[3];
    if (a4 == 1)
    {
LABEL_12:
      *(_WORD *)(a1 + 40) = 0;
      goto LABEL_15;
    }
    *(_WORD *)(a1 + 40) = -1;
    double v25 = (double)a5 / (double)v13;
    double v21 = v25 * v21;
    double v22 = v25 * v22;
    uint64_t v14 = *(unsigned int *)(a3 + 44);
LABEL_14:
    if (v14 != a6)
    {
      double v28 = (double)a6 / (double)v14;
      double v27 = v23 * v28;
      double v26 = v24 * v28;
      goto LABEL_17;
    }
LABEL_15:
    double v26 = v24;
    double v27 = v23;
LABEL_17:
    double v29 = (double)a6 * a10;
    double v30 = (double)(*((_DWORD *)a2 + 3) + *((_DWORD *)a2 + 1)) - (a7[5] + v24 * v29);
    a7[4] = a7[4] + v23 * v29 - (double)*(int *)a2;
    a7[5] = v30;
    a12 = -v22;
    *a7 = v21;
    a7[1] = a12;
    *(double *)&long long v12 = -v27;
    a7[2] = -v27;
    a7[3] = v26;
    *(void *)(a1 + 24) = a7;
    *(void *)(a1 + 48) = 0;
    goto LABEL_18;
  }
  uint64_t v14 = *(unsigned int *)(a3 + 44);
  if (v14 != a6)
  {
    double v21 = *a7;
    double v22 = a7[1];
    double v23 = a7[2];
    double v24 = a7[3];
    if (a4 == 1) {
      goto LABEL_12;
    }
    *(_WORD *)(a1 + 40) = -1;
    goto LABEL_14;
  }
  int v15 = *((_DWORD *)a2 + 3) + *((_DWORD *)a2 + 1);
  double v16 = (double)a6 * a10;
  double v17 = a7[5] + a7[3] * v16;
  double v19 = a7[1];
  double v18 = a7[2];
  a7[4] = a7[4] + v18 * v16 - (double)*(int *)a2;
  a7[5] = (double)v15 - v17;
  *(double *)&long long v12 = -v18;
  a12 = -v19;
  a7[1] = -v19;
  a7[2] = -v18;
  *(void *)(a1 + 24) = a7;
  *(void *)(a1 + 48) = 0;
  if (a4 == 1) {
    __int16 v20 = 0;
  }
  else {
    __int16 v20 = -1;
  }
  *(_WORD *)(a1 + 40) = v20;
LABEL_18:
  *(void *)(a1 + 32) = a8;
  if (a8)
  {
    LODWORD(a12) = *(_DWORD *)(a3 + 40);
    LODWORD(v12) = *(_DWORD *)(a3 + 44);
    double v31 = (double)(unint64_t)v12 * a10;
    double v32 = a8[1];
    double v33 = v31 - (v32 + a8[3]) * v31;
    double v34 = v31 - v32 * v31;
    double v35 = (double)*(unint64_t *)&a12 * result;
    double v36 = *a8 + a8[2];
    double v37 = *a8 * v35;
    *a8 = v37;
    a8[1] = v33;
    CFDictionaryRef result = v36 * v35 - v37;
    a8[2] = result;
    a8[3] = v34 - v33;
  }
  return result;
}

void ripc_DrawLines(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1) {
    uint64_t v9 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v9 = 0;
  }
  memset(v24, 0, sizeof(v24));
  uint64_t v22 = 0;
  if (ripc_GetRenderingState(v9, a2, a3, (uint64_t)v24))
  {
    uint64_t v10 = *(void *)(*(void *)(a3 + 144) + 8);
    long long v21 = *(_OWORD *)(v9 + 24);
    uint64_t v11 = *(void *)(v9 + 40);
    v20[0] = v10;
    v20[1] = v11;
    char v12 = *(unsigned char *)(a2 + 81);
    if (v12) {
      char v12 = *(unsigned char *)(*(void *)(a3 + 120) + 7) & 1;
    }
    LOBYTE(v22) = v12;
    double v23 = (char *)&v24[1] + 8;
    memset(v19, 0, sizeof(v19));
    ripc_GetRenderStroke(a3, (uint64_t)v19, (long long *)(a3 + 24));
    double v17 = *(_DWORD **)(v9 + 64);
    if (!v17)
    {
      double v17 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
      *(void *)double v17 = RIPRenderCreate_ripr_class;
      _OWORD v17[2] = 1;
      *((void *)v17 + 2) = 0;
      *(void *)(v9 + 64) = v17;
    }
    if (a5 && a4 && *(void *)v17)
    {
      double v18 = ripr_Acquire((uint64_t)v17, (uint64_t)v20);
      if (v18)
      {
        uint64_t v26 = 0;
        memset(v25, 0, sizeof(v25));
        ripr_stroke_acquire((uint64_t)v18, (uint64_t)v25, (uint64_t)v19);
      }
    }
    ripc_Render(v9, a2, a3, (uint64_t *)v24, 1uLL, v13, v14, v15, v16);
  }
}

uint64_t ripc_GetColorTransform(uint64_t a1)
{
  if (a1) {
    uint64_t v1 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v1 = 0;
  }
  ripc_InitializeColorTransform(v1);
  return *(void *)(v1 + 120);
}

CFDataRef CGCMSUtilsGetICCProfileData(CGColorSpaceRef space, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((CGCMSUtilsGetICCProfileData_warned & 1) == 0)
  {
    CGCMSUtilsGetICCProfileData_warnedouble d = 1;
  }

  return CGColorSpaceCopyICCData(space);
}

double *CG::Quadratic::length(double *this, int a2)
{
  double v3 = this[2];
  if (*this != v3 || this[1] != this[3])
  {
    double v4 = this[4];
    if (v3 == v4)
    {
      double v6 = this[3];
      double v5 = this[5];
      if (v6 == v5) {
        return this;
      }
    }
    else
    {
      double v5 = this[5];
      double v6 = this[3];
    }
    if (a2 <= 32
      && (v5 - v6 + this[1] - v6) * (v5 - v6 + this[1] - v6) + (*this - v3 + v4 - v3) * (*this - v3 + v4 - v3) >= 4.0)
    {
      CG::Quadratic::split((CG::Quadratic *)v8, 0.5, this);
      int v7 = a2 + 1;
      CG::Quadratic::length((CG::Quadratic *)v8, v7);
      return (double *)CG::Quadratic::length((CG::Quadratic *)&v9, v7);
    }
  }
  return this;
}

double CG::Quadratic::split(CG::Quadratic *this, double a2, double *a3)
{
  double v3 = a3[2];
  double v4 = a3[3];
  double v5 = a3[1];
  double v6 = *a3 + (v3 - *a3) * a2;
  double v7 = v5 + (v4 - v5) * a2;
  double v8 = a3[4];
  double v9 = a3[5];
  double v10 = v3 + (v8 - v3) * a2;
  double v11 = v4 + (v9 - v4) * a2;
  double v12 = v6 + (v10 - v6) * a2;
  double v13 = v7 + (v11 - v7) * a2;
  double v14 = v6 - *a3;
  double v15 = v11 - v13 + v11 - v13;
  *(double *)this = *a3;
  *((double *)this + 1) = v5;
  *((double *)this + 2) = v6;
  *((double *)this + 3) = v7;
  *((double *)this + 4) = v12;
  *((double *)this + 5) = v13;
  *((double *)this + 6) = v14 + v14;
  *((double *)this + 7) = v7 - v5 + v7 - v5;
  *((double *)this + 8) = v12 - v6 - v14;
  *((double *)this + 9) = v13 - v7 - (v7 - v5);
  *((double *)this + 10) = v12;
  *((double *)this + 11) = v13;
  *((double *)this + 12) = v10;
  *((double *)this + 13) = v11;
  *((double *)this + 14) = v8;
  *((double *)this + 15) = v9;
  double result = v9 - v11 - (v11 - v13);
  *((double *)this + 16) = v10 - v12 + v10 - v12;
  *((double *)this + 17) = v15;
  *((double *)this + 18) = v8 - v10 - (v10 - v12);
  *((double *)this + 19) = result;
  return result;
}

double *CG::Quadratic::index(double *this, double a2)
{
  if (a2 > 0.0)
  {
    double v3 = this;
    this = CG::Quadratic::length(this, 0);
    if (v4 > a2)
    {
      double v5 = 1.0;
      double v6 = 0.0;
      do
      {
        CG::Quadratic::split((CG::Quadratic *)v8, (v5 + v6) * 0.5, v3);
        this = CG::Quadratic::length(v8, 0);
        if (v7 <= a2) {
          double v6 = (v5 + v6) * 0.5;
        }
        else {
          double v5 = (v5 + v6) * 0.5;
        }
      }
      while (v5 - v6 > 0.0001);
    }
  }
  return this;
}

void cmap_cid_set_release(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    free(a1);
  }
}

char *add_range(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6 == *(void *)(a1 + 8))
  {
    uint64_t v7 = 2 * v6 + 8;
    double result = (char *)malloc_type_realloc(*(void **)(a1 + 24), 12 * v7, 0x1000040CBA68D63uLL);
    if (!result) {
      return result;
    }
    *(void *)(a1 + 24) = result;
    *(void *)(a1 + 8) = v7;
    uint64_t v6 = *(void *)(a1 + 16);
  }
  else
  {
    double result = *(char **)(a1 + 24);
  }
  *(void *)(a1 + 16) = v6 + 1;
  double v9 = &result[12 * v6];
  *(void *)double v9 = a2;
  *((_DWORD *)v9 + 2) = a3;
  return result;
}

BOOL cmap_cid_set_normalize(BOOL result)
{
  if (*(unsigned char *)(result + 32))
  {
    uint64_t v1 = (unsigned __int8 *)result;
    qsort(*(void **)(result + 24), *(void *)(result + 16), 0xCuLL, (int (__cdecl *)(const void *, const void *))compare_ranges);
    double result = contains_overlaps((uint64_t)v1);
    if (result)
    {
      unsigned int v2 = *v1;
      if (v2 > 4 || ((1 << v2) & 0x16) == 0)
      {
        double v5 = 0;
      }
      else
      {
        double v4 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x10200401AE633E8uLL);
        double v5 = v4;
        if (v4)
        {
          *double v4 = v2;
          v4[32] = 0;
        }
      }
      unint64_t v6 = *((void *)v1 + 2);
      if (v6)
      {
        unint64_t v7 = 0;
        uint64_t v8 = -1;
        do
        {
          add_nonoverlapping_range(v5, (unsigned int *)(*((void *)v1 + 3) + 12 * (v6 + v8)), 0);
          ++v7;
          unint64_t v6 = *((void *)v1 + 2);
          --v8;
        }
        while (v7 < v6);
      }
      free(*((void **)v1 + 3));
      long long v9 = *(_OWORD *)v5;
      long long v10 = *((_OWORD *)v5 + 1);
      *((void *)v1 + 4) = *((void *)v5 + 4);
      *(_OWORD *)uint64_t v1 = v9;
      *((_OWORD *)v1 + 1) = v10;
      *((void *)v5 + 3) = 0;
      cmap_cid_set_release((void **)v5);
      double result = contains_overlaps((uint64_t)v1);
      if (result) {
        _CGHandleAssert("remove_overlaps", 203, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/CMaps/cmap-cid-set.c", "!contains_overlaps(set)", "set %p contains overlaps", v11, v12, v13, (char)v1);
      }
    }
    v1[32] = 0;
  }
  return result;
}

BOOL contains_overlaps(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *(void *)(a1 + 24);
    unint64_t v4 = v1 - 1;
    double v5 = (_DWORD *)(v3 + 16);
    BOOL v6 = 1;
    while (1)
    {
      uint64_t v7 = v2 + 1;
      if (v2 + 1 < v1) {
        break;
      }
LABEL_8:
      --v4;
      v5 += 3;
      BOOL v6 = ++v2 < v1;
      if (v7 == v1) {
        return 0;
      }
    }
    uint64_t v8 = (_DWORD *)(v3 + 12 * v2);
    long long v9 = v5;
    unint64_t v10 = v4;
    while (v8[1] < *(v9 - 1) || *v8 > *v9)
    {
      v9 += 3;
      if (!--v10) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

char *add_nonoverlapping_range(char *result, unsigned int *a2, unint64_t a3)
{
  unint64_t v4 = result;
  unint64_t v5 = *((void *)result + 2);
  if (v5 <= a3)
  {
LABEL_6:
    uint64_t v12 = *(void *)a2;
    int v13 = a2[2];
    return add_range((uint64_t)result, v12, v13);
  }
  else
  {
    unint64_t v6 = a3;
    uint64_t v7 = a2[1];
    uint64_t v8 = (unsigned int *)(*((void *)result + 3) + 12 * a3 + 4);
    while (1)
    {
      unsigned int v9 = *(v8 - 1);
      if (v7 >= v9)
      {
        uint64_t v10 = *a2;
        unsigned int v11 = *v8;
        if (v10 <= *v8) {
          break;
        }
      }
      ++v6;
      v8 += 3;
      if (v5 == v6) {
        goto LABEL_6;
      }
    }
    int v17 = 0;
    unint64_t v16 = 0;
    if (v10 < v9)
    {
      int v14 = *((unsigned __int16 *)a2 + 4);
      unint64_t v16 = v10 | ((unint64_t)(v9 - 1) << 32);
      int v17 = v14;
      double result = (char *)add_nonoverlapping_range(result, &v16, v6 + 1);
      uint64_t v7 = a2[1];
      unsigned int v11 = *(_DWORD *)(*((void *)v4 + 3) + 12 * v6 + 4);
    }
    if (v7 > v11)
    {
      int v15 = (unsigned __int16)(v11 + 1 + *((_WORD *)a2 + 4) - *a2);
      unint64_t v16 = (v11 + 1) | (unint64_t)(v7 << 32);
      int v17 = v15;
      return (char *)add_nonoverlapping_range(v4, &v16, v6 + 1);
    }
  }
  return result;
}

uint64_t compare_ranges(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t cmap_cid_set_find_matching_range(uint64_t result, int a2, uint64_t a3)
{
  __kedouble y = a2;
  if (result)
  {
    uint64_t v4 = result;
    cmap_cid_set_normalize(result);
    double result = (uint64_t)bsearch(&__key, *(const void **)(v4 + 24), *(void *)(v4 + 16), 0xCuLL, (int (__cdecl *)(const void *, const void *))compare_code_with_range);
    if (result)
    {
      uint64_t v5 = *(void *)result;
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(result + 8);
      *(void *)a3 = v5;
      return 1;
    }
  }
  return result;
}

uint64_t compare_code_with_range(_DWORD *a1, _DWORD *a2)
{
  if (*a1 >= *a2) {
    return *a1 > a2[1];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t cmap_cid_set_create_with_stream(__CFReadStream *a1)
{
  buffer[0] = 0;
  uint64_t v2 = 0;
  if (!CFReadStreamRead(a1, buffer, 1)) {
    return v2;
  }
  int v3 = buffer[0];
  if (!buffer[0]) {
    return v2;
  }
  if (buffer[0] > 4u || ((1 << buffer[0]) & 0x16) == 0) {
    return 0;
  }
  uint64_t v5 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401AE633E8uLL);
  uint64_t v2 = (uint64_t)v5;
  if (!v5) {
    return v2;
  }
  *uint64_t v5 = v3;
  v5[32] = 0;
  *(_DWORD *)buffer = 0;
  CFIndex v6 = CFReadStreamRead(a1, buffer, 4);
  uint64_t v7 = bswap32(*(unsigned int *)buffer);
  if (v6) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)(v2 + 8) = v8;
  unsigned int v9 = malloc_type_malloc(12 * v8, 0x1000040CBA68D63uLL);
  *(void *)(v2 + 24) = v9;
  if (!v9)
  {
    free((void *)v2);
    return 0;
  }
  if (v8)
  {
    if ((v3 - 1) >= 2 && v3 != 4) {
      abort();
    }
    do
    {
      if (v3 == 2)
      {
        *(_WORD *)buffer = 0;
        CFIndex v13 = CFReadStreamRead(a1, buffer, 2);
        unsigned int v14 = bswap32(*(unsigned __int16 *)buffer) >> 16;
        if (v13) {
          unsigned int v10 = v14;
        }
        else {
          unsigned int v10 = 0;
        }
        *(_WORD *)buffer = 0;
        CFIndex v11 = CFReadStreamRead(a1, buffer, 2);
        unsigned int v12 = bswap32(*(unsigned __int16 *)buffer) >> 16;
      }
      else if (v3 == 1)
      {
        buffer[0] = 0;
        if (CFReadStreamRead(a1, buffer, 1)) {
          unsigned int v10 = buffer[0];
        }
        else {
          unsigned int v10 = 0;
        }
        buffer[0] = 0;
        CFIndex v11 = CFReadStreamRead(a1, buffer, 1);
        unsigned int v12 = buffer[0];
      }
      else
      {
        *(_DWORD *)buffer = 0;
        CFIndex v15 = CFReadStreamRead(a1, buffer, 4);
        unsigned int v16 = bswap32(*(unsigned int *)buffer);
        if (v15) {
          unsigned int v10 = v16;
        }
        else {
          unsigned int v10 = 0;
        }
        *(_DWORD *)buffer = 0;
        CFIndex v11 = CFReadStreamRead(a1, buffer, 4);
        unsigned int v12 = bswap32(*(unsigned int *)buffer);
      }
      if (v11) {
        uint64_t v17 = v12;
      }
      else {
        uint64_t v17 = 0;
      }
      *(_WORD *)buffer = 0;
      CFIndex v18 = CFReadStreamRead(a1, buffer, 2);
      unsigned int v19 = bswap32(*(unsigned __int16 *)buffer) >> 16;
      if (v18) {
        int v20 = v19;
      }
      else {
        int v20 = 0;
      }
      add_range(v2, v10 | (unint64_t)(v17 << 32), v20);
      *(unsigned char *)(v2 + 32) = 1;
      --v8;
    }
    while (v8);
  }
  *(unsigned char *)(v2 + 32) = 0;
  return v2;
}

BOOL CGPDFTaggedNodeEqualToPDFTaggedNode(uint64_t a1, uint64_t a2)
{
  if (!(a1 | a2)) {
    return 1;
  }
  BOOL v2 = 0;
  if (a1 && a2)
  {
    CFArrayRef v6 = *(const __CFArray **)(a1 + 96);
    unint64_t v7 = v6 ? CFArrayGetCount(v6) : 0;
    CFArrayRef v8 = *(const __CFArray **)(a2 + 96);
    CFIndex v9 = v8 ? CFArrayGetCount(v8) : 0;
    Name = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(a1 + 16));
    CFIndex v11 = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(a2 + 16));
    uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
    uint64_t v14 = v13;
    uint64_t v15 = CGPDFTaggedNodeGetTextRange(a2);
    BOOL v2 = 0;
    if (v7 == v9 && Name == v11)
    {
      BOOL v2 = 0;
      if (TextRange == v15 && v14 == v16)
      {
        if (!v7) {
          return 1;
        }
        BOOL v2 = 0;
        for (i = 0; i != v7; BOOL v2 = i >= v7)
        {
          ChildAtIndedouble x = CGPDFTaggedNodeGetChildAtIndex(a1, i);
          unsigned int v19 = CGPDFTaggedNodeGetChildAtIndex(a2, i);
          if ((CGPDFTaggedNodeEqualToPDFTaggedNode(ChildAtIndex, v19) & 1) == 0) {
            break;
          }
          ++i;
        }
      }
    }
  }
  return v2;
}

uint64_t CGPDFTaggedNodeGetTextRange(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 104))
    {
      if (!*(unsigned char *)(result + 168))
      {
        double result = GetTextRangeForTaggedNode(result);
        *(void *)(v1 + 176) = result;
        *(void *)(v1 + 184) = v2;
        *(unsigned char *)(v1 + 168) = 1;
        return result;
      }
    }
    else if (!*(unsigned char *)(result + 168))
    {
      v3[0] = MEMORY[0x1E4F143A8];
      v3[1] = 3221225472;
      v3[2] = __CGPDFTaggedNodeGetTextRange_block_invoke;
      v3[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
      v3[4] = result;
      CGPDFTaggedNodeEnumerateChildren(result, v3);
      *(unsigned char *)(v1 + 168) = 1;
      *(unsigned char *)(v1 + 192) = 0;
    }
    return *(void *)(v1 + 176);
  }
  return result;
}

const void *CGPDFTaggedNodeGetChildAtIndex(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 0;
  }
  CFArrayRef v3 = *(const __CFArray **)(a1 + 96);
  if (!v3 || CFArrayGetCount(v3) <= a2) {
    return 0;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 96);

  return CFArrayGetValueAtIndex(v5, a2);
}

uint64_t GetTextRangeForTaggedNode(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x4012000000;
  CFIndex v18 = __Block_byref_object_copy__47;
  unsigned int v19 = __Block_byref_object_dispose__48;
  int v20 = "";
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 16);
    BOOL v3 = v2 == 700 || v2 == 1;
    if (v3 && (CGPDFNodeGetTextRange(*(void *)(a1 + 104)), v4 >= 1))
    {
      uint64_t v5 = v16[6];
      uint64_t v6 = v16[7];
      uint64_t TextRange = CGPDFNodeGetTextRange(*(void *)(v1 + 104));
      uint64_t v1 = TextRange;
      uint64_t v9 = v8;
      if (v6 >= 1)
      {
        if (v8 < 1)
        {
          uint64_t v9 = v6;
          uint64_t v1 = v5;
        }
        else
        {
          uint64_t v10 = v6 + v5 - TextRange;
          if (v8 > v10) {
            uint64_t v10 = v8;
          }
          uint64_t v11 = v8 - v5 + TextRange;
          if (v6 > v11) {
            uint64_t v11 = v6;
          }
          if (v5 < TextRange) {
            uint64_t v9 = v11;
          }
          else {
            uint64_t v9 = v10;
          }
          if (v5 < TextRange) {
            uint64_t v1 = v5;
          }
        }
      }
      unsigned int v12 = v16;
      v16[6] = v1;
      v12[7] = v9;
    }
    else
    {
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = ___ZL25GetTextRangeForTaggedNodeP15CGPDFTaggedNode_block_invoke;
      v14[3] = &unk_1E52CC140;
      v14[4] = &v15;
      CGPDFTaggedNodeEnumerateChildren(v1, v14);
      uint64_t v1 = v16[6];
    }
  }
  _Block_object_dispose(&v15, 8);
  return v1;
}

void sub_184F552AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CGPDFTaggedNodeGetTextRange_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(v3 + 176);
  uint64_t v5 = *(void *)(v3 + 184);
  uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a2);
  if (v5 >= 1)
  {
    if (v7 < 1)
    {
      uint64_t v7 = v5;
LABEL_8:
      uint64_t TextRange = v4;
      goto LABEL_11;
    }
    if (v4 < TextRange)
    {
      if (v5 <= v7 - v4 + TextRange) {
        uint64_t v7 = v7 - v4 + TextRange;
      }
      else {
        uint64_t v7 = v5;
      }
      goto LABEL_8;
    }
    if (v7 <= v5 + v4 - TextRange) {
      uint64_t v7 = v5 + v4 - TextRange;
    }
  }
LABEL_11:
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(v8 + 176) = TextRange;
  *(void *)(v8 + 184) = v7;
  return 1;
}

void CGPDFTaggedNodeEnumerateChildren(uint64_t a1, void *a2)
{
  uint64_t v11 = a2;
  if (a1)
  {
    if (v11)
    {
      CFArrayRef v3 = *(const __CFArray **)(a1 + 96);
      if (v3)
      {
        CFIndex Count = CFArrayGetCount(v3);
        if (Count)
        {
          unint64_t v5 = 0;
          CFIndex v6 = Count - 1;
          do
          {
            ChildAtIndedouble x = CGPDFTaggedNodeGetChildAtIndex(a1, v5);
            char v8 = v11[2](v11, ChildAtIndex, v5);
            if (v6 == v5++) {
              char v10 = 0;
            }
            else {
              char v10 = v8;
            }
          }
          while ((v10 & 1) != 0);
        }
      }
    }
  }
}

void sub_184F553F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__47(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t ___ZL25GetTextRangeForTaggedNodeP15CGPDFTaggedNode_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = *(void *)(v3 + 48);
  uint64_t v5 = *(void *)(v3 + 56);
  uint64_t TextRangeForTaggedNode = GetTextRangeForTaggedNode(a2);
  if (v5 >= 1)
  {
    if (v7 < 1)
    {
      uint64_t v7 = v5;
LABEL_8:
      uint64_t TextRangeForTaggedNode = v4;
      goto LABEL_11;
    }
    if (v4 < TextRangeForTaggedNode)
    {
      if (v5 <= v7 - v4 + TextRangeForTaggedNode) {
        uint64_t v7 = v7 - v4 + TextRangeForTaggedNode;
      }
      else {
        uint64_t v7 = v5;
      }
      goto LABEL_8;
    }
    if (v7 <= v5 + v4 - TextRangeForTaggedNode) {
      uint64_t v7 = v5 + v4 - TextRangeForTaggedNode;
    }
  }
LABEL_11:
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  *(void *)(v8 + 48) = TextRangeForTaggedNode;
  *(void *)(v8 + 56) = v7;
  return 1;
}

CFIndex CGPDFTaggedNodeGetChildCount(uint64_t a1)
{
  if (a1 && (CFArrayRef v1 = *(const __CFArray **)(a1 + 96)) != 0) {
    return CFArrayGetCount(v1);
  }
  else {
    return 0;
  }
}

uint64_t CGPDFTaggedNodeGetType(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 16);
  }
  return result;
}

uint64_t CGPDFTaggedNodeConvertStringRangeToTextRange(uint64_t a1, int64_t a2, uint64_t a3)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unsigned int v12 = (void **)&v13;
  if (*(unsigned char *)(a1 + 8)) {
    return -1;
  }
  uint64_t result = *(void *)(a1 + 152);
  uint64_t v7 = *(void **)(a1 + 160);
  if ((void *)result != v7)
  {
    int64_t v8 = *(v7 - 1);
    int64_t v9 = a3 + a2;
    uint64_t v10 = -1;
    if ((a2 & 0x8000000000000000) == 0 && a2 < v8) {
      uint64_t v10 = (uint64_t)PageLayout::convertStringRangeIndexToTextRangeIndex((void *)result, v7, a2);
    }
    uint64_t v11 = (void *)v10;
    if ((v9 & 0x8000000000000000) == 0)
    {
      uint64_t v11 = PageLayout::convertStringRangeIndexToTextRangeIndex(*(void **)(a1 + 152), *(void **)(a1 + 160), v9);
      if (v9 < v8 && objc_msgSend(*(id *)(a1 + 24), "characterAtIndex:", v9, v12) == 10) {
        uint64_t v11 = (void *)((char *)v11 + 1);
      }
    }
    *(void *)&long long v16 = v10;
    *((void *)&v16 + 1) = (char *)v11 - v10;
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](&v12, &v16);
    if (v13 == v14)
    {
      uint64_t v3 = -1;
      if (!v14) {
        return v3;
      }
    }
    else
    {
      uint64_t v3 = *v13;
    }
    uint64_t v14 = v13;
    operator delete(v13);
    return v3;
  }
  __break(1u);
  return result;
}

void sub_184F555EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGPDFTaggedNodePrint(uint64_t result)
{
  if (result) {
    return CGPDFTaggedNodePrintTabbed(result, 0);
  }
  return result;
}

uint64_t CGPDFTaggedNodePrintTabbed(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  CFArrayRef v4 = *(const __CFArray **)(result + 96);
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (!a2) {
      goto LABEL_8;
    }
  }
  else
  {
    CFIndex Count = 0;
    if (!a2) {
      goto LABEL_8;
    }
  }
  uint64_t v6 = a2;
  do
  {
    printf("    ");
    --v6;
  }
  while (v6);
LABEL_8:
  Name = CGPDFTaggedNodeTypeGetName(*(_DWORD *)(v3 + 16));
  int TextRange = CGPDFTaggedNodeGetTextRange(v3);
  int v10 = v9;
  double Bounds = CGPDFTaggedNodeGetBounds(v3);
  uint64_t result = printf("CGPDFTaggedNodeRef: %p, type: <%s>, page %d, child count: %zu, text range: [%d, %d], bounds: (%.2f, %.2f), [%.2f, %.2f]\n", (const void *)v3, Name, *(void *)(v3 + 160), Count, TextRange, v10, Bounds, v12, v13, v14);
  if (Count)
  {
    for (unint64_t i = 0; i != Count; ++i)
    {
      ChildAtIndedouble x = CGPDFTaggedNodeGetChildAtIndex(v3, i);
      uint64_t v17 = ChildAtIndex;
      if (ChildAtIndex)
      {
        int v18 = ChildAtIndex[4];
        if (v18 == 700 || v18 == 1)
        {
          if (a2 != -1)
          {
            uint64_t v20 = a2 + 1;
            do
            {
              printf("    ");
              --v20;
            }
            while (v20);
          }
          uint64_t v21 = CGPDFTaggedNodeTypeGetName(v18);
          uint64_t result = printf("Leaf-node type: %s.\n", v21);
          continue;
        }
      }
      else
      {
        int v18 = 0;
      }
      if (a2)
      {
        uint64_t v22 = a2;
        do
        {
          printf("    ");
          --v22;
        }
        while (v22);
      }
      double v23 = CGPDFTaggedNodeTypeGetName(v18);
      printf("Tagged node type: %s.\n", v23);
      uint64_t result = CGPDFTaggedNodePrintTabbed(v17, a2 + 1);
    }
  }
  return result;
}

double CGPDFTaggedNodeGetBounds(uint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  if (*(unsigned char *)(a1 + 48)) {
    return *(double *)(a1 + 56);
  }
  uint64_t v7 = 0;
  int64_t v8 = (double *)&v7;
  uint64_t v9 = 0x5012000000;
  int v10 = __Block_byref_object_copy__13982;
  uint64_t v11 = __Block_byref_object_dispose__13983;
  double v12 = "";
  CGRect v13 = CGRectNull;
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __CGPDFTaggedNodeGetBounds_block_invoke;
  v6[3] = &unk_1E52CC140;
  UInt8 v6[4] = &v7;
  CGPDFTaggedNodeEnumerateChildren(a1, v6);
  *(unsigned char *)(a1 + 48) = 1;
  uint64_t v3 = v8;
  long long v4 = *((_OWORD *)v8 + 4);
  *(_OWORD *)(a1 + 56) = *((_OWORD *)v8 + 3);
  *(_OWORD *)(a1 + 72) = v4;
  double v2 = v3[6];
  _Block_object_dispose(&v7, 8);
  return v2;
}

void sub_184F558F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__13982(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

uint64_t __CGPDFTaggedNodeGetBounds_block_invoke(uint64_t a1, uint64_t a2)
{
  long long v3 = *(double **)(*(void *)(a1 + 32) + 8);
  CGFloat v4 = v3[6];
  CGFloat v5 = v3[7];
  CGFloat v6 = v3[8];
  CGFloat v7 = v3[9];
  v13.origin.double x = CGPDFTaggedNodeGetBounds(a2);
  v13.origin.double y = v8;
  v13.size.double width = v9;
  v13.size.double height = v10;
  v12.origin.double x = v4;
  v12.origin.double y = v5;
  v12.size.double width = v6;
  v12.size.double height = v7;
  *(CGRect *)(*(void *)(*(void *)(a1 + 32) + 8) + 48) = CGRectUnion(v12, v13);
  return 1;
}

CFTypeRef CGPDFTaggedNodeRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void CGPDFTaggedNodeRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFTaggedNodeGetTypeName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

BOOL CGPDFTaggedNodeIsImage(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 113) != 0;
  }
  return result;
}

double CGPDFTaggedNodeGetBoundsForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return INFINITY;
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6)
  {
    uint64_t v7 = CGPDFNodeGetTextRange(*(void *)(a1 + 104)) + a2;
    while (*(_DWORD *)v6 != 517)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6)
      {
        uint64_t v8 = 0;
        return CGPDFLayoutGetBoundsForTextRange(v8, v7, a3);
      }
    }
    uint64_t v8 = *(void *)(v6 + 104);
    return CGPDFLayoutGetBoundsForTextRange(v8, v7, a3);
  }
  else
  {
    uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (a2 + a3 > v11) {
      CFIndex v12 = -1;
    }
    else {
      CFIndex v12 = TextRange + a2;
    }
    if (a2 + a3 > v11) {
      a3 = 0;
    }
    double v9 = INFINITY;
    if (v12 != -1)
    {
      if (a3)
      {
        CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
        double v14 = (const void *)v13;
        v17.locatiouint64_t n = v12;
        v17.length = a3;
        PageLayout::GetBoundsForTextRange((PageLayout *)(v13 + 16), v17);
        double v9 = v15;
        if (v14) {
          CFRelease(v14);
        }
      }
    }
  }
  return v9;
}

double CGPDFTaggedNodeGetBoundsForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && !*(void *)(a1 + 104))
  {
    int64_t PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
    uint64_t v8 = v7;
    CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
    CGFloat v10 = (const void *)v9;
    uint64_t v17 = v9;
    uint64_t v11 = (PageLayout *)(v9 + 16);
    PageLayout::PageLayout((PageLayout *)v16, (const PageLayout *)(v9 + 16));
    CFIndex v12 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v16, PageStringRangeFromStringRange, v8);
    CFIndex v14 = v13;
    PageLayout::~PageLayout((PageLayout *)v16);
    if (v12 == -1)
    {
      double v4 = INFINITY;
      if (!v10) {
        return v4;
      }
    }
    else
    {
      v18.locatiouint64_t n = v12;
      v18.length = v14;
      PageLayout::GetBoundsForTextRange(v11, v18);
      double v4 = v15;
      if (!v10) {
        return v4;
      }
    }
    CFRelease(v10);
    return v4;
  }
  return INFINITY;
}

void sub_184F55C2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PageLayout::~PageLayout((PageLayout *)va);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v2 - 88));
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeGetPageStringRangeFromStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 104)) {
    return 0;
  }
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  uint64_t v8 = v7;
  uint64_t v17 = v7;
  uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
  uint64_t v11 = v10;
  PageLayout::PageLayout((PageLayout *)v16, (const PageLayout *)(v8 + 16));
  uint64_t v12 = CGPDFTaggedNodeConvertTextRangeToStringRange((uint64_t)v16, TextRange, v11);
  uint64_t v14 = v13;
  PageLayout::~PageLayout((PageLayout *)v16);
  if (a2 + a3 > v14) {
    uint64_t v3 = -1;
  }
  else {
    uint64_t v3 = v12 + a2;
  }
  if (v8) {
    CFRelease((CFTypeRef)v8);
  }
  return v3;
}

void sub_184F55D20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PageLayout::~PageLayout((PageLayout *)va);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v2 - 56));
  _Unwind_Resume(a1);
}

void PageLayout::PageLayout(PageLayout *this, const PageLayout *a2)
{
  long long v5 = *(_OWORD *)a2;
  *((void *)this + 2) = *((void *)a2 + 2);
  *(_OWORD *)this = v5;
  id v6 = *((id *)a2 + 3);
  *((void *)this + 4) = 0;
  *((void *)this + 3) = v6;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  std::vector<PageLayout::TextLine>::__init_with_size[abi:fe180100]<PageLayout::TextLine*,PageLayout::TextLine*>((void *)this + 4, *((const void **)a2 + 4), *((void *)a2 + 5), 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)a2 + 5) - *((void *)a2 + 4)) >> 3));
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  uint64_t v8 = (unsigned char *)*((void *)a2 + 7);
  uint64_t v7 = (unsigned char *)*((void *)a2 + 8);
  int64_t v9 = v7 - v8;
  if (v7 != v8)
  {
    std::vector<unsigned short>::__vallocate[abi:fe180100]((void *)this + 7, v9 >> 1);
    uint64_t v10 = (char *)*((void *)this + 8);
    memmove(v10, v8, v9);
    *((void *)this + 8) = &v10[2 * (v9 >> 1)];
  }
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>((void *)this + 10, *((const void **)a2 + 10), *((void *)a2 + 11), (uint64_t)(*((void *)a2 + 11) - *((void *)a2 + 10)) >> 3);
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  std::vector<CGRect>::__init_with_size[abi:fe180100]<CGRect*,CGRect*>((void *)this + 13, *((const void **)a2 + 13), *((void *)a2 + 14), (uint64_t)(*((void *)a2 + 14) - *((void *)a2 + 13)) >> 5);
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  std::vector<CGRect>::__init_with_size[abi:fe180100]<CGRect*,CGRect*>((void *)this + 16, *((const void **)a2 + 16), *((void *)a2 + 17), (uint64_t)(*((void *)a2 + 17) - *((void *)a2 + 16)) >> 5);
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>((void *)this + 19, *((const void **)a2 + 19), *((void *)a2 + 20), (uint64_t)(*((void *)a2 + 20) - *((void *)a2 + 19)) >> 3);
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  uint64_t v11 = *((void *)a2 + 22);
  uint64_t v12 = *((void *)a2 + 23);
  double v60 = (char *)this + 176;
  LOBYTE(v61) = 0;
  if (v12 != v11)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v11) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v14 = std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v13);
    *((void *)this + 22) = v14;
    *((void *)this + 23) = v14;
    *((void *)this + 24) = &v14[3 * v15];
    do
    {
      *(_OWORD *)uint64_t v14 = *(_OWORD *)v11;
      uint64_t v16 = *(void *)(v11 + 16);
      if (v16) {
        CFRetain(*(CFTypeRef *)(v11 + 16));
      }
      v14[2] = v16;
      v14 += 3;
      v11 += 24;
    }
    while (v11 != v12);
    *((void *)this + 23) = v14;
  }
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>((void *)this + 25, *((const void **)a2 + 25), *((void *)a2 + 26), (uint64_t)(*((void *)a2 + 26) - *((void *)a2 + 25)) >> 3);
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  std::vector<double>::__init_with_size[abi:fe180100]<double *,double *>((void *)this + 28, *((const void **)a2 + 28), *((void *)a2 + 29), (uint64_t)(*((void *)a2 + 29) - *((void *)a2 + 28)) >> 3);
  *((void *)this + 31) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  uint64_t v17 = (long long *)*((void *)a2 + 31);
  CFRange v18 = (long long *)*((void *)a2 + 32);
  uint64_t v19 = (char *)v18 - (char *)v17;
  if (v18 != v17)
  {
    if (v19 < 0) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v20 = (std::string *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v19 >> 5);
    *((void *)this + 31) = v20;
    *((void *)this + 32) = v20;
    *((void *)this + 33) = (char *)v20 + 32 * v21;
    double v64 = v20;
    double v65 = v20;
    double v60 = (char *)this + 264;
    double v61 = (char **)&v64;
    double v62 = (char **)&v65;
    uint64_t v22 = v20;
    char v63 = 0;
    do
    {
      if (*((char *)v17 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)v17, *((void *)v17 + 1));
        double v24 = v65;
      }
      else
      {
        long long v23 = *v17;
        v22->__r_.__value_.__r.__words[2] = *((void *)v17 + 2);
        *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v23;
        double v24 = v22;
      }
      LODWORD(v22[1].__r_.__value_.__l.__data_) = *((_DWORD *)v17 + 6);
      v17 += 2;
      uint64_t v22 = (std::string *)((char *)v24 + 32);
      double v65 = (std::string *)((char *)v24 + 32);
    }
    while (v17 != v18);
    char v63 = 1;
    std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,unsigned int>>,std::pair<std::string,unsigned int>*>>::~__exception_guard_exceptions[abi:fe180100]((uint64_t)&v60);
    *((void *)this + 32) = v22;
  }
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = 0;
  std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>((void *)this + 34, *((const void **)a2 + 34), *((void *)a2 + 35), (uint64_t)(*((void *)a2 + 35) - *((void *)a2 + 34)) >> 3);
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
  std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>((void *)this + 37, *((const void **)a2 + 37), *((void *)a2 + 38), (uint64_t)(*((void *)a2 + 38) - *((void *)a2 + 37)) >> 3);
  *((void *)this + 40) = *((id *)a2 + 40);
  *((void *)this + 41) = *((id *)a2 + 41);
  double v25 = (uint64_t *)((char *)this + 336);
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_DWORD *)this + 92) = *((_DWORD *)a2 + 92);
  std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>((uint64_t)this + 336, *((void *)a2 + 43));
  uint64_t v26 = (uint64_t *)*((void *)a2 + 44);
  if (v26)
  {
    double v27 = (void *)((char *)this + 352);
    do
    {
      unint64_t v28 = *((unsigned int *)v26 + 4);
      unint64_t v29 = *((void *)this + 43);
      if (v29)
      {
        uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
        v30.i16[0] = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          unint64_t v2 = *((unsigned int *)v26 + 4);
          if (v29 <= v28) {
            unint64_t v2 = v28 % v29;
          }
        }
        else
        {
          unint64_t v2 = (v29 - 1) & v28;
        }
        double v31 = *(uint64_t ***)(*v25 + 8 * v2);
        if (v31)
        {
          for (unint64_t i = *v31; i; unint64_t i = (uint64_t *)*i)
          {
            unint64_t v33 = i[1];
            if (v33 == v28)
            {
              if (*((_DWORD *)i + 4) == v28) {
                goto LABEL_58;
              }
            }
            else
            {
              if (v30.u32[0] > 1uLL)
              {
                if (v33 >= v29) {
                  v33 %= v29;
                }
              }
              else
              {
                v33 &= v29 - 1;
              }
              if (v33 != v2) {
                break;
              }
            }
          }
        }
      }
      double v34 = operator new(0x20uLL);
      *double v34 = 0;
      v34[1] = v28;
      *((_DWORD *)v34 + 4) = *((_DWORD *)v26 + 4);
      v34[3] = (id)v26[3];
      float v35 = (float)(unint64_t)(*((void *)this + 45) + 1);
      float v36 = *((float *)this + 92);
      if (!v29 || (float)(v36 * (float)v29) < v35)
      {
        BOOL v37 = (v29 & (v29 - 1)) != 0;
        if (v29 < 3) {
          BOOL v37 = 1;
        }
        unint64_t v38 = v37 | (2 * v29);
        unint64_t v39 = vcvtps_u32_f32(v35 / v36);
        if (v38 <= v39) {
          size_t v40 = v39;
        }
        else {
          size_t v40 = v38;
        }
        std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>((uint64_t)this + 336, v40);
        unint64_t v29 = *((void *)this + 43);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v29 <= v28) {
            unint64_t v2 = v28 % v29;
          }
          else {
            unint64_t v2 = v28;
          }
        }
        else
        {
          unint64_t v2 = (v29 - 1) & v28;
        }
      }
      uint64_t v41 = *v25;
      uint64_t v42 = *(void **)(*v25 + 8 * v2);
      if (v42)
      {
        *double v34 = *v42;
      }
      else
      {
        *double v34 = *v27;
        *double v27 = v34;
        *(void *)(v41 + 8 * v2) = v27;
        if (!*v34) {
          goto LABEL_57;
        }
        unint64_t v43 = *(void *)(*v34 + 8);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v43 >= v29) {
            v43 %= v29;
          }
        }
        else
        {
          v43 &= v29 - 1;
        }
        uint64_t v42 = (void *)(*v25 + 8 * v43);
      }
      *uint64_t v42 = v34;
LABEL_57:
      ++*((void *)this + 45);
LABEL_58:
      uint64_t v26 = (uint64_t *)*v26;
    }
    while (v26);
  }
  int v44 = *((_DWORD *)a2 + 94);
  *((unsigned char *)this + 380) = *((unsigned char *)a2 + 380);
  *((_DWORD *)this + 94) = v44;
  *((void *)this + 49) = 0;
  *((void *)this + 50) = 0;
  *((void *)this + 48) = 0;
  double v46 = (unsigned char *)*((void *)a2 + 48);
  unint64_t v45 = (unsigned char *)*((void *)a2 + 49);
  int64_t v47 = v45 - v46;
  if (v45 != v46)
  {
    if (0xCCCCCCCCCCCCCCCDLL * (v47 >> 3) >= 0x666666666666667) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    double v48 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::Column>>(0xCCCCCCCCCCCCCCCDLL * (v47 >> 3));
    *((void *)this + 48) = v48;
    *((void *)this + 49) = v48;
    *((void *)this + 50) = &v48[40 * v49];
    memmove(v48, v46, v47);
    *((void *)this + 49) = &v48[8 * (v47 >> 3)];
  }
  *((void *)this + 51) = 0;
  *((void *)this + 52) = 0;
  *((void *)this + 53) = 0;
  std::vector<CGRect>::__init_with_size[abi:fe180100]<CGRect*,CGRect*>((void *)this + 51, *((const void **)a2 + 51), *((void *)a2 + 52), (uint64_t)(*((void *)a2 + 52) - *((void *)a2 + 51)) >> 5);
  *((void *)this + 54) = 0;
  *((void *)this + 55) = 0;
  *((void *)this + 56) = 0;
  double v51 = (unsigned char *)*((void *)a2 + 54);
  BOOL v50 = (unsigned char *)*((void *)a2 + 55);
  int64_t v52 = v50 - v51;
  if (v50 != v51)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v52 >> 3) > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    double v53 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(0xAAAAAAAAAAAAAAABLL * (v52 >> 3));
    *((void *)this + 54) = v53;
    *((void *)this + 55) = v53;
    *((void *)this + 56) = &v53[24 * v54];
    memmove(v53, v51, v52);
    *((void *)this + 55) = &v53[8 * (v52 >> 3)];
  }
  *((void *)this + 57) = 0;
  *((void *)this + 58) = 0;
  *((void *)this + 59) = 0;
  CGRect v56 = (unsigned char *)*((void *)a2 + 57);
  __n128 v55 = (unsigned char *)*((void *)a2 + 58);
  int64_t v57 = v55 - v56;
  if (v55 != v56)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v57 >> 3) > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v58 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(0xAAAAAAAAAAAAAAABLL * (v57 >> 3));
    *((void *)this + 57) = v58;
    *((void *)this + 58) = v58;
    *((void *)this + 59) = &v58[24 * v59];
    memmove(v58, v56, v57);
    *((void *)this + 58) = &v58[8 * (v57 >> 3)];
  }
}

void sub_184F56434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void **a21)
{
  double v24 = *v22;
  if (*v22)
  {
    *(void *)(v21 + 64) = v24;
    operator delete(v24);
  }
  double v25 = *a21;
  if (*a21)
  {
    *(void *)(v21 + 40) = v25;
    operator delete(v25);
  }

  _Unwind_Resume(a1);
}

void *std::vector<unsigned long>::__init_with_size[abi:fe180100]<unsigned long *,unsigned long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    id v6 = result;
    __n128 result = std::vector<unsigned long>::__vallocate[abi:fe180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184F566B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<CGRect>::__init_with_size[abi:fe180100]<CGRect*,CGRect*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    id v6 = result;
    __n128 result = std::vector<CGRect>::__vallocate[abi:fe180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184F5672C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<double>::__init_with_size[abi:fe180100]<double *,double *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    id v6 = result;
    __n128 result = std::vector<unsigned long>::__vallocate[abi:fe180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184F567A8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<std::string,unsigned int>>,std::pair<std::string,unsigned int>*>>::~__exception_guard_exceptions[abi:fe180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    while (v3 != v4)
    {
      if (*(char *)(v3 - 9) < 0) {
        operator delete(*(void **)(v3 - 32));
      }
      v3 -= 32;
    }
  }
  return a1;
}

uint64_t CGPDFTaggedNodeConvertTextRangeToStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = a2;
  v10[1] = a3;
  uint64_t v7 = 0;
  size_t v8 = 0;
  uint64_t v9 = 0;
  v6[0] = v10;
  v6[1] = 1;
  long long v5 = (void **)&v7;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v6, &v5);
  if (v7 != v8)
  {
    uint64_t v3 = *v7;
LABEL_4:
    size_t v8 = v7;
    operator delete(v7);
    return v3;
  }
  uint64_t v3 = -1;
  if (v7) {
    goto LABEL_4;
  }
  return v3;
}

void sub_184F568A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL CGPDFTaggedNodeIsFromTaggedStructure(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 112) != 0;
  }
  return result;
}

uint64_t CGPDFTaggedNodeGetAltText(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t CGPDFTaggedNodeGetActualText(uint64_t result)
{
  if (result) {
    return *(void *)(result + 128);
  }
  return result;
}

uint64_t CGPDFTaggedNodeGetTitleText(uint64_t result)
{
  if (result) {
    return *(void *)(result + 136);
  }
  return result;
}

uint64_t CGPDFTaggedNodeGetLanguageText(uint64_t result)
{
  if (result) {
    return *(void *)(result + 144);
  }
  return result;
}

__CFString *CGPDFTaggedNodeCreateString(void *a1)
{
  if (!a1) {
    return 0;
  }
  if (a1[13])
  {
    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    AppendNodeString((uint64_t)a1, Mutable);
    CFIndex Length = CFStringGetLength(Mutable);
    CFIndex v4 = Length - 1;
    if (Length >= 1 && CFStringHasSuffix(Mutable, @" "))
    {
      v10.locatiouint64_t n = v4;
      v10.length = 1;
      CFStringDelete(Mutable, v10);
    }
  }
  else
  {
    CGPDFPageCopyPageLayoutWithCTLD(a1[28], 1);
    id v6 = v5;
    v9[2] = v5;
    CGPDFTaggedNodeCacheStringRanges((uint64_t)a1);
    uint64_t v7 = (uint64_t)(a1[26] - a1[25]) >> 4;
    v9[0] = a1[25];
    v9[1] = v7;
    CFMutableArrayRef Mutable = (__CFString *)PageLayout::CreateStringForStringRanges((uint64_t)v6 + 16, (uint64_t)v9);
    if (v6) {
      CFRelease(v6);
    }
  }
  return Mutable;
}

void sub_184F569F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void AppendNodeString(uint64_t a1, __CFString *a2)
{
  if (!a1)
  {
    int v3 = 0;
LABEL_9:
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZL16AppendNodeStringP15CGPDFTaggedNodeP10__CFString_block_invoke;
    void v9[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
    v9[4] = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v9);
    if (v3 == 200) {
      CFStringAppend(a2, @"\n");
    }
    return;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 1) {
    goto LABEL_9;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    v10[0] = CGPDFNodeGetTextRange(*(void *)(a1 + 104));
    v10[1] = v5;
    while (*(_DWORD *)v4 != 517)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4)
      {
        uint64_t v6 = 0;
        goto LABEL_12;
      }
    }
    uint64_t v6 = *(void *)(v4 + 104);
LABEL_12:
    StringForRanges = CGPDFLayoutCreateStringForRanges(v6, (uint64_t)v10, 1);
    if (StringForRanges)
    {
      size_t v8 = StringForRanges;
      CFStringAppend(a2, StringForRanges);
      CFStringAppend(a2, @" ");
      CFRelease(v8);
    }
  }
}

void CGPDFTaggedNodeCacheStringRanges(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 192)) {
    return;
  }
  unint64_t v2 = (void **)(a1 + 200);
  *(void *)(a1 + 208) = *(void *)(a1 + 200);
  *(unsigned char *)(a1 + 192) = 1;
  uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
  if (TextRange == -1) {
    return;
  }
  uint64_t v5 = v4;
  if (!v4) {
    return;
  }
  unint64_t v6 = TextRange;
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  size_t v8 = (void *)v7;
  v23[0] = v2;
  v23[1] = (void **)v7;
  if (!*(unsigned char *)(v7 + 24))
  {
    uint64_t v19 = *(void *)(v7 + 168);
    unint64_t v20 = (*(void *)(v7 + 176) - v19) >> 3;
    if (v20 <= v6) {
      std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
    }
    if (v20 <= v5 + v6) {
      std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
    }
    uint64_t v21 = *(void *)(v19 + 8 * v6);
    uint64_t v22 = *(void *)(v19 + 8 * (v5 + v6)) - v21;
    *(void *)&long long v25 = v21;
    *((void *)&v25 + 1) = v22;
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](v23, &v25);
LABEL_28:
    CFRelease(v8);
    return;
  }
  id v9 = objc_alloc_init(MEMORY[0x1E4F28E60]);
  if (v5 >= 1)
  {
    int64_t v10 = v5 + v6;
    uint64_t v12 = v8[12];
    uint64_t v11 = v8[13];
    while (1)
    {
      if (v6 >= (v11 - v12) >> 3) {
        goto LABEL_29;
      }
      if (*(void *)(v12 + 8 * v6)) {
        break;
      }
LABEL_20:
      if ((uint64_t)++v6 >= v10) {
        goto LABEL_21;
      }
    }
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = v8[21];
      if (v6 >= (v8[22] - v14) >> 3) {
        std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
      }
      uint64_t v15 = (void *)v8[39];
      uint64_t v16 = (void *)v8[40];
      if (v15 == v16)
      {
        CFRange v18 = (void *)v8[39];
      }
      else
      {
        uint64_t v17 = *(void *)(v14 + 8 * v6) + v13;
        CFRange v18 = (void *)v8[39];
        while (*v18 != v17)
        {
          if (++v18 == v16)
          {
            CFRange v18 = (void *)v8[40];
            break;
          }
        }
      }
      [v9 addIndex:v18 - v15];
      uint64_t v12 = v8[12];
      uint64_t v11 = v8[13];
      if (v6 >= (v11 - v12) >> 3) {
        break;
      }
      if ((unint64_t)++v13 >= *(void *)(v12 + 8 * v6)) {
        goto LABEL_20;
      }
    }
LABEL_29:
    std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
  }
LABEL_21:
  *(void *)&long long v25 = 0;
  *((void *)&v25 + 1) = &v25;
  uint64_t v26 = 0x4012000000;
  double v27 = __Block_byref_object_copy__47;
  unint64_t v28 = __Block_byref_object_dispose__48;
  unint64_t v29 = "";
  long long v30 = xmmword_1850CD8B0;
  v24[0] = MEMORY[0x1E4F143A8];
  v24[1] = 3221225472;
  v24[2] = ___ZNK10PageLayout31ConvertTextRangesToStringRangesIRNSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke;
  _OWORD v24[3] = &unk_1E52CC288;
  v24[4] = &v25;
  v24[5] = v8 + 2;
  v24[6] = v23;
  [v9 enumerateRangesUsingBlock:v24];
  if (*(void *)(*((void *)&v25 + 1) + 48) != -1) {
    std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](v23, (_OWORD *)(*((void *)&v25 + 1) + 48));
  }
  _Block_object_dispose(&v25, 8);

  if (v8) {
    goto LABEL_28;
  }
}

#error "184F56E08: call analysis failed (funcsize=25)"

#error "184F56E98: call analysis failed (funcsize=21)"

void sub_184F56EA4()
{
}

void ***___ZNK10PageLayout31ConvertTextRangesToStringRangesIRNSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = a2 + a3;
  __n128 result = (void ***)[*(id *)(v6 + 24) length];
  if (v7 < (unint64_t)result)
  {
    __n128 result = (void ***)[*(id *)(v6 + 24) characterAtIndex:v7];
    if (result == 10) {
      ++v3;
    }
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v10 = *(void *)(v9 + 48);
  if (v10 != -1)
  {
    uint64_t v11 = *(void *)(v9 + 56);
    if (v11 + v10 == a2)
    {
      *(void *)(v9 + 56) = v11 + v3;
      return result;
    }
    __n128 result = std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](*(void ****)(a1 + 48), (_OWORD *)(v9 + 48));
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  *(void *)(v9 + 48) = a2;
  *(void *)(v9 + 56) = v3;
  return result;
}

uint64_t ___ZL16AppendNodeStringP15CGPDFTaggedNodeP10__CFString_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

__CFString *CGPDFTaggedNodeCreateStringForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6)
      {
        uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
        uint64_t v8 = 0;
LABEL_6:
        uint64_t v9 = 0;
        goto LABEL_19;
      }
    }
    uint64_t v8 = *(void *)(v6 + 104);
    uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v9 = *(void *)(v8 + 48);
LABEL_19:
    uint64_t v17 = TextRange + a2;
    uint64_t v18 = a3 + TextRange + a2;
    if (v18 >= v9) {
      uint64_t v19 = (unsigned char *)v9;
    }
    else {
      uint64_t v19 = (unsigned char *)(a3 + TextRange + a2);
    }
    if (v17 < 0 || v17 >= v9)
    {
      BOOL v21 = v18 > 0 && v17 < 1;
      uint64_t v17 = 0;
      if (v21) {
        unint64_t v20 = v19;
      }
      else {
        unint64_t v20 = 0;
      }
    }
    else
    {
      unint64_t v20 = &v19[-v17];
    }
    __p = (void *)v17;
    double v27 = v20;
    return CGPDFLayoutCreateStringForRanges(v8, (uint64_t)&__p, 1);
  }
  else
  {
    uint64_t StringForStringRanges = 0;
    uint64_t v11 = CGPDFTaggedNodeGetTextRange(a1) + a2;
    if (a2 + a3 <= v12)
    {
      uint64_t v13 = a3;
    }
    else
    {
      uint64_t v11 = -1;
      uint64_t v13 = 0;
    }
    v30[0] = v11;
    v30[1] = v13;
    if (v11 != -1 && v13)
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
      uint64_t v15 = v14;
      uint64_t v28 = 0;
      unint64_t v29 = v14;
      uint64_t v16 = (uint64_t)v14 + 16;
      __p = 0;
      double v27 = 0;
      double v24 = v30;
      uint64_t v25 = 1;
      p_p = &__p;
      PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v14 + 16, (uint64_t)&v24, &p_p);
      double v24 = __p;
      uint64_t v25 = (v27 - (unsigned char *)__p) >> 4;
      uint64_t StringForStringRanges = PageLayout::CreateStringForStringRanges(v16, (uint64_t)&v24);
      if (__p)
      {
        double v27 = __p;
        operator delete(__p);
      }
      if (v15) {
        CFRelease(v15);
      }
    }
  }
  return (__CFString *)StringForStringRanges;
}

void sub_184F5710C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p) {
    operator delete(__p);
  }
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeCreateStringForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || *(void *)(a1 + 104)) {
    return 0;
  }
  uint64_t PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
  uint64_t StringForStringRanges = 0;
  if (PageStringRangeFromStringRange != -1)
  {
    uint64_t v8 = v7;
    if (v7)
    {
      uint64_t v9 = PageStringRangeFromStringRange;
      CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
      uint64_t v11 = v10;
      v13[2] = v10;
      uint64_t v12 = operator new(0x10uLL);
      *uint64_t v12 = v9;
      v12[1] = v8;
      v13[0] = v12;
      v13[1] = 1;
      uint64_t StringForStringRanges = PageLayout::CreateStringForStringRanges((uint64_t)v11 + 16, (uint64_t)v13);
      operator delete(v12);
      if (v11) {
        CFRelease(v11);
      }
    }
  }
  return StringForStringRanges;
}

void sub_184F571F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  operator delete(v12);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a12);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedNodeCreateAttributedString(uint64_t a1)
{
  Attributeduint64_t StringForStringRanges = a1;
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      CFAttributedStringRef Mutable = CFAttributedStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      AppendNodeAttributedString(AttributedStringForStringRanges, Mutable);
      CFIndex Length = CFAttributedStringGetLength(Mutable);
      CFIndex v4 = Length - 1;
      if (Length >= 1)
      {
        CFStringRef String = CFAttributedStringGetString(Mutable);
        if (CFStringHasSuffix(String, @" "))
        {
          v11.locatiouint64_t n = v4;
          v11.length = 1;
          CFAttributedStringReplaceString(Mutable, v11, &stru_1ED0A02B0);
        }
      }
      Attributeduint64_t StringForStringRanges = _updateAttributedStringAttributes((NSAttributedString *)Mutable);
    }
    else
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
      uint64_t v7 = v6;
      void v10[2] = v6;
      CGPDFTaggedNodeCacheStringRanges(AttributedStringForStringRanges);
      uint64_t v8 = (uint64_t)(*(void *)(AttributedStringForStringRanges + 208)
                   - *(void *)(AttributedStringForStringRanges + 200)) >> 4;
      v10[0] = *(void *)(AttributedStringForStringRanges + 200);
      v10[1] = v8;
      Attributeduint64_t StringForStringRanges = (uint64_t)PageLayout::CreateAttributedStringForStringRanges((uint64_t)v7 + 16, (uint64_t)v10);
      if (v7) {
        CFRelease(v7);
      }
    }
  }
  return AttributedStringForStringRanges;
}

void sub_184F5731C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void AppendNodeAttributedString(uint64_t a1, const __CFAttributedString *a2)
{
  if (!a1)
  {
    int v3 = 0;
LABEL_9:
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZL26AppendNodeAttributedStringP15CGPDFTaggedNodeP20__CFAttributedString_block_invoke;
    void v9[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
    v9[4] = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v9);
    if (v3 == 200)
    {
      v11.locatiouint64_t n = CFAttributedStringGetLength(a2);
      v11.length = 0;
      CFAttributedStringReplaceString(a2, v11, @"\n");
    }
    return;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 1) {
    goto LABEL_9;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    v10[0] = CGPDFNodeGetTextRange(*(void *)(a1 + 104));
    v10[1] = v5;
    while (*(_DWORD *)v4 != 517)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4)
      {
        uint64_t v6 = 0;
        goto LABEL_12;
      }
    }
    uint64_t v6 = *(void *)(v4 + 104);
LABEL_12:
    CFAttributedStringRef AttributedStringForRanges = CGPDFLayoutCreateAttributedStringForRanges(v6, (uint64_t)v10, 1);
    if (AttributedStringForRanges)
    {
      CFAttributedStringRef v8 = AttributedStringForRanges;
      v12.locatiouint64_t n = CFAttributedStringGetLength(a2);
      v12.length = 0;
      CFAttributedStringReplaceAttributedString(a2, v12, v8);
      v13.locatiouint64_t n = CFAttributedStringGetLength(a2);
      v13.length = 0;
      CFAttributedStringReplaceString(a2, v13, @" ");
      CFRelease(v8);
    }
  }
}

id _updateAttributedStringAttributes(NSAttributedString *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = (void *)[(NSAttributedString *)v1 mutableCopy];
  uint64_t v3 = [v2 length];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = ___ZL33_updateAttributedStringAttributesP18NSAttributedString_block_invoke;
  v6[3] = &unk_1E52CC200;
  id v4 = v2;
  id v7 = v4;
  objc_msgSend(v4, "enumerateAttributesInRange:options:usingBlock:", 0, v3, 0, v6);

  return v4;
}

void sub_184F5754C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL33_updateAttributedStringAttributesP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  CFAttributedStringRef v8 = (void *)[v7 mutableCopy];
  uint64_t v9 = [v7 objectForKey:kCGPDFTextStyleFont];
  long long v30 = [v7 objectForKey:kCGPDFTextStyleFontSize];
  if (!v9) {
    goto LABEL_14;
  }
  uint64_t v10 = self;
  if ((objc_opt_isKindOfClass() & 1) == 0 || [v9 length] != 8 || !v30)
  {
LABEL_13:

    goto LABEL_14;
  }
  CFRange v11 = self;
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_13;
  }
  uint64_t v12 = [v30 length];

  BOOL v13 = v12 == 8;
  uint64_t v14 = (void *)&unk_1E8F97000;
  if (v13)
  {
    uint64_t v32 = 0;
    [v9 getBytes:&v32 length:8];
    uint64_t Font = CGPDFFontGetFont(v32);
    if (Font)
    {
      uint64_t v16 = (PageLayout *)(*(uint64_t (**)(void))(*(void *)(Font + 16) + 152))(*(void *)(Font + 112));
      if (v16)
      {
        unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(v32);
        if (FontDescriptor) {
          uint64_t v18 = (NSString *)*(unsigned int *)(FontDescriptor + 40);
        }
        else {
          uint64_t v18 = 0;
        }
        double v31 = 0.0;
        [v30 getBytes:&v31 length:8];
        CTuint64_t Font = (void *)PageLayout::CreateCTFont(v16, v18, v31);
        if (CTFont)
        {
          uint64_t v38 = 0;
          unint64_t v39 = &v38;
          uint64_t v40 = 0x2020000000;
          double v27 = (void *)getkCTFontAttributeNameSymbolLoc(void)::ptr;
          uint64_t v41 = getkCTFontAttributeNameSymbolLoc(void)::ptr;
          if (!getkCTFontAttributeNameSymbolLoc(void)::ptr)
          {
            uint64_t v33 = MEMORY[0x1E4F143A8];
            uint64_t v34 = 3221225472;
            float v35 = ___ZL32getkCTFontAttributeNameSymbolLocv_block_invoke_14000;
            float v36 = &unk_1E52CD918;
            BOOL v37 = &v38;
            uint64_t v28 = (void *)CoreTextLibrary();
            unint64_t v29 = dlsym(v28, "kCTFontAttributeName");
            *(void *)(v37[1] + 24) = v29;
            getkCTFontAttributeNameSymbolLoc(void)::ptr = *(void *)(v37[1] + 24);
            double v27 = (void *)v39[3];
          }
          _Block_object_dispose(&v38, 8);
          if (!v27) {
            goto LABEL_31;
          }
          [v8 setObject:CTFont forKey:*v27];

          uint64_t v14 = &unk_1E8F97000;
        }
        [v8 removeObjectForKey:v14[471]];
        [v8 removeObjectForKey:kCGPDFTextStyleFontSize];
      }
    }
  }
LABEL_14:
  uint64_t v19 = [v7 objectForKey:kCGPDFTextStyleBaseLineOffset];
  if (!v19) {
    goto LABEL_22;
  }
  unint64_t v20 = self;
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {

    goto LABEL_22;
  }
  uint64_t v21 = [v19 length];

  if (v21 != 8)
  {
LABEL_22:
    objc_msgSend(*(id *)(a1 + 32), "setAttributes:range:", v8, a3, a4);

    return;
  }
  uint64_t v32 = 0;
  [v19 getBytes:&v32 length:8];
  uint64_t v22 = [NSNumber numberWithDouble:*(double *)&v32];
  uint64_t v38 = 0;
  unint64_t v39 = &v38;
  uint64_t v40 = 0x2020000000;
  long long v23 = (void *)getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  uint64_t v41 = getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr)
  {
    uint64_t v33 = MEMORY[0x1E4F143A8];
    uint64_t v34 = 3221225472;
    float v35 = ___ZL42getkCTBaselineOffsetAttributeNameSymbolLocv_block_invoke_14005;
    float v36 = &unk_1E52CD918;
    BOOL v37 = &v38;
    double v24 = (void *)CoreTextLibrary();
    uint64_t v25 = dlsym(v24, "kCTBaselineOffsetAttributeName");
    *(void *)(v37[1] + 24) = v25;
    getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = *(void *)(v37[1] + 24);
    long long v23 = (void *)v39[3];
  }
  _Block_object_dispose(&v38, 8);
  if (v23)
  {
    [v8 setObject:v22 forKey:*v23];

    [v8 removeObjectForKey:kCGPDFTextStyleBaseLineOffset];
    goto LABEL_22;
  }
LABEL_31:
  dlerror();
  abort_report_np();
  __break(1u);
}

void sub_184F579CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void *___ZL32getkCTFontAttributeNameSymbolLocv_block_invoke_14000(uint64_t a1)
{
  unint64_t v2 = (void *)CoreTextLibrary();
  __n128 result = dlsym(v2, "kCTFontAttributeName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCTFontAttributeNameSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreTextLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!CoreTextLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL19CoreTextLibraryCorePPc_block_invoke_14008;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E52CC220;
    uint64_t v5 = 0;
    CoreTextLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = CoreTextLibraryCore(char **)::frameworkLibrary;
    if (CoreTextLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return CoreTextLibraryCore(char **)::frameworkLibrary;
}

{
  uint64_t v0;
  void *v1;
  void v3[6];
  long long v4;
  uint64_t v5;
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!CoreTextLibraryCore_frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = __CoreTextLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E52CD938;
    uint64_t v5 = 0;
    CoreTextLibraryCore_frameworkLibrardouble y = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = CoreTextLibraryCore_frameworkLibrary;
    if (CoreTextLibraryCore_frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return CoreTextLibraryCore_frameworkLibrary;
}

void *___ZL42getkCTBaselineOffsetAttributeNameSymbolLocv_block_invoke_14005(uint64_t a1)
{
  unint64_t v2 = (void *)CoreTextLibrary();
  __n128 result = dlsym(v2, "kCTBaselineOffsetAttributeName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL19CoreTextLibraryCorePPc_block_invoke_14008()
{
  uint64_t result = _sl_dlopen();
  CoreTextLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

uint64_t ___ZL26AppendNodeAttributedStringP15CGPDFTaggedNodeP20__CFAttributedString_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t CGPDFTaggedNodeCreateAttributedStringForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6)
      {
        uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
        uint64_t v8 = 0;
LABEL_6:
        uint64_t v9 = 0;
        goto LABEL_21;
      }
    }
    uint64_t v8 = *(void *)(v6 + 104);
    uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v9 = *(void *)(v8 + 48);
LABEL_21:
    uint64_t v18 = TextRange + a2;
    uint64_t v19 = a3 + TextRange + a2;
    if (v19 >= v9) {
      unint64_t v20 = (unsigned char *)v9;
    }
    else {
      unint64_t v20 = (unsigned char *)(a3 + TextRange + a2);
    }
    if (v18 < 0 || v18 >= v9)
    {
      BOOL v22 = v19 > 0 && v18 < 1;
      uint64_t v18 = 0;
      if (v22) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 0;
      }
    }
    else
    {
      uint64_t v21 = &v20[-v18];
    }
    __p = (void *)v18;
    unint64_t v29 = v21;
    CFAttributedStringRef AttributedStringForRanges = (NSAttributedString *)CGPDFLayoutCreateAttributedStringForRanges(v8, (uint64_t)&__p, 1);
    Attributeduint64_t StringForStringRanges = _updateAttributedStringAttributes(AttributedStringForRanges);
  }
  else
  {
    uint64_t v11 = CGPDFTaggedNodeGetTextRange(a1);
    Attributeduint64_t StringForStringRanges = 0;
    if (a2 + a3 > v12) {
      uint64_t v13 = -1;
    }
    else {
      uint64_t v13 = v11 + a2;
    }
    if (a2 + a3 <= v12) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = 0;
    }
    v32[0] = v13;
    v32[1] = v14;
    if ((unint64_t)(v13 + 1) >= 2)
    {
      CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
      uint64_t v16 = v15;
      uint64_t v30 = 0;
      double v31 = v15;
      uint64_t v17 = (uint64_t)v15 + 16;
      __p = 0;
      unint64_t v29 = 0;
      uint64_t v26 = v32;
      uint64_t v27 = 1;
      p_p = &__p;
      PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v15 + 16, (uint64_t)&v26, &p_p);
      uint64_t v26 = __p;
      uint64_t v27 = (v29 - (unsigned char *)__p) >> 4;
      Attributeduint64_t StringForStringRanges = (uint64_t)PageLayout::CreateAttributedStringForStringRanges(v17, (uint64_t)&v26);
      if (__p)
      {
        unint64_t v29 = __p;
        operator delete(__p);
      }
      if (v16) {
        CFRelease(v16);
      }
    }
  }
  return AttributedStringForStringRanges;
}

void sub_184F57E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p) {
    operator delete(__p);
  }
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

id CGPDFTaggedNodeCreateAttributedStringForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (*(void *)(a1 + 104)) {
    return 0;
  }
  uint64_t PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
  if (PageStringRangeFromStringRange == -1) {
    return 0;
  }
  uint64_t v8 = PageStringRangeFromStringRange;
  uint64_t v9 = v7;
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  uint64_t v11 = v10;
  v13[2] = v10;
  uint64_t v12 = operator new(0x10uLL);
  *uint64_t v12 = v8;
  v12[1] = v9;
  v13[0] = v12;
  v13[1] = 1;
  Attributeduint64_t StringForStringRanges = PageLayout::CreateAttributedStringForStringRanges((uint64_t)v11 + 16, (uint64_t)v13);
  operator delete(v12);
  if (v11) {
    CFRelease(v11);
  }
  return AttributedStringForStringRanges;
}

void sub_184F57F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12)
{
  operator delete(v12);
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a12);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineRanges(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 104);
    if (v2)
    {
      while (*(_DWORD *)v2 != 517)
      {
        uint64_t v2 = *(void *)(v2 + 8);
        if (!v2)
        {
          uint64_t v3 = 0;
          goto LABEL_10;
        }
      }
      uint64_t v3 = *(void *)(v2 + 104);
LABEL_10:
      uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
      uint64_t v7 = v6;
      id v8 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      uint64_t v14 = 0;
      CGPDFLayoutGetLineRangesForTextRange(v3, TextRange, v7, 0, &v14);
      if (v14 >= 1)
      {
        std::vector<CFRange>::vector(&v12, v14);
        CGPDFLayoutGetLineRangesForTextRange(v3, TextRange, v7, (uint64_t)v12, &v14);
        uint64_t v9 = v12;
        uint64_t v10 = v13;
        if (v12 != v13)
        {
          do
          {
            uint64_t v11 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", *v9, v9[1]);
            [v8 addObject:v11];

            v9 += 2;
          }
          while (v9 != v10);
          uint64_t v9 = v12;
        }
        if (v9)
        {
          uint64_t v13 = v9;
          operator delete(v9);
        }
      }
    }
    else
    {
      CGPDFTaggedNodeGetTextRange(a1);
      CGPDFTaggedNodeCreateLineRangesForTextRange(a1, 0, v4);
    }
  }
}

void sub_184F580AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::vector<CFRange>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<CFRange>::__vallocate[abi:fe180100](a1, a2);
  uint64_t v4 = (char *)a1[1];
  bzero(v4, 16 * a2);
  a1[1] = &v4[16 * a2];
  return a1;
}

void sub_184F5813C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CGPDFTaggedNodeCreateLineRangesForTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 104);
  if (v6)
  {
    while (*(_DWORD *)v6 != 517)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6)
      {
        uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
        uint64_t v9 = v8;
        uint64_t v10 = 0;
LABEL_6:
        uint64_t v11 = 0;
        goto LABEL_28;
      }
    }
    uint64_t v10 = *(void *)(v6 + 104);
    uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
    uint64_t v9 = v32;
    if (!v10) {
      goto LABEL_6;
    }
    uint64_t v11 = *(void *)(v10 + 48);
LABEL_28:
    uint64_t v33 = TextRange + a2;
    if (v33 + a3 >= v11) {
      uint64_t v34 = v11;
    }
    else {
      uint64_t v34 = v33 + a3;
    }
    if (v33 < 0 || v33 >= v11)
    {
      BOOL v36 = v33 + a3 > 0 && v33 < 1;
      uint64_t v33 = 0;
      if (v36) {
        uint64_t v35 = v34;
      }
      else {
        uint64_t v35 = 0;
      }
    }
    else
    {
      uint64_t v35 = v34 - v33;
    }
    id v37 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    uint64_t v45 = 0;
    CGPDFLayoutGetLineRangesForTextRange(v10, v33, v35, 0, &v45);
    if (v45 >= 1)
    {
      std::vector<CFRange>::vector(&v43, v45);
      CGPDFLayoutGetLineRangesForTextRange(v10, TextRange, v9, (uint64_t)v43, &v45);
      uint64_t v38 = v43;
      unint64_t v39 = v44;
      if (v43 != v44)
      {
        do
        {
          uint64_t v40 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", *v38, v38[1]);
          [v37 addObject:v40];

          v38 += 2;
        }
        while (v38 != v39);
        uint64_t v38 = v43;
      }
      if (v38)
      {
        int v44 = v38;
        operator delete(v38);
      }
    }
    return;
  }
  uint64_t v12 = CGPDFTaggedNodeGetTextRange(a1);
  if (a2 + a3 > v13) {
    uint64_t v14 = -1;
  }
  else {
    uint64_t v14 = v12 + a2;
  }
  if (a2 + a3 <= v13) {
    uint64_t v15 = a3;
  }
  else {
    uint64_t v15 = 0;
  }
  if (v14 == -1) {
    return;
  }
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  uint64_t v17 = (void *)v16;
  unint64_t v43 = (void *)v16;
  uint64_t v18 = CGPDFTaggedNodeGetTextRange(a1);
  id v19 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v21 = (PageLayout *)v17[6];
  unint64_t v20 = (PageLayout *)v17[7];
  LineIndedouble x = PageLayout::getLineIndex(v21, v20, v14);
  if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) <= LineIndex)
  {
LABEL_56:
    __break(1u);
    return;
  }
  unint64_t v23 = LineIndex;
  double v24 = (uint64_t *)((char *)v21 + 72 * LineIndex);
  uint64_t v26 = *v24;
  uint64_t v25 = v24[1];
  uint64_t v27 = v15 + v14;
  if (v27 > v25 + v26)
  {
    uint64_t v28 = 72 * LineIndex;
    uint64_t v29 = -1;
    while (1)
    {
      if (v23 != v29)
      {
        if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) > v23)
        {
          uint64_t v30 = v25;
        }
        else
        {
          uint64_t v26 = -1;
          uint64_t v30 = 0;
        }
        double v31 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v26 - v18, v30, v43);
        [v19 addObject:v31];

        uint64_t v21 = (PageLayout *)v17[6];
        unint64_t v20 = (PageLayout *)v17[7];
        uint64_t v29 = v23;
      }
      if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) <= ++v23) {
        goto LABEL_56;
      }
      uint64_t v26 = *(void *)((char *)v21 + v28 + 72);
      uint64_t v25 = *(void *)((char *)v21 + v28 + 80);
      v28 += 72;
      if (v27 <= v25 + v26) {
        goto LABEL_47;
      }
    }
  }
  uint64_t v29 = -1;
LABEL_47:
  if (v29 == v23)
  {
    if (!v17) {
      return;
    }
  }
  else
  {
    if (0x8E38E38E38E38E39 * ((v20 - v21) >> 3) > v23)
    {
      uint64_t v41 = v25;
    }
    else
    {
      uint64_t v26 = -1;
      uint64_t v41 = 0;
    }
    uint64_t v42 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v26 - v18, v41, v43);
    [v19 addObject:v42];
  }
  CFRelease(v17);
}

void sub_184F584AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)&__p);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRanges(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      objc_opt_new();
    }
    else
    {
      CGPDFTaggedNodeGetStringRange(a1);
      CGPDFTaggedNodeCreateLineStringRangesForStringRange(a1, 0, v2);
    }
  }
}

uint64_t CGPDFTaggedNodeGetStringRange(uint64_t a1)
{
  if (!a1 || *(void *)(a1 + 104)) {
    return 0;
  }
  v13[0] = CGPDFTaggedNodeGetTextRange(a1);
  v13[1] = v4;
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  uint64_t v6 = v5;
  uint64_t v11 = 0;
  uint64_t v12 = v5;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  v8[0] = v13;
  v8[1] = 1;
  uint64_t v7 = (void **)&v9;
  PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>((uint64_t)v5 + 16, (uint64_t)v8, &v7);
  if (v9 == v10)
  {
    uint64_t v2 = -1;
    if (!v9) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v2 = *v9;
  }
  uint64_t v10 = v9;
  operator delete(v9);
LABEL_9:
  if (v6) {
    CFRelease(v6);
  }
  return v2;
}

void sub_184F58678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, const void *a16)
{
  if (__p) {
    operator delete(__p);
  }
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef(&a16);
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRangesForStringRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (!*(void *)(a1 + 104))
    {
      uint64_t PageStringRangeFromStringRange = CGPDFTaggedNodeGetPageStringRangeFromStringRange(a1, a2, a3);
      if (PageStringRangeFromStringRange != -1)
      {
        int64_t v6 = PageStringRangeFromStringRange;
        uint64_t v7 = v5;
        CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
        uint64_t v9 = v8;
        uint64_t v45 = v8;
        uint64_t v10 = v8 + 2;
        PageLayout::PageLayout((PageLayout *)v44, (const PageLayout *)(v8 + 2));
        uint64_t v11 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v44, v6, v7);
        uint64_t v13 = v12;
        PageLayout::~PageLayout((PageLayout *)v44);
        if (v11 != -1)
        {
          uint64_t StringRange = CGPDFTaggedNodeGetStringRange(a1);
          uint64_t v43 = v14;
          uint64_t v40 = -1;
          id v41 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
          v39[0] = &v40;
          v39[1] = v10;
          v39[2] = &v41;
          v39[3] = &StringRange;
          uint64_t v15 = (PageLayout *)v9[6];
          uint64_t v16 = (PageLayout *)v9[7];
          LineIndedouble x = PageLayout::getLineIndex(v15, v16, v11);
          if (0x8E38E38E38E38E39 * ((v16 - v15) >> 3) <= LineIndex)
          {
LABEL_20:
            __break(1u);
            return;
          }
          unint64_t v18 = LineIndex;
          uint64_t v19 = v13 + v11;
          if (v19 > *((void *)v15 + 9 * LineIndex + 1) + *((void *)v15 + 9 * LineIndex))
          {
            uint64_t v20 = 72 * LineIndex;
            do
            {
              CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>((uint64_t)v39, v18++);
              uint64_t v21 = v9[6];
              if (0x8E38E38E38E38E39 * ((v9[7] - v21) >> 3) <= v18) {
                goto LABEL_20;
              }
              uint64_t v22 = *(void *)(v21 + v20 + 80) + *(void *)(v21 + v20 + 72);
              v20 += 72;
            }
            while (v19 > v22);
          }
          CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>((uint64_t)v39, v18);
          if ([v41 count])
          {
            unint64_t v23 = [v41 firstObject];
            uint64_t v24 = [v23 rangeValue];
            uint64_t v26 = v25;

            if (v24 < 0)
            {
              id v27 = v41;
              uint64_t v28 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", 0, v26 + v24);
              [v27 replaceObjectAtIndex:0 withObject:v28];
            }
            uint64_t v29 = [v41 lastObject];
            uint64_t v30 = [v29 rangeValue];
            uint64_t v32 = v31;

            uint64_t v33 = StringRange;
            uint64_t v34 = v43;
            id v35 = v41;
            uint64_t v36 = [v41 count];
            uint64_t v37 = v34 + v33;
            if (v34 + v33 >= v30 + v32) {
              uint64_t v37 = v30 + v32;
            }
            uint64_t v38 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v30, v37 - v30);
            [v35 replaceObjectAtIndex:v36 - 1 withObject:v38];
          }
LABEL_19:
          CFRelease(v9);
          return;
        }
        if (v9) {
          goto LABEL_19;
        }
      }
    }
  }
}

void sub_184F58950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v16 - 88));
  _Unwind_Resume(a1);
}

void CGPDFTaggedNodeCreateLineStringRangesForStringRange::$_0::operator()<CFRange>(uint64_t a1, unint64_t a2)
{
  if (**(void **)a1 != a2)
  {
    **(void **)a1 = a2;
    PageLayout::PageLayout((PageLayout *)v13, *(const PageLayout **)(a1 + 8));
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 32);
    if (0x8E38E38E38E38E39 * ((*(void *)(*(void *)(a1 + 8) + 40) - v4) >> 3) <= a2)
    {
      uint64_t v7 = 0;
      uint64_t v6 = -1;
    }
    else
    {
      uint64_t v5 = (uint64_t *)(v4 + 72 * a2);
      uint64_t v6 = *v5;
      uint64_t v7 = v5[1];
    }
    uint64_t v8 = CGPDFTaggedNodeConvertTextRangeToStringRange((uint64_t)v13, v6, v7);
    uint64_t v10 = v9;
    PageLayout::~PageLayout((PageLayout *)v13);
    uint64_t v11 = **(void ***)(a1 + 16);
    uint64_t v12 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v8 - **(void **)(a1 + 24), v10);
    [v11 addObject:v12];
  }
}

void sub_184F58AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL CGPDFTaggedNodeIsImageFigure(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 112)) {
    return *(unsigned char *)(a1 + 113) != 0;
  }
  uint64_t v2 = *(_DWORD **)(a1 + 104);
  if (v2 && *v2 == 257) {
    return 1;
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __CGPDFTaggedNodeIsImageFigure_block_invoke;
  v4[3] = &unk_1E52CC140;
  v4[4] = &v5;
  CGPDFTaggedNodeEnumerateChildren(a1, v4);
  BOOL v1 = *((unsigned char *)v6 + 24) != 0;
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_184F58BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __CGPDFTaggedNodeIsImageFigure_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CGPDFTaggedNodeIsImageFigure(a2);
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetParent(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t CGPDFTaggedNodeGetNodeContainingTextRange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t TextRange = CGPDFTaggedNodeGetTextRange(a1);
  uint64_t v8 = 0;
  if (a2 >= TextRange && a2 < TextRange + v7 && a2 + a3 > TextRange && a2 + a3 <= TextRange + v7)
  {
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000;
    uint64_t v14 = a1;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    void v10[2] = __CGPDFTaggedNodeGetNodeContainingTextRange_block_invoke;
    void v10[3] = &unk_1E52CC188;
    v10[5] = a2;
    v10[6] = a3;
    v10[4] = &v11;
    CGPDFTaggedNodeEnumerateChildren(a1, v10);
    uint64_t v8 = v12[3];
    _Block_object_dispose(&v11, 8);
  }
  return v8;
}

void sub_184F58D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CGPDFTaggedNodeGetNodeContainingTextRange_block_invoke(void *a1, uint64_t a2)
{
  NodeContaininguint64_t TextRange = CGPDFTaggedNodeGetNodeContainingTextRange(a2, a1[5], a1[6]);
  if (NodeContainingTextRange) {
    *(void *)(*(void *)(a1[4] + 8) + 24) = NodeContainingTextRange;
  }
  return 1;
}

uint64_t CGPDFTaggedNodeGetNodeContainingPoint(uint64_t a1, int a2, char a3, double a4, double a5, double a6)
{
  if (!a1) {
    return 0;
  }
  uint64_t v10 = a1;
  double v11 = a6 >= 0.0 ? a6 : 0.0;
  CGFloat v12 = a5 - v11 * 0.5;
  v26.origin.double x = CGPDFTaggedNodeGetBounds(a1);
  v26.origin.double y = v13;
  v26.size.double width = v14;
  v26.size.double height = v15;
  v25.origin.double x = a4 - v11 * 0.5;
  v25.origin.double y = v12;
  v25.size.double width = v11;
  v25.size.double height = v11;
  if (!CGRectIntersectsRect(v25, v26)) {
    return 0;
  }
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000;
  uint64_t v24 = v10;
  if (a2 && *(_DWORD *)(v10 + 16) != a2) {
    uint64_t v10 = 0;
  }
  if ((a3 & 1) == 0 && v10 && *(_DWORD *)(v10 + 16) == 700) {
    uint64_t v10 = 0;
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  v18[2] = __CGPDFTaggedNodeGetNodeContainingPoint_block_invoke;
  v18[3] = &unk_1E52CC1B0;
  int v19 = a2;
  *(double *)&v18[5] = a4;
  *(double *)&v18[6] = a5;
  *(double *)&v18[7] = v11;
  char v20 = a3;
  v18[4] = &v21;
  CGPDFTaggedNodeEnumerateChildren(v10, v18);
  uint64_t v16 = v22[3];
  _Block_object_dispose(&v21, 8);
  return v16;
}

void sub_184F58EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CGPDFTaggedNodeGetNodeContainingPoint_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t NodeContainingPoint = CGPDFTaggedNodeGetNodeContainingPoint(a2, *(unsigned int *)(a1 + 64), *(unsigned __int8 *)(a1 + 68), *(double *)(a1 + 40), *(double *)(a1 + 48), *(double *)(a1 + 56));
  if (NodeContainingPoint) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = NodeContainingPoint;
  }
  return 1;
}

uint64_t CGPDFTaggedNodeGetListStyle(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  while (*(_DWORD *)(a1 + 16) != 301)
  {
    a1 = *(void *)(a1 + 88);
    if (!a1) {
      return 0;
    }
  }
  ChildTaggedNodeOfchar Type = (void *)GetChildTaggedNodeOfType(a1, 302);
  if (!ChildTaggedNodeOfType) {
    return 0;
  }
  CFStringRef String = CGPDFTaggedNodeCreateString(ChildTaggedNodeOfType);
  if (!String) {
    return 0;
  }
  CFStringRef v3 = String;
  if (CFStringHasPrefix(String, @"•")
    || CFStringHasPrefix(v3, @"·")
    || CFStringHasPrefix(v3, @"․")
    || CFStringHasPrefix(v3, @"∙")
    || CFStringHasPrefix(v3, @"◘")
    || CFStringHasPrefix(v3, @"◦")
    || CFStringHasPrefix(v3, @"∘"))
  {
    uint64_t v4 = 257;
  }
  else
  {
    IntCFNumberRef Value = CFStringGetIntValue(v3);
    uint64_t v4 = 0;
    if (IntValue != 0x80000000 && IntValue && IntValue != 0x7FFFFFFF) {
      uint64_t v4 = 513;
    }
  }
  CFRelease(v3);
  return v4;
}

uint64_t GetChildTaggedNodeOfType(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  if (a1 && *(_DWORD *)(a1 + 16) != a2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = &v6;
    uint64_t v8 = 0x2020000000;
    uint64_t v9 = 0;
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = ___ZL24GetChildTaggedNodeOfTypeP15CGPDFTaggedNode19CGPDFTaggedNodeType_block_invoke;
    v4[3] = &unk_1E52CC240;
    v4[4] = &v6;
    int v5 = a2;
    CGPDFTaggedNodeEnumerateChildren(a1, v4);
    uint64_t v2 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  return v2;
}

void sub_184F59138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL24GetChildTaggedNodeOfTypeP15CGPDFTaggedNode19CGPDFTaggedNodeType_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = GetChildTaggedNodeOfType(a2, *(unsigned int *)(a1 + 40));
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetTableRowCount(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)(result + 16) != 400)
    {
      uint64_t result = *(void *)(result + 88);
      if (!result) {
        return result;
      }
    }
    uint64_t v1 = 0;
    GetTaggedNodeCountForType(result, 401, &v1);
    return v1;
  }
  return result;
}

void GetTaggedNodeCountForType(uint64_t a1, int a2, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == a2)
    {
      ++*a3;
    }
    else
    {
      v3[0] = MEMORY[0x1E4F143A8];
      v3[1] = 3221225472;
      v3[2] = ___ZL25GetTaggedNodeCountForTypeP15CGPDFTaggedNode19CGPDFTaggedNodeTypePm_block_invoke;
      v3[3] = &__block_descriptor_44_e12_B24__0_v8Q16l;
      int v4 = a2;
      v3[4] = a3;
      CGPDFTaggedNodeEnumerateChildren(a1, v3);
    }
  }
}

uint64_t ___ZL25GetTaggedNodeCountForTypeP15CGPDFTaggedNode19CGPDFTaggedNodeTypePm_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t CGPDFTaggedNodeGetTableColumnCount(uint64_t result)
{
  if (result)
  {
    while (*(_DWORD *)(result + 16) != 400)
    {
      uint64_t result = *(void *)(result + 88);
      if (!result) {
        return result;
      }
    }
    uint64_t v1 = 0;
    GetColumnCount(result, &v1);
    return v1;
  }
  return result;
}

void GetColumnCount(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 401)
    {
      uint64_t v6 = 0;
      GetTaggedNodeCountForType(a1, 403, &v6);
      uint64_t v5 = 0;
      GetTaggedNodeCountForType(a1, 402, &v5);
      if ((unint64_t)(v5 + v6) > *a2) {
        *a2 = v5 + v6;
      }
    }
    else
    {
      v4[0] = MEMORY[0x1E4F143A8];
      v4[1] = 3221225472;
      v4[2] = ___ZL14GetColumnCountP15CGPDFTaggedNodePm_block_invoke;
      v4[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
      v4[4] = a2;
      CGPDFTaggedNodeEnumerateChildren(a1, v4);
    }
  }
}

uint64_t ___ZL14GetColumnCountP15CGPDFTaggedNodePm_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t CGPDFTaggedNodeGetTableCellRowSpan(uint64_t a1)
{
  if (!a1) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    CFStringRef v3 = &CPRangeNull;
    while (1)
    {
      if (*(_DWORD *)v2 == 1538)
      {
        int v4 = *(_DWORD **)(v2 + 104);
        if (v4)
        {
          if (*v4 == 2) {
            break;
          }
        }
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return *(void *)v3;
      }
    }
    CFStringRef v3 = (long long *)(v4 + 2);
    return *(void *)v3;
  }
  if ((*(_DWORD *)(a1 + 16) - 401) > 5) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  while (*(_DWORD *)(v5 + 16) != 400)
  {
    uint64_t v5 = *(void *)(v5 + 88);
    if (!v5) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  uint64_t v10 = 0;
  double v11 = &v10;
  uint64_t v12 = 0x2020000000;
  uint64_t v13 = 0;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __CGPDFTaggedNodeGetTableCellRowSpan_block_invoke;
  void v9[3] = &unk_1E52CC1D8;
  v9[4] = &v10;
  void v9[5] = a1;
  CGPDFTaggedNodeEnumerateChildren(v5, v9);
  uint64_t v8 = 0;
  CountRowElements(a1, 0, &v8);
  uint64_t v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

void sub_184F59558(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __CGPDFTaggedNodeGetTableCellRowSpan_block_invoke(uint64_t a1, uint64_t a2)
{
  return CountRowElements(a2, *(void *)(a1 + 40), (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) ^ 1;
}

uint64_t CountRowElements(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (v4 == 400) {
      return 0;
    }
  }
  else
  {
    int v4 = 0;
  }
  if (a1 == a2) {
    return 1;
  }
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000;
  char v12 = 0;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = ___ZL16CountRowElementsP15CGPDFTaggedNodeS0_Pm_block_invoke;
  v8[3] = &unk_1E52CC188;
  v8[4] = &v9;
  v8[5] = a2;
  v8[6] = a3;
  CGPDFTaggedNodeEnumerateChildren(a1, v8);
  int v6 = *((unsigned __int8 *)v10 + 24);
  if (v4 == 401 && !*((unsigned char *)v10 + 24)) {
    ++*a3;
  }
  BOOL v5 = v6 != 0;
  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_184F5969C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL16CountRowElementsP15CGPDFTaggedNodeS0_Pm_block_invoke(void *a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = CountRowElements(a2, a1[5], a1[6]);
  return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetTableCellColumnSpan(uint64_t a1)
{
  if (!a1) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 104);
  if (v2)
  {
    CFStringRef v3 = &CPRangeNull;
    while (1)
    {
      if (*(_DWORD *)v2 == 1538)
      {
        int v4 = *(_DWORD **)(v2 + 104);
        if (v4)
        {
          if (*v4 == 2) {
            break;
          }
        }
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return *(void *)v3;
      }
    }
    CFStringRef v3 = (long long *)(v4 + 6);
    return *(void *)v3;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if ((v6 - 401) > 5) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    uint64_t v7 = *(void *)(a1 + 88);
    if (!v7) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    while (*(_DWORD *)(v7 + 16) != 400)
    {
      uint64_t v7 = *(void *)(v7 + 88);
      if (!v7) {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    if ((v6 - 401) <= 5 && ((1 << (v6 + 111)) & 0x39) != 0)
    {
      uint64_t v11 = 0;
      ChildTaggedNodeOfchar Type = GetChildTaggedNodeOfType(a1, 401);
      if (!ChildTaggedNodeOfType) {
        ChildTaggedNodeOfchar Type = a1;
      }
      CountColumnElements(ChildTaggedNodeOfType, 0, &v11);
      return 0;
    }
    uint64_t v9 = *(void *)(a1 + 88);
    if (!v9) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    uint64_t v10 = *(void *)(a1 + 88);
    while (*(_DWORD *)(v10 + 16) != 401)
    {
      uint64_t v10 = *(void *)(v10 + 88);
      if (!v10)
      {
        uint64_t v10 = a1;
        if (v6 != 404)
        {
          uint64_t v10 = *(void *)(a1 + 88);
          while (*(_DWORD *)(v10 + 16) != 404)
          {
            uint64_t v10 = *(void *)(v10 + 88);
            if (!v10)
            {
              uint64_t v10 = a1;
              if (v6 != 405)
              {
                uint64_t v10 = *(void *)(a1 + 88);
                while (*(_DWORD *)(v10 + 16) != 405)
                {
                  uint64_t v10 = *(void *)(v10 + 88);
                  if (!v10)
                  {
                    uint64_t v10 = a1;
                    if (v6 != 406)
                    {
                      uint64_t result = 0x7FFFFFFFFFFFFFFFLL;
                      while (*(_DWORD *)(v9 + 16) != 406)
                      {
                        uint64_t v9 = *(void *)(v9 + 88);
                        if (!v9) {
                          return result;
                        }
                      }
                      uint64_t v10 = v9;
                    }
                    goto LABEL_27;
                  }
                }
              }
              goto LABEL_27;
            }
          }
        }
        break;
      }
    }
LABEL_27:
    uint64_t v11 = 0;
    CountColumnElements(v10, a1, &v11);
    if (v11) {
      return v11 - 1;
    }
    else {
      return 0;
    }
  }
}

BOOL CountColumnElements(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 16);
    if (v3 == 400) {
      return 0;
    }
    BOOL v5 = v3 == 403;
    if ((v3 & 0xFFFFFFFE) == 0x192) {
      ++*a3;
    }
  }
  else
  {
    BOOL v5 = 0;
  }
  BOOL v4 = a1 == a2;
  if (a1 != a2 && !v5)
  {
    uint64_t v8 = 0;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2020000000;
    char v11 = 0;
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = ___ZL19CountColumnElementsP15CGPDFTaggedNodeS0_Pm_block_invoke;
    _OWORD v7[3] = &unk_1E52CC188;
    v7[4] = &v8;
    v7[5] = a2;
    v7[6] = a3;
    CGPDFTaggedNodeEnumerateChildren(a1, v7);
    BOOL v4 = *((unsigned char *)v9 + 24) != 0;
    _Block_object_dispose(&v8, 8);
  }
  return v4;
}

void sub_184F599D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL19CountColumnElementsP15CGPDFTaggedNodeS0_Pm_block_invoke(void *a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = CountColumnElements(a2, a1[5], a1[6]);
  return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
}

uint64_t CGPDFTaggedNodeGetParagraphLinks(uint64_t result)
{
  if (result) {
    return *(void *)(result + 152);
  }
  return result;
}

uint64_t CGPDFTaggedNodeCreate(uint64_t a1)
{
  if (CGPDFTaggedNodeGetTypeID(void)::onceToken != -1) {
    dispatch_once(&CGPDFTaggedNodeGetTypeID(void)::onceToken, &__block_literal_global_14036);
  }
  uint64_t cftype = pdf_create_cftype();
  uint64_t v3 = cftype;
  if (cftype)
  {
    *(_DWORD *)(cftype + 16) = 0;
    *(void *)(cftype + 24) = 0;
    *(unsigned char *)(cftype + 48) = 0;
    *(unsigned char *)(cftype + 113) = 0;
    *(_OWORD *)(cftype + 56) = 0u;
    *(_OWORD *)(cftype + 72) = 0u;
    *(void *)(cftype + 88) = 0;
    *(void *)(cftype + 96) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(v3 + 104) = 0;
    *(unsigned char *)(v3 + 112) = 1;
    *(void *)(v3 + 200) = 0;
    *(void *)(v3 + 208) = 0;
    *(_OWORD *)(v3 + 120) = 0u;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(unsigned char *)(v3 + 168) = 0;
    *(void *)(v3 + 176) = 0;
    *(void *)(v3 + 184) = 0;
    *(unsigned char *)(v3 + 192) = 0;
    *(void *)(v3 + 216) = 0;
    *(void *)(v3 + 224) = a1;
  }
  return v3;
}

uint64_t ___ZL24CGPDFTaggedNodeGetTypeIDv_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFTaggedNodeGetTypeID(void)::CGPDFTaggedNodeType);
  CGPDFTaggedNodeGetTypeID(void)::typeID = result;
  return result;
}

void CGPDFTaggedNodeFinalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  CFArrayRef v3 = *(const __CFArray **)(a1 + 96);
  if (v3)
  {
    CFIndex Count = CFArrayGetCount(v3);
    if (Count)
    {
      CFIndex v5 = Count;
      for (unint64_t i = 0; i != v5; ++i)
      {
        ChildAtIndedouble x = CGPDFTaggedNodeGetChildAtIndex(a1, i);
        if (ChildAtIndex) {
          CFRelease(ChildAtIndex);
        }
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 96));
  }
  uint64_t v8 = *(_DWORD **)(a1 + 104);
  if (v8) {
    CGPDFNodeRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 120);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = *(const void **)(a1 + 128);
  if (v10) {
    CFRelease(v10);
  }
  char v11 = *(const void **)(a1 + 136);
  if (v11) {
    CFRelease(v11);
  }
  char v12 = *(const void **)(a1 + 144);
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = *(const void **)(a1 + 152);
  if (v13) {
    CFRelease(v13);
  }
  CGFloat v14 = *(void **)(a1 + 200);
  if (v14)
  {
    *(void *)(a1 + 208) = v14;
    operator delete(v14);
  }
}

uint64_t CGPDFTaggedNodeCreateCopyWithStringRange(uint64_t a1, int64_t a2, uint64_t a3)
{
  CGPDFPageCopyPageLayoutWithCTLD(*(void *)(a1 + 224), 1);
  uint64_t v7 = (const void *)v6;
  uint64_t v27 = v6;
  uint64_t v8 = (PageLayout *)(v6 + 16);
  PageLayout::PageLayout((PageLayout *)v26, (const PageLayout *)(v6 + 16));
  CFIndex v9 = CGPDFTaggedNodeConvertStringRangeToTextRange((uint64_t)v26, a2, a3);
  CFIndex v11 = v10;
  PageLayout::~PageLayout((PageLayout *)v26);
  CFIndex v12 = *(void *)(a1 + 176);
  if (v12 <= v9 && v9 + v11 <= *(void *)(a1 + 184) + v12)
  {
    if (CGPDFTaggedNodeGetTypeID(void)::onceToken != -1) {
      dispatch_once(&CGPDFTaggedNodeGetTypeID(void)::onceToken, &__block_literal_global_14036);
    }
    CFStringRef cftype = (const __CFString *)pdf_create_cftype();
    uint64_t v14 = (uint64_t)cftype;
    if (cftype)
    {
      CGPDFTaggedNodeSetType(cftype, *(_DWORD *)(a1 + 16));
      CGPDFTaggedNodeSetTypeName(v14, *(CFTypeRef *)(a1 + 24));
      *(unsigned char *)(v14 + 48) = 1;
      v28.locatiouint64_t n = v9;
      v28.length = v11;
      PageLayout::GetBoundsForTextRange(v8, v28);
      *(void *)(v14 + 56) = v16;
      *(void *)(v14 + 64) = v17;
      *(void *)(v14 + 72) = v18;
      *(void *)(v14 + 80) = v19;
      *(unsigned char *)(v14 + 113) = *(unsigned char *)(a1 + 113);
      *(void *)(v14 + 88) = *(void *)(a1 + 88);
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 3221225472;
      v25[2] = __CGPDFTaggedNodeCreateCopyWithStringRange_block_invoke;
      _OWORD v25[3] = &__block_descriptor_40_e12_B24__0_v8Q16l;
      v25[4] = v14;
      CGPDFTaggedNodeEnumerateChildren(a1, v25);
      *(void *)(v14 + 104) = *(void *)(a1 + 104);
      *(unsigned char *)(v14 + 112) = *(unsigned char *)(a1 + 112);
      CGPDFTaggedNodeSetAltText(v14, *(CFTypeRef *)(a1 + 120));
      CGPDFTaggedNodeSetActualText(v14, *(CFTypeRef *)(a1 + 128));
      CGPDFTaggedNodeSetTitleText(v14, *(CFTypeRef *)(a1 + 136));
      CGPDFTaggedNodeSetLanguageText(v14, *(CFTypeRef *)(a1 + 144));
      CFArrayRef v20 = *(const __CFArray **)(a1 + 152);
      if (v20)
      {
        CFIndex Count = CFArrayGetCount(v20);
        if (Count >= 1)
        {
          for (CFIndex i = 0; i != Count; ++i)
          {
            ValueAtIndedouble x = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 152), i);
            CGPDFTaggedNodeAddURL(v14, ValueAtIndex);
          }
        }
      }
      else
      {
        *(void *)(v14 + 152) = 0;
      }
      *(void *)(v14 + 160) = *(void *)(a1 + 160);
      *(unsigned char *)(v14 + 168) = 1;
      *(void *)(v14 + 176) = v9;
      *(void *)(v14 + 184) = v11;
      *(unsigned char *)(v14 + 192) = 0;
      *(void *)(v14 + 208) = 0;
      *(void *)(v14 + 216) = 0;
      *(void *)(v14 + 200) = 0;
      *(void *)(v14 + 224) = *(void *)(a1 + 224);
    }
  }
  else
  {
    pdf_error("New text range needs to be within the original node's text range.");
    uint64_t v14 = 0;
  }
  if (v7) {
    CFRelease(v7);
  }
  return v14;
}

void sub_184F59E78(_Unwind_Exception *a1)
{
  applesauce::CF::ObjectRef<CGPDFPageLayout *>::~ObjectRef((const void **)(v1 - 72));
  _Unwind_Resume(a1);
}

CFStringRef CGPDFTaggedNodeSetType(CFStringRef result, int a2)
{
  if (result)
  {
    CFStringRef v2 = result;
    LODWORD(result->data) = a2;
    if (!result->length)
    {
      Name = CGPDFTaggedNodeTypeGetName(a2);
      uint64_t result = CFStringCreateWithCString(0, Name, 0x8000100u);
      v2->length = (uint64_t)result;
    }
  }
  return result;
}

void CGPDFTaggedNodeSetTypeName(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    BOOL v4 = *(const void **)(a1 + 24);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 24) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

uint64_t __CGPDFTaggedNodeCreateCopyWithStringRange_block_invoke(uint64_t a1, void *a2)
{
  return 1;
}

void CGPDFTaggedNodeSetAltText(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    BOOL v4 = *(const void **)(a1 + 120);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 120) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void CGPDFTaggedNodeSetActualText(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    BOOL v4 = *(const void **)(a1 + 128);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 128) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void CGPDFTaggedNodeSetTitleText(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    BOOL v4 = *(const void **)(a1 + 136);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 136) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void CGPDFTaggedNodeSetLanguageText(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    BOOL v4 = *(const void **)(a1 + 144);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 144) = cf;
    if (cf)
    {
      CFRetain(cf);
    }
  }
}

void CGPDFTaggedNodeAddURL(uint64_t a1, void *value)
{
  if (a1 && value)
  {
    CFAttributedStringRef Mutable = *(__CFArray **)(a1 + 152);
    if (!Mutable)
    {
      CFAttributedStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      *(void *)(a1 + 152) = Mutable;
    }
    CFArrayAppendValue(Mutable, value);
  }
}

void CGPDFTaggedNodeAddTaggedNode(uint64_t a1, void *cf)
{
  if (a1)
  {
    if (cf)
    {
      CFStringRef v2 = *(__CFArray **)(a1 + 96);
      if (v2)
      {
        cf[11] = a1;
        CFTypeRef v3 = CFRetain(cf);
        CFArrayAppendValue(v2, v3);
      }
    }
  }
}

uint64_t ___ZL27CGPDFTaggedContextGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGPDFTaggedContextGetTypeID(void)::idouble d = result;
  return result;
}

uint64_t CGPDFTaggedContextFinalize(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 16);
  if (v1)
  {
    uint64_t v2 = *v1;
    CFTypeRef v3 = *(StructureElement **)(*v1 + 24);
    if (!v3 || (StructureElement::~StructureElement(v3), MEMORY[0x18532A2A0](), (uint64_t v2 = *v1) != 0))
    {
      BOOL v4 = *(void **)(v2 + 248);
      if (v4) {
        operator delete(v4);
      }
      uint64_t v5 = *(void *)(v2 + 224);
      if (v5)
      {
        uint64_t v6 = *(void *)(v2 + 232);
        uint64_t v7 = *(void **)(v2 + 224);
        if (v6 != v5)
        {
          do
            uint64_t v6 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v6 - 40);
          while (v6 != v5);
          uint64_t v7 = *(void **)(v2 + 224);
        }
        *(void *)(v2 + 232) = v5;
        operator delete(v7);
      }
      uint64_t v8 = *(void ***)(v2 + 200);
      if (v8)
      {
        CFIndex v9 = *(void ***)(v2 + 208);
        CFIndex v10 = *(void **)(v2 + 200);
        if (v9 != v8)
        {
          do
          {
            v9 -= 3;
            uint64_t v21 = v9;
            std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:fe180100](&v21);
          }
          while (v9 != v8);
          CFIndex v10 = *(void **)(v2 + 200);
        }
        *(void *)(v2 + 208) = v8;
        operator delete(v10);
      }
      std::__tree<unsigned long>::destroy(*(void **)(v2 + 184));
      std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(void **)(v2 + 160));
      uint64_t v11 = *(void *)(v2 + 128);
      if (v11)
      {
        uint64_t v12 = *(void *)(v2 + 136);
        uint64_t v13 = *(void **)(v2 + 128);
        if (v12 != v11)
        {
          do
          {
            uint64_t v14 = v12 - 24;
            std::__tree<unsigned long>::destroy(*(void **)(v12 - 16));
            uint64_t v12 = v14;
          }
          while (v14 != v11);
          uint64_t v13 = *(void **)(v2 + 128);
        }
        *(void *)(v2 + 136) = v11;
        operator delete(v13);
      }
      uint64_t v15 = *(void *)(v2 + 104);
      if (v15)
      {
        uint64_t v16 = *(void *)(v2 + 112);
        uint64_t v17 = *(void **)(v2 + 104);
        if (v16 != v15)
        {
          uint64_t v18 = *(void *)(v2 + 112);
          do
          {
            CFArrayRef v20 = *(void **)(v18 - 24);
            v18 -= 24;
            uint64_t v19 = v20;
            if (v20)
            {
              *(void *)(v16 - 16) = v19;
              operator delete(v19);
            }
            uint64_t v16 = v18;
          }
          while (v18 != v15);
          uint64_t v17 = *(void **)(v2 + 104);
        }
        *(void *)(v2 + 112) = v15;
        operator delete(v17);
      }
      std::mutex::~mutex((std::mutex *)(v2 + 32));
      MEMORY[0x18532A2A0](v2, 0x1030C402EF8FC53);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

void CGPDFTaggedContextAddNode(uint64_t a1, int64_t a2, uint64_t a3)
{
  if (a1)
  {
    CFTypeRef v3 = *(uint64_t **)(a1 + 16);
    if (v3)
    {
      unint64_t v4 = HIDWORD(a2) - 1;
      uint64_t v5 = *v3;
      uint64_t v6 = *(void *)(*v3 + 128);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v5 + 136) - v6) >> 3) <= v4)
      {
        __break(1u);
        goto LABEL_41;
      }
      if (!*(unsigned char *)(v5 + 97))
      {
        uint64_t v7 = v6 + 24 * v4;
        CFIndex v10 = *(void **)(v7 + 8);
        CFIndex v9 = (void *)(v7 + 8);
        uint64_t v8 = v10;
        if (v10)
        {
          uint64_t v12 = v9;
          uint64_t v13 = v8;
          do
          {
            uint64_t v14 = v13[4];
            BOOL v15 = v14 < a2;
            if (v14 >= a2) {
              uint64_t v16 = v13;
            }
            else {
              uint64_t v16 = v13 + 1;
            }
            if (!v15) {
              uint64_t v12 = v13;
            }
            uint64_t v13 = (void *)*v16;
          }
          while (*v16);
          if (v12 != v9 && v12[4] <= a2)
          {
            while (1)
            {
              while (1)
              {
                uint64_t v17 = v8[4];
                if (v17 <= a2) {
                  break;
                }
                uint64_t v8 = (void *)*v8;
                if (!v8) {
                  goto LABEL_21;
                }
              }
              if (v17 >= a2) {
                break;
              }
              uint64_t v8 = (void *)v8[1];
              if (!v8) {
LABEL_21:
              }
                std::__throw_out_of_range[abi:fe180100]("map::at:  key not found");
            }
            uint64_t v18 = (void *)v8[5];
            ++*(_DWORD *)(a3 + 40);
            CFArrayRef v20 = (void *)v18[18];
            unint64_t v19 = v18[19];
            if ((unint64_t)v20 < v19)
            {
              *CFArrayRef v20 = a3;
              uint64_t v21 = v20 + 1;
LABEL_39:
              v18[18] = v21;
              return;
            }
            uint64_t v22 = (void *)v18[17];
            uint64_t v23 = v20 - v22;
            unint64_t v24 = v23 + 1;
            if (!((unint64_t)(v23 + 1) >> 61))
            {
              uint64_t v25 = v19 - (void)v22;
              if (v25 >> 2 > v24) {
                unint64_t v24 = v25 >> 2;
              }
              if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v26 = v24;
              }
              if (v26)
              {
                if (v26 >> 61) {
                  std::__throw_bad_array_new_length[abi:fe180100]();
                }
                uint64_t v27 = (char *)operator new(8 * v26);
              }
              else
              {
                uint64_t v27 = 0;
              }
              CFRange v28 = &v27[8 * v23];
              *(void *)CFRange v28 = a3;
              uint64_t v21 = v28 + 8;
              if (v20 != v22)
              {
                do
                {
                  uint64_t v29 = *--v20;
                  *((void *)v28 - 1) = v29;
                  v28 -= 8;
                }
                while (v20 != v22);
                CFArrayRef v20 = (void *)v18[17];
              }
              v18[17] = v28;
              v18[18] = v21;
              v18[19] = &v27[8 * v26];
              if (v20) {
                operator delete(v20);
              }
              goto LABEL_39;
            }
LABEL_41:
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
        }
      }
    }
  }
}

uint64_t CGPDFTaggedPagePropertiesCreate(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2 || !CGPDFDocumentIsTaggedPDF(*(void *)(a1 + 16))) {
    return 0;
  }
  CFTypeRef v3 = (void **)CGPDFDocumentCopyTaggedContext(v2);
  unint64_t v4 = v3;
  if (*(unsigned char *)(*v3[2] + 97))
  {
    CFRelease(v3);
    return 0;
  }
  if (CGPDFTaggedPagePropertiesGetTypeID(void)::onceToken != -1) {
    dispatch_once(&CGPDFTaggedPagePropertiesGetTypeID(void)::onceToken, &__block_literal_global_57_14101);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = v4;
  *(void *)(Instance + 24) = *(void *)(*(void *)(a1 + 40) + 8);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 32), 0);
  *(void *)(Instance + 96) = 0;
  return Instance;
}

uint64_t ___ZL34CGPDFTaggedPagePropertiesGetTypeIDv_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGPDFTaggedPagePropertiesGetTypeID(void)::idouble d = result;
  return result;
}

void CGPDFTaggedPagePropertiesFinalize(char *a1)
{
  uint64_t v2 = (const void *)*((void *)a1 + 2);
  if (v2) {
    CFRelease(v2);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  CFTypeRef v3 = (const void *)*((void *)a1 + 12);
  if (v3)
  {
    CFRelease(v3);
  }
}

void CGPDFTaggedPagePropertiesRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFTaggedPagePropertiesGetStructureTree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(result + 32));
      if (!*(void *)(v1 + 96))
      {
        size_t v2 = *(void *)(v1 + 24);
        CFTypeRef v3 = *(TaggedParser **)(*(void *)(v1 + 16) + 16);
        Page = CGPDFDocumentGetPage(*(CGPDFDocumentRef *)(*(void *)v3 + 16), v2);
        TaggedParser::AddPage(v3, Page);
        uint64_t v5 = *(void *)v3;
        if (*(void *)(*(void *)v3 + 24))
        {
          uint64_t v6 = (std::mutex *)(v5 + 32);
          std::mutex::lock((std::mutex *)(v5 + 32));
          uint64_t v7 = BuildStructureTree(v2, 0, *(void *)(*(void *)v3 + 24));
          std::mutex::unlock(v6);
        }
        else
        {
          uint64_t v7 = 0;
        }
        *(void *)(v1 + 96) = v7;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 32));
      return *(void *)(v1 + 96);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_184F5A7A4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t CGPDFTaggedpagePropertiesGetStructureElementID(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 16);
    if (v2)
    {
      CFTypeRef v3 = *(void **)(v2 + 16);
      uint64_t v4 = *(void *)(result + 24);
      uint64_t v6 = (uint64_t *)(*v3 + 128);
      uint64_t v5 = *v6;
      if (0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3) <= v4 - 1)
      {
        __break(1u);
        return result;
      }
      uint64_t v8 = (uint64_t *)(a2 | ((unint64_t)v4 << 32));
      uint64_t v7 = std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v5 + 24 * (v4 - 1)), (uint64_t)v8, &v8)[5];
      if (v7) {
        return *v7;
      }
    }
  }
  return -1;
}

uint64_t CGPDFTaggedNodeGetObjectReference(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

void pdf_reader_release(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *a1;
    if (*a1) {
      *(unsigned char *)(v3 + 176) = 1;
    }
    pdf_xref_release(v3);
    free(a1);
  }
}

uint64_t convert_version(const char *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v12 = 0;
  uint64_t v6 = strtol_l(a1, &v12, 10, 0);
  uint64_t v7 = v12;
  if (v12 == a1) {
    return 0;
  }
  uint64_t v8 = v6;
  uint64_t result = 0;
  if (*v12 == 46 && (v8 & 0x8000000000000000) == 0 && v8 <= 0x7FFFFFFF)
  {
    *a2 = v8;
    CFIndex v10 = v7 + 1;
    unint64_t v11 = strtol_l(v7 + 1, &v12, 10, 0);
    if (v12 != v10 && (*v12 | 0x20) == 0x20 && !(v11 >> 31))
    {
      *a3 = v11;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t pdf_reader_get_linearized_page_ranges(uint64_t result, unint64_t a2, uint64_t *a3, uint64_t *a4)
{
  if (result)
  {
    if (a2 && (uint64_t v5 = result, *(void *)(result + 16) >= a2))
    {
      if (a3)
      {
        if (a4)
        {
          *a3 = 0;
          *a4 = 0;
          uint64_t v8 = *(void *)(result + 64);
          unint64_t v9 = a2 - 1;
          uint64_t v10 = *(void *)(v8 + 48);
          if (a2 - 1 < (*(void *)(v8 + 56) - v10) >> 6)
          {
            if (a2 < 2) {
              uint64_t v11 = 1;
            }
            else {
              uint64_t v11 = ((uint64_t)(*(void *)(v10 + (v9 << 6) + 32) - *(void *)(v10 + (v9 << 6) + 24)) >> 3) + 1;
            }
            uint64_t result = (uint64_t)malloc_type_malloc(16 * v11, 0x1000040451B5BE8uLL);
            uint64_t v12 = v10 + (v9 << 6);
            uint64_t v13 = *(void *)(v12 + 48);
            uint64_t v14 = *(unsigned int *)(v12 + 4);
            *(void *)uint64_t result = v13;
            *(void *)(result + 8) = v14;
            if (a2 < 2)
            {
LABEL_23:
              *a3 = result;
              *a4 = v11;
              return 1;
            }
            uint64_t v15 = *(void *)(v5 + 64);
            uint64_t v16 = *(void *)(v15 + 48);
            if (*(void *)(v15 + 56) != v16)
            {
              uint64_t v17 = (void *)(result + 16);
              uint64_t v18 = v10 + (v9 << 6);
              unint64_t v19 = *(unsigned int **)(v18 + 24);
              CFArrayRef v20 = *(unsigned int **)(v18 + 32);
              if (v19 != v20)
              {
                uint64_t v21 = *(void *)(v16 + 48);
                uint64_t v22 = *(unsigned int *)(v16 + 4);
                uint64_t v23 = *(void *)(*(void *)(v5 + 72) + 32);
                unint64_t v24 = (*(void *)(*(void *)(v5 + 72) + 40) - v23) >> 4;
                uint64_t v25 = v21 + v22;
                while (1)
                {
                  unint64_t v26 = *v19;
                  if (v24 <= v26) {
                    break;
                  }
                  uint64_t v27 = (unsigned int *)(v23 + 16 * v26);
                  uint64_t v28 = *((void *)v27 + 1);
                  uint64_t v29 = *v27;
                  if (v21 <= v28 && v28 + v29 <= v25)
                  {
                    *uint64_t v17 = v28;
                    v17[1] = v29;
                    v17 += 2;
                  }
                  v19 += 2;
                  if (v19 == v20) {
                    goto LABEL_22;
                  }
                }
                exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(exception, "shared object index is out of range");
                uint64_t v32 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
                uint64_t v33 = (struct type_info *)off_1E529EE70;
                uint64_t v34 = MEMORY[0x1E4FBA4D8] + 16;
LABEL_30:
                exception->__vftable = (std::logic_error_vtbl *)v34;
                __cxa_throw(exception, v33, v32);
              }
LABEL_22:
              uint64_t v11 = ((uint64_t)v17 - result) >> 4;
              goto LABEL_23;
            }
          }
          __break(1u);
          return result;
        }
        exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "NULL 'range_count' parameter");
      }
      else
      {
        exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "NULL 'shared_resource_ranges' parameter");
      }
    }
    else
    {
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "page_number is out of range");
    }
    uint64_t v32 = (void (*)(void *))MEMORY[0x1E4FBA1E8];
    uint64_t v33 = (struct type_info *)off_1E529EE80;
    uint64_t v34 = MEMORY[0x1E4FBA4E8] + 16;
    goto LABEL_30;
  }
  return result;
}

void sub_184F5ABC8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  uint64_t v13 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    (*(void (**)(void *))(*(void *)v13 + 16))(v13);
    pdf_error("%s caught exception: %s");
  }
  else
  {
    pdf_error("%s caught an unknown exception");
  }
  __cxa_end_catch();
  JUMPOUT(0x184F5AAD0);
}

void *GList::append(GList *this, void *a2)
{
  int v5 = *((_DWORD *)this + 2);
  int v4 = *((_DWORD *)this + 3);
  uint64_t result = *(void **)this;
  if (v4 >= v5)
  {
    int v7 = *((_DWORD *)this + 4);
    if (v7 <= 0) {
      int v7 = v5;
    }
    *((_DWORD *)this + 2) = v7 + v5;
    uint64_t result = greallocn(result, v7 + v5, 8u);
    *(void *)this = result;
    int v4 = *((_DWORD *)this + 3);
  }
  *((_DWORD *)this + 3) = v4 + 1;
  *((void *)result + v4) = a2;
  return result;
}

void CGErrorSetCallback(CGErrorCallback callback)
{
  pthread_mutex_lock(&error_callback_lock);
  error_callback = callback;

  pthread_mutex_unlock(&error_callback_lock);
}

void CGLog(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

os_log_t __CGLogWithArguments_block_invoke()
{
  MainBundleIfLooksLikeBundle = (__CFBundle *)_CFBundleGetMainBundleIfLooksLikeBundle();
  if (MainBundleIfLooksLikeBundle)
  {
    CFStringRef Identifier = CFBundleGetIdentifier(MainBundleIfLooksLikeBundle);
    if (Identifier)
    {
      CFStringRef v2 = Identifier;
      CFIndex Length = CFStringGetLength(Identifier);
      if (!CFStringGetCString(v2, (char *)fetch_process_name_name, 1024, 0x8000100u))
      {
        v5.locatiouint64_t n = 0;
        v5.length = Length;
        CFStringGetBytes(v2, v5, 0x600u, 0x3Fu, 0, fetch_process_name_name, 1024, 0);
      }
    }
  }
  if (!fetch_process_name_name[0]) {
    __sprintf_chk((char *)fetch_process_name_name, 0, 0x401uLL, "Unknown process name");
  }
  os_log_t result = os_log_create("com.apple.coregraphics", (const char *)fetch_process_name_name);
  CGLogWithArguments_log = (uint64_t)result;
  return result;
}

void CGPostErrorWithArguments(uint64_t a1, va_list a2)
{
}

void CGPDFPageGetImages(uint64_t a1, CGPDFContentStream *a2, CGPDFContentStream *a3)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v6 = (CGPDFContentStreamRef *)CGPDFImageExtractorCreate(0);
      if (v6)
      {
        int v7 = v6;
        uint64_t v8 = CGPDFContentStreamCreate(*(void *)(a1 + 40));
        v7[2] = (CGPDFContentStreamRef)v8;
        if (v8)
        {
          _OWORD v7[3] = a2;
          v7[4] = a3;
          CGPDFImageExtractorGetImages(v7);
        }
        CGPDFImageExtractorRelease(v7);
      }
    }
  }
}

void *CGPDFImageExtractorCreate(long long ***a1)
{
  CFStringRef v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
  {
    if (a1) {
      Copdouble y = CGPDFRStateCreateCopy(*a1);
    }
    else {
      Copdouble y = CGPDFRStateCreate();
    }
    *CFStringRef v2 = Copy;
    if (!Copy
      || (int v4 = CGPDFOperatorTableCreate(),
          CGPDFOperatorTableSetCallback(v4, "q", (CGPDFOperatorCallback)image_q),
          CGPDFOperatorTableSetCallback(v4, "Q", (CGPDFOperatorCallback)image_Q),
          CGPDFOperatorTableSetCallback(v4, "cm", (CGPDFOperatorCallback)image_cm),
          CGPDFOperatorTableSetCallback(v4, "Do", (CGPDFOperatorCallback)image_Do),
          CGPDFOperatorTableSetCallback(v4, "EI", (CGPDFOperatorCallback)image_EI),
          (v2[1] = v4) == 0))
    {
      CGPDFImageExtractorRelease(v2);
      return 0;
    }
  }
  return v2;
}

void CGPDFImageExtractorGetImages(CGPDFContentStreamRef *info)
{
  uint64_t v1 = CGPDFScannerCreate(info[2], info[1], info);
  CGPDFScannerScan(v1);
  if (v1)
  {
    CFRelease(v1);
  }
}

void CGPDFImageExtractorRelease(void *a1)
{
  if (a1)
  {
    CGPDFRStateRelease((void *)*a1);
    CFStringRef v2 = (const void *)a1[1];
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)a1[2];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void image_EI(uint64_t *a1, uint64_t a2)
{
  CGPDFStreamRef value = 0;
  if (CGPDFScannerPopStream((CGPDFScannerRef)a1, &value))
  {
    Inline = (CGImage *)CGPDFImageCreateInline(a1[7], (uint64_t)value);
    if (Inline)
    {
      CFRange v5 = Inline;
      CGImageRef ImageForRenderingSize = CGPDFImageCreateImageForRenderingSize(Inline, a1[7], 0.0, 0.0);
      if (ImageForRenderingSize)
      {
        CGImageRef v7 = ImageForRenderingSize;
        uint64_t v8 = *(const CGAffineTransform **)a2;
        if (*(void *)a2) {
          uint64_t v8 = *(const CGAffineTransform **)&v8->a;
        }
        if (!v8) {
          uint64_t v8 = &CGAffineTransformIdentity;
        }
        long long v9 = *(_OWORD *)&v8->c;
        long long v14 = *(_OWORD *)&v8->a;
        long long v15 = v9;
        long long v16 = *(_OWORD *)&v8->tx;
        uint64_t v11 = *(void (**)(CGImageRef, _OWORD *, uint64_t))(a2 + 24);
        uint64_t v10 = *(void *)(a2 + 32);
        v12[0] = v14;
        v12[1] = v9;
        void v12[2] = v16;
        v11(ImageForRenderingSize, v12, v10);
        CFRelease(v7);
      }
      CFRelease(v5);
    }
  }
}

void image_Do(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStreamRef value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value)) {
    return;
  }
  uint64_t v4 = *((void *)a1 + 7);
  if (!v4) {
    return;
  }
  CFRange v5 = value;
  uint64_t v6 = v4;
  while (1)
  {
    CGImageRef v7 = CGPDFResourcesCopyXObject(*(void *)(v6 + 32), v5);
    if (v7) {
      break;
    }
    uint64_t v6 = *(void *)(v6 + 40);
    if (!v6) {
      return;
    }
  }
  int v8 = v7[4];
  if (v8 == 2)
  {
    uint64_t v16 = CGPDFXObjectGetValue((uint64_t)v7);
    uint64_t v17 = (double ***)CGPDFImageExtractorCreate(a2);
    if (v17)
    {
      if (v16)
      {
        uint64_t v18 = *(CGPDFStream **)v16;
        unint64_t v19 = *(CGPDFDictionary **)(v16 + 88);
      }
      else
      {
        uint64_t v18 = 0;
        unint64_t v19 = 0;
      }
      CGPDFContentStreamRef v22 = CGPDFContentStreamCreateWithStream(v18, v19, *(CGPDFContentStreamRef *)(a2 + 16));
      _OWORD v17[2] = (double **)v22;
      if (v22)
      {
        *(_OWORD *)(v17 + 3) = *(_OWORD *)(a2 + 24);
      }
      else
      {
        CGPDFImageExtractorRelease(v17);
        uint64_t v17 = 0;
      }
    }
    CGPDFRStateGSave((uint64_t)*v17);
    unint64_t v24 = (const CGAffineTransform *)(v16 + 40);
  }
  else
  {
    if (v8 != 1)
    {
      if (!v8)
      {
        long long v9 = (CGImage *)CGPDFXObjectGetValue((uint64_t)v7);
        CGImageRef ImageForRenderingSize = CGPDFImageCreateImageForRenderingSize(v9, v4, 0.0, 0.0);
        if (ImageForRenderingSize)
        {
          CGImageRef v11 = ImageForRenderingSize;
          uint64_t v12 = *(const CGAffineTransform **)a2;
          if (*(void *)a2) {
            uint64_t v12 = *(const CGAffineTransform **)&v12->a;
          }
          if (!v12) {
            uint64_t v12 = &CGAffineTransformIdentity;
          }
          long long v13 = *(_OWORD *)&v12->c;
          long long v29 = *(_OWORD *)&v12->a;
          long long v30 = v13;
          long long v31 = *(_OWORD *)&v12->tx;
          long long v15 = *(void (**)(CGImageRef, _OWORD *, uint64_t))(a2 + 24);
          uint64_t v14 = *(void *)(a2 + 32);
          v28[0] = v29;
          v28[1] = v13;
          v28[2] = v31;
          v15(ImageForRenderingSize, v28, v14);
          CFRelease(v11);
        }
      }
      return;
    }
    uint64_t v16 = CGPDFXObjectGetValue((uint64_t)v7);
    uint64_t v17 = (double ***)CGPDFImageExtractorCreate(a2);
    if (v17)
    {
      if (v16)
      {
        CFArrayRef v20 = *(CGPDFStream **)(v16 + 16);
        uint64_t v21 = *(CGPDFDictionary **)(v16 + 104);
      }
      else
      {
        CFArrayRef v20 = 0;
        uint64_t v21 = 0;
      }
      CGPDFContentStreamRef v23 = CGPDFContentStreamCreateWithStream(v20, v21, *(CGPDFContentStreamRef *)(a2 + 16));
      _OWORD v17[2] = (double **)v23;
      if (v23)
      {
        *(_OWORD *)(v17 + 3) = *(_OWORD *)(a2 + 24);
      }
      else
      {
        CGPDFImageExtractorRelease(v17);
        uint64_t v17 = 0;
      }
    }
    CGPDFRStateGSave((uint64_t)*v17);
    unint64_t v24 = (const CGAffineTransform *)(v16 + 56);
  }
  if (!v16) {
    unint64_t v24 = &CGAffineTransformIdentity;
  }
  if (*v17) {
    uint64_t v25 = **v17;
  }
  else {
    uint64_t v25 = 0;
  }
  long long v26 = *(_OWORD *)&v24->c;
  long long v29 = *(_OWORD *)&v24->a;
  long long v30 = v26;
  long long v31 = *(_OWORD *)&v24->tx;
  CGPDFGStateConcatCTM(v25, (double *)&v29);
  CGPDFImageExtractorGetImages((CGPDFContentStreamRef *)v17);
  CGPDFRStateGRestore((uint64_t)*v17);
  CGPDFImageExtractorRelease(v17);
}

double image_cm(CGPDFScanner *a1, double ***a2)
{
  CGPDFReal v11 = 0.0;
  CGPDFReal v12 = 0.0;
  CGPDFReal v9 = 0.0;
  CGPDFReal v10 = 0.0;
  CGPDFReal value = 0.0;
  CGPDFReal v8 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v10)
    && CGPDFScannerPopNumber(a1, &v11)
    && CGPDFScannerPopNumber(a1, &v12))
  {
    if (*a2) {
      CFRange v5 = **a2;
    }
    else {
      CFRange v5 = 0;
    }
    v6[0] = v12;
    v6[1] = v11;
    void v6[2] = v10;
    v6[3] = v9;
    void v6[4] = v8;
    void v6[5] = value;
    return CGPDFGStateConcatCTM(v5, v6);
  }
  return result;
}

void image_Q(uint64_t a1, uint64_t *a2)
{
}

void image_q(uint64_t a1, uint64_t *a2)
{
}

uint64_t CGFontGetMaxUnichars(uint64_t result)
{
  if (result)
  {
    get_unimap((void *)result);
    return 256;
  }
  return result;
}

char **get_unimap(void *a1)
{
  explicit = (char **)atomic_load_explicit(a1 + 9, memory_order_acquire);
  if (!explicit)
  {
    explicit = (char **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004014030ADEuLL);
    *explicit = (char *)a1;
    font_info = (char **)get_font_info(a1);
    if (font_info) {
      uint64_t v4 = *font_info;
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v5 = 0;
    explicit[1] = v4;
    atomic_compare_exchange_strong(a1 + 9, (unint64_t *)&v5, (unint64_t)explicit);
    if (v5)
    {
      CGFontUnimapRelease(explicit);
      return (char **)v5;
    }
  }
  return explicit;
}

uint64_t CGFontGetUnicharsForGlyph(uint64_t result, uint64_t a2, _WORD *a3)
{
  if (!result) {
    return result;
  }
  double result = (uint64_t)get_unimap((void *)result);
  if (!result) {
    return result;
  }
  if (*(void *)(result + 8) <= (unint64_t)a2) {
    return 0;
  }
  explicit = (unsigned __int16 *)atomic_load_explicit((atomic_ullong *volatile)(result + 16), memory_order_acquire);
  if (explicit)
  {
    int v6 = a2;
    if (explicit != (unsigned __int16 *)-1)
    {
      unint64_t v7 = atomic_load((unint64_t *)&explicit[4 * (a2 >> 10) + 4]);
      if (v7) {
        int v6 = *(unsigned __int16 *)(v7 + 2 * (a2 & 0x3FF));
      }
      else {
        int v6 = *explicit;
      }
    }
    if (v6 != 0xFFFF)
    {
      if (a3) {
        *a3 = v6;
      }
      return 1;
    }
  }
  uint64_t v8 = *(void *)result;
  if (!*(void *)result) {
    return 0;
  }
  CGPDFReal v9 = *(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t))(*(void *)(v8 + 16) + 384);
  uint64_t v10 = *(void *)(v8 + 112);

  return v9(v10, a2, a3, 256);
}

void *conversion_cache_get_retained_conversion_params(uint64_t a1, CGColorSpace *a2, long long *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  value_out = 0;
  if (a1)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    if (v6) {
      unint64_t v7 = (long long *)(v6 + 64);
    }
    else {
      unint64_t v7 = 0;
    }
  }
  else
  {
    unint64_t v7 = 0;
  }
  double result = 0;
  if (a2)
  {
    if (v7)
    {
      uint64_t v9 = *((void *)a2 + 3);
      if (v9)
      {
        long long v10 = *(_OWORD *)(v9 + 64);
        long long v11 = *v7;
        long long v75 = 0uLL;
        int v76 = 0;
        key[0] = v10;
        key[1] = v11;
        if (a3)
        {
          long long v75 = *a3;
          int v76 = *((_DWORD *)a3 + 4);
        }
        cache_lock_14216();
        if (get_cache_predicate_14217 != -1) {
          dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
        }
        if (!cache_get_and_retain(*(cache_t **)(get_cache_conversion_cache + 64), key, &value_out))
        {
          cache_unlock_14219();
          if (!value_out) {
            _CGHandleAssert("conversion_cache_get_retained_conversion_params", 549, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "params != NULL", "params is NULL", v16, v17, v18, v68);
          }
          if (!CGConditionalVarWait((uint64_t)value_out, v12, v13, v14, v15, v16, v17, v18))
          {
            release_and_remove_14223(key, value_out);
            value_out = 0;
            cache_lock_14216();
          }
        }
        if (value_out) {
          return value_out;
        }
        unint64_t v19 = malloc_type_calloc(1uLL, 0x110uLL, 0x10600409D7FDA2EuLL);
        if (v19)
        {
          uint64_t v27 = v19;
          CGConditionalVarInit((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
          value_out = v27;
          if (get_cache_predicate_14217 != -1) {
            dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
          }
          cache_set_and_retain(*(cache_t **)(get_cache_conversion_cache + 64), key, value_out, 0);
        }
        else
        {
          value_out = 0;
        }
        cache_unlock_14219();
        id v35 = (char *)value_out;
        if (!value_out) {
          return value_out;
        }
        if (v5) {
          uint64_t v36 = *(void *)(*(void *)(v5 + 24) + 48);
        }
        else {
          uint64_t v36 = 0;
        }
        if ((v36 & 0xFFFFFFFFFFFFFFFDLL) != 1
          || (uint64_t v37 = *(void *)(*((void *)v4 + 3) + 48), (v37 & 0xFFFFFFFFFFFFFFFDLL) != 1))
        {
          CGConditionalVarPost((uint64_t)value_out, v28, v29, v30, v31, v32, v33, v34);
LABEL_110:
          release_and_remove_14223(key, value_out);
          return 0;
        }
        uint64_t v38 = &should_enable_lcd_styles;
        if (xyz_color_space_predicate != -1) {
          dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
        }
        BOOL v39 = CGColorSpaceEqualToColorSpace(v5, xyz_color_space_xyz);
        BOOL v69 = CGColorSpaceEqualToColorSpace((uint64_t)v4, xyz_color_space_xyz);
        if (v5)
        {
          uint64_t v40 = *(unsigned char **)(v5 + 24);
          if (v40[15] || v40[16]) {
            goto LABEL_41;
          }
          BOOL v41 = v40[17] != 0;
        }
        else
        {
          BOOL v41 = 0;
        }
        if (!v41 && !v39)
        {
          if (xsRGB_color_space_predicate != -1) {
            dispatch_once(&xsRGB_color_space_predicate, &__block_literal_global_11_14225);
          }
          uint64_t v5 = xsRGB_color_space_sRGB;
        }
LABEL_41:
        uint64_t v42 = (unsigned char *)*((void *)v4 + 3);
        if (!v42[15] && !v42[16])
        {
          BOOL v43 = v42[17] == 0;
          char v44 = v69;
          if (!v43) {
            char v44 = 1;
          }
          if ((v44 & 1) == 0)
          {
            if (xsRGB_color_space_predicate != -1) {
              dispatch_once(&xsRGB_color_space_predicate, &__block_literal_global_11_14225);
            }
            uint64_t v4 = (CGColorSpace *)xsRGB_color_space_sRGB;
          }
        }
        if (v5
          && ((uint64_t v45 = *(void *)(v5 + 24), v46 = *(unsigned __int8 *)(v45 + 16), *(unsigned char *)(v45 + 16))
           || *(unsigned char *)(v45 + 17)))
        {
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          *(_OWORD *)keys = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          *(_OWORD *)values = 0u;
          if (!v4)
          {
            CFIndex v50 = 0;
            goto LABEL_75;
          }
          int v47 = *(unsigned __int8 *)(*((void *)v4 + 3) + 16);
        }
        else
        {
          if (!v4
            || (v48 = *((void *)v4 + 3), int v47 = *(unsigned __int8 *)(v48 + 16), !*(unsigned char *)(v48 + 16))
            && !*(unsigned char *)(v48 + 17))
          {
            CFDictionaryRef v51 = 0;
            goto LABEL_91;
          }
          long long v90 = 0u;
          long long v91 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          *(_OWORD *)keys = 0u;
          long long v80 = 0u;
          long long v81 = 0u;
          long long v78 = 0u;
          long long v79 = 0u;
          *(_OWORD *)values = 0u;
        }
        if (v47)
        {
          keys[0] = @"kCGPQEOTFOpticalScale";
          LODWORD(valuePtr[0]) = 1120403456;
          values[0] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
          if (a3)
          {
            float v49 = *((float *)a3 + 1);
            if (v49 == 0.0)
            {
              CFIndex v50 = 1;
            }
            else
            {
              keys[1] = @"kCGPQMasteringDisplayWhite";
              *(float *)float valuePtr = v49;
              values[1] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
              CFIndex v50 = 2;
            }
            float v52 = *((float *)a3 + 2);
            if (v52 != 0.0)
            {
              keys[v50] = @"kCGPQMasteringDisplayBlack";
              *(float *)float valuePtr = v52;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            float v53 = *((float *)a3 + 3);
            if (v53 != 0.0)
            {
              keys[v50] = @"kCGTargetDisplayWhite";
              *(float *)float valuePtr = v53;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            if (*((float *)a3 + 2) != 0.0)
            {
              keys[v50] = @"kCGTargetDisplayBlack";
              LODWORD(valuePtr[0]) = *((_DWORD *)a3 + 3);
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
          }
          else
          {
            CFIndex v50 = 1;
          }
        }
        else
        {
          CFIndex v50 = 0;
        }
        if (!v5)
        {
LABEL_78:
          if (a3 && *(unsigned char *)(*((void *)v4 + 3) + 17))
          {
            float v54 = *((float *)a3 + 3);
            if (v54 != 0.0)
            {
              keys[v50] = @"kCGTargetDisplayWhite";
              *(float *)float valuePtr = v54;
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
            }
            if (*((float *)a3 + 2) != 0.0)
            {
              keys[v50] = @"kCGTargetDisplayBlack";
              LODWORD(valuePtr[0]) = *((_DWORD *)a3 + 3);
              values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
              goto LABEL_85;
            }
          }
LABEL_84:
          if (!v50)
          {
            CFDictionaryRef v51 = 0;
            goto LABEL_91;
          }
LABEL_85:
          __n128 v55 = keys;
          CFDictionaryRef v51 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v50, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          do
          {
            if (*v55) {
              CFRelease(*v55);
            }
            ++v55;
            --v50;
          }
          while (v50);
          uint64_t v38 = &should_enable_lcd_styles;
LABEL_91:
          BOOL v56 = CGColorSpaceEqualToColorSpace(v5, (uint64_t)v4);
          int v57 = v39;
          if (v51) {
            int v57 = 1;
          }
          if ((v57 | v69) != 1 || v56)
          {
            long long v94 = 0u;
            memset(v95, 0, sizeof(v95));
            long long v92 = 0u;
            long long v93 = 0u;
            long long v90 = 0u;
            long long v91 = 0u;
            long long v88 = 0u;
            long long v89 = 0u;
            *(_OWORD *)keys = 0u;
            if (*((void *)v38 + 176) != -1) {
              dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
            }
            if (iterate_with_params((uint64_t)keys, xyz_color_space_xyz, v4, v51))
            {
              memset(v86, 0, sizeof(v86));
              long long v84 = 0u;
              memset(v85, 0, sizeof(v85));
              long long v82 = 0u;
              long long v83 = 0u;
              long long v80 = 0u;
              long long v81 = 0u;
              long long v78 = 0u;
              long long v79 = 0u;
              *(_OWORD *)values = 0u;
              if (*((void *)v38 + 176) != -1) {
                dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
              }
              int v66 = iterate_with_params((uint64_t)values, v5, (CGColorSpace *)xyz_color_space_xyz, v51);
              char v65 = v66;
              if (v66)
              {
                *((void *)v35 + 15) = v36;
                *((void *)v35 + 16) = v37;
                if (v37) {
                  memcpy(v35 + 184, (char *)&v95[3] + 8, 8 * v37);
                }
                v71[0] = *(_OWORD *)((char *)v95 + 8);
                v71[1] = *(_OWORD *)((char *)&v95[1] + 8);
                v71[2] = *(_OWORD *)((char *)&v95[2] + 8);
                v72[0] = *(_OWORD *)((char *)v85 + 8);
                v72[1] = *(_OWORD *)((char *)&v85[1] + 8);
                v72[2] = *(_OWORD *)((char *)&v85[2] + 8);
                CGColorMatrixConcat((float *)v72, (float *)v71, (float *)valuePtr);
                long long v67 = valuePtr[1];
                *(_OWORD *)(v35 + 136) = valuePtr[0];
                *(_OWORD *)(v35 + 152) = v67;
                *(_OWORD *)(v35 + 168) = valuePtr[2];
                if (v36) {
                  memcpy(v35 + 208, v86, 8 * v36);
                }
              }
            }
            else
            {
              char v65 = 0;
            }
          }
          else
          {
            char v65 = iterate_with_params((uint64_t)v35, v5, v4, v51);
          }
          if (v51) {
            CFRelease(v51);
          }
          CGConditionalVarPost((uint64_t)value_out, v58, v59, v60, v61, v62, v63, v64);
          if (v65) {
            return value_out;
          }
          goto LABEL_110;
        }
        int v46 = *(unsigned __int8 *)(*(void *)(v5 + 24) + 16);
LABEL_75:
        if (v46)
        {
          keys[v50] = @"kCGPQInvEOTFOpticalScale";
          LODWORD(valuePtr[0]) = 1008981770;
          values[v50++] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
        }
        if (!v4) {
          goto LABEL_84;
        }
        goto LABEL_78;
      }
    }
  }
  return result;
}

uint64_t cache_lock_14216()
{
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  uint64_t v0 = (pthread_mutex_t *)get_cache_conversion_cache;

  return pthread_mutex_lock(v0);
}

uint64_t cache_unlock_14219()
{
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  uint64_t v0 = (pthread_mutex_t *)get_cache_conversion_cache;

  return pthread_mutex_unlock(v0);
}

uint64_t release_and_remove_14223(void *a1, void *value)
{
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), value);
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  uint64_t v4 = *(cache_t **)(get_cache_conversion_cache + 64);

  return cache_remove(v4, a1);
}

uint64_t iterate_with_params(uint64_t a1, uint64_t a2, CGColorSpace *a3, const __CFDictionary *a4)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(*(void *)(a2 + 24) + 48);
    if (a3)
    {
LABEL_3:
      uint64_t v5 = *(void *)(*((void *)a3 + 3) + 48);
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v4 = 0;
    if (a3) {
      goto LABEL_3;
    }
  }
  uint64_t v5 = 0;
LABEL_6:
  *(void *)(a1 + 120) = v4;
  *(void *)(a1 + 128) = v5;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = a1;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = -1;
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  v15[2] = __iterate_with_params_block_invoke_2;
  v15[3] = &unk_1E52CC330;
  v15[4] = &v20;
  v15[5] = v5;
  v15[6] = v4;
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  v14[2] = __iterate_with_params_block_invoke_3;
  v14[3] = &unk_1E52CC358;
  v14[4] = &v20;
  void v14[5] = &v16;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  void v13[2] = __iterate_with_params_block_invoke_4;
  void v13[3] = &unk_1E52CC380;
  v13[4] = &v16;
  v13[5] = &v20;
  uint64_t v6 = CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacksAndOptions(a2, a3, 0, (uint64_t)&__block_literal_global_31_14233, (uint64_t)v15, (uint64_t)v14, (uint64_t)v13, 2u, 0, a4);
  if (v6)
  {
    if (v5 >= 1)
    {
      uint64_t v7 = -v5;
      uint64_t v8 = 23;
      do
      {
        if (!*(void *)(v21[3] + 8 * v8)) {
          *(void *)(v21[3] + 8 * v8) = CGDisplayColorCurveCreateIdentity();
        }
        ++v8;
      }
      while (v7 + v8 != 23);
    }
    if (v17[3] == -1)
    {
      uint64_t v9 = v21[3];
      *(_OWORD *)(v9 + 136) = CGColorMatrixMakeIdentity_identity;
      *(_OWORD *)(v9 + 152) = unk_185295180;
      *(_OWORD *)(v9 + 168) = xmmword_185295190;
    }
    if (v4 >= 1)
    {
      uint64_t v10 = -v4;
      uint64_t v11 = 26;
      do
      {
        if (!*(void *)(v21[3] + 8 * v11)) {
          *(void *)(v21[3] + 8 * v11) = CGDisplayColorCurveCreateIdentity();
        }
        ++v11;
      }
      while (v10 + v11 != 26);
    }
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v6;
}

uint64_t __iterate_with_params_block_invoke_2(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a3)
  {
    if (a1[5] == a4)
    {
      if (a4 >= 1)
      {
        for (uint64_t i = 0; i != a4; ++i)
        {
          uint64_t v21 = *(void *)(a5 + 8 * i);
          if (v21 < 0)
          {
            Identitdouble y = CGDisplayColorCurveCreateIdentity();
          }
          else
          {
            uint64_t v22 = *(const void **)(*(void *)(a2 + 52) + 8 * v21);
            int v37 = 0;
            long long v35 = 0u;
            long long v36 = 0u;
            CGColorTRCGetFunction((uint64_t)v22, (uint64_t)&v35);
            if (CGColorTRCPureGammaOriginal_cglibrarypredicate != -1) {
              dispatch_once(&CGColorTRCPureGammaOriginal_cglibrarypredicate, &__block_literal_global_12);
            }
            char v23 = CGColorTRCPureGammaOriginal_f(v22);
            int Properties = CGColorFunctionGetProperties(v22);
            float InputRange = CGColorFunctionGetInputRange(v22);
            float v27 = v26;
            float OutputRange = CGColorFunctionGetOutputRange(v22);
            long long v32 = v35;
            long long v33 = v36;
            int v34 = v37;
            Identitdouble y = (uint64_t)CGDisplayColorCurveCreate(&v32, v23, Properties, InputRange, v27, OutputRange, v29);
          }
          *(void *)(*(void *)(*(void *)(a1[4] + 8) + 24) + 8 * i + 184) = Identity;
        }
      }
      return 1;
    }
    return 0;
  }
  if (a1[6] != a4) {
    return 0;
  }
  if (a4 >= 1)
  {
    for (uint64_t j = 0; j != a4; ++j)
    {
      uint64_t v10 = *(void *)(a5 + 8 * j);
      if (v10 < 0)
      {
        uint64_t v19 = CGDisplayColorCurveCreateIdentity();
      }
      else
      {
        uint64_t v11 = *(const void **)(*(void *)(a2 + 52) + 8 * v10);
        int v37 = 0;
        long long v35 = 0u;
        long long v36 = 0u;
        CGColorTRCGetFunction((uint64_t)v11, (uint64_t)&v35);
        if (CGColorTRCPureGammaOriginal_cglibrarypredicate != -1) {
          dispatch_once(&CGColorTRCPureGammaOriginal_cglibrarypredicate, &__block_literal_global_12);
        }
        char v12 = CGColorTRCPureGammaOriginal_f(v11);
        int v13 = CGColorFunctionGetProperties(v11);
        float v14 = CGColorFunctionGetInputRange(v11);
        float v16 = v15;
        float v17 = CGColorFunctionGetOutputRange(v11);
        long long v32 = v35;
        long long v33 = v36;
        int v34 = v37;
        uint64_t v19 = (uint64_t)CGDisplayColorCurveCreate(&v32, v12, v13, v14, v16, v17, v18);
      }
      *(void *)(*(void *)(*(void *)(a1[4] + 8) + 24) + 8 * j + 208) = v19;
    }
  }
  return 1;
}

BOOL __iterate_with_params_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4)
  {
    uint64_t v7 = **(void **)(a2 + 60);
    long long v12 = 0u;
    long long v13 = 0u;
    long long v11 = 0u;
    CGColorMatrixGetMatrix(v7, &v11);
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    long long v9 = v12;
    *(_OWORD *)(v8 + 136) = v11;
    *(_OWORD *)(v8 + 152) = v9;
    *(_OWORD *)(v8 + 168) = v13;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
  }
  return a4 == 0;
}

uint64_t __iterate_with_params_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v5 = *(CFTypeRef *)(*(void *)(a2 + 68) + 8 * a4);
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == -1)
  {
    if (v5) {
      CFTypeRef v5 = CFRetain(v5);
    }
    *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 232) = v5;
  }
  else
  {
    if (v5) {
      CFTypeRef v5 = CFRetain(v5);
    }
    *(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 240) = v5;
  }
  return 1;
}

BOOL __iterate_with_params_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(uint64_t *)(a2 + 36) <= 1 && *(void *)(a2 + 44) < 2;
}

CGColorSpaceRef __xsRGB_color_space_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedSRGB");
  xsRGB_color_space_sRGB = (uint64_t)result;
  return result;
}

CGColorSpaceRef __xyz_color_space_block_invoke()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericXYZ");
  xyz_color_space_xyz = (uint64_t)result;
  return result;
}

uint64_t __get_cache_block_invoke_14259()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  get_cache_conversion_cache = (uint64_t)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040C6685353uLL);
  if (!get_cache_conversion_cache) {
    _CGHandleAssert("get_cache_block_invoke", 467, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "conversion_cache != NULL", "conversion cache", v0, v1, v2, v7.version);
  }
  v8.__sig = 0;
  *(void *)v8.__opaque = 0;
  pthread_mutexattr_init(&v8);
  pthread_mutexattr_settype(&v8, 2);
  pthread_mutex_init((pthread_mutex_t *)get_cache_conversion_cache, &v8);
  pthread_mutexattr_destroy(&v8);
  cache_attributes_t v7 = *(cache_attributes_t *)byte_1ED09C978;
  if (cache_create("com.apple.CoreGraphics.display_colorspace_conversion_cache", &v7, (cache_t **)(get_cache_conversion_cache + 64)))
  {
    _CGHandleAssert("get_cache_block_invoke", 489, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DisplayColorSpaceConversions/CGDisplayColorSpaceConversion.c", "cacheErr == 0", "cache creation failed", v3, v4, v5, v7.version);
  }
  return cache_set_count_hint();
}

uint64_t conversion_params_data_make_nonpurgeable()
{
  return 1;
}

void conversion_params_data_value_release(uint64_t a1)
{
  if (a1)
  {
    if (!pthread_mutex_destroy((pthread_mutex_t *)a1)) {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 64));
    }
    CGColorCurveRelease(*(void *)(a1 + 184));
    CGColorCurveRelease(*(void *)(a1 + 192));
    CGColorCurveRelease(*(void *)(a1 + 200));
    CGColorCurveRelease(*(void *)(a1 + 208));
    CGColorCurveRelease(*(void *)(a1 + 216));
    CGColorCurveRelease(*(void *)(a1 + 224));
    uint64_t v2 = *(const void **)(a1 + 232);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(const void **)(a1 + 240);
    if (v3) {
      CFRelease(v3);
    }
    free((void *)a1);
  }
}

void conversion_params_data_key_release(void *a1)
{
  if (a1) {
    free(a1);
  }
}

_DWORD *conversion_params_data_key_retain(long long *a1, void *a2)
{
  CGColorSpaceRef result = malloc_type_malloc(0x34uLL, 0x10000403884A0CCuLL);
  if (result)
  {
    long long v5 = *a1;
    long long v6 = a1[1];
    long long v7 = a1[2];
    result[12] = *((_DWORD *)a1 + 12);
    *((_OWORD *)result + 1) = v6;
    *((_OWORD *)result + 2) = v7;
    *(_OWORD *)CGColorSpaceRef result = v5;
  }
  *a2 = result;
  return result;
}

BOOL conversion_params_data_key_is_equal(uint64_t a1, uint64_t a2)
{
  long long v8 = *(_OWORD *)(a1 + 16);
  long long v7 = *(_OWORD *)(a2 + 16);
  if ((void)v8 != (void)v7 || *((void *)&v8 + 1) != *((void *)&v7 + 1)) {
    return 0;
  }
  if (*(void *)a1 != *(void *)a2 || *(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a1 + 32) == *(void *)(a2 + 32)
      && *(void *)(a1 + 40) == *(void *)(a2 + 40)
      && *(_DWORD *)(a1 + 48) == (unint64_t)*(unsigned int *)(a2 + 48);
}

uint64_t conversion_params_data_key_hash(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  long long v1 = *(_OWORD *)(a1 + 16);
  v3[0] = *(_OWORD *)a1;
  v3[1] = v1;
  v3[2] = *(_OWORD *)(a1 + 32);
  int v4 = *(_DWORD *)(a1 + 48);
  return MEMORY[0x18532A6B0](v3, 52);
}

char *CGColorSpaceGetConversionMatrix@<X0>(uint64_t a1@<X0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  *a3 = CGColorMatrixMakeIdentity_identity;
  a3[1] = unk_185295180;
  a3[2] = xmmword_185295190;
  switch(a2)
  {
    case 0:
    case 2:
      if (xyz_color_space_predicate != -1) {
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
      }
      uint64_t v5 = (CGColorSpace *)a1;
      a1 = xyz_color_space_xyz;
      break;
    case 1:
    case 3:
      if (xyz_color_space_predicate != -1) {
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
      }
      uint64_t v5 = (CGColorSpace *)xyz_color_space_xyz;
      break;
    default:
      uint64_t v5 = 0;
      a1 = 0;
      break;
  }
  CGColorSpaceRef result = (char *)conversion_cache_get_retained_conversion_params(a1, v5, 0);
  if (result)
  {
    long long v7 = result;
    long long v8 = *(_OWORD *)(result + 152);
    *a3 = *(_OWORD *)(result + 136);
    a3[1] = v8;
    a3[2] = *(_OWORD *)(result + 168);
    if (get_cache_predicate_14217 != -1) {
      dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
    }
    uint64_t v9 = *(cache_t **)(get_cache_conversion_cache + 64);
    return (char *)cache_release_value(v9, v7);
  }
  return result;
}

atomic_uint *CGColorSpaceCreateConversionCurve(uint64_t a1, unint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
    case 2:
      if (xyz_color_space_predicate != -1) {
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
      }
      long long v6 = (CGColorSpace *)a1;
      a1 = xyz_color_space_xyz;
      break;
    case 1:
    case 3:
      if (xyz_color_space_predicate != -1) {
        dispatch_once(&xyz_color_space_predicate, &__block_literal_global_39_14224);
      }
      long long v6 = (CGColorSpace *)xyz_color_space_xyz;
      break;
    default:
      long long v6 = 0;
      a1 = 0;
      break;
  }
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, v6, 0);
  long long v8 = retained_conversion_params;
  switch(a3)
  {
    case 0:
    case 2:
      if (!retained_conversion_params || *((void *)retained_conversion_params + 16) <= a2) {
        goto LABEL_22;
      }
      uint64_t v9 = (atomic_uint *)*((void *)retained_conversion_params + a2 + 23);
      if (v9) {
        atomic_fetch_add_explicit(v9, 1u, memory_order_relaxed);
      }
      if (get_cache_predicate_14217 != -1) {
        goto LABEL_24;
      }
      goto LABEL_21;
    case 1:
    case 3:
      if (!retained_conversion_params || *((void *)retained_conversion_params + 15) <= a2) {
        goto LABEL_22;
      }
      uint64_t v9 = (atomic_uint *)*((void *)retained_conversion_params + a2 + 26);
      if (v9) {
        atomic_fetch_add_explicit(v9, 1u, memory_order_relaxed);
      }
      if (get_cache_predicate_14217 != -1)
      {
LABEL_24:
        long long v11 = retained_conversion_params;
        dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
        long long v8 = v11;
      }
LABEL_21:
      cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v8);
      break;
    default:
LABEL_22:
      uint64_t v9 = 0;
      break;
  }
  return v9;
}

atomic_uint *CGDisplayColorSpaceConversionCreateLinearizationCurve(uint64_t a1, CGColorSpace *a2, unint64_t a3, long long *a4)
{
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a4);
  if (!retained_conversion_params) {
    return 0;
  }
  long long v6 = retained_conversion_params;
  if (*((void *)retained_conversion_params + 16) <= a3) {
    return 0;
  }
  long long v7 = (atomic_uint *)*((void *)retained_conversion_params + a3 + 23);
  if (v7) {
    atomic_fetch_add_explicit(v7, 1u, memory_order_relaxed);
  }
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v6);
  return v7;
}

uint64_t CGDisplayColorSpaceConversionCreatePreMatrixToneMapping(uint64_t a1, CGColorSpace *a2, long long *a3)
{
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (!retained_conversion_params) {
    return 0;
  }
  int v4 = retained_conversion_params;
  uint64_t v5 = *((void *)retained_conversion_params + 29);
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v4);
  return v5;
}

char *CGDisplayColorSpaceConversionGetConversionMatrix@<X0>(uint64_t a1@<X0>, CGColorSpace *a2@<X1>, long long *a3@<X2>, _OWORD *a4@<X8>)
{
  *a4 = CGColorMatrixMakeIdentity_identity;
  a4[1] = unk_185295180;
  a4[2] = xmmword_185295190;
  CGColorSpaceRef result = (char *)conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (result)
  {
    long long v6 = result;
    long long v7 = *(_OWORD *)(result + 152);
    *a4 = *(_OWORD *)(result + 136);
    a4[1] = v7;
    a4[2] = *(_OWORD *)(result + 168);
    if (get_cache_predicate_14217 != -1) {
      dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
    }
    long long v8 = *(cache_t **)(get_cache_conversion_cache + 64);
    return (char *)cache_release_value(v8, v6);
  }
  return result;
}

uint64_t CGDisplayColorSpaceConversionCreatePostMatrixToneMapping(uint64_t a1, CGColorSpace *a2, long long *a3)
{
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a3);
  if (!retained_conversion_params) {
    return 0;
  }
  int v4 = retained_conversion_params;
  uint64_t v5 = *((void *)retained_conversion_params + 30);
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v4);
  return v5;
}

atomic_uint *CGDisplayColorSpaceConversionCreateInvertedLinearizationCurve(uint64_t a1, CGColorSpace *a2, unint64_t a3, long long *a4)
{
  retained_conversion_params = conversion_cache_get_retained_conversion_params(a1, a2, a4);
  if (!retained_conversion_params) {
    return 0;
  }
  long long v6 = retained_conversion_params;
  if (*((void *)retained_conversion_params + 15) <= a3) {
    return 0;
  }
  long long v7 = (atomic_uint *)*((void *)retained_conversion_params + a3 + 26);
  if (v7) {
    atomic_fetch_add_explicit(v7, 1u, memory_order_relaxed);
  }
  if (get_cache_predicate_14217 != -1) {
    dispatch_once(&get_cache_predicate_14217, &__block_literal_global_14218);
  }
  cache_release_value(*(cache_t **)(get_cache_conversion_cache + 64), v6);
  return v7;
}

uint64_t type4_value_add(double *a1, uint64_t a2, double *a3)
{
  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 == 258)
    {
      double v10 = *(double *)(a2 + 8) + a3[1];
      goto LABEL_15;
    }
    if (*(_DWORD *)a3 == 257)
    {
      double v7 = (double)*((int *)a3 + 2);
      double v8 = *(double *)(a2 + 8);
LABEL_13:
      double v10 = v8 + v7;
      goto LABEL_15;
    }
    return 0;
  }
  if (*(_DWORD *)a2 != 257) {
    return 0;
  }
  int v3 = *(_DWORD *)a3;
  if (*(_DWORD *)a3 == 258)
  {
    double v7 = (double)*(int *)(a2 + 8);
    double v8 = a3[1];
    goto LABEL_13;
  }
  BOOL v4 = __OFSUB__(v3, 257);
  if (v3 != 257) {
    return 0;
  }
  int v5 = *(_DWORD *)(a2 + 8);
  int v6 = *((_DWORD *)a3 + 2);
  if ((v6 | v5) < 0)
  {
    if ((v6 & v5) < 0 == v4 || (int)(0x80000000 - v6) <= v5) {
      goto LABEL_21;
    }
  }
  else if ((v6 ^ 0x7FFFFFFF) >= v5)
  {
LABEL_21:
    *(_DWORD *)a1 = 257;
    *((_DWORD *)a1 + 2) = v6 + v5;
    return 1;
  }
  double v10 = (double)v5 + (double)v6;
LABEL_15:
  *(_DWORD *)a1 = 258;
  a1[1] = v10;
  return 1;
}

uint64_t type4_value_sub(double *a1, double *a2, uint64_t a3)
{
  if (*(_DWORD *)a2 != 258)
  {
    if (*(_DWORD *)a2 == 257)
    {
      if (*(_DWORD *)a3 == 258)
      {
        double v7 = (double)*((int *)a2 + 2);
        double v8 = *(double *)(a3 + 8);
LABEL_19:
        double v5 = v7 - v8;
        goto LABEL_20;
      }
      if (*(_DWORD *)a3 == 257)
      {
        signed int v3 = *((_DWORD *)a2 + 2);
        int v4 = *(_DWORD *)(a3 + 8);
        if (v3 < 0 || (v4 & 0x80000000) == 0)
        {
          if ((v3 & 0x80000000) == 0 || v4 < 0 || (v4 | 0x80000000) <= v3) {
            goto LABEL_22;
          }
        }
        else if (v4 + 0x7FFFFFFF >= v3)
        {
LABEL_22:
          *(_DWORD *)a1 = 257;
          *((_DWORD *)a1 + 2) = v3 - v4;
          return 1;
        }
        double v7 = (double)v3;
        double v8 = (double)v4;
        goto LABEL_19;
      }
    }
    return 0;
  }
  if (*(_DWORD *)a3 == 258)
  {
    double v5 = a2[1] - *(double *)(a3 + 8);
  }
  else
  {
    if (*(_DWORD *)a3 != 257) {
      return 0;
    }
    double v5 = a2[1] - (double)*(int *)(a3 + 8);
  }
LABEL_20:
  *(_DWORD *)a1 = 258;
  a1[1] = v5;
  return 1;
}

uint64_t type4_value_mul(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 == 258)
    {
      double v8 = *(double *)(a2 + 8) * *(double *)(a3 + 8);
      goto LABEL_14;
    }
    if (*(_DWORD *)a3 != 257) {
      return 0;
    }
    double v5 = (double)*(int *)(a3 + 8);
    double v6 = *(double *)(a2 + 8);
LABEL_12:
    double v8 = v6 * v5;
LABEL_14:
    *(_DWORD *)a1 = 258;
    *(double *)(a1 + 8) = v8;
    return 1;
  }
  if (*(_DWORD *)a2 != 257) {
    return 0;
  }
  if (*(_DWORD *)a3 == 258)
  {
    double v5 = (double)*(int *)(a2 + 8);
    double v6 = *(double *)(a3 + 8);
    goto LABEL_12;
  }
  if (*(_DWORD *)a3 != 257) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  int v4 = *(_DWORD *)(a3 + 8);
  if (((v4 + 0x8000) | (v3 + 0x8000)) >> 16)
  {
    uint64_t v9 = v4 * (uint64_t)v3;
    if (v9 == (int)v9)
    {
      *(_DWORD *)a1 = 257;
      *(_DWORD *)(a1 + 8) = v9;
      return 1;
    }
    double v8 = (double)v9;
    goto LABEL_14;
  }
  *(_DWORD *)a1 = 257;
  *(_DWORD *)(a1 + 8) = v4 * v3;
  return 1;
}

BOOL type4_value_equal(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 - 257) >= 2)
  {
    if (*(_DWORD *)a1 != 256 || *(_DWORD *)a2 != 256) {
      return 0;
    }
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  }
  else
  {
    int v5 = 0;
    int v2 = type4_value_compare(&v5, a1, (double *)a2);
    BOOL result = 0;
    if (!v2) {
      return result;
    }
    return v5 == 0;
  }
}

uint64_t type4_value_compare(int *a1, uint64_t a2, double *a3)
{
  if (*(_DWORD *)a2 == 258)
  {
    if (*(_DWORD *)a3 != 258)
    {
      if (*(_DWORD *)a3 != 257) {
        return 0;
      }
      double v4 = *(double *)(a2 + 8);
      double v5 = (double)*((int *)a3 + 2);
LABEL_13:
      if (v4 >= v5) {
        int v3 = v4 > v5;
      }
      else {
        int v3 = -1;
      }
      goto LABEL_16;
    }
    double v4 = *(double *)(a2 + 8);
LABEL_12:
    double v5 = a3[1];
    goto LABEL_13;
  }
  if (*(_DWORD *)a2 != 257) {
    return 0;
  }
  if (*(_DWORD *)a3 == 258)
  {
    double v4 = (double)*(int *)(a2 + 8);
    goto LABEL_12;
  }
  if (*(_DWORD *)a3 != 257) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 8) - *((_DWORD *)a3 + 2);
LABEL_16:
  *a1 = v3;
  return 1;
}

uint64_t type4_value_cvi(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (*(_DWORD *)a2 != 258)
  {
    if (*(_DWORD *)a2 != 257) {
      return 0;
    }
    *(_OWORD *)a1 = *(_OWORD *)a2;
    return 1;
  }
  __double y = 0.0;
  modf(*(long double *)(a2 + 8), &__y);
  double v5 = __y;
  if (__y < -2147483650.0)
  {
    uint64_t result = 1;
    *a3 = 1;
    *(_DWORD *)a1 = 257;
    unsigned int v7 = 0x80000000;
LABEL_9:
    *(_DWORD *)(a1 + 8) = v7;
    return result;
  }
  if (__y > 2147483650.0)
  {
    uint64_t result = 1;
    *a3 = 1;
    *(_DWORD *)a1 = 257;
    unsigned int v7 = 0x7FFFFFFF;
    goto LABEL_9;
  }
  *a3 = 0;
  *(_DWORD *)a1 = 257;
  *(_DWORD *)(a1 + 8) = (int)v5;
  return 1;
}

char *CGPDFGroupCreate(CGPDFDictionary *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v2 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
  {
    __s1 = 0;
    CGPDFInteger value = 0;
    CGPDFDictionaryRef dict = 0;
    CGPDFObjectRef v10 = 0;
    *(_WORD *)double v8 = 0;
    *(void *)int v2 = a1;
    if (a1) {
      a1 = (CGPDFDictionary *)*((void *)a1 + 6);
    }
    if (CGPDFDictionaryGetInteger(a1, "FormType", &value) && value != 1)
    {
LABEL_20:
      CGColorSpaceRelease(*((CGColorSpaceRef *)v2 + 12));
      free(v2);
      return 0;
    }
    if (!CGPDFDictionaryGetRect(a1, "BBox", (double *)v2 + 1))
    {
      goto LABEL_20;
    }
    if (CGPDFDictionaryGetNumbers(a1, "Matrix", (uint64_t)v13, (CGPDFArray *)6))
    {
      long long v3 = v13[1];
      *(_OWORD *)(v2 + 40) = v13[0];
      *(_OWORD *)(v2 + 56) = v3;
      *(_OWORD *)(v2 + 72) = v13[2];
    }
    else
    {
      *(CGAffineTransform *)(v2 + 40) = CGAffineTransformIdentity;
    }
    if (!CGPDFDictionaryGetDictionary(a1, "Resources", (CGPDFDictionaryRef *)v2 + 11)) {
      *((void *)v2 + 11) = 0;
    }
    if (!CGPDFDictionaryGetDictionary(a1, "Group", &dict))
    {
      goto LABEL_20;
    }
    if (!CGPDFDictionaryGetName(dict, "S", (const char **)&__s1))
    {
      goto LABEL_20;
    }
    if (strcmp(__s1, "Transparency"))
    {
      goto LABEL_20;
    }
    v2[104] = 0;
    if (CGPDFDictionaryGetBoolean(dict, "I", &v8[1])) {
      v2[104] = v8[1] != 0;
    }
    v2[105] = 0;
    if (CGPDFDictionaryGetBoolean(dict, "K", v8)) {
      v2[105] = v8[0] != 0;
    }
    *((void *)v2 + 12) = 0;
    if (CGPDFDictionaryGetObject(dict, "CS", &v10))
    {
      colorCGColorSpaceRef space = cg_create_colorspace((uint64_t)v10);
      *((void *)v2 + 12) = colorspace;
      int Type = CGColorSpaceGetType(colorspace);
      if ((Type - 7) < 3) {
        goto LABEL_33;
      }
      if (Type != 6)
      {
        if (Type != 5) {
          return v2;
        }
        goto LABEL_33;
      }
      uint64_t v7 = *((void *)v2 + 12);
      if (!v7 || *(_DWORD *)(*(void *)(v7 + 24) + 28) >= 3u)
      {
LABEL_33:
        pdf_error("invalid group attributes color space.");
        goto LABEL_20;
      }
    }
  }
  return v2;
}

void CGPDFGroupRelease(CGColorSpaceRef *a1)
{
  if (a1)
  {
    CGColorSpaceRelease(a1[12]);
    free(a1);
  }
}

uint64_t CGDisplayColorCurveCreateIdentity()
{
  if (CGDisplayColorCurveCreateIdentity_predicate != -1) {
    dispatch_once(&CGDisplayColorCurveCreateIdentity_predicate, &__block_literal_global_14321);
  }
  uint64_t result = CGDisplayColorCurveCreateIdentity_curve;
  if (CGDisplayColorCurveCreateIdentity_curve) {
    atomic_fetch_add_explicit((atomic_uint *volatile)CGDisplayColorCurveCreateIdentity_curve, 1u, memory_order_relaxed);
  }
  return result;
}

int64x2_t __CGDisplayColorCurveCreateIdentity_block_invoke()
{
  uint64_t v0 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x10C2040536035A7uLL);
  CGDisplayColorCurveCreateIdentity_curve = (uint64_t)v0;
  if (v0)
  {
    *((_DWORD *)v0 + 1) = 0;
    __asm { FMOV            V0.2S, #1.0 }
    *((void *)v0 + 1) = _D0;
    *((_DWORD *)v0 + 16) = 1065353216;
    v0[60] = 1;
    int64x2_t result = vdupq_n_s64(0x7F7FFFFFFF7FFFFFuLL);
    *(int64x2_t *)(v0 + 44) = result;
    *(_DWORD *)uint64_t v0 = 1;
  }
  return result;
}

atomic_uint *CGColorCurveRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

char *CGDisplayColorCurveCreate(_DWORD *a1, char a2, int a3, float a4, float a5, float a6, float a7)
{
  uint64_t v14 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x10C2040536035A7uLL);
  float v15 = v14;
  if (v14)
  {
    pthread_mutex_init((pthread_mutex_t *)(v14 + 80), 0);
    *(_DWORD *)float v15 = 1;
    *((_DWORD *)v15 + 1) = 4;
    v15[60] = a2;
    *((_DWORD *)v15 + 10) = a3;
    *((float *)v15 + 11) = a4;
    *((float *)v15 + 12) = a5;
    *((float *)v15 + 13) = a6;
    *((float *)v15 + 14) = a7;
    float v16 = *(float *)a1;
    switch(*a1)
    {
      case 0:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = 1065353216;
        *((void *)v15 + 2) = 0;
        *((void *)v15 + 3) = 0;
        *((_DWORD *)v15 + 8) = 0;
        *((_DWORD *)v15 + 16) = a1[1];
        return v15;
      case 1:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 7) = 0;
        *((float *)v15 + 6) = (float)-*((float *)a1 + 3) / *((float *)a1 + 2);
        *((_DWORD *)v15 + 5) = 0;
        *((_DWORD *)v15 + 8) = 0;
        return v15;
      case 2:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = 0;
        *((float *)v15 + 6) = (float)-*((float *)a1 + 3) / *((float *)a1 + 2);
        *((_DWORD *)v15 + 7) = a1[4];
        *((_DWORD *)v15 + 8) = a1[4];
        return v15;
      case 3:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = 0;
        *((_DWORD *)v15 + 8) = 0;
        long long v17 = *((_OWORD *)a1 + 1);
        long long v26 = *(_OWORD *)a1;
        long long v27 = v17;
        int v28 = a1[8];
        if (trc_equal_trc((uint64_t)&v26, (uint64_t)&sRGB_curve))
        {
          int v18 = 1074580685;
          goto LABEL_20;
        }
        long long v23 = *((_OWORD *)a1 + 1);
        long long v26 = *(_OWORD *)a1;
        long long v27 = v23;
        int v28 = a1[8];
        if (!trc_equal_trc((uint64_t)&v26, (uint64_t)&itu_r_709_curve)) {
          return v15;
        }
        int v18 = 1072902963;
        goto LABEL_20;
      case 4:
        *((_DWORD *)v15 + 2) = a1[1];
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = a1[6];
        *((_DWORD *)v15 + 8) = a1[7];
        long long v19 = *((_OWORD *)a1 + 1);
        long long v26 = *(_OWORD *)a1;
        long long v27 = v19;
        int v28 = a1[8];
        if (trc_equal_trc((uint64_t)&v26, (uint64_t)&inverted_sRGB_curve))
        {
          int v18 = 1055439407;
        }
        else
        {
          long long v24 = *((_OWORD *)a1 + 1);
          long long v26 = *(_OWORD *)a1;
          long long v27 = v24;
          int v28 = a1[8];
          if (!trc_equal_trc((uint64_t)&v26, (uint64_t)&inverted_itu_r_709_curve)) {
            return v15;
          }
          int v18 = 1057406114;
        }
LABEL_20:
        *((_DWORD *)v15 + 16) = v18;
        break;
      case 5:
        *((_DWORD *)v15 + 1) = 5;
        uint64_t v20 = malloc_type_malloc(4 * *(void *)(a1 + 1), 0x100004052888210uLL);
        *((void *)v15 + 9) = v20;
        if (v20)
        {
          if (*(void *)(a1 + 1))
          {
            unint64_t v21 = 0;
            do
            {
              v20[v21] = *(_DWORD *)(*(void *)(a1 + 3) + 4 * v21);
              ++v21;
              unint64_t v22 = *(void *)(a1 + 1);
            }
            while (v21 < v22);
          }
          else
          {
            unint64_t v22 = 0;
          }
          *((void *)v15 + 1) = v22;
        }
        *((void *)v15 + 2) = v20;
        return v15;
      case 6:
      case 7:
      case 8:
      case 9:
        v15[60] = 0;
        *((float *)v15 + 1) = v16;
        *((_DWORD *)v15 + 2) = 0;
        *((_DWORD *)v15 + 3) = a1[2];
        *((_DWORD *)v15 + 4) = a1[3];
        *((_DWORD *)v15 + 5) = a1[4];
        *((_DWORD *)v15 + 6) = a1[5];
        *((_DWORD *)v15 + 7) = a1[6];
        *((_DWORD *)v15 + 8) = a1[7];
        *((_DWORD *)v15 + 16) = 0;
        return v15;
      default:
        abort();
    }
  }
  return v15;
}

BOOL trc_equal_trc(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 != 5
      && *(_DWORD *)a1 == *(_DWORD *)a2
      && vabds_f32(*(float *)(a1 + 4), *(float *)(a2 + 4)) < 0.0005
      && vabds_f32(*(float *)(a1 + 8), *(float *)(a2 + 8)) < 0.0005
      && vabds_f32(*(float *)(a1 + 12), *(float *)(a2 + 12)) < 0.0005
      && vabds_f32(*(float *)(a1 + 16), *(float *)(a2 + 16)) < 0.0005
      && vabds_f32(*(float *)(a1 + 20), *(float *)(a2 + 20)) < 0.0005
      && vabds_f32(*(float *)(a1 + 24), *(float *)(a2 + 24)) < 0.0005
      && vabds_f32(*(float *)(a1 + 28), *(float *)(a2 + 28)) < 0.0005;
}

void CGColorCurveRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 80));
    free(*(void **)(a1 + 72));
    free((void *)a1);
  }
}

BOOL CGColorCurveEqualToGammaCurve(uint64_t a1, uint64_t a2)
{
  BOOL v2 = 0;
  if (a1 && a2)
  {
    if (a1 == a2) {
      return 1;
    }
    unsigned int v3 = *(_DWORD *)(a1 + 4);
    if (v3 != *(_DWORD *)(a2 + 4) || v3 > 9) {
      return 0;
    }
    if (v3 != 5)
    {
      if (*(float *)(a1 + 12) == *(float *)(a2 + 12)
        && *(float *)(a1 + 16) == *(float *)(a2 + 16)
        && *(float *)(a1 + 20) == *(float *)(a2 + 20)
        && *(float *)(a1 + 24) == *(float *)(a2 + 24)
        && *(float *)(a1 + 28) == *(float *)(a2 + 28)
        && *(float *)(a1 + 32) == *(float *)(a2 + 32))
      {
        return *(float *)(a1 + 8) == *(float *)(a2 + 8);
      }
      return 0;
    }
    uint64_t v4 = *(void *)(a1 + 8);
    if (v4 != *(void *)(a2 + 8)) {
      return 0;
    }
    if (!v4) {
      return 1;
    }
    double v5 = *(float **)(a1 + 16);
    double v6 = *(float **)(a2 + 16);
    uint64_t v7 = v4 - 1;
    do
    {
      float v8 = *v5++;
      float v9 = v8;
      float v10 = *v6++;
      float v11 = v10;
      BOOL v13 = v7-- != 0;
      BOOL v2 = v9 == v11;
    }
    while (v9 == v11 && v13);
  }
  return v2;
}

float get_gamma(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v2 = a1 + 8;
  }
  else
  {
    if (*(int *)(a1 + 4) <= 5)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
      if (*(float *)(a1 + 64) == 0.0)
      {
        int v3 = *(_DWORD *)(a1 + 4);
        float v4 = 0.0;
        if (v3 <= 5)
        {
          int v5 = 0;
          unint64_t v6 = 0;
          float v7 = 0.0;
          do
          {
            int v14 = v3;
            long long v8 = *(_OWORD *)(a1 + 24);
            long long v15 = *(_OWORD *)(a1 + 8);
            long long v16 = v8;
            calculate_trc((uint64_t)&v14, (float)v6 / 1023.0);
            if (v6)
            {
              float v10 = v9;
              if (v9 != 1.0 && v6 != 1023 && v9 != 0.0)
              {
                float v11 = logf((float)v6 / 1023.0);
                float v7 = v7 + (float)(logf(v10) / v11);
                ++v5;
              }
            }
            ++v6;
          }
          while (v6 != 1024);
          if (v5 <= 0) {
            double v12 = 1.0;
          }
          else {
            double v12 = (float)(v7 / (float)v5);
          }
          float v4 = floor(v12 * 10.0 + 0.5) / 10.0;
        }
        *(float *)(a1 + 64) = v4;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 80));
    }
    uint64_t v2 = a1 + 64;
  }
  return *(float *)v2;
}

void calculate_trc(uint64_t a1, float a2)
{
  switch(*(_DWORD *)a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      float v3 = *(float *)(a1 + 20);
      if (v3 <= a2) {
        fmaxf(*(float *)(a1 + 28) + (float)(v3 * *(float *)(a1 + 16)), powf(*(float *)(a1 + 12) + (float)(a2 * *(float *)(a1 + 8)), *(float *)(a1 + 4)) + *(float *)(a1 + 24));
      }
      break;
    case 6:
      float v4 = powf(fabsf(a2), *(float *)(a1 + 8));
      powf(fmaxf(v4 - *(float *)(a1 + 16), 0.0) / (float)(*(float *)(a1 + 20) - (float)(*(float *)(a1 + 24) * v4)), *(float *)(a1 + 12));
      break;
    case 7:
      float v5 = powf(fabsf(a2) * *(float *)(a1 + 28), *(float *)(a1 + 8));
      float v6 = (float)(*(float *)(a1 + 16) + (float)(*(float *)(a1 + 20) * v5)) / ((float)(v5 * *(float *)(a1 + 24)) + 1.0);
      powf(v6, *(float *)(a1 + 12));
      break;
    case 8:
      float v8 = *(float *)(a1 + 28) + (float)((float)(1.0 - *(float *)(a1 + 28)) * fabsf(a2));
      if (v8 >= 0.0 && v8 > 0.5) {
        expf((float)(v8 - *(float *)(a1 + 16)) / *(float *)(a1 + 8));
      }
      break;
    case 9:
      float v7 = fabsf(*(float *)(a1 + 24) * a2);
      if (v7 > *(float *)(a1 + 20)) {
        log(-(*(float *)(a1 + 12) - v7 * 12.0));
      }
      break;
    default:
      return;
  }
}

uint64_t CGColorCurveOriginalIsPureGamma(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 60);
}

void CGColorCurveGetParameters(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, float *a8)
{
  unsigned int v16 = *(_DWORD *)(a1 + 4);
  if (v16 < 5)
  {
    *a2 = *(_DWORD *)(a1 + 24);
    *a3 = *(_DWORD *)(a1 + 12);
    *a4 = *(_DWORD *)(a1 + 16);
    *a5 = *(_DWORD *)(a1 + 28);
    *a6 = *(_DWORD *)(a1 + 20);
    *a7 = *(_DWORD *)(a1 + 32);
    gammdouble a = *(float *)(a1 + 8);
LABEL_5:
    *a8 = gamma;
    return;
  }
  if (v16 - 6 < 4)
  {
    *a2 = *(_DWORD *)(a1 + 24);
    *a3 = *(_DWORD *)(a1 + 12);
    *a4 = *(_DWORD *)(a1 + 16);
    *a5 = *(_DWORD *)(a1 + 28);
    *a6 = *(_DWORD *)(a1 + 20);
    *a7 = *(_DWORD *)(a1 + 32);
    *a8 = 0.0;
    return;
  }
  if (v16 == 5)
  {
    CGPostError((uint64_t)"%s: CGColorCurve type kCGColorTRCTable used as parametric. Returning estimated gamma", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (char)"CGColorCurveGetParameters");
    *a2 = 0;
    *a3 = 1065353216;
    *a4 = 0;
    *a5 = 0;
    *a6 = 0;
    *a7 = 0;
    gammdouble a = get_gamma(a1);
    goto LABEL_5;
  }
  CGPostError((uint64_t)"%s: CGColorCurve type %d is not supprted", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, (char)"CGColorCurveGetParameters");
}

__n128 CGColorCurveGetTRC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)(a1 + 4);
  long long v3 = *(_OWORD *)(a1 + 20);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 36);
  return result;
}

uint64_t CGColorCurveGetProperties(uint64_t a1)
{
  return *(unsigned int *)(a1 + 40);
}

float CGColorCurveGetInputRange(uint64_t a1)
{
  return *(float *)(a1 + 44);
}

float CGColorCurveGetOutputRange(uint64_t a1)
{
  return *(float *)(a1 + 52);
}

void CGColorCurveMapValue(uint64_t a1, float a2)
{
  long long v2 = *(_OWORD *)(a1 + 20);
  v3[0] = *(_OWORD *)(a1 + 4);
  v3[1] = v2;
  int v4 = *(_DWORD *)(a1 + 36);
  calculate_trc((uint64_t)v3, a2);
}

uint64_t CGColorCurvePrint(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 4))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      uint64_t result = printf("%s: d:%f | gamma:%f | c:%f f:%f | a:%f b:%f e:%f");
      break;
    case 5:
      uint64_t result = printf("%s: table with %zu entries\n");
      break;
    case 6:
    case 7:
    case 8:
    case 9:
      uint64_t result = printf("%s: %s a:%f | b:%f | c:%f | d:%f | e:%f | f:%f");
      break;
    default:
      uint64_t result = printf("%s: unknown curve type\n");
      break;
  }
  return result;
}

void CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      BOOL v13 = (const CGPath *)*((void *)c + 21);
      if (v13 && !CGPathIsEmpty(v13))
      {
        long long v19 = (CGPath *)*((void *)c + 21);
        uint64_t v20 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
        CGPathAddQuadCurveToPoint(v19, v20, cpx, cpy, x, y);
      }
      else
      {
        CGPostError((uint64_t)"%s: no current point.", v5, v6, v7, v8, v9, v10, v11, (char)"CGContextAddQuadCurveToPoint");
      }
      return;
    }
    CGContextRef v18 = c;
  }
  else
  {
    CGContextRef v18 = 0;
  }

  handle_invalid_context((char)"CGContextAddQuadCurveToPoint", (uint64_t)v18, v6, v7, v8, v9, v10, v11);
}

void CGContextAddRects(CGContextRef c, const CGRect *rects, size_t count)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (rects && count)
      {
        CFAttributedStringRef Mutable = (CGPath *)*((void *)c + 21);
        if (!Mutable)
        {
          CFAttributedStringRef Mutable = CGPathCreateMutable();
          *((void *)c + 21) = Mutable;
        }
        double v12 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
        CGPathAddRects(Mutable, v12, rects, count);
      }
      return;
    }
    CGContextRef v13 = c;
  }
  else
  {
    CGContextRef v13 = 0;
  }

  handle_invalid_context((char)"CGContextAddRects", (uint64_t)v13, count, v3, v4, v5, v6, v7);
}

void CGContextAddLines(CGContextRef c, const CGPoint *points, size_t count)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (points && count)
      {
        CFAttributedStringRef Mutable = (CGPath *)*((void *)c + 21);
        if (!Mutable)
        {
          CFAttributedStringRef Mutable = CGPathCreateMutable();
          *((void *)c + 21) = Mutable;
        }
        double v12 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
        CGPathAddLines(Mutable, v12, points, count);
      }
      return;
    }
    CGContextRef v13 = c;
  }
  else
  {
    CGContextRef v13 = 0;
  }

  handle_invalid_context((char)"CGContextAddLines", (uint64_t)v13, count, v3, v4, v5, v6, v7);
}

void CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CFAttributedStringRef Mutable = (CGPath *)*((void *)c + 21);
      if (!Mutable)
      {
        CFAttributedStringRef Mutable = CGPathCreateMutable();
        *((void *)c + 21) = Mutable;
      }
      long long v19 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
      CGPathAddArcToPoint(Mutable, v19, x1, y1, x2, y2, radius);
      return;
    }
    CGContextRef v20 = c;
  }
  else
  {
    CGContextRef v20 = 0;
  }

  handle_invalid_context((char)"CGContextAddArcToPoint", (uint64_t)v20, v6, v7, v8, v9, v10, v11);
}

BOOL CGContextIsPathEmpty(CGContextRef c)
{
  if (!c || *((_DWORD *)c + 4) != 1129601108)
  {
    handle_invalid_context((char)"CGContextIsPathEmpty", (uint64_t)c, v1, v2, v3, v4, v5, v6);
    return 1;
  }
  uint64_t v7 = (const CGPath *)*((void *)c + 21);
  if (!v7) {
    return 1;
  }

  return CGPathIsEmpty(v7);
}

CGPoint CGContextGetPathCurrentPoint(CGContextRef c)
{
  if (!c)
  {
    CGContextRef v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetPathCurrentPoint", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
    goto LABEL_9;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v10 = c;
    goto LABEL_8;
  }
  uint64_t v9 = (const CGPath *)*((void *)c + 21);
  if (!v9 || CGPathIsEmpty(v9))
  {
    CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGContextGetPathCurrentPoint");
LABEL_9:
    double v11 = 0.0;
    double v12 = 0.0;
    goto LABEL_12;
  }
  CGPoint CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*((void *)c + 21));
  uint64_t v14 = *((void *)c + 12);
  long long v15 = *(_OWORD *)(v14 + 40);
  v23[0] = *(_OWORD *)(v14 + 24);
  v23[1] = v15;
  v23[2] = *(_OWORD *)(v14 + 56);
  double v11 = CGPointApplyInverseAffineTransform((double *)v23, v16, v17, v18, v19, v20, v21, v22, CurrentPoint.x, CurrentPoint.y);
LABEL_12:
  result.double y = v12;
  result.double x = v11;
  return result;
}

CGRect CGContextGetPathBoundingBox(CGContextRef c)
{
  if (!c)
  {
    CGContextRef v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetPathBoundingBox", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
    goto LABEL_9;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v10 = c;
    goto LABEL_8;
  }
  uint64_t v9 = (const CGPath *)*((void *)c + 21);
  if (!v9 || CGPathIsEmpty(v9))
  {
    CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGContextGetPathBoundingBox");
LABEL_9:
    double v11 = 0.0;
    double v12 = INFINITY;
    double v13 = INFINITY;
    double v14 = 0.0;
    goto LABEL_12;
  }
  BoundingBodouble x = CGPathGetBoundingBox((CGPathRef)*((void *)c + 21));
  uint64_t v15 = *((void *)c + 12);
  long long v16 = *(_OWORD *)(v15 + 40);
  v17[0] = *(_OWORD *)(v15 + 24);
  v17[1] = v16;
  _OWORD v17[2] = *(_OWORD *)(v15 + 56);
  double v13 = CGRectApplyInverseAffineTransform((double *)v17, *(__n64 *)&BoundingBox.origin.x, BoundingBox.origin.y, BoundingBox.size.width, BoundingBox.size.height).n64_f64[0];
LABEL_12:
  result.size.double height = v14;
  result.size.double width = v11;
  result.origin.double y = v12;
  result.origin.double x = v13;
  return result;
}

void *__draw_path_block_invoke(void *result, int *a2, unsigned char *a3)
{
  int v3 = *a2;
  if (*a2 == 4)
  {
    uint64_t v5 = result[7];
LABEL_8:
    ++*(_DWORD *)(*(void *)(v5 + 8) + 24);
    goto LABEL_11;
  }
  if (v3 == 1)
  {
    uint64_t v5 = result[6];
    goto LABEL_8;
  }
  if (v3)
  {
    ++*(_DWORD *)(*(void *)(result[8] + 8) + 24);
LABEL_10:
    *a3 = 1;
    goto LABEL_11;
  }
  int v4 = ++*(_DWORD *)(*(void *)(result[4] + 8) + 24);
  if (v4 != 1)
  {
    if (v4 < 2) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  *(_OWORD *)(*(void *)(result[5] + 8) + 24) = *(_OWORD *)*((void *)a2 + 1);
LABEL_11:
  *(void *)(*(void *)(result[9] + 8) + 24) = a2;
  return result;
}

__n128 __draw_path_block_invoke_2(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (*(_DWORD *)a2 == 4) {
    uint64_t v6 = (__n128 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
  else {
    uint64_t v6 = *(__n128 **)(a2 + 8);
  }
  __n128 result = *v6;
  uint64_t v8 = *(void *)(a1 + 72);
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v10 = *(void *)(v9 + 24);
  *(void *)(v9 + 24) = v10 + 1;
  *(__n128 *)(v8 + 16 * v10) = result;
  size_t v11 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  if (v11 >= 0x80)
  {
    CGPathAddLines(*(CGMutablePathRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), 0, *(const CGPoint **)(a1 + 72), v11);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 56) + 8)+ 24));
    uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
    double v13 = *(const void **)(v12 + 24);
    if (v13)
    {
      CFRelease(v13);
      uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
    }
    *(void *)(v12 + 24) = 0;
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24))
    {
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
      *a3 = 1;
    }
    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = CGPathCreateMutable();
      __n128 result = *(__n128 *)*(void *)(a2 + 8);
      *(__n128 *)*(void *)(a1 + 72) = result;
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    }
  }
  return result;
}

void CGContextEOFillPath(CGContextRef c)
{
}

void CGContextStrokeLineSegments(CGContextRef c, const CGPoint *points, size_t count)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      size_t v11 = (const void *)*((void *)c + 21);
      if (v11)
      {
        CFRelease(v11);
        *((void *)c + 21) = 0;
      }
      if (points)
      {
        if (count)
        {
          uint64_t v12 = *((void *)c + 12);
          double v13 = *(double *)(*(void *)(v12 + 128) + 8);
          if (v13 > 0.0 || v13 == -1.0905473e16)
          {
            uint64_t v15 = *((void *)c + 5);
            uint64_t v16 = *((void *)c + 14);
            CGContextDelegateDrawLines(v15, v16, v12, points, count);
          }
        }
      }
      return;
    }
    CGContextRef v14 = c;
  }
  else
  {
    CGContextRef v14 = 0;
  }

  handle_invalid_context((char)"CGContextStrokeLineSegments", (uint64_t)v14, count, v3, v4, v5, v6, v7);
}

void CGContextClipToMaskWithTransform(uint64_t a1, __CFData *image, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  if (!a1)
  {
    uint64_t v25 = 0;
LABEL_25:
    handle_invalid_context((char)"CGContextClipToMaskWithTransform", v25, (uint64_t)a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v25 = a1;
    goto LABEL_25;
  }
  if (a9 != INFINITY && a10 != INFINITY)
  {
    uint64_t v22 = image;
    if (!image) {
      goto LABEL_36;
    }
    if ((*((unsigned char *)image + 39) & 2) != 0)
    {
      mask_from_image = 0;
    }
    else
    {
      mask_from_image = create_mask_from_image(image, (uint64_t)image, (uint64_t)a3, a4, a5, a6, a7, a8);
      uint64_t v22 = mask_from_image;
      if (!mask_from_image)
      {
LABEL_36:
        uint64_t v45 = *(const void **)(a1 + 168);
        if (v45)
        {
          CFRelease(v45);
          *(void *)(a1 + 168) = 0;
        }
        return;
      }
    }
    uint64_t v26 = *(void *)(a1 + 96);
    double v28 = *(double *)(v26 + 24);
    double v27 = *(double *)(v26 + 32);
    double v30 = *(double *)(v26 + 40);
    double v29 = *(double *)(v26 + 48);
    double v31 = *(double *)(v26 + 64);
    if (a3)
    {
      double v32 = a3[1];
      double v33 = a3[2];
      double v34 = a3[3];
      double v35 = a3[4];
      double v36 = a3[5];
      double v37 = v32 * v30;
      double v38 = v30 * v36;
      double v30 = v34 * v30 + v33 * v28;
      double v39 = v38 + v35 * v28;
      double v28 = v37 + *a3 * v28;
      double v40 = v32 * v29;
      double v41 = v29 * v36;
      double v29 = v34 * v29 + v33 * v27;
      double v42 = v41 + v35 * v27;
      double v27 = v40 + *a3 * v27;
      double v46 = *(double *)(v26 + 56) + v39;
      double v31 = v42 + v31;
    }
    else
    {
      double v46 = *(double *)(v26 + 56);
    }
    double v47 = v31;
    BOOL v43 = (double *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    *(_DWORD *)BOOL v43 = 1;
    v43[1] = v28;
    v43[2] = v27;
    v43[3] = v30;
    v43[4] = v29;
    v43[5] = v46;
    v43[6] = v47;
    CFRetain(v22);
    *((void *)v43 + 7) = v22;
    v43[8] = a9;
    v43[9] = a10;
    v43[10] = a11;
    v43[11] = a12;
    char v44 = (char *)CGClipCreateWithMask((atomic_uint *)v43, HIBYTE(*(_DWORD *)(*(void *)(v26 + 120) + 4)) & 1);
    CGClipMaskRelease(v43);
    if (v44)
    {
      maybeCopyClipState(v26);
      CGClipStackAddClip(*(void *)(v26 + 112), (uint64_t)v44);
      CGClipRelease(v44);
    }
    if (mask_from_image) {
      CFRelease(mask_from_image);
    }
    goto LABEL_36;
  }
}

void CGContextClipToRects(CGContextRef c, const CGRect *rects, size_t count)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (count == 1)
      {
        CGFloat x = rects->origin.x;
        CGFloat y = rects->origin.y;
        CGFloat width = rects->size.width;
        CGFloat height = rects->size.height;
        CGContextClipToRect(c, *(CGRect *)&x);
      }
      else
      {
        uint64_t v16 = (const void *)*((void *)c + 21);
        if (v16)
        {
          CFRelease(v16);
          *((void *)c + 21) = 0;
        }
        CGContextAddRects(c, rects, count);
        clip((uint64_t)c, 0, v17, v18, v19, v20, v21, v22);
      }
      return;
    }
    CGContextRef v15 = c;
  }
  else
  {
    CGContextRef v15 = 0;
  }

  handle_invalid_context((char)"CGContextClipToRects", (uint64_t)v15, count, v3, v4, v5, v6, v7);
}

BOOL CGContextPathContainsPoint(CGContextRef c, CGPoint point, CGPathDrawingMode mode)
{
  if (!c)
  {
    CGContextRef v23 = 0;
LABEL_12:
    handle_invalid_context((char)"CGContextPathContainsPoint", (uint64_t)v23, v3, v4, v5, v6, v7, v8);
LABEL_13:
    LOBYTE(v22) = 0;
    return v22;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v23 = c;
    goto LABEL_12;
  }
  uint64_t v10 = (const CGPath *)*((void *)c + 21);
  if (!v10) {
    goto LABEL_13;
  }
  CGFloat y = point.y;
  CGFloat x = point.x;
  if (CGPathIsEmpty(v10)) {
    goto LABEL_13;
  }
  uint64_t v19 = *((void *)c + 12);
  double v20 = *(double *)(*(void *)(v19 + 128) + 8);
  if (v20 > 0.0 || v20 == -1.0905473e16)
  {
    LOBYTE(v22) = 0;
    int v21 = 0;
    switch(mode)
    {
      case kCGPathFill:
        goto LABEL_21;
      case kCGPathEOFill:
        int v21 = 0;
        LOBYTE(v22) = 1;
        goto LABEL_21;
      case kCGPathStroke:
        uint64_t v25 = (const CGAffineTransform *)(v19 + 24);
        int v21 = 1;
        goto LABEL_23;
      case kCGPathFillStroke:
        LOBYTE(v22) = 0;
        goto LABEL_20;
      case kCGPathEOFillStroke:
        LOBYTE(v22) = 1;
LABEL_20:
        int v21 = 1;
        goto LABEL_21;
      default:
        return v22;
    }
  }
  if (mode >= (kCGPathEOFillStroke|kCGPathEOFill) || ((0x1Bu >> mode) & 1) == 0) {
    goto LABEL_13;
  }
  int v21 = 0;
  unsigned int v22 = (0x16u >> mode) & 1;
LABEL_21:
  uint64_t v25 = (const CGAffineTransform *)(v19 + 24);
  v28.CGFloat x = x;
  v28.CGFloat y = y;
  if (CGPathContainsPoint(*((CGPathRef *)c + 21), (const CGAffineTransform *)(v19 + 24), v28, v22))
  {
    LOBYTE(v22) = 1;
    return v22;
  }
LABEL_23:
  if (v20 == -1.0905473e16 || v21 == 0) {
    goto LABEL_13;
  }
  stroked_path = (const CGPath *)create_stroked_path(*((char **)c + 21), *((void **)c + 12), 1, v14, v15, v16, v17, v18);
  v29.CGFloat x = x;
  v29.CGFloat y = y;
  LOBYTE(v22) = CGPathContainsPoint(stroked_path, v25, v29, 0);
  if (stroked_path) {
    CFRelease(stroked_path);
  }
  return v22;
}

uint64_t create_stroked_path(char *DashedPath, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (_anonymous_namespace_ *)(a2 + 3);
  uint64_t v10 = a2[16];
  uint64_t v11 = *(void *)(v10 + 32);
  if (v11)
  {
    uint64_t v13 = *(void *)(v11 + 16);
    uint64_t v14 = (const double *)(v11 + 24);
    if (!a3 || v13 != 2) {
      goto LABEL_6;
    }
    if (*v14 == 0.0)
    {
      DashedPath = 0;
    }
    else if (*(double *)(v11 + 32) != 0.0)
    {
LABEL_6:
      DashedPath = (char *)CGPathCreateDashedPath(DashedPath, (_anonymous_namespace_ *)(a2 + 3), v14, v13, a5, a6, a7, a8, *(double *)(v11 + 8));
      uint64_t v10 = a2[16];
      uint64_t v15 = DashedPath;
      goto LABEL_9;
    }
  }
  uint64_t v15 = 0;
LABEL_9:
  uint64_t StrokedPath = CGPathCreateStrokedPath(DashedPath, v9, (char)*(_WORD *)(v10 + 2), (*(__int16 *)(v10 + 2) >> 8), a5, a6, a7, a8, *(double *)(v10 + 8), *(double *)(v10 + 16), *(double *)(a2[18] + 8));
  if (v15) {
    CFRelease(v15);
  }
  return StrokedPath;
}

void CGContextReplacePathWithStrokedPath(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v8 = (const CGPath *)*((void *)c + 21);
      if (v8 && !CGPathIsEmpty(v8))
      {
        uint64_t stroked_path = create_stroked_path(*((char **)c + 21), *((void **)c + 12), 0, v9, v10, v11, v12, v13);
        uint64_t v15 = (const void *)*((void *)c + 21);
        if (v15) {
          CFRelease(v15);
        }
        *((void *)c + 21) = stroked_path;
      }
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextReplacePathWithStrokedPath", (uint64_t)v16, v1, v2, v3, v4, v5, v6);
}

void CGContextReplacePathWithClipPath(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v9 = (const void *)*((void *)c + 21);
      if (v9)
      {
        CFRelease(v9);
        *((void *)c + 21) = 0;
      }
      ClipBoundingBoCGFloat x = CGContextGetClipBoundingBox(c);
      CGContextAddRect(c, ClipBoundingBox);
      return;
    }
    CGContextRef v10 = c;
  }
  else
  {
    CGContextRef v10 = 0;
  }

  handle_invalid_context((char)"CGContextReplacePathWithClipPath", (uint64_t)v10, a3, a4, a5, a6, a7, a8);
}

void CGContextReplacePathWithShapePath(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGContextRef v10 = *(const void **)(a1 + 168);
      if (v10)
      {
        CFRelease(v10);
        *(void *)(a1 + 168) = 0;
      }
      if (a2)
      {
        uint64_t v11 = a2[2];
        if ((_UNKNOWN *)v11 != &the_empty_shape && *(_DWORD *)(v11 + 4 * *(int *)(v11 + 4)) != 0x7FFFFFFF)
        {
          CGMutablePathRef Mutable = CGPathCreateMutable();
          *(void *)(a1 + 168) = Mutable;
          uint64_t v19 = (_anonymous_namespace_ *)(*(void *)(a1 + 96) + 24);
          CGPathAddRegion((uint64_t)Mutable, v19, a2, v14, v15, v16, v17, v18);
        }
      }
      return;
    }
    uint64_t v12 = a1;
  }
  else
  {
    uint64_t v12 = 0;
  }

  handle_invalid_context((char)"CGContextReplacePathWithShapePath", v12, a3, a4, a5, a6, a7, a8);
}

int32x2_t *CPPDFContextCreate()
{
  uint64_t v0 = (int32x2_t *)malloc_type_malloc(0x930uLL, 0x10B0040402FB33CuLL);
  uint64_t v1 = v0;
  if (v0)
  {
    v0[282] = 0;
    v0[257].i32[0] = 0;
    v0[284].i32[0] = 0;
    CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    v0[280] = (int32x2_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
    v1[281] = (int32x2_t)CFDictionaryCreateMutable(v2, 0, 0, v3);
    uint64_t v4 = (char *)malloc_type_malloc(0x188uLL, 0x10A00400C8B88DDuLL);
    *(void *)uint64_t v4 = 0;
    *((_WORD *)v4 + 4) = 0;
    *((void *)v4 + 9) = 0xFFFFFFFF00000000;
    *((_DWORD *)v4 + 20) = 0;
    *((void *)v4 + 8) = CGPathCreateMutable();
    *(CGAffineTransform *)(v4 + 16) = CGAffineTransformIdentity;
    *((_OWORD *)v4 + 16) = 0u;
    *((_OWORD *)v4 + 17) = 0u;
    *((_OWORD *)v4 + 18) = xmmword_1850CDDB0;
    *((_WORD *)v4 + 152) = 0;
    *(void *)(v4 + 316) = 0;
    *(void *)(v4 + 324) = 0;
    *(void *)(v4 + 308) = 0;
    *((_DWORD *)v4 + 83) = 0;
    __asm { FMOV            V4.2D, #1.0 }
    *((_OWORD *)v4 + 21) = _Q4;
    *((void *)v4 + 44) = 0;
    *((void *)v4 + 45) = 0;
    *(CGAffineTransform *)(v4 + 88) = CGAffineTransformIdentity;
    *((void *)v4 + 23) = 0;
    *((void *)v4 + 24) = 0;
    *((void *)v4 + 25) = 0x4059000000000000;
    *((void *)v4 + 31) = 0;
    *((_OWORD *)v4 + 13) = 0u;
    *((_OWORD *)v4 + 14) = 0u;
    v4[240] = 0;
    *((void *)v4 + 47) = 0;
    *((void *)v4 + 48) = 0;
    *((void *)v4 + 46) = 0;
    v1[5] = (int32x2_t)v4;
    v1[6] = 0;
    v1[268] = (int32x2_t)0xC8000000C8;
    v1[267].i32[0] = 43200;
    CGContextRef v10 = (char *)malloc_type_malloc(0xA8C0uLL, 0x480F97FFuLL);
    v1[264] = (int32x2_t)v10;
    uint64_t v11 = v1[267].u32[0];
    v1[267].i32[1] = v11;
    v1[265] = (int32x2_t)v10;
    v1[266] = (int32x2_t)&v10[v11];
    v1[269].i32[0] = 0;
    v1[276] = 0;
    v1[262] = vdup_n_s32(0x7D0u);
    v1[261].i32[0] = 384000;
    uint64_t v12 = (char *)malloc_type_malloc(0x5DC00uLL, 0x480F97FFuLL);
    v1[258] = (int32x2_t)v12;
    uint64_t v13 = v1[261].u32[0];
    v1[261].i32[1] = v13;
    v1[259] = (int32x2_t)v12;
    v1[260] = (int32x2_t)&v12[v13];
    v1[263].i32[0] = 0;
    v1[274] = (int32x2_t)0xC8000000C8;
    v1[273].i32[0] = 36800;
    uint64_t v14 = (char *)malloc_type_malloc(0x8FC0uLL, 0x480F97FFuLL);
    v1[270] = (int32x2_t)v14;
    uint64_t v15 = v1[273].u32[0];
    v1[273].i32[1] = v15;
    v1[271] = (int32x2_t)v14;
    v1[272] = (int32x2_t)&v14[v15];
    v1[275].i32[0] = 0;
    v1[279] = (int32x2_t)CFDictionaryCreateMutable(v2, 0, 0, v3);
    uint64_t v16 = malloc_type_calloc(0x3E9uLL, 0x34uLL, 0x10000403884A0CCuLL);
    v1[278] = (int32x2_t)v16;
    v1[277].i32[0] = 1001;
    v1[276] = (int32x2_t)0x100000004;
    if (v16)
    {
      v1[4].i32[0] = 2400;
      uint64_t v17 = malloc_type_malloc(0x2580uLL, 0x100004052888210uLL);
      v1[283] = (int32x2_t)v17;
      if (v17)
      {
        v1[284] = 0;
        v1[285] = 0;
        v1[287] = (int32x2_t)CPMultiUnicodesCreate();
        v1[293] = 0;
        return v1;
      }
      free(*(void **)&v1[264]);
      free(*(void **)&v1[258]);
      free(*(void **)&v1[270]);
      uint64_t v18 = (void *)v1[278];
      if (!v18) {
        return 0;
      }
    }
    else
    {
      free(*(void **)&v1[264]);
      free(*(void **)&v1[258]);
      uint64_t v18 = (void *)v1[270];
    }
    free(v18);
    return 0;
  }
  return v1;
}

void CPPDFContextRelease(uint64_t a1)
{
  free(*(void **)(a1 + 2264));
  uint64_t v2 = *(void *)(a1 + 2256);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 104);
      if (*(void *)v2) {
        CFRelease(*(CFTypeRef *)v2);
      }
      CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 8));
      uint64_t v4 = *(const void **)(v2 + 16);
      if (v4) {
        CFRelease(v4);
      }
      CGColorSpaceRelease(*(CGColorSpaceRef *)(v2 + 24));
      uint64_t v5 = *(const void **)(v2 + 96);
      if (v5) {
        CFRelease(v5);
      }

      free((void *)v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v6 = *(void **)(a1 + 2224);
  if (v6) {
    free(v6);
  }
  CFRelease(*(CFTypeRef *)(a1 + 2232));
  CFRelease(*(CFTypeRef *)(a1 + 2248));
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 2240), (CFDictionaryApplierFunction)freeFont, 0);
  CFRelease(*(CFTypeRef *)(a1 + 2240));
  uint64_t v7 = *(void **)(a1 + 40);
  if (v7)
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      CPPDFGraphicStateReleaseElements((uint64_t)v7);
      free(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = *(void **)(a1 + 48);
  if (v9)
  {
    do
    {
      CGContextRef v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  unint64_t v11 = *(void *)(a1 + 2112);
  unint64_t v12 = *(void *)(a1 + 2120);
  while (v11 < v12)
  {
    uint64_t v13 = *(const void **)(v11 + 96);
    if (v13)
    {
      CFRelease(v13);
      unint64_t v12 = *(void *)(a1 + 2120);
    }
    v11 += 216;
  }
  for (unint64_t i = *(void *)(a1 + 2160); i < *(void *)(a1 + 2168); i += 184)
  {
    uint64_t v15 = *(const void **)(i + 96);
    if (v15) {
      CFRelease(v15);
    }
    uint64_t v16 = *(const void **)(i + 168);
    if (v16) {
      CFRelease(v16);
    }
  }
  free(*(void **)(a1 + 2064));
  free(*(void **)(a1 + 2112));
  free(*(void **)(a1 + 2160));
  CPMultiUnicodesRelease(*(void **)(a1 + 2296));
  uint64_t v17 = *(const void **)(a1 + 2344);
  if (v17) {
    CFRelease(v17);
  }

  free((void *)a1);
}

void freeFont(uint64_t a1, void *a2)
{
  [a2 dispose];
}

void CPPDFContextSaveGState(uint64_t a1)
{
  uint64_t v3 = *(CGPathRef **)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2) {
    *(void *)(a1 + 48) = *v2;
  }
  else {
    uint64_t v2 = malloc_type_malloc(0x188uLL, 0x10A00400C8B88DDuLL);
  }
  memcpy(v2, v3, 0x188uLL);
  MutableCopCGFloat y = CGPathCreateMutableCopy(v3[8]);
  v2[8] = MutableCopy;
  if (MutableCopy) {
    CFRetain(MutableCopy);
  }
  uint64_t v5 = (const void *)v2[32];
  if (v5) {
    CFRetain(v5);
  }
  uint64_t v6 = (const void *)v2[33];
  if (v6) {
    CFRetain(v6);
  }
  uint64_t v7 = (const void *)v2[34];
  if (v7) {
    CFRetain(v7);
  }
  uint64_t v8 = (const void *)v2[35];
  if (v8) {
    CFRetain(v8);
  }
  id v9 = (id)v2[31];
  CGContextRef v10 = (const void *)v2[8];
  if (v10) {
    CFRelease(v10);
  }
  *((_DWORD *)v2 + 18) = 0;
  *uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v2;
}

void CPPDFContextRestoreGState(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)v2;
    if (*(void *)v2)
    {
      if (*(_DWORD *)(v2 + 72))
      {
        unsigned int v4 = *(_DWORD *)(a1 + 2212);
        unsigned int v5 = *(_DWORD *)(a1 + 2216);
        if (v5 > v4)
        {
          uint64_t v6 = *(void *)(a1 + 2224);
          if (v6)
          {
            uint64_t v7 = (unsigned int *)(v6 + 52 * v4);
            unsigned int v8 = *v7;
            if (!v7[2])
            {
LABEL_11:
              if (v8)
              {
                while (v5 > v8)
                {
                  uint64_t v9 = v6 + 52 * v8;
                  int v11 = *(_DWORD *)(v9 + 4);
                  CGContextRef v10 = (unsigned int *)(v9 + 4);
                  if (v11)
                  {
                    unsigned int v8 = *(_DWORD *)(v6 + 52 * v8);
                    if (v8) {
                      continue;
                    }
                  }
                  *CGContextRef v10 = v4;
                  break;
                }
              }
              if (v7)
              {
                v7[1] = 0;
                v7[2] = 0;
                *uint64_t v7 = v8;
              }
              goto LABEL_18;
            }
            unsigned int v4 = *(_DWORD *)(a1 + 2208);
            if (v4 + 3 < v5)
            {
              *(_DWORD *)(a1 + 2212) = v4;
              uint64_t v7 = (unsigned int *)(v6 + 52 * v4);
              if (v5 <= v4) {
                uint64_t v7 = 0;
              }
              *(_DWORD *)(a1 + 2208) = v4 + 3;
              goto LABEL_11;
            }
          }
        }
      }
LABEL_18:
      *(void *)uint64_t v2 = *(void *)(a1 + 48);
      *(void *)(a1 + 40) = v3;
      *(void *)(a1 + 48) = v2;
      CPPDFGraphicStateReleaseElements(v2);
    }
  }
}

double CPPDFContextConcatCTM(double *a1, double *a2)
{
  double v2 = a2[1];
  double v3 = a2[2];
  double v4 = a2[3];
  double v5 = a2[4];
  double v6 = a2[5];
  double v7 = a1[2];
  double v8 = a1[3];
  double v9 = a1[4];
  double v10 = a1[5];
  double v11 = v2 * v9 + *a2 * v7;
  double result = v2 * v10 + *a2 * v8;
  double v13 = v4 * v9 + v3 * v7;
  double v14 = v4 * v10 + v3 * v8;
  double v15 = a1[6] + v9 * v6 + v5 * v7;
  double v16 = v10 * v6 + v5 * v8 + a1[7];
  a1[2] = v11;
  a1[3] = result;
  a1[4] = v13;
  a1[5] = v14;
  a1[6] = v15;
  a1[7] = v16;
  return result;
}

uint64_t CPPDFContextAddPathToClip(uint64_t result, int a2)
{
  double v2 = *(_DWORD **)(result + 40);
  if ((v2[19] & 0x80000000) == 0)
  {
    uint64_t v3 = result;
    int v4 = v2[18];
    v2[18] = v4 + 1;
    if (v4)
    {
      if (a2)
      {
        double result = CPPDFClipBufferPush(v2[20], result + 2208);
        if (result)
        {
          unsigned int v5 = *(_DWORD *)(v3 + 2212);
          unsigned int v6 = *(_DWORD *)(v3 + 2216);
          if (v6 > v5)
          {
            uint64_t v7 = *(void *)(v3 + 2224);
            if (v7)
            {
              unsigned int v8 = *(_DWORD *)(v7 + 52 * v5);
              if (v8 && v6 > v8) {
                *(_DWORD *)(v7 + 52 * v8 + 4) = v5;
              }
            }
          }
        }
      }
    }
    else
    {
      double result = CPPDFClipBufferPush(v2[20], result + 2208);
    }
    unsigned int v10 = *(_DWORD *)(v3 + 2216);
    if (*(_DWORD *)(v3 + 2208) < v10)
    {
      unsigned int v11 = *(_DWORD *)(v3 + 2212);
      if (v10 > v11)
      {
        uint64_t v12 = *(void *)(v3 + 2224);
        if (v12)
        {
          uint64_t v13 = v12 + 52 * v11;
          uint64_t v14 = *(unsigned int *)(v13 + 8);
          *(_DWORD *)(v13 + 4 * v14 + 12) = v2[19];
          *(_DWORD *)(v13 + 8) = v14 + 1;
          ++*(_DWORD *)(v3 + 2208);
        }
      }
    }
    int v15 = *(_DWORD *)(v3 + 2212);
    v2[19] = -1;
    v2[20] = v15;
  }
  return result;
}

uint64_t CPPDFContextAddStroke(uint64_t a1)
{
  uint64_t result = CPPDFContextAddShape(a1, 1, 2);
  if (result)
  {
    return CPPDFContextAddPathToClip(a1, 1);
  }
  return result;
}

uint64_t CPPDFContextAddShape(uint64_t a1, char a2, int a3)
{
  if (!*(void *)(a1 + 2264)) {
    return 0;
  }
  uint64_t v6 = a1 + 40;
  PathBoundingBodouble x = CGPathGetPathBoundingBox((CGPathRef)*(void *)(*(void *)(a1 + 40) + 64));
  double x = PathBoundingBox.origin.x;
  double y = PathBoundingBox.origin.y;
  double width = PathBoundingBox.size.width;
  double height = PathBoundingBox.size.height;
  if (a3 == 2
    && CGPathGetNumberOfPoints(*(char **)(*(void *)v6 + 64), *(int32x2_t *)&PathBoundingBox.origin.x) == 2
    && (width == 0.0 || height == 0.0))
  {
    double v11 = *(double *)(a1 + 16);
    double v12 = 0.03;
  }
  else
  {
    double v11 = *(double *)(a1 + 16);
    double v12 = 0.05;
  }
  BOOL v13 = width <= v11 * v12 && height <= *(double *)(a1 + 24) * v12;
  if (fabs(x) == INFINITY
    || fabs(y) == INFINITY
    || fabs(width) == INFINITY
    || fabs(height) == INFINITY
    || (uint64_t v15 = *(void *)a1,
        uint64_t v16 = *(void *)(a1 + 8),
        uint64_t v17 = *(void *)(a1 + 24),
        v31.origin.double x = x,
        v31.origin.double y = y,
        v31.size.double width = width,
        v31.size.double height = height,
        !CGRectIntersectsRect(*(CGRect *)(&v11 - 2), v31) || v13))
  {
    uint64_t v18 = *(const void **)(*(void *)v6 + 64);
    if (v18) {
      CFRelease(v18);
    }
    CGMutablePathRef Mutable = CGPathCreateMutable();
    uint64_t result = 0;
    *(void *)(*(void *)v6 + 64) = Mutable;
  }
  else
  {
    uint64_t result = primitiveBufferMemoryCheck(a1, a1 + 2112);
    if (result)
    {
      ++*(_DWORD *)(a1 + 2152);
      uint64_t v20 = *(void *)(a1 + 2120);
      *(double *)uint64_t v20 = x;
      *(double *)(v20 + 8) = y;
      *(double *)(v20 + 16) = width;
      *(double *)(v20 + 24) = height;
      *(void *)(v20 + 68) = *(void *)(a1 + 2272);
      uint64_t v21 = *(void *)(a1 + 40);
      *(_DWORD *)(v20 + 64) = *(_DWORD *)(v21 + 80);
      *(void *)(v20 + 96) = *(void *)(v21 + 64);
      if (a3 == 4) {
        Style = 0;
      }
      else {
        Style = CPPDFStyleListGetStyle(a1);
      }
      *(void *)(v20 + 80) = Style;
      *(unsigned char *)(v20 + 104) = a2;
      long long v23 = *(_OWORD *)(*(void *)v6 + 16);
      long long v24 = *(_OWORD *)(*(void *)v6 + 48);
      *(_OWORD *)(v20 + 128) = *(_OWORD *)(*(void *)v6 + 32);
      *(_OWORD *)(v20 + 144) = v24;
      *(_OWORD *)(v20 + 112) = v23;
      while (1)
      {
        uint64_t v6 = *(void *)v6;
        if (!v6) {
          break;
        }
        if (*(unsigned char *)(v6 + 8))
        {
          long long v25 = *(_OWORD *)(v6 + 16);
          long long v26 = *(_OWORD *)(v6 + 48);
          *(_OWORD *)(v20 + 176) = *(_OWORD *)(v6 + 32);
          *(_OWORD *)(v20 + 192) = v26;
          *(_OWORD *)(v20 + 160) = v25;
          goto LABEL_30;
        }
      }
      *(CGAffineTransform *)(v20 + 160) = CGAffineTransformIdentity;
LABEL_30:
      *(_DWORD *)(v20 + 88) = a3;
      uint64_t v27 = *(void *)(a1 + 2344);
      if (v27 && (uint64_t v28 = *(void *)(v27 + 16)) != 0) {
        uint64_t CurrentMCID = TaggedParser::GetCurrentMCID(v28, *(CGPDFPage **)(a1 + 2288));
      }
      else {
        uint64_t CurrentMCID = -1;
      }
      *(void *)(v20 + 208) = CurrentMCID;
      *(void *)(a1 + 2120) = v20 + 216;
      *(void *)(*(void *)(a1 + 40) + 64) = CGPathCreateMutable();
      *(_DWORD *)(*(void *)(a1 + 2264) + 4 * *(unsigned int *)(a1 + 2272)) = 0;
      *(int32x2_t *)(a1 + 2272) = vadd_s32(*(int32x2_t *)(a1 + 2272), (int32x2_t)0x100000001);
      return 1;
    }
  }
  return result;
}

uint64_t primitiveBufferMemoryCheck(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 8) < *(void *)(a2 + 16)) {
    return 1;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 32) = v4;
  uint64_t result = (uint64_t)malloc_type_realloc(*(void **)(a1 + 2264), 4 * v4, 0x100004052888210uLL);
  *(void *)(a1 + 2264) = result;
  if (result)
  {
    int v6 = *(_DWORD *)(a2 + 32);
    int v7 = v6 + *(_DWORD *)(a2 + 36);
    int v8 = *(_DWORD *)(a2 + 24);
    size_t v9 = (v8 + *(_DWORD *)(a2 + 28));
    *(_DWORD *)(a2 + 24) = v9;
    *(_DWORD *)(a2 + 28) = v8;
    *(_DWORD *)(a2 + 32) = v7;
    *(_DWORD *)(a2 + 36) = v6;
    uint64_t v10 = *(void *)(a2 + 16);
    double v11 = *(void **)a2;
    uint64_t result = (uint64_t)malloc_type_realloc(*(void **)a2, v9, 0xFF261EC3uLL);
    *(void *)a2 = result;
    if (result)
    {
      *(void *)(a2 + 8) = result + (v10 - v11);
      *(void *)(a2 + 16) = result + v9;
      return 1;
    }
  }
  return result;
}

uint64_t CPPDFContextAddFill(uint64_t a1, char a2)
{
  uint64_t result = CPPDFContextAddShape(a1, a2, 1);
  if (result)
  {
    return CPPDFContextAddPathToClip(a1, 1);
  }
  return result;
}

uint64_t CPPDFContextAddStrokeAndFill(uint64_t a1, char a2)
{
  uint64_t result = CPPDFContextAddShape(a1, a2, 3);
  if (result)
  {
    return CPPDFContextAddPathToClip(a1, 1);
  }
  return result;
}

uint64_t CPPDFContextAddClip(uint64_t a1, char a2)
{
  int v3 = *(_DWORD *)(a1 + 2152);
  uint64_t result = CPPDFContextAddShape(a1, a2, 4);
  if (result)
  {
    uint64_t result = CPPDFContextAddPathToClip(a1, 1);
    *(_DWORD *)(*(void *)(a1 + 40) + 76) = v3;
  }
  return result;
}

void CPPDFContextAddImage(uint64_t a1, long long *a2)
{
  unsigned int v4 = *(_OWORD **)(a1 + 40);
  long long v5 = v4[2];
  *(_OWORD *)&v36.double a = v4[1];
  *(_OWORD *)&v36.double c = v5;
  *(_OWORD *)&v36.tCGFloat x = v4[3];
  uint64_t v6 = 0;
  *(void *)&long long v5 = 0;
  double v7 = 1.0;
  double v8 = 1.0;
  CGRect v37 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v5 - 8), &v36);
  CGFloat x = v37.origin.x;
  CGFloat y = v37.origin.y;
  CGFloat width = v37.size.width;
  if (fabs(*(double *)a1) != INFINITY)
  {
    CGFloat height = v37.size.height;
    double v14 = *(double *)(a1 + 8);
    if (fabs(v14) != INFINITY)
    {
      double v15 = *(double *)(a1 + 16);
      if (fabs(v15) != INFINITY)
      {
        double v16 = *(double *)(a1 + 24);
        if (fabs(v16) != INFINITY)
        {
          v38.origin.CGFloat x = v37.origin.x;
          v38.origin.CGFloat y = y;
          v38.size.CGFloat width = width;
          v38.size.CGFloat height = height;
          double v12 = *(double *)a1;
          if (CGRectIntersectsRect(*(CGRect *)(&v14 - 1), v38))
          {
            if (primitiveBufferMemoryCheck(a1, a1 + 2160))
            {
              ++*(_DWORD *)(a1 + 2200);
              uint64_t v17 = *(void *)(a1 + 2168);
              long long v18 = *a2;
              long long v19 = a2[1];
              long long v20 = a2[3];
              *(_OWORD *)(v17 + 32) = a2[2];
              *(_OWORD *)(v17 + 48) = v20;
              *(_OWORD *)(v17 + 16) = v19;
              long long v21 = a2[4];
              long long v22 = a2[5];
              long long v23 = a2[7];
              *(_OWORD *)(v17 + 96) = a2[6];
              *(_OWORD *)(v17 + 112) = v23;
              *(_OWORD *)(v17 + 64) = v21;
              *(_OWORD *)(v17 + 80) = v22;
              long long v24 = a2[8];
              long long v25 = a2[9];
              long long v26 = a2[10];
              *(void *)(v17 + 176) = *((void *)a2 + 22);
              *(_OWORD *)(v17 + 144) = v25;
              *(_OWORD *)(v17 + 160) = v26;
              *(_OWORD *)(v17 + 128) = v24;
              *(_OWORD *)uint64_t v17 = v18;
              uint64_t v27 = *(const void **)(v17 + 96);
              if (v27) {
                CFRetain(v27);
              }
              uint64_t v28 = *(const void **)(v17 + 168);
              if (v28) {
                CFRetain(v28);
              }
              CGPoint v29 = *(_OWORD **)(a1 + 40);
              long long v30 = v29[1];
              long long v31 = v29[2];
              *(_OWORD *)(v17 + 136) = v29[3];
              *(_OWORD *)(v17 + 120) = v31;
              *(_OWORD *)(v17 + 104) = v30;
              uint64_t v32 = *(void *)(a1 + 40);
              *(void *)(v17 + 160) = *(void *)(v32 + 336);
              *(void *)(v17 + 68) = *(void *)(a1 + 2272);
              *(_DWORD *)(v17 + 64) = *(_DWORD *)(v32 + 80);
              *(CGFloat *)uint64_t v17 = x;
              *(CGFloat *)(v17 + 8) = y;
              *(CGFloat *)(v17 + 16) = width;
              *(CGFloat *)(v17 + 24) = height;
              uint64_t v33 = *(void *)(a1 + 2344);
              if (v33 && (uint64_t v34 = *(void *)(v33 + 16)) != 0) {
                uint64_t CurrentMCID = TaggedParser::GetCurrentMCID(v34, *(CGPDFPage **)(a1 + 2288));
              }
              else {
                uint64_t CurrentMCID = -1;
              }
              *(void *)(v17 + 176) = CurrentMCID;
              *(void *)(a1 + 2168) = v17 + 184;
            }
            *(_DWORD *)(*(void *)(a1 + 2264) + 4 * (*(_DWORD *)(a1 + 2272))++) = 1;
          }
        }
      }
    }
  }
}

CGPath *CPPDFGetClipPathIntersection(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 1;
  unint64_t v6 = a2;
  CFNumberRef Value = (CGPath *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2232), (const void *)a2);
  CGMutablePathRef Mutable = Value;
  if (!a2 || Value) {
    return Mutable;
  }
  uint64_t v9 = *(void *)(a1 + 2224);
  uint64_t v10 = v9 + 52 * v6;
  unsigned int v13 = *(_DWORD *)(v10 + 8);
  double v12 = (unsigned int *)(v10 + 8);
  unsigned int v11 = v13;
  uint64_t v14 = *(unsigned int *)(v9 + 52 * v6);
  if (v14) {
    BOOL v15 = v14 == a2;
  }
  else {
    BOOL v15 = 1;
  }
  int v16 = !v15;
  if (v15) {
    size_t v17 = v11;
  }
  else {
    size_t v17 = v11 + 1;
  }
  if (!v17) {
    return 0;
  }
  long long v18 = (CFTypeRef *)malloc_type_calloc(v17, 8uLL, 0x6004044C4A2DFuLL);
  long long v19 = v18;
  uint64_t v20 = *v12;
  if (v20)
  {
    uint64_t v21 = 0;
    uint64_t v22 = *(void *)(a1 + 2112);
    unsigned int v23 = *(_DWORD *)(a1 + 2152);
    do
    {
      unsigned int v24 = *(_DWORD *)(v9 + 52 * v6 + 12 + 4 * v21);
      if (v24 >= v23)
      {
        free(v18);
        return 0;
      }
      v18[v21++] = *(CFTypeRef *)(v22 + 216 * v24 + 96);
    }
    while (v20 != v21);
    if (!v16) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v20 = 0;
    if (!v16) {
      goto LABEL_19;
    }
  }
  v18[v20] = (CFTypeRef)CPPDFGetClipPathIntersection(a1, v14, a3);
LABEL_19:
  if (v17 == 1)
  {
    CGMutablePathRef Mutable = (CGPath *)*v19;
    if (*v19) {
      CFRetain(*v19);
    }
  }
  else
  {
    CGMutablePathRef Mutable = CGPathCreateMutable();
    CGPathAddIntersection(Mutable, (const CGPath **)v19, v17);
  }
  free(v19);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 2232), (const void *)v6, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return Mutable;
}

CGMutablePathRef CPPDFLazyContextAddShape(CGMutablePathRef result)
{
  CGMutablePathRef v1 = result;
  if (*((void *)result + 289) >= *((void *)result + 288))
  {
LABEL_15:
    *((unsigned char *)v1 + 2336) = 1;
    return result;
  }
  PathBoundingBoCGFloat x = CGPathGetPathBoundingBox((CGPathRef)*(void *)(*((void *)result + 5) + 64));
  CGFloat x = PathBoundingBox.origin.x;
  CGFloat y = PathBoundingBox.origin.y;
  if (fabs(PathBoundingBox.origin.x) == INFINITY
    || fabs(PathBoundingBox.origin.y) == INFINITY
    || (CGFloat width = PathBoundingBox.size.width, fabs(PathBoundingBox.size.width) == INFINITY)
    || (CGFloat height = PathBoundingBox.size.height, fabs(PathBoundingBox.size.height) == INFINITY)
    || !CGRectIntersectsRect(*(CGRect *)v1, *(CGRect *)&x))
  {
    uint64_t v9 = *(const void **)(*((void *)v1 + 5) + 64);
    if (v9) {
      CFRelease(v9);
    }
    uint64_t result = CGPathCreateMutable();
    *(void *)(*((void *)v1 + 5) + 64) = result;
  }
  else
  {
    uint64_t v6 = *((void *)v1 + 289);
    double v7 = *(const void **)(*((void *)v1 + 5) + 64);
    if (*((_DWORD *)v1 + 569) == *(_DWORD *)(*((void *)v1 + 290) + 4 * v6))
    {
      uint64_t v8 = *((void *)v1 + 291);
      *((void *)v1 + 289) = v6 + 1;
      *(void *)(v8 + 8 * v6) = v7;
    }
    else if (v7)
    {
      CFRelease(v7);
    }
    uint64_t result = CGPathCreateMutable();
    *(void *)(*((void *)v1 + 5) + 64) = result;
    ++*((_DWORD *)v1 + 569);
    if (*((void *)v1 + 289) == *((void *)v1 + 288)) {
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t __CGImageEPSRepGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  kCGImageEPSRepRuntimeID = result;
  return result;
}

CFStringRef cg_image_eps_rep_copy_debug_description(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CGImageEPSRep %p>", a1);
}

CFStringRef cg_image_eps_rep_copy_format_description(const void *a1, const __CFDictionary *a2)
{
  CFAllocatorRef v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, @"<CGImageEPSRep %p>", a1);
}

uint64_t cg_image_eps_rep_equal(CFTypeRef *cf, CFTypeRef *a2)
{
  if (cf == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (cf && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (CGImageEPSRepGetTypeID_predicate != -1)
    {
      CFTypeID v7 = v5;
      dispatch_once(&CGImageEPSRepGetTypeID_predicate, &__block_literal_global_14457);
      CFTypeID v5 = v7;
    }
    if (v5 != kCGImageEPSRepRuntimeID) {
      return 0;
    }
    CFTypeID v6 = CFGetTypeID(a2);
    if (CGImageEPSRepGetTypeID_predicate != -1)
    {
      CFTypeID v8 = v6;
      dispatch_once(&CGImageEPSRepGetTypeID_predicate, &__block_literal_global_14457);
      CFTypeID v6 = v8;
    }
    if (v6 == kCGImageEPSRepRuntimeID)
    {
      uint64_t result = CFEqual(cf[3], a2[3]);
      if (result) {
        return CFEqual(cf[2], a2[2]) != 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void cg_image_eps_rep_finalize(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
    if (CGImageEPSRepGetTypeID_predicate != -1) {
      dispatch_once(&CGImageEPSRepGetTypeID_predicate, &__block_literal_global_14457);
    }
    if (v2 == kCGImageEPSRepRuntimeID)
    {
      CGDataProviderRelease(*(CGDataProviderRef *)(a1 + 16));
      int v3 = *(const void **)(a1 + 24);
      if (v3)
      {
        CFRelease(v3);
      }
    }
  }
}

_OWORD *CGImageEPSRepCreate(CGDataProvider *a1, const void *a2)
{
  unsigned int v11 = CGAccessSessionCreate(a1);
  uint64_t v12 = 0;
  *(void *)&long long v89 = 0xFFFFFFFFLL;
  *((void *)&v89 + 1) = v11;
  while (v12 != 4)
  {
    int v13 = byte_185212C30[v12];
    int byte = read_byte((int *)&v89, v4, v5, v6, v7, v8, v9, v10);
    if (byte != -1)
    {
      ++v12;
      if (byte == v13) {
        continue;
      }
    }
    CGAccessSessionRewind((uint64_t)v11);
    goto LABEL_13;
  }
  int v22 = read_byte((int *)&v89, v4, v5, v6, v7, v8, v9, v10);
  unsigned int v30 = v22 | (read_byte((int *)&v89, v23, v24, v25, v26, v27, v28, v29) << 8);
  unsigned int v38 = v30 | (read_byte((int *)&v89, v31, v32, v33, v34, v35, v36, v37) << 16);
  unsigned int v46 = v38 | (read_byte((int *)&v89, v39, v40, v41, v42, v43, v44, v45) << 24);
  if (v46 >= 9)
  {
    uint64_t v47 = (int)v46 - 9;
    while (read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21) != -1 && v47-- != 0)
      ;
  }
LABEL_13:
  uint64_t v49 = 0;
  while (v49 != 2)
  {
    int v50 = asc_1852C483C[v49];
    int v51 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    if (v51 != -1)
    {
      ++v49;
      if (v51 == v50) {
        continue;
      }
    }
    goto LABEL_61;
  }
  do
  {
    do
      int v52 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    while (v52 == 9);
  }
  while (v52 == 32);
  if (v52 != -1) {
    LODWORD(v89) = v52;
  }
  uint64_t v53 = 0;
  while (v53 != 9)
  {
    int v54 = aPsAdobe_0[v53];
    int v55 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    if (v55 != -1)
    {
      ++v53;
      if (v55 == v54) {
        continue;
      }
    }
    goto LABEL_61;
  }
  if (read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21) - 52 < 0xFFFFFFFD) {
    goto LABEL_61;
  }
  uint64_t v56 = 0;
  while (v56 != 1)
  {
    int v57 = asc_1852C4849[v56];
    int v58 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    if (v58 != -1)
    {
      ++v56;
      if (v58 == v57) {
        continue;
      }
    }
    goto LABEL_61;
  }
  if (read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21) - 50 < 0xFFFFFFFE) {
    goto LABEL_61;
  }
  do
  {
    do
      int v59 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    while (v59 == 9);
  }
  while (v59 == 32);
  if (v59 != -1) {
    LODWORD(v89) = v59;
  }
  uint64_t v60 = 0;
  while (v60 != 5)
  {
    int v61 = aEpsf[v60];
    int v62 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    if (v62 != -1)
    {
      ++v60;
      if (v62 == v61) {
        continue;
      }
    }
    goto LABEL_61;
  }
  if (read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21) - 52 < 0xFFFFFFFD) {
    goto LABEL_61;
  }
  uint64_t v63 = 0;
  while (v63 != 1)
  {
    int v64 = asc_1852C4849[v63];
    int v65 = read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21);
    if (v65 != -1)
    {
      ++v63;
      if (v65 == v64) {
        continue;
      }
    }
    goto LABEL_61;
  }
  if (read_byte((int *)&v89, v15, v16, v17, v18, v19, v20, v21) - 48 >= 3)
  {
LABEL_61:
    long long v83 = "Failed to read EPSF header.";
    goto LABEL_62;
  }
  long long v89 = 0u;
  long long v90 = 0u;
  v91[0] = 0xFFFFFFFFLL;
  v91[1] = v11;
  if (!match_anchored_string((int *)v91, v15, v16, v17, v18, v19, v20, v21))
  {
LABEL_60:
    long long v83 = "Failed to read EPS bounding box.";
LABEL_62:
    CGPostError((uint64_t)v83, v15, v16, v17, v18, v19, v20, v21, v89);
    CGAccessSessionRelease(v11);
    return 0;
  }
  do
  {
    do
      int v66 = read_byte((int *)v91, v15, v16, v17, v18, v19, v20, v21);
    while (v66 == 9);
  }
  while (v66 == 32);
  if (v66 != -1) {
    LODWORD(v91[0]) = v66;
  }
  uint64_t v67 = 0;
  while (v67 != 7)
  {
    int v68 = aAtend[v67];
    int v69 = read_byte((int *)v91, v15, v16, v17, v18, v19, v20, v21);
    if (v69 != -1)
    {
      ++v67;
      if (v69 == v68) {
        continue;
      }
    }
    CGAccessSessionRewind((uint64_t)v11);
    match_anchored_string((int *)v91, v70, v71, v72, v73, v74, v75, v76);
    if (!get_bbox((int *)v91, (double *)&v89, v77, v78, v79, v80, v81, v82)) {
      goto LABEL_60;
    }
    goto LABEL_68;
  }
  int v86 = 0;
  while (match_anchored_string((int *)v91, v15, v16, v17, v18, v19, v20, v21))
    v86 |= get_bbox((int *)v91, (double *)&v89, v16, v17, v18, v19, v20, v21);
  if ((v86 & 1) == 0) {
    goto LABEL_60;
  }
LABEL_68:
  CGAccessSessionRelease(v11);
  if (CGImageEPSRepGetTypeID_predicate != -1) {
    dispatch_once(&CGImageEPSRepGetTypeID_predicate, &__block_literal_global_14457);
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  long long v84 = Instance;
  if (Instance)
  {
    Instance[2] = 0u;
    Instance[3] = 0u;
    Instance[1] = 0u;
    CGDataProviderRetain(a1);
    *((void *)v84 + 2) = a1;
    if (a2) {
      CFRetain(a2);
    }
    *((void *)v84 + 3) = a2;
    long long v88 = v90;
    v84[2] = v89;
    v84[3] = v88;
  }
  return v84;
}

uint64_t read_byte(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a1;
  if (*a1 == -1)
  {
    char v10 = 0;
    if (!CGAccessSessionGetBytes(*((uint64_t **)a1 + 1), &v10, 1uLL, a4, a5, a6, a7, a8)) {
      return 0xFFFFFFFFLL;
    }
    LOBYTE(v8) = v10;
  }
  else
  {
    *a1 = -1;
  }
  return v8;
}

uint64_t match_anchored_string(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
BOOL get_bbox(int *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v35 = 0.0;
  BOOL result = read_number(a1, &v35, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    double v34 = 0.0;
    BOOL result = read_number(a1, &v34, v11, v12, v13, v14, v15, v16);
    if (result)
    {
      double v33 = 0.0;
      BOOL result = read_number(a1, &v33, v17, v18, v19, v20, v21, v22);
      if (result)
      {
        double v32 = 0.0;
        BOOL result = read_number(a1, &v32, v23, v24, v25, v26, v27, v28);
        if (result)
        {
          double v29 = v34;
          double v30 = v33 - v35;
          double v31 = v32 - v34;
          *a2 = v35;
          a2[1] = v29;
          a2[2] = v30;
          a2[3] = v31;
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL read_number(int *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  do
  {
    do
      int byte = read_byte(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    while (byte == 9);
  }
  while (byte == 32);
  if (byte != -1) {
    *a1 = byte;
  }
  unsigned int v11 = read_byte(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v11 == 45 || v11 == 43)
  {
    v22[0] = v11;
    unsigned int v11 = read_byte(a1, v12, v13, v14, v15, v16, v17, v18);
    unint64_t v19 = 1;
  }
  else
  {
    unint64_t v19 = 0;
  }
  if (v11 - 58 < 0xFFFFFFF6) {
    return 0;
  }
  while (1)
  {
    v22[v19] = v11;
    unsigned int v11 = read_byte(a1, v12, v13, v14, v15, v16, v17, v18);
    if (v11 == -1 || v19 > 0x3D) {
      break;
    }
    if (v11 <= 0x2E)
    {
      if (v11 == 46) {
        goto LABEL_18;
      }
      if (((1 << v11) & 0x100002600) != 0) {
        break;
      }
    }
    if (v11 - 58 < 0xFFFFFFF6) {
      return 0;
    }
LABEL_18:
    ++v19;
  }
  uint64_t v21 = 0;
  v22[v19 + 1] = 0;
  *a2 = strtod_l(v22, &v21, 0);
  return v21 != v22;
}

CFTypeRef CGImageEPSRepRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t CGImageEPSRepGetSource(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t CGImageEPSRepGetAlternateImage(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

CGFloat CGImageEPSRepGetBBox(const CGRect *a1)
{
  CGMutablePathRef v1 = &CGRectNull;
  if (a1) {
    CGMutablePathRef v1 = a1 + 1;
  }
  return v1->origin.x;
}

unsigned char *PDFWriteNumber(unsigned char *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  double v10 = fabs(a2);
  if (v10 == INFINITY)
  {
    LOBYTE(v13) = -1;
    if (a2 <= 0.0) {
      LOBYTE(v13) = 0;
    }
    return CGDataConsumerPrintf(a1, "%d", a4, a5, a6, a7, a8, a9, v13);
  }
  if (a2 >= -2147483650.0 && a2 <= 2147483650.0)
  {
    double v11 = ceil(a2 + -0.5);
    double v12 = floor(a2 + 0.5);
    if (a2 >= 0.0) {
      double v11 = v12;
    }
    int v13 = (int)v11;
    if (vabdd_f64(a2, (double)(int)v11) < 0.000001) {
      return CGDataConsumerPrintf(a1, "%d", a4, a5, a6, a7, a8, a9, v13);
    }
  }
  if (v10 >= 1.0)
  {
    if (v10 <= 10000000.0) {
      return CGDataConsumerPrintf(a1, "%0.7g", a4, a5, a6, a7, a8, a9, SLOBYTE(a2));
    }
    else {
      return CGDataConsumerPrintf(a1, "%0.0f", a4, a5, a6, a7, a8, a9, SLOBYTE(a2));
    }
  }
  else if (v10 >= 0.000001)
  {
    int v15 = 0;
    int v16 = 1;
    do
    {
      if (v10 * (double)v16 >= 1.0) {
        break;
      }
      v16 *= 10;
      ++v15;
    }
    while (v15 != 6);
    for (int i = 0; i != 6; ++i)
    {
      if (vabdd_f64(v10 * (double)v16, round(v10 * (double)v16)) < 0.00001) {
        break;
      }
      v16 *= 10;
    }
    return CGDataConsumerPrintf(a1, "%0.*f", a4, a5, a6, a7, a8, a9, i + v15);
  }
  else
  {
    return CGDataConsumerPrintf(a1, "0", a4, a5, a6, a7, a8, a9, a10);
  }
}

unsigned char *PDFWriteCFData(unsigned char *a1, CFDataRef theData, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = a3;
  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    CFIndex v14 = Length;
    if (BytePtr) {
      BOOL v15 = Length == 0;
    }
    else {
      BOOL v15 = 1;
    }
    int v16 = v15;
    if (v9)
    {
      if (v16)
      {
        uint64_t v17 = "<>";
        goto LABEL_16;
      }
      uint64_t v25 = CGDataConsumerPrintf(a1, "<", a3, a4, a5, a6, a7, a8, v33);
      do
      {
        char v26 = *BytePtr++;
        uint64_t v25 = &v25[(void)CGDataConsumerPrintf(a1, "%02x", v19, v20, v21, v22, v23, v24, v26)];
        --v14;
      }
      while (v14);
      uint64_t v27 = ">";
    }
    else
    {
      if (v16)
      {
        uint64_t v17 = "()";
        goto LABEL_16;
      }
      uint64_t v25 = CGDataConsumerPrintf(a1, "(", a3, a4, a5, a6, a7, a8, v33);
      uint64_t v28 = MEMORY[0x1E4F14390];
      do
      {
        unsigned int v30 = *BytePtr++;
        uint64_t v29 = v30;
        if (v30 > 0x7E || (*(_DWORD *)(v28 + 4 * v29 + 60) & 0x40000) != 0)
        {
          if ((v29 - 40) <= 0x34 && ((1 << (v29 - 40)) & 0x10000000000003) != 0) {
            uint64_t v25 = &v25[(void)CGDataConsumerPrintf(a1, "\\"", v19, v20, v21, v22, v23, v24, v34)];
          }
          double v31 = "%c";
        }
        else
        {
          double v31 = "\\%03o";
        }
        uint64_t v25 = &v25[(void)CGDataConsumerPrintf(a1, v31, v19, v20, v21, v22, v23, v24, v29)];
        --v14;
      }
      while (v14);
      uint64_t v27 = ")";
    }
    return &v25[(void)CGDataConsumerPrintf(a1, v27, v19, v20, v21, v22, v23, v24, v34)];
  }
  if (a3) {
    uint64_t v17 = "<>";
  }
  else {
    uint64_t v17 = "()";
  }
LABEL_16:

  return CGDataConsumerPrintf(a1, v17, a3, a4, a5, a6, a7, a8, a9);
}

CFCalendarRef PDFCreateDateString(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFCalendarRef result = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFCalendarIdentifier)*MEMORY[0x1E4F1D198]);
  if (result)
  {
    uint64_t v4 = result;
    CFTimeZoneRef v5 = CFTimeZoneCreateWithName(v2, @"GMT", 1u);
    if (v5)
    {
      CFTimeZoneRef v6 = v5;
      CFCalendarSetTimeZone(v4, v5);
      CFRelease(v6);
      MEMORY[0x185328FB0](a1);
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      unsigned int v9 = 0;
      unsigned int v8 = 0;
      CFCalendarDecomposeAbsoluteTime(v4, v7, "yMdHms", (char *)&v11 + 4, &v11, (char *)&v10 + 4, &v10, &v9, &v8);
      CFRelease(v4);
      return (CFCalendarRef)CFStringCreateWithFormat(v2, 0, @"D:%04d%02d%02d%02d%02d%02dZ00'00'", HIDWORD(v11), v11, HIDWORD(v10), v10, v9, v8);
    }
    else
    {
      CFRelease(v4);
      return 0;
    }
  }
  return result;
}

char *create_image(uint64_t a1, void *a2, const void *a3, int a4, char a5, const void *a6, int a7)
{
  CFIndex v14 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (!v14) {
    return v14;
  }
  *(_DWORD *)CFIndex v14 = 1;
  *((void *)v14 + 1) = a1;
  if (a2) {
    CFRetain(a2);
  }
  *((void *)v14 + 6) = a2;
  if (a3) {
    CFRetain(a3);
  }
  *((void *)v14 + 8) = a3;
  uint64_t v15 = PDFXRefTableAddObject(*(void **)(a1 + 464));
  *((void *)v14 + 2) = PDFStreamCreateWithObjectNumber(a1, v15);
  v14[72] = a5;
  *((void *)v14 + 7) = 0;
  *((_DWORD *)v14 + 11) = a4;
  if (!a2) {
    goto LABEL_26;
  }
  uint64_t v16 = a2[27];
  if (!v16) {
    goto LABEL_26;
  }
  PropertCGFloat y = CGPropertiesGetProperty(v16, @"com.apple.ImageIO.imageSourceTypeIdentifier");
  if (!Property || !CFEqual(Property, @"public.jpeg"))
  {
LABEL_16:
    uint64_t v21 = a2[27];
    if (v21)
    {
      uint64_t v22 = CGPropertiesGetProperty(v21, @"com.apple.ImageIO.imageSourceTypeIdentifier");
      if (v22)
      {
        if (CFEqual(v22, @"public.jpeg-2000"))
        {
          if (init_with_jpeg2000_data_predicate != -1) {
            dispatch_once(&init_with_jpeg2000_data_predicate, &__block_literal_global_17_14583);
          }
          uint64_t v23 = (CGColorSpaceRef *)(v14 + 88);
          uint64_t v24 = init_with_jpeg2000_data_f(a2, v14 + 88);
          *((void *)v14 + 10) = v24;
          if (v24)
          {
            __int16 v20 = 256;
            goto LABEL_23;
          }
          if (*v23) {
            CGColorSpaceRelease(*v23);
          }
        }
      }
    }
LABEL_26:
    *(_WORD *)(v14 + 73) = 0;
    *((void *)v14 + 10) = 0;
    *((void *)v14 + 11) = 0;
    goto LABEL_27;
  }
  if (init_with_jpeg_data_predicate != -1) {
    dispatch_once(&init_with_jpeg_data_predicate, &__block_literal_global_14581);
  }
  uint64_t v18 = (CGColorSpaceRef *)(v14 + 88);
  uint64_t v19 = init_with_jpeg_data_f(a2, v14 + 88);
  *((void *)v14 + 10) = v19;
  if (!v19)
  {
    if (*v18) {
      CGColorSpaceRelease(*v18);
    }
    goto LABEL_16;
  }
  __int16 v20 = 1;
LABEL_23:
  *(_WORD *)(v14 + 73) = v20;
LABEL_27:
  snprintf_l(v14 + 24, 0x10uLL, 0, "Im%d", a7);
  if (a6) {
    *((void *)v14 + 12) = CFRetain(a6);
  }
  *((void *)v14 + 13) = -1;
  return v14;
}

void *__init_with_jpeg2000_data_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageCopyJPEGDataAndColorSpace");
  }
  CFCalendarRef result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageCopyJPEGDataAndColorSpace");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageCopyJPEGDataAndColorSpace");
  }
  init_with_jpeg2000_data_f = result;
  return result;
}

void *__init_with_jpeg_data_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageCopyJPEGDataAndColorSpace");
  }
  CFCalendarRef result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageCopyJPEGDataAndColorSpace");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageCopyJPEGDataAndColorSpace");
  }
  init_with_jpeg_data_f = result;
  return result;
}

void PDFImageRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2) {
      PDFStreamRelease(v2);
    }
    int v3 = *(const void **)(a1 + 64);
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = *(const void **)(a1 + 48);
    if (v4) {
      CFRelease(v4);
    }
    CFTimeZoneRef v5 = *(const void **)(a1 + 80);
    if (v5) {
      CFRelease(v5);
    }
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 88));
    free((void *)a1);
  }
}

void path_iterator_cull_create(uint64_t a1)
{
  uint64_t v2 = (double *)malloc_type_malloc(0x50uLL, 0x2062DE7BuLL);
  unint64_t v3 = *(void *)a1;
  double v4 = *(double *)(a1 + 16);
  double v5 = *(double *)(a1 + 24);
  if (v4 < 0.0 || v5 < 0.0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    unint64_t v3 = (unint64_t)CGRectStandardize(*(CGRect *)&v3);
  }
  *(void *)uint64_t v2 = v3;
  uint64_t v7 = *(void *)(a1 + 8);
  double v8 = *(double *)(a1 + 16);
  double v9 = *(double *)(a1 + 24);
  if (v8 < 0.0 || v9 < 0.0)
  {
    unint64_t v10 = *(void *)a1;
    *(CGRect *)(&v7 - 1) = CGRectStandardize(*(CGRect *)(&v7 - 1));
  }
  *((void *)v2 + 1) = v7;
  double v11 = *(double *)a1;
  double v12 = *(double *)(a1 + 16);
  double v13 = *(double *)(a1 + 24);
  if (v12 < 0.0 || v13 < 0.0)
  {
    uint64_t v14 = *(void *)(a1 + 8);
    *(CGRect *)&double v11 = CGRectStandardize(*(CGRect *)&v11);
  }
  v2[2] = v11 + v12;
  double v15 = *(double *)(a1 + 8);
  double v16 = *(double *)(a1 + 16);
  double v17 = *(double *)(a1 + 24);
  if (v16 < 0.0 || v17 < 0.0)
  {
    unint64_t v18 = *(void *)a1;
    *(CGRect *)(&v15 - 1) = CGRectStandardize(*(CGRect *)(&v15 - 1));
  }
  v2[3] = v15 + v17;
  *((unsigned char *)v2 + 64) = 0;
  uint64_t v19 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
  *uint64_t v19 = 0;
  v19[1] = 0;
  v19[2] = v19 + 64;
  v19[3] = ((unint64_t)v19 + 55) & 0xFFFFFFFFFFFFFFF8;
  v19[4] = 0;
  v19[5] = 464;
  *((void *)v2 + 9) = v19;
  operator new();
}

void path_cull_release_info(void **a1)
{
  path_free(a1[9]);

  free(a1);
}

float64x2_t *path_cull_end(float64x2_t *a1, void *a2)
{
  CFCalendarRef result = finish_subpath(a1, (uint64_t)a2);
  if (a2)
  {
    double v4 = (uint64_t (*)(uint64_t, uint64_t))a2[4];
    if (v4)
    {
      uint64_t v5 = a2[1];
      uint64_t v6 = a2[6];
      return (float64x2_t *)v4(v5, v6);
    }
  }
  return result;
}

float64x2_t *finish_subpath(float64x2_t *result, uint64_t a2)
{
  if (LOBYTE(result[4].f64[0]))
  {
    uint64_t v2 = result;
    int32x2_t v3 = vmovn_s64(vcltzq_f64(vsubq_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result[1], result[3]), (int8x16_t)result[3], (int8x16_t)result[1]), (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result[2], *result), (int8x16_t)result[2], *(int8x16_t *)result))));
    if (((v3.i32[0] | v3.i32[1]) & 1) == 0 && a2 && *(void *)&result[4].f64[1])
    {
      v6[0] = *(void *)&result[4].f64[1];
      v6[1] = 4;
      void v6[2] = 0;
      v6[3] = 0;
      while (1)
      {
        uint64_t v5 = path_element((uint64_t)v6);
        if (!v5) {
          break;
        }
        (*(void (**)(void, void, void, void))(a2 + 24))(*(void *)(a2 + 8), *(unsigned int *)(v5 + 8), *(void *)(v5 + 16), *(void *)(a2 + 48));
      }
    }
    CFCalendarRef result = (float64x2_t *)path_reset(&v2[4].f64[1]);
    LOBYTE(v2[4].f64[0]) = 0;
  }
  return result;
}

uint64_t path_cull_iterate(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = result;
  switch(a2)
  {
    case -3:
      finish_subpath((float64x2_t *)result, a4);
      double v17 = (_OWORD *)path_add((unsigned __int8 **)(v10 + 72), 0xFFFFFFFD, v11, v12, v13, v14, v15, v16);
      *double v17 = *(_OWORD *)a3;
      v17[1] = *(_OWORD *)(a3 + 16);
      add_subpath_points(v10, (double *)a3, 2);
      goto LABEL_13;
    case 0:
      finish_subpath((float64x2_t *)result, a4);
      unint64_t v18 = (unsigned __int8 **)(v10 + 72);
      unsigned int v19 = 0;
      goto LABEL_5;
    case 1:
      unint64_t v18 = (unsigned __int8 **)(result + 72);
      unsigned int v19 = 1;
LABEL_5:
      *(_OWORD *)path_add(v18, v19, a3, a4, a5, a6, a7, a8) = *(_OWORD *)a3;
      uint64_t v20 = v10;
      uint64_t v21 = (double *)a3;
      uint64_t v22 = 1;
      goto LABEL_8;
    case 2:
      uint64_t v23 = (_OWORD *)path_add((unsigned __int8 **)(result + 72), 2u, a3, a4, a5, a6, a7, a8);
      *uint64_t v23 = *(_OWORD *)a3;
      v23[1] = *(_OWORD *)(a3 + 16);
      uint64_t v20 = v10;
      uint64_t v21 = (double *)a3;
      uint64_t v22 = 2;
      goto LABEL_8;
    case 3:
      uint64_t v24 = (_OWORD *)path_add((unsigned __int8 **)(result + 72), 3u, a3, a4, a5, a6, a7, a8);
      *uint64_t v24 = *(_OWORD *)a3;
      v24[1] = *(_OWORD *)(a3 + 16);
      v24[2] = *(_OWORD *)(a3 + 32);
      uint64_t v20 = v10;
      uint64_t v21 = (double *)a3;
      uint64_t v22 = 3;
LABEL_8:
      CFCalendarRef result = add_subpath_points(v20, v21, v22);
      break;
    case 4:
      if (*(unsigned char *)(result + 64))
      {
        path_add((unsigned __int8 **)(result + 72), 4u, a3, a4, a5, a6, a7, a8);
LABEL_13:
        CFCalendarRef result = (uint64_t)finish_subpath((float64x2_t *)v10, a4);
      }
      break;
    default:
      abort();
  }
  return result;
}

uint64_t add_subpath_points(uint64_t result, double *a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(result + 64);
  do
  {
    if (v3)
    {
      double v4 = *a2;
      if (*a2 < *(double *)(result + 32)) {
        *(double *)(result + 32) = v4;
      }
      if (v4 > *(double *)(result + 48)) {
        *(double *)(result + 48) = v4;
      }
      double v5 = a2[1];
      if (v5 < *(double *)(result + 40)) {
        *(double *)(result + 40) = v5;
      }
      if (v5 > *(double *)(result + 56)) {
        *(double *)(result + 56) = v5;
      }
    }
    else
    {
      int v3 = 1;
      *(unsigned char *)(result + 64) = 1;
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)(result + 32) = *(_OWORD *)a2;
      *(_OWORD *)(result + 48) = v6;
    }
    a2 += 2;
    --a3;
  }
  while (a3);
  return result;
}

void *path_cull_begin(uint64_t a1, uint64_t a2, void *a3)
{
  CFCalendarRef result = path_reset((void *)(a1 + 72));
  *(unsigned char *)(a1 + 64) = 0;
  if (a3)
  {
    uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))a3[2];
    if (v7)
    {
      uint64_t v8 = a3[1];
      uint64_t v9 = a3[6];
      return (void *)v7(v8, a2, v9);
    }
  }
  return result;
}

int *argb32_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t v72 = *(void *)(a1 + 80);
  uint64_t v75 = *(int **)(a1 + 88);
  uint64_t v82 = *(void *)(a1 + 112);
  uint64_t v81 = *(void *)(a1 + 120);
  int v71 = *(_DWORD *)(a1 + 188);
  uint64_t v16 = (int *)(*(void *)(a1 + 152) - 4);
  uint64_t v76 = *(void *)(a1 + 144) - 1;
  int v79 = *(_DWORD *)(a1 + 24);
  uint64_t v80 = *(void *)(a1 + 40);
  uint64_t v77 = *(void *)(a1 + 32);
  unint64_t v17 = v77 + ((*(_DWORD *)(a1 + 260) - 1) * v79) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  uint64_t v73 = *(void *)(a1 + 64);
  uint64_t v74 = *(void *)(a1 + 72);
  unint64_t v78 = v17;
  while (1)
  {
    if (a3 >= v74)
    {
      CFCalendarRef result = v75;
      if (a3 <= (uint64_t)v75)
      {
        uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        HIDWORD(v31) = HIDWORD(a3);
        int v21 = a4;
        uint64_t v22 = v73;
      }
      else
      {
        uint64_t v25 = *(void *)(a1 + 216);
        char v26 = (char *)v75 + *(void *)(a1 + 224);
        uint64_t v27 = (uint64_t)&v26[(v25 >> 1) - a3];
        int v21 = a4;
        uint64_t v22 = v73;
        if (v27 < 1) {
          goto LABEL_34;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(a1 + 232) * v27) >> 32;
        }
        unsigned int v30 = v71 | v28;
        double v31 = v26 - 0x1000000;
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 216);
      uint64_t v19 = v74 - *(void *)(a1 + 224);
      uint64_t v20 = a3 - v19 + (v18 >> 1);
      int v21 = a4;
      uint64_t v22 = v73;
      CFCalendarRef result = v75;
      if (v20 < 1) {
        goto LABEL_34;
      }
      if (v20 >= v18) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(a1 + 232) * v20) >> 32;
      }
      unsigned int v30 = v71 | v24;
      double v31 = (char *)(v19 + 0x1000000);
      uint64_t v29 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v72)
      {
        uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v35 = a2;
      }
      else
      {
        uint64_t v37 = *(void *)(a1 + 192);
        uint64_t v38 = *(void *)(a1 + 200) + v72;
        uint64_t v39 = v38 - a2 + (v37 >> 1);
        if (v39 < 1) {
          goto LABEL_34;
        }
        if (v39 < v37) {
          unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v39) >> 32) >> 15)) | v71;
        }
        uint64_t v35 = v38 - 0x1000000;
        uint64_t v36 = 28;
      }
    }
    else
    {
      uint64_t v32 = *(void *)(a1 + 192);
      uint64_t v33 = v22 - *(void *)(a1 + 200);
      uint64_t v34 = a2 - v33 + (v32 >> 1);
      if (v34 < 1) {
        goto LABEL_34;
      }
      if (v34 < v32) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v34) >> 32) >> 15)) | v71;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = 32;
    }
    if (v30 >= 0x400000) {
      break;
    }
LABEL_34:
    int v44 = v21 - 1;
    a2 += v82;
    a3 += v81;
    ++v16;
    *(unsigned char *)++uint64_t v76 = 0;
LABEL_35:
    a4 = v44;
    if (!v44) {
      return result;
    }
  }
  unint64_t v40 = v77 + SHIDWORD(v31) * (uint64_t)v79 + 16 * (v35 >> 32);
  uint64_t v41 = *(float32x2_t **)(a1 + 32);
  if (v17 >= v40) {
    uint64_t v42 = (float32x2_t *)v40;
  }
  else {
    uint64_t v42 = (float32x2_t *)v17;
  }
  if (v42 < v41) {
    uint64_t v42 = *(float32x2_t **)(a1 + 32);
  }
  if (v80) {
    float v43 = v42[1].f32[1];
  }
  else {
    float v43 = 1.0;
  }
  float32x2_t v45 = *v42;
  float v46 = v42[1].f32[0];
  if (v15)
  {
    unsigned int v47 = *(_DWORD *)(v15 + (v36 | v29));
LABEL_41:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    if (v48 == 1)
    {
      int v57 = (float32x2_t *)(v40 + SBYTE1(v47) * (uint64_t)v79);
      if (v17 < (unint64_t)v57) {
        int v57 = (float32x2_t *)v17;
      }
      if (v57 >= v41) {
        uint64_t v41 = v57;
      }
      float32x2_t v58 = *v41;
      float v59 = v41[1].f32[0];
      float v60 = 1.0;
      if (v80) {
        float v60 = v41[1].f32[1];
      }
      int v61 = &interpolate_rgbaf_21353[4 * v49];
    }
    else
    {
      if (v48 != 2)
      {
        if (v48 == 3)
        {
          uint64_t v50 = SBYTE1(v47) * (uint64_t)v79;
          uint64_t v51 = 16 * SBYTE2(v47);
          int v52 = (float32x2_t *)(v40 + v51);
          if (v17 < v40 + v51) {
            int v52 = (float32x2_t *)v17;
          }
          if (v52 < v41) {
            int v52 = v41;
          }
          float32x2_t v53 = *v52;
          if (v80)
          {
            float v54 = v52[1].f32[1];
            int v55 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v55) {
              int v55 = (float32x2_t *)v17;
            }
            if (v55 >= v41) {
              uint64_t v41 = v55;
            }
            float v56 = v41[1].f32[1];
          }
          else
          {
            uint64_t v63 = (float32x2_t *)(v40 + v50 + v51);
            if (v17 < (unint64_t)v63) {
              uint64_t v63 = (float32x2_t *)v17;
            }
            if (v63 >= v41) {
              uint64_t v41 = v63;
            }
            float v54 = 1.0;
            float v56 = 1.0;
          }
          v11.i32[0] = interpolate_rgbaf_21353[4 * v49 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v47 >> 28) & 3) + 3];
          float v46 = (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                      - (float)((float)((float)(v46 - (float)(v46 * v11.f32[0])) + (float)(v52[1].f32[0] * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v52[1].f32[0] - (float)(v52[1].f32[0] * v11.f32[0]))
                              + (float)(v41[1].f32[0] * v11.f32[0]))
                      * v12.f32[0]);
          float32x2_t v64 = vmla_n_f32(vmls_lane_f32(v45, v45, v11, 0), v53, v11.f32[0]);
          float32x2_t v45 = vmla_n_f32(vmls_lane_f32(v64, v64, v12, 0), vmla_n_f32(vmls_lane_f32(v53, v53, v11, 0), *v41, v11.f32[0]), v12.f32[0]);
          float v43 = (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                      - (float)((float)((float)(v43 - (float)(v43 * v11.f32[0])) + (float)(v54 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v54 - (float)(v54 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_75;
      }
      int v62 = (float32x2_t *)(v40 + ((uint64_t)((unint64_t)HIWORD(v47) << 56) >> 52));
      if (v17 < (unint64_t)v62) {
        int v62 = (float32x2_t *)v17;
      }
      if (v62 >= v41) {
        uint64_t v41 = v62;
      }
      float32x2_t v58 = *v41;
      float v59 = v41[1].f32[0];
      float v60 = 1.0;
      if (v80) {
        float v60 = v41[1].f32[1];
      }
      int v61 = &interpolate_rgbaf_21353[4 * ((v47 >> 28) & 3)];
    }
    LODWORD(a11) = v61[3];
    float32x2_t v45 = vmla_n_f32(vmls_lane_f32(v45, v45, *(float32x2_t *)&a11, 0), v58, *(float *)&a11);
    float v46 = (float)(v46 - (float)(v46 * *(float *)&a11)) + (float)(v59 * *(float *)&a11);
    float v43 = (float)(v43 - (float)(v43 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
  }
LABEL_75:
  uint64_t v65 = 0;
  ++v16;
  int v70 = v21;
  int v66 = v21 - 1;
  a3 += v81;
  unint64_t v67 = (unint64_t)result - a3;
  a2 += v82;
  uint64_t v68 = v72 - a2;
  while (1)
  {
    CFCalendarRef result = RGBAF(v16, v45.f32[0], v45.f32[1], v46, v43);
    *(unsigned char *)(v76 + 1 + v65) = v30 >> 22;
    unint64_t v17 = v78;
    if (v66 == v65) {
      return result;
    }
    if (((v67 | v68 | (a3 - v74) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v76 += v65 + 1;
      int v44 = ~v65 + v70;
      goto LABEL_35;
    }
    unint64_t v40 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    uint64_t v41 = *(float32x2_t **)(a1 + 32);
    if (v78 >= v40) {
      unint64_t v69 = v77 + SHIDWORD(a3) * (uint64_t)v79 + 16 * (a2 >> 32);
    }
    else {
      unint64_t v69 = v78;
    }
    if (v69 < (unint64_t)v41) {
      unint64_t v69 = *(void *)(a1 + 32);
    }
    if (v80) {
      float v43 = *(float *)(v69 + 12);
    }
    else {
      float v43 = 1.0;
    }
    float32x2_t v45 = *(float32x2_t *)v69;
    float v46 = *(float *)(v69 + 8);
    if (v15)
    {
      unsigned int v47 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        CFCalendarRef result = v75;
        v76 += v65 + 1;
        int v21 = ~v65 + v70;
        unsigned int v30 = -1;
        goto LABEL_41;
      }
    }
    ++v16;
    ++v65;
    a3 += v81;
    v67 -= v81;
    a2 += v82;
    v68 -= v82;
    unsigned int v30 = -1;
  }
}

int *RGBAF(int *result, float a2, float a3, float a4, float a5)
{
  if (a5 <= 0.0)
  {
    int v9 = 0;
  }
  else
  {
    int v5 = (int)(float)((float)(a5 * 255.0) + 0.5);
    if (a5 > 1.0)
    {
      int v5 = 255;
      a5 = 1.0;
    }
    int v6 = (int)(float)((float)(a2 * 255.0) + 0.5);
    if (a2 < 0.0) {
      int v6 = 0;
    }
    if (a2 > a5) {
      int v6 = v5;
    }
    int v7 = (int)(float)((float)(a3 * 255.0) + 0.5);
    if (a3 < 0.0) {
      int v7 = 0;
    }
    if (a3 > a5) {
      int v7 = v5;
    }
    int v8 = (int)(float)((float)(a4 * 255.0) + 0.5);
    if (a4 < 0.0) {
      int v8 = 0;
    }
    if (a4 > a5) {
      int v8 = v5;
    }
    int v9 = (v6 << 16) | (v5 << 24) | (v7 << 8) | v8;
  }
  *CFCalendarRef result = v9;
  return result;
}

int *argb32_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t v71 = *(void *)(a1 + 80);
  uint64_t v74 = *(int **)(a1 + 88);
  uint64_t v81 = *(void *)(a1 + 112);
  uint64_t v80 = *(void *)(a1 + 120);
  int v70 = *(_DWORD *)(a1 + 188);
  uint64_t v16 = (int *)(*(void *)(a1 + 152) - 4);
  uint64_t v75 = *(void *)(a1 + 144) - 1;
  uint64_t v79 = *(void *)(a1 + 40);
  uint64_t v76 = *(void *)(a1 + 32);
  int v77 = *(_DWORD *)(a1 + 24);
  unint64_t v78 = v76 + ((*(_DWORD *)(a1 + 260) - 1) * v77) + 4 * (4 * *(_DWORD *)(a1 + 256)) - 16;
  uint64_t v72 = *(void *)(a1 + 72);
  uint64_t v73 = *(void *)(a1 + 64);
  while (1)
  {
    if (a3 >= v72)
    {
      CFCalendarRef result = v74;
      if (a3 <= (uint64_t)v74)
      {
        uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v29 = 0x3FFFFFFF;
        HIDWORD(v30) = HIDWORD(a3);
        int v20 = a4;
        uint64_t v22 = v73;
      }
      else
      {
        uint64_t v24 = *(void *)(a1 + 216);
        uint64_t v25 = (char *)v74 + *(void *)(a1 + 224);
        uint64_t v26 = (uint64_t)&v25[(v24 >> 1) - a3];
        int v20 = a4;
        uint64_t v22 = v73;
        if (v26 < 1) {
          goto LABEL_33;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(a1 + 232) * v26) >> 32;
        }
        unsigned int v29 = v70 | v27;
        unsigned int v30 = v25 - 0x1000000;
        uint64_t v28 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(a1 + 216);
      uint64_t v18 = v72 - *(void *)(a1 + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      int v20 = a4;
      uint64_t v22 = v73;
      CFCalendarRef result = v74;
      if (v19 < 1) {
        goto LABEL_33;
      }
      if (v19 >= v17) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(a1 + 232) * v19) >> 32;
      }
      unsigned int v29 = v70 | v23;
      unsigned int v30 = (char *)(v18 + 0x1000000);
      uint64_t v28 = 512;
    }
    if (a2 >= v22)
    {
      if (a2 <= v71)
      {
        uint64_t v35 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v34 = a2;
      }
      else
      {
        uint64_t v36 = *(void *)(a1 + 192);
        uint64_t v37 = *(void *)(a1 + 200) + v71;
        uint64_t v38 = v37 - a2 + (v36 >> 1);
        if (v38 < 1) {
          goto LABEL_33;
        }
        if (v38 < v36) {
          unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v38) >> 32) >> 15)) | v70;
        }
        uint64_t v34 = v37 - 0x1000000;
        uint64_t v35 = 28;
      }
    }
    else
    {
      uint64_t v31 = *(void *)(a1 + 192);
      uint64_t v32 = v22 - *(void *)(a1 + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 < 1) {
        goto LABEL_33;
      }
      if (v33 < v31) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v33) >> 32) >> 15)) | v70;
      }
      uint64_t v34 = v32 + 0x1000000;
      uint64_t v35 = 32;
    }
    if (v29 >= 0x400000) {
      break;
    }
LABEL_33:
    int v43 = v20 - 1;
    a2 += v81;
    a3 += v80;
    ++v16;
    *(unsigned char *)++uint64_t v75 = 0;
LABEL_34:
    a4 = v43;
    if (!v43) {
      return result;
    }
  }
  unint64_t v39 = v76 + SHIDWORD(v30) * (uint64_t)v77 + 16 * (v34 >> 32);
  unint64_t v40 = *(int8x8_t **)(a1 + 32);
  uint64_t v41 = (int8x8_t *)v78;
  if (v78 >= v39) {
    uint64_t v41 = (int8x8_t *)v39;
  }
  if (v41 < v40) {
    uint64_t v41 = *(int8x8_t **)(a1 + 32);
  }
  if (v79) {
    float v42 = COERCE_FLOAT(bswap32(v41[1].u32[1]));
  }
  else {
    float v42 = 1.0;
  }
  float32x2_t v44 = (float32x2_t)vrev32_s8(*v41);
  float v45 = COERCE_FLOAT(bswap32(v41[1].u32[0]));
  if (v15)
  {
    unsigned int v46 = *(_DWORD *)(v15 + (v35 | v28));
LABEL_40:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      float32x2_t v58 = (int8x8_t *)(v39 + SBYTE1(v46) * (uint64_t)v77);
      if (v78 < (unint64_t)v58) {
        float32x2_t v58 = (int8x8_t *)v78;
      }
      if (v58 >= v40) {
        unint64_t v40 = v58;
      }
      float32x2_t v59 = (float32x2_t)vrev32_s8(*v40);
      float v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      float v61 = 1.0;
      if (v79) {
        float v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      }
      int v62 = &interpolate_rgbaf_21353[4 * v48];
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int v49 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
          if (v78 < (unint64_t)v49) {
            int v49 = (int8x8_t *)v78;
          }
          if (v49 < v40) {
            int v49 = v40;
          }
          float32x2_t v50 = (float32x2_t)vrev32_s8(*v49);
          float v51 = COERCE_FLOAT(bswap32(v49[1].u32[0]));
          float v52 = 1.0;
          float v53 = 1.0;
          if (v79) {
            float v53 = COERCE_FLOAT(bswap32(v49[1].u32[1]));
          }
          unint64_t v54 = v39 + SBYTE1(v46) * (uint64_t)v77 + 16 * SBYTE2(v46);
          if (v78 < v54) {
            unint64_t v54 = v78;
          }
          if (v54 >= (unint64_t)v40) {
            unint64_t v40 = (int8x8_t *)v54;
          }
          float32x2_t v55 = (float32x2_t)vrev32_s8(*v40);
          float v56 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
          if (v79) {
            float v52 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
          }
          v11.i32[0] = interpolate_rgbaf_21353[4 * v48 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v46 >> 28) & 3) + 3];
          float v45 = (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                      - (float)((float)((float)(v45 - (float)(v45 * v11.f32[0])) + (float)(v51 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v51 - (float)(v51 * v11.f32[0])) + (float)(v56 * v11.f32[0])) * v12.f32[0]);
          float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v44, v44, v11, 0), v50, v11.f32[0]);
          float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v57, v57, v12, 0), vmla_n_f32(vmls_lane_f32(v50, v50, v11, 0), v55, v11.f32[0]), v12.f32[0]);
          float v42 = (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                      - (float)((float)((float)(v42 - (float)(v42 * v11.f32[0])) + (float)(v53 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v53 - (float)(v53 * v11.f32[0])) + (float)(v52 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_71;
      }
      uint64_t v63 = (int8x8_t *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 52));
      if (v78 < (unint64_t)v63) {
        uint64_t v63 = (int8x8_t *)v78;
      }
      if (v63 >= v40) {
        unint64_t v40 = v63;
      }
      float32x2_t v59 = (float32x2_t)vrev32_s8(*v40);
      float v60 = COERCE_FLOAT(bswap32(v40[1].u32[0]));
      float v61 = 1.0;
      if (v79) {
        float v61 = COERCE_FLOAT(bswap32(v40[1].u32[1]));
      }
      int v62 = &interpolate_rgbaf_21353[4 * ((v46 >> 28) & 3)];
    }
    LODWORD(a11) = v62[3];
    float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
    float v45 = (float)(v45 - (float)(v45 * *(float *)&a11)) + (float)(v60 * *(float *)&a11);
    float v42 = (float)(v42 - (float)(v42 * *(float *)&a11)) + (float)(v61 * *(float *)&a11);
  }
LABEL_71:
  uint64_t v64 = 0;
  ++v16;
  int v69 = v20;
  int v65 = v20 - 1;
  a3 += v80;
  unint64_t v66 = (unint64_t)result - a3;
  a2 += v81;
  uint64_t v67 = v71 - a2;
  while (1)
  {
    CFCalendarRef result = RGBAF(v16, v44.f32[0], v44.f32[1], v45, v42);
    *(unsigned char *)(v75 + 1 + v64) = v29 >> 22;
    if (v65 == v64) {
      return result;
    }
    if (((v66 | v67 | (a3 - v72) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v75 += v64 + 1;
      int v43 = ~v64 + v69;
      goto LABEL_34;
    }
    unint64_t v39 = v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32);
    unint64_t v40 = *(int8x8_t **)(a1 + 32);
    uint64_t v68 = (int8x8_t *)v78;
    if (v78 >= v39) {
      uint64_t v68 = (int8x8_t *)(v76 + SHIDWORD(a3) * (uint64_t)v77 + 16 * (a2 >> 32));
    }
    if (v68 < v40) {
      uint64_t v68 = *(int8x8_t **)(a1 + 32);
    }
    if (v79) {
      float v42 = COERCE_FLOAT(bswap32(v68[1].u32[1]));
    }
    else {
      float v42 = 1.0;
    }
    float32x2_t v44 = (float32x2_t)vrev32_s8(*v68);
    float v45 = COERCE_FLOAT(bswap32(v68[1].u32[0]));
    if (v15)
    {
      unsigned int v46 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        CFCalendarRef result = v74;
        v75 += v64 + 1;
        int v20 = ~v64 + v69;
        unsigned int v29 = -1;
        goto LABEL_40;
      }
    }
    ++v16;
    ++v64;
    a3 += v80;
    v66 -= v80;
    a2 += v81;
    v67 -= v81;
    unsigned int v29 = -1;
  }
}

int *argb32_sample_RGBf(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12 = *((void *)result + 22);
  uint64_t v59 = *((void *)result + 10);
  uint64_t v62 = *((void *)result + 11);
  uint64_t v67 = *((void *)result + 15);
  uint64_t v68 = *((void *)result + 14);
  uint64_t v13 = (int *)(*((void *)result + 19) - 4);
  uint64_t v63 = *((void *)result + 18) - 1;
  uint64_t v64 = *((void *)result + 4);
  int v65 = result[6];
  int v69 = result;
  int v58 = result[47];
  unint64_t v66 = v64 + ((result[65] - 1) * v65) + 4 * (3 * result[64]) - 16;
  uint64_t v60 = *((void *)result + 8);
  uint64_t v61 = *((void *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v61)
    {
      if ((uint64_t)a3 <= v62)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        int v17 = a4;
        uint64_t v18 = v60;
      }
      else
      {
        uint64_t v20 = *((void *)v69 + 27);
        uint64_t v21 = *((void *)v69 + 28) + v62;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        int v17 = a4;
        uint64_t v18 = v60;
        if (v22 < 1) {
          goto LABEL_33;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*((void *)v69 + 29) * v22) >> 32;
        }
        unsigned int v25 = v58 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v14 = *((void *)v69 + 27);
      uint64_t v15 = v61 - *((void *)v69 + 28);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      int v17 = a4;
      uint64_t v18 = v60;
      if (v16 < 1) {
        goto LABEL_33;
      }
      if (v16 >= v14) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*((void *)v69 + 29) * v16) >> 32;
      }
      unsigned int v25 = v58 | v19;
      uint64_t v26 = v15 + 0x1000000;
      uint64_t v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v59)
      {
        uint64_t v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        uint64_t v32 = *((void *)v69 + 24);
        uint64_t v33 = *((void *)v69 + 25) + v59;
        uint64_t v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_33;
        }
        if (v34 < v32) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v69 + 26) * v34) >> 32) >> 15)) | v58;
        }
        uint64_t v30 = v33 - 0x1000000;
        uint64_t v31 = 28;
      }
    }
    else
    {
      uint64_t v27 = *((void *)v69 + 24);
      uint64_t v28 = v18 - *((void *)v69 + 25);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_33;
      }
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v69 + 26) * v29) >> 32) >> 15)) | v58;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
    }
    if (v25 >= 0x400000) {
      break;
    }
LABEL_33:
    int v41 = v17 - 1;
    a2 += v68;
    a3 += v67;
    ++v13;
    *(unsigned char *)++uint64_t v63 = 0;
LABEL_34:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  unint64_t v35 = v64 + SHIDWORD(v26) * (uint64_t)v65 + 12 * SHIDWORD(v30);
  uint64_t v36 = (float32x2_t *)*((void *)v69 + 4);
  uint64_t v37 = (float32x2_t *)v66;
  if (v66 >= v35) {
    uint64_t v37 = (float32x2_t *)v35;
  }
  if (v37 < v36) {
    uint64_t v37 = (float32x2_t *)*((void *)v69 + 4);
  }
  float32x2_t v38 = *v37;
  float v39 = v37[1].f32[0];
  if (!v12) {
    goto LABEL_36;
  }
  unsigned int v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  int v42 = v40 & 0xF;
  int v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    int v48 = (float32x2_t *)(v35 + SBYTE1(v40) * (uint64_t)v65);
    if (v66 < (unint64_t)v48) {
      int v48 = (float32x2_t *)v66;
    }
    if (v48 >= v36) {
      uint64_t v36 = v48;
    }
    float v49 = v36[1].f32[0];
    float32x2_t v50 = &interpolate_rgbaf_21353[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    float v51 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
    if (v66 < (unint64_t)v51) {
      float v51 = (float32x2_t *)v66;
    }
    if (v51 >= v36) {
      uint64_t v36 = v51;
    }
    float v49 = v36[1].f32[0];
    float32x2_t v50 = &interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v50[3];
    float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), *v36, *(float *)&a8);
    float v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v49 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  float32x2_t v44 = (float32x2_t *)(v35 + 12 * SBYTE2(v40));
  if (v66 >= (unint64_t)v44) {
    float v45 = v44;
  }
  else {
    float v45 = (float32x2_t *)v66;
  }
  if (v45 < v36) {
    float v45 = v36;
  }
  unsigned int v46 = (float32x2_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v65);
  if (v66 < (unint64_t)v46) {
    unsigned int v46 = (float32x2_t *)v66;
  }
  if (v46 >= v36) {
    uint64_t v36 = v46;
  }
  LODWORD(a9) = interpolate_rgbaf_21353[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3) + 3];
  float v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v45[1].f32[0] * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v45[1].f32[0] - (float)(v45[1].f32[0] * *(float *)&a9))
                      + (float)(v36[1].f32[0] * *(float *)&a9))
              * *(float *)&a10);
  float32x2_t v47 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *v45, *(float *)&a9);
  float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*v45, *v45, *(float32x2_t *)&a9, 0), *v36, *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  uint64_t v52 = 0;
  ++v13;
  int v57 = v17;
  int v53 = v17 - 1;
  a3 += v67;
  uint64_t v54 = v62 - a3;
  a2 += v68;
  uint64_t v55 = v59 - a2;
  while (1)
  {
    CFCalendarRef result = RGBAF(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(unsigned char *)(v63 + 1 + v52) = v25 >> 22;
    if (v53 == v52) {
      return result;
    }
    if (((v54 | v55 | (a3 - v61) | (a2 - v60)) & 0x8000000000000000) != 0)
    {
      v63 += v52 + 1;
      int v41 = ~v52 + v57;
      goto LABEL_34;
    }
    unint64_t v35 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    uint64_t v36 = (float32x2_t *)*((void *)v69 + 4);
    unint64_t v56 = v66;
    if (v66 >= v35) {
      unint64_t v56 = v64 + SHIDWORD(a3) * (uint64_t)v65 + 12 * SHIDWORD(a2);
    }
    if (v56 < (unint64_t)v36) {
      unint64_t v56 = *((void *)v69 + 4);
    }
    float32x2_t v38 = *(float32x2_t *)v56;
    float v39 = *(float *)(v56 + 8);
    if (v12)
    {
      unsigned int v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v63 += v52 + 1;
        int v17 = ~v52 + v57;
        unsigned int v25 = -1;
        goto LABEL_38;
      }
    }
    ++v52;
    ++v13;
    a3 += v67;
    v54 -= v67;
    a2 += v68;
    v55 -= v68;
    LODWORD(a8) = 1.0;
    unsigned int v25 = -1;
  }
}

int *argb32_sample_RGBF(int *result, unint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v12 = *((void *)result + 22);
  uint64_t v60 = *((void *)result + 10);
  uint64_t v63 = *((void *)result + 11);
  uint64_t v68 = *((void *)result + 15);
  uint64_t v69 = *((void *)result + 14);
  uint64_t v13 = (int *)(*((void *)result + 19) - 4);
  uint64_t v64 = *((void *)result + 18) - 1;
  uint64_t v65 = *((void *)result + 4);
  int v66 = result[6];
  int v70 = result;
  int v59 = result[47];
  unint64_t v67 = v65 + ((result[65] - 1) * v66) + 4 * (3 * result[64]) - 16;
  uint64_t v61 = *((void *)result + 8);
  uint64_t v62 = *((void *)result + 9);
  while (1)
  {
    if ((uint64_t)a3 >= v62)
    {
      if ((uint64_t)a3 <= v63)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        int v17 = a4;
        uint64_t v18 = v61;
      }
      else
      {
        uint64_t v20 = *((void *)v70 + 27);
        uint64_t v21 = *((void *)v70 + 28) + v63;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        int v17 = a4;
        uint64_t v18 = v61;
        if (v22 < 1) {
          goto LABEL_33;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*((void *)v70 + 29) * v22) >> 32;
        }
        unsigned int v25 = v59 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v14 = *((void *)v70 + 27);
      uint64_t v15 = v62 - *((void *)v70 + 28);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      int v17 = a4;
      uint64_t v18 = v61;
      if (v16 < 1) {
        goto LABEL_33;
      }
      if (v16 >= v14) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*((void *)v70 + 29) * v16) >> 32;
      }
      unsigned int v25 = v59 | v19;
      uint64_t v26 = v15 + 0x1000000;
      uint64_t v24 = 512;
    }
    if ((uint64_t)a2 >= v18)
    {
      if ((uint64_t)a2 <= v60)
      {
        uint64_t v31 = (a2 >> 26) & 0x3C;
        HIDWORD(v30) = HIDWORD(a2);
      }
      else
      {
        uint64_t v32 = *((void *)v70 + 24);
        uint64_t v33 = *((void *)v70 + 25) + v60;
        uint64_t v34 = v33 - a2 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_33;
        }
        if (v34 < v32) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v70 + 26) * v34) >> 32) >> 15)) | v59;
        }
        uint64_t v30 = v33 - 0x1000000;
        uint64_t v31 = 28;
      }
    }
    else
    {
      uint64_t v27 = *((void *)v70 + 24);
      uint64_t v28 = v18 - *((void *)v70 + 25);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_33;
      }
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*((void *)v70 + 26) * v29) >> 32) >> 15)) | v59;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
    }
    if (v25 >= 0x400000) {
      break;
    }
LABEL_33:
    int v41 = v17 - 1;
    a2 += v69;
    a3 += v68;
    ++v13;
    *(unsigned char *)++uint64_t v64 = 0;
LABEL_34:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  unint64_t v35 = v65 + SHIDWORD(v26) * (uint64_t)v66 + 12 * SHIDWORD(v30);
  uint64_t v36 = (int8x8_t *)*((void *)v70 + 4);
  uint64_t v37 = (int8x8_t *)v67;
  if (v67 >= v35) {
    uint64_t v37 = (int8x8_t *)v35;
  }
  if (v37 < v36) {
    uint64_t v37 = (int8x8_t *)*((void *)v70 + 4);
  }
  float32x2_t v38 = (float32x2_t)vrev32_s8(*v37);
  float v39 = COERCE_FLOAT(bswap32(v37[1].u32[0]));
  if (!v12) {
    goto LABEL_36;
  }
  unsigned int v40 = *(_DWORD *)(v12 + (v31 | v24));
LABEL_38:
  int v42 = v40 & 0xF;
  int v43 = HIBYTE(v40) & 3;
  if (v42 == 1)
  {
    float v49 = (int8x8_t *)(v35 + SBYTE1(v40) * (uint64_t)v66);
    if (v67 < (unint64_t)v49) {
      float v49 = (int8x8_t *)v67;
    }
    if (v49 >= v36) {
      uint64_t v36 = v49;
    }
    float v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    float v51 = &interpolate_rgbaf_21353[4 * v43];
    goto LABEL_61;
  }
  if (v42 == 2)
  {
    uint64_t v52 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
    if (v67 < (unint64_t)v52) {
      uint64_t v52 = (int8x8_t *)v67;
    }
    if (v52 >= v36) {
      uint64_t v36 = v52;
    }
    float v50 = COERCE_FLOAT(bswap32(v36[1].u32[0]));
    float v51 = &interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3)];
LABEL_61:
    LODWORD(a8) = v51[3];
    float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a8, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a8);
    float v39 = (float)(v39 - (float)(v39 * *(float *)&a8)) + (float)(v50 * *(float *)&a8);
    *(float *)&a8 = *(float *)&a8 + (float)(1.0 - *(float *)&a8);
    goto LABEL_62;
  }
  if (v42 != 3)
  {
LABEL_36:
    LODWORD(a8) = 1.0;
    goto LABEL_62;
  }
  float32x2_t v44 = (int8x8_t *)(v35 + 12 * SBYTE2(v40));
  if (v67 >= (unint64_t)v44) {
    float v45 = v44;
  }
  else {
    float v45 = (int8x8_t *)v67;
  }
  if (v45 < v36) {
    float v45 = v36;
  }
  float v46 = COERCE_FLOAT(bswap32(v45[1].u32[0]));
  float32x2_t v47 = (int8x8_t *)((char *)v44 + SBYTE1(v40) * (uint64_t)v66);
  if (v67 < (unint64_t)v47) {
    float32x2_t v47 = (int8x8_t *)v67;
  }
  if (v47 >= v36) {
    uint64_t v36 = v47;
  }
  LODWORD(a9) = interpolate_rgbaf_21353[4 * v43 + 3];
  LODWORD(a10) = interpolate_rgbaf_21353[4 * ((v40 >> 28) & 3) + 3];
  float v39 = (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
              - (float)((float)((float)(v39 - (float)(v39 * *(float *)&a9)) + (float)(v46 * *(float *)&a9))
                      * *(float *)&a10))
      + (float)((float)((float)(v46 - (float)(v46 * *(float *)&a9))
                      + (float)(COERCE_FLOAT(bswap32(v36[1].u32[0])) * *(float *)&a9))
              * *(float *)&a10);
  a8 = COERCE_DOUBLE(vrev32_s8(*v45));
  float32x2_t v48 = vmla_n_f32(vmls_lane_f32(v38, v38, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a8, *(float *)&a9);
  float32x2_t v38 = vmla_n_f32(vmls_lane_f32(v48, v48, *(float32x2_t *)&a10, 0), vmla_n_f32(vmls_lane_f32(*(float32x2_t *)&a8, *(float32x2_t *)&a8, *(float32x2_t *)&a9, 0), (float32x2_t)vrev32_s8(*v36), *(float *)&a9), *(float *)&a10);
  *(float *)&a8 = (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9))
                        - (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10))
                + (float)((float)(*(float *)&a9 + (float)(1.0 - *(float *)&a9)) * *(float *)&a10);
LABEL_62:
  uint64_t v53 = 0;
  ++v13;
  int v58 = v17;
  int v54 = v17 - 1;
  a3 += v68;
  uint64_t v55 = v63 - a3;
  a2 += v69;
  uint64_t v56 = v60 - a2;
  while (1)
  {
    CFCalendarRef result = RGBAF(v13, v38.f32[0], v38.f32[1], v39, *(float *)&a8);
    *(unsigned char *)(v64 + 1 + v53) = v25 >> 22;
    if (v54 == v53) {
      return result;
    }
    if (((v55 | v56 | (a3 - v62) | (a2 - v61)) & 0x8000000000000000) != 0)
    {
      v64 += v53 + 1;
      int v41 = ~v53 + v58;
      goto LABEL_34;
    }
    unint64_t v35 = v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2);
    uint64_t v36 = (int8x8_t *)*((void *)v70 + 4);
    int v57 = (int8x8_t *)v67;
    if (v67 >= v35) {
      int v57 = (int8x8_t *)(v65 + SHIDWORD(a3) * (uint64_t)v66 + 12 * SHIDWORD(a2));
    }
    if (v57 < v36) {
      int v57 = (int8x8_t *)*((void *)v70 + 4);
    }
    float32x2_t v38 = (float32x2_t)vrev32_s8(*v57);
    float v39 = COERCE_FLOAT(bswap32(v57[1].u32[0]));
    if (v12)
    {
      unsigned int v40 = *(_DWORD *)(v12 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v64 += v53 + 1;
        int v17 = ~v53 + v58;
        unsigned int v25 = -1;
        goto LABEL_38;
      }
    }
    ++v53;
    ++v13;
    a3 += v68;
    v55 -= v68;
    a2 += v69;
    v56 -= v69;
    LODWORD(a8) = 1.0;
    unsigned int v25 = -1;
  }
}

uint64_t argb32_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v72 = *(_DWORD *)(result + 188);
  uint64_t v10 = *(void *)(result + 152) - 4;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v12 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = 0xFF00000000000000;
  }
  unint64_t v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v73 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_37;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v72 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_37;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v72 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v73) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v73 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v72;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 4;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_29;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v74;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_37;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v72;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_29:
  if (v24 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v34 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v35 = v29 >> 32;
  unint64_t v36 = v34 + 8 * v35;
  uint64_t v37 = *(unint64_t **)(result + 32);
  if (v14 >= v36) {
    float32x2_t v38 = (unint64_t *)(v34 + 8 * v35);
  }
  else {
    float32x2_t v38 = (unint64_t *)v14;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unint64_t **)(result + 32);
  }
  unint64_t v39 = *v38;
  if (!v5) {
    goto LABEL_69;
  }
  unsigned int v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_40:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      int v59 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59) {
        int v59 = (unint64_t *)v14;
      }
      if (v59 < v37) {
        int v59 = v37;
      }
      unint64_t v60 = interpolate_16161616_21355[v42];
      char v61 = v42 + 1;
      unint64_t v57 = v39 - ((v60 & v39) >> v61);
      unint64_t v62 = (v60 & *v59) >> v61;
LABEL_68:
      unint64_t v39 = v57 + v62;
      break;
    case 2:
      uint64_t v63 = (unint64_t *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 53));
      if (v14 < (unint64_t)v63) {
        uint64_t v63 = (unint64_t *)v14;
      }
      if (v63 < v37) {
        uint64_t v63 = v37;
      }
      int v64 = (v40 >> 28) & 3;
      uint64_t v65 = interpolate_16161616_21355[v64];
      char v56 = v64 + 1;
      unint64_t v57 = v39 - ((v65 & v39) >> v56);
      unint64_t v58 = v65 & *v63;
LABEL_67:
      unint64_t v62 = v58 >> v56;
      goto LABEL_68;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v40) << 56;
      float32x2_t v44 = (unint64_t *)(v36 + (v43 >> 53));
      if (v14 < (unint64_t)v44) {
        float32x2_t v44 = (unint64_t *)v14;
      }
      if (v44 < v37) {
        float32x2_t v44 = v37;
      }
      unint64_t v45 = *v44;
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46) {
        float32x2_t v47 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      }
      else {
        float32x2_t v47 = (unint64_t *)v14;
      }
      if (v47 < v37) {
        float32x2_t v47 = v37;
      }
      unint64_t v48 = *v47;
      float v49 = (unint64_t *)(v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49) {
        float v49 = (unint64_t *)v14;
      }
      if (v49 < v37) {
        float v49 = v37;
      }
      unint64_t v50 = interpolate_16161616_21355[v42];
      char v51 = v42 + 1;
      unint64_t v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      unint64_t v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      int v54 = (v40 >> 28) & 3;
      unint64_t v55 = interpolate_16161616_21355[v54];
      char v56 = v54 + 1;
      unint64_t v57 = v52 - ((v52 & v55) >> v56);
      unint64_t v58 = v53 & v55;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  a3 += v9;
  uint64_t v68 = v7 - a3;
  a2 += v8;
  uint64_t v69 = v74 - a2;
  while (1)
  {
    *(_DWORD *)(v10 + 4 + 4 * v66) = BYTE5(v39) | (BYTE1(v39) << 16) | (BYTE3(v39) << 8) | ((v39 | v13) >> 32) & 0xFF000000;
    *(unsigned char *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v68 | v69 | (a3 - v6) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = v10 - v67 + 4;
      v11 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v70 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v36 = v70 + 8 * (a2 >> 32);
    uint64_t v37 = *(unint64_t **)(result + 32);
    if (v14 >= v36) {
      uint64_t v71 = (unint64_t *)(v70 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v71 = (unint64_t *)v14;
    }
    if (v71 < v37) {
      uint64_t v71 = *(unint64_t **)(result + 32);
    }
    unint64_t v39 = *v71;
    if (v5)
    {
      unsigned int v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        uint64_t v10 = v10 - v67 + 4;
        v11 += v66 + 1;
        a4 += ~v66;
        unsigned int v24 = -1;
        goto LABEL_40;
      }
    }
    v67 -= 4;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    unsigned int v24 = -1;
  }
}

uint64_t argb32_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v72 = *(void *)(result + 88);
  uint64_t v7 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  int v70 = *(_DWORD *)(result + 188);
  uint64_t v9 = *(void *)(result + 152) - 4;
  uint64_t v10 = *(void *)(result + 144) - 1;
  uint64_t v11 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = 0xFF00000000000000;
  }
  unint64_t v13 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v71 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v72)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v71;
        uint64_t v26 = v73;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v72;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_37;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v71;
        uint64_t v26 = v73;
        unsigned int v23 = v70 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v6 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_37;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v71;
      uint64_t v26 = v73;
      unsigned int v23 = v70 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v25 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v70;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v7;
    a3 += v8;
    v9 += 4;
    *(unsigned char *)++uint64_t v10 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v26)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v26;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v70;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v23 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v11 + SHIDWORD(v24) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 8 * v36;
  float32x2_t v38 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v37) {
    unint64_t v39 = (unsigned __int16 *)(v35 + 8 * v36);
  }
  else {
    unint64_t v39 = (unsigned __int16 *)v13;
  }
  if (v39 < v38) {
    unint64_t v39 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v22));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        int v59 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v13 < (unint64_t)v59) {
          int v59 = (unsigned __int16 *)v13;
        }
        if (v59 < v38) {
          int v59 = v38;
        }
        uint64_t v60 = interpolate_16161616_21355[v43];
        char v61 = v43 + 1;
        unint64_t v57 = v40 - ((v60 & v40) >> v61);
        unint64_t v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v60) >> v61;
LABEL_62:
        unint64_t v40 = v57 + v58;
        break;
      case 2:
        unint64_t v62 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
        if (v13 < (unint64_t)v62) {
          unint64_t v62 = (unsigned __int16 *)v13;
        }
        if (v62 < v38) {
          unint64_t v62 = v38;
        }
        int v63 = (v41 >> 28) & 3;
        unint64_t v40 = v40
            - ((interpolate_16161616_21355[v63] & v40) >> (v63 + 1))
            + (((((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16)) & interpolate_16161616_21355[v63]) >> (v63 + 1));
        break;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        unint64_t v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
        if (v13 < (unint64_t)v45) {
          unint64_t v45 = (unsigned __int16 *)v13;
        }
        if (v45 < v38) {
          unint64_t v45 = v38;
        }
        unint64_t v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v13 >= v47) {
          unint64_t v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          unint64_t v48 = (unsigned __int16 *)v13;
        }
        if (v48 < v38) {
          unint64_t v48 = v38;
        }
        unint64_t v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
        unint64_t v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
        if (v13 < (unint64_t)v50) {
          unint64_t v50 = (unsigned __int16 *)v13;
        }
        if (v50 < v38) {
          unint64_t v50 = v38;
        }
        uint64_t v51 = interpolate_16161616_21355[v43];
        char v52 = v43 + 1;
        unint64_t v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
        unint64_t v54 = v46
            - ((v51 & v46) >> v52)
            + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52);
        int v55 = (v41 >> 28) & 3;
        uint64_t v56 = interpolate_16161616_21355[v55];
        LOBYTE(v55) = v55 + 1;
        unint64_t v57 = v53 - ((v53 & v56) >> v55);
        unint64_t v58 = (v54 & v56) >> v55;
        goto LABEL_62;
    }
  }
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  a3 += v8;
  uint64_t v66 = v72 - a3;
  a2 += v7;
  uint64_t v67 = v73 - a2;
  while (1)
  {
    *(_DWORD *)(v9 + 4 + 4 * v65) = BYTE5(v40) | (BYTE1(v40) << 16) | (BYTE3(v40) << 8) | ((v40 | v12) >> 32) & 0xFF000000;
    *(unsigned char *)(v10 + 1 + v65) = v23 >> 22;
    if (a4 - 1 == v65) {
      return result;
    }
    if (((v66 | v67 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v10 += v65 + 1;
      uint64_t v9 = v9 - v64 + 4;
      a4 += ~v65;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v68 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v68 + 8 * (a2 >> 32);
    float32x2_t v38 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v37) {
      uint64_t v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v69 = (unsigned __int16 *)v13;
    }
    if (v69 < v38) {
      uint64_t v69 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v10 += v65 + 1;
        uint64_t v9 = v9 - v64 + 4;
        a4 += ~v65;
        unsigned int v23 = -1;
        goto LABEL_40;
      }
    }
    ++v65;
    v64 -= 4;
    a3 += v8;
    v66 -= v8;
    a2 += v7;
    v67 -= v7;
    unsigned int v23 = -1;
  }
}

uint64_t argb32_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v69 = *(void *)(result + 64);
  uint64_t v70 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v68 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v69;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v69;
        unsigned int v23 = v68 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v69;
      unsigned int v23 = v68 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v25 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v68;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v70)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v70;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v68;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned int **)(result + 32);
  if (v13 >= v36) {
    float32x2_t v38 = (unsigned int *)(v35 + 6 * (int)v34);
  }
  else {
    float32x2_t v38 = (unsigned int *)v13;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unsigned int **)(result + 32);
  }
  unint64_t v39 = *v38 | ((unint64_t)*((unsigned __int16 *)v38 + 2) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      unint64_t v57 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57) {
        unint64_t v57 = (unsigned int *)v13;
      }
      if (v57 < v37) {
        unint64_t v57 = v37;
      }
      uint64_t v58 = interpolate_16161616_21355[v42];
      char v59 = v42 + 1;
      unint64_t v56 = v39 - ((v58 & v39) >> v59);
      unint64_t v60 = ((*v57 | ((unint64_t)*((unsigned __int16 *)v57 + 2) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      unint64_t v39 = v56 + v60;
      break;
    case 2:
      char v61 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61) {
        char v61 = (unsigned int *)v13;
      }
      if (v61 < v37) {
        char v61 = v37;
      }
      unint64_t v52 = *v61 | ((unint64_t)*((unsigned __int16 *)v61 + 2) << 32) | 0xFFFF000000000000;
      int v62 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v62];
      char v55 = v62 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      unint64_t v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      int v43 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43) {
        int v43 = (unsigned int *)v13;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = *v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45) {
        unint64_t v46 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned int *)v13;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = *v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned int *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48) {
        unint64_t v48 = (unsigned int *)v13;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + (((*v48 | ((unint64_t)*((unsigned __int16 *)v48 + 2) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v10;
  uint64_t v65 = v8 - a3;
  a2 += v9;
  uint64_t v66 = v70 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = BYTE5(v39) | HIDWORD(v39) & 0xFF000000 | (BYTE1(v39) << 16) | (BYTE3(v39) << 8);
    *(unsigned char *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      uint64_t v11 = v11 - v63 + 4;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v36 = v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned int **)(result + 32);
    if (v13 >= v36) {
      uint64_t v67 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v5 + 6 * SHIDWORD(a2));
    }
    else {
      uint64_t v67 = (unsigned int *)v13;
    }
    if (v67 < v37) {
      uint64_t v67 = *(unsigned int **)(result + 32);
    }
    unint64_t v39 = *v67 | ((unint64_t)*((unsigned __int16 *)v67 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        uint64_t v11 = v11 - v63 + 4;
        a4 += ~v64;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t argb32_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v70 = *(void *)(result + 64);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v69 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v70;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v70;
        unsigned int v23 = v69 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v70;
      unsigned int v23 = v69 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v25 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v69;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v71)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v71;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v69;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v36) {
    float32x2_t v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  }
  else {
    float32x2_t v38 = (unsigned __int16 *)v13;
  }
  if (v38 < v37) {
    float32x2_t v38 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      unint64_t v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57) {
        unint64_t v57 = (unsigned __int16 *)v13;
      }
      if (v57 < v37) {
        unint64_t v57 = v37;
      }
      uint64_t v58 = interpolate_16161616_21355[v42];
      char v59 = v42 + 1;
      unint64_t v56 = v39 - ((v58 & v39) >> v59);
      unint64_t v60 = (((bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      unint64_t v39 = v56 + v60;
      break;
    case 2:
      char v61 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61) {
        char v61 = (unsigned __int16 *)v13;
      }
      if (v61 < v37) {
        char v61 = v37;
      }
      unint64_t v52 = (bswap32(*v61) >> 16) | ((unint64_t)(bswap32(v61[1]) >> 16) << 16) | ((unint64_t)(bswap32(v61[2]) >> 16) << 32) | 0xFFFF000000000000;
      int v62 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v62];
      char v55 = v62 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      unint64_t v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      int v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43) {
        int v43 = (unsigned __int16 *)v13;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45) {
        unint64_t v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned __int16 *)v13;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48) {
        unint64_t v48 = (unsigned __int16 *)v13;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v10;
  uint64_t v65 = v8 - a3;
  a2 += v9;
  uint64_t v66 = v71 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = BYTE5(v39) | HIDWORD(v39) & 0xFF000000 | (BYTE1(v39) << 16) | (BYTE3(v39) << 8);
    *(unsigned char *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v70)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      uint64_t v11 = v11 - v63 + 4;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v67 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v36 = v67 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v36) {
      int v68 = (unsigned __int16 *)(v67 + 6 * SHIDWORD(a2));
    }
    else {
      int v68 = (unsigned __int16 *)v13;
    }
    if (v68 < v37) {
      int v68 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v39 = (bswap32(*v68) >> 16) | ((unint64_t)(bswap32(v68[1]) >> 16) << 16) | ((unint64_t)(bswap32(v68[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        uint64_t v11 = v11 - v63 + 4;
        a4 += ~v64;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t argb32_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v88 = *(void *)(result + 88);
  uint64_t v101 = *(void *)(result + 120);
  uint64_t v102 = *(void *)(result + 112);
  uint64_t v8 = (int *)(*(void *)(result + 152) - 4);
  uint64_t v91 = *(void *)(result + 144) - 1;
  uint64_t v9 = 0xFF00000000;
  if (v6) {
    uint64_t v9 = 0;
  }
  uint64_t v96 = v9;
  int v10 = *(_DWORD *)(result + 260) - 1;
  int v99 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  uint64_t v11 = *(unsigned int *)(result + 256);
  int v86 = *(_DWORD *)(result + 188);
  int v93 = *(_DWORD *)(result + 28);
  long long v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  unint64_t v100 = v95 + (v10 * v99) + 4 * v11 - 8;
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v90 = *(void *)(result + 72);
  uint64_t v97 = *(void *)(result + 40);
  uint64_t v98 = result;
  while (1)
  {
    if (a3 >= v90)
    {
      if (a3 <= v88)
      {
        uint64_t v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        uint64_t v24 = a3;
        int v15 = a4;
        uint64_t v16 = v89;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v88;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        int v15 = a4;
        uint64_t v16 = v89;
        if (v20 < 1) {
          goto LABEL_40;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v23 = v86 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v12 = *(void *)(result + 216);
      uint64_t v13 = v90 - *(void *)(result + 224);
      uint64_t v14 = a3 - v13 + (v12 >> 1);
      int v15 = a4;
      uint64_t v16 = v89;
      if (v14 < 1) {
        goto LABEL_40;
      }
      if (v14 >= v12) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v14) >> 32;
      }
      unsigned int v23 = v86 | v17;
      uint64_t v24 = v13 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v28 = a2;
      }
      else
      {
        uint64_t v30 = *(void *)(result + 192);
        uint64_t v31 = *(void *)(result + 200) + v87;
        uint64_t v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1) {
          goto LABEL_40;
        }
        if (v32 < v30) {
          unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v86;
        }
        uint64_t v28 = v31 - 0x1000000;
        uint64_t v29 = 28;
      }
    }
    else
    {
      uint64_t v25 = *(void *)(result + 192);
      uint64_t v26 = v16 - *(void *)(result + 200);
      uint64_t v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1) {
        goto LABEL_40;
      }
      if (v27 < v25) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v86;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
    }
    if (v23 >= 0x400000) {
      break;
    }
LABEL_40:
    int v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_41:
    a4 = v42;
    if (!v42) {
      return result;
    }
  }
  uint64_t v33 = v24 >> 32;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 4 * (v28 >> 32);
  unint64_t v36 = *(unsigned int **)(result + 32);
  unint64_t v37 = (unsigned int *)v100;
  if (v100 >= v35) {
    unint64_t v37 = (unsigned int *)v35;
  }
  if (v37 < v36) {
    unint64_t v37 = *(unsigned int **)(result + 32);
  }
  unint64_t v38 = *v37;
  if (v6)
  {
    unint64_t v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    unsigned int v40 = *(unsigned __int8 **)(result + 40);
    int v41 = v94;
    unint64_t v92 = v39;
    if ((unint64_t)v94 >= v39) {
      int v41 = (unsigned __int8 *)v39;
    }
    if (v41 >= v40) {
      unsigned int v40 = v41;
    }
    v38 |= (unint64_t)*v40 << 32;
    if (!v7) {
      goto LABEL_102;
    }
  }
  else
  {
    unint64_t v92 = 0;
    if (!v7) {
      goto LABEL_102;
    }
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_46:
  int v44 = v43 & 0xF;
  int v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    uint64_t v67 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67) {
      uint64_t v67 = (unsigned int *)v100;
    }
    if (v67 >= v36) {
      unint64_t v36 = v67;
    }
    unint64_t v68 = *v36;
    if (v6)
    {
      int v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69) {
        int v69 = v94;
      }
      if ((unint64_t)v69 < *(void *)(result + 40)) {
        int v69 = *(unsigned __int8 **)(result + 40);
      }
      v68 |= (unint64_t)*v69 << 32;
    }
    uint64_t v70 = interpolate_cif10a[v45];
    char v71 = v45 + 1;
    unint64_t v65 = v38 - ((v70 & v38) >> v71);
    unint64_t v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      uint64_t v73 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 54));
      if (v100 < (unint64_t)v73) {
        uint64_t v73 = (unsigned int *)v100;
      }
      if (v73 >= v36) {
        unint64_t v36 = v73;
      }
      uint64_t v74 = *v36;
      if (v6)
      {
        uint64_t v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75) {
          uint64_t v75 = v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          uint64_t v75 = *(unsigned __int8 **)(result + 40);
        }
        v74 |= (unint64_t)*v75 << 32;
      }
      int v76 = (v43 >> 28) & 3;
      uint64_t v77 = interpolate_cif10a[v76];
      char v64 = v76 + 1;
      unint64_t v65 = v38 - ((v77 & v38) >> v64);
      unint64_t v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3) {
        goto LABEL_102;
      }
      int64_t v46 = (unint64_t)HIWORD(v43) << 56;
      unint64_t v47 = (unsigned int *)(v35 + (v46 >> 54));
      if (v100 < (unint64_t)v47) {
        unint64_t v47 = (unsigned int *)v100;
      }
      if (v47 < v36) {
        unint64_t v47 = v36;
      }
      unint64_t v48 = *v47;
      unint64_t v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49) {
        char v50 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      }
      else {
        char v50 = (unsigned int *)v100;
      }
      if (v50 < v36) {
        char v50 = v36;
      }
      unint64_t v51 = *v50;
      unint64_t v52 = (unsigned int *)(v49 + (v46 >> 54));
      if (v100 < (unint64_t)v52) {
        unint64_t v52 = (unsigned int *)v100;
      }
      if (v52 >= v36) {
        unint64_t v36 = v52;
      }
      unint64_t v53 = *v36;
      if (v6)
      {
        uint64_t v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        unint64_t v55 = *(void *)(result + 40);
        if (v94 < v54) {
          uint64_t v54 = v94;
        }
        if ((unint64_t)v54 < v55) {
          uint64_t v54 = *(unsigned __int8 **)(result + 40);
        }
        v48 |= (unint64_t)*v54 << 32;
        unint64_t v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56) {
          unint64_t v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        }
        else {
          unint64_t v57 = v94;
        }
        if ((unint64_t)v57 < v55) {
          unint64_t v57 = *(unsigned __int8 **)(result + 40);
        }
        v51 |= (unint64_t)*v57 << 32;
        uint64_t v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58) {
          uint64_t v58 = v94;
        }
        if ((unint64_t)v58 < v55) {
          uint64_t v58 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= (unint64_t)*v58 << 32;
      }
      uint64_t v59 = interpolate_cif10a[v45];
      char v60 = v45 + 1;
      unint64_t v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      int v62 = (v43 >> 28) & 3;
      unint64_t v63 = interpolate_cif10a[v62];
      char v64 = v62 + 1;
      unint64_t v65 = v61 - ((v61 & v63) >> v64);
      unint64_t v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    unint64_t v72 = v66 >> v64;
  }
  unint64_t v38 = v65 + v72;
LABEL_102:
  uint64_t v78 = 0;
  ++v8;
  int v85 = v15;
  int v79 = v15 - 1;
  a3 += v101;
  uint64_t v80 = v88 - a3;
  a2 += v102;
  uint64_t v81 = v87 - a2;
  while (1)
  {
    CMYK32_14616(v8, v38 | v96);
    *(unsigned char *)(v91 + 1 + v78) = v23 >> 22;
    uint64_t v6 = v97;
    CFCalendarRef result = v98;
    if (v79 == v78) {
      return result;
    }
    if ((v80 | v81 | (a3 - v90) | (a2 - v89)) < 0)
    {
      v91 += v78 + 1;
      int v42 = ~v78 + v85;
      goto LABEL_41;
    }
    unint64_t v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32);
    unint64_t v36 = *(unsigned int **)(v98 + 32);
    uint64_t v82 = (unsigned int *)v100;
    if (v100 >= v35) {
      uint64_t v82 = (unsigned int *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32));
    }
    if (v82 < v36) {
      uint64_t v82 = *(unsigned int **)(v98 + 32);
    }
    unint64_t v38 = *v82;
    if (v97)
    {
      long long v83 = *(unsigned __int8 **)(v98 + 40);
      unint64_t v84 = (unint64_t)v94;
      unint64_t v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92) {
        unint64_t v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      }
      if (v84 >= (unint64_t)v83) {
        long long v83 = (unsigned __int8 *)v84;
      }
      v38 |= (unint64_t)*v83 << 32;
    }
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        int v15 = ~v78 + v85;
        unsigned int v23 = -1;
        goto LABEL_46;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    unsigned int v23 = -1;
  }
}

int *CMYK32_14616(int *result, uint64_t a2)
{
  int v2 = BYTE4(a2) - (BYTE3(a2) + a2);
  int v3 = BYTE4(a2) - (BYTE2(a2) + a2);
  *CFCalendarRef result = (HIDWORD(a2) << 24) | ((v2 & ~(v2 >> 31)) << 16) | ((v3 & ~(v3 >> 31)) << 8) | (BYTE4(a2) - (BYTE1(a2) + a2)) & ~((BYTE4(a2) - (BYTE1(a2) + a2)) >> 31);
  return result;
}

uint64_t argb32_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v88 = *(void *)(result + 88);
  uint64_t v101 = *(void *)(result + 120);
  uint64_t v102 = *(void *)(result + 112);
  uint64_t v8 = (int *)(*(void *)(result + 152) - 4);
  uint64_t v91 = *(void *)(result + 144) - 1;
  uint64_t v9 = 0xFF00000000;
  if (v6) {
    uint64_t v9 = 0;
  }
  uint64_t v96 = v9;
  int v10 = *(_DWORD *)(result + 260) - 1;
  int v99 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  uint64_t v11 = *(unsigned int *)(result + 256);
  int v86 = *(_DWORD *)(result + 188);
  int v93 = *(_DWORD *)(result + 28);
  long long v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  unint64_t v100 = v95 + (v10 * v99) + 4 * v11 - 8;
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v90 = *(void *)(result + 72);
  uint64_t v97 = *(void *)(result + 40);
  uint64_t v98 = result;
  while (1)
  {
    if (a3 >= v90)
    {
      if (a3 <= v88)
      {
        uint64_t v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        uint64_t v24 = a3;
        int v15 = a4;
        uint64_t v16 = v89;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v88;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        int v15 = a4;
        uint64_t v16 = v89;
        if (v20 < 1) {
          goto LABEL_40;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v23 = v86 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v12 = *(void *)(result + 216);
      uint64_t v13 = v90 - *(void *)(result + 224);
      uint64_t v14 = a3 - v13 + (v12 >> 1);
      int v15 = a4;
      uint64_t v16 = v89;
      if (v14 < 1) {
        goto LABEL_40;
      }
      if (v14 >= v12) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v14) >> 32;
      }
      unsigned int v23 = v86 | v17;
      uint64_t v24 = v13 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v28 = a2;
      }
      else
      {
        uint64_t v30 = *(void *)(result + 192);
        uint64_t v31 = *(void *)(result + 200) + v87;
        uint64_t v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1) {
          goto LABEL_40;
        }
        if (v32 < v30) {
          unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v86;
        }
        uint64_t v28 = v31 - 0x1000000;
        uint64_t v29 = 28;
      }
    }
    else
    {
      uint64_t v25 = *(void *)(result + 192);
      uint64_t v26 = v16 - *(void *)(result + 200);
      uint64_t v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1) {
        goto LABEL_40;
      }
      if (v27 < v25) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v86;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
    }
    if (v23 >= 0x400000) {
      break;
    }
LABEL_40:
    int v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_41:
    a4 = v42;
    if (!v42) {
      return result;
    }
  }
  uint64_t v33 = v24 >> 32;
  uint64_t v34 = v28 >> 32;
  unint64_t v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 4 * (v28 >> 32);
  unint64_t v36 = *(unsigned int **)(result + 32);
  unint64_t v37 = (unsigned int *)v100;
  if (v100 >= v35) {
    unint64_t v37 = (unsigned int *)v35;
  }
  if (v37 < v36) {
    unint64_t v37 = *(unsigned int **)(result + 32);
  }
  unint64_t v38 = bswap32(*v37);
  if (v6)
  {
    unint64_t v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    unsigned int v40 = *(unsigned __int8 **)(result + 40);
    int v41 = v94;
    unint64_t v92 = v39;
    if ((unint64_t)v94 >= v39) {
      int v41 = (unsigned __int8 *)v39;
    }
    if (v41 >= v40) {
      unsigned int v40 = v41;
    }
    v38 |= (unint64_t)*v40 << 32;
    if (!v7) {
      goto LABEL_102;
    }
  }
  else
  {
    unint64_t v92 = 0;
    if (!v7) {
      goto LABEL_102;
    }
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_46:
  int v44 = v43 & 0xF;
  int v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    uint64_t v67 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67) {
      uint64_t v67 = (unsigned int *)v100;
    }
    if (v67 >= v36) {
      unint64_t v36 = v67;
    }
    unint64_t v68 = bswap32(*v36);
    if (v6)
    {
      int v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69) {
        int v69 = v94;
      }
      if ((unint64_t)v69 < *(void *)(result + 40)) {
        int v69 = *(unsigned __int8 **)(result + 40);
      }
      v68 |= (unint64_t)*v69 << 32;
    }
    uint64_t v70 = interpolate_cif10a[v45];
    char v71 = v45 + 1;
    unint64_t v65 = v38 - ((v70 & v38) >> v71);
    unint64_t v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      uint64_t v73 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 54));
      if (v100 < (unint64_t)v73) {
        uint64_t v73 = (unsigned int *)v100;
      }
      if (v73 >= v36) {
        unint64_t v36 = v73;
      }
      uint64_t v74 = bswap32(*v36);
      if (v6)
      {
        uint64_t v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75) {
          uint64_t v75 = v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          uint64_t v75 = *(unsigned __int8 **)(result + 40);
        }
        v74 |= (unint64_t)*v75 << 32;
      }
      int v76 = (v43 >> 28) & 3;
      uint64_t v77 = interpolate_cif10a[v76];
      char v64 = v76 + 1;
      unint64_t v65 = v38 - ((v77 & v38) >> v64);
      unint64_t v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3) {
        goto LABEL_102;
      }
      int64_t v46 = (unint64_t)HIWORD(v43) << 56;
      unint64_t v47 = (unsigned int *)(v35 + (v46 >> 54));
      if (v100 < (unint64_t)v47) {
        unint64_t v47 = (unsigned int *)v100;
      }
      if (v47 < v36) {
        unint64_t v47 = v36;
      }
      unint64_t v48 = bswap32(*v47);
      unint64_t v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49) {
        char v50 = (unsigned int *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      }
      else {
        char v50 = (unsigned int *)v100;
      }
      if (v50 < v36) {
        char v50 = v36;
      }
      unint64_t v51 = bswap32(*v50);
      unint64_t v52 = (unsigned int *)(v49 + (v46 >> 54));
      if (v100 < (unint64_t)v52) {
        unint64_t v52 = (unsigned int *)v100;
      }
      if (v52 >= v36) {
        unint64_t v36 = v52;
      }
      unint64_t v53 = bswap32(*v36);
      if (v6)
      {
        uint64_t v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        unint64_t v55 = *(void *)(result + 40);
        if (v94 < v54) {
          uint64_t v54 = v94;
        }
        if ((unint64_t)v54 < v55) {
          uint64_t v54 = *(unsigned __int8 **)(result + 40);
        }
        v48 |= (unint64_t)*v54 << 32;
        unint64_t v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56) {
          unint64_t v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        }
        else {
          unint64_t v57 = v94;
        }
        if ((unint64_t)v57 < v55) {
          unint64_t v57 = *(unsigned __int8 **)(result + 40);
        }
        v51 |= (unint64_t)*v57 << 32;
        uint64_t v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58) {
          uint64_t v58 = v94;
        }
        if ((unint64_t)v58 < v55) {
          uint64_t v58 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= (unint64_t)*v58 << 32;
      }
      uint64_t v59 = interpolate_cif10a[v45];
      char v60 = v45 + 1;
      unint64_t v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      int v62 = (v43 >> 28) & 3;
      unint64_t v63 = interpolate_cif10a[v62];
      char v64 = v62 + 1;
      unint64_t v65 = v61 - ((v61 & v63) >> v64);
      unint64_t v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    unint64_t v72 = v66 >> v64;
  }
  unint64_t v38 = v65 + v72;
LABEL_102:
  uint64_t v78 = 0;
  ++v8;
  int v85 = v15;
  int v79 = v15 - 1;
  a3 += v101;
  uint64_t v80 = v88 - a3;
  a2 += v102;
  uint64_t v81 = v87 - a2;
  while (1)
  {
    CMYK32_14616(v8, v38 | v96);
    *(unsigned char *)(v91 + 1 + v78) = v23 >> 22;
    uint64_t v6 = v97;
    CFCalendarRef result = v98;
    if (v79 == v78) {
      return result;
    }
    if ((v80 | v81 | (a3 - v90) | (a2 - v89)) < 0)
    {
      v91 += v78 + 1;
      int v42 = ~v78 + v85;
      goto LABEL_41;
    }
    unint64_t v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32);
    unint64_t v36 = *(unsigned int **)(v98 + 32);
    uint64_t v82 = (unsigned int *)v100;
    if (v100 >= v35) {
      uint64_t v82 = (unsigned int *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 4 * (a2 >> 32));
    }
    if (v82 < v36) {
      uint64_t v82 = *(unsigned int **)(v98 + 32);
    }
    unint64_t v38 = bswap32(*v82);
    if (v97)
    {
      long long v83 = *(unsigned __int8 **)(v98 + 40);
      unint64_t v84 = (unint64_t)v94;
      unint64_t v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92) {
        unint64_t v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      }
      if (v84 >= (unint64_t)v83) {
        long long v83 = (unsigned __int8 *)v84;
      }
      v38 |= (unint64_t)*v83 << 32;
    }
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        int v15 = ~v78 + v85;
        unsigned int v23 = -1;
        goto LABEL_46;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    unsigned int v23 = -1;
  }
}

uint64_t argb32_sample_ARGB32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v108 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v108 = v5 % v6;
    }
  }
  else
  {
    uint64_t v108 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v107 = v11;
  }
  else
  {
    uint64_t v107 = 0;
  }
  uint64_t v103 = *(void *)(result + 80);
  uint64_t v104 = *(void *)(result + 64);
  uint64_t v105 = *(void *)(result + 88);
  uint64_t v106 = *(void *)(result + 72);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  int v102 = *(_DWORD *)(result + 188);
  unint64_t v15 = v9 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v16 = -*(void *)(result + 64);
  uint64_t v17 = -*(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v106)
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v106 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_55;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v28 = v102 | v21;
        uint64_t v29 = v19 + 0x1000000;
        uint64_t v26 = a3 - (v19 + 0x1000000);
        uint64_t v27 = 512;
        goto LABEL_25;
      }
      if (a3 <= v105)
      {
        uint64_t v26 = 0;
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        uint64_t v29 = a3;
LABEL_25:
        uint64_t v30 = v104;
        goto LABEL_28;
      }
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = *(void *)(result + 224) + v105;
      uint64_t v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_55;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v30 = v104;
      unsigned int v28 = v102 | v25;
      uint64_t v29 = v23 - 0x1000000;
      uint64_t v26 = a3 - (v23 - 0x1000000);
      uint64_t v27 = 448;
LABEL_28:
      if (a2 >= v30) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v30 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v102;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = a2 - (v32 + 0x1000000);
        uint64_t v36 = 32;
        goto LABEL_39;
      }
LABEL_55:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v103)
    {
      uint64_t v35 = 0;
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_39;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v103;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_55;
    }
    if (v39 < v37) {
      unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v102;
    }
    uint64_t v34 = v38 - 0x1000000;
    uint64_t v35 = a2 - (v38 - 0x1000000);
    uint64_t v36 = 28;
LABEL_39:
    if (v28 < 0x400000) {
      goto LABEL_55;
    }
    if (v6)
    {
      uint64_t v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      uint64_t v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7) {
        uint64_t v42 = v7;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v29 = v40 - v42;
      if (v41 >= v6) {
        uint64_t v43 = v6;
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    uint64_t v44 = v9 + SHIDWORD(v29) * (uint64_t)v4;
    uint64_t v45 = v34 >> 32;
    unint64_t v46 = v44 + 4 * v45;
    unint64_t v47 = *(unsigned int **)(result + 32);
    if (v15 >= v46) {
      unint64_t v48 = (unsigned int *)(v44 + 4 * v45);
    }
    else {
      unint64_t v48 = (unsigned int *)v15;
    }
    if (v48 < v47) {
      unint64_t v48 = *(unsigned int **)(result + 32);
    }
    unsigned int v49 = bswap32(*v48);
    if (!v8) {
      goto LABEL_104;
    }
    unsigned int v50 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_58:
    int v51 = v50 & 0xF;
    uint64_t v52 = v50 >> 8;
    int v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v77) = SBYTE1(v50);
        if (v6)
        {
          uint64_t v78 = v52 << 56;
          uint64_t v79 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v80 = v7 & (v79 >> 63);
          if (v80 + v79 >= v7) {
            uint64_t v81 = v7;
          }
          else {
            uint64_t v81 = 0;
          }
          uint64_t v77 = (v80 + (v78 >> 24) - v81) >> 32;
        }
        uint64_t v82 = (unsigned int *)(v46 + (int)v77 * (uint64_t)v4);
        if (v15 < (unint64_t)v82) {
          uint64_t v82 = (unsigned int *)v15;
        }
        if (v82 < v47) {
          uint64_t v82 = v47;
        }
        int v83 = interpolate_8888_21358[v53];
        char v84 = v53 + 1;
        unsigned int v75 = v49 - ((v83 & v49) >> v84);
        unsigned int v76 = (bswap32(*v82) & v83) >> v84;
        goto LABEL_93;
      case 2:
        uint64_t v85 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v86 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v87 = v6 & (v86 >> 63);
          if (v87 + v86 >= v6) {
            uint64_t v88 = v6;
          }
          else {
            uint64_t v88 = 0;
          }
          uint64_t v85 = (v87 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v88) >> 32;
        }
        uint64_t v89 = (unsigned int *)(v46 + 4 * v85);
        if (v15 < (unint64_t)v89) {
          uint64_t v89 = (unsigned int *)v15;
        }
        if (v89 < v47) {
          uint64_t v89 = v47;
        }
        unsigned int v49 = v49
            - ((interpolate_8888_21358[(v50 >> 28) & 3] & v49) >> (((v50 >> 28) & 3) + 1))
            + ((bswap32(*v89) & interpolate_8888_21358[(v50 >> 28) & 3]) >> (((v50 >> 28) & 3) + 1));
        break;
      case 3:
        int v101 = HIBYTE(v50) & 3;
        LODWORD(v54) = SBYTE1(v50);
        uint64_t v55 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v56 = v52 << 56;
          uint64_t v57 = v26 + (v56 >> 24);
          uint64_t v58 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v59 = v7 & (v57 >> 63);
          uint64_t v60 = v6 & (v58 >> 63);
          uint64_t v61 = v60 + v58;
          if (v59 + v57 >= v7) {
            uint64_t v62 = v7;
          }
          else {
            uint64_t v62 = 0;
          }
          if (v61 >= v6) {
            uint64_t v63 = v6;
          }
          else {
            uint64_t v63 = 0;
          }
          uint64_t v54 = (v59 + (v56 >> 24) - v62) >> 32;
          uint64_t v55 = (v60 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v63) >> 32;
        }
        char v64 = (unsigned int *)(v46 + 4 * v55);
        if (v15 < (unint64_t)v64) {
          char v64 = (unsigned int *)v15;
        }
        if (v64 < v47) {
          char v64 = v47;
        }
        unsigned int v65 = bswap32(*v64);
        unint64_t v66 = v46 + (int)v54 * (uint64_t)v4;
        if (v15 >= v66) {
          uint64_t v67 = (unsigned int *)(v46 + (int)v54 * (uint64_t)v4);
        }
        else {
          uint64_t v67 = (unsigned int *)v15;
        }
        if (v67 < v47) {
          uint64_t v67 = v47;
        }
        unsigned int v68 = bswap32(*v67);
        int v69 = (unsigned int *)(v66 + 4 * v55);
        if (v15 < (unint64_t)v69) {
          int v69 = (unsigned int *)v15;
        }
        if (v69 < v47) {
          int v69 = v47;
        }
        int v70 = interpolate_8888_21358[v101];
        unsigned int v71 = v49 - ((v70 & v49) >> (v101 + 1)) + ((v70 & v68) >> (v101 + 1));
        unsigned int v72 = v65 - ((v70 & v65) >> (v101 + 1)) + ((bswap32(*v69) & v70) >> (v101 + 1));
        int v73 = (v50 >> 28) & 3;
        int v74 = interpolate_8888_21358[v73];
        LOBYTE(v73) = v73 + 1;
        unsigned int v75 = v71 - ((v71 & v74) >> v73);
        unsigned int v76 = (v72 & v74) >> v73;
LABEL_93:
        unsigned int v49 = v75 + v76;
        break;
    }
LABEL_104:
    *(_DWORD *)(v12 + 4) = v49 | v14;
    *(unsigned char *)(v13 + 1) = v28 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v90 = 0;
    a2 += v5;
    uint64_t v91 = v103 - a2;
    a3 += v10;
    uint64_t v92 = v105 - a3;
    uint64_t v93 = -4;
    while (((v92 | v91 | (v17 + a3) | (v16 + a2)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v94 = (v7 & ((v26 + v107) >> 63)) + v26 + v107;
        uint64_t v95 = (v6 & ((v35 + v108) >> 63)) + v35 + v108;
        if (v94 >= v7) {
          uint64_t v96 = v7;
        }
        else {
          uint64_t v96 = 0;
        }
        uint64_t v97 = v94 - v96;
        if (v95 >= v6) {
          uint64_t v98 = v6;
        }
        else {
          uint64_t v98 = 0;
        }
        uint64_t v99 = v95 - v98;
        uint64_t v35 = v99;
        uint64_t v26 = v97;
      }
      else
      {
        uint64_t v99 = a2;
        HIDWORD(v97) = HIDWORD(a3);
      }
      unint64_t v46 = v9 + SHIDWORD(v97) * (uint64_t)v4 + 4 * (v99 >> 32);
      unint64_t v47 = *(unsigned int **)(result + 32);
      if (v15 >= v46) {
        unint64_t v100 = (unsigned int *)v46;
      }
      else {
        unint64_t v100 = (unsigned int *)v15;
      }
      if (v100 < v47) {
        unint64_t v100 = *(unsigned int **)(result + 32);
      }
      unsigned int v49 = bswap32(*v100);
      if (v8)
      {
        unsigned int v50 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v50 & 0xF) != 0)
        {
          v13 += v90 + 1;
          v12 -= v93;
          a4 += ~v90;
          unsigned int v28 = -1;
          goto LABEL_58;
        }
      }
      *(_DWORD *)(v12 + 4 * v90 + 8) = v49 | v14;
      *(unsigned char *)(v13 + v90++ + 2) = -1;
      v93 -= 4;
      a2 += v5;
      v91 -= v5;
      a3 += v10;
      v92 -= v10;
      if (a4 - 1 == v90) {
        return result;
      }
    }
    v13 += v90 + 1;
    v12 -= v93;
    a4 += ~v90;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v76 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  int v75 = *(_DWORD *)(result + 188);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = 255;
  }
  unint64_t v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          uint64_t v24 = (a3 >> 22) & 0x3C0;
          unsigned int v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          uint64_t v20 = *(void *)(result + 216);
          uint64_t v21 = *(void *)(result + 224) + v8;
          uint64_t v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1) {
            goto LABEL_37;
          }
          if (v22 >= v20) {
            LODWORD(v23) = 0x3FFFFFFF;
          }
          else {
            unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
          }
          unsigned int v25 = v75 | v23;
          uint64_t v26 = v21 - 0x1000000;
          uint64_t v24 = 448;
        }
      }
      else
      {
        uint64_t v16 = *(void *)(result + 216);
        uint64_t v17 = v7 - *(void *)(result + 224);
        uint64_t v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1) {
          goto LABEL_37;
        }
        if (v18 >= v16) {
          LODWORD(v19) = 0x3FFFFFFF;
        }
        else {
          unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
        }
        unsigned int v25 = v75 | v19;
        uint64_t v26 = v17 + 0x1000000;
        uint64_t v24 = 512;
      }
      if (a2 >= v6) {
        break;
      }
      uint64_t v27 = *(void *)(result + 192);
      uint64_t v28 = v6 - *(void *)(result + 200);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v75;
        }
        uint64_t v30 = v28 + 0x1000000;
        uint64_t v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v76)
    {
      uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v30 = a2;
      goto LABEL_29;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = *(void *)(result + 200) + v76;
    uint64_t v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1) {
      goto LABEL_37;
    }
    if (v34 < v32) {
      unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v75;
    }
    uint64_t v30 = v33 - 0x1000000;
    uint64_t v31 = 28;
LABEL_29:
    if (v25 < 0x400000) {
      goto LABEL_37;
    }
    uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    uint64_t v36 = v30 >> 32;
    unint64_t v37 = v35 + 4 * v36;
    uint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      uint64_t v39 = (unsigned int *)(v35 + 4 * v36);
    }
    else {
      uint64_t v39 = (unsigned int *)v15;
    }
    if (v39 < v38) {
      uint64_t v39 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = *v39;
    if (!v5) {
      goto LABEL_69;
    }
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        uint64_t v60 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v60) {
          uint64_t v60 = (unsigned int *)v15;
        }
        if (v60 < v38) {
          uint64_t v60 = v38;
        }
        unsigned int v61 = interpolate_8888_21358[v43];
        char v62 = v43 + 1;
        unsigned int v58 = v40 - ((v61 & v40) >> v62);
        unsigned int v63 = (v61 & *v60) >> v62;
        goto LABEL_68;
      case 2:
        char v64 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v64) {
          char v64 = (unsigned int *)v15;
        }
        if (v64 < v38) {
          char v64 = v38;
        }
        int v65 = (v41 >> 28) & 3;
        int v66 = interpolate_8888_21358[v65];
        char v57 = v65 + 1;
        unsigned int v58 = v40 - ((v66 & v40) >> v57);
        unsigned int v59 = v66 & *v64;
        goto LABEL_67;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        uint64_t v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45) {
          uint64_t v45 = (unsigned int *)v15;
        }
        if (v45 < v38) {
          uint64_t v45 = v38;
        }
        unsigned int v46 = *v45;
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47) {
          unint64_t v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          unint64_t v48 = (unsigned int *)v15;
        }
        if (v48 < v38) {
          unint64_t v48 = v38;
        }
        unsigned int v49 = *v48;
        unsigned int v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50) {
          unsigned int v50 = (unsigned int *)v15;
        }
        if (v50 < v38) {
          unsigned int v50 = v38;
        }
        unsigned int v51 = interpolate_8888_21358[v43];
        char v52 = v43 + 1;
        unsigned int v53 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        unsigned int v54 = v46 - ((v51 & v46) >> v52) + ((v51 & *v50) >> v52);
        int v55 = (v41 >> 28) & 3;
        int v56 = interpolate_8888_21358[v55];
        char v57 = v55 + 1;
        unsigned int v58 = v53 - ((v53 & v56) >> v57);
        unsigned int v59 = v54 & v56;
LABEL_67:
        unsigned int v63 = v59 >> v57;
LABEL_68:
        unsigned int v40 = v58 + v63;
        break;
    }
LABEL_69:
    HIDWORD(v67) = v40 | v14;
    LODWORD(v67) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v67 >> 8;
    *(unsigned char *)(v12 + 1) = v25 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v68 = 0;
    a2 += v9;
    uint64_t v69 = v76 - a2;
    a3 += v10;
    uint64_t v70 = v8 - a3;
    uint64_t v71 = -4;
    while (((v70 | v69 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      uint64_t v72 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      unint64_t v37 = v72 + 4 * (a2 >> 32);
      uint64_t v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37) {
        int v73 = (unsigned int *)(v72 + 4 * (a2 >> 32));
      }
      else {
        int v73 = (unsigned int *)v15;
      }
      if (v73 < v38) {
        int v73 = *(unsigned int **)(result + 32);
      }
      unsigned int v40 = *v73;
      if (v5)
      {
        unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v68 + 1;
          v11 -= v71;
          a4 += ~v68;
          unsigned int v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v74) = v40 | v14;
      LODWORD(v74) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v68 + 8) = v74 >> 8;
      *(unsigned char *)(v12 + v68++ + 2) = -1;
      v71 -= 4;
      a2 += v9;
      v69 -= v9;
      a3 += v10;
      v70 -= v10;
      if (a4 - 1 == v68) {
        return result;
      }
    }
    v12 += v68 + 1;
    v11 -= v71;
    a4 += ~v68;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  int v72 = *(_DWORD *)(result + 188);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = 255;
  }
  unint64_t v15 = v13 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v7)
      {
        if ((uint64_t)a3 <= v8)
        {
          uint64_t v24 = (a3 >> 22) & 0x3C0;
          unsigned int v25 = 0x3FFFFFFF;
          HIDWORD(v26) = HIDWORD(a3);
        }
        else
        {
          uint64_t v20 = *(void *)(result + 216);
          uint64_t v21 = *(void *)(result + 224) + v8;
          uint64_t v22 = v21 - a3 + (v20 >> 1);
          if (v22 < 1) {
            goto LABEL_37;
          }
          if (v22 >= v20) {
            LODWORD(v23) = 0x3FFFFFFF;
          }
          else {
            unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
          }
          unsigned int v25 = v72 | v23;
          uint64_t v26 = v21 - 0x1000000;
          uint64_t v24 = 448;
        }
      }
      else
      {
        uint64_t v16 = *(void *)(result + 216);
        uint64_t v17 = v7 - *(void *)(result + 224);
        uint64_t v18 = a3 - v17 + (v16 >> 1);
        if (v18 < 1) {
          goto LABEL_37;
        }
        if (v18 >= v16) {
          LODWORD(v19) = 0x3FFFFFFF;
        }
        else {
          unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
        }
        unsigned int v25 = v72 | v19;
        uint64_t v26 = v17 + 0x1000000;
        uint64_t v24 = 512;
      }
      if (a2 >= v6) {
        break;
      }
      uint64_t v27 = *(void *)(result + 192);
      uint64_t v28 = v6 - *(void *)(result + 200);
      uint64_t v29 = a2 - v28 + (v27 >> 1);
      if (v29 >= 1)
      {
        if (v29 < v27) {
          unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v72;
        }
        uint64_t v30 = v28 + 0x1000000;
        uint64_t v31 = 32;
        goto LABEL_29;
      }
LABEL_37:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v73)
    {
      uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v30 = a2;
      goto LABEL_29;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = *(void *)(result + 200) + v73;
    uint64_t v34 = v33 - a2 + (v32 >> 1);
    if (v34 < 1) {
      goto LABEL_37;
    }
    if (v34 < v32) {
      unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v72;
    }
    uint64_t v30 = v33 - 0x1000000;
    uint64_t v31 = 28;
LABEL_29:
    if (v25 < 0x400000) {
      goto LABEL_37;
    }
    uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
    uint64_t v36 = v30 >> 32;
    unint64_t v37 = v35 + 4 * v36;
    uint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      uint64_t v39 = (unsigned int *)(v35 + 4 * v36);
    }
    else {
      uint64_t v39 = (unsigned int *)v15;
    }
    if (v39 < v38) {
      uint64_t v39 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = bswap32(*v39);
    if (!v5) {
      goto LABEL_69;
    }
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        char v57 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v15 < (unint64_t)v57) {
          char v57 = (unsigned int *)v15;
        }
        if (v57 < v38) {
          char v57 = v38;
        }
        int v58 = interpolate_8888_21358[v43];
        char v59 = v43 + 1;
        unsigned int v60 = v40 - ((v58 & v40) >> v59);
        unsigned int v61 = (bswap32(*v57) & v58) >> v59;
        goto LABEL_68;
      case 2:
        char v62 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
        if (v15 < (unint64_t)v62) {
          char v62 = (unsigned int *)v15;
        }
        if (v62 < v38) {
          char v62 = v38;
        }
        unsigned int v53 = bswap32(*v62);
        int v54 = (v41 >> 28) & 3;
        int v55 = interpolate_8888_21358[v54];
        unsigned int v56 = v55 & v40;
        goto LABEL_67;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        uint64_t v45 = (unsigned int *)(v37 + (v44 >> 54));
        if (v15 < (unint64_t)v45) {
          uint64_t v45 = (unsigned int *)v15;
        }
        if (v45 < v38) {
          uint64_t v45 = v38;
        }
        unsigned int v46 = bswap32(*v45);
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v15 >= v47) {
          unint64_t v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          unint64_t v48 = (unsigned int *)v15;
        }
        if (v48 < v38) {
          unint64_t v48 = v38;
        }
        unsigned int v49 = bswap32(*v48);
        unsigned int v50 = (unsigned int *)(v47 + (v44 >> 54));
        if (v15 < (unint64_t)v50) {
          unsigned int v50 = (unsigned int *)v15;
        }
        if (v50 < v38) {
          unsigned int v50 = v38;
        }
        int v51 = interpolate_8888_21358[v43];
        char v52 = v43 + 1;
        unsigned int v40 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
        unsigned int v53 = v46 - ((v51 & v46) >> v52) + ((bswap32(*v50) & v51) >> v52);
        int v54 = (v41 >> 28) & 3;
        int v55 = interpolate_8888_21358[v54];
        unsigned int v56 = v40 & v55;
LABEL_67:
        char v63 = v54 + 1;
        unsigned int v60 = v40 - (v56 >> v63);
        unsigned int v61 = (v53 & v55) >> v63;
LABEL_68:
        unsigned int v40 = v60 + v61;
        break;
    }
LABEL_69:
    HIDWORD(v64) = v40 | v14;
    LODWORD(v64) = v40 | v14;
    *(_DWORD *)(v11 + 4) = v64 >> 8;
    *(unsigned char *)(v12 + 1) = v25 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v65 = 0;
    a2 += v9;
    uint64_t v66 = v73 - a2;
    a3 += v10;
    uint64_t v67 = v8 - a3;
    uint64_t v68 = -4;
    while (((v67 | v66 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) == 0)
    {
      uint64_t v69 = v13 + SHIDWORD(a3) * (uint64_t)v4;
      unint64_t v37 = v69 + 4 * (a2 >> 32);
      uint64_t v38 = *(unsigned int **)(result + 32);
      if (v15 >= v37) {
        uint64_t v70 = (unsigned int *)(v69 + 4 * (a2 >> 32));
      }
      else {
        uint64_t v70 = (unsigned int *)v15;
      }
      if (v70 < v38) {
        uint64_t v70 = *(unsigned int **)(result + 32);
      }
      unsigned int v40 = bswap32(*v70);
      if (v5)
      {
        unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v41 & 0xF) != 0)
        {
          v12 += v65 + 1;
          v11 -= v68;
          a4 += ~v65;
          unsigned int v25 = -1;
          goto LABEL_40;
        }
      }
      HIDWORD(v71) = v40 | v14;
      LODWORD(v71) = v40 | v14;
      *(_DWORD *)(v11 + 4 * v65 + 8) = v71 >> 8;
      *(unsigned char *)(v12 + v65++ + 2) = -1;
      v68 -= 4;
      a2 += v9;
      v66 -= v9;
      a3 += v10;
      v67 -= v10;
      if (a4 - 1 == v65) {
        return result;
      }
    }
    v12 += v65 + 1;
    v11 -= v68;
    a4 += ~v65;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 64);
  uint64_t v8 = *(void *)(result + 72);
  uint64_t v9 = *(void *)(result + 88);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v72 = *(_DWORD *)(result + 188);
  unint64_t v14 = v4 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v5) - 3;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v8)
      {
        if ((uint64_t)a3 <= v9)
        {
          uint64_t v23 = (a3 >> 22) & 0x3C0;
          unsigned int v24 = 0x3FFFFFFF;
          HIDWORD(v25) = HIDWORD(a3);
        }
        else
        {
          uint64_t v19 = *(void *)(result + 216);
          uint64_t v20 = *(void *)(result + 224) + v9;
          uint64_t v21 = v20 - a3 + (v19 >> 1);
          if (v21 < 1) {
            goto LABEL_34;
          }
          if (v21 >= v19) {
            LODWORD(v22) = 0x3FFFFFFF;
          }
          else {
            unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
          }
          unsigned int v24 = v72 | v22;
          uint64_t v25 = v20 - 0x1000000;
          uint64_t v23 = 448;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(result + 216);
        uint64_t v16 = v8 - *(void *)(result + 224);
        uint64_t v17 = a3 - v16 + (v15 >> 1);
        if (v17 < 1) {
          goto LABEL_34;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
        }
        unsigned int v24 = v72 | v18;
        uint64_t v25 = v16 + 0x1000000;
        uint64_t v23 = 512;
      }
      if (a2 >= v7) {
        break;
      }
      uint64_t v26 = *(void *)(result + 192);
      uint64_t v27 = v7 - *(void *)(result + 200);
      uint64_t v28 = a2 - v27 + (v26 >> 1);
      if (v28 >= 1)
      {
        if (v28 < v26) {
          unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v72;
        }
        uint64_t v29 = v27 + 0x1000000;
        uint64_t v30 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v10;
      a3 += v11;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v73)
    {
      uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v29 = a2;
      goto LABEL_26;
    }
    uint64_t v31 = *(void *)(result + 192);
    uint64_t v32 = *(void *)(result + 200) + v73;
    uint64_t v33 = v32 - a2 + (v31 >> 1);
    if (v33 < 1) {
      goto LABEL_34;
    }
    if (v33 < v31) {
      unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v72;
    }
    uint64_t v29 = v32 - 0x1000000;
    uint64_t v30 = 28;
LABEL_26:
    if (v24 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v34 = v4 + SHIDWORD(v25) * (uint64_t)v5;
    uint64_t v35 = 3 * (v29 >> 32);
    uint64_t v36 = v34 + v35;
    unint64_t v37 = *(unsigned __int8 **)(result + 32);
    if (v14 >= v34 + v35) {
      uint64_t v38 = (unsigned __int8 *)(v34 + v35);
    }
    else {
      uint64_t v38 = (unsigned __int8 *)v14;
    }
    if (v38 < v37) {
      uint64_t v38 = *(unsigned __int8 **)(result + 32);
    }
    int v39 = (v38[1] << 16) | (*v38 << 24) | (v38[2] << 8) | 0xFF;
    if (!v6) {
      goto LABEL_65;
    }
    unsigned int v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
    int v41 = v40 & 0xF;
    int v42 = HIBYTE(v40) & 3;
    switch(v41)
    {
      case 1:
        int v58 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        if (v14 < (unint64_t)v58) {
          int v58 = (unsigned __int8 *)v14;
        }
        if (v58 < v37) {
          int v58 = v37;
        }
        int v39 = v39
            - ((interpolate_8888_21358[v42] & v39) >> (v42 + 1))
            + ((((v58[1] << 16) | (*v58 << 24) | (v58[2] << 8) | 0xFFu) & interpolate_8888_21358[v42]) >> (v42 + 1));
        break;
      case 2:
        char v59 = (unsigned __int8 *)(v36 + 3 * SBYTE2(v40));
        if (v14 < (unint64_t)v59) {
          char v59 = (unsigned __int8 *)v14;
        }
        if (v59 < v37) {
          char v59 = v37;
        }
        int v53 = (v59[1] << 16) | (*v59 << 24) | (v59[2] << 8) | 0xFF;
        int v60 = (v40 >> 28) & 3;
        unsigned int v55 = interpolate_8888_21358[v60];
        char v56 = v60 + 1;
        unsigned int v57 = v39 - ((v55 & v39) >> v56);
        goto LABEL_64;
      case 3:
        uint64_t v43 = 3 * SBYTE2(v40);
        int64_t v44 = (unsigned __int8 *)(v36 + v43);
        if (v14 < v36 + v43) {
          int64_t v44 = (unsigned __int8 *)v14;
        }
        if (v44 < v37) {
          int64_t v44 = v37;
        }
        int v45 = (v44[1] << 16) | (*v44 << 24) | (v44[2] << 8) | 0xFF;
        unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v5;
        if (v14 >= v46) {
          unint64_t v47 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
        }
        else {
          unint64_t v47 = (unsigned __int8 *)v14;
        }
        if (v47 < v37) {
          unint64_t v47 = v37;
        }
        int v48 = (v47[1] << 16) | (*v47 << 24) | (v47[2] << 8) | 0xFF;
        unsigned int v49 = (unsigned __int8 *)(v46 + v43);
        if (v14 < (unint64_t)v49) {
          unsigned int v49 = (unsigned __int8 *)v14;
        }
        if (v49 < v37) {
          unsigned int v49 = v37;
        }
        unsigned int v50 = interpolate_8888_21358[v42];
        char v51 = v42 + 1;
        unsigned int v52 = v39 - ((v50 & v39) >> v51) + ((v48 & v50) >> v51);
        int v53 = v45 - ((v50 & v45) >> v51) + ((((v49[1] << 16) | (*v49 << 24) | (v49[2] << 8) | 0xFF) & v50) >> v51);
        int v54 = (v40 >> 28) & 3;
        unsigned int v55 = interpolate_8888_21358[v54];
        char v56 = v54 + 1;
        unsigned int v57 = v52 - ((v52 & v55) >> v56);
LABEL_64:
        int v39 = v57 + ((v53 & v55) >> v56);
        break;
    }
LABEL_65:
    uint64_t v61 = v12;
    HIDWORD(v62) = v39;
    LODWORD(v62) = v39;
    *(_DWORD *)(v12 + 4) = v62 >> 8;
    v12 += 4;
    *(unsigned char *)(v13 + 1) = v24 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v63 = 0;
    a2 += v10;
    uint64_t v64 = v73 - a2;
    a3 += v11;
    uint64_t v65 = v9 - a3;
    int v66 = --a4;
    while (1)
    {
      uint64_t v67 = v13 + v63 + 1;
      if (((v65 | v64 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0) {
        break;
      }
      uint64_t v68 = v4 + SHIDWORD(a3) * (uint64_t)v5;
      uint64_t v69 = 3 * (a2 >> 32);
      uint64_t v36 = v68 + v69;
      unint64_t v37 = *(unsigned __int8 **)(result + 32);
      if (v14 >= v68 + v69) {
        uint64_t v70 = (unsigned __int8 *)(v68 + v69);
      }
      else {
        uint64_t v70 = (unsigned __int8 *)v14;
      }
      if (v70 < v37) {
        uint64_t v70 = *(unsigned __int8 **)(result + 32);
      }
      unsigned int v71 = (v70[1] << 16) | (*v70 << 24) | (v70[2] << 8);
      if (v6)
      {
        unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
        if ((v40 & 0xF) != 0)
        {
          int v39 = v71 | 0xFF;
          unsigned int v24 = -1;
          uint64_t v13 = v67;
          goto LABEL_37;
        }
      }
      --a4;
      v12 += 4;
      *(_DWORD *)(v61 + 4 * v63 + 8) = (v71 >> 8) | 0xFF000000;
      *(unsigned char *)(v13 + v63++ + 2) = -1;
      a2 += v10;
      v64 -= v10;
      a3 += v11;
      v65 -= v11;
      if (v66 == v63) {
        return result;
      }
    }
    v13 += v63 + 1;
  }
  while (a4);
  return result;
}

uint64_t argb32_sample_rgb555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    int v11 = 0;
  }
  else {
    int v11 = -16777216;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v85 = *(_DWORD *)(result + 188);
  unint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  uint64_t v38 = v4 + (int)v36 * (uint64_t)v6;
  unint64_t v39 = v38 + 2 * v37;
  unsigned int v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39) {
    int v41 = (unsigned __int16 *)(v38 + 2 * v37);
  }
  else {
    int v41 = (unsigned __int16 *)v15;
  }
  if (v41 < v40) {
    int v41 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v42 = *v41;
  if (!v5)
  {
    unint64_t v43 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      uint64_t v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65) {
        uint64_t v65 = (unsigned __int16 *)v15;
      }
      if (v65 < v40) {
        uint64_t v65 = v40;
      }
      unsigned int v66 = *v65;
      if (v5)
      {
        uint64_t v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67) {
          uint64_t v67 = v14;
        }
        if ((unint64_t)v67 < *(void *)(result + 40)) {
          uint64_t v67 = *(unsigned __int8 **)(result + 40);
        }
        v66 |= *v67 << 24;
      }
      int v68 = interpolate_8555_21359[v48];
      char v69 = v48 + 1;
      unsigned int v70 = v42 - ((v68 & v42) >> v69);
      unsigned int v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int64_t v49 = (unint64_t)HIWORD(v46) << 56;
          unsigned int v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50) {
            unsigned int v50 = (unsigned __int16 *)v15;
          }
          if (v50 < v40) {
            unsigned int v50 = v40;
          }
          unsigned int v51 = *v50;
          unint64_t v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52) {
            int v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          }
          else {
            int v53 = (unsigned __int16 *)v15;
          }
          if (v53 < v40) {
            int v53 = v40;
          }
          unsigned int v54 = *v53;
          unsigned int v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55) {
            unsigned int v55 = (unsigned __int16 *)v15;
          }
          if (v55 < v40) {
            unsigned int v55 = v40;
          }
          unsigned int v56 = *v55;
          if (v5)
          {
            unsigned int v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            unint64_t v58 = *(void *)(result + 40);
            if (v14 < v57) {
              unsigned int v57 = v14;
            }
            if ((unint64_t)v57 < v58) {
              unsigned int v57 = *(unsigned __int8 **)(result + 40);
            }
            v51 |= *v57 << 24;
            unint64_t v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59) {
              int v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            }
            else {
              int v60 = v14;
            }
            if ((unint64_t)v60 < v58) {
              int v60 = *(unsigned __int8 **)(result + 40);
            }
            v54 |= *v60 << 24;
            uint64_t v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61) {
              uint64_t v61 = v14;
            }
            if ((unint64_t)v61 < v58) {
              uint64_t v61 = *(unsigned __int8 **)(result + 40);
            }
            v56 |= *v61 << 24;
          }
          int v62 = interpolate_8555_21359[v48];
          char v63 = v48 + 1;
          unsigned int v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          unsigned int v42 = v64
              - ((v64 & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      int v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72) {
        int v72 = (unsigned __int16 *)v15;
      }
      if (v72 < v40) {
        int v72 = v40;
      }
      unsigned int v73 = *v72;
      if (v5)
      {
        unint64_t v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74) {
          unint64_t v74 = v14;
        }
        if ((unint64_t)v74 < *(void *)(result + 40)) {
          unint64_t v74 = *(unsigned __int8 **)(result + 40);
        }
        v73 |= *v74 << 24;
      }
      int v75 = (v46 >> 28) & 3;
      int v76 = interpolate_8555_21359[v75];
      LOBYTE(v75) = v75 + 1;
      unsigned int v70 = v42 - ((v76 & v42) >> v75);
      unsigned int v71 = (v76 & v73) >> v75;
    }
    unsigned int v42 = v70 + v71;
    goto LABEL_103;
  }
  unint64_t v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  int64_t v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43) {
    int v45 = (unsigned __int8 *)v43;
  }
  else {
    int v45 = v14;
  }
  if (v45 >= v44) {
    int64_t v44 = v45;
  }
  v42 |= *v44 << 24;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  a3 += v9;
  uint64_t v79 = v89 - a3;
  a2 += v10;
  uint64_t v80 = v87 - a2;
  while (1)
  {
    unsigned int v81 = (v42 << 6) & 0xF800 | (((v42 >> 10) & 0x1F) << 19) | (8 * (v42 & 0x1F));
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v11 | (v42 >> 5) | v42) & 0xFF000000 | v81 | (v81 >> 5) & 0x3F3F3F3F;
    *(unsigned char *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == v77) {
      return result;
    }
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      uint64_t v91 = v91 - v78 + 4;
      a4 += ~v77;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    unsigned int v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39) {
      uint64_t v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned __int16 *)v15;
    }
    if (v82 < v40) {
      uint64_t v82 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v42 = *v82;
    if (v5)
    {
      unint64_t v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      int v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        int v83 = (unsigned __int8 *)v84;
      }
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      unsigned int v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        uint64_t v91 = v91 - v78 + 4;
        a4 += ~v77;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t argb32_sample_RGB555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v90 = *(void *)(result + 144) - 1;
  if (v5) {
    int v11 = 0;
  }
  else {
    int v11 = -16777216;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v85 = *(_DWORD *)(result + 188);
  unint64_t v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + (v12 * v6) + 2 * v13 - 4;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v86 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v88)
    {
      if (a3 <= v89)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v86;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v89;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v86;
        unsigned int v25 = v85 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v88 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v86;
      unsigned int v25 = v85 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v85;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v90 = 0;
    v91 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v87)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v87;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v85;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  uint64_t v38 = v4 + (int)v36 * (uint64_t)v6;
  unint64_t v39 = v38 + 2 * v37;
  unsigned int v40 = *(unsigned __int16 **)(result + 32);
  if (v15 >= v39) {
    int v41 = (unsigned __int16 *)(v38 + 2 * v37);
  }
  else {
    int v41 = (unsigned __int16 *)v15;
  }
  if (v41 < v40) {
    int v41 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v42 = bswap32(*v41) >> 16;
  if (!v5)
  {
    unint64_t v43 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v46 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v47 = v46 & 0xF;
    int v48 = HIBYTE(v46) & 3;
    if (v47 == 1)
    {
      uint64_t v65 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
      if (v15 < (unint64_t)v65) {
        uint64_t v65 = (unsigned __int16 *)v15;
      }
      if (v65 < v40) {
        uint64_t v65 = v40;
      }
      unsigned int v66 = bswap32(*v65) >> 16;
      if (v5)
      {
        uint64_t v67 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
        if (v14 < v67) {
          uint64_t v67 = v14;
        }
        if ((unint64_t)v67 < *(void *)(result + 40)) {
          uint64_t v67 = *(unsigned __int8 **)(result + 40);
        }
        v66 |= *v67 << 24;
      }
      int v68 = interpolate_8555_21359[v48];
      char v69 = v48 + 1;
      unsigned int v70 = v42 - ((v68 & v42) >> v69);
      unsigned int v71 = (v68 & v66) >> v69;
    }
    else
    {
      if (v47 != 2)
      {
        if (v47 == 3)
        {
          int64_t v49 = (unint64_t)HIWORD(v46) << 56;
          unsigned int v50 = (unsigned __int16 *)(v39 + (v49 >> 55));
          if (v15 < (unint64_t)v50) {
            unsigned int v50 = (unsigned __int16 *)v15;
          }
          if (v50 < v40) {
            unsigned int v50 = v40;
          }
          unsigned int v51 = bswap32(*v50) >> 16;
          unint64_t v52 = v39 + SBYTE1(v46) * (uint64_t)v6;
          if (v15 >= v52) {
            int v53 = (unsigned __int16 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
          }
          else {
            int v53 = (unsigned __int16 *)v15;
          }
          if (v53 < v40) {
            int v53 = v40;
          }
          unsigned int v54 = bswap32(*v53) >> 16;
          unsigned int v55 = (unsigned __int16 *)(v52 + (v49 >> 55));
          if (v15 < (unint64_t)v55) {
            unsigned int v55 = (unsigned __int16 *)v15;
          }
          if (v55 < v40) {
            unsigned int v55 = v40;
          }
          unsigned int v56 = bswap32(*v55) >> 16;
          if (v5)
          {
            unsigned int v57 = (unsigned __int8 *)(v43 + SBYTE2(v46));
            unint64_t v58 = *(void *)(result + 40);
            if (v14 < v57) {
              unsigned int v57 = v14;
            }
            if ((unint64_t)v57 < v58) {
              unsigned int v57 = *(unsigned __int8 **)(result + 40);
            }
            v51 |= *v57 << 24;
            unint64_t v59 = v43 + SBYTE1(v46) * (uint64_t)v7;
            if ((unint64_t)v14 >= v59) {
              int v60 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
            }
            else {
              int v60 = v14;
            }
            if ((unint64_t)v60 < v58) {
              int v60 = *(unsigned __int8 **)(result + 40);
            }
            v54 |= *v60 << 24;
            uint64_t v61 = (unsigned __int8 *)(v59 + SBYTE2(v46));
            if (v14 < v61) {
              uint64_t v61 = v14;
            }
            if ((unint64_t)v61 < v58) {
              uint64_t v61 = *(unsigned __int8 **)(result + 40);
            }
            v56 |= *v61 << 24;
          }
          int v62 = interpolate_8555_21359[v48];
          char v63 = v48 + 1;
          unsigned int v64 = v42 - ((v62 & v42) >> v63) + ((v62 & v54) >> v63);
          unsigned int v42 = v64
              - ((v64 & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1))
              + (((v51 - ((v62 & v51) >> v63) + ((v62 & v56) >> v63)) & interpolate_8555_21359[(v46 >> 28) & 3]) >> (((v46 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      int v72 = (unsigned __int16 *)(v39 + ((uint64_t)((unint64_t)HIWORD(v46) << 56) >> 55));
      if (v15 < (unint64_t)v72) {
        int v72 = (unsigned __int16 *)v15;
      }
      if (v72 < v40) {
        int v72 = v40;
      }
      unsigned int v73 = bswap32(*v72) >> 16;
      if (v5)
      {
        unint64_t v74 = (unsigned __int8 *)(v43 + SBYTE2(v46));
        if (v14 < v74) {
          unint64_t v74 = v14;
        }
        if ((unint64_t)v74 < *(void *)(result + 40)) {
          unint64_t v74 = *(unsigned __int8 **)(result + 40);
        }
        v73 |= *v74 << 24;
      }
      int v75 = (v46 >> 28) & 3;
      int v76 = interpolate_8555_21359[v75];
      LOBYTE(v75) = v75 + 1;
      unsigned int v70 = v42 - ((v76 & v42) >> v75);
      unsigned int v71 = (v76 & v73) >> v75;
    }
    unsigned int v42 = v70 + v71;
    goto LABEL_103;
  }
  unint64_t v43 = v5 + (int)v36 * (uint64_t)v7 + v37;
  int64_t v44 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v43) {
    int v45 = (unsigned __int8 *)v43;
  }
  else {
    int v45 = v14;
  }
  if (v45 >= v44) {
    int64_t v44 = v45;
  }
  v42 |= *v44 << 24;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  a3 += v9;
  uint64_t v79 = v89 - a3;
  a2 += v10;
  uint64_t v80 = v87 - a2;
  while (1)
  {
    unsigned int v81 = (v42 << 6) & 0xF800 | (((v42 >> 10) & 0x1F) << 19) | (8 * (v42 & 0x1F));
    *(_DWORD *)(v91 + 4 + 4 * v77) = (v11 | (v42 >> 5) | v42) & 0xFF000000 | v81 | (v81 >> 5) & 0x3F3F3F3F;
    *(unsigned char *)(v90 + 1 + v77) = v25 >> 22;
    if (a4 - 1 == v77) {
      return result;
    }
    if ((v79 | v80 | (a3 - v88) | (a2 - v86)) < 0)
    {
      v90 += v77 + 1;
      uint64_t v91 = v91 - v78 + 4;
      a4 += ~v77;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32);
    unsigned int v40 = *(unsigned __int16 **)(result + 32);
    if (v15 >= v39) {
      uint64_t v82 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 2 * (a2 >> 32));
    }
    else {
      uint64_t v82 = (unsigned __int16 *)v15;
    }
    if (v82 < v40) {
      uint64_t v82 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v42 = bswap32(*v82) >> 16;
    if (v5)
    {
      unint64_t v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      int v83 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v43) {
        unint64_t v84 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v84 = (unint64_t)v14;
      }
      if (v84 >= (unint64_t)v83) {
        int v83 = (unsigned __int8 *)v84;
      }
      v42 |= *v83 << 24;
    }
    if (v8)
    {
      unsigned int v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v90 += v77 + 1;
        uint64_t v91 = v91 - v78 + 4;
        a4 += ~v77;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v78 -= 4;
    ++v77;
    a3 += v9;
    v79 -= v9;
    a2 += v10;
    v80 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t argb32_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v91 = *(void *)(result + 80);
  uint64_t v89 = *(void *)(result + 88);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    int v13 = 0;
  }
  else {
    int v13 = -16777216;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  uint64_t v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  int v87 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + v15 + (v14 * v6) - 1;
  uint64_t v88 = *(void *)(result + 64);
  uint64_t v90 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v90)
      {
        if (a3 <= v89)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v88;
          uint64_t v30 = v91;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v89;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v88;
          uint64_t v30 = v91;
          unsigned int v27 = v87 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v90 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v88;
        uint64_t v30 = v91;
        unsigned int v27 = v87 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v29 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v87;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v9;
      a3 += v10;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v30)
    {
      uint64_t v35 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_29;
    }
    uint64_t v36 = *(void *)(result + 192);
    uint64_t v37 = *(void *)(result + 200) + v30;
    uint64_t v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1) {
      goto LABEL_43;
    }
    if (v38 < v36) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v38) >> 32) >> 15)) | v87;
    }
    uint64_t v34 = v37 - 0x1000000;
    uint64_t v35 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v39 = v28 >> 32;
    unint64_t v40 = v4 + (int)v39 * (uint64_t)v6 + (v34 >> 32);
    int v41 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v40) {
      unsigned int v42 = (unsigned __int8 *)(v4 + (int)v39 * (uint64_t)v6 + (v34 >> 32));
    }
    else {
      unsigned int v42 = (unsigned __int8 *)v17;
    }
    if (v42 < v41) {
      unsigned int v42 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v43 = *v42;
    if (v5)
    {
      unint64_t v44 = v5 + (int)v39 * (uint64_t)v7 + (v34 >> 32);
      int v45 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v44) {
        unsigned int v46 = (unsigned __int8 *)v44;
      }
      else {
        unsigned int v46 = v16;
      }
      if (v46 >= v45) {
        int v45 = v46;
      }
      v43 |= *v45 << 24;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v44 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v47 = *(_DWORD *)(v8 + (v35 | v26));
LABEL_48:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    switch(v48)
    {
      case 1:
        char v69 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        if (v17 < (unint64_t)v69) {
          char v69 = (unsigned __int8 *)v17;
        }
        if (v69 < v41) {
          char v69 = v41;
        }
        int v66 = *v69;
        if (v5)
        {
          unsigned int v70 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v70) {
            unsigned int v70 = v16;
          }
          if ((unint64_t)v70 < *(void *)(result + 40)) {
            unsigned int v70 = *(unsigned __int8 **)(result + 40);
          }
          v66 |= *v70 << 24;
        }
        unsigned int v64 = interpolate_8888_21358[v49];
        char v67 = v49 + 1;
        unsigned int v68 = v43 - ((v64 & v43) >> v67);
        goto LABEL_91;
      case 2:
        int v72 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v72) {
          int v72 = (unsigned __int8 *)v17;
        }
        if (v72 < v41) {
          int v72 = v41;
        }
        unsigned int v73 = *v72;
        if (v5)
        {
          unint64_t v74 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          if (v16 < v74) {
            unint64_t v74 = v16;
          }
          if ((unint64_t)v74 < *(void *)(result + 40)) {
            unint64_t v74 = *(unsigned __int8 **)(result + 40);
          }
          v73 |= *v74 << 24;
        }
        int v75 = (v47 >> 28) & 3;
        int v76 = interpolate_8888_21358[v75];
        LOBYTE(v75) = v75 + 1;
        unsigned int v68 = v43 - ((v76 & v43) >> v75);
        unsigned int v71 = (v76 & v73) >> v75;
        goto LABEL_103;
      case 3:
        unsigned int v50 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v50) {
          unsigned int v50 = (unsigned __int8 *)v17;
        }
        if (v50 < v41) {
          unsigned int v50 = v41;
        }
        unsigned int v51 = *v50;
        unint64_t v52 = v40 + SBYTE1(v47) * (uint64_t)v6;
        if (v17 >= v52) {
          int v53 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        }
        else {
          int v53 = (unsigned __int8 *)v17;
        }
        if (v53 < v41) {
          int v53 = v41;
        }
        unsigned int v86 = *v53;
        unsigned int v54 = (unsigned __int8 *)(v52 + SBYTE2(v47));
        if (v17 < (unint64_t)v54) {
          unsigned int v54 = (unsigned __int8 *)v17;
        }
        if (v54 < v41) {
          unsigned int v54 = v41;
        }
        unsigned int v55 = *v54;
        if (v5)
        {
          unsigned int v56 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          unsigned int v57 = *(unsigned __int8 **)(result + 40);
          if (v16 < v56) {
            unsigned int v56 = v16;
          }
          if (v56 < v57) {
            unsigned int v56 = *(unsigned __int8 **)(result + 40);
          }
          v51 |= *v56 << 24;
          unint64_t v58 = v44 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v58) {
            unint64_t v59 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          }
          else {
            unint64_t v59 = v16;
          }
          if (v59 < v57) {
            unint64_t v59 = *(unsigned __int8 **)(result + 40);
          }
          v86 |= *v59 << 24;
          int v60 = (unsigned __int8 *)(v58 + SBYTE2(v47));
          if (v16 < v60) {
            int v60 = v16;
          }
          if (v60 >= v57) {
            unsigned int v57 = v60;
          }
          v55 |= *v57 << 24;
        }
        int v61 = interpolate_8888_21358[v49];
        char v62 = v49 + 1;
        unsigned int v63 = v43 - ((v61 & v43) >> v62) + ((v61 & v86) >> v62);
        unsigned int v64 = v51 - ((v61 & v51) >> v62) + ((v61 & v55) >> v62);
        int v65 = (v47 >> 28) & 3;
        int v66 = interpolate_8888_21358[v65];
        char v67 = v65 + 1;
        unsigned int v68 = v63 - ((v63 & v66) >> v67);
LABEL_91:
        unsigned int v71 = (v64 & v66) >> v67;
LABEL_103:
        unsigned int v43 = v68 + v71;
        break;
    }
LABEL_104:
    *(_DWORD *)(v11 + 4) = (65792 * v43) | v13 | v43;
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v77 = 0;
    a2 += v9;
    uint64_t v78 = v91 - a2;
    a3 += v10;
    uint64_t v79 = v89 - a3;
    uint64_t v80 = -4;
    while (((v79 | v78 | (a3 - v90) | (a2 - v88)) & 0x8000000000000000) == 0)
    {
      uint64_t v81 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      unint64_t v40 = v81 + (a2 >> 32);
      int v41 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v40) {
        uint64_t v82 = (unsigned __int8 *)(v81 + (a2 >> 32));
      }
      else {
        uint64_t v82 = (unsigned __int8 *)v17;
      }
      if (v82 < v41) {
        uint64_t v82 = *(unsigned __int8 **)(result + 32);
      }
      unsigned int v43 = *v82;
      if (v5)
      {
        uint64_t v83 = v5 + SHIDWORD(a3) * (uint64_t)v7;
        unint64_t v44 = v83 + (a2 >> 32);
        unint64_t v84 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v44) {
          int v85 = (unsigned __int8 *)(v83 + (a2 >> 32));
        }
        else {
          int v85 = v16;
        }
        if (v85 >= v84) {
          unint64_t v84 = v85;
        }
        v43 |= *v84 << 24;
      }
      if (v8)
      {
        unsigned int v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v12 += v77 + 1;
          v11 -= v80;
          a4 += ~v77;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      *(_DWORD *)(v11 + 4 * v77 + 8) = (65792 * v43) | v13 | v43;
      *(unsigned char *)(v12 + v77++ + 2) = -1;
      v80 -= 4;
      a2 += v9;
      v78 -= v9;
      a3 += v10;
      v79 -= v10;
      if (a4 - 1 == v77) {
        return result;
      }
    }
    v12 += v77 + 1;
    v11 -= v80;
    a4 += ~v77;
  }
  while (a4);
  return result;
}

unint64_t PDM_14621(unsigned int a1, int a2)
{
  unsigned int v2 = ((a1 >> 8) & 0xFF00FF) * (a2 ^ 0xFF) + 8388736;
  uint64_t v3 = ((((((a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF) + (a1 & 0xFF00FF) * (a2 ^ 0xFF) + 8388736) >> 8) & 0xFF00FF | (((v2 >> 8) & 0xFF00FF) + v2) & 0xFF00FF00;
  unint64_t v4 = (((a1 | ((unint64_t)a1 << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v3 | (unint64_t)(v3 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  return (((v4 & 0x100010001000100) - ((v4 & 0x100010001000100) >> 8)) & v4 | ((((v4 & 0x100010001000100)
                                                                                   - ((v4 & 0x100010001000100) >> 8)) & v4) << 40)) >> 32;
}

unsigned int *DMplusDM_14622(unsigned int *result, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5 = (unsigned __int16)(BYTE1(a4) * (_WORD)a5) + (unsigned __int16)(BYTE1(a2) * (_WORD)a3);
  unsigned int v6 = ((((a4 >> 8) & 0xFF00FF) * a5) >> 16) + ((((a2 >> 8) & 0xFF00FF) * a3) >> 16);
  if (v5 >= 0xFE79) {
    unsigned int v5 = 65145;
  }
  if (v6 >= 0xFE79) {
    unsigned int v6 = 65145;
  }
  unsigned int v7 = (a2 & 0xFF00FF) * a3;
  unsigned int v8 = (unsigned __int16)(a4 * (_WORD)a5) + (unsigned __int16)v7;
  unsigned int v9 = (((a4 & 0xFF00FF) * a5) >> 16) + HIWORD(v7);
  if (v8 >= 0xFE79) {
    int v10 = 65145;
  }
  else {
    int v10 = v8;
  }
  if (v9 >= 0xFE79) {
    int v11 = 65145;
  }
  else {
    int v11 = v9;
  }
  *CFCalendarRef result = ((((((v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v10 | (v11 << 16)) + 8388736) >> 8) & 0xFF00FF | (((((v5 | (v6 << 16)) + 8388736) >> 8) & 0xFF00FF) + (v5 | (v6 << 16)) + 8388736) & 0xFF00FF00;
  return result;
}

_DWORD *DplusDM_14623(_DWORD *result, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v4 = ((((((a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + (a3 & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF | ((((((a3 >> 8) & 0xFF00FF) * a4 + 8388736) >> 8) & 0xFF00FF) + ((a3 >> 8) & 0xFF00FF) * a4 + 8388736) & 0xFF00FF00;
  unint64_t v5 = (((v4 | (unint64_t)(v4 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *CFCalendarRef result = ((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL | (((((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) | v5) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

_DWORD *DAplusdDA_14624(_DWORD *result, int a2, int a3, int a4, int a5)
{
  unint64_t v5 = ((((65793 * a3) | ((unint64_t)(65793 * a3) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
     - (((a2 & 0xFFFFFF | ((unint64_t)(a2 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  unint64_t v6 = ((v5 & 0x100010001000100) - ((v5 & 0x100010001000100) >> 8)) & v5;
  unint64_t v7 = (v6 | (v6 << 40)) >> 32;
  unint64_t v8 = ((((65793 * a5) | ((unint64_t)(65793 * a5) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
     - (((a4 & 0xFFFFFF | ((unint64_t)(a4 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  unint64_t v9 = ((v8 & 0x100010001000100) - ((v8 & 0x100010001000100) >> 8)) & v8;
  unint64_t v10 = (v9 | (v9 << 40)) >> 32;
  unsigned int v11 = (((v10 | (a5 << 24)) >> 8) & 0xFF00FF) + (((v7 | (a3 << 24)) >> 8) & 0xFF00FF);
  LODWORD(v7) = (v11 << 8) & 0xFF00FF00 | ((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                           * (v11 & 0x1000100 | (((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v11 & 0x1000100 | (((v10 & 0xFF00FF) + (v7 & 0xFF00FF)) >> 8) & 0x10001));
  unint64_t v12 = ((((65793 * BYTE3(v7)) | ((unint64_t)(65793 * BYTE3(v7)) << 40)) >> 8) & 0xFEFF00FFFEFF00FFLL | 0x100010001000100)
      - (((v7 & 0xFFFFFF | ((v7 & 0xFFFFFF) << 40)) >> 8) & 0xFFFF00FFFFFF00FFLL);
  *CFCalendarRef result = v7 & 0xFF000000 | ((((v12 & 0x100010001000100) - ((v12 & 0x100010001000100) >> 8)) & v12 | ((((v12 & 0x100010001000100) - ((v12 & 0x100010001000100) >> 8)) & v12) << 40)) >> 32);
  return result;
}

uint64_t PDAmultiplyPDA_14625(unsigned int a1, int a2, unsigned __int8 a3, int a4)
{
  int32x2_t v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  unsigned int v5 = ((a4 ^ 0xFF) + a3) * a1;
  double v6 = COERCE_DOUBLE(vmul_s32(vadd_s32(vdup_n_s32(a4 ^ 0xFFu), v4), (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)));
  double v7 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v6, v4, vdup_n_s32(a2 ^ 0xFFu)));
  if (a2 != 255)
  {
    v5 += a3 * (a2 ^ 0xFF);
    double v6 = v7;
  }
  int v8 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v9 = HIDWORD(v6) + 128;
  if (HIDWORD(v6) >> 7 >= 0x1FD) {
    unsigned int v9 = 65152;
  }
  unsigned int v10 = v9 + (v9 >> 8);
  if (v5 >> 7 >= 0x1FD) {
    unsigned int v11 = 65152;
  }
  else {
    unsigned int v11 = v5 + 128;
  }
  unsigned int v12 = v11 + (v11 >> 8);
  if (v8 >= 65152) {
    unsigned int v13 = 65152;
  }
  else {
    unsigned int v13 = v8 + 128;
  }
  unsigned int v14 = (v13 + (v13 >> 8)) >> 8;
  if (LODWORD(v6) >> 7 >= 0x1FD) {
    int v15 = 16711680;
  }
  else {
    int v15 = (257 * LODWORD(v6) + 32896) & 0xFF0000;
  }
  return v15 & 0xFF0000 | (v14 << 24) | v10 & 0xFF00 | BYTE1(v12);
}

uint64_t PDAscreenPDA_14626(int a1, int a2, int a3, int a4)
{
  unsigned int v4 = BYTE2(a3) * (BYTE2(a1) ^ 0xFF) - BYTE2(a1) + (BYTE2(a1) << 8);
  unsigned int v5 = BYTE1(a3) * (BYTE1(a1) ^ 0xFF) - BYTE1(a1) + (BYTE1(a1) << 8);
  unsigned int v6 = a3 * (a1 ^ 0xFF) - a1 + (a1 << 8);
  int v7 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v8 = v5 + 128;
  if (v5 >> 7 >= 0x1FD) {
    unsigned int v8 = 65152;
  }
  unsigned int v9 = v8 + (v8 >> 8);
  if (v6 >> 7 >= 0x1FD) {
    unsigned int v10 = 65152;
  }
  else {
    unsigned int v10 = v6 + 128;
  }
  unsigned int v11 = v10 + (v10 >> 8);
  if (v7 >= 65152) {
    unsigned int v12 = 65152;
  }
  else {
    unsigned int v12 = v7 + 128;
  }
  unsigned int v13 = (v12 + (v12 >> 8)) >> 8;
  if (v4 >> 7 >= 0x1FD) {
    int v14 = 16711680;
  }
  else {
    int v14 = (257 * v4 + 32896) & 0xFF0000;
  }
  return v14 & 0xFF0000 | v9 & 0xFF00 | BYTE1(v11) | (v13 << 24);
}

uint64_t PDAoverlayPDA_14627(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE1(a1);
  unsigned int v6 = a1;
  unsigned int v7 = BYTE2(a3);
  unsigned int v8 = BYTE1(a3);
  unsigned int v9 = a3;
  if (BYTE2(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v4 = a2;
  }
  int v10 = 2 * v4 * v7;
  if (BYTE1(a3) >= a4) {
    unsigned int v8 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v11 = 2 * v5 * v8;
  if (a3 >= a4) {
    unsigned int v9 = a4;
  }
  if (a1 >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 2 * v6 * v9;
  int v13 = a4 * a2;
  unsigned int v14 = (a2 + 1) >> 1;
  unsigned int v15 = a4 + 255;
  unsigned int v16 = a2 + 255;
  int v17 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  int v18 = a4 ^ 0xFF;
  int v19 = a2 ^ 0xFF;
  int v20 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  if (v4 < v14) {
    int v21 = v20;
  }
  else {
    int v21 = v17;
  }
  int v22 = v15 * v5 + v8 * v16 - (v13 + v11);
  int v23 = v8 * v19 + v18 * v5 + v11;
  if (v5 < v14) {
    int v24 = v23;
  }
  else {
    int v24 = v22;
  }
  if (v6 < v14) {
    int v25 = v9 * v19 + v18 * v6 + v12;
  }
  else {
    int v25 = v15 * v6 + v9 * v16 - (v13 + v12);
  }
  int v26 = 255 * (a4 + a2) - v13;
  if (v24 >= 65152) {
    unsigned int v27 = 65152;
  }
  else {
    unsigned int v27 = v24 + 128;
  }
  unsigned int v28 = v27 + (v27 >> 8);
  if (v25 >= 65152) {
    unsigned int v29 = 65152;
  }
  else {
    unsigned int v29 = v25 + 128;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  if (v26 >= 65152) {
    unsigned int v31 = 65152;
  }
  else {
    unsigned int v31 = v26 + 128;
  }
  unsigned int v32 = (v31 + (v31 >> 8)) >> 8;
  if (v21 >= 65152) {
    int v33 = 16711680;
  }
  else {
    int v33 = (257 * v21 + 32896) & 0xFF0000;
  }
  return v33 & 0xFF0000 | (v32 << 24) | v28 & 0xFF00 | BYTE1(v30);
}

uint64_t PDAlightenPDA_14628(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = a1;
  unsigned int v5 = a3;
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vdup_n_s32(a2);
  int32x2_t v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  int32x2_t v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  double v10 = COERCE_DOUBLE(vmax_u32((uint32x2_t)vmul_s32(v8, v7), (uint32x2_t)vmul_s32(v9, v6)));
  if (a3 >= a4) {
    unsigned int v5 = a4;
  }
  if (a1 >= a2) {
    unsigned int v4 = a2;
  }
  int v11 = v4 * a4;
  if (v5 * a2 > v4 * a4) {
    int v11 = v5 * a2;
  }
  double v12 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  unsigned int v13 = v11 + (a4 ^ 0xFF) * v4;
  if (a4 == 255)
  {
    unsigned int v13 = v11;
    *(double *)&int32x2_t v14 = v10;
  }
  else
  {
    *(double *)&int32x2_t v14 = v12;
  }
  double v15 = COERCE_DOUBLE(vmla_s32(v14, v8, vdup_n_s32(a2 ^ 0xFF)));
  unsigned int v16 = v13 + v5 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    unsigned int v13 = v16;
    *(double *)&int32x2_t v14 = v15;
  }
  int v17 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v18 = v14.i32[1] + 128;
  if ((unsigned __int32)v14.i32[1] >> 7 >= 0x1FD) {
    unsigned int v18 = 65152;
  }
  unsigned int v19 = v18 + (v18 >> 8);
  if (v13 >> 7 >= 0x1FD) {
    unsigned int v20 = 65152;
  }
  else {
    unsigned int v20 = v13 + 128;
  }
  unsigned int v21 = v20 + (v20 >> 8);
  if (v17 >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v17 + 128;
  }
  unsigned int v23 = (v22 + (v22 >> 8)) >> 8;
  if ((unsigned __int32)v14.i32[0] >> 7 >= 0x1FD) {
    int v24 = 16711680;
  }
  else {
    int v24 = (257 * v14.i32[0] + 32896) & 0xFF0000;
  }
  return v24 & 0xFF0000 | (v23 << 24) | v19 & 0xFF00 | BYTE1(v21);
}

uint64_t PDAdarkenPDA_14629(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = a1;
  unsigned int v5 = a3;
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vdup_n_s32(a2);
  int32x2_t v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  int32x2_t v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  double v10 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vmul_s32(v8, v7), (uint32x2_t)vmul_s32(v9, v6)));
  if (a3 >= a4) {
    unsigned int v5 = a4;
  }
  if (a1 >= a2) {
    unsigned int v4 = a2;
  }
  int v11 = v4 * a4;
  if (v5 * a2 < v4 * a4) {
    int v11 = v5 * a2;
  }
  double v12 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, vdup_n_s32(a4 ^ 0xFF), v9));
  unsigned int v13 = v11 + (a4 ^ 0xFF) * v4;
  if (a4 == 255)
  {
    unsigned int v13 = v11;
    *(double *)&int32x2_t v14 = v10;
  }
  else
  {
    *(double *)&int32x2_t v14 = v12;
  }
  double v15 = COERCE_DOUBLE(vmla_s32(v14, v8, vdup_n_s32(a2 ^ 0xFF)));
  unsigned int v16 = v13 + v5 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    unsigned int v13 = v16;
    *(double *)&int32x2_t v14 = v15;
  }
  int v17 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v18 = v14.i32[1] + 128;
  if ((unsigned __int32)v14.i32[1] >> 7 >= 0x1FD) {
    unsigned int v18 = 65152;
  }
  unsigned int v19 = v18 + (v18 >> 8);
  if (v13 >> 7 >= 0x1FD) {
    unsigned int v20 = 65152;
  }
  else {
    unsigned int v20 = v13 + 128;
  }
  unsigned int v21 = v20 + (v20 >> 8);
  if (v17 >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v17 + 128;
  }
  unsigned int v23 = (v22 + (v22 >> 8)) >> 8;
  if ((unsigned __int32)v14.i32[0] >> 7 >= 0x1FD) {
    int v24 = 16711680;
  }
  else {
    int v24 = (257 * v14.i32[0] + 32896) & 0xFF0000;
  }
  return v24 & 0xFF0000 | (v23 << 24) | v19 & 0xFF00 | BYTE1(v21);
}

uint64_t PDAcolordodgePDA_14630(int a1, unsigned int a2, int a3, unsigned int a4)
{
  int v4 = a4 * a4;
  if (BYTE2(a1) >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = BYTE2(a1);
  }
  if (BYTE2(a3) >= a4) {
    unsigned int v6 = a4;
  }
  else {
    unsigned int v6 = BYTE2(a3);
  }
  if (v5)
  {
    if (BYTE2(a3) >= a4) {
      int v7 = 65025;
    }
    else {
      int v7 = (int)(v4 * v5) / (int)(a4 - v6);
    }
  }
  else
  {
    int v7 = 0;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v8 = a2;
  }
  else {
    unsigned int v8 = BYTE1(a1);
  }
  if (BYTE1(a3) >= a4) {
    unsigned int v9 = a4;
  }
  else {
    unsigned int v9 = BYTE1(a3);
  }
  if (v8)
  {
    if (BYTE1(a3) >= a4) {
      int v10 = 65025;
    }
    else {
      int v10 = (int)(v4 * v8) / (int)(a4 - v9);
    }
  }
  else
  {
    int v10 = 0;
  }
  if (a1 >= a2) {
    unsigned int v11 = a2;
  }
  else {
    unsigned int v11 = a1;
  }
  if (a3 >= a4) {
    unsigned int v12 = a4;
  }
  else {
    unsigned int v12 = a3;
  }
  if (v11)
  {
    if (a3 >= a4) {
      int v13 = 65025;
    }
    else {
      int v13 = (int)(v4 * v11) / (int)(a4 - v12);
    }
  }
  else
  {
    int v13 = 0;
  }
  unsigned int v14 = v7 + (a4 ^ 0xFF) * v5;
  unsigned int v15 = v10 + (a4 ^ 0xFF) * v8;
  if (a4 == 255)
  {
    unsigned int v14 = v7;
    int v16 = v10;
  }
  else
  {
    int v16 = v15;
  }
  if (a4 != 255) {
    v13 += (a4 ^ 0xFF) * v11;
  }
  int v17 = v14 + v6 * (a2 ^ 0xFF);
  int v18 = v16 + v9 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    int v17 = v14;
    int v19 = v16;
  }
  else
  {
    int v19 = v18;
  }
  if (a2 == 255) {
    int v20 = v13;
  }
  else {
    int v20 = v13 + v12 * (a2 ^ 0xFF);
  }
  int v21 = 255 * (a4 + a2) - a4 * a2;
  if (v17 >= v21) {
    int v17 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v19 >= v21) {
    int v19 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v20 >= v21) {
    int v20 = 255 * (a4 + a2) - a4 * a2;
  }
  if (v19 >= 65152) {
    unsigned int v22 = 65152;
  }
  else {
    unsigned int v22 = v19 + 128;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v20 >= 65152) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v20 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (v21 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v21 + 128;
  }
  unsigned int v27 = (v26 + (v26 >> 8)) >> 8;
  if (v17 >= 65152) {
    int v28 = 16711680;
  }
  else {
    int v28 = (257 * v17 + 32896) & 0xFF0000;
  }
  return v28 & 0xFF0000 | (v27 << 24) | v23 & 0xFF00 | BYTE1(v25);
}

uint64_t PDAcolorburnPDA_14631(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE1(a1);
  unsigned int v6 = a1;
  unsigned int v7 = BYTE1(a3);
  unsigned int v8 = a3;
  int v9 = a4 * a2;
  if (BYTE2(a3) >= a4) {
    signed int v10 = a4;
  }
  else {
    signed int v10 = BYTE2(a3);
  }
  if (v4 >= a2) {
    unsigned int v11 = a2;
  }
  else {
    unsigned int v11 = v4;
  }
  if (v7 >= a4) {
    signed int v12 = a4;
  }
  else {
    signed int v12 = v7;
  }
  if (v5 >= a2) {
    unsigned int v13 = a2;
  }
  else {
    unsigned int v13 = v5;
  }
  if (v8 >= a4) {
    signed int v14 = a4;
  }
  else {
    signed int v14 = v8;
  }
  if (v6 >= a2) {
    unsigned int v15 = a2;
  }
  else {
    unsigned int v15 = v6;
  }
  int v16 = v9 + (a4 ^ 0xFF) * v11;
  unsigned int v17 = v9 + (a4 ^ 0xFF) * v13;
  if (a4 == 255)
  {
    int v16 = a4 * a2;
    unsigned int v17 = 255 * a2;
    int v18 = 255 * a2;
  }
  else
  {
    int v18 = v9 + (a4 ^ 0xFF) * v15;
  }
  if (a2 == 255) {
    unsigned int v19 = v16;
  }
  else {
    unsigned int v19 = v16 + v10 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    unsigned int v20 = v18;
  }
  else
  {
    v17 += v12 * (a2 ^ 0xFF);
    unsigned int v20 = v18 + v14 * (a2 ^ 0xFF);
  }
  if (v4 < a2)
  {
    if (v10) {
      unsigned int v19 = (v19 - (int)(a4 * a4 * (a2 - v11)) / v10) & ~((int)(v19 - (int)(a4 * a4 * (a2 - v11)) / v10) >> 31);
    }
    else {
      unsigned int v19 = 0;
    }
  }
  if (v5 < a2)
  {
    if (v12) {
      unsigned int v17 = (v17 - (int)(a4 * a4 * (a2 - v13)) / v12) & ~((int)(v17 - (int)(a4 * a4 * (a2 - v13)) / v12) >> 31);
    }
    else {
      unsigned int v17 = 0;
    }
  }
  if (v6 < a2)
  {
    if (v14) {
      unsigned int v20 = (v20 - (int)(a4 * a4 * (a2 - v15)) / v14) & ~((int)(v20 - (int)(a4 * a4 * (a2 - v15)) / v14) >> 31);
    }
    else {
      unsigned int v20 = 0;
    }
  }
  int v21 = 255 * (a4 + a2) - v9;
  unsigned int v22 = v17 + 128;
  if (v17 >> 7 >= 0x1FD) {
    unsigned int v22 = 65152;
  }
  unsigned int v23 = v22 + (v22 >> 8);
  if (v20 >> 7 >= 0x1FD) {
    unsigned int v24 = 65152;
  }
  else {
    unsigned int v24 = v20 + 128;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (v21 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v21 + 128;
  }
  unsigned int v27 = (v26 + (v26 >> 8)) >> 8;
  if (v19 >> 7 >= 0x1FD) {
    int v28 = 16711680;
  }
  else {
    int v28 = (257 * v19 + 32896) & 0xFF0000;
  }
  return v28 & 0xFFFFFF | (v27 << 24) | v23 & 0xFF00 | (v25 >> 8);
}

uint64_t PDAhardlightPDA_14632(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE1(a1);
  unsigned int v6 = a1;
  unsigned int v7 = BYTE2(a3);
  unsigned int v8 = BYTE1(a3);
  unsigned int v9 = a3;
  if (BYTE2(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v4 = a2;
  }
  int v10 = 2 * v4 * v7;
  if (BYTE1(a3) >= a4) {
    unsigned int v8 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v11 = 2 * v5 * v8;
  if (a3 >= a4) {
    unsigned int v9 = a4;
  }
  if (a1 >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 2 * v6 * v9;
  int v13 = a4 * a2;
  unsigned int v14 = (a4 + 1) >> 1;
  int v15 = a4 ^ 0xFF;
  int v16 = a2 ^ 0xFF;
  int v17 = v7 * (a2 ^ 0xFF) + (a4 ^ 0xFF) * v4 + v10;
  unsigned int v18 = a4 + 255;
  unsigned int v19 = a2 + 255;
  int v20 = (a4 + 255) * v4 + v7 * (a2 + 255) - (a4 * a2 + v10);
  if (v7 <= v14) {
    int v20 = v17;
  }
  int v21 = v8 * v16 + v15 * v5 + v11;
  int v22 = v18 * v5 + v8 * v19 - (v13 + v11);
  if (v8 <= v14) {
    int v22 = v21;
  }
  int v23 = v9 * v16 + v15 * v6 + v12;
  int v24 = v18 * v6 + v9 * v19 - (v13 + v12);
  if (v9 <= v14) {
    int v24 = v23;
  }
  int v25 = 255 * (a4 + a2) - v13;
  if (v22 >= 65152) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v22 + 128;
  }
  unsigned int v27 = v26 + (v26 >> 8);
  if (v24 >= 65152) {
    unsigned int v28 = 65152;
  }
  else {
    unsigned int v28 = v24 + 128;
  }
  unsigned int v29 = v28 + (v28 >> 8);
  if (v25 >= 65152) {
    unsigned int v30 = 65152;
  }
  else {
    unsigned int v30 = v25 + 128;
  }
  unsigned int v31 = (v30 + (v30 >> 8)) >> 8;
  if (v20 >= 65152) {
    int v32 = 16711680;
  }
  else {
    int v32 = (257 * v20 + 32896) & 0xFF0000;
  }
  return v32 & 0xFF0000 | (v31 << 24) | v27 & 0xFF00 | BYTE1(v29);
}

uint64_t PDAsoftlightPDA_14633(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE2(a3);
  if (BYTE2(a3) >= a4) {
    unsigned int v5 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v4 = a2;
  }
  unsigned int v6 = a3;
  unsigned int v7 = BYTE1(a3);
  unsigned int v8 = a1;
  unsigned int v9 = BYTE1(a1);
  int v10 = (int)(v4 * v4 * (2 * v5 - a4)) / (int)a2;
  int v11 = (2 * v4 * v5 - v10) & ~((int)(2 * v4 * v5 - v10) >> 31);
  if (BYTE1(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v9 = a2;
  }
  int v12 = (int)(v9 * v9 * (2 * v7 - a4)) / (int)a2;
  int v13 = (2 * v9 * v7 - v12) & ~((int)(2 * v9 * v7 - v12) >> 31);
  if (a3 >= a4) {
    unsigned int v6 = a4;
  }
  if (a1 >= a2) {
    unsigned int v8 = a2;
  }
  int v14 = 2 * v8 * v6 - (int)(v8 * v8 * (2 * v6 - a4)) / (int)a2;
  int v15 = v14 & ~(v14 >> 31);
  unsigned int v16 = v11 + (a4 ^ 0xFF) * v4;
  int v17 = v13 + v9 * (a4 ^ 0xFF);
  int v18 = v15 + v8 * (a4 ^ 0xFF);
  if (a4 == 255)
  {
    unsigned int v16 = v11;
    int v17 = v13;
    int v18 = v15;
  }
  unsigned int v19 = v16 + v5 * (a2 ^ 0xFF);
  unsigned int v20 = v17 + v7 * (a2 ^ 0xFF);
  unsigned int v21 = v18 + v6 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    unsigned int v22 = v17;
  }
  else
  {
    unsigned int v16 = v19;
    unsigned int v22 = v20;
  }
  if (a2 == 255) {
    unsigned int v21 = v18;
  }
  int v23 = 255 * (a4 + a2) - a4 * a2;
  unsigned int v24 = v22 + 128;
  if (v22 >> 7 >= 0x1FD) {
    unsigned int v24 = 65152;
  }
  unsigned int v25 = v24 + (v24 >> 8);
  if (v21 >> 7 >= 0x1FD) {
    unsigned int v26 = 65152;
  }
  else {
    unsigned int v26 = v21 + 128;
  }
  unsigned int v27 = v26 + (v26 >> 8);
  if (v23 >= 65152) {
    unsigned int v28 = 65152;
  }
  else {
    unsigned int v28 = v23 + 128;
  }
  unsigned int v29 = (v28 + (v28 >> 8)) >> 8;
  if (v16 >> 7 >= 0x1FD) {
    int v30 = 16711680;
  }
  else {
    int v30 = (257 * v16 + 32896) & 0xFF0000;
  }
  return v30 & 0xFF0000 | (v29 << 24) | v25 & 0xFF00 | BYTE1(v27);
}

uint64_t PDAdifferencePDA_14634(unsigned __int32 a1, unsigned int a2, unsigned __int32 a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE2(a3);
  v6.i32[0] = a1;
  v6.i32[1] = a1 >> 8;
  v7.i32[0] = a3;
  v7.i32[1] = a3 >> 8;
  int32x2_t v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8(v7, (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a4));
  int32x2_t v9 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8(v6, (int8x8_t)0xFF000000FFLL), (uint32x2_t)vdup_n_s32(a2));
  int32x2_t v10 = vmul_s32((int32x2_t)__PAIR64__(v8.u32[1], v9.u32[0]), (int32x2_t)__PAIR64__(a2, a4));
  int32x2_t v11 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  if (BYTE2(a3) >= a4) {
    unsigned int v5 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v4 = a2;
  }
  unsigned int v12 = v5 + v4;
  int v13 = v4 * a4;
  int v14 = v5 * a2;
  int v16 = v13 - v14;
  BOOL v15 = v13 - v14 < 0;
  int v17 = 255 * v12 - v14 - v13;
  if (v15) {
    int v18 = -v16;
  }
  else {
    int v18 = v16;
  }
  int v19 = v17 + v18;
  int v20 = 255 * (a4 + a2) - a4 * a2;
  int32x2_t v21 = vadd_s32(v8, v9);
  v8.i32[1] = v9.i32[1];
  int32x2_t v22 = vmul_s32(v8, v11);
  uint32x2_t v23 = (uint32x2_t)__PAIR64__(v10.u32[1], v22.u32[0]);
  int32x2_t v24 = vneg_s32(v10);
  v10.i32[1] = v22.i32[1];
  int32x2_t v25 = (int32x2_t)vaba_u32((uint32x2_t)vsub_s32(vmla_s32(v24, v21, (int32x2_t)0xFF000000FFLL), v22), v23, (uint32x2_t)v10);
  unsigned int v26 = v25.i32[1] + 128;
  int32x2_t v27 = vcgt_s32(vdup_n_s32(0xFE80u), v25);
  if ((v27.i8[4] & 1) == 0) {
    unsigned int v26 = 65152;
  }
  unsigned int v28 = v26 + (v26 >> 8);
  unsigned int v29 = v25.i32[0] + 128;
  if ((v27.i8[0] & 1) == 0) {
    unsigned int v29 = 65152;
  }
  unsigned int v30 = v29 + (v29 >> 8);
  if (v20 >= 65152) {
    unsigned int v31 = 65152;
  }
  else {
    unsigned int v31 = v20 + 128;
  }
  unsigned int v32 = (v31 + (v31 >> 8)) >> 8;
  if (v19 >= 65152) {
    int v33 = 16711680;
  }
  else {
    int v33 = (257 * v19 + 32896) & 0xFF0000;
  }
  return v33 & 0xFF0000 | (v32 << 24) | v28 & 0xFF00 | BYTE1(v30);
}

uint64_t PDAexclusionPDA_14635(int a1, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int v4 = BYTE2(a1);
  unsigned int v5 = BYTE1(a1);
  unsigned int v6 = a1;
  unsigned int v7 = BYTE2(a3);
  if (BYTE2(a3) >= a4) {
    unsigned int v7 = a4;
  }
  if (BYTE2(a1) >= a2) {
    unsigned int v4 = a2;
  }
  int v8 = 255 * (v7 + v4) - 2 * v4 * v7;
  if (BYTE1(a3) >= a4) {
    unsigned int v9 = a4;
  }
  else {
    unsigned int v9 = BYTE1(a3);
  }
  if (BYTE1(a1) >= a2) {
    unsigned int v5 = a2;
  }
  int v10 = 255 * (v9 + v5) - 2 * v5 * v9;
  if (a3 >= a4) {
    unsigned int v11 = a4;
  }
  else {
    unsigned int v11 = a3;
  }
  if (a1 >= a2) {
    unsigned int v6 = a2;
  }
  int v12 = 255 * (v11 + v6) - 2 * v6 * v11;
  int v13 = 255 * (a4 + a2) - a4 * a2;
  if (v10 >= 65152) {
    unsigned int v14 = 65152;
  }
  else {
    unsigned int v14 = v10 + 128;
  }
  unsigned int v15 = v14 + (v14 >> 8);
  if (v12 >= 65152) {
    unsigned int v16 = 65152;
  }
  else {
    unsigned int v16 = v12 + 128;
  }
  unsigned int v17 = v16 + (v16 >> 8);
  if (v13 >= 65152) {
    unsigned int v18 = 65152;
  }
  else {
    unsigned int v18 = v13 + 128;
  }
  unsigned int v19 = (v18 + (v18 >> 8)) >> 8;
  if (v8 >= 65152) {
    int v20 = 16711680;
  }
  else {
    int v20 = (257 * v8 + 32896) & 0xFF0000;
  }
  return v20 & 0xFF0000 | v15 & 0xFF00 | (v19 << 24) | BYTE1(v17);
}

uint64_t PDAhuePDA_14636(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a1;
  int32x2_t v5 = vdup_n_s32(a4);
  int32x2_t v6 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v5);
  int32x2_t v7 = vdup_n_s32(a2);
  double v8 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7));
  if (a3 >= a4) {
    unsigned int v9 = a4;
  }
  else {
    unsigned int v9 = a3;
  }
  if (a1 >= a2) {
    unsigned int v4 = a2;
  }
  double v10 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v8));
  uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v8, v5);
  double v12 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL));
  if (a4 == 255) {
    int v13 = 0;
  }
  else {
    int v13 = (a4 ^ 0xFF) * v4;
  }
  if (a4 == 255) {
    unsigned int v14 = v4;
  }
  else {
    unsigned int v14 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  }
  if (a4 == 255)
  {
    double v10 = 0.0;
    double v15 = v8;
  }
  else
  {
    double v15 = v12;
  }
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v10, v6, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v6, v7);
  double v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  unsigned int v19 = v13 + v9 * (a2 ^ 0xFF);
  signed int v20 = (v9 * a2 + 128 + ((v9 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    unsigned int v19 = v13;
    signed int v20 = v9;
    double v21 = v10;
  }
  else
  {
    *(double *)&int32x2_t v6 = v18;
    double v21 = v16;
  }
  int32x2_t v53 = v6;
  signed int v54 = v20;
  unsigned __int8 v22 = vcge_u32((uint32x2_t)v6, (uint32x2_t)vdup_lane_s32(v6, 1)).u8[0];
  uint64_t v23 = v22 & 1;
  uint64_t v24 = (v22 & 1) == 0;
  if (v20 >= *(_DWORD *)((unint64_t)&v53 & 0xFFFFFFFFFFFFFFFBLL | (4 * v23)))
  {
    BOOL v26 = v20 <= *(_DWORD *)((unint64_t)&v53 | (4 * v24));
    uint64_t v25 = v22 & 1;
    if (v26) {
      uint64_t v23 = 2;
    }
    else {
      uint64_t v23 = (v22 & 1) == 0;
    }
    if (!v26) {
      uint64_t v24 = 2;
    }
  }
  else
  {
    uint64_t v25 = 2;
  }
  __int32 v27 = v53.i32[v24];
  __int32 v28 = v53.i32[v25];
  __int32 v29 = v27 - v28;
  if (v27 <= v28)
  {
    v53.i32[v24] = 0;
    v53.i32[v23] = 0;
    int v30 = LODWORD(v15);
    int v31 = HIDWORD(v15);
  }
  else
  {
    int v30 = LODWORD(v15);
    int v31 = HIDWORD(v15);
    if (LODWORD(v15) >= HIDWORD(v15)) {
      unsigned int v32 = HIDWORD(v15);
    }
    else {
      unsigned int v32 = LODWORD(v15);
    }
    if (LODWORD(v15) <= HIDWORD(v15)) {
      unsigned int v33 = HIDWORD(v15);
    }
    else {
      unsigned int v33 = LODWORD(v15);
    }
    if (v14 <= v33) {
      unsigned int v34 = v33;
    }
    else {
      unsigned int v34 = v14;
    }
    if (v14 >= v32) {
      unsigned int v33 = v34;
    }
    else {
      unsigned int v32 = v14;
    }
    unsigned int v35 = v33 - v32;
    v53.i32[v24] = v35;
    v53.i32[v23] = ((v53.i32[v23] - v53.i32[v25]) * ((int)(v35 << 16) / v29) + 0x8000) >> 16;
  }
  v53.i32[v25] = 0;
  int v36 = 77 * (v30 - v53.i32[0]) + 151 * (v31 - v53.i32[1]) + 28 * (v14 - v54);
  int v37 = v53.i32[0] + ((v36 + 128) >> 8);
  int v38 = v53.i32[1] + ((v36 + 128) >> 8);
  signed int v39 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v40 = v54 + ((v36 + 128) >> 8);
  if (v36 != (char)v36)
  {
    if (v53.i32[0] >= v53.i32[1]) {
      int v41 = v53.i32[1] + ((v36 + 128) >> 8);
    }
    else {
      int v41 = v53.i32[0] + ((v36 + 128) >> 8);
    }
    if (v53.i32[0] >= v53.i32[1]) {
      int v42 = v53.i32[0] + ((v36 + 128) >> 8);
    }
    else {
      int v42 = v53.i32[1] + ((v36 + 128) >> 8);
    }
    if (v40 <= v42) {
      int v43 = v42;
    }
    else {
      int v43 = v54 + ((v36 + 128) >> 8);
    }
    if (v40 >= v41) {
      int v44 = v41;
    }
    else {
      int v44 = v54 + ((v36 + 128) >> 8);
    }
    if (v40 >= v41) {
      int v42 = v43;
    }
    if (v42 > v39 || v44 < 0)
    {
      int v45 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      if (v36 > -129)
      {
        int v46 = v42 - v45;
        if (v42 == v45) {
          goto LABEL_63;
        }
        int v47 = v39 - v45;
      }
      else
      {
        int v46 = v45 - v44;
        if (v45 == v44) {
          goto LABEL_63;
        }
        int v47 = (77 * v37 + 151 * v38 + 28 * v40 + 128) >> 8;
      }
      int v48 = (v47 << 16) / v46;
      int v37 = v45 + ((v48 * (v37 - v45) + 0x8000) >> 16);
      int v38 = v45 + ((v48 * (v38 - v45) + 0x8000) >> 16);
      int v40 = v45 + ((v48 * (v40 - v45) + 0x8000) >> 16);
    }
  }
LABEL_63:
  if (v19 >> 7 >= 0x1FD) {
    unsigned int v49 = 65152;
  }
  else {
    unsigned int v49 = v19 + 128;
  }
  if (HIDWORD(v21) >> 7 >= 0x1FD) {
    unsigned int v50 = 65152;
  }
  else {
    unsigned int v50 = HIDWORD(v21) + 128;
  }
  if (LODWORD(v21) >> 7 >= 0x1FD) {
    unsigned int v51 = 65152;
  }
  else {
    unsigned int v51 = LODWORD(v21) + 128;
  }
  return (v40 + ((unsigned __int16)(v49 + (v49 >> 8)) >> 8)) | ((a4 + a2 - v39) << 24) | ((_WORD)v50 + (unsigned __int16)(v50 >> 8) + ((_WORD)v38 << 8)) & 0xFF00 | ((v37 + ((unsigned __int16)(v51 + (v51 >> 8)) >> 8)) << 16);
}

uint64_t PDAsaturationPDA_14637(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int32x2_t v4 = vdup_n_s32(a4);
  double v5 = COERCE_DOUBLE(vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v4));
  int32x2_t v6 = vdup_n_s32(a2);
  int32x2_t v7 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v6);
  if (a3 >= a4) {
    unsigned int v8 = a4;
  }
  else {
    unsigned int v8 = a3;
  }
  if (a1 >= a2) {
    signed int v9 = a2;
  }
  else {
    signed int v9 = a1;
  }
  if (a4 == 255)
  {
    unsigned int v12 = 0;
    int32x2_t v10 = 0;
  }
  else
  {
    int32x2_t v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v7);
    uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v7, v4);
    int32x2_t v7 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    unsigned int v12 = (a4 ^ 0xFF) * v9;
    signed int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  double v13 = COERCE_DOUBLE(vrev64_s32(v10));
  double v14 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v5, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v15 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v5, v6);
  double v16 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v15, v15, 8uLL), 8uLL));
  unsigned int v17 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255) {
    unsigned int v17 = v8;
  }
  else {
    v12 += v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    double v16 = v5;
    double v18 = v13;
  }
  else
  {
    double v18 = v14;
  }
  int32x2_t v47 = v7;
  signed int v48 = v9;
  uint64_t v19 = v7.i32[0] < (unsigned __int32)v7.i32[1];
  uint64_t v20 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
  if (v9 >= *(_DWORD *)((unint64_t)&v47 | (4 * v20)))
  {
    uint64_t v21 = v7.i32[0] >= (unsigned __int32)v7.i32[1];
    if (v9 <= *(_DWORD *)((unint64_t)&v47 | (4 * v19))) {
      uint64_t v20 = 2;
    }
    else {
      uint64_t v20 = v7.i32[0] < (unsigned __int32)v7.i32[1];
    }
    if (v9 > *(_DWORD *)((unint64_t)&v47 | (4 * v19))) {
      uint64_t v19 = 2;
    }
  }
  else
  {
    uint64_t v21 = 2;
  }
  __int32 v22 = v47.i32[v19];
  __int32 v23 = v47.i32[v21];
  BOOL v24 = __OFSUB__(v22, v23);
  int v25 = v22 - v23;
  if ((v25 < 0) ^ v24 | (v25 == 0))
  {
    v47.i32[v19] = 0;
    v47.i32[v20] = 0;
  }
  else
  {
    unsigned int v26 = LODWORD(v16);
    if (HIDWORD(v16) >= LODWORD(v16)) {
      unsigned int v27 = LODWORD(v16);
    }
    else {
      unsigned int v27 = HIDWORD(v16);
    }
    if (HIDWORD(v16) > LODWORD(v16)) {
      unsigned int v26 = HIDWORD(v16);
    }
    if (v17 <= v26) {
      unsigned int v28 = v26;
    }
    else {
      unsigned int v28 = v17;
    }
    if (v17 >= v27)
    {
      unsigned int v17 = v27;
      unsigned int v26 = v28;
    }
    unsigned int v29 = v26 - v17;
    v47.i32[v19] = v29;
    v47.i32[v20] = ((v47.i32[v20] - v47.i32[v21]) * ((int)(v29 << 16) / v25) + 0x8000) >> 16;
  }
  v47.i32[v21] = 0;
  int v30 = 77 * (v7.i32[0] - v47.i32[0]) + 151 * (v7.i32[1] - v47.i32[1]) + 28 * (v9 - v48);
  int v31 = v47.i32[0] + ((v30 + 128) >> 8);
  int v32 = v47.i32[1] + ((v30 + 128) >> 8);
  signed int v33 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v34 = v48 + ((v30 + 128) >> 8);
  if (v30 != (char)v30)
  {
    if (v47.i32[0] >= v47.i32[1]) {
      int v35 = v47.i32[1] + ((v30 + 128) >> 8);
    }
    else {
      int v35 = v47.i32[0] + ((v30 + 128) >> 8);
    }
    if (v47.i32[0] >= v47.i32[1]) {
      int v36 = v47.i32[0] + ((v30 + 128) >> 8);
    }
    else {
      int v36 = v47.i32[1] + ((v30 + 128) >> 8);
    }
    if (v34 <= v36) {
      int v37 = v36;
    }
    else {
      int v37 = v48 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      int v38 = v35;
    }
    else {
      int v38 = v48 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      int v36 = v37;
    }
    if (v36 > v33 || v38 < 0)
    {
      int v39 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      if (v30 > -129)
      {
        int v40 = v36 - v39;
        if (v36 == v39) {
          goto LABEL_59;
        }
        int v41 = v33 - v39;
      }
      else
      {
        int v40 = v39 - v38;
        if (v39 == v38) {
          goto LABEL_59;
        }
        int v41 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      }
      int v42 = (v41 << 16) / v40;
      int v31 = v39 + ((v42 * (v31 - v39) + 0x8000) >> 16);
      int v32 = v39 + ((v42 * (v32 - v39) + 0x8000) >> 16);
      int v34 = v39 + ((v42 * (v34 - v39) + 0x8000) >> 16);
    }
  }
LABEL_59:
  if (v12 >> 7 >= 0x1FD) {
    unsigned int v43 = 65152;
  }
  else {
    unsigned int v43 = v12 + 128;
  }
  if (LODWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v44 = 65152;
  }
  else {
    unsigned int v44 = LODWORD(v18) + 128;
  }
  if (HIDWORD(v18) >> 7 >= 0x1FD) {
    unsigned int v45 = 65152;
  }
  else {
    unsigned int v45 = HIDWORD(v18) + 128;
  }
  return (v34 + ((unsigned __int16)(v43 + (v43 >> 8)) >> 8)) | ((a4 + a2 - v33) << 24) | ((_WORD)v44 + (unsigned __int16)(v44 >> 8) + ((_WORD)v32 << 8)) & 0xFF00 | ((v31 + ((unsigned __int16)(v45 + (v45 >> 8)) >> 8)) << 16);
}

uint64_t PDAluminosityPDA_14638(unsigned __int8 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  unsigned int v5 = a3;
  int32x2_t v6 = vdup_n_s32(a4);
  int32x2_t v7 = vdup_n_s32(a2);
  int32x2_t v8 = (int32x2_t)vmin_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL), (uint32x2_t)v7);
  if (a3 >= a4) {
    unsigned int v5 = a4;
  }
  if (a1 >= a2) {
    unsigned int v9 = a2;
  }
  else {
    unsigned int v9 = a1;
  }
  if (a4 == 255)
  {
    unsigned int v12 = 0;
    int32x2_t v10 = 0;
  }
  else
  {
    int32x2_t v10 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v8);
    uint32x2_t v11 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v8, v6);
    int32x2_t v8 = (int32x2_t)vshr_n_u32(vsra_n_u32(v11, v11, 8uLL), 8uLL);
    unsigned int v12 = (a4 ^ 0xFF) * v9;
    unsigned int v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
  }
  int32x2_t v13 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v6);
  if (a2 != 255)
  {
    int32x2_t v10 = vmla_s32(v10, v13, vdup_n_s32(a2 ^ 0xFF));
    uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v13, v7);
    int32x2_t v13 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
    v12 += v5 * (a2 ^ 0xFF);
    unsigned int v5 = (v5 * a2 + 128 + ((v5 * a2 + 128) >> 8)) >> 8;
  }
  int32x2_t v15 = vmul_s32(vsub_s32(v13, v8), (int32x2_t)0x4D00000097);
  int v16 = v15.i32[0] + 28 * (v5 - v9) + v15.i32[1];
  int v17 = v8.i32[1] + ((v16 + 128) >> 8);
  __int32 v18 = v8.i32[0] + ((v16 + 128) >> 8);
  signed int v19 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v20 = v9 + ((v16 + 128) >> 8);
  if (v16 != (char)v16)
  {
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0]) {
      int v21 = v8.i32[0] + ((v16 + 128) >> 8);
    }
    else {
      int v21 = v8.i32[1] + ((v16 + 128) >> 8);
    }
    if (v8.i32[1] >= (unsigned __int32)v8.i32[0]) {
      int v22 = v8.i32[1] + ((v16 + 128) >> 8);
    }
    else {
      int v22 = v8.i32[0] + ((v16 + 128) >> 8);
    }
    if (v20 <= v22) {
      int v23 = v22;
    }
    else {
      int v23 = v20;
    }
    if (v20 >= v21) {
      int v24 = v21;
    }
    else {
      int v24 = v20;
    }
    if (v20 >= v21) {
      int v22 = v23;
    }
    if (v22 > v19 || v24 < 0)
    {
      int v25 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      if (v16 > -129)
      {
        int v26 = v22 - v25;
        if (v22 == v25) {
          goto LABEL_34;
        }
        int v27 = v19 - v25;
      }
      else
      {
        int v26 = v25 - v24;
        if (v25 == v24) {
          goto LABEL_34;
        }
        int v27 = (77 * v17 + 151 * v18 + 28 * v20 + 128) >> 8;
      }
      int v28 = (v27 << 16) / v26;
      int v17 = v25 + ((v28 * (v17 - v25) + 0x8000) >> 16);
      __int32 v18 = v25 + ((v28 * (v18 - v25) + 0x8000) >> 16);
      int v20 = v25 + ((v28 * (v20 - v25) + 0x8000) >> 16);
    }
  }
LABEL_34:
  unsigned int v29 = a4 + a2 - v19;
  unsigned int v30 = v12 + 128;
  if (v12 >> 7 >= 0x1FD) {
    unsigned int v30 = 65152;
  }
  unsigned int v31 = v20 + ((v30 + (v30 >> 8)) >> 8);
  uint32x2_t v32 = vcgt_u32((uint32x2_t)vdup_n_s32(0xFE80u), (uint32x2_t)v10);
  unsigned int v33 = v10.i32[0] + 128;
  if ((v32.i8[0] & 1) == 0) {
    unsigned int v33 = 65152;
  }
  unsigned int v34 = v33 + (v33 >> 8);
  if (v32.i8[4]) {
    unsigned int v35 = v10.i32[1] + 128;
  }
  else {
    unsigned int v35 = 65152;
  }
  return v31 | (v29 << 24) | ((_WORD)v34 + ((_WORD)v18 << 8)) & 0xFF00 | ((v17 + ((unsigned __int16)(v35 + (v35 >> 8)) >> 8)) << 16);
}

uint64_t PDAtranspose_huePDA_14639(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a1;
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  uint32x2_t v6 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4) {
    unsigned int v7 = a4;
  }
  else {
    unsigned int v7 = a3;
  }
  if (a1 >= a2) {
    unsigned int v4 = a2;
  }
  int32x2_t v8 = vdup_n_s32(a4);
  double v9 = COERCE_DOUBLE(vmin_u32(v6, (uint32x2_t)v8));
  int32x2_t v10 = vdup_n_s32(a2);
  double v11 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v10));
  int v12 = (a4 ^ 0xFF) * v4;
  double v13 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFF), *(int32x2_t *)&v11));
  uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v11, v8);
  double v15 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL));
  if (a4 == 255)
  {
    int v12 = 0;
    unsigned int v16 = v4;
  }
  else
  {
    unsigned int v16 = (v4 * a4 + 128 + ((v4 * a4 + 128) >> 8)) >> 8;
  }
  if (a4 == 255)
  {
    double v13 = 0.0;
    double v17 = v11;
  }
  else
  {
    double v17 = v15;
  }
  double v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v13, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v19 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  double v20 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v19, v19, 8uLL), 8uLL));
  if (a2 == 255) {
    unsigned int v21 = v12;
  }
  else {
    unsigned int v21 = v12 + v7 * (a2 ^ 0xFF);
  }
  if (a2 == 255) {
    unsigned int v22 = v7;
  }
  else {
    unsigned int v22 = (v7 * a2 + 128 + ((v7 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    double v23 = v13;
  }
  else
  {
    double v9 = v20;
    double v23 = v18;
  }
  int v55 = v22;
  double v56 = v9;
  BOOL v24 = v22 >= LODWORD(v9);
  uint64_t v25 = v22 < LODWORD(v9);
  uint64_t v26 = v24;
  if (SHIDWORD(v9) >= *(&v55 + v26))
  {
    int v28 = *(&v55 + v25);
    uint64_t v27 = v26;
    if (SHIDWORD(v9) <= v28) {
      uint64_t v26 = 2;
    }
    else {
      uint64_t v26 = v25;
    }
    if (SHIDWORD(v9) > v28) {
      uint64_t v25 = 2;
    }
  }
  else
  {
    uint64_t v27 = 2;
  }
  int v29 = *(&v55 + v25);
  int v30 = *(&v55 + v27);
  int v31 = v29 - v30;
  if (v29 <= v30)
  {
    *(&v55 + v25) = 0;
    *(&v55 + v26) = 0;
    int v32 = LODWORD(v17);
    int v35 = HIDWORD(v17);
  }
  else
  {
    int v32 = LODWORD(v17);
    if (v16 >= LODWORD(v17)) {
      unsigned int v33 = LODWORD(v17);
    }
    else {
      unsigned int v33 = v16;
    }
    if (v16 <= LODWORD(v17)) {
      unsigned int v34 = LODWORD(v17);
    }
    else {
      unsigned int v34 = v16;
    }
    int v35 = HIDWORD(v17);
    if (HIDWORD(v17) <= v34) {
      unsigned int v36 = v34;
    }
    else {
      unsigned int v36 = HIDWORD(v17);
    }
    if (HIDWORD(v17) >= v33) {
      unsigned int v34 = v36;
    }
    else {
      unsigned int v33 = HIDWORD(v17);
    }
    int v37 = v34 - v33;
    *(&v55 + v25) = v37;
    *(&v55 + v26) = ((*(&v55 + v26) - *(&v55 + v27)) * ((v37 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v55 + v27) = 0;
  int v38 = 77 * (v16 - v55) + 151 * (v32 - LODWORD(v56)) + 28 * (v35 - HIDWORD(v56));
  int v39 = v55 + ((v38 + 128) >> 8);
  int v40 = LODWORD(v56) + ((v38 + 128) >> 8);
  signed int v41 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v42 = HIDWORD(v56) + ((v38 + 128) >> 8);
  if (v38 != (char)v38)
  {
    if (v55 >= SLODWORD(v56)) {
      int v43 = LODWORD(v56) + ((v38 + 128) >> 8);
    }
    else {
      int v43 = v55 + ((v38 + 128) >> 8);
    }
    if (v55 >= SLODWORD(v56)) {
      signed int v44 = v55 + ((v38 + 128) >> 8);
    }
    else {
      signed int v44 = LODWORD(v56) + ((v38 + 128) >> 8);
    }
    if (v42 <= v44) {
      int v45 = v44;
    }
    else {
      int v45 = HIDWORD(v56) + ((v38 + 128) >> 8);
    }
    if (v42 >= v43) {
      int v46 = v43;
    }
    else {
      int v46 = HIDWORD(v56) + ((v38 + 128) >> 8);
    }
    if (v42 >= v43) {
      signed int v44 = v45;
    }
    if (v44 > v41 || v46 < 0)
    {
      int v47 = (77 * v39 + 151 * v40 + 28 * v42 + 128) >> 8;
      if (v38 > -129)
      {
        int v48 = v44 - v47;
        if (v44 == v47) {
          goto LABEL_69;
        }
        int v49 = v41 - v47;
      }
      else
      {
        int v48 = v47 - v46;
        if (v47 == v46) {
          goto LABEL_69;
        }
        int v49 = (77 * v39 + 151 * v40 + 28 * v42 + 128) >> 8;
      }
      int v50 = (v49 << 16) / v48;
      int v39 = v47 + ((v50 * (v39 - v47) + 0x8000) >> 16);
      int v40 = v47 + ((v50 * (v40 - v47) + 0x8000) >> 16);
      int v42 = v47 + ((v50 * (v42 - v47) + 0x8000) >> 16);
    }
  }
LABEL_69:
  if (HIDWORD(v23) >> 7 >= 0x1FD) {
    unsigned int v51 = 65152;
  }
  else {
    unsigned int v51 = HIDWORD(v23) + 128;
  }
  if (LODWORD(v23) >> 7 >= 0x1FD) {
    unsigned int v52 = 65152;
  }
  else {
    unsigned int v52 = LODWORD(v23) + 128;
  }
  if (v21 >> 7 >= 0x1FD) {
    unsigned int v53 = 65152;
  }
  else {
    unsigned int v53 = v21 + 128;
  }
  return ((a4 + a2 - v41) << 24) | ((v42 + ((unsigned __int16)(v51 + (v51 >> 8)) >> 8)) << 16) | (v52 + (v52 >> 8) + (v40 << 8)) & 0xFF00 | (v39 + ((unsigned __int16)(v53 + (v53 >> 8)) >> 8));
}

uint64_t PDAtranspose_saturationPDA_14640(unsigned __int8 a1, unsigned int a2, unsigned __int8 a3, unsigned int a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint32x2_t v4 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4) {
    unsigned int v6 = a4;
  }
  else {
    unsigned int v6 = a3;
  }
  if (a1 >= a2) {
    unsigned int v7 = a2;
  }
  else {
    unsigned int v7 = a1;
  }
  int32x2_t v8 = vdup_n_s32(a4);
  double v9 = COERCE_DOUBLE(vmin_u32(v5, (uint32x2_t)v8));
  int32x2_t v10 = vdup_n_s32(a2);
  int32x2_t v11 = (int32x2_t)vmin_u32(v4, (uint32x2_t)v10);
  if (a4 == 255)
  {
    unsigned int v12 = 0;
    int32x2_t v13 = 0;
  }
  else
  {
    unsigned int v12 = (a4 ^ 0xFF) * v7;
    unsigned int v7 = (v7 * a4 + 128 + ((v7 * a4 + 128) >> 8)) >> 8;
    int32x2_t v13 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v11);
    uint32x2_t v14 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v11, v8);
    int32x2_t v11 = (int32x2_t)vshr_n_u32(vsra_n_u32(v14, v14, 8uLL), 8uLL);
  }
  double v15 = COERCE_DOUBLE(vrev64_s32(v13));
  double v16 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, *(int32x2_t *)&v9, vdup_n_s32(a2 ^ 0xFF)));
  uint32x2_t v17 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v9, v10);
  double v18 = COERCE_DOUBLE(vshr_n_u32(vsra_n_u32(v17, v17, 8uLL), 8uLL));
  if (a2 == 255)
  {
    unsigned int v19 = v6;
  }
  else
  {
    v12 += v6 * (a2 ^ 0xFF);
    unsigned int v19 = (v6 * a2 + 128 + ((v6 * a2 + 128) >> 8)) >> 8;
  }
  if (a2 == 255)
  {
    double v18 = v9;
    double v20 = v15;
  }
  else
  {
    double v20 = v16;
  }
  int v49 = v7;
  int32x2_t v50 = v11;
  uint64_t v21 = v7 < v11.i32[0];
  uint64_t v22 = v7 >= v11.i32[0];
  if (v11.i32[1] >= *(&v49 + v22))
  {
    uint64_t v23 = v7 >= v11.i32[0];
    if (v11.i32[1] <= *(&v49 + v21)) {
      uint64_t v22 = 2;
    }
    else {
      uint64_t v22 = v7 < v11.i32[0];
    }
    if (v11.i32[1] > *(&v49 + v21)) {
      uint64_t v21 = 2;
    }
  }
  else
  {
    uint64_t v23 = 2;
  }
  int v24 = *(&v49 + v21);
  int v25 = *(&v49 + v23);
  BOOL v26 = __OFSUB__(v24, v25);
  int v27 = v24 - v25;
  if ((v27 < 0) ^ v26 | (v27 == 0))
  {
    *(&v49 + v21) = 0;
    *(&v49 + v22) = 0;
  }
  else
  {
    if (v19 >= HIDWORD(v18)) {
      unsigned int v28 = HIDWORD(v18);
    }
    else {
      unsigned int v28 = v19;
    }
    if (v19 <= HIDWORD(v18)) {
      unsigned int v19 = HIDWORD(v18);
    }
    unsigned int v29 = LODWORD(v18);
    if (LODWORD(v18) <= v19) {
      unsigned int v30 = v19;
    }
    else {
      unsigned int v30 = LODWORD(v18);
    }
    if (LODWORD(v18) >= v28)
    {
      unsigned int v29 = v28;
      unsigned int v19 = v30;
    }
    int v31 = v19 - v29;
    *(&v49 + v21) = v31;
    *(&v49 + v22) = ((*(&v49 + v22) - *(&v49 + v23)) * ((v31 << 16) / v27) + 0x8000) >> 16;
  }
  *(&v49 + v23) = 0;
  int v32 = 77 * (v7 - v49) + 151 * (v11.i32[0] - v50.i32[0]) + 28 * (v11.i32[1] - v50.i32[1]);
  int v33 = v49 + ((v32 + 128) >> 8);
  int v34 = v50.i32[0] + ((v32 + 128) >> 8);
  signed int v35 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int v36 = v50.i32[1] + ((v32 + 128) >> 8);
  if (v32 != (char)v32)
  {
    if (v49 >= v50.i32[0]) {
      int v37 = v50.i32[0] + ((v32 + 128) >> 8);
    }
    else {
      int v37 = v49 + ((v32 + 128) >> 8);
    }
    if (v49 >= v50.i32[0]) {
      signed int v38 = v49 + ((v32 + 128) >> 8);
    }
    else {
      signed int v38 = v50.i32[0] + ((v32 + 128) >> 8);
    }
    if (v36 <= v38) {
      int v39 = v38;
    }
    else {
      int v39 = v50.i32[1] + ((v32 + 128) >> 8);
    }
    if (v36 >= v37) {
      int v40 = v37;
    }
    else {
      int v40 = v50.i32[1] + ((v32 + 128) >> 8);
    }
    if (v36 >= v37) {
      signed int v38 = v39;
    }
    if (v38 > v35 || v40 < 0)
    {
      int v41 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      if (v32 > -129)
      {
        int v42 = v38 - v41;
        if (v38 == v41) {
          goto LABEL_59;
        }
        int v43 = v35 - v41;
      }
      else
      {
        int v42 = v41 - v40;
        if (!v42) {
          goto LABEL_59;
        }
        int v43 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      }
      int v44 = (v43 << 16) / v42;
      int v33 = v41 + ((v44 * (v33 - v41) + 0x8000) >> 16);
      int v34 = v41 + ((v44 * (v34 - v41) + 0x8000) >> 16);
      int v36 = v41 + ((v44 * (v36 - v41) + 0x8000) >> 16);
    }
  }
LABEL_59:
  if (LODWORD(v20) >> 7 >= 0x1FD) {
    unsigned int v45 = 65152;
  }
  else {
    unsigned int v45 = LODWORD(v20) + 128;
  }
  unsigned int v46 = HIDWORD(v20) + 128;
  if (HIDWORD(v20) >> 7 >= 0x1FD) {
    unsigned int v46 = 65152;
  }
  if (v12 >> 7 >= 0x1FD) {
    unsigned int v47 = 65152;
  }
  else {
    unsigned int v47 = v12 + 128;
  }
  return ((a4 + a2 - v35) << 24) | ((v36 + ((unsigned __int16)(v45 + (v45 >> 8)) >> 8)) << 16) | (v46 + (v46 >> 8) + (v34 << 8)) & 0xFF00 | (v33 + ((unsigned __int16)(v47 + (v47 >> 8)) >> 8));
}

uint64_t PDAtranspose_luminosityPDA_14641(unsigned __int8 a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4 = a3;
  uint32x2_t v5 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  uint32x2_t v6 = (uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL);
  if (a3 >= a4) {
    unsigned int v4 = a4;
  }
  int32x2_t v7 = vdup_n_s32(a4);
  if (a1 >= a2) {
    unsigned int v8 = a2;
  }
  else {
    unsigned int v8 = a1;
  }
  int32x2_t v9 = vdup_n_s32(a2);
  int32x2_t v10 = (int32x2_t)vmin_u32(v5, (uint32x2_t)v9);
  if (a4 == 255)
  {
    unsigned int v11 = 0;
    int32x2_t v12 = 0;
  }
  else
  {
    unsigned int v11 = (a4 ^ 0xFF) * v8;
    unsigned int v8 = (v8 * a4 + 128 + ((v8 * a4 + 128) >> 8)) >> 8;
    int32x2_t v12 = vmul_s32(vdup_n_s32(a4 ^ 0xFF), v10);
    uint32x2_t v13 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v10, v7);
    int32x2_t v10 = (int32x2_t)vshr_n_u32(vsra_n_u32(v13, v13, 8uLL), 8uLL);
  }
  int32x2_t v14 = (int32x2_t)vmin_u32(v6, (uint32x2_t)v7);
  if (a2 != 255)
  {
    v11 += v4 * (a2 ^ 0xFF);
    unsigned int v4 = (v4 * a2 + 128 + ((v4 * a2 + 128) >> 8)) >> 8;
    int32x2_t v12 = vmla_s32(v12, v14, vdup_n_s32(a2 ^ 0xFF));
    uint32x2_t v15 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, v14, v9);
    int32x2_t v14 = (int32x2_t)vshr_n_u32(vsra_n_u32(v15, v15, 8uLL), 8uLL);
  }
  signed int v16 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  int32x2_t v17 = vmul_s32(vsub_s32(v14, v10), (int32x2_t)0x1C00000097);
  signed __int32 v18 = vadd_s32(v17, vdup_lane_s32(v17, 1)).u32[0] + 77 * (v4 - v8);
  int v19 = v8 + ((v18 + 128) >> 8);
  __int32 v20 = v10.i32[0] + ((v18 + 128) >> 8);
  int v21 = v10.i32[1] + ((v18 + 128) >> 8);
  if (v18 != (char)v18)
  {
    BOOL v22 = v8 >= v10.i32[0];
    if (v8 >= v10.i32[0]) {
      int v23 = v10.i32[0] + ((v18 + 128) >> 8);
    }
    else {
      int v23 = v8 + ((v18 + 128) >> 8);
    }
    if (v22) {
      signed int v24 = v19;
    }
    else {
      signed int v24 = v10.i32[0] + ((v18 + 128) >> 8);
    }
    if (v21 <= v24) {
      int v25 = v24;
    }
    else {
      int v25 = v10.i32[1] + ((v18 + 128) >> 8);
    }
    if (v21 >= v23) {
      int v26 = v23;
    }
    else {
      int v26 = v10.i32[1] + ((v18 + 128) >> 8);
    }
    if (v21 >= v23) {
      signed int v24 = v25;
    }
    if (v24 > v16 || v26 < 0)
    {
      int v27 = (77 * v19 + 151 * v20 + 28 * v21 + 128) >> 8;
      if (v18 > -129)
      {
        int v28 = v24 - v27;
        if (v24 == v27) {
          goto LABEL_34;
        }
        int v29 = v16 - v27;
      }
      else
      {
        int v28 = v27 - v26;
        if (v27 == v26) {
          goto LABEL_34;
        }
        int v29 = (77 * v19 + 151 * v20 + 28 * v21 + 128) >> 8;
      }
      int v30 = (v29 << 16) / v28;
      int v19 = v27 + ((v30 * (v19 - v27) + 0x8000) >> 16);
      __int32 v20 = v27 + ((v30 * (v20 - v27) + 0x8000) >> 16);
      int v21 = v27 + ((v30 * (v21 - v27) + 0x8000) >> 16);
    }
  }
LABEL_34:
  unsigned int v31 = a4 + a2 - v16;
  uint32x2_t v32 = vcgt_u32((uint32x2_t)vdup_n_s32(0xFE80u), (uint32x2_t)v12);
  unsigned int v33 = v12.i32[1] + 128;
  if ((v32.i8[4] & 1) == 0) {
    unsigned int v33 = 65152;
  }
  unsigned int v34 = v21 + ((v33 + (v33 >> 8)) >> 8);
  unsigned int v35 = v12.i32[0] + 128;
  if ((v32.i8[0] & 1) == 0) {
    unsigned int v35 = 65152;
  }
  unsigned int v36 = v35 + (v35 >> 8);
  if (v11 >> 7 >= 0x1FD) {
    unsigned int v37 = 65152;
  }
  else {
    unsigned int v37 = v11 + 128;
  }
  return (v31 << 24) | (v34 << 16) | ((_WORD)v36 + ((_WORD)v20 << 8)) & 0xFF00 | (v19 + ((unsigned __int16)(v37 + (v37 >> 8)) >> 8));
}

uint64_t argb32_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(result + 280);
  float v5 = *(float *)(*(void *)(result + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = result + 368;
  uint64_t v10 = *(void *)(result + 368);
  int v11 = 15;
  if (v10) {
    uint64_t v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(result + 284);
  float v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  float v14 = *(float *)(result + 304);
  float v15 = *(float *)(result + 308);
  float v16 = *(float *)(result + 312);
  float v17 = *(float *)(result + 316);
  float v18 = *(float *)(result + 336);
  float v19 = *(float *)(result + 348);
  float v20 = *(float *)(result + 344);
  float v21 = *(float *)(result + 356);
  BOOL v22 = *(_WORD **)(result + 376);
  uint64_t v23 = *(void *)(result + 360);
  int v24 = 4 * *(_DWORD *)(result + 48);
  if (v10) {
    uint64_t v25 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v25 = 0;
  }
  int v27 = *(char **)(result + 144);
  int v26 = *(int **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      unsigned int v35 = (_WORD *)(v23
                    + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                    + 8 * (int)(float)(v20 * (float)(v8 - v18)));
      __int16 v36 = v35[1];
      int v37 = *(unsigned __int8 *)(v9 + v25);
      int v38 = (unsigned __int16)v35[2];
      __int16 v39 = v35[3];
      __int16 v32 = v37 + *v35;
      __int16 v33 = v37 + v36;
      CFCalendarRef result = (v37 + v38);
      __int16 v34 = v37 + v39;
      goto LABEL_21;
    }
    if (v22)
    {
      int v31 = *(unsigned __int8 *)(v9 + v25);
      __int16 v32 = v31 + *v22;
      __int16 v33 = v31 + v22[1];
      CFCalendarRef result = v31 + (unsigned __int16)v22[2];
      __int16 v34 = v31 + v22[3];
LABEL_21:
      *int v26 = v33 & 0xFF00 | (HIBYTE(v32) << 16) & 0xFFFFFF | BYTE1(result) | (HIBYTE(v34) << 24);
      char v40 = -1;
      goto LABEL_22;
    }
    char v40 = 0;
LABEL_22:
    uint64_t v25 = (v25 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    ++v26;
    *v27++ = v40;
    --a4;
  }
  while (a4);
  return result;
}

void argb32_shade_conic_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  uint64_t v9 = *(void *)(a1 + 368);
  if (v9) {
    uint64_t v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v10 = a1 + 368;
  }
  if (v9) {
    int v11 = 15;
  }
  else {
    int v11 = 0;
  }
  float v12 = *(float *)(a1 + 284);
  float v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  float v37 = *(float *)(a1 + 336);
  float v38 = *(float *)(a1 + 304);
  float v15 = *(float *)(a1 + 344);
  uint64_t v16 = *(void *)(a1 + 360);
  float v18 = *(unsigned char **)(a1 + 144);
  float v17 = *(unsigned int **)(a1 + 152);
  if (v9) {
    uint64_t v19 = ((unint64_t)a2 >> 8) & 0xF;
  }
  else {
    uint64_t v19 = 0;
  }
  float v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    float v21 = v15 * (float)((float)(v38 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v37);
    unsigned int v22 = vcvtms_s32_f32(v21);
    float v23 = ceilf(v21);
    float v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    unsigned int v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0) {
      unsigned int v22 = v25;
    }
    float v26 = ceilf(v21 - v15);
    if (v21 <= v15) {
      float v27 = v23;
    }
    else {
      float v27 = v26;
    }
    int v28 = (unsigned __int16 *)(v16 + 2 * (int)(4 * v22));
    int v29 = *v28;
    int v30 = 255 - (int)v24;
    int v31 = v28[1];
    int v32 = v28[2];
    __int16 v33 = (unsigned __int16 *)(v16 + 8 * (int)v27);
    int v34 = v33[2];
    int v35 = (int)v24 * *v33;
    LODWORD(v28) = (int)v24 * v33[3] + v30 * v28[3];
    LODWORD(v33) = (int)v24 * v33[1] + v30 * v31;
    int v36 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = (v35 + (v36 << 8) + v30 * v29) & 0xFF0000 | (v36 + (v33 >> 8)) & 0xFF00 | ((unsigned __int16)(v36 + (((int)v24 * v34 + v30 * v32) >> 8)) >> 8) | (((unsigned __int16)(v36 + (v28 >> 8)) >> 8) << 24);
    uint64_t v19 = (v19 + 1) & v11;
    float v8 = v4 + v8;
    float v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
}

void argb32_shade_radial_RGB(uint64_t a1, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float v13 = *(float *)(a1 + 280);
  float v14 = *(float *)(a1 + 284);
  float v15 = *(float *)(*(void *)(a1 + 272) + 4);
  float v16 = v15 * (float)a2;
  float v17 = v15 * (float)(uint64_t)a3;
  float v18 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v17) + (float)(v13 * v16));
  float v19 = *(float *)(a1 + 300) + (float)((float)(v17 * *(float *)(a1 + 292)) + (float)(v14 * v16));
  uint64_t v21 = *(void *)(a1 + 400);
  float v22 = *(float *)(a1 + 336);
  float v23 = *(float *)(a1 + 344);
  float v24 = *(float *)(a1 + 304);
  float v25 = *(float *)(a1 + 308);
  int v26 = *(_DWORD *)(a1 + 324);
  LODWORD(a12) = *(_DWORD *)(v21 + 8);
  float v27 = *(float *)(v21 + 16);
  float v28 = *(float *)(v21 + 20);
  float v29 = *(float *)(v21 + 28);
  uint64_t v32 = a1 + 144;
  int v30 = *(char **)(a1 + 144);
  uint64_t v31 = *(void *)(v32 + 8);
  __int16 v33 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v34 = *(void *)(a1 + 360);
  uint64_t v35 = ((unint64_t)a2 >> 8) & 0xF;
  if (*(float *)&a12 != 0.0 || v29 != 0.0 || v14 != 0.0)
  {
    int v47 = *(_DWORD *)(a1 + 320);
    float v48 = *(float *)(v21 + 12);
    float v49 = *(float *)(v21 + 24);
    float v50 = *(float *)(v21 + 32);
    uint64_t v51 = a1 + 368;
    uint64_t v52 = *(void *)(a1 + 368);
    uint64_t v53 = v52 + ((a3 >> 4) & 0xF0);
    BOOL v39 = v52 == 0;
    int v54 = 15;
    if (v39)
    {
      int v54 = 0;
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v51 = v53;
    }
    float v55 = -v49;
    float v56 = v25 - v24;
    while (1)
    {
      float v57 = v55 + (float)((float)(v18 + v18) * *(float *)&a12);
      float v58 = (float)((float)(v19 * v19) + (float)(v18 * v18)) - v29;
      if (v28 == 0.0)
      {
        float v65 = v58 / v57;
      }
      else
      {
        float v59 = (float)((float)(v28 * -4.0) * v58) + (float)(v57 * v57);
        if (v59 < 0.0) {
          goto LABEL_56;
        }
        float v60 = sqrtf(v59);
        float v61 = v50 * (float)(v57 - v60);
        float v62 = v57 + v60;
        float v63 = v50 * v62;
        BOOL v64 = (float)(v50 * v62) <= v61;
        if ((float)(v50 * v62) <= v61) {
          float v65 = v50 * v62;
        }
        else {
          float v65 = v61;
        }
        if (v64) {
          float v63 = v61;
        }
        if (v63 < 0.0)
        {
          BOOL v66 = v63 < v48;
LABEL_42:
          int v67 = v47;
          if (v66) {
            goto LABEL_56;
          }
LABEL_43:
          if ((v67 & 0x80000000) == 0) {
            goto LABEL_55;
          }
          goto LABEL_56;
        }
        if (v63 <= 1.0)
        {
          float v68 = v24 + (float)(v63 * v56);
          goto LABEL_54;
        }
        if ((v26 & 0x80000000) == 0)
        {
          int v67 = v26;
          if (v63 <= v27)
          {
LABEL_55:
            char v69 = (_WORD *)(v34 + 8 * v67);
            __int16 v70 = v69[1];
            __int16 v71 = *(unsigned __int8 *)(v51 + v35);
            __int16 v72 = v69[2];
            __int16 v73 = v69[3];
            __int16 v74 = v71 + *v69;
            __int16 v75 = v71 + v70;
            __int16 v76 = v71 + v72;
            __int16 v77 = v71 + v73;
            goto LABEL_58;
          }
        }
      }
      if (v65 < 0.0)
      {
        BOOL v66 = v65 < v48;
        goto LABEL_42;
      }
      if (v65 > 1.0)
      {
        int v67 = v26;
        if (v65 > v27) {
          goto LABEL_56;
        }
        goto LABEL_43;
      }
      float v68 = v24 + (float)(v65 * v56);
LABEL_54:
      int v67 = (int)(float)(v23 * (float)(v68 - v22));
      if ((v67 & 0x80000000) == 0) {
        goto LABEL_55;
      }
LABEL_56:
      if (!v33)
      {
        char v79 = 0;
        goto LABEL_60;
      }
      __int16 v78 = *(unsigned __int8 *)(v51 + v35);
      __int16 v74 = v78 + *v33;
      __int16 v75 = v78 + v33[1];
      __int16 v76 = v78 + v33[2];
      __int16 v77 = v78 + v33[3];
LABEL_58:
      *(_DWORD *)uint64_t v31 = v75 & 0xFF00 | (HIBYTE(v74) << 16) & 0xFFFFFF | HIBYTE(v76) | (HIBYTE(v77) << 24);
      char v79 = -1;
LABEL_60:
      uint64_t v35 = (v35 + 1) & v54;
      float v18 = v13 + v18;
      float v19 = v14 + v19;
      v31 += 4;
      *v30++ = v79;
      if (!--a4) {
        return;
      }
    }
  }
  uint64_t v36 = a1 + 368;
  uint64_t v37 = *(void *)(a1 + 368);
  int v38 = (BYTE1(a2) + 1) & 0xF;
  BOOL v39 = v37 == 0;
  if (v37) {
    uint64_t v40 = v37 + ((a3 >> 4) & 0xF0);
  }
  else {
    uint64_t v40 = v36;
  }
  if (v39) {
    LODWORD(v41) = 0;
  }
  else {
    LODWORD(v41) = v38;
  }
  if (v39) {
    LODWORD(v42) = 0;
  }
  else {
    LODWORD(v42) = v35;
  }
  if (v39) {
    int v43 = 0;
  }
  else {
    int v43 = 15;
  }
  float v44 = v19 * v19;
  float v45 = -v28;
  if (v44 <= (float)-v28)
  {
    float v80 = fabsf(*(float *)(v21 + 32));
    float v81 = v28 * -4.0;
    float v82 = v25 - v24;
    uint64_t v83 = (unsigned __int16 *)(v34 + 8 * v26);
    int v84 = a4 + 2;
    while (1)
    {
      float v85 = v44 + (float)(v18 * v18);
      float v86 = v13 + v18;
      float v87 = v44 + (float)(v86 * v86);
      if (v85 > v45 && v87 > v45)
      {
        if (v26 < 0)
        {
          if (!v33)
          {
            char v121 = 0;
            char v120 = 0;
            goto LABEL_84;
          }
          int v96 = *v33;
          unsigned __int16 v97 = v33[1];
          unsigned __int16 v98 = v33[2];
          int v99 = v33[3];
        }
        else
        {
          int v96 = *v83;
          unsigned __int16 v97 = v83[1];
          unsigned __int16 v98 = v83[2];
          int v99 = v83[3];
        }
        int v114 = *(unsigned __int8 *)(v40 + v42);
        unsigned int v115 = (v114 + v96) >> 8;
        __int16 v116 = v114 + v97;
        __int16 v117 = v114 + v98;
        unsigned int v118 = (v114 + v99) >> 8;
        __int16 v119 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v119 + v96;
        __int16 v111 = v119 + v97;
        __int16 v112 = v119 + v98;
        __int16 v113 = v119 + v99;
        *(_DWORD *)uint64_t v31 = v116 & 0xFF00 | (v115 << 16) & 0xFFFFFF | HIBYTE(v117) | (v118 << 24);
        goto LABEL_82;
      }
      float v89 = sqrtf(v81 * v87);
      float v90 = v80 * sqrtf(v81 * v85);
      float v91 = v80 * v89;
      int v92 = (int)(float)(v23 * (float)((float)(v24 + (float)(v90 * v82)) - v22));
      int v93 = (int)(float)(v23 * (float)((float)(v24 + (float)((float)(v80 * v89) * v82)) - v22));
      if (v90 <= 1.0 && v91 <= 1.0)
      {
        unint64_t v100 = (unsigned __int16 *)(v34 + 8 * v92);
        int v101 = (__int16 *)(v34 + 8 * v93);
        __int16 v102 = *v101;
        __int16 v103 = v101[1];
        __int16 v104 = v101[2];
        __int16 v105 = v101[3];
        LODWORD(v101) = *(unsigned __int8 *)(v40 + v42);
        unsigned int v106 = (v101 + *v100) >> 8;
        __int16 v107 = (_WORD)v101 + v100[1];
        __int16 v108 = (_WORD)v101 + v100[2];
        LODWORD(v100) = (v101 + v100[3]) >> 8;
        __int16 v109 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v109 + v102;
        __int16 v111 = v109 + v103;
        __int16 v112 = v109 + v104;
        __int16 v113 = v109 + v105;
        *(_DWORD *)uint64_t v31 = v107 & 0xFF00 | (v106 << 16) & 0xFFFFFF | HIBYTE(v108) | (v100 << 24);
LABEL_82:
        char v120 = -1;
        goto LABEL_83;
      }
      if (v90 <= 1.0)
      {
        if ((v92 & 0x80000000) == 0)
        {
          uint64_t v95 = 4 * v92;
LABEL_88:
          unsigned int v122 = (_WORD *)(v34 + 2 * v95);
          __int16 v123 = v122[1];
          __int16 v124 = *(unsigned __int8 *)(v40 + v42);
          __int16 v125 = v122[2];
          __int16 v126 = v122[3];
          __int16 v127 = v124 + *v122;
          __int16 v128 = v124 + v123;
          __int16 v129 = v124 + v125;
          __int16 v130 = v124 + v126;
          goto LABEL_91;
        }
      }
      else if (v90 <= v27)
      {
        uint64_t v95 = 4 * v26;
        if ((v26 & 0x80000000) == 0) {
          goto LABEL_88;
        }
      }
      if (!v33)
      {
        char v120 = 0;
        goto LABEL_92;
      }
      __int16 v131 = *(unsigned __int8 *)(v40 + v42);
      __int16 v127 = v131 + *v33;
      __int16 v128 = v131 + v33[1];
      __int16 v129 = v131 + v33[2];
      __int16 v130 = v131 + v33[3];
LABEL_91:
      *(_DWORD *)uint64_t v31 = v128 & 0xFF00 | (HIBYTE(v127) << 16) & 0xFFFFFF | HIBYTE(v129) | (HIBYTE(v130) << 24);
      char v120 = -1;
LABEL_92:
      if (v91 <= 1.0)
      {
        if (v93 < 0) {
          goto LABEL_99;
        }
        uint64_t v132 = 4 * v93;
      }
      else if (v91 > v27 || (uint64_t v132 = 4 * v26, v26 < 0))
      {
LABEL_99:
        if (!v33)
        {
          char v121 = 0;
          goto LABEL_84;
        }
        __int16 v138 = *(unsigned __int8 *)(v40 + v41);
        __int16 v110 = v138 + *v33;
        __int16 v111 = v138 + v33[1];
        __int16 v112 = v138 + v33[2];
        __int16 v113 = v138 + v33[3];
        goto LABEL_83;
      }
      double v133 = (_WORD *)(v34 + 2 * v132);
      __int16 v134 = v133[1];
      __int16 v135 = *(unsigned __int8 *)(v40 + v41);
      __int16 v136 = v133[2];
      __int16 v137 = v133[3];
      __int16 v110 = v135 + *v133;
      __int16 v111 = v135 + v134;
      __int16 v112 = v135 + v136;
      __int16 v113 = v135 + v137;
LABEL_83:
      *(_DWORD *)(v31 + 4) = v111 & 0xFF00 | (HIBYTE(v110) << 16) & 0xFFFFFF | HIBYTE(v112) | (HIBYTE(v113) << 24);
      char v121 = -1;
LABEL_84:
      float v18 = v13 + v86;
      LOBYTE(v42) = (v42 + 1) & v43;
      LOBYTE(v41) = (v41 + 1) & v43;
      v31 += 8;
      *int v30 = v120;
      v30[1] = v121;
      v30 += 2;
      v84 -= 2;
      if (v84 <= 2) {
        return;
      }
    }
  }
  if (v33 || (v26 & 0x80000000) == 0)
  {
    double v139 = (unsigned __int16 *)(v34 + 8 * v26);
    if (v26 >= 0) {
      uint64_t v140 = v139;
    }
    else {
      uint64_t v140 = v33;
    }
    int32x2_t v141 = vdup_n_s32(*v140);
    int32x2_t v142 = vdup_n_s32(v140[1]);
    int32x2_t v143 = vdup_n_s32(v140[2]);
    int32x2_t v144 = vdup_n_s32(v140[3]);
    int v145 = a4 + 4;
    do
    {
      double v146 = (unsigned char *)(v40 + v42);
      uint64_t v42 = (v42 + 1) & v43;
      LOBYTE(a12) = *v146;
      BYTE4(a12) = *(unsigned char *)(v40 + v41);
      int32x2_t v147 = (int32x2_t)vand_s8(*(int8x8_t *)&a12, (int8x8_t)0xFF000000FFLL);
      int8x8_t v148 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v141, v147), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v142, v147), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v143, v147), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v144, v147), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
      *(int8x8_t *)uint64_t v31 = v148;
      uint64_t v41 = (v41 + 1) & v43;
      v148.i8[0] = *(unsigned char *)(v40 + v42);
      v148.i8[4] = *(unsigned char *)(v40 + v41);
      int32x2_t v149 = (int32x2_t)vand_s8(v148, (int8x8_t)0xFF000000FFLL);
      a12 = COERCE_DOUBLE(vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v141, v149), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v142, v149), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v143, v149), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v144, v149), 0x10uLL) & 0xFF00FFFFFF00FFFFLL))));
      *(double *)(v31 + 8) = a12;
      *(_DWORD *)int v30 = -1;
      v30 += 4;
      v145 -= 4;
      v31 += 16;
    }
    while (v145 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v46 = 4;
    }
    else {
      int v46 = a4;
    }
    bzero(v30, ((a4 - v46 + 3) & 0xFFFFFFFC) + 4);
  }
}

void argb32_mark_image_W8(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  float v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    float v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  float v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertW8toRGBA8888((char *)(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void argb32_mark_image_RGB24(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v39 = a2;
  int v10 = *(_DWORD *)(a1 + 28);
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v41 = v12;
  int v42 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v43) = *(_DWORD *)(a1 + 108);
    HIDWORD(v43) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v43, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_28;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  uint64_t v43 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertBGR888toRGBA8888", 195, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertBGR888toRGBA8888", 195, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v12);
    }
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * v8) + 3 * (v17 + v39);
    uint64_t v21 = *(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17);
    uint64_t v22 = v19 * (uint64_t)v8;
    uint64_t v23 = v12 - 1;
    uint64_t v24 = v20 + (int)v23 * v22;
    uint64_t v25 = v21 + v23 * v10;
    int v26 = (char *)(v10 < 0 ? v25 : v21);
    size_t v27 = v10 >= 0 ? v10 : -v10;
    size_t v28 = v10 >= 0 ? v22 : -(int)v22;
    float v29 = (char *)(v10 < 0 ? v24 : v20);
    if ((v28 & 0x80000000) != 0)
    {
      int v30 = (char *)malloc_type_malloc((int)v27 * v12, 0x52337FB7uLL);
      uint64_t v31 = v30;
      if (v12 >= 1)
      {
        for (uint64_t i = 0; i != v12; ++i)
        {
          if (v11 >= 1)
          {
            __int16 v33 = &v30[i * v27];
            int v34 = v11;
            uint64_t v35 = &v29[i * (int)v28];
            do
            {
              char v36 = *v35;
              char v37 = v35[1];
              *__int16 v33 = v35[2];
              v33[1] = v37;
              v33[2] = v36;
              v33[3] = -1;
              v35 += 3;
              v33 += 4;
              --v34;
            }
            while (v34);
          }
        }
      }
      CGBlt_copyBytes(4 * v11, v12, v30, v26, v27, v27);
      free(v31);
      int v8 = a4;
      if (!v16) {
        return;
      }
    }
    else
    {
      v45.datdouble a = v29;
      v45.CGFloat height = v12;
      v45.CGFloat width = v11;
      v45.rowBytes = v28;
      v44.datdouble a = v26;
      v44.CGFloat height = v12;
      v44.CGFloat width = v11;
      v44.rowBytes = v27;
      vImageConvert_RGB888toBGRA8888(&v45, 0, 0xFFu, &v44, 0, 0);
      if (!v16) {
        return;
      }
    }
LABEL_28:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v43 + 1, &v43, &v42, &v41)) {
      break;
    }
    int v18 = v43;
    int v17 = HIDWORD(v43);
    int v12 = v41;
    int v11 = v42;
    if (v42 < 0) {
      goto LABEL_4;
    }
  }
  free(v16);
}

void argb32_mark_image_rgbx32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v25, v24, v13, v27, v26, 0x1Bu, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertARGB8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertXRGB8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void argb32_mark_image_xrgb32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v25 = v15;
  int v26 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    int v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  int v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, 0xC6u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGBlt_copyBytes(4 * v26, v25, v23, v24, v22 * a5, v13);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertRGBX8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v26, &v25)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void argb32_mark_image_W16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  int v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    int v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  int v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertW16toRGBA8888(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void argb32_mark_image_w16(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  uint64_t v12 = *(int *)(a1 + 28);
  int v13 = *(_DWORD *)(a1 + 4);
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a1 + 8);
  int v22 = v13;
  int v15 = *(int **)(a1 + 136);
  if (v15)
  {
    int v16 = *(_DWORD *)(a1 + 104);
    LODWORD(v23) = *(_DWORD *)(a1 + 108);
    HIDWORD(v23) = v16;
    shape_enum_clip_alloc(a1, a2, v15, 1, 1, 1, v16, v23, v13, v14);
    int v18 = v17;
    if (v17) {
      goto LABEL_5;
    }
  }
  int v19 = 0;
  int v20 = 0;
  int v18 = 0;
  uint64_t v23 = 0;
  while (1)
  {
    CGSConvertw16toRGBA8888(*(void *)(a1 + 88) + *(int *)(a1 + 76) * (uint64_t)(a3 + v20 * a4) + 2 * (v19 + v10), *(_DWORD *)(a1 + 76) * a4, (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v20) * v12 + 4 * (*(_DWORD *)(a1 + 12) + v19)), v12, v13, v14, a7, a8);
    if (!v18) {
      break;
    }
LABEL_5:
    if (!shape_enum_clip_next((uint64_t)v18, (int *)&v23 + 1, &v23, &v22, &v21))
    {
      free(v18);
      return;
    }
    int v20 = v23;
    int v19 = HIDWORD(v23);
    uint64_t v14 = v21;
    int v13 = v22;
  }
}

void argb32_mark_image_RGB48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v36 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v40 = v12;
  int v41 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v42) = *(_DWORD *)(a1 + 108);
    HIDWORD(v42) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v42, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  uint64_t v42 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertBGR16toRGBA8888", 465, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertBGR16toRGBA8888", 465, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v12);
    }
    int v39 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v36);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    size_t v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      size_t v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        size_t v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0x6AA0E972uLL);
      }
    }
    if (v12 >= 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        if (v11 >= 1)
        {
          uint64_t v31 = &v28[i * v26];
          int v32 = v11;
          __int16 v33 = (char *)(v20 + i * (int)v22);
          do
          {
            char v34 = *v33;
            char v35 = v33[2];
            char *v31 = v33[4];
            v31[1] = v35;
            v31[2] = v34;
            v31[3] = -1;
            v33 += 6;
            v31 += 4;
            --v32;
          }
          while (v32);
        }
      }
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    int v16 = v39;
    if (!v39) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v42 + 1, &v42, &v41, &v40))
    {
      free(v16);
      return;
    }
    int v18 = v42;
    int v17 = HIDWORD(v42);
    int v12 = v40;
    int v11 = v41;
    if (v41 < 0) {
      goto LABEL_4;
    }
  }
}

void argb32_mark_image_rgb48(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v38 = a2;
  uint64_t v9 = *(unsigned int *)(a1 + 28);
  uint64_t v10 = (int)v9;
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v42 = v12;
  int v43 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v44) = *(_DWORD *)(a1 + 108);
    HIDWORD(v44) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v44, v11, v12);
    int v16 = v15;
    if (v15) {
      goto LABEL_24;
    }
  }
  int v17 = 0;
  int v18 = 0;
  int v16 = 0;
  uint64_t v44 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertbgr16toRGBA8888", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertbgr16toRGBA8888", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v12);
    }
    int v41 = v16;
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * a4) + 6 * (v17 + v38);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17));
    uint64_t v22 = v19 * (uint64_t)a4;
    uint64_t v23 = v12 - 1;
    if ((v9 & 0x80000000) != 0)
    {
      v20 += (int)v23 * v22;
      LODWORD(v22) = -(int)v22;
      uint64_t v24 = v10;
      v21 += v23 * v10;
      uint64_t v25 = v9;
      int v26 = -(int)v9;
    }
    else
    {
      uint64_t v24 = v10;
      uint64_t v25 = v9;
      int v26 = v9;
    }
    unint64_t v27 = v20 + (int)((v22 * v23) & ((int)v22 >> 31));
    size_t v28 = v21;
    if (v27 <= (unint64_t)&v21[v12 * (uint64_t)v26])
    {
      int v29 = (int)v22 >= 0 ? v22 : -(int)v22;
      size_t v28 = v21;
      if (v27 + v12 * (uint64_t)v29 >= (unint64_t)v21) {
        size_t v28 = (char *)malloc_type_malloc(v12 * (uint64_t)v26, 0xC245444CuLL);
      }
    }
    if (v12 >= 1)
    {
      uint64_t v30 = 0;
      uint64_t v31 = (char *)(v20 + 5);
      do
      {
        if (v11 >= 1)
        {
          int v32 = &v28[v30 * v26];
          int v33 = v11;
          char v34 = v31;
          do
          {
            char v35 = *(v34 - 4);
            char v36 = *(v34 - 2);
            char v37 = *v34;
            v34 += 6;
            *int v32 = v37;
            v32[1] = v36;
            void v32[2] = v35;
            v32[3] = -1;
            v32 += 4;
            --v33;
          }
          while (v33);
        }
        ++v30;
        v31 += (int)v22;
      }
      while (v30 != v12);
    }
    if (v28 != v21)
    {
      CGBlt_copyBytes(4 * v11, v12, v28, v21, v26, v26);
      free(v28);
    }
    uint64_t v10 = v24;
    uint64_t v9 = v25;
    int v16 = v41;
    if (!v41) {
      break;
    }
LABEL_24:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v44 + 1, &v44, &v43, &v42))
    {
      free(v16);
      return;
    }
    int v18 = v44;
    int v17 = HIDWORD(v44);
    int v12 = v42;
    int v11 = v43;
    if (v43 < 0) {
      goto LABEL_4;
    }
  }
}

void argb32_mark_image_RGBA64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v63 = a2;
  int v62 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v68 = v10;
  int v69 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v70) = *(_DWORD *)(a1 + 108);
    HIDWORD(v70) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v70, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v70 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + v19 * v62 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    int v67 = v14;
    if (v63 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = -16777216;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FFLL;
        v25.i64[1] = 0xFF000000FFLL;
        v26.i64[0] = 0xFF000000FF000000;
        v26.i64[1] = 0xFF000000FF000000;
        v27.i64[0] = 0x1000100010001;
        v27.i64[1] = 0x1000100010001;
        do
        {
          int v28 = v9;
          int v29 = (uint32x4_t *)v21;
          uint64_t v30 = (__int32 *)v18;
          unsigned int v31 = v9;
          if (v9 >= 4)
          {
            do
            {
              v32.i32[0] = v30[1];
              v32.i32[1] = v30[3];
              v32.i32[2] = v30[5];
              v32.i32[3] = v30[7];
              int8x16_t v33 = (int8x16_t)vshlq_n_s32(v32, 8uLL);
              int32x4_t v34 = (int32x4_t)vshrq_n_u32((uint32x4_t)v33, 0x18uLL);
              int v35 = vaddvq_s32(v34);
              if (v35)
              {
                v36.i32[0] = *v30;
                v36.i32[1] = v30[2];
                v36.i32[2] = v30[4];
                v36.i32[3] = v30[6];
                int32x4_t v37 = (int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v36, 0x10uLL) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL)), (int8x16_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v36, 8uLL) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))), vorrq_s8(vandq_s8((int8x16_t)v32, v25), vandq_s8(v33, v26)));
                if (v35 != 1020)
                {
                  int32x4_t v38 = (int32x4_t)veorq_s8((int8x16_t)v34, v25);
                  v39.i16[0] = v29->u8[0];
                  v39.i16[1] = BYTE2(v29->u32[0]);
                  v39.i16[2] = BYTE4(v29->i64[0]);
                  v39.i16[3] = BYTE6(v29->i64[0]);
                  v39.i16[4] = v29->i64[1];
                  v39.i16[5] = BYTE2(v29->i64[1]);
                  v39.i16[6] = BYTE12(*(unsigned long long *)v29);
                  v39.i16[7] = BYTE14(*(unsigned long long *)v29);
                  int32x4_t v40 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v29, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v38);
                  int32x4_t v41 = vmulq_s32(v39, v38);
                  int32x4_t v37 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v41, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v41, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v37, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v40, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)int v29 = vorrq_s8((int8x16_t)v37, v24);
              }
              int v28 = v31 - 4;
              v30 += 8;
              ++v29;
              BOOL v42 = v31 > 7;
              v31 -= 4;
            }
            while (v42);
          }
          if (v28 >= 1)
          {
            int v43 = v28 + 1;
            do
            {
              __int32 v44 = v30[1];
              if (BYTE2(v44))
              {
                int v45 = (*v30 >> 8) & 0xFF00 | (*v30 << 16) & 0xFFFFFF | v30[1] | (BYTE2(v30[1]) << 24);
                if (BYTE2(v44) != 255) {
                  v45 += ((((v29->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                }
                          + 65537
                          + ((((v29->i32[0] & 0xFF00FF) * (BYTE2(v44) ^ 0xFFu)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (BYTE2(v44) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v29->i32[0] = v45 | v23;
              }
              int v29 = (uint32x4_t *)((char *)v29 + 4);
              --v43;
              v30 += 2;
            }
            while (v43 > 1);
          }
          v18 += v22;
          v21 += v62;
          BOOL v42 = v10-- <= 1;
        }
        while (!v42);
      }
    }
    else
    {
      BOOL v46 = 0;
      if (v20) {
        BOOL v46 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertBGRA16toRGBA8888", 499, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertBGRA16toRGBA8888", 499, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v10);
      }
      uint64_t v47 = v10 - 1;
      if (v62 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v48 = -v62;
        v21 += v47 * v62;
      }
      else
      {
        int v48 = v62;
      }
      unint64_t v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      float v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        int v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        float v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          int v52 = v48;
          uint64_t v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0xA390BB75uLL);
          int v48 = v52;
          float v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        for (uint64_t i = 0; i != v10; ++i)
        {
          if (v9 >= 1)
          {
            float v55 = &v50[i * v48];
            int v56 = v9;
            float v57 = (char *)(v18 + i * (int)v22);
            do
            {
              char v58 = *v57;
              char v59 = v57[2];
              char v60 = v57[6];
              if (!v46) {
                char v60 = -1;
              }
              *float v55 = v57[4];
              v55[1] = v59;
              v55[2] = v58;
              v55[3] = v60;
              v57 += 8;
              v55 += 4;
              --v56;
            }
            while (v56);
          }
        }
      }
      int v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    int v14 = v67;
    if (!v67) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v70 + 1, &v70, &v69, &v68))
    {
      free(v14);
      return;
    }
    int v16 = v70;
    int v15 = HIDWORD(v70);
    int v10 = v68;
    int v9 = v69;
  }
}

void argb32_mark_image_rgba64(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v64 = a2;
  int v63 = *(_DWORD *)(a1 + 28);
  int v9 = *(_DWORD *)(a1 + 4);
  int v10 = *(_DWORD *)(a1 + 8);
  int v69 = v10;
  int v70 = v9;
  int v11 = *(int **)(a1 + 136);
  if (v11)
  {
    int v12 = *(_DWORD *)(a1 + 104);
    LODWORD(v71) = *(_DWORD *)(a1 + 108);
    HIDWORD(v71) = v12;
    shape_enum_clip_alloc(a1, a2, v11, 1, 1, 1, v12, v71, v9, v10);
    int v14 = v13;
    if (v13) {
      goto LABEL_50;
    }
  }
  int v15 = 0;
  int v16 = 0;
  int v14 = 0;
  uint64_t v71 = 0;
  while (1)
  {
    int v17 = *(_DWORD *)(a1 + 76);
    uint64_t v18 = *(void *)(a1 + 88) + v17 * (uint64_t)(a4 + v16 * v8) + 8 * (v15 + a3);
    uint64_t v19 = *(int *)(a1 + 16) + (uint64_t)v16;
    uint64_t v20 = *(void *)(a1 + 48);
    unsigned int v21 = (char *)(*(void *)(a1 + 40) + v19 * v63 + 4 * (*(_DWORD *)(a1 + 12) + v15));
    uint64_t v22 = v17 * (uint64_t)v8;
    int v68 = v14;
    if (v64 == 2)
    {
      if (v20) {
        unsigned int v23 = 0;
      }
      else {
        unsigned int v23 = -16777216;
      }
      if (v10 >= 1)
      {
        int8x16_t v24 = (int8x16_t)vdupq_n_s32(v23);
        v25.i64[0] = 0xFF000000FFLL;
        v25.i64[1] = 0xFF000000FFLL;
        v26.i64[0] = 0xFF000000FF000000;
        v26.i64[1] = 0xFF000000FF000000;
        v27.i64[0] = 0x1000100010001;
        v27.i64[1] = 0x1000100010001;
        do
        {
          int v28 = v9;
          int v29 = (uint32x4_t *)v21;
          uint64_t v30 = (__int32 *)v18;
          unsigned int v31 = v9;
          if (v9 >= 4)
          {
            do
            {
              v32.i32[0] = v30[1];
              v32.i32[1] = v30[3];
              v32.i32[2] = v30[5];
              v32.i32[3] = v30[7];
              int32x4_t v33 = (int32x4_t)vshrq_n_u32((uint32x4_t)v32, 0x18uLL);
              int v34 = vaddvq_s32(v33);
              if (v34)
              {
                v35.i32[0] = *v30;
                v35.i32[1] = v30[2];
                v35.i32[2] = v30[4];
                v35.i32[3] = v30[6];
                int32x4_t v36 = (int32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v35, 8uLL) & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL)), (int8x16_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v35, 0x10uLL) & __PAIR128__(0xFFFFFF00FFFFFF00, 0xFFFFFF00FFFFFF00))), vorrq_s8(vandq_s8(v32, v26), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v32, 8uLL), v25)));
                if (v34 != 1020)
                {
                  int32x4_t v37 = (int32x4_t)veorq_s8((int8x16_t)v33, v25);
                  v38.i16[0] = v29->u8[0];
                  v38.i16[1] = BYTE2(v29->u32[0]);
                  v38.i16[2] = BYTE4(v29->i64[0]);
                  v38.i16[3] = BYTE6(v29->i64[0]);
                  v38.i16[4] = v29->i64[1];
                  v38.i16[5] = BYTE2(v29->i64[1]);
                  v38.i16[6] = BYTE12(*(unsigned long long *)v29);
                  v38.i16[7] = BYTE14(*(unsigned long long *)v29);
                  int32x4_t v39 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v29, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v37);
                  int32x4_t v40 = vmulq_s32(v38, v37);
                  int32x4_t v36 = vaddq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v40, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v40, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), vaddq_s32(v36, (int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v39, v27), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v39, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00))));
                }
                *(int8x16_t *)int v29 = vorrq_s8((int8x16_t)v36, v24);
              }
              int v28 = v31 - 4;
              v30 += 8;
              ++v29;
              BOOL v41 = v31 > 7;
              v31 -= 4;
            }
            while (v41);
          }
          if (v28 >= 1)
          {
            int v42 = v28 + 1;
            do
            {
              unsigned __int32 v43 = v30[1];
              unsigned __int32 v44 = HIBYTE(v43);
              if (HIBYTE(v43))
              {
                unsigned int v45 = HIWORD(*v30) & 0xFF00 | (BYTE1(*v30) << 16) | v43 & 0xFF000000 | BYTE1(v43);
                if (v44 != 255) {
                  v45 += ((((v29->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)
                }
                          + 65537
                          + ((((v29->i32[0] & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)
                         + 65537
                         + ((((((unsigned __int32)v29->i32[0] >> 8) & 0xFF00FF) * (v44 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00);
                v29->i32[0] = v45 | v23;
              }
              int v29 = (uint32x4_t *)((char *)v29 + 4);
              --v42;
              v30 += 2;
            }
            while (v42 > 1);
          }
          v18 += v22;
          v21 += v63;
          BOOL v41 = v10-- <= 1;
        }
        while (!v41);
      }
    }
    else
    {
      BOOL v46 = 0;
      if (v20) {
        BOOL v46 = *(void *)(a1 + 96) != 0;
      }
      if (v9 < 0) {
        _CGHandleAssert("CGSConvertbgra16toRGBA8888", 972, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, v9);
      }
      if (v10 < 0) {
        _CGHandleAssert("CGSConvertbgra16toRGBA8888", 972, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, v10);
      }
      uint64_t v47 = v10 - 1;
      if (v63 < 0)
      {
        v18 += (int)v47 * (uint64_t)(int)v22;
        LODWORD(v22) = -(int)v22;
        int v48 = -v63;
        v21 += v47 * v63;
      }
      else
      {
        int v48 = v63;
      }
      unint64_t v49 = v18 + (int)((v22 * v47) & ((int)v22 >> 31));
      float v50 = v21;
      if (v49 <= (unint64_t)&v21[v10 * (uint64_t)v48])
      {
        int v51 = (int)v22 >= 0 ? v22 : -(int)v22;
        float v50 = v21;
        if (v49 + v10 * (uint64_t)v51 >= (unint64_t)v21)
        {
          int v52 = v48;
          uint64_t v53 = (char *)malloc_type_malloc(v10 * (uint64_t)v48, 0x619F4619uLL);
          int v48 = v52;
          float v50 = v53;
        }
      }
      if (v10 >= 1)
      {
        uint64_t v54 = 0;
        float v55 = (char *)(v18 + 3);
        do
        {
          if (v9 >= 1)
          {
            int v56 = &v50[v54 * v48];
            float v57 = v55;
            int v58 = v9;
            do
            {
              char v59 = *(v57 - 2);
              char v60 = *v57;
              char v61 = v57[4];
              if (!v46) {
                char v61 = -1;
              }
              *int v56 = v57[2];
              v56[1] = v60;
              v56[2] = v59;
              v56[3] = v61;
              v56 += 4;
              v57 += 8;
              --v58;
            }
            while (v58);
          }
          ++v54;
          v55 += (int)v22;
        }
        while (v54 != v10);
      }
      int v8 = a5;
      if (v50 != v21)
      {
        CGBlt_copyBytes(4 * v9, v10, v50, v21, v48, v48);
        free(v50);
      }
    }
    int v14 = v68;
    if (!v68) {
      break;
    }
LABEL_50:
    if (!shape_enum_clip_next((uint64_t)v14, (int *)&v71 + 1, &v71, &v70, &v69))
    {
      free(v14);
      return;
    }
    int v16 = v71;
    int v15 = HIDWORD(v71);
    int v10 = v69;
    int v9 = v70;
  }
}

unint64_t argb32_image_mark_rgba64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v98 = *a2;
  float v7 = *(char **)(result + 32);
  if (*(void *)(result + 40)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 0xFFFFLL;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v97 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v94 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v94 * a4;
  int v14 = &v7[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
          + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v102 = result;
  char v95 = v12;
  uint64_t v96 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v92 = *((void *)a2 + 11);
    uint64_t v90 = ~(-1 << v12);
    uint64_t v91 = *((void *)a2 + 13);
    char v89 = v12 - 4;
    int v15 = v14 - 8;
    uint64_t v16 = v8 << 48;
    uint64_t v87 = a5;
    uint64_t v88 = -v11;
    uint64_t v86 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v91 - v13) | (v13 - v92)) < 0)
      {
        unsigned int v21 = 0;
        uint64_t v103 = 0;
      }
      else
      {
        uint64_t v17 = ((v13 & (unint64_t)v90) >> v89) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v88;
        if (!v19) {
          uint64_t v20 = v11;
        }
        uint64_t v103 = v20;
        unsigned int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v102 + 32) + (v13 >> v12) * v11;
      int v100 = a6;
      uint64_t v99 = v13;
      if (v98 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unsigned int v23 = (uint64_t *)v86;
        uint64_t v24 = v87;
        while (1)
        {
          uint64_t v25 = *(v23 - 1);
          uint64_t v26 = *v23;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25) {
            int v28 = (char *)(v22 + v25);
          }
          else {
            int v28 = v15;
          }
          if (v28 < v7) {
            int v28 = v7;
          }
          unint64_t v29 = *(void *)v28;
          uint64_t v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            int v42 = (char *)(v27 + v103);
            if ((unint64_t)v15 < v27 + v103) {
              int v42 = v15;
            }
            if (v42 < v7) {
              int v42 = v7;
            }
            unint64_t v43 = BLEND16_21384[v21];
            unint64_t v40 = v29 - ((v43 & v29) >> v21);
            unint64_t v41 = (v43 & *(void *)v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          CFCalendarRef result = BYTE5(v29) | (BYTE1(v29) << 16) | (BYTE3(v29) << 8) | ((v29 | v16) >> 32) & 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v24) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v26 >> 4;
        int8x16_t v32 = (char *)(v27 + (v26 >> 4));
        if (v15 < v32) {
          int8x16_t v32 = v15;
        }
        if (v32 < v7) {
          int8x16_t v32 = v7;
        }
        unint64_t v33 = *(void *)v32;
        if (v21)
        {
          int v34 = (char *)(v27 + v103);
          if (v15 >= v34) {
            int32x4_t v35 = v34;
          }
          else {
            int32x4_t v35 = v15;
          }
          if (v35 < v7) {
            int32x4_t v35 = v7;
          }
          unint64_t v36 = *(void *)v35;
          int32x4_t v37 = &v34[v31];
          if (v15 < v37) {
            int32x4_t v37 = v15;
          }
          if (v37 < v7) {
            int32x4_t v37 = v7;
          }
          unint64_t v38 = BLEND16_21384[v21];
          unint64_t v29 = v29 - ((v38 & v29) >> v21) + ((v38 & v36) >> v21);
          unint64_t v33 = v33 - ((v38 & v33) >> v21) + ((v38 & *(void *)v37) >> v21);
        }
        uint64_t v39 = BLEND16_21384[v30];
        unint64_t v40 = v29 - ((v39 & v29) >> v30);
        unint64_t v41 = (v39 & v33) >> v30;
LABEL_42:
        unint64_t v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v96;
      v9 += v97;
      LOBYTE(v12) = v95;
      uint64_t v13 = v99 + v94;
      a6 = v100 - 1;
      if (v100 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    unsigned int v45 = (uint64_t *)v86;
    uint64_t v44 = v87;
    while (1)
    {
      uint64_t v46 = *(v45 - 1);
      uint64_t v47 = *v45;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46) {
        unint64_t v49 = (char *)(v22 + v46);
      }
      else {
        unint64_t v49 = v15;
      }
      if (v49 < v7) {
        unint64_t v49 = v7;
      }
      unint64_t v50 = *(void *)v49;
      uint64_t v51 = *v45 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v63 = (char *)(v48 + v103);
        if ((unint64_t)v15 < v48 + v103) {
          int v63 = v15;
        }
        if (v63 < v7) {
          int v63 = v7;
        }
        unint64_t v64 = BLEND16_21384[v21];
        unint64_t v61 = v50 - ((v64 & v50) >> v21);
        unint64_t v62 = (v64 & *(void *)v63) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      int v65 = ((v50 | v16) >> 32) & 0xFF000000;
      unsigned int v66 = BYTE5(v50) | (BYTE1(v50) << 16) | (BYTE3(v50) << 8);
      unsigned int v67 = v66 | v65;
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v66 | v65, v6);
        unsigned int v67 = result;
      }
      if (HIBYTE(v67))
      {
        if (HIBYTE(v67) == 255) {
          *int v9 = v67;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v9, v67, *v9, ~v67 >> 24);
        }
      }
      v45 += 2;
      ++v9;
      if (!--v44) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = v47 >> 4;
    uint64_t v53 = (char *)(v48 + (v47 >> 4));
    if (v15 < v53) {
      uint64_t v53 = v15;
    }
    if (v53 < v7) {
      uint64_t v53 = v7;
    }
    unint64_t v54 = *(void *)v53;
    if (v21)
    {
      float v55 = (char *)(v48 + v103);
      if (v15 >= v55) {
        int v56 = v55;
      }
      else {
        int v56 = v15;
      }
      if (v56 < v7) {
        int v56 = v7;
      }
      unint64_t v57 = *(void *)v56;
      int v58 = &v55[v52];
      if (v15 < v58) {
        int v58 = v15;
      }
      if (v58 < v7) {
        int v58 = v7;
      }
      unint64_t v59 = BLEND16_21384[v21];
      unint64_t v50 = v50 - ((v59 & v50) >> v21) + ((v59 & v57) >> v21);
      unint64_t v54 = v54 - ((v59 & v54) >> v21) + ((v59 & *(void *)v58) >> v21);
    }
    uint64_t v60 = BLEND16_21384[v51];
    unint64_t v61 = v50 - ((v60 & v50) >> v51);
    unint64_t v62 = (v60 & v54) >> v51;
LABEL_77:
    unint64_t v50 = v61 + v62;
    goto LABEL_78;
  }
  __int16 v104 = (uint64_t *)(v10 + 16 * a3);
  int v68 = v14 - 8;
  uint64_t v69 = v8 << 48;
  uint64_t v101 = a5;
  do
  {
    int v70 = *(char **)(v102 + 32);
    uint64_t v71 = &v70[(v13 >> v12) * v11];
    if (v98 == 1)
    {
      uint64_t v72 = v13;
      int v73 = a6;
      if (a5 >= 1)
      {
        __int16 v74 = v104;
        uint64_t v75 = v101;
        do
        {
          uint64_t v76 = *v74;
          v74 += 2;
          __int16 v77 = &v71[v76];
          if (v68 < &v71[v76]) {
            __int16 v77 = v68;
          }
          if (v77 < v70) {
            __int16 v77 = v70;
          }
          CFCalendarRef result = ((unsigned __int16)WORD2(*(void *)v77) >> 8) | (BYTE1(*(void *)v77) << 16) | (BYTE3(*(void *)v77) << 8) | ((*(void *)v77 | (unint64_t)v69) >> 32) & 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v9++ = result;
          --v75;
        }
        while (v75);
      }
    }
    else
    {
      uint64_t v72 = v13;
      int v73 = a6;
      __int16 v78 = v104;
      uint64_t v79 = v101;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v80 = *v78;
          v78 += 2;
          float v81 = &v71[v80];
          if (v68 < &v71[v80]) {
            float v81 = v68;
          }
          if ((unint64_t)v81 < *(void *)(v102 + 32)) {
            float v81 = *(char **)(v102 + 32);
          }
          uint64_t v82 = *(void *)v81;
          int v83 = ((v82 | (unint64_t)v69) >> 32) & 0xFF000000;
          unsigned int v84 = BYTE5(v82) | (BYTE1(v82) << 16) | (BYTE3(v82) << 8);
          unsigned int v85 = v84 | v83;
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v84 | v83, v6);
            unsigned int v85 = result;
          }
          if (HIBYTE(v85))
          {
            if (HIBYTE(v85) == 255) {
              *int v9 = v85;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v9, v85, *v9, ~v85 >> 24);
            }
          }
          ++v9;
          --v79;
        }
        while (v79);
      }
    }
    uint64_t v11 = v96;
    v9 += v97;
    LOBYTE(v12) = v95;
    uint64_t v13 = v72 + v94;
    a6 = v73 - 1;
  }
  while (v73 != 1);
  return result;
}

unint64_t argb32_image_mark_RGBA64(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v105 = *a2;
  float v7 = *(unsigned __int16 **)(result + 32);
  if (*(void *)(result + 40)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = 0xFFFFLL;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v104 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v101 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v101 * a4;
  int v14 = (char *)v7
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v108 = result;
  char v102 = v12;
  uint64_t v103 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v99 = *((void *)a2 + 11);
    uint64_t v97 = ~(-1 << v12);
    uint64_t v98 = *((void *)a2 + 13);
    char v96 = v12 - 4;
    int v15 = (unsigned __int16 *)(v14 - 8);
    uint64_t v16 = v8 << 48;
    uint64_t v94 = a5;
    uint64_t v95 = -v11;
    uint64_t v93 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v98 - v13) | (v13 - v99)) < 0)
      {
        int v21 = 0;
        uint64_t v109 = 0;
      }
      else
      {
        uint64_t v17 = ((v13 & (unint64_t)v97) >> v96) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v95;
        if (!v19) {
          uint64_t v20 = v11;
        }
        uint64_t v109 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v108 + 32) + (v13 >> v12) * v11;
      int v106 = a6;
      if (v105 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unsigned int v23 = (uint64_t *)v93;
        uint64_t v24 = v94;
        while (1)
        {
          uint64_t v25 = *(v23 - 1);
          uint64_t v26 = *v23;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v15 >= v22 + v25) {
            int v28 = (unsigned __int16 *)(v22 + v25);
          }
          else {
            int v28 = v15;
          }
          if (v28 < v7) {
            int v28 = v7;
          }
          unint64_t v29 = ((unint64_t)(bswap32(v28[3]) >> 16) << 48) | ((unint64_t)(bswap32(v28[2]) >> 16) << 32) | bswap32(v28[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v28) >> 16);
          uint64_t v30 = *v23 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            int v42 = (unsigned __int16 *)(v27 + v109);
            if ((unint64_t)v15 < v27 + v109) {
              int v42 = v15;
            }
            if (v42 < v7) {
              int v42 = v7;
            }
            uint64_t v43 = BLEND16_21384[v21];
            unint64_t v40 = v29 - ((v43 & v29) >> v21);
            unint64_t v41 = ((((unint64_t)(bswap32(v42[3]) >> 16) << 48) | ((unint64_t)(bswap32(v42[2]) >> 16) << 32) | bswap32(v42[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v42) >> 16)) & v43) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          CFCalendarRef result = BYTE5(v29) | (BYTE1(v29) << 16) | (BYTE3(v29) << 8) | ((v29 | v16) >> 32) & 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v24) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = v26 >> 4;
        int8x16_t v32 = (unsigned __int16 *)(v27 + (v26 >> 4));
        if (v15 < v32) {
          int8x16_t v32 = v15;
        }
        if (v32 < v7) {
          int8x16_t v32 = v7;
        }
        unint64_t v33 = ((unint64_t)(bswap32(v32[3]) >> 16) << 48) | ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | bswap32(v32[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v32) >> 16);
        if (v21)
        {
          int v34 = (unsigned __int16 *)(v27 + v109);
          if (v15 >= v34) {
            int32x4_t v35 = v34;
          }
          else {
            int32x4_t v35 = v15;
          }
          if (v35 < v7) {
            int32x4_t v35 = v7;
          }
          unint64_t v36 = ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
          int32x4_t v37 = (unsigned __int16 *)((char *)v34 + v31);
          if (v15 < v37) {
            int32x4_t v37 = v15;
          }
          if (v37 < v7) {
            int32x4_t v37 = v7;
          }
          uint64_t v38 = BLEND16_21384[v21];
          unint64_t v29 = v29 - ((v38 & v29) >> v21) + ((v36 & v38) >> v21);
          unint64_t v33 = v33
              - ((v38 & v33) >> v21)
              + (((((unint64_t)(bswap32(v37[3]) >> 16) << 48) | ((unint64_t)(bswap32(v37[2]) >> 16) << 32) | bswap32(v37[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v37) >> 16)) & v38) >> v21);
        }
        uint64_t v39 = BLEND16_21384[v30];
        unint64_t v40 = v29 - ((v39 & v29) >> v30);
        unint64_t v41 = (v39 & v33) >> v30;
LABEL_42:
        unint64_t v29 = v40 + v41;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v103;
      v9 += v104;
      LOBYTE(v12) = v102;
      v13 += v101;
      a6 = v106 - 1;
      if (v106 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    unsigned int v45 = (uint64_t *)v93;
    uint64_t v44 = v94;
    while (1)
    {
      uint64_t v46 = *(v45 - 1);
      uint64_t v47 = *v45;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v15 >= v22 + v46) {
        unint64_t v49 = (unsigned __int16 *)(v22 + v46);
      }
      else {
        unint64_t v49 = v15;
      }
      if (v49 < v7) {
        unint64_t v49 = v7;
      }
      unint64_t v50 = ((unint64_t)(bswap32(v49[3]) >> 16) << 48) | ((unint64_t)(bswap32(v49[2]) >> 16) << 32) | bswap32(v49[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v49) >> 16);
      uint64_t v51 = *v45 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v63 = (unsigned __int16 *)(v48 + v109);
        if ((unint64_t)v15 < v48 + v109) {
          int v63 = v15;
        }
        if (v63 < v7) {
          int v63 = v7;
        }
        uint64_t v64 = BLEND16_21384[v21];
        unint64_t v61 = v50 - ((v64 & v50) >> v21);
        unint64_t v62 = ((((unint64_t)(bswap32(v63[3]) >> 16) << 48) | ((unint64_t)(bswap32(v63[2]) >> 16) << 32) | bswap32(v63[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v63) >> 16)) & v64) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      int v65 = ((v50 | v16) >> 32) & 0xFF000000;
      unsigned int v66 = BYTE5(v50) | (BYTE1(v50) << 16) | (BYTE3(v50) << 8);
      unsigned int v67 = v66 | v65;
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v66 | v65, v6);
        unsigned int v67 = result;
      }
      if (HIBYTE(v67))
      {
        if (HIBYTE(v67) == 255) {
          *int v9 = v67;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v9, v67, *v9, ~v67 >> 24);
        }
      }
      v45 += 2;
      ++v9;
      if (!--v44) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = v47 >> 4;
    uint64_t v53 = (unsigned __int16 *)(v48 + (v47 >> 4));
    if (v15 < v53) {
      uint64_t v53 = v15;
    }
    if (v53 < v7) {
      uint64_t v53 = v7;
    }
    unint64_t v54 = ((unint64_t)(bswap32(v53[3]) >> 16) << 48) | ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | bswap32(v53[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v53) >> 16);
    if (v21)
    {
      float v55 = (unsigned __int16 *)(v48 + v109);
      if (v15 >= v55) {
        int v56 = v55;
      }
      else {
        int v56 = v15;
      }
      if (v56 < v7) {
        int v56 = v7;
      }
      unint64_t v57 = ((unint64_t)(bswap32(v56[3]) >> 16) << 48) | ((unint64_t)(bswap32(v56[2]) >> 16) << 32) | bswap32(v56[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v56) >> 16);
      int v58 = (unsigned __int16 *)((char *)v55 + v52);
      if (v15 < v58) {
        int v58 = v15;
      }
      if (v58 < v7) {
        int v58 = v7;
      }
      uint64_t v59 = BLEND16_21384[v21];
      unint64_t v50 = v50 - ((v59 & v50) >> v21) + ((v57 & v59) >> v21);
      unint64_t v54 = v54
          - ((v59 & v54) >> v21)
          + (((((unint64_t)(bswap32(v58[3]) >> 16) << 48) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | bswap32(v58[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v58) >> 16)) & v59) >> v21);
    }
    uint64_t v60 = BLEND16_21384[v51];
    unint64_t v61 = v50 - ((v60 & v50) >> v51);
    unint64_t v62 = (v60 & v54) >> v51;
LABEL_77:
    unint64_t v50 = v61 + v62;
    goto LABEL_78;
  }
  __int16 v110 = (uint64_t *)(v10 + 16 * a3);
  int v68 = (unsigned __int16 *)(v14 - 8);
  uint64_t v107 = a5;
  do
  {
    uint64_t v69 = *(unsigned __int16 **)(v108 + 32);
    int v70 = (char *)v69 + (v13 >> v12) * v11;
    if (v105 == 1)
    {
      int v71 = a6;
      if (a5 >= 1)
      {
        uint64_t v72 = v110;
        uint64_t v73 = v107;
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          uint64_t v75 = (unsigned __int16 *)&v70[v74];
          if (v68 < (unsigned __int16 *)&v70[v74]) {
            uint64_t v75 = v68;
          }
          if (v75 >= v69) {
            uint64_t v76 = v75;
          }
          else {
            uint64_t v76 = v69;
          }
          unsigned int v77 = bswap32(v76[3]);
          unsigned int v78 = bswap32(*v76) >> 16;
          unsigned int v79 = bswap32(v76[1]) >> 16;
          unsigned int v80 = bswap32(v76[2]) >> 16;
          int v81 = v8 | HIWORD(v77);
          if (v6 == 255) {
            CFCalendarRef result = (v80 >> 8) & 0xFF00FFFF | (BYTE1(v81) << 24) | (BYTE1(v78) << 16) | v79 & 0xFF00;
          }
          else {
            CFCalendarRef result = PDM_14621((v80 >> 8) & 0xFF00FFFF | (BYTE1(v81) << 24) | (BYTE1(v78) << 16) | v79 & 0xFF00, v6);
          }
          *v9++ = result;
          --v73;
        }
        while (v73);
      }
    }
    else
    {
      int v71 = a6;
      uint64_t v82 = v110;
      uint64_t v83 = v107;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v84 = *v82;
          v82 += 2;
          unsigned int v85 = (unsigned __int16 *)&v70[v84];
          if (v68 < (unsigned __int16 *)&v70[v84]) {
            unsigned int v85 = v68;
          }
          if ((unint64_t)v85 >= *(void *)(v108 + 32)) {
            uint64_t v86 = v85;
          }
          else {
            uint64_t v86 = *(unsigned __int16 **)(v108 + 32);
          }
          unsigned int v87 = bswap32(v86[3]);
          unsigned int v88 = bswap32(*v86) >> 16;
          unsigned int v89 = bswap32(v86[1]) >> 16;
          unsigned int v90 = bswap32(v86[2]) >> 16;
          int v91 = v8 | HIWORD(v87);
          if (v6 == 255)
          {
            unsigned int v92 = (v90 >> 8) & 0xFF00FFFF | (BYTE1(v91) << 24) | (BYTE1(v88) << 16) | v89 & 0xFF00;
          }
          else
          {
            CFCalendarRef result = PDM_14621((v90 >> 8) & 0xFF00FFFF | (BYTE1(v91) << 24) | (BYTE1(v88) << 16) | v89 & 0xFF00, v6);
            unsigned int v92 = result;
          }
          if (HIBYTE(v92))
          {
            if (HIBYTE(v92) == 255) {
              *int v9 = v92;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v9, v92, *v9, ~v92 >> 24);
            }
          }
          ++v9;
          --v83;
        }
        while (v83);
      }
    }
    uint64_t v11 = v103;
    v9 += v104;
    LOBYTE(v12) = v102;
    v13 += v101;
    a6 = v71 - 1;
  }
  while (v71 != 1);
  return result;
}

unint64_t argb32_image_mark_rgb48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  float v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 15);
  uint64_t v8 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v12 = *(unsigned __int16 **)(result + 32);
  uint64_t v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v93 = result;
  int v90 = a5;
  char v86 = v10;
  uint64_t v87 = v9;
  if (*(void *)(result + 176))
  {
    uint64_t v84 = *((void *)a2 + 11);
    uint64_t v82 = ~(-1 << v10);
    uint64_t v83 = *((void *)a2 + 13);
    char v81 = v10 - 4;
    int v14 = (unsigned __int16 *)(v13 - 6);
    uint64_t v79 = a5;
    uint64_t v80 = -v9;
    uint64_t v78 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v11) | (v11 - v84)) < 0)
      {
        int v17 = 0;
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v82) >> v81) & 0xF;
        uint64_t v16 = (unint64_t)(v15 - 7) >= 9 ? v80 : v9;
        int v17 = weights_21383[v15] & 0xF;
      }
      uint64_t v18 = *(void *)(v93 + 32) + (v11 >> v10) * v9;
      int v91 = a6;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        BOOL v19 = (uint64_t *)v78;
        uint64_t v20 = v79;
        while (1)
        {
          uint64_t v21 = *(v19 - 1);
          uint64_t v22 = *v19;
          uint64_t v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21) {
            uint64_t v24 = (unsigned __int16 *)(v18 + v21);
          }
          else {
            uint64_t v24 = v14;
          }
          if (v24 < v12) {
            uint64_t v24 = v12;
          }
          unint64_t v25 = *v24 | ((unint64_t)*(unsigned int *)(v24 + 1) << 16);
          uint64_t v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0) {
            break;
          }
          if (v17)
          {
            uint64_t v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16) {
              uint64_t v38 = v14;
            }
            if (v38 < v12) {
              uint64_t v38 = v12;
            }
            uint64_t v39 = BLEND16_21384[v17];
            unint64_t v36 = v25 - ((v39 & v25) >> v17);
            unint64_t v37 = ((*v38 | ((unint64_t)*(unsigned int *)(v38 + 1) << 16)) & v39) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = BYTE5(v25) | (BYTE1(v25) << 16) | (BYTE3(v25) << 8) | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v19 += 2;
          *v7++ = result;
          if (!--v20) {
            goto LABEL_83;
          }
        }
        uint64_t v27 = v22 >> 4;
        int v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28) {
          int v28 = v14;
        }
        if (v28 < v12) {
          int v28 = v12;
        }
        unint64_t v29 = *v28 | ((unint64_t)*(unsigned int *)(v28 + 1) << 16);
        if (v17)
        {
          uint64_t v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v14;
          }
          if (v31 < v12) {
            uint64_t v31 = v12;
          }
          unint64_t v32 = *v31 | ((unint64_t)*(unsigned int *)(v31 + 1) << 16);
          unint64_t v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33) {
            unint64_t v33 = v14;
          }
          if (v33 < v12) {
            unint64_t v33 = v12;
          }
          uint64_t v34 = BLEND16_21384[v17];
          unint64_t v25 = v25 - ((v34 & v25) >> v17) + ((v32 & v34) >> v17);
          unint64_t v29 = v29
              - ((v34 & v29) >> v17)
              + (((*v33 | ((unint64_t)*(unsigned int *)(v33 + 1) << 16)) & v34) >> v17);
        }
        uint64_t v35 = BLEND16_21384[v26];
        unint64_t v36 = v25 - ((v35 & v25) >> v26);
        unint64_t v37 = (v35 & v29) >> v26;
LABEL_40:
        unint64_t v25 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v9 = v87;
      v7 += v88;
      LOBYTE(v10) = v86;
      v11 += v85;
      a6 = v91 - 1;
      a5 = v90;
      if (v91 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    unint64_t v40 = (uint64_t *)v78;
    uint64_t v41 = v79;
    while (1)
    {
      uint64_t v42 = *(v40 - 1);
      uint64_t v43 = *v40;
      uint64_t v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42) {
        unsigned int v45 = (unsigned __int16 *)(v18 + v42);
      }
      else {
        unsigned int v45 = v14;
      }
      if (v45 < v12) {
        unsigned int v45 = v12;
      }
      unint64_t v46 = *v45 | ((unint64_t)*(unsigned int *)(v45 + 1) << 16);
      uint64_t v47 = *v40 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v17)
      {
        uint64_t v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16) {
          uint64_t v59 = v14;
        }
        if (v59 < v12) {
          uint64_t v59 = v12;
        }
        uint64_t v60 = BLEND16_21384[v17];
        unint64_t v57 = v46 - ((v60 & v46) >> v17);
        unint64_t v58 = ((*v59 | ((unint64_t)*(unsigned int *)(v59 + 1) << 16)) & v60) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v61 = BYTE5(v46) | (BYTE1(v46) << 16) | (BYTE3(v46) << 8);
      unsigned int v62 = v61 | 0xFF000000;
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v61 | 0xFF000000, v6);
        unsigned int v62 = result;
      }
      if (HIBYTE(v62))
      {
        if (HIBYTE(v62) == 255) {
          *float v7 = v62;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v62, *v7, ~v62 >> 24);
        }
      }
      v40 += 2;
      ++v7;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v48 = v43 >> 4;
    unint64_t v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49) {
      unint64_t v49 = v14;
    }
    if (v49 < v12) {
      unint64_t v49 = v12;
    }
    unint64_t v50 = *v49 | ((unint64_t)*(unsigned int *)(v49 + 1) << 16);
    if (v17)
    {
      uint64_t v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51) {
        uint64_t v52 = v51;
      }
      else {
        uint64_t v52 = v14;
      }
      if (v52 < v12) {
        uint64_t v52 = v12;
      }
      unint64_t v53 = *v52 | ((unint64_t)*(unsigned int *)(v52 + 1) << 16);
      unint64_t v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54) {
        unint64_t v54 = v14;
      }
      if (v54 < v12) {
        unint64_t v54 = v12;
      }
      uint64_t v55 = BLEND16_21384[v17];
      unint64_t v46 = v46 - ((v55 & v46) >> v17) + ((v53 & v55) >> v17);
      unint64_t v50 = v50 - ((v55 & v50) >> v17) + (((*v54 | ((unint64_t)*(unsigned int *)(v54 + 1) << 16)) & v55) >> v17);
    }
    uint64_t v56 = BLEND16_21384[v47];
    unint64_t v57 = v46 - ((v56 & v46) >> v47);
    unint64_t v58 = (v56 & v50) >> v47;
LABEL_75:
    unint64_t v46 = v57 + v58;
    goto LABEL_76;
  }
  unsigned int v92 = (uint64_t *)(v8 + 16 * a3);
  int v63 = v13 - 6;
  uint64_t v64 = a5;
  do
  {
    unint64_t v65 = *(void *)(v93 + 32);
    unint64_t v66 = v65 + (v11 >> v10) * v9;
    int v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        int v68 = v92;
        uint64_t v69 = v64;
        do
        {
          uint64_t v70 = *v68;
          v68 += 2;
          unint64_t v71 = v66 + v70;
          if ((unint64_t)v63 < v66 + v70) {
            unint64_t v71 = (unint64_t)v63;
          }
          if (v71 < v65) {
            unint64_t v71 = v65;
          }
          CFCalendarRef result = *(unsigned __int8 *)(v71 + 5) | (HIBYTE(*(_WORD *)v71) << 16) | (*(unsigned __int8 *)(v71 + 3) << 8) | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v7++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      uint64_t v72 = v92;
      uint64_t v73 = v64;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          unint64_t v75 = v66 + v74;
          if ((unint64_t)v63 < v66 + v74) {
            unint64_t v75 = (unint64_t)v63;
          }
          if (v75 < *(void *)(v93 + 32)) {
            unint64_t v75 = *(void *)(v93 + 32);
          }
          int v76 = *(unsigned __int8 *)(v75 + 5) | (HIBYTE(*(_WORD *)v75) << 16) | (*(unsigned __int8 *)(v75 + 3) << 8);
          unsigned int v77 = v76 | 0xFF000000;
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v76 | 0xFF000000, v6);
            unsigned int v77 = result;
          }
          if (HIBYTE(v77))
          {
            if (HIBYTE(v77) == 255) {
              *float v7 = v77;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v77, *v7, ~v77 >> 24);
            }
          }
          ++v7;
          --v73;
        }
        while (v73);
      }
    }
    uint64_t v9 = v87;
    v7 += v88;
    LOBYTE(v10) = v86;
    v11 += v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

unint64_t argb32_image_mark_RGB48(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  float v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 15);
  uint64_t v8 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v12 = *(unsigned __int16 **)(result + 32);
  uint64_t v13 = (char *)v12
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v93 = result;
  int v90 = a5;
  char v86 = v10;
  uint64_t v87 = v9;
  if (*(void *)(result + 176))
  {
    uint64_t v84 = *((void *)a2 + 11);
    uint64_t v82 = ~(-1 << v10);
    uint64_t v83 = *((void *)a2 + 13);
    char v81 = v10 - 4;
    int v14 = (unsigned __int16 *)(v13 - 6);
    uint64_t v79 = a5;
    uint64_t v80 = -v9;
    uint64_t v78 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v11) | (v11 - v84)) < 0)
      {
        int v17 = 0;
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v82) >> v81) & 0xF;
        uint64_t v16 = (unint64_t)(v15 - 7) >= 9 ? v80 : v9;
        int v17 = weights_21383[v15] & 0xF;
      }
      uint64_t v18 = *(void *)(v93 + 32) + (v11 >> v10) * v9;
      int v91 = a6;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        BOOL v19 = (uint64_t *)v78;
        uint64_t v20 = v79;
        while (1)
        {
          uint64_t v21 = *(v19 - 1);
          uint64_t v22 = *v19;
          uint64_t v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21) {
            uint64_t v24 = (unsigned __int16 *)(v18 + v21);
          }
          else {
            uint64_t v24 = v14;
          }
          if (v24 < v12) {
            uint64_t v24 = v12;
          }
          unint64_t v25 = bswap32(v24[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v24[2]) >> 16) << 32) | (bswap32(*v24) >> 16);
          uint64_t v26 = *v19 & 0xF;
          if ((v22 & 0xF) != 0) {
            break;
          }
          if (v17)
          {
            uint64_t v38 = (unsigned __int16 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16) {
              uint64_t v38 = v14;
            }
            if (v38 < v12) {
              uint64_t v38 = v12;
            }
            uint64_t v39 = BLEND16_21384[v17];
            unint64_t v36 = v25 - ((v39 & v25) >> v17);
            unint64_t v37 = ((bswap32(v38[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | (bswap32(*v38) >> 16)) & v39) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = BYTE5(v25) | (BYTE1(v25) << 16) | (BYTE3(v25) << 8) | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v19 += 2;
          *v7++ = result;
          if (!--v20) {
            goto LABEL_83;
          }
        }
        uint64_t v27 = v22 >> 4;
        int v28 = (unsigned __int16 *)(v23 + (v22 >> 4));
        if (v14 < v28) {
          int v28 = v14;
        }
        if (v28 < v12) {
          int v28 = v12;
        }
        unint64_t v29 = bswap32(v28[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v28[2]) >> 16) << 32) | (bswap32(*v28) >> 16);
        if (v17)
        {
          uint64_t v30 = (unsigned __int16 *)(v23 + v16);
          if (v14 >= v30) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v14;
          }
          if (v31 < v12) {
            uint64_t v31 = v12;
          }
          unint64_t v32 = bswap32(v31[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | (bswap32(*v31) >> 16);
          unint64_t v33 = (unsigned __int16 *)((char *)v30 + v27);
          if (v14 < v33) {
            unint64_t v33 = v14;
          }
          if (v33 < v12) {
            unint64_t v33 = v12;
          }
          uint64_t v34 = BLEND16_21384[v17];
          unint64_t v25 = v25 - ((v34 & v25) >> v17) + ((v32 & v34) >> v17);
          unint64_t v29 = v29
              - ((v34 & v29) >> v17)
              + (((bswap32(v33[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v33[2]) >> 16) << 32) | (bswap32(*v33) >> 16)) & v34) >> v17);
        }
        uint64_t v35 = BLEND16_21384[v26];
        unint64_t v36 = v25 - ((v35 & v25) >> v26);
        unint64_t v37 = (v35 & v29) >> v26;
LABEL_40:
        unint64_t v25 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v9 = v87;
      v7 += v88;
      LOBYTE(v10) = v86;
      v11 += v85;
      a6 = v91 - 1;
      a5 = v90;
      if (v91 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    unint64_t v40 = (uint64_t *)v78;
    uint64_t v41 = v79;
    while (1)
    {
      uint64_t v42 = *(v40 - 1);
      uint64_t v43 = *v40;
      uint64_t v44 = v18 + v42;
      if ((unint64_t)v14 >= v18 + v42) {
        unsigned int v45 = (unsigned __int16 *)(v18 + v42);
      }
      else {
        unsigned int v45 = v14;
      }
      if (v45 < v12) {
        unsigned int v45 = v12;
      }
      unint64_t v46 = bswap32(v45[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | (bswap32(*v45) >> 16);
      uint64_t v47 = *v40 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v17)
      {
        uint64_t v59 = (unsigned __int16 *)(v44 + v16);
        if ((unint64_t)v14 < v44 + v16) {
          uint64_t v59 = v14;
        }
        if (v59 < v12) {
          uint64_t v59 = v12;
        }
        uint64_t v60 = BLEND16_21384[v17];
        unint64_t v57 = v46 - ((v60 & v46) >> v17);
        unint64_t v58 = ((bswap32(v59[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v59[2]) >> 16) << 32) | (bswap32(*v59) >> 16)) & v60) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v61 = BYTE5(v46) | (BYTE1(v46) << 16) | (BYTE3(v46) << 8);
      unsigned int v62 = v61 | 0xFF000000;
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v61 | 0xFF000000, v6);
        unsigned int v62 = result;
      }
      if (HIBYTE(v62))
      {
        if (HIBYTE(v62) == 255) {
          *float v7 = v62;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v62, *v7, ~v62 >> 24);
        }
      }
      v40 += 2;
      ++v7;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v48 = v43 >> 4;
    unint64_t v49 = (unsigned __int16 *)(v44 + (v43 >> 4));
    if (v14 < v49) {
      unint64_t v49 = v14;
    }
    if (v49 < v12) {
      unint64_t v49 = v12;
    }
    unint64_t v50 = bswap32(v49[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v49[2]) >> 16) << 32) | (bswap32(*v49) >> 16);
    if (v17)
    {
      uint64_t v51 = (unsigned __int16 *)(v44 + v16);
      if (v14 >= v51) {
        uint64_t v52 = v51;
      }
      else {
        uint64_t v52 = v14;
      }
      if (v52 < v12) {
        uint64_t v52 = v12;
      }
      unint64_t v53 = bswap32(v52[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v52[2]) >> 16) << 32) | (bswap32(*v52) >> 16);
      unint64_t v54 = (unsigned __int16 *)((char *)v51 + v48);
      if (v14 < v54) {
        unint64_t v54 = v14;
      }
      if (v54 < v12) {
        unint64_t v54 = v12;
      }
      uint64_t v55 = BLEND16_21384[v17];
      unint64_t v46 = v46 - ((v55 & v46) >> v17) + ((v53 & v55) >> v17);
      unint64_t v50 = v50
          - ((v55 & v50) >> v17)
          + (((bswap32(v54[1]) & 0xFFFF0000 | ((unint64_t)(bswap32(v54[2]) >> 16) << 32) | (bswap32(*v54) >> 16)) & v55) >> v17);
    }
    uint64_t v56 = BLEND16_21384[v47];
    unint64_t v57 = v46 - ((v56 & v46) >> v47);
    unint64_t v58 = (v56 & v50) >> v47;
LABEL_75:
    unint64_t v46 = v57 + v58;
    goto LABEL_76;
  }
  unsigned int v92 = (uint64_t *)(v8 + 16 * a3);
  int v63 = v13 - 6;
  uint64_t v64 = a5;
  do
  {
    unint64_t v65 = *(char **)(v93 + 32);
    unint64_t v66 = &v65[(v11 >> v10) * v9];
    int v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        int v68 = v92;
        uint64_t v69 = v64;
        do
        {
          uint64_t v70 = *v68;
          v68 += 2;
          unint64_t v71 = &v66[v70];
          if (v63 < &v66[v70]) {
            unint64_t v71 = v63;
          }
          if (v71 < v65) {
            unint64_t v71 = v65;
          }
          CFCalendarRef result = v71[4] | (*(unsigned __int16 *)v71 << 16) | (*((_WORD *)v71 + 1) << 8) | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v7++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      uint64_t v72 = v92;
      uint64_t v73 = v64;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          unint64_t v75 = &v66[v74];
          if (v63 < &v66[v74]) {
            unint64_t v75 = v63;
          }
          if ((unint64_t)v75 < *(void *)(v93 + 32)) {
            unint64_t v75 = *(char **)(v93 + 32);
          }
          int v76 = v75[4] | (*(unsigned __int16 *)v75 << 16) | (*((_WORD *)v75 + 1) << 8);
          unsigned int v77 = v76 | 0xFF000000;
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v76 | 0xFF000000, v6);
            unsigned int v77 = result;
          }
          if (HIBYTE(v77))
          {
            if (HIBYTE(v77) == 255) {
              *float v7 = v77;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v77, *v7, ~v77 >> 24);
            }
          }
          ++v7;
          --v73;
        }
        while (v73);
      }
    }
    uint64_t v9 = v87;
    v7 += v88;
    LOBYTE(v10) = v86;
    v11 += v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

unint64_t argb32_image_mark_w16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v91 = *a2;
  uint64_t v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v90 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v87 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v87 * a4;
  uint64_t v13 = *(unsigned __int16 **)(result + 32);
  int v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v95 = result;
  char v88 = v11;
  uint64_t v89 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v85 = *((void *)a2 + 11);
    uint64_t v83 = ~(-1 << v11);
    uint64_t v84 = *((void *)a2 + 13);
    char v82 = v11 - 4;
    uint64_t v15 = (unsigned __int16 *)(v14 - 4);
    uint64_t v80 = a5;
    uint64_t v81 = -v10;
    uint64_t v79 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v84 - v12) | (v12 - v85)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v83) >> v82) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v81 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v95 + 32) + (v12 >> v11) * v10;
      int v93 = a6;
      uint64_t v92 = v12;
      if (v91 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v79;
        uint64_t v21 = v80;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            unint64_t v25 = (unsigned __int16 *)(v19 + v22);
          }
          else {
            unint64_t v25 = v15;
          }
          if (v25 < v13) {
            unint64_t v25 = v13;
          }
          unint64_t v26 = *v25;
          uint64_t v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            uint64_t v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              uint64_t v39 = v15;
            }
            if (v39 < v13) {
              uint64_t v39 = v13;
            }
            uint64_t v40 = BLEND16_21384[v18];
            __int16 v37 = v26 - ((v40 & v26) >> v18);
            unint64_t v38 = (unint64_t)(unsigned __int16)(v40 & *v39) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = (65793 * BYTE1(v26)) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        uint64_t v28 = v23 >> 4;
        unint64_t v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29) {
          unint64_t v29 = v15;
        }
        if (v29 < v13) {
          unint64_t v29 = v13;
        }
        unint64_t v30 = *v29;
        if (v18)
        {
          uint64_t v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31) {
            unint64_t v32 = v31;
          }
          else {
            unint64_t v32 = v15;
          }
          if (v32 < v13) {
            unint64_t v32 = v13;
          }
          unint64_t v33 = *v32;
          uint64_t v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34) {
            uint64_t v34 = v15;
          }
          if (v34 < v13) {
            uint64_t v34 = v13;
          }
          uint64_t v35 = BLEND16_21384[v18];
          LODWORD(v26) = v26 - ((v35 & v26) >> v18) + ((v35 & v33) >> v18);
          LODWORD(v30) = v30 - ((v35 & v30) >> v18) + ((unint64_t)(unsigned __int16)(v35 & *v34) >> v18);
        }
        uint64_t v36 = BLEND16_21384[v27];
        __int16 v37 = v26 - ((unint64_t)(v36 & v26) >> v27);
        unint64_t v38 = (unint64_t)(v36 & v30) >> v27;
LABEL_40:
        LOWORD(v26) = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v89;
      v8 += v90;
      LOBYTE(v11) = v88;
      uint64_t v12 = v92 + v87;
      a6 = v93 - 1;
      if (v93 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    uint64_t v42 = (uint64_t *)v79;
    uint64_t v41 = v80;
    while (1)
    {
      uint64_t v43 = *(v42 - 1);
      uint64_t v44 = *v42;
      uint64_t v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43) {
        unint64_t v46 = (unsigned __int16 *)(v19 + v43);
      }
      else {
        unint64_t v46 = v15;
      }
      if (v46 < v13) {
        unint64_t v46 = v13;
      }
      unint64_t v47 = *v46;
      uint64_t v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        uint64_t v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17) {
          uint64_t v60 = v15;
        }
        if (v60 < v13) {
          uint64_t v60 = v13;
        }
        uint64_t v61 = BLEND16_21384[v18];
        __int16 v58 = v47 - ((v61 & v47) >> v18);
        unint64_t v59 = (unint64_t)(unsigned __int16)(v61 & *v60) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      int v62 = 65793 * BYTE1(v47);
      unsigned int v63 = v62 | 0xFF000000;
      if (v7 != 255)
      {
        CFCalendarRef result = PDM_14621(v62 | 0xFF000000, v7);
        unsigned int v63 = result;
      }
      if (HIBYTE(v63))
      {
        if (HIBYTE(v63) == 255) {
          *uint64_t v8 = v63;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v63, *v8, ~v63 >> 24);
        }
      }
      v42 += 2;
      ++v8;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v49 = v44 >> 4;
    unint64_t v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50) {
      unint64_t v50 = v15;
    }
    if (v50 < v13) {
      unint64_t v50 = v13;
    }
    unint64_t v51 = *v50;
    if (v18)
    {
      uint64_t v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52) {
        unint64_t v53 = v52;
      }
      else {
        unint64_t v53 = v15;
      }
      if (v53 < v13) {
        unint64_t v53 = v13;
      }
      unint64_t v54 = *v53;
      uint64_t v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55) {
        uint64_t v55 = v15;
      }
      if (v55 < v13) {
        uint64_t v55 = v13;
      }
      uint64_t v56 = BLEND16_21384[v18];
      LODWORD(v47) = v47 - ((v56 & v47) >> v18) + ((v56 & v54) >> v18);
      LODWORD(v51) = v51 - ((v56 & v51) >> v18) + ((unint64_t)(unsigned __int16)(v56 & *v55) >> v18);
    }
    uint64_t v57 = BLEND16_21384[v48];
    __int16 v58 = v47 - ((unint64_t)(v57 & v47) >> v48);
    unint64_t v59 = (unint64_t)(v57 & v51) >> v48;
LABEL_75:
    LOWORD(v47) = v58 + v59;
    goto LABEL_76;
  }
  uint64_t v94 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v64 = v14 - 4;
  uint64_t v65 = a5;
  do
  {
    uint64_t v66 = v12;
    int v67 = *(char **)(v95 + 32);
    int v68 = &v67[(v12 >> v11) * v10];
    if (v91 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v69 = v94;
        uint64_t v70 = v65;
        do
        {
          uint64_t v71 = *v69;
          v69 += 2;
          uint64_t v72 = &v68[v71];
          if (v64 < &v68[v71]) {
            uint64_t v72 = v64;
          }
          if (v72 < v67) {
            uint64_t v72 = v67;
          }
          CFCalendarRef result = *(_WORD *)v72 & 0xFF00 | (HIBYTE(*(unsigned __int16 *)v72) << 16) | HIBYTE(*(unsigned __int16 *)v72) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          *v8++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      uint64_t v73 = v94;
      uint64_t v74 = v65;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v75 = *v73;
          v73 += 2;
          int v76 = &v68[v75];
          if (v64 < &v68[v75]) {
            int v76 = v64;
          }
          if ((unint64_t)v76 < *(void *)(v95 + 32)) {
            int v76 = *(char **)(v95 + 32);
          }
          int v77 = *(_WORD *)v76 & 0xFF00 | (HIBYTE(*(unsigned __int16 *)v76) << 16) | HIBYTE(*(unsigned __int16 *)v76);
          unsigned int v78 = v77 | 0xFF000000;
          if (v7 != 255)
          {
            CFCalendarRef result = PDM_14621(v77 | 0xFF000000, v7);
            unsigned int v78 = result;
          }
          if (HIBYTE(v78))
          {
            if (HIBYTE(v78) == 255) {
              *uint64_t v8 = v78;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v78, *v8, ~v78 >> 24);
            }
          }
          ++v8;
          --v74;
        }
        while (v74);
      }
    }
    uint64_t v10 = v89;
    v8 += v90;
    LOBYTE(v11) = v88;
    uint64_t v12 = v66 + v87;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t argb32_image_mark_W16(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v92 = *a2;
  uint64_t v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v91 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v88 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v88 * a4;
  uint64_t v13 = *(unsigned __int16 **)(result + 32);
  int v14 = (char *)v13
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v96 = result;
  char v89 = v11;
  uint64_t v90 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v86 = *((void *)a2 + 11);
    uint64_t v84 = ~(-1 << v11);
    uint64_t v85 = *((void *)a2 + 13);
    char v83 = v11 - 4;
    uint64_t v15 = (unsigned __int16 *)(v14 - 4);
    uint64_t v81 = a5;
    uint64_t v82 = -v10;
    uint64_t v80 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v85 - v12) | (v12 - v86)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v84) >> v83) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v82 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v96 + 32) + (v12 >> v11) * v10;
      int v94 = a6;
      uint64_t v93 = v12;
      if (v92 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v80;
        uint64_t v21 = v81;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            unint64_t v25 = (unsigned __int16 *)(v19 + v22);
          }
          else {
            unint64_t v25 = v15;
          }
          if (v25 < v13) {
            unint64_t v25 = v13;
          }
          unint64_t v26 = bswap32(*v25) >> 16;
          uint64_t v27 = *v20 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            uint64_t v39 = (unsigned __int16 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              uint64_t v39 = v15;
            }
            if (v39 < v13) {
              uint64_t v39 = v13;
            }
            uint64_t v40 = BLEND16_21384[v18];
            __int16 v37 = v26 - ((v40 & v26) >> v18);
            unint64_t v38 = (v40 & (unint64_t)(bswap32(*v39) >> 16)) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = (65793 * BYTE1(v26)) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        uint64_t v28 = v23 >> 4;
        unint64_t v29 = (unsigned __int16 *)(v24 + (v23 >> 4));
        if (v15 < v29) {
          unint64_t v29 = v15;
        }
        if (v29 < v13) {
          unint64_t v29 = v13;
        }
        unint64_t v30 = bswap32(*v29) >> 16;
        if (v18)
        {
          uint64_t v31 = (unsigned __int16 *)(v24 + v17);
          if (v15 >= v31) {
            unint64_t v32 = v31;
          }
          else {
            unint64_t v32 = v15;
          }
          if (v32 < v13) {
            unint64_t v32 = v13;
          }
          unint64_t v33 = bswap32(*v32) >> 16;
          uint64_t v34 = (unsigned __int16 *)((char *)v31 + v28);
          if (v15 < v34) {
            uint64_t v34 = v15;
          }
          if (v34 < v13) {
            uint64_t v34 = v13;
          }
          uint64_t v35 = BLEND16_21384[v18];
          LODWORD(v26) = v26 - ((v35 & v26) >> v18) + ((v35 & v33) >> v18);
          LODWORD(v30) = v30 - ((v35 & v30) >> v18) + ((v35 & (unint64_t)(bswap32(*v34) >> 16)) >> v18);
        }
        uint64_t v36 = BLEND16_21384[v27];
        __int16 v37 = v26 - ((unint64_t)(v36 & v26) >> v27);
        unint64_t v38 = (unint64_t)(v36 & v30) >> v27;
LABEL_40:
        LOWORD(v26) = v37 + v38;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v90;
      v8 += v91;
      LOBYTE(v11) = v89;
      uint64_t v12 = v93 + v88;
      a6 = v94 - 1;
      if (v94 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    uint64_t v42 = (uint64_t *)v80;
    uint64_t v41 = v81;
    while (1)
    {
      uint64_t v43 = *(v42 - 1);
      uint64_t v44 = *v42;
      uint64_t v45 = v19 + v43;
      if ((unint64_t)v15 >= v19 + v43) {
        unint64_t v46 = (unsigned __int16 *)(v19 + v43);
      }
      else {
        unint64_t v46 = v15;
      }
      if (v46 < v13) {
        unint64_t v46 = v13;
      }
      unint64_t v47 = bswap32(*v46) >> 16;
      uint64_t v48 = *v42 & 0xF;
      if ((v44 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        uint64_t v60 = (unsigned __int16 *)(v45 + v17);
        if ((unint64_t)v15 < v45 + v17) {
          uint64_t v60 = v15;
        }
        if (v60 < v13) {
          uint64_t v60 = v13;
        }
        uint64_t v61 = BLEND16_21384[v18];
        __int16 v58 = v47 - ((v61 & v47) >> v18);
        unint64_t v59 = (v61 & (unint64_t)(bswap32(*v60) >> 16)) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      int v62 = 65793 * BYTE1(v47);
      unsigned int v63 = v62 | 0xFF000000;
      if (v7 != 255)
      {
        CFCalendarRef result = PDM_14621(v62 | 0xFF000000, v7);
        unsigned int v63 = result;
      }
      if (HIBYTE(v63))
      {
        if (HIBYTE(v63) == 255) {
          *uint64_t v8 = v63;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v63, *v8, ~v63 >> 24);
        }
      }
      v42 += 2;
      ++v8;
      if (!--v41) {
        goto LABEL_83;
      }
    }
    uint64_t v49 = v44 >> 4;
    unint64_t v50 = (unsigned __int16 *)(v45 + (v44 >> 4));
    if (v15 < v50) {
      unint64_t v50 = v15;
    }
    if (v50 < v13) {
      unint64_t v50 = v13;
    }
    unint64_t v51 = bswap32(*v50) >> 16;
    if (v18)
    {
      uint64_t v52 = (unsigned __int16 *)(v45 + v17);
      if (v15 >= v52) {
        unint64_t v53 = v52;
      }
      else {
        unint64_t v53 = v15;
      }
      if (v53 < v13) {
        unint64_t v53 = v13;
      }
      unint64_t v54 = bswap32(*v53) >> 16;
      uint64_t v55 = (unsigned __int16 *)((char *)v52 + v49);
      if (v15 < v55) {
        uint64_t v55 = v15;
      }
      if (v55 < v13) {
        uint64_t v55 = v13;
      }
      uint64_t v56 = BLEND16_21384[v18];
      LODWORD(v47) = v47 - ((v56 & v47) >> v18) + ((v56 & v54) >> v18);
      LODWORD(v51) = v51 - ((v56 & v51) >> v18) + ((v56 & (unint64_t)(bswap32(*v55) >> 16)) >> v18);
    }
    uint64_t v57 = BLEND16_21384[v48];
    __int16 v58 = v47 - ((unint64_t)(v57 & v47) >> v48);
    unint64_t v59 = (unint64_t)(v57 & v51) >> v48;
LABEL_75:
    LOWORD(v47) = v58 + v59;
    goto LABEL_76;
  }
  unint64_t v95 = (uint64_t *)(v9 + 16 * a3);
  uint64_t v64 = v14 - 4;
  uint64_t v65 = a5;
  do
  {
    uint64_t v66 = v12;
    int v67 = *(char **)(v96 + 32);
    int v68 = &v67[(v12 >> v11) * v10];
    if (v92 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v69 = v95;
        uint64_t v70 = v65;
        do
        {
          uint64_t v71 = *v69;
          v69 += 2;
          uint64_t v72 = &v68[v71];
          if (v64 < &v68[v71]) {
            uint64_t v72 = v64;
          }
          if (v72 < v67) {
            uint64_t v72 = v67;
          }
          unsigned int v73 = bswap32(*(unsigned __int16 *)v72);
          CFCalendarRef result = HIWORD(v73) & 0xFF00 | (HIBYTE(v73) << 16) | HIBYTE(v73) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          *v8++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      uint64_t v74 = v95;
      uint64_t v75 = v65;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v76 = *v74;
          v74 += 2;
          int v77 = &v68[v76];
          if (v64 < &v68[v76]) {
            int v77 = v64;
          }
          if ((unint64_t)v77 < *(void *)(v96 + 32)) {
            int v77 = *(char **)(v96 + 32);
          }
          unsigned int v78 = bswap32(*(unsigned __int16 *)v77);
          unsigned int v79 = HIWORD(v78) & 0xFF00 | (HIBYTE(v78) << 16) | HIBYTE(v78) | 0xFF000000;
          if (v7 != 255)
          {
            CFCalendarRef result = PDM_14621(HIWORD(v78) & 0xFF00 | (HIBYTE(v78) << 16) | HIBYTE(v78) | 0xFF000000, v7);
            unsigned int v79 = result;
          }
          if (HIBYTE(v79))
          {
            if (HIBYTE(v79) == 255) {
              *uint64_t v8 = v79;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v79, *v8, ~v79 >> 24);
            }
          }
          ++v8;
          --v75;
        }
        while (v75);
      }
    }
    uint64_t v10 = v90;
    v8 += v91;
    LOBYTE(v11) = v89;
    uint64_t v12 = v66 + v88;
    --a6;
  }
  while (a6);
  return result;
}

unint64_t argb32_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = a2[1];
  int v93 = *a2;
  uint64_t v8 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v92 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v13 = *((void *)a2 + 7);
  uint64_t v89 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v89 * a4;
  uint64_t v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v99 = result;
  int v94 = a5;
  char v90 = v13;
  uint64_t v91 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v86 = ~(-1 << v13);
    uint64_t v87 = *((void *)a2 + 13);
    uint64_t v88 = *((void *)a2 + 11);
    char v85 = v13 - 4;
    uint64_t v84 = -v12;
    uint64_t v16 = (unsigned int *)(v15 - 4);
    uint64_t v82 = v11 + 16 * a3 + 8;
    uint64_t v83 = a5;
    while (1)
    {
      if (((v87 - v14) | (v14 - v88)) < 0)
      {
        int v21 = 0;
        uint64_t v100 = 0;
      }
      else
      {
        uint64_t v17 = ((v14 & (unint64_t)v86) >> v85) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v84;
        if (!v19) {
          uint64_t v20 = v12;
        }
        uint64_t v100 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v99 + 32) + (v14 >> v13) * v12;
      int v97 = a6;
      uint64_t v95 = v14;
      if (v93 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v24 = (uint64_t *)v82;
        uint64_t v23 = v83;
        while (1)
        {
          uint64_t v25 = *(v24 - 1);
          uint64_t v26 = *v24;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25) {
            uint64_t v28 = (unsigned int *)(v22 + v25);
          }
          else {
            uint64_t v28 = v16;
          }
          if (v28 < v8) {
            uint64_t v28 = v8;
          }
          unsigned int v29 = *v28;
          char v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            uint64_t v41 = (unsigned int *)(v27 + v100);
            if ((unint64_t)v16 < v27 + v100) {
              uint64_t v41 = v16;
            }
            if (v41 < v8) {
              uint64_t v41 = v8;
            }
            int v42 = BLEND8_21385[v21];
            unsigned int v39 = v29 - ((v42 & v29) >> v21);
            unsigned int v40 = (v42 & *v41) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          HIDWORD(v43) = __ROL4__(v29, v7);
          LODWORD(v43) = HIDWORD(v43);
          CFCalendarRef result = (v43 >> 8) | (v9 << 24);
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v24 += 2;
          *v10++ = result;
          if (!--v23) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31) {
          uint64_t v31 = v16;
        }
        if (v31 < v8) {
          uint64_t v31 = v8;
        }
        unsigned int v32 = *v31;
        if (v21)
        {
          unint64_t v33 = (unsigned int *)(v27 + v100);
          if (v16 >= v33) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = v16;
          }
          if (v34 < v8) {
            uint64_t v34 = v8;
          }
          unsigned int v35 = *v34;
          uint64_t v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36) {
            uint64_t v36 = v16;
          }
          if (v36 < v8) {
            uint64_t v36 = v8;
          }
          int v37 = BLEND8_21385[v21];
          unsigned int v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          unsigned int v32 = v32 - ((v37 & v32) >> v21) + ((v37 & *v36) >> v21);
        }
        int v38 = BLEND8_21385[*v24 & 0xF];
        unsigned int v39 = v29 - ((v38 & v29) >> v30);
        unsigned int v40 = (v38 & v32) >> v30;
LABEL_42:
        unsigned int v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v12 = v91;
      v10 += v92;
      LOBYTE(v13) = v90;
      uint64_t v14 = v95 + v89;
      a6 = v97 - 1;
      a5 = v94;
      if (v97 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v44 = (uint64_t *)v82;
    uint64_t v45 = v83;
    while (1)
    {
      uint64_t v46 = *(v44 - 1);
      uint64_t v47 = *v44;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v16 >= v22 + v46) {
        uint64_t v49 = (unsigned int *)(v22 + v46);
      }
      else {
        uint64_t v49 = v16;
      }
      if (v49 < v8) {
        uint64_t v49 = v8;
      }
      unsigned int v50 = *v49;
      char v51 = v47 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v62 = (unsigned int *)(v48 + v100);
        if ((unint64_t)v16 < v48 + v100) {
          int v62 = v16;
        }
        if (v62 < v8) {
          int v62 = v8;
        }
        int v63 = BLEND8_21385[v21];
        unsigned int v60 = v50 - ((v63 & v50) >> v21);
        unsigned int v61 = (v63 & *v62) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      HIDWORD(v65) = __ROL4__(v50, v7);
      LODWORD(v65) = HIDWORD(v65);
      int v64 = v65 >> 8;
      unsigned int v66 = v64 | (v9 << 24);
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v64 | (v9 << 24), v6);
        unsigned int v66 = result;
      }
      if (HIBYTE(v66))
      {
        if (HIBYTE(v66) == 255) {
          *uint64_t v10 = v66;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v10, v66, *v10, ~v66 >> 24);
        }
      }
      v44 += 2;
      ++v10;
      if (!--v45) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = (unsigned int *)(v48 + (v47 >> 4));
    if (v16 < v52) {
      uint64_t v52 = v16;
    }
    if (v52 < v8) {
      uint64_t v52 = v8;
    }
    unsigned int v53 = *v52;
    if (v21)
    {
      unint64_t v54 = (unsigned int *)(v48 + v100);
      if (v16 >= v54) {
        uint64_t v55 = v54;
      }
      else {
        uint64_t v55 = v16;
      }
      if (v55 < v8) {
        uint64_t v55 = v8;
      }
      unsigned int v56 = *v55;
      uint64_t v57 = (unsigned int *)((char *)v54 + (v47 >> 4));
      if (v16 < v57) {
        uint64_t v57 = v16;
      }
      if (v57 < v8) {
        uint64_t v57 = v8;
      }
      int v58 = BLEND8_21385[v21];
      unsigned int v50 = v50 - ((v58 & v50) >> v21) + ((v58 & v56) >> v21);
      unsigned int v53 = v53 - ((v58 & v53) >> v21) + ((v58 & *v57) >> v21);
    }
    int v59 = BLEND8_21385[*v44 & 0xF];
    unsigned int v60 = v50 - ((v59 & v50) >> v51);
    unsigned int v61 = (v59 & v53) >> v51;
LABEL_77:
    unsigned int v50 = v60 + v61;
    goto LABEL_78;
  }
  int v67 = v15 - 4;
  uint64_t v101 = a5;
  char v102 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    int v68 = *(char **)(v99 + 32);
    uint64_t v69 = &v68[(v14 >> v13) * v12];
    int v98 = a6;
    uint64_t v96 = v14;
    if (v93 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v70 = v101;
        uint64_t v71 = v102;
        do
        {
          uint64_t v72 = *v71;
          v71 += 2;
          unsigned int v73 = &v69[v72];
          if (v67 < &v69[v72]) {
            unsigned int v73 = v67;
          }
          if (v73 < v68) {
            unsigned int v73 = v68;
          }
          HIDWORD(v74) = __ROL4__(*(_DWORD *)v73, v7);
          LODWORD(v74) = HIDWORD(v74);
          CFCalendarRef result = (v74 >> 8) | (v9 << 24);
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v10++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      uint64_t v75 = v101;
      uint64_t v76 = v102;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v77 = *v76;
          v76 += 2;
          unsigned int v78 = &v69[v77];
          if (v67 < &v69[v77]) {
            unsigned int v78 = v67;
          }
          if ((unint64_t)v78 < *(void *)(v99 + 32)) {
            unsigned int v78 = *(char **)(v99 + 32);
          }
          HIDWORD(v80) = __ROL4__(*(_DWORD *)v78, v7);
          LODWORD(v80) = HIDWORD(v80);
          int v79 = v80 >> 8;
          unsigned int v81 = v79 | (v9 << 24);
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v79 | (v9 << 24), v6);
            unsigned int v81 = result;
          }
          if (HIBYTE(v81))
          {
            if (HIBYTE(v81) == 255) {
              *uint64_t v10 = v81;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v10, v81, *v10, ~v81 >> 24);
            }
          }
          ++v10;
          --v75;
        }
        while (v75);
      }
    }
    uint64_t v12 = v91;
    v10 += v92;
    LOBYTE(v13) = v90;
    uint64_t v14 = v96 + v89;
    a6 = v98 - 1;
    a5 = v94;
  }
  while (v98 != 1);
  return result;
}

unint64_t argb32_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v7 = a2[1];
  int v93 = *a2;
  uint64_t v8 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v9 = 0;
  }
  else {
    int v9 = 255;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v92 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v13 = *((void *)a2 + 7);
  uint64_t v89 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v89 * a4;
  uint64_t v15 = (char *)v8
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v99 = result;
  int v94 = a5;
  char v90 = v13;
  uint64_t v91 = v12;
  if (*(void *)(result + 176))
  {
    uint64_t v86 = ~(-1 << v13);
    uint64_t v87 = *((void *)a2 + 13);
    uint64_t v88 = *((void *)a2 + 11);
    char v85 = v13 - 4;
    uint64_t v84 = -v12;
    uint64_t v16 = (unsigned int *)(v15 - 4);
    uint64_t v82 = v11 + 16 * a3 + 8;
    uint64_t v83 = a5;
    while (1)
    {
      if (((v87 - v14) | (v14 - v88)) < 0)
      {
        int v21 = 0;
        uint64_t v100 = 0;
      }
      else
      {
        uint64_t v17 = ((v14 & (unint64_t)v86) >> v85) & 0xF;
        char v18 = weights_21383[v17];
        BOOL v19 = (unint64_t)(v17 - 7) >= 9;
        uint64_t v20 = v84;
        if (!v19) {
          uint64_t v20 = v12;
        }
        uint64_t v100 = v20;
        int v21 = v18 & 0xF;
      }
      uint64_t v22 = *(void *)(v99 + 32) + (v14 >> v13) * v12;
      int v97 = a6;
      uint64_t v95 = v14;
      if (v93 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v24 = (uint64_t *)v82;
        uint64_t v23 = v83;
        while (1)
        {
          uint64_t v25 = *(v24 - 1);
          uint64_t v26 = *v24;
          uint64_t v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25) {
            uint64_t v28 = (unsigned int *)(v22 + v25);
          }
          else {
            uint64_t v28 = v16;
          }
          if (v28 < v8) {
            uint64_t v28 = v8;
          }
          unsigned int v29 = bswap32(*v28);
          char v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0) {
            break;
          }
          if (v21)
          {
            uint64_t v41 = (unsigned int *)(v27 + v100);
            if ((unint64_t)v16 < v27 + v100) {
              uint64_t v41 = v16;
            }
            if (v41 < v8) {
              uint64_t v41 = v8;
            }
            int v42 = BLEND8_21385[v21];
            unsigned int v39 = v29 - ((v42 & v29) >> v21);
            unsigned int v40 = (bswap32(*v41) & v42) >> v21;
            goto LABEL_42;
          }
LABEL_43:
          HIDWORD(v43) = __ROL4__(v29, v7);
          LODWORD(v43) = HIDWORD(v43);
          CFCalendarRef result = (v43 >> 8) | (v9 << 24);
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v24 += 2;
          *v10++ = result;
          if (!--v23) {
            goto LABEL_85;
          }
        }
        uint64_t v31 = (unsigned int *)(v27 + (v26 >> 4));
        if (v16 < v31) {
          uint64_t v31 = v16;
        }
        if (v31 < v8) {
          uint64_t v31 = v8;
        }
        unsigned int v32 = bswap32(*v31);
        if (v21)
        {
          unint64_t v33 = (unsigned int *)(v27 + v100);
          if (v16 >= v33) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = v16;
          }
          if (v34 < v8) {
            uint64_t v34 = v8;
          }
          unsigned int v35 = bswap32(*v34);
          uint64_t v36 = (unsigned int *)((char *)v33 + (v26 >> 4));
          if (v16 < v36) {
            uint64_t v36 = v16;
          }
          if (v36 < v8) {
            uint64_t v36 = v8;
          }
          int v37 = BLEND8_21385[v21];
          unsigned int v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
          unsigned int v32 = v32 - ((v37 & v32) >> v21) + ((bswap32(*v36) & v37) >> v21);
        }
        int v38 = BLEND8_21385[*v24 & 0xF];
        unsigned int v39 = v29 - ((v38 & v29) >> v30);
        unsigned int v40 = (v38 & v32) >> v30;
LABEL_42:
        unsigned int v29 = v39 + v40;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v12 = v91;
      v10 += v92;
      LOBYTE(v13) = v90;
      uint64_t v14 = v95 + v89;
      a6 = v97 - 1;
      a5 = v94;
      if (v97 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    uint64_t v44 = (uint64_t *)v82;
    uint64_t v45 = v83;
    while (1)
    {
      uint64_t v46 = *(v44 - 1);
      uint64_t v47 = *v44;
      uint64_t v48 = v22 + v46;
      if ((unint64_t)v16 >= v22 + v46) {
        uint64_t v49 = (unsigned int *)(v22 + v46);
      }
      else {
        uint64_t v49 = v16;
      }
      if (v49 < v8) {
        uint64_t v49 = v8;
      }
      unsigned int v50 = bswap32(*v49);
      char v51 = v47 & 0xF;
      if ((v47 & 0xF) != 0) {
        break;
      }
      if (v21)
      {
        int v62 = (unsigned int *)(v48 + v100);
        if ((unint64_t)v16 < v48 + v100) {
          int v62 = v16;
        }
        if (v62 < v8) {
          int v62 = v8;
        }
        int v63 = BLEND8_21385[v21];
        unsigned int v60 = v50 - ((v63 & v50) >> v21);
        unsigned int v61 = (bswap32(*v62) & v63) >> v21;
        goto LABEL_77;
      }
LABEL_78:
      HIDWORD(v65) = __ROL4__(v50, v7);
      LODWORD(v65) = HIDWORD(v65);
      int v64 = v65 >> 8;
      unsigned int v66 = v64 | (v9 << 24);
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621(v64 | (v9 << 24), v6);
        unsigned int v66 = result;
      }
      if (HIBYTE(v66))
      {
        if (HIBYTE(v66) == 255) {
          *uint64_t v10 = v66;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v10, v66, *v10, ~v66 >> 24);
        }
      }
      v44 += 2;
      ++v10;
      if (!--v45) {
        goto LABEL_85;
      }
    }
    uint64_t v52 = (unsigned int *)(v48 + (v47 >> 4));
    if (v16 < v52) {
      uint64_t v52 = v16;
    }
    if (v52 < v8) {
      uint64_t v52 = v8;
    }
    unsigned int v53 = bswap32(*v52);
    if (v21)
    {
      unint64_t v54 = (unsigned int *)(v48 + v100);
      if (v16 >= v54) {
        uint64_t v55 = v54;
      }
      else {
        uint64_t v55 = v16;
      }
      if (v55 < v8) {
        uint64_t v55 = v8;
      }
      unsigned int v56 = bswap32(*v55);
      uint64_t v57 = (unsigned int *)((char *)v54 + (v47 >> 4));
      if (v16 < v57) {
        uint64_t v57 = v16;
      }
      if (v57 < v8) {
        uint64_t v57 = v8;
      }
      int v58 = BLEND8_21385[v21];
      unsigned int v50 = v50 - ((v58 & v50) >> v21) + ((v58 & v56) >> v21);
      unsigned int v53 = v53 - ((v58 & v53) >> v21) + ((bswap32(*v57) & v58) >> v21);
    }
    int v59 = BLEND8_21385[*v44 & 0xF];
    unsigned int v60 = v50 - ((v59 & v50) >> v51);
    unsigned int v61 = (v59 & v53) >> v51;
LABEL_77:
    unsigned int v50 = v60 + v61;
    goto LABEL_78;
  }
  int v67 = (unsigned int *)(v15 - 4);
  uint64_t v101 = a5;
  char v102 = (uint64_t *)(v11 + 16 * a3);
  do
  {
    int v68 = *(unsigned int **)(v99 + 32);
    uint64_t v69 = (char *)v68 + (v14 >> v13) * v12;
    int v98 = a6;
    uint64_t v96 = v14;
    if (v93 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v70 = v101;
        uint64_t v71 = v102;
        do
        {
          uint64_t v72 = *v71;
          v71 += 2;
          unsigned int v73 = (unsigned int *)&v69[v72];
          if (v67 < (unsigned int *)&v69[v72]) {
            unsigned int v73 = v67;
          }
          if (v73 < v68) {
            unsigned int v73 = v68;
          }
          HIDWORD(v74) = __ROL4__(bswap32(*v73), v7);
          LODWORD(v74) = HIDWORD(v74);
          CFCalendarRef result = (v74 >> 8) | (v9 << 24);
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v10++ = result;
          --v70;
        }
        while (v70);
      }
    }
    else
    {
      uint64_t v75 = v101;
      uint64_t v76 = v102;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v77 = *v76;
          v76 += 2;
          unsigned int v78 = (unsigned int *)&v69[v77];
          if (v67 < (unsigned int *)&v69[v77]) {
            unsigned int v78 = v67;
          }
          if ((unint64_t)v78 < *(void *)(v99 + 32)) {
            unsigned int v78 = *(unsigned int **)(v99 + 32);
          }
          HIDWORD(v80) = __ROL4__(bswap32(*v78), v7);
          LODWORD(v80) = HIDWORD(v80);
          int v79 = v80 >> 8;
          unsigned int v81 = v79 | (v9 << 24);
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v79 | (v9 << 24), v6);
            unsigned int v81 = result;
          }
          if (HIBYTE(v81))
          {
            if (HIBYTE(v81) == 255) {
              *uint64_t v10 = v81;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v10, v81, *v10, ~v81 >> 24);
            }
          }
          ++v10;
          --v75;
        }
        while (v75);
      }
    }
    uint64_t v12 = v91;
    v10 += v92;
    LOBYTE(v13) = v90;
    uint64_t v14 = v96 + v89;
    a6 = v98 - 1;
    a5 = v94;
  }
  while (v98 != 1);
  return result;
}

unint64_t argb32_image_mark_RGB24(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v86 = *a2;
  int v7 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v85 = *((void *)a2 + 3) - a5;
  uint64_t v9 = *((void *)a2 + 15);
  uint64_t v8 = *((void *)a2 + 16);
  uint64_t v10 = *((void *)a2 + 7);
  uint64_t v82 = *((void *)a2 + 9);
  uint64_t v11 = *((void *)a2 + 5) + v82 * a4;
  uint64_t v12 = *(unsigned __int8 **)(result + 32);
  uint64_t v13 = &v12[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v90 = result;
  int v87 = a5;
  char v83 = v10;
  uint64_t v84 = v9;
  if (*(void *)(result + 176))
  {
    uint64_t v81 = *((void *)a2 + 11);
    uint64_t v79 = ~(-1 << v10);
    uint64_t v80 = *((void *)a2 + 13);
    char v78 = v10 - 4;
    uint64_t v14 = v13 - 3;
    uint64_t v76 = a5;
    uint64_t v77 = -v9;
    uint64_t v75 = v8 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v11) | (v11 - v81)) < 0)
      {
        int v17 = 0;
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v15 = ((v11 & (unint64_t)v79) >> v78) & 0xF;
        uint64_t v16 = (unint64_t)(v15 - 7) >= 9 ? v77 : v9;
        int v17 = weights_21383[v15] & 0xF;
      }
      uint64_t v18 = *(void *)(v90 + 32) + (v11 >> v10) * v9;
      int v88 = a6;
      if (v86 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        BOOL v19 = (uint64_t *)v75;
        uint64_t v20 = v76;
        while (1)
        {
          uint64_t v21 = *(v19 - 1);
          uint64_t v22 = *v19;
          uint64_t v23 = v18 + v21;
          if ((unint64_t)v14 >= v18 + v21) {
            uint64_t v24 = (unsigned __int8 *)(v18 + v21);
          }
          else {
            uint64_t v24 = v14;
          }
          if (v24 < v12) {
            uint64_t v24 = v12;
          }
          unsigned int v25 = (*v24 << 24) | (v24[1] << 16) | (v24[2] << 8);
          char v26 = v22 & 0xF;
          if ((v22 & 0xF) != 0) {
            break;
          }
          if (v17)
          {
            int v37 = (unsigned __int8 *)(v23 + v16);
            if ((unint64_t)v14 < v23 + v16) {
              int v37 = v14;
            }
            if (v37 < v12) {
              int v37 = v12;
            }
            unsigned int v38 = BLEND8_21385[v17];
            unsigned int v35 = v25 - ((v38 & v25) >> v17);
            unsigned int v36 = (((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v17;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = (v25 >> 8) | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          v19 += 2;
          *v7++ = result;
          if (!--v20) {
            goto LABEL_83;
          }
        }
        uint64_t v27 = (unsigned __int8 *)(v23 + (v22 >> 4));
        if (v14 < v27) {
          uint64_t v27 = v14;
        }
        if (v27 < v12) {
          uint64_t v27 = v12;
        }
        int v28 = (*v27 << 24) | (v27[1] << 16) | (v27[2] << 8);
        if (v17)
        {
          unsigned int v29 = (unsigned __int8 *)(v23 + v16);
          if (v14 >= v29) {
            char v30 = v29;
          }
          else {
            char v30 = v14;
          }
          if (v30 < v12) {
            char v30 = v12;
          }
          int v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
          unsigned int v32 = &v29[v22 >> 4];
          if (v14 < v32) {
            unsigned int v32 = v14;
          }
          if (v32 < v12) {
            unsigned int v32 = v12;
          }
          unsigned int v33 = BLEND8_21385[v17];
          unsigned int v25 = v25 - ((v33 & v25) >> v17) + ((v33 & v31) >> v17);
          int v28 = v28 - ((v33 & v28) >> v17) + ((((*v32 << 24) | (v32[1] << 16) | (v32[2] << 8)) & v33) >> v17);
        }
        int v34 = BLEND8_21385[*v19 & 0xF];
        unsigned int v35 = v25 - ((v34 & v25) >> v26);
        unsigned int v36 = (v34 & v28) >> v26;
LABEL_40:
        unsigned int v25 = v35 + v36;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v9 = v84;
      v7 += v85;
      LOBYTE(v10) = v83;
      v11 += v82;
      a6 = v88 - 1;
      a5 = v87;
      if (v88 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    unsigned int v39 = (uint64_t *)v75;
    uint64_t v40 = v76;
    while (1)
    {
      uint64_t v41 = *(v39 - 1);
      uint64_t v42 = *v39;
      uint64_t v43 = v18 + v41;
      if ((unint64_t)v14 >= v18 + v41) {
        uint64_t v44 = (unsigned __int8 *)(v18 + v41);
      }
      else {
        uint64_t v44 = v14;
      }
      if (v44 < v12) {
        uint64_t v44 = v12;
      }
      unsigned int v45 = (*v44 << 24) | (v44[1] << 16) | (v44[2] << 8);
      char v46 = v42 & 0xF;
      if ((v42 & 0xF) != 0) {
        break;
      }
      if (v17)
      {
        uint64_t v57 = (unsigned __int8 *)(v43 + v16);
        if ((unint64_t)v14 < v43 + v16) {
          uint64_t v57 = v14;
        }
        if (v57 < v12) {
          uint64_t v57 = v12;
        }
        unsigned int v58 = BLEND8_21385[v17];
        unsigned int v55 = v45 - ((v58 & v45) >> v17);
        unsigned int v56 = (((*v57 << 24) | (v57[1] << 16) | (v57[2] << 8)) & v58) >> v17;
        goto LABEL_75;
      }
LABEL_76:
      unsigned int v59 = (v45 >> 8) | 0xFF000000;
      if (v6 != 255)
      {
        CFCalendarRef result = PDM_14621((v45 >> 8) | 0xFF000000, v6);
        unsigned int v59 = result;
      }
      if (HIBYTE(v59))
      {
        if (HIBYTE(v59) == 255) {
          *int v7 = v59;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v59, *v7, ~v59 >> 24);
        }
      }
      v39 += 2;
      ++v7;
      if (!--v40) {
        goto LABEL_83;
      }
    }
    uint64_t v47 = (unsigned __int8 *)(v43 + (v42 >> 4));
    if (v14 < v47) {
      uint64_t v47 = v14;
    }
    if (v47 < v12) {
      uint64_t v47 = v12;
    }
    int v48 = (*v47 << 24) | (v47[1] << 16) | (v47[2] << 8);
    if (v17)
    {
      uint64_t v49 = (unsigned __int8 *)(v43 + v16);
      if (v14 >= v49) {
        unsigned int v50 = v49;
      }
      else {
        unsigned int v50 = v14;
      }
      if (v50 < v12) {
        unsigned int v50 = v12;
      }
      int v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      uint64_t v52 = &v49[v42 >> 4];
      if (v14 < v52) {
        uint64_t v52 = v14;
      }
      if (v52 < v12) {
        uint64_t v52 = v12;
      }
      unsigned int v53 = BLEND8_21385[v17];
      unsigned int v45 = v45 - ((v53 & v45) >> v17) + ((v53 & v51) >> v17);
      int v48 = v48 - ((v53 & v48) >> v17) + ((((*v52 << 24) | (v52[1] << 16) | (v52[2] << 8)) & v53) >> v17);
    }
    int v54 = BLEND8_21385[*v39 & 0xF];
    unsigned int v55 = v45 - ((v54 & v45) >> v46);
    unsigned int v56 = (v54 & v48) >> v46;
LABEL_75:
    unsigned int v45 = v55 + v56;
    goto LABEL_76;
  }
  uint64_t v89 = (uint64_t *)(v8 + 16 * a3);
  unsigned int v60 = v13 - 3;
  uint64_t v61 = a5;
  do
  {
    int v62 = *(unsigned __int8 **)(v90 + 32);
    int v63 = &v62[(v11 >> v10) * v9];
    int v64 = a6;
    if (v86 == 1)
    {
      if (a5 >= 1)
      {
        unint64_t v65 = v89;
        uint64_t v66 = v61;
        do
        {
          uint64_t v67 = *v65;
          v65 += 2;
          int v68 = &v63[v67];
          if (v60 < &v63[v67]) {
            int v68 = v60;
          }
          if (v68 < v62) {
            int v68 = v62;
          }
          CFCalendarRef result = (*v68 << 16) | (v68[1] << 8) | v68[2] | 0xFF000000;
          if (v6 != 255) {
            CFCalendarRef result = PDM_14621(result, v6);
          }
          *v7++ = result;
          --v66;
        }
        while (v66);
      }
    }
    else
    {
      uint64_t v69 = v89;
      uint64_t v70 = v61;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v71 = *v69;
          v69 += 2;
          uint64_t v72 = &v63[v71];
          if (v60 < &v63[v71]) {
            uint64_t v72 = v60;
          }
          if ((unint64_t)v72 < *(void *)(v90 + 32)) {
            uint64_t v72 = *(unsigned __int8 **)(v90 + 32);
          }
          int v73 = (*v72 << 16) | (v72[1] << 8) | v72[2];
          unsigned int v74 = v73 | 0xFF000000;
          if (v6 != 255)
          {
            CFCalendarRef result = PDM_14621(v73 | 0xFF000000, v6);
            unsigned int v74 = result;
          }
          if (HIBYTE(v74))
          {
            if (HIBYTE(v74) == 255) {
              *int v7 = v74;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v74, *v7, ~v74 >> 24);
            }
          }
          ++v7;
          --v70;
        }
        while (v70);
      }
    }
    uint64_t v9 = v84;
    v7 += v85;
    LOBYTE(v10) = v83;
    v11 += v82;
    a6 = v64 - 1;
    a5 = v87;
  }
  while (v64 != 1);
  return result;
}

unint64_t argb32_image_mark_W8(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v7 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  uint64_t v8 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v9 = *((void *)a2 + 16);
  uint64_t v11 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v12 = *((void *)a2 + 5) + v85 * a4;
  uint64_t v13 = *(unsigned __int8 **)(result + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  unint64_t v93 = result;
  char v86 = v11;
  uint64_t v87 = v10;
  if (*(void *)(result + 176))
  {
    uint64_t v83 = *((void *)a2 + 11);
    uint64_t v81 = ~(-1 << v11);
    uint64_t v82 = *((void *)a2 + 13);
    char v80 = v11 - 4;
    uint64_t v15 = v14 - 4;
    uint64_t v78 = a5;
    uint64_t v79 = -v10;
    uint64_t v77 = v9 + 16 * a3 + 8;
    while (1)
    {
      if (((v82 - v12) | (v12 - v83)) < 0)
      {
        int v18 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v16 = ((v12 & (unint64_t)v81) >> v80) & 0xF;
        uint64_t v17 = (unint64_t)(v16 - 7) >= 9 ? v79 : v10;
        int v18 = weights_21383[v16] & 0xF;
      }
      uint64_t v19 = *(void *)(v93 + 32) + (v12 >> v11) * v10;
      int v91 = a6;
      uint64_t v90 = v12;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v20 = (uint64_t *)v77;
        uint64_t v21 = v78;
        while (1)
        {
          uint64_t v22 = *(v20 - 1);
          uint64_t v23 = *v20;
          uint64_t v24 = v19 + v22;
          if ((unint64_t)v15 >= v19 + v22) {
            unsigned int v25 = (unsigned __int8 *)(v19 + v22);
          }
          else {
            unsigned int v25 = v15;
          }
          if (v25 < v13) {
            unsigned int v25 = v13;
          }
          unsigned int v26 = *v25;
          char v27 = v23 & 0xF;
          if ((v23 & 0xF) != 0) {
            break;
          }
          if (v18)
          {
            unsigned int v38 = (unsigned __int8 *)(v24 + v17);
            if ((unint64_t)v15 < v24 + v17) {
              unsigned int v38 = v15;
            }
            if (v38 < v13) {
              unsigned int v38 = v13;
            }
            int v39 = BLEND8_21385[v18];
            unsigned int v36 = v26 - ((v39 & v26) >> v18);
            unsigned int v37 = (v39 & *v38) >> v18;
            goto LABEL_40;
          }
LABEL_41:
          CFCalendarRef result = v26 | (65792 * v26) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          v20 += 2;
          *v8++ = result;
          if (!--v21) {
            goto LABEL_83;
          }
        }
        int v28 = (unsigned __int8 *)(v24 + (v23 >> 4));
        if (v15 < v28) {
          int v28 = v15;
        }
        if (v28 < v13) {
          int v28 = v13;
        }
        unsigned int v29 = *v28;
        if (v18)
        {
          char v30 = (unsigned __int8 *)(v24 + v17);
          if (v15 >= v30) {
            int v31 = v30;
          }
          else {
            int v31 = v15;
          }
          if (v31 < v13) {
            int v31 = v13;
          }
          unsigned int v32 = *v31;
          unsigned int v33 = &v30[v23 >> 4];
          if (v15 < v33) {
            unsigned int v33 = v15;
          }
          if (v33 < v13) {
            unsigned int v33 = v13;
          }
          int v34 = BLEND8_21385[v18];
          unsigned int v26 = v26 - ((v34 & v26) >> v18) + ((v34 & v32) >> v18);
          unsigned int v29 = v29 - ((v34 & v29) >> v18) + ((v34 & *v33) >> v18);
        }
        int v35 = BLEND8_21385[*v20 & 0xF];
        unsigned int v36 = v26 - ((v35 & v26) >> v27);
        unsigned int v37 = (v35 & v29) >> v27;
LABEL_40:
        unsigned int v26 = v36 + v37;
        goto LABEL_41;
      }
LABEL_83:
      uint64_t v10 = v87;
      v8 += v88;
      LOBYTE(v11) = v86;
      uint64_t v12 = v90 + v85;
      a6 = v91 - 1;
      if (v91 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_83;
    }
    uint64_t v41 = (uint64_t *)v77;
    uint64_t v40 = v78;
    while (1)
    {
      uint64_t v42 = *(v41 - 1);
      uint64_t v43 = *v41;
      uint64_t v44 = v19 + v42;
      if ((unint64_t)v15 >= v19 + v42) {
        unsigned int v45 = (unsigned __int8 *)(v19 + v42);
      }
      else {
        unsigned int v45 = v15;
      }
      if (v45 < v13) {
        unsigned int v45 = v13;
      }
      unsigned int v46 = *v45;
      char v47 = v43 & 0xF;
      if ((v43 & 0xF) != 0) {
        break;
      }
      if (v18)
      {
        unsigned int v58 = (unsigned __int8 *)(v44 + v17);
        if ((unint64_t)v15 < v44 + v17) {
          unsigned int v58 = v15;
        }
        if (v58 < v13) {
          unsigned int v58 = v13;
        }
        int v59 = BLEND8_21385[v18];
        unsigned int v56 = v46 - ((v59 & v46) >> v18);
        unsigned int v57 = (v59 & *v58) >> v18;
        goto LABEL_75;
      }
LABEL_76:
      int v60 = v46 | (65792 * v46);
      unsigned int v61 = v60 | 0xFF000000;
      if (v7 != 255)
      {
        CFCalendarRef result = PDM_14621(v60 | 0xFF000000, v7);
        unsigned int v61 = result;
      }
      if (HIBYTE(v61))
      {
        if (HIBYTE(v61) == 255) {
          *uint64_t v8 = v61;
        }
        else {
          CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v61, *v8, ~v61 >> 24);
        }
      }
      v41 += 2;
      ++v8;
      if (!--v40) {
        goto LABEL_83;
      }
    }
    int v48 = (unsigned __int8 *)(v44 + (v43 >> 4));
    if (v15 < v48) {
      int v48 = v15;
    }
    if (v48 < v13) {
      int v48 = v13;
    }
    unsigned int v49 = *v48;
    if (v18)
    {
      unsigned int v50 = (unsigned __int8 *)(v44 + v17);
      if (v15 >= v50) {
        int v51 = v50;
      }
      else {
        int v51 = v15;
      }
      if (v51 < v13) {
        int v51 = v13;
      }
      unsigned int v52 = *v51;
      unsigned int v53 = &v50[v43 >> 4];
      if (v15 < v53) {
        unsigned int v53 = v15;
      }
      if (v53 < v13) {
        unsigned int v53 = v13;
      }
      int v54 = BLEND8_21385[v18];
      unsigned int v46 = v46 - ((v54 & v46) >> v18) + ((v54 & v52) >> v18);
      unsigned int v49 = v49 - ((v54 & v49) >> v18) + ((v54 & *v53) >> v18);
    }
    int v55 = BLEND8_21385[*v41 & 0xF];
    unsigned int v56 = v46 - ((v55 & v46) >> v47);
    unsigned int v57 = (v55 & v49) >> v47;
LABEL_75:
    unsigned int v46 = v56 + v57;
    goto LABEL_76;
  }
  uint64_t v92 = (uint64_t *)(v9 + 16 * a3);
  int v62 = v14 - 4;
  uint64_t v63 = a5;
  do
  {
    uint64_t v64 = v12;
    unint64_t v65 = *(unsigned __int8 **)(v93 + 32);
    uint64_t v66 = &v65[(v12 >> v11) * v10];
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        uint64_t v67 = v92;
        uint64_t v68 = v63;
        do
        {
          uint64_t v69 = *v67;
          v67 += 2;
          uint64_t v70 = &v66[v69];
          if (v62 < &v66[v69]) {
            uint64_t v70 = v62;
          }
          if (v70 < v65) {
            uint64_t v70 = v65;
          }
          CFCalendarRef result = *v70 | (*v70 << 8) | (*v70 << 16) | 0xFF000000;
          if (v7 != 255) {
            CFCalendarRef result = PDM_14621(result, v7);
          }
          *v8++ = result;
          --v68;
        }
        while (v68);
      }
    }
    else
    {
      uint64_t v71 = v92;
      uint64_t v72 = v63;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v73 = *v71;
          v71 += 2;
          unsigned int v74 = &v66[v73];
          if (v62 < &v66[v73]) {
            unsigned int v74 = v62;
          }
          if ((unint64_t)v74 < *(void *)(v93 + 32)) {
            unsigned int v74 = *(unsigned __int8 **)(v93 + 32);
          }
          int v75 = *v74 | (*v74 << 8) | (*v74 << 16);
          unsigned int v76 = v75 | 0xFF000000;
          if (v7 != 255)
          {
            CFCalendarRef result = PDM_14621(v75 | 0xFF000000, v7);
            unsigned int v76 = result;
          }
          if (HIBYTE(v76))
          {
            if (HIBYTE(v76) == 255) {
              *uint64_t v8 = v76;
            }
            else {
              CFCalendarRef result = (unint64_t)DplusDM_14623(v8, v76, *v8, ~v76 >> 24);
            }
          }
          ++v8;
          --v72;
        }
        while (v72);
      }
    }
    uint64_t v10 = v87;
    v8 += v88;
    LOBYTE(v11) = v86;
    uint64_t v12 = v64 + v85;
    --a6;
  }
  while (a6);
  return result;
}

_DWORD *DplusDAM(_DWORD *result, unsigned int a2, int a3, int a4, int a5)
{
  unsigned int v5 = (BYTE1(a3) | (a4 << 16)) * a5 + 8388736;
  uint64_t v6 = (((v5 >> 8) & 0xFF00FF) + v5) & 0xFF00FF00 | ((((((a3 & 0xFF00FFu) * a5 + 8388736) >> 8) & 0xFF00FF)
                                                    + (a3 & 0xFF00FF) * a5
                                                    + 8388736) >> 8) & 0xFF00FF;
  unint64_t v7 = (((v6 | (unint64_t)(v6 << 40)) >> 8) & 0xFF00FF00FF00FFLL)
     + (((a2 | ((unint64_t)a2 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *CFCalendarRef result = ((((v7 & 0x100010001000100) - ((v7 & 0x100010001000100) >> 8)) | v7) & 0xFF00FF00FF00FFLL | (((((v7 & 0x100010001000100) - ((v7 & 0x100010001000100) >> 8)) | v7) & 0xFF00FF00FF00FFLL) << 40)) >> 32;
  return result;
}

_DWORD *DAM(_DWORD *result, int a2, unsigned __int8 a3, int a4)
{
  int v4 = a2 & 0xFF00FF;
  uint64_t v5 = a2 & 0xFFFFFF | (a3 << 24);
  unsigned int v6 = ((v5 >> 8) & 0xFF00FF) * (a4 ^ 0xFF) + 8388736;
  uint64_t v7 = (((v6 >> 8) & 0xFF00FF) + v6) & 0xFF00FF00 | (((((v4 * (a4 ^ 0xFFu) + 8388736) >> 8) & 0xFF00FF)
                                                    + v4 * (a4 ^ 0xFF)
                                                    + 8388736) >> 8) & 0xFF00FF;
  uint64_t v8 = (((v5 | (unint64_t)(v5 << 40)) >> 8) & 0xFF00FF00FF00FFLL | 0x100010001000100)
     - (((v7 | (unint64_t)(v7 << 40)) >> 8) & 0xFF00FF00FF00FFLL);
  *CFCalendarRef result = (((v8 & 0x100010001000100) - ((v8 & 0x100010001000100uLL) >> 8)) & v8 | ((((v8 & 0x100010001000100)
                                                                                       - ((v8 & 0x100010001000100uLL) >> 8)) & v8) << 40)) >> 32;
  return result;
}

unint64_t argb32_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 136);
  if (v2)
  {
    int v516 = *(_DWORD *)(result + 4);
    uint64_t v3 = v516;
    int v518 = *(_DWORD *)(result + 8);
    uint64_t v519 = *(void *)(result + 48);
    uint64_t v4 = *(void *)(result + 88);
    uint64_t v5 = *(void *)(result + 96);
    unint64_t v6 = (unint64_t)*(int *)(result + 28) >> 2;
    uint64_t v7 = (unsigned int *)(*(void *)(result + 40) + 4 * (*(int *)(result + 12) + v6 * *(int *)(result + 16)));
    uint64_t v8 = *(int *)(result + 124);
    uint64_t v9 = (char *)(v2 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v8);
    uint64_t v10 = *(int *)(result + 56);
    uint64_t v11 = *(int *)(result + 60);
    unint64_t v12 = *(int *)(result + 76);
    if (*(unsigned __int8 *)(result + 1) << 8 != 256)
    {
      int v18 = *(_DWORD *)(result + 64);
      int v17 = *(_DWORD *)(result + 68);
      uint64_t v13 = v12 >> 2;
      BOOL v19 = v5 != 0;
      uint64_t v515 = v8 - v516;
      unint64_t v514 = v6 - v516;
      if (v4)
      {
        int v512 = 0;
        unint64_t v511 = v4 + 4 * v13 * v17;
        uint64_t v513 = v13;
        uint64_t v20 = v4 + 4 * v13 * ((int)v11 % v17);
        uint64_t v14 = (unsigned int *)(v20 + 4 * ((int)v10 % v18));
        unint64_t v21 = v20 + 4 * v18;
        int v16 = 1;
        uint64_t v517 = v14;
LABEL_16:
        switch(a2)
        {
          case 0:
            uint64_t v22 = v16;
            uint64_t v23 = 4 * v16;
            do
            {
              int v24 = v516;
              do
              {
                int v25 = *v9;
                if (*v9)
                {
                  if (v25 == 255) {
                    CFCalendarRef result = 0;
                  }
                  else {
                    CFCalendarRef result = PDM_14621(*v7, v25 ^ 0xFFu);
                  }
                  *uint64_t v7 = result;
                }
                v9 += v22;
                uint64_t v7 = (unsigned int *)((char *)v7 + v23);
                --v24;
              }
              while (v24);
              v9 += v515;
              v7 += v514;
              --v518;
            }
            while (v518);
            return result;
          case 1:
            if (v519) {
              char v26 = v19;
            }
            else {
              char v26 = 1;
            }
            uint64_t v27 = v16;
            uint64_t v28 = -(uint64_t)v18;
            uint64_t v29 = -(v513 * v17);
            uint64_t v30 = 4 * v16;
            if (v26)
            {
              do
              {
                int v31 = v516;
                do
                {
                  int v32 = *v9;
                  if (*v9)
                  {
                    if (v32 == 255) {
                      *uint64_t v7 = *v14;
                    }
                    else {
                      CFCalendarRef result = (unint64_t)DMplusDM_14622(v7, *v14, v32, *v7, v32 ^ 0xFFu);
                    }
                  }
                  v9 += v27;
                  unint64_t v33 = (unint64_t)&v14[v27];
                  if (v33 >= v21) {
                    uint64_t v34 = v28;
                  }
                  else {
                    uint64_t v34 = 0;
                  }
                  uint64_t v14 = (unsigned int *)(v33 + 4 * v34);
                  uint64_t v7 = (unsigned int *)((char *)v7 + v30);
                  --v31;
                }
                while (v31);
                v9 += v515;
                v7 += v514;
                int v35 = v517;
                unsigned int v36 = &v517[v513];
                if ((unint64_t)v36 >= v511) {
                  uint64_t v37 = v29;
                }
                else {
                  uint64_t v37 = 0;
                }
                unsigned int v38 = &v36[v37];
                uint64_t v39 = v21 + 4 * v37 + 4 * v513;
                if (v512)
                {
                  v14 += v513;
                }
                else
                {
                  unint64_t v21 = v39;
                  int v35 = v38;
                  uint64_t v14 = v38;
                }
                BOOL v40 = v518 == 1;
                uint64_t v517 = v35;
                --v518;
              }
              while (!v40);
            }
            else
            {
              do
              {
                int v41 = v516;
                do
                {
                  int v42 = *v9;
                  if (*v9)
                  {
                    if (v42 == 255) {
                      *uint64_t v7 = *v14 | 0xFF000000;
                    }
                    else {
                      CFCalendarRef result = (unint64_t)DMplusDAM(v7, *v7, v42 ^ 0xFFu, *v14, 255, v42);
                    }
                  }
                  v9 += v27;
                  unint64_t v43 = (unint64_t)&v14[v27];
                  if (v43 >= v21) {
                    uint64_t v44 = v28;
                  }
                  else {
                    uint64_t v44 = 0;
                  }
                  uint64_t v14 = (unsigned int *)(v43 + 4 * v44);
                  uint64_t v7 = (unsigned int *)((char *)v7 + v30);
                  --v41;
                }
                while (v41);
                v9 += v515;
                v7 += v514;
                unsigned int v45 = v517;
                unsigned int v46 = &v517[v513];
                if ((unint64_t)v46 >= v511) {
                  uint64_t v47 = v29;
                }
                else {
                  uint64_t v47 = 0;
                }
                int v48 = &v46[v47];
                uint64_t v49 = v21 + 4 * v47 + 4 * v513;
                if (v512)
                {
                  v14 += v513;
                }
                else
                {
                  unint64_t v21 = v49;
                  unsigned int v45 = v48;
                  uint64_t v14 = v48;
                }
                BOOL v40 = v518 == 1;
                uint64_t v517 = v45;
                --v518;
              }
              while (!v40);
            }
            return result;
          case 2:
            uint64_t v50 = v16;
            uint64_t v51 = -(uint64_t)v18;
            uint64_t v52 = -(v513 * v17);
            uint64_t v53 = 4 * v16;
            while (1)
            {
              int v54 = v516;
              do
              {
                int v55 = *v9;
                if (!*v9) {
                  goto LABEL_78;
                }
                if (v55 == 255)
                {
                  unsigned int v56 = *v14;
                  unsigned int v57 = HIBYTE(*v14);
                  if (!v57) {
                    goto LABEL_78;
                  }
                  if (v57 == 255)
                  {
                    *uint64_t v7 = v56;
                    goto LABEL_78;
                  }
                }
                else
                {
                  CFCalendarRef result = PDM_14621(*v14, v55);
                  if (!BYTE3(result)) {
                    goto LABEL_78;
                  }
                  unsigned int v56 = result;
                }
                CFCalendarRef result = (unint64_t)DplusDM_14623(v7, v56, *v7, ~v56 >> 24);
LABEL_78:
                v9 += v50;
                unint64_t v58 = (unint64_t)&v14[v50];
                if (v58 >= v21) {
                  uint64_t v59 = v51;
                }
                else {
                  uint64_t v59 = 0;
                }
                uint64_t v14 = (unsigned int *)(v58 + 4 * v59);
                uint64_t v7 = (unsigned int *)((char *)v7 + v53);
                --v54;
              }
              while (v54);
              v9 += v515;
              v7 += v514;
              int v60 = v517;
              unsigned int v61 = &v517[v513];
              if ((unint64_t)v61 >= v511) {
                uint64_t v62 = v52;
              }
              else {
                uint64_t v62 = 0;
              }
              uint64_t v63 = &v61[v62];
              uint64_t v64 = v21 + 4 * v62 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v64;
                int v60 = v63;
                uint64_t v14 = v63;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v60;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 3:
            uint64_t v65 = v16;
            uint64_t v66 = -(uint64_t)v18;
            uint64_t v67 = -(v513 * v17);
            uint64_t v68 = 4 * v16;
            do
            {
              int v69 = v516;
              do
              {
                int v70 = *v9;
                if (*v9)
                {
                  if (v70 == 255)
                  {
                    unsigned int v71 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v71) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DAM(v7, *v14, v71, *((unsigned __int8 *)v7 + 3));
                  }
                  else
                  {
                    unsigned int v72 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v72) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DMplusDAM(v7, *v7, v70 ^ 0xFFu, *v14, v72, ((unsigned __int16)(HIBYTE(*v7) * v70+ 128+ ((HIBYTE(*v7) * v70 + 128) >> 8)) >> 8));
                  }
                }
                v9 += v65;
                unint64_t v73 = (unint64_t)&v14[v65];
                if (v73 >= v21) {
                  uint64_t v74 = v66;
                }
                else {
                  uint64_t v74 = 0;
                }
                uint64_t v14 = (unsigned int *)(v73 + 4 * v74);
                uint64_t v7 = (unsigned int *)((char *)v7 + v68);
                --v69;
              }
              while (v69);
              v9 += v515;
              v7 += v514;
              int v75 = v517;
              unsigned int v76 = &v517[v513];
              if ((unint64_t)v76 >= v511) {
                uint64_t v77 = v67;
              }
              else {
                uint64_t v77 = 0;
              }
              uint64_t v78 = &v76[v77];
              uint64_t v79 = v21 + 4 * v77 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v79;
                int v75 = v78;
                uint64_t v14 = v78;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v75;
              --v518;
            }
            while (!v40);
            return result;
          case 4:
            uint64_t v80 = v16;
            uint64_t v81 = -(uint64_t)v18;
            uint64_t v82 = -(v513 * v17);
            uint64_t v83 = 4 * v16;
            do
            {
              int v84 = v516;
              do
              {
                int v85 = *v9;
                if (*v9)
                {
                  if (v85 == 255)
                  {
                    unsigned int v86 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v86) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DAM(v7, *v14, v86, *((unsigned __int8 *)v7 + 3) ^ 0xFFu);
                  }
                  else
                  {
                    unsigned int v87 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v87) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DMplusDAM(v7, *v7, v85 ^ 0xFFu, *v14, v87, ((unsigned __int16)((~*v7 >> 24) * v85+ 128+ (((~*v7 >> 24) * v85 + 128) >> 8)) >> 8));
                  }
                }
                v9 += v80;
                unint64_t v88 = (unint64_t)&v14[v80];
                if (v88 >= v21) {
                  uint64_t v89 = v81;
                }
                else {
                  uint64_t v89 = 0;
                }
                uint64_t v14 = (unsigned int *)(v88 + 4 * v89);
                uint64_t v7 = (unsigned int *)((char *)v7 + v83);
                --v84;
              }
              while (v84);
              v9 += v515;
              v7 += v514;
              uint64_t v90 = v517;
              int v91 = &v517[v513];
              if ((unint64_t)v91 >= v511) {
                uint64_t v92 = v82;
              }
              else {
                uint64_t v92 = 0;
              }
              unint64_t v93 = &v91[v92];
              uint64_t v94 = v21 + 4 * v92 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v94;
                uint64_t v90 = v93;
                uint64_t v14 = v93;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v90;
              --v518;
            }
            while (!v40);
            return result;
          case 5:
            uint64_t v95 = v16;
            uint64_t v96 = -(uint64_t)v18;
            uint64_t v97 = -(v513 * v17);
            uint64_t v98 = 4 * v16;
            do
            {
              int v99 = v516;
              do
              {
                if (*v9)
                {
                  unsigned int v100 = PDM_14621(*v14, *v9);
                  CFCalendarRef result = (unint64_t)DMplusDM_14622(v7, v100, HIBYTE(*v7), *v7, ~v100 >> 24);
                }
                v9 += v95;
                unint64_t v101 = (unint64_t)&v14[v95];
                if (v101 >= v21) {
                  uint64_t v102 = v96;
                }
                else {
                  uint64_t v102 = 0;
                }
                uint64_t v14 = (unsigned int *)(v101 + 4 * v102);
                uint64_t v7 = (unsigned int *)((char *)v7 + v98);
                --v99;
              }
              while (v99);
              v9 += v515;
              v7 += v514;
              uint64_t v103 = v517;
              uint64_t v104 = &v517[v513];
              if ((unint64_t)v104 >= v511) {
                uint64_t v105 = v97;
              }
              else {
                uint64_t v105 = 0;
              }
              int v106 = &v104[v105];
              uint64_t v107 = v21 + 4 * v105 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v107;
                uint64_t v103 = v106;
                uint64_t v14 = v106;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v103;
              --v518;
            }
            while (!v40);
            return result;
          case 6:
            uint64_t v108 = v16;
            uint64_t v109 = -(uint64_t)v18;
            uint64_t v520 = -(v513 * v17);
            uint64_t v110 = 4 * v16;
            do
            {
              int v111 = v516;
              do
              {
                int v112 = *v9;
                if (*v9 && ~HIBYTE(*v7))
                {
                  if (~HIBYTE(*v7) == 255)
                  {
                    unsigned int v113 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v113) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DAM(v7, *v14, v113, v112);
                  }
                  else
                  {
                    unsigned int v114 = HIBYTE(*v14);
                    if (!v19) {
                      LOBYTE(v114) = -1;
                    }
                    CFCalendarRef result = (unint64_t)DplusDAM(v7, *v7, *v14, v114, ((unsigned __int16)(~HIBYTE(*v7)* (_WORD)v112+ 128+ ((~HIBYTE(*v7)* v112+ 128) >> 8)) >> 8));
                  }
                }
                v9 += v108;
                unint64_t v115 = (unint64_t)&v14[v108];
                if (v115 >= v21) {
                  uint64_t v116 = v109;
                }
                else {
                  uint64_t v116 = 0;
                }
                uint64_t v14 = (unsigned int *)(v115 + 4 * v116);
                uint64_t v7 = (unsigned int *)((char *)v7 + v110);
                --v111;
              }
              while (v111);
              v9 += v515;
              v7 += v514;
              __int16 v117 = v517;
              unsigned int v118 = &v517[v513];
              uint64_t v119 = v520;
              if ((unint64_t)v118 < v511) {
                uint64_t v119 = 0;
              }
              char v120 = &v118[v119];
              uint64_t v121 = v21 + 4 * v119 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v121;
                __int16 v117 = v120;
                uint64_t v14 = v120;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v117;
              --v518;
            }
            while (!v40);
            return result;
          case 7:
            uint64_t v122 = v16;
            uint64_t v123 = -(uint64_t)v18;
            uint64_t v124 = -(v513 * v17);
            uint64_t v125 = 4 * v16;
            do
            {
              int v126 = v516;
              do
              {
                int v127 = *v9;
                if (*v9)
                {
                  if (v127 == 255)
                  {
                    CFCalendarRef result = PDM_14621(*v7, *((unsigned __int8 *)v14 + 3));
                    *uint64_t v7 = result;
                  }
                  else
                  {
                    unsigned int v128 = *((unsigned __int8 *)v14 + 3) * v127 + 128;
                    CFCalendarRef result = (unint64_t)DMplusDM_14622(v7, *v7, ((unsigned __int16)(v128 + (v128 >> 8)) >> 8), *v7, v127 ^ 0xFFu);
                  }
                }
                v9 += v122;
                unint64_t v129 = (unint64_t)&v14[v122];
                if (v129 >= v21) {
                  uint64_t v130 = v123;
                }
                else {
                  uint64_t v130 = 0;
                }
                uint64_t v14 = (unsigned int *)(v129 + 4 * v130);
                uint64_t v7 = (unsigned int *)((char *)v7 + v125);
                --v126;
              }
              while (v126);
              v9 += v515;
              v7 += v514;
              __int16 v131 = v517;
              uint64_t v132 = &v517[v513];
              if ((unint64_t)v132 >= v511) {
                uint64_t v133 = v124;
              }
              else {
                uint64_t v133 = 0;
              }
              __int16 v134 = &v132[v133];
              uint64_t v135 = v21 + 4 * v133 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v135;
                __int16 v131 = v134;
                uint64_t v14 = v134;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v131;
              --v518;
            }
            while (!v40);
            return result;
          case 8:
            uint64_t v136 = v16;
            uint64_t v137 = -(uint64_t)v18;
            uint64_t v138 = -(v513 * v17);
            uint64_t v139 = 4 * v16;
            do
            {
              int v140 = v516;
              do
              {
                int v141 = *v9;
                if (*v9)
                {
                  if (v141 == 255) {
                    LOBYTE(v142) = *((unsigned char *)v14 + 3);
                  }
                  else {
                    unsigned int v142 = (*((unsigned __int8 *)v14 + 3) * v141
                  }
                          + 128
                          + ((*((unsigned __int8 *)v14 + 3) * v141 + 128) >> 8)) >> 8;
                  CFCalendarRef result = PDM_14621(*v7, ~(_BYTE)v142);
                  *uint64_t v7 = result;
                }
                v9 += v136;
                unint64_t v143 = (unint64_t)&v14[v136];
                if (v143 >= v21) {
                  uint64_t v144 = v137;
                }
                else {
                  uint64_t v144 = 0;
                }
                uint64_t v14 = (unsigned int *)(v143 + 4 * v144);
                uint64_t v7 = (unsigned int *)((char *)v7 + v139);
                --v140;
              }
              while (v140);
              v9 += v515;
              v7 += v514;
              int v145 = v517;
              double v146 = &v517[v513];
              if ((unint64_t)v146 >= v511) {
                uint64_t v147 = v138;
              }
              else {
                uint64_t v147 = 0;
              }
              int8x8_t v148 = &v146[v147];
              uint64_t v149 = v21 + 4 * v147 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v149;
                int v145 = v148;
                uint64_t v14 = v148;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v145;
              --v518;
            }
            while (!v40);
            return result;
          case 9:
            uint64_t v150 = v16;
            uint64_t v151 = -(uint64_t)v18;
            uint64_t v152 = -(v513 * v17);
            uint64_t v153 = 4 * v16;
            do
            {
              int v154 = v516;
              do
              {
                char v155 = *v9;
                if (*v9)
                {
                  unsigned int v156 = PDM_14621(*v14, *v9);
                  CFCalendarRef result = (unint64_t)DMplusDM_14622(v7, v156, ~*v7 >> 24, *v7, (~v155 + HIBYTE(v156)));
                }
                v9 += v150;
                unint64_t v157 = (unint64_t)&v14[v150];
                if (v157 >= v21) {
                  uint64_t v158 = v151;
                }
                else {
                  uint64_t v158 = 0;
                }
                uint64_t v14 = (unsigned int *)(v157 + 4 * v158);
                uint64_t v7 = (unsigned int *)((char *)v7 + v153);
                --v154;
              }
              while (v154);
              v9 += v515;
              v7 += v514;
              double v159 = v517;
              double v160 = &v517[v513];
              if ((unint64_t)v160 >= v511) {
                uint64_t v161 = v152;
              }
              else {
                uint64_t v161 = 0;
              }
              double v162 = &v160[v161];
              uint64_t v163 = v21 + 4 * v161 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v163;
                double v159 = v162;
                uint64_t v14 = v162;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v159;
              --v518;
            }
            while (!v40);
            return result;
          case 10:
            uint64_t v164 = v16;
            uint64_t v165 = -(uint64_t)v18;
            uint64_t v166 = -(v513 * v17);
            uint64_t v167 = 4 * v16;
            do
            {
              int v168 = v516;
              do
              {
                if (*v9)
                {
                  unsigned int v169 = PDM_14621(*v14, *v9);
                  CFCalendarRef result = (unint64_t)DMplusDM_14622(v7, v169, ~*v7 >> 24, *v7, ~v169 >> 24);
                }
                v9 += v164;
                unint64_t v170 = (unint64_t)&v14[v164];
                if (v170 >= v21) {
                  uint64_t v171 = v165;
                }
                else {
                  uint64_t v171 = 0;
                }
                uint64_t v14 = (unsigned int *)(v170 + 4 * v171);
                uint64_t v7 = (unsigned int *)((char *)v7 + v167);
                --v168;
              }
              while (v168);
              v9 += v515;
              v7 += v514;
              unsigned int v172 = v517;
              double v173 = &v517[v513];
              if ((unint64_t)v173 >= v511) {
                uint64_t v174 = v166;
              }
              else {
                uint64_t v174 = 0;
              }
              double v175 = &v173[v174];
              uint64_t v176 = v21 + 4 * v174 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v176;
                unsigned int v172 = v175;
                uint64_t v14 = v175;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v172;
              --v518;
            }
            while (!v40);
            return result;
          case 11:
            uint64_t v177 = v16;
            uint64_t v178 = -(uint64_t)v18;
            uint64_t v490 = -(v513 * v17);
            uint64_t v179 = 4 * v16;
            do
            {
              int v180 = v516;
              do
              {
                int v181 = *v9;
                if (*v9)
                {
                  unsigned int v182 = PDM_14621(*v14, *v9);
                  unsigned int v183 = HIBYTE(*v7);
                  if (!v519) {
                    LOBYTE(v183) = -1;
                  }
                  if (v19) {
                    int v184 = HIBYTE(v182);
                  }
                  else {
                    int v184 = v181;
                  }
                  CFCalendarRef result = (unint64_t)DAplusdDA_14624(v7, *v7, v183, v182, v184);
                }
                v9 += v177;
                unint64_t v185 = (unint64_t)&v14[v177];
                if (v185 >= v21) {
                  uint64_t v186 = v178;
                }
                else {
                  uint64_t v186 = 0;
                }
                uint64_t v14 = (unsigned int *)(v185 + 4 * v186);
                uint64_t v7 = (unsigned int *)((char *)v7 + v179);
                --v180;
              }
              while (v180);
              v9 += v515;
              v7 += v514;
              int v187 = v517;
              uint64_t v188 = &v517[v513];
              uint64_t v189 = v490;
              if ((unint64_t)v188 < v511) {
                uint64_t v189 = 0;
              }
              double v190 = &v188[v189];
              uint64_t v191 = v21 + 4 * v189 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v191;
                int v187 = v190;
                uint64_t v14 = v190;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v187;
              --v518;
            }
            while (!v40);
            return result;
          case 12:
            uint64_t v192 = v16;
            uint64_t v193 = -(uint64_t)v18;
            uint64_t v521 = -(v513 * v17);
            uint64_t v194 = 4 * v16;
            BOOL v510 = v19;
            do
            {
              int v195 = v516;
              do
              {
                unsigned int v196 = *v9;
                if (*v9)
                {
                  CFCalendarRef result = PDM_14621(*v14, *v9);
                  unsigned int v197 = *v7;
                  unsigned int v198 = BYTE3(result);
                  if (!v510) {
                    unsigned int v198 = v196;
                  }
                  int v199 = ((v197 >> 8) & 0xFF00FF) + BYTE1(result) + (v198 << 16);
                  *uint64_t v7 = (v199 << 8) & 0xFF00FF00 | ((v197 & 0xFF00FF) + (result & 0xFF00FF)) & 0xFF00FF | (15 * (v199 & 0x1000100 | (((v197 & 0xFF00FF) + (result & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v199 & 0x1000100 | (((v197 & 0xFF00FF) + (result & 0xFF00FF)) >> 8) & 0x10001));
                }
                v9 += v192;
                unint64_t v200 = (unint64_t)&v14[v192];
                if (v200 >= v21) {
                  uint64_t v201 = v193;
                }
                else {
                  uint64_t v201 = 0;
                }
                uint64_t v14 = (unsigned int *)(v200 + 4 * v201);
                uint64_t v7 = (unsigned int *)((char *)v7 + v194);
                --v195;
              }
              while (v195);
              v9 += v515;
              v7 += v514;
              uint64_t v202 = v517;
              unint64_t v203 = &v517[v513];
              uint64_t v204 = v521;
              if ((unint64_t)v203 < v511) {
                uint64_t v204 = 0;
              }
              uint64_t v205 = &v203[v204];
              uint64_t v206 = v21 + 4 * v204 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v206;
                uint64_t v202 = v205;
                uint64_t v14 = v205;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v202;
              --v518;
            }
            while (!v40);
            return result;
          case 13:
            uint64_t v207 = v16;
            uint64_t v208 = -(uint64_t)v18;
            uint64_t v491 = -(v513 * v17);
            uint64_t v209 = 4 * v16;
            while (1)
            {
              int v210 = v516;
              do
              {
                unsigned int v211 = *v9;
                if (!*v9) {
                  goto LABEL_300;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v212 = result;
                if (v19)
                {
                  unsigned int v211 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_300;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v213 = 255;
LABEL_298:
                  CFCalendarRef result = PDAmultiplyPDA_14625(result, v213, v212, v211);
                  int v214 = result;
                  goto LABEL_299;
                }
                unsigned int v213 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_298;
                }
                int v214 = v212 & 0xFFFFFF | (v211 << 24);
LABEL_299:
                *uint64_t v7 = v214;
LABEL_300:
                v9 += v207;
                unint64_t v215 = (unint64_t)&v14[v207];
                if (v215 >= v21) {
                  uint64_t v216 = v208;
                }
                else {
                  uint64_t v216 = 0;
                }
                uint64_t v14 = (unsigned int *)(v215 + 4 * v216);
                uint64_t v7 = (unsigned int *)((char *)v7 + v209);
                --v210;
              }
              while (v210);
              v9 += v515;
              v7 += v514;
              float64x2_t v217 = v517;
              float64x2_t v218 = &v517[v513];
              uint64_t v219 = v491;
              if ((unint64_t)v218 < v511) {
                uint64_t v219 = 0;
              }
              uint64_t v220 = &v218[v219];
              uint64_t v221 = v21 + 4 * v219 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v221;
                float64x2_t v217 = v220;
                uint64_t v14 = v220;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v217;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 14:
            uint64_t v222 = v16;
            uint64_t v223 = -(uint64_t)v18;
            uint64_t v492 = -(v513 * v17);
            uint64_t v224 = 4 * v16;
            while (1)
            {
              int v225 = v516;
              do
              {
                unsigned int v226 = *v9;
                if (!*v9) {
                  goto LABEL_323;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v227 = result;
                if (v19)
                {
                  unsigned int v226 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_323;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v228 = 255;
LABEL_321:
                  CFCalendarRef result = PDAscreenPDA_14626(result, v228, v227, v226);
                  int v229 = result;
                  goto LABEL_322;
                }
                unsigned int v228 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_321;
                }
                int v229 = v227 & 0xFFFFFF | (v226 << 24);
LABEL_322:
                *uint64_t v7 = v229;
LABEL_323:
                v9 += v222;
                unint64_t v230 = (unint64_t)&v14[v222];
                if (v230 >= v21) {
                  uint64_t v231 = v223;
                }
                else {
                  uint64_t v231 = 0;
                }
                uint64_t v14 = (unsigned int *)(v230 + 4 * v231);
                uint64_t v7 = (unsigned int *)((char *)v7 + v224);
                --v225;
              }
              while (v225);
              v9 += v515;
              v7 += v514;
              CGRect v232 = v517;
              CGRect v233 = &v517[v513];
              uint64_t v234 = v492;
              if ((unint64_t)v233 < v511) {
                uint64_t v234 = 0;
              }
              CGRect v235 = &v233[v234];
              uint64_t v236 = v21 + 4 * v234 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v236;
                CGRect v232 = v235;
                uint64_t v14 = v235;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v232;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 15:
            uint64_t v237 = v16;
            uint64_t v238 = -(uint64_t)v18;
            uint64_t v493 = -(v513 * v17);
            uint64_t v239 = 4 * v16;
            while (1)
            {
              int v240 = v516;
              do
              {
                unsigned int v241 = *v9;
                if (!*v9) {
                  goto LABEL_346;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v242 = result;
                if (v19)
                {
                  unsigned int v241 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_346;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v243 = 255;
LABEL_344:
                  CFCalendarRef result = PDAoverlayPDA_14627(result, v243, v242, v241);
                  int v244 = result;
                  goto LABEL_345;
                }
                unsigned int v243 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_344;
                }
                int v244 = v242 & 0xFFFFFF | (v241 << 24);
LABEL_345:
                *uint64_t v7 = v244;
LABEL_346:
                v9 += v237;
                unint64_t v245 = (unint64_t)&v14[v237];
                if (v245 >= v21) {
                  uint64_t v246 = v238;
                }
                else {
                  uint64_t v246 = 0;
                }
                uint64_t v14 = (unsigned int *)(v245 + 4 * v246);
                uint64_t v7 = (unsigned int *)((char *)v7 + v239);
                --v240;
              }
              while (v240);
              v9 += v515;
              v7 += v514;
              uint64_t v247 = v517;
              uint64_t v248 = &v517[v513];
              uint64_t v249 = v493;
              if ((unint64_t)v248 < v511) {
                uint64_t v249 = 0;
              }
              uint64_t v250 = &v248[v249];
              uint64_t v251 = v21 + 4 * v249 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v251;
                uint64_t v247 = v250;
                uint64_t v14 = v250;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v247;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 16:
            uint64_t v252 = v16;
            uint64_t v253 = -(uint64_t)v18;
            uint64_t v494 = -(v513 * v17);
            uint64_t v254 = 4 * v16;
            while (1)
            {
              int v255 = v516;
              do
              {
                unsigned int v256 = *v9;
                if (!*v9) {
                  goto LABEL_369;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                unsigned int v257 = result;
                if (v19)
                {
                  unsigned int v256 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_369;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v258 = 255;
LABEL_367:
                  CFCalendarRef result = PDAdarkenPDA_14629(result, v258, v257, v256);
                  int v259 = result;
                  goto LABEL_368;
                }
                unsigned int v258 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_367;
                }
                int v259 = v257 & 0xFFFFFF | (v256 << 24);
LABEL_368:
                *uint64_t v7 = v259;
LABEL_369:
                v9 += v252;
                unint64_t v260 = (unint64_t)&v14[v252];
                if (v260 >= v21) {
                  uint64_t v261 = v253;
                }
                else {
                  uint64_t v261 = 0;
                }
                uint64_t v14 = (unsigned int *)(v260 + 4 * v261);
                uint64_t v7 = (unsigned int *)((char *)v7 + v254);
                --v255;
              }
              while (v255);
              v9 += v515;
              v7 += v514;
              uint64_t v262 = v517;
              uint64_t v263 = &v517[v513];
              uint64_t v264 = v494;
              if ((unint64_t)v263 < v511) {
                uint64_t v264 = 0;
              }
              uint64_t v265 = &v263[v264];
              uint64_t v266 = v21 + 4 * v264 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v266;
                uint64_t v262 = v265;
                uint64_t v14 = v265;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v262;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 17:
            uint64_t v267 = v16;
            uint64_t v268 = -(uint64_t)v18;
            uint64_t v495 = -(v513 * v17);
            uint64_t v269 = 4 * v16;
            while (1)
            {
              int v270 = v516;
              do
              {
                unsigned int v271 = *v9;
                if (!*v9) {
                  goto LABEL_392;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                unsigned int v272 = result;
                if (v19)
                {
                  unsigned int v271 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_392;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v273 = 255;
LABEL_390:
                  CFCalendarRef result = PDAlightenPDA_14628(result, v273, v272, v271);
                  int v274 = result;
                  goto LABEL_391;
                }
                unsigned int v273 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_390;
                }
                int v274 = v272 & 0xFFFFFF | (v271 << 24);
LABEL_391:
                *uint64_t v7 = v274;
LABEL_392:
                v9 += v267;
                unint64_t v275 = (unint64_t)&v14[v267];
                if (v275 >= v21) {
                  uint64_t v276 = v268;
                }
                else {
                  uint64_t v276 = 0;
                }
                uint64_t v14 = (unsigned int *)(v275 + 4 * v276);
                uint64_t v7 = (unsigned int *)((char *)v7 + v269);
                --v270;
              }
              while (v270);
              v9 += v515;
              v7 += v514;
              size_t v277 = v517;
              CFDataRef v278 = &v517[v513];
              uint64_t v279 = v495;
              if ((unint64_t)v278 < v511) {
                uint64_t v279 = 0;
              }
              int v280 = &v278[v279];
              uint64_t v281 = v21 + 4 * v279 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v281;
                size_t v277 = v280;
                uint64_t v14 = v280;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v277;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 18:
            uint64_t v282 = v16;
            uint64_t v283 = -(uint64_t)v18;
            uint64_t v496 = -(v513 * v17);
            uint64_t v284 = 4 * v16;
            while (1)
            {
              int v285 = v516;
              do
              {
                unsigned int v286 = *v9;
                if (!*v9) {
                  goto LABEL_415;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v287 = result;
                if (v19)
                {
                  unsigned int v286 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_415;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v288 = 255;
LABEL_413:
                  CFCalendarRef result = PDAcolordodgePDA_14630(result, v288, v287, v286);
                  int v289 = result;
                  goto LABEL_414;
                }
                unsigned int v288 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_413;
                }
                int v289 = v287 & 0xFFFFFF | (v286 << 24);
LABEL_414:
                *uint64_t v7 = v289;
LABEL_415:
                v9 += v282;
                unint64_t v290 = (unint64_t)&v14[v282];
                if (v290 >= v21) {
                  uint64_t v291 = v283;
                }
                else {
                  uint64_t v291 = 0;
                }
                uint64_t v14 = (unsigned int *)(v290 + 4 * v291);
                uint64_t v7 = (unsigned int *)((char *)v7 + v284);
                --v285;
              }
              while (v285);
              v9 += v515;
              v7 += v514;
              uint64_t v292 = v517;
              uint64_t v293 = &v517[v513];
              uint64_t v294 = v496;
              if ((unint64_t)v293 < v511) {
                uint64_t v294 = 0;
              }
              uint64_t v295 = &v293[v294];
              uint64_t v296 = v21 + 4 * v294 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v296;
                uint64_t v292 = v295;
                uint64_t v14 = v295;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v292;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 19:
            uint64_t v297 = v16;
            uint64_t v298 = -(uint64_t)v18;
            uint64_t v497 = -(v513 * v17);
            uint64_t v299 = 4 * v16;
            while (1)
            {
              int v300 = v516;
              do
              {
                unsigned int v301 = *v9;
                if (!*v9) {
                  goto LABEL_438;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v302 = result;
                if (v19)
                {
                  unsigned int v301 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_438;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v303 = 255;
LABEL_436:
                  CFCalendarRef result = PDAcolorburnPDA_14631(result, v303, v302, v301);
                  int v304 = result;
                  goto LABEL_437;
                }
                unsigned int v303 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_436;
                }
                int v304 = v302 & 0xFFFFFF | (v301 << 24);
LABEL_437:
                *uint64_t v7 = v304;
LABEL_438:
                v9 += v297;
                unint64_t v305 = (unint64_t)&v14[v297];
                if (v305 >= v21) {
                  uint64_t v306 = v298;
                }
                else {
                  uint64_t v306 = 0;
                }
                uint64_t v14 = (unsigned int *)(v305 + 4 * v306);
                uint64_t v7 = (unsigned int *)((char *)v7 + v299);
                --v300;
              }
              while (v300);
              v9 += v515;
              v7 += v514;
              uint64_t v307 = v517;
              unsigned int v308 = &v517[v513];
              uint64_t v309 = v497;
              if ((unint64_t)v308 < v511) {
                uint64_t v309 = 0;
              }
              unint64_t v310 = &v308[v309];
              uint64_t v311 = v21 + 4 * v309 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v311;
                uint64_t v307 = v310;
                uint64_t v14 = v310;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v307;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 20:
            uint64_t v312 = v16;
            uint64_t v313 = -(uint64_t)v18;
            uint64_t v498 = -(v513 * v17);
            uint64_t v314 = 4 * v16;
            while (1)
            {
              int v315 = v516;
              do
              {
                unsigned int v316 = *v9;
                if (!*v9) {
                  goto LABEL_461;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v317 = result;
                if (v19)
                {
                  unsigned int v316 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_461;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v318 = 255;
LABEL_459:
                  CFCalendarRef result = PDAsoftlightPDA_14633(result, v318, v317, v316);
                  int v319 = result;
                  goto LABEL_460;
                }
                unsigned int v318 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_459;
                }
                int v319 = v317 & 0xFFFFFF | (v316 << 24);
LABEL_460:
                *uint64_t v7 = v319;
LABEL_461:
                v9 += v312;
                unint64_t v320 = (unint64_t)&v14[v312];
                if (v320 >= v21) {
                  uint64_t v321 = v313;
                }
                else {
                  uint64_t v321 = 0;
                }
                uint64_t v14 = (unsigned int *)(v320 + 4 * v321);
                uint64_t v7 = (unsigned int *)((char *)v7 + v314);
                --v315;
              }
              while (v315);
              v9 += v515;
              v7 += v514;
              unsigned int v322 = v517;
              long long v323 = &v517[v513];
              uint64_t v324 = v498;
              if ((unint64_t)v323 < v511) {
                uint64_t v324 = 0;
              }
              unsigned int v325 = &v323[v324];
              uint64_t v326 = v21 + 4 * v324 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v326;
                unsigned int v322 = v325;
                uint64_t v14 = v325;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v322;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 21:
            uint64_t v327 = v16;
            uint64_t v328 = -(uint64_t)v18;
            uint64_t v499 = -(v513 * v17);
            uint64_t v329 = 4 * v16;
            while (1)
            {
              int v330 = v516;
              do
              {
                unsigned int v331 = *v9;
                if (!*v9) {
                  goto LABEL_484;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v332 = result;
                if (v19)
                {
                  unsigned int v331 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_484;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v333 = 255;
LABEL_482:
                  CFCalendarRef result = PDAhardlightPDA_14632(result, v333, v332, v331);
                  int v334 = result;
                  goto LABEL_483;
                }
                unsigned int v333 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_482;
                }
                int v334 = v332 & 0xFFFFFF | (v331 << 24);
LABEL_483:
                *uint64_t v7 = v334;
LABEL_484:
                v9 += v327;
                unint64_t v335 = (unint64_t)&v14[v327];
                if (v335 >= v21) {
                  uint64_t v336 = v328;
                }
                else {
                  uint64_t v336 = 0;
                }
                uint64_t v14 = (unsigned int *)(v335 + 4 * v336);
                uint64_t v7 = (unsigned int *)((char *)v7 + v329);
                --v330;
              }
              while (v330);
              v9 += v515;
              v7 += v514;
              long long v337 = v517;
              long long v338 = &v517[v513];
              uint64_t v339 = v499;
              if ((unint64_t)v338 < v511) {
                uint64_t v339 = 0;
              }
              long long v340 = &v338[v339];
              uint64_t v341 = v21 + 4 * v339 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v341;
                long long v337 = v340;
                uint64_t v14 = v340;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v337;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 22:
            uint64_t v342 = v16;
            uint64_t v343 = -(uint64_t)v18;
            uint64_t v500 = -(v513 * v17);
            uint64_t v344 = 4 * v16;
            while (1)
            {
              int v345 = v516;
              do
              {
                unsigned int v346 = *v9;
                if (!*v9) {
                  goto LABEL_507;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                unsigned __int32 v347 = result;
                if (v19)
                {
                  unsigned int v346 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_507;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v348 = 255;
LABEL_505:
                  CFCalendarRef result = PDAdifferencePDA_14634(result, v348, v347, v346);
                  int v349 = result;
                  goto LABEL_506;
                }
                unsigned int v348 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_505;
                }
                int v349 = v347 & 0xFFFFFF | (v346 << 24);
LABEL_506:
                *uint64_t v7 = v349;
LABEL_507:
                v9 += v342;
                unint64_t v350 = (unint64_t)&v14[v342];
                if (v350 >= v21) {
                  uint64_t v351 = v343;
                }
                else {
                  uint64_t v351 = 0;
                }
                uint64_t v14 = (unsigned int *)(v350 + 4 * v351);
                uint64_t v7 = (unsigned int *)((char *)v7 + v344);
                --v345;
              }
              while (v345);
              v9 += v515;
              v7 += v514;
              int v352 = v517;
              uint64_t v353 = &v517[v513];
              uint64_t v354 = v500;
              if ((unint64_t)v353 < v511) {
                uint64_t v354 = 0;
              }
              uint64_t v355 = &v353[v354];
              uint64_t v356 = v21 + 4 * v354 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v356;
                int v352 = v355;
                uint64_t v14 = v355;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v352;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 23:
            uint64_t v357 = v16;
            uint64_t v358 = -(uint64_t)v18;
            uint64_t v501 = -(v513 * v17);
            uint64_t v359 = 4 * v16;
            while (1)
            {
              int v360 = v516;
              do
              {
                unsigned int v361 = *v9;
                if (!*v9) {
                  goto LABEL_530;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v362 = result;
                if (v19)
                {
                  unsigned int v361 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_530;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v363 = 255;
LABEL_528:
                  CFCalendarRef result = PDAexclusionPDA_14635(result, v363, v362, v361);
                  int v364 = result;
                  goto LABEL_529;
                }
                unsigned int v363 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_528;
                }
                int v364 = v362 & 0xFFFFFF | (v361 << 24);
LABEL_529:
                *uint64_t v7 = v364;
LABEL_530:
                v9 += v357;
                unint64_t v365 = (unint64_t)&v14[v357];
                if (v365 >= v21) {
                  uint64_t v366 = v358;
                }
                else {
                  uint64_t v366 = 0;
                }
                uint64_t v14 = (unsigned int *)(v365 + 4 * v366);
                uint64_t v7 = (unsigned int *)((char *)v7 + v359);
                --v360;
              }
              while (v360);
              v9 += v515;
              v7 += v514;
              uint64_t v367 = v517;
              uint64_t v368 = &v517[v513];
              uint64_t v369 = v501;
              if ((unint64_t)v368 < v511) {
                uint64_t v369 = 0;
              }
              uint64_t v370 = &v368[v369];
              uint64_t v371 = v21 + 4 * v369 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v371;
                uint64_t v367 = v370;
                uint64_t v14 = v370;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v367;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 24:
            uint64_t v372 = v16;
            uint64_t v373 = -(uint64_t)v18;
            uint64_t v502 = -(v513 * v17);
            uint64_t v374 = 4 * v16;
            while (1)
            {
              int v375 = v516;
              do
              {
                unsigned int v376 = *v9;
                if (!*v9) {
                  goto LABEL_553;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v377 = result;
                if (v19)
                {
                  unsigned int v376 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_553;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v378 = 255;
LABEL_551:
                  CFCalendarRef result = PDAhuePDA_14636(result, v378, v377, v376);
                  int v379 = result;
                  goto LABEL_552;
                }
                unsigned int v378 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_551;
                }
                int v379 = v377 & 0xFFFFFF | (v376 << 24);
LABEL_552:
                *uint64_t v7 = v379;
LABEL_553:
                v9 += v372;
                unint64_t v380 = (unint64_t)&v14[v372];
                if (v380 >= v21) {
                  uint64_t v381 = v373;
                }
                else {
                  uint64_t v381 = 0;
                }
                uint64_t v14 = (unsigned int *)(v380 + 4 * v381);
                uint64_t v7 = (unsigned int *)((char *)v7 + v374);
                --v375;
              }
              while (v375);
              v9 += v515;
              v7 += v514;
              uint64_t v382 = v517;
              uint64_t v383 = &v517[v513];
              uint64_t v384 = v502;
              if ((unint64_t)v383 < v511) {
                uint64_t v384 = 0;
              }
              uint64_t v385 = &v383[v384];
              uint64_t v386 = v21 + 4 * v384 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v386;
                uint64_t v382 = v385;
                uint64_t v14 = v385;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v382;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 25:
            uint64_t v387 = v16;
            uint64_t v388 = -(uint64_t)v18;
            uint64_t v503 = -(v513 * v17);
            uint64_t v389 = 4 * v16;
            while (1)
            {
              int v390 = v516;
              do
              {
                unsigned int v391 = *v9;
                if (!*v9) {
                  goto LABEL_576;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v392 = result;
                if (v19)
                {
                  unsigned int v391 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_576;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v393 = 255;
LABEL_574:
                  CFCalendarRef result = PDAsaturationPDA_14637(result, v393, v392, v391);
                  int v394 = result;
                  goto LABEL_575;
                }
                unsigned int v393 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_574;
                }
                int v394 = v392 & 0xFFFFFF | (v391 << 24);
LABEL_575:
                *uint64_t v7 = v394;
LABEL_576:
                v9 += v387;
                unint64_t v395 = (unint64_t)&v14[v387];
                if (v395 >= v21) {
                  uint64_t v396 = v388;
                }
                else {
                  uint64_t v396 = 0;
                }
                uint64_t v14 = (unsigned int *)(v395 + 4 * v396);
                uint64_t v7 = (unsigned int *)((char *)v7 + v389);
                --v390;
              }
              while (v390);
              v9 += v515;
              v7 += v514;
              unsigned int v397 = v517;
              unsigned int v398 = &v517[v513];
              uint64_t v399 = v503;
              if ((unint64_t)v398 < v511) {
                uint64_t v399 = 0;
              }
              unsigned int v400 = &v398[v399];
              uint64_t v401 = v21 + 4 * v399 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v401;
                unsigned int v397 = v400;
                uint64_t v14 = v400;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v397;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 26:
            uint64_t v402 = v16;
            uint64_t v403 = -(uint64_t)v18;
            uint64_t v504 = -(v513 * v17);
            uint64_t v404 = 4 * v16;
            while (1)
            {
              int v405 = v516;
              do
              {
                unsigned int v406 = *v9;
                if (!*v9) {
                  goto LABEL_599;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                if (v19)
                {
                  unsigned int v406 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_599;
                  }
                }
                unsigned int v407 = *v7;
                if (!v519)
                {
                  unsigned int v408 = 255;
LABEL_597:
                  CFCalendarRef result = PDAluminosityPDA_14638(result, v406, v407, v408);
                  goto LABEL_598;
                }
                unsigned int v408 = HIBYTE(v407);
                if (HIBYTE(v407)) {
                  goto LABEL_597;
                }
                CFCalendarRef result = result & 0xFFFFFF | (v406 << 24);
LABEL_598:
                *uint64_t v7 = result;
LABEL_599:
                v9 += v402;
                unint64_t v409 = (unint64_t)&v14[v402];
                if (v409 >= v21) {
                  uint64_t v410 = v403;
                }
                else {
                  uint64_t v410 = 0;
                }
                uint64_t v14 = (unsigned int *)(v409 + 4 * v410);
                uint64_t v7 = (unsigned int *)((char *)v7 + v404);
                --v405;
              }
              while (v405);
              v9 += v515;
              v7 += v514;
              uint64_t v411 = v517;
              int32x4_t v412 = &v517[v513];
              uint64_t v413 = v504;
              if ((unint64_t)v412 < v511) {
                uint64_t v413 = 0;
              }
              uint64_t v414 = &v412[v413];
              uint64_t v415 = v21 + 4 * v413 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v415;
                uint64_t v411 = v414;
                uint64_t v14 = v414;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v411;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 27:
            uint64_t v416 = v16;
            uint64_t v417 = -(uint64_t)v18;
            uint64_t v505 = -(v513 * v17);
            uint64_t v418 = 4 * v16;
            while (1)
            {
              int v419 = v516;
              do
              {
                unsigned int v420 = *v9;
                if (!*v9) {
                  goto LABEL_622;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                unsigned int v421 = result;
                if (v19)
                {
                  unsigned int v420 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_622;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v422 = 255;
LABEL_620:
                  CFCalendarRef result = PDAluminosityPDA_14638(result, v422, v421, v420);
                  int v423 = result;
                  goto LABEL_621;
                }
                unsigned int v422 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_620;
                }
                int v423 = v421 & 0xFFFFFF | (v420 << 24);
LABEL_621:
                *uint64_t v7 = v423;
LABEL_622:
                v9 += v416;
                unint64_t v424 = (unint64_t)&v14[v416];
                if (v424 >= v21) {
                  uint64_t v425 = v417;
                }
                else {
                  uint64_t v425 = 0;
                }
                uint64_t v14 = (unsigned int *)(v424 + 4 * v425);
                uint64_t v7 = (unsigned int *)((char *)v7 + v418);
                --v419;
              }
              while (v419);
              v9 += v515;
              v7 += v514;
              unsigned int v426 = v517;
              int v427 = &v517[v513];
              uint64_t v428 = v505;
              if ((unint64_t)v427 < v511) {
                uint64_t v428 = 0;
              }
              unsigned int v429 = &v427[v428];
              uint64_t v430 = v21 + 4 * v428 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v430;
                unsigned int v426 = v429;
                uint64_t v14 = v429;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v426;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 28:
            uint64_t v431 = v16;
            uint64_t v432 = -(uint64_t)v18;
            uint64_t v506 = -(v513 * v17);
            uint64_t v433 = 4 * v16;
            while (1)
            {
              int v434 = v516;
              do
              {
                unsigned int v435 = *v9;
                if (!*v9) {
                  goto LABEL_645;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v436 = result;
                if (v19)
                {
                  unsigned int v435 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_645;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v437 = 255;
LABEL_643:
                  CFCalendarRef result = PDAtranspose_huePDA_14639(result, v437, v436, v435);
                  int v438 = result;
                  goto LABEL_644;
                }
                unsigned int v437 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_643;
                }
                int v438 = v436 & 0xFFFFFF | (v435 << 24);
LABEL_644:
                *uint64_t v7 = v438;
LABEL_645:
                v9 += v431;
                unint64_t v439 = (unint64_t)&v14[v431];
                if (v439 >= v21) {
                  uint64_t v440 = v432;
                }
                else {
                  uint64_t v440 = 0;
                }
                uint64_t v14 = (unsigned int *)(v439 + 4 * v440);
                uint64_t v7 = (unsigned int *)((char *)v7 + v433);
                --v434;
              }
              while (v434);
              v9 += v515;
              v7 += v514;
              uint64_t v441 = v517;
              int v442 = &v517[v513];
              uint64_t v443 = v506;
              if ((unint64_t)v442 < v511) {
                uint64_t v443 = 0;
              }
              int v444 = &v442[v443];
              uint64_t v445 = v21 + 4 * v443 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v445;
                uint64_t v441 = v444;
                uint64_t v14 = v444;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v441;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 29:
            uint64_t v446 = v16;
            uint64_t v447 = -(uint64_t)v18;
            uint64_t v507 = -(v513 * v17);
            uint64_t v448 = 4 * v16;
            while (1)
            {
              int v449 = v516;
              do
              {
                unsigned int v450 = *v9;
                if (!*v9) {
                  goto LABEL_668;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                int v451 = result;
                if (v19)
                {
                  unsigned int v450 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_668;
                  }
                }
                CFCalendarRef result = *v7;
                if (!v519)
                {
                  unsigned int v452 = 255;
LABEL_666:
                  CFCalendarRef result = PDAtranspose_saturationPDA_14640(result, v452, v451, v450);
                  int v453 = result;
                  goto LABEL_667;
                }
                unsigned int v452 = BYTE3(result);
                if (BYTE3(result)) {
                  goto LABEL_666;
                }
                int v453 = v451 & 0xFFFFFF | (v450 << 24);
LABEL_667:
                *uint64_t v7 = v453;
LABEL_668:
                v9 += v446;
                unint64_t v454 = (unint64_t)&v14[v446];
                if (v454 >= v21) {
                  uint64_t v455 = v447;
                }
                else {
                  uint64_t v455 = 0;
                }
                uint64_t v14 = (unsigned int *)(v454 + 4 * v455);
                uint64_t v7 = (unsigned int *)((char *)v7 + v448);
                --v449;
              }
              while (v449);
              v9 += v515;
              v7 += v514;
              unsigned int v456 = v517;
              unsigned int v457 = &v517[v513];
              uint64_t v458 = v507;
              if ((unint64_t)v457 < v511) {
                uint64_t v458 = 0;
              }
              unint64_t v459 = &v457[v458];
              uint64_t v460 = v21 + 4 * v458 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v460;
                unsigned int v456 = v459;
                uint64_t v14 = v459;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v456;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 30:
            uint64_t v461 = v16;
            uint64_t v462 = -(uint64_t)v18;
            uint64_t v508 = -(v513 * v17);
            uint64_t v463 = 4 * v16;
            while (1)
            {
              int v464 = v516;
              do
              {
                unsigned int v465 = *v9;
                if (!*v9) {
                  goto LABEL_691;
                }
                CFCalendarRef result = PDM_14621(*v14, *v9);
                if (v19)
                {
                  unsigned int v465 = BYTE3(result);
                  if (!BYTE3(result)) {
                    goto LABEL_691;
                  }
                }
                unsigned int v466 = *v7;
                if (!v519)
                {
                  unsigned int v467 = 255;
LABEL_689:
                  CFCalendarRef result = PDAtranspose_luminosityPDA_14641(result, v465, v466, v467);
                  goto LABEL_690;
                }
                unsigned int v467 = HIBYTE(v466);
                if (HIBYTE(v466)) {
                  goto LABEL_689;
                }
                CFCalendarRef result = result & 0xFFFFFF | (v465 << 24);
LABEL_690:
                *uint64_t v7 = result;
LABEL_691:
                v9 += v461;
                unint64_t v468 = (unint64_t)&v14[v461];
                if (v468 >= v21) {
                  uint64_t v469 = v462;
                }
                else {
                  uint64_t v469 = 0;
                }
                uint64_t v14 = (unsigned int *)(v468 + 4 * v469);
                uint64_t v7 = (unsigned int *)((char *)v7 + v463);
                --v464;
              }
              while (v464);
              v9 += v515;
              v7 += v514;
              int v470 = v517;
              unsigned int v471 = &v517[v513];
              uint64_t v472 = v508;
              if ((unint64_t)v471 < v511) {
                uint64_t v472 = 0;
              }
              unsigned int v473 = &v471[v472];
              uint64_t v474 = v21 + 4 * v472 + 4 * v513;
              if (v512)
              {
                v14 += v513;
              }
              else
              {
                unint64_t v21 = v474;
                int v470 = v473;
                uint64_t v14 = v473;
              }
              BOOL v40 = v518 == 1;
              uint64_t v517 = v470;
              --v518;
              if (v40) {
                return result;
              }
            }
          case 31:
            uint64_t v475 = v16;
            uint64_t v476 = -(uint64_t)v18;
            uint64_t v509 = -(v513 * v17);
            uint64_t v477 = 4 * v16;
            break;
          default:
            return result;
        }
LABEL_704:
        int v478 = v516;
        while (1)
        {
          unsigned int v479 = *v9;
          if (*v9)
          {
            CFCalendarRef result = PDM_14621(*v14, *v9);
            unsigned int v480 = result;
            if (!v19) {
              break;
            }
            unsigned int v479 = BYTE3(result);
            if (BYTE3(result)) {
              break;
            }
          }
LABEL_714:
          v9 += v475;
          unint64_t v483 = (unint64_t)&v14[v475];
          if (v483 >= v21) {
            uint64_t v484 = v476;
          }
          else {
            uint64_t v484 = 0;
          }
          uint64_t v14 = (unsigned int *)(v483 + 4 * v484);
          uint64_t v7 = (unsigned int *)((char *)v7 + v477);
          if (!--v478)
          {
            v9 += v515;
            v7 += v514;
            unsigned int v485 = v517;
            uint64_t v486 = &v517[v513];
            uint64_t v487 = v509;
            if ((unint64_t)v486 < v511) {
              uint64_t v487 = 0;
            }
            uint64_t v488 = &v486[v487];
            uint64_t v489 = v21 + 4 * v487 + 4 * v513;
            if (v512)
            {
              v14 += v513;
            }
            else
            {
              unint64_t v21 = v489;
              unsigned int v485 = v488;
              uint64_t v14 = v488;
            }
            BOOL v40 = v518 == 1;
            uint64_t v517 = v485;
            --v518;
            if (v40) {
              return result;
            }
            goto LABEL_704;
          }
        }
        CFCalendarRef result = *v7;
        if (v519)
        {
          unsigned int v481 = BYTE3(result);
          if (!BYTE3(result))
          {
            int v482 = v480 & 0xFFFFFF | (v479 << 24);
LABEL_713:
            *uint64_t v7 = v482;
            goto LABEL_714;
          }
        }
        else
        {
          unsigned int v481 = 255;
        }
        CFCalendarRef result = PDAtranspose_luminosityPDA_14641(result, v481, v480, v479);
        int v482 = result;
        goto LABEL_713;
      }
      uint64_t v14 = 0;
      unint64_t v21 = 0;
      int v16 = 1;
LABEL_15:
      unint64_t v511 = 0;
      uint64_t v517 = 0;
      uint64_t v513 = v13 - v3;
      int v512 = 1;
      goto LABEL_16;
    }
    uint64_t v13 = v12 >> 2;
    uint64_t v14 = (unsigned int *)(v4 + 4 * (v10 + v13 * v11));
    if (v13 != v6)
    {
      int v16 = 1;
LABEL_14:
      int v17 = 0;
      uint64_t v3 = v16 * v516;
      BOOL v19 = v5 != 0;
      unint64_t v514 = v6 - v3;
      uint64_t v515 = v8 - v3;
      unint64_t v21 = -1;
      int v18 = v13;
      goto LABEL_15;
    }
    if ((char *)v7 - (char *)v14 >= 1)
    {
      if (v516 >= (uint64_t)((unint64_t)((char *)v7 - (char *)v14) >> 2))
      {
        v7 += v516 - 1;
        v14 += v516 - 1;
        v9 += v516 - 1;
        int v16 = -1;
        goto LABEL_13;
      }
      uint64_t v15 = *(int *)(result + 8) - 1;
      if (v7 <= &v14[v6 * v15 - 1 + v516])
      {
        v7 += v6 * v15;
        uint64_t v13 = -(uint64_t)v6;
        v9 += v8 * v15;
        uint64_t v8 = -v8;
        int v16 = 1;
        v14 += v6 * v15;
        unint64_t v6 = -(uint64_t)v6;
        goto LABEL_14;
      }
    }
    int v16 = 1;
LABEL_13:
    uint64_t v13 = (unint64_t)*(int *)(result + 28) >> 2;
    goto LABEL_14;
  }
  return result;
}

void argb32_mark_constdeep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a2 + 88);
  if (v9) {
    unsigned int v10 = *v9;
  }
  else {
    unsigned int v10 = -16777216;
  }
  uint64_t v154 = *(int *)(a2 + 28);
  uint64_t v11 = *(void *)(a2 + 40) + (int)v154 * (uint64_t)*(int *)(a2 + 16) + 4 * *(int *)(a2 + 12);
  uint64_t v153 = *(int *)(a2 + 124);
  uint64_t v12 = *(void *)(a2 + 136) + (int)v153 * (uint64_t)*(int *)(a2 + 108) + 2 * *(int *)(a2 + 104);
  if (*(void *)(a2 + 48))
  {
    uint64_t v13 = *(void *)(a2 + 152);
    long double v14 = *(double *)(a2 + 144);
    if (v13 && v14 == 2.0)
    {
      unsigned int v15 = PIXELCONSTANT_14645(*(float **)(a1 + 64), *(_DWORD *)v13, *(float **)(v13 + 8), *(float *)(v13 + 16));
      int v16 = *(_DWORD *)(a2 + 4);
      int v17 = *(_DWORD *)(a2 + 8);
      int v152 = v17;
      if (HIBYTE(v10) == 255)
      {
        if (v17 >= 1)
        {
          int v18 = 0;
          unsigned int v19 = (BYTE2(v10) * BYTE2(v10) + 128 + ((BYTE2(v10) * BYTE2(v10) + 128) >> 8)) >> 8;
          unsigned int v20 = (BYTE1(v10) * BYTE1(v10) + 128 + ((BYTE1(v10) * BYTE1(v10) + 128) >> 8)) >> 8;
          unsigned int v21 = (v10 * v10
               + 128
               + ((v10 * v10 + 128) >> 8)) >> 8;
          do
          {
            if (v16 >= 1)
            {
              uint64_t v22 = 0;
              do
              {
                unint64_t v23 = *(unsigned __int16 *)(v12 + 2 * v22);
                if (*(_WORD *)(v12 + 2 * v22))
                {
                  uint64_t v24 = *(unsigned int *)(v11 + 4 * v22);
                  unint64_t v25 = ((v15 | ((unint64_t)v15 << 24)) & 0xFF00FF00FF00FFLL)
                      * (~v24 >> 24)
                      + 0x80008000800080;
                  unint64_t v26 = ((((v25 >> 8) & 0xFF00FF00FF00FFLL) + v25) >> 8) & 0xFF00FF00FF00FFLL;
                  unsigned int v27 = v24 + ((v26 >> 24) | v26);
                  int32x2_t v28 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v27), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                  unsigned int v29 = (v24 + (BYTE3(v26) | v26));
                  unsigned int v30 = HIBYTE(v27);
                  unsigned int v31 = v29;
                  int32x2_t v32 = v28;
                  if (v30 - 1 <= 0xFD)
                  {
                    int32x2_t v32 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v28, vdup_n_s32(v33)), 8uLL);
                    unsigned int v31 = (v29 * v33) >> 8;
                  }
                  int8x8_t v34 = (int8x8_t)vmul_s32(v32, v32);
                  unsigned int v38 = (int)((256 - ((v36 * v36) >> 8)) * v30 - ((v36 * v36) >> 8) + ((v36 * v36) >> 8 << 8)) >> 8;
                                                                         + (256 - v35)
                                                                         * ((v34.i32[0]
                                                                           + 128
                                                                           + ((v34.i32[0] + 128) >> 8)) >> 8)) >> 8];
                  unsigned int v40 = v38
                                                              + (256 - v37)
                                                              * ((v31 * v31 + 128 + ((v31 * v31 + 128) >> 8)) >> 8)) >> 8]
                      + 128;
                  unsigned int v41 = (v40 + (v40 >> 8)) >> 8;
                  if (v35 <= v36) {
                    unsigned int v35 = v36;
                  }
                  if (v35 > v37) {
                    unsigned int v37 = v35;
                  }
                  unsigned int v42 = 256 - v37;
                  v34.i8[0] = *v39;
                                                                    + (256 - v36)
                                                                    * ((v34.i32[1]
                                                                      + 128
                                                                      + ((v34.i32[1] + 128) >> 8)) >> 8)) >> 8];
                  uint32x2_t v43 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v38), (int32x2_t)vand_s8(v34, (int8x8_t)0xFF000000FFLL));
                  uint32x2_t v44 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v43, v43, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v42), v28), 8uLL)), 0), (uint32x2_t)0x800000010);
                  unsigned __int32 v45 = (v41 - ((int)(v42 * v29) >> 8)) & ~((int)(v41 - ((int)(v42 * v29) >> 8)) >> 31) | (((v38 - ((int)(v42 * v30) >> 8)) & ~((int)(v38 - ((int)(v42 * v30) >> 8)) >> 31)) << 24) | v44.i32[0] | v44.i32[1];
                  unint64_t v46 = ((v24 | (v24 << 24)) & 0xFF00FF00FF00FFLL) * (~v45 >> 24) + 0x80008000800080;
                  unint64_t v47 = ((((v46 >> 8) & 0xFF00FF00FF00FFLL) + v46) >> 8) & 0xFF00FF00FF00FFLL;
                  *(_DWORD *)(v11 + 4 * v22) = v45 + ((v47 >> 24) | v47);
                }
                ++v22;
              }
              while (v16 != v22);
            }
            v11 += v154;
            v12 += v153;
            ++v18;
          }
          while (v18 != v17);
        }
      }
      else if (v17 >= 1)
      {
        int v116 = 0;
        unint64_t v117 = (v15 | ((unint64_t)v15 << 24)) & 0xFF00FF00FF00FFLL;
        do
        {
          if (v16 >= 1)
          {
            uint64_t v118 = 0;
            do
            {
              unint64_t v119 = *(unsigned __int16 *)(v12 + 2 * v118);
              if (*(_WORD *)(v12 + 2 * v118))
              {
                uint64_t v120 = *(unsigned int *)(v11 + 4 * v118);
                unint64_t v121 = v117 * (~v120 >> 24) + 0x80008000800080;
                unint64_t v122 = ((((v121 >> 8) & 0xFF00FF00FF00FFLL) + v121) >> 8) & 0xFF00FF00FF00FFLL;
                uint64_t v123 = v120 + ((v122 >> 24) | v122);
                unint64_t v124 = ((v123 | (v123 << 24)) & 0xFF00FF00FF00FFLL) * (~v10 >> 24) + 0x80008000800080;
                unint64_t v125 = ((((v124 >> 8) & 0xFF00FF00FF00FFLL) + v124) >> 8) & 0xFF00FF00FF00FFLL;
                LODWORD(v125) = v10 + ((v125 >> 24) | v125);
                unsigned int v126 = BYTE2(v125);
                unsigned int v127 = BYTE1(v125);
                unsigned int v128 = v125;
                unsigned int v129 = BYTE3(v125);
                if (v129 - 1 <= 0xFD)
                {
                  unsigned int v126 = (v126 * v130) >> 8;
                  unsigned int v127 = (v127 * v130) >> 8;
                  unsigned int v128 = (v128 * v130) >> 8;
                }
                int32x2_t v131 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v123), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                unsigned int v132 = v123;
                unsigned int v133 = BYTE3(v123);
                unsigned int v134 = v132;
                int32x2_t v135 = v131;
                if (v133 - 1 <= 0xFD)
                {
                  int32x2_t v135 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v131, vdup_n_s32(v136)), 8uLL);
                  unsigned int v134 = (v132 * v136) >> 8;
                }
                int8x8_t v137 = (int8x8_t)vmul_s32(v135, v135);
                unsigned int v141 = (int)(((v139 * v139) >> 8) * v129 + (256 - ((v139 * v139) >> 8)) * v133) >> 8;
                                                             * v140
                                                             + (256 - v140)
                                                             * ((v134 * v134 + 128 + ((v134 * v134 + 128) >> 8)) >> 8)) >> 8];
                                                                          + 128
                                                                          + ((v127 * v127 + 128) >> 8)) >> 8)
                                                                        * v139
                                                                        + (256 - v139)
                                                                        * ((v137.i32[1]
                                                                          + 128
                                                                          + ((v137.i32[1] + 128) >> 8)) >> 8)) >> 8];
                unsigned int v144 = (v141 * v142 + 128 + ((v141 * v142 + 128) >> 8)) >> 8;
                if (v138 <= v139) {
                  unsigned int v145 = v139;
                }
                else {
                  unsigned int v145 = v138;
                }
                if (v145 > v140) {
                  unsigned int v140 = v145;
                }
                unsigned int v146 = 256 - v140;
                                                                   * v138
                                                                   + (256 - v138)
                                                                   * ((v137.i32[0]
                                                                     + 128
                                                                     + ((v137.i32[0] + 128) >> 8)) >> 8)) >> 8];
                v137.i8[4] = *v143;
                uint32x2_t v147 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v141), (int32x2_t)vand_s8(v137, (int8x8_t)0xFF000000FFLL));
                uint32x2_t v148 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v147, v147, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v146), v131), 8uLL)), 0), (uint32x2_t)0x800000010);
                unsigned __int32 v149 = (v144 - ((int)(v146 * v132) >> 8)) & ~((int)(v144 - ((int)(v146 * v132) >> 8)) >> 31) | (((v141 - ((int)(v146 * v133) >> 8)) & ~((int)(v141 - ((int)(v146 * v133) >> 8)) >> 31)) << 24) | v148.i32[0] | v148.i32[1];
                unint64_t v150 = ((v120 | (v120 << 24)) & 0xFF00FF00FF00FFLL) * (~v149 >> 24) + 0x80008000800080;
                unint64_t v151 = ((((v150 >> 8) & 0xFF00FF00FF00FFLL) + v150) >> 8) & 0xFF00FF00FF00FFLL;
                *(_DWORD *)(v11 + 4 * v118) = v149 + ((v151 >> 24) | v151);
              }
              ++v118;
            }
            while (v16 != v118);
          }
          v11 += v154;
          v12 += v153;
          ++v116;
        }
        while (v116 != v152);
      }
      return;
    }
    int v70 = *(_DWORD *)(a2 + 4);
    int v71 = *(_DWORD *)(a2 + 8);
    uint64_t mask_table = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v73 = mask_table;
    uint64_t v74 = HIBYTE(v10);
    unsigned int v75 = BYTE2(v10);
    unsigned int v76 = v10;
    unsigned int v77 = BYTE1(v10);
    if (v74)
    {
      int v78 = *(unsigned __int16 *)(mask_table + 2 * v74 + 512);
      unsigned int v75 = (BYTE2(v10) * v78 + 128) >> 8;
      unsigned int v77 = (BYTE1(v10) * v78 + 128) >> 8;
      unsigned int v76 = (v10 * v78 + 128) >> 8;
    }
    int v79 = *(unsigned __int16 *)(mask_table + 2 * v74);
    uint64_t v59 = gamma_table_create(v14);
    if (v71 >= 1)
    {
      int v80 = 0;
      int v81 = *(unsigned __int16 *)&v59[2 * v75 + 16];
      int v82 = *(unsigned __int16 *)&v59[2 * v77 + 16];
      int v83 = *(unsigned __int16 *)&v59[2 * v76 + 16];
      do
      {
        if (v70 >= 1)
        {
          uint64_t v84 = 0;
          do
          {
            unsigned int v85 = *(unsigned __int16 *)(v12 + 2 * v84);
            if (*(_WORD *)(v12 + 2 * v84))
            {
              unint64_t v86 = *(unsigned int *)(v11 + 4 * v84);
              unint64_t v87 = v86 >> 24;
              int v88 = BYTE2(v86);
              unsigned int v89 = BYTE1(v86);
              int v90 = *(_DWORD *)(v11 + 4 * v84);
              if (HIBYTE(*(_DWORD *)(v11 + 4 * v84)))
              {
                int v94 = *(unsigned __int16 *)(v73 + 2 * v87 + 512);
                unsigned int v91 = (BYTE2(v86) * v94 + 128) >> 8;
                unsigned int v92 = (v89 * v94 + 128) >> 8;
                unsigned int v93 = (v90 * v94 + 128) >> 8;
              }
              else
              {
                unsigned int v91 = BYTE2(v86);
                unsigned int v92 = v89;
                unsigned int v93 = *(_DWORD *)(v11 + 4 * v84);
              }
              unsigned int v95 = (v85 >> 2) & 0xF8;
              uint64_t v96 = *(unsigned __int16 *)(v73 + 2 * (((v95 + 16) * v95) >> 8));
              int v97 = *(unsigned __int16 *)(v73 + 2 * ((v85 >> 7) & 0xF8 | (((v85 >> 7) & 0xF8) >> 5)));
              int v98 = *(unsigned __int16 *)(v73 + 2 * (v95 | (v95 >> 5)));
              int v99 = *(unsigned __int16 *)(v73 + 2 * ((8 * (v85 & 0x1F)) | ((8 * (v85 & 0x1F)) >> 5)));
              uint64_t v100 = *(unsigned __int16 *)(v73 + 2 * v87);
              if (v91 >= 0x400) {
                unsigned int v101 = 1024;
              }
              else {
                unsigned int v101 = v91;
              }
              if (v92 >= 0x400) {
                unsigned int v102 = 1024;
              }
              else {
                unsigned int v102 = v92;
              }
              if (v93 >= 0x400) {
                unsigned int v103 = 1024;
              }
              else {
                unsigned int v103 = v93;
              }
              int v104 = *(unsigned __int16 *)&v59[2 * v101 + 16];
              unsigned int v105 = *(unsigned __int16 *)&v59[2 * v102 + 16] * v100 + 512;
              unsigned int v106 = *(unsigned __int16 *)&v59[2 * v103 + 16] * v100 + 512;
              uint64_t v107 = v96 - ((v100 * v96 + 512) >> 10) + v100;
              int v108 = ((int)((v81 - ((v104 * v100 + 512) >> 10)) * v97 + 512) >> 10)
                   + ((v104 * v100 + 512) >> 10);
              int v109 = ((int)((v82 - (v105 >> 10)) * v98 + 512) >> 10) + (v105 >> 10);
              int v110 = ((int)((v83 - (v106 >> 10)) * v99 + 512) >> 10) + (v106 >> 10);
              if ((int)v107 >= 1)
              {
                int v111 = *(unsigned __int16 *)(v73 + 2 * v107 + 1024);
                int v108 = (v108 * v111 + 512) >> 10;
                int v109 = (v109 * v111 + 512) >> 10;
                int v110 = (v110 * v111 + 512) >> 10;
              }
              if (v108 >= 1024) {
                int v108 = 1024;
              }
              if (v109 >= 1024) {
                int v109 = 1024;
              }
              if (v110 >= 1024) {
                int v110 = 1024;
              }
              signed int v112 = v87 + (((*(unsigned __int8 *)(v73 + 3074 + v107) - (int)v87) * v79 + 512) >> 10);
              int v113 = v88
                   + (((*(unsigned __int8 *)(v73
                                           + 3074
                                           + ((int)(v107 * *(unsigned __int16 *)&v59[2 * v108 + 2066] + 512) >> 10))
                      - v88)
                     * v79
                     + 512) >> 10);
              signed int v114 = v89
                   + ((int)((*(unsigned __int8 *)(v73
                                                + 3074
                                                + ((int)(v107 * *(unsigned __int16 *)&v59[2 * v109 + 2066] + 512) >> 10))
                           - v89)
                          * v79
                          + 512) >> 10);
              int v115 = v90
                   + (((*(unsigned __int8 *)(v73
                                           + 3074
                                           + ((int)(v107 * *(unsigned __int16 *)&v59[2 * v110 + 2066] + 512) >> 10))
                      - v90)
                     * v79
                     + 512) >> 10);
              if (v112 < v113) {
                int v113 = v112;
              }
              if (v112 < v114) {
                signed int v114 = v112;
              }
              if (v112 < v115) {
                int v115 = v112;
              }
              *(_DWORD *)(v11 + 4 * v84) = (v113 << 16) | (v112 << 24) | (v114 << 8) | v115;
            }
            ++v84;
          }
          while (v70 != v84);
        }
        v12 += v153;
        v11 += v154;
        ++v80;
      }
      while (v80 != v71);
      goto LABEL_70;
    }
  }
  else
  {
    int v48 = *(_DWORD *)(a2 + 4);
    int v49 = *(_DWORD *)(a2 + 8);
    long double v50 = *(double *)(a2 + 144);
    uint64_t v51 = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v52 = v51;
    uint64_t v53 = HIBYTE(v10);
    unsigned int v54 = BYTE2(v10);
    unsigned int v55 = v10;
    unsigned int v56 = BYTE1(v10);
    if (v53)
    {
      int v57 = *(unsigned __int16 *)(v51 + 2 * v53 + 512);
      unsigned int v54 = (BYTE2(v10) * v57 + 128) >> 8;
      unsigned int v56 = (BYTE1(v10) * v57 + 128) >> 8;
      unsigned int v55 = (v10 * v57 + 128) >> 8;
    }
    int v58 = *(unsigned __int16 *)(v51 + 2 * v53);
    uint64_t v59 = gamma_table_create(v50);
    if (v49 >= 1)
    {
      int v60 = 0;
      int v61 = *(unsigned __int16 *)&v59[2 * v54 + 16];
      int v62 = *(unsigned __int16 *)&v59[2 * v56 + 16];
      int v63 = *(unsigned __int16 *)&v59[2 * v55 + 16];
      do
      {
        if (v48 >= 1)
        {
          uint64_t v64 = 0;
          do
          {
            if (*(_WORD *)(v12 + 2 * v64))
            {
              int v66 = *(_DWORD *)(v11 + 4 * v64);
              int v67 = *(unsigned __int16 *)&v59[2 * *(unsigned __int16 *)(v52 + 2 * BYTE2(v66)) + 16];
              int v68 = *(unsigned __int16 *)&v59[2 * *(unsigned __int16 *)(v52 + 2 * BYTE1(v66)) + 16];
              int v69 = *(unsigned __int16 *)&v59[2 * *(unsigned __int16 *)(v52 + 2 * v66) + 16];
              unsigned int v65 = *(unsigned __int16 *)(v12 + 2 * v64);
              *(_DWORD *)(v11 + 4 * v64) = ((BYTE2(v66)
                                           + (((*(unsigned __int8 *)(v52
                                                                   + 3074
                                                                   + *(unsigned __int16 *)&v59[2 * v67
                                                                                             + 2066
                                                                                             + 2
                                                                                             * (((v61 - v67)
                                                                                               * *(unsigned __int16 *)(v52 + 2 * ((v65 >> 7) & 0xF8 | (((v65 >> 7) & 0xF8) >> 5)))
                                                                                               + 512) >> 10)])
                                              - BYTE2(v66))
                                             * v58
                                             + 512) >> 10)) << 16) | ((BYTE1(v66)
                                                                     + (((*(unsigned __int8 *)(v52
                                                                                             + 3074
                                                                                             + *(unsigned __int16 *)&v59[2 * v68 + 2066 + 2 * (((v62 - v68) * *(unsigned __int16 *)(v52 + 2 * ((v65 >> 2) & 0xF8 | (((v65 >> 2) & 0xF8) >> 5))) + 512) >> 10)])
                                                                        - BYTE1(v66))
                                                                       * v58
                                                                       + 512) >> 10)) << 8) | (v66
                                                                                             + (((*(unsigned __int8 *)(v52 + 3074 + *(unsigned __int16 *)&v59[2 * v69 + 2066 + 2 * (((v63 - v69) * *(unsigned __int16 *)(v52 + 2 * ((8 * (v65 & 0x1F)) | ((8 * (v65 & 0x1F)) >> 5))) + 512) >> 10)])
                                                                                                - v66)
                                                                                               * v58
                                                                                               + 512) >> 10)) | 0xFF000000;
            }
            ++v64;
          }
          while (v48 != v64);
        }
        v12 += v153;
        v11 += v154;
        ++v60;
      }
      while (v60 != v49);
LABEL_70:
      if (!v59) {
        return;
      }
    }
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)v59, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    free(v59);
  }
}

void argb32_mark_pixeldeep(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v129 = *(int *)(a2 + 28);
  uint64_t v125 = *(void *)(a2 + 40);
  uint64_t v8 = v125 + (int)v129 * (uint64_t)*(int *)(a2 + 16) + 4 * *(int *)(a2 + 12);
  uint64_t v128 = *(int *)(a2 + 124);
  uint64_t v9 = *(void *)(a2 + 136) + (int)v128 * (uint64_t)*(int *)(a2 + 108) + 2 * *(int *)(a2 + 104);
  uint64_t v10 = *(int *)(a2 + 64);
  uint64_t v11 = *(int *)(a2 + 56);
  if (*(unsigned __int8 *)(a2 + 1) << 8 == 512)
  {
    v11 %= v10;
    uint64_t v12 = *(int *)(a2 + 60) % (uint64_t)*(int *)(a2 + 68);
  }
  else
  {
    uint64_t v12 = *(int *)(a2 + 60);
  }
  uint64_t v13 = *(void *)(a2 + 152);
  double v14 = *(double *)(a2 + 144);
  uint64_t v127 = *(int *)(a2 + 68);
  uint64_t v118 = v11;
  uint64_t v130 = v12;
  if (v13 && v14 == 2.0 && (double v14 = 2.0, *(void *)(a2 + 48)))
  {
    int v123 = *(_DWORD *)(a2 + 8);
    if (v123 >= 1)
    {
      int v119 = *(_DWORD *)(a2 + 76);
      uint64_t v121 = *(void *)(a2 + 88);
      int v15 = *(_DWORD *)(a2 + 4);
      unsigned int v16 = PIXELCONSTANT_14645(*(float **)(a1 + 64), *(_DWORD *)v13, *(float **)(v13 + 8), *(float *)(v13 + 16));
      int v17 = 0;
      unint64_t v18 = (v16 | ((unint64_t)v16 << 24)) & 0xFF00FF00FF00FFLL;
      do
      {
        int v126 = v17;
        if (v15 >= 1)
        {
          uint64_t v19 = 0;
          int v20 = v118;
          do
          {
            unint64_t v21 = *(unsigned __int16 *)(v9 + 2 * v19);
            if (*(_WORD *)(v9 + 2 * v19))
            {
              int v22 = *(_DWORD *)(v121 + v119 * (uint64_t)(int)v130 + 4 * v20);
              uint64_t v23 = *(unsigned int *)(v8 + 4 * v19);
              unint64_t v24 = v18 * (~v23 >> 24) + 0x80008000800080;
              unint64_t v25 = ((((v24 >> 8) & 0xFF00FF00FF00FFLL) + v24) >> 8) & 0xFF00FF00FF00FFLL;
              uint64_t v26 = v23 + ((v25 >> 24) | v25);
              unint64_t v27 = ((v26 | (v26 << 24)) & 0xFF00FF00FF00FFLL) * (~v22 >> 24) + 0x80008000800080;
              unint64_t v28 = ((((v27 >> 8) & 0xFF00FF00FF00FFLL) + v27) >> 8) & 0xFF00FF00FF00FFLL;
              unsigned int v29 = v22 + ((v28 >> 24) | v28);
              unsigned int v30 = BYTE2(v29);
              unsigned int v31 = BYTE1(v29);
              unsigned int v32 = v29;
              unsigned int v33 = HIBYTE(v29);
              if (v33 - 1 <= 0xFD)
              {
                unsigned int v30 = (v30 * v34) >> 8;
                unsigned int v31 = (v31 * v34) >> 8;
                unsigned int v32 = (v32 * v34) >> 8;
              }
              int32x2_t v35 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v26), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
              unsigned int v36 = v26;
              unsigned int v37 = BYTE3(v26);
              unsigned int v38 = v36;
              int32x2_t v39 = v35;
              if (v37 - 1 <= 0xFD)
              {
                int32x2_t v39 = (int32x2_t)vshr_n_u32((uint32x2_t)vmul_s32(v35, vdup_n_s32(v40)), 8uLL);
                unsigned int v38 = (v36 * v40) >> 8;
              }
              int8x8_t v41 = (int8x8_t)vmul_s32(v39, v39);
              unsigned int v45 = (int)(((v43 * v43) >> 8) * v33 + (256 - ((v43 * v43) >> 8)) * v37) >> 8;
                                                          + (256 - v44)
                                                          * ((v38 * v38 + 128 + ((v38 * v38 + 128) >> 8)) >> 8)) >> 8];
                                                           + (256 - v43)
                                                           * ((v41.i32[1] + 128 + ((v41.i32[1] + 128) >> 8)) >> 8)) >> 8];
              unsigned int v48 = (v45 * v46 + 128 + ((v45 * v46 + 128) >> 8)) >> 8;
              if (v42 <= v43) {
                unsigned int v49 = v43;
              }
              else {
                unsigned int v49 = v42;
              }
              if (v49 > v44) {
                unsigned int v44 = v49;
              }
              unsigned int v50 = 256 - v44;
                                                                * v42
                                                                + (256 - v42)
                                                                * ((v41.i32[0]
                                                                  + 128
                                                                  + ((v41.i32[0] + 128) >> 8)) >> 8)) >> 8];
              v41.i8[4] = *v47;
              uint32x2_t v51 = (uint32x2_t)vmla_s32((int32x2_t)0x8000000080, vdup_n_s32(v45), (int32x2_t)vand_s8(v41, (int8x8_t)0xFF000000FFLL));
              uint32x2_t v52 = vshl_u32((uint32x2_t)vmax_s32(vsub_s32((int32x2_t)vshr_n_u32(vsra_n_u32(v51, v51, 8uLL), 8uLL), vshr_n_s32(vmul_s32(vdup_n_s32(v50), v35), 8uLL)), 0), (uint32x2_t)0x800000010);
              unsigned __int32 v53 = (v48 - ((int)(v50 * v36) >> 8)) & ~((int)(v48 - ((int)(v50 * v36) >> 8)) >> 31) | (((v45 - ((int)(v50 * v37) >> 8)) & ~((int)(v45 - ((int)(v50 * v37) >> 8)) >> 31)) << 24) | v52.i32[0] | v52.i32[1];
              unint64_t v54 = ((v23 | (v23 << 24)) & 0xFF00FF00FF00FFLL) * (~v53 >> 24) + 0x80008000800080;
              unint64_t v55 = ((((v54 >> 8) & 0xFF00FF00FF00FFLL) + v54) >> 8) & 0xFF00FF00FF00FFLL;
              *(_DWORD *)(v8 + 4 * v19) = v53 + ((v55 >> 24) | v55);
            }
            if (v20 + 1 < (int)v10) {
              ++v20;
            }
            else {
              int v20 = 0;
            }
            ++v19;
          }
          while (v15 != v19);
        }
        v8 += v129;
        v9 += v128;
        if ((int)v130 + 1 < (int)v127) {
          int v56 = v130 + 1;
        }
        else {
          int v56 = 0;
        }
        LODWORD(v130) = v56;
        int v17 = v126 + 1;
      }
      while (v126 + 1 != v123);
    }
  }
  else
  {
    uint64_t v122 = *(int *)(a2 + 76);
    uint64_t v124 = *(void *)(a2 + 88);
    uint64_t v58 = *(int *)(a2 + 4);
    uint64_t v57 = *(int *)(a2 + 8);
    uint64_t mask_table = get_mask_table(a1, a2, a3, a4, a5, a6, a7, a8);
    int v60 = gamma_table_create(v14);
    uint64_t v120 = v57;
    uint64_t v61 = v130;
    if ((int)v57 >= 1)
    {
      uint64_t v62 = 0;
      do
      {
        uint64_t v131 = v61;
        uint64_t v63 = v124 + v61 * v122;
        if (v125)
        {
          if ((int)v58 >= 1)
          {
            uint64_t v64 = 0;
            uint64_t v65 = v118;
            do
            {
              unsigned int v66 = *(unsigned __int16 *)(v9 + 2 * v64);
              if (*(_WORD *)(v9 + 2 * v64))
              {
                unint64_t v67 = *(unsigned int *)(v63 + 4 * v65);
                if (v65 + 1 < v10) {
                  ++v65;
                }
                else {
                  uint64_t v65 = 0;
                }
                unint64_t v68 = v67 >> 24;
                unint64_t v69 = BYTE2(v67);
                unint64_t v70 = BYTE1(v67);
                unint64_t v71 = v67;
                if (BYTE3(v67))
                {
                  unint64_t v69 = (BYTE2(v67) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                  unint64_t v70 = (BYTE1(v67) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                  unint64_t v71 = (v67 * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v68 + 512) + 128) >> 8;
                }
                unint64_t v72 = *(unsigned int *)(v8 + 4 * v64);
                unint64_t v73 = v72 >> 24;
                int v74 = BYTE2(v72);
                unsigned int v75 = BYTE1(v72);
                int v76 = *(_DWORD *)(v8 + 4 * v64);
                if (HIBYTE(*(_DWORD *)(v8 + 4 * v64)))
                {
                  int v80 = *(unsigned __int16 *)(mask_table + 2 * v73 + 512);
                  unsigned int v77 = (BYTE2(v72) * v80 + 128) >> 8;
                  unsigned int v78 = (v75 * v80 + 128) >> 8;
                  unsigned int v79 = (v76 * v80 + 128) >> 8;
                }
                else
                {
                  unsigned int v77 = BYTE2(v72);
                  unsigned int v78 = v75;
                  unsigned int v79 = *(_DWORD *)(v8 + 4 * v64);
                }
                unsigned int v81 = (v66 >> 2) & 0xF8;
                uint64_t v82 = *(unsigned __int16 *)(mask_table + 2 * (((v81 + 16) * v81) >> 8));
                int v83 = *(unsigned __int16 *)(mask_table + 2 * ((v66 >> 7) & 0xF8 | (((v66 >> 7) & 0xF8) >> 5)));
                int v84 = *(unsigned __int16 *)(mask_table + 2 * (v81 | (v81 >> 5)));
                int v85 = *(unsigned __int16 *)(mask_table + 2 * ((8 * (v66 & 0x1F)) | ((8 * (v66 & 0x1F)) >> 5)));
                unint64_t v86 = v60 + 16;
                int v87 = *(unsigned __int16 *)&v60[2 * v69 + 16];
                int v88 = *(unsigned __int16 *)&v60[2 * v70 + 16];
                int v89 = *(unsigned __int16 *)&v60[2 * v71 + 16];
                uint64_t v90 = *(unsigned __int16 *)(mask_table + 2 * v73);
                if (v77 >= 0x400) {
                  unsigned int v77 = 1024;
                }
                if (v78 >= 0x400) {
                  unsigned int v78 = 1024;
                }
                if (v79 >= 0x400) {
                  unsigned int v79 = 1024;
                }
                unsigned int v91 = *(unsigned __int16 *)&v86[2 * v77] * v90 + 512;
                unsigned int v92 = *(unsigned __int16 *)&v86[2 * v78] * v90 + 512;
                unsigned int v93 = *(unsigned __int16 *)&v86[2 * v79] * v90 + 512;
                uint64_t v94 = v82 - ((v90 * v82 + 512) >> 10) + v90;
                int v95 = ((int)((v87 - (v91 >> 10)) * v83 + 512) >> 10) + (v91 >> 10);
                int v96 = ((int)((v88 - (v92 >> 10)) * v84 + 512) >> 10) + (v92 >> 10);
                int v97 = ((int)((v89 - (v93 >> 10)) * v85 + 512) >> 10) + (v93 >> 10);
                if ((int)v94 >= 1)
                {
                  int v98 = *(unsigned __int16 *)(mask_table + 2 * v94 + 1024);
                  int v95 = (v95 * v98 + 512) >> 10;
                  int v96 = (v96 * v98 + 512) >> 10;
                  int v97 = (v97 * v98 + 512) >> 10;
                }
                int v99 = *(unsigned __int16 *)(mask_table + 2 * v68);
                if (v95 >= 1024) {
                  int v95 = 1024;
                }
                if (v96 >= 1024) {
                  int v96 = 1024;
                }
                if (v97 >= 1024) {
                  int v97 = 1024;
                }
                signed int v100 = v73 + (((*(unsigned __int8 *)(mask_table + 3074 + v94) - (int)v73) * v99 + 512) >> 10);
                int v101 = v74
                     + (((*(unsigned __int8 *)(mask_table
                                             + 3074
                                             + ((int)(v94 * *(unsigned __int16 *)&v60[2 * v95 + 2066] + 512) >> 10))
                        - v74)
                       * v99
                       + 512) >> 10);
                signed int v102 = v75
                     + ((int)((*(unsigned __int8 *)(mask_table
                                                  + 3074
                                                  + ((int)(v94 * *(unsigned __int16 *)&v60[2 * v96 + 2066] + 512) >> 10))
                             - v75)
                            * v99
                            + 512) >> 10);
                int v103 = v76
                     + (((*(unsigned __int8 *)(mask_table
                                             + 3074
                                             + ((int)(v94 * *(unsigned __int16 *)&v60[2 * v97 + 2066] + 512) >> 10))
                        - v76)
                       * v99
                       + 512) >> 10);
                if (v100 >= v101) {
                  int v104 = v101;
                }
                else {
                  int v104 = v100;
                }
                if (v100 < v102) {
                  signed int v102 = v100;
                }
                if (v100 < v103) {
                  int v103 = v100;
                }
                *(_DWORD *)(v8 + 4 * v64) = (v104 << 16) | (v100 << 24) | (v102 << 8) | v103;
              }
              else if (v65 + 1 < v10)
              {
                ++v65;
              }
              else
              {
                uint64_t v65 = 0;
              }
              ++v64;
            }
            while (v58 != v64);
          }
        }
        else if ((int)v58 >= 1)
        {
          uint64_t v105 = 0;
          uint64_t v106 = v118;
          do
          {
            if (*(_WORD *)(v9 + 2 * v105))
            {
              unint64_t v108 = *(unsigned int *)(v63 + 4 * v106);
              if (v106 + 1 < v10) {
                ++v106;
              }
              else {
                uint64_t v106 = 0;
              }
              unint64_t v109 = v108 >> 24;
              unint64_t v110 = BYTE2(v108);
              unint64_t v111 = BYTE1(v108);
              unint64_t v112 = v108;
              if (BYTE3(v108))
              {
                unint64_t v110 = (BYTE2(v108) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512) + 128) >> 8;
                unint64_t v111 = (BYTE1(v108) * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512) + 128) >> 8;
                unint64_t v112 = (v108 * (unint64_t)*(unsigned __int16 *)(mask_table + 2 * v109 + 512)
                      + 128) >> 8;
              }
              int v113 = *(unsigned __int16 *)(mask_table + 2 * v109);
              int v114 = *(_DWORD *)(v8 + 4 * v105);
              int v115 = *(unsigned __int16 *)&v60[2 * *(unsigned __int16 *)(mask_table + 2 * BYTE2(v114)) + 16];
              int v116 = *(unsigned __int16 *)&v60[2 * *(unsigned __int16 *)(mask_table + 2 * BYTE1(v114)) + 16];
              int v117 = *(unsigned __int16 *)&v60[2 * *(unsigned __int16 *)(mask_table + 2 * v114) + 16];
              unsigned int v107 = *(unsigned __int16 *)(v9 + 2 * v105);
              *(_DWORD *)(v8 + 4 * v105) = ((BYTE2(v114)
                                           + (((*(unsigned __int8 *)(mask_table
                                                                   + 3074
                                                                   + *(unsigned __int16 *)&v60[2 * v115
                                                                                             + 2066
                                                                                             + 2
                                                                                             * (((*(unsigned __int16 *)&v60[2 * v110 + 16]
                                                                                                - v115)
                                                                                               * *(unsigned __int16 *)(mask_table + 2 * ((v107 >> 7) & 0xF8 | (((v107 >> 7) & 0xF8) >> 5)))
                                                                                               + 512) >> 10)])
                                              - BYTE2(v114))
                                             * v113
                                             + 512) >> 10)) << 16) | ((BYTE1(v114)
                                                                     + (((*(unsigned __int8 *)(mask_table
                                                                                             + 3074
                                                                                             + *(unsigned __int16 *)&v60[2 * v116 + 2066 + 2 * (((*(unsigned __int16 *)&v60[2 * v111 + 16] - v116) * *(unsigned __int16 *)(mask_table + 2 * ((v107 >> 2) & 0xF8 | (((v107 >> 2) & 0xF8) >> 5))) + 512) >> 10)])
                                                                        - BYTE1(v114))
                                                                       * v113
                                                                       + 512) >> 10)) << 8) | (v114
                                                                                             + (((*(unsigned __int8 *)(mask_table + 3074 + *(unsigned __int16 *)&v60[2 * v117 + 2066 + 2 * (((*(unsigned __int16 *)&v60[2 * v112 + 16] - v117) * *(unsigned __int16 *)(mask_table + 2 * ((8 * (v107 & 0x1F)) | ((8 * (v107 & 0x1F)) >> 5))) + 512) >> 10)])
                                                                                                - v114)
                                                                                               * v113
                                                                                               + 512) >> 10)) | 0xFF000000;
            }
            else if (v106 + 1 < v10)
            {
              ++v106;
            }
            else
            {
              uint64_t v106 = 0;
            }
            ++v105;
          }
          while (v58 != v105);
        }
        v9 += v128;
        if (v131 + 1 < v127) {
          uint64_t v61 = v131 + 1;
        }
        else {
          uint64_t v61 = 0;
        }
        v8 += v129;
        ++v62;
      }
      while (v62 != v120);
    }
    if (v60 && atomic_fetch_add_explicit((atomic_uint *volatile)v60, 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      free(v60);
    }
  }
}

void argb32_mark_bits(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  int v4 = v3;
  uint64_t v5 = v2;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(v2 + 112);
  int v7 = *(_DWORD *)(v2 + 116);
  unsigned int v8 = (v6 + 15) & 0xFFFFFFF0;
  size_t v9 = v8 * v7;
  if ((int)v9 <= 4096)
  {
    uint64_t v10 = v20;
  }
  else
  {
    uint64_t v10 = malloc_type_malloc(v9, 0x8303D2FuLL);
    if (!v10) {
      return;
    }
  }
  CGSConvertBitsToMask(*(uint16x4_t **)(v5 + 136), *(_DWORD *)(v5 + 124), v10, v8, v6, v7, *(_DWORD *)(v5 + 128));
  long long v11 = *(_OWORD *)(v5 + 112);
  v16[6] = *(_OWORD *)(v5 + 96);
  long long v17 = v11;
  long long v12 = *(_OWORD *)(v5 + 144);
  long long v18 = *(_OWORD *)(v5 + 128);
  long long v19 = v12;
  long long v13 = *(_OWORD *)(v5 + 48);
  v16[2] = *(_OWORD *)(v5 + 32);
  v16[3] = v13;
  long long v14 = *(_OWORD *)(v5 + 80);
  v16[4] = *(_OWORD *)(v5 + 64);
  v16[5] = v14;
  long long v15 = *(_OWORD *)(v5 + 16);
  v16[0] = *(_OWORD *)v5;
  v16[1] = v15;
  HIDWORD(v17) = (v6 + 15) & 0xFFFFFFF0;
  *((void *)&v18 + 1) = v10;
  if (BYTE1(v16[0]) << 8 == 1024) {
    argb32_mark_constmask((uint64_t)v16, v4);
  }
  else {
    argb32_mark_pixelmask((unint64_t)v16, v4);
  }
  if (v10 != v20) {
    free(v10);
  }
}

uint64_t PIXELCONSTANT_14645(float *a1, int a2, float *a3, float a4)
{
  float v4 = *a1;
  float v5 = a1[1];
  float v6 = v5;
  if (v5 >= a4)
  {
    float v6 = a4;
    if (v4 > a4) {
      float v6 = *a1;
    }
  }
  float v7 = a1[3];
  float v8 = v6 * a1[2];
  if (a3) {
    int v9 = a2;
  }
  else {
    int v9 = 0;
  }
  if (v9 == 1)
  {
    if (*a3 >= v4) {
      float v4 = *a3;
    }
    if (*a3 > v5) {
      float v4 = a1[1];
    }
    unsigned int v10 = (float)(v7 + (float)(v4 * v8));
    unsigned int v11 = v10;
    unsigned int v12 = v10;
  }
  else
  {
    if (v9 == 4)
    {
      float v19 = a3[4];
      float v20 = *a3;
      float v21 = a3[1];
      float v22 = a3[2];
      if (v19 < v4) {
        float v23 = *a1;
      }
      else {
        float v23 = a3[4];
      }
      if (v19 <= v5) {
        float v24 = v23;
      }
      else {
        float v24 = a1[1];
      }
      if (v20 < v4) {
        float v25 = *a1;
      }
      else {
        float v25 = *a3;
      }
      if (v20 <= v5) {
        float v26 = v25;
      }
      else {
        float v26 = a1[1];
      }
      if (v21 < v4) {
        float v27 = *a1;
      }
      else {
        float v27 = a3[1];
      }
      if (v21 <= v5) {
        float v28 = v27;
      }
      else {
        float v28 = a1[1];
      }
      if (v22 < v4) {
        float v29 = *a1;
      }
      else {
        float v29 = a3[2];
      }
      if (v22 <= v5) {
        float v30 = v29;
      }
      else {
        float v30 = a1[1];
      }
      float v31 = (float)(v5 - v26) - v24;
      float v32 = (float)(v5 - v28) - v24;
      float v33 = (float)(v5 - v30) - v24;
      float v34 = v7 + (float)(v31 * v8);
      if (v31 < v4) {
        float v34 = *a1;
      }
      float v35 = v7 + (float)(v32 * v8);
      if (v32 < v4) {
        float v35 = *a1;
      }
      if (v33 >= v4) {
        float v4 = v7 + (float)(v33 * v8);
      }
      unsigned int v10 = v34;
      unsigned int v11 = v35;
      goto LABEL_63;
    }
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    unsigned int v12 = 0;
    if (v9 == 3)
    {
      float v13 = a3[1];
      float v14 = a3[2];
      if (*a3 < v4) {
        float v15 = *a1;
      }
      else {
        float v15 = *a3;
      }
      if (*a3 <= v5) {
        float v16 = v15;
      }
      else {
        float v16 = a1[1];
      }
      if (v13 < v4) {
        float v17 = *a1;
      }
      else {
        float v17 = a3[1];
      }
      if (v13 <= v5) {
        float v18 = v17;
      }
      else {
        float v18 = a1[1];
      }
      if (v14 >= v4) {
        float v4 = a3[2];
      }
      if (v14 > v5) {
        float v4 = a1[1];
      }
      unsigned int v10 = (float)(v7 + (float)(v16 * v8));
      unsigned int v11 = (float)(v7 + (float)(v18 * v8));
      float v4 = v7 + (float)(v4 * v8);
LABEL_63:
      unsigned int v12 = v4;
    }
  }
  return (v10 << 16) | ((float)(v7 + v8) << 24) | (v11 << 8) | v12;
}