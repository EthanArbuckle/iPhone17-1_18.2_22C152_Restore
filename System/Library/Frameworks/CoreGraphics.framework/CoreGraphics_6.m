uint64_t (*__create_flexGTX_profile_stub_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateCopyWithFlexGTC");
  }
  if (result) {
    v1 = result;
  }
  else {
    v1 = colorsync_smart_null_6672;
  }
  create_flexGTX_profile_stub_f = (uint64_t (*)(void, void))v1;
  return result;
}

void __create_node_table_block_invoke()
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  create_node_table_node_table = (uint64_t)CFArrayCreateMutable(0, 2, MEMORY[0x1E4F1D510]);
  float v0 = 0.0;
  char v1 = 1;
  v2 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  v3 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  do
  {
    char v4 = v1;
    *(_OWORD *)keys = xmmword_1E52B41C8;
    float v5 = (float)(v0 * 0.3) + 0.4;
    v13 = @"com.apple.ColorSync.FlexGTCNodeSlope";
    values = 0;
    CFNumberRef v10 = 0;
    CFNumberRef v11 = 0;
    float valuePtr = v5;
    values = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    float valuePtr = v5 + 0.5;
    CFNumberRef v10 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    float valuePtr = v5 + 0.7;
    CFNumberRef v11 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFDictionaryRef v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 3, v2, v3);
    for (uint64_t i = 0; i != 24; i += 8)
      CFRelease(*(void **)((char *)&values + i));
    CFArrayAppendValue((CFMutableArrayRef)create_node_table_node_table, v6);
    CFRelease(v6);
    char v1 = 0;
    float v0 = 1.0;
  }
  while ((v4 & 1) != 0);
}

CFStringRef data_provider_copy_debug_description(uint64_t a1)
{
  if (!os_variant_has_internal_content()) {
    return 0;
  }

  return data_provider_copy_debug_string(a1, 0);
}

CFStringRef data_provider_copy_debug_string(uint64_t a1, __CFString *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v14 = 0;
  long long v4 = *(_OWORD *)(a1 + 56);
  v17[0] = *(_OWORD *)(a1 + 40);
  v17[1] = v4;
  long long v5 = *(_OWORD *)(a1 + 88);
  v17[2] = *(_OWORD *)(a1 + 72);
  v17[3] = v5;
  uint64_t v18 = *(void *)(a1 + 112);
  bzero(v16, 0x489uLL);
  for (uint64_t i = 0; i != 72; i += 8)
  {
    v7 = *(const void **)((char *)v17 + i);
    if (v7)
    {
      memset(&v13, 0, sizeof(v13));
      if (dladdr(v7, &v13)) {
        snprintf(__str, 0x80uLL, "%s %s:%s");
      }
      else {
        snprintf(__str, 0x80uLL, "%s %p");
      }
      __strcat_chk();
      __strcat_chk();
    }
  }
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  if (v8 > 3) {
    v9 = "?";
  }
  else {
    v9 = off_1E52B4290[v8];
  }
  asprintf(&v14, "CGDataProvider: %p type: %s size: %lld retain count: %d retained pointer: %p\n%s", (const void *)a1, v9, *(void *)(a1 + 32), *(_DWORD *)(a1 + 252), *(const void **)(a1 + 264), v16);
  CFNumberRef v11 = &stru_1ED0A02B0;
  if (a2) {
    CFNumberRef v11 = a2;
  }
  CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"%s\n%@", v14, v11);
  free(v14);
  return v10;
}

CFStringRef data_provider_copy_format_description(uint64_t a1)
{
  if (!os_variant_has_internal_content()) {
    return 0;
  }

  return data_provider_copy_debug_string(a1, 0);
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  if (!callbacks || !callbacks->getBytes || callbacks->version) {
    return 0;
  }
  uint64_t provider = create_provider((uint64_t)info, 1, v2, v3, v4, v5, v6, v7);
  v9 = (CGDataProvider *)provider;
  if (provider)
  {
    *(_OWORD *)(provider + 40) = *(_OWORD *)&callbacks->getBytes;
    *(_OWORD *)(provider + 64) = *(_OWORD *)&callbacks->rewind;
    if (!CGDataProviderIsRewindable(provider))
    {
      CFDataRef v12 = CGDataProviderCopyData(v9);
      Dl_info v13 = CGDataProviderCreateWithCFData(v12);
      if (v12) {
        CFRelease(v12);
      }
      CFRelease(v9);
      return v13;
    }
  }
  return v9;
}

BOOL CGDataProviderIsRewindable(uint64_t a1)
{
  CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  return v2 == CGDataProviderGetTypeID_id && (*(_DWORD *)(a1 + 20) & 0xFFFFFFFD) == 1 && *(void *)(a1 + 64) != 0;
}

uint64_t CGDataProviderCreateSequentialWithInternalCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  if (*(_DWORD *)a2 != 1 || !*(void *)(a2 + 24) || !*(void *)(a2 + 16)) {
    return 0;
  }
  uint64_t result = create_provider(a1, 1, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 8);
    *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 24);
    *(void *)(result + 120) = *(void *)(a2 + 40);
    *(_OWORD *)(result + 144) = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(result + 160) = *(_OWORD *)(a2 + 64);
    *(void *)(result + 176) = *(void *)(a2 + 80);
  }
  return result;
}

uint64_t CGDataProviderCreateMultiRangeDirectAccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0)
  {
    CGPostError((uint64_t)"%s: Invalid size = %lld", a2, a3, a4, a5, a6, a7, a8, (char)"CGDataProviderCreateMultiRangeDirectAccess");
    if (!a3) {
      return 0;
    }
  }
  else if (!a3)
  {
    return 0;
  }
  uint64_t result = 0;
  if (a2 >= 1 && !*(_DWORD *)a3)
  {
    if (!*(void *)(a3 + 8) && !*(void *)(a3 + 16)) {
      return 0;
    }
    uint64_t result = create_provider(a1, 0, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      *(void *)(result + 32) = a2;
      *(_OWORD *)(result + 96) = *(_OWORD *)(a3 + 8);
      *(void *)(result + 72) = *(void *)(a3 + 24);
    }
  }
  return result;
}

uint64_t CGDataProviderGetType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, vars0);
  }
  return *(unsigned int *)(a1 + 20);
}

uint64_t CGDataProviderSequentialGetBytesInternal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 < 1 || *(unsigned char *)(a1 + 261)) {
    return 0;
  }
  unint64_t v6 = a3;
  uint64_t v4 = 0;
  while (1)
  {
    unint64_t v8 = (*(uint64_t (**)(void, uint64_t, unint64_t))(a1 + 40))(*(void *)(a1 + 24), a2, v6);
    if (!v8) {
      break;
    }
    if (v8 >= v6) {
      unint64_t v9 = v6;
    }
    else {
      unint64_t v9 = v8;
    }
    v4 += v9;
    a2 += v9;
    v6 -= v9;
    if (!v6) {
      return v4;
    }
  }
  *(unsigned char *)(a1 + 261) = 1;
  return v4;
}

uint64_t CGDataProviderGetBytes(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  if (v13 != CGDataProviderGetTypeID_id)
  {
    CGPostError((uint64_t)"%s - bad argument", v6, v7, v8, v9, v10, v11, v12, (char)"CGDataProviderGetBytes");
    return 0;
  }
  if ((a1[5] & 0xFFFFFFFD) != 1) {
    _CGHandleAssert("CGDataProviderGetBytes", 557, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v10, v11, v12, v15);
  }

  return CGDataProviderSequentialGetBytesInternal((uint64_t)a1, a2, a3);
}

void CGDataProviderRewind(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v9 = CFGetTypeID((CFTypeRef)a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v9 == CGDataProviderGetTypeID_id)
    {
      if ((*(_DWORD *)(a1 + 20) & 0xFFFFFFFD) != 1) {
        _CGHandleAssert("CGDataProviderRewind", 583, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v6, v7, v8, v11);
      }
      uint64_t v10 = *(void (**)(void))(a1 + 64);
      if (v10) {
        v10(*(void *)(a1 + 24));
      }
      *(unsigned char *)(a1 + 261) = 0;
    }
    else
    {
      CGPostError((uint64_t)"%s - bad argument", v2, v3, v4, v5, v6, v7, v8, (char)"CGDataProviderRewind");
    }
  }
}

uint64_t CGDataProviderSkipForwardInternal(uint64_t a1, uint64_t a2)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  if (a2 < 1) {
    return 0;
  }
  unint64_t BytesInternal = a2;
  uint64_t v4 = *(uint64_t (**)(void, uint64_t))(a1 + 48);
  if (v4)
  {
    unint64_t BytesInternal = v4(*(void *)(a1 + 24), a2);
    if (!BytesInternal) {
      *(unsigned char *)(a1 + 261) = 1;
    }
  }
  else
  {
    uint64_t v5 = *(void (**)(void, uint64_t))(a1 + 56);
    if (v5)
    {
      v5(*(void *)(a1 + 24), a2);
    }
    else
    {
      MEMORY[0x1F4188790]();
      uint64_t v7 = (char *)v10 - v6;
      if (BytesInternal > 0x400)
      {
        uint64_t v8 = (char *)malloc_type_malloc(BytesInternal, 0x59FA0E00uLL);
        unint64_t BytesInternal = CGDataProviderSequentialGetBytesInternal(a1, (uint64_t)v8, BytesInternal);
        if (v8 != v7) {
          free(v8);
        }
      }
      else
      {
        return CGDataProviderSequentialGetBytesInternal(a1, (uint64_t)v10 - v6, BytesInternal);
      }
    }
  }
  return BytesInternal;
}

void CGDataProviderSkipForward(_DWORD *a1, uint64_t a2)
{
  if (a1)
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v7 == CGDataProviderGetTypeID_id)
    {
      if ((a1[5] & 0xFFFFFFFD) != 1) {
        _CGHandleAssert("CGDataProviderSkipForward", 631, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider)", "provider is not sequential", v4, v5, v6, v8);
      }
      CGDataProviderSkipForwardInternal((uint64_t)a1, a2);
    }
  }
}

void CGDataProviderGetBytesInRanges(void *a1, __CFArray *a2, uint64_t a3, uint64_t a4)
{
  if (a1)
  {
    CFTypeID v8 = CFGetTypeID(a1);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v8 == CGDataProviderGetTypeID_id)
    {
      CFTypeID v9 = (void (*)(uint64_t, __CFArray *, uint64_t, uint64_t))a1[13];
      if (v9)
      {
        uint64_t v10 = a1[3];
        v9(v10, a2, a3, a4);
      }
      else if (a4)
      {
        CFIndex v11 = 0;
        CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
        uint64_t v14 = (size_t *)(a3 + 8);
        do
        {
          char v15 = (char *)malloc_type_malloc(*v14, 0x47D328A9uLL);
          if (v15)
          {
            v16 = (const UInt8 *)v15;
            CGDataProviderGetBytesAtPosition((uint64_t)a1, v15, *(v14 - 1), *v14);
            CFDataRef v17 = CFDataCreateWithBytesNoCopy(v12, v16, *v14, v13);
            if (v17)
            {
              CFDataRef v18 = v17;
              CFArraySetValueAtIndex(a2, v11, v17);
              CFRelease(v18);
            }
          }
          ++v11;
          v14 += 2;
        }
        while (a4 != v11);
      }
    }
  }
}

const void *CGDataProviderGetProperty(uint64_t a1, const void *a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 272)) != 0) {
    return CGPropertiesGetProperty(v2, a2);
  }
  else {
    return 0;
  }
}

void CGDataProviderUngetBytePtr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((CGDataProviderUngetBytePtr_warned & 1) == 0)
  {
    CGDataProviderUngetBytePtr_warned = 1;
  }

  CGDataProviderReleaseBytePtr(a1);
}

uint64_t CGDataProviderGetBytePtr(uint64_t a1)
{
  if (CGDataProviderGetBytePtr_predicate != -1) {
    dispatch_once(&CGDataProviderGetBytePtr_predicate, &__block_literal_global_34_6867);
  }

  return CGDataProviderRetainBytePtr(a1);
}

void __CGDataProviderGetBytePtr_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void *__cdecl CGDataProviderGetInfo(void *provider)
{
  if (provider) {
    return (void *)*((void *)provider + 3);
  }
  return provider;
}

void pdf_object_scanner_release(uint64_t *a1)
{
  if (a1)
  {
    pdf_lexer_release(a1[2]);
    free(a1);
  }
}

uint64_t *pdf_object_scanner_set_source(uint64_t *result, const void *a2)
{
  if ((const void *)result[1] != a2)
  {
    uint64_t v3 = result;
    pdf_lexer_release(result[2]);
    uint64_t result = pdf_lexer_create(*v3, a2, 2 * *((unsigned __int8 *)v3 + 24));
    v3[1] = (uint64_t)a2;
    v3[2] = (uint64_t)result;
  }
  return result;
}

void handle_choke(uint64_t a1)
{
  if (!a1 || *(_DWORD *)(a1 + 8) != 6 || (uint64_t v1 = *(void *)(a1 + 32)) == 0)
  {
LABEL_10:
    return;
  }
  if (*(void *)(v1 + 24)) {
    decrypt_string(*(void *)(a1 + 32));
  }
  if (*(void *)(v1 + 72) < 0x33uLL)
  {
    if (*(void *)(v1 + 24)) {
      decrypt_string(v1);
    }
    goto LABEL_10;
  }
  if (*(void *)(v1 + 24)) {
    decrypt_string(v1);
  }
}

unsigned char *Type1Subset::emit_font_file(Type1Subset *this, uint64_t a2)
{
  CFDataRef embedded_font_data = (const __CFData *)Type1Subset::create_embedded_font_data(this);
  uint64_t v5 = **(void **)(*((void *)this + 1) + 8);
  uint64_t v6 = PDFStreamCreateWithObjectNumber(v5, a2);
  PDFDocumentBeginObject(*v6, v6[1], v7, v8, v9, v10, v11, v12);
  PDFDocumentPrintf(*v6, (uint64_t)"<<", v13, v14, v15, v16, v17, v18, v164);
  uint64_t v19 = PDFXRefTableAddObject(*(void **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length1 %R", v19, v20, v21, v22, v23, v24);
  uint64_t v25 = PDFXRefTableAddObject(*(void **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length2 %R", v25, v26, v27, v28, v29, v30);
  uint64_t v31 = PDFXRefTableAddObject(*(void **)(v5 + 464));
  PDFDocumentPrintReference(v5, (uint64_t)"/Length3 %R", v31, v32, v33, v34, v35, v36);
  PDFStreamBeginData((CGDataConsumerRef)v6);
  if (!embedded_font_data)
  {
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    goto LABEL_134;
  }
  CFIndex Length = CFDataGetLength(embedded_font_data);
  BytePtr = CFDataGetBytePtr(embedded_font_data);
  uint64_t v39 = v6[3];
  if (v39) {
    v40 = (uint64_t *)(v39 + 40);
  }
  else {
    v40 = v6 + 2;
  }
  uint64_t v41 = *v40;
  std::string::basic_string[abi:fe180100]<0>(&__p, "eexec");
  unint64_t v42 = (unint64_t)&BytePtr[Length];
  CFIndex v43 = v173;
  if ((v173 & 0x80u) == 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  if ((v173 & 0x80u) != 0) {
    CFIndex v43 = v172;
  }
  uint64_t v166 = v41;
  if (v43)
  {
    if (Length < v43) {
      goto LABEL_31;
    }
    uint64_t v45 = v42 - v43 + 1;
    if ((const UInt8 *)v45 == BytePtr) {
      goto LABEL_31;
    }
    int v48 = *p_p;
    v46 = p_p + 1;
    int v47 = v48;
    CFIndex v49 = v43 - 1;
    v50 = BytePtr;
    while (*v50 != v47)
    {
LABEL_18:
      if (++v50 == (const UInt8 *)v45) {
        goto LABEL_31;
      }
    }
    v51 = (unsigned __int8 *)(v50 + 1);
    CFIndex v52 = v49;
    v53 = v46;
    while (v52)
    {
      int v55 = *v51++;
      int v54 = v55;
      int v56 = *v53++;
      --v52;
      if (v54 != v56) {
        goto LABEL_18;
      }
    }
  }
  else
  {
    v50 = BytePtr;
  }
  if ((const UInt8 *)v42 == v50)
  {
LABEL_31:
    v60 = 0;
    char v64 = 1;
    goto LABEL_35;
  }
  v60 = v50 + 5;
  if ((unint64_t)(v50 + 5) >= v42)
  {
    char v64 = 0;
    goto LABEL_35;
  }
  uint64_t v167 = v31;
  uint64_t v61 = &BytePtr[Length] - v50 - 5;
  uint64_t v62 = MEMORY[0x1E4F14390];
  while (1)
  {
    uint64_t v63 = *v60;
    if (*(char *)v60 < 0) {
      break;
    }
    if ((*(_DWORD *)(v62 + 4 * v63 + 60) & 0x4000) == 0) {
      goto LABEL_33;
    }
LABEL_29:
    ++v60;
    if (!--v61)
    {
      char v64 = 0;
      v60 = &BytePtr[Length];
      goto LABEL_34;
    }
  }
  if (__maskrune_l(v63, 0x4000uLL, 0)) {
    goto LABEL_29;
  }
LABEL_33:
  char v64 = 0;
LABEL_34:
  uint64_t v31 = v167;
LABEL_35:
  if ((char)v173 < 0)
  {
    operator delete(__p);
    if (v64) {
      goto LABEL_88;
    }
  }
  else if (v64)
  {
    goto LABEL_88;
  }
  std::string::basic_string[abi:fe180100]<0>(&__p, "/Encoding StandardEncoding def");
  uint64_t v65 = v173;
  if ((v173 & 0x80u) == 0) {
    v66 = (char *)&__p;
  }
  else {
    v66 = (char *)__p;
  }
  if ((v173 & 0x80u) != 0) {
    uint64_t v65 = v172;
  }
  uint64_t v168 = v31;
  if (BytePtr == v60 || !v65) {
    goto LABEL_58;
  }
  v67 = BytePtr;
  v68 = (unsigned __int8 *)v60;
  do
  {
    if (*v67 == *v66)
    {
      uint64_t v69 = 1;
      while (v65 != v69)
      {
        if (&v67[v69] == v60) {
          goto LABEL_56;
        }
        int v70 = v67[v69];
        int v71 = v66[v69++];
        if (v70 != v71) {
          goto LABEL_48;
        }
      }
      v68 = (unsigned __int8 *)v67;
    }
LABEL_48:
    ++v67;
  }
  while (v67 != v60);
LABEL_56:
  if (v68 == v60)
  {
LABEL_58:
    std::string::basic_string[abi:fe180100]<0>(v169, "currentdict end");
    unint64_t v72 = v170;
    if ((v170 & 0x80u) == 0) {
      v73 = v169;
    }
    else {
      v73 = (void **)v169[0];
    }
    if ((v170 & 0x80u) != 0) {
      unint64_t v72 = (unint64_t)v169[1];
    }
    if (BytePtr == v60 || !v72) {
      goto LABEL_83;
    }
    v74 = BytePtr;
    uint64_t v75 = (uint64_t)v60;
    do
    {
      if (*v74 == *(char *)v73)
      {
        uint64_t v76 = 1;
        while (v72 != v76)
        {
          if (&v74[v76] == v60) {
            goto LABEL_75;
          }
          int v77 = v74[v76];
          int v78 = *((char *)v73 + v76++);
          if (v77 != v78) {
            goto LABEL_67;
          }
        }
        uint64_t v75 = (uint64_t)v74;
      }
LABEL_67:
      ++v74;
    }
    while (v74 != v60);
LABEL_75:
    if ((const UInt8 *)v75 == v60)
    {
LABEL_83:
      char v81 = 1;
    }
    else
    {
      CGDataConsumerPutBytes(v6[3], (uint64_t)BytePtr, v75 - (void)BytePtr);
      if ((v173 & 0x80u) == 0) {
        v79 = &__p;
      }
      else {
        v79 = __p;
      }
      if ((v173 & 0x80u) == 0) {
        uint64_t v80 = v173;
      }
      else {
        uint64_t v80 = v172;
      }
      CGDataConsumerPutBytes(v6[3], (uint64_t)v79, v80);
      CGDataConsumerPutBytes(v6[3], (uint64_t)"\n", 1);
      CGDataConsumerPutBytes(v6[3], v75, (uint64_t)&v60[-v75]);
      char v81 = 0;
    }
    uint64_t v31 = v168;
    if ((char)v170 < 0)
    {
      operator delete(v169[0]);
      if ((v81 & 1) == 0) {
        goto LABEL_90;
      }
    }
    else if ((v81 & 1) == 0)
    {
      goto LABEL_90;
    }
    if ((char)v173 < 0) {
      operator delete(__p);
    }
LABEL_88:
    uint64_t v59 = 0;
    uint64_t v58 = 0;
    uint64_t v57 = 0;
  }
  else
  {
    CGDataConsumerPutBytes(v6[3], (uint64_t)BytePtr, v60 - BytePtr);
LABEL_90:
    uint64_t v165 = v25;
    if ((char)v173 < 0) {
      operator delete(__p);
    }
    uint64_t v82 = BytePtr - v60 + Length;
    uint64_t v83 = v6[3];
    v84 = (uint64_t *)(v83 + 40);
    BOOL v85 = v83 == 0;
    v86 = v6 + 2;
    if (!v85) {
      v86 = v84;
    }
    uint64_t v87 = *v86;
    std::string::basic_string[abi:fe180100]<0>(&__p, "cleartomark");
    uint64_t v88 = v172;
    if ((v173 & 0x80u) == 0) {
      v89 = (char *)&__p;
    }
    else {
      v89 = (char *)__p;
    }
    if ((v173 & 0x80u) == 0) {
      uint64_t v88 = v173;
    }
    if (!v82 || !v88) {
      goto LABEL_123;
    }
    v90 = (unsigned __int8 *)&BytePtr[Length];
    v91 = (unsigned __int8 *)v60;
    v92 = &BytePtr[Length];
    do
    {
      if (*v91 == *v89)
      {
        uint64_t v93 = 1;
        while (v88 != v93)
        {
          if (&v91[v93] == v90) {
            goto LABEL_111;
          }
          int v94 = v91[v93];
          int v95 = v89[v93++];
          if (v94 != v95) {
            goto LABEL_103;
          }
        }
        v92 = v91;
      }
LABEL_103:
      ++v91;
    }
    while (v91 != v90);
LABEL_111:
    if (v92 != v90)
    {
      if (v92 > v60)
      {
        int v96 = 0;
        v97 = (unsigned __int8 *)(v92 - 1);
        uint64_t v98 = MEMORY[0x1E4F14390];
        do
        {
          v99 = v97;
          uint64_t v100 = *v97;
          if (v100 == 48)
          {
            if (++v96 == 512)
            {
              CGDataConsumerPutBytes(v6[3], (uint64_t)v60, v97 - v60);
              v82 -= v99 - v60;
              v60 = v99;
              goto LABEL_125;
            }
          }
          else if ((v100 & 0x80) != 0)
          {
            if (!__maskrune_l(v100, 0x4000uLL, 0)) {
              break;
            }
          }
          else if ((*(_DWORD *)(v98 + 4 * v100 + 60) & 0x4000) == 0)
          {
            break;
          }
          v97 = (unsigned __int8 *)(v99 - 1);
        }
        while (v99 > v60);
      }
      pdf_error("invalid Type1 font stream: missing 512 zeroes.");
    }
    else
    {
LABEL_123:
    }
LABEL_125:
    uint64_t v59 = v87 - v166;
    if ((char)v173 < 0) {
      operator delete(__p);
    }
    uint64_t v101 = v6[3];
    v102 = (uint64_t *)(v101 + 40);
    if (!v101) {
      v102 = v6 + 2;
    }
    uint64_t v103 = *v102;
    uint64_t v58 = *v102 - v87;
    CGDataConsumerPutBytes(v101, (uint64_t)v60, v82);
    uint64_t v104 = v6[3];
    if (v104) {
      v105 = (void *)(v104 + 40);
    }
    else {
      v105 = v6 + 2;
    }
    uint64_t v57 = *v105 - v103;
    uint64_t v31 = v168;
    uint64_t v25 = v165;
  }
  CFRelease(embedded_font_data);
LABEL_134:
  PDFStreamEndData(v6);
  PDFStreamEnd((CFDataRef *)v6);
  PDFStreamRelease((uint64_t)v6);
  PDFDocumentBeginObject(v5, v19, v106, v107, v108, v109, v110, v111);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v112, v113, v114, v115, v116, v117, v59);
  PDFDocumentEndObject(v5, v118, v119, v120, v121, v122, v123, v124);
  PDFDocumentBeginObject(v5, v25, v125, v126, v127, v128, v129, v130);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v131, v132, v133, v134, v135, v136, v58);
  PDFDocumentEndObject(v5, v137, v138, v139, v140, v141, v142, v143);
  PDFDocumentBeginObject(v5, v31, v144, v145, v146, v147, v148, v149);
  PDFDocumentPrintf(v5, (uint64_t)"%O", v150, v151, v152, v153, v154, v155, v57);

  return PDFDocumentEndObject(v5, v156, v157, v158, v159, v160, v161, v162);
}

void sub_184E57484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef Type1Subset::create_embedded_font_data(Type1Subset *this)
{
  uint64_t v2 = (void *)*((void *)this + 1);
  glyph_index_set = FontSubset::create_glyph_index_set(this);
  CFTypeRef embedded_font = PDFFont::create_embedded_font(v2, (uint64_t *)this + 8, (uint64_t)glyph_index_set, 0, 0);
  CGFontIndexSetRelease((void **)glyph_index_set);
  if (embedded_font
    && (unint64_t)(CFDataGetLength((CFDataRef)embedded_font) - 0x80000000) <= 0xFFFFFFFF80000000)
  {
    CFRelease(embedded_font);
    return 0;
  }
  return embedded_font;
}

void Type1Subset::emit_definition(Type1Subset *this)
{
  if (*((void *)this + 13))
  {
    uint64_t v2 = (const PDFFont *)*((void *)this + 1);
    FontDescriptor::FontDescriptor((FontDescriptor *)v125, v2, *((_DWORD *)this + 10) == 1);
    uint64_t v3 = **((void **)v2 + 1);
    PDFDocumentBeginObject(v3, *((void *)this + 6), v4, v5, v6, v7, v8, v9);
    PDFDocumentPrintf(v3, (uint64_t)"<<", v10, v11, v12, v13, v14, v15, v116);
    PDFDocumentPrintf(v3, (uint64_t)"/Type /Font", v16, v17, v18, v19, v20, v21, v117);
    PDFDocumentPrintf(v3, (uint64_t)"/Subtype /Type1", v22, v23, v24, v25, v26, v27, v118);
    uint64_t v35 = (char *)this + 64;
    uint64_t v34 = (char *)*((void *)this + 8);
    if (*((char *)this + 87) >= 0) {
      uint64_t v34 = (char *)this + 64;
    }
    PDFDocumentPrintf(v3, (uint64_t)"/BaseFont /%N", v28, v29, v30, v31, v32, v33, (uint64_t)v34);
    PDFDocumentPrintReference(v3, (uint64_t)"/FontDescriptor %R", v126, v36, v37, v38, v39, v40);
    uint64_t v47 = *((void *)this + 1);
    uint64_t v48 = **(void **)(v47 + 8);
    if (*((_DWORD *)this + 10) == 1)
    {
      PDFDocumentPrintf(**(void **)(v47 + 8), (uint64_t)"/Encoding /MacRomanEncoding", v41, v42, v43, v44, v45, v46, v119);
    }
    else
    {
      uint64_t v49 = *(void *)(v47 + 16);
      if (v49)
      {
        uint64_t v50 = (*(uint64_t (**)(void))(*(void *)(v49 + 16) + 288))(*(void *)(v49 + 112));
        if (v50)
        {
          std::vector<char>::size_type v57 = v50;
          uint64_t v124 = v2;
          PDFDocumentPrintf(v48, (uint64_t)"/Encoding <<", v51, v52, v53, v54, v55, v56, v119);
          PDFDocumentPrintf(v48, (uint64_t)"/Type /Encoding", v58, v59, v60, v61, v62, v63, v120);
          PDFDocumentPrintf(v48, (uint64_t)"/Differences [", v64, v65, v66, v67, v68, v69, v121);
          std::vector<char>::vector(&v128, v57);
          FontSubset::get_encoding_vector((FontSubset *)v127, (uint64_t)this);
          uint64_t v76 = 0;
          int v77 = (unsigned __int16 *)v127[0];
          uint64_t v78 = (uint64_t)(v127[1] - v127[0]) >> 1;
          char v79 = 1;
          do
          {
            if (v78 == v76)
            {
LABEL_29:
              __break(1u);
              return;
            }
            int v80 = v77[v76];
            BOOL v81 = v80 == 0xFFFF;
            if (v80 != 0xFFFF)
            {
              if (v79) {
                PDFDocumentPrintf(v48, (uint64_t)"%d", v70, v71, v72, v73, v74, v75, v76);
              }
              std::vector<char>::pointer begin = v128.__begin_;
              std::vector<char>::pointer end = v128.__end_;
              if (v128.__end_ == v128.__begin_) {
                goto LABEL_29;
              }
              uint64_t v84 = *(void *)(v47 + 16);
              if (v84)
              {
                (*(void (**)(void, void))(*(void *)(v84 + 16) + 296))(*(void *)(v84 + 112), v77[v76]);
                std::vector<char>::pointer begin = v128.__begin_;
                std::vector<char>::pointer end = v128.__end_;
              }
              if (end == begin) {
                goto LABEL_29;
              }
              PDFDocumentPrintf(v48, (uint64_t)"/%N", (uint64_t)begin, v71, v72, v73, v74, v75, (uint64_t)begin);
            }
            ++v76;
            char v79 = v81;
          }
          while (v76 != 256);
          PDFDocumentPrintf(v48, (uint64_t)"]", v70, v71, v72, v73, v74, v75, v122);
          PDFDocumentPrintf(v48, (uint64_t)">>", v85, v86, v87, v88, v89, v90, v123);
          operator delete(v77);
          uint64_t v2 = v124;
          uint64_t v35 = (char *)this + 64;
          if (v128.__begin_)
          {
            v128.__end_ = v128.__begin_;
            operator delete(v128.__begin_);
          }
        }
      }
    }
    if (*((_DWORD *)this + 10) == 1)
    {
      uint64_t v91 = 0;
    }
    else
    {
      uint64_t v91 = PDFXRefTableAddObject(*(void **)(v3 + 464));
      PDFDocumentPrintReference(v3, (uint64_t)"/ToUnicode %R", v91, v92, v93, v94, v95, v96);
    }
    FontSubset::emit_widths(this);
    PDFDocumentPrintf(v3, (uint64_t)">>", v97, v98, v99, v100, v101, v102, v119);
    PDFDocumentEndObject(v3, v103, v104, v105, v106, v107, v108, v109);
    if (v91)
    {
      v127[0] = v2;
      FontSubset::get_encoding_vector((FontSubset *)&v128, (uint64_t)this);
      ToUnicode::write<std::vector<unsigned short>>((uint64_t)v127, v91, &v128);
      if (v128.__begin_) {
        operator delete(v128.__begin_);
      }
    }
    uint64_t v110 = PDFXRefTableAddObject(*(void **)(v3 + 464));
    FontDescriptor::emit_definition((uint64_t)v125, (uint64_t)v35, v110, v111, v112, v113, v114, v115);
    (*(void (**)(Type1Subset *, uint64_t))(*(void *)this + 24))(this, v110);
  }
}

void sub_184E57860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    if ((__n & 0x8000000000000000) != 0) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v4 = (char *)operator new(__n);
    this->__begin_ = v4;
    uint64_t v5 = &v4[__n];
    this->__end_cap_.__value_ = &v4[__n];
    bzero(v4, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_184E578F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Type1Subset::~Type1Subset(Type1Subset *this)
{
  FontSubset::~FontSubset(this);

  JUMPOUT(0x18532A2A0);
}

uint64_t RGBAf_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 64);
  uint64_t v8 = *(void *)(result + 72);
  uint64_t v9 = *(void *)(result + 88);
  uint64_t v68 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  uint64_t v12 = *(void *)(result + 152) - 16;
  uint64_t v13 = *(void *)(result + 144) - 1;
  unint64_t v14 = v4
      + (3 * *(_DWORD *)(result + 256) - 3)
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      - 3;
  int v67 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v9;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_34;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v22 | v67;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v8 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_34;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v18 | v67;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v7) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v7 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v67;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(unsigned char *)++uint64_t v13 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v68)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v68;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v67;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  uint64_t v35 = 3 * (v29 >> 32);
  uint64_t v36 = v34 + v35;
  uint64_t v37 = *(unsigned __int8 **)(result + 32);
  if (v14 >= v34 + v35) {
    uint64_t v38 = (unsigned __int8 *)(v34 + v35);
  }
  else {
    uint64_t v38 = (unsigned __int8 *)v14;
  }
  if (v38 < v37) {
    uint64_t v38 = *(unsigned __int8 **)(result + 32);
  }
  unsigned int v39 = (v38[1] << 16) | (*v38 << 24) | (v38[2] << 8) | 0xFF;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      uint64_t v58 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v58) {
        uint64_t v58 = (unsigned __int8 *)v14;
      }
      if (v58 < v37) {
        uint64_t v58 = v37;
      }
      int v53 = (v58[1] << 16) | (*v58 << 24) | (v58[2] << 8) | 0xFF;
      goto LABEL_64;
    case 2:
      uint64_t v59 = (unsigned __int8 *)(v36 + 3 * SBYTE2(v40));
      if (v14 < (unint64_t)v59) {
        uint64_t v59 = (unsigned __int8 *)v14;
      }
      if (v59 < v37) {
        uint64_t v59 = v37;
      }
      int v53 = (v59[1] << 16) | (*v59 << 24) | (v59[2] << 8) | 0xFF;
      int v42 = (v40 >> 28) & 3;
LABEL_64:
      unsigned int v55 = interpolate_8888_21358[v42];
      char v56 = v42 + 1;
      unsigned int v57 = v39 - ((v55 & v39) >> v56);
      goto LABEL_65;
    case 3:
      uint64_t v43 = 3 * SBYTE2(v40);
      uint64_t v44 = (unsigned __int8 *)(v36 + v43);
      if (v14 < v36 + v43) {
        uint64_t v44 = (unsigned __int8 *)v14;
      }
      if (v44 < v37) {
        uint64_t v44 = v37;
      }
      int v45 = (v44[1] << 16) | (*v44 << 24) | (v44[2] << 8) | 0xFF;
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v46) {
        uint64_t v47 = (unsigned __int8 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        uint64_t v47 = (unsigned __int8 *)v14;
      }
      if (v47 < v37) {
        uint64_t v47 = v37;
      }
      int v48 = (v47[1] << 16) | (*v47 << 24) | (v47[2] << 8) | 0xFF;
      uint64_t v49 = (unsigned __int8 *)(v46 + v43);
      if (v14 < (unint64_t)v49) {
        uint64_t v49 = (unsigned __int8 *)v14;
      }
      if (v49 < v37) {
        uint64_t v49 = v37;
      }
      unsigned int v50 = interpolate_8888_21358[v42];
      char v51 = v42 + 1;
      unsigned int v52 = v39 - ((v50 & v39) >> v51) + ((v48 & v50) >> v51);
      int v53 = v45 - ((v50 & v45) >> v51) + ((((v49[1] << 16) | (*v49 << 24) | (v49[2] << 8) | 0xFF) & v50) >> v51);
      int v54 = (v40 >> 28) & 3;
      unsigned int v55 = interpolate_8888_21358[v54];
      char v56 = v54 + 1;
      unsigned int v57 = v52 - ((v52 & v55) >> v56);
LABEL_65:
      unsigned int v39 = v57 + ((v53 & v55) >> v56);
      break;
  }
LABEL_66:
  uint64_t v60 = 0;
  a2 += v10;
  uint64_t v61 = v68 - a2;
  uint64_t v62 = (_DWORD *)(v12 + 28);
  a3 += v11;
  uint64_t v63 = v9 - a3;
  while (1)
  {
    *(v62 - 3) = _blt_float[HIBYTE(v39)];
    *(v62 - 2) = _blt_float[BYTE2(v39)];
    *(v62 - 1) = _blt_float[BYTE1(v39)];
    *uint64_t v62 = _blt_float[v39];
    *(unsigned char *)(v13 + 1 + v60) = v24 >> 22;
    if (a4 - 1 == v60) {
      return result;
    }
    if (((v63 | v61 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v60 + 1;
      uint64_t v12 = (uint64_t)(v62 - 3);
      a4 += ~v60;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v64 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    uint64_t v65 = 3 * (a2 >> 32);
    uint64_t v36 = v64 + v65;
    uint64_t v37 = *(unsigned __int8 **)(result + 32);
    if (v14 >= v64 + v65) {
      uint64_t v66 = (unsigned __int8 *)(v64 + v65);
    }
    else {
      uint64_t v66 = (unsigned __int8 *)v14;
    }
    if (v66 < v37) {
      uint64_t v66 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v39 = (v66[1] << 16) | (*v66 << 24) | (v66[2] << 8) | 0xFF;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v60 + 1;
        uint64_t v12 = (uint64_t)(v62 - 3);
        a4 += ~v60;
        unsigned int v24 = -1;
        goto LABEL_37;
      }
    }
    ++v60;
    v61 -= v10;
    a2 += v10;
    v62 += 4;
    a3 += v11;
    v63 -= v11;
    unsigned int v24 = -1;
  }
}

uint64_t RGBAf_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v72 = *(void *)(result + 64);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  uint64_t v12 = *(void *)(result + 40);
  unint64_t v14 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  int v71 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_34;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v22 | v71;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_34;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v18 | v71;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v72) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v72 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v71;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v73)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v73;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v71;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v13 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v35 = v29 >> 32;
  unint64_t v36 = v34 + 4 * v35;
  uint64_t v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36) {
    uint64_t v38 = (unsigned int *)(v34 + 4 * v35);
  }
  else {
    uint64_t v38 = (unsigned int *)v14;
  }
  if (v38 < v37) {
    uint64_t v38 = *(unsigned int **)(result + 32);
  }
  unsigned int v39 = bswap32(*v38);
  if (!v5) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      uint64_t v58 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v58) {
        uint64_t v58 = (unsigned int *)v14;
      }
      if (v58 < v37) {
        uint64_t v58 = v37;
      }
      int v59 = interpolate_8888_21358[v42];
      char v60 = v42 + 1;
      unsigned int v57 = v39 - ((v59 & v39) >> v60);
      unsigned int v61 = (bswap32(*v58) & v59) >> v60;
LABEL_65:
      unsigned int v39 = v57 + v61;
      break;
    case 2:
      uint64_t v62 = (unsigned int *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 54));
      if (v14 < (unint64_t)v62) {
        uint64_t v62 = (unsigned int *)v14;
      }
      if (v62 < v37) {
        uint64_t v62 = v37;
      }
      unsigned int v53 = bswap32(*v62);
      int v63 = (v40 >> 28) & 3;
      int v55 = interpolate_8888_21358[v63];
      char v56 = v63 + 1;
      unsigned int v57 = v39 - ((v55 & v39) >> v56);
LABEL_64:
      unsigned int v61 = (v53 & v55) >> v56;
      goto LABEL_65;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v40) << 56;
      uint64_t v44 = (unsigned int *)(v36 + (v43 >> 54));
      if (v14 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v14;
      }
      if (v44 < v37) {
        uint64_t v44 = v37;
      }
      unsigned int v45 = bswap32(*v44);
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46) {
        uint64_t v47 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      }
      else {
        uint64_t v47 = (unsigned int *)v14;
      }
      if (v47 < v37) {
        uint64_t v47 = v37;
      }
      unsigned int v48 = bswap32(*v47);
      uint64_t v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v14 < (unint64_t)v49) {
        uint64_t v49 = (unsigned int *)v14;
      }
      if (v49 < v37) {
        uint64_t v49 = v37;
      }
      int v50 = interpolate_8888_21358[v42];
      char v51 = v42 + 1;
      unsigned int v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      unsigned int v53 = v45 - ((v50 & v45) >> v51) + ((bswap32(*v49) & v50) >> v51);
      int v54 = (v40 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      char v56 = v54 + 1;
      unsigned int v57 = v52 - ((v52 & v55) >> v56);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v64 = 0;
  a2 += v8;
  uint64_t v65 = v73 - a2;
  uint64_t v66 = (_DWORD *)(v10 + 28);
  a3 += v9;
  uint64_t v67 = v7 - a3;
  while (1)
  {
    *(v66 - 3) = _blt_float[HIBYTE(v39)];
    *(v66 - 2) = _blt_float[BYTE2(v39)];
    *(v66 - 1) = _blt_float[BYTE1(v39)];
    uint64_t v68 = v39;
    if (!v12) {
      uint64_t v68 = 255;
    }
    _DWORD *v66 = _blt_float[v68];
    *(unsigned char *)(v11 + 1 + v64) = v24 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v67 | v65 | (a3 - v6) | (a2 - v72)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = (uint64_t)(v66 - 3);
      v11 += v64 + 1;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v69 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v36 = v69 + 4 * (a2 >> 32);
    uint64_t v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36) {
      uint64_t v70 = (unsigned int *)(v69 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v70 = (unsigned int *)v14;
    }
    if (v70 < v37) {
      uint64_t v70 = *(unsigned int **)(result + 32);
    }
    unsigned int v39 = bswap32(*v70);
    if (v5)
    {
      unsigned int v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        uint64_t v10 = (uint64_t)(v66 - 3);
        v11 += v64 + 1;
        a4 += ~v64;
        unsigned int v24 = -1;
        goto LABEL_37;
      }
    }
    v65 -= v8;
    a2 += v8;
    v66 += 4;
    ++v64;
    a3 += v9;
    v67 -= v9;
    unsigned int v24 = -1;
  }
}

uint64_t RGBAf_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v74 = *(void *)(result + 64);
  uint64_t v75 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  uint64_t v12 = *(void *)(result + 40);
  unint64_t v14 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  int v73 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_34;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v22 | v73;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_34;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v18 | v73;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v74) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v74 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v73;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v75)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v75;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v73;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v13 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v35 = v29 >> 32;
  unint64_t v36 = v34 + 4 * v35;
  uint64_t v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36) {
    uint64_t v38 = (unsigned int *)(v34 + 4 * v35);
  }
  else {
    uint64_t v38 = (unsigned int *)v14;
  }
  if (v38 < v37) {
    uint64_t v38 = *(unsigned int **)(result + 32);
  }
  unsigned int v39 = *v38;
  if (!v5) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      int v59 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59) {
        int v59 = (unsigned int *)v14;
      }
      if (v59 < v37) {
        int v59 = v37;
      }
      unsigned int v60 = interpolate_8888_21358[v42];
      char v61 = v42 + 1;
      unsigned int v57 = v39 - ((v60 & v39) >> v61);
      unsigned int v62 = (v60 & *v59) >> v61;
LABEL_65:
      unsigned int v39 = v57 + v62;
      break;
    case 2:
      int v63 = (unsigned int *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 54));
      if (v14 < (unint64_t)v63) {
        int v63 = (unsigned int *)v14;
      }
      if (v63 < v37) {
        int v63 = v37;
      }
      int v64 = (v40 >> 28) & 3;
      int v65 = interpolate_8888_21358[v64];
      char v56 = v64 + 1;
      unsigned int v57 = v39 - ((v65 & v39) >> v56);
      unsigned int v58 = v65 & *v63;
LABEL_64:
      unsigned int v62 = v58 >> v56;
      goto LABEL_65;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v40) << 56;
      uint64_t v44 = (unsigned int *)(v36 + (v43 >> 54));
      if (v14 < (unint64_t)v44) {
        uint64_t v44 = (unsigned int *)v14;
      }
      if (v44 < v37) {
        uint64_t v44 = v37;
      }
      unsigned int v45 = *v44;
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46) {
        uint64_t v47 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      }
      else {
        uint64_t v47 = (unsigned int *)v14;
      }
      if (v47 < v37) {
        uint64_t v47 = v37;
      }
      unsigned int v48 = *v47;
      uint64_t v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v14 < (unint64_t)v49) {
        uint64_t v49 = (unsigned int *)v14;
      }
      if (v49 < v37) {
        uint64_t v49 = v37;
      }
      unsigned int v50 = interpolate_8888_21358[v42];
      char v51 = v42 + 1;
      unsigned int v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      unsigned int v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      int v54 = (v40 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      char v56 = v54 + 1;
      unsigned int v57 = v52 - ((v52 & v55) >> v56);
      unsigned int v58 = v53 & v55;
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v66 = 0;
  a2 += v8;
  uint64_t v67 = v75 - a2;
  uint64_t v68 = (_DWORD *)(v10 + 28);
  a3 += v9;
  uint64_t v69 = v7 - a3;
  while (1)
  {
    *(v68 - 3) = _blt_float[HIBYTE(v39)];
    *(v68 - 2) = _blt_float[BYTE2(v39)];
    *(v68 - 1) = _blt_float[BYTE1(v39)];
    uint64_t v70 = v39;
    if (!v12) {
      uint64_t v70 = 255;
    }
    _DWORD *v68 = _blt_float[v70];
    *(unsigned char *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v69 | v67 | (a3 - v6) | (a2 - v74)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = (uint64_t)(v68 - 3);
      v11 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v71 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v36 = v71 + 4 * (a2 >> 32);
    uint64_t v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36) {
      uint64_t v72 = (unsigned int *)(v71 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v72 = (unsigned int *)v14;
    }
    if (v72 < v37) {
      uint64_t v72 = *(unsigned int **)(result + 32);
    }
    unsigned int v39 = *v72;
    if (v5)
    {
      unsigned int v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        uint64_t v10 = (uint64_t)(v68 - 3);
        v11 += v66 + 1;
        a4 += ~v66;
        unsigned int v24 = -1;
        goto LABEL_37;
      }
    }
    v67 -= v8;
    a2 += v8;
    v68 += 4;
    ++v66;
    a3 += v9;
    v69 -= v9;
    unsigned int v24 = -1;
  }
}

uint64_t RGBAf_sample_ARGB32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 16;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  unint64_t v15 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  int v70 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v8;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_37;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        unsigned int v25 = v23 | v70;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v7 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_37;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      unsigned int v25 = v19 | v70;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v6) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v6 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v70;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 16;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v71)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v71;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v70;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 4 * v36;
  uint64_t v38 = *(unsigned int **)(result + 32);
  if (v15 >= v37) {
    unsigned int v39 = (unsigned int *)(v35 + 4 * v36);
  }
  else {
    unsigned int v39 = (unsigned int *)v15;
  }
  if (v39 < v38) {
    unsigned int v39 = *(unsigned int **)(result + 32);
  }
  unsigned int v40 = bswap32(*v39);
  if (!v5) {
    goto LABEL_69;
  }
  unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
  int v42 = v41 & 0xF;
  int v43 = HIBYTE(v41) & 3;
  switch(v42)
  {
    case 1:
      unsigned int v57 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v15 < (unint64_t)v57) {
        unsigned int v57 = (unsigned int *)v15;
      }
      if (v57 < v38) {
        unsigned int v57 = v38;
      }
      int v58 = interpolate_8888_21358[v43];
      char v59 = v43 + 1;
      unsigned int v60 = v40 - ((v58 & v40) >> v59);
      unsigned int v61 = (bswap32(*v57) & v58) >> v59;
LABEL_68:
      unsigned int v40 = v60 + v61;
      break;
    case 2:
      unsigned int v62 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
      if (v15 < (unint64_t)v62) {
        unsigned int v62 = (unsigned int *)v15;
      }
      if (v62 < v38) {
        unsigned int v62 = v38;
      }
      unsigned int v53 = bswap32(*v62);
      int v54 = (v41 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      unsigned int v56 = v55 & v40;
LABEL_67:
      char v63 = v54 + 1;
      unsigned int v60 = v40 - (v56 >> v63);
      unsigned int v61 = (v53 & v55) >> v63;
      goto LABEL_68;
    case 3:
      int64_t v44 = (unint64_t)HIWORD(v41) << 56;
      unsigned int v45 = (unsigned int *)(v37 + (v44 >> 54));
      if (v15 < (unint64_t)v45) {
        unsigned int v45 = (unsigned int *)v15;
      }
      if (v45 < v38) {
        unsigned int v45 = v38;
      }
      unsigned int v46 = bswap32(*v45);
      unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
      if (v15 >= v47) {
        unsigned int v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      }
      else {
        unsigned int v48 = (unsigned int *)v15;
      }
      if (v48 < v38) {
        unsigned int v48 = v38;
      }
      unsigned int v49 = bswap32(*v48);
      unsigned int v50 = (unsigned int *)(v47 + (v44 >> 54));
      if (v15 < (unint64_t)v50) {
        unsigned int v50 = (unsigned int *)v15;
      }
      if (v50 < v38) {
        unsigned int v50 = v38;
      }
      int v51 = interpolate_8888_21358[v43];
      char v52 = v43 + 1;
      unsigned int v40 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
      unsigned int v53 = v46 - ((v51 & v46) >> v52) + ((bswap32(*v50) & v51) >> v52);
      int v54 = (v41 >> 28) & 3;
      int v55 = interpolate_8888_21358[v54];
      unsigned int v56 = v40 & v55;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v64 = 0;
  a2 += v9;
  uint64_t v65 = v71 - a2;
  uint64_t v66 = (_DWORD *)(v11 + 28);
  a3 += v10;
  uint64_t v67 = v8 - a3;
  while (1)
  {
    *(v66 - 3) = _blt_float[BYTE2(v40)];
    *(v66 - 2) = _blt_float[BYTE1(v40)];
    *(v66 - 1) = _blt_float[v40];
    _DWORD *v66 = _blt_float[(v40 | v14) >> 24];
    *(unsigned char *)(v12 + 1 + v64) = v25 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v67 | v65 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (uint64_t)(v66 - 3);
      v12 += v64 + 1;
      a4 += ~v64;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v68 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v68 + 4 * (a2 >> 32);
    uint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      uint64_t v69 = (unsigned int *)(v68 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v69 = (unsigned int *)v15;
    }
    if (v69 < v38) {
      uint64_t v69 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = bswap32(*v69);
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        uint64_t v11 = (uint64_t)(v66 - 3);
        v12 += v64 + 1;
        a4 += ~v64;
        unsigned int v25 = -1;
        goto LABEL_40;
      }
    }
    v65 -= v9;
    a2 += v9;
    v66 += 4;
    ++v64;
    a3 += v10;
    v67 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t RGBAf_sample_argb32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 64);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 16;
  uint64_t v12 = *(void *)(result + 144) - 1;
  uint64_t v13 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  unint64_t v15 = v13
      + ((*(_DWORD *)(result + 260) - 1) * v4)
      + 4 * (*(_DWORD *)(result + 256) - 1)
      - 4;
  int v73 = *(_DWORD *)(result + 188);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v8;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_37;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        unsigned int v25 = v23 | v73;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v7 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_37;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      unsigned int v25 = v19 | v73;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v6) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v6 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v73;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 16;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v74;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v73;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v13 + SHIDWORD(v26) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 4 * v36;
  uint64_t v38 = *(unsigned int **)(result + 32);
  if (v15 >= v37) {
    unsigned int v39 = (unsigned int *)(v35 + 4 * v36);
  }
  else {
    unsigned int v39 = (unsigned int *)v15;
  }
  if (v39 < v38) {
    unsigned int v39 = *(unsigned int **)(result + 32);
  }
  unsigned int v40 = *v39;
  if (!v5) {
    goto LABEL_69;
  }
  unsigned int v41 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_40:
  int v42 = v41 & 0xF;
  int v43 = HIBYTE(v41) & 3;
  switch(v42)
  {
    case 1:
      unsigned int v60 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v15 < (unint64_t)v60) {
        unsigned int v60 = (unsigned int *)v15;
      }
      if (v60 < v38) {
        unsigned int v60 = v38;
      }
      unsigned int v61 = interpolate_8888_21358[v43];
      char v62 = v43 + 1;
      unsigned int v58 = v40 - ((v61 & v40) >> v62);
      unsigned int v63 = (v61 & *v60) >> v62;
LABEL_68:
      unsigned int v40 = v58 + v63;
      break;
    case 2:
      uint64_t v64 = (unsigned int *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 54));
      if (v15 < (unint64_t)v64) {
        uint64_t v64 = (unsigned int *)v15;
      }
      if (v64 < v38) {
        uint64_t v64 = v38;
      }
      int v65 = (v41 >> 28) & 3;
      int v66 = interpolate_8888_21358[v65];
      char v57 = v65 + 1;
      unsigned int v58 = v40 - ((v66 & v40) >> v57);
      unsigned int v59 = v66 & *v64;
LABEL_67:
      unsigned int v63 = v59 >> v57;
      goto LABEL_68;
    case 3:
      int64_t v44 = (unint64_t)HIWORD(v41) << 56;
      unsigned int v45 = (unsigned int *)(v37 + (v44 >> 54));
      if (v15 < (unint64_t)v45) {
        unsigned int v45 = (unsigned int *)v15;
      }
      if (v45 < v38) {
        unsigned int v45 = v38;
      }
      unsigned int v46 = *v45;
      unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
      if (v15 >= v47) {
        unsigned int v48 = (unsigned int *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      }
      else {
        unsigned int v48 = (unsigned int *)v15;
      }
      if (v48 < v38) {
        unsigned int v48 = v38;
      }
      unsigned int v49 = *v48;
      unsigned int v50 = (unsigned int *)(v47 + (v44 >> 54));
      if (v15 < (unint64_t)v50) {
        unsigned int v50 = (unsigned int *)v15;
      }
      if (v50 < v38) {
        unsigned int v50 = v38;
      }
      unsigned int v51 = interpolate_8888_21358[v43];
      char v52 = v43 + 1;
      unsigned int v53 = v40 - ((v51 & v40) >> v52) + ((v51 & v49) >> v52);
      unsigned int v54 = v46 - ((v51 & v46) >> v52) + ((v51 & *v50) >> v52);
      int v55 = (v41 >> 28) & 3;
      int v56 = interpolate_8888_21358[v55];
      char v57 = v55 + 1;
      unsigned int v58 = v53 - ((v53 & v56) >> v57);
      unsigned int v59 = v54 & v56;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v67 = 0;
  a2 += v9;
  uint64_t v68 = v74 - a2;
  uint64_t v69 = (_DWORD *)(v11 + 28);
  a3 += v10;
  uint64_t v70 = v8 - a3;
  while (1)
  {
    *(v69 - 3) = _blt_float[BYTE2(v40)];
    *(v69 - 2) = _blt_float[BYTE1(v40)];
    *(v69 - 1) = _blt_float[v40];
    *uint64_t v69 = _blt_float[(v40 | v14) >> 24];
    *(unsigned char *)(v12 + 1 + v67) = v25 >> 22;
    if (a4 - 1 == v67) {
      return result;
    }
    if (((v70 | v68 | (a3 - v7) | (a2 - v6)) & 0x8000000000000000) != 0)
    {
      uint64_t v11 = (uint64_t)(v69 - 3);
      v12 += v67 + 1;
      a4 += ~v67;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v71 = v13 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v71 + 4 * (a2 >> 32);
    uint64_t v38 = *(unsigned int **)(result + 32);
    if (v15 >= v37) {
      uint64_t v72 = (unsigned int *)(v71 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v72 = (unsigned int *)v15;
    }
    if (v72 < v38) {
      uint64_t v72 = *(unsigned int **)(result + 32);
    }
    unsigned int v40 = *v72;
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        uint64_t v11 = (uint64_t)(v69 - 3);
        v12 += v67 + 1;
        a4 += ~v67;
        unsigned int v25 = -1;
        goto LABEL_40;
      }
    }
    v68 -= v9;
    a2 += v9;
    v69 += 4;
    ++v67;
    a3 += v10;
    v70 -= v10;
    unsigned int v25 = -1;
  }
}

void RGBAf_sample_RGB48(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v61 = *(void *)(a1 + 80);
  uint64_t v64 = *(void *)(a1 + 88);
  uint64_t v70 = *(void *)(a1 + 112);
  uint64_t v69 = *(void *)(a1 + 120);
  uint64_t v7 = (float *)(*(void *)(a1 + 152) - 16);
  uint64_t v65 = *(void *)(a1 + 144) - 1;
  uint64_t v66 = *(void *)(a1 + 32);
  int v67 = *(_DWORD *)(a1 + 24);
  int v60 = *(_DWORD *)(a1 + 188);
  unint64_t v68 = v66
      + ((*(_DWORD *)(a1 + 260) - 1) * v67)
      + 2 * (3 * *(_DWORD *)(a1 + 256) - 3)
      - 6;
  uint64_t v62 = *(void *)(a1 + 64);
  uint64_t v63 = *(void *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v63)
    {
      if ((uint64_t)a3 <= v64)
      {
        uint64_t v18 = (a3 >> 22) & 0x3C0;
        unsigned int v19 = 0x3FFFFFFF;
        HIDWORD(v20) = HIDWORD(a3);
        int v11 = a4;
        uint64_t v12 = v62;
      }
      else
      {
        uint64_t v14 = *(void *)(a1 + 216);
        uint64_t v15 = *(void *)(a1 + 224) + v64;
        uint64_t v16 = v15 - a3 + (v14 >> 1);
        int v11 = a4;
        uint64_t v12 = v62;
        if (v16 < 1) {
          goto LABEL_33;
        }
        if (v16 >= v14) {
          LODWORD(v17) = 0x3FFFFFFF;
        }
        else {
          unint64_t v17 = (unint64_t)(*(void *)(a1 + 232) * v16) >> 32;
        }
        unsigned int v19 = v17 | v60;
        uint64_t v20 = v15 - 0x1000000;
        uint64_t v18 = 448;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 216);
      uint64_t v9 = v63 - *(void *)(a1 + 224);
      uint64_t v10 = a3 - v9 + (v8 >> 1);
      int v11 = a4;
      uint64_t v12 = v62;
      if (v10 < 1) {
        goto LABEL_33;
      }
      if (v10 >= v8) {
        LODWORD(v13) = 0x3FFFFFFF;
      }
      else {
        unint64_t v13 = (unint64_t)(*(void *)(a1 + 232) * v10) >> 32;
      }
      unsigned int v19 = v13 | v60;
      uint64_t v20 = v9 + 0x1000000;
      uint64_t v18 = 512;
    }
    if ((uint64_t)a2 >= v12)
    {
      if ((uint64_t)a2 <= v61)
      {
        uint64_t v25 = (a2 >> 26) & 0x3C;
        HIDWORD(v24) = HIDWORD(a2);
      }
      else
      {
        uint64_t v26 = *(void *)(a1 + 192);
        uint64_t v27 = *(void *)(a1 + 200) + v61;
        uint64_t v28 = v27 - a2 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_33;
        }
        if (v28 < v26) {
          unsigned int v19 = ((v19 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v28) >> 32) >> 15)) | v60;
        }
        uint64_t v24 = v27 - 0x1000000;
        uint64_t v25 = 28;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(a1 + 192);
      uint64_t v22 = v12 - *(void *)(a1 + 200);
      uint64_t v23 = a2 - v22 + (v21 >> 1);
      if (v23 < 1) {
        goto LABEL_33;
      }
      if (v23 < v21) {
        unsigned int v19 = ((v19 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v23) >> 32) >> 15)) | v60;
      }
      uint64_t v24 = v22 + 0x1000000;
      uint64_t v25 = 32;
    }
    if (v19 >= 0x400000) {
      break;
    }
LABEL_33:
    int v34 = v11 - 1;
    a2 += v70;
    a3 += v69;
    v7 += 4;
    *(unsigned char *)++uint64_t v65 = 0;
LABEL_34:
    a4 = v34;
    if (!v34) {
      return;
    }
  }
  unint64_t v29 = v66 + SHIDWORD(v20) * (uint64_t)v67 + 6 * SHIDWORD(v24);
  uint64_t v30 = *(unsigned __int16 **)(a1 + 32);
  uint64_t v31 = (unsigned __int16 *)v68;
  if (v68 >= v29) {
    uint64_t v31 = (unsigned __int16 *)v29;
  }
  if (v31 < v30) {
    uint64_t v31 = *(unsigned __int16 **)(a1 + 32);
  }
  unint64_t v32 = (bswap32(*v31) >> 16) | ((unint64_t)(bswap32(v31[1]) >> 16) << 16) | ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (v6)
  {
    unsigned int v33 = *(_DWORD *)(v6 + (v25 | v18));
LABEL_37:
    int v35 = v33 & 0xF;
    int v36 = HIBYTE(v33) & 3;
    switch(v35)
    {
      case 1:
        unsigned int v51 = (unsigned __int16 *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 < (unint64_t)v51) {
          unsigned int v51 = (unsigned __int16 *)v68;
        }
        if (v51 >= v30) {
          uint64_t v30 = v51;
        }
        unint64_t v32 = v32
            - ((interpolate_16161616_21355[v36] & v32) >> (v36 + 1))
            + ((((bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000) & interpolate_16161616_21355[v36]) >> (v36 + 1));
        break;
      case 2:
        char v52 = (unsigned __int16 *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v52) {
          char v52 = (unsigned __int16 *)v68;
        }
        if (v52 >= v30) {
          uint64_t v30 = v52;
        }
        unint64_t v46 = (bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000;
        int v53 = (v33 >> 28) & 3;
        uint64_t v48 = interpolate_16161616_21355[v53];
        char v49 = v53 + 1;
        unint64_t v50 = v32 - ((v48 & v32) >> v49);
LABEL_64:
        unint64_t v32 = v50 + ((v46 & v48) >> v49);
        break;
      case 3:
        unint64_t v37 = (unsigned __int16 *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v37) {
          unint64_t v37 = (unsigned __int16 *)v68;
        }
        if (v37 < v30) {
          unint64_t v37 = v30;
        }
        unint64_t v38 = (bswap32(*v37) >> 16) | ((unint64_t)(bswap32(v37[1]) >> 16) << 16) | ((unint64_t)(bswap32(v37[2]) >> 16) << 32) | 0xFFFF000000000000;
        unsigned int v39 = (unsigned __int16 *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 >= (unint64_t)v39) {
          unsigned int v40 = v39;
        }
        else {
          unsigned int v40 = (unsigned __int16 *)v68;
        }
        if (v40 < v30) {
          unsigned int v40 = v30;
        }
        unint64_t v41 = (bswap32(*v40) >> 16) | ((unint64_t)(bswap32(v40[1]) >> 16) << 16) | ((unint64_t)(bswap32(v40[2]) >> 16) << 32) | 0xFFFF000000000000;
        int v42 = &v39[3 * SBYTE2(v33)];
        if (v68 < (unint64_t)v42) {
          int v42 = (unsigned __int16 *)v68;
        }
        if (v42 >= v30) {
          uint64_t v30 = v42;
        }
        uint64_t v43 = interpolate_16161616_21355[v36];
        char v44 = v36 + 1;
        unint64_t v45 = v32 - ((v43 & v32) >> v44) + ((v41 & v43) >> v44);
        unint64_t v46 = v38
            - ((v43 & v38) >> v44)
            + ((((bswap32(*v30) >> 16) | ((unint64_t)(bswap32(v30[1]) >> 16) << 16) | ((unint64_t)(bswap32(v30[2]) >> 16) << 32) | 0xFFFF000000000000) & v43) >> v44);
        int v47 = (v33 >> 28) & 3;
        uint64_t v48 = interpolate_16161616_21355[v47];
        char v49 = v47 + 1;
        unint64_t v50 = v45 - ((v45 & v48) >> v49);
        goto LABEL_64;
    }
  }
  uint64_t v54 = 0;
  v7 += 4;
  int v59 = v11;
  int v55 = v11 - 1;
  a3 += v69;
  uint64_t v56 = v64 - a3;
  a2 += v70;
  uint64_t v57 = v61 - a2;
  while (1)
  {
    RGBA64(v7, v32);
    *(unsigned char *)(v65 + 1 + v54) = v19 >> 22;
    if (v55 == v54) {
      break;
    }
    if (((v56 | v57 | (a3 - v63) | (a2 - v62)) & 0x8000000000000000) != 0)
    {
      v65 += v54 + 1;
      int v34 = ~v54 + v59;
      goto LABEL_34;
    }
    unint64_t v29 = v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2);
    uint64_t v30 = *(unsigned __int16 **)(a1 + 32);
    unsigned int v58 = (unsigned __int16 *)v68;
    if (v68 >= v29) {
      unsigned int v58 = (unsigned __int16 *)(v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2));
    }
    if (v58 < v30) {
      unsigned int v58 = *(unsigned __int16 **)(a1 + 32);
    }
    unint64_t v32 = (bswap32(*v58) >> 16) | ((unint64_t)(bswap32(v58[1]) >> 16) << 16) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v33 = *(_DWORD *)(v6 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v33 & 0xF) != 0)
      {
        v65 += v54 + 1;
        int v11 = ~v54 + v59;
        unsigned int v19 = -1;
        goto LABEL_37;
      }
    }
    ++v54;
    v7 += 4;
    a3 += v69;
    v56 -= v69;
    a2 += v70;
    v57 -= v70;
    unsigned int v19 = -1;
  }
}

float RGBA64(float *a1, unint64_t a2)
{
  *a1 = *(float *)&_blt_float[a2 + 256] + *(float *)&_blt_float[BYTE1(a2) + 512];
  a1[1] = *(float *)&_blt_float[BYTE2(a2) + 256] + *(float *)&_blt_float[BYTE3(a2) | 0x200];
  a1[2] = *(float *)&_blt_float[BYTE4(a2) + 256] + *(float *)&_blt_float[BYTE5(a2) + 512];
  float result = *(float *)&_blt_float[BYTE6(a2) + 256] + *(float *)&_blt_float[HIBYTE(a2) + 512];
  a1[3] = result;
  return result;
}

void RGBAf_sample_rgb48(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v61 = *(void *)(a1 + 80);
  uint64_t v64 = *(void *)(a1 + 88);
  uint64_t v70 = *(void *)(a1 + 112);
  uint64_t v69 = *(void *)(a1 + 120);
  uint64_t v7 = (float *)(*(void *)(a1 + 152) - 16);
  uint64_t v65 = *(void *)(a1 + 144) - 1;
  uint64_t v66 = *(void *)(a1 + 32);
  int v67 = *(_DWORD *)(a1 + 24);
  int v60 = *(_DWORD *)(a1 + 188);
  unint64_t v68 = v66
      + ((*(_DWORD *)(a1 + 260) - 1) * v67)
      + 2 * (3 * *(_DWORD *)(a1 + 256) - 3)
      - 6;
  uint64_t v62 = *(void *)(a1 + 64);
  uint64_t v63 = *(void *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v63)
    {
      if ((uint64_t)a3 <= v64)
      {
        uint64_t v18 = (a3 >> 22) & 0x3C0;
        unsigned int v19 = 0x3FFFFFFF;
        HIDWORD(v20) = HIDWORD(a3);
        int v11 = a4;
        uint64_t v12 = v62;
      }
      else
      {
        uint64_t v14 = *(void *)(a1 + 216);
        uint64_t v15 = *(void *)(a1 + 224) + v64;
        uint64_t v16 = v15 - a3 + (v14 >> 1);
        int v11 = a4;
        uint64_t v12 = v62;
        if (v16 < 1) {
          goto LABEL_33;
        }
        if (v16 >= v14) {
          LODWORD(v17) = 0x3FFFFFFF;
        }
        else {
          unint64_t v17 = (unint64_t)(*(void *)(a1 + 232) * v16) >> 32;
        }
        unsigned int v19 = v17 | v60;
        uint64_t v20 = v15 - 0x1000000;
        uint64_t v18 = 448;
      }
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 216);
      uint64_t v9 = v63 - *(void *)(a1 + 224);
      uint64_t v10 = a3 - v9 + (v8 >> 1);
      int v11 = a4;
      uint64_t v12 = v62;
      if (v10 < 1) {
        goto LABEL_33;
      }
      if (v10 >= v8) {
        LODWORD(v13) = 0x3FFFFFFF;
      }
      else {
        unint64_t v13 = (unint64_t)(*(void *)(a1 + 232) * v10) >> 32;
      }
      unsigned int v19 = v13 | v60;
      uint64_t v20 = v9 + 0x1000000;
      uint64_t v18 = 512;
    }
    if ((uint64_t)a2 >= v12)
    {
      if ((uint64_t)a2 <= v61)
      {
        uint64_t v25 = (a2 >> 26) & 0x3C;
        HIDWORD(v24) = HIDWORD(a2);
      }
      else
      {
        uint64_t v26 = *(void *)(a1 + 192);
        uint64_t v27 = *(void *)(a1 + 200) + v61;
        uint64_t v28 = v27 - a2 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_33;
        }
        if (v28 < v26) {
          unsigned int v19 = ((v19 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v28) >> 32) >> 15)) | v60;
        }
        uint64_t v24 = v27 - 0x1000000;
        uint64_t v25 = 28;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(a1 + 192);
      uint64_t v22 = v12 - *(void *)(a1 + 200);
      uint64_t v23 = a2 - v22 + (v21 >> 1);
      if (v23 < 1) {
        goto LABEL_33;
      }
      if (v23 < v21) {
        unsigned int v19 = ((v19 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v23) >> 32) >> 15)) | v60;
      }
      uint64_t v24 = v22 + 0x1000000;
      uint64_t v25 = 32;
    }
    if (v19 >= 0x400000) {
      break;
    }
LABEL_33:
    int v34 = v11 - 1;
    a2 += v70;
    a3 += v69;
    v7 += 4;
    *(unsigned char *)++uint64_t v65 = 0;
LABEL_34:
    a4 = v34;
    if (!v34) {
      return;
    }
  }
  unint64_t v29 = v66 + SHIDWORD(v20) * (uint64_t)v67 + 6 * SHIDWORD(v24);
  uint64_t v30 = *(unsigned int **)(a1 + 32);
  uint64_t v31 = (unsigned int *)v68;
  if (v68 >= v29) {
    uint64_t v31 = (unsigned int *)v29;
  }
  if (v31 < v30) {
    uint64_t v31 = *(unsigned int **)(a1 + 32);
  }
  unint64_t v32 = *v31 | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32) | 0xFFFF000000000000;
  if (v6)
  {
    unsigned int v33 = *(_DWORD *)(v6 + (v25 | v18));
LABEL_37:
    int v35 = v33 & 0xF;
    int v36 = HIBYTE(v33) & 3;
    switch(v35)
    {
      case 1:
        unsigned int v51 = (unsigned int *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 < (unint64_t)v51) {
          unsigned int v51 = (unsigned int *)v68;
        }
        if (v51 >= v30) {
          uint64_t v30 = v51;
        }
        unint64_t v32 = v32
            - ((interpolate_16161616_21355[v36] & v32) >> (v36 + 1))
            + (((*v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000) & interpolate_16161616_21355[v36]) >> (v36 + 1));
        break;
      case 2:
        char v52 = (unsigned int *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v52) {
          char v52 = (unsigned int *)v68;
        }
        if (v52 >= v30) {
          uint64_t v30 = v52;
        }
        unint64_t v46 = *v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000;
        int v53 = (v33 >> 28) & 3;
        uint64_t v48 = interpolate_16161616_21355[v53];
        char v49 = v53 + 1;
        unint64_t v50 = v32 - ((v48 & v32) >> v49);
LABEL_64:
        unint64_t v32 = v50 + ((v46 & v48) >> v49);
        break;
      case 3:
        unint64_t v37 = (unsigned int *)(v29 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v37) {
          unint64_t v37 = (unsigned int *)v68;
        }
        if (v37 < v30) {
          unint64_t v37 = v30;
        }
        unint64_t v38 = *v37 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32) | 0xFFFF000000000000;
        unsigned int v39 = (unsigned int *)(v29 + SBYTE1(v33) * (uint64_t)v67);
        if (v68 >= (unint64_t)v39) {
          unsigned int v40 = v39;
        }
        else {
          unsigned int v40 = (unsigned int *)v68;
        }
        if (v40 < v30) {
          unsigned int v40 = v30;
        }
        unint64_t v41 = *v40 | ((unint64_t)*((unsigned __int16 *)v40 + 2) << 32) | 0xFFFF000000000000;
        int v42 = (unsigned int *)((char *)v39 + 6 * SBYTE2(v33));
        if (v68 < (unint64_t)v42) {
          int v42 = (unsigned int *)v68;
        }
        if (v42 >= v30) {
          uint64_t v30 = v42;
        }
        uint64_t v43 = interpolate_16161616_21355[v36];
        char v44 = v36 + 1;
        unint64_t v45 = v32 - ((v43 & v32) >> v44) + ((v41 & v43) >> v44);
        unint64_t v46 = v38
            - ((v43 & v38) >> v44)
            + (((*v30 | ((unint64_t)*((unsigned __int16 *)v30 + 2) << 32) | 0xFFFF000000000000) & v43) >> v44);
        int v47 = (v33 >> 28) & 3;
        uint64_t v48 = interpolate_16161616_21355[v47];
        char v49 = v47 + 1;
        unint64_t v50 = v45 - ((v45 & v48) >> v49);
        goto LABEL_64;
    }
  }
  uint64_t v54 = 0;
  v7 += 4;
  int v59 = v11;
  int v55 = v11 - 1;
  a3 += v69;
  uint64_t v56 = v64 - a3;
  a2 += v70;
  uint64_t v57 = v61 - a2;
  while (1)
  {
    RGBA64(v7, v32);
    *(unsigned char *)(v65 + 1 + v54) = v19 >> 22;
    if (v55 == v54) {
      break;
    }
    if (((v56 | v57 | (a3 - v63) | (a2 - v62)) & 0x8000000000000000) != 0)
    {
      v65 += v54 + 1;
      int v34 = ~v54 + v59;
      goto LABEL_34;
    }
    unint64_t v29 = v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2);
    uint64_t v30 = *(unsigned int **)(a1 + 32);
    unsigned int v58 = (unsigned int *)v68;
    if (v68 >= v29) {
      unsigned int v58 = (unsigned int *)(v66 + SHIDWORD(a3) * (uint64_t)v67 + 6 * SHIDWORD(a2));
    }
    if (v58 < v30) {
      unsigned int v58 = *(unsigned int **)(a1 + 32);
    }
    unint64_t v32 = *v58 | ((unint64_t)*((unsigned __int16 *)v58 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v33 = *(_DWORD *)(v6 + ((a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v33 & 0xF) != 0)
      {
        v65 += v54 + 1;
        int v11 = ~v54 + v59;
        unsigned int v19 = -1;
        goto LABEL_37;
      }
    }
    ++v54;
    v7 += 4;
    a3 += v69;
    v56 -= v69;
    a2 += v70;
    v57 -= v70;
    unsigned int v19 = -1;
  }
}

void RGBAf_sample_RGBA64(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v65 = *(void *)(a1 + 80);
  uint64_t v68 = *(void *)(a1 + 88);
  uint64_t v75 = *(void *)(a1 + 112);
  uint64_t v74 = *(void *)(a1 + 120);
  int v64 = *(_DWORD *)(a1 + 188);
  uint64_t v7 = (float *)(*(void *)(a1 + 152) - 16);
  uint64_t v69 = *(void *)(a1 + 144) - 1;
  unint64_t v8 = 0xFFFF000000000000;
  if (*(void *)(a1 + 40)) {
    unint64_t v8 = 0;
  }
  unint64_t v71 = v8;
  int v72 = *(_DWORD *)(a1 + 24);
  uint64_t v70 = *(void *)(a1 + 32);
  unint64_t v73 = v70 + ((*(_DWORD *)(a1 + 260) - 1) * v72) + 8 * (*(_DWORD *)(a1 + 256) - 1) - 8;
  uint64_t v66 = *(void *)(a1 + 64);
  uint64_t v67 = *(void *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v67)
    {
      if ((uint64_t)a3 <= v68)
      {
        uint64_t v19 = (a3 >> 22) & 0x3C0;
        unsigned int v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        int v12 = a4;
        uint64_t v13 = v66;
      }
      else
      {
        uint64_t v15 = *(void *)(a1 + 216);
        uint64_t v16 = *(void *)(a1 + 224) + v68;
        uint64_t v17 = v16 - a3 + (v15 >> 1);
        int v12 = a4;
        uint64_t v13 = v66;
        if (v17 < 1) {
          goto LABEL_35;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (unint64_t)(*(void *)(a1 + 232) * v17) >> 32;
        }
        unsigned int v20 = v18 | v64;
        uint64_t v21 = v16 - 0x1000000;
        uint64_t v19 = 448;
      }
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 216);
      uint64_t v10 = v67 - *(void *)(a1 + 224);
      uint64_t v11 = a3 - v10 + (v9 >> 1);
      int v12 = a4;
      uint64_t v13 = v66;
      if (v11 < 1) {
        goto LABEL_35;
      }
      if (v11 >= v9) {
        LODWORD(v14) = 0x3FFFFFFF;
      }
      else {
        unint64_t v14 = (unint64_t)(*(void *)(a1 + 232) * v11) >> 32;
      }
      unsigned int v20 = v14 | v64;
      uint64_t v21 = v10 + 0x1000000;
      uint64_t v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v65)
      {
        uint64_t v26 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v25 = a2;
      }
      else
      {
        uint64_t v27 = *(void *)(a1 + 192);
        uint64_t v28 = *(void *)(a1 + 200) + v65;
        uint64_t v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1) {
          goto LABEL_35;
        }
        if (v29 < v27) {
          unsigned int v20 = ((v20 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v29) >> 32) >> 15)) | v64;
        }
        uint64_t v25 = v28 - 0x1000000;
        uint64_t v26 = 28;
      }
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 192);
      uint64_t v23 = v13 - *(void *)(a1 + 200);
      uint64_t v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_35;
      }
      if (v24 < v22) {
        unsigned int v20 = ((v20 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v24) >> 32) >> 15)) | v64;
      }
      uint64_t v25 = v23 + 0x1000000;
      uint64_t v26 = 32;
    }
    if (v20 >= 0x400000) {
      break;
    }
LABEL_35:
    int v35 = v12 - 1;
    a2 += v75;
    a3 += v74;
    v7 += 4;
    *(unsigned char *)++uint64_t v69 = 0;
LABEL_36:
    a4 = v35;
    if (!v35) {
      return;
    }
  }
  unint64_t v30 = v70 + SHIDWORD(v21) * (uint64_t)v72 + 8 * (v25 >> 32);
  uint64_t v31 = *(unsigned __int16 **)(a1 + 32);
  unint64_t v32 = (unsigned __int16 *)v73;
  if (v73 >= v30) {
    unint64_t v32 = (unsigned __int16 *)v30;
  }
  if (v32 < v31) {
    unint64_t v32 = *(unsigned __int16 **)(a1 + 32);
  }
  unint64_t v33 = ((unint64_t)(bswap32(v32[2]) >> 16) << 32) | ((unint64_t)(bswap32(v32[3]) >> 16) << 48) | bswap32(v32[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v32) >> 16);
  if (!v6) {
    goto LABEL_68;
  }
  unsigned int v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_39:
  int v36 = v34 & 0xF;
  int v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      unsigned int v51 = (unsigned __int16 *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 < (unint64_t)v51) {
        unsigned int v51 = (unsigned __int16 *)v73;
      }
      if (v51 >= v31) {
        uint64_t v31 = v51;
      }
      uint64_t v52 = interpolate_16161616_21355[v37];
      char v53 = v37 + 1;
      unint64_t v54 = v33 - ((v52 & v33) >> v53);
      unint64_t v55 = ((((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16)) & v52) >> v53;
LABEL_67:
      unint64_t v33 = v54 + v55;
      break;
    case 2:
      uint64_t v56 = (unsigned __int16 *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 53));
      if (v73 < (unint64_t)v56) {
        uint64_t v56 = (unsigned __int16 *)v73;
      }
      if (v56 >= v31) {
        uint64_t v31 = v56;
      }
      unint64_t v47 = ((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16);
      int v48 = (v34 >> 28) & 3;
      uint64_t v49 = interpolate_16161616_21355[v48];
      unint64_t v50 = v49 & v33;
LABEL_66:
      char v57 = v48 + 1;
      unint64_t v54 = v33 - (v50 >> v57);
      unint64_t v55 = (v47 & v49) >> v57;
      goto LABEL_67;
    case 3:
      int64_t v38 = (unint64_t)HIWORD(v34) << 56;
      unsigned int v39 = (unsigned __int16 *)(v30 + (v38 >> 53));
      if (v73 < (unint64_t)v39) {
        unsigned int v39 = (unsigned __int16 *)v73;
      }
      if (v39 < v31) {
        unsigned int v39 = v31;
      }
      unint64_t v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
      unint64_t v41 = (unsigned __int16 *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 >= (unint64_t)v41) {
        int v42 = v41;
      }
      else {
        int v42 = (unsigned __int16 *)v73;
      }
      if (v42 < v31) {
        int v42 = v31;
      }
      unint64_t v43 = ((unint64_t)(bswap32(v42[2]) >> 16) << 32) | ((unint64_t)(bswap32(v42[3]) >> 16) << 48) | bswap32(v42[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v42) >> 16);
      char v44 = (unsigned __int16 *)((char *)v41 + (v38 >> 53));
      if (v73 < (unint64_t)v44) {
        char v44 = (unsigned __int16 *)v73;
      }
      if (v44 >= v31) {
        uint64_t v31 = v44;
      }
      uint64_t v45 = interpolate_16161616_21355[v37];
      char v46 = v37 + 1;
      unint64_t v33 = v33 - ((v45 & v33) >> v46) + ((v43 & v45) >> v46);
      unint64_t v47 = v40
          - ((v45 & v40) >> v46)
          + (((((unint64_t)(bswap32(v31[2]) >> 16) << 32) | ((unint64_t)(bswap32(v31[3]) >> 16) << 48) | bswap32(v31[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v31) >> 16)) & v45) >> v46);
      int v48 = (v34 >> 28) & 3;
      uint64_t v49 = interpolate_16161616_21355[v48];
      unint64_t v50 = v33 & v49;
      goto LABEL_66;
  }
LABEL_68:
  uint64_t v58 = 0;
  v7 += 4;
  int v63 = v12;
  int v59 = v12 - 1;
  a3 += v74;
  uint64_t v60 = v68 - a3;
  a2 += v75;
  uint64_t v61 = v65 - a2;
  while (1)
  {
    RGBA64(v7, v33 | v71);
    *(unsigned char *)(v69 + 1 + v58) = v20 >> 22;
    if (v59 == v58) {
      break;
    }
    if (((v60 | v61 | (a3 - v67) | (a2 - v66)) & 0x8000000000000000) != 0)
    {
      v69 += v58 + 1;
      int v35 = ~v58 + v63;
      goto LABEL_36;
    }
    unint64_t v30 = v70 + SHIDWORD(a3) * (uint64_t)v72 + 8 * (a2 >> 32);
    uint64_t v31 = *(unsigned __int16 **)(a1 + 32);
    uint64_t v62 = (unsigned __int16 *)v73;
    if (v73 >= v30) {
      uint64_t v62 = (unsigned __int16 *)(v70 + SHIDWORD(a3) * (uint64_t)v72 + 8 * (a2 >> 32));
    }
    if (v62 < v31) {
      uint64_t v62 = *(unsigned __int16 **)(a1 + 32);
    }
    unint64_t v33 = ((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16);
    if (v6)
    {
      unsigned int v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v69 += v58 + 1;
        int v12 = ~v58 + v63;
        unsigned int v20 = -1;
        goto LABEL_39;
      }
    }
    ++v58;
    v7 += 4;
    a3 += v74;
    v60 -= v74;
    a2 += v75;
    v61 -= v75;
    unsigned int v20 = -1;
  }
}

void RGBAf_sample_rgba64(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v68 = *(void *)(a1 + 80);
  uint64_t v71 = *(void *)(a1 + 88);
  uint64_t v78 = *(void *)(a1 + 112);
  uint64_t v77 = *(void *)(a1 + 120);
  int v67 = *(_DWORD *)(a1 + 188);
  uint64_t v7 = (float *)(*(void *)(a1 + 152) - 16);
  uint64_t v72 = *(void *)(a1 + 144) - 1;
  unint64_t v8 = 0xFFFF000000000000;
  if (*(void *)(a1 + 40)) {
    unint64_t v8 = 0;
  }
  unint64_t v74 = v8;
  int v75 = *(_DWORD *)(a1 + 24);
  uint64_t v73 = *(void *)(a1 + 32);
  unint64_t v76 = v73 + ((*(_DWORD *)(a1 + 260) - 1) * v75) + 8 * (*(_DWORD *)(a1 + 256) - 1) - 8;
  uint64_t v69 = *(void *)(a1 + 64);
  uint64_t v70 = *(void *)(a1 + 72);
  while (1)
  {
    if ((uint64_t)a3 >= v70)
    {
      if ((uint64_t)a3 <= v71)
      {
        uint64_t v19 = (a3 >> 22) & 0x3C0;
        unsigned int v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        int v12 = a4;
        uint64_t v13 = v69;
      }
      else
      {
        uint64_t v15 = *(void *)(a1 + 216);
        uint64_t v16 = *(void *)(a1 + 224) + v71;
        uint64_t v17 = v16 - a3 + (v15 >> 1);
        int v12 = a4;
        uint64_t v13 = v69;
        if (v17 < 1) {
          goto LABEL_35;
        }
        if (v17 >= v15) {
          LODWORD(v18) = 0x3FFFFFFF;
        }
        else {
          unint64_t v18 = (unint64_t)(*(void *)(a1 + 232) * v17) >> 32;
        }
        unsigned int v20 = v18 | v67;
        uint64_t v21 = v16 - 0x1000000;
        uint64_t v19 = 448;
      }
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 216);
      uint64_t v10 = v70 - *(void *)(a1 + 224);
      uint64_t v11 = a3 - v10 + (v9 >> 1);
      int v12 = a4;
      uint64_t v13 = v69;
      if (v11 < 1) {
        goto LABEL_35;
      }
      if (v11 >= v9) {
        LODWORD(v14) = 0x3FFFFFFF;
      }
      else {
        unint64_t v14 = (unint64_t)(*(void *)(a1 + 232) * v11) >> 32;
      }
      unsigned int v20 = v14 | v67;
      uint64_t v21 = v10 + 0x1000000;
      uint64_t v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v68)
      {
        uint64_t v26 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v25 = a2;
      }
      else
      {
        uint64_t v27 = *(void *)(a1 + 192);
        uint64_t v28 = *(void *)(a1 + 200) + v68;
        uint64_t v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1) {
          goto LABEL_35;
        }
        if (v29 < v27) {
          unsigned int v20 = ((v20 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v29) >> 32) >> 15)) | v67;
        }
        uint64_t v25 = v28 - 0x1000000;
        uint64_t v26 = 28;
      }
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 192);
      uint64_t v23 = v13 - *(void *)(a1 + 200);
      uint64_t v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_35;
      }
      if (v24 < v22) {
        unsigned int v20 = ((v20 >> 15) * (((unint64_t)(*(void *)(a1 + 208) * v24) >> 32) >> 15)) | v67;
      }
      uint64_t v25 = v23 + 0x1000000;
      uint64_t v26 = 32;
    }
    if (v20 >= 0x400000) {
      break;
    }
LABEL_35:
    int v35 = v12 - 1;
    a2 += v78;
    a3 += v77;
    v7 += 4;
    *(unsigned char *)++uint64_t v72 = 0;
LABEL_36:
    a4 = v35;
    if (!v35) {
      return;
    }
  }
  unint64_t v30 = v73 + SHIDWORD(v21) * (uint64_t)v75 + 8 * (v25 >> 32);
  uint64_t v31 = *(unint64_t **)(a1 + 32);
  unint64_t v32 = (unint64_t *)v76;
  if (v76 >= v30) {
    unint64_t v32 = (unint64_t *)v30;
  }
  if (v32 < v31) {
    unint64_t v32 = *(unint64_t **)(a1 + 32);
  }
  unint64_t v33 = *v32;
  if (!v6) {
    goto LABEL_68;
  }
  unsigned int v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_39:
  int v36 = v34 & 0xF;
  int v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      unint64_t v54 = (unint64_t *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 < (unint64_t)v54) {
        unint64_t v54 = (unint64_t *)v76;
      }
      if (v54 >= v31) {
        uint64_t v31 = v54;
      }
      unint64_t v55 = interpolate_16161616_21355[v37];
      char v56 = v37 + 1;
      unint64_t v52 = v33 - ((v55 & v33) >> v56);
      unint64_t v57 = (v55 & *v31) >> v56;
LABEL_67:
      unint64_t v33 = v52 + v57;
      break;
    case 2:
      uint64_t v58 = (unint64_t *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 53));
      if (v76 < (unint64_t)v58) {
        uint64_t v58 = (unint64_t *)v76;
      }
      if (v58 >= v31) {
        uint64_t v31 = v58;
      }
      int v59 = (v34 >> 28) & 3;
      uint64_t v60 = interpolate_16161616_21355[v59];
      char v51 = v59 + 1;
      unint64_t v52 = v33 - ((v60 & v33) >> v51);
      unint64_t v53 = v60 & *v31;
LABEL_66:
      unint64_t v57 = v53 >> v51;
      goto LABEL_67;
    case 3:
      int64_t v38 = (unint64_t)HIWORD(v34) << 56;
      unsigned int v39 = (unint64_t *)(v30 + (v38 >> 53));
      if (v76 < (unint64_t)v39) {
        unsigned int v39 = (unint64_t *)v76;
      }
      if (v39 < v31) {
        unsigned int v39 = v31;
      }
      unint64_t v40 = *v39;
      unint64_t v41 = (unint64_t *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 >= (unint64_t)v41) {
        int v42 = v41;
      }
      else {
        int v42 = (unint64_t *)v76;
      }
      if (v42 < v31) {
        int v42 = v31;
      }
      unint64_t v43 = *v42;
      char v44 = (unint64_t *)((char *)v41 + (v38 >> 53));
      if (v76 < (unint64_t)v44) {
        char v44 = (unint64_t *)v76;
      }
      if (v44 >= v31) {
        uint64_t v31 = v44;
      }
      unint64_t v45 = interpolate_16161616_21355[v37];
      char v46 = v37 + 1;
      unint64_t v47 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      unint64_t v48 = v40 - ((v45 & v40) >> v46) + ((v45 & *v31) >> v46);
      int v49 = (v34 >> 28) & 3;
      unint64_t v50 = interpolate_16161616_21355[v49];
      char v51 = v49 + 1;
      unint64_t v52 = v47 - ((v47 & v50) >> v51);
      unint64_t v53 = v48 & v50;
      goto LABEL_66;
  }
LABEL_68:
  uint64_t v61 = 0;
  v7 += 4;
  int v66 = v12;
  int v62 = v12 - 1;
  a3 += v77;
  uint64_t v63 = v71 - a3;
  a2 += v78;
  uint64_t v64 = v68 - a2;
  while (1)
  {
    RGBA64(v7, v33 | v74);
    *(unsigned char *)(v72 + 1 + v61) = v20 >> 22;
    if (v62 == v61) {
      break;
    }
    if (((v63 | v64 | (a3 - v70) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v72 += v61 + 1;
      int v35 = ~v61 + v66;
      goto LABEL_36;
    }
    unint64_t v30 = v73 + SHIDWORD(a3) * (uint64_t)v75 + 8 * (a2 >> 32);
    uint64_t v31 = *(unint64_t **)(a1 + 32);
    uint64_t v65 = (unint64_t *)v76;
    if (v76 >= v30) {
      uint64_t v65 = (unint64_t *)(v73 + SHIDWORD(a3) * (uint64_t)v75 + 8 * (a2 >> 32));
    }
    if (v65 < v31) {
      uint64_t v65 = *(unint64_t **)(a1 + 32);
    }
    unint64_t v33 = *v65;
    if (v6)
    {
      unsigned int v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v72 += v61 + 1;
        int v12 = ~v61 + v66;
        unsigned int v20 = -1;
        goto LABEL_39;
      }
    }
    v7 += 4;
    ++v61;
    a3 += v77;
    v63 -= v77;
    a2 += v78;
    v64 -= v78;
    unsigned int v20 = -1;
  }
}

uint64_t RGBAf_sample_WF(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v86 = *(void *)(result + 80);
  uint64_t v87 = *(void *)(result + 64);
  uint64_t v88 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = (float *)(*(void *)(result + 152) - 16);
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v13 = *(_DWORD *)(result + 260) - 1;
  unsigned int v14 = *(_DWORD *)(result + 256) - 1;
  unint64_t v15 = v5 + (v13 * v7) + 4 * v14;
  int v85 = *(_DWORD *)(result + 188);
  unint64_t v16 = v4 + (v13 * v6) + 4 * v14 - 4;
  uint64_t v89 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v89)
      {
        if (a3 <= v88)
        {
          uint64_t v25 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v26 = 0x3FFFFFFF;
          uint64_t v27 = a3;
          uint64_t v28 = v87;
        }
        else
        {
          uint64_t v21 = *(void *)(result + 216);
          uint64_t v22 = *(void *)(result + 224) + v88;
          uint64_t v23 = v22 - a3 + (v21 >> 1);
          if (v23 < 1) {
            goto LABEL_39;
          }
          if (v23 >= v21) {
            LODWORD(v24) = 0x3FFFFFFF;
          }
          else {
            unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
          }
          uint64_t v28 = v87;
          unsigned int v26 = v24 | v85;
          uint64_t v27 = v22 - 0x1000000;
          uint64_t v25 = 448;
        }
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = v89 - *(void *)(result + 224);
        uint64_t v19 = a3 - v18 + (v17 >> 1);
        if (v19 < 1) {
          goto LABEL_39;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        uint64_t v28 = v87;
        unsigned int v26 = v20 | v85;
        uint64_t v27 = v18 + 0x1000000;
        uint64_t v25 = 512;
      }
      if (a2 >= v28) {
        break;
      }
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v28 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 >= 1)
      {
        if (v31 < v29) {
          unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v85;
        }
        uint64_t v32 = v30 + 0x1000000;
        uint64_t v33 = 32;
        goto LABEL_26;
      }
LABEL_39:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 4;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v86)
    {
      uint64_t v33 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v32 = a2;
      goto LABEL_26;
    }
    uint64_t v34 = *(void *)(result + 192);
    uint64_t v35 = *(void *)(result + 200) + v86;
    uint64_t v36 = v35 - a2 + (v34 >> 1);
    if (v36 < 1) {
      goto LABEL_39;
    }
    if (v36 < v34) {
      unsigned int v26 = ((v26 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v85;
    }
    uint64_t v32 = v35 - 0x1000000;
    uint64_t v33 = 28;
LABEL_26:
    if (v26 < 0x400000) {
      goto LABEL_39;
    }
    uint64_t v37 = v27 >> 32;
    uint64_t v38 = v4 + SHIDWORD(v27) * (uint64_t)v6;
    unint64_t v39 = (v32 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v40 = v38 + v39;
    unint64_t v41 = *(unsigned int **)(result + 32);
    if (v16 >= v38 + v39) {
      int v42 = (unsigned int *)(v38 + v39);
    }
    else {
      int v42 = (unsigned int *)v16;
    }
    if (v42 < v41) {
      int v42 = *(unsigned int **)(result + 32);
    }
    if (v5)
    {
      unint64_t v43 = v5 + (int)v37 * (uint64_t)v7 + v39;
      char v44 = *(unsigned int **)(result + 40);
      if (v15 >= v43) {
        unint64_t v45 = (unsigned int *)v43;
      }
      else {
        unint64_t v45 = (unsigned int *)v15;
      }
      if (v45 >= v44) {
        char v44 = v45;
      }
      float v46 = COERCE_FLOAT(bswap32(*v44));
    }
    else
    {
      unint64_t v43 = 0;
      float v46 = 1.0;
    }
    float v47 = COERCE_FLOAT(bswap32(*v42));
    if (!v8) {
      goto LABEL_92;
    }
    unsigned int v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_45:
    int v49 = v48 & 0xF;
    int v50 = HIBYTE(v48) & 3;
    if (v49 == 1)
    {
      uint64_t v64 = (unsigned int *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v64) {
        uint64_t v64 = (unsigned int *)v16;
      }
      if (v64 < v41) {
        uint64_t v64 = v41;
      }
      float v65 = COERCE_FLOAT(bswap32(*v64));
      float v66 = 1.0;
      if (v5)
      {
        int v67 = (unsigned int *)(v43 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v67) {
          int v67 = (unsigned int *)v15;
        }
        if ((unint64_t)v67 < *(void *)(result + 40)) {
          int v67 = *(unsigned int **)(result + 40);
        }
        float v66 = COERCE_FLOAT(bswap32(*v67));
      }
      uint64_t v68 = &interpolate_waf[2 * v50];
    }
    else
    {
      if (v49 != 2)
      {
        if (v49 == 3)
        {
          unint64_t v51 = v40 + 4 * SBYTE2(v48);
          if (v16 >= v51) {
            unint64_t v52 = (unsigned int *)(v40 + 4 * SBYTE2(v48));
          }
          else {
            unint64_t v52 = (unsigned int *)v16;
          }
          if (v52 < v41) {
            unint64_t v52 = v41;
          }
          float v53 = COERCE_FLOAT(bswap32(*v52));
          unint64_t v54 = (unsigned int *)(v51 + SBYTE1(v48) * (uint64_t)v6);
          if (v16 < (unint64_t)v54) {
            unint64_t v54 = (unsigned int *)v16;
          }
          if (v54 < v41) {
            unint64_t v54 = v41;
          }
          float v55 = COERCE_FLOAT(bswap32(*v54));
          float v56 = 1.0;
          float v57 = 1.0;
          if (v5)
          {
            unint64_t v58 = v43 + 4 * SBYTE2(v48);
            unint64_t v59 = *(void *)(result + 40);
            if (v15 >= v58) {
              uint64_t v60 = (unsigned int *)(v43 + 4 * SBYTE2(v48));
            }
            else {
              uint64_t v60 = (unsigned int *)v15;
            }
            if ((unint64_t)v60 < v59) {
              uint64_t v60 = *(unsigned int **)(result + 40);
            }
            float v57 = COERCE_FLOAT(bswap32(*v60));
            uint64_t v61 = (unsigned int *)(v58 + SBYTE1(v48) * (uint64_t)v7);
            if (v15 < (unint64_t)v61) {
              uint64_t v61 = (unsigned int *)v15;
            }
            if ((unint64_t)v61 < v59) {
              uint64_t v61 = *(unsigned int **)(result + 40);
            }
            float v56 = COERCE_FLOAT(bswap32(*v61));
          }
          float v62 = interpolate_waf[2 * v50 + 1];
          float v63 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
          float v47 = (float)((float)((float)(v47 - (float)(v47 * v62)) + (float)(v53 * v62))
                      - (float)((float)((float)(v47 - (float)(v47 * v62)) + (float)(v53 * v62)) * v63))
              + (float)((float)((float)(v53 - (float)(v53 * v62)) + (float)(v55 * v62)) * v63);
          float v46 = (float)((float)((float)(v46 - (float)(v46 * v62)) + (float)(v57 * v62))
                      - (float)((float)((float)(v46 - (float)(v46 * v62)) + (float)(v57 * v62)) * v63))
              + (float)((float)((float)(v57 - (float)(v57 * v62)) + (float)(v56 * v62)) * v63);
        }
        goto LABEL_92;
      }
      uint64_t v69 = (unsigned int *)(v40 + 4 * SBYTE2(v48));
      if (v16 < (unint64_t)v69) {
        uint64_t v69 = (unsigned int *)v16;
      }
      if (v69 < v41) {
        uint64_t v69 = v41;
      }
      float v65 = COERCE_FLOAT(bswap32(*v69));
      float v66 = 1.0;
      if (v5)
      {
        uint64_t v70 = (unsigned int *)(v43 + 4 * SBYTE2(v48));
        if (v15 < (unint64_t)v70) {
          uint64_t v70 = (unsigned int *)v15;
        }
        if ((unint64_t)v70 < *(void *)(result + 40)) {
          uint64_t v70 = *(unsigned int **)(result + 40);
        }
        float v66 = COERCE_FLOAT(bswap32(*v70));
      }
      uint64_t v68 = &interpolate_waf[2 * ((v48 >> 28) & 3)];
    }
    float v71 = v68[1];
    float v47 = (float)(v47 - (float)(v47 * v71)) + (float)(v65 * v71);
    float v46 = (float)(v46 - (float)(v46 * v71)) + (float)(v66 * v71);
LABEL_92:
    v11[4] = v47;
    v11[5] = v47;
    v11[6] = v47;
    v11[7] = v46;
    *(unsigned char *)(v12 + 1) = v26 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v72 = 0;
    uint64_t v73 = v11 + 11;
    int v74 = a4 - 1;
    a2 += v10;
    uint64_t v75 = v86 - a2;
    a3 += v9;
    uint64_t v76 = v88 - a3;
    --a4;
    while (1)
    {
      uint64_t v77 = v12 + v72 + 1;
      uint64_t v11 = v73 - 7;
      if (((a2 - v87) | v75 | (a3 - v89) | v76) < 0) {
        break;
      }
      uint64_t v78 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      unint64_t v79 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v40 = v78 + v79;
      unint64_t v41 = *(unsigned int **)(result + 32);
      if (v16 >= v78 + v79) {
        int v80 = (unsigned int *)(v78 + v79);
      }
      else {
        int v80 = (unsigned int *)v16;
      }
      if (v80 < v41) {
        int v80 = *(unsigned int **)(result + 32);
      }
      if (v5)
      {
        unint64_t v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v79;
        BOOL v81 = *(unsigned int **)(result + 40);
        if (v15 >= v43) {
          uint64_t v82 = (unsigned int *)v43;
        }
        else {
          uint64_t v82 = (unsigned int *)v15;
        }
        if (v82 >= v81) {
          BOOL v81 = v82;
        }
        float v46 = COERCE_FLOAT(bswap32(*v81));
      }
      else
      {
        float v46 = 1.0;
      }
      unsigned int v83 = bswap32(*v80);
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          float v47 = *(float *)&v83;
          unsigned int v26 = -1;
          uint64_t v12 = v77;
          goto LABEL_45;
        }
      }
      --a4;
      *((_DWORD *)v73 - 2) = v83;
      *((_DWORD *)v73 - 1) = v83;
      uint64_t v84 = v12 + v72++;
      *((_DWORD *)v73 - 3) = v83;
      *uint64_t v73 = v46;
      v73 += 4;
      a2 += v10;
      v75 -= v10;
      a3 += v9;
      v76 -= v9;
      *(unsigned char *)(v84 + 2) = -1;
      if (v74 == v72) {
        return result;
      }
    }
    v12 += v72 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_Wf(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 72);
  uint64_t v85 = *(void *)(result + 80);
  uint64_t v86 = *(void *)(result + 64);
  uint64_t v87 = *(void *)(result + 88);
  uint64_t v11 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v12 = (float *)(*(void *)(result + 152) - 16);
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v14 = *(_DWORD *)(result + 260) - 1;
  unsigned int v15 = *(_DWORD *)(result + 256) - 1;
  unint64_t v16 = v5 + (v14 * v7) + 4 * v15;
  int v84 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + (v14 * v6) + 4 * v15 - 4;
  do
  {
    while (1)
    {
      if (a3 >= v9)
      {
        if (a3 <= v87)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v86;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v87;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_40;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v86;
          unsigned int v27 = v25 | v84;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v9 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_40;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v86;
        unsigned int v27 = v21 | v84;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v84;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_26;
      }
LABEL_40:
      --a4;
      a2 += v11;
      a3 += v10;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v85)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_26;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v85;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_40;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v84;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_26:
    if (v27 < 0x400000) {
      goto LABEL_40;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v4 + SHIDWORD(v28) * (uint64_t)v6;
    unint64_t v40 = (v33 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v41 = v39 + v40;
    int v42 = *(float **)(result + 32);
    if (v17 >= v39 + v40) {
      unint64_t v43 = (float *)(v39 + v40);
    }
    else {
      unint64_t v43 = (float *)v17;
    }
    if (v43 >= v42) {
      char v44 = v43;
    }
    else {
      char v44 = *(float **)(result + 32);
    }
    if (v5)
    {
      unint64_t v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      float v46 = *(float **)(result + 40);
      if (v16 >= v45) {
        float v47 = (float *)v45;
      }
      else {
        float v47 = (float *)v16;
      }
      if (v47 >= v46) {
        float v46 = v47;
      }
      float v48 = *v46;
    }
    else
    {
      unint64_t v45 = 0;
      float v48 = 1.0;
    }
    float v49 = *v44;
    if (!v8) {
      goto LABEL_93;
    }
    unsigned int v50 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_46:
    int v51 = v50 & 0xF;
    int v52 = HIBYTE(v50) & 3;
    if (v51 == 1)
    {
      float v66 = (float *)(v41 + SBYTE1(v50) * (uint64_t)v6);
      if (v17 < (unint64_t)v66) {
        float v66 = (float *)v17;
      }
      if (v66 < v42) {
        float v66 = v42;
      }
      float v67 = *v66;
      float v68 = 1.0;
      if (v5)
      {
        uint64_t v69 = (float *)(v45 + SBYTE1(v50) * (uint64_t)v7);
        if (v16 < (unint64_t)v69) {
          uint64_t v69 = (float *)v16;
        }
        if ((unint64_t)v69 < *(void *)(result + 40)) {
          uint64_t v69 = *(float **)(result + 40);
        }
        float v68 = *v69;
      }
      uint64_t v70 = &interpolate_waf[2 * v52];
    }
    else
    {
      if (v51 != 2)
      {
        if (v51 == 3)
        {
          unint64_t v53 = v41 + 4 * SBYTE2(v50);
          if (v17 >= v53) {
            unint64_t v54 = (float *)(v41 + 4 * SBYTE2(v50));
          }
          else {
            unint64_t v54 = (float *)v17;
          }
          if (v54 < v42) {
            unint64_t v54 = v42;
          }
          float v55 = *v54;
          float v56 = (float *)(v53 + SBYTE1(v50) * (uint64_t)v6);
          if (v17 < (unint64_t)v56) {
            float v56 = (float *)v17;
          }
          if (v56 < v42) {
            float v56 = v42;
          }
          float v57 = *v56;
          float v58 = 1.0;
          float v59 = 1.0;
          if (v5)
          {
            unint64_t v60 = v45 + 4 * SBYTE2(v50);
            unint64_t v61 = *(void *)(result + 40);
            if (v16 >= v60) {
              float v62 = (float *)(v45 + 4 * SBYTE2(v50));
            }
            else {
              float v62 = (float *)v16;
            }
            if ((unint64_t)v62 < v61) {
              float v62 = *(float **)(result + 40);
            }
            float v58 = *v62;
            float v63 = (float *)(v60 + SBYTE1(v50) * (uint64_t)v7);
            if (v16 < (unint64_t)v63) {
              float v63 = (float *)v16;
            }
            if ((unint64_t)v63 < v61) {
              float v63 = *(float **)(result + 40);
            }
            float v59 = *v63;
          }
          float v64 = interpolate_waf[2 * v52 + 1];
          float v65 = interpolate_waf[2 * ((v50 >> 28) & 3) + 1];
          float v49 = (float)((float)((float)(v49 - (float)(v49 * v64)) + (float)(v55 * v64))
                      - (float)((float)((float)(v49 - (float)(v49 * v64)) + (float)(v55 * v64)) * v65))
              + (float)((float)((float)(v55 - (float)(v55 * v64)) + (float)(v57 * v64)) * v65);
          float v48 = (float)((float)((float)(v48 - (float)(v48 * v64)) + (float)(v58 * v64))
                      - (float)((float)((float)(v48 - (float)(v48 * v64)) + (float)(v58 * v64)) * v65))
              + (float)((float)((float)(v58 - (float)(v58 * v64)) + (float)(v59 * v64)) * v65);
        }
        goto LABEL_93;
      }
      float v71 = (float *)(v41 + 4 * SBYTE2(v50));
      if (v17 < (unint64_t)v71) {
        float v71 = (float *)v17;
      }
      if (v71 < v42) {
        float v71 = v42;
      }
      float v67 = *v71;
      float v68 = 1.0;
      if (v5)
      {
        uint64_t v72 = (float *)(v45 + 4 * SBYTE2(v50));
        if (v16 < (unint64_t)v72) {
          uint64_t v72 = (float *)v16;
        }
        if ((unint64_t)v72 < *(void *)(result + 40)) {
          uint64_t v72 = *(float **)(result + 40);
        }
        float v68 = *v72;
      }
      uint64_t v70 = &interpolate_waf[2 * ((v50 >> 28) & 3)];
    }
    float v73 = v70[1];
    float v49 = (float)(v49 - (float)(v49 * v73)) + (float)(v67 * v73);
    float v48 = (float)(v48 - (float)(v48 * v73)) + (float)(v68 * v73);
LABEL_93:
    v12[4] = v49;
    v12[5] = v49;
    v12[6] = v49;
    v12[7] = v48;
    *(unsigned char *)(v13 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v74 = 0;
    uint64_t v75 = v12 + 11;
    a3 += v10;
    uint64_t v76 = v87 - a3;
    a2 += v11;
    uint64_t v77 = v85 - a2;
    while ((((a2 - v86) | v77 | (a3 - v9) | v76) & 0x8000000000000000) == 0)
    {
      uint64_t v78 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      unint64_t v79 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v41 = v78 + v79;
      int v42 = *(float **)(result + 32);
      if (v17 >= v78 + v79) {
        int v80 = (float *)(v78 + v79);
      }
      else {
        int v80 = (float *)v17;
      }
      if (v80 < v42) {
        int v80 = *(float **)(result + 32);
      }
      if (v5)
      {
        unint64_t v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v79;
        BOOL v81 = *(float **)(result + 40);
        if (v16 >= v45) {
          uint64_t v82 = (float *)v45;
        }
        else {
          uint64_t v82 = (float *)v16;
        }
        if (v82 >= v81) {
          BOOL v81 = v82;
        }
        float v48 = *v81;
      }
      else
      {
        float v48 = 1.0;
      }
      float v49 = *v80;
      if (v8)
      {
        unsigned int v50 = *(_DWORD *)(v8 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v50 & 0xF) != 0)
        {
          v13 += v74 + 1;
          uint64_t v12 = v75 - 7;
          a4 += ~v74;
          unsigned int v27 = -1;
          goto LABEL_46;
        }
      }
      *(v75 - 2) = v49;
      *(v75 - 1) = v49;
      uint64_t v83 = v13 + v74++;
      *(v75 - 3) = v49;
      *uint64_t v75 = v48;
      v75 += 4;
      v76 -= v10;
      a2 += v11;
      v77 -= v11;
      a3 += v10;
      *(unsigned char *)(v83 + 2) = -1;
      if (a4 - 1 == v74) {
        return result;
      }
    }
    v13 += v74 + 1;
    uint64_t v12 = v75 - 7;
    a4 += ~v74;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBF(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v11 = *(void *)(result + 32);
  int v12 = *(_DWORD *)(result + 24);
  uint64_t v13 = *(void *)(result + 176);
  uint64_t v14 = *(void *)(result + 72);
  uint64_t v70 = *(void *)(result + 88);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v15 = *(void *)(result + 112);
  uint64_t v16 = *(void *)(result + 120);
  uint64_t v17 = *(void *)(result + 152) - 16;
  uint64_t v18 = *(void *)(result + 144) - 1;
  unint64_t v19 = v11
      + ((*(_DWORD *)(result + 260) - 1) * v12)
      + 4 * (3 * *(_DWORD *)(result + 256) - 3)
      - 12;
  uint64_t v69 = *(void *)(result + 64);
  int v68 = *(_DWORD *)(result + 188);
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v14)
      {
        if ((uint64_t)a3 <= v70)
        {
          uint64_t v28 = (a3 >> 22) & 0x3C0;
          unsigned int v29 = 0x3FFFFFFF;
          HIDWORD(v30) = HIDWORD(a3);
        }
        else
        {
          uint64_t v24 = *(void *)(result + 216);
          uint64_t v25 = *(void *)(result + 224) + v70;
          uint64_t v26 = v25 - a3 + (v24 >> 1);
          if (v26 < 1) {
            goto LABEL_34;
          }
          if (v26 >= v24) {
            LODWORD(v27) = 0x3FFFFFFF;
          }
          else {
            unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
          }
          unsigned int v29 = v27 | v68;
          uint64_t v30 = v25 - 0x1000000;
          uint64_t v28 = 448;
        }
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = v14 - *(void *)(result + 224);
        uint64_t v22 = a3 - v21 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_34;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        unsigned int v29 = v23 | v68;
        uint64_t v30 = v21 + 0x1000000;
        uint64_t v28 = 512;
      }
      if (a2 >= v69) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v69 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v68;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v15;
      a3 += v16;
      v17 += 16;
      *(unsigned char *)++uint64_t v18 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v71)
    {
      uint64_t v35 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_26;
    }
    uint64_t v36 = *(void *)(result + 192);
    uint64_t v37 = *(void *)(result + 200) + v71;
    uint64_t v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1) {
      goto LABEL_34;
    }
    if (v38 < v36) {
      unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v38) >> 32) >> 15)) | v68;
    }
    uint64_t v34 = v37 - 0x1000000;
    uint64_t v35 = 28;
LABEL_26:
    if (v29 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v39 = v34 >> 32;
    uint64_t v40 = v11 + SHIDWORD(v30) * (uint64_t)v12;
    unint64_t v41 = v40 + 12 * (int)v39;
    int v42 = *(int8x8_t **)(result + 32);
    if (v19 >= v41) {
      unint64_t v43 = (int8x8_t *)(v40 + 12 * (int)v39);
    }
    else {
      unint64_t v43 = (int8x8_t *)v19;
    }
    if (v43 < v42) {
      unint64_t v43 = *(int8x8_t **)(result + 32);
    }
    float32x2_t v44 = (float32x2_t)vrev32_s8(*v43);
    float v45 = COERCE_FLOAT(bswap32(v43[1].u32[0]));
    if (v13)
    {
      unsigned int v46 = *(_DWORD *)(v13 + (v35 | v28));
LABEL_38:
      int v48 = v46 & 0xF;
      int v49 = HIBYTE(v46) & 3;
      switch(v48)
      {
        case 1:
          float v56 = (int8x8_t *)(v41 + SBYTE1(v46) * (uint64_t)v12);
          if (v19 < (unint64_t)v56) {
            float v56 = (int8x8_t *)v19;
          }
          if (v56 < v42) {
            float v56 = v42;
          }
          float v57 = COERCE_FLOAT(bswap32(v56[1].u32[0]));
          break;
        case 2:
          float v56 = (int8x8_t *)(v41 + 12 * SBYTE2(v46));
          if (v19 < (unint64_t)v56) {
            float v56 = (int8x8_t *)v19;
          }
          if (v56 < v42) {
            float v56 = v42;
          }
          float v57 = COERCE_FLOAT(bswap32(v56[1].u32[0]));
          int v49 = (v46 >> 28) & 3;
          break;
        case 3:
          unint64_t v50 = v41 + 12 * SBYTE2(v46);
          if (v19 >= v50) {
            int v51 = (int8x8_t *)(v41 + 12 * SBYTE2(v46));
          }
          else {
            int v51 = (int8x8_t *)v19;
          }
          if (v51 < v42) {
            int v51 = v42;
          }
          float v52 = COERCE_FLOAT(bswap32(v51[1].u32[0]));
          unint64_t v53 = (int8x8_t *)(v50 + SBYTE1(v46) * (uint64_t)v12);
          if (v19 < (unint64_t)v53) {
            unint64_t v53 = (int8x8_t *)v19;
          }
          if (v53 < v42) {
            unint64_t v53 = v42;
          }
          LODWORD(a10) = interpolate_rgbaf_21353[4 * v49 + 3];
          LODWORD(a11) = interpolate_rgbaf_21353[4 * ((v46 >> 28) & 3) + 3];
          float v45 = (float)((float)((float)(v45 - (float)(v45 * *(float *)&a10)) + (float)(v52 * *(float *)&a10))
                      - (float)((float)((float)(v45 - (float)(v45 * *(float *)&a10)) + (float)(v52 * *(float *)&a10))
                              * *(float *)&a11))
              + (float)((float)((float)(v52 - (float)(v52 * *(float *)&a10))
                              + (float)(COERCE_FLOAT(bswap32(v53[1].u32[0])) * *(float *)&a10))
                      * *(float *)&a11);
          float32x2_t v54 = (float32x2_t)vrev32_s8(*v51);
          float32x2_t v55 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a10, 0), v54, *(float *)&a10);
          a9 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v54, v54, *(float32x2_t *)&a10, 0), (float32x2_t)vrev32_s8(*v53), *(float *)&a10));
          float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v55, v55, *(float32x2_t *)&a11, 0), *(float32x2_t *)&a9, *(float *)&a11);
          float v47 = (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10))
                      - (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11))
              + (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      LODWORD(a9) = interpolate_rgbaf_21353[4 * v49 + 3];
      a10 = COERCE_DOUBLE(vrev32_s8(*v56));
      float32x2_t v44 = vmla_n_f32(vmls_lane_f32(v44, v44, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a10, *(float *)&a9);
      float v45 = (float)(v45 - (float)(v45 * *(float *)&a9)) + (float)(v57 * *(float *)&a9);
      float v47 = *(float *)&a9 + (float)(1.0 - *(float *)&a9);
      goto LABEL_62;
    }
LABEL_36:
    float v47 = 1.0;
LABEL_62:
    *(float32x2_t *)(v17 + 16) = v44;
    *(float *)(v17 + 24) = v45;
    *(float *)(v17 + 28) = v47;
    *(unsigned char *)(v18 + 1) = v29 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v58 = 0;
    float v59 = (_DWORD *)(v17 + 44);
    a2 += v15;
    uint64_t v60 = v71 - a2;
    a3 += v16;
    uint64_t v61 = v70 - a3;
    int v62 = --a4;
    while (1)
    {
      uint64_t v63 = v18 + v58 + 1;
      uint64_t v17 = (uint64_t)(v59 - 7);
      if ((((a2 - v69) | v60 | (a3 - v14) | v61) & 0x8000000000000000) != 0) {
        break;
      }
      uint64_t v64 = v11 + SHIDWORD(a3) * (uint64_t)v12;
      unint64_t v41 = v64 + 12 * SHIDWORD(a2);
      int v42 = *(int8x8_t **)(result + 32);
      if (v19 >= v41) {
        float v65 = (int8x8_t *)(v64 + 12 * SHIDWORD(a2));
      }
      else {
        float v65 = (int8x8_t *)v19;
      }
      if (v65 < v42) {
        float v65 = *(int8x8_t **)(result + 32);
      }
      float32x2_t v44 = (float32x2_t)vrev32_s8(*v65);
      unsigned int v66 = bswap32(v65[1].u32[0]);
      if (v13)
      {
        unsigned int v46 = *(_DWORD *)(v13 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v46 & 0xF) != 0)
        {
          float v45 = *(float *)&v66;
          unsigned int v29 = -1;
          uint64_t v18 = v63;
          goto LABEL_38;
        }
      }
      --a4;
      *(float32x2_t *)(v59 - 3) = v44;
      *(v59 - 1) = v66;
      *float v59 = 1065353216;
      uint64_t v67 = v18 + v58++;
      v59 += 4;
      a2 += v15;
      *(unsigned char *)(v67 + 2) = -1;
      v60 -= v15;
      a3 += v16;
      v61 -= v16;
      if (v62 == v58) {
        return result;
      }
    }
    v18 += v58 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBf(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v11 = *(void *)(result + 32);
  int v12 = *(_DWORD *)(result + 24);
  uint64_t v13 = *(void *)(result + 176);
  uint64_t v14 = *(void *)(result + 64);
  uint64_t v15 = *(void *)(result + 72);
  uint64_t v16 = *(void *)(result + 80);
  uint64_t v17 = *(void *)(result + 88);
  uint64_t v18 = *(void *)(result + 112);
  uint64_t v19 = *(void *)(result + 120);
  uint64_t v20 = *(void *)(result + 152) - 16;
  uint64_t v21 = *(void *)(result + 144) - 1;
  unint64_t v22 = v11
      + ((*(_DWORD *)(result + 260) - 1) * v12)
      + 4 * (3 * *(_DWORD *)(result + 256) - 3)
      - 12;
  int v66 = *(_DWORD *)(result + 188);
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v15)
      {
        if ((uint64_t)a3 <= v17)
        {
          uint64_t v31 = (a3 >> 22) & 0x3C0;
          unsigned int v32 = 0x3FFFFFFF;
          HIDWORD(v33) = HIDWORD(a3);
        }
        else
        {
          uint64_t v27 = *(void *)(result + 216);
          uint64_t v28 = *(void *)(result + 224) + v17;
          uint64_t v29 = v28 - a3 + (v27 >> 1);
          if (v29 < 1) {
            goto LABEL_34;
          }
          if (v29 >= v27) {
            LODWORD(v30) = 0x3FFFFFFF;
          }
          else {
            unint64_t v30 = (unint64_t)(*(void *)(result + 232) * v29) >> 32;
          }
          unsigned int v32 = v30 | v66;
          uint64_t v33 = v28 - 0x1000000;
          uint64_t v31 = 448;
        }
      }
      else
      {
        uint64_t v23 = *(void *)(result + 216);
        uint64_t v24 = v15 - *(void *)(result + 224);
        uint64_t v25 = a3 - v24 + (v23 >> 1);
        if (v25 < 1) {
          goto LABEL_34;
        }
        if (v25 >= v23) {
          LODWORD(v26) = 0x3FFFFFFF;
        }
        else {
          unint64_t v26 = (unint64_t)(*(void *)(result + 232) * v25) >> 32;
        }
        unsigned int v32 = v26 | v66;
        uint64_t v33 = v24 + 0x1000000;
        uint64_t v31 = 512;
      }
      if (a2 >= v14) {
        break;
      }
      uint64_t v34 = *(void *)(result + 192);
      uint64_t v35 = v14 - *(void *)(result + 200);
      uint64_t v36 = a2 - v35 + (v34 >> 1);
      if (v36 >= 1)
      {
        if (v36 < v34) {
          unsigned int v32 = ((v32 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v66;
        }
        uint64_t v37 = v35 + 0x1000000;
        uint64_t v38 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v18;
      a3 += v19;
      v20 += 16;
      *(unsigned char *)++uint64_t v21 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v16)
    {
      uint64_t v38 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v37 = a2;
      goto LABEL_26;
    }
    uint64_t v39 = *(void *)(result + 192);
    uint64_t v40 = *(void *)(result + 200) + v16;
    uint64_t v41 = v40 - a2 + (v39 >> 1);
    if (v41 < 1) {
      goto LABEL_34;
    }
    if (v41 < v39) {
      unsigned int v32 = ((v32 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v66;
    }
    uint64_t v37 = v40 - 0x1000000;
    uint64_t v38 = 28;
LABEL_26:
    if (v32 < 0x400000) {
      goto LABEL_34;
    }
    uint64_t v42 = v37 >> 32;
    uint64_t v43 = v11 + SHIDWORD(v33) * (uint64_t)v12;
    unint64_t v44 = v43 + 12 * (int)v42;
    float v45 = *(float32x2_t **)(result + 32);
    if (v22 >= v44) {
      unsigned int v46 = (float32x2_t *)(v43 + 12 * (int)v42);
    }
    else {
      unsigned int v46 = (float32x2_t *)v22;
    }
    if (v46 < v45) {
      unsigned int v46 = *(float32x2_t **)(result + 32);
    }
    float32x2_t v47 = *v46;
    float v48 = v46[1].f32[0];
    if (v13)
    {
      unsigned int v49 = *(_DWORD *)(v13 + (v38 | v31));
LABEL_38:
      int v51 = v49 & 0xF;
      int v52 = HIBYTE(v49) & 3;
      switch(v51)
      {
        case 1:
          unint64_t v57 = v44 + SBYTE1(v49) * (uint64_t)v12;
          if (v22 < v57) {
            unint64_t v57 = v22;
          }
          if (v57 < (unint64_t)v45) {
            unint64_t v57 = (unint64_t)v45;
          }
          float v58 = *(float *)(v57 + 8);
          LODWORD(a9) = interpolate_rgbaf_21353[4 * v52 + 3];
          a10 = *(double *)v57;
          break;
        case 2:
          unint64_t v59 = v44 + 12 * SBYTE2(v49);
          if (v22 < v59) {
            unint64_t v59 = v22;
          }
          if (v59 < (unint64_t)v45) {
            unint64_t v59 = (unint64_t)v45;
          }
          float v58 = *(float *)(v59 + 8);
          LODWORD(a9) = interpolate_rgbaf_21353[4 * ((v49 >> 28) & 3) + 3];
          a10 = *(double *)v59;
          break;
        case 3:
          unint64_t v53 = v44 + 12 * SBYTE2(v49);
          if (v22 >= v53) {
            float32x2_t v54 = (float32x2_t *)(v44 + 12 * SBYTE2(v49));
          }
          else {
            float32x2_t v54 = (float32x2_t *)v22;
          }
          if (v54 < v45) {
            float32x2_t v54 = v45;
          }
          float32x2_t v55 = (float32x2_t *)(v53 + SBYTE1(v49) * (uint64_t)v12);
          if (v22 < (unint64_t)v55) {
            float32x2_t v55 = (float32x2_t *)v22;
          }
          if (v55 < v45) {
            float32x2_t v55 = v45;
          }
          LODWORD(a10) = interpolate_rgbaf_21353[4 * v52 + 3];
          LODWORD(a11) = interpolate_rgbaf_21353[4 * ((v49 >> 28) & 3) + 3];
          float v48 = (float)((float)((float)(v48 - (float)(v48 * *(float *)&a10)) + (float)(v54[1].f32[0] * *(float *)&a10))
                      - (float)((float)((float)(v48 - (float)(v48 * *(float *)&a10))
                                      + (float)(v54[1].f32[0] * *(float *)&a10))
                              * *(float *)&a11))
              + (float)((float)((float)(v54[1].f32[0] - (float)(v54[1].f32[0] * *(float *)&a10))
                              + (float)(v55[1].f32[0] * *(float *)&a10))
                      * *(float *)&a11);
          float32x2_t v56 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a10, 0), *v54, *(float *)&a10);
          a9 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(*v54, *v54, *(float32x2_t *)&a10, 0), *v55, *(float *)&a10));
          float32x2_t v47 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), *(float32x2_t *)&a9, *(float *)&a11);
          float v50 = (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10))
                      - (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11))
              + (float)((float)(*(float *)&a10 + (float)(1.0 - *(float *)&a10)) * *(float *)&a11);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      float32x2_t v47 = vmla_n_f32(vmls_lane_f32(v47, v47, *(float32x2_t *)&a9, 0), *(float32x2_t *)&a10, *(float *)&a9);
      float v48 = (float)(v48 - (float)(v48 * *(float *)&a9)) + (float)(v58 * *(float *)&a9);
      float v50 = *(float *)&a9 + (float)(1.0 - *(float *)&a9);
      goto LABEL_62;
    }
LABEL_36:
    float v50 = 1.0;
LABEL_62:
    *(float32x2_t *)(v20 + 16) = v47;
    *(float *)(v20 + 24) = v48;
    *(float *)(v20 + 28) = v50;
    *(unsigned char *)(v21 + 1) = v32 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v60 = 0;
    uint64_t v61 = (float *)(v20 + 44);
    a2 += v18;
    uint64_t v62 = v16 - a2;
    a3 += v19;
    uint64_t v63 = v17 - a3;
    while ((((a2 - v14) | v62 | (a3 - v15) | v63) & 0x8000000000000000) == 0)
    {
      unint64_t v44 = v11 + SHIDWORD(a3) * (uint64_t)v12 + 12 * SHIDWORD(a2);
      float v45 = *(float32x2_t **)(result + 32);
      if (v22 >= v44) {
        unint64_t v64 = v11 + SHIDWORD(a3) * (uint64_t)v12 + 12 * SHIDWORD(a2);
      }
      else {
        unint64_t v64 = v22;
      }
      if (v64 < (unint64_t)v45) {
        unint64_t v64 = *(void *)(result + 32);
      }
      float32x2_t v47 = *(float32x2_t *)v64;
      float v48 = *(float *)(v64 + 8);
      if (v13)
      {
        unsigned int v49 = *(_DWORD *)(v13 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v49 & 0xF) != 0)
        {
          v21 += v60 + 1;
          uint64_t v20 = (uint64_t)(v61 - 7);
          a4 += ~v60;
          unsigned int v32 = -1;
          goto LABEL_38;
        }
      }
      *(float32x2_t *)(v61 - 3) = v47;
      *(v61 - 1) = v48;
      uint64_t v65 = v21 + v60++;
      *uint64_t v61 = 1.0;
      v61 += 4;
      a2 += v18;
      *(unsigned char *)(v65 + 2) = -1;
      v62 -= v18;
      a3 += v19;
      v63 -= v19;
      if (a4 - 1 == v60) {
        return result;
      }
    }
    v21 += v60 + 1;
    uint64_t v20 = (uint64_t)(v61 - 7);
    a4 += ~v60;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBAF_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int v13 = *(_DWORD *)(result + 24);
  uint64_t v14 = *(void *)(result + 112);
  uint64_t v15 = *(void *)(result + 48);
  uint64_t v16 = *(void *)(result + 56);
  if (v15)
  {
    uint64_t v122 = *(void *)(result + 112);
    if (v14 > v15) {
      uint64_t v122 = v14 % v15;
    }
  }
  else
  {
    uint64_t v122 = 0;
  }
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v18 = *(void *)(result + 32);
  uint64_t v19 = *(void *)(result + 120);
  if (v16)
  {
    uint64_t v20 = v19 % v16;
    if (v19 <= v16) {
      uint64_t v20 = *(void *)(result + 120);
    }
    uint64_t v121 = v20;
  }
  else
  {
    uint64_t v121 = 0;
  }
  uint64_t v117 = *(void *)(result + 80);
  uint64_t v118 = *(void *)(result + 64);
  uint64_t v119 = *(void *)(result + 88);
  uint64_t v120 = *(void *)(result + 72);
  int v116 = *(_DWORD *)(result + 188);
  uint64_t v21 = *(void *)(result + 152) - 16;
  uint64_t v22 = *(void *)(result + 144) - 1;
  uint64_t v23 = *(void *)(result + 40);
  unint64_t v24 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v13)
      + 4 * (4 * *(_DWORD *)(result + 256) - 4)
      - 16;
  do
  {
    while (1)
    {
      if (a3 < v120)
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = v120 - *(void *)(result + 224);
        uint64_t v27 = a3 - v26 + (v25 >> 1);
        if (v27 < 1) {
          goto LABEL_52;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        unsigned int v35 = v116 | v28;
        uint64_t v36 = v26 + 0x1000000;
        uint64_t v33 = a3 - (v26 + 0x1000000);
        uint64_t v34 = 512;
        goto LABEL_22;
      }
      if (a3 <= v119)
      {
        uint64_t v33 = 0;
        uint64_t v34 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v35 = 0x3FFFFFFF;
        uint64_t v36 = a3;
LABEL_22:
        uint64_t v37 = v118;
        goto LABEL_25;
      }
      uint64_t v29 = *(void *)(result + 216);
      uint64_t v30 = *(void *)(result + 224) + v119;
      uint64_t v31 = v30 - a3 + (v29 >> 1);
      if (v31 < 1) {
        goto LABEL_52;
      }
      if (v31 >= v29) {
        LODWORD(v32) = 0x3FFFFFFF;
      }
      else {
        unint64_t v32 = (unint64_t)(*(void *)(result + 232) * v31) >> 32;
      }
      uint64_t v37 = v118;
      unsigned int v35 = v116 | v32;
      uint64_t v36 = v30 - 0x1000000;
      uint64_t v33 = a3 - (v30 - 0x1000000);
      uint64_t v34 = 448;
LABEL_25:
      if (a2 >= v37) {
        break;
      }
      uint64_t v38 = *(void *)(result + 192);
      uint64_t v39 = v37 - *(void *)(result + 200);
      uint64_t v40 = a2 - v39 + (v38 >> 1);
      if (v40 >= 1)
      {
        if (v40 < v38) {
          unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v116;
        }
        uint64_t v41 = v39 + 0x1000000;
        uint64_t v42 = a2 - (v39 + 0x1000000);
        uint64_t v43 = 32;
        goto LABEL_36;
      }
LABEL_52:
      --a4;
      a2 += v14;
      a3 += v19;
      v21 += 16;
      *(unsigned char *)++uint64_t v22 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v117)
    {
      uint64_t v42 = 0;
      uint64_t v43 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v41 = a2;
      goto LABEL_36;
    }
    uint64_t v44 = *(void *)(result + 192);
    uint64_t v45 = *(void *)(result + 200) + v117;
    uint64_t v46 = v45 - a2 + (v44 >> 1);
    if (v46 < 1) {
      goto LABEL_52;
    }
    if (v46 < v44) {
      unsigned int v35 = ((v35 >> 15) * (((unint64_t)(*(void *)(result + 208) * v46) >> 32) >> 15)) | v116;
    }
    uint64_t v41 = v45 - 0x1000000;
    uint64_t v42 = a2 - (v45 - 0x1000000);
    uint64_t v43 = 28;
LABEL_36:
    if (v35 < 0x400000) {
      goto LABEL_52;
    }
    if (v15)
    {
      uint64_t v47 = (v16 & ((v36 % v16) >> 63)) + v36 % v16;
      uint64_t v48 = (v15 & ((v41 % v15) >> 63)) + v41 % v15;
      if (v47 >= v16) {
        uint64_t v49 = v16;
      }
      else {
        uint64_t v49 = 0;
      }
      uint64_t v36 = v47 - v49;
      if (v48 >= v15) {
        uint64_t v50 = v15;
      }
      else {
        uint64_t v50 = 0;
      }
      uint64_t v41 = v48 - v50;
      v33 += v36;
      v42 += v41;
    }
    uint64_t v51 = v18 + SHIDWORD(v36) * (uint64_t)v13;
    uint64_t v52 = v41 >> 32;
    unint64_t v53 = v51 + 16 * v52;
    float32x2_t v54 = *(int8x8_t **)(result + 32);
    if (v24 >= v53) {
      float32x2_t v55 = (int8x8_t *)(v51 + 16 * v52);
    }
    else {
      float32x2_t v55 = (int8x8_t *)v24;
    }
    if (v55 < v54) {
      float32x2_t v55 = *(int8x8_t **)(result + 32);
    }
    if (v23) {
      float v56 = COERCE_FLOAT(bswap32(v55[1].u32[1]));
    }
    else {
      float v56 = 1.0;
    }
    float32x2_t v57 = (float32x2_t)vrev32_s8(*v55);
    float v58 = COERCE_FLOAT(bswap32(v55[1].u32[0]));
    if (!v17) {
      goto LABEL_107;
    }
    unsigned int v59 = *(_DWORD *)(v17 + (v43 | v34));
LABEL_58:
    int v60 = v59 & 0xF;
    uint64_t v61 = v59 >> 8;
    int v62 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      LODWORD(v84) = SBYTE1(v59);
      if (v15)
      {
        uint64_t v85 = v61 << 56;
        uint64_t v86 = v33 + ((uint64_t)SBYTE1(v59) << 32);
        uint64_t v87 = v16 & (v86 >> 63);
        if (v87 + v86 >= v16) {
          uint64_t v88 = v16;
        }
        else {
          uint64_t v88 = 0;
        }
        uint64_t v84 = (v87 + (v85 >> 24) - v88) >> 32;
      }
      uint64_t v89 = (int8x8_t *)(v53 + (int)v84 * (uint64_t)v13);
      if (v24 < (unint64_t)v89) {
        uint64_t v89 = (int8x8_t *)v24;
      }
      if (v89 < v54) {
        uint64_t v89 = v54;
      }
      float32x2_t v90 = (float32x2_t)vrev32_s8(*v89);
      float v91 = COERCE_FLOAT(bswap32(v89[1].u32[0]));
      float v92 = 1.0;
      if (v23) {
        float v92 = COERCE_FLOAT(bswap32(v89[1].u32[1]));
      }
      uint64_t v93 = &interpolate_rgbaf_21353[4 * v62];
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          LODWORD(v63) = SBYTE1(v59);
          uint64_t v64 = SBYTE2(v59);
          if (v15)
          {
            uint64_t v65 = v61 << 56;
            int64_t v66 = (unint64_t)HIWORD(v59) << 56;
            uint64_t v67 = v33 + (v65 >> 24);
            uint64_t v68 = v42 + (v66 >> 24);
            uint64_t v69 = v16 & (v67 >> 63);
            uint64_t v70 = v15 & (v68 >> 63);
            uint64_t v71 = v70 + v68;
            if (v69 + v67 >= v16) {
              uint64_t v72 = v16;
            }
            else {
              uint64_t v72 = 0;
            }
            if (v71 >= v15) {
              uint64_t v73 = v15;
            }
            else {
              uint64_t v73 = 0;
            }
            uint64_t v63 = (v69 + (v65 >> 24) - v72) >> 32;
            uint64_t v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          uint64_t v74 = (int)v63 * (uint64_t)v13;
          uint64_t v75 = (int8x8_t *)(v53 + 16 * v64);
          if (v24 < (unint64_t)v75) {
            uint64_t v75 = (int8x8_t *)v24;
          }
          if (v75 < v54) {
            uint64_t v75 = v54;
          }
          float32x2_t v76 = (float32x2_t)vrev32_s8(*v75);
          float v77 = COERCE_FLOAT(bswap32(v75[1].u32[0]));
          float v78 = 1.0;
          float v79 = 1.0;
          if (v23) {
            float v79 = COERCE_FLOAT(bswap32(v75[1].u32[1]));
          }
          int v80 = (int8x8_t *)(v53 + v74 + 16 * v64);
          if (v24 < (unint64_t)v80) {
            int v80 = (int8x8_t *)v24;
          }
          if (v80 < v54) {
            int v80 = v54;
          }
          float32x2_t v81 = (float32x2_t)vrev32_s8(*v80);
          float v82 = COERCE_FLOAT(bswap32(v80[1].u32[0]));
          if (v23) {
            float v78 = COERCE_FLOAT(bswap32(v80[1].u32[1]));
          }
          v11.i32[0] = interpolate_rgbaf_21353[4 * v62 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v59 >> 28) & 3) + 3];
          float v58 = (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v77 * v11.f32[0]))
                      - (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v77 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v77 - (float)(v77 * v11.f32[0])) + (float)(v82 * v11.f32[0])) * v12.f32[0]);
          float32x2_t v83 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v76, v11.f32[0]);
          float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v83, v83, v12, 0), vmla_n_f32(vmls_lane_f32(v76, v76, v11, 0), v81, v11.f32[0]), v12.f32[0]);
          float v56 = (float)((float)((float)(v56 - (float)(v56 * v11.f32[0])) + (float)(v79 * v11.f32[0]))
                      - (float)((float)((float)(v56 - (float)(v56 * v11.f32[0])) + (float)(v79 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v79 - (float)(v79 * v11.f32[0])) + (float)(v78 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_107;
      }
      uint64_t v94 = SBYTE2(v59);
      if (v15)
      {
        uint64_t v95 = v42 + ((uint64_t)SBYTE2(v59) << 32);
        uint64_t v96 = v15 & (v95 >> 63);
        if (v96 + v95 >= v15) {
          uint64_t v97 = v15;
        }
        else {
          uint64_t v97 = 0;
        }
        uint64_t v94 = (v96 + ((uint64_t)((unint64_t)HIWORD(v59) << 56) >> 24) - v97) >> 32;
      }
      uint64_t v98 = (int8x8_t *)(v53 + 16 * v94);
      if (v24 < (unint64_t)v98) {
        uint64_t v98 = (int8x8_t *)v24;
      }
      if (v98 < v54) {
        uint64_t v98 = v54;
      }
      float32x2_t v90 = (float32x2_t)vrev32_s8(*v98);
      float v91 = COERCE_FLOAT(bswap32(v98[1].u32[0]));
      float v92 = 1.0;
      if (v23) {
        float v92 = COERCE_FLOAT(bswap32(v98[1].u32[1]));
      }
      uint64_t v93 = &interpolate_rgbaf_21353[4 * ((v59 >> 28) & 3)];
    }
    LODWORD(a11) = v93[3];
    float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v90, *(float *)&a11);
    float v58 = (float)(v58 - (float)(v58 * *(float *)&a11)) + (float)(v91 * *(float *)&a11);
    float v56 = (float)(v56 - (float)(v56 * *(float *)&a11)) + (float)(v92 * *(float *)&a11);
LABEL_107:
    *(float32x2_t *)(v21 + 16) = v57;
    *(float *)(v21 + 24) = v58;
    *(float *)(v21 + 28) = v56;
    *(unsigned char *)(v22 + 1) = v35 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v99 = 0;
    uint64_t v100 = (float *)(v21 + 44);
    a2 += v14;
    uint64_t v101 = v117 - a2;
    a3 += v19;
    uint64_t v102 = v119 - a3;
    int v103 = --a4;
    while (1)
    {
      uint64_t v104 = v22 + v99 + 1;
      uint64_t v21 = (uint64_t)(v100 - 7);
      if ((v102 | v101 | (a3 - v120) | (a2 - v118)) < 0) {
        break;
      }
      if (v15)
      {
        uint64_t v105 = (v16 & ((v33 + v121) >> 63)) + v33 + v121;
        uint64_t v106 = (v15 & ((v42 + v122) >> 63)) + v42 + v122;
        if (v105 >= v16) {
          uint64_t v107 = v16;
        }
        else {
          uint64_t v107 = 0;
        }
        uint64_t v108 = v105 - v107;
        if (v106 >= v15) {
          uint64_t v109 = v15;
        }
        else {
          uint64_t v109 = 0;
        }
        uint64_t v110 = v106 - v109;
        uint64_t v42 = v110;
        uint64_t v33 = v108;
      }
      else
      {
        uint64_t v110 = a2;
        HIDWORD(v108) = HIDWORD(a3);
      }
      uint64_t v111 = v18 + SHIDWORD(v108) * (uint64_t)v13;
      uint64_t v112 = v110 >> 32;
      unint64_t v53 = v111 + 16 * v112;
      float32x2_t v54 = *(int8x8_t **)(result + 32);
      if (v24 >= v53) {
        uint64_t v113 = (int8x8_t *)(v111 + 16 * v112);
      }
      else {
        uint64_t v113 = (int8x8_t *)v24;
      }
      if (v113 < v54) {
        uint64_t v113 = *(int8x8_t **)(result + 32);
      }
      if (v23) {
        float v56 = COERCE_FLOAT(bswap32(v113[1].u32[1]));
      }
      else {
        float v56 = 1.0;
      }
      float32x2_t v57 = (float32x2_t)vrev32_s8(*v113);
      unsigned int v114 = bswap32(v113[1].u32[0]);
      if (v17)
      {
        unsigned int v59 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v59 & 0xF) != 0)
        {
          float v58 = *(float *)&v114;
          unsigned int v35 = -1;
          uint64_t v22 = v104;
          goto LABEL_58;
        }
      }
      --a4;
      *(float32x2_t *)(v100 - 3) = v57;
      *((_DWORD *)v100 - 1) = v114;
      uint64_t v115 = v22 + v99++;
      *uint64_t v100 = v56;
      v100 += 4;
      a2 += v14;
      *(unsigned char *)(v115 + 2) = -1;
      v101 -= v14;
      a3 += v19;
      v102 -= v19;
      if (v103 == v99) {
        return result;
      }
    }
    v22 += v99 + 1;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_RGBAf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int v13 = *(_DWORD *)(result + 24);
  uint64_t v14 = *(void *)(result + 112);
  uint64_t v15 = *(void *)(result + 48);
  uint64_t v16 = *(void *)(result + 56);
  if (v15)
  {
    uint64_t v17 = *(void *)(result + 112);
    if (v14 > v15) {
      uint64_t v17 = v14 % v15;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v18 = *(void *)(result + 176);
  uint64_t v19 = *(void *)(result + 32);
  uint64_t v20 = *(void *)(result + 120);
  if (v16)
  {
    uint64_t v21 = v20 % v16;
    if (v20 <= v16) {
      uint64_t v21 = *(void *)(result + 120);
    }
    uint64_t v124 = v21;
  }
  else
  {
    uint64_t v124 = 0;
  }
  uint64_t v123 = *(void *)(result + 80);
  uint64_t v120 = *(void *)(result + 64);
  uint64_t v121 = *(void *)(result + 88);
  int v119 = *(_DWORD *)(result + 188);
  uint64_t v22 = *(void *)(result + 152) - 16;
  uint64_t v23 = *(void *)(result + 144) - 1;
  uint64_t v24 = *(void *)(result + 40);
  unint64_t v25 = v19
      + ((*(_DWORD *)(result + 260) - 1) * v13)
      + 4 * (4 * *(_DWORD *)(result + 256) - 4)
      - 16;
  uint64_t v122 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v122)
      {
        if (a3 <= v121)
        {
          uint64_t v34 = 0;
          uint64_t v35 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v36 = 0x3FFFFFFF;
          uint64_t v37 = a3;
          uint64_t v38 = v120;
          uint64_t v39 = v123;
        }
        else
        {
          uint64_t v30 = *(void *)(result + 216);
          uint64_t v31 = *(void *)(result + 224) + v121;
          uint64_t v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1) {
            goto LABEL_51;
          }
          if (v32 >= v30) {
            LODWORD(v33) = 0x3FFFFFFF;
          }
          else {
            unint64_t v33 = (unint64_t)(*(void *)(result + 232) * v32) >> 32;
          }
          uint64_t v38 = v120;
          uint64_t v39 = v123;
          unsigned int v36 = v119 | v33;
          uint64_t v37 = v31 - 0x1000000;
          uint64_t v34 = a3 - (v31 - 0x1000000);
          uint64_t v35 = 448;
        }
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = v122 - *(void *)(result + 224);
        uint64_t v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1) {
          goto LABEL_51;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        uint64_t v38 = v120;
        uint64_t v39 = v123;
        unsigned int v36 = v119 | v29;
        uint64_t v37 = v27 + 0x1000000;
        uint64_t v34 = a3 - (v27 + 0x1000000);
        uint64_t v35 = 512;
      }
      if (a2 >= v38) {
        break;
      }
      uint64_t v40 = *(void *)(result + 192);
      uint64_t v41 = v38 - *(void *)(result + 200);
      uint64_t v42 = a2 - v41 + (v40 >> 1);
      if (v42 >= 1)
      {
        if (v42 < v40) {
          unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v119;
        }
        uint64_t v43 = v41 + 0x1000000;
        uint64_t v44 = a2 - (v41 + 0x1000000);
        uint64_t v45 = 32;
        goto LABEL_35;
      }
LABEL_51:
      --a4;
      a2 += v14;
      a3 += v20;
      v22 += 16;
      *(unsigned char *)++uint64_t v23 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v39)
    {
      uint64_t v44 = 0;
      uint64_t v45 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v43 = a2;
      goto LABEL_35;
    }
    uint64_t v46 = *(void *)(result + 192);
    uint64_t v47 = *(void *)(result + 200) + v39;
    uint64_t v48 = v47 - a2 + (v46 >> 1);
    if (v48 < 1) {
      goto LABEL_51;
    }
    if (v48 < v46) {
      unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v48) >> 32) >> 15)) | v119;
    }
    uint64_t v43 = v47 - 0x1000000;
    uint64_t v44 = a2 - (v47 - 0x1000000);
    uint64_t v45 = 28;
LABEL_35:
    if (v36 < 0x400000) {
      goto LABEL_51;
    }
    if (v15)
    {
      uint64_t v49 = (v16 & ((v37 % v16) >> 63)) + v37 % v16;
      uint64_t v50 = (v15 & ((v43 % v15) >> 63)) + v43 % v15;
      if (v49 >= v16) {
        uint64_t v51 = v16;
      }
      else {
        uint64_t v51 = 0;
      }
      uint64_t v37 = v49 - v51;
      if (v50 >= v15) {
        uint64_t v52 = v15;
      }
      else {
        uint64_t v52 = 0;
      }
      uint64_t v43 = v50 - v52;
      v34 += v37;
      v44 += v43;
    }
    uint64_t v53 = v19 + SHIDWORD(v37) * (uint64_t)v13;
    uint64_t v54 = v43 >> 32;
    unint64_t v55 = v53 + 16 * v54;
    float v56 = *(float32x2_t **)(result + 32);
    if (v25 >= v55) {
      float32x2_t v57 = (float32x2_t *)(v53 + 16 * v54);
    }
    else {
      float32x2_t v57 = (float32x2_t *)v25;
    }
    if (v57 < v56) {
      float32x2_t v57 = *(float32x2_t **)(result + 32);
    }
    if (v24) {
      float v58 = v57[1].f32[1];
    }
    else {
      float v58 = 1.0;
    }
    float32x2_t v59 = *v57;
    float v60 = v57[1].f32[0];
    if (!v18) {
      goto LABEL_114;
    }
    unsigned int v61 = *(_DWORD *)(v18 + (v45 | v35));
LABEL_57:
    int v62 = v61 & 0xF;
    uint64_t v63 = v61 >> 8;
    int v64 = HIBYTE(v61) & 3;
    if (v62 == 1)
    {
      LODWORD(v85) = SBYTE1(v61);
      if (v15)
      {
        uint64_t v86 = v63 << 56;
        uint64_t v87 = v34 + ((uint64_t)SBYTE1(v61) << 32);
        uint64_t v88 = v16 & (v87 >> 63);
        if (v88 + v87 >= v16) {
          uint64_t v89 = v16;
        }
        else {
          uint64_t v89 = 0;
        }
        uint64_t v85 = (v88 + (v86 >> 24) - v89) >> 32;
      }
      unint64_t v90 = v55 + (int)v85 * (uint64_t)v13;
      if (v25 < v90) {
        unint64_t v90 = v25;
      }
      if (v90 >= (unint64_t)v56) {
        float v91 = (float32x2_t *)v90;
      }
      else {
        float v91 = v56;
      }
      float32x2_t v92 = *v91;
      float v93 = v91[1].f32[0];
      float v94 = 1.0;
      if (v24) {
        float v94 = v91[1].f32[1];
      }
      uint64_t v95 = &interpolate_rgbaf_21353[4 * v64];
    }
    else
    {
      if (v62 != 2)
      {
        if (v62 == 3)
        {
          uint64_t v118 = v17;
          LODWORD(v65) = SBYTE1(v61);
          uint64_t v66 = SBYTE2(v61);
          if (v15)
          {
            uint64_t v67 = v63 << 56;
            uint64_t v68 = v34 + (v67 >> 24);
            uint64_t v69 = v44 + ((uint64_t)SBYTE2(v61) << 32);
            uint64_t v70 = v16 & (v68 >> 63);
            uint64_t v71 = v15 & (v69 >> 63);
            uint64_t v72 = v71 + v69;
            if (v70 + v68 >= v16) {
              uint64_t v73 = v16;
            }
            else {
              uint64_t v73 = 0;
            }
            if (v72 >= v15) {
              uint64_t v74 = v15;
            }
            else {
              uint64_t v74 = 0;
            }
            uint64_t v75 = v70 + (v67 >> 24);
            int v64 = HIBYTE(v61) & 3;
            uint64_t v65 = (v75 - v73) >> 32;
            uint64_t v66 = (v71 + ((uint64_t)((unint64_t)HIWORD(v61) << 56) >> 24) - v74) >> 32;
          }
          uint64_t v76 = (int)v65 * (uint64_t)v13;
          uint64_t v77 = 16 * v66;
          unint64_t v78 = v55 + 16 * v66;
          if (v25 < v78) {
            unint64_t v78 = v25;
          }
          if (v78 >= (unint64_t)v56) {
            float v79 = (float32x2_t *)v78;
          }
          else {
            float v79 = v56;
          }
          float32x2_t v80 = *v79;
          if (v24)
          {
            float v81 = v79[1].f32[1];
            float v82 = (float32x2_t *)(v55 + v76 + v77);
            if (v25 < (unint64_t)v82) {
              float v82 = (float32x2_t *)v25;
            }
            if (v82 >= v56) {
              float32x2_t v83 = v82;
            }
            else {
              float32x2_t v83 = v56;
            }
            float v84 = v83[1].f32[1];
          }
          else
          {
            uint64_t v102 = (float32x2_t *)(v55 + v76 + v77);
            if (v25 < (unint64_t)v102) {
              uint64_t v102 = (float32x2_t *)v25;
            }
            if (v102 >= v56) {
              float32x2_t v83 = v102;
            }
            else {
              float32x2_t v83 = v56;
            }
            float v81 = 1.0;
            float v84 = 1.0;
          }
          uint64_t v17 = v118;
          v11.i32[0] = interpolate_rgbaf_21353[4 * v64 + 3];
          v12.i32[0] = interpolate_rgbaf_21353[4 * ((v61 >> 28) & 3) + 3];
          float v60 = (float)((float)((float)(v60 - (float)(v60 * v11.f32[0])) + (float)(v79[1].f32[0] * v11.f32[0]))
                      - (float)((float)((float)(v60 - (float)(v60 * v11.f32[0])) + (float)(v79[1].f32[0] * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v79[1].f32[0] - (float)(v79[1].f32[0] * v11.f32[0]))
                              + (float)(v83[1].f32[0] * v11.f32[0]))
                      * v12.f32[0]);
          float32x2_t v103 = vmla_n_f32(vmls_lane_f32(v59, v59, v11, 0), v80, v11.f32[0]);
          float32x2_t v59 = vmla_n_f32(vmls_lane_f32(v103, v103, v12, 0), vmla_n_f32(vmls_lane_f32(v80, v80, v11, 0), *v83, v11.f32[0]), v12.f32[0]);
          float v58 = (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v81 * v11.f32[0]))
                      - (float)((float)((float)(v58 - (float)(v58 * v11.f32[0])) + (float)(v81 * v11.f32[0]))
                              * v12.f32[0]))
              + (float)((float)((float)(v81 - (float)(v81 * v11.f32[0])) + (float)(v84 * v11.f32[0])) * v12.f32[0]);
        }
        goto LABEL_114;
      }
      uint64_t v96 = SBYTE2(v61);
      if (v15)
      {
        uint64_t v97 = v44 + ((uint64_t)SBYTE2(v61) << 32);
        uint64_t v98 = v15 & (v97 >> 63);
        if (v98 + v97 >= v15) {
          uint64_t v99 = v15;
        }
        else {
          uint64_t v99 = 0;
        }
        uint64_t v96 = (v98 + ((uint64_t)((unint64_t)HIWORD(v61) << 56) >> 24) - v99) >> 32;
      }
      unint64_t v100 = v55 + 16 * v96;
      if (v25 < v100) {
        unint64_t v100 = v25;
      }
      if (v100 >= (unint64_t)v56) {
        uint64_t v101 = (float32x2_t *)v100;
      }
      else {
        uint64_t v101 = v56;
      }
      float32x2_t v92 = *v101;
      float v93 = v101[1].f32[0];
      float v94 = 1.0;
      if (v24) {
        float v94 = v101[1].f32[1];
      }
      uint64_t v95 = &interpolate_rgbaf_21353[4 * ((v61 >> 28) & 3)];
    }
    LODWORD(a11) = v95[3];
    float32x2_t v59 = vmla_n_f32(vmls_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v92, *(float *)&a11);
    float v60 = (float)(v60 - (float)(v60 * *(float *)&a11)) + (float)(v93 * *(float *)&a11);
    float v58 = (float)(v58 - (float)(v58 * *(float *)&a11)) + (float)(v94 * *(float *)&a11);
LABEL_114:
    *(float32x2_t *)(v22 + 16) = v59;
    *(float *)(v22 + 24) = v60;
    *(float *)(v22 + 28) = v58;
    *(unsigned char *)(v23 + 1) = v36 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v104 = 0;
    uint64_t v105 = (float *)(v22 + 44);
    a2 += v14;
    uint64_t v106 = v123 - a2;
    a3 += v20;
    uint64_t v107 = v121 - a3;
    while (((v107 | v106 | (a3 - v122) | (a2 - v120)) & 0x8000000000000000) == 0)
    {
      if (v15)
      {
        uint64_t v108 = (v16 & ((v34 + v124) >> 63)) + v34 + v124;
        uint64_t v109 = (v15 & ((v44 + v17) >> 63)) + v44 + v17;
        if (v108 >= v16) {
          uint64_t v110 = v16;
        }
        else {
          uint64_t v110 = 0;
        }
        uint64_t v34 = v108 - v110;
        if (v109 >= v15) {
          uint64_t v111 = v15;
        }
        else {
          uint64_t v111 = 0;
        }
        uint64_t v44 = v109 - v111;
        int v112 = HIDWORD(v34);
        uint64_t v113 = v109 - v111;
      }
      else
      {
        int v112 = HIDWORD(a3);
        uint64_t v113 = a2;
      }
      uint64_t v114 = v19 + v112 * (uint64_t)v13;
      unint64_t v55 = v114 + 16 * (v113 >> 32);
      float v56 = *(float32x2_t **)(result + 32);
      if (v25 >= v55) {
        unint64_t v115 = v114 + 16 * (v113 >> 32);
      }
      else {
        unint64_t v115 = v25;
      }
      if (v115 >= (unint64_t)v56) {
        int v116 = (float32x2_t *)v115;
      }
      else {
        int v116 = *(float32x2_t **)(result + 32);
      }
      if (v24) {
        float v58 = v116[1].f32[1];
      }
      else {
        float v58 = 1.0;
      }
      float32x2_t v59 = *v116;
      float v60 = v116[1].f32[0];
      if (v18)
      {
        unsigned int v61 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v61 & 0xF) != 0)
        {
          v23 += v104 + 1;
          uint64_t v22 = (uint64_t)(v105 - 7);
          a4 += ~v104;
          unsigned int v36 = -1;
          goto LABEL_57;
        }
      }
      *(float32x2_t *)(v105 - 3) = v59;
      *(v105 - 1) = v60;
      float *v105 = v58;
      uint64_t v117 = v23 + v104++;
      v105 += 4;
      a2 += v14;
      *(unsigned char *)(v117 + 2) = -1;
      v106 -= v14;
      a3 += v20;
      v107 -= v20;
      if (a4 - 1 == v104) {
        return result;
      }
    }
    v23 += v104 + 1;
    uint64_t v22 = (uint64_t)(v105 - 7);
    a4 += ~v104;
  }
  while (a4);
  return result;
}

uint64_t RGBAf_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v13 = *(void *)(result + 32);
  uint64_t v14 = *(void *)(result + 40);
  int v15 = *(_DWORD *)(result + 24);
  int v16 = *(_DWORD *)(result + 28);
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v18 = *(void *)(result + 72);
  uint64_t v94 = *(void *)(result + 80);
  uint64_t v95 = *(void *)(result + 88);
  uint64_t v20 = *(void *)(result + 112);
  uint64_t v19 = *(void *)(result + 120);
  uint64_t v21 = *(void *)(result + 152) - 16;
  uint64_t v22 = *(void *)(result + 144) - 1;
  int v23 = *(_DWORD *)(result + 260) - 1;
  unsigned int v24 = *(_DWORD *)(result + 256) - 1;
  unint64_t v25 = v14 + (v23 * v16) + 4 * v24;
  int v92 = *(_DWORD *)(result + 188);
  unint64_t v26 = v13 + (v23 * v15) + 16 * v24 - 16;
  uint64_t v93 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v18)
    {
      if (a3 <= v95)
      {
        uint64_t v35 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v36 = 0x3FFFFFFF;
        uint64_t v37 = a3;
        uint64_t v38 = v93;
      }
      else
      {
        uint64_t v31 = *(void *)(result + 216);
        uint64_t v32 = *(void *)(result + 224) + v95;
        uint64_t v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1) {
          goto LABEL_39;
        }
        if (v33 >= v31) {
          LODWORD(v34) = 0x3FFFFFFF;
        }
        else {
          unint64_t v34 = (unint64_t)(*(void *)(result + 232) * v33) >> 32;
        }
        uint64_t v38 = v93;
        unsigned int v36 = v34 | v92;
        uint64_t v37 = v32 - 0x1000000;
        uint64_t v35 = 448;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(result + 216);
      uint64_t v28 = v18 - *(void *)(result + 224);
      uint64_t v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_39;
      }
      if (v29 >= v27) {
        LODWORD(v30) = 0x3FFFFFFF;
      }
      else {
        unint64_t v30 = (unint64_t)(*(void *)(result + 232) * v29) >> 32;
      }
      uint64_t v38 = v93;
      unsigned int v36 = v30 | v92;
      uint64_t v37 = v28 + 0x1000000;
      uint64_t v35 = 512;
    }
    if (a2 >= v38) {
      break;
    }
    uint64_t v39 = *(void *)(result + 192);
    uint64_t v40 = v38 - *(void *)(result + 200);
    uint64_t v41 = a2 - v40 + (v39 >> 1);
    if (v41 >= 1)
    {
      if (v41 < v39) {
        unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v92;
      }
      uint64_t v42 = v40 + 0x1000000;
      uint64_t v43 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v20;
    a3 += v19;
    v21 += 16;
    *(unsigned char *)++uint64_t v22 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v94)
  {
    uint64_t v43 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v42 = a2;
    goto LABEL_26;
  }
  uint64_t v44 = *(void *)(result + 192);
  uint64_t v45 = *(void *)(result + 200) + v94;
  uint64_t v46 = v45 - a2 + (v44 >> 1);
  if (v46 < 1) {
    goto LABEL_39;
  }
  if (v46 < v44) {
    unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v46) >> 32) >> 15)) | v92;
  }
  uint64_t v42 = v45 - 0x1000000;
  uint64_t v43 = 28;
LABEL_26:
  if (v36 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v47 = v37 >> 32;
  uint64_t v48 = v13 + SHIDWORD(v37) * (uint64_t)v15;
  unint64_t v49 = (v42 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v50 = v48 + 4 * v49;
  uint64_t v51 = *(int8x8_t **)(result + 32);
  if (v26 >= v50) {
    uint64_t v52 = (int8x8_t *)(v48 + 4 * v49);
  }
  else {
    uint64_t v52 = (int8x8_t *)v26;
  }
  if (v52 < v51) {
    uint64_t v52 = *(int8x8_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v53 = v14 + (int)v47 * (uint64_t)v16 + v49;
    uint64_t v54 = *(unsigned int **)(result + 40);
    if (v25 >= v53) {
      unint64_t v55 = (unsigned int *)(v14 + (int)v47 * (uint64_t)v16 + v49);
    }
    else {
      unint64_t v55 = (unsigned int *)v25;
    }
    if (v55 >= v54) {
      uint64_t v54 = v55;
    }
    LODWORD(a5) = bswap32(*v54);
  }
  else
  {
    unint64_t v53 = 0;
    LODWORD(a5) = 1.0;
  }
  float32x2_t v56 = (float32x2_t)vrev32_s8(*v52);
  float32x2_t v57 = (float32x2_t)vrev32_s8(v52[1]);
  if (v17)
  {
    unsigned int v58 = *(_DWORD *)(v17 + (v43 | v35));
LABEL_45:
    int v59 = v58 & 0xF;
    int v60 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      uint64_t v76 = (int8x8_t *)(v50 + SBYTE1(v58) * (uint64_t)v15);
      if (v26 < (unint64_t)v76) {
        uint64_t v76 = (int8x8_t *)v26;
      }
      if (v76 < v51) {
        uint64_t v76 = v51;
      }
      float32x2_t v77 = (float32x2_t)vrev32_s8(*v76);
      float32x2_t v78 = (float32x2_t)vrev32_s8(v76[1]);
      float v79 = 1.0;
      if (v14)
      {
        float32x2_t v80 = (unsigned int *)(v53 + SBYTE1(v58) * (uint64_t)v16);
        if (v25 < (unint64_t)v80) {
          float32x2_t v80 = (unsigned int *)v25;
        }
        if ((unint64_t)v80 < *(void *)(result + 40)) {
          float32x2_t v80 = *(unsigned int **)(result + 40);
        }
        float v79 = COERCE_FLOAT(bswap32(*v80));
      }
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          int64_t v61 = (unint64_t)HIWORD(v58) << 56;
          unint64_t v62 = v50 + (v61 >> 52);
          if (v26 >= v62) {
            uint64_t v63 = (int8x8_t *)(v50 + (v61 >> 52));
          }
          else {
            uint64_t v63 = (int8x8_t *)v26;
          }
          if (v63 < v51) {
            uint64_t v63 = v51;
          }
          unint64_t v64 = v62 + SBYTE1(v58) * (uint64_t)v15;
          if (v26 < v64) {
            unint64_t v64 = v26;
          }
          if (v64 < (unint64_t)v51) {
            unint64_t v64 = (unint64_t)v51;
          }
          float32x2_t v65 = (float32x2_t)vrev32_s8(*v63);
          a11 = *(double *)(v64 + 8);
          float32x2_t v66 = (float32x2_t)vrev32_s8(*(int8x8_t *)v64);
          float32x2_t v67 = (float32x2_t)vrev32_s8(v63[1]);
          float32x2_t v68 = (float32x2_t)vrev32_s8(*(int8x8_t *)&a11);
          float v69 = 1.0;
          LODWORD(a11) = 1.0;
          if (v14)
          {
            uint64_t v70 = (unsigned int *)(v53 + (v61 >> 54));
            unint64_t v71 = *(void *)(result + 40);
            if (v25 >= (unint64_t)v70) {
              uint64_t v72 = v70;
            }
            else {
              uint64_t v72 = (unsigned int *)v25;
            }
            if ((unint64_t)v72 < v71) {
              uint64_t v72 = *(unsigned int **)(result + 40);
            }
            LODWORD(a11) = bswap32(*v72);
            uint64_t v73 = (unsigned int *)((char *)v70 + SBYTE1(v58) * (uint64_t)v16);
            if (v25 < (unint64_t)v73) {
              uint64_t v73 = (unsigned int *)v25;
            }
            if ((unint64_t)v73 < v71) {
              uint64_t v73 = *(unsigned int **)(result + 40);
            }
            float v69 = COERCE_FLOAT(bswap32(*v73));
          }
          v11.i32[0] = interpolate_cmykaf[5 * v60 + 4];
          v12.i32[0] = interpolate_cmykaf[5 * ((v58 >> 28) & 3) + 4];
          float32x2_t v74 = vmla_n_f32(vmls_lane_f32(v56, v56, v11, 0), v65, v11.f32[0]);
          float32x2_t v56 = vmla_n_f32(vmls_lane_f32(v74, v74, v12, 0), vmla_n_f32(vmls_lane_f32(v65, v65, v11, 0), v66, v11.f32[0]), v12.f32[0]);
          float32x2_t v75 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v67, v11.f32[0]);
          float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v75, v75, v12, 0), vmla_n_f32(vmls_lane_f32(v67, v67, v11, 0), v68, v11.f32[0]), v12.f32[0]);
          *(float *)&a5 = (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                        + (float)(*(float *)&a11 * v11.f32[0]))
                                - (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                                + (float)(*(float *)&a11 * v11.f32[0]))
                                        * v12.f32[0]))
                        + (float)((float)((float)(*(float *)&a11 - (float)(*(float *)&a11 * v11.f32[0]))
                                        + (float)(v69 * v11.f32[0]))
                                * v12.f32[0]);
        }
        goto LABEL_91;
      }
      int64_t v81 = (unint64_t)HIWORD(v58) << 56;
      float v82 = (int8x8_t *)(v50 + (v81 >> 52));
      if (v26 < (unint64_t)v82) {
        float v82 = (int8x8_t *)v26;
      }
      if (v82 < v51) {
        float v82 = v51;
      }
      float32x2_t v77 = (float32x2_t)vrev32_s8(*v82);
      float32x2_t v78 = (float32x2_t)vrev32_s8(v82[1]);
      float v79 = 1.0;
      if (v14)
      {
        float32x2_t v83 = (unsigned int *)(v53 + (v81 >> 54));
        if (v25 < (unint64_t)v83) {
          float32x2_t v83 = (unsigned int *)v25;
        }
        if ((unint64_t)v83 < *(void *)(result + 40)) {
          float32x2_t v83 = *(unsigned int **)(result + 40);
        }
        float v79 = COERCE_FLOAT(bswap32(*v83));
      }
      int v60 = (v58 >> 28) & 3;
    }
    LODWORD(a11) = interpolate_cmykaf[5 * v60 + 4];
    float32x2_t v56 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), v77, *(float *)&a11);
    float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v78, *(float *)&a11);
    *(float *)&a5 = (float)(*(float *)&a5 - (float)(*(float *)&a5 * *(float *)&a11)) + (float)(v79 * *(float *)&a11);
  }
LABEL_91:
  uint64_t v84 = 0;
  uint64_t v85 = (float *)(v21 + 28);
  a2 += v20;
  uint64_t v86 = v94 - a2;
  a3 += v19;
  uint64_t v87 = v95 - a3;
  while (1)
  {
    *(float32x2_t *)(v85 - 3) = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v56), (float32x2_t)vdup_lane_s32((int32x2_t)v57, 1));
    *(v85 - 1) = (float)(*(float *)&a5 - v57.f32[0]) - v57.f32[1];
    *uint64_t v85 = *(float *)&a5;
    *(unsigned char *)(v22 + 1 + v84) = v36 >> 22;
    if (a4 - 1 == v84) {
      return result;
    }
    if ((v87 | v86 | (a3 - v18) | (a2 - v93)) < 0)
    {
      v22 += v84 + 1;
      uint64_t v21 = (uint64_t)(v85 - 3);
      a4 += ~v84;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v88 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v50 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v88;
    uint64_t v51 = *(int8x8_t **)(result + 32);
    if (v26 >= v50) {
      uint64_t v89 = (int8x8_t *)(v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v88);
    }
    else {
      uint64_t v89 = (int8x8_t *)v26;
    }
    if (v89 < v51) {
      uint64_t v89 = *(int8x8_t **)(result + 32);
    }
    if (v14)
    {
      unint64_t v53 = v14 + SHIDWORD(a3) * (uint64_t)v16 + v88;
      unint64_t v90 = *(unsigned int **)(result + 40);
      if (v25 >= v53) {
        float v91 = (unsigned int *)v53;
      }
      else {
        float v91 = (unsigned int *)v25;
      }
      if (v91 >= v90) {
        unint64_t v90 = v91;
      }
      LODWORD(a5) = bswap32(*v90);
    }
    else
    {
      LODWORD(a5) = 1.0;
    }
    float32x2_t v56 = (float32x2_t)vrev32_s8(*v89);
    float32x2_t v57 = (float32x2_t)vrev32_s8(v89[1]);
    if (v17)
    {
      unsigned int v58 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v22 += v84 + 1;
        uint64_t v21 = (uint64_t)(v85 - 3);
        a4 += ~v84;
        unsigned int v36 = -1;
        goto LABEL_45;
      }
    }
    ++v84;
    v85 += 4;
    v86 -= v20;
    a3 += v19;
    v87 -= v19;
    a2 += v20;
    unsigned int v36 = -1;
  }
}

uint64_t RGBAf_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  uint64_t v13 = *(void *)(result + 32);
  uint64_t v14 = *(void *)(result + 40);
  int v15 = *(_DWORD *)(result + 24);
  int v16 = *(_DWORD *)(result + 28);
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v18 = *(void *)(result + 72);
  uint64_t v95 = *(void *)(result + 80);
  uint64_t v96 = *(void *)(result + 88);
  uint64_t v20 = *(void *)(result + 112);
  uint64_t v19 = *(void *)(result + 120);
  uint64_t v21 = *(void *)(result + 152) - 16;
  uint64_t v22 = *(void *)(result + 144) - 1;
  int v23 = *(_DWORD *)(result + 260) - 1;
  unsigned int v24 = *(_DWORD *)(result + 256) - 1;
  unint64_t v25 = v14 + (v23 * v16) + 4 * v24;
  int v93 = *(_DWORD *)(result + 188);
  unint64_t v26 = v13 + (v23 * v15) + 16 * v24 - 16;
  uint64_t v94 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v18)
    {
      if (a3 <= v96)
      {
        uint64_t v35 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v36 = 0x3FFFFFFF;
        uint64_t v37 = a3;
        uint64_t v38 = v94;
      }
      else
      {
        uint64_t v31 = *(void *)(result + 216);
        uint64_t v32 = *(void *)(result + 224) + v96;
        uint64_t v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1) {
          goto LABEL_39;
        }
        if (v33 >= v31) {
          LODWORD(v34) = 0x3FFFFFFF;
        }
        else {
          unint64_t v34 = (unint64_t)(*(void *)(result + 232) * v33) >> 32;
        }
        uint64_t v38 = v94;
        unsigned int v36 = v34 | v93;
        uint64_t v37 = v32 - 0x1000000;
        uint64_t v35 = 448;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(result + 216);
      uint64_t v28 = v18 - *(void *)(result + 224);
      uint64_t v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_39;
      }
      if (v29 >= v27) {
        LODWORD(v30) = 0x3FFFFFFF;
      }
      else {
        unint64_t v30 = (unint64_t)(*(void *)(result + 232) * v29) >> 32;
      }
      uint64_t v38 = v94;
      unsigned int v36 = v30 | v93;
      uint64_t v37 = v28 + 0x1000000;
      uint64_t v35 = 512;
    }
    if (a2 >= v38) {
      break;
    }
    uint64_t v39 = *(void *)(result + 192);
    uint64_t v40 = v38 - *(void *)(result + 200);
    uint64_t v41 = a2 - v40 + (v39 >> 1);
    if (v41 >= 1)
    {
      if (v41 < v39) {
        unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v93;
      }
      uint64_t v42 = v40 + 0x1000000;
      uint64_t v43 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v20;
    a3 += v19;
    v21 += 16;
    *(unsigned char *)++uint64_t v22 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v95)
  {
    uint64_t v43 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v42 = a2;
    goto LABEL_26;
  }
  uint64_t v44 = *(void *)(result + 192);
  uint64_t v45 = *(void *)(result + 200) + v95;
  uint64_t v46 = v45 - a2 + (v44 >> 1);
  if (v46 < 1) {
    goto LABEL_39;
  }
  if (v46 < v44) {
    unsigned int v36 = ((v36 >> 15) * (((unint64_t)(*(void *)(result + 208) * v46) >> 32) >> 15)) | v93;
  }
  uint64_t v42 = v45 - 0x1000000;
  uint64_t v43 = 28;
LABEL_26:
  if (v36 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v47 = v37 >> 32;
  uint64_t v48 = v13 + SHIDWORD(v37) * (uint64_t)v15;
  unint64_t v49 = (v42 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v50 = v48 + 4 * v49;
  uint64_t v51 = *(float32x2_t **)(result + 32);
  if (v26 >= v50) {
    uint64_t v52 = (float32x2_t *)(v48 + 4 * v49);
  }
  else {
    uint64_t v52 = (float32x2_t *)v26;
  }
  if (v52 < v51) {
    uint64_t v52 = *(float32x2_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v53 = v14 + (int)v47 * (uint64_t)v16 + v49;
    uint64_t v54 = *(_DWORD **)(result + 40);
    if (v25 >= v53) {
      unint64_t v55 = (_DWORD *)(v14 + (int)v47 * (uint64_t)v16 + v49);
    }
    else {
      unint64_t v55 = (_DWORD *)v25;
    }
    if (v55 >= v54) {
      uint64_t v54 = v55;
    }
    LODWORD(a5) = *v54;
  }
  else
  {
    unint64_t v53 = 0;
    LODWORD(a5) = 1.0;
  }
  float32x2_t v57 = *v52;
  float32x2_t v56 = v52[1];
  if (v17)
  {
    unsigned int v58 = *(_DWORD *)(v17 + (v43 | v35));
LABEL_45:
    int v59 = v58 & 0xF;
    int v60 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      float32x2_t v77 = (float32x2_t *)(v50 + SBYTE1(v58) * (uint64_t)v15);
      if (v26 < (unint64_t)v77) {
        float32x2_t v77 = (float32x2_t *)v26;
      }
      if (v77 < v51) {
        float32x2_t v77 = v51;
      }
      float32x2_t v79 = *v77;
      float32x2_t v78 = v77[1];
      float v80 = 1.0;
      if (v14)
      {
        int64_t v81 = (float *)(v53 + SBYTE1(v58) * (uint64_t)v16);
        if (v25 < (unint64_t)v81) {
          int64_t v81 = (float *)v25;
        }
        if ((unint64_t)v81 < *(void *)(result + 40)) {
          int64_t v81 = *(float **)(result + 40);
        }
        float v80 = *v81;
      }
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          int64_t v61 = (unint64_t)HIWORD(v58) << 56;
          unint64_t v62 = v50 + (v61 >> 52);
          if (v26 >= v62) {
            uint64_t v63 = (float32x2_t *)(v50 + (v61 >> 52));
          }
          else {
            uint64_t v63 = (float32x2_t *)v26;
          }
          if (v63 < v51) {
            uint64_t v63 = v51;
          }
          unint64_t v64 = (float32x2_t *)(v62 + SBYTE1(v58) * (uint64_t)v15);
          if (v26 < (unint64_t)v64) {
            unint64_t v64 = (float32x2_t *)v26;
          }
          if (v64 < v51) {
            unint64_t v64 = v51;
          }
          float32x2_t v66 = *v63;
          float32x2_t v65 = v63[1];
          float32x2_t v68 = *v64;
          float32x2_t v67 = v64[1];
          float v69 = 1.0;
          float v70 = 1.0;
          if (v14)
          {
            unint64_t v71 = (float *)(v53 + (v61 >> 54));
            unint64_t v72 = *(void *)(result + 40);
            if (v25 >= (unint64_t)v71) {
              uint64_t v73 = v71;
            }
            else {
              uint64_t v73 = (float *)v25;
            }
            if ((unint64_t)v73 < v72) {
              uint64_t v73 = *(float **)(result + 40);
            }
            float v69 = *v73;
            float32x2_t v74 = (float *)((char *)v71 + SBYTE1(v58) * (uint64_t)v16);
            if (v25 < (unint64_t)v74) {
              float32x2_t v74 = (float *)v25;
            }
            if ((unint64_t)v74 < v72) {
              float32x2_t v74 = *(float **)(result + 40);
            }
            float v70 = *v74;
          }
          v11.i32[0] = interpolate_cmykaf[5 * v60 + 4];
          v12.i32[0] = interpolate_cmykaf[5 * ((v58 >> 28) & 3) + 4];
          float32x2_t v75 = vmla_n_f32(vmls_lane_f32(v57, v57, v11, 0), v66, v11.f32[0]);
          a11 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v66, v66, v11, 0), v68, v11.f32[0]));
          float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v75, v75, v12, 0), *(float32x2_t *)&a11, v12.f32[0]);
          float32x2_t v76 = vmla_n_f32(vmls_lane_f32(v56, v56, v11, 0), v65, v11.f32[0]);
          float32x2_t v56 = vmla_n_f32(vmls_lane_f32(v76, v76, v12, 0), vmla_n_f32(vmls_lane_f32(v65, v65, v11, 0), v67, v11.f32[0]), v12.f32[0]);
          *(float *)&a5 = (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                        + (float)(v69 * v11.f32[0]))
                                - (float)((float)((float)(*(float *)&a5 - (float)(*(float *)&a5 * v11.f32[0]))
                                                + (float)(v69 * v11.f32[0]))
                                        * v12.f32[0]))
                        + (float)((float)((float)(v69 - (float)(v69 * v11.f32[0])) + (float)(v70 * v11.f32[0]))
                                * v12.f32[0]);
        }
        goto LABEL_91;
      }
      int64_t v82 = (unint64_t)HIWORD(v58) << 56;
      float32x2_t v83 = (float32x2_t *)(v50 + (v82 >> 52));
      if (v26 < (unint64_t)v83) {
        float32x2_t v83 = (float32x2_t *)v26;
      }
      if (v83 < v51) {
        float32x2_t v83 = v51;
      }
      float32x2_t v79 = *v83;
      float32x2_t v78 = v83[1];
      float v80 = 1.0;
      if (v14)
      {
        uint64_t v84 = (float *)(v53 + (v82 >> 54));
        if (v25 < (unint64_t)v84) {
          uint64_t v84 = (float *)v25;
        }
        if ((unint64_t)v84 < *(void *)(result + 40)) {
          uint64_t v84 = *(float **)(result + 40);
        }
        float v80 = *v84;
      }
      int v60 = (v58 >> 28) & 3;
    }
    LODWORD(a11) = interpolate_cmykaf[5 * v60 + 4];
    float32x2_t v57 = vmla_n_f32(vmls_lane_f32(v57, v57, *(float32x2_t *)&a11, 0), v79, *(float *)&a11);
    float32x2_t v56 = vmla_n_f32(vmls_lane_f32(v56, v56, *(float32x2_t *)&a11, 0), v78, *(float *)&a11);
    *(float *)&a5 = (float)(*(float *)&a5 - (float)(*(float *)&a5 * *(float *)&a11)) + (float)(v80 * *(float *)&a11);
  }
LABEL_91:
  uint64_t v85 = 0;
  uint64_t v86 = (float *)(v21 + 28);
  a2 += v20;
  uint64_t v87 = v95 - a2;
  a3 += v19;
  uint64_t v88 = v96 - a3;
  while (1)
  {
    *(float32x2_t *)(v86 - 3) = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), v57), (float32x2_t)vdup_lane_s32((int32x2_t)v56, 1));
    *(v86 - 1) = (float)(*(float *)&a5 - v56.f32[0]) - v56.f32[1];
    float *v86 = *(float *)&a5;
    *(unsigned char *)(v22 + 1 + v85) = v36 >> 22;
    if (a4 - 1 == v85) {
      return result;
    }
    if ((v88 | v87 | (a3 - v18) | (a2 - v94)) < 0)
    {
      v22 += v85 + 1;
      uint64_t v21 = (uint64_t)(v86 - 3);
      a4 += ~v85;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    unint64_t v89 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v50 = v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v89;
    uint64_t v51 = *(float32x2_t **)(result + 32);
    if (v26 >= v50) {
      unint64_t v90 = (float32x2_t *)(v13 + SHIDWORD(a3) * (uint64_t)v15 + 4 * v89);
    }
    else {
      unint64_t v90 = (float32x2_t *)v26;
    }
    if (v90 < v51) {
      unint64_t v90 = *(float32x2_t **)(result + 32);
    }
    if (v14)
    {
      unint64_t v53 = v14 + SHIDWORD(a3) * (uint64_t)v16 + v89;
      float v91 = *(_DWORD **)(result + 40);
      if (v25 >= v53) {
        int v92 = (_DWORD *)v53;
      }
      else {
        int v92 = (_DWORD *)v25;
      }
      if (v92 >= v91) {
        float v91 = v92;
      }
      LODWORD(a5) = *v91;
    }
    else
    {
      LODWORD(a5) = 1.0;
    }
    float32x2_t v57 = *v90;
    float32x2_t v56 = v90[1];
    if (v17)
    {
      unsigned int v58 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v22 += v85 + 1;
        uint64_t v21 = (uint64_t)(v86 - 3);
        a4 += ~v85;
        unsigned int v36 = -1;
        goto LABEL_45;
      }
    }
    ++v85;
    v86 += 4;
    v87 -= v20;
    a3 += v19;
    v88 -= v19;
    a2 += v20;
    unsigned int v36 = -1;
  }
}

float32x2_t *RGBAf_pattern(uint64_t a1, float32x2_t *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  int v15 = *(_DWORD **)(*(void *)a1 + 64);
  LODWORD(a9) = *v15;
  LODWORD(a12) = v15[1];
  if (a2 && a3 > 0xF
    || (double v22 = a9,
        double v23 = a12,
        int v16 = (float32x2_t *)malloc_type_malloc(0x40uLL, 0x705560E0uLL),
        a9 = v22,
        a12 = v23,
        (a2 = v16) != 0))
  {
    if (*(float *)&a9 <= a6) {
      float v17 = a6;
    }
    else {
      float v17 = *(float *)&a9;
    }
    if (*(float *)&a12 < a6) {
      float v17 = *(float *)&a12;
    }
    if (a5) {
      int v18 = a4;
    }
    else {
      int v18 = 0;
    }
    switch(v18)
    {
      case 1:
        *(float *)&a9 = v17 * a5->f32[0];
        break;
      case 4:
        LODWORD(a8) = a5[2].i32[0];
        float32x2_t v19 = vmul_n_f32(vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a12, 0), *a5), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0)), v17);
        *(float *)&a8 = (float)(*(float *)&a12 - a5[1].f32[0]) - *(float *)&a8;
        goto LABEL_19;
      case 3:
        float32x2_t v19 = vmul_n_f32(*a5, v17);
        LODWORD(a8) = a5[1].i32[0];
LABEL_19:
        *(float *)&a9 = v17 * *(float *)&a8;
        goto LABEL_20;
    }
    float32x2_t v19 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
LABEL_20:
    *(_OWORD *)a2->f32 = xmmword_1850CDBE0;
    a2[3].i32[0] = 0;
    a2[2] = (float32x2_t)1;
    a2[6] = v19;
    if (v17 >= *(float *)&a12) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = a2 + 6;
    }
    a2[4] = (float32x2_t)&a2[6];
    a2[5] = (float32x2_t)v20;
    a2[7].i32[0] = LODWORD(a9);
    a2[7].f32[1] = v17;
  }
  return a2;
}

uint64_t RGBAf_mark(uint64_t *a1, __n128 a2)
{
  return RGBAf_mark_inner(*a1, a2);
}

uint64_t RGBAf_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v218 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = *(void *)(v3 + 48);
  uint64_t v18 = *(unsigned int *)(*(void *)(v2 + 56)
                        + 16 * *(_DWORD *)v3
                        + 8 * (*(void *)(v3 + 96) == 0)
                        + 4 * (v17 == 0));
  if ((int)v18 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v20 = v3;
  int v21 = *(_DWORD *)(v3 + 4);
  if (v21 < 1) {
    return 0;
  }
  int v22 = *(_DWORD *)(v3 + 8);
  if (v22 < 1) {
    return 0;
  }
  double v23 = (_DWORD *)v2;
  unsigned int v24 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v24)
  {
    if ((*(_DWORD *)v3 & 0xFF00) != 0x400)
    {
      RGBAf_mark_pixelshape(v2, v3, v18, v4, v5, v6, *(int8x8_t *)&v9, v10, v11, v12, v13, v14, v15, v16);
      return 1;
    }
    v217[0] = *(_DWORD *)(v3 + 4);
    v207[0] = v22;
    uint64_t v26 = *(void *)(v3 + 40);
    float32x4_t v27 = *(float32x4_t *)*(void *)(v3 + 88);
    float v28 = v27.f32[3];
    *(float *)&double v12 = 1.0 - v27.f32[3];
    unint64_t v29 = (unint64_t)*(int *)(v3 + 28) >> 4;
    unint64_t v30 = *(int *)(v3 + 12) + v29 * *(int *)(v3 + 16);
    uint64_t v31 = v26 + 16 * v30;
    double v204 = v12;
    float32x4_t v205 = v27;
    int v202 = *(_DWORD *)(v3 + 28);
    uint64_t v203 = v31;
    if (v24)
    {
      shape_enum_clip_alloc(v2, v3, (int *)v24, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v21, v22);
      uint64_t v33 = v32;
      if (!v32) {
        return 1;
      }
      goto LABEL_287;
    }
    uint64_t v33 = 0;
    uint64_t v40 = (float32x4_t *)(v26 + 16 * v30);
LABEL_27:
    unint64_t v60 = v29 - v21;
    switch((int)v18)
    {
      case 0:
        unsigned int v61 = v207[0];
        int v62 = 16 * v21;
        goto LABEL_293;
      case 1:
        uint64_t v63 = *(void *)(v20 + 88);
        if (v63)
        {
          CGSFillDRAM64((unint64_t)v40, v202 & 0xFFFFFFF0, 16 * v21, v207[0], v63, 16, 16, 1, 0, 0);
          if (!v33) {
            return 1;
          }
          goto LABEL_286;
        }
        int v62 = 16 * v21;
        unsigned int v61 = v207[0];
LABEL_293:
        CGBlt_fillBytes(v62, v61, 0, (char *)v40, v202 & 0xFFFFFFF0);
        if (v33) {
          goto LABEL_286;
        }
        return 1;
      case 2:
        int v64 = v207[0];
        float32x4_t v65 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
        do
        {
          if (v21 < 4)
          {
            int v69 = v21;
          }
          else
          {
            unsigned int v66 = (v21 >> 2) + 1;
            do
            {
              float32x4_t v67 = vmlaq_f32(v27, v65, v40[1]);
              float32x4_t *v40 = vmlaq_f32(v27, v65, *v40);
              v40[1] = v67;
              float32x4_t v68 = vmlaq_f32(v27, v65, v40[3]);
              v40[2] = vmlaq_f32(v27, v65, v40[2]);
              v40[3] = v68;
              v40 += 4;
              --v66;
            }
            while (v66 > 1);
            int v69 = v21 & 3;
          }
          if (v69 >= 1)
          {
            unsigned int v70 = v69 + 1;
            do
            {
              float32x4_t *v40 = vmlaq_f32(v27, v65, *v40);
              ++v40;
              --v70;
            }
            while (v70 > 1);
          }
          v40 += v60;
          --v64;
        }
        while (v64);
        goto LABEL_239;
      case 3:
        int v71 = v207[0];
        do
        {
          int v72 = v21;
          do
          {
            float v73 = v40->f32[3];
            if (v73 <= 0.0)
            {
              v40->i64[0] = 0;
              v40->i64[1] = 0;
            }
            else if (v73 >= 1.0)
            {
              float32x4_t *v40 = v27;
            }
            else
            {
              float32x4_t *v40 = vmulq_n_f32(v27, v73);
            }
            ++v40;
            --v72;
          }
          while (v72);
          v40 += v60;
          --v71;
        }
        while (v71);
        goto LABEL_239;
      case 4:
        int v74 = v207[0];
        do
        {
          int v75 = v21;
          do
          {
            float v76 = 1.0 - v40->f32[3];
            if (v76 <= 0.0)
            {
              v40->i64[0] = 0;
              v40->i64[1] = 0;
            }
            else if (v76 >= 1.0)
            {
              float32x4_t *v40 = v27;
            }
            else
            {
              float32x4_t *v40 = vmulq_n_f32(v27, v76);
            }
            ++v40;
            --v75;
          }
          while (v75);
          v40 += v60;
          --v74;
        }
        while (v74);
        goto LABEL_239;
      case 5:
        int v77 = v207[0];
        do
        {
          int v78 = v21;
          do
          {
            float32x4_t *v40 = vmlaq_laneq_f32(vmulq_n_f32(*v40, *(float *)&v12), v27, *v40, 3);
            ++v40;
            --v78;
          }
          while (v78);
          v40 += v60;
          --v77;
        }
        while (v77);
        goto LABEL_239;
      case 6:
        int v79 = v207[0];
        while (1)
        {
          int v80 = v21;
          do
          {
            float v81 = v40->f32[3];
            float v82 = 1.0 - v81;
            if ((float)(1.0 - v81) >= 1.0)
            {
              v40->i64[0] = v27.i64[0];
              v40->i32[2] = v27.i32[2];
              float v83 = v28;
            }
            else
            {
              if (v82 <= 0.0) {
                goto LABEL_75;
              }
              *(float32x2_t *)v40->f32 = vmla_n_f32(*(float32x2_t *)v40->f32, *(float32x2_t *)v27.f32, v82);
              v40->f32[2] = v40->f32[2] + (float)(v27.f32[2] * v82);
              float v83 = v81 + (float)(v28 * v82);
            }
            v40->f32[3] = v83;
LABEL_75:
            ++v40;
            --v80;
          }
          while (v80);
          v40 += v60;
          if (!--v79) {
            goto LABEL_239;
          }
        }
      case 7:
        int v84 = v207[0];
        do
        {
          int v85 = v21;
          do
          {
            float32x4_t *v40 = vmulq_laneq_f32(*v40, v27, 3);
            ++v40;
            --v85;
          }
          while (v85);
          v40 += v60;
          --v84;
        }
        while (v84);
        goto LABEL_239;
      case 8:
        int v86 = v207[0];
        do
        {
          int v87 = v21;
          do
          {
            float32x4_t *v40 = vmulq_n_f32(*v40, *(float *)&v12);
            ++v40;
            --v87;
          }
          while (v87);
          v40 += v60;
          --v86;
        }
        while (v86);
        goto LABEL_239;
      case 9:
        int v88 = v207[0];
        do
        {
          int v89 = v21;
          do
          {
            float32x4_t *v40 = vmlaq_n_f32(vmulq_laneq_f32(*v40, v27, 3), v27, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v40)));
            ++v40;
            --v89;
          }
          while (v89);
          v40 += v60;
          --v88;
        }
        while (v88);
        goto LABEL_239;
      case 10:
        int v90 = v207[0];
        do
        {
          int v91 = v21;
          do
          {
            float32x4_t *v40 = vmlaq_n_f32(vmulq_n_f32(*v40, *(float *)&v12), v27, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v40)));
            ++v40;
            --v91;
          }
          while (v91);
          v40 += v60;
          --v90;
        }
        while (v90);
        goto LABEL_239;
      case 11:
        float v92 = v28 - v27.f32[0];
        float v93 = v28 + 1.0;
        if ((float)(v28 + 1.0) > 1.0) {
          float v93 = 1.0;
        }
        int v94 = v207[0];
        do
        {
          int v95 = v21;
          do
          {
            if (v17)
            {
              float v96 = v40->f32[3];
              float v97 = v28 + v96;
              if ((float)(v28 + v96) > 1.0) {
                float v97 = 1.0;
              }
              uint64_t v98 = &v40->f32[1];
              float v99 = v96 - v40->f32[1];
              v27.f32[0] = v97 - (float)(v92 + (float)(v96 - v40->f32[0]));
            }
            else
            {
              float v96 = 1.0;
              uint64_t v98 = &v40->f32[1];
              float v99 = 1.0 - v40->f32[1];
              v27.f32[0] = v93 - (float)(v92 + (float)(1.0 - v40->f32[0]));
              float v97 = v93;
            }
            v40->i32[0] = v27.i32[0];
            v27.i32[0] = v40->i32[2];
            *uint64_t v98 = v97 - (float)((float)(v28 - v27.f32[1]) + v99);
            v40->f32[2] = v97 - (float)((float)(v28 - v27.f32[2]) + (float)(v96 - v27.f32[0]));
            v40->f32[3] = v97;
            ++v40;
            --v95;
          }
          while (v95);
          v40 += v60;
          --v94;
        }
        while (v94);
        goto LABEL_239;
      case 12:
        int v100 = v207[0];
        do
        {
          int v101 = v21;
          do
          {
            *(float32x2_t *)v40->f32 = vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32);
            float v102 = v28 + v40->f32[3];
            if (v102 > 1.0) {
              float v102 = 1.0;
            }
            v40->f32[2] = v27.f32[2] + v40->f32[2];
            v40->f32[3] = v102;
            ++v40;
            --v101;
          }
          while (v101);
          v40 += v60;
          --v100;
        }
        while (v100);
        goto LABEL_239;
      case 13:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v103 = v27.i32[2];
        int v104 = v207[0];
        while (1)
        {
          int v105 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v106 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_125;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v106 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v107 = PDAmultiplyPDA(v40->f32[0], v10, v11, v12, v106, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v103)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v107;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_125:
            ++v40;
            --v105;
          }
          while (v105);
          v40 += v60;
          if (!--v104) {
            goto LABEL_284;
          }
        }
      case 14:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        int v108 = v207[0];
        __asm { FMOV            V2.2S, #1.0 }
        while (1)
        {
          int v114 = v21;
          do
          {
            if (v17)
            {
              float v115 = v40->f32[3];
              if (v115 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_136;
              }
            }
            else
            {
              float v115 = 1.0;
            }
            float32_t v116 = v40->f32[2] + (float)(v27.f32[2] * (float)(1.0 - v40->f32[2]));
            *(float32x2_t *)v40->f32 = vmla_f32(*(float32x2_t *)v40->f32, vsub_f32(_D2, *(float32x2_t *)v40->f32), *(float32x2_t *)v27.f32);
            v40->f32[2] = v116;
            v40->f32[3] = (float)(v28 + v115) - (float)(v115 * v28);
LABEL_136:
            ++v40;
            --v114;
          }
          while (v114);
          v40 += v60;
          if (!--v108) {
            goto LABEL_239;
          }
        }
      case 15:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v117 = v27.i32[2];
        int v118 = v207[0];
        while (1)
        {
          int v119 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v120 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_147;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v120 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v121 = PDAoverlayPDA(v40->f32[0], v10, v11, v12, v120, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v117)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v121;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_147:
            ++v40;
            --v119;
          }
          while (v119);
          v40 += v60;
          if (!--v118) {
            goto LABEL_284;
          }
        }
      case 16:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v122 = v27.i32[2];
        int v123 = v207[0];
        while (1)
        {
          int v124 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v125 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_158;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v125 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v126 = PDAdarkenPDA(v40->f32[0], v10, v11, v12, v125, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v122)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v126;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_158:
            ++v40;
            --v124;
          }
          while (v124);
          v40 += v60;
          if (!--v123) {
            goto LABEL_284;
          }
        }
      case 17:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v127 = v27.i32[2];
        int v128 = v207[0];
        while (1)
        {
          int v129 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v130 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_169;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v130 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v131 = PDAlightenPDA(v40->f32[0], v10, v11, v12, v130, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v127)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v131;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_169:
            ++v40;
            --v129;
          }
          while (v129);
          v40 += v60;
          if (!--v128) {
            goto LABEL_284;
          }
        }
      case 18:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v132 = v27.i32[2];
        int v133 = v207[0];
        while (1)
        {
          int v134 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v135 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_180;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v135 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v136 = PDAcolordodgePDA(v40->f32[0], v10, v11, v12, v135, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v132)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v136;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_180:
            ++v40;
            --v134;
          }
          while (v134);
          v40 += v60;
          if (!--v133) {
            goto LABEL_284;
          }
        }
      case 19:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v137 = v27.i32[2];
        int v138 = v207[0];
        while (1)
        {
          int v139 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v140 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_191;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v140 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v141 = PDAcolorburnPDA(v40->f32[0], v10, v11, v12, v140, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v137)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v141;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_191:
            ++v40;
            --v139;
          }
          while (v139);
          v40 += v60;
          if (!--v138) {
            goto LABEL_284;
          }
        }
      case 20:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        unsigned int v142 = v27.u32[1];
        __int32 v143 = v27.i32[2];
        int v144 = v207[0];
        while (1)
        {
          int v145 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              LODWORD(v13) = LODWORD(v12);
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_202;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              LODWORD(v13) = 1.0;
            }
            LODWORD(v11) = v40->i32[2];
            float v146 = PDAsoftlightPDA(v40->f32[0], v40->f32[1], v11, *(int32x2_t *)&v12, v13, v14, v15, v16, v2, v3, (uint64_t)v24, v4, v5, v6, v7, v8, v27.f32[0], v142, __SPAIR64__(LODWORD(v28), v143),
                     v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v146;
            v40->i32[1] = v147;
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_202:
            ++v40;
            --v145;
          }
          while (v145);
          v40 += v60;
          if (!--v144) {
            goto LABEL_284;
          }
        }
      case 21:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        __int32 v148 = v27.i32[2];
        int v149 = v207[0];
        while (1)
        {
          int v150 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v151 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_213;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v151 = 1.0;
            }
            LODWORD(v10) = v40->i32[1];
            LODWORD(v11) = v40->i32[2];
            float v152 = PDAhardlightPDA(v40->f32[0], v10, v11, v12, v151, v14, v15, v16, v27.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v28), v148)), v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v152;
            v40->i32[1] = LODWORD(v10);
            v40->i32[2] = LODWORD(v11);
            v40->i32[3] = LODWORD(v12);
LABEL_213:
            ++v40;
            --v150;
          }
          while (v150);
          v40 += v60;
          if (!--v149) {
            goto LABEL_284;
          }
        }
      case 22:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        int v153 = v207[0];
        while (1)
        {
          int v154 = v21;
          do
          {
            if (v17)
            {
              float v155 = v40->f32[3];
              if (v155 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_226;
              }
            }
            else
            {
              float v155 = 1.0;
            }
            float v156 = v40->f32[2];
            float32x2_t v157 = vmul_laneq_f32(*(float32x2_t *)v40->f32, v27, 3);
            float32x2_t v158 = vmul_n_f32(*(float32x2_t *)v27.f32, v155);
            float32x2_t v159 = vsub_f32(vadd_f32(*(float32x2_t *)v40->f32, *(float32x2_t *)v27.f32), v157);
            float32x2_t v160 = vsub_f32(v157, v158);
            float32x2_t v161 = vadd_f32(vsub_f32(v159, v158), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v160), (int8x8_t)vneg_f32(v160), (int8x8_t)v160));
            v159.f32[0] = v156 + v27.f32[2];
            float v162 = v156 * v28;
            v159.f32[0] = v159.f32[0] - v162;
            float v163 = v162 - (float)(v27.f32[2] * v155);
            float v164 = v159.f32[0] - (float)(v27.f32[2] * v155);
            if (v163 < 0.0) {
              float v163 = -v163;
            }
            *(float32x2_t *)v40->f32 = v161;
            v40->f32[2] = v164 + v163;
            v40->f32[3] = (float)(v155 + v28) - (float)(v155 * v28);
LABEL_226:
            ++v40;
            --v154;
          }
          while (v154);
          v40 += v60;
          if (!--v153)
          {
LABEL_239:
            v207[0] = 0;
            if (!v33) {
              return 1;
            }
LABEL_286:
            uint64_t v206 = 0;
LABEL_287:
            uint64_t v2 = shape_enum_clip_next(v33, (int *)&v206 + 1, &v206, v217, v207);
            if (v2)
            {
              uint64_t v40 = (float32x4_t *)(v31 + 16 * v29 * (int)v206 + 16 * SHIDWORD(v206));
              int v21 = v217[0];
              double v12 = v204;
              float32x4_t v27 = v205;
              goto LABEL_27;
            }
            int v59 = (void *)v33;
LABEL_290:
            free(v59);
            return 1;
          }
        }
      case 23:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        int v165 = v207[0];
        while (1)
        {
          int v166 = v21;
          do
          {
            if (v17)
            {
              float v167 = v40->f32[3];
              if (v167 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_237;
              }
            }
            else
            {
              float v167 = 1.0;
            }
            float32_t v168 = (float)(v27.f32[2] + v40->f32[2]) + (float)((float)(v27.f32[2] * v40->f32[2]) * -2.0);
            *(float32x2_t *)v40->f32 = vmla_f32(vadd_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v27.f32, *(float32x2_t *)v40->f32));
            v40->f32[2] = v168;
            v40->f32[3] = (float)(v28 + v167) - (float)(v167 * v28);
LABEL_237:
            ++v40;
            --v166;
          }
          while (v166);
          v40 += v60;
          if (!--v165) {
            goto LABEL_239;
          }
        }
      case 24:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        float v169 = v27.f32[1];
        float v170 = v27.f32[2];
        int v171 = v207[0];
        while (1)
        {
          int v172 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v173 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_249;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v173 = 1.0;
            }
            float v174 = PDAhuePDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v173, v14, v15, v16, v27.f32[0], v169, v170, v28, v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v174;
            v40->i32[1] = v175;
            v40->i32[2] = v176;
            v40->i32[3] = LODWORD(v12);
LABEL_249:
            ++v40;
            --v172;
          }
          while (v172);
          v40 += v60;
          if (!--v171) {
            goto LABEL_284;
          }
        }
      case 25:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        float v177 = v27.f32[1];
        float v178 = v27.f32[2];
        int v179 = v207[0];
        while (1)
        {
          int v180 = v21;
          do
          {
            if (v17)
            {
              LODWORD(v12) = v40->i32[3];
              float v181 = *(float *)&v12;
              if (*(float *)&v12 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_260;
              }
            }
            else
            {
              LODWORD(v12) = v40->i32[3];
              float v181 = 1.0;
            }
            float v182 = PDAsaturationPDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v181, v14, v15, v16, v27.f32[0], v177, v178, v28, v28);
            float32x4_t v27 = v205;
            v40->f32[0] = v182;
            v40->i32[1] = v183;
            v40->i32[2] = v184;
            v40->i32[3] = LODWORD(v12);
LABEL_260:
            ++v40;
            --v180;
          }
          while (v180);
          v40 += v60;
          if (!--v179) {
            goto LABEL_284;
          }
        }
      case 26:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        float v185 = v27.f32[1];
        float v186 = v27.f32[2];
        int v187 = v207[0];
        while (1)
        {
          int v188 = v21;
          do
          {
            if (v17)
            {
              float v189 = v40->f32[3];
              float v190 = v189;
              if (v189 <= 0.0)
              {
                float32x4_t *v40 = v27;
                goto LABEL_271;
              }
            }
            else
            {
              float v189 = v40->f32[3];
              float v190 = 1.0;
            }
            *(float *)&double v12 = v28;
            float v191 = PDAluminosityPDA(v27.f32[0], v185, v186, v12, v28, v14, v15, v16, COERCE_FLOAT(v40->i64[0]), COERCE_FLOAT(HIDWORD(v40->i64[0])), v40->f32[2], v189, v190);
            float32x4_t v27 = v205;
            v40->f32[0] = v191;
            v40->i32[1] = v192;
            v40->i32[2] = v193;
            v40->i32[3] = LODWORD(v12);
LABEL_271:
            ++v40;
            --v188;
          }
          while (v188);
          v40 += v60;
          if (!--v187) {
            goto LABEL_284;
          }
        }
      case 27:
        if (v28 <= 0.0) {
          goto LABEL_285;
        }
        float v194 = v27.f32[1];
        float v195 = v27.f32[2];
        int v196 = v207[0];
        break;
      default:
        goto LABEL_285;
    }
LABEL_276:
    int v197 = v21;
    while (v17)
    {
      LODWORD(v12) = v40->i32[3];
      float v198 = *(float *)&v12;
      if (*(float *)&v12 > 0.0) {
        goto LABEL_281;
      }
      float32x4_t *v40 = v27;
LABEL_282:
      ++v40;
      if (!--v197)
      {
        v40 += v60;
        if (!--v196)
        {
LABEL_284:
          v207[0] = 0;
          uint64_t v31 = v203;
LABEL_285:
          if (v33) {
            goto LABEL_286;
          }
          return 1;
        }
        goto LABEL_276;
      }
    }
    LODWORD(v12) = v40->i32[3];
    float v198 = 1.0;
LABEL_281:
    float v199 = PDAluminosityPDA(v40->f32[0], v40->f32[1], v40->f32[2], v12, v198, v14, v15, v16, v27.f32[0], v194, v195, v28, v28);
    float32x4_t v27 = v205;
    v40->f32[0] = v199;
    v40->i32[1] = v200;
    v40->i32[2] = v201;
    v40->i32[3] = LODWORD(v12);
    goto LABEL_282;
  }
  uint64_t v25 = *(unsigned int *)(v3 + 128);
  if ((v25 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      RGBAf_mark_constmask(v3, v18, (uint64_t)v24, v4, v5, v6, v25, v8, v9, v10, v11, v12, v13, v14, v15, v16);
    }
    else {
      RGBAf_mark_pixelmask((_DWORD *)v2, (int *)v3, v18, v9, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  else
  {
    int v34 = *(_DWORD *)(v3 + 112);
    int v35 = *(_DWORD *)(v3 + 116);
    unsigned int v36 = (v34 + 15) & 0xFFFFFFF0;
    size_t v37 = v36 * v35;
    if ((int)v37 <= 4096)
    {
      uint64_t v39 = v217;
    }
    else
    {
      uint64_t v38 = malloc_type_malloc(v37, 0xF1367701uLL);
      if (!v38) {
        return 1;
      }
      uint64_t v39 = v38;
      unsigned int v24 = *(uint16x4_t **)(v20 + 136);
      LODWORD(v25) = *(_DWORD *)(v20 + 128);
    }
    CGSConvertBitsToMask(v24, *(_DWORD *)(v20 + 124), v39, v36, v34, v35, v25);
    long long v53 = *(_OWORD *)(v20 + 112);
    long long v213 = *(_OWORD *)(v20 + 96);
    long long v214 = v53;
    long long v54 = *(_OWORD *)(v20 + 144);
    long long v215 = *(_OWORD *)(v20 + 128);
    long long v216 = v54;
    long long v55 = *(_OWORD *)(v20 + 48);
    long long v209 = *(_OWORD *)(v20 + 32);
    long long v210 = v55;
    long long v56 = *(_OWORD *)(v20 + 80);
    long long v211 = *(_OWORD *)(v20 + 64);
    long long v212 = v56;
    long long v57 = *(_OWORD *)v20;
    long long v58 = *(_OWORD *)(v20 + 16);
    *(_OWORD *)v207 = *(_OWORD *)v20;
    long long v208 = v58;
    HIDWORD(v214) = (v34 + 15) & 0xFFFFFFF0;
    *((void *)&v215 + 1) = v39;
    if (BYTE1(v207[0]) << 8 == 1024) {
      RGBAf_mark_constmask((uint64_t)v207, v18, v41, v42, v43, v44, v45, v46, *(double *)&v57, *(double *)&v58, v47, v48, v49, v50, v51, v52);
    }
    else {
      RGBAf_mark_pixelmask(v23, v207, v18, *(double *)&v57, *(double *)&v58, v47, v48, v49, v50, v51, v52);
    }
    if (v39 != (unsigned char *)v217)
    {
      int v59 = v39;
      goto LABEL_290;
    }
  }
  return 1;
}

float PDAmultiplyPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = a1 * a9;
  float result = (float)(a1 * a9) + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0) {
    float result = v16;
  }
  if (a5 != 1.0) {
    return result + (float)(a9 * (float)(1.0 - a5));
  }
  return result;
}

float PDAoverlayPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = (float)(a1 * a9) + (float)(a1 * a9);
  BOOL v17 = a1 < (float)(a5 * 0.5);
  float v18 = (float)((float)((float)((float)(a5 + 1.0) * a9) + (float)(a1 * (float)(a11 + 1.0))) - v16) - (float)(a5 * a11);
  float result = (float)((float)((float)(1.0 - a5) * a9) + (float)(a1 * (float)(1.0 - a11))) + v16;
  if (!v17) {
    return v18;
  }
  return result;
}

float PDAlightenPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = a1 * a11;
  if ((float)(a9 * a5) > (float)(a1 * a11)) {
    float v16 = a9 * a5;
  }
  float result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0) {
    float result = v16;
  }
  if (a5 != 1.0) {
    return result + (float)(a9 * (float)(1.0 - a5));
  }
  return result;
}

float PDAdarkenPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = a1 * a11;
  if ((float)(a9 * a5) < (float)(a1 * a11)) {
    float v16 = a9 * a5;
  }
  float result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0) {
    float result = v16;
  }
  if (a5 != 1.0) {
    return result + (float)(a9 * (float)(1.0 - a5));
  }
  return result;
}

float PDAcolordodgePDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = 0.0;
  if (a1 != 0.0)
  {
    float v16 = 1.0;
    if (a9 != a11) {
      float v16 = (float)(a1 * (float)(a11 * a11)) / (float)(a11 - a9);
    }
  }
  float result = v16 + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0) {
    float result = v16;
  }
  if (a5 != 1.0) {
    float result = result + (float)(a9 * (float)(1.0 - a5));
  }
  if (result > (float)((float)(a5 + a11) - (float)(a5 * a11))) {
    return (float)(a5 + a11) - (float)(a5 * a11);
  }
  return result;
}

float PDAcolorburnPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v17 = (float)(a5 * a11) + (float)(a1 * (float)(1.0 - a11));
  if (a11 == 1.0) {
    float v17 = a5 * a11;
  }
  if (a5 == 1.0) {
    float result = v17;
  }
  else {
    float result = v17 + (float)(a9 * (float)(1.0 - a5));
  }
  float v19 = a5 - a1;
  if (v19 != 0.0)
  {
    if (a9 == 0.0) {
      return 0.0;
    }
    float result = result - (float)((float)(v19 * (float)(a11 * a11)) / a9);
    if (result < 0.0) {
      return 0.0;
    }
  }
  return result;
}

float PDAhardlightPDA(float a1, double a2, double a3, double a4, float a5, double a6, double a7, double a8, float a9, double a10, float a11)
{
  float v16 = (float)(a1 * a9) + (float)(a1 * a9);
  float v17 = (float)((float)((float)(1.0 - a5) * a9) + (float)(a1 * (float)(1.0 - a11))) + v16;
  float result = (float)((float)((float)((float)(a5 + 1.0) * a9) + (float)(a1 * (float)(a11 + 1.0))) - v16)
         - (float)(a5 * a11);
  if (a9 <= (float)(a11 * 0.5)) {
    return v17;
  }
  return result;
}

float PDAsoftlightPDA(float a1, float a2, double a3, int32x2_t a4, double a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, unsigned int a18, uint64_t a19, float a20)
{
  *(float *)a4.i32 = a20;
  if (*(float *)&a5 == 0.0)
  {
    v19.i32[1] = 0;
  }
  else
  {
    float32x2_t v17 = vmul_f32((float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2)), (float32x2_t)__PAIR64__(LODWORD(a17), a18));
    float32x2_t v18 = vsub_f32(vadd_f32(v17, v17), vdiv_f32(vmul_f32(vmul_f32((float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2)), (float32x2_t)__PAIR64__(LODWORD(a1), LODWORD(a2))), vsub_f32(vadd_f32((float32x2_t)__PAIR64__(LODWORD(a17), a18), (float32x2_t)__PAIR64__(LODWORD(a17), a18)), (float32x2_t)vdup_lane_s32(a4, 0))), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0)));
    int8x8_t v19 = vbic_s8((int8x8_t)v18, (int8x8_t)vcltz_f32(v18));
  }
  float result = *(float *)&v19.i32[1] + (float)(a1 * (float)(1.0 - a20));
  if (a20 == 1.0) {
    float result = *(float *)&v19.i32[1];
  }
  if (*(float *)&a5 != 1.0) {
    return result + (float)(a17 * (float)(1.0 - *(float *)&a5));
  }
  return result;
}

float PDAhuePDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  float v18 = a1 * a13;
  float v19 = a1 - (float)(a1 * a13);
  if (a13 == 1.0) {
    float v19 = 0.0;
  }
  else {
    a3 = a3 * a13;
  }
  if (a13 == 1.0) {
    float v20 = a2;
  }
  else {
    float v20 = a2 * a13;
  }
  if (a13 == 1.0) {
    float v18 = a1;
  }
  float v21 = (float)(a9 + v19) - (float)(a9 * a5);
  float v22 = a10 * a5;
  if (a5 == 1.0) {
    float v23 = a9;
  }
  else {
    float v23 = a9 * a5;
  }
  if (a5 == 1.0)
  {
    float v22 = a10;
    float v24 = a11;
  }
  else
  {
    float v24 = a11 * a5;
  }
  if (a5 == 1.0) {
    float v21 = v19;
  }
  float v35 = v23;
  float v36 = v22;
  float v37 = v24;
  uint64_t v25 = v23 < v22;
  BOOL v26 = v23 >= v22;
  if (v24 >= *(&v35 + v26))
  {
    uint64_t v27 = v23 >= v22;
    if (v24 > *(&v35 + v25))
    {
      BOOL v26 = v23 < v22;
      uint64_t v25 = 2;
    }
  }
  else
  {
    uint64_t v27 = 2;
  }
  float v28 = *(&v35 + v25);
  float v29 = *(&v35 + v27);
  if (v28 <= v29)
  {
    *(&v35 + v25) = 0.0;
    *(&v35 + v26) = 0.0;
  }
  else
  {
    if (v18 >= v20) {
      float v30 = v20;
    }
    else {
      float v30 = v18;
    }
    if (v18 >= v20) {
      float v31 = v18;
    }
    else {
      float v31 = v20;
    }
    if (a3 > v31) {
      float v32 = a3;
    }
    else {
      float v32 = v31;
    }
    if (a3 >= v30) {
      float v31 = v32;
    }
    else {
      float v30 = a3;
    }
    float v33 = v31 - v30;
    *(&v35 + v25) = v33;
    *(&v35 + v26) = (float)(v33 / (float)(v28 - v29)) * (float)(*(&v35 + v26) - *(&v35 + v27));
  }
  *(&v35 + v27) = 0.0;
  return v21
       + (float)(v35
               + (float)((float)((float)((float)(v20 - v36) * 0.59) + (float)((float)(v18 - v35) * 0.3))
                       + (float)((float)(a3 - v37) * 0.11)));
}

float PDAsaturationPDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a13 == 1.0)
  {
    float v18 = 0.0;
  }
  else
  {
    float v18 = a1 - (float)(a1 * a13);
    a3 = a3 * a13;
    a2 = a2 * a13;
    a1 = a1 * a13;
  }
  float v19 = a9 * a5;
  float v20 = a10 * a5;
  if (a5 == 1.0)
  {
    float v19 = a9;
    float v20 = a10;
    float v21 = a11;
  }
  else
  {
    float v21 = a11 * a5;
  }
  if (a5 == 1.0) {
    float v22 = v18;
  }
  else {
    float v22 = (float)(a9 + v18) - (float)(a9 * a5);
  }
  float v32 = a1;
  float v33 = a2;
  float v34 = a3;
  uint64_t v23 = a1 < a2;
  BOOL v24 = a1 >= a2;
  if (a3 >= *(&v32 + v24))
  {
    uint64_t v25 = a1 >= a2;
    if (a3 > *(&v32 + v23))
    {
      BOOL v24 = a1 < a2;
      uint64_t v23 = 2;
    }
  }
  else
  {
    uint64_t v25 = 2;
  }
  float v26 = *(&v32 + v23);
  float v27 = *(&v32 + v25);
  if (v26 <= v27)
  {
    *(&v32 + v23) = 0.0;
    *(&v32 + v24) = 0.0;
  }
  else
  {
    if (v19 >= v20) {
      float v28 = v20;
    }
    else {
      float v28 = v19;
    }
    if (v19 < v20) {
      float v19 = v20;
    }
    if (v21 > v19) {
      float v29 = v21;
    }
    else {
      float v29 = v19;
    }
    if (v21 >= v28)
    {
      float v21 = v28;
      float v19 = v29;
    }
    float v30 = v19 - v21;
    *(&v32 + v23) = v30;
    *(&v32 + v24) = (float)(v30 / (float)(v26 - v27)) * (float)(*(&v32 + v24) - *(&v32 + v25));
  }
  *(&v32 + v25) = 0.0;
  return v22
       + (float)(v32
               + (float)((float)((float)((float)(a2 - v33) * 0.59) + (float)((float)(a1 - v32) * 0.3))
                       + (float)((float)(a3 - v34) * 0.11)));
}

float PDAluminosityPDA(float a1, float a2, float a3, double a4, float a5, double a6, double a7, double a8, float a9, float a10, float a11, float a12, float a13)
{
  float v18 = a9;
  float v19 = a10;
  float v20 = a11;
  float v21 = a1 - (float)(a1 * a13);
  if (a13 == 1.0) {
    float v21 = 0.0;
  }
  else {
    a3 = a3 * a13;
  }
  if (a13 != 1.0)
  {
    a2 = a2 * a13;
    a1 = a1 * a13;
  }
  float v22 = (float)(a9 + v21) - (float)(a9 * a5);
  if (a5 == 1.0)
  {
    float v22 = v21;
  }
  else
  {
    float v18 = a9 * a5;
    float v19 = a10 * a5;
    float v20 = a11 * a5;
  }
  return v22
       + (float)(a1
               + (float)((float)((float)((float)(v19 - a2) * 0.59) + (float)((float)(v18 - a1) * 0.3))
                       + (float)((float)(v20 - a3) * 0.11)));
}

void RGBAf_mark_pixelshape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int8x8_t a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v14 = a3;
  v1533 = (unsigned char *)a1;
  int v15 = *(_DWORD *)a2;
  int v16 = *(_DWORD *)(a2 + 4);
  uint64_t v17 = *(int *)(a2 + 8);
  unsigned int v1552 = *(_DWORD *)(a2 + 8);
  v1553[0] = v16;
  unint64_t v18 = *(int *)(a2 + 28);
  uint64_t v19 = *(void *)(a2 + 40);
  uint64_t v20 = *(void *)(a2 + 48);
  unint64_t v22 = *(void *)(a2 + 88);
  uint64_t v21 = *(void *)(a2 + 96);
  uint64_t v23 = *(int **)(a2 + 136);
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1) {
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_9_13630);
  }
  int v1546 = v16;
  int64_t v24 = v16;
  int v1534 = v14;
  int v1535 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
  unint64_t v25 = v18 >> 4;
  float v26 = (float32x4_t *)(v19 + 16 * (*(int *)(a2 + 12) + (v18 >> 4) * *(int *)(a2 + 16)));
  uint64_t v27 = *(unsigned int *)(a2 + 104);
  uint64_t v28 = *(unsigned int *)(a2 + 108);
  int v29 = v15 & 0xFF00;
  uint64_t v30 = a2;
  unint64_t v31 = (unint64_t)*(int *)(a2 + 76) >> 4;
  int v1538 = *(_DWORD *)(a2 + 60);
  int v1539 = *(_DWORD *)(a2 + 56);
  if (v29 != 256)
  {
    unint64_t v33 = v18 >> 4;
    LODWORD(v1545) = *(_DWORD *)(a2 + 64);
    unint64_t v1549 = (unint64_t)*(int *)(a2 + 76) >> 4;
    int v1542 = *(_DWORD *)(a2 + 68);
    uint64_t v32 = v22;
    unint64_t v1548 = v22 + 16 * v31 * v1542;
    BOOL v44 = v21 != 0;
    if (v23)
    {
      LODWORD(a4) = 1;
      unint64_t v1550 = v22;
      goto LABEL_32;
    }
    int v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
    if (v22)
    {
      v1543 = 0;
      unint64_t v46 = v22 + 16 * v31 * (v1538 % v1542);
      v1539 %= (int)v1545;
      uint64_t v47 = v46 + 16 * v1539;
      unint64_t v22 = v46 + 16 * (int)v1545;
      int v1541 = 1;
      unint64_t v1550 = v47;
      v1544 = v26;
      v1538 %= v1542;
      unint64_t v48 = v33;
      goto LABEL_38;
    }
    unint64_t v22 = 0;
    int v1541 = 1;
    unint64_t v48 = v25;
    unint64_t v52 = (unint64_t)*(int *)(a2 + 76) >> 4;
    goto LABEL_36;
  }
  uint64_t v32 = v22 + 16 * (*(int *)(a2 + 56) + v31 * *(int *)(a2 + 60));
  unint64_t v33 = v25;
  if (v31 == v25)
  {
    unint64_t v34 = (unint64_t)v26 - v32;
    if ((uint64_t)v26 - v32 < 1)
    {
      a4 = 1;
      unint64_t v1545 = v25;
    }
    else
    {
      unint64_t v35 = v25;
      uint64_t v36 = v25 * (v17 - 1);
      uint64_t v37 = v32 + 16 * v36;
      int v38 = v1546 - 1;
      uint64_t v39 = &v26[v36];
      if ((unint64_t)v26 <= v37 + 16 * (v1546 - 1))
      {
        unint64_t v25 = -(uint64_t)v25;
      }
      else
      {
        uint64_t v37 = v32;
        uint64_t v39 = v26;
      }
      uint64_t v40 = &v26[v38];
      uint64_t v41 = v32 + 16 * v38;
      BOOL v42 = v24 < (uint64_t)(v34 >> 4);
      if (v24 >= (uint64_t)(v34 >> 4)) {
        uint64_t v32 = v41;
      }
      else {
        uint64_t v32 = v37;
      }
      if (v24 >= (uint64_t)(v34 >> 4)) {
        float v26 = v40;
      }
      else {
        float v26 = v39;
      }
      if (v24 >= (uint64_t)(v34 >> 4)) {
        unint64_t v43 = v35;
      }
      else {
        unint64_t v43 = v25;
      }
      unint64_t v1545 = v43;
      if (v42) {
        unint64_t v33 = v25;
      }
      else {
        unint64_t v33 = v35;
      }
      if (v42) {
        a4 = 1;
      }
      else {
        a4 = 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    a4 = 1;
    unint64_t v1545 = (unint64_t)*(int *)(a2 + 76) >> 4;
  }
  BOOL v44 = v21 != 0;
  if (!v23)
  {
    int v1541 = a4;
    int v1542 = 0;
    unint64_t v52 = v1545;
    int64_t v24 = v1546 * (int)a4;
    unint64_t v22 = -1;
    int v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
    unint64_t v48 = v33;
LABEL_36:
    unint64_t v1548 = 0;
    v1543 = 0;
    unint64_t v1549 = v52 - v24;
    unint64_t v1550 = 0;
    uint64_t v47 = v32;
    v1544 = v26;
LABEL_38:
    while (2)
    {
      unint64_t v1547 = v48 - v24;
      switch(v14)
      {
        case 0:
          long long v53 = &v26[-v1546 + 1];
          uint64_t v54 = v1547 + v1546;
          if (v1541 < 0) {
            uint64_t v54 = v1547 - v1546;
          }
          else {
            long long v53 = v26;
          }
          long long v55 = (char *)&v53[(v54 * ((int)v1552 - 1)) & (v54 >> 63)];
          if (v54 < 0) {
            uint64_t v54 = -v54;
          }
          CGBlt_fillBytes(16 * v1546, v1552, 0, v55, 16 * v54);
          goto LABEL_1353;
        case 1:
          int v56 = *(unsigned __int8 *)(v30 + 1);
          if (v56 == 2)
          {
            if (v1546 >= 2 && (16 * v1545) <= 0x40)
            {
              a7.i32[0] = 16 * v1545;
              uint8x8_t v915 = (uint8x8_t)vcnt_s8(a7);
              v915.i16[0] = vaddlv_u8(v915);
              if (v915.i32[0] <= 1u)
              {
                CGSFillDRAM64((unint64_t)v26, 16 * (v1546 + v1547), 16 * v1546, v1552, v32, 16 * v1549, 16 * v1545, v1542, 16 * v1539, v1538);
                goto LABEL_1353;
              }
            }
          }
          else if (v56 == 1)
          {
            if (v20 != 0 && !v44)
            {
              unsigned int v1006 = v1552;
              do
              {
                int v1007 = v1546;
                do
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = 1065353216;
                  unint64_t v1008 = v47 + 16 * v1541;
                  if (v1008 >= v22) {
                    uint64_t v1009 = -(uint64_t)(int)v1545;
                  }
                  else {
                    uint64_t v1009 = 0;
                  }
                  uint64_t v47 = v1008 + 16 * v1009;
                  v26 += v1541;
                  --v1007;
                }
                while (v1007);
                v26 += v1547;
                unint64_t v1010 = v1550;
                unint64_t v1011 = v1550 + 16 * v1549;
                if (v1011 >= v1548) {
                  uint64_t v1012 = -(uint64_t)(v1549 * v1542);
                }
                else {
                  uint64_t v1012 = 0;
                }
                uint64_t v1013 = v1011 + 16 * v1012;
                uint64_t v1014 = v22 + 16 * v1012 + 16 * v1549;
                if (v1548)
                {
                  unint64_t v22 = v1014;
                  unint64_t v1010 = v1013;
                }
                unint64_t v1550 = v1010;
                if (v1548) {
                  uint64_t v47 = v1013;
                }
                else {
                  v47 += 16 * v1549;
                }
                --v1006;
              }
              while (v1006);
              goto LABEL_1352;
            }
            if (v1541 < 0)
            {
              uint64_t v57 = v1549 - v1546;
              v47 -= 16 * (v1546 - 1);
              uint64_t v58 = v1547 - v1546;
              v26 += -v1546 + 1;
            }
            else
            {
              uint64_t v57 = v1549 + v1546;
              uint64_t v58 = v1547 + v1546;
            }
            v1522 = (char *)(v47 + 16 * ((v57 * ((int)v1552 - 1)) & (v57 >> 63)));
            if (v57 >= 0) {
              unint64_t v1523 = v57;
            }
            else {
              unint64_t v1523 = -v57;
            }
            if (v58 >= 0) {
              LODWORD(v1524) = v58;
            }
            else {
              uint64_t v1524 = -v58;
            }
            unint64_t v1549 = v1523;
            CGBlt_copyBytes(16 * v1546, v1552, v1522, (char *)&v26[(v58 * ((int)v1552 - 1)) & (v58 >> 63)], 16 * v1523, 16 * v1524);
            goto LABEL_1353;
          }
          unsigned int v916 = v1552;
          uint64_t v917 = 16 * v1541;
          if (v20 == 0 || v44)
          {
            do
            {
              int v918 = v1546;
              do
              {
                *float v26 = *(float32x4_t *)v47;
                unint64_t v919 = v47 + 16 * v1541;
                if (v919 >= v22) {
                  uint64_t v920 = -(uint64_t)(int)v1545;
                }
                else {
                  uint64_t v920 = 0;
                }
                uint64_t v47 = v919 + 16 * v920;
                float v26 = (float32x4_t *)((char *)v26 + v917);
                --v918;
              }
              while (v918);
              v26 += v1547;
              unint64_t v921 = v1550;
              unint64_t v922 = v1550 + 16 * v1549;
              if (v922 >= v1548) {
                uint64_t v923 = -(uint64_t)(v1549 * v1542);
              }
              else {
                uint64_t v923 = 0;
              }
              uint64_t v924 = v922 + 16 * v923;
              uint64_t v925 = v22 + 16 * v923 + 16 * v1549;
              if (v1548)
              {
                unint64_t v22 = v925;
                unint64_t v921 = v924;
              }
              unint64_t v1550 = v921;
              if (v1548) {
                uint64_t v47 = v924;
              }
              else {
                v47 += 16 * v1549;
              }
              --v916;
            }
            while (v916);
          }
          else
          {
            do
            {
              int v926 = v1546;
              do
              {
                v26->i64[0] = *(void *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                v26->i32[3] = 1065353216;
                unint64_t v927 = v47 + 16 * v1541;
                if (v927 >= v22) {
                  uint64_t v928 = -(uint64_t)(int)v1545;
                }
                else {
                  uint64_t v928 = 0;
                }
                uint64_t v47 = v927 + 16 * v928;
                float v26 = (float32x4_t *)((char *)v26 + v917);
                --v926;
              }
              while (v926);
              v26 += v1547;
              unint64_t v929 = v1550;
              unint64_t v930 = v1550 + 16 * v1549;
              if (v930 >= v1548) {
                uint64_t v931 = -(uint64_t)(v1549 * v1542);
              }
              else {
                uint64_t v931 = 0;
              }
              uint64_t v932 = v930 + 16 * v931;
              uint64_t v933 = v22 + 16 * v931 + 16 * v1549;
              if (v1548)
              {
                unint64_t v22 = v933;
                unint64_t v929 = v932;
              }
              unint64_t v1550 = v929;
              if (v1548) {
                uint64_t v47 = v932;
              }
              else {
                v47 += 16 * v1549;
              }
              --v916;
            }
            while (v916);
          }
          goto LABEL_1352;
        case 2:
          if (v45)
          {
            int v59 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v60 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v66 = v22;
                unint64_t v67 = v1550;
                do
                {
                  unint64_t v68 = (v66 - v47) >> 4;
                  if (v68 >= v1546) {
                    unint64_t v68 = v1546;
                  }
                  if (v68 < 2)
                  {
                    unint64_t i = v68;
                  }
                  else
                  {
                    uint64_t v69 = 0;
                    for (unint64_t i = v68; i > 1; i -= 2)
                    {
                      int v71 = (int8x16_t *)((char *)v26 + v69);
                      float32x4_t v72 = *(float32x4_t *)(v47 + v69);
                      float32x4_t v73 = *(float32x4_t *)(v47 + v69 + 16);
                      float32x4_t v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
                      float32x4_t v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
                      int8x16_t v76 = vbslq_s8((int8x16_t)vcgtzq_f32(v74), (int8x16_t)vaddq_f32(v73, vmlsq_f32(*(float32x4_t *)((char *)v26 + v69 + 16), vmaxnmq_f32(vminnmq_f32(v74, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)v26 + v69 + 16))), *(int8x16_t *)((char *)&v26[1] + v69));
                      *int v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), (int8x16_t)vaddq_f32(v72, vmlsq_f32(*(float32x4_t *)((char *)v26 + v69), vmaxnmq_f32(vminnmq_f32(v75, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)v26 + v69))), *(int8x16_t *)((char *)v26 + v69));
                      v71[1] = v76;
                      v69 += v60;
                    }
                    v47 += v69;
                    float v26 = (float32x4_t *)((char *)v26 + v69);
                  }
                  for (unint64_t j = i + v1546 - v68; j; --j)
                  {
                    float32x4_t v78 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v78), (int8x16_t)vaddq_f32(*(float32x4_t *)v47, vmlsq_f32(*v26, vmaxnmq_f32(vminnmq_f32(v78, _Q0), (float32x4_t)0), *v26)), *(int8x16_t *)v26);
                    unint64_t v79 = v47 + 16 * v1541;
                    if (v79 >= v66) {
                      uint64_t v80 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v80 = 0;
                    }
                    uint64_t v47 = v79 + 16 * v80;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v81 = v67 + 16 * v1549;
                  if (v81 >= v1548) {
                    uint64_t v82 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v82 = 0;
                  }
                  uint64_t v83 = v81 + 16 * v82;
                  uint64_t v84 = v66 + 16 * v82 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v83;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v66 = v84;
                    unint64_t v67 = v83;
                  }
                  _VF = __OFSUB__(v59--, 1);
                }
                while (!((v59 < 0) ^ _VF | (v59 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v1016 = v22;
                unint64_t v1017 = v1550;
                do
                {
                  unint64_t v1018 = (v1016 - v47) >> 4;
                  if (v1018 >= v1546) {
                    unint64_t v1018 = v1546;
                  }
                  if (v1018 < 2)
                  {
                    unint64_t k = v1018;
                  }
                  else
                  {
                    uint64_t v1019 = 0;
                    for (unint64_t k = v1018; k > 1; k -= 2)
                    {
                      v1021 = (int8x16_t *)((char *)v26 + v1019);
                      float32x4_t v1022 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1019 + 16));
                      float32x4_t v1023 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1019));
                      float32x4_t v1024 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1019));
                      float32x4_t v1025 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1023, 3);
                      float32x4_t v1026 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1019));
                      float32x4_t v1027 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1022, 3);
                      int8x16_t *v1021 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1025), (int8x16_t)vaddq_f32(vmlsq_f32(v1026, vmaxnmq_f32(vminnmq_f32(v1025, _Q0), (float32x4_t)0), v1026), v1023), (int8x16_t)v1026));
                      v1021[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1027), (int8x16_t)vaddq_f32(vmlsq_f32(v1024, vmaxnmq_f32(vminnmq_f32(v1027, _Q0), (float32x4_t)0), v1024), v1022), (int8x16_t)v1024));
                      v1019 += v60;
                    }
                    v47 += v1019;
                    float v26 = (float32x4_t *)((char *)v26 + v1019);
                  }
                  for (unint64_t m = k + v1546 - v1018; m; --m)
                  {
                    float32x4_t v1029 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    float32x4_t v1030 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    float32x4_t v1031 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1029, 3);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1031), (int8x16_t)vaddq_f32(vmlsq_f32(v1030, vmaxnmq_f32(vminnmq_f32(v1031, _Q0), (float32x4_t)0), v1030), v1029), (int8x16_t)v1030));
                    unint64_t v1032 = v47 + 16 * v1541;
                    if (v1032 >= v1016) {
                      uint64_t v1033 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1033 = 0;
                    }
                    uint64_t v47 = v1032 + 16 * v1033;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1034 = v1017 + 16 * v1549;
                  if (v1034 >= v1548) {
                    uint64_t v1035 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1035 = 0;
                  }
                  uint64_t v1036 = v1034 + 16 * v1035;
                  uint64_t v1037 = v1016 + 16 * v1035 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1036;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1016 = v1037;
                    unint64_t v1017 = v1036;
                  }
                  _VF = __OFSUB__(v59--, 1);
                }
                while (!((v59 < 0) ^ _VF | (v59 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v59 = v1552;
          }
          do
          {
            int v753 = v1546;
            do
            {
              float v754 = *(float *)(v47 + 12);
              if (v754 >= 1.0)
              {
                v26->i64[0] = *(void *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                v26->f32[3] = v754;
              }
              else if (v754 > 0.0)
              {
                *float v26 = vmlaq_n_f32(*(float32x4_t *)v47, *v26, 1.0 - v754);
              }
              unint64_t v755 = v47 + 16 * v1541;
              if (v755 >= v22) {
                uint64_t v756 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v756 = 0;
              }
              uint64_t v47 = v755 + 16 * v756;
              v26 += v1541;
              --v753;
            }
            while (v753);
            v26 += v1547;
            unint64_t v757 = v1550;
            unint64_t v758 = v1550 + 16 * v1549;
            if (v758 >= v1548) {
              uint64_t v759 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v759 = 0;
            }
            uint64_t v760 = v758 + 16 * v759;
            uint64_t v761 = v22 + 16 * v759 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v761;
              unint64_t v757 = v760;
            }
            unint64_t v1550 = v757;
            if (v1548) {
              uint64_t v47 = v760;
            }
            else {
              v47 += 16 * v1549;
            }
            --v59;
          }
          while (v59);
          goto LABEL_1352;
        case 3:
          if (v45)
          {
            int v85 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v86.i64[0] = 0;
              v86.i32[2] = 0;
              v86.i32[3] = v44 - 1;
              int8x16_t v87 = vmvnq_s8(v86);
              int8x16_t v88 = vandq_s8((int8x16_t)vdupq_n_s32(v44 - 1), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v89 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v91 = v22;
                unint64_t v92 = v1550;
                do
                {
                  unint64_t v93 = (v91 - v47) >> 4;
                  if (v93 >= v1546) {
                    unint64_t v93 = v1546;
                  }
                  if (v93 < 2)
                  {
                    unint64_t n = v93;
                  }
                  else
                  {
                    uint64_t v94 = 0;
                    for (unint64_t n = v93; n > 1; n -= 2)
                    {
                      float v96 = (float32x4_t *)((char *)v26 + v94);
                      float32x4_t v97 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v26[1] + v94), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v94 + 16), v87), v88));
                      *float v96 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)v26 + v94), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v94), v87), v88));
                      v96[1] = v97;
                      v94 += v89;
                    }
                    v47 += v94;
                    float v26 = (float32x4_t *)((char *)v26 + v94);
                  }
                  for (iunint64_t i = n + v1546 - v93; ii; --ii)
                  {
                    *float v26 = vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v87), v88));
                    unint64_t v99 = v47 + 16 * v1541;
                    if (v99 >= v91) {
                      uint64_t v100 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v100 = 0;
                    }
                    uint64_t v47 = v99 + 16 * v100;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v101 = v92 + 16 * v1549;
                  if (v101 >= v1548) {
                    uint64_t v102 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v102 = 0;
                  }
                  uint64_t v103 = v101 + 16 * v102;
                  uint64_t v104 = v91 + 16 * v102 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v103;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v91 = v104;
                    unint64_t v92 = v103;
                  }
                  _VF = __OFSUB__(v85--, 1);
                }
                while (!((v85 < 0) ^ _VF | (v85 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v1039 = v22;
                unint64_t v1040 = v1550;
                do
                {
                  unint64_t v1041 = (v1039 - v47) >> 4;
                  if (v1041 >= v1546) {
                    unint64_t v1041 = v1546;
                  }
                  if (v1041 < 2)
                  {
                    junint64_t j = v1041;
                  }
                  else
                  {
                    uint64_t v1042 = 0;
                    for (junint64_t j = v1041; jj > 1; jj -= 2)
                    {
                      v1044 = (int8x16_t *)((char *)v26 + v1042);
                      int8x16_t v1045 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1042)), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1042 + 16)), v87), v88)));
                      int8x16_t *v1044 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1042)), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1042)), v87), v88)));
                      v1044[1] = v1045;
                      v1042 += v89;
                    }
                    v47 += v1042;
                    float v26 = (float32x4_t *)((char *)v26 + v1042);
                  }
                  for (kunint64_t k = jj + v1546 - v1041; kk; --kk)
                  {
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v26), 3), _Q3), (float32x4_t)0), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v87), v88)));
                    unint64_t v1047 = v47 + 16 * v1541;
                    if (v1047 >= v1039) {
                      uint64_t v1048 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1048 = 0;
                    }
                    uint64_t v47 = v1047 + 16 * v1048;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1049 = v1040 + 16 * v1549;
                  if (v1049 >= v1548) {
                    uint64_t v1050 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1050 = 0;
                  }
                  uint64_t v1051 = v1049 + 16 * v1050;
                  uint64_t v1052 = v1039 + 16 * v1050 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1051;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1039 = v1052;
                    unint64_t v1040 = v1051;
                  }
                  _VF = __OFSUB__(v85--, 1);
                }
                while (!((v85 < 0) ^ _VF | (v85 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v85 = v1552;
          }
          do
          {
            int v762 = v1546;
            do
            {
              float v763 = v26->f32[3];
              if (v763 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else
              {
                float v764 = *(float *)v47;
                if (v763 >= 1.0)
                {
                  v26->f32[0] = v764;
                  *(uint64_t *)((char *)v26->i64 + 4) = *(void *)(v47 + 4);
                  float v766 = 1.0;
                  if (v44) {
                    float v766 = *(float *)(v47 + 12);
                  }
                }
                else
                {
                  v26->f32[0] = v763 * v764;
                  *(float32x2_t *)&v26->i32[1] = vmul_n_f32(*(float32x2_t *)(v47 + 4), v763);
                  float v765 = 1.0;
                  if (v44) {
                    float v765 = *(float *)(v47 + 12);
                  }
                  float v766 = v763 * v765;
                }
                v26->f32[3] = v766;
              }
              unint64_t v767 = v47 + 16 * v1541;
              if (v767 >= v22) {
                uint64_t v768 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v768 = 0;
              }
              uint64_t v47 = v767 + 16 * v768;
              v26 += v1541;
              --v762;
            }
            while (v762);
            v26 += v1547;
            unint64_t v769 = v1550;
            unint64_t v770 = v1550 + 16 * v1549;
            if (v770 >= v1548) {
              uint64_t v771 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v771 = 0;
            }
            uint64_t v772 = v770 + 16 * v771;
            uint64_t v773 = v22 + 16 * v771 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v773;
              unint64_t v769 = v772;
            }
            unint64_t v1550 = v769;
            if (v1548) {
              uint64_t v47 = v772;
            }
            else {
              v47 += 16 * v1549;
            }
            --v85;
          }
          while (v85);
          goto LABEL_1352;
        case 4:
          if (v45)
          {
            int v105 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v106 = 0;
              }
              else {
                unsigned int v106 = -1;
              }
              v107.i64[0] = 0;
              v107.i32[2] = 0;
              v107.i32[3] = v106;
              int8x16_t v108 = vmvnq_s8(v107);
              int8x16_t v109 = vandq_s8((int8x16_t)vdupq_n_s32(v106), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v110 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v112 = v22;
                unint64_t v113 = v1550;
                do
                {
                  unint64_t v114 = (v112 - v47) >> 4;
                  if (v114 >= v1546) {
                    unint64_t v114 = v1546;
                  }
                  if (v114 < 2)
                  {
                    unint64_t mm = v114;
                  }
                  else
                  {
                    uint64_t v115 = 0;
                    for (unint64_t mm = v114; mm > 1; mm -= 2)
                    {
                      __int32 v117 = (float32x4_t *)((char *)v26 + v115);
                      float32x4_t v118 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v115), v108), v109);
                      float32x4_t v119 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v115 + 16), v108), v109);
                      float32x4_t v120 = vmlsq_f32(v119, v119, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)&v26[1] + v115), 3), _Q3), (float32x4_t)0));
                      *__int32 v117 = vmlsq_f32(v118, v118, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)((char *)v26 + v115), 3), _Q3), (float32x4_t)0));
                      v117[1] = v120;
                      v115 += v110;
                    }
                    v47 += v115;
                    float v26 = (float32x4_t *)((char *)v26 + v115);
                  }
                  for (nunint64_t n = mm + v1546 - v114; nn; --nn)
                  {
                    float32x4_t v122 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v108), v109);
                    *float v26 = vmlsq_f32(v122, v122, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3), _Q3), (float32x4_t)0));
                    unint64_t v123 = v47 + 16 * v1541;
                    if (v123 >= v112) {
                      uint64_t v124 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v124 = 0;
                    }
                    uint64_t v47 = v123 + 16 * v124;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v125 = v113 + 16 * v1549;
                  if (v125 >= v1548) {
                    uint64_t v126 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v126 = 0;
                  }
                  uint64_t v127 = v125 + 16 * v126;
                  uint64_t v128 = v112 + 16 * v126 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v127;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v112 = v128;
                    unint64_t v113 = v127;
                  }
                  _VF = __OFSUB__(v105--, 1);
                }
                while (!((v105 < 0) ^ _VF | (v105 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v1054 = v22;
                unint64_t v1055 = v1550;
                do
                {
                  unint64_t v1056 = (v1054 - v47) >> 4;
                  if (v1056 >= v1546) {
                    unint64_t v1056 = v1546;
                  }
                  if (v1056 < 2)
                  {
                    unint64_t i1 = v1056;
                  }
                  else
                  {
                    uint64_t v1057 = 0;
                    for (unint64_t i1 = v1056; i1 > 1; i1 -= 2)
                    {
                      v1059 = (int8x16_t *)((char *)v26 + v1057);
                      float32x4_t v1060 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1057)), v108), v109);
                      float32x4_t v1061 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1057 + 16)), v108), v109);
                      int8x16_t v1062 = vrev32q_s8((int8x16_t)vmlsq_f32(v1061, v1061, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1057)), 3), _Q3), (float32x4_t)0)));
                      int8x16_t *v1059 = vrev32q_s8((int8x16_t)vmlsq_f32(v1060, v1060, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1057)), 3), _Q3), (float32x4_t)0)));
                      v1059[1] = v1062;
                      v1057 += v110;
                    }
                    v47 += v1057;
                    float v26 = (float32x4_t *)((char *)v26 + v1057);
                  }
                  for (unint64_t i2 = i1 + v1546 - v1056; i2; --i2)
                  {
                    float32x4_t v1064 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v108), v109);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmlsq_f32(v1064, v1064, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v26), 3), _Q3), (float32x4_t)0)));
                    unint64_t v1065 = v47 + 16 * v1541;
                    if (v1065 >= v1054) {
                      uint64_t v1066 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1066 = 0;
                    }
                    uint64_t v47 = v1065 + 16 * v1066;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1067 = v1055 + 16 * v1549;
                  if (v1067 >= v1548) {
                    uint64_t v1068 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1068 = 0;
                  }
                  uint64_t v1069 = v1067 + 16 * v1068;
                  uint64_t v1070 = v1054 + 16 * v1068 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1069;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1054 = v1070;
                    unint64_t v1055 = v1069;
                  }
                  _VF = __OFSUB__(v105--, 1);
                }
                while (!((v105 < 0) ^ _VF | (v105 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v105 = v1552;
          }
          do
          {
            int v774 = v1546;
            do
            {
              float v775 = 1.0 - v26->f32[3];
              if (v775 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else
              {
                float v776 = *(float *)v47;
                if (v775 >= 1.0)
                {
                  v26->f32[0] = v776;
                  *(uint64_t *)((char *)v26->i64 + 4) = *(void *)(v47 + 4);
                  float v778 = 1.0;
                  if (v44) {
                    float v778 = *(float *)(v47 + 12);
                  }
                }
                else
                {
                  v26->f32[0] = v775 * v776;
                  *(float32x2_t *)&v26->i32[1] = vmul_n_f32(*(float32x2_t *)(v47 + 4), v775);
                  float v777 = 1.0;
                  if (v44) {
                    float v777 = *(float *)(v47 + 12);
                  }
                  float v778 = v775 * v777;
                }
                v26->f32[3] = v778;
              }
              unint64_t v779 = v47 + 16 * v1541;
              if (v779 >= v22) {
                uint64_t v780 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v780 = 0;
              }
              uint64_t v47 = v779 + 16 * v780;
              v26 += v1541;
              --v774;
            }
            while (v774);
            v26 += v1547;
            unint64_t v781 = v1550;
            unint64_t v782 = v1550 + 16 * v1549;
            if (v782 >= v1548) {
              uint64_t v783 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v783 = 0;
            }
            uint64_t v784 = v782 + 16 * v783;
            uint64_t v785 = v22 + 16 * v783 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v785;
              unint64_t v781 = v784;
            }
            unint64_t v1550 = v781;
            if (v1548) {
              uint64_t v47 = v784;
            }
            else {
              v47 += 16 * v1549;
            }
            --v105;
          }
          while (v105);
          goto LABEL_1352;
        case 5:
          if (v45)
          {
            int v129 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v130 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v131 = v22;
                unint64_t v132 = v1550;
                do
                {
                  unint64_t v133 = (v131 - v47) >> 4;
                  if (v133 >= v1546) {
                    unint64_t v133 = v1546;
                  }
                  if (v133 < 2)
                  {
                    unint64_t i3 = v133;
                  }
                  else
                  {
                    uint64_t v134 = 0;
                    for (unint64_t i3 = v133; i3 > 1; i3 -= 2)
                    {
                      float v136 = (float32x4_t *)((char *)v26 + v134);
                      float32x4_t v137 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v134 + 16), *(float32x4_t *)((char *)v26 + v134 + 16), *(float32x4_t *)(v47 + v134 + 16), 3), *(float32x4_t *)(v47 + v134 + 16), *(float32x4_t *)((char *)v26 + v134 + 16), 3);
                      *float v136 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v134), *(float32x4_t *)((char *)v26 + v134), *(float32x4_t *)(v47 + v134), 3), *(float32x4_t *)(v47 + v134), *(float32x4_t *)((char *)v26 + v134), 3);
                      v136[1] = v137;
                      v134 += v130;
                    }
                    v47 += v134;
                    float v26 = (float32x4_t *)((char *)v26 + v134);
                  }
                  for (unint64_t i4 = i3 + v1546 - v133; i4; --i4)
                  {
                    *float v26 = vmlaq_laneq_f32(vmlsq_laneq_f32(*v26, *v26, *(float32x4_t *)v47, 3), *(float32x4_t *)v47, *v26, 3);
                    unint64_t v139 = v47 + 16 * v1541;
                    if (v139 >= v131) {
                      uint64_t v140 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v140 = 0;
                    }
                    uint64_t v47 = v139 + 16 * v140;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v141 = v132 + 16 * v1549;
                  if (v141 >= v1548) {
                    uint64_t v142 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v142 = 0;
                  }
                  uint64_t v143 = v141 + 16 * v142;
                  uint64_t v144 = v131 + 16 * v142 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v143;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v131 = v144;
                    unint64_t v132 = v143;
                  }
                  _VF = __OFSUB__(v129--, 1);
                }
                while (!((v129 < 0) ^ _VF | (v129 == 0)));
              }
              else
              {
                unint64_t v1071 = v22;
                unint64_t v1072 = v1550;
                do
                {
                  unint64_t v1073 = (v1071 - v47) >> 4;
                  if (v1073 >= v1546) {
                    unint64_t v1073 = v1546;
                  }
                  if (v1073 < 2)
                  {
                    unint64_t i5 = v1073;
                  }
                  else
                  {
                    uint64_t v1074 = 0;
                    for (unint64_t i5 = v1073; i5 > 1; i5 -= 2)
                    {
                      v1076 = (int8x16_t *)((char *)v26 + v1074);
                      float32x4_t v1077 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1074 + 16));
                      float32x4_t v1078 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1074));
                      float32x4_t v1079 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1074));
                      float32x4_t v1080 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1074));
                      int8x16_t *v1076 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1080, v1080, v1078, 3), v1078, v1080, 3));
                      v1076[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1079, v1079, v1077, 3), v1077, v1079, 3));
                      v1074 += v130;
                    }
                    v47 += v1074;
                    float v26 = (float32x4_t *)((char *)v26 + v1074);
                  }
                  for (unint64_t i6 = i5 + v1546 - v1073; i6; --i6)
                  {
                    float32x4_t v1082 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    float32x4_t v1083 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1083, v1083, v1082, 3), v1082, v1083, 3));
                    unint64_t v1084 = v47 + 16 * v1541;
                    if (v1084 >= v1071) {
                      uint64_t v1085 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1085 = 0;
                    }
                    uint64_t v47 = v1084 + 16 * v1085;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1086 = v1072 + 16 * v1549;
                  if (v1086 >= v1548) {
                    uint64_t v1087 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1087 = 0;
                  }
                  uint64_t v1088 = v1086 + 16 * v1087;
                  uint64_t v1089 = v1071 + 16 * v1087 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1088;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1071 = v1089;
                    unint64_t v1072 = v1088;
                  }
                  _VF = __OFSUB__(v129--, 1);
                }
                while (!((v129 < 0) ^ _VF | (v129 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v129 = v1552;
          }
          do
          {
            int v786 = v1546;
            do
            {
              *float v26 = vmlaq_laneq_f32(vmulq_n_f32(*v26, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v47))), *(float32x4_t *)v47, *v26, 3);
              unint64_t v787 = v47 + 16 * v1541;
              if (v787 >= v22) {
                uint64_t v788 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v788 = 0;
              }
              uint64_t v47 = v787 + 16 * v788;
              v26 += v1541;
              --v786;
            }
            while (v786);
            v26 += v1547;
            unint64_t v789 = v1550;
            unint64_t v790 = v1550 + 16 * v1549;
            if (v790 >= v1548) {
              uint64_t v791 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v791 = 0;
            }
            uint64_t v792 = v790 + 16 * v791;
            uint64_t v793 = v22 + 16 * v791 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v793;
              unint64_t v789 = v792;
            }
            unint64_t v1550 = v789;
            if (v1548) {
              uint64_t v47 = v792;
            }
            else {
              v47 += 16 * v1549;
            }
            --v129;
          }
          while (v129);
          goto LABEL_1352;
        case 6:
          if (v45)
          {
            int v145 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v146 = 0;
              }
              else {
                unsigned int v146 = -1;
              }
              v147.i64[0] = 0;
              v147.i32[2] = 0;
              v147.i32[3] = v146;
              int8x16_t v148 = vmvnq_s8(v147);
              int8x16_t v149 = vandq_s8((int8x16_t)vdupq_n_s32(v146), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v150 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v152 = v22;
                unint64_t v153 = v1550;
                do
                {
                  unint64_t v154 = (v152 - v47) >> 4;
                  if (v154 >= v1546) {
                    unint64_t v154 = v1546;
                  }
                  if (v154 < 2)
                  {
                    unint64_t i7 = v154;
                  }
                  else
                  {
                    uint64_t v155 = 0;
                    for (unint64_t i7 = v154; i7 > 1; i7 -= 2)
                    {
                      float32x2_t v157 = (int8x16_t *)((char *)v26 + v155);
                      float32x4_t v158 = *(float32x4_t *)((char *)v26 + v155);
                      float32x4_t v159 = *(float32x4_t *)((char *)v26 + v155 + 16);
                      float32x4_t v160 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v159, 3);
                      float32x4_t v161 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v158, 3);
                      int8x16_t v162 = (int8x16_t)vcgtzq_f32(v161);
                      float32x4_t v163 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v155), v148), v149);
                      float32x4_t v164 = vmlsq_f32(v163, vmaxnmq_f32(vminnmq_f32(v161, _Q3), (float32x4_t)0), v163);
                      float32x4_t v165 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v155 + 16), v148), v149);
                      *float32x2_t v157 = vbslq_s8(v162, (int8x16_t)vaddq_f32(v158, v164), (int8x16_t)v163);
                      v157[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v160), (int8x16_t)vaddq_f32(v159, vmlsq_f32(v165, vmaxnmq_f32(vminnmq_f32(v160, _Q3), (float32x4_t)0), v165)), (int8x16_t)v165);
                      v155 += v150;
                    }
                    v47 += v155;
                    float v26 = (float32x4_t *)((char *)v26 + v155);
                  }
                  for (unint64_t i8 = i7 + v1546 - v154; i8; --i8)
                  {
                    float32x4_t v167 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v148), v149);
                    float32x4_t v168 = (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v26, 3);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v168), (int8x16_t)vaddq_f32(*v26, vmlsq_f32(v167, vmaxnmq_f32(vminnmq_f32(v168, _Q3), (float32x4_t)0), v167)), (int8x16_t)v167);
                    unint64_t v169 = v47 + 16 * v1541;
                    if (v169 >= v152) {
                      uint64_t v170 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v170 = 0;
                    }
                    uint64_t v47 = v169 + 16 * v170;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v171 = v153 + 16 * v1549;
                  if (v171 >= v1548) {
                    uint64_t v172 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v172 = 0;
                  }
                  uint64_t v173 = v171 + 16 * v172;
                  uint64_t v174 = v152 + 16 * v172 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v173;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v152 = v174;
                    unint64_t v153 = v173;
                  }
                  _VF = __OFSUB__(v145--, 1);
                }
                while (!((v145 < 0) ^ _VF | (v145 == 0)));
              }
              else
              {
                __asm { FMOV            V3.4S, #1.0 }
                unint64_t v1091 = v22;
                unint64_t v1092 = v1550;
                do
                {
                  unint64_t v1093 = (v1091 - v47) >> 4;
                  if (v1093 >= v1546) {
                    unint64_t v1093 = v1546;
                  }
                  if (v1093 < 2)
                  {
                    unint64_t i9 = v1093;
                  }
                  else
                  {
                    uint64_t v1094 = 0;
                    for (unint64_t i9 = v1093; i9 > 1; i9 -= 2)
                    {
                      v1096 = (int8x16_t *)((char *)v26 + v1094);
                      float32x4_t v1097 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1094));
                      float32x4_t v1098 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1094));
                      float32x4_t v1099 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1098, 3);
                      float32x4_t v1100 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1097, 3);
                      float32x4_t v1101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1094)), v148), v149);
                      float32x4_t v1102 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1094 + 16)), v148), v149);
                      int8x16_t *v1096 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1099), (int8x16_t)vaddq_f32(vmlsq_f32(v1101, vmaxnmq_f32(vminnmq_f32(v1099, _Q3), (float32x4_t)0), v1101), v1098), (int8x16_t)v1101));
                      v1096[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1100), (int8x16_t)vaddq_f32(vmlsq_f32(v1102, vmaxnmq_f32(vminnmq_f32(v1100, _Q3), (float32x4_t)0), v1102), v1097), (int8x16_t)v1102));
                      v1094 += v150;
                    }
                    v47 += v1094;
                    float v26 = (float32x4_t *)((char *)v26 + v1094);
                  }
                  for (unint64_t i10 = i9 + v1546 - v1093; i10; --i10)
                  {
                    float32x4_t v1104 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    float32x4_t v1105 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v148), v149);
                    float32x4_t v1106 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1104, 3);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1106), (int8x16_t)vaddq_f32(vmlsq_f32(v1105, vmaxnmq_f32(vminnmq_f32(v1106, _Q3), (float32x4_t)0), v1105), v1104), (int8x16_t)v1105));
                    unint64_t v1107 = v47 + 16 * v1541;
                    if (v1107 >= v1091) {
                      uint64_t v1108 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1108 = 0;
                    }
                    uint64_t v47 = v1107 + 16 * v1108;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1109 = v1092 + 16 * v1549;
                  if (v1109 >= v1548) {
                    uint64_t v1110 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1110 = 0;
                  }
                  uint64_t v1111 = v1109 + 16 * v1110;
                  uint64_t v1112 = v1091 + 16 * v1110 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1111;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1091 = v1112;
                    unint64_t v1092 = v1111;
                  }
                  _VF = __OFSUB__(v145--, 1);
                }
                while (!((v145 < 0) ^ _VF | (v145 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v145 = v1552;
          }
          while (1)
          {
            int v794 = v1546;
            do
            {
              float v795 = v26->f32[3];
              float v796 = 1.0 - v795;
              if ((float)(1.0 - v795) >= 1.0)
              {
                v26->i64[0] = *(void *)v47;
                v26->i32[2] = *(_DWORD *)(v47 + 8);
                float v798 = 1.0;
                if (v44) {
                  float v798 = *(float *)(v47 + 12);
                }
              }
              else
              {
                if (v796 <= 0.0) {
                  goto LABEL_906;
                }
                *(float32x2_t *)v26->f32 = vmla_n_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47, v796);
                v26->f32[2] = v26->f32[2] + (float)(*(float *)(v47 + 8) * v796);
                float v797 = 1.0;
                if (v44) {
                  float v797 = *(float *)(v47 + 12);
                }
                float v798 = v795 + (float)(v797 * v796);
              }
              v26->f32[3] = v798;
LABEL_906:
              unint64_t v799 = v47 + 16 * v1541;
              if (v799 >= v22) {
                uint64_t v800 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v800 = 0;
              }
              uint64_t v47 = v799 + 16 * v800;
              v26 += v1541;
              --v794;
            }
            while (v794);
            v26 += v1547;
            unint64_t v801 = v1550;
            unint64_t v802 = v1550 + 16 * v1549;
            if (v802 >= v1548) {
              uint64_t v803 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v803 = 0;
            }
            uint64_t v804 = v802 + 16 * v803;
            uint64_t v805 = v22 + 16 * v803 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v805;
              unint64_t v801 = v804;
            }
            unint64_t v1550 = v801;
            if (v1548) {
              uint64_t v47 = v804;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v145)
            {
LABEL_1352:
              unsigned int v1552 = 0;
              goto LABEL_1353;
            }
          }
        case 7:
          if (v45)
          {
            int v175 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v176 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v178 = v22;
                unint64_t v179 = v1550;
                do
                {
                  unint64_t v180 = (v178 - v47) >> 4;
                  if (v180 >= v1546) {
                    unint64_t v180 = v1546;
                  }
                  if (v180 < 2)
                  {
                    unint64_t i11 = v180;
                  }
                  else
                  {
                    uint64_t v181 = 0;
                    for (unint64_t i11 = v180; i11 > 1; i11 -= 2)
                    {
                      __int32 v183 = (float32x4_t *)((char *)v26 + v181);
                      float32x4_t v184 = vmulq_f32(*(float32x4_t *)((char *)v26 + v181 + 16), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v181 + 16), 3), _Q0), (float32x4_t)0));
                      *__int32 v183 = vmulq_f32(*(float32x4_t *)((char *)v26 + v181), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v181), 3), _Q0), (float32x4_t)0));
                      v183[1] = v184;
                      v181 += v176;
                    }
                    v47 += v181;
                    float v26 = (float32x4_t *)((char *)v26 + v181);
                  }
                  for (unint64_t i12 = i11 + v1546 - v180; i12; --i12)
                  {
                    *float v26 = vmulq_f32(*v26, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3), _Q0), (float32x4_t)0));
                    unint64_t v186 = v47 + 16 * v1541;
                    if (v186 >= v178) {
                      uint64_t v187 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v187 = 0;
                    }
                    uint64_t v47 = v186 + 16 * v187;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v188 = v179 + 16 * v1549;
                  if (v188 >= v1548) {
                    uint64_t v189 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v189 = 0;
                  }
                  uint64_t v190 = v188 + 16 * v189;
                  uint64_t v191 = v178 + 16 * v189 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v190;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v178 = v191;
                    unint64_t v179 = v190;
                  }
                  _VF = __OFSUB__(v175--, 1);
                }
                while (!((v175 < 0) ^ _VF | (v175 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v1114 = v22;
                unint64_t v1115 = v1550;
                do
                {
                  unint64_t v1116 = (v1114 - v47) >> 4;
                  if (v1116 >= v1546) {
                    unint64_t v1116 = v1546;
                  }
                  if (v1116 < 2)
                  {
                    unint64_t i13 = v1116;
                  }
                  else
                  {
                    uint64_t v1117 = 0;
                    for (unint64_t i13 = v1116; i13 > 1; i13 -= 2)
                    {
                      v1119 = (int8x16_t *)((char *)v26 + v1117);
                      int8x16_t v1120 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1117 + 16)), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1117))));
                      int8x16_t *v1119 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1117)), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1117))));
                      v1119[1] = v1120;
                      v1117 += v176;
                    }
                    v47 += v1117;
                    float v26 = (float32x4_t *)((char *)v26 + v1117);
                  }
                  for (unint64_t i14 = i13 + v1546 - v1116; i14; --i14)
                  {
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmulq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v47), 3), _Q0), (float32x4_t)0), (float32x4_t)vrev32q_s8(*(int8x16_t *)v26)));
                    unint64_t v1122 = v47 + 16 * v1541;
                    if (v1122 >= v1114) {
                      uint64_t v1123 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1123 = 0;
                    }
                    uint64_t v47 = v1122 + 16 * v1123;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1124 = v1115 + 16 * v1549;
                  if (v1124 >= v1548) {
                    uint64_t v1125 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1125 = 0;
                  }
                  uint64_t v1126 = v1124 + 16 * v1125;
                  uint64_t v1127 = v1114 + 16 * v1125 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1126;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1114 = v1127;
                    unint64_t v1115 = v1126;
                  }
                  _VF = __OFSUB__(v175--, 1);
                }
                while (!((v175 < 0) ^ _VF | (v175 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v175 = v1552;
          }
          do
          {
            int v806 = v1546;
            do
            {
              float v807 = *(float *)(v47 + 12);
              if (v807 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else if (v807 < 1.0)
              {
                *float v26 = vmulq_n_f32(*v26, v807);
              }
              unint64_t v808 = v47 + 16 * v1541;
              if (v808 >= v22) {
                uint64_t v809 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v809 = 0;
              }
              uint64_t v47 = v808 + 16 * v809;
              v26 += v1541;
              --v806;
            }
            while (v806);
            v26 += v1547;
            unint64_t v810 = v1550;
            unint64_t v811 = v1550 + 16 * v1549;
            if (v811 >= v1548) {
              uint64_t v812 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v812 = 0;
            }
            uint64_t v813 = v811 + 16 * v812;
            uint64_t v814 = v22 + 16 * v812 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v814;
              unint64_t v810 = v813;
            }
            unint64_t v1550 = v810;
            if (v1548) {
              uint64_t v47 = v813;
            }
            else {
              v47 += 16 * v1549;
            }
            --v175;
          }
          while (v175);
          goto LABEL_1352;
        case 8:
          if (v45)
          {
            int v192 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v193 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v195 = v22;
                unint64_t v196 = v1550;
                do
                {
                  unint64_t v197 = (v195 - v47) >> 4;
                  if (v197 >= v1546) {
                    unint64_t v197 = v1546;
                  }
                  if (v197 < 2)
                  {
                    unint64_t i15 = v197;
                  }
                  else
                  {
                    uint64_t v198 = 0;
                    for (unint64_t i15 = v197; i15 > 1; i15 -= 2)
                    {
                      __int32 v200 = (float32x4_t *)((char *)v26 + v198);
                      float32x4_t v201 = vmlsq_f32(*(float32x4_t *)((char *)v26 + v198 + 16), *(float32x4_t *)((char *)v26 + v198 + 16), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v198 + 16), 3), _Q0), (float32x4_t)0));
                      *__int32 v200 = vmlsq_f32(*(float32x4_t *)((char *)v26 + v198), *(float32x4_t *)((char *)v26 + v198), vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v47 + v198), 3), _Q0), (float32x4_t)0));
                      v200[1] = v201;
                      v198 += v193;
                    }
                    v47 += v198;
                    float v26 = (float32x4_t *)((char *)v26 + v198);
                  }
                  for (unint64_t i16 = i15 + v1546 - v197; i16; --i16)
                  {
                    *float v26 = vmlsq_f32(*v26, *v26, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32(*(int32x4_t *)v47, 3), _Q0), (float32x4_t)0));
                    unint64_t v203 = v47 + 16 * v1541;
                    if (v203 >= v195) {
                      uint64_t v204 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v204 = 0;
                    }
                    uint64_t v47 = v203 + 16 * v204;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v205 = v196 + 16 * v1549;
                  if (v205 >= v1548) {
                    uint64_t v206 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v206 = 0;
                  }
                  uint64_t v207 = v205 + 16 * v206;
                  uint64_t v208 = v195 + 16 * v206 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v207;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v195 = v208;
                    unint64_t v196 = v207;
                  }
                  _VF = __OFSUB__(v192--, 1);
                }
                while (!((v192 < 0) ^ _VF | (v192 == 0)));
              }
              else
              {
                __asm { FMOV            V0.4S, #1.0 }
                unint64_t v1129 = v22;
                unint64_t v1130 = v1550;
                do
                {
                  unint64_t v1131 = (v1129 - v47) >> 4;
                  if (v1131 >= v1546) {
                    unint64_t v1131 = v1546;
                  }
                  if (v1131 < 2)
                  {
                    unint64_t i17 = v1131;
                  }
                  else
                  {
                    uint64_t v1132 = 0;
                    for (unint64_t i17 = v1131; i17 > 1; i17 -= 2)
                    {
                      v1134 = (int8x16_t *)((char *)v26 + v1132);
                      float32x4_t v1135 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1132));
                      float32x4_t v1136 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1132));
                      int8x16_t v1137 = vrev32q_s8((int8x16_t)vmlsq_f32(v1135, v1135, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1132 + 16)), 3), _Q0), (float32x4_t)0)));
                      int8x16_t *v1134 = vrev32q_s8((int8x16_t)vmlsq_f32(v1136, v1136, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1132)), 3), _Q0), (float32x4_t)0)));
                      v1134[1] = v1137;
                      v1132 += v193;
                    }
                    v47 += v1132;
                    float v26 = (float32x4_t *)((char *)v26 + v1132);
                  }
                  for (unint64_t i18 = i17 + v1546 - v1131; i18; --i18)
                  {
                    float32x4_t v1139 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmlsq_f32(v1139, v1139, vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vrev32q_s8(*(int8x16_t *)v47), 3), _Q0), (float32x4_t)0)));
                    unint64_t v1140 = v47 + 16 * v1541;
                    if (v1140 >= v1129) {
                      uint64_t v1141 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1141 = 0;
                    }
                    uint64_t v47 = v1140 + 16 * v1141;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1142 = v1130 + 16 * v1549;
                  if (v1142 >= v1548) {
                    uint64_t v1143 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1143 = 0;
                  }
                  uint64_t v1144 = v1142 + 16 * v1143;
                  uint64_t v1145 = v1129 + 16 * v1143 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1144;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1129 = v1145;
                    unint64_t v1130 = v1144;
                  }
                  _VF = __OFSUB__(v192--, 1);
                }
                while (!((v192 < 0) ^ _VF | (v192 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v192 = v1552;
          }
          do
          {
            int v815 = v1546;
            do
            {
              float v816 = 1.0 - *(float *)(v47 + 12);
              if (v816 <= 0.0)
              {
                v26->i64[0] = 0;
                v26->i64[1] = 0;
              }
              else if (v816 < 1.0)
              {
                *float v26 = vmulq_n_f32(*v26, v816);
              }
              unint64_t v817 = v47 + 16 * v1541;
              if (v817 >= v22) {
                uint64_t v818 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v818 = 0;
              }
              uint64_t v47 = v817 + 16 * v818;
              v26 += v1541;
              --v815;
            }
            while (v815);
            v26 += v1547;
            unint64_t v819 = v1550;
            unint64_t v820 = v1550 + 16 * v1549;
            if (v820 >= v1548) {
              uint64_t v821 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v821 = 0;
            }
            uint64_t v822 = v820 + 16 * v821;
            uint64_t v823 = v22 + 16 * v821 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v823;
              unint64_t v819 = v822;
            }
            unint64_t v1550 = v819;
            if (v1548) {
              uint64_t v47 = v822;
            }
            else {
              v47 += 16 * v1549;
            }
            --v192;
          }
          while (v192);
          goto LABEL_1352;
        case 9:
          if (v45)
          {
            int v209 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v210 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v211 = v22;
                unint64_t v212 = v1550;
                do
                {
                  unint64_t v213 = (v211 - v47) >> 4;
                  if (v213 >= v1546) {
                    unint64_t v213 = v1546;
                  }
                  if (v213 < 2)
                  {
                    unint64_t i19 = v213;
                  }
                  else
                  {
                    uint64_t v214 = 0;
                    for (unint64_t i19 = v213; i19 > 1; i19 -= 2)
                    {
                      long long v216 = (float32x4_t *)((char *)v26 + v214);
                      float32x4_t v217 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)(v47 + v214 + 16), *(float32x4_t *)(v47 + v214 + 16), *(float32x4_t *)((char *)v26 + v214 + 16), 3), *(float32x4_t *)((char *)v26 + v214 + 16), *(float32x4_t *)(v47 + v214 + 16), 3);
                      *long long v216 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)(v47 + v214), *(float32x4_t *)(v47 + v214), *(float32x4_t *)((char *)v26 + v214), 3), *(float32x4_t *)((char *)v26 + v214), *(float32x4_t *)(v47 + v214), 3);
                      v216[1] = v217;
                      v214 += v210;
                    }
                    v47 += v214;
                    float v26 = (float32x4_t *)((char *)v26 + v214);
                  }
                  for (unint64_t i20 = i19 + v1546 - v213; i20; --i20)
                  {
                    *float v26 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)v47, *(float32x4_t *)v47, *v26, 3), *v26, *(float32x4_t *)v47, 3);
                    unint64_t v219 = v47 + 16 * v1541;
                    if (v219 >= v211) {
                      uint64_t v220 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v220 = 0;
                    }
                    uint64_t v47 = v219 + 16 * v220;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v221 = v212 + 16 * v1549;
                  if (v221 >= v1548) {
                    uint64_t v222 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v222 = 0;
                  }
                  uint64_t v223 = v221 + 16 * v222;
                  uint64_t v224 = v211 + 16 * v222 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v223;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v211 = v224;
                    unint64_t v212 = v223;
                  }
                  _VF = __OFSUB__(v209--, 1);
                }
                while (!((v209 < 0) ^ _VF | (v209 == 0)));
              }
              else
              {
                unint64_t v1146 = v22;
                unint64_t v1147 = v1550;
                do
                {
                  unint64_t v1148 = (v1146 - v47) >> 4;
                  if (v1148 >= v1546) {
                    unint64_t v1148 = v1546;
                  }
                  if (v1148 < 2)
                  {
                    unint64_t i21 = v1148;
                  }
                  else
                  {
                    uint64_t v1149 = 0;
                    for (unint64_t i21 = v1148; i21 > 1; i21 -= 2)
                    {
                      v1151 = (int8x16_t *)((char *)v26 + v1149);
                      float32x4_t v1152 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1149 + 16));
                      float32x4_t v1153 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1149));
                      float32x4_t v1154 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1149));
                      float32x4_t v1155 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1149));
                      int8x16_t *v1151 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1153, v1153, v1155, 3), v1155, v1153, 3));
                      v1151[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1152, v1152, v1154, 3), v1154, v1152, 3));
                      v1149 += v210;
                    }
                    v47 += v1149;
                    float v26 = (float32x4_t *)((char *)v26 + v1149);
                  }
                  for (unint64_t i22 = i21 + v1546 - v1148; i22; --i22)
                  {
                    float32x4_t v1157 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    float32x4_t v1158 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v1157, v1157, v1158, 3), v1158, v1157, 3));
                    unint64_t v1159 = v47 + 16 * v1541;
                    if (v1159 >= v1146) {
                      uint64_t v1160 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1160 = 0;
                    }
                    uint64_t v47 = v1159 + 16 * v1160;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1161 = v1147 + 16 * v1549;
                  if (v1161 >= v1548) {
                    uint64_t v1162 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1162 = 0;
                  }
                  uint64_t v1163 = v1161 + 16 * v1162;
                  uint64_t v1164 = v1146 + 16 * v1162 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1163;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1146 = v1164;
                    unint64_t v1147 = v1163;
                  }
                  _VF = __OFSUB__(v209--, 1);
                }
                while (!((v209 < 0) ^ _VF | (v209 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v209 = v1552;
          }
          do
          {
            int v824 = v1546;
            do
            {
              *float v26 = vmlaq_n_f32(vmulq_laneq_f32(*v26, *(float32x4_t *)v47, 3), *(float32x4_t *)v47, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v26)));
              unint64_t v825 = v47 + 16 * v1541;
              if (v825 >= v22) {
                uint64_t v826 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v826 = 0;
              }
              uint64_t v47 = v825 + 16 * v826;
              v26 += v1541;
              --v824;
            }
            while (v824);
            v26 += v1547;
            unint64_t v827 = v1550;
            unint64_t v828 = v1550 + 16 * v1549;
            if (v828 >= v1548) {
              uint64_t v829 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v829 = 0;
            }
            uint64_t v830 = v828 + 16 * v829;
            uint64_t v831 = v22 + 16 * v829 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v831;
              unint64_t v827 = v830;
            }
            unint64_t v1550 = v827;
            if (v1548) {
              uint64_t v47 = v830;
            }
            else {
              v47 += 16 * v1549;
            }
            --v209;
          }
          while (v209);
          goto LABEL_1352;
        case 10:
          if (v45)
          {
            int v225 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              uint64_t v226 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v227 = v22;
                unint64_t v228 = v1550;
                do
                {
                  unint64_t v229 = (v227 - v47) >> 4;
                  if (v229 >= v1546) {
                    unint64_t v229 = v1546;
                  }
                  if (v229 < 2)
                  {
                    unint64_t i23 = v229;
                  }
                  else
                  {
                    uint64_t v230 = 0;
                    for (unint64_t i23 = v229; i23 > 1; i23 -= 2)
                    {
                      v232 = (float32x4_t *)((char *)v26 + v230);
                      float32x4_t v233 = *(float32x4_t *)(v47 + v230 + 16);
                      float32x4_t v234 = *(float32x4_t *)((char *)v26 + v230 + 16);
                      float32x4_t *v232 = vaddq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)v26 + v230), *(float32x4_t *)((char *)v26 + v230), *(float32x4_t *)(v47 + v230), 3), vmlsq_laneq_f32(*(float32x4_t *)(v47 + v230), *(float32x4_t *)(v47 + v230), *(float32x4_t *)((char *)v26 + v230), 3));
                      v232[1] = vaddq_f32(vmlsq_laneq_f32(v234, v234, v233, 3), vmlsq_laneq_f32(v233, v233, v234, 3));
                      v230 += v226;
                    }
                    v47 += v230;
                    float v26 = (float32x4_t *)((char *)v26 + v230);
                  }
                  for (unint64_t i24 = i23 + v1546 - v229; i24; --i24)
                  {
                    *float v26 = vaddq_f32(vmlsq_laneq_f32(*v26, *v26, *(float32x4_t *)v47, 3), vmlsq_laneq_f32(*(float32x4_t *)v47, *(float32x4_t *)v47, *v26, 3));
                    unint64_t v236 = v47 + 16 * v1541;
                    if (v236 >= v227) {
                      uint64_t v237 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v237 = 0;
                    }
                    uint64_t v47 = v236 + 16 * v237;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v238 = v228 + 16 * v1549;
                  if (v238 >= v1548) {
                    uint64_t v239 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v239 = 0;
                  }
                  uint64_t v240 = v238 + 16 * v239;
                  uint64_t v241 = v227 + 16 * v239 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v240;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v227 = v241;
                    unint64_t v228 = v240;
                  }
                  _VF = __OFSUB__(v225--, 1);
                }
                while (!((v225 < 0) ^ _VF | (v225 == 0)));
              }
              else
              {
                unint64_t v1165 = v22;
                unint64_t v1166 = v1550;
                do
                {
                  unint64_t v1167 = (v1165 - v47) >> 4;
                  if (v1167 >= v1546) {
                    unint64_t v1167 = v1546;
                  }
                  if (v1167 < 2)
                  {
                    unint64_t i25 = v1167;
                  }
                  else
                  {
                    uint64_t v1168 = 0;
                    for (unint64_t i25 = v1167; i25 > 1; i25 -= 2)
                    {
                      v1170 = (int8x16_t *)((char *)v26 + v1168);
                      float32x4_t v1171 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1168 + 16));
                      float32x4_t v1172 = (float32x4_t)vrev32q_s8(*(int8x16_t *)(v47 + v1168));
                      float32x4_t v1173 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1168));
                      float32x4_t v1174 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1168));
                      int8x16_t *v1170 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1174, v1174, v1172, 3), vmlsq_laneq_f32(v1172, v1172, v1174, 3)));
                      v1170[1] = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1173, v1173, v1171, 3), vmlsq_laneq_f32(v1171, v1171, v1173, 3)));
                      v1168 += v226;
                    }
                    v47 += v1168;
                    float v26 = (float32x4_t *)((char *)v26 + v1168);
                  }
                  for (unint64_t i26 = i25 + v1546 - v1167; i26; --i26)
                  {
                    float32x4_t v1176 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v47);
                    float32x4_t v1177 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v26);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1177, v1177, v1176, 3), vmlsq_laneq_f32(v1176, v1176, v1177, 3)));
                    unint64_t v1178 = v47 + 16 * v1541;
                    if (v1178 >= v1165) {
                      uint64_t v1179 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1179 = 0;
                    }
                    uint64_t v47 = v1178 + 16 * v1179;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1180 = v1166 + 16 * v1549;
                  if (v1180 >= v1548) {
                    uint64_t v1181 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1181 = 0;
                  }
                  uint64_t v1182 = v1180 + 16 * v1181;
                  uint64_t v1183 = v1165 + 16 * v1181 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1182;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1165 = v1183;
                    unint64_t v1166 = v1182;
                  }
                  _VF = __OFSUB__(v225--, 1);
                }
                while (!((v225 < 0) ^ _VF | (v225 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v225 = v1552;
          }
          do
          {
            int v832 = v1546;
            do
            {
              *float v26 = vmlaq_n_f32(vmulq_n_f32(*v26, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v47))), *(float32x4_t *)v47, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v26)));
              unint64_t v833 = v47 + 16 * v1541;
              if (v833 >= v22) {
                uint64_t v834 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v834 = 0;
              }
              uint64_t v47 = v833 + 16 * v834;
              v26 += v1541;
              --v832;
            }
            while (v832);
            v26 += v1547;
            unint64_t v835 = v1550;
            unint64_t v836 = v1550 + 16 * v1549;
            if (v836 >= v1548) {
              uint64_t v837 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v837 = 0;
            }
            uint64_t v838 = v836 + 16 * v837;
            uint64_t v839 = v22 + 16 * v837 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v839;
              unint64_t v835 = v838;
            }
            unint64_t v1550 = v835;
            if (v1548) {
              uint64_t v47 = v838;
            }
            else {
              v47 += 16 * v1549;
            }
            --v225;
          }
          while (v225);
          goto LABEL_1352;
        case 11:
          if (v45)
          {
            int v242 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v243 = 0;
              }
              else {
                unsigned int v243 = -1;
              }
              v244.i64[0] = 0;
              v244.i32[2] = 0;
              v245.i64[0] = 0;
              v245.i32[2] = 0;
              v245.i32[3] = v243;
              int8x16_t v246 = vmvnq_s8(v245);
              int8x16_t v247 = vandq_s8((int8x16_t)vdupq_n_s32(v243), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v248 = 0;
              }
              else {
                unsigned int v248 = -1;
              }
              v244.i32[3] = v248;
              int8x16_t v249 = vmvnq_s8(v244);
              int8x16_t v250 = vandq_s8((int8x16_t)vdupq_n_s32(v248), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v251 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V4.4S, #1.0 }
                unint64_t v253 = v22;
                unint64_t v254 = v1550;
                do
                {
                  unint64_t v255 = (v253 - v47) >> 4;
                  if (v255 >= v1546) {
                    unint64_t v255 = v1546;
                  }
                  if (v255 < 2)
                  {
                    unint64_t i27 = v255;
                  }
                  else
                  {
                    uint64_t v256 = 0;
                    for (unint64_t i27 = v255; i27 > 1; i27 -= 2)
                    {
                      v258 = (float32x4_t *)((char *)v26 + v256);
                      float32x4_t v259 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v256 + 16), v246), v247);
                      float32x4_t v260 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v256), v246), v247);
                      float32x4_t v261 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v256), v249), v250);
                      float32x4_t v262 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v256), v249), v250);
                      float32x4_t v263 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v260, 3);
                      float32x4_t v264 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v259, 3);
                      float32x4_t v265 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v262, 3);
                      float32x4_t v266 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v261, 3);
                      float32x4_t *v258 = vsubq_f32(vminnmq_f32(vaddq_f32(v263, v265), _Q4), vaddq_f32(vsubq_f32(v263, v260), vsubq_f32(v265, v262)));
                      v258[1] = vsubq_f32(vminnmq_f32(vaddq_f32(v264, v266), _Q4), vaddq_f32(vsubq_f32(v264, v259), vsubq_f32(v266, v261)));
                      v256 += v251;
                    }
                    v47 += v256;
                    float v26 = (float32x4_t *)((char *)v26 + v256);
                  }
                  for (unint64_t i28 = i27 + v1546 - v255; i28; --i28)
                  {
                    float32x4_t v268 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v246), v247);
                    float32x4_t v269 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v249), v250);
                    float32x4_t v270 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v268, 3);
                    float32x4_t v271 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v269, 3);
                    *float v26 = vsubq_f32(vminnmq_f32(vaddq_f32(v270, v271), _Q4), vaddq_f32(vsubq_f32(v270, v268), vsubq_f32(v271, v269)));
                    unint64_t v272 = v47 + 16 * v1541;
                    if (v272 >= v253) {
                      uint64_t v273 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v273 = 0;
                    }
                    uint64_t v47 = v272 + 16 * v273;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v274 = v254 + 16 * v1549;
                  if (v274 >= v1548) {
                    uint64_t v275 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v275 = 0;
                  }
                  uint64_t v276 = v274 + 16 * v275;
                  uint64_t v277 = v253 + 16 * v275 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v276;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v253 = v277;
                    unint64_t v254 = v276;
                  }
                  _VF = __OFSUB__(v242--, 1);
                }
                while (!((v242 < 0) ^ _VF | (v242 == 0)));
              }
              else
              {
                __asm { FMOV            V4.4S, #1.0 }
                unint64_t v1185 = v22;
                unint64_t v1186 = v1550;
                do
                {
                  unint64_t v1187 = (v1185 - v47) >> 4;
                  if (v1187 >= v1546) {
                    unint64_t v1187 = v1546;
                  }
                  if (v1187 < 2)
                  {
                    unint64_t i29 = v1187;
                  }
                  else
                  {
                    uint64_t v1188 = 0;
                    for (unint64_t i29 = v1187; i29 > 1; i29 -= 2)
                    {
                      v1190 = (int8x16_t *)((char *)v26 + v1188);
                      float32x4_t v1191 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1188 + 16)), v246), v247);
                      float32x4_t v1192 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1188)), v246), v247);
                      float32x4_t v1193 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1188)), v249), v250);
                      float32x4_t v1194 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1192, 3);
                      float32x4_t v1195 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1191, 3);
                      float32x4_t v1196 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1188)), v249), v250);
                      float32x4_t v1197 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1196, 3);
                      float32x4_t v1198 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1193, 3);
                      int8x16_t *v1190 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1194, v1197), _Q4), vaddq_f32(vsubq_f32(v1194, v1192), vsubq_f32(v1197, v1196))));
                      v1190[1] = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1195, v1198), _Q4), vaddq_f32(vsubq_f32(v1195, v1191), vsubq_f32(v1198, v1193))));
                      v1188 += v251;
                    }
                    v47 += v1188;
                    float v26 = (float32x4_t *)((char *)v26 + v1188);
                  }
                  for (unint64_t i30 = i29 + v1546 - v1187; i30; --i30)
                  {
                    float32x4_t v1200 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v246), v247);
                    float32x4_t v1201 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v249), v250);
                    float32x4_t v1202 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1200, 3);
                    float32x4_t v1203 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1201, 3);
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v1202, v1203), _Q4), vaddq_f32(vsubq_f32(v1202, v1200), vsubq_f32(v1203, v1201))));
                    unint64_t v1204 = v47 + 16 * v1541;
                    if (v1204 >= v1185) {
                      uint64_t v1205 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1205 = 0;
                    }
                    uint64_t v47 = v1204 + 16 * v1205;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1206 = v1186 + 16 * v1549;
                  if (v1206 >= v1548) {
                    uint64_t v1207 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1207 = 0;
                  }
                  uint64_t v1208 = v1206 + 16 * v1207;
                  uint64_t v1209 = v1185 + 16 * v1207 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1208;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1185 = v1209;
                    unint64_t v1186 = v1208;
                  }
                  _VF = __OFSUB__(v242--, 1);
                }
                while (!((v242 < 0) ^ _VF | (v242 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v242 = v1552;
          }
          do
          {
            int v840 = v1546;
            do
            {
              float v841 = 1.0;
              float v842 = 1.0;
              if (v20) {
                float v842 = v26->f32[3];
              }
              if (v44) {
                float v841 = *(float *)(v47 + 12);
              }
              float v843 = 1.0;
              float v844 = 1.0;
              if (v20) {
                float v844 = v26->f32[3];
              }
              if (v44) {
                float v843 = *(float *)(v47 + 12);
              }
              float v845 = v842 + v841;
              float v846 = 1.0;
              if (v845 > 1.0) {
                float v845 = 1.0;
              }
              float v847 = 1.0;
              if (v20) {
                float v847 = v26->f32[3];
              }
              if (v44) {
                float v846 = *(float *)(v47 + 12);
              }
              float v848 = v26->f32[1];
              float v849 = v844 - v26->f32[0];
              float v850 = *(float *)(v47 + 4);
              v26->f32[0] = v845 - (float)(v849 + (float)(v843 - *(float *)v47));
              float v851 = 1.0;
              float v852 = 1.0;
              if (v20) {
                float v852 = v26->f32[3];
              }
              if (v44) {
                float v851 = *(float *)(v47 + 12);
              }
              float v853 = (float)(v852 - v26->f32[2]) + (float)(v851 - *(float *)(v47 + 8));
              v26->f32[3] = v845;
              v26->f32[1] = v845 - (float)((float)(v847 - v848) + (float)(v846 - v850));
              v26->f32[2] = v845 - v853;
              unint64_t v854 = v47 + 16 * v1541;
              if (v854 >= v22) {
                uint64_t v855 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v855 = 0;
              }
              uint64_t v47 = v854 + 16 * v855;
              v26 += v1541;
              --v840;
            }
            while (v840);
            v26 += v1547;
            unint64_t v856 = v1550;
            unint64_t v857 = v1550 + 16 * v1549;
            if (v857 >= v1548) {
              uint64_t v858 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v858 = 0;
            }
            uint64_t v859 = v857 + 16 * v858;
            uint64_t v860 = v22 + 16 * v858 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v860;
              unint64_t v856 = v859;
            }
            unint64_t v1550 = v856;
            if (v1548) {
              uint64_t v47 = v859;
            }
            else {
              v47 += 16 * v1549;
            }
            --v242;
          }
          while (v242);
          goto LABEL_1352;
        case 12:
          if (v45)
          {
            int v278 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              v279.i64[0] = 0;
              v279.i32[2] = 0;
              v279.i32[3] = v44 - 1;
              int8x16_t v280 = vmvnq_s8(v279);
              int8x16_t v281 = vandq_s8((int8x16_t)vdupq_n_s32(v44 - 1), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v282 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v283 = v22;
                unint64_t v284 = v1550;
                do
                {
                  unint64_t v285 = (v283 - v47) >> 4;
                  if (v285 >= v1546) {
                    unint64_t v285 = v1546;
                  }
                  if (v285 < 2)
                  {
                    unint64_t i31 = v285;
                  }
                  else
                  {
                    uint64_t v286 = 0;
                    for (unint64_t i31 = v285; i31 > 1; i31 -= 2)
                    {
                      v288 = (float32x4_t *)((char *)v26 + v286);
                      float32x4_t v289 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)v26 + v286 + 16), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v286 + 16), v280), v281)), (float32x4_t)xmmword_1850CD6C0);
                      float32x4_t *v288 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)v26 + v286), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v286), v280), v281)), (float32x4_t)xmmword_1850CD6C0);
                      v288[1] = v289;
                      v286 += v282;
                    }
                    v47 += v286;
                    float v26 = (float32x4_t *)((char *)v26 + v286);
                  }
                  for (unint64_t i32 = i31 + v1546 - v285; i32; --i32)
                  {
                    *float v26 = vminnmq_f32(vaddq_f32(*v26, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v280), v281)), (float32x4_t)xmmword_1850CD6C0);
                    unint64_t v291 = v47 + 16 * v1541;
                    if (v291 >= v283) {
                      uint64_t v292 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v292 = 0;
                    }
                    uint64_t v47 = v291 + 16 * v292;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v293 = v284 + 16 * v1549;
                  if (v293 >= v1548) {
                    uint64_t v294 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v294 = 0;
                  }
                  uint64_t v295 = v293 + 16 * v294;
                  uint64_t v296 = v283 + 16 * v294 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v295;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v283 = v296;
                    unint64_t v284 = v295;
                  }
                  _VF = __OFSUB__(v278--, 1);
                }
                while (!((v278 < 0) ^ _VF | (v278 == 0)));
              }
              else
              {
                unint64_t v1210 = v22;
                unint64_t v1211 = v1550;
                do
                {
                  unint64_t v1212 = (v1210 - v47) >> 4;
                  if (v1212 >= v1546) {
                    unint64_t v1212 = v1546;
                  }
                  if (v1212 < 2)
                  {
                    unint64_t i33 = v1212;
                  }
                  else
                  {
                    uint64_t v1213 = 0;
                    for (unint64_t i33 = v1212; i33 > 1; i33 -= 2)
                    {
                      v1215 = (int8x16_t *)((char *)v26 + v1213);
                      int8x16_t v1216 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1213)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1213 + 16)), v280), v281)), (float32x4_t)xmmword_1850CD6C0));
                      int8x16_t *v1215 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)v26 + v1213)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1213)), v280), v281)), (float32x4_t)xmmword_1850CD6C0));
                      v1215[1] = v1216;
                      v1213 += v282;
                    }
                    v47 += v1213;
                    float v26 = (float32x4_t *)((char *)v26 + v1213);
                  }
                  for (unint64_t i34 = i33 + v1546 - v1212; i34; --i34)
                  {
                    *(int8x16_t *)float v26 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v26), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v280), v281)), (float32x4_t)xmmword_1850CD6C0));
                    unint64_t v1218 = v47 + 16 * v1541;
                    if (v1218 >= v1210) {
                      uint64_t v1219 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1219 = 0;
                    }
                    uint64_t v47 = v1218 + 16 * v1219;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1220 = v1211 + 16 * v1549;
                  if (v1220 >= v1548) {
                    uint64_t v1221 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1221 = 0;
                  }
                  uint64_t v1222 = v1220 + 16 * v1221;
                  uint64_t v1223 = v1210 + 16 * v1221 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1222;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1210 = v1223;
                    unint64_t v1211 = v1222;
                  }
                  _VF = __OFSUB__(v278--, 1);
                }
                while (!((v278 < 0) ^ _VF | (v278 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v278 = v1552;
          }
          do
          {
            int v861 = v1546;
            do
            {
              *(float32x2_t *)v26->f32 = vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47);
              float v862 = 1.0;
              if (v44) {
                float v862 = *(float *)(v47 + 12);
              }
              float v863 = v26->f32[3] + v862;
              if (v863 > 1.0) {
                float v863 = 1.0;
              }
              v26->f32[2] = v26->f32[2] + *(float *)(v47 + 8);
              v26->f32[3] = v863;
              unint64_t v864 = v47 + 16 * v1541;
              if (v864 >= v22) {
                uint64_t v865 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v865 = 0;
              }
              uint64_t v47 = v864 + 16 * v865;
              v26 += v1541;
              --v861;
            }
            while (v861);
            v26 += v1547;
            unint64_t v866 = v1550;
            unint64_t v867 = v1550 + 16 * v1549;
            if (v867 >= v1548) {
              uint64_t v868 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v868 = 0;
            }
            uint64_t v869 = v867 + 16 * v868;
            uint64_t v870 = v22 + 16 * v868 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v870;
              unint64_t v866 = v869;
            }
            unint64_t v1550 = v866;
            if (v1548) {
              uint64_t v47 = v869;
            }
            else {
              v47 += 16 * v1549;
            }
            --v278;
          }
          while (v278);
          goto LABEL_1352;
        case 13:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v297 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v298 = 0;
              }
              else {
                unsigned int v298 = -1;
              }
              v299.i64[0] = 0;
              v299.i32[2] = 0;
              v300.i64[0] = 0;
              v300.i32[2] = 0;
              v300.i32[3] = v298;
              int8x16_t v301 = vmvnq_s8(v300);
              int8x16_t v302 = vandq_s8((int8x16_t)vdupq_n_s32(v298), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v303 = 0;
              }
              else {
                unsigned int v303 = -1;
              }
              v299.i32[3] = v303;
              int8x16_t v304 = vmvnq_s8(v299);
              int8x16_t v305 = vandq_s8((int8x16_t)vdupq_n_s32(v303), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v306 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v307 = v22;
                unint64_t v308 = v1550;
                do
                {
                  unint64_t v309 = (v307 - v47) >> 4;
                  if (v309 >= v1546) {
                    unint64_t v309 = v1546;
                  }
                  if (v309 < 2)
                  {
                    unint64_t i35 = v309;
                  }
                  else
                  {
                    uint64_t v310 = 0;
                    for (unint64_t i35 = v309; i35 > 1; i35 -= 2)
                    {
                      v312 = (int8x16_t *)((char *)v26 + v310);
                      float32x4_t v313 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v310), v301), v302);
                      float32x4_t v314 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v310 + 16), v301), v302);
                      float32x4_t v315 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v310), v304), v305);
                      float32x4_t v316 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v310), v304), v305);
                      int8x16_t *v312 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v313, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v316, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v316, v316, v313, 3), vmlsq_laneq_f32(v313, v313, v316, 3)), v313, v316), (int8x16_t)v313), (int8x16_t)v316);
                      v312[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v314, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v315, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v315, v315, v314, 3), vmlsq_laneq_f32(v314, v314, v315, 3)), v314, v315), (int8x16_t)v314), (int8x16_t)v315);
                      v310 += v306;
                    }
                    v47 += v310;
                    float v26 = (float32x4_t *)((char *)v26 + v310);
                  }
                  for (unint64_t i36 = i35 + v1546 - v309; i36; --i36)
                  {
                    float32x4_t v318 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v301), v302);
                    float32x4_t v319 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v304), v305);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v318, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v319, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v319, v319, v318, 3), vmlsq_laneq_f32(v318, v318, v319, 3)), v318, v319), (int8x16_t)v318), (int8x16_t)v319);
                    unint64_t v320 = v47 + 16 * v1541;
                    if (v320 >= v307) {
                      uint64_t v321 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v321 = 0;
                    }
                    uint64_t v47 = v320 + 16 * v321;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v322 = v308 + 16 * v1549;
                  if (v322 >= v1548) {
                    uint64_t v323 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v323 = 0;
                  }
                  uint64_t v324 = v322 + 16 * v323;
                  uint64_t v325 = v307 + 16 * v323 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v324;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v307 = v325;
                    unint64_t v308 = v324;
                  }
                  _VF = __OFSUB__(v297--, 1);
                }
                while (!((v297 < 0) ^ _VF | (v297 == 0)));
              }
              else
              {
                unint64_t v1224 = v22;
                unint64_t v1225 = v1550;
                do
                {
                  unint64_t v1226 = (v1224 - v47) >> 4;
                  if (v1226 >= v1546) {
                    unint64_t v1226 = v1546;
                  }
                  if (v1226 < 2)
                  {
                    unint64_t i37 = v1226;
                  }
                  else
                  {
                    uint64_t v1227 = 0;
                    for (unint64_t i37 = v1226; i37 > 1; i37 -= 2)
                    {
                      v1229 = (int8x16_t *)((char *)v26 + v1227);
                      float32x4_t v1230 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1227 + 16)), v301), v302);
                      float32x4_t v1231 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1227)), v301), v302);
                      float32x4_t v1232 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1227)), v304), v305);
                      float32x4_t v1233 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1227)), v304), v305);
                      int8x16_t *v1229 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1231, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1232, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1232, v1232, v1231, 3), vmlsq_laneq_f32(v1231, v1231, v1232, 3)), v1231, v1232), (int8x16_t)v1231), (int8x16_t)v1232));
                      v1229[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1230, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1233, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1233, v1233, v1230, 3), vmlsq_laneq_f32(v1230, v1230, v1233, 3)), v1230, v1233), (int8x16_t)v1230), (int8x16_t)v1233));
                      v1227 += v306;
                    }
                    v47 += v1227;
                    float v26 = (float32x4_t *)((char *)v26 + v1227);
                  }
                  for (unint64_t i38 = i37 + v1546 - v1226; i38; --i38)
                  {
                    float32x4_t v1235 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v301), v302);
                    float32x4_t v1236 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v304), v305);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1235, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1236, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v1236, v1236, v1235, 3), vmlsq_laneq_f32(v1235, v1235, v1236, 3)), v1235, v1236), (int8x16_t)v1235), (int8x16_t)v1236));
                    unint64_t v1237 = v47 + 16 * v1541;
                    if (v1237 >= v1224) {
                      uint64_t v1238 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1238 = 0;
                    }
                    uint64_t v47 = v1237 + 16 * v1238;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1239 = v1225 + 16 * v1549;
                  if (v1239 >= v1548) {
                    uint64_t v1240 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1240 = 0;
                  }
                  uint64_t v1241 = v1239 + 16 * v1240;
                  uint64_t v1242 = v1224 + 16 * v1240 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1241;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1224 = v1242;
                    unint64_t v1225 = v1241;
                  }
                  _VF = __OFSUB__(v297--, 1);
                }
                while (!((v297 < 0) ^ _VF | (v297 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v297 = v1552;
          }
          do
          {
            int v934 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1169;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v935 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1169;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v935 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1526) = LODWORD(a14);
              LODWORD(v1526) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAmultiplyPDA(v26->f32[0], a8, a9, a10, v935, a12, a13, a14, *(float *)v47, v1526, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1169:
              unint64_t v936 = v47 + 16 * v1541;
              if (v936 >= v22) {
                uint64_t v937 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v937 = 0;
              }
              uint64_t v47 = v936 + 16 * v937;
              v26 += v1541;
              --v934;
            }
            while (v934);
            v26 += v1547;
            unint64_t v938 = v1550;
            unint64_t v939 = v1550 + 16 * v1549;
            uint64_t v940 = -(uint64_t)(v1549 * v1542);
            if (v939 < v1548) {
              uint64_t v940 = 0;
            }
            uint64_t v941 = v939 + 16 * v940;
            uint64_t v942 = v22 + 16 * v940 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v942;
              unint64_t v938 = v941;
            }
            unint64_t v1550 = v938;
            if (v1548) {
              uint64_t v47 = v941;
            }
            else {
              v47 += 16 * v1549;
            }
            --v297;
          }
          while (v297);
LABEL_1335:
          unsigned int v1552 = 0;
          int v14 = v1534;
          int v45 = v1535;
          uint64_t v30 = a2;
          uint64_t v32 = v1537;
LABEL_1336:
          unint64_t v48 = v1540;
LABEL_1353:
          double v51 = v1543;
          float v26 = v1544;
          if (!v1543) {
            return;
          }
          uint64_t v1551 = 0;
LABEL_1355:
          a1 = shape_enum_clip_next((uint64_t)v51, (int *)&v1551 + 1, &v1551, v1553, &v1552);
          if (!a1)
          {
            free(v51);
            return;
          }
          v1543 = v51;
          v1544 = v26;
          if (v1548)
          {
            v26 += v48 * (int)v1551 + SHIDWORD(v1551);
            int64_t v24 = v32 + 16 * v1549 * (((int)v1551 + *(_DWORD *)(v30 + 60)) % v1542);
            int v1539 = (HIDWORD(v1551) + *(_DWORD *)(v30 + 56)) % (int)v1545;
            uint64_t v47 = v24 + 16 * v1539;
            unint64_t v22 = v24 + 16 * (int)v1545;
            unint64_t v1550 = v47;
            int v1546 = v1553[0];
            LODWORD(v24) = v1553[0];
            int v1538 = ((int)v1551 + *(_DWORD *)(v30 + 60)) % v1542;
          }
          else
          {
            int v1546 = v1553[0];
            LODWORD(v24) = v1553[0] * v1541;
            v26 += v48 * (int)v1551 + HIDWORD(v1551) * v1541;
            uint64_t v47 = v32 + 16 * (int)v1551 * (int)v1545 + 16 * HIDWORD(v1551) * v1541;
            unint64_t v1549 = (int)v1545 - v1553[0] * v1541;
          }
          int64_t v24 = (int)v24;
          continue;
        case 14:
          if (v45)
          {
            int v326 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v327 = 0;
              }
              else {
                unsigned int v327 = -1;
              }
              v328.i64[0] = 0;
              v328.i32[2] = 0;
              v328.i32[3] = v327;
              int8x16_t v329 = vmvnq_s8(v328);
              int8x16_t v330 = vandq_s8((int8x16_t)vdupq_n_s32(v327), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v331 = 0;
              }
              else {
                unsigned int v331 = -1;
              }
              v332.i64[0] = 0;
              v332.i32[2] = 0;
              v332.i32[3] = v331;
              int8x16_t v333 = vmvnq_s8(v332);
              int8x16_t v334 = vandq_s8((int8x16_t)vdupq_n_s32(v331), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v335 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V5.4S, #1.0 }
                unint64_t v337 = v22;
                unint64_t v338 = v1550;
                do
                {
                  unint64_t v339 = (v337 - v47) >> 4;
                  if (v339 >= v1546) {
                    unint64_t v339 = v1546;
                  }
                  if (v339 < 2)
                  {
                    unint64_t i39 = v339;
                  }
                  else
                  {
                    uint64_t v340 = 0;
                    for (unint64_t i39 = v339; i39 > 1; i39 -= 2)
                    {
                      v342 = (int8x16_t *)((char *)v26 + v340);
                      float32x4_t v343 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v340 + 16), v329), v330);
                      float32x4_t v344 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v340), v329), v330);
                      float32x4_t v345 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v340), v333), v334);
                      float32x4_t v346 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v340), v333), v334);
                      int8x16_t *v342 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v344, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v345, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v344, v345, v344), v345), (int8x16_t)v344), (int8x16_t)v345);
                      v342[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v343, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v346, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v343, v346, v343), v346), (int8x16_t)v343), (int8x16_t)v346);
                      v340 += v335;
                    }
                    v47 += v340;
                    float v26 = (float32x4_t *)((char *)v26 + v340);
                  }
                  for (unint64_t i40 = i39 + v1546 - v339; i40; --i40)
                  {
                    float32x4_t v348 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v329), v330);
                    float32x4_t v349 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v333), v334);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v348)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v349, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v348, v349, v348), v349), (int8x16_t)v348), (int8x16_t)v349);
                    unint64_t v350 = v47 + 16 * v1541;
                    if (v350 >= v337) {
                      uint64_t v351 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v351 = 0;
                    }
                    uint64_t v47 = v350 + 16 * v351;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v352 = v338 + 16 * v1549;
                  if (v352 >= v1548) {
                    uint64_t v353 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v353 = 0;
                  }
                  uint64_t v354 = v352 + 16 * v353;
                  uint64_t v355 = v337 + 16 * v353 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v354;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v337 = v355;
                    unint64_t v338 = v354;
                  }
                  _VF = __OFSUB__(v326--, 1);
                }
                while (!((v326 < 0) ^ _VF | (v326 == 0)));
              }
              else
              {
                __asm { FMOV            V5.4S, #1.0 }
                unint64_t v1244 = v22;
                unint64_t v1245 = v1550;
                do
                {
                  unint64_t v1246 = (v1244 - v47) >> 4;
                  if (v1246 >= v1546) {
                    unint64_t v1246 = v1546;
                  }
                  if (v1246 < 2)
                  {
                    unint64_t i41 = v1246;
                  }
                  else
                  {
                    uint64_t v1247 = 0;
                    for (unint64_t i41 = v1246; i41 > 1; i41 -= 2)
                    {
                      v1249 = (int8x16_t *)((char *)v26 + v1247);
                      float32x4_t v1250 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1247)), v329), v330);
                      float32x4_t v1251 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1247 + 16)), v329), v330);
                      float32x4_t v1252 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1247)), v333), v334);
                      float32x4_t v1253 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1247)), v333), v334);
                      int8x16_t *v1249 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1250, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1252, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1250, v1252, v1250), v1252), (int8x16_t)v1250), (int8x16_t)v1252));
                      v1249[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1251, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1253, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1251, v1253, v1251), v1253), (int8x16_t)v1251), (int8x16_t)v1253));
                      v1247 += v335;
                    }
                    v47 += v1247;
                    float v26 = (float32x4_t *)((char *)v26 + v1247);
                  }
                  for (unint64_t i42 = i41 + v1546 - v1246; i42; --i42)
                  {
                    float32x4_t v1255 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v329), v330);
                    float32x4_t v1256 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v333), v334);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1255)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1256, 3), _Q5), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v1255, v1256, v1255), v1256), (int8x16_t)v1255), (int8x16_t)v1256));
                    unint64_t v1257 = v47 + 16 * v1541;
                    if (v1257 >= v1244) {
                      uint64_t v1258 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1258 = 0;
                    }
                    uint64_t v47 = v1257 + 16 * v1258;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1259 = v1245 + 16 * v1549;
                  if (v1259 >= v1548) {
                    uint64_t v1260 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1260 = 0;
                  }
                  uint64_t v1261 = v1259 + 16 * v1260;
                  uint64_t v1262 = v1244 + 16 * v1260 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1261;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1244 = v1262;
                    unint64_t v1245 = v1261;
                  }
                  _VF = __OFSUB__(v326--, 1);
                }
                while (!((v326 < 0) ^ _VF | (v326 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v326 = v1552;
          }
          __asm { FMOV            V1.2S, #1.0 }
          do
          {
            int v872 = v1546;
            do
            {
              float v873 = 1.0;
              float v874 = 1.0;
              if (!v44 || (float v874 = *(float *)(v47 + 12), v874 > 0.0))
              {
                if (v20 && (float v873 = v26->f32[3], v873 <= 0.0))
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                }
                else
                {
                  float32_t v875 = v26->f32[2] + (float)(*(float *)(v47 + 8) * (float)(1.0 - v26->f32[2]));
                  float v874 = (float)(v874 + v873) - (float)(v873 * v874);
                  *(float32x2_t *)v26->f32 = vmla_f32(*(float32x2_t *)v26->f32, vsub_f32(_D1, *(float32x2_t *)v26->f32), *(float32x2_t *)v47);
                  v26->f32[2] = v875;
                }
                v26->f32[3] = v874;
              }
              unint64_t v876 = v47 + 16 * v1541;
              if (v876 >= v22) {
                uint64_t v877 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v877 = 0;
              }
              uint64_t v47 = v876 + 16 * v877;
              v26 += v1541;
              --v872;
            }
            while (v872);
            v26 += v1547;
            unint64_t v878 = v1550;
            unint64_t v879 = v1550 + 16 * v1549;
            if (v879 >= v1548) {
              uint64_t v880 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v880 = 0;
            }
            uint64_t v881 = v879 + 16 * v880;
            uint64_t v882 = v22 + 16 * v880 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v882;
              unint64_t v878 = v881;
            }
            unint64_t v1550 = v878;
            if (v1548) {
              uint64_t v47 = v881;
            }
            else {
              v47 += 16 * v1549;
            }
            --v326;
          }
          while (v326);
          goto LABEL_1352;
        case 15:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v356 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v357 = 0;
              }
              else {
                unsigned int v357 = -1;
              }
              v358.i64[0] = 0;
              v358.i32[2] = 0;
              v359.i64[0] = 0;
              v359.i32[2] = 0;
              v359.i32[3] = v357;
              int8x16_t v360 = vmvnq_s8(v359);
              int8x16_t v361 = vandq_s8((int8x16_t)vdupq_n_s32(v357), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v362 = 0;
              }
              else {
                unsigned int v362 = -1;
              }
              v358.i32[3] = v362;
              int8x16_t v363 = vmvnq_s8(v358);
              int8x16_t v364 = vandq_s8((int8x16_t)vdupq_n_s32(v362), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v365 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v366.i64[0] = 0x3F0000003F000000;
                v366.i64[1] = 0x3F0000003F000000;
                v367.i64[0] = 0x8000000080000000;
                v367.i64[1] = 0x8000000080000000;
                unint64_t v368 = v22;
                unint64_t v369 = v1550;
                do
                {
                  unint64_t v370 = (v368 - v47) >> 4;
                  if (v370 >= v1546) {
                    unint64_t v370 = v1546;
                  }
                  if (v370 < 2)
                  {
                    unint64_t i43 = v370;
                  }
                  else
                  {
                    uint64_t v371 = 0;
                    for (unint64_t i43 = v370; i43 > 1; i43 -= 2)
                    {
                      v373 = (int8x16_t *)((char *)v26 + v371);
                      float32x4_t v374 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v371), v360), v361);
                      float32x4_t v375 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v371 + 16), v360), v361);
                      float32x4_t v376 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v371), v363), v364);
                      float32x4_t v377 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v375, 3);
                      float32x4_t v378 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v374, 3);
                      float32x4_t v379 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v371), v363), v364);
                      float32x4_t v380 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v379, 3);
                      float32x4_t v381 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v376, 3);
                      int8x16_t v382 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v379, 3), v379);
                      int8x16_t v383 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v376, 3), v376);
                      int8x16_t v384 = vandq_s8(v383, v367);
                      int8x16_t v385 = vandq_s8(v382, v367);
                      int8x16_t *v373 = vbslq_s8((int8x16_t)vcgtzq_f32(v378), vbslq_s8((int8x16_t)vcgtzq_f32(v380), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v379, (float32x4_t)veorq_s8(v385, (int8x16_t)vsubq_f32(v378, v374)), v379), vmlaq_f32(v374, (float32x4_t)veorq_s8(v385, (int8x16_t)vsubq_f32(v380, v379)), v374)), (float32x4_t)vbslq_s8(v382, v367, (int8x16_t)vmulq_laneq_f32(v378, v379, 3))), (int8x16_t)v374), (int8x16_t)v379);
                      v373[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v377), vbslq_s8((int8x16_t)vcgtzq_f32(v381), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v376, (float32x4_t)veorq_s8(v384, (int8x16_t)vsubq_f32(v377, v375)), v376), vmlaq_f32(v375, (float32x4_t)veorq_s8(v384, (int8x16_t)vsubq_f32(v381, v376)), v375)), (float32x4_t)vbslq_s8(v383, v367, (int8x16_t)vmulq_laneq_f32(v377, v376, 3))), (int8x16_t)v375), (int8x16_t)v376);
                      v371 += v365;
                    }
                    v47 += v371;
                    float v26 = (float32x4_t *)((char *)v26 + v371);
                  }
                  for (unint64_t i44 = i43 + v1546 - v370; i44; --i44)
                  {
                    float32x4_t v387 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v360), v361);
                    float32x4_t v388 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v363), v364);
                    float32x4_t v389 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v387, 3);
                    float32x4_t v390 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v388, 3);
                    int8x16_t v391 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v366, v388, 3), v388);
                    int8x16_t v392 = vandq_s8(v391, v367);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v389), vbslq_s8((int8x16_t)vcgtzq_f32(v390), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v388, (float32x4_t)veorq_s8(v392, (int8x16_t)vsubq_f32(v389, v387)), v388), vmlaq_f32(v387, (float32x4_t)veorq_s8(v392, (int8x16_t)vsubq_f32(v390, v388)), v387)), (float32x4_t)vbslq_s8(v391,
                                                                        v367,
                                                                        (int8x16_t)vmulq_laneq_f32(v389, v388, 3))),
                                            (int8x16_t)v387),
                                          (int8x16_t)v388);
                    unint64_t v393 = v47 + 16 * v1541;
                    if (v393 >= v368) {
                      uint64_t v394 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v394 = 0;
                    }
                    uint64_t v47 = v393 + 16 * v394;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v395 = v369 + 16 * v1549;
                  if (v395 >= v1548) {
                    uint64_t v396 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v396 = 0;
                  }
                  uint64_t v397 = v395 + 16 * v396;
                  uint64_t v398 = v368 + 16 * v396 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v397;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v368 = v398;
                    unint64_t v369 = v397;
                  }
                  _VF = __OFSUB__(v356--, 1);
                }
                while (!((v356 < 0) ^ _VF | (v356 == 0)));
              }
              else
              {
                v1263.i64[0] = 0x3F0000003F000000;
                v1263.i64[1] = 0x3F0000003F000000;
                v1264.i64[0] = 0x8000000080000000;
                v1264.i64[1] = 0x8000000080000000;
                unint64_t v1265 = v22;
                unint64_t v1266 = v1550;
                do
                {
                  unint64_t v1267 = (v1265 - v47) >> 4;
                  if (v1267 >= v1546) {
                    unint64_t v1267 = v1546;
                  }
                  if (v1267 < 2)
                  {
                    unint64_t i45 = v1267;
                  }
                  else
                  {
                    uint64_t v1268 = 0;
                    for (unint64_t i45 = v1267; i45 > 1; i45 -= 2)
                    {
                      v1270 = (int8x16_t *)((char *)v26 + v1268);
                      float32x4_t v1271 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1268 + 16)), v360), v361);
                      float32x4_t v1272 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1268)), v360), v361);
                      float32x4_t v1273 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1268)), v363), v364);
                      float32x4_t v1274 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1272, 3);
                      float32x4_t v1275 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1271, 3);
                      float32x4_t v1276 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1273, 3);
                      float32x4_t v1277 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1268)), v363), v364);
                      float32x4_t v1278 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1277, 3);
                      int8x16_t v1279 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1273, 3), v1273);
                      int8x16_t v1280 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1277, 3), v1277);
                      int8x16_t v1281 = vandq_s8(v1280, v1264);
                      int8x16_t v1282 = vandq_s8(v1279, v1264);
                      int8x16_t *v1270 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1274), vbslq_s8((int8x16_t)vcgtzq_f32(v1278), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1277, (float32x4_t)veorq_s8(v1281, (int8x16_t)vsubq_f32(v1274, v1272)), v1277), vmlaq_f32(v1272, (float32x4_t)veorq_s8(v1281, (int8x16_t)vsubq_f32(v1278, v1277)), v1272)), (float32x4_t)vbslq_s8(v1280, v1264, (int8x16_t)vmulq_laneq_f32(v1274, v1277, 3))), (int8x16_t)v1272),
                                   (int8x16_t)v1277));
                      v1270[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1275), vbslq_s8((int8x16_t)vcgtzq_f32(v1276), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1273, (float32x4_t)veorq_s8(v1282, (int8x16_t)vsubq_f32(v1275, v1271)), v1273), vmlaq_f32(v1271, (float32x4_t)veorq_s8(v1282, (int8x16_t)vsubq_f32(v1276, v1273)), v1271)), (float32x4_t)vbslq_s8(v1279, v1264, (int8x16_t)vmulq_laneq_f32(v1275, v1273, 3))), (int8x16_t)v1271),
                                     (int8x16_t)v1273));
                      v1268 += v365;
                    }
                    v47 += v1268;
                    float v26 = (float32x4_t *)((char *)v26 + v1268);
                  }
                  for (unint64_t i46 = i45 + v1546 - v1267; i46; --i46)
                  {
                    float32x4_t v1284 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v360), v361);
                    float32x4_t v1285 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1284, 3);
                    float32x4_t v1286 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v363), v364);
                    float32x4_t v1287 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1286, 3);
                    int8x16_t v1288 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v1263, v1286, 3), v1286);
                    int8x16_t v1289 = vandq_s8(v1288, v1264);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1285), vbslq_s8((int8x16_t)vcgtzq_f32(v1287), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1286, (float32x4_t)veorq_s8(v1289, (int8x16_t)vsubq_f32(v1285, v1284)), v1286), vmlaq_f32(v1284, (float32x4_t)veorq_s8(v1289, (int8x16_t)vsubq_f32(v1287, v1286)), v1284)), (float32x4_t)vbslq_s8(
                                                                          v1288,
                                                                          v1264,
                                                                          (int8x16_t)vmulq_laneq_f32(v1285, v1286, 3))),
                                              (int8x16_t)v1284),
                                            (int8x16_t)v1286));
                    unint64_t v1290 = v47 + 16 * v1541;
                    if (v1290 >= v1265) {
                      uint64_t v1291 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1291 = 0;
                    }
                    uint64_t v47 = v1290 + 16 * v1291;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1292 = v1266 + 16 * v1549;
                  if (v1292 >= v1548) {
                    uint64_t v1293 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1293 = 0;
                  }
                  uint64_t v1294 = v1292 + 16 * v1293;
                  uint64_t v1295 = v1265 + 16 * v1293 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1294;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1265 = v1295;
                    unint64_t v1266 = v1294;
                  }
                  _VF = __OFSUB__(v356--, 1);
                }
                while (!((v356 < 0) ^ _VF | (v356 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v356 = v1552;
          }
          while (1)
          {
            int v943 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1191;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v944 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1191;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v944 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1527) = LODWORD(a14);
              LODWORD(v1527) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAoverlayPDA(v26->f32[0], a8, a9, a10, v944, a12, a13, a14, *(float *)v47, v1527, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1191:
              unint64_t v945 = v47 + 16 * v1541;
              if (v945 >= v22) {
                uint64_t v946 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v946 = 0;
              }
              uint64_t v47 = v945 + 16 * v946;
              v26 += v1541;
              --v943;
            }
            while (v943);
            v26 += v1547;
            unint64_t v947 = v1550;
            unint64_t v948 = v1550 + 16 * v1549;
            uint64_t v949 = -(uint64_t)(v1549 * v1542);
            if (v948 < v1548) {
              uint64_t v949 = 0;
            }
            uint64_t v950 = v948 + 16 * v949;
            uint64_t v951 = v22 + 16 * v949 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v951;
              unint64_t v947 = v950;
            }
            unint64_t v1550 = v947;
            if (v1548) {
              uint64_t v47 = v950;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v356) {
              goto LABEL_1335;
            }
          }
        case 16:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v399 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v400 = 0;
              }
              else {
                unsigned int v400 = -1;
              }
              v401.i64[0] = 0;
              v401.i32[2] = 0;
              v402.i64[0] = 0;
              v402.i32[2] = 0;
              v402.i32[3] = v400;
              int8x16_t v403 = vmvnq_s8(v402);
              int8x16_t v404 = vandq_s8((int8x16_t)vdupq_n_s32(v400), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v405 = 0;
              }
              else {
                unsigned int v405 = -1;
              }
              v401.i32[3] = v405;
              int8x16_t v406 = vmvnq_s8(v401);
              int8x16_t v407 = vandq_s8((int8x16_t)vdupq_n_s32(v405), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v408 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v409 = v22;
                unint64_t v410 = v1550;
                do
                {
                  unint64_t v411 = (v409 - v47) >> 4;
                  if (v411 >= v1546) {
                    unint64_t v411 = v1546;
                  }
                  if (v411 < 2)
                  {
                    unint64_t i47 = v411;
                  }
                  else
                  {
                    uint64_t v412 = 0;
                    for (unint64_t i47 = v411; i47 > 1; i47 -= 2)
                    {
                      v414 = (int8x16_t *)((char *)v26 + v412);
                      float32x4_t v415 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v412), v406), v407);
                      float32x4_t v416 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v412), v406), v407);
                      float32x4_t v417 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v412), v403), v404);
                      float32x4_t v418 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v412 + 16), v403), v404);
                      int8x16_t *v414 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v417, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v416, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v417, v417, v416, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v416, v417, 3), vmulq_laneq_f32(v417, v416, 3)), vmlsq_laneq_f32(v416, v416, v417, 3))), (int8x16_t)v417), (int8x16_t)v416);
                      v414[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v418, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v415, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v418, v418, v415, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v415, v418, 3), vmulq_laneq_f32(v418, v415, 3)), vmlsq_laneq_f32(v415, v415, v418, 3))), (int8x16_t)v418), (int8x16_t)v415);
                      v412 += v408;
                    }
                    v47 += v412;
                    float v26 = (float32x4_t *)((char *)v26 + v412);
                  }
                  for (unint64_t i48 = i47 + v1546 - v411; i48; --i48)
                  {
                    float32x4_t v420 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v403), v404);
                    float32x4_t v421 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v406), v407);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v420, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v421, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v420, v420, v421, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v421, v420, 3), vmulq_laneq_f32(v420, v421, 3)), vmlsq_laneq_f32(v421, v421, v420, 3))), (int8x16_t)v420), (int8x16_t)v421);
                    unint64_t v422 = v47 + 16 * v1541;
                    if (v422 >= v409) {
                      uint64_t v423 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v423 = 0;
                    }
                    uint64_t v47 = v422 + 16 * v423;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v424 = v410 + 16 * v1549;
                  if (v424 >= v1548) {
                    uint64_t v425 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v425 = 0;
                  }
                  uint64_t v426 = v424 + 16 * v425;
                  uint64_t v427 = v409 + 16 * v425 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v426;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v409 = v427;
                    unint64_t v410 = v426;
                  }
                  _VF = __OFSUB__(v399--, 1);
                }
                while (!((v399 < 0) ^ _VF | (v399 == 0)));
              }
              else
              {
                unint64_t v1296 = v22;
                unint64_t v1297 = v1550;
                do
                {
                  unint64_t v1298 = (v1296 - v47) >> 4;
                  if (v1298 >= v1546) {
                    unint64_t v1298 = v1546;
                  }
                  if (v1298 < 2)
                  {
                    unint64_t i49 = v1298;
                  }
                  else
                  {
                    uint64_t v1299 = 0;
                    for (unint64_t i49 = v1298; i49 > 1; i49 -= 2)
                    {
                      v1301 = (int8x16_t *)((char *)v26 + v1299);
                      float32x4_t v1302 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1299)), v406), v407);
                      float32x4_t v1303 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1299)), v406), v407);
                      float32x4_t v1304 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1299 + 16)), v403), v404);
                      float32x4_t v1305 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1299)), v403), v404);
                      int8x16_t *v1301 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1305, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1302, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1305, v1305, v1302, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1302, v1305, 3), vmulq_laneq_f32(v1305, v1302, 3)), vmlsq_laneq_f32(v1302, v1302, v1305, 3))), (int8x16_t)v1305), (int8x16_t)v1302));
                      v1301[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1304, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1303, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1304, v1304, v1303, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1303, v1304, 3), vmulq_laneq_f32(v1304, v1303, 3)), vmlsq_laneq_f32(v1303, v1303, v1304, 3))), (int8x16_t)v1304), (int8x16_t)v1303));
                      v1299 += v408;
                    }
                    v47 += v1299;
                    float v26 = (float32x4_t *)((char *)v26 + v1299);
                  }
                  for (unint64_t i50 = i49 + v1546 - v1298; i50; --i50)
                  {
                    float32x4_t v1307 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v403), v404);
                    float32x4_t v1308 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v406), v407);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1307, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1308, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1307, v1307, v1308, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v1308, v1307, 3), vmulq_laneq_f32(v1307, v1308, 3)), vmlsq_laneq_f32(v1308, v1308, v1307, 3))), (int8x16_t)v1307), (int8x16_t)v1308));
                    unint64_t v1309 = v47 + 16 * v1541;
                    if (v1309 >= v1296) {
                      uint64_t v1310 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1310 = 0;
                    }
                    uint64_t v47 = v1309 + 16 * v1310;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1311 = v1297 + 16 * v1549;
                  if (v1311 >= v1548) {
                    uint64_t v1312 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1312 = 0;
                  }
                  uint64_t v1313 = v1311 + 16 * v1312;
                  uint64_t v1314 = v1296 + 16 * v1312 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1313;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1296 = v1314;
                    unint64_t v1297 = v1313;
                  }
                  _VF = __OFSUB__(v399--, 1);
                }
                while (!((v399 < 0) ^ _VF | (v399 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v399 = v1552;
          }
          while (1)
          {
            int v952 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1213;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v953 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1213;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v953 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1528) = LODWORD(a14);
              LODWORD(v1528) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAdarkenPDA(v26->f32[0], a8, a9, a10, v953, a12, a13, a14, *(float *)v47, v1528, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1213:
              unint64_t v954 = v47 + 16 * v1541;
              if (v954 >= v22) {
                uint64_t v955 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v955 = 0;
              }
              uint64_t v47 = v954 + 16 * v955;
              v26 += v1541;
              --v952;
            }
            while (v952);
            v26 += v1547;
            unint64_t v956 = v1550;
            unint64_t v957 = v1550 + 16 * v1549;
            uint64_t v958 = -(uint64_t)(v1549 * v1542);
            if (v957 < v1548) {
              uint64_t v958 = 0;
            }
            uint64_t v959 = v957 + 16 * v958;
            uint64_t v960 = v22 + 16 * v958 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v960;
              unint64_t v956 = v959;
            }
            unint64_t v1550 = v956;
            if (v1548) {
              uint64_t v47 = v959;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v399) {
              goto LABEL_1335;
            }
          }
        case 17:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v428 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v429 = 0;
              }
              else {
                unsigned int v429 = -1;
              }
              v430.i64[0] = 0;
              v430.i32[2] = 0;
              v431.i64[0] = 0;
              v431.i32[2] = 0;
              v431.i32[3] = v429;
              int8x16_t v432 = vmvnq_s8(v431);
              int8x16_t v433 = vandq_s8((int8x16_t)vdupq_n_s32(v429), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v434 = 0;
              }
              else {
                unsigned int v434 = -1;
              }
              v430.i32[3] = v434;
              int8x16_t v435 = vmvnq_s8(v430);
              int8x16_t v436 = vandq_s8((int8x16_t)vdupq_n_s32(v434), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v437 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v438 = v22;
                unint64_t v439 = v1550;
                do
                {
                  unint64_t v440 = (v438 - v47) >> 4;
                  if (v440 >= v1546) {
                    unint64_t v440 = v1546;
                  }
                  if (v440 < 2)
                  {
                    unint64_t i51 = v440;
                  }
                  else
                  {
                    uint64_t v441 = 0;
                    for (unint64_t i51 = v440; i51 > 1; i51 -= 2)
                    {
                      v443 = (int8x16_t *)((char *)v26 + v441);
                      float32x4_t v444 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v441), v435), v436);
                      float32x4_t v445 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v441), v435), v436);
                      float32x4_t v446 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v441), v432), v433);
                      float32x4_t v447 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v441 + 16), v432), v433);
                      int8x16_t *v443 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v446, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v445, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v446, v446, v445, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v445, v446, 3), vmulq_laneq_f32(v446, v445, 3)), vmlsq_laneq_f32(v445, v445, v446, 3))), (int8x16_t)v446), (int8x16_t)v445);
                      v443[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v447, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v444, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v447, v447, v444, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v444, v447, 3), vmulq_laneq_f32(v447, v444, 3)), vmlsq_laneq_f32(v444, v444, v447, 3))), (int8x16_t)v447), (int8x16_t)v444);
                      v441 += v437;
                    }
                    v47 += v441;
                    float v26 = (float32x4_t *)((char *)v26 + v441);
                  }
                  for (unint64_t i52 = i51 + v1546 - v440; i52; --i52)
                  {
                    float32x4_t v449 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v432), v433);
                    float32x4_t v450 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v435), v436);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v449, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v450, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v449, v449, v450, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v450, v449, 3), vmulq_laneq_f32(v449, v450, 3)), vmlsq_laneq_f32(v450, v450, v449, 3))), (int8x16_t)v449), (int8x16_t)v450);
                    unint64_t v451 = v47 + 16 * v1541;
                    if (v451 >= v438) {
                      uint64_t v452 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v452 = 0;
                    }
                    uint64_t v47 = v451 + 16 * v452;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v453 = v439 + 16 * v1549;
                  if (v453 >= v1548) {
                    uint64_t v454 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v454 = 0;
                  }
                  uint64_t v455 = v453 + 16 * v454;
                  uint64_t v456 = v438 + 16 * v454 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v455;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v438 = v456;
                    unint64_t v439 = v455;
                  }
                  _VF = __OFSUB__(v428--, 1);
                }
                while (!((v428 < 0) ^ _VF | (v428 == 0)));
              }
              else
              {
                unint64_t v1315 = v22;
                unint64_t v1316 = v1550;
                do
                {
                  unint64_t v1317 = (v1315 - v47) >> 4;
                  if (v1317 >= v1546) {
                    unint64_t v1317 = v1546;
                  }
                  if (v1317 < 2)
                  {
                    unint64_t i53 = v1317;
                  }
                  else
                  {
                    uint64_t v1318 = 0;
                    for (unint64_t i53 = v1317; i53 > 1; i53 -= 2)
                    {
                      v1320 = (int8x16_t *)((char *)v26 + v1318);
                      float32x4_t v1321 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1318)), v435), v436);
                      float32x4_t v1322 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1318)), v435), v436);
                      float32x4_t v1323 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1318 + 16)), v432), v433);
                      float32x4_t v1324 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1318)), v432), v433);
                      int8x16_t *v1320 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1324, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1321, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1324, v1324, v1321, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1321, v1324, 3), vmulq_laneq_f32(v1324, v1321, 3)), vmlsq_laneq_f32(v1321, v1321, v1324, 3))), (int8x16_t)v1324), (int8x16_t)v1321));
                      v1320[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1323, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1322, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1323, v1323, v1322, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1322, v1323, 3), vmulq_laneq_f32(v1323, v1322, 3)), vmlsq_laneq_f32(v1322, v1322, v1323, 3))), (int8x16_t)v1323), (int8x16_t)v1322));
                      v1318 += v437;
                    }
                    v47 += v1318;
                    float v26 = (float32x4_t *)((char *)v26 + v1318);
                  }
                  for (unint64_t i54 = i53 + v1546 - v1317; i54; --i54)
                  {
                    float32x4_t v1326 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v432), v433);
                    float32x4_t v1327 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v435), v436);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1326, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1327, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1326, v1326, v1327, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v1327, v1326, 3), vmulq_laneq_f32(v1326, v1327, 3)), vmlsq_laneq_f32(v1327, v1327, v1326, 3))), (int8x16_t)v1326), (int8x16_t)v1327));
                    unint64_t v1328 = v47 + 16 * v1541;
                    if (v1328 >= v1315) {
                      uint64_t v1329 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1329 = 0;
                    }
                    uint64_t v47 = v1328 + 16 * v1329;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1330 = v1316 + 16 * v1549;
                  if (v1330 >= v1548) {
                    uint64_t v1331 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1331 = 0;
                  }
                  uint64_t v1332 = v1330 + 16 * v1331;
                  uint64_t v1333 = v1315 + 16 * v1331 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1332;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1315 = v1333;
                    unint64_t v1316 = v1332;
                  }
                  _VF = __OFSUB__(v428--, 1);
                }
                while (!((v428 < 0) ^ _VF | (v428 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v428 = v1552;
          }
          while (1)
          {
            int v961 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1235;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v962 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1235;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v962 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1529) = LODWORD(a14);
              LODWORD(v1529) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAlightenPDA(v26->f32[0], a8, a9, a10, v962, a12, a13, a14, *(float *)v47, v1529, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1235:
              unint64_t v963 = v47 + 16 * v1541;
              if (v963 >= v22) {
                uint64_t v964 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v964 = 0;
              }
              uint64_t v47 = v963 + 16 * v964;
              v26 += v1541;
              --v961;
            }
            while (v961);
            v26 += v1547;
            unint64_t v965 = v1550;
            unint64_t v966 = v1550 + 16 * v1549;
            uint64_t v967 = -(uint64_t)(v1549 * v1542);
            if (v966 < v1548) {
              uint64_t v967 = 0;
            }
            uint64_t v968 = v966 + 16 * v967;
            uint64_t v969 = v22 + 16 * v967 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v969;
              unint64_t v965 = v968;
            }
            unint64_t v1550 = v965;
            if (v1548) {
              uint64_t v47 = v968;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v428) {
              goto LABEL_1335;
            }
          }
        case 18:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v457 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v458 = 0;
              }
              else {
                unsigned int v458 = -1;
              }
              v459.i64[0] = 0;
              v459.i32[2] = 0;
              v460.i64[0] = 0;
              v460.i32[2] = 0;
              v460.i32[3] = v458;
              int8x16_t v461 = vmvnq_s8(v460);
              int8x16_t v462 = vandq_s8((int8x16_t)vdupq_n_s32(v458), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v463 = 0;
              }
              else {
                unsigned int v463 = -1;
              }
              v459.i32[3] = v463;
              int8x16_t v464 = vmvnq_s8(v459);
              int8x16_t v465 = vandq_s8((int8x16_t)vdupq_n_s32(v463), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v466 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                __asm { FMOV            V4.4S, #1.0 }
                unint64_t v468 = v22;
                unint64_t v469 = v1550;
                do
                {
                  unint64_t v470 = (v468 - v47) >> 4;
                  if (v470 >= v1546) {
                    unint64_t v470 = v1546;
                  }
                  if (v470 < 2)
                  {
                    unint64_t i55 = v470;
                  }
                  else
                  {
                    uint64_t v471 = 0;
                    for (unint64_t i55 = v470; i55 > 1; i55 -= 2)
                    {
                      v473 = (int8x16_t *)((char *)v26 + v471);
                      float32x4_t v474 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v471), v464), v465);
                      float32x4_t v475 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v474, 3);
                      float32x4_t v476 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v471), v464), v465);
                      float32x4_t v477 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v476, 3);
                      int8x16_t v478 = (int8x16_t)vcgtzq_f32(v475);
                      float32x4_t v479 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v471), v461), v462);
                      float32x4_t v480 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v479, 3);
                      int8x16_t v481 = (int8x16_t)vcgtzq_f32(v477);
                      float32x4_t v482 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v471 + 16), v461), v462);
                      float32x4_t v483 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v482, 3);
                      int8x16_t v484 = (int8x16_t)vcgtzq_f32(v480);
                      float32x4_t v485 = vaddq_f32(vmlsq_laneq_f32(v476, v476, v479, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v480, v479), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v476, vmulq_f32(v479, v479), 3), vsubq_f32(v480, v479))));
                      float32x4_t v486 = vaddq_f32(v475, vmlsq_laneq_f32(v483, v475, v482, 3));
                      float32x4_t v487 = vaddq_f32(v477, vmlsq_laneq_f32(v480, v477, v479, 3));
                      int8x16_t v488 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v482, v482, v474, 3), vaddq_f32(vmlsq_laneq_f32(v474, v474, v482, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v483, v482), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v474, vmulq_f32(v482, v482), 3), vsubq_f32(v483, v482))))), v486);
                      v488.i32[3] = v486.i32[3];
                      int8x16_t v489 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v479, v479, v476, 3), v485), v487);
                      v489.i32[3] = v487.i32[3];
                      int8x16_t *v473 = vbslq_s8(v484, vbslq_s8(v481, v489, (int8x16_t)v479), (int8x16_t)v476);
                      v473[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v483), vbslq_s8(v478, v488, (int8x16_t)v482), (int8x16_t)v474);
                      v471 += v466;
                    }
                    v47 += v471;
                    float v26 = (float32x4_t *)((char *)v26 + v471);
                  }
                  for (unint64_t i56 = i55 + v1546 - v470; i56; --i56)
                  {
                    float32x4_t v491 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v461), v462);
                    float32x4_t v492 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v464), v465);
                    float32x4_t v493 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v491, 3);
                    float32x4_t v494 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v492, 3);
                    int8x16_t v495 = (int8x16_t)vcgtzq_f32(v494);
                    int8x16_t v496 = (int8x16_t)vcgtzq_f32(v493);
                    float32x4_t v497 = vaddq_f32(vmlsq_laneq_f32(v491, v491, v492, 3), vaddq_f32(vmlsq_laneq_f32(v492, v492, v491, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v493, v491), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v492, vmulq_f32(v491, v491), 3), vsubq_f32(v493, v491)))));
                    float32x4_t v498 = vaddq_f32(v494, vmlsq_laneq_f32(v493, v494, v491, 3));
                    int8x16_t v499 = (int8x16_t)vminnmq_f32(v497, v498);
                    v499.i32[3] = v498.i32[3];
                    *(int8x16_t *)float v26 = vbslq_s8(v496, vbslq_s8(v495, v499, (int8x16_t)v491), (int8x16_t)v492);
                    unint64_t v500 = v47 + 16 * v1541;
                    if (v500 >= v468) {
                      uint64_t v501 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v501 = 0;
                    }
                    uint64_t v47 = v500 + 16 * v501;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v502 = v469 + 16 * v1549;
                  if (v502 >= v1548) {
                    uint64_t v503 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v503 = 0;
                  }
                  uint64_t v504 = v502 + 16 * v503;
                  uint64_t v505 = v468 + 16 * v503 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v504;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v468 = v505;
                    unint64_t v469 = v504;
                  }
                  _VF = __OFSUB__(v457--, 1);
                }
                while (!((v457 < 0) ^ _VF | (v457 == 0)));
              }
              else
              {
                __asm { FMOV            V4.4S, #1.0 }
                unint64_t v1335 = v22;
                unint64_t v1336 = v1550;
                do
                {
                  unint64_t v1337 = (v1335 - v47) >> 4;
                  if (v1337 >= v1546) {
                    unint64_t v1337 = v1546;
                  }
                  if (v1337 < 2)
                  {
                    unint64_t i57 = v1337;
                  }
                  else
                  {
                    uint64_t v1338 = 0;
                    for (unint64_t i57 = v1337; i57 > 1; i57 -= 2)
                    {
                      v1340 = (int8x16_t *)((char *)v26 + v1338);
                      float32x4_t v1341 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1338)), v464), v465);
                      float32x4_t v1342 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1338)), v464), v465);
                      float32x4_t v1343 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1341, 3);
                      float32x4_t v1344 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1342, 3);
                      float32x4_t v1345 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1338 + 16)), v461), v462);
                      float32x4_t v1346 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1345, 3);
                      float32x4_t v1347 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1338)), v461), v462);
                      float32x4_t v1348 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1347, 3);
                      int8x16_t v1349 = (int8x16_t)vcgtzq_f32(v1346);
                      int8x16_t v1350 = (int8x16_t)vcgtzq_f32(v1348);
                      float32x4_t v1351 = vaddq_f32(vmlsq_laneq_f32(v1345, v1345, v1342, 3), vaddq_f32(vmlsq_laneq_f32(v1342, v1342, v1345, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1346, v1345), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1342, vmulq_f32(v1345, v1345), 3), vsubq_f32(v1346, v1345)))));
                      float32x4_t v1352 = vaddq_f32(vmlsq_laneq_f32(v1347, v1347, v1341, 3), vaddq_f32(vmlsq_laneq_f32(v1341, v1341, v1347, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1348, v1347), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1341, vmulq_f32(v1347, v1347), 3), vsubq_f32(v1348, v1347)))));
                      float32x4_t v1353 = vaddq_f32(v1344, vmlsq_laneq_f32(v1346, v1344, v1345, 3));
                      float32x4_t v1354 = vaddq_f32(v1343, vmlsq_laneq_f32(v1348, v1343, v1347, 3));
                      int8x16_t v1355 = (int8x16_t)vminnmq_f32(v1352, v1354);
                      int8x16_t v1356 = (int8x16_t)vminnmq_f32(v1351, v1353);
                      v1355.i32[3] = v1354.i32[3];
                      v1356.i32[3] = v1353.i32[3];
                      int8x16_t *v1340 = vrev32q_s8(vbslq_s8(v1350, vbslq_s8((int8x16_t)vcgtzq_f32(v1343), v1355, (int8x16_t)v1347), (int8x16_t)v1341));
                      v1340[1] = vrev32q_s8(vbslq_s8(v1349, vbslq_s8((int8x16_t)vcgtzq_f32(v1344), v1356, (int8x16_t)v1345), (int8x16_t)v1342));
                      v1338 += v466;
                    }
                    v47 += v1338;
                    float v26 = (float32x4_t *)((char *)v26 + v1338);
                  }
                  for (unint64_t i58 = i57 + v1546 - v1337; i58; --i58)
                  {
                    float32x4_t v1358 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v461), v462);
                    float32x4_t v1359 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v464), v465);
                    float32x4_t v1360 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1358, 3);
                    float32x4_t v1361 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1359, 3);
                    int8x16_t v1362 = (int8x16_t)vcgtzq_f32(v1361);
                    int8x16_t v1363 = (int8x16_t)vcgtzq_f32(v1360);
                    float32x4_t v1364 = vaddq_f32(vmlsq_laneq_f32(v1358, v1358, v1359, 3), vaddq_f32(vmlsq_laneq_f32(v1359, v1359, v1358, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v1360, v1358), _Q4, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v1359, vmulq_f32(v1358, v1358), 3), vsubq_f32(v1360, v1358)))));
                    float32x4_t v1365 = vaddq_f32(v1361, vmlsq_laneq_f32(v1360, v1361, v1358, 3));
                    int8x16_t v1366 = (int8x16_t)vminnmq_f32(v1364, v1365);
                    v1366.i32[3] = v1365.i32[3];
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8(v1363, vbslq_s8(v1362, v1366, (int8x16_t)v1358), (int8x16_t)v1359));
                    unint64_t v1367 = v47 + 16 * v1541;
                    if (v1367 >= v1335) {
                      uint64_t v1368 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1368 = 0;
                    }
                    uint64_t v47 = v1367 + 16 * v1368;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1369 = v1336 + 16 * v1549;
                  if (v1369 >= v1548) {
                    uint64_t v1370 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1370 = 0;
                  }
                  uint64_t v1371 = v1369 + 16 * v1370;
                  uint64_t v1372 = v1335 + 16 * v1370 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1371;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1335 = v1372;
                    unint64_t v1336 = v1371;
                  }
                  _VF = __OFSUB__(v457--, 1);
                }
                while (!((v457 < 0) ^ _VF | (v457 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v457 = v1552;
          }
          while (1)
          {
            int v970 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1257;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v971 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1257;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v971 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1530) = LODWORD(a14);
              LODWORD(v1530) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAcolordodgePDA(v26->f32[0], a8, a9, a10, v971, a12, a13, a14, *(float *)v47, v1530, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1257:
              unint64_t v972 = v47 + 16 * v1541;
              if (v972 >= v22) {
                uint64_t v973 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v973 = 0;
              }
              uint64_t v47 = v972 + 16 * v973;
              v26 += v1541;
              --v970;
            }
            while (v970);
            v26 += v1547;
            unint64_t v974 = v1550;
            unint64_t v975 = v1550 + 16 * v1549;
            uint64_t v976 = -(uint64_t)(v1549 * v1542);
            if (v975 < v1548) {
              uint64_t v976 = 0;
            }
            uint64_t v977 = v975 + 16 * v976;
            uint64_t v978 = v22 + 16 * v976 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v978;
              unint64_t v974 = v977;
            }
            unint64_t v1550 = v974;
            if (v1548) {
              uint64_t v47 = v977;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v457) {
              goto LABEL_1335;
            }
          }
        case 19:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v506 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v507 = 0;
              }
              else {
                unsigned int v507 = -1;
              }
              v508.i64[0] = 0;
              v508.i32[2] = 0;
              v508.i32[3] = v507;
              int8x16_t v509 = vmvnq_s8(v508);
              int8x16_t v510 = vandq_s8((int8x16_t)vdupq_n_s32(v507), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v511 = 0;
              }
              else {
                unsigned int v511 = -1;
              }
              v512.i64[0] = 0;
              v512.i32[2] = 0;
              v512.i32[3] = v511;
              int8x16_t v513 = vmvnq_s8(v512);
              int8x16_t v514 = vandq_s8((int8x16_t)vdupq_n_s32(v511), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v515 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v516 = v22;
                unint64_t v517 = v1550;
                do
                {
                  unint64_t v518 = (v516 - v47) >> 4;
                  if (v518 >= v1546) {
                    unint64_t v518 = v1546;
                  }
                  if (v518 < 2)
                  {
                    unint64_t i59 = v518;
                  }
                  else
                  {
                    uint64_t v519 = 0;
                    for (unint64_t i59 = v518; i59 > 1; i59 -= 2)
                    {
                      v521 = (int8x16_t *)((char *)v26 + v519);
                      float32x4_t v522 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v519), v513), v514);
                      float32x4_t v523 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v519), v513), v514);
                      float32x4_t v524 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v519), v509), v510);
                      float32x4_t v525 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v524, 3);
                      float32x4_t v526 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v519 + 16), v509), v510);
                      float32x4_t v527 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v526, 3);
                      int8x16_t v528 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v522, 3));
                      int8x16_t v529 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v523, 3));
                      float32x4_t v530 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v526, v526), 3), v526);
                      float32x4_t v531 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v524, v524), 3), v524);
                      int8x16_t *v521 = vbslq_s8((int8x16_t)vcgtzq_f32(v525), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v524, v524, v522, 3), vaddq_f32(vmulq_laneq_f32(v525, v522, 3), vmlsq_laneq_f32(v522, v522, v524, 3))), v531, v522, 3), v522, v531), (float32x4_t)0), vbicq_s8(v528, (int8x16_t)vceqzq_f32(v524))), vbicq_s8((int8x16_t)v524, v528)),
                                (int8x16_t)v522);
                      v521[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v527), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v526, v526, v523, 3), vaddq_f32(vmulq_laneq_f32(v527, v523, 3), vmlsq_laneq_f32(v523, v523, v526, 3))), v530, v523, 3), v523, v530), (float32x4_t)0), vbicq_s8(v529, (int8x16_t)vceqzq_f32(v526))), vbicq_s8((int8x16_t)v526, v529)),
                                  (int8x16_t)v523);
                      v519 += v515;
                    }
                    v47 += v519;
                    float v26 = (float32x4_t *)((char *)v26 + v519);
                  }
                  for (unint64_t i60 = i59 + v1546 - v518; i60; --i60)
                  {
                    float32x4_t v533 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v509), v510);
                    float32x4_t v534 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v513), v514);
                    float32x4_t v535 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v533, 3);
                    int8x16_t v536 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v534, 3));
                    float32x4_t v537 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v533, v533), 3), v533);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v535), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v533, v533, v534, 3), vaddq_f32(vmlsq_laneq_f32(v534, v534, v533, 3), vmulq_laneq_f32(v535, v534, 3))), v537, v534, 3), v534, v537), (float32x4_t)0), vbicq_s8(v536, (int8x16_t)vceqzq_f32(v533))), vbicq_s8((int8x16_t)v533, v536)),
                                          (int8x16_t)v534);
                    unint64_t v538 = v47 + 16 * v1541;
                    if (v538 >= v516) {
                      uint64_t v539 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v539 = 0;
                    }
                    uint64_t v47 = v538 + 16 * v539;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v540 = v517 + 16 * v1549;
                  if (v540 >= v1548) {
                    uint64_t v541 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v541 = 0;
                  }
                  uint64_t v542 = v540 + 16 * v541;
                  uint64_t v543 = v516 + 16 * v541 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v542;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v516 = v543;
                    unint64_t v517 = v542;
                  }
                  _VF = __OFSUB__(v506--, 1);
                }
                while (!((v506 < 0) ^ _VF | (v506 == 0)));
              }
              else
              {
                unint64_t v1373 = v22;
                unint64_t v1374 = v1550;
                do
                {
                  unint64_t v1375 = (v1373 - v47) >> 4;
                  if (v1375 >= v1546) {
                    unint64_t v1375 = v1546;
                  }
                  if (v1375 < 2)
                  {
                    unint64_t i61 = v1375;
                  }
                  else
                  {
                    uint64_t v1376 = 0;
                    for (unint64_t i61 = v1375; i61 > 1; i61 -= 2)
                    {
                      v1378 = (int8x16_t *)((char *)v26 + v1376);
                      float32x4_t v1379 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1376)), v513), v514);
                      float32x4_t v1380 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1376)), v513), v514);
                      float32x4_t v1381 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1376 + 16)), v509), v510);
                      float32x4_t v1382 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1381, 3);
                      int8x16_t v1383 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1379, 3));
                      int8x16_t v1384 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1380, 3));
                      float32x4_t v1385 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1376)), v509), v510);
                      float32x4_t v1386 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1385, 3);
                      float32x4_t v1387 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1385, v1385), 3), v1385);
                      float32x4_t v1388 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1381, v1381), 3), v1381);
                      int8x16_t *v1378 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1386), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1385, v1385, v1380, 3), vaddq_f32(vmulq_laneq_f32(v1386, v1380, 3), vmlsq_laneq_f32(v1380, v1380, v1385, 3))), v1387, v1380, 3), v1380, v1387), (float32x4_t)0), vbicq_s8(v1384, (int8x16_t)vceqzq_f32(v1385))),
                                     vbicq_s8((int8x16_t)v1385, v1384)),
                                   (int8x16_t)v1380));
                      v1378[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1382), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1381, v1381, v1379, 3), vaddq_f32(vmulq_laneq_f32(v1382, v1379, 3), vmlsq_laneq_f32(v1379, v1379, v1381, 3))), v1388, v1379, 3), v1379, v1388), (float32x4_t)0), vbicq_s8(v1383, (int8x16_t)vceqzq_f32(v1381))),
                                       vbicq_s8((int8x16_t)v1381, v1383)),
                                     (int8x16_t)v1379));
                      v1376 += v515;
                    }
                    v47 += v1376;
                    float v26 = (float32x4_t *)((char *)v26 + v1376);
                  }
                  for (unint64_t i62 = i61 + v1546 - v1375; i62; --i62)
                  {
                    float32x4_t v1390 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v509), v510);
                    float32x4_t v1391 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v513), v514);
                    float32x4_t v1392 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1390, 3);
                    int8x16_t v1393 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1391, 3));
                    float32x4_t v1394 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v1390, v1390), 3), v1390);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1392), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v1390, v1390, v1391, 3), vaddq_f32(vmlsq_laneq_f32(v1391, v1391, v1390, 3), vmulq_laneq_f32(v1392, v1391, 3))), v1394, v1391, 3), v1391, v1394), (float32x4_t)0), vbicq_s8(v1393, (int8x16_t)vceqzq_f32(v1390))),
                                              vbicq_s8((int8x16_t)v1390, v1393)),
                                            (int8x16_t)v1391));
                    unint64_t v1395 = v47 + 16 * v1541;
                    if (v1395 >= v1373) {
                      uint64_t v1396 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1396 = 0;
                    }
                    uint64_t v47 = v1395 + 16 * v1396;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1397 = v1374 + 16 * v1549;
                  if (v1397 >= v1548) {
                    uint64_t v1398 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1398 = 0;
                  }
                  uint64_t v1399 = v1397 + 16 * v1398;
                  uint64_t v1400 = v1373 + 16 * v1398 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1399;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1373 = v1400;
                    unint64_t v1374 = v1399;
                  }
                  _VF = __OFSUB__(v506--, 1);
                }
                while (!((v506 < 0) ^ _VF | (v506 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v506 = v1552;
          }
          while (1)
          {
            int v979 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1279;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v980 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1279;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v980 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1531) = LODWORD(a14);
              LODWORD(v1531) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAcolorburnPDA(v26->f32[0], a8, a9, a10, v980, a12, a13, a14, *(float *)v47, v1531, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1279:
              unint64_t v981 = v47 + 16 * v1541;
              if (v981 >= v22) {
                uint64_t v982 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v982 = 0;
              }
              uint64_t v47 = v981 + 16 * v982;
              v26 += v1541;
              --v979;
            }
            while (v979);
            v26 += v1547;
            unint64_t v983 = v1550;
            unint64_t v984 = v1550 + 16 * v1549;
            uint64_t v985 = -(uint64_t)(v1549 * v1542);
            if (v984 < v1548) {
              uint64_t v985 = 0;
            }
            uint64_t v986 = v984 + 16 * v985;
            uint64_t v987 = v22 + 16 * v985 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v987;
              unint64_t v983 = v986;
            }
            unint64_t v1550 = v983;
            if (v1548) {
              uint64_t v47 = v986;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v506) {
              goto LABEL_1335;
            }
          }
        case 20:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v544 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v545 = 0;
              }
              else {
                unsigned int v545 = -1;
              }
              v546.i64[0] = 0;
              v546.i32[2] = 0;
              v547.i64[0] = 0;
              v547.i32[2] = 0;
              v547.i32[3] = v545;
              int8x16_t v548 = vmvnq_s8(v547);
              int8x16_t v549 = vandq_s8((int8x16_t)vdupq_n_s32(v545), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v550 = 0;
              }
              else {
                unsigned int v550 = -1;
              }
              v546.i32[3] = v550;
              int8x16_t v551 = vmvnq_s8(v546);
              int8x16_t v552 = vandq_s8((int8x16_t)vdupq_n_s32(v550), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v553 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v554 = v22;
                unint64_t v555 = v1550;
                do
                {
                  unint64_t v556 = (v554 - v47) >> 4;
                  if (v556 >= v1546) {
                    unint64_t v556 = v1546;
                  }
                  if (v556 < 2)
                  {
                    unint64_t i63 = v556;
                  }
                  else
                  {
                    uint64_t v557 = 0;
                    for (unint64_t i63 = v556; i63 > 1; i63 -= 2)
                    {
                      v559 = (int8x16_t *)((char *)v26 + v557);
                      float32x4_t v560 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v557), v551), v552);
                      float32x4_t v561 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v557), v551), v552);
                      float32x4_t v562 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v560, 3);
                      float32x4_t v563 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v561, 3);
                      float32x4_t v564 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v557), v548), v549);
                      float32x4_t v565 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v557 + 16), v548), v549);
                      int8x16_t v566 = (int8x16_t)vcgtzq_f32(v562);
                      int8x16_t v567 = (int8x16_t)vcgtzq_f32(v563);
                      int8x16_t v568 = (int8x16_t)vceqzq_f32(v562);
                      int8x16_t v569 = (int8x16_t)vceqzq_f32(v563);
                      float32x4_t v570 = vdivq_f32(v560, v562);
                      float32x4_t v571 = vaddq_f32(v565, v565);
                      float32x4_t v572 = vdivq_f32(v561, v563);
                      float32x4_t v573 = vaddq_f32(v564, v564);
                      float32x4_t v574 = vmlaq_laneq_f32(vmlsq_f32(v571, v570, v571), v570, v565, 3);
                      float32x4_t v575 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v573, v572, v573), v572, v564, 3), v561);
                      float32x4_t v576 = vmulq_f32(v574, v560);
                      int8x16_t *v559 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v564, 3)), vbslq_s8(v567, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v564, v564, v561, 3), vaddq_f32(vmlsq_laneq_f32(v561, v561, v564, 3), (float32x4_t)vandq_s8((int8x16_t)v575, vbicq_s8((int8x16_t)vcgezq_f32(v575), v569)))), (int8x16_t)v564), (int8x16_t)v561);
                      v559[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v565, 3)), vbslq_s8(v566, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v565, v565, v560, 3), vaddq_f32(vmlsq_laneq_f32(v560, v560, v565, 3), (float32x4_t)vandq_s8((int8x16_t)v576, vbicq_s8((int8x16_t)vcgezq_f32(v576), v568)))), (int8x16_t)v565), (int8x16_t)v560);
                      v557 += v553;
                    }
                    v47 += v557;
                    float v26 = (float32x4_t *)((char *)v26 + v557);
                  }
                  for (unint64_t i64 = i63 + v1546 - v556; i64; --i64)
                  {
                    float32x4_t v578 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v548), v549);
                    float32x4_t v579 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v551), v552);
                    float32x4_t v580 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v579, 3);
                    int8x16_t v581 = (int8x16_t)vcgtzq_f32(v580);
                    int8x16_t v582 = (int8x16_t)vceqzq_f32(v580);
                    float32x4_t v583 = vdivq_f32(v579, v580);
                    float32x4_t v584 = vaddq_f32(v578, v578);
                    float32x4_t v585 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v584, v583, v584), v583, v578, 3), v579);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v578, 3)), vbslq_s8(v581, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v578, v578, v579, 3), vaddq_f32(vmlsq_laneq_f32(v579, v579, v578, 3), (float32x4_t)vandq_s8((int8x16_t)v585, vbicq_s8((int8x16_t)vcgezq_f32(v585), v582)))), (int8x16_t)v578), (int8x16_t)v579);
                    unint64_t v586 = v47 + 16 * v1541;
                    if (v586 >= v554) {
                      uint64_t v587 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v587 = 0;
                    }
                    uint64_t v47 = v586 + 16 * v587;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v588 = v555 + 16 * v1549;
                  if (v588 >= v1548) {
                    uint64_t v589 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v589 = 0;
                  }
                  uint64_t v590 = v588 + 16 * v589;
                  uint64_t v591 = v554 + 16 * v589 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v590;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v554 = v591;
                    unint64_t v555 = v590;
                  }
                  _VF = __OFSUB__(v544--, 1);
                }
                while (!((v544 < 0) ^ _VF | (v544 == 0)));
              }
              else
              {
                unint64_t v1401 = v22;
                unint64_t v1402 = v1550;
                do
                {
                  unint64_t v1403 = (v1401 - v47) >> 4;
                  if (v1403 >= v1546) {
                    unint64_t v1403 = v1546;
                  }
                  if (v1403 < 2)
                  {
                    unint64_t i65 = v1403;
                  }
                  else
                  {
                    uint64_t v1404 = 0;
                    for (unint64_t i65 = v1403; i65 > 1; i65 -= 2)
                    {
                      v1406 = (int8x16_t *)((char *)v26 + v1404);
                      float32x4_t v1407 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1404)), v551), v552);
                      float32x4_t v1408 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1407, 3);
                      float32x4_t v1409 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1404)), v551), v552);
                      float32x4_t v1410 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1409, 3);
                      float32x4_t v1411 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1404 + 16)), v548), v549);
                      int8x16_t v1412 = (int8x16_t)vcgtzq_f32(v1408);
                      int8x16_t v1413 = (int8x16_t)vcgtzq_f32(v1410);
                      float32x4_t v1414 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1404)), v548), v549);
                      int8x16_t v1415 = (int8x16_t)vceqzq_f32(v1408);
                      int8x16_t v1416 = (int8x16_t)vceqzq_f32(v1410);
                      float32x4_t v1417 = vdivq_f32(v1409, v1410);
                      float32x4_t v1418 = vaddq_f32(v1411, v1411);
                      float32x4_t v1419 = vdivq_f32(v1407, v1408);
                      float32x4_t v1420 = vaddq_f32(v1414, v1414);
                      float32x4_t v1421 = vmlaq_laneq_f32(vmlsq_f32(v1420, v1419, v1420), v1419, v1414, 3);
                      float32x4_t v1422 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v1418, v1417, v1418), v1417, v1411, 3), v1409);
                      float32x4_t v1423 = vmulq_f32(v1421, v1407);
                      int8x16_t *v1406 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1414, 3)), vbslq_s8(v1412, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1414, v1414, v1407, 3), vaddq_f32(vmlsq_laneq_f32(v1407, v1407, v1414, 3), (float32x4_t)vandq_s8((int8x16_t)v1423, vbicq_s8((int8x16_t)vcgezq_f32(v1423), v1415)))), (int8x16_t)v1414), (int8x16_t)v1407));
                      v1406[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1411, 3)), vbslq_s8(v1413, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1411, v1411, v1409, 3), vaddq_f32(vmlsq_laneq_f32(v1409, v1409, v1411, 3), (float32x4_t)vandq_s8((int8x16_t)v1422, vbicq_s8((int8x16_t)vcgezq_f32(v1422), v1416)))), (int8x16_t)v1411), (int8x16_t)v1409));
                      v1404 += v553;
                    }
                    v47 += v1404;
                    float v26 = (float32x4_t *)((char *)v26 + v1404);
                  }
                  for (unint64_t i66 = i65 + v1546 - v1403; i66; --i66)
                  {
                    float32x4_t v1425 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v548), v549);
                    float32x4_t v1426 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v551), v552);
                    float32x4_t v1427 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1426, 3);
                    int8x16_t v1428 = (int8x16_t)vcgtzq_f32(v1427);
                    int8x16_t v1429 = (int8x16_t)vceqzq_f32(v1427);
                    float32x4_t v1430 = vdivq_f32(v1426, v1427);
                    float32x4_t v1431 = vaddq_f32(v1425, v1425);
                    float32x4_t v1432 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v1431, v1430, v1431), v1430, v1425, 3), v1426);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1425, 3)), vbslq_s8(v1428, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v1425, v1425, v1426, 3), vaddq_f32(vmlsq_laneq_f32(v1426, v1426, v1425, 3), (float32x4_t)vandq_s8((int8x16_t)v1432, vbicq_s8((int8x16_t)vcgezq_f32(v1432), v1429)))), (int8x16_t)v1425), (int8x16_t)v1426));
                    unint64_t v1433 = v47 + 16 * v1541;
                    if (v1433 >= v1401) {
                      uint64_t v1434 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1434 = 0;
                    }
                    uint64_t v47 = v1433 + 16 * v1434;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1435 = v1402 + 16 * v1549;
                  if (v1435 >= v1548) {
                    uint64_t v1436 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1436 = 0;
                  }
                  uint64_t v1437 = v1435 + 16 * v1436;
                  uint64_t v1438 = v1401 + 16 * v1436 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1437;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1401 = v1438;
                    unint64_t v1402 = v1437;
                  }
                  _VF = __OFSUB__(v544--, 1);
                }
                while (!((v544 < 0) ^ _VF | (v544 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v544 = v1552;
          }
          while (1)
          {
            int v988 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1301;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                LODWORD(a11) = LODWORD(a10);
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1301;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                LODWORD(a11) = 1.0;
              }
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              DWORD2(v1525) = LODWORD(a14);
              *(void *)&long long v1525 = *(void *)(v47 + 4);
              v26->f32[0] = PDAsoftlightPDA(v26->f32[0], v26->f32[1], a9, *(int32x2_t *)&a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, v27, v28, *(float *)v47, v1525, *(uint64_t *)((char *)&v1525 + 4),
                              *(float *)&a12);
              v26->i32[1] = v989;
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1301:
              unint64_t v990 = v47 + 16 * v1541;
              if (v990 >= v22) {
                uint64_t v991 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v991 = 0;
              }
              uint64_t v47 = v990 + 16 * v991;
              v26 += v1541;
              --v988;
            }
            while (v988);
            v26 += v1547;
            unint64_t v992 = v1550;
            unint64_t v993 = v1550 + 16 * v1549;
            uint64_t v994 = -(uint64_t)(v1549 * v1542);
            if (v993 < v1548) {
              uint64_t v994 = 0;
            }
            uint64_t v995 = v993 + 16 * v994;
            uint64_t v996 = v22 + 16 * v994 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v996;
              unint64_t v992 = v995;
            }
            unint64_t v1550 = v992;
            if (v1548) {
              uint64_t v47 = v995;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v544) {
              goto LABEL_1335;
            }
          }
        case 21:
          unint64_t v1540 = v48;
          if (v45)
          {
            int v592 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v593 = 0;
              }
              else {
                unsigned int v593 = -1;
              }
              v594.i64[0] = 0;
              v594.i32[2] = 0;
              v595.i64[0] = 0;
              v595.i32[2] = 0;
              v595.i32[3] = v593;
              int8x16_t v596 = vmvnq_s8(v595);
              int8x16_t v597 = vandq_s8((int8x16_t)vdupq_n_s32(v593), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v598 = 0;
              }
              else {
                unsigned int v598 = -1;
              }
              v594.i32[3] = v598;
              int8x16_t v599 = vmvnq_s8(v594);
              int8x16_t v600 = vandq_s8((int8x16_t)vdupq_n_s32(v598), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v601 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                v602.i64[0] = 0x3F0000003F000000;
                v602.i64[1] = 0x3F0000003F000000;
                v603.i64[0] = 0x8000000080000000;
                v603.i64[1] = 0x8000000080000000;
                unint64_t v604 = v22;
                unint64_t v605 = v1550;
                do
                {
                  unint64_t v606 = (v604 - v47) >> 4;
                  if (v606 >= v1546) {
                    unint64_t v606 = v1546;
                  }
                  if (v606 < 2)
                  {
                    unint64_t i67 = v606;
                  }
                  else
                  {
                    uint64_t v607 = 0;
                    for (unint64_t i67 = v606; i67 > 1; i67 -= 2)
                    {
                      v609 = (int8x16_t *)((char *)v26 + v607);
                      float32x4_t v610 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v607), v596), v597);
                      float32x4_t v611 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v607 + 16), v596), v597);
                      float32x4_t v612 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v607), v599), v600);
                      float32x4_t v613 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v611, 3);
                      float32x4_t v614 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v610, 3);
                      float32x4_t v615 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v607), v599), v600);
                      float32x4_t v616 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v615, 3);
                      float32x4_t v617 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v612, 3);
                      int8x16_t v618 = (int8x16_t)vcgtq_f32(v610, vmulq_laneq_f32(v602, v610, 3));
                      int8x16_t v619 = (int8x16_t)vcgtq_f32(v611, vmulq_laneq_f32(v602, v611, 3));
                      int8x16_t v620 = vbicq_s8(v603, v619);
                      int8x16_t v621 = vbicq_s8(v603, v618);
                      int8x16_t *v609 = vbslq_s8((int8x16_t)vcgtzq_f32(v614), vbslq_s8((int8x16_t)vcgtzq_f32(v616), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v615, (float32x4_t)veorq_s8(v621, (int8x16_t)vsubq_f32(v614, v610)), v615), vmlaq_f32(v610, (float32x4_t)veorq_s8(v621, (int8x16_t)vsubq_f32(v616, v615)), v610)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v614, v615, 3), v618)), (int8x16_t)v610), (int8x16_t)v615);
                      v609[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v613), vbslq_s8((int8x16_t)vcgtzq_f32(v617), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v612, (float32x4_t)veorq_s8(v620, (int8x16_t)vsubq_f32(v613, v611)), v612), vmlaq_f32(v611, (float32x4_t)veorq_s8(v620, (int8x16_t)vsubq_f32(v617, v612)), v611)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v613, v612, 3), v619)), (int8x16_t)v611), (int8x16_t)v612);
                      v607 += v601;
                    }
                    v47 += v607;
                    float v26 = (float32x4_t *)((char *)v26 + v607);
                  }
                  for (unint64_t i68 = i67 + v1546 - v606; i68; --i68)
                  {
                    float32x4_t v623 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v596), v597);
                    float32x4_t v624 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v599), v600);
                    float32x4_t v625 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v623, 3);
                    float32x4_t v626 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v624, 3);
                    int8x16_t v627 = (int8x16_t)vcgtq_f32(v623, vmulq_laneq_f32(v602, v623, 3));
                    int8x16_t v628 = vbicq_s8(v603, v627);
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v625), vbslq_s8((int8x16_t)vcgtzq_f32(v626), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v624, (float32x4_t)veorq_s8(v628, (int8x16_t)vsubq_f32(v625, v623)), v624), vmlaq_f32(v623, (float32x4_t)veorq_s8(v628, (int8x16_t)vsubq_f32(v626, v624)), v623)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v625, v624, 3),
                                                                        v627)),
                                            (int8x16_t)v623),
                                          (int8x16_t)v624);
                    unint64_t v629 = v47 + 16 * v1541;
                    if (v629 >= v604) {
                      uint64_t v630 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v630 = 0;
                    }
                    uint64_t v47 = v629 + 16 * v630;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v631 = v605 + 16 * v1549;
                  if (v631 >= v1548) {
                    uint64_t v632 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v632 = 0;
                  }
                  uint64_t v633 = v631 + 16 * v632;
                  uint64_t v634 = v604 + 16 * v632 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v633;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v604 = v634;
                    unint64_t v605 = v633;
                  }
                  _VF = __OFSUB__(v592--, 1);
                }
                while (!((v592 < 0) ^ _VF | (v592 == 0)));
              }
              else
              {
                v1439.i64[0] = 0x3F0000003F000000;
                v1439.i64[1] = 0x3F0000003F000000;
                v1440.i64[0] = 0x8000000080000000;
                v1440.i64[1] = 0x8000000080000000;
                unint64_t v1441 = v22;
                unint64_t v1442 = v1550;
                do
                {
                  unint64_t v1443 = (v1441 - v47) >> 4;
                  if (v1443 >= v1546) {
                    unint64_t v1443 = v1546;
                  }
                  if (v1443 < 2)
                  {
                    unint64_t i69 = v1443;
                  }
                  else
                  {
                    uint64_t v1444 = 0;
                    for (unint64_t i69 = v1443; i69 > 1; i69 -= 2)
                    {
                      v1446 = (int8x16_t *)((char *)v26 + v1444);
                      float32x4_t v1447 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1444 + 16)), v596), v597);
                      float32x4_t v1448 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1444)), v596), v597);
                      float32x4_t v1449 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1444)), v599), v600);
                      float32x4_t v1450 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1448, 3);
                      float32x4_t v1451 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1447, 3);
                      float32x4_t v1452 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1449, 3);
                      float32x4_t v1453 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1444)), v599), v600);
                      float32x4_t v1454 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1453, 3);
                      int8x16_t v1455 = (int8x16_t)vcgtq_f32(v1447, vmulq_laneq_f32(v1439, v1447, 3));
                      int8x16_t v1456 = (int8x16_t)vcgtq_f32(v1448, vmulq_laneq_f32(v1439, v1448, 3));
                      int8x16_t v1457 = vbicq_s8(v1440, v1456);
                      int8x16_t v1458 = vbicq_s8(v1440, v1455);
                      int8x16_t *v1446 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1450), vbslq_s8((int8x16_t)vcgtzq_f32(v1454), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1453, (float32x4_t)veorq_s8(v1457, (int8x16_t)vsubq_f32(v1450, v1448)), v1453), vmlaq_f32(v1448, (float32x4_t)veorq_s8(v1457, (int8x16_t)vsubq_f32(v1454, v1453)), v1448)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v1450, v1453, 3), v1456)), (int8x16_t)v1448), (int8x16_t)v1453));
                      v1446[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1451), vbslq_s8((int8x16_t)vcgtzq_f32(v1452), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1449, (float32x4_t)veorq_s8(v1458, (int8x16_t)vsubq_f32(v1451, v1447)), v1449), vmlaq_f32(v1447, (float32x4_t)veorq_s8(v1458, (int8x16_t)vsubq_f32(v1452, v1449)), v1447)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v1451, v1449, 3), v1455)), (int8x16_t)v1447), (int8x16_t)v1449));
                      v1444 += v601;
                    }
                    v47 += v1444;
                    float v26 = (float32x4_t *)((char *)v26 + v1444);
                  }
                  for (unint64_t i70 = i69 + v1546 - v1443; i70; --i70)
                  {
                    float32x4_t v1460 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v596), v597);
                    float32x4_t v1461 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1460, 3);
                    float32x4_t v1462 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v599), v600);
                    float32x4_t v1463 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1462, 3);
                    int8x16_t v1464 = (int8x16_t)vcgtq_f32(v1460, vmulq_laneq_f32(v1439, v1460, 3));
                    int8x16_t v1465 = vbicq_s8(v1440, v1464);
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1461), vbslq_s8((int8x16_t)vcgtzq_f32(v1463), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v1462, (float32x4_t)veorq_s8(v1465, (int8x16_t)vsubq_f32(v1461, v1460)), v1462), vmlaq_f32(v1460, (float32x4_t)veorq_s8(v1465, (int8x16_t)vsubq_f32(v1463, v1462)), v1460)), (float32x4_t)vandq_s8(
                                                                          (int8x16_t)vmulq_laneq_f32(v1461, v1462, 3),
                                                                          v1464)),
                                              (int8x16_t)v1460),
                                            (int8x16_t)v1462));
                    unint64_t v1466 = v47 + 16 * v1541;
                    if (v1466 >= v1441) {
                      uint64_t v1467 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1467 = 0;
                    }
                    uint64_t v47 = v1466 + 16 * v1467;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1468 = v1442 + 16 * v1549;
                  if (v1468 >= v1548) {
                    uint64_t v1469 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1469 = 0;
                  }
                  uint64_t v1470 = v1468 + 16 * v1469;
                  uint64_t v1471 = v1441 + 16 * v1469 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1470;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1441 = v1471;
                    unint64_t v1442 = v1470;
                  }
                  _VF = __OFSUB__(v592--, 1);
                }
                while (!((v592 < 0) ^ _VF | (v592 == 0)));
              }
              goto LABEL_1336;
            }
            uint64_t v1537 = v32;
          }
          else
          {
            uint64_t v1537 = v32;
            int v592 = v1552;
          }
          while (1)
          {
            int v997 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_1323;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v998 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_1323;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v998 = 1.0;
              }
              LODWORD(a8) = v26->i32[1];
              LODWORD(a9) = v26->i32[2];
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              HIDWORD(v1532) = LODWORD(a14);
              LODWORD(v1532) = HIDWORD(*(void *)(v47 + 4));
              v26->f32[0] = PDAhardlightPDA(v26->f32[0], a8, a9, a10, v998, a12, a13, a14, *(float *)v47, v1532, *(float *)&a12);
              v26->i32[1] = LODWORD(a8);
              v26->i32[2] = LODWORD(a9);
              v26->i32[3] = LODWORD(a10);
LABEL_1323:
              unint64_t v999 = v47 + 16 * v1541;
              if (v999 >= v22) {
                uint64_t v1000 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v1000 = 0;
              }
              uint64_t v47 = v999 + 16 * v1000;
              v26 += v1541;
              --v997;
            }
            while (v997);
            v26 += v1547;
            unint64_t v1001 = v1550;
            unint64_t v1002 = v1550 + 16 * v1549;
            uint64_t v1003 = -(uint64_t)(v1549 * v1542);
            if (v1002 < v1548) {
              uint64_t v1003 = 0;
            }
            uint64_t v1004 = v1002 + 16 * v1003;
            uint64_t v1005 = v22 + 16 * v1003 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v1005;
              unint64_t v1001 = v1004;
            }
            unint64_t v1550 = v1001;
            if (v1548) {
              uint64_t v47 = v1004;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v592) {
              goto LABEL_1335;
            }
          }
        case 22:
          if (v45)
          {
            int v635 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v636 = 0;
              }
              else {
                unsigned int v636 = -1;
              }
              v637.i64[0] = 0;
              v637.i32[2] = 0;
              v638.i64[0] = 0;
              v638.i32[2] = 0;
              v638.i32[3] = v636;
              int8x16_t v639 = vmvnq_s8(v638);
              int8x16_t v640 = vandq_s8((int8x16_t)vdupq_n_s32(v636), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v641 = 0;
              }
              else {
                unsigned int v641 = -1;
              }
              v637.i32[3] = v641;
              int8x16_t v642 = vmvnq_s8(v637);
              int8x16_t v643 = vandq_s8((int8x16_t)vdupq_n_s32(v641), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v644 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v645 = v22;
                unint64_t v646 = v1550;
                do
                {
                  unint64_t v647 = (v645 - v47) >> 4;
                  if (v647 >= v1546) {
                    unint64_t v647 = v1546;
                  }
                  if (v647 < 2)
                  {
                    unint64_t i71 = v647;
                  }
                  else
                  {
                    uint64_t v648 = 0;
                    for (unint64_t i71 = v647; i71 > 1; i71 -= 2)
                    {
                      v650 = (int8x16_t *)((char *)v26 + v648);
                      float32x4_t v651 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v648), v642), v643);
                      float32x4_t v652 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v651, 3);
                      float32x4_t v653 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v648), v642), v643);
                      float32x4_t v654 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v653, 3);
                      float32x4_t v655 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v648), v639), v640);
                      float32x4_t v656 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v655, 3);
                      float32x4_t v657 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v648 + 16), v639), v640);
                      float32x4_t v658 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v657, 3);
                      int8x16_t v659 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v653, v655, 3), vmulq_laneq_f32(v655, v653, 3)), vaddq_f32(vmlsq_laneq_f32(v653, v653, v655, 3), vmlsq_laneq_f32(v655, v655, v653, 3)));
                      int8x16_t v660 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v651, v657, 3), vmulq_laneq_f32(v657, v651, 3)), vaddq_f32(vmlsq_laneq_f32(v651, v651, v657, 3), vmlsq_laneq_f32(v657, v657, v651, 3)));
                      v660.i32[3] = vaddq_f32(v657, vmlsq_laneq_f32(v652, v658, v651, 3)).i32[3];
                      v659.i32[3] = vaddq_f32(v655, vmlsq_laneq_f32(v654, v656, v653, 3)).i32[3];
                      int8x16_t *v650 = vbslq_s8((int8x16_t)vcgtzq_f32(v656), vbslq_s8((int8x16_t)vcgtzq_f32(v654), v659, (int8x16_t)v655), (int8x16_t)v653);
                      v650[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v658), vbslq_s8((int8x16_t)vcgtzq_f32(v652), v660, (int8x16_t)v657), (int8x16_t)v651);
                      v648 += v644;
                    }
                    v47 += v648;
                    float v26 = (float32x4_t *)((char *)v26 + v648);
                  }
                  for (unint64_t i72 = i71 + v1546 - v647; i72; --i72)
                  {
                    float32x4_t v662 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v639), v640);
                    float32x4_t v663 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v642), v643);
                    float32x4_t v664 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v662, 3);
                    float32x4_t v665 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v663, 3);
                    int8x16_t v666 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v663, v663, v662, 3), vmlsq_laneq_f32(v662, v662, v663, 3)), vabdq_f32(vmulq_laneq_f32(v663, v662, 3), vmulq_laneq_f32(v662, v663, 3)));
                    v666.i32[3] = vaddq_f32(v662, vmlsq_laneq_f32(v665, v664, v663, 3)).i32[3];
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vcgtzq_f32(v664), vbslq_s8((int8x16_t)vcgtzq_f32(v665), v666, (int8x16_t)v662), (int8x16_t)v663);
                    unint64_t v667 = v47 + 16 * v1541;
                    if (v667 >= v645) {
                      uint64_t v668 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v668 = 0;
                    }
                    uint64_t v47 = v667 + 16 * v668;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v669 = v646 + 16 * v1549;
                  if (v669 >= v1548) {
                    uint64_t v670 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v670 = 0;
                  }
                  uint64_t v671 = v669 + 16 * v670;
                  uint64_t v672 = v645 + 16 * v670 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v671;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v645 = v672;
                    unint64_t v646 = v671;
                  }
                  _VF = __OFSUB__(v635--, 1);
                }
                while (!((v635 < 0) ^ _VF | (v635 == 0)));
              }
              else
              {
                unint64_t v1472 = v22;
                unint64_t v1473 = v1550;
                do
                {
                  unint64_t v1474 = (v1472 - v47) >> 4;
                  if (v1474 >= v1546) {
                    unint64_t v1474 = v1546;
                  }
                  if (v1474 < 2)
                  {
                    unint64_t i73 = v1474;
                  }
                  else
                  {
                    uint64_t v1475 = 0;
                    for (unint64_t i73 = v1474; i73 > 1; i73 -= 2)
                    {
                      v1477 = (int8x16_t *)((char *)v26 + v1475);
                      float32x4_t v1478 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1475)), v642), v643);
                      float32x4_t v1479 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1478, 3);
                      float32x4_t v1480 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1475)), v642), v643);
                      float32x4_t v1481 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1475 + 16)), v639), v640);
                      float32x4_t v1482 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1480, 3);
                      float32x4_t v1483 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1481, 3);
                      float32x4_t v1484 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1475)), v639), v640);
                      float32x4_t v1485 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1484, 3);
                      int8x16_t v1486 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v1480, v1481, 3), vmulq_laneq_f32(v1481, v1480, 3)), vaddq_f32(vmlsq_laneq_f32(v1480, v1480, v1481, 3), vmlsq_laneq_f32(v1481, v1481, v1480, 3)));
                      int8x16_t v1487 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v1478, v1484, 3), vmulq_laneq_f32(v1484, v1478, 3)), vaddq_f32(vmlsq_laneq_f32(v1478, v1478, v1484, 3), vmlsq_laneq_f32(v1484, v1484, v1478, 3)));
                      v1487.i32[3] = vaddq_f32(v1484, vmlsq_laneq_f32(v1479, v1485, v1478, 3)).i32[3];
                      v1486.i32[3] = vaddq_f32(v1481, vmlsq_laneq_f32(v1482, v1483, v1480, 3)).i32[3];
                      int8x16_t *v1477 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1485), vbslq_s8((int8x16_t)vcgtzq_f32(v1479), v1487, (int8x16_t)v1484), (int8x16_t)v1478));
                      v1477[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1483), vbslq_s8((int8x16_t)vcgtzq_f32(v1482), v1486, (int8x16_t)v1481), (int8x16_t)v1480));
                      v1475 += v644;
                    }
                    v47 += v1475;
                    float v26 = (float32x4_t *)((char *)v26 + v1475);
                  }
                  for (unint64_t i74 = i73 + v1546 - v1474; i74; --i74)
                  {
                    float32x4_t v1489 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v639), v640);
                    float32x4_t v1490 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v642), v643);
                    float32x4_t v1491 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1489, 3);
                    float32x4_t v1492 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v1490, 3);
                    int8x16_t v1493 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v1490, v1490, v1489, 3), vmlsq_laneq_f32(v1489, v1489, v1490, 3)), vabdq_f32(vmulq_laneq_f32(v1490, v1489, 3), vmulq_laneq_f32(v1489, v1490, 3)));
                    v1493.i32[3] = vaddq_f32(v1489, vmlsq_laneq_f32(v1492, v1491, v1490, 3)).i32[3];
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v1491), vbslq_s8((int8x16_t)vcgtzq_f32(v1492), v1493, (int8x16_t)v1489), (int8x16_t)v1490));
                    unint64_t v1494 = v47 + 16 * v1541;
                    if (v1494 >= v1472) {
                      uint64_t v1495 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1495 = 0;
                    }
                    uint64_t v47 = v1494 + 16 * v1495;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1496 = v1473 + 16 * v1549;
                  if (v1496 >= v1548) {
                    uint64_t v1497 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1497 = 0;
                  }
                  uint64_t v1498 = v1496 + 16 * v1497;
                  uint64_t v1499 = v1472 + 16 * v1497 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1498;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1472 = v1499;
                    unint64_t v1473 = v1498;
                  }
                  _VF = __OFSUB__(v635--, 1);
                }
                while (!((v635 < 0) ^ _VF | (v635 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v635 = v1552;
          }
          do
          {
            int v883 = v1546;
            do
            {
              float v884 = 1.0;
              float v885 = 1.0;
              if (!v44 || (float v885 = *(float *)(v47 + 12), v885 > 0.0))
              {
                if (v20 && (float v884 = v26->f32[3], v884 <= 0.0))
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->f32[3] = v885;
                }
                else
                {
                  float v886 = v26->f32[2];
                  float v887 = *(float *)(v47 + 8);
                  float32x2_t v888 = vmul_n_f32(*(float32x2_t *)v26->f32, v885);
                  float32x2_t v889 = vmul_n_f32(*(float32x2_t *)v47, v884);
                  float32x2_t v890 = vsub_f32(vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47), v888);
                  float32x2_t v891 = vsub_f32(v888, v889);
                  float32x2_t v892 = vadd_f32(vsub_f32(v890, v889), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v891), (int8x8_t)vneg_f32(v891), (int8x8_t)v891));
                  v889.f32[0] = v886 + v887;
                  float v893 = v886 * v885;
                  float v894 = v887 * v884;
                  v889.f32[0] = v889.f32[0] - v893;
                  float v895 = v893 - v894;
                  float v896 = v889.f32[0] - v894;
                  if (v895 < 0.0) {
                    float v895 = -v895;
                  }
                  *(float32x2_t *)v26->f32 = v892;
                  v26->f32[2] = v896 + v895;
                  v26->f32[3] = (float)(v884 + v885) - (float)(v884 * v885);
                }
              }
              unint64_t v897 = v47 + 16 * v1541;
              if (v897 >= v22) {
                uint64_t v898 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v898 = 0;
              }
              uint64_t v47 = v897 + 16 * v898;
              v26 += v1541;
              --v883;
            }
            while (v883);
            v26 += v1547;
            unint64_t v899 = v1550;
            unint64_t v900 = v1550 + 16 * v1549;
            if (v900 >= v1548) {
              uint64_t v901 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v901 = 0;
            }
            uint64_t v902 = v900 + 16 * v901;
            uint64_t v903 = v22 + 16 * v901 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v903;
              unint64_t v899 = v902;
            }
            unint64_t v1550 = v899;
            if (v1548) {
              uint64_t v47 = v902;
            }
            else {
              v47 += 16 * v1549;
            }
            --v635;
          }
          while (v635);
          goto LABEL_1352;
        case 23:
          if (v45)
          {
            int v673 = v1552;
            if (*(_DWORD *)(v30 + 132))
            {
              if (v44) {
                unsigned int v674 = 0;
              }
              else {
                unsigned int v674 = -1;
              }
              v675.i64[0] = 0;
              v675.i32[2] = 0;
              v676.i64[0] = 0;
              v676.i32[2] = 0;
              v676.i32[3] = v674;
              int8x16_t v677 = vmvnq_s8(v676);
              int8x16_t v678 = vandq_s8((int8x16_t)vdupq_n_s32(v674), (int8x16_t)xmmword_1850CDBF0);
              if (v20) {
                unsigned int v679 = 0;
              }
              else {
                unsigned int v679 = -1;
              }
              v675.i32[3] = v679;
              int8x16_t v680 = vmvnq_s8(v675);
              int8x16_t v681 = vandq_s8((int8x16_t)vdupq_n_s32(v679), (int8x16_t)xmmword_1850CDBF0);
              uint64_t v682 = 32 * v1541;
              if ((*v1533 & 0x30) != 0)
              {
                unint64_t v683 = v22;
                unint64_t v684 = v1550;
                do
                {
                  unint64_t v685 = (v683 - v47) >> 4;
                  if (v685 >= v1546) {
                    unint64_t v685 = v1546;
                  }
                  if (v685 < 2)
                  {
                    unint64_t i75 = v685;
                  }
                  else
                  {
                    uint64_t v686 = 0;
                    for (unint64_t i75 = v685; i75 > 1; i75 -= 2)
                    {
                      float32x4_t v688 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v686 + 16), v677), v678);
                      v689 = (int8x16_t *)((char *)v26 + v686);
                      float32x4_t v690 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v47 + v686), v677), v678);
                      float32x4_t v691 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)v26 + v686), v680), v681);
                      float32x4_t v692 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&v26[1] + v686), v680), v681);
                      float32x4_t v693 = vmlsq_f32(v690, v691, v690);
                      float32x4_t v694 = vmlsq_f32(v688, v692, v688);
                      v693.i32[3] = v690.i32[3];
                      v694.i32[3] = v688.i32[3];
                      int8x16_t *v689 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v690, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v691, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v691, v690, v691), v693), (int8x16_t)v690), (int8x16_t)v691);
                      v689[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v688, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v692, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v692, v688, v692), v694), (int8x16_t)v688), (int8x16_t)v692);
                      v686 += v682;
                    }
                    v47 += v686;
                    float v26 = (float32x4_t *)((char *)v26 + v686);
                  }
                  for (unint64_t i76 = i75 + v1546 - v685; i76; --i76)
                  {
                    float32x4_t v696 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v47, v677), v678);
                    float32x4_t v697 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)v26, v680), v681);
                    float32x4_t v698 = vmlsq_f32(v696, v697, v696);
                    v698.i32[3] = v696.i32[3];
                    *(int8x16_t *)float v26 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v696)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v697)), 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v697, v696, v697), v698), (int8x16_t)v696), (int8x16_t)v697);
                    unint64_t v699 = v47 + 16 * v1541;
                    if (v699 >= v683) {
                      uint64_t v700 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v700 = 0;
                    }
                    uint64_t v47 = v699 + 16 * v700;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v701 = v684 + 16 * v1549;
                  if (v701 >= v1548) {
                    uint64_t v702 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v702 = 0;
                  }
                  uint64_t v703 = v701 + 16 * v702;
                  uint64_t v704 = v683 + 16 * v702 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v703;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v683 = v704;
                    unint64_t v684 = v703;
                  }
                  _VF = __OFSUB__(v673--, 1);
                }
                while (!((v673 < 0) ^ _VF | (v673 == 0)));
              }
              else
              {
                unint64_t v1500 = v22;
                unint64_t v1501 = v1550;
                do
                {
                  unint64_t v1502 = (v1500 - v47) >> 4;
                  if (v1502 >= v1546) {
                    unint64_t v1502 = v1546;
                  }
                  if (v1502 < 2)
                  {
                    unint64_t i77 = v1502;
                  }
                  else
                  {
                    uint64_t v1503 = 0;
                    for (unint64_t i77 = v1502; i77 > 1; i77 -= 2)
                    {
                      v1505 = (int8x16_t *)((char *)v26 + v1503);
                      float32x4_t v1506 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1503)), v677), v678);
                      float32x4_t v1507 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)(v47 + v1503 + 16)), v677), v678);
                      float32x4_t v1508 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&v26[1] + v1503)), v680), v681);
                      float32x4_t v1509 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)v26 + v1503)), v680), v681);
                      float32x4_t v1510 = vmlsq_f32(v1506, v1509, v1506);
                      float32x4_t v1511 = vmlsq_f32(v1507, v1508, v1507);
                      v1511.i32[3] = v1507.i32[3];
                      v1510.i32[3] = v1506.i32[3];
                      int8x16_t *v1505 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1506, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1509, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1509, v1506, v1509), v1510), (int8x16_t)v1506), (int8x16_t)v1509));
                      v1505[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1507, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1508, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1508, v1507, v1508), v1511), (int8x16_t)v1507), (int8x16_t)v1508));
                      v1503 += v682;
                    }
                    v47 += v1503;
                    float v26 = (float32x4_t *)((char *)v26 + v1503);
                  }
                  for (unint64_t i78 = i77 + v1546 - v1502; i78; --i78)
                  {
                    float32x4_t v1513 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v26), v680), v681);
                    float32x4_t v1514 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)v47), v677), v678);
                    float32x4_t v1515 = vmlsq_f32(v1514, v1513, v1514);
                    v1515.i32[3] = v1514.i32[3];
                    *(int8x16_t *)float v26 = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1514)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v1513)), 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v1513, v1514, v1513), v1515), (int8x16_t)v1514), (int8x16_t)v1513));
                    unint64_t v1516 = v47 + 16 * v1541;
                    if (v1516 >= v1500) {
                      uint64_t v1517 = -(uint64_t)(int)v1545;
                    }
                    else {
                      uint64_t v1517 = 0;
                    }
                    uint64_t v47 = v1516 + 16 * v1517;
                    v26 += v1541;
                  }
                  v26 += v1547;
                  unint64_t v1518 = v1501 + 16 * v1549;
                  if (v1518 >= v1548) {
                    uint64_t v1519 = -(uint64_t)(v1549 * v1542);
                  }
                  else {
                    uint64_t v1519 = 0;
                  }
                  uint64_t v1520 = v1518 + 16 * v1519;
                  uint64_t v1521 = v1500 + 16 * v1519 + 16 * v1549;
                  if (v1548) {
                    uint64_t v47 = v1520;
                  }
                  else {
                    v47 += 16 * v1549;
                  }
                  if (v1548)
                  {
                    unint64_t v1500 = v1521;
                    unint64_t v1501 = v1520;
                  }
                  _VF = __OFSUB__(v673--, 1);
                }
                while (!((v673 < 0) ^ _VF | (v673 == 0)));
              }
              goto LABEL_1353;
            }
          }
          else
          {
            int v673 = v1552;
          }
          do
          {
            int v904 = v1546;
            do
            {
              float v905 = 1.0;
              float v906 = 1.0;
              if (!v44 || (float v906 = *(float *)(v47 + 12), v906 > 0.0))
              {
                if (v20 && (float v905 = v26->f32[3], v905 <= 0.0))
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                }
                else
                {
                  float32_t v907 = (float)(v26->f32[2] + *(float *)(v47 + 8))
                       + (float)((float)(*(float *)(v47 + 8) * v26->f32[2]) * -2.0);
                  *(float32x2_t *)v26->f32 = vmla_f32(vadd_f32(*(float32x2_t *)v26->f32, *(float32x2_t *)v47), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v47, *(float32x2_t *)v26->f32));
                  float v906 = (float)(v906 + v905) - (float)(v905 * v906);
                  v26->f32[2] = v907;
                }
                v26->f32[3] = v906;
              }
              unint64_t v908 = v47 + 16 * v1541;
              if (v908 >= v22) {
                uint64_t v909 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v909 = 0;
              }
              uint64_t v47 = v908 + 16 * v909;
              v26 += v1541;
              --v904;
            }
            while (v904);
            v26 += v1547;
            unint64_t v910 = v1550;
            unint64_t v911 = v1550 + 16 * v1549;
            if (v911 >= v1548) {
              uint64_t v912 = -(uint64_t)(v1549 * v1542);
            }
            else {
              uint64_t v912 = 0;
            }
            uint64_t v913 = v911 + 16 * v912;
            uint64_t v914 = v22 + 16 * v912 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v914;
              unint64_t v910 = v913;
            }
            unint64_t v1550 = v910;
            if (v1548) {
              uint64_t v47 = v913;
            }
            else {
              v47 += 16 * v1549;
            }
            --v673;
          }
          while (v673);
          goto LABEL_1352;
        case 24:
          unint64_t v1540 = v48;
          uint64_t v1537 = v32;
          unsigned int v705 = v1552;
          while (1)
          {
            int v706 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_731;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v707 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_731;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v707 = 1.0;
              }
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              v26->f32[0] = PDAhuePDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v707, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(void *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(void *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
              v26->i32[1] = v708;
              v26->i32[2] = v709;
              v26->i32[3] = LODWORD(a10);
LABEL_731:
              unint64_t v710 = v47 + 16 * v1541;
              if (v710 >= v22) {
                uint64_t v711 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v711 = 0;
              }
              uint64_t v47 = v710 + 16 * v711;
              v26 += v1541;
              --v706;
            }
            while (v706);
            v26 += v1547;
            unint64_t v712 = v1550;
            unint64_t v713 = v1550 + 16 * v1549;
            uint64_t v714 = -(uint64_t)(v1549 * v1542);
            if (v713 < v1548) {
              uint64_t v714 = 0;
            }
            uint64_t v715 = v713 + 16 * v714;
            uint64_t v716 = v22 + 16 * v714 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v716;
              unint64_t v712 = v715;
            }
            unint64_t v1550 = v712;
            if (v1548) {
              uint64_t v47 = v715;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v705) {
              goto LABEL_1335;
            }
          }
        case 25:
          unint64_t v1540 = v48;
          uint64_t v1537 = v32;
          unsigned int v717 = v1552;
          while (1)
          {
            int v718 = v1546;
            do
            {
              LODWORD(a12) = 1.0;
              if (v44)
              {
                LODWORD(a12) = *(_DWORD *)(v47 + 12);
                if (*(float *)&a12 <= 0.0) {
                  goto LABEL_753;
                }
              }
              if (v20)
              {
                LODWORD(a10) = v26->i32[3];
                float v719 = *(float *)&a10;
                if (*(float *)&a10 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->i32[3] = LODWORD(a12);
                  goto LABEL_753;
                }
              }
              else
              {
                LODWORD(a10) = v26->i32[3];
                float v719 = 1.0;
              }
              LODWORD(a13) = *(_DWORD *)v47;
              LODWORD(a14) = *(_DWORD *)(v47 + 12);
              v26->f32[0] = PDAsaturationPDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v719, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(void *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(void *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
              v26->i32[1] = v720;
              v26->i32[2] = v721;
              v26->i32[3] = LODWORD(a10);
LABEL_753:
              unint64_t v722 = v47 + 16 * v1541;
              if (v722 >= v22) {
                uint64_t v723 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v723 = 0;
              }
              uint64_t v47 = v722 + 16 * v723;
              v26 += v1541;
              --v718;
            }
            while (v718);
            v26 += v1547;
            unint64_t v724 = v1550;
            unint64_t v725 = v1550 + 16 * v1549;
            uint64_t v726 = -(uint64_t)(v1549 * v1542);
            if (v725 < v1548) {
              uint64_t v726 = 0;
            }
            uint64_t v727 = v725 + 16 * v726;
            uint64_t v728 = v22 + 16 * v726 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v728;
              unint64_t v724 = v727;
            }
            unint64_t v1550 = v724;
            if (v1548) {
              uint64_t v47 = v727;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v717) {
              goto LABEL_1335;
            }
          }
        case 26:
          unint64_t v1540 = v48;
          uint64_t v1537 = v32;
          unsigned int v729 = v1552;
          while (1)
          {
            int v730 = v1546;
            do
            {
              float v731 = 1.0;
              if (v44)
              {
                float v731 = *(float *)(v47 + 12);
                if (v731 <= 0.0) {
                  goto LABEL_775;
                }
              }
              if (v20)
              {
                LODWORD(a12) = v26->i32[3];
                LODWORD(a13) = LODWORD(a12);
                if (*(float *)&a12 <= 0.0)
                {
                  v26->i64[0] = *(void *)v47;
                  v26->i32[2] = *(_DWORD *)(v47 + 8);
                  v26->f32[3] = v731;
                  goto LABEL_775;
                }
              }
              else
              {
                LODWORD(a12) = v26->i32[3];
                LODWORD(a13) = 1.0;
              }
              LODWORD(a10) = *(_DWORD *)(v47 + 12);
              LODWORD(a14) = v26->i32[2];
              v26->f32[0] = PDAluminosityPDA(*(float *)v47, *(float *)(v47 + 4), *(float *)(v47 + 8), a10, v731, a12, a13, a14, COERCE_FLOAT(v26->i64[0]), COERCE_FLOAT(HIDWORD(v26->i64[0])), *(float *)&a14, *(float *)&a12, *(float *)&a13);
              v26->i32[1] = v732;
              v26->i32[2] = v733;
              v26->i32[3] = LODWORD(a10);
LABEL_775:
              unint64_t v734 = v47 + 16 * v1541;
              if (v734 >= v22) {
                uint64_t v735 = -(uint64_t)(int)v1545;
              }
              else {
                uint64_t v735 = 0;
              }
              uint64_t v47 = v734 + 16 * v735;
              v26 += v1541;
              --v730;
            }
            while (v730);
            v26 += v1547;
            unint64_t v736 = v1550;
            unint64_t v737 = v1550 + 16 * v1549;
            uint64_t v738 = -(uint64_t)(v1549 * v1542);
            if (v737 < v1548) {
              uint64_t v738 = 0;
            }
            uint64_t v739 = v737 + 16 * v738;
            uint64_t v740 = v22 + 16 * v738 + 16 * v1549;
            if (v1548)
            {
              unint64_t v22 = v740;
              unint64_t v736 = v739;
            }
            unint64_t v1550 = v736;
            if (v1548) {
              uint64_t v47 = v739;
            }
            else {
              v47 += 16 * v1549;
            }
            if (!--v729) {
              goto LABEL_1335;
            }
          }
        case 27:
          unint64_t v1540 = v48;
          uint64_t v1537 = v32;
          unsigned int v741 = v1552;
          break;
        default:
          goto LABEL_1353;
      }
      break;
    }
LABEL_789:
    int v742 = v1546;
    while (1)
    {
      LODWORD(a12) = 1.0;
      if (!v44 || (LODWORD(a12) = *(_DWORD *)(v47 + 12), *(float *)&a12 > 0.0))
      {
        if (!v20)
        {
          LODWORD(a10) = v26->i32[3];
          float v743 = 1.0;
LABEL_796:
          LODWORD(a13) = *(_DWORD *)v47;
          LODWORD(a14) = *(_DWORD *)(v47 + 12);
          v26->f32[0] = PDAluminosityPDA(v26->f32[0], v26->f32[1], v26->f32[2], a10, v743, a12, a13, a14, *(float *)v47, COERCE_FLOAT(*(void *)(v47 + 4)), COERCE_FLOAT(HIDWORD(*(void *)(v47 + 4))), *(float *)&a14, *(float *)&a12);
          v26->i32[1] = v744;
          v26->i32[2] = v745;
          v26->i32[3] = LODWORD(a10);
          goto LABEL_797;
        }
        LODWORD(a10) = v26->i32[3];
        float v743 = *(float *)&a10;
        if (*(float *)&a10 > 0.0) {
          goto LABEL_796;
        }
        v26->i64[0] = *(void *)v47;
        v26->i32[2] = *(_DWORD *)(v47 + 8);
        v26->i32[3] = LODWORD(a12);
      }
LABEL_797:
      unint64_t v746 = v47 + 16 * v1541;
      if (v746 >= v22) {
        uint64_t v747 = -(uint64_t)(int)v1545;
      }
      else {
        uint64_t v747 = 0;
      }
      uint64_t v47 = v746 + 16 * v747;
      v26 += v1541;
      if (!--v742)
      {
        v26 += v1547;
        unint64_t v748 = v1550;
        unint64_t v749 = v1550 + 16 * v1549;
        uint64_t v750 = -(uint64_t)(v1549 * v1542);
        if (v749 < v1548) {
          uint64_t v750 = 0;
        }
        uint64_t v751 = v749 + 16 * v750;
        uint64_t v752 = v22 + 16 * v750 + 16 * v1549;
        if (v1548)
        {
          unint64_t v22 = v752;
          unint64_t v748 = v751;
        }
        unint64_t v1550 = v748;
        if (v1548) {
          uint64_t v47 = v751;
        }
        else {
          v47 += 16 * v1549;
        }
        if (!--v741) {
          goto LABEL_1335;
        }
        goto LABEL_789;
      }
    }
  }
  int v1542 = 0;
  unint64_t v1550 = 0;
  unint64_t v1548 = 0;
  unint64_t v22 = -1;
  unint64_t v1549 = v1545;
LABEL_32:
  int v45 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result;
  double v49 = v23;
  int v1541 = a4;
  unint64_t v48 = v33;
  shape_enum_clip_alloc(a1, a2, v49, a4, v33, 1, v27, v28, v1546, v17);
  double v51 = v50;
  if (v50) {
    goto LABEL_1355;
  }
}

void RGBAf_mark_constmask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16)
{
  uint64_t v16 = *(void *)(a1 + 136);
  if (v16)
  {
    int v18 = *(_DWORD *)(a1 + 4);
    int v17 = *(_DWORD *)(a1 + 8);
    uint64_t v19 = *(void *)(a1 + 48);
    float32x4_t v20 = *(float32x4_t *)*(void *)(a1 + 88);
    unint64_t v21 = (unint64_t)*(int *)(a1 + 28) >> 4;
    unint64_t v22 = (float32x2_t *)(*(void *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v21 * *(int *)(a1 + 16)));
    uint64_t v23 = *(int *)(a1 + 124);
    unint64_t v24 = v16 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v23;
    uint64_t v25 = v23 - v18;
    unint64_t v26 = v21 - v18;
    float32x4_t v211 = v20;
    switch((int)a2)
    {
      case 0:
        do
        {
          int v27 = v18;
          do
          {
            int v28 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v28 == 255)
              {
                *unint64_t v22 = 0;
                v22[1] = 0;
              }
              else
              {
                *(float32x4_t *)v22->f32 = vmulq_n_f32(*(float32x4_t *)v22->f32, (float)(v28 ^ 0xFFu) * 0.0039216);
              }
            }
            ++v24;
            v22 += 2;
            --v27;
          }
          while (v27);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 1:
        int v29 = -1;
        unsigned int v30 = v24 & 3;
        if ((v24 & 3) != 0)
        {
          v18 += v30;
          int v29 = -1 << (8 * v30);
          unint64_t v31 = v24 & 3;
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
          v22 -= 2 * v31;
        }
        unsigned int v32 = ((_BYTE)v18 + (_BYTE)v24) & 3;
        if ((((_BYTE)v18 + (_BYTE)v24) & 3) != 0)
        {
          unsigned int v33 = 4 - v32;
          v30 += v33;
          unsigned int v34 = 0xFFFFFFFF >> (8 * v33);
          if (v18 >= 4) {
            unsigned int v32 = 0xFFFFFFFF >> (8 * v33);
          }
          else {
            unsigned int v32 = 0;
          }
          if (v18 >= 4) {
            unsigned int v34 = -1;
          }
          v29 &= v34;
        }
        uint64_t v35 = v25 - v30;
        unint64_t v36 = v26 - v30;
        do
        {
          unsigned int v37 = *(_DWORD *)v24 & v29;
          int v38 = v18 >> 2;
          unsigned int v39 = v32;
          if (!v37) {
            goto LABEL_40;
          }
LABEL_22:
          if (v37 == -1)
          {
            *(float32x4_t *)v22->f32 = v20;
            *(float32x4_t *)v22[2].f32 = v20;
            *(float32x4_t *)v22[4].f32 = v20;
LABEL_37:
            *(float32x4_t *)v22[6].f32 = v20;
            goto LABEL_40;
          }
          while (1)
          {
            if ((_BYTE)v37)
            {
              float32x4_t v40 = v20;
              if (v37 != 255) {
                float32x4_t v40 = vmlaq_n_f32(vmulq_n_f32(v20, (float)v37 * 0.0039216), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v37 * 0.0039216));
              }
              *(float32x4_t *)v22->f32 = v40;
            }
            if (BYTE1(v37))
            {
              float32x4_t v41 = v20;
              if (BYTE1(v37) != 255) {
                float32x4_t v41 = vmlaq_n_f32(vmulq_n_f32(v20, (float)BYTE1(v37) * 0.0039216), *(float32x4_t *)v22[2].f32, 1.0 - (float)((float)BYTE1(v37) * 0.0039216));
              }
              *(float32x4_t *)v22[2].f32 = v41;
            }
            if (BYTE2(v37))
            {
              float32x4_t v42 = v20;
              if (BYTE2(v37) != 255) {
                float32x4_t v42 = vmlaq_n_f32(vmulq_n_f32(v20, (float)BYTE2(v37) * 0.0039216), *(float32x4_t *)v22[4].f32, 1.0 - (float)((float)BYTE2(v37) * 0.0039216));
              }
              *(float32x4_t *)v22[4].f32 = v42;
            }
            unsigned int v43 = HIBYTE(v37);
            if (v43 == 255) {
              goto LABEL_37;
            }
            if (v43) {
              *(float32x4_t *)v22[6].f32 = vmlaq_n_f32(vmulq_n_f32(v20, (float)v43 * 0.0039216), *(float32x4_t *)v22[6].f32, 1.0 - (float)((float)v43 * 0.0039216));
            }
LABEL_40:
            while (1)
            {
              int v44 = v38;
              v22 += 8;
              --v38;
              v24 += 4;
              if (v44 < 2) {
                break;
              }
              unsigned int v37 = *(_DWORD *)v24;
              if (*(_DWORD *)v24) {
                goto LABEL_22;
              }
            }
            if (!v39) {
              break;
            }
            unsigned int v39 = 0;
            unsigned int v37 = *(_DWORD *)v24 & v32;
          }
          v24 += v35;
          v22 += 2 * v36;
          --v17;
        }
        while (v17);
        return;
      case 2:
        int v45 = -1;
        unsigned int v46 = v24 & 3;
        if ((v24 & 3) != 0)
        {
          v18 += v46;
          int v45 = -1 << (8 * v46);
          unint64_t v47 = v24 & 3;
          v24 &= 0xFFFFFFFFFFFFFFFCLL;
          v22 -= 2 * v47;
        }
        unsigned int v48 = ((_BYTE)v18 + (_BYTE)v24) & 3;
        if ((((_BYTE)v18 + (_BYTE)v24) & 3) != 0)
        {
          unsigned int v49 = 4 - v48;
          v46 += v49;
          unsigned int v50 = 0xFFFFFFFF >> (8 * v49);
          if (v18 >= 4) {
            unsigned int v48 = 0xFFFFFFFF >> (8 * v49);
          }
          else {
            unsigned int v48 = 0;
          }
          if (v18 >= 4) {
            unsigned int v50 = -1;
          }
          v45 &= v50;
        }
        uint64_t v51 = v25 - v46;
        *(float *)&a9 = 1.0 - v20.f32[3];
        float32x4_t v52 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
        unint64_t v53 = v26 - v46;
        do
        {
          unsigned int v54 = *(_DWORD *)v24 & v45;
          int v55 = v18 >> 2;
          unsigned int v56 = v48;
          if (!v54) {
            goto LABEL_68;
          }
LABEL_58:
          if (v54 == -1)
          {
            float32x4_t v57 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[2].f32);
            *(float32x4_t *)v22->f32 = vmlaq_f32(v20, v52, *(float32x4_t *)v22->f32);
            *(float32x4_t *)v22[2].f32 = v57;
            float32x4_t v58 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[6].f32);
            *(float32x4_t *)v22[4].f32 = vmlaq_f32(v20, v52, *(float32x4_t *)v22[4].f32);
            *(float32x4_t *)v22[6].f32 = v58;
            goto LABEL_68;
          }
          while (1)
          {
            if ((_BYTE)v54)
            {
              float32x4_t v59 = vmulq_n_f32(v20, (float)v54 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(v59, *(float32x4_t *)v22->f32, 1.0 - v59.f32[3]);
            }
            if ((v54 & 0xFF00) != 0)
            {
              float32x4_t v60 = vmulq_n_f32(v20, (float)BYTE1(v54) * 0.0039216);
              *(float32x4_t *)v22[2].f32 = vmlaq_n_f32(v60, *(float32x4_t *)v22[2].f32, 1.0 - v60.f32[3]);
            }
            if ((v54 & 0xFF0000) != 0)
            {
              float32x4_t v61 = vmulq_n_f32(v20, (float)BYTE2(v54) * 0.0039216);
              *(float32x4_t *)v22[4].f32 = vmlaq_n_f32(v61, *(float32x4_t *)v22[4].f32, 1.0 - v61.f32[3]);
            }
            unsigned int v62 = HIBYTE(v54);
            if (v62)
            {
              float32x4_t v63 = vmulq_n_f32(v20, (float)v62 * 0.0039216);
              *(float32x4_t *)v22[6].f32 = vmlaq_n_f32(v63, *(float32x4_t *)v22[6].f32, 1.0 - v63.f32[3]);
            }
LABEL_68:
            while (1)
            {
              int v64 = v55;
              v22 += 8;
              --v55;
              v24 += 4;
              if (v64 < 2) {
                break;
              }
              unsigned int v54 = *(_DWORD *)v24;
              if (*(_DWORD *)v24) {
                goto LABEL_58;
              }
            }
            if (!v56) {
              break;
            }
            unsigned int v56 = 0;
            unsigned int v54 = *(_DWORD *)v24 & v48;
          }
          v24 += v51;
          v22 += 2 * v53;
          --v17;
        }
        while (v17);
        return;
      case 3:
        do
        {
          int v65 = v18;
          do
          {
            unsigned int v66 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v66 == 255) {
                float32x4_t v67 = vmulq_n_f32(v20, v22[1].f32[1]);
              }
              else {
                float32x4_t v67 = vmlaq_n_f32(vmulq_n_f32(v20, vmuls_lane_f32((float)v66 * 0.0039216, *(float32x4_t *)v22->f32, 3)), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v66 * 0.0039216));
              }
              *(float32x4_t *)v22->f32 = v67;
            }
            ++v24;
            v22 += 2;
            --v65;
          }
          while (v65);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 4:
        do
        {
          int v68 = v18;
          do
          {
            unsigned int v69 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v69 == 255) {
                float32x4_t v70 = vmulq_n_f32(v20, 1.0 - v22[1].f32[1]);
              }
              else {
                float32x4_t v70 = vmlaq_n_f32(vmulq_n_f32(v20, (float)((float)v69 * 0.0039216) * (float)(1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)))), *(float32x4_t *)v22->f32, 1.0 - (float)((float)v69 * 0.0039216));
              }
              *(float32x4_t *)v22->f32 = v70;
            }
            ++v24;
            v22 += 2;
            --v68;
          }
          while (v68);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 5:
        do
        {
          int v71 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float32x4_t v72 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_laneq_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v72.f32[3]), v72, *(float32x4_t *)v22->f32, 3);
            }
            ++v24;
            v22 += 2;
            --v71;
          }
          while (v71);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 6:
        while (1)
        {
          int v73 = v18;
          do
          {
            unsigned int v74 = *(unsigned __int8 *)v24;
            if (!*(unsigned char *)v24) {
              goto LABEL_106;
            }
            float v75 = v22[1].f32[1];
            float v76 = 1.0 - v75;
            if ((float)(1.0 - v75) >= 1.0)
            {
              float v79 = (float)v74 * 0.0039216;
              float v78 = v20.f32[3] * v79;
              *unint64_t v22 = vmul_n_f32(*(float32x2_t *)v20.f32, v79);
              v22[1].f32[0] = v20.f32[2] * v79;
            }
            else
            {
              if (v76 <= 0.0) {
                goto LABEL_106;
              }
              float v77 = (float)v74 * 0.0039216;
              *unint64_t v22 = vmla_n_f32(*v22, vmul_n_f32(*(float32x2_t *)v20.f32, v77), v76);
              v22[1].f32[0] = v22[1].f32[0] + (float)((float)(v20.f32[2] * v77) * v76);
              float v78 = v75 + (float)((float)(v20.f32[3] * v77) * v76);
            }
            v22[1].f32[1] = v78;
LABEL_106:
            ++v24;
            v22 += 2;
            --v73;
          }
          while (v73);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 7:
        do
        {
          int v80 = v18;
          do
          {
            unsigned int v81 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v81 == 255)
              {
                float v82 = v20.f32[3] * v22->f32[0];
                float v83 = v20.f32[3];
              }
              else
              {
                float v83 = (float)(v20.f32[3] * (float)((float)v81 * 0.0039216))
                    + (float)(1.0 - (float)((float)v81 * 0.0039216));
                float v82 = v83 * v22->f32[0];
              }
              v22->f32[0] = v82;
              *(float32x2_t *)((char *)v22 + 4) = vmul_n_f32(*(float32x2_t *)((char *)v22 + 4), v83);
              v22[1].f32[1] = v83 * v22[1].f32[1];
            }
            ++v24;
            v22 += 2;
            --v80;
          }
          while (v80);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 8:
        do
        {
          int v84 = v18;
          do
          {
            unsigned int v85 = *(unsigned __int8 *)v24;
            if (*(unsigned char *)v24)
            {
              if (v85 == 255)
              {
                float v86 = (float)(1.0 - v20.f32[3]) * v22->f32[0];
                float v87 = 1.0 - v20.f32[3];
              }
              else
              {
                float v87 = (float)(v20.f32[3] * (float)((float)v85 * -0.0039216)) + 1.0;
                float v86 = v87 * v22->f32[0];
              }
              v22->f32[0] = v86;
              *(float32x2_t *)((char *)v22 + 4) = vmul_n_f32(*(float32x2_t *)((char *)v22 + 4), v87);
              v22[1].f32[1] = v87 * v22[1].f32[1];
            }
            ++v24;
            v22 += 2;
            --v84;
          }
          while (v84);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 9:
        do
        {
          int v88 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float v89 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              float v90 = 1.0 - v89;
              float32x4_t v91 = vmulq_n_f32(v20, v89);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, v90 + v91.f32[3]), v91, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
            }
            ++v24;
            v22 += 2;
            --v88;
          }
          while (v88);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 10:
        do
        {
          int v92 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float32x4_t v93 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v93.f32[3]), v93, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
            }
            ++v24;
            v22 += 2;
            --v92;
          }
          while (v92);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 11:
        do
        {
          int v94 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float v95 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              float v96 = v20.f32[0] * v95;
              float v97 = v20.f32[3] * v95;
              if (v19)
              {
                float v98 = v22[1].f32[1];
                float v99 = (float)(v97 - v96) + (float)(v98 - v22->f32[0]);
                if ((float)(v97 + v98) <= 1.0) {
                  float v100 = v97 + v98;
                }
                else {
                  float v100 = 1.0;
                }
              }
              else
              {
                float v98 = 1.0;
                float v99 = (float)(v97 - v96) + (float)(1.0 - v22->f32[0]);
                if ((float)(v97 + 1.0) <= 1.0) {
                  float v100 = v97 + 1.0;
                }
                else {
                  float v100 = 1.0;
                }
              }
              float v101 = (float)(v97 - (float)(v20.f32[1] * v95)) + (float)(v98 - v22->f32[1]);
              v22->f32[0] = v100 - v99;
              float v102 = (float)(v97 - (float)(v20.f32[2] * v95)) + (float)(v98 - v22[1].f32[0]);
              v22->f32[1] = v100 - v101;
              v22[1].f32[0] = v100 - v102;
              v22[1].f32[1] = v100;
            }
            ++v24;
            v22 += 2;
            --v94;
          }
          while (v94);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 12:
        do
        {
          int v103 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float v104 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              float v105 = v20.f32[2] * v104;
              *unint64_t v22 = vadd_f32(vmul_n_f32(*(float32x2_t *)v20.f32, v104), *v22);
              float v106 = (float)(v20.f32[3] * v104) + v22[1].f32[1];
              float v107 = v105 + v22[1].f32[0];
              if (v106 > 1.0) {
                float v106 = 1.0;
              }
              v22[1].f32[0] = v107;
              v22[1].f32[1] = v106;
            }
            ++v24;
            v22 += 2;
            --v103;
          }
          while (v103);
          v24 += v25;
          v22 += 2 * v26;
          --v17;
        }
        while (v17);
        return;
      case 13:
        while (1)
        {
          int v108 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v109 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v109.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v110 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v109;
                    goto LABEL_168;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v110 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v111 = vextq_s8(v109, v109, 4uLL).u64[0];
                float v112 = PDAmultiplyPDA(v22->f32[0], a10, a11, a12, v110, *(double *)v109.i64, v111, a16, *(float *)v109.i32, COERCE_DOUBLE(__PAIR64__(v109.u32[3], HIDWORD(v111))), *(float *)&v109.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v112;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_168:
            ++v24;
            v22 += 2;
            --v108;
          }
          while (v108);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 14:
        float32x2_t v113 = (float32x2_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL).u64[0];
        __asm { FMOV            V3.2S, #1.0 }
        while (1)
        {
          int v119 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float v120 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              float32x2_t v121 = vmul_n_f32(v113, v120);
              if (v121.f32[1] > 0.0)
              {
                float32x2_t v122 = vmul_n_f32(*(float32x2_t *)v20.f32, v120);
                if (v19)
                {
                  float v123 = v22[1].f32[1];
                  if (v123 <= 0.0)
                  {
                    *unint64_t v22 = v122;
                    v22[1] = v121;
                    goto LABEL_180;
                  }
                }
                else
                {
                  float v123 = 1.0;
                }
                float v124 = vmlas_n_f32(v22[1].f32[0], 1.0 - v22[1].f32[0], v121.f32[0]);
                *unint64_t v22 = vmla_f32(*v22, vsub_f32(_D3, *v22), v122);
                v22[1].f32[0] = v124;
                v22[1].f32[1] = (float)(v121.f32[1] + v123) - (float)(v123 * v121.f32[1]);
              }
            }
LABEL_180:
            ++v24;
            v22 += 2;
            --v119;
          }
          while (v119);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 15:
        while (1)
        {
          int v125 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v126 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v126.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v127 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v126;
                    goto LABEL_191;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v127 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v128 = vextq_s8(v126, v126, 4uLL).u64[0];
                float v129 = PDAoverlayPDA(v22->f32[0], a10, a11, a12, v127, *(double *)v126.i64, v128, a16, *(float *)v126.i32, COERCE_DOUBLE(__PAIR64__(v126.u32[3], HIDWORD(v128))), *(float *)&v126.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v129;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_191:
            ++v24;
            v22 += 2;
            --v125;
          }
          while (v125);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 16:
        while (1)
        {
          int v130 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v131 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v131.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v132 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v131;
                    goto LABEL_202;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v132 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v133 = vextq_s8(v131, v131, 4uLL).u64[0];
                float v134 = PDAdarkenPDA(v22->f32[0], a10, a11, a12, v132, *(double *)v131.i64, v133, a16, *(float *)v131.i32, COERCE_DOUBLE(__PAIR64__(v131.u32[3], HIDWORD(v133))), *(float *)&v131.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v134;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_202:
            ++v24;
            v22 += 2;
            --v130;
          }
          while (v130);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 17:
        while (1)
        {
          int v135 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v136 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v136.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v137 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v136;
                    goto LABEL_213;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v137 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v138 = vextq_s8(v136, v136, 4uLL).u64[0];
                float v139 = PDAlightenPDA(v22->f32[0], a10, a11, a12, v137, *(double *)v136.i64, v138, a16, *(float *)v136.i32, COERCE_DOUBLE(__PAIR64__(v136.u32[3], HIDWORD(v138))), *(float *)&v136.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v139;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_213:
            ++v24;
            v22 += 2;
            --v135;
          }
          while (v135);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 18:
        while (1)
        {
          int v140 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v141 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v141.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v142 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v141;
                    goto LABEL_224;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v142 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v143 = vextq_s8(v141, v141, 4uLL).u64[0];
                float v144 = PDAcolordodgePDA(v22->f32[0], a10, a11, a12, v142, *(double *)v141.i64, v143, a16, *(float *)v141.i32, COERCE_DOUBLE(__PAIR64__(v141.u32[3], HIDWORD(v143))), *(float *)&v141.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v144;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_224:
            ++v24;
            v22 += 2;
            --v140;
          }
          while (v140);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 19:
        while (1)
        {
          int v145 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v146 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v146.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v147 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v146;
                    goto LABEL_235;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v147 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v148 = vextq_s8(v146, v146, 4uLL).u64[0];
                float v149 = PDAcolorburnPDA(v22->f32[0], a10, a11, a12, v147, *(double *)v146.i64, v148, a16, *(float *)v146.i32, COERCE_DOUBLE(__PAIR64__(v146.u32[3], HIDWORD(v148))), *(float *)&v146.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v149;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_235:
            ++v24;
            v22 += 2;
            --v145;
          }
          while (v145);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 20:
        while (1)
        {
          int v150 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v151 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v151.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  LODWORD(a13) = LODWORD(a12);
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v151;
                    goto LABEL_246;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  LODWORD(a13) = 1.0;
                }
                LODWORD(a11) = v22[1].i32[0];
                DWORD2(v207) = v151.i32[3];
                *(void *)&long long v207 = vextq_s8(v151, v151, 4uLL).u64[0];
                float v152 = PDAsoftlightPDA(v22->f32[0], v22->f32[1], a11, *(int32x2_t *)&a12, a13, *(double *)v151.i64, *(double *)&v207, a16, a1, a2, a3, a4, a5, a6, a7, a8, *(float *)v151.i32, v207, *(uint64_t *)((char *)&v207 + 4),
                         *(float *)&v151.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v152;
                v22->i32[1] = v153;
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_246:
            ++v24;
            v22 += 2;
            --v150;
          }
          while (v150);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 21:
        while (1)
        {
          int v154 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v155 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v155.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v156 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v155;
                    goto LABEL_257;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v156 = 1.0;
                }
                LODWORD(a10) = v22->i32[1];
                LODWORD(a11) = v22[1].i32[0];
                *(void *)&double v157 = vextq_s8(v155, v155, 4uLL).u64[0];
                float v158 = PDAhardlightPDA(v22->f32[0], a10, a11, a12, v156, *(double *)v155.i64, v157, a16, *(float *)v155.i32, COERCE_DOUBLE(__PAIR64__(v155.u32[3], HIDWORD(v157))), *(float *)&v155.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v158;
                v22->i32[1] = LODWORD(a10);
                v22[1].i32[0] = LODWORD(a11);
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_257:
            ++v24;
            v22 += 2;
            --v154;
          }
          while (v154);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 22:
        while (1)
        {
          int v159 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float32x4_t v160 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (v160.f32[3] > 0.0)
              {
                if (v19)
                {
                  float v161 = v22[1].f32[1];
                  if (v161 <= 0.0)
                  {
                    *(float32x4_t *)v22->f32 = v160;
                    goto LABEL_270;
                  }
                }
                else
                {
                  float v161 = 1.0;
                }
                float v162 = v22[1].f32[0];
                float32x2_t v163 = vmul_laneq_f32(*v22, v160, 3);
                float32x2_t v164 = vmul_n_f32(*(float32x2_t *)v160.f32, v161);
                float32x2_t v165 = vsub_f32(vadd_f32(*v22, *(float32x2_t *)v160.f32), v163);
                float32x2_t v166 = vsub_f32(v163, v164);
                float32x2_t v167 = vadd_f32(vsub_f32(v165, v164), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v166), (int8x8_t)vneg_f32(v166), (int8x8_t)v166));
                float v168 = v162 + v160.f32[2];
                float v169 = v162 * v160.f32[3];
                float v170 = vmuls_lane_f32(v161, v160, 2);
                float v171 = v168 - v169;
                float v172 = v169 - v170;
                v160.f32[0] = v171 - v170;
                if (v172 < 0.0) {
                  float v172 = -v172;
                }
                *unint64_t v22 = v167;
                v22[1].f32[0] = v160.f32[0] + v172;
                v22[1].f32[1] = (float)(v161 + v160.f32[3]) - (float)(v161 * v160.f32[3]);
              }
            }
LABEL_270:
            ++v24;
            v22 += 2;
            --v159;
          }
          while (v159);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 23:
        float32x2_t v173 = (float32x2_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 8uLL).u64[0];
        while (1)
        {
          int v174 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float v175 = (float)*(unsigned __int8 *)v24 * 0.0039216;
              float32x2_t v176 = vmul_n_f32(v173, v175);
              if (v176.f32[1] > 0.0)
              {
                *(float32x2_t *)&long long v177 = vmul_n_f32(*(float32x2_t *)v20.f32, v175);
                if (v19)
                {
                  float v178 = v22[1].f32[1];
                  if (v178 <= 0.0)
                  {
                    *((float32x2_t *)&v177 + 1) = v176;
                    *(_OWORD *)v22->f32 = v177;
                    goto LABEL_282;
                  }
                }
                else
                {
                  float v178 = 1.0;
                }
                v179.i32[0] = v22[1].i32[0];
                v180.f32[0] = (float)-v179.f32[0] * v176.f32[0];
                float32x2_t v181 = vmla_f32(vadd_f32(*(float32x2_t *)&v177, *v22), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)&v177, *v22));
                v179.f32[1] = v178;
                v180.f32[1] = -v178;
                float32x2_t v182 = vadd_f32(v176, v179);
                v176.i32[0] = 2.0;
                *unint64_t v22 = v181;
                v22[1] = vmla_f32(v182, v176, v180);
              }
            }
LABEL_282:
            ++v24;
            v22 += 2;
            --v174;
          }
          while (v174);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 24:
        while (1)
        {
          int v183 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v184 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v184.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v185 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v184;
                    goto LABEL_293;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v185 = 1.0;
                }
                *(void *)&double v208 = vextq_s8(v184, v184, 4uLL).u64[0];
                float v186 = PDAhuePDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v185, *(double *)v184.i64, v208, a16, *(float *)v184.i32, *(float *)&v208, *((float *)&v208 + 1), *(float *)&v184.i32[3], *(float *)&v184.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v186;
                v22->i32[1] = v187;
                v22[1].i32[0] = v188;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_293:
            ++v24;
            v22 += 2;
            --v183;
          }
          while (v183);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 25:
        while (1)
        {
          int v189 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              int8x16_t v190 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              if (*(float *)&v190.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v191 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0)
                  {
                    *(int8x16_t *)v22->f32 = v190;
                    goto LABEL_304;
                  }
                }
                else
                {
                  LODWORD(a12) = v22[1].i32[1];
                  float v191 = 1.0;
                }
                *(void *)&double v209 = vextq_s8(v190, v190, 4uLL).u64[0];
                float v192 = PDAsaturationPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v191, *(double *)v190.i64, v209, a16, *(float *)v190.i32, *(float *)&v209, *((float *)&v209 + 1), *(float *)&v190.i32[3], *(float *)&v190.i32[3]);
                float32x4_t v20 = v211;
                v22->f32[0] = v192;
                v22->i32[1] = v193;
                v22[1].i32[0] = v194;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_304:
            ++v24;
            v22 += 2;
            --v189;
          }
          while (v189);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 26:
        while (1)
        {
          int v195 = v18;
          do
          {
            if (*(unsigned char *)v24)
            {
              float32x4_t v196 = vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
              LODWORD(a12) = v196.i32[3];
              if (v196.f32[3] > 0.0)
              {
                if (v19)
                {
                  float v197 = v22[1].f32[1];
                  *(float *)&a14 = v197;
                  if (v197 <= 0.0)
                  {
                    *(float32x4_t *)v22->f32 = v196;
                    goto LABEL_315;
                  }
                }
                else
                {
                  float v197 = v22[1].f32[1];
                  LODWORD(a14) = 1.0;
                }
                LODWORD(a15) = v22[1].i32[0];
                float v198 = PDAluminosityPDA(v196.f32[0], v196.f32[1], v196.f32[2], a12, v196.f32[3], a14, a15, a16, COERCE_FLOAT(*v22), COERCE_FLOAT(HIDWORD(*(unint64_t *)v22)), *(float *)&a15, v197, *(float *)&a14);
                float32x4_t v20 = v211;
                v22->f32[0] = v198;
                v22->i32[1] = v199;
                v22[1].i32[0] = v200;
                v22[1].i32[1] = LODWORD(a12);
              }
            }
LABEL_315:
            ++v24;
            v22 += 2;
            --v195;
          }
          while (v195);
          v24 += v25;
          v22 += 2 * v26;
          if (!--v17) {
            return;
          }
        }
      case 27:
        break;
      default:
        return;
    }
LABEL_318:
    int v201 = v18;
    while (1)
    {
      if (!*(unsigned char *)v24) {
        goto LABEL_326;
      }
      int8x16_t v202 = (int8x16_t)vmulq_n_f32(v20, (float)*(unsigned __int8 *)v24 * 0.0039216);
      if (*(float *)&v202.i32[3] <= 0.0) {
        goto LABEL_326;
      }
      if (!v19) {
        break;
      }
      LODWORD(a12) = v22[1].i32[1];
      float v203 = *(float *)&a12;
      if (*(float *)&a12 > 0.0) {
        goto LABEL_325;
      }
      *(int8x16_t *)v22->f32 = v202;
LABEL_326:
      ++v24;
      v22 += 2;
      if (!--v201)
      {
        v24 += v25;
        v22 += 2 * v26;
        if (!--v17) {
          return;
        }
        goto LABEL_318;
      }
    }
    LODWORD(a12) = v22[1].i32[1];
    float v203 = 1.0;
LABEL_325:
    *(void *)&double v210 = vextq_s8(v202, v202, 4uLL).u64[0];
    float v204 = PDAluminosityPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a12, v203, *(double *)v202.i64, v210, a16, *(float *)v202.i32, *(float *)&v210, *((float *)&v210 + 1), *(float *)&v202.i32[3], *(float *)&v202.i32[3]);
    float32x4_t v20 = v211;
    v22->f32[0] = v204;
    v22->i32[1] = v205;
    v22[1].i32[0] = v206;
    v22[1].i32[1] = LODWORD(a12);
    goto LABEL_326;
  }
}

void RGBAf_mark_pixelmask(_DWORD *a1, int *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  double v12 = a1;
  int v489 = a2[2];
  unint64_t v13 = a2[7];
  uint64_t v14 = *((void *)a2 + 5);
  uint64_t v15 = *((void *)a2 + 6);
  unint64_t v16 = *((void *)a2 + 11);
  uint64_t v17 = *((void *)a2 + 12);
  uint64_t v18 = *((void *)a2 + 17);
  int v19 = *a2;
  int v488 = a2[1];
  if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken != -1)
  {
    uint64_t v459 = a3;
    dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::onceToken, &__block_literal_global_9_13630);
    a3 = v459;
    double v12 = a1;
  }
  BOOL v20 = v15 != 0;
  if (v18)
  {
    unint64_t v21 = v13 >> 4;
    unint64_t v22 = (float32x2_t *)(v14 + 16 * (a2[3] + (v13 >> 4) * a2[4]));
    uint64_t v23 = a2[31];
    unint64_t v24 = (char *)(v18 + a2[26] + a2[27] * (uint64_t)(int)v23);
    uint64_t v25 = a2[14];
    uint64_t v26 = a2[15];
    unint64_t v27 = a2[19];
    if ((v19 & 0xFF00) != 0x100)
    {
      uint64_t v34 = a2[16];
      uint64_t v35 = a2[17];
      uint64_t v28 = v27 >> 4;
      unint64_t v36 = v16 + 16 * (v27 >> 4) * v35;
      int v33 = 1;
      unsigned int v37 = (float32x4_t *)v16;
      int v29 = (float32x4_t *)v16;
      int v30 = v488;
      goto LABEL_15;
    }
    uint64_t v28 = v27 >> 4;
    int v29 = (float32x4_t *)(v16 + 16 * (v25 + (v27 >> 4) * v26));
    int v30 = v488;
    if (v27 >> 4 != v21)
    {
      int v33 = 1;
LABEL_14:
      unint64_t v36 = 0;
      unsigned int v37 = 0;
      uint64_t v35 = 0;
      unint64_t v16 = -1;
      uint64_t v34 = v28;
LABEL_15:
      BOOL v38 = v17 != 0;
      int v39 = v33 * v30;
      if (v36)
      {
        float32x4_t v40 = &v29[v28 * ((int)v26 % (int)v35)];
        unsigned int v37 = &v40[(int)v25 % (int)v34];
        unint64_t v16 = (unint64_t)&v40[(int)v34];
        int v29 = v37;
      }
      else
      {
        v28 -= v39;
      }
      uint64_t v41 = v23 - v39;
      uint64_t v42 = v21 - v39;
      uint64_t v474 = v42;
      uint64_t v475 = v28;
      uint64_t v472 = v41;
      unint64_t v473 = v36;
      switch((int)a3)
      {
        case 0:
          do
          {
            int v43 = v488;
            do
            {
              unsigned int v44 = *v24;
              if (*v24)
              {
                if (v44 == 255)
                {
                  *unint64_t v22 = 0;
                  v22[1] = 0;
                }
                else
                {
                  *(float32x4_t *)v22->f32 = vmulq_n_f32(*(float32x4_t *)v22->f32, (float)((float)v44 * -0.0039216) + 1.0);
                }
              }
              v24 += v33;
              v22 += 2 * v33;
              --v43;
            }
            while (v43);
            v24 += v41;
            v22 += 2 * v42;
            --v489;
          }
          while (v489);
          return;
        case 1:
          if (!v15 || v17)
          {
            do
            {
              int v449 = v488;
              do
              {
                unsigned int v450 = *v24;
                if (*v24)
                {
                  if (v450 == 255) {
                    float32x4_t v451 = *v29;
                  }
                  else {
                    float32x4_t v451 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - (float)((float)v450 * 0.0039216)), *v29, (float)v450 * 0.0039216);
                  }
                  *(float32x4_t *)v22->f32 = v451;
                }
                v24 += v33;
                uint64_t v452 = &v29[v33];
                if ((unint64_t)v452 >= v16) {
                  uint64_t v453 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v453 = 0;
                }
                int v29 = &v452[v453];
                v22 += 2 * v33;
                --v449;
              }
              while (v449);
              v24 += v41;
              v22 += 2 * v42;
              uint64_t v454 = &v37[v28];
              if ((unint64_t)v454 >= v36) {
                uint64_t v455 = -(v28 * (int)v35);
              }
              else {
                uint64_t v455 = 0;
              }
              uint64_t v456 = &v454[v455];
              uint64_t v457 = v16 + 16 * v455 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v457;
                unsigned int v37 = v456;
                int v29 = v456;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          else
          {
            do
            {
              int v45 = v488;
              do
              {
                unsigned int v46 = *v24;
                if (*v24)
                {
                  if (v46 == 255)
                  {
                    *unint64_t v22 = *(float32x2_t *)v29->f32;
                    v22[1].i32[0] = v29->i32[2];
                    v22[1].i32[1] = 1065353216;
                  }
                  else
                  {
                    float v47 = (float)v46 * 0.0039216;
                    *unint64_t v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v47), *v22, 1.0 - v47);
                    float32_t v48 = (float)(v47 * v29->f32[2]) + (float)(v22[1].f32[0] * (float)(1.0 - v47));
                    float32_t v49 = v47 + (float)(v22[1].f32[1] * (float)(1.0 - v47));
                    v22[1].f32[0] = v48;
                    v22[1].f32[1] = v49;
                  }
                }
                v24 += v33;
                unsigned int v50 = &v29[v33];
                if ((unint64_t)v50 >= v16) {
                  uint64_t v51 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v51 = 0;
                }
                int v29 = &v50[v51];
                v22 += 2 * v33;
                --v45;
              }
              while (v45);
              v24 += v41;
              v22 += 2 * v42;
              float32x4_t v52 = &v37[v28];
              if ((unint64_t)v52 >= v36) {
                uint64_t v53 = -(v28 * (int)v35);
              }
              else {
                uint64_t v53 = 0;
              }
              unsigned int v54 = &v52[v53];
              uint64_t v55 = v16 + 16 * v53 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v55;
                unsigned int v37 = v54;
                int v29 = v54;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 2:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)2,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
            return;
          }
          while (1)
          {
            int v129 = v488;
            do
            {
              unsigned int v130 = *v24;
              if (!*v24) {
                goto LABEL_216;
              }
              if (v130 == 255)
              {
                float v131 = v29->f32[3];
                if (v131 >= 1.0)
                {
                  *unint64_t v22 = *(float32x2_t *)v29->f32;
                  v22[1].i32[0] = v29->i32[2];
                  v22[1].f32[1] = v131;
                }
                else if (v131 > 0.0)
                {
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(*v29, *(float32x4_t *)v22->f32, 1.0 - v131);
                }
              }
              else
              {
                float32x4_t v132 = vmulq_n_f32(*v29, (float)v130 * 0.0039216);
                if (v132.f32[3] < 1.0)
                {
                  if (v132.f32[3] <= 0.0) {
                    goto LABEL_216;
                  }
                  float32x4_t v132 = vmlaq_n_f32(v132, *(float32x4_t *)v22->f32, 1.0 - v132.f32[3]);
                }
                *(float32x4_t *)v22->f32 = v132;
              }
LABEL_216:
              v24 += v33;
              double v133 = &v29[v33];
              if ((unint64_t)v133 >= v16) {
                uint64_t v134 = -(uint64_t)(int)v34;
              }
              else {
                uint64_t v134 = 0;
              }
              int v29 = &v133[v134];
              v22 += 2 * v33;
              --v129;
            }
            while (v129);
            v24 += v41;
            v22 += 2 * v42;
            int v135 = &v37[v28];
            if ((unint64_t)v135 >= v36) {
              uint64_t v136 = -(v28 * (int)v35);
            }
            else {
              uint64_t v136 = 0;
            }
            float v137 = &v135[v136];
            uint64_t v138 = v16 + 16 * v136 + 16 * v28;
            if (v36)
            {
              unint64_t v16 = v138;
              unsigned int v37 = v137;
              int v29 = v137;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489) {
              return;
            }
          }
        case 3:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)3,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              int v139 = v488;
              do
              {
                unsigned int v140 = *v24;
                if (*v24)
                {
                  if (v140 == 255)
                  {
                    float v141 = v22[1].f32[1];
                    *unint64_t v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v141);
                    v22[1].f32[0] = v141 * v29->f32[2];
                    if (v17) {
                      float v142 = v29->f32[3];
                    }
                    else {
                      float v142 = 1.0;
                    }
                    float v149 = v141 * v142;
                  }
                  else
                  {
                    float v143 = (float)v140 * 0.0039216;
                    float v144 = 1.0;
                    float v145 = 1.0 - v143;
                    float v147 = v22[1].f32[0];
                    float v146 = v22[1].f32[1];
                    float v148 = v143 * v146;
                    *unint64_t v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v148), *v22, v145);
                    v22[1].f32[0] = (float)(v148 * v29->f32[2]) + (float)(v147 * v145);
                    if (v17) {
                      float v144 = v29->f32[3];
                    }
                    float v149 = (float)(v148 * v144) + (float)(v146 * v145);
                  }
                  v22[1].f32[1] = v149;
                }
                v24 += v33;
                int v150 = &v29[v33];
                if ((unint64_t)v150 >= v16) {
                  uint64_t v151 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v151 = 0;
                }
                int v29 = &v150[v151];
                v22 += 2 * v33;
                --v139;
              }
              while (v139);
              v24 += v41;
              v22 += 2 * v42;
              float v152 = &v37[v28];
              if ((unint64_t)v152 >= v36) {
                uint64_t v153 = -(v28 * (int)v35);
              }
              else {
                uint64_t v153 = 0;
              }
              int v154 = &v152[v153];
              uint64_t v155 = v16 + 16 * v153 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v155;
                unsigned int v37 = v154;
                int v29 = v154;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 4:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)4,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              int v156 = v488;
              do
              {
                unsigned int v157 = *v24;
                if (*v24)
                {
                  if (v157 == 255)
                  {
                    float v158 = 1.0;
                    float v159 = 1.0 - v22[1].f32[1];
                    *unint64_t v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v159);
                    v22[1].f32[0] = v159 * v29->f32[2];
                    if (v17) {
                      float v158 = v29->f32[3];
                    }
                    float v160 = v159 * v158;
                  }
                  else
                  {
                    float v161 = (float)v157 * 0.0039216;
                    float v162 = 1.0;
                    float v163 = 1.0 - v161;
                    float v165 = v22[1].f32[0];
                    float v164 = v22[1].f32[1];
                    float v166 = v161 * (float)(1.0 - v164);
                    *unint64_t v22 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v166), *v22, v163);
                    v22[1].f32[0] = (float)(v166 * v29->f32[2]) + (float)(v165 * v163);
                    if (v17) {
                      float v162 = v29->f32[3];
                    }
                    float v160 = (float)(v166 * v162) + (float)(v164 * v163);
                  }
                  v22[1].f32[1] = v160;
                }
                v24 += v33;
                float32x2_t v167 = &v29[v33];
                if ((unint64_t)v167 >= v16) {
                  uint64_t v168 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v168 = 0;
                }
                int v29 = &v167[v168];
                v22 += 2 * v33;
                --v156;
              }
              while (v156);
              v24 += v41;
              v22 += 2 * v42;
              float v169 = &v37[v28];
              if ((unint64_t)v169 >= v36) {
                uint64_t v170 = -(v28 * (int)v35);
              }
              else {
                uint64_t v170 = 0;
              }
              float v171 = &v169[v170];
              uint64_t v172 = v16 + 16 * v170 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v172;
                unsigned int v37 = v171;
                int v29 = v171;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 5:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)5,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              int v173 = v488;
              do
              {
                if (*v24)
                {
                  float32x4_t v174 = vmulq_n_f32(*v29, (float)*v24 * 0.0039216);
                  *(float32x4_t *)v22->f32 = vmlaq_laneq_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v174.f32[3]), v174, *(float32x4_t *)v22->f32, 3);
                }
                v24 += v33;
                float v175 = &v29[v33];
                if ((unint64_t)v175 >= v16) {
                  uint64_t v176 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v176 = 0;
                }
                int v29 = &v175[v176];
                v22 += 2 * v33;
                --v173;
              }
              while (v173);
              v24 += v41;
              v22 += 2 * v42;
              long long v177 = &v37[v28];
              if ((unint64_t)v177 >= v36) {
                uint64_t v178 = -(v28 * (int)v35);
              }
              else {
                uint64_t v178 = 0;
              }
              float32x2_t v179 = &v177[v178];
              uint64_t v180 = v16 + 16 * v178 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v180;
                unsigned int v37 = v179;
                int v29 = v179;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 6:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)6,_rgbaf_t>((int32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
            return;
          }
          while (1)
          {
            int v181 = v488;
            do
            {
              unsigned int v182 = *v24;
              if (!*v24) {
                goto LABEL_301;
              }
              float v183 = v22[1].f32[1];
              float v184 = 1.0 - v183;
              if ((float)(1.0 - v183) >= 1.0)
              {
                float v187 = (float)v182 * 0.0039216;
                *unint64_t v22 = vmul_n_f32(*(float32x2_t *)v29->f32, v187);
                v22[1].f32[0] = v187 * v29->f32[2];
                if (v17) {
                  float v188 = v29->f32[3];
                }
                else {
                  float v188 = 1.0;
                }
                float v189 = v187 * v188;
              }
              else
              {
                if (v184 <= 0.0) {
                  goto LABEL_301;
                }
                float v185 = (float)((float)v182 * 0.0039216) * v184;
                *unint64_t v22 = vmla_n_f32(*v22, *(float32x2_t *)v29->f32, v185);
                v22[1].f32[0] = v22[1].f32[0] + (float)(v29->f32[2] * v185);
                if (v17) {
                  float v186 = v29->f32[3];
                }
                else {
                  float v186 = 1.0;
                }
                float v189 = v183 + (float)(v186 * v185);
              }
              v22[1].f32[1] = v189;
LABEL_301:
              v24 += v33;
              int8x16_t v190 = &v29[v33];
              if ((unint64_t)v190 >= v16) {
                uint64_t v191 = -(uint64_t)(int)v34;
              }
              else {
                uint64_t v191 = 0;
              }
              int v29 = &v190[v191];
              v22 += 2 * v33;
              --v181;
            }
            while (v181);
            v24 += v41;
            v22 += 2 * v42;
            float v192 = &v37[v28];
            if ((unint64_t)v192 >= v36) {
              uint64_t v193 = -(v28 * (int)v35);
            }
            else {
              uint64_t v193 = 0;
            }
            __int32 v194 = &v192[v193];
            uint64_t v195 = v16 + 16 * v193 + 16 * v28;
            if (v36)
            {
              unint64_t v16 = v195;
              unsigned int v37 = v194;
              int v29 = v194;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489) {
              return;
            }
          }
        case 7:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)7,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              int v196 = v488;
              do
              {
                unsigned int v197 = *v24;
                if (*v24)
                {
                  if (v197 == 255) {
                    float32x4_t v198 = vmulq_n_f32(*(float32x4_t *)v22->f32, v29->f32[3]);
                  }
                  else {
                    float32x4_t v198 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - (float)((float)v197 * 0.0039216)), *(float32x4_t *)v22->f32, (float)((float)v197 * 0.0039216) * v29->f32[3]);
                  }
                  *(float32x4_t *)v22->f32 = v198;
                }
                v24 += v33;
                __int32 v199 = &v29[v33];
                if ((unint64_t)v199 >= v16) {
                  uint64_t v200 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v200 = 0;
                }
                int v29 = &v199[v200];
                v22 += 2 * v33;
                --v196;
              }
              while (v196);
              v24 += v41;
              v22 += 2 * v42;
              int v201 = &v37[v28];
              if ((unint64_t)v201 >= v36) {
                uint64_t v202 = -(v28 * (int)v35);
              }
              else {
                uint64_t v202 = 0;
              }
              float v203 = &v201[v202];
              uint64_t v204 = v16 + 16 * v202 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v204;
                unsigned int v37 = v203;
                int v29 = v203;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 8:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)8,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              int v205 = v488;
              do
              {
                unsigned int v206 = *v24;
                if (*v24)
                {
                  if (v206 == 255)
                  {
                    float v207 = 1.0 - v29->f32[3];
                    v22->f32[0] = v22->f32[0] * v207;
                    double v208 = (float *)v22 + 1;
                    float v209 = v22->f32[1];
                    float v210 = v207;
                  }
                  else
                  {
                    float v209 = (float)((float)((float)v206 * -0.0039216) * v29->f32[3]) + 1.0;
                    v22->f32[0] = v22->f32[0] * v209;
                    double v208 = (float *)v22 + 1;
                    float v207 = v22->f32[1];
                    float v210 = v209;
                  }
                  *double v208 = v207 * v209;
                  v22[1] = vmul_n_f32(v22[1], v210);
                }
                v24 += v33;
                v22 += 2 * v33;
                float32x4_t v211 = &v29[v33];
                if ((unint64_t)v211 >= v16) {
                  uint64_t v212 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v212 = 0;
                }
                int v29 = &v211[v212];
                --v205;
              }
              while (v205);
              v24 += v41;
              v22 += 2 * v42;
              unint64_t v213 = &v37[v28];
              if ((unint64_t)v213 >= v36) {
                uint64_t v214 = -(v28 * (int)v35);
              }
              else {
                uint64_t v214 = 0;
              }
              long long v215 = &v213[v214];
              uint64_t v216 = v16 + 16 * v214 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v216;
                unsigned int v37 = v215;
                int v29 = v215;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 9:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)9,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              int v217 = v488;
              do
              {
                if (*v24)
                {
                  float v218 = (float)*v24 * 0.0039216;
                  float v219 = 1.0 - v218;
                  float32x4_t v220 = vmulq_n_f32(*v29, v218);
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, v219 + v220.f32[3]), v220, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
                }
                v24 += v33;
                unint64_t v221 = &v29[v33];
                if ((unint64_t)v221 >= v16) {
                  uint64_t v222 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v222 = 0;
                }
                int v29 = &v221[v222];
                v22 += 2 * v33;
                --v217;
              }
              while (v217);
              v24 += v41;
              v22 += 2 * v42;
              uint64_t v223 = &v37[v28];
              if ((unint64_t)v223 >= v36) {
                uint64_t v224 = -(v28 * (int)v35);
              }
              else {
                uint64_t v224 = 0;
              }
              int v225 = &v223[v224];
              uint64_t v226 = v16 + 16 * v224 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v226;
                unsigned int v37 = v225;
                int v29 = v225;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 10:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)10,_rgbaf_t>((float32x4_t *)v22, v42, v29, v28, v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, *v12);
          }
          else
          {
            do
            {
              int v227 = v488;
              do
              {
                if (*v24)
                {
                  float32x4_t v228 = vmulq_n_f32(*v29, (float)*v24 * 0.0039216);
                  *(float32x4_t *)v22->f32 = vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)v22->f32, 1.0 - v228.f32[3]), v228, 1.0 - COERCE_FLOAT(HIDWORD(*(_OWORD *)v22->f32)));
                }
                v24 += v33;
                unint64_t v229 = &v29[v33];
                if ((unint64_t)v229 >= v16) {
                  uint64_t v230 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v230 = 0;
                }
                int v29 = &v229[v230];
                v22 += 2 * v33;
                --v227;
              }
              while (v227);
              v24 += v41;
              v22 += 2 * v42;
              v231 = &v37[v28];
              if ((unint64_t)v231 >= v36) {
                uint64_t v232 = -(v28 * (int)v35);
              }
              else {
                uint64_t v232 = 0;
              }
              float32x4_t v233 = &v231[v232];
              uint64_t v234 = v16 + 16 * v232 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v234;
                unsigned int v37 = v233;
                int v29 = v233;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 11:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)11,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
          }
          else
          {
            do
            {
              int v235 = v488;
              do
              {
                if (*v24)
                {
                  float v236 = (float)*v24 * 0.0039216;
                  float v237 = v236 * v29->f32[0];
                  float v238 = v29->f32[3];
                  if (v15)
                  {
                    float v239 = v22[1].f32[1];
                    if (!v17) {
                      float v238 = 1.0;
                    }
                    float v240 = v236 * v238;
                    float v241 = (float)(v240 - v237) + (float)(v239 - v22->f32[0]);
                    if ((float)(v240 + v239) <= 1.0) {
                      float v242 = v240 + v239;
                    }
                    else {
                      float v242 = 1.0;
                    }
                  }
                  else
                  {
                    float v239 = 1.0;
                    if (!v17) {
                      float v238 = 1.0;
                    }
                    float v240 = v236 * v238;
                    float v241 = (float)(v240 - v237) + (float)(1.0 - v22->f32[0]);
                    if ((float)(v240 + 1.0) <= 1.0) {
                      float v242 = v240 + 1.0;
                    }
                    else {
                      float v242 = 1.0;
                    }
                  }
                  float v243 = (float)(v240 - (float)(v236 * v29->f32[1])) + (float)(v239 - v22->f32[1]);
                  float32_t v244 = v242 - v241;
                  float v245 = v29->f32[2];
                  v22->f32[0] = v244;
                  float v246 = (float)(v240 - (float)(v236 * v245)) + (float)(v239 - v22[1].f32[0]);
                  v22->f32[1] = v242 - v243;
                  v22[1].f32[0] = v242 - v246;
                  v22[1].f32[1] = v242;
                }
                v24 += v33;
                v22 += 2 * v33;
                int8x16_t v247 = &v29[v33];
                if ((unint64_t)v247 >= v16) {
                  uint64_t v248 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v248 = 0;
                }
                int v29 = &v247[v248];
                --v235;
              }
              while (v235);
              v24 += v41;
              v22 += 2 * v42;
              int8x16_t v249 = &v37[v28];
              if ((unint64_t)v249 >= v36) {
                uint64_t v250 = -(v28 * (int)v35);
              }
              else {
                uint64_t v250 = 0;
              }
              uint64_t v251 = &v249[v250];
              uint64_t v252 = v16 + 16 * v250 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v252;
                unsigned int v37 = v251;
                int v29 = v251;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 12:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)12,_rgbaf_t>((float32x4_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v38, *v12);
          }
          else
          {
            do
            {
              int v253 = v488;
              do
              {
                if (*v24)
                {
                  float v254 = (float)*v24 * 0.0039216;
                  float v255 = v29->f32[3];
                  float v256 = v254 * v29->f32[2];
                  *unint64_t v22 = vadd_f32(vmul_n_f32(*(float32x2_t *)v29->f32, v254), *v22);
                  if (!v17) {
                    float v255 = 1.0;
                  }
                  float v257 = (float)(v254 * v255) + v22[1].f32[1];
                  float v258 = v256 + v22[1].f32[0];
                  if (v257 > 1.0) {
                    float v257 = 1.0;
                  }
                  v22[1].f32[0] = v258;
                  v22[1].f32[1] = v257;
                }
                v24 += v33;
                float32x4_t v259 = &v29[v33];
                if ((unint64_t)v259 >= v16) {
                  uint64_t v260 = -(uint64_t)(int)v34;
                }
                else {
                  uint64_t v260 = 0;
                }
                int v29 = &v259[v260];
                v22 += 2 * v33;
                --v253;
              }
              while (v253);
              v24 += v41;
              v22 += 2 * v42;
              float32x4_t v261 = &v37[v28];
              if ((unint64_t)v261 >= v36) {
                uint64_t v262 = -(v28 * (int)v35);
              }
              else {
                uint64_t v262 = 0;
              }
              float32x4_t v263 = &v261[v262];
              uint64_t v264 = v16 + 16 * v262 + 16 * v28;
              if (v36)
              {
                unint64_t v16 = v264;
                unsigned int v37 = v263;
                int v29 = v263;
              }
              else
              {
                v29 += v28;
              }
              --v489;
            }
            while (v489);
          }
          return;
        case 13:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)13,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v265 = v33;
          uint64_t v266 = -(uint64_t)(int)v34;
          uint64_t v464 = -(v28 * (int)v35);
          uint64_t v267 = 16 * v33;
          while (1)
          {
            float32x4_t v480 = v37;
            int v268 = v488;
            do
            {
              unsigned int v269 = *v24;
              if (*v24)
              {
                float v270 = (float)v269 * 0.0039216;
                float v271 = v29->f32[3];
                *(float *)&a10 = v270 * v271;
                *(float *)&a9 = v17 ? v270 * v271 : (float)v269 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v270 * v29->f32[0];
                  float v272 = v270 * v29->f32[1];
                  float v273 = v270 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v274 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v272;
                      v22[1].f32[0] = v273;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_436;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v274 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAmultiplyPDA(v22->f32[0], a5, a6, a7, v274, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v273))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_436:
              v24 += v265;
              uint64_t v275 = &v29[v265];
              if ((unint64_t)v275 >= v16) {
                uint64_t v276 = v266;
              }
              else {
                uint64_t v276 = 0;
              }
              int v29 = &v275[v276];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v267);
              --v268;
            }
            while (v268);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v480;
            uint64_t v277 = &v480[v475];
            uint64_t v278 = v464;
            if ((unint64_t)v277 < v473) {
              uint64_t v278 = 0;
            }
            int8x16_t v279 = &v277[v278];
            uint64_t v280 = v16 + 16 * v278 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v280;
              unsigned int v37 = v279;
              int v29 = v279;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 14:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)14,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          __asm { FMOV            V2.2S, #1.0 }
          while (1)
          {
            int v286 = v488;
            do
            {
              if (*v24)
              {
                float v287 = (float)*v24 * 0.0039216;
                float v288 = v29->f32[3];
                if (!v17) {
                  float v288 = 1.0;
                }
                float v289 = v287 * v288;
                if (v289 > 0.0)
                {
                  float32x2_t v290 = vmul_n_f32(*(float32x2_t *)v29->f32, v287);
                  float v291 = v287 * v29->f32[2];
                  if (v15)
                  {
                    float v292 = v22[1].f32[1];
                    if (v292 <= 0.0)
                    {
                      *unint64_t v22 = v290;
LABEL_458:
                      v22[1].f32[0] = v291;
                      v22[1].f32[1] = v289;
                      goto LABEL_459;
                    }
                  }
                  else
                  {
                    float v292 = 1.0;
                  }
                  float v291 = v22[1].f32[0] + (float)(v291 * (float)(1.0 - v22[1].f32[0]));
                  *unint64_t v22 = vmla_f32(*v22, vsub_f32(_D2, *v22), v290);
                  float v289 = (float)(v289 + v292) - (float)(v292 * v289);
                  goto LABEL_458;
                }
              }
LABEL_459:
              v24 += v33;
              unint64_t v293 = &v29[v33];
              if ((unint64_t)v293 >= v16) {
                uint64_t v294 = -(uint64_t)(int)v34;
              }
              else {
                uint64_t v294 = 0;
              }
              int v29 = &v293[v294];
              v22 += 2 * v33;
              --v286;
            }
            while (v286);
            v24 += v41;
            v22 += 2 * v42;
            uint64_t v295 = &v37[v28];
            if ((unint64_t)v295 >= v36) {
              uint64_t v296 = -(v28 * (int)v35);
            }
            else {
              uint64_t v296 = 0;
            }
            int v297 = &v295[v296];
            uint64_t v298 = v16 + 16 * v296 + 16 * v28;
            if (v36)
            {
              unint64_t v16 = v298;
              unsigned int v37 = v297;
              int v29 = v297;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489) {
              return;
            }
          }
        case 15:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)15,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v299 = v33;
          uint64_t v300 = -(uint64_t)(int)v34;
          uint64_t v465 = -(v28 * (int)v35);
          uint64_t v301 = 16 * v33;
          while (1)
          {
            int8x16_t v481 = v37;
            int v302 = v488;
            do
            {
              unsigned int v303 = *v24;
              if (*v24)
              {
                float v304 = (float)v303 * 0.0039216;
                float v305 = v29->f32[3];
                *(float *)&a10 = v304 * v305;
                *(float *)&a9 = v17 ? v304 * v305 : (float)v303 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v304 * v29->f32[0];
                  float v306 = v304 * v29->f32[1];
                  float v307 = v304 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v308 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v306;
                      v22[1].f32[0] = v307;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_483;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v308 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAoverlayPDA(v22->f32[0], a5, a6, a7, v308, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v307))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_483:
              v24 += v299;
              unint64_t v309 = &v29[v299];
              if ((unint64_t)v309 >= v16) {
                uint64_t v310 = v300;
              }
              else {
                uint64_t v310 = 0;
              }
              int v29 = &v309[v310];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v301);
              --v302;
            }
            while (v302);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v481;
            v311 = &v481[v475];
            uint64_t v312 = v465;
            if ((unint64_t)v311 < v473) {
              uint64_t v312 = 0;
            }
            float32x4_t v313 = &v311[v312];
            uint64_t v314 = v16 + 16 * v312 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v314;
              unsigned int v37 = v313;
              int v29 = v313;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 16:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)16,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v315 = v33;
          uint64_t v316 = -(uint64_t)(int)v34;
          uint64_t v466 = -(v28 * (int)v35);
          uint64_t v317 = 16 * v33;
          while (1)
          {
            float32x4_t v482 = v37;
            int v318 = v488;
            do
            {
              unsigned int v319 = *v24;
              if (*v24)
              {
                float v320 = (float)v319 * 0.0039216;
                float v321 = v29->f32[3];
                *(float *)&a10 = v320 * v321;
                *(float *)&a9 = v17 ? v320 * v321 : (float)v319 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v320 * v29->f32[0];
                  float v322 = v320 * v29->f32[1];
                  float v323 = v320 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v324 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v322;
                      v22[1].f32[0] = v323;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_506;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v324 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAdarkenPDA(v22->f32[0], a5, a6, a7, v324, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v323))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_506:
              v24 += v315;
              uint64_t v325 = &v29[v315];
              if ((unint64_t)v325 >= v16) {
                uint64_t v326 = v316;
              }
              else {
                uint64_t v326 = 0;
              }
              int v29 = &v325[v326];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v317);
              --v318;
            }
            while (v318);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v482;
            unsigned int v327 = &v482[v475];
            uint64_t v328 = v466;
            if ((unint64_t)v327 < v473) {
              uint64_t v328 = 0;
            }
            int8x16_t v329 = &v327[v328];
            uint64_t v330 = v16 + 16 * v328 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v330;
              unsigned int v37 = v329;
              int v29 = v329;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 17:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)17,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v331 = v33;
          uint64_t v332 = -(uint64_t)(int)v34;
          uint64_t v467 = -(v28 * (int)v35);
          uint64_t v333 = 16 * v33;
          while (1)
          {
            float32x4_t v483 = v37;
            int v334 = v488;
            do
            {
              unsigned int v335 = *v24;
              if (*v24)
              {
                float v336 = (float)v335 * 0.0039216;
                float v337 = v29->f32[3];
                *(float *)&a10 = v336 * v337;
                *(float *)&a9 = v17 ? v336 * v337 : (float)v335 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v336 * v29->f32[0];
                  float v338 = v336 * v29->f32[1];
                  float v339 = v336 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v340 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v338;
                      v22[1].f32[0] = v339;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_529;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v340 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAlightenPDA(v22->f32[0], a5, a6, a7, v340, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v339))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_529:
              v24 += v331;
              v341 = &v29[v331];
              if ((unint64_t)v341 >= v16) {
                uint64_t v342 = v332;
              }
              else {
                uint64_t v342 = 0;
              }
              int v29 = &v341[v342];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v333);
              --v334;
            }
            while (v334);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v483;
            float32x4_t v343 = &v483[v475];
            uint64_t v344 = v467;
            if ((unint64_t)v343 < v473) {
              uint64_t v344 = 0;
            }
            float32x4_t v345 = &v343[v344];
            uint64_t v346 = v16 + 16 * v344 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v346;
              unsigned int v37 = v345;
              int v29 = v345;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 18:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)18,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v347 = v33;
          uint64_t v348 = -(uint64_t)(int)v34;
          uint64_t v468 = -(v28 * (int)v35);
          uint64_t v349 = 16 * v33;
          while (1)
          {
            int8x16_t v484 = v37;
            int v350 = v488;
            do
            {
              unsigned int v351 = *v24;
              if (*v24)
              {
                float v352 = (float)v351 * 0.0039216;
                float v353 = v29->f32[3];
                *(float *)&a10 = v352 * v353;
                *(float *)&a9 = v17 ? v352 * v353 : (float)v351 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v352 * v29->f32[0];
                  float v354 = v352 * v29->f32[1];
                  float v355 = v352 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v356 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v354;
                      v22[1].f32[0] = v355;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_552;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v356 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAcolordodgePDA(v22->f32[0], a5, a6, a7, v356, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v355))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_552:
              v24 += v347;
              unsigned int v357 = &v29[v347];
              if ((unint64_t)v357 >= v16) {
                uint64_t v358 = v348;
              }
              else {
                uint64_t v358 = 0;
              }
              int v29 = &v357[v358];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v349);
              --v350;
            }
            while (v350);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v484;
            int8x16_t v359 = &v484[v475];
            uint64_t v360 = v468;
            if ((unint64_t)v359 < v473) {
              uint64_t v360 = 0;
            }
            int8x16_t v361 = &v359[v360];
            uint64_t v362 = v16 + 16 * v360 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v362;
              unsigned int v37 = v361;
              int v29 = v361;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 19:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)19,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v363 = v33;
          uint64_t v364 = -(uint64_t)(int)v34;
          uint64_t v469 = -(v28 * (int)v35);
          uint64_t v365 = 16 * v33;
          while (1)
          {
            float32x4_t v485 = v37;
            int v366 = v488;
            do
            {
              unsigned int v367 = *v24;
              if (*v24)
              {
                float v368 = (float)v367 * 0.0039216;
                float v369 = v29->f32[3];
                *(float *)&a10 = v368 * v369;
                *(float *)&a9 = v17 ? v368 * v369 : (float)v367 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v368 * v29->f32[0];
                  float v370 = v368 * v29->f32[1];
                  float v371 = v368 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v372 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v370;
                      v22[1].f32[0] = v371;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_575;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v372 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAcolorburnPDA(v22->f32[0], a5, a6, a7, v372, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v371))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_575:
              v24 += v363;
              v373 = &v29[v363];
              if ((unint64_t)v373 >= v16) {
                uint64_t v374 = v364;
              }
              else {
                uint64_t v374 = 0;
              }
              int v29 = &v373[v374];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v365);
              --v366;
            }
            while (v366);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v485;
            float32x4_t v375 = &v485[v475];
            uint64_t v376 = v469;
            if ((unint64_t)v375 < v473) {
              uint64_t v376 = 0;
            }
            float32x4_t v377 = &v375[v376];
            uint64_t v378 = v16 + 16 * v376 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v378;
              unsigned int v37 = v377;
              int v29 = v377;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 20:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)20,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v379 = v33;
          uint64_t v380 = -(uint64_t)(int)v34;
          uint64_t v470 = -(v28 * (int)v35);
          uint64_t v381 = 16 * v33;
          while (1)
          {
            float32x4_t v486 = v37;
            int v382 = v488;
            do
            {
              unsigned int v383 = *v24;
              if (*v24)
              {
                float v384 = (float)v383 * 0.0039216;
                float v385 = v29->f32[3];
                *(float *)&a9 = v17 ? v384 * v385 : (float)v383 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v384 * v29->f32[0];
                  float v386 = v384 * v29->f32[1];
                  float v387 = v384 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    LODWORD(a8) = LODWORD(a7);
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v386;
                      v22[1].f32[0] = v387;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_598;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    LODWORD(a8) = 1.0;
                  }
                  LODWORD(a6) = v22[1].i32[0];
                  *(float *)&a10 = v384 * v385;
                  v22->f32[0] = PDAsoftlightPDA(v22->f32[0], v22->f32[1], a6, *(int32x2_t *)&a7, a8, a9, a10, a11, v36, v42, a3, v28, (uint64_t)v37, v35, v34, (uint64_t)v12, *(float *)&a11, LODWORD(v386), __SPAIR64__(LODWORD(a10), LODWORD(v387)),
                                  *(float *)&a9);
                  v22->i32[1] = v388;
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_598:
              v24 += v379;
              float32x4_t v389 = &v29[v379];
              if ((unint64_t)v389 >= v16) {
                uint64_t v390 = v380;
              }
              else {
                uint64_t v390 = 0;
              }
              int v29 = &v389[v390];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v381);
              --v382;
            }
            while (v382);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v486;
            int8x16_t v391 = &v486[v475];
            uint64_t v392 = v470;
            if ((unint64_t)v391 < v473) {
              uint64_t v392 = 0;
            }
            unint64_t v393 = &v391[v392];
            uint64_t v394 = v16 + 16 * v392 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v394;
              unsigned int v37 = v393;
              int v29 = v393;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 21:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)21,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          uint64_t v395 = v33;
          uint64_t v396 = -(uint64_t)(int)v34;
          uint64_t v471 = -(v28 * (int)v35);
          uint64_t v397 = 16 * v33;
          while (1)
          {
            float32x4_t v487 = v37;
            int v398 = v488;
            do
            {
              unsigned int v399 = *v24;
              if (*v24)
              {
                float v400 = (float)v399 * 0.0039216;
                float v401 = v29->f32[3];
                *(float *)&a10 = v400 * v401;
                *(float *)&a9 = v17 ? v400 * v401 : (float)v399 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v400 * v29->f32[0];
                  float v402 = v400 * v29->f32[1];
                  float v403 = v400 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v404 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v402;
                      v22[1].f32[0] = v403;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_621;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v404 = 1.0;
                  }
                  LODWORD(a5) = v22->i32[1];
                  LODWORD(a6) = v22[1].i32[0];
                  v22->f32[0] = PDAhardlightPDA(v22->f32[0], a5, a6, a7, v404, a9, a10, a11, *(float *)&a11, COERCE_DOUBLE(__PAIR64__(LODWORD(a10), LODWORD(v403))), *(float *)&a9);
                  v22->i32[1] = LODWORD(a5);
                  v22[1].i32[0] = LODWORD(a6);
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_621:
              v24 += v395;
              unsigned int v405 = &v29[v395];
              if ((unint64_t)v405 >= v16) {
                uint64_t v406 = v396;
              }
              else {
                uint64_t v406 = 0;
              }
              int v29 = &v405[v406];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v397);
              --v398;
            }
            while (v398);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v487;
            int8x16_t v407 = &v487[v475];
            uint64_t v408 = v471;
            if ((unint64_t)v407 < v473) {
              uint64_t v408 = 0;
            }
            unint64_t v409 = &v407[v408];
            uint64_t v410 = v16 + 16 * v408 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v410;
              unsigned int v37 = v409;
              int v29 = v409;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 22:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)22,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          while (1)
          {
            int v411 = v488;
            do
            {
              if (*v24)
              {
                float v412 = (float)*v24 * 0.0039216;
                float v413 = v29->f32[3];
                if (!v17) {
                  float v413 = 1.0;
                }
                float v414 = v412 * v413;
                if (v414 > 0.0)
                {
                  float32x2_t v415 = vmul_n_f32(*(float32x2_t *)v29->f32, v412);
                  float v416 = v412 * v29->f32[2];
                  if (v15)
                  {
                    float v417 = v22[1].f32[1];
                    if (v417 <= 0.0)
                    {
                      *unint64_t v22 = v415;
LABEL_644:
                      v22[1].f32[0] = v416;
                      v22[1].f32[1] = v414;
                      goto LABEL_645;
                    }
                  }
                  else
                  {
                    float v417 = 1.0;
                  }
                  float v418 = v22[1].f32[0];
                  float32x2_t v419 = vadd_f32(*v22, v415);
                  float32x2_t v420 = vmul_n_f32(*v22, v414);
                  float32x2_t v421 = vmul_n_f32(v415, v417);
                  float32x2_t v422 = vsub_f32(v419, v420);
                  float32x2_t v423 = vsub_f32(v420, v421);
                  float32x2_t v424 = vadd_f32(vsub_f32(v422, v421), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v423), (int8x8_t)vneg_f32(v423), (int8x8_t)v423));
                  v423.f32[0] = v418 + v416;
                  float v425 = v418 * v414;
                  float v426 = v416 * v417;
                  v423.f32[0] = v423.f32[0] - v425;
                  float v427 = v425 - v426;
                  float v428 = v423.f32[0] - v426;
                  float v429 = -v427;
                  if (v427 >= 0.0) {
                    float v429 = v427;
                  }
                  float v416 = v428 + v429;
                  *unint64_t v22 = v424;
                  float v414 = (float)(v417 + v414) - (float)(v417 * v414);
                  goto LABEL_644;
                }
              }
LABEL_645:
              v24 += v33;
              int8x16_t v430 = &v29[v33];
              if ((unint64_t)v430 >= v16) {
                uint64_t v431 = -(uint64_t)(int)v34;
              }
              else {
                uint64_t v431 = 0;
              }
              int v29 = &v430[v431];
              v22 += 2 * v33;
              --v411;
            }
            while (v411);
            v24 += v41;
            v22 += 2 * v42;
            int8x16_t v432 = &v37[v28];
            if ((unint64_t)v432 >= v36) {
              uint64_t v433 = -(v28 * (int)v35);
            }
            else {
              uint64_t v433 = 0;
            }
            unsigned int v434 = &v432[v433];
            uint64_t v435 = v16 + 16 * v433 + 16 * v28;
            if (v36)
            {
              unint64_t v16 = v435;
              unsigned int v37 = v434;
              int v29 = v434;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489) {
              return;
            }
          }
        case 23:
          if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodFP>(void)::result && a2[33])
          {
            composite_pixelmask<(CGCompositeOperation)23,_rgbaf_t>((int8x16_t *)v22, v42, (int8x16_t *)v29, v28, (int8x16_t *)v37, v35, v34, v16, v36, v24, v41, v488, v489, v33, v20, v38, *v12);
            return;
          }
          while (1)
          {
            int v436 = v488;
            do
            {
              if (*v24)
              {
                float v437 = (float)*v24 * 0.0039216;
                float v438 = v29->f32[3];
                if (!v17) {
                  float v438 = 1.0;
                }
                float v439 = v437 * v438;
                if (v439 > 0.0)
                {
                  float32x2_t v440 = vmul_n_f32(*(float32x2_t *)v29->f32, v437);
                  float v441 = v437 * v29->f32[2];
                  if (v15)
                  {
                    float v442 = v22[1].f32[1];
                    if (v442 <= 0.0)
                    {
                      *unint64_t v22 = v440;
LABEL_667:
                      v22[1].f32[0] = v441;
                      v22[1].f32[1] = v439;
                      goto LABEL_668;
                    }
                  }
                  else
                  {
                    float v442 = 1.0;
                  }
                  float v441 = (float)(v441 + v22[1].f32[0]) + (float)((float)(v441 * v22[1].f32[0]) * -2.0);
                  *unint64_t v22 = vmla_f32(vadd_f32(v440, *v22), (float32x2_t)0xC0000000C0000000, vmul_f32(v440, *v22));
                  float v439 = (float)(v439 + v442) - (float)(v442 * v439);
                  goto LABEL_667;
                }
              }
LABEL_668:
              v24 += v33;
              v443 = &v29[v33];
              if ((unint64_t)v443 >= v16) {
                uint64_t v444 = -(uint64_t)(int)v34;
              }
              else {
                uint64_t v444 = 0;
              }
              int v29 = &v443[v444];
              v22 += 2 * v33;
              --v436;
            }
            while (v436);
            v24 += v41;
            v22 += 2 * v42;
            float32x4_t v445 = &v37[v28];
            if ((unint64_t)v445 >= v36) {
              uint64_t v446 = -(v28 * (int)v35);
            }
            else {
              uint64_t v446 = 0;
            }
            float32x4_t v447 = &v445[v446];
            uint64_t v448 = v16 + 16 * v446 + 16 * v28;
            if (v36)
            {
              unint64_t v16 = v448;
              unsigned int v37 = v447;
              int v29 = v447;
            }
            else
            {
              v29 += v28;
            }
            if (!--v489) {
              return;
            }
          }
        case 24:
          uint64_t v56 = v33;
          uint64_t v57 = -(uint64_t)(int)v34;
          uint64_t v460 = -(v28 * (int)v35);
          uint64_t v58 = 16 * v33;
          while (1)
          {
            float32x4_t v476 = v37;
            int v59 = v488;
            do
            {
              unsigned int v60 = *v24;
              if (*v24)
              {
                float v61 = (float)v60 * 0.0039216;
                float v62 = v29->f32[3];
                *(float *)&a9 = v17 ? v61 * v62 : (float)v60 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v61 * v29->f32[0];
                  float v63 = v61 * v29->f32[1];
                  float v64 = v61 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v65 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v63;
                      v22[1].f32[0] = v64;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_125;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v65 = 1.0;
                  }
                  *(float *)&a10 = v61 * v62;
                  v22->f32[0] = PDAhuePDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v65, a9, a10, a11, *(float *)&a11, v63, v64, *(float *)&a10, *(float *)&a9);
                  v22->i32[1] = v66;
                  v22[1].i32[0] = v67;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_125:
              v24 += v56;
              int v68 = &v29[v56];
              if ((unint64_t)v68 >= v16) {
                uint64_t v69 = v57;
              }
              else {
                uint64_t v69 = 0;
              }
              int v29 = &v68[v69];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v58);
              --v59;
            }
            while (v59);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v476;
            float32x4_t v70 = &v476[v475];
            uint64_t v71 = v460;
            if ((unint64_t)v70 < v473) {
              uint64_t v71 = 0;
            }
            float32x4_t v72 = &v70[v71];
            uint64_t v73 = v16 + 16 * v71 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v73;
              unsigned int v37 = v72;
              int v29 = v72;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 25:
          uint64_t v74 = v33;
          uint64_t v75 = -(uint64_t)(int)v34;
          uint64_t v461 = -(v28 * (int)v35);
          uint64_t v76 = 16 * v33;
          while (1)
          {
            float32x4_t v477 = v37;
            int v77 = v488;
            do
            {
              unsigned int v78 = *v24;
              if (*v24)
              {
                float v79 = (float)v78 * 0.0039216;
                float v80 = v29->f32[3];
                *(float *)&a9 = v17 ? v79 * v80 : (float)v78 * 0.0039216;
                if (*(float *)&a9 > 0.0)
                {
                  *(float *)&a11 = v79 * v29->f32[0];
                  float v81 = v79 * v29->f32[1];
                  float v82 = v79 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v83 = *(float *)&a7;
                    if (*(float *)&a7 <= 0.0)
                    {
                      v22->i32[0] = LODWORD(a11);
                      v22->f32[1] = v81;
                      v22[1].f32[0] = v82;
                      v22[1].i32[1] = LODWORD(a9);
                      goto LABEL_148;
                    }
                  }
                  else
                  {
                    LODWORD(a7) = v22[1].i32[1];
                    float v83 = 1.0;
                  }
                  *(float *)&a10 = v79 * v80;
                  v22->f32[0] = PDAsaturationPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v83, a9, a10, a11, *(float *)&a11, v81, v82, *(float *)&a10, *(float *)&a9);
                  v22->i32[1] = v84;
                  v22[1].i32[0] = v85;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_148:
              v24 += v74;
              float v86 = &v29[v74];
              if ((unint64_t)v86 >= v16) {
                uint64_t v87 = v75;
              }
              else {
                uint64_t v87 = 0;
              }
              int v29 = &v86[v87];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v76);
              --v77;
            }
            while (v77);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v477;
            int v88 = &v477[v475];
            uint64_t v89 = v461;
            if ((unint64_t)v88 < v473) {
              uint64_t v89 = 0;
            }
            float v90 = &v88[v89];
            uint64_t v91 = v16 + 16 * v89 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v91;
              unsigned int v37 = v90;
              int v29 = v90;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 26:
          uint64_t v92 = v33;
          uint64_t v93 = -(uint64_t)(int)v34;
          uint64_t v462 = -(v28 * (int)v35);
          uint64_t v94 = 16 * v33;
          while (1)
          {
            int8x16_t v478 = v37;
            int v95 = v488;
            do
            {
              unsigned int v96 = *v24;
              if (*v24)
              {
                float v97 = (float)v96 * 0.0039216;
                float v98 = v29->f32[3];
                *(float *)&a7 = v97 * v98;
                float v99 = v17 ? v97 * v98 : (float)v96 * 0.0039216;
                if (v99 > 0.0)
                {
                  float v100 = v97 * v29->f32[0];
                  float v101 = v97 * v29->f32[1];
                  float v102 = v97 * v29->f32[2];
                  if (v15)
                  {
                    LODWORD(a9) = v22[1].i32[1];
                    LODWORD(a10) = LODWORD(a9);
                    if (*(float *)&a9 <= 0.0)
                    {
                      v22->f32[0] = v100;
                      v22->f32[1] = v101;
                      v22[1].f32[0] = v102;
                      v22[1].f32[1] = v99;
                      goto LABEL_171;
                    }
                  }
                  else
                  {
                    LODWORD(a9) = v22[1].i32[1];
                    LODWORD(a10) = 1.0;
                  }
                  LODWORD(a11) = v22[1].i32[0];
                  v22->f32[0] = PDAluminosityPDA(v100, v101, v102, a7, v99, a9, a10, a11, COERCE_FLOAT(*v22), COERCE_FLOAT(HIDWORD(*(unint64_t *)v22)), *(float *)&a11, *(float *)&a9, *(float *)&a10);
                  v22->i32[1] = v103;
                  v22[1].i32[0] = v104;
                  v22[1].i32[1] = LODWORD(a7);
                }
              }
LABEL_171:
              v24 += v92;
              float v105 = &v29[v92];
              if ((unint64_t)v105 >= v16) {
                uint64_t v106 = v93;
              }
              else {
                uint64_t v106 = 0;
              }
              int v29 = &v105[v106];
              unint64_t v22 = (float32x2_t *)((char *)v22 + v94);
              --v95;
            }
            while (v95);
            v24 += v472;
            v22 += 2 * v474;
            unsigned int v37 = v478;
            float v107 = &v478[v475];
            uint64_t v108 = v462;
            if ((unint64_t)v107 < v473) {
              uint64_t v108 = 0;
            }
            int8x16_t v109 = &v107[v108];
            uint64_t v110 = v16 + 16 * v108 + 16 * v475;
            if (v473)
            {
              unint64_t v16 = v110;
              unsigned int v37 = v109;
              int v29 = v109;
            }
            else
            {
              v29 += v475;
            }
            if (!--v489) {
              return;
            }
          }
        case 27:
          uint64_t v111 = v33;
          uint64_t v112 = -(uint64_t)(int)v34;
          uint64_t v463 = -(v28 * (int)v35);
          uint64_t v113 = 16 * v33;
          break;
        default:
          return;
      }
LABEL_183:
      float32x4_t v479 = v37;
      int v114 = v488;
      while (1)
      {
        unsigned int v115 = *v24;
        if (!*v24) {
          goto LABEL_194;
        }
        float v116 = (float)v115 * 0.0039216;
        float v117 = v29->f32[3];
        *(float *)&a9 = v17 ? v116 * v117 : (float)v115 * 0.0039216;
        if (*(float *)&a9 <= 0.0) {
          goto LABEL_194;
        }
        *(float *)&a11 = v116 * v29->f32[0];
        float v118 = v116 * v29->f32[1];
        float v119 = v116 * v29->f32[2];
        if (!v15) {
          break;
        }
        LODWORD(a7) = v22[1].i32[1];
        float v120 = *(float *)&a7;
        if (*(float *)&a7 > 0.0) {
          goto LABEL_193;
        }
        v22->i32[0] = LODWORD(a11);
        v22->f32[1] = v118;
        v22[1].f32[0] = v119;
        v22[1].i32[1] = LODWORD(a9);
LABEL_194:
        v24 += v111;
        float v123 = &v29[v111];
        if ((unint64_t)v123 >= v16) {
          uint64_t v124 = v112;
        }
        else {
          uint64_t v124 = 0;
        }
        int v29 = &v123[v124];
        unint64_t v22 = (float32x2_t *)((char *)v22 + v113);
        if (!--v114)
        {
          v24 += v472;
          v22 += 2 * v474;
          unsigned int v37 = v479;
          int v125 = &v479[v475];
          uint64_t v126 = v463;
          if ((unint64_t)v125 < v473) {
            uint64_t v126 = 0;
          }
          float v127 = &v125[v126];
          uint64_t v128 = v16 + 16 * v126 + 16 * v475;
          if (v473)
          {
            unint64_t v16 = v128;
            unsigned int v37 = v127;
            int v29 = v127;
          }
          else
          {
            v29 += v475;
          }
          if (!--v489) {
            return;
          }
          goto LABEL_183;
        }
      }
      LODWORD(a7) = v22[1].i32[1];
      float v120 = 1.0;
LABEL_193:
      *(float *)&a10 = v116 * v117;
      v22->f32[0] = PDAluminosityPDA(v22->f32[0], v22->f32[1], v22[1].f32[0], a7, v120, a9, a10, a11, *(float *)&a11, v118, v119, *(float *)&a10, *(float *)&a9);
      v22->i32[1] = v121;
      v22[1].i32[0] = v122;
      v22[1].i32[1] = LODWORD(a7);
      goto LABEL_194;
    }
    if ((char *)v22 - (char *)v29 >= 1)
    {
      if (v488 >= (uint64_t)((unint64_t)((char *)v22 - (char *)v29) >> 4))
      {
        v22 += 2 * v488 - 2;
        v29 += v488 - 1;
        v24 += v488 - 1;
        int v33 = -1;
        goto LABEL_13;
      }
      uint64_t v31 = v489 - 1;
      unsigned int v32 = &v29[v21 * v31];
      if (v22 <= (float32x2_t *)&v32[v488 - 1])
      {
        v22 += 2 * v21 * v31;
        uint64_t v28 = -(uint64_t)v21;
        v24 += v23 * v31;
        uint64_t v23 = -v23;
        int v33 = 1;
        int v29 = v32;
        unint64_t v21 = -(uint64_t)v21;
        goto LABEL_14;
      }
    }
    int v33 = 1;
LABEL_13:
    uint64_t v28 = v13 >> 4;
    goto LABEL_14;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)2,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  __asm { FMOV            V0.4S, #1.0 }
  if ((a15 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12) {
        unint64_t v28 = a12;
      }
      unint64_t v29 = v28;
      if (v28 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          unsigned int v44 = (int8x16_t *)&a10[v29];
          int v45 = (int8x16_t *)a10;
          do
            unsigned int v46 = v45++;
          while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v46)) & 0x80) != 0);
          do
          {
            float v47 = v46;
            unsigned int v46 = (int8x16_t *)((char *)v46 + 4);
          }
          while (v46 <= v44 && !v47->i32[0]);
          if (v47 < v44)
          {
            while (!v47->i8[0])
            {
              float v47 = (int8x16_t *)((char *)v47 + 1);
              if (v47 >= v44)
              {
                float v47 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          int64_t v48 = (char *)v47 - a10;
          int64_t v49 = ((char *)v47 - a10) * a14;
          a3 += v49;
          result += v49;
          a10 += v49;
          v29 -= v48;
          goto LABEL_34;
        }
        if (v30 != 0xFFFF) {
          break;
        }
        uint64_t v31 = (int8x16_t *)&a10[v29];
        unsigned int v32 = (int8x16_t *)a10;
        do
          int v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          uint64_t v34 = v33;
          int v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            uint64_t v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              uint64_t v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        uint64_t v35 = 0;
        int64_t v36 = (char *)v34 - a10;
        unint64_t v37 = (char *)v34 - a10;
        do
        {
          BOOL v38 = (int8x16_t *)((char *)result + v35);
          float32x4_t v39 = *(float32x4_t *)((char *)a3 + v35);
          float32x4_t v40 = *(float32x4_t *)((char *)a3 + v35 + 16);
          float32x4_t v41 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 3);
          float32x4_t v42 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v39, 3);
          int8x16_t v43 = vbslq_s8((int8x16_t)vcgtzq_f32(v41), (int8x16_t)vaddq_f32(v40, vmlsq_f32(*(float32x4_t *)((char *)result + v35 + 16), vmaxnmq_f32(vminnmq_f32(v41, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v35 + 16))), *(int8x16_t *)((char *)&result[1] + v35));
          *BOOL v38 = vbslq_s8((int8x16_t)vcgtzq_f32(v42), (int8x16_t)vaddq_f32(v39, vmlsq_f32(*(float32x4_t *)((char *)result + v35), vmaxnmq_f32(vminnmq_f32(v42, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v35))), *(int8x16_t *)((char *)result + v35));
          v38[1] = v43;
          a10 += v17;
          v37 -= 2;
          v35 += v19;
        }
        while (v37 > 1);
        a3 = (float32x4_t *)((char *)a3 + v35);
        float result = (float32x4_t *)((char *)result + v35);
        unint64_t v29 = v29 - v36 + v37;
LABEL_34:
        if (v29 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v50 = 0;
      while (1)
      {
        uint64_t v51 = (int8x16_t *)((char *)result + v50);
        float32x4_t v52 = vmulq_f32(*(float32x4_t *)((char *)a3 + v50), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27));
        float32x4_t v53 = vmulq_f32(*(float32x4_t *)((char *)a3 + v50 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27));
        float32x4_t v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
        float32x4_t v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
        int8x16_t v56 = vbslq_s8((int8x16_t)vcgtzq_f32(v54), (int8x16_t)vaddq_f32(v53, vmlsq_f32(*(float32x4_t *)((char *)result + v50 + 16), vmaxnmq_f32(vminnmq_f32(v54, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v50 + 16))), *(int8x16_t *)((char *)&result[1] + v50));
        int8x16_t *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v55), (int8x16_t)vaddq_f32(v52, vmlsq_f32(*(float32x4_t *)((char *)result + v50), vmaxnmq_f32(vminnmq_f32(v55, _Q0), (float32x4_t)0), *(float32x4_t *)((char *)result + v50))), *(int8x16_t *)((char *)result + v50));
        v51[1] = v56;
        a10 += v17;
        v29 -= 2;
        if (v29 < 2) {
          break;
        }
        LOWORD(v30) = *(_WORD *)a10;
        v50 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v50);
          a3 = (float32x4_t *)((char *)a3 + v50);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v50);
      a3 = (float32x4_t *)((char *)a3 + v19 + v50);
LABEL_37:
      for (unint64_t i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          float32x4_t v58 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27), *a3);
          float32x4_t v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 3);
          *(int8x16_t *)float result = vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vaddq_f32(v58, vmlsq_f32(*result, vmaxnmq_f32(vminnmq_f32(v59, _Q0), (float32x4_t)0), *result)), *(int8x16_t *)result);
        }
        unsigned int v60 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v60 >= a8) {
          uint64_t v61 = -(uint64_t)a7;
        }
        else {
          uint64_t v61 = 0;
        }
        a3 = &v60[v61];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      float v62 = &a5[a4];
      if ((unint64_t)v62 >= a9) {
        uint64_t v63 = v18;
      }
      else {
        uint64_t v63 = 0;
      }
      float v64 = &v62[v63];
      uint64_t v65 = a8 + 16 * v63 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v64;
        a8 = v65;
        a5 = v64;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v66.i64[0] = -1;
  v66.i64[1] = -1;
  float32x4_t v67 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v68 = (a8 - (unint64_t)a3) >> 4;
    if (v68 >= a12) {
      unint64_t v68 = a12;
    }
    unint64_t v69 = v68;
    if (v68 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v70 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        __int32 v85 = (int8x16_t *)&a10[v69];
        float v86 = (int8x16_t *)a10;
        do
          uint64_t v87 = v86++;
        while (v86 <= v85 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v87)) & 0x80) != 0);
        do
        {
          int v88 = v87;
          uint64_t v87 = (int8x16_t *)((char *)v87 + 4);
        }
        while (v87 <= v85 && !v88->i32[0]);
        if (v88 < v85)
        {
          while (!v88->i8[0])
          {
            int v88 = (int8x16_t *)((char *)v88 + 1);
            if (v88 >= v85)
            {
              int v88 = (int8x16_t *)&a10[v69];
              break;
            }
          }
        }
        int64_t v89 = (char *)v88 - a10;
        int64_t v90 = ((char *)v88 - a10) * a14;
        a3 += v90;
        result += v90;
        a10 += v90;
        v69 -= v89;
        goto LABEL_84;
      }
      if (v70 != 0xFFFF) {
        break;
      }
      uint64_t v71 = (int8x16_t *)&a10[v69];
      float32x4_t v72 = (int8x16_t *)a10;
      do
        uint64_t v73 = v72++;
      while (v72 <= v71 && (vminvq_u8((uint8x16_t)vceqq_s8(*v73, v66)) & 0x80) != 0);
      do
      {
        uint64_t v74 = v73;
        uint64_t v73 = (int8x16_t *)((char *)v73 + 4);
      }
      while (v73 <= v71 && v74->i32[0] == -1);
      if (v74 < v71)
      {
        while (v74->u8[0] == 255)
        {
          uint64_t v74 = (int8x16_t *)((char *)v74 + 1);
          if (v74 >= v71)
          {
            uint64_t v74 = (int8x16_t *)&a10[v69];
            break;
          }
        }
      }
      uint64_t v75 = 0;
      int64_t v76 = (char *)v74 - a10;
      unint64_t v77 = (char *)v74 - a10;
      do
      {
        unsigned int v78 = (int8x16_t *)((char *)result + v75);
        float32x4_t v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
        float32x4_t v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
        float32x4_t v81 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
        float32x4_t v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
        float32x4_t v83 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        float32x4_t v84 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3);
        *unsigned int v78 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v83), (int8x16_t)vaddq_f32(vmlsq_f32(v82, vmaxnmq_f32(vminnmq_f32(v83, _Q0), (float32x4_t)0), v82), v80), (int8x16_t)v82));
        v78[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v84), (int8x16_t)vaddq_f32(vmlsq_f32(v81, vmaxnmq_f32(vminnmq_f32(v84, _Q0), (float32x4_t)0), v81), v79), (int8x16_t)v81));
        a10 += v17;
        v77 -= 2;
        v75 += v19;
      }
      while (v77 > 1);
      a3 = (float32x4_t *)((char *)a3 + v75);
      float result = (float32x4_t *)((char *)result + v75);
      unint64_t v69 = v69 - v76 + v77;
LABEL_84:
      if (v69 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v91 = 0;
    while (1)
    {
      uint64_t v92 = (int8x16_t *)((char *)result + v91);
      float32x4_t v93 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v91));
      float32x4_t v94 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v91));
      float32x4_t v95 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v70) & 0xFF00FF00FF00FFLL))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v91)));
      float32x4_t v96 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
      float32x4_t v97 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v70)) & 0xFF00FF00FF00FFLL))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v91)));
      float32x4_t v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3);
      int8x16_t *v92 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v96), (int8x16_t)vaddq_f32(v95, vmlsq_f32(v94, vmaxnmq_f32(vminnmq_f32(v96, _Q0), (float32x4_t)0), v94)), (int8x16_t)v94));
      v92[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v98), (int8x16_t)vaddq_f32(v97, vmlsq_f32(v93, vmaxnmq_f32(vminnmq_f32(v98, _Q0), (float32x4_t)0), v93)), (int8x16_t)v93));
      a10 += v17;
      v69 -= 2;
      if (v69 < 2) {
        break;
      }
      LOWORD(v70) = *(_WORD *)a10;
      v91 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v91);
        a3 = (float32x4_t *)((char *)a3 + v91);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v91);
    a3 = (float32x4_t *)((char *)a3 + v19 + v91);
LABEL_87:
    for (unint64_t j = a12 - v68 + v69; j; --j)
    {
      if (*a10)
      {
        float32x4_t v100 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v101 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v67), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3));
        float32x4_t v102 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 3);
        *(int8x16_t *)float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v102), (int8x16_t)vaddq_f32(v101, vmlsq_f32(v100, vmaxnmq_f32(vminnmq_f32(v102, _Q0), (float32x4_t)0), v100)), (int8x16_t)v100));
      }
      __int32 v103 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v103 >= a8) {
        uint64_t v104 = -(uint64_t)a7;
      }
      else {
        uint64_t v104 = 0;
      }
      a3 = &v103[v104];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float v105 = &a5[a4];
    if ((unint64_t)v105 >= a9) {
      uint64_t v106 = v18;
    }
    else {
      uint64_t v106 = 0;
    }
    float v107 = &v105[v106];
    uint64_t v108 = a8 + 16 * v106 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v107;
      a8 = v108;
      a5 = v107;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int32x4_t *composite_pixelmask<(CGCompositeOperation)6,_rgbaf_t>(int32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  int8x16_t v20 = vmvnq_s8(v19);
  int8x16_t v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v22 = 2 * a14;
  uint64_t v23 = -(a6 * a4);
  uint64_t v24 = 32 * a14;
  uint64_t v25 = 16 * a14;
  __asm { FMOV            V2.4S, #1.0 }
  if ((a16 & 0x30) != 0)
  {
    v31.i64[0] = -1;
    v31.i64[1] = -1;
    float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v33 = (a8 - (unint64_t)a3) >> 4;
      if (v33 >= a12) {
        unint64_t v33 = a12;
      }
      unint64_t v34 = v33;
      if (v33 < 2) {
        goto LABEL_40;
      }
      while (1)
      {
        int v35 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v52 = (int8x16_t *)&a10[v34];
          float32x4_t v53 = (int8x16_t *)a10;
          do
            float32x4_t v54 = v53++;
          while (v53 <= v52 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v54)) & 0x80) != 0);
          do
          {
            float32x4_t v55 = v54;
            float32x4_t v54 = (int8x16_t *)((char *)v54 + 4);
          }
          while (v54 <= v52 && !v55->i32[0]);
          if (v55 < v52)
          {
            while (!v55->i8[0])
            {
              float32x4_t v55 = (int8x16_t *)((char *)v55 + 1);
              if (v55 >= v52)
              {
                float32x4_t v55 = (int8x16_t *)&a10[v34];
                break;
              }
            }
          }
          int64_t v56 = (char *)v55 - a10;
          int64_t v57 = ((char *)v55 - a10) * a14;
          a3 += v57;
          result += v57;
          a10 += v57;
          v34 -= v56;
          goto LABEL_37;
        }
        if (v35 != 0xFFFF) {
          break;
        }
        int64_t v36 = (int8x16_t *)&a10[v34];
        unint64_t v37 = (int8x16_t *)a10;
        do
          BOOL v38 = v37++;
        while (v37 <= v36 && (vminvq_u8((uint8x16_t)vceqq_s8(*v38, v31)) & 0x80) != 0);
        do
        {
          float32x4_t v39 = v38;
          BOOL v38 = (int8x16_t *)((char *)v38 + 4);
        }
        while (v38 <= v36 && v39->i32[0] == -1);
        if (v39 < v36)
        {
          while (v39->u8[0] == 255)
          {
            float32x4_t v39 = (int8x16_t *)((char *)v39 + 1);
            if (v39 >= v36)
            {
              float32x4_t v39 = (int8x16_t *)&a10[v34];
              break;
            }
          }
        }
        uint64_t v40 = 0;
        int64_t v41 = (char *)v39 - a10;
        unint64_t v42 = (char *)v39 - a10;
        do
        {
          int8x16_t v43 = (int8x16_t *)&result->i8[v40];
          int32x4_t v44 = *(int32x4_t *)((char *)result + v40);
          int32x4_t v45 = *(int32x4_t *)((char *)&result[1] + v40);
          float32x4_t v46 = (float32x4_t)vdupq_laneq_s32(v45, 3);
          float32x4_t v47 = (float32x4_t)vdupq_laneq_s32(v44, 3);
          int8x16_t v48 = (int8x16_t)vcgtzq_f32(v47);
          int8x16_t v49 = (int8x16_t)vcgtzq_f32(v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v40), v20), v21);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v40), v20), v21);
          *int8x16_t v43 = vbslq_s8((int8x16_t)vcgtq_f32(v47, _Q2), (int8x16_t)v44, (int8x16_t)vaddq_f32(vmlsq_f32(v50, (float32x4_t)vandq_s8(v48, (int8x16_t)v47), v50), (float32x4_t)vandq_s8(v48, (int8x16_t)v44)));
          v43[1] = vbslq_s8((int8x16_t)vcgtq_f32(v46, _Q2), (int8x16_t)v45, (int8x16_t)vaddq_f32(vmlsq_f32(v51, (float32x4_t)vandq_s8(v49, (int8x16_t)v46), v51), (float32x4_t)vandq_s8(v49, (int8x16_t)v45)));
          a10 += v22;
          v42 -= 2;
          v40 += v24;
        }
        while (v42 > 1);
        a3 = (int8x16_t *)((char *)a3 + v40);
        float result = (int32x4_t *)((char *)result + v40);
        unint64_t v34 = v34 - v41 + v42;
LABEL_37:
        if (v34 <= 1) {
          goto LABEL_40;
        }
      }
      uint64_t v58 = 0;
      while (1)
      {
        float32x4_t v59 = (int8x16_t *)&result->i8[v58];
        int32x4_t v60 = *(int32x4_t *)((char *)result + v58);
        int32x4_t v61 = *(int32x4_t *)((char *)&result[1] + v58);
        float32x4_t v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v35) & 0xFF00FF00FF00FFLL))), v32);
        float32x4_t v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v35)) & 0xFF00FF00FF00FFLL))), v32);
        float32x4_t v64 = (float32x4_t)vdupq_laneq_s32(v61, 3);
        float32x4_t v65 = (float32x4_t)vdupq_laneq_s32(v60, 3);
        int8x16_t v66 = (int8x16_t)vcgtzq_f32(v65);
        int8x16_t v67 = (int8x16_t)vcgtzq_f32(v64);
        float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v58), v20), v21);
        float32x4_t v69 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v58), v20), v21);
        *float32x4_t v59 = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v62), (int8x16_t)vcgtq_f32(v65, _Q2)), (int8x16_t)v60, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v66, (int8x16_t)v60), v62, vmlsq_f32(v68, (float32x4_t)vandq_s8(v66, (int8x16_t)v65), v68)));
        v59[1] = vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v63), (int8x16_t)vcgtq_f32(v64, _Q2)), (int8x16_t)v61, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v67, (int8x16_t)v61), v63, vmlsq_f32(v69, (float32x4_t)vandq_s8(v67, (int8x16_t)v64), v69)));
        a10 += v22;
        v34 -= 2;
        if (v34 < 2) {
          break;
        }
        LOWORD(v35) = *(_WORD *)a10;
        v58 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int32x4_t *)((char *)result + v58);
          a3 = (int8x16_t *)((char *)a3 + v58);
          goto LABEL_37;
        }
      }
      float result = (int32x4_t *)((char *)result + v24 + v58);
      a3 = (int8x16_t *)((char *)a3 + v24 + v58);
LABEL_40:
      for (unint64_t i = a12 - v33 + v34; i; --i)
      {
        if (*a10)
        {
          float32x4_t v71 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v32);
          float32x4_t v72 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21);
          float32x4_t v73 = (float32x4_t)vdupq_laneq_s32(*result, 3);
          int8x16_t v74 = (int8x16_t)vcgtzq_f32(v73);
          *(int8x16_t *)float result = vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v73, _Q2), (int8x16_t)vceqzq_f32(v71)), *(int8x16_t *)result, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v74, *(int8x16_t *)result), v71, vmlsq_f32(v72, (float32x4_t)vandq_s8(v74, (int8x16_t)v73), v72)));
        }
        uint64_t v75 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v75 >= a8) {
          uint64_t v76 = -(uint64_t)a7;
        }
        else {
          uint64_t v76 = 0;
        }
        a3 = &v75[v76];
        float result = (int32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      unint64_t v77 = &a5[a4];
      if ((unint64_t)v77 >= a9) {
        uint64_t v78 = v23;
      }
      else {
        uint64_t v78 = 0;
      }
      float32x4_t v79 = &v77[v78];
      uint64_t v80 = a8 + 16 * v78 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v79;
        a8 = v80;
        a5 = v79;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v81.i64[0] = -1;
  v81.i64[1] = -1;
  float32x4_t v82 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v83 = (a8 - (unint64_t)a3) >> 4;
    if (v83 >= a12) {
      unint64_t v83 = a12;
    }
    unint64_t v84 = v83;
    if (v83 < 2) {
      goto LABEL_90;
    }
    while (1)
    {
      int v85 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v102 = (int8x16_t *)&a10[v84];
        __int32 v103 = (int8x16_t *)a10;
        do
          uint64_t v104 = v103++;
        while (v103 <= v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
        do
        {
          float v105 = v104;
          uint64_t v104 = (int8x16_t *)((char *)v104 + 4);
        }
        while (v104 <= v102 && !v105->i32[0]);
        if (v105 < v102)
        {
          while (!v105->i8[0])
          {
            float v105 = (int8x16_t *)((char *)v105 + 1);
            if (v105 >= v102)
            {
              float v105 = (int8x16_t *)&a10[v84];
              break;
            }
          }
        }
        int64_t v106 = (char *)v105 - a10;
        int64_t v107 = ((char *)v105 - a10) * a14;
        a3 += v107;
        result += v107;
        a10 += v107;
        v84 -= v106;
        goto LABEL_87;
      }
      if (v85 != 0xFFFF) {
        break;
      }
      float v86 = (int8x16_t *)&a10[v84];
      uint64_t v87 = (int8x16_t *)a10;
      do
        int v88 = v87++;
      while (v87 <= v86 && (vminvq_u8((uint8x16_t)vceqq_s8(*v88, v81)) & 0x80) != 0);
      do
      {
        int64_t v89 = v88;
        int v88 = (int8x16_t *)((char *)v88 + 4);
      }
      while (v88 <= v86 && v89->i32[0] == -1);
      if (v89 < v86)
      {
        while (v89->u8[0] == 255)
        {
          int64_t v89 = (int8x16_t *)((char *)v89 + 1);
          if (v89 >= v86)
          {
            int64_t v89 = (int8x16_t *)&a10[v84];
            break;
          }
        }
      }
      uint64_t v90 = 0;
      int64_t v91 = (char *)v89 - a10;
      unint64_t v92 = (char *)v89 - a10;
      do
      {
        float32x4_t v93 = (int8x16_t *)&result->i8[v90];
        int32x4_t v94 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v90));
        int32x4_t v95 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v90));
        float32x4_t v96 = (float32x4_t)vdupq_laneq_s32(v95, 3);
        float32x4_t v97 = (float32x4_t)vdupq_laneq_s32(v94, 3);
        int8x16_t v98 = (int8x16_t)vcgtzq_f32(v97);
        int8x16_t v99 = (int8x16_t)vcgtzq_f32(v96);
        float32x4_t v100 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v90)), v20), v21);
        float32x4_t v101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v90)), v20), v21);
        *float32x4_t v93 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtq_f32(v97, _Q2), (int8x16_t)v94, (int8x16_t)vaddq_f32(vmlsq_f32(v100, (float32x4_t)vandq_s8(v98, (int8x16_t)v97), v100), (float32x4_t)vandq_s8(v98, (int8x16_t)v94))));
        v93[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtq_f32(v96, _Q2), (int8x16_t)v95, (int8x16_t)vaddq_f32(vmlsq_f32(v101, (float32x4_t)vandq_s8(v99, (int8x16_t)v96), v101), (float32x4_t)vandq_s8(v99, (int8x16_t)v95))));
        a10 += v22;
        v92 -= 2;
        v90 += v24;
      }
      while (v92 > 1);
      a3 = (int8x16_t *)((char *)a3 + v90);
      float result = (int32x4_t *)((char *)result + v90);
      unint64_t v84 = v84 - v91 + v92;
LABEL_87:
      if (v84 <= 1) {
        goto LABEL_90;
      }
    }
    uint64_t v108 = 0;
    while (1)
    {
      int8x16_t v109 = (int8x16_t *)&result->i8[v108];
      int32x4_t v110 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v108));
      int32x4_t v111 = (int32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v108));
      float32x4_t v112 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v85)) & 0xFF00FF00FF00FFLL))), v82);
      float32x4_t v113 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v85) & 0xFF00FF00FF00FFLL))), v82);
      float32x4_t v114 = (float32x4_t)vdupq_laneq_s32(v111, 3);
      float32x4_t v115 = (float32x4_t)vdupq_laneq_s32(v110, 3);
      int8x16_t v116 = (int8x16_t)vcgtzq_f32(v115);
      int8x16_t v117 = (int8x16_t)vcgtzq_f32(v114);
      float32x4_t v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v108)), v20), v21);
      float32x4_t v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v108)), v20), v21);
      *int8x16_t v109 = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v113), (int8x16_t)vcgtq_f32(v115, _Q2)), (int8x16_t)v110, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v116, (int8x16_t)v110), v113, vmlsq_f32(v118, (float32x4_t)vandq_s8(v116, (int8x16_t)v115), v118))));
      v109[1] = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vceqzq_f32(v112), (int8x16_t)vcgtq_f32(v114, _Q2)), (int8x16_t)v111, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v117, (int8x16_t)v111), v112, vmlsq_f32(v119, (float32x4_t)vandq_s8(v117, (int8x16_t)v114), v119))));
      a10 += v22;
      v84 -= 2;
      if (v84 < 2) {
        break;
      }
      LOWORD(v85) = *(_WORD *)a10;
      v108 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int32x4_t *)((char *)result + v108);
        a3 = (int8x16_t *)((char *)a3 + v108);
        goto LABEL_87;
      }
    }
    float result = (int32x4_t *)((char *)result + v24 + v108);
    a3 = (int8x16_t *)((char *)a3 + v24 + v108);
LABEL_90:
    for (unint64_t j = a12 - v83 + v84; j; --j)
    {
      if (*a10)
      {
        int32x4_t v121 = (int32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v122 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v82);
        float32x4_t v123 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21);
        float32x4_t v124 = (float32x4_t)vdupq_laneq_s32(v121, 3);
        int8x16_t v125 = (int8x16_t)vcgtzq_f32(v124);
        *(int8x16_t *)float result = vrev32q_s8(vbslq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v124, _Q2), (int8x16_t)vceqzq_f32(v122)), (int8x16_t)v121, (int8x16_t)vmlaq_f32((float32x4_t)vandq_s8(v125, (int8x16_t)v121), v122, vmlsq_f32(v123, (float32x4_t)vandq_s8(v125, (int8x16_t)v124), v123))));
      }
      uint64_t v126 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v126 >= a8) {
        uint64_t v127 = -(uint64_t)a7;
      }
      else {
        uint64_t v127 = 0;
      }
      a3 = &v126[v127];
      float result = (int32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    uint64_t v128 = &a5[a4];
    if ((unint64_t)v128 >= a9) {
      uint64_t v129 = v23;
    }
    else {
      uint64_t v129 = 0;
    }
    unsigned int v130 = &v128[v129];
    uint64_t v131 = a8 + 16 * v129 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v130;
      a8 = v131;
      a5 = v130;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)3,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  int8x16_t v20 = vmvnq_s8(v19);
  int8x16_t v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v22 = 2 * a14;
  uint64_t v23 = -(a6 * a4);
  uint64_t v24 = 32 * a14;
  uint64_t v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12) {
        unint64_t v28 = a12;
      }
      unint64_t v29 = v28;
      if (v28 < 2) {
        goto LABEL_40;
      }
      while (1)
      {
        int v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          uint64_t v40 = (int8x16_t *)&a10[v29];
          int64_t v41 = (int8x16_t *)a10;
          do
            unint64_t v42 = v41++;
          while (v41 <= v40 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v42)) & 0x80) != 0);
          do
          {
            int8x16_t v43 = v42;
            unint64_t v42 = (int8x16_t *)((char *)v42 + 4);
          }
          while (v42 <= v40 && !v43->i32[0]);
          if (v43 < v40)
          {
            while (!v43->i8[0])
            {
              int8x16_t v43 = (int8x16_t *)((char *)v43 + 1);
              if (v43 >= v40)
              {
                int8x16_t v43 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          int64_t v44 = (char *)v43 - a10;
          int64_t v45 = ((char *)v43 - a10) * a14;
          a3 += v45;
          result += v45;
          a10 += v45;
          v29 -= v44;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF) {
          break;
        }
        int8x16_t v31 = (int8x16_t *)&a10[v29];
        float32x4_t v32 = (int8x16_t *)a10;
        do
          unint64_t v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          unint64_t v34 = v33;
          unint64_t v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            unint64_t v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              unint64_t v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        uint64_t v35 = 0;
        int64_t v36 = (char *)v34 - a10;
        unint64_t v37 = (char *)v34 - a10;
        do
        {
          BOOL v38 = (float32x4_t *)((char *)result + v35);
          float32x4_t v39 = vmlaq_laneq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35 + 16), *(float32x4_t *)((char *)result + v35 + 16)), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21), *(float32x4_t *)((char *)result + v35 + 16), 3);
          *BOOL v38 = vmlaq_laneq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35), *(float32x4_t *)((char *)result + v35)), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21), *(float32x4_t *)((char *)result + v35), 3);
          v38[1] = v39;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        float result = (float32x4_t *)((char *)result + v35);
        unint64_t v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1) {
          goto LABEL_40;
        }
      }
      uint64_t v46 = 0;
      while (1)
      {
        float32x4_t v47 = (float32x4_t *)((char *)result + v46);
        float32x4_t v48 = *(float32x4_t *)((char *)result + v46);
        float32x4_t v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        float32x4_t v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        float32x4_t v51 = vmulq_f32(v50, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v20), v21));
        float32x4_t v52 = vmlsq_f32(v48, v50, v48);
        float32x4_t v53 = vmlaq_laneq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v46 + 16), v49, *(float32x4_t *)((char *)result + v46 + 16)), vmulq_f32(v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v20), v21)), *(float32x4_t *)((char *)result + v46 + 16), 3);
        *float32x4_t v47 = vmlaq_laneq_f32(v52, v51, v48, 3);
        v47[1] = v53;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2) {
          break;
        }
        LOWORD(v30) = *(_WORD *)a10;
        v46 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v46);
          a3 = (int8x16_t *)((char *)a3 + v46);
          goto LABEL_37;
        }
      }
      float result = (float32x4_t *)((char *)result + v24 + v46);
      a3 = (int8x16_t *)((char *)a3 + v24 + v46);
LABEL_40:
      for (unint64_t i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          float32x4_t v55 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          *float result = vmlaq_laneq_f32(vmlsq_f32(*result, v55, *result), vmulq_f32(v55, (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21)), *result, 3);
        }
        int64_t v56 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v56 >= a8) {
          uint64_t v57 = -(uint64_t)a7;
        }
        else {
          uint64_t v57 = 0;
        }
        a3 = &v56[v57];
        float result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      uint64_t v58 = &a5[a4];
      if ((unint64_t)v58 >= a9) {
        uint64_t v59 = v23;
      }
      else {
        uint64_t v59 = 0;
      }
      int32x4_t v60 = &v58[v59];
      uint64_t v61 = a8 + 16 * v59 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v60;
        a8 = v61;
        a5 = v60;
      }
      BOOL v62 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v62 | (a13 == 0)) {
        return result;
      }
    }
  }
  v63.i64[0] = -1;
  v63.i64[1] = -1;
  float32x4_t v64 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v65 = (a8 - (unint64_t)a3) >> 4;
    if (v65 >= a12) {
      unint64_t v65 = a12;
    }
    unint64_t v66 = v65;
    if (v65 < 2) {
      goto LABEL_90;
    }
    while (1)
    {
      int v67 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v79 = (int8x16_t *)&a10[v66];
        uint64_t v80 = (int8x16_t *)a10;
        do
          int8x16_t v81 = v80++;
        while (v80 <= v79 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v81)) & 0x80) != 0);
        do
        {
          float32x4_t v82 = v81;
          int8x16_t v81 = (int8x16_t *)((char *)v81 + 4);
        }
        while (v81 <= v79 && !v82->i32[0]);
        if (v82 < v79)
        {
          while (!v82->i8[0])
          {
            float32x4_t v82 = (int8x16_t *)((char *)v82 + 1);
            if (v82 >= v79)
            {
              float32x4_t v82 = (int8x16_t *)&a10[v66];
              break;
            }
          }
        }
        int64_t v83 = (char *)v82 - a10;
        int64_t v84 = ((char *)v82 - a10) * a14;
        a3 += v84;
        result += v84;
        a10 += v84;
        v66 -= v83;
        goto LABEL_87;
      }
      if (v67 != 0xFFFF) {
        break;
      }
      float32x4_t v68 = (int8x16_t *)&a10[v66];
      float32x4_t v69 = (int8x16_t *)a10;
      do
        int v70 = v69++;
      while (v69 <= v68 && (vminvq_u8((uint8x16_t)vceqq_s8(*v70, v63)) & 0x80) != 0);
      do
      {
        float32x4_t v71 = v70;
        int v70 = (int8x16_t *)((char *)v70 + 4);
      }
      while (v70 <= v68 && v71->i32[0] == -1);
      if (v71 < v68)
      {
        while (v71->u8[0] == 255)
        {
          float32x4_t v71 = (int8x16_t *)((char *)v71 + 1);
          if (v71 >= v68)
          {
            float32x4_t v71 = (int8x16_t *)&a10[v66];
            break;
          }
        }
      }
      uint64_t v72 = 0;
      int64_t v73 = (char *)v71 - a10;
      unint64_t v74 = (char *)v71 - a10;
      do
      {
        uint64_t v75 = (int8x16_t *)((char *)result + v72);
        float32x4_t v76 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v72));
        float32x4_t v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v72));
        int8x16_t v78 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vsubq_f32(v77, v77), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v72)), v20), v21), v77, 3));
        *uint64_t v75 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vsubq_f32(v76, v76), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v72)), v20), v21), v76, 3));
        v75[1] = v78;
        a10 += v22;
        v74 -= 2;
        v72 += v24;
      }
      while (v74 > 1);
      a3 = (int8x16_t *)((char *)a3 + v72);
      float result = (float32x4_t *)((char *)result + v72);
      unint64_t v66 = v66 - v73 + v74;
LABEL_87:
      if (v66 <= 1) {
        goto LABEL_90;
      }
    }
    uint64_t v85 = 0;
    while (1)
    {
      float v86 = (int8x16_t *)((char *)result + v85);
      float32x4_t v87 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v85));
      float32x4_t v88 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v85));
      float32x4_t v89 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v67) & 0xFF00FF00FF00FFLL))), v64);
      float32x4_t v90 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v67)) & 0xFF00FF00FF00FFLL))), v64);
      int8x16_t v91 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v87, v90, v87), vmulq_f32(v90, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v85)), v20), v21)), v87, 3));
      int8x16_t *v86 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v88, v89, v88), vmulq_f32(v89, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v85)), v20), v21)), v88, 3));
      v86[1] = v91;
      a10 += v22;
      v66 -= 2;
      if (v66 < 2) {
        break;
      }
      LOWORD(v67) = *(_WORD *)a10;
      v85 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v85);
        a3 = (int8x16_t *)((char *)a3 + v85);
        goto LABEL_87;
      }
    }
    float result = (float32x4_t *)((char *)result + v24 + v85);
    a3 = (int8x16_t *)((char *)a3 + v24 + v85);
LABEL_90:
    for (unint64_t j = a12 - v65 + v66; j; --j)
    {
      if (*a10)
      {
        float32x4_t v93 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v64);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_f32(v93, v94, v93), vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21)), v93, 3));
      }
      int32x4_t v95 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v95 >= a8) {
        uint64_t v96 = -(uint64_t)a7;
      }
      else {
        uint64_t v96 = 0;
      }
      a3 = &v95[v96];
      float result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    float32x4_t v97 = &a5[a4];
    if ((unint64_t)v97 >= a9) {
      uint64_t v98 = v23;
    }
    else {
      uint64_t v98 = 0;
    }
    int8x16_t v99 = &v97[v98];
    uint64_t v100 = a8 + 16 * v98 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v99;
      a8 = v100;
      a5 = v99;
    }
    BOOL v62 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v62 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)7,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  __asm
  {
    FMOV            V0.4S, #-1.0
    FMOV            V1.4S, #1.0
  }
  if ((a15 & 0x30) != 0)
  {
    v27.i64[0] = -1;
    v27.i64[1] = -1;
    float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v29 = (a8 - (unint64_t)a3) >> 4;
      if (v29 >= a12) {
        unint64_t v29 = a12;
      }
      unint64_t v30 = v29;
      if (v29 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v31 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          int64_t v41 = (int8x16_t *)&a10[v30];
          unint64_t v42 = (int8x16_t *)a10;
          do
            int8x16_t v43 = v42++;
          while (v42 <= v41 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v43)) & 0x80) != 0);
          do
          {
            int64_t v44 = v43;
            int8x16_t v43 = (int8x16_t *)((char *)v43 + 4);
          }
          while (v43 <= v41 && !v44->i32[0]);
          if (v44 < v41)
          {
            while (!v44->i8[0])
            {
              int64_t v44 = (int8x16_t *)((char *)v44 + 1);
              if (v44 >= v41)
              {
                int64_t v44 = (int8x16_t *)&a10[v30];
                break;
              }
            }
          }
          int64_t v45 = (char *)v44 - a10;
          int64_t v46 = ((char *)v44 - a10) * a14;
          a3 += v46;
          result += v46;
          a10 += v46;
          v30 -= v45;
          goto LABEL_34;
        }
        if (v31 != 0xFFFF) {
          break;
        }
        float32x4_t v32 = (int8x16_t *)&a10[v30];
        unint64_t v33 = (int8x16_t *)a10;
        do
          unint64_t v34 = v33++;
        while (v33 <= v32 && (vminvq_u8((uint8x16_t)vceqq_s8(*v34, v27)) & 0x80) != 0);
        do
        {
          uint64_t v35 = v34;
          unint64_t v34 = (int8x16_t *)((char *)v34 + 4);
        }
        while (v34 <= v32 && v35->i32[0] == -1);
        if (v35 < v32)
        {
          while (v35->u8[0] == 255)
          {
            uint64_t v35 = (int8x16_t *)((char *)v35 + 1);
            if (v35 >= v32)
            {
              uint64_t v35 = (int8x16_t *)&a10[v30];
              break;
            }
          }
        }
        uint64_t v36 = 0;
        int64_t v37 = (char *)v35 - a10;
        unint64_t v38 = (char *)v35 - a10;
        do
        {
          float32x4_t v39 = (float32x4_t *)((char *)result + v36);
          float32x4_t v40 = vmlsq_f32(*(float32x4_t *)((char *)result + v36 + 16), vmlaq_laneq_f32(_Q1, _Q0, *(float32x4_t *)((char *)a3 + v36 + 16), 3), *(float32x4_t *)((char *)result + v36 + 16));
          *float32x4_t v39 = vmlsq_f32(*(float32x4_t *)((char *)result + v36), vmlaq_laneq_f32(_Q1, _Q0, *(float32x4_t *)((char *)a3 + v36), 3), *(float32x4_t *)((char *)result + v36));
          v39[1] = v40;
          a10 += v17;
          v38 -= 2;
          v36 += v19;
        }
        while (v38 > 1);
        a3 = (float32x4_t *)((char *)a3 + v36);
        float result = (float32x4_t *)((char *)result + v36);
        unint64_t v30 = v30 - v37 + v38;
LABEL_34:
        if (v30 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v47 = 0;
      while (1)
      {
        float32x4_t v48 = (float32x4_t *)((char *)result + v47);
        float32x4_t v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v31)) & 0xFF00FF00FF00FFLL))), v28);
        float32x4_t v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v31) & 0xFF00FF00FF00FFLL))), v28);
        float32x4_t v51 = vmlsq_f32(*(float32x4_t *)((char *)result + v47 + 16), vmlsq_laneq_f32(v49, v49, *(float32x4_t *)((char *)a3 + v47 + 16), 3), *(float32x4_t *)((char *)result + v47 + 16));
        *float32x4_t v48 = vmlsq_f32(*(float32x4_t *)((char *)result + v47), vmlsq_laneq_f32(v50, v50, *(float32x4_t *)((char *)a3 + v47), 3), *(float32x4_t *)((char *)result + v47));
        v48[1] = v51;
        a10 += v17;
        v30 -= 2;
        if (v30 < 2) {
          break;
        }
        LOWORD(v31) = *(_WORD *)a10;
        v47 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v47);
          a3 = (float32x4_t *)((char *)a3 + v47);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v47);
      a3 = (float32x4_t *)((char *)a3 + v19 + v47);
LABEL_37:
      for (unint64_t i = a12 - v29 + v30; i; --i)
      {
        if (*a10)
        {
          float32x4_t v53 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v28);
          *float result = vmlsq_f32(*result, vmlsq_laneq_f32(v53, v53, *a3, 3), *result);
        }
        float32x4_t v54 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v54 >= a8) {
          uint64_t v55 = -(uint64_t)a7;
        }
        else {
          uint64_t v55 = 0;
        }
        a3 = &v54[v55];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      int64_t v56 = &a5[a4];
      if ((unint64_t)v56 >= a9) {
        uint64_t v57 = v18;
      }
      else {
        uint64_t v57 = 0;
      }
      uint64_t v58 = &v56[v57];
      uint64_t v59 = a8 + 16 * v57 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v58;
        a8 = v59;
        a5 = v58;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v60.i64[0] = -1;
  v60.i64[1] = -1;
  float32x4_t v61 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v62 = (a8 - (unint64_t)a3) >> 4;
    if (v62 >= a12) {
      unint64_t v62 = a12;
    }
    unint64_t v63 = v62;
    if (v62 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v64 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v76 = (int8x16_t *)&a10[v63];
        float32x4_t v77 = (int8x16_t *)a10;
        do
          int8x16_t v78 = v77++;
        while (v77 <= v76 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v78)) & 0x80) != 0);
        do
        {
          float32x4_t v79 = v78;
          int8x16_t v78 = (int8x16_t *)((char *)v78 + 4);
        }
        while (v78 <= v76 && !v79->i32[0]);
        if (v79 < v76)
        {
          while (!v79->i8[0])
          {
            float32x4_t v79 = (int8x16_t *)((char *)v79 + 1);
            if (v79 >= v76)
            {
              float32x4_t v79 = (int8x16_t *)&a10[v63];
              break;
            }
          }
        }
        int64_t v80 = (char *)v79 - a10;
        int64_t v81 = ((char *)v79 - a10) * a14;
        a3 += v81;
        result += v81;
        a10 += v81;
        v63 -= v80;
        goto LABEL_84;
      }
      if (v64 != 0xFFFF) {
        break;
      }
      unint64_t v65 = (int8x16_t *)&a10[v63];
      unint64_t v66 = (int8x16_t *)a10;
      do
        int v67 = v66++;
      while (v66 <= v65 && (vminvq_u8((uint8x16_t)vceqq_s8(*v67, v60)) & 0x80) != 0);
      do
      {
        float32x4_t v68 = v67;
        int v67 = (int8x16_t *)((char *)v67 + 4);
      }
      while (v67 <= v65 && v68->i32[0] == -1);
      if (v68 < v65)
      {
        while (v68->u8[0] == 255)
        {
          float32x4_t v68 = (int8x16_t *)((char *)v68 + 1);
          if (v68 >= v65)
          {
            float32x4_t v68 = (int8x16_t *)&a10[v63];
            break;
          }
        }
      }
      uint64_t v69 = 0;
      int64_t v70 = (char *)v68 - a10;
      unint64_t v71 = (char *)v68 - a10;
      do
      {
        uint64_t v72 = (int8x16_t *)((char *)result + v69);
        float32x4_t v73 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v69));
        float32x4_t v74 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v69));
        int8x16_t v75 = vrev32q_s8((int8x16_t)vmlsq_f32(v73, vmlaq_laneq_f32(_Q1, _Q0, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v69)), 3), v73));
        *uint64_t v72 = vrev32q_s8((int8x16_t)vmlsq_f32(v74, vmlaq_laneq_f32(_Q1, _Q0, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v69)), 3), v74));
        v72[1] = v75;
        a10 += v17;
        v71 -= 2;
        v69 += v19;
      }
      while (v71 > 1);
      a3 = (float32x4_t *)((char *)a3 + v69);
      float result = (float32x4_t *)((char *)result + v69);
      unint64_t v63 = v63 - v70 + v71;
LABEL_84:
      if (v63 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v82 = 0;
    while (1)
    {
      int64_t v83 = (int8x16_t *)((char *)result + v82);
      float32x4_t v84 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v82));
      float32x4_t v85 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v82));
      float32x4_t v86 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v64)) & 0xFF00FF00FF00FFLL))), v61);
      float32x4_t v87 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v64) & 0xFF00FF00FF00FFLL))), v61);
      int8x16_t v88 = vrev32q_s8((int8x16_t)vmlsq_f32(v84, vmlsq_laneq_f32(v86, v86, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v82)), 3), v84));
      *int64_t v83 = vrev32q_s8((int8x16_t)vmlsq_f32(v85, vmlsq_laneq_f32(v87, v87, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v82)), 3), v85));
      v83[1] = v88;
      a10 += v17;
      v63 -= 2;
      if (v63 < 2) {
        break;
      }
      LOWORD(v64) = *(_WORD *)a10;
      v82 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v82);
        a3 = (float32x4_t *)((char *)a3 + v82);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v82);
    a3 = (float32x4_t *)((char *)a3 + v19 + v82);
LABEL_87:
    for (unint64_t j = a12 - v62 + v63; j; --j)
    {
      if (*a10)
      {
        float32x4_t v90 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v91 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v61);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlsq_f32(v90, vmlsq_laneq_f32(v91, v91, (float32x4_t)vrev32q_s8(*(int8x16_t *)a3), 3), v90));
      }
      unint64_t v92 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v92 >= a8) {
        uint64_t v93 = -(uint64_t)a7;
      }
      else {
        uint64_t v93 = 0;
      }
      a3 = &v92[v93];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float32x4_t v94 = &a5[a4];
    if ((unint64_t)v94 >= a9) {
      uint64_t v95 = v18;
    }
    else {
      uint64_t v95 = 0;
    }
    uint64_t v96 = &v94[v95];
    uint64_t v97 = a8 + 16 * v95 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v96;
      a8 = v97;
      a5 = v96;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)4,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  int8x16_t v20 = vmvnq_s8(v19);
  int8x16_t v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v22 = 2 * a14;
  uint64_t v23 = -(a6 * a4);
  uint64_t v24 = 32 * a14;
  uint64_t v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12) {
        unint64_t v28 = a12;
      }
      unint64_t v29 = v28;
      if (v28 < 2) {
        goto LABEL_40;
      }
      while (1)
      {
        int v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          unint64_t v42 = (int8x16_t *)&a10[v29];
          int8x16_t v43 = (int8x16_t *)a10;
          do
            int64_t v44 = v43++;
          while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v44)) & 0x80) != 0);
          do
          {
            int64_t v45 = v44;
            int64_t v44 = (int8x16_t *)((char *)v44 + 4);
          }
          while (v44 <= v42 && !v45->i32[0]);
          if (v45 < v42)
          {
            while (!v45->i8[0])
            {
              int64_t v45 = (int8x16_t *)((char *)v45 + 1);
              if (v45 >= v42)
              {
                int64_t v45 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          int64_t v46 = (char *)v45 - a10;
          int64_t v47 = ((char *)v45 - a10) * a14;
          a3 += v47;
          result += v47;
          a10 += v47;
          v29 -= v46;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF) {
          break;
        }
        int v31 = (int8x16_t *)&a10[v29];
        float32x4_t v32 = (int8x16_t *)a10;
        do
          unint64_t v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          unint64_t v34 = v33;
          unint64_t v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            unint64_t v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              unint64_t v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        uint64_t v35 = 0;
        int64_t v36 = (char *)v34 - a10;
        unint64_t v37 = (char *)v34 - a10;
        do
        {
          unint64_t v38 = (float32x4_t *)((char *)result + v35);
          float32x4_t v39 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21);
          float32x4_t v40 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21);
          float32x4_t v41 = vaddq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35 + 16), *(float32x4_t *)((char *)result + v35 + 16)), vmlsq_laneq_f32(v40, v40, *(float32x4_t *)((char *)result + v35 + 16), 3));
          *unint64_t v38 = vaddq_f32(vsubq_f32(*(float32x4_t *)((char *)result + v35), *(float32x4_t *)((char *)result + v35)), vmlsq_laneq_f32(v39, v39, *(float32x4_t *)((char *)result + v35), 3));
          v38[1] = v41;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        float result = (float32x4_t *)((char *)result + v35);
        unint64_t v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1) {
          goto LABEL_40;
        }
      }
      uint64_t v48 = 0;
      while (1)
      {
        float32x4_t v49 = (float32x4_t *)((char *)result + v48);
        float32x4_t v50 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        float32x4_t v51 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v20), v21);
        float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v20), v21);
        float32x4_t v54 = vmlaq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v48 + 16), v50, *(float32x4_t *)((char *)result + v48 + 16)), v50, vmlsq_laneq_f32(v53, v53, *(float32x4_t *)((char *)result + v48 + 16), 3));
        *float32x4_t v49 = vmlaq_f32(vmlsq_f32(*(float32x4_t *)((char *)result + v48), v51, *(float32x4_t *)((char *)result + v48)), v51, vmlsq_laneq_f32(v52, v52, *(float32x4_t *)((char *)result + v48), 3));
        v49[1] = v54;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2) {
          break;
        }
        LOWORD(v30) = *(_WORD *)a10;
        v48 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v48);
          a3 = (int8x16_t *)((char *)a3 + v48);
          goto LABEL_37;
        }
      }
      float result = (float32x4_t *)((char *)result + v24 + v48);
      a3 = (int8x16_t *)((char *)a3 + v24 + v48);
LABEL_40:
      for (unint64_t i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          float32x4_t v56 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          float32x4_t v57 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21);
          *float result = vmlaq_f32(vmlsq_f32(*result, v56, *result), v56, vmlsq_laneq_f32(v57, v57, *result, 3));
        }
        uint64_t v58 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v58 >= a8) {
          uint64_t v59 = -(uint64_t)a7;
        }
        else {
          uint64_t v59 = 0;
        }
        a3 = &v58[v59];
        float result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      int8x16_t v60 = &a5[a4];
      if ((unint64_t)v60 >= a9) {
        uint64_t v61 = v23;
      }
      else {
        uint64_t v61 = 0;
      }
      unint64_t v62 = &v60[v61];
      uint64_t v63 = a8 + 16 * v61 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v62;
        a8 = v63;
        a5 = v62;
      }
      BOOL v64 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v64 | (a13 == 0)) {
        return result;
      }
    }
  }
  v65.i64[0] = -1;
  v65.i64[1] = -1;
  float32x4_t v66 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v67 = (a8 - (unint64_t)a3) >> 4;
    if (v67 >= a12) {
      unint64_t v67 = a12;
    }
    unint64_t v68 = v67;
    if (v67 < 2) {
      goto LABEL_90;
    }
    while (1)
    {
      int v69 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v82 = (int8x16_t *)&a10[v68];
        int64_t v83 = (int8x16_t *)a10;
        do
          float32x4_t v84 = v83++;
        while (v83 <= v82 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v84)) & 0x80) != 0);
        do
        {
          float32x4_t v85 = v84;
          float32x4_t v84 = (int8x16_t *)((char *)v84 + 4);
        }
        while (v84 <= v82 && !v85->i32[0]);
        if (v85 < v82)
        {
          while (!v85->i8[0])
          {
            float32x4_t v85 = (int8x16_t *)((char *)v85 + 1);
            if (v85 >= v82)
            {
              float32x4_t v85 = (int8x16_t *)&a10[v68];
              break;
            }
          }
        }
        int64_t v86 = (char *)v85 - a10;
        int64_t v87 = ((char *)v85 - a10) * a14;
        a3 += v87;
        result += v87;
        a10 += v87;
        v68 -= v86;
        goto LABEL_87;
      }
      if (v69 != 0xFFFF) {
        break;
      }
      int64_t v70 = (int8x16_t *)&a10[v68];
      unint64_t v71 = (int8x16_t *)a10;
      do
        uint64_t v72 = v71++;
      while (v71 <= v70 && (vminvq_u8((uint8x16_t)vceqq_s8(*v72, v65)) & 0x80) != 0);
      do
      {
        float32x4_t v73 = v72;
        uint64_t v72 = (int8x16_t *)((char *)v72 + 4);
      }
      while (v72 <= v70 && v73->i32[0] == -1);
      if (v73 < v70)
      {
        while (v73->u8[0] == 255)
        {
          float32x4_t v73 = (int8x16_t *)((char *)v73 + 1);
          if (v73 >= v70)
          {
            float32x4_t v73 = (int8x16_t *)&a10[v68];
            break;
          }
        }
      }
      uint64_t v74 = 0;
      int64_t v75 = (char *)v73 - a10;
      unint64_t v76 = (char *)v73 - a10;
      do
      {
        float32x4_t v77 = (int8x16_t *)((char *)result + v74);
        float32x4_t v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v74));
        float32x4_t v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v74));
        float32x4_t v80 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v74)), v20), v21);
        float32x4_t v81 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v74)), v20), v21);
        *float32x4_t v77 = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(v79, v79), vmlsq_laneq_f32(v80, v80, v79, 3)));
        v77[1] = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(v78, v78), vmlsq_laneq_f32(v81, v81, v78, 3)));
        a10 += v22;
        v76 -= 2;
        v74 += v24;
      }
      while (v76 > 1);
      a3 = (int8x16_t *)((char *)a3 + v74);
      float result = (float32x4_t *)((char *)result + v74);
      unint64_t v68 = v68 - v75 + v76;
LABEL_87:
      if (v68 <= 1) {
        goto LABEL_90;
      }
    }
    uint64_t v88 = 0;
    while (1)
    {
      float32x4_t v89 = (int8x16_t *)((char *)result + v88);
      float32x4_t v90 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v88));
      float32x4_t v91 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v88));
      float32x4_t v92 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v69)) & 0xFF00FF00FF00FFLL))), v66);
      float32x4_t v93 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v69) & 0xFF00FF00FF00FFLL))), v66);
      float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v88)), v20), v21);
      float32x4_t v95 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v88)), v20), v21);
      int8x16_t *v89 = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v91, v93, v91), v93, vmlsq_laneq_f32(v94, v94, v91, 3)));
      v89[1] = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v90, v92, v90), v92, vmlsq_laneq_f32(v95, v95, v90, 3)));
      a10 += v22;
      v68 -= 2;
      if (v68 < 2) {
        break;
      }
      LOWORD(v69) = *(_WORD *)a10;
      v88 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v88);
        a3 = (int8x16_t *)((char *)a3 + v88);
        goto LABEL_87;
      }
    }
    float result = (float32x4_t *)((char *)result + v24 + v88);
    a3 = (int8x16_t *)((char *)a3 + v24 + v88);
LABEL_90:
    for (unint64_t j = a12 - v67 + v68; j; --j)
    {
      if (*a10)
      {
        float32x4_t v97 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v98 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v66);
        float32x4_t v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_f32(vmlsq_f32(v97, v98, v97), v98, vmlsq_laneq_f32(v99, v99, v97, 3)));
      }
      uint64_t v100 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v100 >= a8) {
        uint64_t v101 = -(uint64_t)a7;
      }
      else {
        uint64_t v101 = 0;
      }
      a3 = &v100[v101];
      float result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    float32x4_t v102 = &a5[a4];
    if ((unint64_t)v102 >= a9) {
      uint64_t v103 = v23;
    }
    else {
      uint64_t v103 = 0;
    }
    uint64_t v104 = &v102[v103];
    uint64_t v105 = a8 + 16 * v103 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v104;
      a8 = v105;
      a5 = v104;
    }
    BOOL v64 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v64 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)8,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    float32x4_t v23 = (float32x4_t)vdupq_n_s32(0xBB808081);
    while (1)
    {
      unint64_t v24 = (a8 - (unint64_t)a3) >> 4;
      if (v24 >= a12) {
        unint64_t v24 = a12;
      }
      unint64_t v25 = v24;
      if (v24 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v26 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          int64_t v36 = (int8x16_t *)&a10[v25];
          unint64_t v37 = (int8x16_t *)a10;
          do
            unint64_t v38 = v37++;
          while (v37 <= v36 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v38)) & 0x80) != 0);
          do
          {
            float32x4_t v39 = v38;
            unint64_t v38 = (int8x16_t *)((char *)v38 + 4);
          }
          while (v38 <= v36 && !v39->i32[0]);
          if (v39 < v36)
          {
            while (!v39->i8[0])
            {
              float32x4_t v39 = (int8x16_t *)((char *)v39 + 1);
              if (v39 >= v36)
              {
                float32x4_t v39 = (int8x16_t *)&a10[v25];
                break;
              }
            }
          }
          int64_t v40 = (char *)v39 - a10;
          int64_t v41 = ((char *)v39 - a10) * a14;
          a3 += v41;
          result += v41;
          a10 += v41;
          v25 -= v40;
          goto LABEL_34;
        }
        if (v26 != 0xFFFF) {
          break;
        }
        float32x4_t v27 = (int8x16_t *)&a10[v25];
        unint64_t v28 = (int8x16_t *)a10;
        do
          unint64_t v29 = v28++;
        while (v28 <= v27 && (vminvq_u8((uint8x16_t)vceqq_s8(*v29, v21)) & 0x80) != 0);
        do
        {
          int v30 = v29;
          unint64_t v29 = (int8x16_t *)((char *)v29 + 4);
        }
        while (v29 <= v27 && v30->i32[0] == -1);
        if (v30 < v27)
        {
          while (v30->u8[0] == 255)
          {
            int v30 = (int8x16_t *)((char *)v30 + 1);
            if (v30 >= v27)
            {
              int v30 = (int8x16_t *)&a10[v25];
              break;
            }
          }
        }
        uint64_t v31 = 0;
        int64_t v32 = (char *)v30 - a10;
        unint64_t v33 = (char *)v30 - a10;
        do
        {
          unint64_t v34 = (float32x4_t *)((char *)result + v31);
          float32x4_t v35 = vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v31 + 16), *(float32x4_t *)((char *)result + v31 + 16), *(float32x4_t *)((char *)a3 + v31 + 16), 3);
          *unint64_t v34 = vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v31), *(float32x4_t *)((char *)result + v31), *(float32x4_t *)((char *)a3 + v31), 3);
          v34[1] = v35;
          a10 += v17;
          v33 -= 2;
          v31 += v19;
        }
        while (v33 > 1);
        a3 = (float32x4_t *)((char *)a3 + v31);
        float result = (float32x4_t *)((char *)result + v31);
        unint64_t v25 = v25 - v32 + v33;
LABEL_34:
        if (v25 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v42 = 0;
      while (1)
      {
        int8x16_t v43 = (float32x4_t *)((char *)result + v42);
        float32x4_t v44 = vmlsq_f32(*(float32x4_t *)((char *)result + v42 + 16), vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v26)) & 0xFF00FF00FF00FFLL))), v22), *(float32x4_t *)((char *)a3 + v42 + 16), 3), *(float32x4_t *)((char *)result + v42 + 16));
        *int8x16_t v43 = vmlsq_f32(*(float32x4_t *)((char *)result + v42), vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v26) & 0xFF00FF00FF00FFLL))), v22), *(float32x4_t *)((char *)a3 + v42), 3), *(float32x4_t *)((char *)result + v42));
        v43[1] = v44;
        a10 += v17;
        v25 -= 2;
        if (v25 < 2) {
          break;
        }
        LOWORD(v26) = *(_WORD *)a10;
        v42 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v42);
          a3 = (float32x4_t *)((char *)a3 + v42);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v42);
      a3 = (float32x4_t *)((char *)a3 + v19 + v42);
LABEL_37:
      for (unint64_t i = a12 - v24 + v25; i; --i)
      {
        if (*a10) {
          *float result = vmlaq_f32(*result, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v23), *a3, 3), *result);
        }
        int64_t v46 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v46 >= a8) {
          uint64_t v47 = -(uint64_t)a7;
        }
        else {
          uint64_t v47 = 0;
        }
        a3 = &v46[v47];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      uint64_t v48 = &a5[a4];
      if ((unint64_t)v48 >= a9) {
        uint64_t v49 = v18;
      }
      else {
        uint64_t v49 = 0;
      }
      float32x4_t v50 = &v48[v49];
      uint64_t v51 = a8 + 16 * v49 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v50;
        a8 = v51;
        a5 = v50;
      }
      BOOL v52 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v52 | (a13 == 0)) {
        return result;
      }
    }
  }
  v53.i64[0] = -1;
  v53.i64[1] = -1;
  float32x4_t v54 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  float32x4_t v55 = (float32x4_t)vdupq_n_s32(0xBB808081);
  while (2)
  {
    unint64_t v56 = (a8 - (unint64_t)a3) >> 4;
    if (v56 >= a12) {
      unint64_t v56 = a12;
    }
    unint64_t v57 = v56;
    if (v56 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v58 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        int64_t v70 = (int8x16_t *)&a10[v57];
        unint64_t v71 = (int8x16_t *)a10;
        do
          uint64_t v72 = v71++;
        while (v71 <= v70 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v72)) & 0x80) != 0);
        do
        {
          float32x4_t v73 = v72;
          uint64_t v72 = (int8x16_t *)((char *)v72 + 4);
        }
        while (v72 <= v70 && !v73->i32[0]);
        if (v73 < v70)
        {
          while (!v73->i8[0])
          {
            float32x4_t v73 = (int8x16_t *)((char *)v73 + 1);
            if (v73 >= v70)
            {
              float32x4_t v73 = (int8x16_t *)&a10[v57];
              break;
            }
          }
        }
        int64_t v74 = (char *)v73 - a10;
        int64_t v75 = ((char *)v73 - a10) * a14;
        a3 += v75;
        result += v75;
        a10 += v75;
        v57 -= v74;
        goto LABEL_84;
      }
      if (v58 != 0xFFFF) {
        break;
      }
      uint64_t v59 = (int8x16_t *)&a10[v57];
      int8x16_t v60 = (int8x16_t *)a10;
      do
        uint64_t v61 = v60++;
      while (v60 <= v59 && (vminvq_u8((uint8x16_t)vceqq_s8(*v61, v53)) & 0x80) != 0);
      do
      {
        unint64_t v62 = v61;
        uint64_t v61 = (int8x16_t *)((char *)v61 + 4);
      }
      while (v61 <= v59 && v62->i32[0] == -1);
      if (v62 < v59)
      {
        while (v62->u8[0] == 255)
        {
          unint64_t v62 = (int8x16_t *)((char *)v62 + 1);
          if (v62 >= v59)
          {
            unint64_t v62 = (int8x16_t *)&a10[v57];
            break;
          }
        }
      }
      uint64_t v63 = 0;
      int64_t v64 = (char *)v62 - a10;
      unint64_t v65 = (char *)v62 - a10;
      do
      {
        float32x4_t v66 = (int8x16_t *)((char *)result + v63);
        float32x4_t v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v63));
        float32x4_t v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v63));
        int8x16_t v69 = vrev32q_s8((int8x16_t)vmlsq_laneq_f32(v67, v67, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v63)), 3));
        int8x16_t *v66 = vrev32q_s8((int8x16_t)vmlsq_laneq_f32(v68, v68, (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v63)), 3));
        v66[1] = v69;
        a10 += v17;
        v65 -= 2;
        v63 += v19;
      }
      while (v65 > 1);
      a3 = (float32x4_t *)((char *)a3 + v63);
      float result = (float32x4_t *)((char *)result + v63);
      unint64_t v57 = v57 - v64 + v65;
LABEL_84:
      if (v57 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v76 = 0;
    while (1)
    {
      float32x4_t v77 = (int8x16_t *)((char *)result + v76);
      float32x4_t v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v76));
      float32x4_t v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v76));
      int8x16_t v80 = vrev32q_s8((int8x16_t)vmlsq_f32(v78, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v58)) & 0xFF00FF00FF00FFLL))), v54), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v76)), 3), v78));
      *float32x4_t v77 = vrev32q_s8((int8x16_t)vmlsq_f32(v79, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v58) & 0xFF00FF00FF00FFLL))), v54), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v76)), 3), v79));
      v77[1] = v80;
      a10 += v17;
      v57 -= 2;
      if (v57 < 2) {
        break;
      }
      LOWORD(v58) = *(_WORD *)a10;
      v76 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v76);
        a3 = (float32x4_t *)((char *)a3 + v76);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v76);
    a3 = (float32x4_t *)((char *)a3 + v19 + v76);
LABEL_87:
    for (unint64_t j = a12 - v56 + v57; j; --j)
    {
      if (*a10)
      {
        float32x4_t v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vmulq_laneq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v55), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3), 3), v82));
      }
      int64_t v83 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v83 >= a8) {
        uint64_t v84 = -(uint64_t)a7;
      }
      else {
        uint64_t v84 = 0;
      }
      a3 = &v83[v84];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float32x4_t v85 = &a5[a4];
    if ((unint64_t)v85 >= a9) {
      uint64_t v86 = v18;
    }
    else {
      uint64_t v86 = 0;
    }
    int64_t v87 = &v85[v86];
    uint64_t v88 = a8 + 16 * v86 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v87;
      a8 = v88;
      a5 = v87;
    }
    BOOL v52 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v52 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)5,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12) {
        unint64_t v23 = a12;
      }
      unint64_t v24 = v23;
      if (v23 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v35 = (int8x16_t *)&a10[v24];
          int64_t v36 = (int8x16_t *)a10;
          do
            unint64_t v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            unint64_t v38 = v37;
            unint64_t v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                unint64_t v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          int64_t v39 = (char *)v38 - a10;
          int64_t v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF) {
          break;
        }
        int v26 = (int8x16_t *)&a10[v24];
        float32x4_t v27 = (int8x16_t *)a10;
        do
          unint64_t v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          unint64_t v29 = v28;
          unint64_t v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            unint64_t v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              unint64_t v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        uint64_t v30 = 0;
        int64_t v31 = (char *)v29 - a10;
        unint64_t v32 = (char *)v29 - a10;
        do
        {
          unint64_t v33 = (float32x4_t *)((char *)result + v30);
          float32x4_t v34 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3);
          *unint64_t v33 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3);
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        float result = (float32x4_t *)((char *)result + v30);
        unint64_t v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v41 = 0;
      while (1)
      {
        uint64_t v42 = (float32x4_t *)((char *)result + v41);
        float32x4_t v43 = vmulq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22));
        float32x4_t v44 = vmulq_f32(*(float32x4_t *)((char *)a3 + v41), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22));
        float32x4_t v45 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), v43, 3), v43, *(float32x4_t *)((char *)result + v41 + 16), 3);
        *uint64_t v42 = vmlaq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)result + v41), v44, 3), v44, *(float32x4_t *)((char *)result + v41), 3);
        v42[1] = v45;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2) {
          break;
        }
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (unint64_t i = a12 - v23 + v24; i; --i)
      {
        if (*a10)
        {
          float32x4_t v47 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22), *a3);
          *float result = vmlaq_laneq_f32(vmlsq_laneq_f32(*result, *result, v47, 3), v47, *result, 3);
        }
        uint64_t v48 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v48 >= a8) {
          uint64_t v49 = -(uint64_t)a7;
        }
        else {
          uint64_t v49 = 0;
        }
        a3 = &v48[v49];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      float32x4_t v50 = &a5[a4];
      if ((unint64_t)v50 >= a9) {
        uint64_t v51 = v18;
      }
      else {
        uint64_t v51 = 0;
      }
      BOOL v52 = &v50[v51];
      uint64_t v53 = a8 + 16 * v51 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v52;
        a8 = v53;
        a5 = v52;
      }
      BOOL v54 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v54 | (a13 == 0)) {
        return result;
      }
    }
  }
  v55.i64[0] = -1;
  v55.i64[1] = -1;
  float32x4_t v56 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v57 = (a8 - (unint64_t)a3) >> 4;
    if (v57 >= a12) {
      unint64_t v57 = a12;
    }
    unint64_t v58 = v57;
    if (v57 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v59 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v72 = (int8x16_t *)&a10[v58];
        float32x4_t v73 = (int8x16_t *)a10;
        do
          int64_t v74 = v73++;
        while (v73 <= v72 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v74)) & 0x80) != 0);
        do
        {
          int64_t v75 = v74;
          int64_t v74 = (int8x16_t *)((char *)v74 + 4);
        }
        while (v74 <= v72 && !v75->i32[0]);
        if (v75 < v72)
        {
          while (!v75->i8[0])
          {
            int64_t v75 = (int8x16_t *)((char *)v75 + 1);
            if (v75 >= v72)
            {
              int64_t v75 = (int8x16_t *)&a10[v58];
              break;
            }
          }
        }
        int64_t v76 = (char *)v75 - a10;
        int64_t v77 = ((char *)v75 - a10) * a14;
        a3 += v77;
        result += v77;
        a10 += v77;
        v58 -= v76;
        goto LABEL_84;
      }
      if (v59 != 0xFFFF) {
        break;
      }
      int8x16_t v60 = (int8x16_t *)&a10[v58];
      uint64_t v61 = (int8x16_t *)a10;
      do
        unint64_t v62 = v61++;
      while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqq_s8(*v62, v55)) & 0x80) != 0);
      do
      {
        uint64_t v63 = v62;
        unint64_t v62 = (int8x16_t *)((char *)v62 + 4);
      }
      while (v62 <= v60 && v63->i32[0] == -1);
      if (v63 < v60)
      {
        while (v63->u8[0] == 255)
        {
          uint64_t v63 = (int8x16_t *)((char *)v63 + 1);
          if (v63 >= v60)
          {
            uint64_t v63 = (int8x16_t *)&a10[v58];
            break;
          }
        }
      }
      uint64_t v64 = 0;
      int64_t v65 = (char *)v63 - a10;
      unint64_t v66 = (char *)v63 - a10;
      do
      {
        float32x4_t v67 = (int8x16_t *)((char *)result + v64);
        float32x4_t v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v64));
        float32x4_t v69 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v64));
        float32x4_t v70 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v64));
        float32x4_t v71 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v64));
        int8x16_t *v67 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v71, v71, v69, 3), v69, v71, 3));
        v67[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v70, v70, v68, 3), v68, v70, 3));
        a10 += v17;
        v66 -= 2;
        v64 += v19;
      }
      while (v66 > 1);
      a3 = (float32x4_t *)((char *)a3 + v64);
      float result = (float32x4_t *)((char *)result + v64);
      unint64_t v58 = v58 - v65 + v66;
LABEL_84:
      if (v58 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v78 = 0;
    while (1)
    {
      float32x4_t v79 = (int8x16_t *)((char *)result + v78);
      float32x4_t v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v78));
      float32x4_t v81 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v78));
      float32x4_t v82 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v59)) & 0xFF00FF00FF00FFLL))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v78)));
      float32x4_t v83 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v59) & 0xFF00FF00FF00FFLL))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v78)));
      int8x16_t *v79 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v81, v81, v83, 3), v83, v81, 3));
      v79[1] = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v80, v80, v82, 3), v82, v80, 3));
      a10 += v17;
      v58 -= 2;
      if (v58 < 2) {
        break;
      }
      LOWORD(v59) = *(_WORD *)a10;
      v78 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v78);
        a3 = (float32x4_t *)((char *)a3 + v78);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v78);
    a3 = (float32x4_t *)((char *)a3 + v19 + v78);
LABEL_87:
    for (unint64_t j = a12 - v57 + v58; j; --j)
    {
      if (*a10)
      {
        float32x4_t v85 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v86 = vmulq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v56), (float32x4_t)vrev32q_s8(*(int8x16_t *)a3));
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmlsq_laneq_f32(v85, v85, v86, 3), v86, v85, 3));
      }
      int64_t v87 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v87 >= a8) {
        uint64_t v88 = -(uint64_t)a7;
      }
      else {
        uint64_t v88 = 0;
      }
      a3 = &v87[v88];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float32x4_t v89 = &a5[a4];
    if ((unint64_t)v89 >= a9) {
      uint64_t v90 = v18;
    }
    else {
      uint64_t v90 = 0;
    }
    float32x4_t v91 = &v89[v90];
    uint64_t v92 = a8 + 16 * v90 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v91;
      a8 = v92;
      a5 = v91;
    }
    BOOL v54 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v54 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)9,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12) {
        unint64_t v23 = a12;
      }
      unint64_t v24 = v23;
      if (v23 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v35 = (int8x16_t *)&a10[v24];
          int64_t v36 = (int8x16_t *)a10;
          do
            unint64_t v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            unint64_t v38 = v37;
            unint64_t v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                unint64_t v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          int64_t v39 = (char *)v38 - a10;
          int64_t v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF) {
          break;
        }
        int v26 = (int8x16_t *)&a10[v24];
        float32x4_t v27 = (int8x16_t *)a10;
        do
          unint64_t v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          unint64_t v29 = v28;
          unint64_t v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            unint64_t v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              unint64_t v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        uint64_t v30 = 0;
        int64_t v31 = (char *)v29 - a10;
        unint64_t v32 = (char *)v29 - a10;
        do
        {
          unint64_t v33 = (float32x4_t *)((char *)result + v30);
          float32x4_t v34 = vaddq_f32(*(float32x4_t *)((char *)result + v30 + 16), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3)));
          *unint64_t v33 = vaddq_f32(*(float32x4_t *)((char *)result + v30), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3)));
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        float result = (float32x4_t *)((char *)result + v30);
        unint64_t v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v41 = 0;
      while (1)
      {
        uint64_t v42 = (float32x4_t *)((char *)result + v41);
        float32x4_t v43 = vmlaq_f32(*(float32x4_t *)((char *)result + v41 + 16), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22));
        *uint64_t v42 = vmlaq_f32(*(float32x4_t *)((char *)result + v41), vsubq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)result + v41), 3), vmlsq_laneq_f32(*(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)a3 + v41), 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22));
        v42[1] = v43;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2) {
          break;
        }
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (unint64_t i = a12 - v23 + v24; i; --i)
      {
        if (*a10) {
          *float result = vmlaq_f32(*result, vsubq_f32(vmlsq_laneq_f32(*a3, *a3, *result, 3), vmlsq_laneq_f32(*result, *result, *a3, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22));
        }
        float32x4_t v45 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v45 >= a8) {
          uint64_t v46 = -(uint64_t)a7;
        }
        else {
          uint64_t v46 = 0;
        }
        a3 = &v45[v46];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      float32x4_t v47 = &a5[a4];
      if ((unint64_t)v47 >= a9) {
        uint64_t v48 = v18;
      }
      else {
        uint64_t v48 = 0;
      }
      uint64_t v49 = &v47[v48];
      uint64_t v50 = a8 + 16 * v48 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v49;
        a8 = v50;
        a5 = v49;
      }
      BOOL v51 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v51 | (a13 == 0)) {
        return result;
      }
    }
  }
  v52.i64[0] = -1;
  v52.i64[1] = -1;
  float32x4_t v53 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v54 = (a8 - (unint64_t)a3) >> 4;
    if (v54 >= a12) {
      unint64_t v54 = a12;
    }
    unint64_t v55 = v54;
    if (v54 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v56 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v69 = (int8x16_t *)&a10[v55];
        float32x4_t v70 = (int8x16_t *)a10;
        do
          float32x4_t v71 = v70++;
        while (v70 <= v69 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v71)) & 0x80) != 0);
        do
        {
          uint64_t v72 = v71;
          float32x4_t v71 = (int8x16_t *)((char *)v71 + 4);
        }
        while (v71 <= v69 && !v72->i32[0]);
        if (v72 < v69)
        {
          while (!v72->i8[0])
          {
            uint64_t v72 = (int8x16_t *)((char *)v72 + 1);
            if (v72 >= v69)
            {
              uint64_t v72 = (int8x16_t *)&a10[v55];
              break;
            }
          }
        }
        int64_t v73 = (char *)v72 - a10;
        int64_t v74 = ((char *)v72 - a10) * a14;
        a3 += v74;
        result += v74;
        a10 += v74;
        v55 -= v73;
        goto LABEL_84;
      }
      if (v56 != 0xFFFF) {
        break;
      }
      unint64_t v57 = (int8x16_t *)&a10[v55];
      unint64_t v58 = (int8x16_t *)a10;
      do
        int v59 = v58++;
      while (v58 <= v57 && (vminvq_u8((uint8x16_t)vceqq_s8(*v59, v52)) & 0x80) != 0);
      do
      {
        int8x16_t v60 = v59;
        int v59 = (int8x16_t *)((char *)v59 + 4);
      }
      while (v59 <= v57 && v60->i32[0] == -1);
      if (v60 < v57)
      {
        while (v60->u8[0] == 255)
        {
          int8x16_t v60 = (int8x16_t *)((char *)v60 + 1);
          if (v60 >= v57)
          {
            int8x16_t v60 = (int8x16_t *)&a10[v55];
            break;
          }
        }
      }
      uint64_t v61 = 0;
      int64_t v62 = (char *)v60 - a10;
      unint64_t v63 = (char *)v60 - a10;
      do
      {
        uint64_t v64 = (int8x16_t *)((char *)result + v61);
        float32x4_t v65 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v61));
        float32x4_t v66 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v61));
        float32x4_t v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v61));
        float32x4_t v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v61));
        *uint64_t v64 = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(vmlsq_laneq_f32(v66, v66, v68, 3), vmlsq_laneq_f32(v68, v68, v66, 3)), v68));
        v64[1] = vrev32q_s8((int8x16_t)vaddq_f32(vsubq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vmlsq_laneq_f32(v67, v67, v65, 3)), v67));
        a10 += v17;
        v63 -= 2;
        v61 += v19;
      }
      while (v63 > 1);
      a3 = (float32x4_t *)((char *)a3 + v61);
      float result = (float32x4_t *)((char *)result + v61);
      unint64_t v55 = v55 - v62 + v63;
LABEL_84:
      if (v55 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v75 = 0;
    while (1)
    {
      int64_t v76 = (int8x16_t *)((char *)result + v75);
      float32x4_t v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
      float32x4_t v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
      float32x4_t v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
      float32x4_t v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
      *int64_t v76 = vrev32q_s8((int8x16_t)vmlaq_f32(v80, vsubq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), vmlsq_laneq_f32(v80, v80, v78, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v56) & 0xFF00FF00FF00FFLL))), v53)));
      v76[1] = vrev32q_s8((int8x16_t)vmlaq_f32(v79, vsubq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), vmlsq_laneq_f32(v79, v79, v77, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v56)) & 0xFF00FF00FF00FFLL))), v53)));
      a10 += v17;
      v55 -= 2;
      if (v55 < 2) {
        break;
      }
      LOWORD(v56) = *(_WORD *)a10;
      v75 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v75);
        a3 = (float32x4_t *)((char *)a3 + v75);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v75);
    a3 = (float32x4_t *)((char *)a3 + v19 + v75);
LABEL_87:
    for (unint64_t j = a12 - v54 + v55; j; --j)
    {
      if (*a10)
      {
        float32x4_t v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)a3);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vsubq_f32(vmlsq_laneq_f32(v83, v83, v82, 3), vmlsq_laneq_f32(v82, v82, v83, 3)), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v53)));
      }
      uint64_t v84 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v84 >= a8) {
        uint64_t v85 = -(uint64_t)a7;
      }
      else {
        uint64_t v85 = 0;
      }
      a3 = &v84[v85];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float32x4_t v86 = &a5[a4];
    if ((unint64_t)v86 >= a9) {
      uint64_t v87 = v18;
    }
    else {
      uint64_t v87 = 0;
    }
    uint64_t v88 = &v86[v87];
    uint64_t v89 = a8 + 16 * v87 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v88;
      a8 = v89;
      a5 = v88;
    }
    BOOL v51 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v51 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)10,_rgbaf_t>(float32x4_t *result, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, char a15)
{
  uint64_t v17 = 2 * a14;
  uint64_t v18 = -(a6 * a4);
  uint64_t v19 = 32 * a14;
  uint64_t v20 = 16 * a14;
  if ((a15 & 0x30) != 0)
  {
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v23 = (a8 - (unint64_t)a3) >> 4;
      if (v23 >= a12) {
        unint64_t v23 = a12;
      }
      unint64_t v24 = v23;
      if (v23 < 2) {
        goto LABEL_37;
      }
      while (1)
      {
        int v25 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v35 = (int8x16_t *)&a10[v24];
          int64_t v36 = (int8x16_t *)a10;
          do
            unint64_t v37 = v36++;
          while (v36 <= v35 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v37)) & 0x80) != 0);
          do
          {
            unint64_t v38 = v37;
            unint64_t v37 = (int8x16_t *)((char *)v37 + 4);
          }
          while (v37 <= v35 && !v38->i32[0]);
          if (v38 < v35)
          {
            while (!v38->i8[0])
            {
              unint64_t v38 = (int8x16_t *)((char *)v38 + 1);
              if (v38 >= v35)
              {
                unint64_t v38 = (int8x16_t *)&a10[v24];
                break;
              }
            }
          }
          int64_t v39 = (char *)v38 - a10;
          int64_t v40 = ((char *)v38 - a10) * a14;
          a3 += v40;
          result += v40;
          a10 += v40;
          v24 -= v39;
          goto LABEL_34;
        }
        if (v25 != 0xFFFF) {
          break;
        }
        int v26 = (int8x16_t *)&a10[v24];
        float32x4_t v27 = (int8x16_t *)a10;
        do
          unint64_t v28 = v27++;
        while (v27 <= v26 && (vminvq_u8((uint8x16_t)vceqq_s8(*v28, v21)) & 0x80) != 0);
        do
        {
          unint64_t v29 = v28;
          unint64_t v28 = (int8x16_t *)((char *)v28 + 4);
        }
        while (v28 <= v26 && v29->i32[0] == -1);
        if (v29 < v26)
        {
          while (v29->u8[0] == 255)
          {
            unint64_t v29 = (int8x16_t *)((char *)v29 + 1);
            if (v29 >= v26)
            {
              unint64_t v29 = (int8x16_t *)&a10[v24];
              break;
            }
          }
        }
        uint64_t v30 = 0;
        int64_t v31 = (char *)v29 - a10;
        unint64_t v32 = (char *)v29 - a10;
        do
        {
          unint64_t v33 = (float32x4_t *)((char *)result + v30);
          float32x4_t v34 = vaddq_f32(*(float32x4_t *)((char *)result + v30 + 16), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), *(float32x4_t *)((char *)result + v30 + 16), 3), *(float32x4_t *)((char *)result + v30 + 16), *(float32x4_t *)((char *)a3 + v30 + 16), 3));
          *unint64_t v33 = vaddq_f32(*(float32x4_t *)((char *)result + v30), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)a3 + v30), *(float32x4_t *)((char *)result + v30), 3), *(float32x4_t *)((char *)result + v30), *(float32x4_t *)((char *)a3 + v30), 3));
          v33[1] = v34;
          a10 += v17;
          v32 -= 2;
          v30 += v19;
        }
        while (v32 > 1);
        a3 = (float32x4_t *)((char *)a3 + v30);
        float result = (float32x4_t *)((char *)result + v30);
        unint64_t v24 = v24 - v31 + v32;
LABEL_34:
        if (v24 <= 1) {
          goto LABEL_37;
        }
      }
      uint64_t v41 = 0;
      while (1)
      {
        uint64_t v42 = (float32x4_t *)((char *)result + v41);
        float32x4_t v43 = vmlaq_f32(*(float32x4_t *)((char *)result + v41 + 16), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v25)) & 0xFF00FF00FF00FFLL))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), *(float32x4_t *)((char *)result + v41 + 16), 3), *(float32x4_t *)((char *)result + v41 + 16), *(float32x4_t *)((char *)a3 + v41 + 16), 3));
        *uint64_t v42 = vmlaq_f32(*(float32x4_t *)((char *)result + v41), vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v25) & 0xFF00FF00FF00FFLL))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)a3 + v41), *(float32x4_t *)((char *)result + v41), 3), *(float32x4_t *)((char *)result + v41), *(float32x4_t *)((char *)a3 + v41), 3));
        v42[1] = v43;
        a10 += v17;
        v24 -= 2;
        if (v24 < 2) {
          break;
        }
        LOWORD(v25) = *(_WORD *)a10;
        v41 += v19;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v41);
          a3 = (float32x4_t *)((char *)a3 + v41);
          goto LABEL_34;
        }
      }
      float result = (float32x4_t *)((char *)result + v19 + v41);
      a3 = (float32x4_t *)((char *)a3 + v19 + v41);
LABEL_37:
      for (unint64_t i = a12 - v23 + v24; i; --i)
      {
        if (*a10) {
          *float result = vmlaq_f32(*result, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v22), vmlsq_laneq_f32(vmlsq_laneq_f32(*a3, *a3, *result, 3), *result, *a3, 3));
        }
        float32x4_t v45 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v45 >= a8) {
          uint64_t v46 = -(uint64_t)a7;
        }
        else {
          uint64_t v46 = 0;
        }
        a3 = &v45[v46];
        float result = (float32x4_t *)((char *)result + v20);
      }
      a10 += a11;
      result += a2;
      float32x4_t v47 = &a5[a4];
      if ((unint64_t)v47 >= a9) {
        uint64_t v48 = v18;
      }
      else {
        uint64_t v48 = 0;
      }
      uint64_t v49 = &v47[v48];
      uint64_t v50 = a8 + 16 * v48 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v49;
        a8 = v50;
        a5 = v49;
      }
      BOOL v51 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v51 | (a13 == 0)) {
        return result;
      }
    }
  }
  v52.i64[0] = -1;
  v52.i64[1] = -1;
  float32x4_t v53 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v54 = (a8 - (unint64_t)a3) >> 4;
    if (v54 >= a12) {
      unint64_t v54 = a12;
    }
    unint64_t v55 = v54;
    if (v54 < 2) {
      goto LABEL_87;
    }
    while (1)
    {
      int v56 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v69 = (int8x16_t *)&a10[v55];
        float32x4_t v70 = (int8x16_t *)a10;
        do
          float32x4_t v71 = v70++;
        while (v70 <= v69 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v71)) & 0x80) != 0);
        do
        {
          uint64_t v72 = v71;
          float32x4_t v71 = (int8x16_t *)((char *)v71 + 4);
        }
        while (v71 <= v69 && !v72->i32[0]);
        if (v72 < v69)
        {
          while (!v72->i8[0])
          {
            uint64_t v72 = (int8x16_t *)((char *)v72 + 1);
            if (v72 >= v69)
            {
              uint64_t v72 = (int8x16_t *)&a10[v55];
              break;
            }
          }
        }
        int64_t v73 = (char *)v72 - a10;
        int64_t v74 = ((char *)v72 - a10) * a14;
        a3 += v74;
        result += v74;
        a10 += v74;
        v55 -= v73;
        goto LABEL_84;
      }
      if (v56 != 0xFFFF) {
        break;
      }
      unint64_t v57 = (int8x16_t *)&a10[v55];
      unint64_t v58 = (int8x16_t *)a10;
      do
        int v59 = v58++;
      while (v58 <= v57 && (vminvq_u8((uint8x16_t)vceqq_s8(*v59, v52)) & 0x80) != 0);
      do
      {
        int8x16_t v60 = v59;
        int v59 = (int8x16_t *)((char *)v59 + 4);
      }
      while (v59 <= v57 && v60->i32[0] == -1);
      if (v60 < v57)
      {
        while (v60->u8[0] == 255)
        {
          int8x16_t v60 = (int8x16_t *)((char *)v60 + 1);
          if (v60 >= v57)
          {
            int8x16_t v60 = (int8x16_t *)&a10[v55];
            break;
          }
        }
      }
      uint64_t v61 = 0;
      int64_t v62 = (char *)v60 - a10;
      unint64_t v63 = (char *)v60 - a10;
      do
      {
        uint64_t v64 = (int8x16_t *)((char *)result + v61);
        float32x4_t v65 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v61));
        float32x4_t v66 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v61));
        float32x4_t v67 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v61));
        float32x4_t v68 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v61));
        *uint64_t v64 = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(vmlsq_laneq_f32(v66, v66, v68, 3), v68, v66, 3), v68));
        v64[1] = vrev32q_s8((int8x16_t)vaddq_f32(vmlsq_laneq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), v67, v65, 3), v67));
        a10 += v17;
        v63 -= 2;
        v61 += v19;
      }
      while (v63 > 1);
      a3 = (float32x4_t *)((char *)a3 + v61);
      float result = (float32x4_t *)((char *)result + v61);
      unint64_t v55 = v55 - v62 + v63;
LABEL_84:
      if (v55 <= 1) {
        goto LABEL_87;
      }
    }
    uint64_t v75 = 0;
    while (1)
    {
      int64_t v76 = (int8x16_t *)((char *)result + v75);
      float32x4_t v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v75));
      float32x4_t v78 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)a3 + v75));
      float32x4_t v79 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v75));
      float32x4_t v80 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v75));
      *int64_t v76 = vrev32q_s8((int8x16_t)vmlaq_f32(v80, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v56) & 0xFF00FF00FF00FFLL))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), v80, v78, 3)));
      v76[1] = vrev32q_s8((int8x16_t)vmlaq_f32(v79, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v56)) & 0xFF00FF00FF00FFLL))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), v79, v77, 3)));
      a10 += v17;
      v55 -= 2;
      if (v55 < 2) {
        break;
      }
      LOWORD(v56) = *(_WORD *)a10;
      v75 += v19;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v75);
        a3 = (float32x4_t *)((char *)a3 + v75);
        goto LABEL_84;
      }
    }
    float result = (float32x4_t *)((char *)result + v19 + v75);
    a3 = (float32x4_t *)((char *)a3 + v19 + v75);
LABEL_87:
    for (unint64_t j = a12 - v54 + v55; j; --j)
    {
      if (*a10)
      {
        float32x4_t v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)a3);
        *(int8x16_t *)float result = vrev32q_s8((int8x16_t)vmlaq_f32(v82, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v53), vmlsq_laneq_f32(vmlsq_laneq_f32(v83, v83, v82, 3), v82, v83, 3)));
      }
      uint64_t v84 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v84 >= a8) {
        uint64_t v85 = -(uint64_t)a7;
      }
      else {
        uint64_t v85 = 0;
      }
      a3 = &v84[v85];
      float result = (float32x4_t *)((char *)result + v20);
    }
    a10 += a11;
    result += a2;
    float32x4_t v86 = &a5[a4];
    if ((unint64_t)v86 >= a9) {
      uint64_t v87 = v18;
    }
    else {
      uint64_t v87 = 0;
    }
    uint64_t v88 = &v86[v87];
    uint64_t v89 = a8 + 16 * v87 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v88;
      a8 = v89;
      a5 = v88;
    }
    BOOL v51 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v51 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)11,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          unint64_t v58 = (int8x16_t *)&a10[v40];
          int v59 = (int8x16_t *)a10;
          do
            int8x16_t v60 = v59++;
          while (v59 <= v58 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v60)) & 0x80) != 0);
          do
          {
            uint64_t v61 = v60;
            int8x16_t v60 = (int8x16_t *)((char *)v60 + 4);
          }
          while (v60 <= v58 && !v61->i32[0]);
          if (v61 < v58)
          {
            while (!v61->i8[0])
            {
              uint64_t v61 = (int8x16_t *)((char *)v61 + 1);
              if (v61 >= v58)
              {
                uint64_t v61 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v62 = (char *)v61 - a10;
          int64_t v63 = ((char *)v61 - a10) * a14;
          a3 += v63;
          result += v63;
          a10 += v63;
          v40 -= v62;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        uint64_t v42 = (int8x16_t *)&a10[v40];
        float32x4_t v43 = (int8x16_t *)a10;
        do
          float32x4_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          float32x4_t v45 = v44;
          float32x4_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            float32x4_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              float32x4_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          uint64_t v49 = (float32x4_t *)&result->i8[v46];
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3);
          float32x4_t v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          float32x4_t v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          *uint64_t v49 = vsubq_f32(vminnmq_f32(vaddq_f32(v54, v56), _Q5), vaddq_f32(vsubq_f32(v54, v51), vsubq_f32(v56, v53)));
          v49[1] = vsubq_f32(vminnmq_f32(vaddq_f32(v55, v57), _Q5), vaddq_f32(vsubq_f32(v55, v50), vsubq_f32(v57, v52)));
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v64 = 0;
      while (1)
      {
        float32x4_t v65 = (int8x16_t *)((char *)result + v64);
        float32x4_t v66 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v67 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v68 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v64), v22), v25);
        float32x4_t v69 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v64), v22), v25);
        float32x4_t v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v67)), (int8x16_t)_Q5, *(int8x16_t *)((char *)&result[1] + v64));
        float32x4_t v71 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v66)), (int8x16_t)_Q5, *(int8x16_t *)((char *)result + v64));
        float32x4_t v72 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3);
        float32x4_t v73 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3);
        *float32x4_t v65 = vbslq_s8((int8x16_t)vceqzq_f32(v66), (int8x16_t)v71, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v72, v66, v68, 3), _Q5), vmlaq_f32(vsubq_f32(v72, v71), v66, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), v68))));
        v65[1] = vbslq_s8((int8x16_t)vceqzq_f32(v67), (int8x16_t)v70, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v73, v67, v69, 3), _Q5), vmlaq_f32(vsubq_f32(v73, v70), v67, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3), v69))));
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v64 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v64);
          a3 = (int8x16_t *)((char *)a3 + v64);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v64);
      a3 = (int8x16_t *)((char *)a3 + v30 + v64);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v76 = (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25);
          float32x4_t v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), (int8x16_t)_Q5, *result);
          float32x4_t v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
          *float result = vbslq_s8((int8x16_t)vceqzq_f32(v75), (int8x16_t)v77, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v78, v75, v76, 3), _Q5), vmlaq_f32(vsubq_f32(v78, v77), v75, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3), v76))));
        }
        float32x4_t v79 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v79 >= a8) {
          uint64_t v80 = -(uint64_t)a7;
        }
        else {
          uint64_t v80 = 0;
        }
        a3 = &v79[v80];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v81 = &a5[a4];
      if ((unint64_t)v81 >= a9) {
        uint64_t v82 = v29;
      }
      else {
        uint64_t v82 = 0;
      }
      float32x4_t v83 = &v81[v82];
      uint64_t v84 = a8 + 16 * v82 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v83;
        a8 = v84;
        a5 = v83;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v85.i64[0] = -1;
  v85.i64[1] = -1;
  float32x4_t v86 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v87 = (a8 - (unint64_t)a3) >> 4;
    if (v87 >= a12) {
      unint64_t v87 = a12;
    }
    unint64_t v88 = v87;
    if (v87 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v89 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        int64_t v106 = (int8x16_t *)&a10[v88];
        int64_t v107 = (int8x16_t *)a10;
        do
          uint64_t v108 = v107++;
        while (v107 <= v106 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v108)) & 0x80) != 0);
        do
        {
          int8x16_t v109 = v108;
          uint64_t v108 = (int8x16_t *)((char *)v108 + 4);
        }
        while (v108 <= v106 && !v109->i32[0]);
        if (v109 < v106)
        {
          while (!v109->i8[0])
          {
            int8x16_t v109 = (int8x16_t *)((char *)v109 + 1);
            if (v109 >= v106)
            {
              int8x16_t v109 = (int8x16_t *)&a10[v88];
              break;
            }
          }
        }
        int64_t v110 = (char *)v109 - a10;
        int64_t v111 = ((char *)v109 - a10) * a14;
        a3 += v111;
        result += v111;
        a10 += v111;
        v88 -= v110;
        goto LABEL_90;
      }
      if (v89 != 0xFFFF) {
        break;
      }
      uint64_t v90 = (int8x16_t *)&a10[v88];
      float32x4_t v91 = (int8x16_t *)a10;
      do
        uint64_t v92 = v91++;
      while (v91 <= v90 && (vminvq_u8((uint8x16_t)vceqq_s8(*v92, v85)) & 0x80) != 0);
      do
      {
        float32x4_t v93 = v92;
        uint64_t v92 = (int8x16_t *)((char *)v92 + 4);
      }
      while (v92 <= v90 && v93->i32[0] == -1);
      if (v93 < v90)
      {
        while (v93->u8[0] == 255)
        {
          float32x4_t v93 = (int8x16_t *)((char *)v93 + 1);
          if (v93 >= v90)
          {
            float32x4_t v93 = (int8x16_t *)&a10[v88];
            break;
          }
        }
      }
      uint64_t v94 = 0;
      int64_t v95 = (char *)v93 - a10;
      unint64_t v96 = (char *)v93 - a10;
      do
      {
        float32x4_t v97 = (int8x16_t *)((char *)result + v94);
        float32x4_t v98 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v94)), v22), v25);
        float32x4_t v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v94)), v22), v25);
        float32x4_t v100 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v94)), v26), v27);
        float32x4_t v101 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v94)), v26), v27);
        float32x4_t v102 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3);
        float32x4_t v103 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3);
        float32x4_t v104 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 3);
        float32x4_t v105 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v100, 3);
        int8x16_t *v97 = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v102, v104), _Q5), vaddq_f32(vsubq_f32(v102, v99), vsubq_f32(v104, v101))));
        v97[1] = vrev32q_s8((int8x16_t)vsubq_f32(vminnmq_f32(vaddq_f32(v103, v105), _Q5), vaddq_f32(vsubq_f32(v103, v98), vsubq_f32(v105, v100))));
        a10 += v28;
        v96 -= 2;
        v94 += v30;
      }
      while (v96 > 1);
      a3 = (int8x16_t *)((char *)a3 + v94);
      float result = (int8x16_t *)((char *)result + v94);
      unint64_t v88 = v88 - v95 + v96;
LABEL_90:
      if (v88 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v112 = 0;
    while (1)
    {
      float32x4_t v113 = (int8x16_t *)((char *)result + v112);
      float32x4_t v114 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v89) & 0xFF00FF00FF00FFLL))), v86);
      float32x4_t v115 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v89)) & 0xFF00FF00FF00FFLL))), v86);
      float32x4_t v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
      float32x4_t v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
      float32x4_t v118 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v115)), (int8x16_t)_Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)));
      float32x4_t v119 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v114)), (int8x16_t)_Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v112)));
      float32x4_t v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
      float32x4_t v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
      *float32x4_t v113 = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v114), (int8x16_t)v119, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v120, v114, v117, 3), _Q5), vmlaq_f32(vsubq_f32(v120, v119), v114, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3), v117)))));
      v113[1] = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v115), (int8x16_t)v118, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v121, v115, v116, 3), _Q5), vmlaq_f32(vsubq_f32(v121, v118), v115, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3), v116)))));
      a10 += v28;
      v88 -= 2;
      if (v88 < 2) {
        break;
      }
      LOWORD(v89) = *(_WORD *)a10;
      v112 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v112);
        a3 = (int8x16_t *)((char *)a3 + v112);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v112);
    a3 = (int8x16_t *)((char *)a3 + v30 + v112);
LABEL_93:
    for (unint64_t j = a12 - v87 + v88; j; --j)
    {
      if (*a10)
      {
        float32x4_t v123 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v86);
        float32x4_t v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25);
        float32x4_t v125 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v123)), (int8x16_t)_Q5, vrev32q_s8(*result));
        float32x4_t v126 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v125, 3);
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vceqzq_f32(v123), (int8x16_t)v125, (int8x16_t)vsubq_f32(vminnmq_f32(vmlaq_laneq_f32(v126, v123, v124, 3), _Q5), vmlaq_f32(vsubq_f32(v126, v125), v123, vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3), v124)))));
      }
      uint64_t v127 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v127 >= a8) {
        uint64_t v128 = -(uint64_t)a7;
      }
      else {
        uint64_t v128 = 0;
      }
      a3 = &v127[v128];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    uint64_t v129 = &a5[a4];
    if ((unint64_t)v129 >= a9) {
      uint64_t v130 = v29;
    }
    else {
      uint64_t v130 = 0;
    }
    uint64_t v131 = &v129[v130];
    uint64_t v132 = a8 + 16 * v130 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v131;
      a8 = v132;
      a5 = v131;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

float32x4_t *composite_pixelmask<(CGCompositeOperation)12,_rgbaf_t>(float32x4_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, char a16)
{
  if (a15) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = -1;
  }
  v19.i64[0] = 0;
  v19.i32[2] = 0;
  v19.i32[3] = v18;
  int8x16_t v20 = vmvnq_s8(v19);
  int8x16_t v21 = vandq_s8((int8x16_t)vdupq_n_s32(v18), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v22 = 2 * a14;
  uint64_t v23 = -(a6 * a4);
  uint64_t v24 = 32 * a14;
  uint64_t v25 = 16 * a14;
  if ((a16 & 0x30) != 0)
  {
    v26.i64[0] = -1;
    v26.i64[1] = -1;
    float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v28 = (a8 - (unint64_t)a3) >> 4;
      if (v28 >= a12) {
        unint64_t v28 = a12;
      }
      unint64_t v29 = v28;
      if (v28 < 2) {
        goto LABEL_40;
      }
      while (1)
      {
        int v30 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          unint64_t v40 = (int8x16_t *)&a10[v29];
          int v41 = (int8x16_t *)a10;
          do
            uint64_t v42 = v41++;
          while (v41 <= v40 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v42)) & 0x80) != 0);
          do
          {
            float32x4_t v43 = v42;
            uint64_t v42 = (int8x16_t *)((char *)v42 + 4);
          }
          while (v42 <= v40 && !v43->i32[0]);
          if (v43 < v40)
          {
            while (!v43->i8[0])
            {
              float32x4_t v43 = (int8x16_t *)((char *)v43 + 1);
              if (v43 >= v40)
              {
                float32x4_t v43 = (int8x16_t *)&a10[v29];
                break;
              }
            }
          }
          int64_t v44 = (char *)v43 - a10;
          int64_t v45 = ((char *)v43 - a10) * a14;
          a3 += v45;
          result += v45;
          a10 += v45;
          v29 -= v44;
          goto LABEL_37;
        }
        if (v30 != 0xFFFF) {
          break;
        }
        uint64_t v31 = (int8x16_t *)&a10[v29];
        unint64_t v32 = (int8x16_t *)a10;
        do
          unint64_t v33 = v32++;
        while (v32 <= v31 && (vminvq_u8((uint8x16_t)vceqq_s8(*v33, v26)) & 0x80) != 0);
        do
        {
          float32x4_t v34 = v33;
          unint64_t v33 = (int8x16_t *)((char *)v33 + 4);
        }
        while (v33 <= v31 && v34->i32[0] == -1);
        if (v34 < v31)
        {
          while (v34->u8[0] == 255)
          {
            float32x4_t v34 = (int8x16_t *)((char *)v34 + 1);
            if (v34 >= v31)
            {
              float32x4_t v34 = (int8x16_t *)&a10[v29];
              break;
            }
          }
        }
        uint64_t v35 = 0;
        int64_t v36 = (char *)v34 - a10;
        unint64_t v37 = (char *)v34 - a10;
        do
        {
          float32x4_t v38 = (float32x4_t *)((char *)result + v35);
          float32x4_t v39 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)result + v35 + 16), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v35), v20), v21)), (float32x4_t)xmmword_1850CD6C0);
          *float32x4_t v38 = vminnmq_f32(vaddq_f32(*(float32x4_t *)((char *)result + v35), (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v35), v20), v21)), (float32x4_t)xmmword_1850CD6C0);
          v38[1] = v39;
          a10 += v22;
          v37 -= 2;
          v35 += v24;
        }
        while (v37 > 1);
        a3 = (int8x16_t *)((char *)a3 + v35);
        float result = (float32x4_t *)((char *)result + v35);
        unint64_t v29 = v29 - v36 + v37;
LABEL_37:
        if (v29 <= 1) {
          goto LABEL_40;
        }
      }
      uint64_t v46 = 0;
      while (1)
      {
        int64_t v47 = (int8x16_t *)((char *)result + v46);
        float32x4_t v48 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v30)) & 0xFF00FF00FF00FFLL))), v27);
        float32x4_t v49 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v30) & 0xFF00FF00FF00FFLL))), v27);
        int8x16_t v50 = vbslq_s8((int8x16_t)vcgtzq_f32(v48), (int8x16_t)vminnmq_f32(vmlaq_f32(*(float32x4_t *)((char *)result + v46 + 16), v48, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v20), v21)), (float32x4_t)xmmword_1850CD6C0), *(int8x16_t *)((char *)&result[1] + v46));
        *int64_t v47 = vbslq_s8((int8x16_t)vcgtzq_f32(v49), (int8x16_t)vminnmq_f32(vmlaq_f32(*(float32x4_t *)((char *)result + v46), v49, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v20), v21)), (float32x4_t)xmmword_1850CD6C0), *(int8x16_t *)((char *)result + v46));
        v47[1] = v50;
        a10 += v22;
        v29 -= 2;
        if (v29 < 2) {
          break;
        }
        LOWORD(v30) = *(_WORD *)a10;
        v46 += v24;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (float32x4_t *)((char *)result + v46);
          a3 = (int8x16_t *)((char *)a3 + v46);
          goto LABEL_37;
        }
      }
      float result = (float32x4_t *)((char *)result + v24 + v46);
      a3 = (int8x16_t *)((char *)a3 + v24 + v46);
LABEL_40:
      for (unint64_t i = a12 - v28 + v29; i; --i)
      {
        if (*a10)
        {
          float32x4_t v52 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v27);
          *(int8x16_t *)float result = vbslq_s8((int8x16_t)vcgtzq_f32(v52), (int8x16_t)vminnmq_f32(vmlaq_f32(*result, v52, (float32x4_t)vorrq_s8(vandq_s8(*a3, v20), v21)), (float32x4_t)xmmword_1850CD6C0), *(int8x16_t *)result);
        }
        float32x4_t v53 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v53 >= a8) {
          uint64_t v54 = -(uint64_t)a7;
        }
        else {
          uint64_t v54 = 0;
        }
        a3 = &v53[v54];
        float result = (float32x4_t *)((char *)result + v25);
      }
      a10 += a11;
      result += a2;
      float32x4_t v55 = &a5[a4];
      if ((unint64_t)v55 >= a9) {
        uint64_t v56 = v23;
      }
      else {
        uint64_t v56 = 0;
      }
      float32x4_t v57 = &v55[v56];
      uint64_t v58 = a8 + 16 * v56 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v57;
        a8 = v58;
        a5 = v57;
      }
      BOOL v59 = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ v59 | (a13 == 0)) {
        return result;
      }
    }
  }
  v60.i64[0] = -1;
  v60.i64[1] = -1;
  float32x4_t v61 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v62 = (a8 - (unint64_t)a3) >> 4;
    if (v62 >= a12) {
      unint64_t v62 = a12;
    }
    unint64_t v63 = v62;
    if (v62 < 2) {
      goto LABEL_90;
    }
    while (1)
    {
      int v64 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        int64_t v74 = (int8x16_t *)&a10[v63];
        float32x4_t v75 = (int8x16_t *)a10;
        do
          float32x4_t v76 = v75++;
        while (v75 <= v74 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v76)) & 0x80) != 0);
        do
        {
          float32x4_t v77 = v76;
          float32x4_t v76 = (int8x16_t *)((char *)v76 + 4);
        }
        while (v76 <= v74 && !v77->i32[0]);
        if (v77 < v74)
        {
          while (!v77->i8[0])
          {
            float32x4_t v77 = (int8x16_t *)((char *)v77 + 1);
            if (v77 >= v74)
            {
              float32x4_t v77 = (int8x16_t *)&a10[v63];
              break;
            }
          }
        }
        int64_t v78 = (char *)v77 - a10;
        int64_t v79 = ((char *)v77 - a10) * a14;
        a3 += v79;
        result += v79;
        a10 += v79;
        v63 -= v78;
        goto LABEL_87;
      }
      if (v64 != 0xFFFF) {
        break;
      }
      float32x4_t v65 = (int8x16_t *)&a10[v63];
      float32x4_t v66 = (int8x16_t *)a10;
      do
        float32x4_t v67 = v66++;
      while (v66 <= v65 && (vminvq_u8((uint8x16_t)vceqq_s8(*v67, v60)) & 0x80) != 0);
      do
      {
        float32x4_t v68 = v67;
        float32x4_t v67 = (int8x16_t *)((char *)v67 + 4);
      }
      while (v67 <= v65 && v68->i32[0] == -1);
      if (v68 < v65)
      {
        while (v68->u8[0] == 255)
        {
          float32x4_t v68 = (int8x16_t *)((char *)v68 + 1);
          if (v68 >= v65)
          {
            float32x4_t v68 = (int8x16_t *)&a10[v63];
            break;
          }
        }
      }
      uint64_t v69 = 0;
      int64_t v70 = (char *)v68 - a10;
      unint64_t v71 = (char *)v68 - a10;
      do
      {
        float32x4_t v72 = (int8x16_t *)((char *)result + v69);
        int8x16_t v73 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v69)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v69)), v20), v21)), (float32x4_t)xmmword_1850CD6C0));
        *float32x4_t v72 = vrev32q_s8((int8x16_t)vminnmq_f32(vaddq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v69)), (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v69)), v20), v21)), (float32x4_t)xmmword_1850CD6C0));
        v72[1] = v73;
        a10 += v22;
        v71 -= 2;
        v69 += v24;
      }
      while (v71 > 1);
      a3 = (int8x16_t *)((char *)a3 + v69);
      float result = (float32x4_t *)((char *)result + v69);
      unint64_t v63 = v63 - v70 + v71;
LABEL_87:
      if (v63 <= 1) {
        goto LABEL_90;
      }
    }
    uint64_t v80 = 0;
    while (1)
    {
      float32x4_t v81 = (int8x16_t *)((char *)result + v80);
      float32x4_t v82 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)result + v80));
      float32x4_t v83 = (float32x4_t)vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v80));
      float32x4_t v84 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v64) & 0xFF00FF00FF00FFLL))), v61);
      float32x4_t v85 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v64)) & 0xFF00FF00FF00FFLL))), v61);
      int8x16_t v86 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v85), (int8x16_t)vminnmq_f32(vmlaq_f32(v83, v85, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v80)), v20), v21)), (float32x4_t)xmmword_1850CD6C0), (int8x16_t)v83));
      *float32x4_t v81 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v84), (int8x16_t)vminnmq_f32(vmlaq_f32(v82, v84, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v80)), v20), v21)), (float32x4_t)xmmword_1850CD6C0), (int8x16_t)v82));
      v81[1] = v86;
      a10 += v22;
      v63 -= 2;
      if (v63 < 2) {
        break;
      }
      LOWORD(v64) = *(_WORD *)a10;
      v80 += v24;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (float32x4_t *)((char *)result + v80);
        a3 = (int8x16_t *)((char *)a3 + v80);
        goto LABEL_87;
      }
    }
    float result = (float32x4_t *)((char *)result + v24 + v80);
    a3 = (int8x16_t *)((char *)a3 + v24 + v80);
LABEL_90:
    for (unint64_t j = a12 - v62 + v63; j; --j)
    {
      if (*a10)
      {
        float32x4_t v88 = (float32x4_t)vrev32q_s8(*(int8x16_t *)result);
        float32x4_t v89 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v61);
        *(int8x16_t *)float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v89), (int8x16_t)vminnmq_f32(vmlaq_f32(v88, v89, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v20), v21)), (float32x4_t)xmmword_1850CD6C0), (int8x16_t)v88));
      }
      uint64_t v90 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v90 >= a8) {
        uint64_t v91 = -(uint64_t)a7;
      }
      else {
        uint64_t v91 = 0;
      }
      a3 = &v90[v91];
      float result = (float32x4_t *)((char *)result + v25);
    }
    a10 += a11;
    result += a2;
    uint64_t v92 = &a5[a4];
    if ((unint64_t)v92 >= a9) {
      uint64_t v93 = v23;
    }
    else {
      uint64_t v93 = 0;
    }
    uint64_t v94 = &v92[v93];
    uint64_t v95 = a8 + 16 * v93 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v94;
      a8 = v95;
      a5 = v94;
    }
    BOOL v59 = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ v59 | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)13,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          uint64_t v54 = (int8x16_t *)&a10[v40];
          float32x4_t v55 = (int8x16_t *)a10;
          do
            uint64_t v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            float32x4_t v57 = v56;
            uint64_t v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              float32x4_t v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                float32x4_t v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v58 = (char *)v57 - a10;
          int64_t v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        uint64_t v42 = (int8x16_t *)&a10[v40];
        float32x4_t v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          float32x4_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          *float32x4_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vmlsq_laneq_f32(v50, v50, v53, 3)), v50, v53), (int8x16_t)v50), (int8x16_t)v53);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vmlsq_laneq_f32(v51, v51, v52, 3)), v51, v52), (int8x16_t)v51), (int8x16_t)v52);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v60 = 0;
      while (1)
      {
        float32x4_t v61 = (int8x16_t *)((char *)result + v60);
        float32x4_t v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        float32x4_t v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        float32x4_t v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        float32x4_t v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *float32x4_t v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v67, v67, v65, 3), vmlsq_laneq_f32(v65, v65, v67, 3)), v65, v67), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v64, v64, v66, 3), vmlsq_laneq_f32(v66, v66, v64, 3)), v66, v64), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          float32x4_t v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vmlsq_laneq_f32(v70, v70, v71, 3)), v71, v70), (int8x16_t)v71), (int8x16_t)v70);
        }
        float32x4_t v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8) {
          uint64_t v73 = -(uint64_t)a7;
        }
        else {
          uint64_t v73 = 0;
        }
        a3 = &v72[v73];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int64_t v74 = &a5[a4];
      if ((unint64_t)v74 >= a9) {
        uint64_t v75 = v29;
      }
      else {
        uint64_t v75 = 0;
      }
      float32x4_t v76 = &v74[v75];
      uint64_t v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12) {
      unint64_t v80 = a12;
    }
    unint64_t v81 = v80;
    if (v80 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v95 = (int8x16_t *)&a10[v81];
        unint64_t v96 = (int8x16_t *)a10;
        do
          float32x4_t v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          float32x4_t v98 = v97;
          float32x4_t v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            float32x4_t v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              float32x4_t v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        int64_t v99 = (char *)v98 - a10;
        int64_t v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF) {
        break;
      }
      float32x4_t v83 = (int8x16_t *)&a10[v81];
      float32x4_t v84 = (int8x16_t *)a10;
      do
        float32x4_t v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        int8x16_t v86 = v85;
        float32x4_t v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          int8x16_t v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            int8x16_t v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      uint64_t v87 = 0;
      int64_t v88 = (char *)v86 - a10;
      unint64_t v89 = (char *)v86 - a10;
      do
      {
        uint64_t v90 = (int8x16_t *)((char *)result + v87);
        float32x4_t v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        float32x4_t v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        int8x16_t *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vmlsq_laneq_f32(v92, v92, v93, 3)), v92, v93), (int8x16_t)v92), (int8x16_t)v93));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vmlsq_laneq_f32(v91, v91, v94, 3)), v91, v94), (int8x16_t)v91), (int8x16_t)v94));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      float result = (int8x16_t *)((char *)result + v87);
      unint64_t v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v101 = 0;
    while (1)
    {
      float32x4_t v102 = (int8x16_t *)((char *)result + v101);
      float32x4_t v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      float32x4_t v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      float32x4_t v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      float32x4_t v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      int8x16_t *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v108, v108, v107, 3), vmlsq_laneq_f32(v107, v107, v108, 3)), v107, v108), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v105, v105, v106, 3), vmlsq_laneq_f32(v106, v106, v105, 3)), v106, v105), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2) {
        break;
      }
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (unint64_t j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        float32x4_t v111 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        float32x4_t v112 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), (int8x16_t)vmlaq_f32(vaddq_f32(vmlsq_laneq_f32(v112, v112, v111, 3), vmlsq_laneq_f32(v111, v111, v112, 3)), v112, v111), (int8x16_t)v112), (int8x16_t)v111));
      }
      float32x4_t v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8) {
        uint64_t v114 = -(uint64_t)a7;
      }
      else {
        uint64_t v114 = 0;
      }
      a3 = &v113[v114];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v115 = &a5[a4];
    if ((unint64_t)v115 >= a9) {
      uint64_t v116 = v29;
    }
    else {
      uint64_t v116 = 0;
    }
    float32x4_t v117 = &v115[v116];
    uint64_t v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)14,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  int8x16_t v21 = vmvnq_s8(v20);
  int8x16_t v22 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0;
  v24.i32[2] = 0;
  v24.i32[3] = v23;
  int8x16_t v25 = vandq_s8(v22, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v24);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v23), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V6.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          uint64_t v54 = (int8x16_t *)&a10[v40];
          float32x4_t v55 = (int8x16_t *)a10;
          do
            uint64_t v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            float32x4_t v57 = v56;
            uint64_t v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              float32x4_t v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                float32x4_t v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v58 = (char *)v57 - a10;
          int64_t v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        uint64_t v42 = (int8x16_t *)&a10[v40];
        float32x4_t v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          float32x4_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v21), v25);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v21), v25);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          *float32x4_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v51, v52, v51), v52), (int8x16_t)v51), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v50, v53, v50), v53), (int8x16_t)v50), (int8x16_t)v53);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v60 = 0;
      while (1)
      {
        float32x4_t v61 = (int8x16_t *)((char *)result + v60);
        float32x4_t v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v64 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v63)), (int8x16_t)_Q6, *(int8x16_t *)((char *)&result[1] + v60));
        float32x4_t v65 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v62)), (int8x16_t)_Q6, *(int8x16_t *)((char *)result + v60));
        float32x4_t v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v21), v25));
        float32x4_t v67 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v21), v25));
        *float32x4_t v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v67, v65, v67), v65), (int8x16_t)v67), (int8x16_t)v65);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v66, v64, v66), v64), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v70 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v69)), (int8x16_t)_Q6, *result);
          float32x4_t v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v21), v25));
          *float result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v71)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v71, v70, v71), v70), (int8x16_t)v71), (int8x16_t)v70);
        }
        float32x4_t v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8) {
          uint64_t v73 = -(uint64_t)a7;
        }
        else {
          uint64_t v73 = 0;
        }
        a3 = &v72[v73];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int64_t v74 = &a5[a4];
      if ((unint64_t)v74 >= a9) {
        uint64_t v75 = v29;
      }
      else {
        uint64_t v75 = 0;
      }
      float32x4_t v76 = &v74[v75];
      uint64_t v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12) {
      unint64_t v80 = a12;
    }
    unint64_t v81 = v80;
    if (v80 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v95 = (int8x16_t *)&a10[v81];
        unint64_t v96 = (int8x16_t *)a10;
        do
          float32x4_t v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          float32x4_t v98 = v97;
          float32x4_t v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            float32x4_t v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              float32x4_t v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        int64_t v99 = (char *)v98 - a10;
        int64_t v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF) {
        break;
      }
      float32x4_t v83 = (int8x16_t *)&a10[v81];
      float32x4_t v84 = (int8x16_t *)a10;
      do
        float32x4_t v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        int8x16_t v86 = v85;
        float32x4_t v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          int8x16_t v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            int8x16_t v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      uint64_t v87 = 0;
      int64_t v88 = (char *)v86 - a10;
      unint64_t v89 = (char *)v86 - a10;
      do
      {
        uint64_t v90 = (int8x16_t *)((char *)result + v87);
        float32x4_t v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v21), v25);
        float32x4_t v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v21), v25);
        float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        int8x16_t *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v91, v93, v91), v93), (int8x16_t)v91), (int8x16_t)v93));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v92, v94, v92), v94), (int8x16_t)v92), (int8x16_t)v94));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      float result = (int8x16_t *)((char *)result + v87);
      unint64_t v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v101 = 0;
    while (1)
    {
      float32x4_t v102 = (int8x16_t *)((char *)result + v101);
      float32x4_t v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v105 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v104)), (int8x16_t)_Q6, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      float32x4_t v106 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v21), v25));
      float32x4_t v107 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v21), v25));
      float32x4_t v108 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v103)), (int8x16_t)_Q6, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      int8x16_t *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v107, v108, v107), v108), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v106, v105, v106), v105), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2) {
        break;
      }
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (unint64_t j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        float32x4_t v111 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v110)), (int8x16_t)_Q6, vrev32q_s8(*result));
        float32x4_t v112 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v21), v25));
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v112)), 3)), vbslq_s8((int8x16_t)vcgtzq_f32(vmaxnmq_f32(vminnmq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3), _Q6), (float32x4_t)0)), (int8x16_t)vaddq_f32(vmlsq_f32(v112, v111, v112), v111), (int8x16_t)v112), (int8x16_t)v111));
      }
      float32x4_t v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8) {
        uint64_t v114 = -(uint64_t)a7;
      }
      else {
        uint64_t v114 = 0;
      }
      a3 = &v113[v114];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v115 = &a5[a4];
    if ((unint64_t)v115 >= a9) {
      uint64_t v116 = v29;
    }
    else {
      uint64_t v116 = 0;
    }
    float32x4_t v117 = &v115[v116];
    uint64_t v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)15,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    v38.i64[0] = 0x8000000080000000;
    v38.i64[1] = 0x8000000080000000;
    v39.i64[0] = -1;
    v39.i64[1] = -1;
    float32x4_t v40 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 4;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v43 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v64 = (int8x16_t *)&a10[v42];
          float32x4_t v65 = (int8x16_t *)a10;
          do
            float32x4_t v66 = v65++;
          while (v65 <= v64 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v66)) & 0x80) != 0);
          do
          {
            float32x4_t v67 = v66;
            float32x4_t v66 = (int8x16_t *)((char *)v66 + 4);
          }
          while (v66 <= v64 && !v67->i32[0]);
          if (v67 < v64)
          {
            while (!v67->i8[0])
            {
              float32x4_t v67 = (int8x16_t *)((char *)v67 + 1);
              if (v67 >= v64)
              {
                float32x4_t v67 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          int64_t v68 = (char *)v67 - a10;
          int64_t v69 = ((char *)v67 - a10) * a14;
          a3 += v69;
          result += v69;
          a10 += v69;
          v42 -= v68;
          goto LABEL_40;
        }
        if (v43 != 0xFFFF) {
          break;
        }
        int64_t v44 = (int8x16_t *)&a10[v42];
        int64_t v45 = (int8x16_t *)a10;
        do
          uint64_t v46 = v45++;
        while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v39)) & 0x80) != 0);
        do
        {
          int64_t v47 = v46;
          uint64_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= v44 && v47->i32[0] == -1);
        if (v47 < v44)
        {
          while (v47->u8[0] == 255)
          {
            int64_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= v44)
            {
              int64_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        uint64_t v48 = 0;
        int64_t v49 = (char *)v47 - a10;
        unint64_t v50 = (char *)v47 - a10;
        do
        {
          float32x4_t v51 = (int8x16_t *)((char *)result + v48);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v22), v25);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v22), v25);
          float32x4_t v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v48), v26), v27);
          float32x4_t v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v48), v26), v27);
          float32x4_t v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          float32x4_t v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          float32x4_t v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
          int8x16_t v60 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v55, 3), v55);
          int8x16_t v61 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v54, 3), v54);
          int8x16_t v62 = vandq_s8(v61, v38);
          int8x16_t v63 = vandq_s8(v60, v38);
          int8x16_t *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v58), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v52, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v58, v55)), v52), vmlaq_f32(v55, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v57, v52)), v55)), (float32x4_t)vbslq_s8(v60, v38, (int8x16_t)vmulq_laneq_f32(v57, v55, 3))), (int8x16_t)v52), (int8x16_t)v55);
          v51[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v53, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v59, v54)), v53), vmlaq_f32(v54, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v56, v53)), v54)), (float32x4_t)vbslq_s8(v61, v38, (int8x16_t)vmulq_laneq_f32(v56, v54, 3))), (int8x16_t)v53), (int8x16_t)v54);
          a10 += v28;
          v50 -= 2;
          v48 += v30;
        }
        while (v50 > 1);
        a3 = (int8x16_t *)((char *)a3 + v48);
        float result = (int8x16_t *)((char *)result + v48);
        unint64_t v42 = v42 - v49 + v50;
LABEL_40:
        if (v42 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v70 = 0;
      while (1)
      {
        float32x4_t v71 = (int8x16_t *)((char *)result + v70);
        float32x4_t v72 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v43) & 0xFF00FF00FF00FFLL))), v40);
        float32x4_t v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v43)) & 0xFF00FF00FF00FFLL))), v40);
        int8x16_t v74 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v72));
        float32x4_t v75 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *(int8x16_t *)((char *)&result[1] + v70));
        float32x4_t v76 = vmulq_f32(v72, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v70), v22), v25));
        float32x4_t v77 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v70), v22), v25));
        float32x4_t v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        float32x4_t v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        float32x4_t v80 = (float32x4_t)vbslq_s8(v74, _Q5, *(int8x16_t *)((char *)result + v70));
        float32x4_t v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        float32x4_t v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 3);
        int8x16_t v83 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v80, 3), v80);
        int8x16_t v84 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v75, 3), v75);
        int8x16_t v85 = vandq_s8(v84, v38);
        int8x16_t v86 = vandq_s8(v83, v38);
        *float32x4_t v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v79), vbslq_s8((int8x16_t)vcgtzq_f32(v81), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v76, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v81, v80)), v76), vmlaq_f32(v80, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v79, v76)), v80)), (float32x4_t)vbslq_s8(v83, v38, (int8x16_t)vmulq_laneq_f32(v79, v80, 3))), (int8x16_t)v76), (int8x16_t)v80);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v78), vbslq_s8((int8x16_t)vcgtzq_f32(v82), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v77, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v82, v75)), v77), vmlaq_f32(v75, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v78, v77)), v75)), (float32x4_t)vbslq_s8(v84, v38, (int8x16_t)vmulq_laneq_f32(v78, v75, 3))), (int8x16_t)v77), (int8x16_t)v75);
        a10 += v28;
        v42 -= 2;
        if (v42 < 2) {
          break;
        }
        LOWORD(v43) = *(_WORD *)a10;
        v70 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v70);
          a3 = (int8x16_t *)((char *)a3 + v70);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v70);
      a3 = (int8x16_t *)((char *)a3 + v30 + v70);
LABEL_43:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float32x4_t v88 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v40);
          float32x4_t v89 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v88)), _Q5, *result);
          float32x4_t v90 = vmulq_f32(v88, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v91 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3);
          float32x4_t v92 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 3);
          int8x16_t v93 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v37, v89, 3), v89);
          int8x16_t v94 = vandq_s8(v93, v38);
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32(v91), vbslq_s8((int8x16_t)vcgtzq_f32(v92), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v90, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v92, v89)), v90), vmlaq_f32(v89, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v91, v90)), v89)), (float32x4_t)vbslq_s8(v93, v38, (int8x16_t)vmulq_laneq_f32(v92, v90, 3))), (int8x16_t)v90), (int8x16_t)v89);
        }
        uint64_t v95 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v95 >= a8) {
          uint64_t v96 = -(uint64_t)a7;
        }
        else {
          uint64_t v96 = 0;
        }
        a3 = &v95[v96];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v97 = &a5[a4];
      if ((unint64_t)v97 >= a9) {
        uint64_t v98 = v29;
      }
      else {
        uint64_t v98 = 0;
      }
      int64_t v99 = &v97[v98];
      uint64_t v100 = a8 + 16 * v98 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v99;
        a8 = v100;
        a5 = v99;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v101.i64[0] = 0x3F0000003F000000;
  v101.i64[1] = 0x3F0000003F000000;
  v102.i64[0] = 0x8000000080000000;
  v102.i64[1] = 0x8000000080000000;
  v103.i64[0] = -1;
  v103.i64[1] = -1;
  float32x4_t v104 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v105 = (a8 - (unint64_t)a3) >> 4;
    if (v105 >= a12) {
      unint64_t v105 = a12;
    }
    unint64_t v106 = v105;
    if (v105 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v107 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v128 = (int8x16_t *)&a10[v106];
        uint64_t v129 = (int8x16_t *)a10;
        do
          uint64_t v130 = v129++;
        while (v129 <= v128 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v130)) & 0x80) != 0);
        do
        {
          uint64_t v131 = v130;
          uint64_t v130 = (int8x16_t *)((char *)v130 + 4);
        }
        while (v130 <= v128 && !v131->i32[0]);
        if (v131 < v128)
        {
          while (!v131->i8[0])
          {
            uint64_t v131 = (int8x16_t *)((char *)v131 + 1);
            if (v131 >= v128)
            {
              uint64_t v131 = (int8x16_t *)&a10[v106];
              break;
            }
          }
        }
        int64_t v132 = (char *)v131 - a10;
        int64_t v133 = ((char *)v131 - a10) * a14;
        a3 += v133;
        result += v133;
        a10 += v133;
        v106 -= v132;
        goto LABEL_90;
      }
      if (v107 != 0xFFFF) {
        break;
      }
      float32x4_t v108 = (int8x16_t *)&a10[v106];
      int8x16_t v109 = (int8x16_t *)a10;
      do
        float32x4_t v110 = v109++;
      while (v109 <= v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v103)) & 0x80) != 0);
      do
      {
        float32x4_t v111 = v110;
        float32x4_t v110 = (int8x16_t *)((char *)v110 + 4);
      }
      while (v110 <= v108 && v111->i32[0] == -1);
      if (v111 < v108)
      {
        while (v111->u8[0] == 255)
        {
          float32x4_t v111 = (int8x16_t *)((char *)v111 + 1);
          if (v111 >= v108)
          {
            float32x4_t v111 = (int8x16_t *)&a10[v106];
            break;
          }
        }
      }
      uint64_t v112 = 0;
      int64_t v113 = (char *)v111 - a10;
      unint64_t v114 = (char *)v111 - a10;
      do
      {
        float32x4_t v115 = (int8x16_t *)((char *)result + v112);
        float32x4_t v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
        float32x4_t v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
        float32x4_t v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v112)), v26), v27);
        float32x4_t v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)), v26), v27);
        float32x4_t v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3);
        float32x4_t v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3);
        float32x4_t v122 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
        float32x4_t v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
        int8x16_t v124 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v119, 3), v119);
        int8x16_t v125 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v118, 3), v118);
        int8x16_t v126 = vandq_s8(v125, v102);
        int8x16_t v127 = vandq_s8(v124, v102);
        *float32x4_t v115 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v120), vbslq_s8((int8x16_t)vcgtzq_f32(v123), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v117, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v123, v118)), v117), vmlaq_f32(v118, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v120, v117)), v118)), (float32x4_t)vbslq_s8(v125, v102, (int8x16_t)vmulq_laneq_f32(v120, v118, 3))), (int8x16_t)v117), (int8x16_t)v118));
        v115[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v121), vbslq_s8((int8x16_t)vcgtzq_f32(v122), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v116, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v122, v119)), v116), vmlaq_f32(v119, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v121, v116)), v119)), (float32x4_t)vbslq_s8(v124, v102, (int8x16_t)vmulq_laneq_f32(v121, v119, 3))), (int8x16_t)v116), (int8x16_t)v119));
        a10 += v28;
        v114 -= 2;
        v112 += v30;
      }
      while (v114 > 1);
      a3 = (int8x16_t *)((char *)a3 + v112);
      float result = (int8x16_t *)((char *)result + v112);
      unint64_t v106 = v106 - v113 + v114;
LABEL_90:
      if (v106 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v134 = 0;
    while (1)
    {
      int v135 = (int8x16_t *)((char *)result + v134);
      float32x4_t v136 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v107)) & 0xFF00FF00FF00FFLL))), v104);
      float32x4_t v137 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v107) & 0xFF00FF00FF00FFLL))), v104);
      int8x16_t v138 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v137));
      float32x4_t v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v136)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v134)));
      float32x4_t v140 = vmulq_f32(v136, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v134)), v22), v25));
      float32x4_t v141 = vmulq_f32(v137, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v134)), v22), v25));
      float32x4_t v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3);
      float32x4_t v143 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
      float32x4_t v144 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
      float32x4_t v145 = (float32x4_t)vbslq_s8(v138, _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v134)));
      float32x4_t v146 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 3);
      int8x16_t v147 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v139, 3), v139);
      int8x16_t v148 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v145, 3), v145);
      int8x16_t v149 = vandq_s8(v148, v102);
      int8x16_t v150 = vandq_s8(v147, v102);
      *int v135 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v142), vbslq_s8((int8x16_t)vcgtzq_f32(v146), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v141, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v146, v145)), v141), vmlaq_f32(v145, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v142, v141)), v145)), (float32x4_t)vbslq_s8(v148, v102, (int8x16_t)vmulq_laneq_f32(v142, v145, 3))), (int8x16_t)v141), (int8x16_t)v145));
      v135[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v143), vbslq_s8((int8x16_t)vcgtzq_f32(v144), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v140, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v144, v139)), v140), vmlaq_f32(v139, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v143, v140)), v139)), (float32x4_t)vbslq_s8(v147, v102, (int8x16_t)vmulq_laneq_f32(v143, v139, 3))), (int8x16_t)v140), (int8x16_t)v139));
      a10 += v28;
      v106 -= 2;
      if (v106 < 2) {
        break;
      }
      LOWORD(v107) = *(_WORD *)a10;
      v134 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v134);
        a3 = (int8x16_t *)((char *)a3 + v134);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v134);
    a3 = (int8x16_t *)((char *)a3 + v30 + v134);
LABEL_93:
    for (unint64_t j = a12 - v105 + v106; j; --j)
    {
      if (*a10)
      {
        float32x4_t v152 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v104);
        int8x16_t v153 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v152));
        float32x4_t v154 = vmulq_f32(v152, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v155 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 3);
        float32x4_t v156 = (float32x4_t)vbslq_s8(v153, _Q5, vrev32q_s8(*result));
        float32x4_t v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 3);
        int8x16_t v158 = (int8x16_t)vcgtq_f32(vmulq_laneq_f32(v101, v156, 3), v156);
        int8x16_t v159 = vandq_s8(v158, v102);
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v155), vbslq_s8((int8x16_t)vcgtzq_f32(v157), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v154, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v157, v156)), v154), vmlaq_f32(v156, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v155, v154)), v156)), (float32x4_t)vbslq_s8(v158, v102, (int8x16_t)vmulq_laneq_f32(v157, v154, 3))), (int8x16_t)v154), (int8x16_t)v156));
      }
      float v160 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v160 >= a8) {
        uint64_t v161 = -(uint64_t)a7;
      }
      else {
        uint64_t v161 = 0;
      }
      a3 = &v160[v161];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float v162 = &a5[a4];
    if ((unint64_t)v162 >= a9) {
      uint64_t v163 = v29;
    }
    else {
      uint64_t v163 = 0;
    }
    float v164 = &v162[v163];
    uint64_t v165 = a8 + 16 * v163 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v164;
      a8 = v165;
      a5 = v164;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)17,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v54 = (int8x16_t *)&a10[v40];
          float32x4_t v55 = (int8x16_t *)a10;
          do
            float32x4_t v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            float32x4_t v57 = v56;
            float32x4_t v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              float32x4_t v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                float32x4_t v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v58 = (char *)v57 - a10;
          int64_t v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v51, v52, 3), vmulq_laneq_f32(v52, v51, 3)), vmlsq_laneq_f32(v51, v51, v52, 3))), (int8x16_t)v52), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v50, v53, 3), vmulq_laneq_f32(v53, v50, 3)), vmlsq_laneq_f32(v50, v50, v53, 3))), (int8x16_t)v53), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v60 = 0;
      while (1)
      {
        int8x16_t v61 = (int8x16_t *)((char *)result + v60);
        float32x4_t v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        float32x4_t v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        float32x4_t v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        float32x4_t v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *int8x16_t v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v67, v65, 3), vmulq_laneq_f32(v65, v67, 3)), vmlsq_laneq_f32(v67, v67, v65, 3))), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v66, v66, v64, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v64, v66, 3), vmulq_laneq_f32(v66, v64, 3)), vmlsq_laneq_f32(v64, v64, v66, 3))), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          float32x4_t v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v70, v71, 3), vmulq_laneq_f32(v71, v70, 3)), vmlsq_laneq_f32(v70, v70, v71, 3))), (int8x16_t)v71), (int8x16_t)v70);
        }
        float32x4_t v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8) {
          uint64_t v73 = -(uint64_t)a7;
        }
        else {
          uint64_t v73 = 0;
        }
        a3 = &v72[v73];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int8x16_t v74 = &a5[a4];
      if ((unint64_t)v74 >= a9) {
        uint64_t v75 = v29;
      }
      else {
        uint64_t v75 = 0;
      }
      float32x4_t v76 = &v74[v75];
      uint64_t v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12) {
      unint64_t v80 = a12;
    }
    unint64_t v81 = v80;
    if (v80 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v95 = (int8x16_t *)&a10[v81];
        uint64_t v96 = (int8x16_t *)a10;
        do
          float32x4_t v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          uint64_t v98 = v97;
          float32x4_t v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            uint64_t v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              uint64_t v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        int64_t v99 = (char *)v98 - a10;
        int64_t v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF) {
        break;
      }
      int8x16_t v83 = (int8x16_t *)&a10[v81];
      int8x16_t v84 = (int8x16_t *)a10;
      do
        int8x16_t v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        int8x16_t v86 = v85;
        int8x16_t v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          int8x16_t v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            int8x16_t v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      uint64_t v87 = 0;
      int64_t v88 = (char *)v86 - a10;
      unint64_t v89 = (char *)v86 - a10;
      do
      {
        float32x4_t v90 = (int8x16_t *)((char *)result + v87);
        float32x4_t v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        float32x4_t v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        int8x16_t *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v91, v94, 3), vmulq_laneq_f32(v94, v91, 3)), vmlsq_laneq_f32(v91, v91, v94, 3))), (int8x16_t)v94), (int8x16_t)v91));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v92, v93, 3), vmulq_laneq_f32(v93, v92, 3)), vmlsq_laneq_f32(v92, v92, v93, 3))), (int8x16_t)v93), (int8x16_t)v92));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      float result = (int8x16_t *)((char *)result + v87);
      unint64_t v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v101 = 0;
    while (1)
    {
      int8x16_t v102 = (int8x16_t *)((char *)result + v101);
      float32x4_t v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      float32x4_t v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      float32x4_t v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      float32x4_t v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      int8x16_t *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v107, v107, v108, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v108, v107, 3), vmulq_laneq_f32(v107, v108, 3)), vmlsq_laneq_f32(v108, v108, v107, 3))), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v106, v106, v105, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v105, v106, 3), vmulq_laneq_f32(v106, v105, 3)), vmlsq_laneq_f32(v105, v105, v106, 3))), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2) {
        break;
      }
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (unint64_t j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        float32x4_t v111 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v111, v111, v112, 3), vaddq_f32(vmaxnmq_f32(vmulq_laneq_f32(v112, v111, 3), vmulq_laneq_f32(v111, v112, 3)), vmlsq_laneq_f32(v112, v112, v111, 3))), (int8x16_t)v111), (int8x16_t)v112));
      }
      int64_t v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8) {
        uint64_t v114 = -(uint64_t)a7;
      }
      else {
        uint64_t v114 = 0;
      }
      a3 = &v113[v114];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v115 = &a5[a4];
    if ((unint64_t)v115 >= a9) {
      uint64_t v116 = v29;
    }
    else {
      uint64_t v116 = 0;
    }
    float32x4_t v117 = &v115[v116];
    uint64_t v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)16,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v54 = (int8x16_t *)&a10[v40];
          float32x4_t v55 = (int8x16_t *)a10;
          do
            float32x4_t v56 = v55++;
          while (v55 <= v54 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v56)) & 0x80) != 0);
          do
          {
            float32x4_t v57 = v56;
            float32x4_t v56 = (int8x16_t *)((char *)v56 + 4);
          }
          while (v56 <= v54 && !v57->i32[0]);
          if (v57 < v54)
          {
            while (!v57->i8[0])
            {
              float32x4_t v57 = (int8x16_t *)((char *)v57 + 1);
              if (v57 >= v54)
              {
                float32x4_t v57 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v58 = (char *)v57 - a10;
          int64_t v59 = ((char *)v57 - a10) * a14;
          a3 += v59;
          result += v59;
          a10 += v59;
          v40 -= v58;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v52, v52, v51, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v51, v52, 3), vmulq_laneq_f32(v52, v51, 3)), vmlsq_laneq_f32(v51, v51, v52, 3))), (int8x16_t)v52), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v53, v53, v50, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v50, v53, 3), vmulq_laneq_f32(v53, v50, 3)), vmlsq_laneq_f32(v50, v50, v53, 3))), (int8x16_t)v53), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v60 = 0;
      while (1)
      {
        int8x16_t v61 = (int8x16_t *)((char *)result + v60);
        float32x4_t v62 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v63 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v64 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v63)), _Q5, *(int8x16_t *)((char *)&result[1] + v60));
        float32x4_t v65 = vmulq_f32(v62, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v60), v22), v25));
        float32x4_t v66 = vmulq_f32(v63, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v60), v22), v25));
        float32x4_t v67 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v62)), _Q5, *(int8x16_t *)((char *)result + v60));
        *int8x16_t v61 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v65, v65, v67, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v67, v65, 3), vmulq_laneq_f32(v65, v67, 3)), vmlsq_laneq_f32(v67, v67, v65, 3))), (int8x16_t)v65), (int8x16_t)v67);
        v61[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v66, v66, v64, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v64, v66, 3), vmulq_laneq_f32(v66, v64, 3)), vmlsq_laneq_f32(v64, v64, v66, 3))), (int8x16_t)v66), (int8x16_t)v64);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v60 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v60);
          a3 = (int8x16_t *)((char *)a3 + v60);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v60);
      a3 = (int8x16_t *)((char *)a3 + v30 + v60);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v70 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69)), _Q5, *result);
          float32x4_t v71 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v70, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v71, v71, v70, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v70, v71, 3), vmulq_laneq_f32(v71, v70, 3)), vmlsq_laneq_f32(v70, v70, v71, 3))), (int8x16_t)v71), (int8x16_t)v70);
        }
        float32x4_t v72 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v72 >= a8) {
          uint64_t v73 = -(uint64_t)a7;
        }
        else {
          uint64_t v73 = 0;
        }
        a3 = &v72[v73];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int8x16_t v74 = &a5[a4];
      if ((unint64_t)v74 >= a9) {
        uint64_t v75 = v29;
      }
      else {
        uint64_t v75 = 0;
      }
      float32x4_t v76 = &v74[v75];
      uint64_t v77 = a8 + 16 * v75 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v76;
        a8 = v77;
        a5 = v76;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v78.i64[0] = -1;
  v78.i64[1] = -1;
  float32x4_t v79 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v80 = (a8 - (unint64_t)a3) >> 4;
    if (v80 >= a12) {
      unint64_t v80 = a12;
    }
    unint64_t v81 = v80;
    if (v80 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v82 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        uint64_t v95 = (int8x16_t *)&a10[v81];
        uint64_t v96 = (int8x16_t *)a10;
        do
          float32x4_t v97 = v96++;
        while (v96 <= v95 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v97)) & 0x80) != 0);
        do
        {
          uint64_t v98 = v97;
          float32x4_t v97 = (int8x16_t *)((char *)v97 + 4);
        }
        while (v97 <= v95 && !v98->i32[0]);
        if (v98 < v95)
        {
          while (!v98->i8[0])
          {
            uint64_t v98 = (int8x16_t *)((char *)v98 + 1);
            if (v98 >= v95)
            {
              uint64_t v98 = (int8x16_t *)&a10[v81];
              break;
            }
          }
        }
        int64_t v99 = (char *)v98 - a10;
        int64_t v100 = ((char *)v98 - a10) * a14;
        a3 += v100;
        result += v100;
        a10 += v100;
        v81 -= v99;
        goto LABEL_90;
      }
      if (v82 != 0xFFFF) {
        break;
      }
      int8x16_t v83 = (int8x16_t *)&a10[v81];
      int8x16_t v84 = (int8x16_t *)a10;
      do
        int8x16_t v85 = v84++;
      while (v84 <= v83 && (vminvq_u8((uint8x16_t)vceqq_s8(*v85, v78)) & 0x80) != 0);
      do
      {
        int8x16_t v86 = v85;
        int8x16_t v85 = (int8x16_t *)((char *)v85 + 4);
      }
      while (v85 <= v83 && v86->i32[0] == -1);
      if (v86 < v83)
      {
        while (v86->u8[0] == 255)
        {
          int8x16_t v86 = (int8x16_t *)((char *)v86 + 1);
          if (v86 >= v83)
          {
            int8x16_t v86 = (int8x16_t *)&a10[v81];
            break;
          }
        }
      }
      uint64_t v87 = 0;
      int64_t v88 = (char *)v86 - a10;
      unint64_t v89 = (char *)v86 - a10;
      do
      {
        float32x4_t v90 = (int8x16_t *)((char *)result + v87);
        float32x4_t v91 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v87)), v26), v27);
        float32x4_t v92 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v87)), v26), v27);
        float32x4_t v93 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v87)), v22), v25);
        float32x4_t v94 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v87)), v22), v25);
        int8x16_t *v90 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v91, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v94, v94, v91, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v91, v94, 3), vmulq_laneq_f32(v94, v91, 3)), vmlsq_laneq_f32(v91, v91, v94, 3))), (int8x16_t)v94), (int8x16_t)v91));
        v90[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v92, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v93, v93, v92, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v92, v93, 3), vmulq_laneq_f32(v93, v92, 3)), vmlsq_laneq_f32(v92, v92, v93, 3))), (int8x16_t)v93), (int8x16_t)v92));
        a10 += v28;
        v89 -= 2;
        v87 += v30;
      }
      while (v89 > 1);
      a3 = (int8x16_t *)((char *)a3 + v87);
      float result = (int8x16_t *)((char *)result + v87);
      unint64_t v81 = v81 - v88 + v89;
LABEL_90:
      if (v81 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v101 = 0;
    while (1)
    {
      int8x16_t v102 = (int8x16_t *)((char *)result + v101);
      float32x4_t v103 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v82)) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v104 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v82) & 0xFF00FF00FF00FFLL))), v79);
      float32x4_t v105 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v103)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v101)));
      float32x4_t v106 = vmulq_f32(v103, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v101)), v22), v25));
      float32x4_t v107 = vmulq_f32(v104, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v101)), v22), v25));
      float32x4_t v108 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v104)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v101)));
      int8x16_t *v102 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v107, v107, v108, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v108, v107, 3), vmulq_laneq_f32(v107, v108, 3)), vmlsq_laneq_f32(v108, v108, v107, 3))), (int8x16_t)v107), (int8x16_t)v108));
      v102[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v105, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v106, v106, v105, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v105, v106, 3), vmulq_laneq_f32(v106, v105, 3)), vmlsq_laneq_f32(v105, v105, v106, 3))), (int8x16_t)v106), (int8x16_t)v105));
      a10 += v28;
      v81 -= 2;
      if (v81 < 2) {
        break;
      }
      LOWORD(v82) = *(_WORD *)a10;
      v101 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v101);
        a3 = (int8x16_t *)((char *)a3 + v101);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v101);
    a3 = (int8x16_t *)((char *)a3 + v30 + v101);
LABEL_93:
    for (unint64_t j = a12 - v80 + v81; j; --j)
    {
      if (*a10)
      {
        float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v79);
        float32x4_t v111 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*result));
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v111, v111, v112, 3), vaddq_f32(vminnmq_f32(vmulq_laneq_f32(v112, v111, 3), vmulq_laneq_f32(v111, v112, 3)), vmlsq_laneq_f32(v112, v112, v111, 3))), (int8x16_t)v111), (int8x16_t)v112));
      }
      int64_t v113 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v113 >= a8) {
        uint64_t v114 = -(uint64_t)a7;
      }
      else {
        uint64_t v114 = 0;
      }
      a3 = &v113[v114];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v115 = &a5[a4];
    if ((unint64_t)v115 >= a9) {
      uint64_t v116 = v29;
    }
    else {
      uint64_t v116 = 0;
    }
    float32x4_t v117 = &v115[v116];
    uint64_t v118 = a8 + 16 * v116 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v117;
      a8 = v118;
      a5 = v117;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)18,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v66 = (int8x16_t *)&a10[v40];
          float32x4_t v67 = (int8x16_t *)a10;
          do
            int64_t v68 = v67++;
          while (v67 <= v66 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v68)) & 0x80) != 0);
          do
          {
            float32x4_t v69 = v68;
            int64_t v68 = (int8x16_t *)((char *)v68 + 4);
          }
          while (v68 <= v66 && !v69->i32[0]);
          if (v69 < v66)
          {
            while (!v69->i8[0])
            {
              float32x4_t v69 = (int8x16_t *)((char *)v69 + 1);
              if (v69 >= v66)
              {
                float32x4_t v69 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v70 = (char *)v69 - a10;
          int64_t v71 = ((char *)v69 - a10) * a14;
          a3 += v71;
          result += v71;
          a10 += v71;
          v40 -= v70;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          int8x16_t v52 = (int8x16_t)vcgtzq_f32(v51);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v54 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          int8x16_t v55 = (int8x16_t)vcgtzq_f32(v54);
          float32x4_t v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
          int8x16_t v58 = (int8x16_t)vcgtzq_f32(v57);
          float32x4_t v59 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          float32x4_t v60 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 3);
          int8x16_t v61 = (int8x16_t)vcgtzq_f32(v60);
          float32x4_t v62 = vaddq_f32(v51, vmlsq_laneq_f32(v60, v51, v59, 3));
          float32x4_t v63 = vaddq_f32(v54, vmlsq_laneq_f32(v57, v54, v56, 3));
          int8x16_t v64 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v56, v56, v53, 3), vaddq_f32(vmlsq_laneq_f32(v53, v53, v56, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v57, v56), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v53, vmulq_f32(v56, v56), 3), vsubq_f32(v57, v56))))), v63);
          int8x16_t v65 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v59, v59, v50, 3), vaddq_f32(vmlsq_laneq_f32(v50, v50, v59, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v60, v59), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v50, vmulq_f32(v59, v59), 3), vsubq_f32(v60, v59))))), v62);
          v65.i32[3] = v62.i32[3];
          v64.i32[3] = v63.i32[3];
          *int64_t v49 = vbslq_s8(v58, vbslq_s8(v55, v64, (int8x16_t)v56), (int8x16_t)v53);
          v49[1] = vbslq_s8(v61, vbslq_s8(v52, v65, (int8x16_t)v59), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v72 = 0;
      while (1)
      {
        uint64_t v73 = (int8x16_t *)((char *)result + v72);
        float32x4_t v74 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v76 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), _Q5, *(int8x16_t *)((char *)&result[1] + v72));
        float32x4_t v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v74)), _Q5, *(int8x16_t *)((char *)result + v72));
        float32x4_t v78 = vmulq_f32(v74, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v72), v22), v25));
        float32x4_t v79 = vmulq_f32(v75, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v72), v22), v25));
        float32x4_t v80 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3);
        float32x4_t v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 3);
        float32x4_t v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        float32x4_t v83 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        int8x16_t v84 = (int8x16_t)vcgtzq_f32(v82);
        int8x16_t v85 = (int8x16_t)vcgtzq_f32(v81);
        int8x16_t v86 = (int8x16_t)vcgtzq_f32(v80);
        float32x4_t v87 = vaddq_f32(vmlsq_laneq_f32(v79, v79, v76, 3), vaddq_f32(vmlsq_laneq_f32(v76, v76, v79, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v80, v79), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v76, vmulq_f32(v79, v79), 3), vsubq_f32(v80, v79)))));
        float32x4_t v88 = vaddq_f32(vmlsq_laneq_f32(v78, v78, v77, 3), vaddq_f32(vmlsq_laneq_f32(v77, v77, v78, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v81, v78), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v77, vmulq_f32(v78, v78), 3), vsubq_f32(v81, v78)))));
        float32x4_t v89 = vaddq_f32(v83, vmlsq_laneq_f32(v80, v83, v79, 3));
        float32x4_t v90 = vaddq_f32(v82, vmlsq_laneq_f32(v81, v82, v78, 3));
        int8x16_t v91 = (int8x16_t)vminnmq_f32(v87, v89);
        v91.i32[3] = v89.i32[3];
        int8x16_t v92 = (int8x16_t)vminnmq_f32(v88, v90);
        v92.i32[3] = v90.i32[3];
        *uint64_t v73 = vbslq_s8(v85, vbslq_s8(v84, v92, (int8x16_t)v78), (int8x16_t)v77);
        v73[1] = vbslq_s8(v86, vbslq_s8((int8x16_t)vcgtzq_f32(v83), v91, (int8x16_t)v79), (int8x16_t)v76);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v72 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v72);
          a3 = (int8x16_t *)((char *)a3 + v72);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v72);
      a3 = (int8x16_t *)((char *)a3 + v30 + v72);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v95 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v94)), _Q5, *result);
          float32x4_t v96 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v97 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3);
          float32x4_t v98 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
          int8x16_t v99 = (int8x16_t)vcgtzq_f32(v98);
          int8x16_t v100 = (int8x16_t)vcgtzq_f32(v97);
          float32x4_t v101 = vaddq_f32(vmlsq_laneq_f32(v96, v96, v95, 3), vaddq_f32(vmlsq_laneq_f32(v95, v95, v96, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v97, v96), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v95, vmulq_f32(v96, v96), 3), vsubq_f32(v97, v96)))));
          float32x4_t v102 = vaddq_f32(v98, vmlsq_laneq_f32(v97, v98, v96, 3));
          int8x16_t v103 = (int8x16_t)vminnmq_f32(v101, v102);
          v103.i32[3] = v102.i32[3];
          *float result = vbslq_s8(v100, vbslq_s8(v99, v103, (int8x16_t)v96), (int8x16_t)v95);
        }
        float32x4_t v104 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v104 >= a8) {
          uint64_t v105 = -(uint64_t)a7;
        }
        else {
          uint64_t v105 = 0;
        }
        a3 = &v104[v105];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v106 = &a5[a4];
      if ((unint64_t)v106 >= a9) {
        uint64_t v107 = v29;
      }
      else {
        uint64_t v107 = 0;
      }
      float32x4_t v108 = &v106[v107];
      uint64_t v109 = a8 + 16 * v107 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v108;
        a8 = v109;
        a5 = v108;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v110.i64[0] = -1;
  v110.i64[1] = -1;
  float32x4_t v111 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v112 = (a8 - (unint64_t)a3) >> 4;
    if (v112 >= a12) {
      unint64_t v112 = a12;
    }
    unint64_t v113 = v112;
    if (v112 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v114 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v139 = (int8x16_t *)&a10[v113];
        float32x4_t v140 = (int8x16_t *)a10;
        do
          float32x4_t v141 = v140++;
        while (v140 <= v139 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v141)) & 0x80) != 0);
        do
        {
          float32x4_t v142 = v141;
          float32x4_t v141 = (int8x16_t *)((char *)v141 + 4);
        }
        while (v141 <= v139 && !v142->i32[0]);
        if (v142 < v139)
        {
          while (!v142->i8[0])
          {
            float32x4_t v142 = (int8x16_t *)((char *)v142 + 1);
            if (v142 >= v139)
            {
              float32x4_t v142 = (int8x16_t *)&a10[v113];
              break;
            }
          }
        }
        int64_t v143 = (char *)v142 - a10;
        int64_t v144 = ((char *)v142 - a10) * a14;
        a3 += v144;
        result += v144;
        a10 += v144;
        v113 -= v143;
        goto LABEL_90;
      }
      if (v114 != 0xFFFF) {
        break;
      }
      float32x4_t v115 = (int8x16_t *)&a10[v113];
      uint64_t v116 = (int8x16_t *)a10;
      do
        float32x4_t v117 = v116++;
      while (v116 <= v115 && (vminvq_u8((uint8x16_t)vceqq_s8(*v117, v110)) & 0x80) != 0);
      do
      {
        uint64_t v118 = v117;
        float32x4_t v117 = (int8x16_t *)((char *)v117 + 4);
      }
      while (v117 <= v115 && v118->i32[0] == -1);
      if (v118 < v115)
      {
        while (v118->u8[0] == 255)
        {
          uint64_t v118 = (int8x16_t *)((char *)v118 + 1);
          if (v118 >= v115)
          {
            uint64_t v118 = (int8x16_t *)&a10[v113];
            break;
          }
        }
      }
      uint64_t v119 = 0;
      int64_t v120 = (char *)v118 - a10;
      unint64_t v121 = (char *)v118 - a10;
      do
      {
        float32x4_t v122 = (int8x16_t *)((char *)result + v119);
        float32x4_t v123 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v119)), v26), v27);
        float32x4_t v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v119)), v26), v27);
        float32x4_t v125 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v123, 3);
        float32x4_t v126 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3);
        float32x4_t v127 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v119)), v22), v25);
        float32x4_t v128 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v127, 3);
        int8x16_t v129 = (int8x16_t)vcgtzq_f32(v125);
        float32x4_t v130 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v119)), v22), v25);
        float32x4_t v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 3);
        int8x16_t v132 = (int8x16_t)vcgtzq_f32(v128);
        int8x16_t v133 = (int8x16_t)vcgtzq_f32(v131);
        float32x4_t v134 = vaddq_f32(vmlsq_laneq_f32(v127, v127, v124, 3), vaddq_f32(vmlsq_laneq_f32(v124, v124, v127, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v128, v127), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v124, vmulq_f32(v127, v127), 3), vsubq_f32(v128, v127)))));
        float32x4_t v135 = vaddq_f32(v126, vmlsq_laneq_f32(v128, v126, v127, 3));
        float32x4_t v136 = vaddq_f32(v125, vmlsq_laneq_f32(v131, v125, v130, 3));
        int8x16_t v137 = (int8x16_t)vminnmq_f32(vaddq_f32(vmlsq_laneq_f32(v130, v130, v123, 3), vaddq_f32(vmlsq_laneq_f32(v123, v123, v130, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v131, v130), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v123, vmulq_f32(v130, v130), 3), vsubq_f32(v131, v130))))), v136);
        int8x16_t v138 = (int8x16_t)vminnmq_f32(v134, v135);
        v137.i32[3] = v136.i32[3];
        v138.i32[3] = v135.i32[3];
        *float32x4_t v122 = vrev32q_s8(vbslq_s8(v133, vbslq_s8(v129, v137, (int8x16_t)v130), (int8x16_t)v123));
        v122[1] = vrev32q_s8(vbslq_s8(v132, vbslq_s8((int8x16_t)vcgtzq_f32(v126), v138, (int8x16_t)v127), (int8x16_t)v124));
        a10 += v28;
        v121 -= 2;
        v119 += v30;
      }
      while (v121 > 1);
      a3 = (int8x16_t *)((char *)a3 + v119);
      float result = (int8x16_t *)((char *)result + v119);
      unint64_t v113 = v113 - v120 + v121;
LABEL_90:
      if (v113 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v145 = 0;
    while (1)
    {
      float32x4_t v146 = (int8x16_t *)((char *)result + v145);
      float32x4_t v147 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v114)) & 0xFF00FF00FF00FFLL))), v111);
      float32x4_t v148 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v114) & 0xFF00FF00FF00FFLL))), v111);
      int8x16_t v149 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v147));
      float32x4_t v150 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v148)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v145)));
      float32x4_t v151 = vmulq_f32(v147, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v145)), v22), v25));
      float32x4_t v152 = vmulq_f32(v148, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v145)), v22), v25));
      float32x4_t v153 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v152, 3);
      float32x4_t v154 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 3);
      float32x4_t v155 = (float32x4_t)vbslq_s8(v149, _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v145)));
      float32x4_t v156 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 3);
      float32x4_t v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v150, 3);
      int8x16_t v158 = (int8x16_t)vcgtzq_f32(v157);
      int8x16_t v159 = (int8x16_t)vcgtzq_f32(v154);
      int8x16_t v160 = (int8x16_t)vcgtzq_f32(v153);
      float32x4_t v161 = vaddq_f32(vmlsq_laneq_f32(v151, v151, v155, 3), vaddq_f32(vmlsq_laneq_f32(v155, v155, v151, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v154, v151), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v155, vmulq_f32(v151, v151), 3), vsubq_f32(v154, v151)))));
      float32x4_t v162 = vaddq_f32(vmlsq_laneq_f32(v152, v152, v150, 3), vaddq_f32(vmlsq_laneq_f32(v150, v150, v152, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v153, v152), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v150, vmulq_f32(v152, v152), 3), vsubq_f32(v153, v152)))));
      float32x4_t v163 = vaddq_f32(v156, vmlsq_laneq_f32(v154, v156, v151, 3));
      float32x4_t v164 = vaddq_f32(v157, vmlsq_laneq_f32(v153, v157, v152, 3));
      int8x16_t v165 = (int8x16_t)vminnmq_f32(v162, v164);
      int8x16_t v166 = (int8x16_t)vminnmq_f32(v161, v163);
      v165.i32[3] = v164.i32[3];
      v166.i32[3] = v163.i32[3];
      *float32x4_t v146 = vrev32q_s8(vbslq_s8(v160, vbslq_s8(v158, v165, (int8x16_t)v152), (int8x16_t)v150));
      v146[1] = vrev32q_s8(vbslq_s8(v159, vbslq_s8((int8x16_t)vcgtzq_f32(v156), v166, (int8x16_t)v151), (int8x16_t)v155));
      a10 += v28;
      v113 -= 2;
      if (v113 < 2) {
        break;
      }
      LOWORD(v114) = *(_WORD *)a10;
      v145 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v145);
        a3 = (int8x16_t *)((char *)a3 + v145);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v145);
    a3 = (int8x16_t *)((char *)a3 + v30 + v145);
LABEL_93:
    for (unint64_t j = a12 - v112 + v113; j; --j)
    {
      if (*a10)
      {
        float32x4_t v168 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v111);
        float32x4_t v169 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v168)), _Q5, vrev32q_s8(*result));
        float32x4_t v170 = vmulq_f32(v168, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v171 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v170, 3);
        float32x4_t v172 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v169, 3);
        int8x16_t v173 = (int8x16_t)vcgtzq_f32(v172);
        int8x16_t v174 = (int8x16_t)vcgtzq_f32(v171);
        float32x4_t v175 = vaddq_f32(vmlsq_laneq_f32(v170, v170, v169, 3), vaddq_f32(vmlsq_laneq_f32(v169, v169, v170, 3), (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v171, v170), _Q5, (int8x16_t)vdivq_f32(vmulq_laneq_f32(v169, vmulq_f32(v170, v170), 3), vsubq_f32(v171, v170)))));
        float32x4_t v176 = vaddq_f32(v172, vmlsq_laneq_f32(v171, v172, v170, 3));
        int8x16_t v177 = (int8x16_t)vminnmq_f32(v175, v176);
        v177.i32[3] = v176.i32[3];
        *float result = vrev32q_s8(vbslq_s8(v174, vbslq_s8(v173, v177, (int8x16_t)v170), (int8x16_t)v169));
      }
      uint64_t v178 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v178 >= a8) {
        uint64_t v179 = -(uint64_t)a7;
      }
      else {
        uint64_t v179 = 0;
      }
      a3 = &v178[v179];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    uint64_t v180 = &a5[a4];
    if ((unint64_t)v180 >= a9) {
      uint64_t v181 = v29;
    }
    else {
      uint64_t v181 = 0;
    }
    unsigned int v182 = &v180[v181];
    uint64_t v183 = a8 + 16 * v181 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v182;
      a8 = v183;
      a5 = v182;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)19,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  int8x16_t v21 = vmvnq_s8(v20);
  int8x16_t v22 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v23 = 0;
  }
  else {
    unsigned int v23 = -1;
  }
  v24.i64[0] = 0;
  v24.i32[2] = 0;
  v24.i32[3] = v23;
  int8x16_t v25 = vandq_s8(v22, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v24);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v23), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V6.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v60 = (int8x16_t *)&a10[v40];
          int8x16_t v61 = (int8x16_t *)a10;
          do
            float32x4_t v62 = v61++;
          while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v62)) & 0x80) != 0);
          do
          {
            float32x4_t v63 = v62;
            float32x4_t v62 = (int8x16_t *)((char *)v62 + 4);
          }
          while (v62 <= v60 && !v63->i32[0]);
          if (v63 < v60)
          {
            while (!v63->i8[0])
            {
              float32x4_t v63 = (int8x16_t *)((char *)v63 + 1);
              if (v63 >= v60)
              {
                float32x4_t v63 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v64 = (char *)v63 - a10;
          int64_t v65 = ((char *)v63 - a10) * a14;
          a3 += v65;
          result += v65;
          a10 += v65;
          v40 -= v64;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v21), v25);
          float32x4_t v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          int8x16_t v54 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3));
          float32x4_t v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v21), v25);
          float32x4_t v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          int8x16_t v57 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3));
          float32x4_t v58 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v52, v52), 3), v52);
          float32x4_t v59 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v55, v55), 3), v55);
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32(v53), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v52, v52, v50, 3), vaddq_f32(vmulq_laneq_f32(v53, v50, 3), vmlsq_laneq_f32(v50, v50, v52, 3))), v58, v50, 3), v50, v58), (float32x4_t)0), vbicq_s8(v54, (int8x16_t)vceqzq_f32(v52))), vbicq_s8((int8x16_t)v52, v54)), (int8x16_t)v50);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v55, v55, v51, 3), vaddq_f32(vmulq_laneq_f32(v56, v51, 3), vmlsq_laneq_f32(v51, v51, v55, 3))), v59, v51, 3), v51, v59), (float32x4_t)0), vbicq_s8(v57, (int8x16_t)vceqzq_f32(v55))), vbicq_s8((int8x16_t)v55, v57)), (int8x16_t)v51);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v66 = 0;
      while (1)
      {
        float32x4_t v67 = (int8x16_t *)((char *)result + v66);
        float32x4_t v68 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        int8x16_t v70 = vandq_s8(v24, (int8x16_t)vcgtzq_f32(v68));
        float32x4_t v71 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v69)), _Q6, *(int8x16_t *)((char *)result + v66));
        float32x4_t v72 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v66), v21), v25));
        float32x4_t v73 = vmulq_f32(v68, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v66), v21), v25));
        float32x4_t v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
        float32x4_t v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
        float32x4_t v76 = (float32x4_t)vbslq_s8(v70, _Q6, *(int8x16_t *)((char *)&result[1] + v66));
        int8x16_t v77 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3));
        int8x16_t v78 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3));
        float32x4_t v79 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v73, v73), 3), v73);
        float32x4_t v80 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v72, v72), 3), v72);
        int8x16_t *v67 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v72, v72, v71, 3), vaddq_f32(vmulq_laneq_f32(v75, v71, 3), vmlsq_laneq_f32(v71, v71, v72, 3))), v80, v71, 3), v71, v80), (float32x4_t)0), vbicq_s8(v77, (int8x16_t)vceqzq_f32(v72))), vbicq_s8((int8x16_t)v72, v77)), (int8x16_t)v71);
        v67[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v74), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v73, v73, v76, 3), vaddq_f32(vmulq_laneq_f32(v74, v76, 3), vmlsq_laneq_f32(v76, v76, v73, 3))), v79, v76, 3), v76, v79), (float32x4_t)0), vbicq_s8(v78, (int8x16_t)vceqzq_f32(v73))), vbicq_s8((int8x16_t)v73, v78)), (int8x16_t)v76);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v66 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v66);
          a3 = (int8x16_t *)((char *)a3 + v66);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v66);
      a3 = (int8x16_t *)((char *)a3 + v30 + v66);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v82 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v83 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v82)), _Q6, *result);
          float32x4_t v84 = vmulq_f32(v82, (float32x4_t)vorrq_s8(vandq_s8(*a3, v21), v25));
          float32x4_t v85 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 3);
          int8x16_t v86 = (int8x16_t)vcgtzq_f32(v85);
          float32x4_t v87 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v84, v84), 3), v84);
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 3)), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v84, v84, v83, 3), vaddq_f32(vmlsq_laneq_f32(v83, v83, v84, 3), vmulq_laneq_f32(v85, v84, 3))), v87, v83, 3), v83, v87), (float32x4_t)0), vbicq_s8(v86, (int8x16_t)vceqzq_f32(v84))), vbicq_s8((int8x16_t)v84, v86)), (int8x16_t)v83);
        }
        float32x4_t v88 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v88 >= a8) {
          uint64_t v89 = -(uint64_t)a7;
        }
        else {
          uint64_t v89 = 0;
        }
        a3 = &v88[v89];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v90 = &a5[a4];
      if ((unint64_t)v90 >= a9) {
        uint64_t v91 = v29;
      }
      else {
        uint64_t v91 = 0;
      }
      int8x16_t v92 = &v90[v91];
      uint64_t v93 = a8 + 16 * v91 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v92;
        a8 = v93;
        a5 = v92;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v94.i64[0] = -1;
  v94.i64[1] = -1;
  float32x4_t v95 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v96 = (a8 - (unint64_t)a3) >> 4;
    if (v96 >= a12) {
      unint64_t v96 = a12;
    }
    unint64_t v97 = v96;
    if (v96 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v98 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v117 = (int8x16_t *)&a10[v97];
        uint64_t v118 = (int8x16_t *)a10;
        do
          uint64_t v119 = v118++;
        while (v118 <= v117 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v119)) & 0x80) != 0);
        do
        {
          int64_t v120 = v119;
          uint64_t v119 = (int8x16_t *)((char *)v119 + 4);
        }
        while (v119 <= v117 && !v120->i32[0]);
        if (v120 < v117)
        {
          while (!v120->i8[0])
          {
            int64_t v120 = (int8x16_t *)((char *)v120 + 1);
            if (v120 >= v117)
            {
              int64_t v120 = (int8x16_t *)&a10[v97];
              break;
            }
          }
        }
        int64_t v121 = (char *)v120 - a10;
        int64_t v122 = ((char *)v120 - a10) * a14;
        a3 += v122;
        result += v122;
        a10 += v122;
        v97 -= v121;
        goto LABEL_90;
      }
      if (v98 != 0xFFFF) {
        break;
      }
      int8x16_t v99 = (int8x16_t *)&a10[v97];
      int8x16_t v100 = (int8x16_t *)a10;
      do
        float32x4_t v101 = v100++;
      while (v100 <= v99 && (vminvq_u8((uint8x16_t)vceqq_s8(*v101, v94)) & 0x80) != 0);
      do
      {
        float32x4_t v102 = v101;
        float32x4_t v101 = (int8x16_t *)((char *)v101 + 4);
      }
      while (v101 <= v99 && v102->i32[0] == -1);
      if (v102 < v99)
      {
        while (v102->u8[0] == 255)
        {
          float32x4_t v102 = (int8x16_t *)((char *)v102 + 1);
          if (v102 >= v99)
          {
            float32x4_t v102 = (int8x16_t *)&a10[v97];
            break;
          }
        }
      }
      uint64_t v103 = 0;
      int64_t v104 = (char *)v102 - a10;
      unint64_t v105 = (char *)v102 - a10;
      do
      {
        float32x4_t v106 = (int8x16_t *)((char *)result + v103);
        float32x4_t v107 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v103)), v26), v27);
        float32x4_t v108 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v103)), v26), v27);
        int8x16_t v109 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3));
        float32x4_t v110 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v103)), v21), v25);
        float32x4_t v111 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 3);
        int8x16_t v112 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 3));
        float32x4_t v113 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v103)), v21), v25);
        float32x4_t v114 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3);
        float32x4_t v115 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v110, v110), 3), v110);
        float32x4_t v116 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v113, v113), 3), v113);
        *float32x4_t v106 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v114), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v113, v113, v108, 3), vaddq_f32(vmulq_laneq_f32(v114, v108, 3), vmlsq_laneq_f32(v108, v108, v113, 3))), v116, v108, 3), v108, v116), (float32x4_t)0), vbicq_s8(v112, (int8x16_t)vceqzq_f32(v113))),
                      vbicq_s8((int8x16_t)v113, v112)),
                    (int8x16_t)v108));
        v106[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v111), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v110, v110, v107, 3), vaddq_f32(vmulq_laneq_f32(v111, v107, 3), vmlsq_laneq_f32(v107, v107, v110, 3))), v115, v107, 3), v107, v115), (float32x4_t)0), vbicq_s8(v109, (int8x16_t)vceqzq_f32(v110))),
                        vbicq_s8((int8x16_t)v110, v109)),
                      (int8x16_t)v107));
        a10 += v28;
        v105 -= 2;
        v103 += v30;
      }
      while (v105 > 1);
      a3 = (int8x16_t *)((char *)a3 + v103);
      float result = (int8x16_t *)((char *)result + v103);
      unint64_t v97 = v97 - v104 + v105;
LABEL_90:
      if (v97 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v123 = 0;
    while (1)
    {
      float32x4_t v124 = (int8x16_t *)((char *)result + v123);
      float32x4_t v125 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v98) & 0xFF00FF00FF00FFLL))), v95);
      float32x4_t v126 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v98)) & 0xFF00FF00FF00FFLL))), v95);
      int8x16_t v127 = vandq_s8(v24, (int8x16_t)vcgtzq_f32(v126));
      float32x4_t v128 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v125)), _Q6, vrev32q_s8(*(int8x16_t *)((char *)result + v123)));
      float32x4_t v129 = vmulq_f32(v126, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v123)), v21), v25));
      float32x4_t v130 = vmulq_f32(v125, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v123)), v21), v25));
      float32x4_t v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 3);
      float32x4_t v132 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 3);
      float32x4_t v133 = (float32x4_t)vbslq_s8(v127, _Q6, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v123)));
      int8x16_t v134 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v133, 3));
      int8x16_t v135 = (int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3));
      float32x4_t v136 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v129, v129), 3), v129);
      float32x4_t v137 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v130, v130), 3), v130);
      *float32x4_t v124 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v131), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v130, v130, v128, 3), vaddq_f32(vmulq_laneq_f32(v131, v128, 3), vmlsq_laneq_f32(v128, v128, v130, 3))), v137, v128, 3), v128, v137), (float32x4_t)0), vbicq_s8(v135, (int8x16_t)vceqzq_f32(v130))), vbicq_s8((int8x16_t)v130, v135)), (int8x16_t)v128));
      v124[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v132), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v129, v129, v133, 3), vaddq_f32(vmulq_laneq_f32(v132, v133, 3), vmlsq_laneq_f32(v133, v133, v129, 3))), v136, v133, 3), v133, v136), (float32x4_t)0), vbicq_s8(v134, (int8x16_t)vceqzq_f32(v129))),
                      vbicq_s8((int8x16_t)v129, v134)),
                    (int8x16_t)v133));
      a10 += v28;
      v97 -= 2;
      if (v97 < 2) {
        break;
      }
      LOWORD(v98) = *(_WORD *)a10;
      v123 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v123);
        a3 = (int8x16_t *)((char *)a3 + v123);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v123);
    a3 = (int8x16_t *)((char *)a3 + v30 + v123);
LABEL_93:
    for (unint64_t j = a12 - v96 + v97; j; --j)
    {
      if (*a10)
      {
        float32x4_t v139 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v95);
        float32x4_t v140 = (float32x4_t)vbslq_s8(vandq_s8(v24, (int8x16_t)vcgtzq_f32(v139)), _Q6, vrev32q_s8(*result));
        float32x4_t v141 = vmulq_f32(v139, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v21), v25));
        float32x4_t v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
        int8x16_t v143 = (int8x16_t)vcgtzq_f32(v142);
        float32x4_t v144 = vdivq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)vmulq_f32(v141, v141), 3), v141);
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3)), vorrq_s8(vandq_s8((int8x16_t)vmaxnmq_f32(vmlaq_f32(vmlsq_laneq_f32(vaddq_f32(vmlsq_laneq_f32(v141, v141, v140, 3), vaddq_f32(vmlsq_laneq_f32(v140, v140, v141, 3), vmulq_laneq_f32(v142, v141, 3))), v144, v140, 3), v140, v144), (float32x4_t)0), vbicq_s8(v143, (int8x16_t)vceqzq_f32(v141))),
                        vbicq_s8((int8x16_t)v141, v143)),
                      (int8x16_t)v140));
      }
      uint64_t v145 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v145 >= a8) {
        uint64_t v146 = -(uint64_t)a7;
      }
      else {
        uint64_t v146 = 0;
      }
      a3 = &v145[v146];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v147 = &a5[a4];
    if ((unint64_t)v147 >= a9) {
      uint64_t v148 = v29;
    }
    else {
      uint64_t v148 = 0;
    }
    int8x16_t v149 = &v147[v148];
    uint64_t v150 = a8 + 16 * v148 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v149;
      a8 = v150;
      a5 = v149;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)21,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = 0x3F0000003F000000;
    v37.i64[1] = 0x3F0000003F000000;
    v38.i64[0] = 0x8000000080000000;
    v38.i64[1] = 0x8000000080000000;
    v39.i64[0] = -1;
    v39.i64[1] = -1;
    float32x4_t v40 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v41 = (a8 - (unint64_t)a3) >> 4;
      if (v41 >= a12) {
        unint64_t v41 = a12;
      }
      unint64_t v42 = v41;
      if (v41 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v43 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          int64_t v64 = (int8x16_t *)&a10[v42];
          int64_t v65 = (int8x16_t *)a10;
          do
            uint64_t v66 = v65++;
          while (v65 <= v64 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v66)) & 0x80) != 0);
          do
          {
            float32x4_t v67 = v66;
            uint64_t v66 = (int8x16_t *)((char *)v66 + 4);
          }
          while (v66 <= v64 && !v67->i32[0]);
          if (v67 < v64)
          {
            while (!v67->i8[0])
            {
              float32x4_t v67 = (int8x16_t *)((char *)v67 + 1);
              if (v67 >= v64)
              {
                float32x4_t v67 = (int8x16_t *)&a10[v42];
                break;
              }
            }
          }
          int64_t v68 = (char *)v67 - a10;
          int64_t v69 = ((char *)v67 - a10) * a14;
          a3 += v69;
          result += v69;
          a10 += v69;
          v42 -= v68;
          goto LABEL_40;
        }
        if (v43 != 0xFFFF) {
          break;
        }
        int64_t v44 = (int8x16_t *)&a10[v42];
        int64_t v45 = (int8x16_t *)a10;
        do
          uint64_t v46 = v45++;
        while (v45 <= v44 && (vminvq_u8((uint8x16_t)vceqq_s8(*v46, v39)) & 0x80) != 0);
        do
        {
          int64_t v47 = v46;
          uint64_t v46 = (int8x16_t *)((char *)v46 + 4);
        }
        while (v46 <= v44 && v47->i32[0] == -1);
        if (v47 < v44)
        {
          while (v47->u8[0] == 255)
          {
            int64_t v47 = (int8x16_t *)((char *)v47 + 1);
            if (v47 >= v44)
            {
              int64_t v47 = (int8x16_t *)&a10[v42];
              break;
            }
          }
        }
        uint64_t v48 = 0;
        int64_t v49 = (char *)v47 - a10;
        unint64_t v50 = (char *)v47 - a10;
        do
        {
          float32x4_t v51 = (int8x16_t *)((char *)result + v48);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v48), v22), v25);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v48), v22), v25);
          float32x4_t v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v48), v26), v27);
          float32x4_t v55 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v48), v26), v27);
          float32x4_t v56 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3);
          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          float32x4_t v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 3);
          float32x4_t v59 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
          int8x16_t v60 = (int8x16_t)vcgtq_f32(v52, vmulq_laneq_f32(v37, v52, 3));
          int8x16_t v61 = (int8x16_t)vcgtq_f32(v53, vmulq_laneq_f32(v37, v53, 3));
          int8x16_t v62 = vbicq_s8(v38, v61);
          int8x16_t v63 = vbicq_s8(v38, v60);
          int8x16_t *v51 = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v58), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v55, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v57, v52)), v55), vmlaq_f32(v52, (float32x4_t)veorq_s8(v63, (int8x16_t)vsubq_f32(v58, v55)), v52)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v57, v55, 3), v60)), (int8x16_t)v52), (int8x16_t)v55);
          v51[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v56), vbslq_s8((int8x16_t)vcgtzq_f32(v59), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v54, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v56, v53)), v54), vmlaq_f32(v53, (float32x4_t)veorq_s8(v62, (int8x16_t)vsubq_f32(v59, v54)), v53)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v56, v54, 3), v61)), (int8x16_t)v53), (int8x16_t)v54);
          a10 += v28;
          v50 -= 2;
          v48 += v30;
        }
        while (v50 > 1);
        a3 = (int8x16_t *)((char *)a3 + v48);
        float result = (int8x16_t *)((char *)result + v48);
        unint64_t v42 = v42 - v49 + v50;
LABEL_40:
        if (v42 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v70 = 0;
      while (1)
      {
        float32x4_t v71 = (int8x16_t *)((char *)result + v70);
        float32x4_t v72 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v43) & 0xFF00FF00FF00FFLL))), v40);
        float32x4_t v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v43)) & 0xFF00FF00FF00FFLL))), v40);
        int8x16_t v74 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v72));
        float32x4_t v75 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *(int8x16_t *)((char *)&result[1] + v70));
        float32x4_t v76 = vmulq_f32(v72, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v70), v22), v25));
        float32x4_t v77 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v70), v22), v25));
        float32x4_t v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        float32x4_t v79 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3);
        float32x4_t v80 = (float32x4_t)vbslq_s8(v74, _Q5, *(int8x16_t *)((char *)result + v70));
        float32x4_t v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        float32x4_t v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 3);
        int8x16_t v83 = (int8x16_t)vcgtq_f32(v76, vmulq_laneq_f32(v37, v76, 3));
        int8x16_t v84 = (int8x16_t)vcgtq_f32(v77, vmulq_laneq_f32(v37, v77, 3));
        int8x16_t v85 = vbicq_s8(v38, v84);
        int8x16_t v86 = vbicq_s8(v38, v83);
        *float32x4_t v71 = vbslq_s8((int8x16_t)vcgtzq_f32(v79), vbslq_s8((int8x16_t)vcgtzq_f32(v81), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v80, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v79, v76)), v80), vmlaq_f32(v76, (float32x4_t)veorq_s8(v86, (int8x16_t)vsubq_f32(v81, v80)), v76)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v79, v80, 3), v83)), (int8x16_t)v76), (int8x16_t)v80);
        v71[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v78), vbslq_s8((int8x16_t)vcgtzq_f32(v82), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v75, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v78, v77)), v75), vmlaq_f32(v77, (float32x4_t)veorq_s8(v85, (int8x16_t)vsubq_f32(v82, v75)), v77)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v78, v75, 3), v84)), (int8x16_t)v77), (int8x16_t)v75);
        a10 += v28;
        v42 -= 2;
        if (v42 < 2) {
          break;
        }
        LOWORD(v43) = *(_WORD *)a10;
        v70 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v70);
          a3 = (int8x16_t *)((char *)a3 + v70);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v70);
      a3 = (int8x16_t *)((char *)a3 + v30 + v70);
LABEL_43:
      for (unint64_t i = a12 - v41 + v42; i; --i)
      {
        if (*a10)
        {
          float32x4_t v88 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v40);
          float32x4_t v89 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v88)), _Q5, *result);
          float32x4_t v90 = vmulq_f32(v88, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v91 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v90, 3);
          float32x4_t v92 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 3);
          int8x16_t v93 = (int8x16_t)vcgtq_f32(v90, vmulq_laneq_f32(v37, v90, 3));
          int8x16_t v94 = vbicq_s8(v38, v93);
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32(v91), vbslq_s8((int8x16_t)vcgtzq_f32(v92), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v89, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v91, v90)), v89), vmlaq_f32(v90, (float32x4_t)veorq_s8(v94, (int8x16_t)vsubq_f32(v92, v89)), v90)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v92, v90, 3), v93)), (int8x16_t)v90), (int8x16_t)v89);
        }
        float32x4_t v95 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v95 >= a8) {
          uint64_t v96 = -(uint64_t)a7;
        }
        else {
          uint64_t v96 = 0;
        }
        a3 = &v95[v96];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      unint64_t v97 = &a5[a4];
      if ((unint64_t)v97 >= a9) {
        uint64_t v98 = v29;
      }
      else {
        uint64_t v98 = 0;
      }
      int8x16_t v99 = &v97[v98];
      uint64_t v100 = a8 + 16 * v98 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v99;
        a8 = v100;
        a5 = v99;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v101.i64[0] = 0x3F0000003F000000;
  v101.i64[1] = 0x3F0000003F000000;
  v102.i64[0] = 0x8000000080000000;
  v102.i64[1] = 0x8000000080000000;
  v103.i64[0] = -1;
  v103.i64[1] = -1;
  float32x4_t v104 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v105 = (a8 - (unint64_t)a3) >> 4;
    if (v105 >= a12) {
      unint64_t v105 = a12;
    }
    unint64_t v106 = v105;
    if (v105 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v107 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v128 = (int8x16_t *)&a10[v106];
        float32x4_t v129 = (int8x16_t *)a10;
        do
          float32x4_t v130 = v129++;
        while (v129 <= v128 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v130)) & 0x80) != 0);
        do
        {
          float32x4_t v131 = v130;
          float32x4_t v130 = (int8x16_t *)((char *)v130 + 4);
        }
        while (v130 <= v128 && !v131->i32[0]);
        if (v131 < v128)
        {
          while (!v131->i8[0])
          {
            float32x4_t v131 = (int8x16_t *)((char *)v131 + 1);
            if (v131 >= v128)
            {
              float32x4_t v131 = (int8x16_t *)&a10[v106];
              break;
            }
          }
        }
        int64_t v132 = (char *)v131 - a10;
        int64_t v133 = ((char *)v131 - a10) * a14;
        a3 += v133;
        result += v133;
        a10 += v133;
        v106 -= v132;
        goto LABEL_90;
      }
      if (v107 != 0xFFFF) {
        break;
      }
      float32x4_t v108 = (int8x16_t *)&a10[v106];
      int8x16_t v109 = (int8x16_t *)a10;
      do
        float32x4_t v110 = v109++;
      while (v109 <= v108 && (vminvq_u8((uint8x16_t)vceqq_s8(*v110, v103)) & 0x80) != 0);
      do
      {
        float32x4_t v111 = v110;
        float32x4_t v110 = (int8x16_t *)((char *)v110 + 4);
      }
      while (v110 <= v108 && v111->i32[0] == -1);
      if (v111 < v108)
      {
        while (v111->u8[0] == 255)
        {
          float32x4_t v111 = (int8x16_t *)((char *)v111 + 1);
          if (v111 >= v108)
          {
            float32x4_t v111 = (int8x16_t *)&a10[v106];
            break;
          }
        }
      }
      uint64_t v112 = 0;
      int64_t v113 = (char *)v111 - a10;
      unint64_t v114 = (char *)v111 - a10;
      do
      {
        float32x4_t v115 = (int8x16_t *)((char *)result + v112);
        float32x4_t v116 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v112)), v22), v25);
        float32x4_t v117 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v112)), v22), v25);
        float32x4_t v118 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v112)), v26), v27);
        float32x4_t v119 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v112)), v26), v27);
        float32x4_t v120 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 3);
        float32x4_t v121 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 3);
        float32x4_t v122 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v119, 3);
        float32x4_t v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v118, 3);
        int8x16_t v124 = (int8x16_t)vcgtq_f32(v116, vmulq_laneq_f32(v101, v116, 3));
        int8x16_t v125 = (int8x16_t)vcgtq_f32(v117, vmulq_laneq_f32(v101, v117, 3));
        int8x16_t v126 = vbicq_s8(v102, v125);
        int8x16_t v127 = vbicq_s8(v102, v124);
        *float32x4_t v115 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v120), vbslq_s8((int8x16_t)vcgtzq_f32(v123), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v118, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v120, v117)), v118), vmlaq_f32(v117, (float32x4_t)veorq_s8(v126, (int8x16_t)vsubq_f32(v123, v118)), v117)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v120, v118, 3), v125)), (int8x16_t)v117), (int8x16_t)v118));
        v115[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v121), vbslq_s8((int8x16_t)vcgtzq_f32(v122), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v119, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v121, v116)), v119), vmlaq_f32(v116, (float32x4_t)veorq_s8(v127, (int8x16_t)vsubq_f32(v122, v119)), v116)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v121, v119, 3), v124)), (int8x16_t)v116), (int8x16_t)v119));
        a10 += v28;
        v114 -= 2;
        v112 += v30;
      }
      while (v114 > 1);
      a3 = (int8x16_t *)((char *)a3 + v112);
      float result = (int8x16_t *)((char *)result + v112);
      unint64_t v106 = v106 - v113 + v114;
LABEL_90:
      if (v106 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v134 = 0;
    while (1)
    {
      int8x16_t v135 = (int8x16_t *)((char *)result + v134);
      float32x4_t v136 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v107)) & 0xFF00FF00FF00FFLL))), v104);
      float32x4_t v137 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v107) & 0xFF00FF00FF00FFLL))), v104);
      int8x16_t v138 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v137));
      float32x4_t v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v136)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v134)));
      float32x4_t v140 = vmulq_f32(v136, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v134)), v22), v25));
      float32x4_t v141 = vmulq_f32(v137, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v134)), v22), v25));
      float32x4_t v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 3);
      float32x4_t v143 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
      float32x4_t v144 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
      float32x4_t v145 = (float32x4_t)vbslq_s8(v138, _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v134)));
      float32x4_t v146 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 3);
      int8x16_t v147 = (int8x16_t)vcgtq_f32(v140, vmulq_laneq_f32(v101, v140, 3));
      int8x16_t v148 = (int8x16_t)vcgtq_f32(v141, vmulq_laneq_f32(v101, v141, 3));
      int8x16_t v149 = vbicq_s8(v102, v148);
      int8x16_t v150 = vbicq_s8(v102, v147);
      *int8x16_t v135 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v142), vbslq_s8((int8x16_t)vcgtzq_f32(v146), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v145, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v142, v141)), v145), vmlaq_f32(v141, (float32x4_t)veorq_s8(v149, (int8x16_t)vsubq_f32(v146, v145)), v141)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v142, v145, 3), v148)), (int8x16_t)v141), (int8x16_t)v145));
      v135[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v143), vbslq_s8((int8x16_t)vcgtzq_f32(v144), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v139, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v143, v140)), v139), vmlaq_f32(v140, (float32x4_t)veorq_s8(v150, (int8x16_t)vsubq_f32(v144, v139)), v140)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v143, v139, 3), v147)), (int8x16_t)v140), (int8x16_t)v139));
      a10 += v28;
      v106 -= 2;
      if (v106 < 2) {
        break;
      }
      LOWORD(v107) = *(_WORD *)a10;
      v134 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v134);
        a3 = (int8x16_t *)((char *)a3 + v134);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v134);
    a3 = (int8x16_t *)((char *)a3 + v30 + v134);
LABEL_93:
    for (unint64_t j = a12 - v105 + v106; j; --j)
    {
      if (*a10)
      {
        float32x4_t v152 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v104);
        int8x16_t v153 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v152));
        float32x4_t v154 = vmulq_f32(v152, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v155 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 3);
        float32x4_t v156 = (float32x4_t)vbslq_s8(v153, _Q5, vrev32q_s8(*result));
        float32x4_t v157 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 3);
        int8x16_t v158 = (int8x16_t)vcgtq_f32(v154, vmulq_laneq_f32(v101, v154, 3));
        int8x16_t v159 = vbicq_s8(v102, v158);
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v155), vbslq_s8((int8x16_t)vcgtzq_f32(v157), (int8x16_t)vsubq_f32(vaddq_f32(vmlaq_f32(v156, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v155, v154)), v156), vmlaq_f32(v154, (float32x4_t)veorq_s8(v159, (int8x16_t)vsubq_f32(v157, v156)), v154)), (float32x4_t)vandq_s8((int8x16_t)vmulq_laneq_f32(v157, v154, 3), v158)), (int8x16_t)v154), (int8x16_t)v156));
      }
      int8x16_t v160 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v160 >= a8) {
        uint64_t v161 = -(uint64_t)a7;
      }
      else {
        uint64_t v161 = 0;
      }
      a3 = &v160[v161];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v162 = &a5[a4];
    if ((unint64_t)v162 >= a9) {
      uint64_t v163 = v29;
    }
    else {
      uint64_t v163 = 0;
    }
    float32x4_t v164 = &v162[v163];
    uint64_t v165 = a8 + 16 * v163 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v164;
      a8 = v165;
      a5 = v164;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)20,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v67 = (int8x16_t *)&a10[v40];
          int64_t v68 = (int8x16_t *)a10;
          do
            int64_t v69 = v68++;
          while (v68 <= v67 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v69)) & 0x80) != 0);
          do
          {
            uint64_t v70 = v69;
            int64_t v69 = (int8x16_t *)((char *)v69 + 4);
          }
          while (v69 <= v67 && !v70->i32[0]);
          if (v70 < v67)
          {
            while (!v70->i8[0])
            {
              uint64_t v70 = (int8x16_t *)((char *)v70 + 1);
              if (v70 >= v67)
              {
                uint64_t v70 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v71 = (char *)v70 - a10;
          int64_t v72 = ((char *)v70 - a10) * a14;
          a3 += v72;
          result += v72;
          a10 += v72;
          v40 -= v71;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v52 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          float32x4_t v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3);
          float32x4_t v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          int8x16_t v55 = (int8x16_t)vcgtzq_f32(v52);
          float32x4_t v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          int8x16_t v57 = (int8x16_t)vcgtzq_f32(v53);
          int8x16_t v58 = (int8x16_t)vceqzq_f32(v52);
          int8x16_t v59 = (int8x16_t)vceqzq_f32(v53);
          float32x4_t v60 = vdivq_f32(v50, v52);
          float32x4_t v61 = vaddq_f32(v56, v56);
          float32x4_t v62 = vdivq_f32(v51, v53);
          float32x4_t v63 = vaddq_f32(v54, v54);
          float32x4_t v64 = vmlaq_laneq_f32(vmlsq_f32(v61, v60, v61), v60, v56, 3);
          float32x4_t v65 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v63, v62, v63), v62, v54, 3), v51);
          float32x4_t v66 = vmulq_f32(v64, v50);
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3)), vbslq_s8(v57, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v54, v54, v51, 3), vaddq_f32(vmlsq_laneq_f32(v51, v51, v54, 3), (float32x4_t)vandq_s8((int8x16_t)v65, vbicq_s8((int8x16_t)vcgezq_f32(v65), v59)))), (int8x16_t)v54), (int8x16_t)v51);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3)), vbslq_s8(v55, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v56, v56, v50, 3), vaddq_f32(vmlsq_laneq_f32(v50, v50, v56, 3), (float32x4_t)vandq_s8((int8x16_t)v66, vbicq_s8((int8x16_t)vcgezq_f32(v66), v58)))), (int8x16_t)v56), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v73 = 0;
      while (1)
      {
        int8x16_t v74 = (int8x16_t *)((char *)result + v73);
        float32x4_t v75 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v76 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v77 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v76)), _Q5, *(int8x16_t *)((char *)&result[1] + v73));
        float32x4_t v78 = vmulq_f32(v75, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v73), v22), v25));
        float32x4_t v79 = vmulq_f32(v76, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v73), v22), v25));
        float32x4_t v80 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v75)), _Q5, *(int8x16_t *)((char *)result + v73));
        float32x4_t v81 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 3);
        float32x4_t v82 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        int8x16_t v83 = (int8x16_t)vcgtzq_f32(v82);
        int8x16_t v84 = (int8x16_t)vcgtzq_f32(v81);
        int8x16_t v85 = (int8x16_t)vceqzq_f32(v82);
        int8x16_t v86 = (int8x16_t)vceqzq_f32(v81);
        float32x4_t v87 = vdivq_f32(v77, v82);
        float32x4_t v88 = vdivq_f32(v80, v81);
        float32x4_t v89 = vaddq_f32(v79, v79);
        float32x4_t v90 = vaddq_f32(v78, v78);
        float32x4_t v91 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v90, v88, v90), v88, v78, 3), v80);
        float32x4_t v92 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v89, v87, v89), v87, v79, 3), v77);
        int8x16_t *v74 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v78, 3)), vbslq_s8(v84, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v78, v78, v80, 3), vaddq_f32(vmlsq_laneq_f32(v80, v80, v78, 3), (float32x4_t)vandq_s8((int8x16_t)v91, vbicq_s8((int8x16_t)vcgezq_f32(v91), v86)))), (int8x16_t)v78), (int8x16_t)v80);
        v74[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 3)), vbslq_s8(v83, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v79, v79, v77, 3), vaddq_f32(vmlsq_laneq_f32(v77, v77, v79, 3), (float32x4_t)vandq_s8((int8x16_t)v92, vbicq_s8((int8x16_t)vcgezq_f32(v92), v85)))), (int8x16_t)v79), (int8x16_t)v77);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v73 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v73);
          a3 = (int8x16_t *)((char *)a3 + v73);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v73);
      a3 = (int8x16_t *)((char *)a3 + v30 + v73);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v94 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v95 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v94)), _Q5, *result);
          float32x4_t v96 = vmulq_f32(v94, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v97 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v95, 3);
          int8x16_t v98 = (int8x16_t)vcgtzq_f32(v97);
          int8x16_t v99 = (int8x16_t)vceqzq_f32(v97);
          float32x4_t v100 = vdivq_f32(v95, v97);
          float32x4_t v101 = vaddq_f32(v96, v96);
          float32x4_t v102 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v101, v100, v101), v100, v96, 3), v95);
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3)), vbslq_s8(v98, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v96, v96, v95, 3), vaddq_f32(vmlsq_laneq_f32(v95, v95, v96, 3), (float32x4_t)vandq_s8((int8x16_t)v102, vbicq_s8((int8x16_t)vcgezq_f32(v102), v99)))), (int8x16_t)v96), (int8x16_t)v95);
        }
        int8x16_t v103 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v103 >= a8) {
          uint64_t v104 = -(uint64_t)a7;
        }
        else {
          uint64_t v104 = 0;
        }
        a3 = &v103[v104];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      unint64_t v105 = &a5[a4];
      if ((unint64_t)v105 >= a9) {
        uint64_t v106 = v29;
      }
      else {
        uint64_t v106 = 0;
      }
      int v107 = &v105[v106];
      uint64_t v108 = a8 + 16 * v106 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v107;
        a8 = v108;
        a5 = v107;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v109.i64[0] = -1;
  v109.i64[1] = -1;
  float32x4_t v110 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v111 = (a8 - (unint64_t)a3) >> 4;
    if (v111 >= a12) {
      unint64_t v111 = a12;
    }
    unint64_t v112 = v111;
    if (v111 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v113 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v137 = (int8x16_t *)&a10[v112];
        int8x16_t v138 = (int8x16_t *)a10;
        do
          float32x4_t v139 = v138++;
        while (v138 <= v137 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v139)) & 0x80) != 0);
        do
        {
          float32x4_t v140 = v139;
          float32x4_t v139 = (int8x16_t *)((char *)v139 + 4);
        }
        while (v139 <= v137 && !v140->i32[0]);
        if (v140 < v137)
        {
          while (!v140->i8[0])
          {
            float32x4_t v140 = (int8x16_t *)((char *)v140 + 1);
            if (v140 >= v137)
            {
              float32x4_t v140 = (int8x16_t *)&a10[v112];
              break;
            }
          }
        }
        int64_t v141 = (char *)v140 - a10;
        int64_t v142 = ((char *)v140 - a10) * a14;
        a3 += v142;
        result += v142;
        a10 += v142;
        v112 -= v141;
        goto LABEL_90;
      }
      if (v113 != 0xFFFF) {
        break;
      }
      unint64_t v114 = (int8x16_t *)&a10[v112];
      float32x4_t v115 = (int8x16_t *)a10;
      do
        float32x4_t v116 = v115++;
      while (v115 <= v114 && (vminvq_u8((uint8x16_t)vceqq_s8(*v116, v109)) & 0x80) != 0);
      do
      {
        float32x4_t v117 = v116;
        float32x4_t v116 = (int8x16_t *)((char *)v116 + 4);
      }
      while (v116 <= v114 && v117->i32[0] == -1);
      if (v117 < v114)
      {
        while (v117->u8[0] == 255)
        {
          float32x4_t v117 = (int8x16_t *)((char *)v117 + 1);
          if (v117 >= v114)
          {
            float32x4_t v117 = (int8x16_t *)&a10[v112];
            break;
          }
        }
      }
      uint64_t v118 = 0;
      int64_t v119 = (char *)v117 - a10;
      unint64_t v120 = (char *)v117 - a10;
      do
      {
        float32x4_t v121 = (int8x16_t *)((char *)result + v118);
        float32x4_t v122 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v118)), v26), v27);
        float32x4_t v123 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v122, 3);
        float32x4_t v124 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v118)), v26), v27);
        float32x4_t v125 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3);
        float32x4_t v126 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v118)), v22), v25);
        int8x16_t v127 = (int8x16_t)vcgtzq_f32(v123);
        float32x4_t v128 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v118)), v22), v25);
        int8x16_t v129 = (int8x16_t)vceqzq_f32(v123);
        float32x4_t v130 = vdivq_f32(v124, v125);
        float32x4_t v131 = vdivq_f32(v122, v123);
        float32x4_t v132 = vaddq_f32(v126, v126);
        float32x4_t v133 = vaddq_f32(v128, v128);
        float32x4_t v134 = vmlaq_laneq_f32(vmlsq_f32(v133, v131, v133), v131, v128, 3);
        float32x4_t v135 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v132, v130, v132), v130, v126, 3), v124);
        float32x4_t v136 = vmulq_f32(v134, v122);
        *float32x4_t v121 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3)), vbslq_s8(v127, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v128, v128, v122, 3), vaddq_f32(vmlsq_laneq_f32(v122, v122, v128, 3), (float32x4_t)vandq_s8((int8x16_t)v136, vbicq_s8((int8x16_t)vcgezq_f32(v136), v129)))), (int8x16_t)v128), (int8x16_t)v122));
        v121[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v126, 3)), vbslq_s8((int8x16_t)vcgtzq_f32(v125), (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v126, v126, v124, 3), vaddq_f32(vmlsq_laneq_f32(v124, v124, v126, 3), (float32x4_t)vandq_s8((int8x16_t)v135, vbicq_s8((int8x16_t)vcgezq_f32(v135), (int8x16_t)vceqzq_f32(v125))))), (int8x16_t)v126), (int8x16_t)v124));
        a10 += v28;
        v120 -= 2;
        v118 += v30;
      }
      while (v120 > 1);
      a3 = (int8x16_t *)((char *)a3 + v118);
      float result = (int8x16_t *)((char *)result + v118);
      unint64_t v112 = v112 - v119 + v120;
LABEL_90:
      if (v112 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v143 = 0;
    while (1)
    {
      float32x4_t v144 = (int8x16_t *)((char *)result + v143);
      float32x4_t v145 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v113)) & 0xFF00FF00FF00FFLL))), v110);
      float32x4_t v146 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v113) & 0xFF00FF00FF00FFLL))), v110);
      float32x4_t v147 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v145)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v143)));
      float32x4_t v148 = vmulq_f32(v145, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v143)), v22), v25));
      float32x4_t v149 = vmulq_f32(v146, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v143)), v22), v25));
      float32x4_t v150 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v147, 3);
      float32x4_t v151 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v146)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v143)));
      float32x4_t v152 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 3);
      int8x16_t v153 = (int8x16_t)vcgtzq_f32(v152);
      int8x16_t v154 = (int8x16_t)vcgtzq_f32(v150);
      int8x16_t v155 = (int8x16_t)vceqzq_f32(v152);
      int8x16_t v156 = (int8x16_t)vceqzq_f32(v150);
      float32x4_t v157 = vdivq_f32(v147, v150);
      float32x4_t v158 = vdivq_f32(v151, v152);
      float32x4_t v159 = vaddq_f32(v148, v148);
      float32x4_t v160 = vaddq_f32(v149, v149);
      float32x4_t v161 = vmlaq_laneq_f32(vmlsq_f32(v160, v158, v160), v158, v149, 3);
      float32x4_t v162 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v159, v157, v159), v157, v148, 3), v147);
      float32x4_t v163 = vmulq_f32(v161, v151);
      *float32x4_t v144 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v149, 3)), vbslq_s8(v153, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v149, v149, v151, 3), vaddq_f32(vmlsq_laneq_f32(v151, v151, v149, 3), (float32x4_t)vandq_s8((int8x16_t)v163, vbicq_s8((int8x16_t)vcgezq_f32(v163), v155)))), (int8x16_t)v149), (int8x16_t)v151));
      v144[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v148, 3)), vbslq_s8(v154, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v148, v148, v147, 3), vaddq_f32(vmlsq_laneq_f32(v147, v147, v148, 3), (float32x4_t)vandq_s8((int8x16_t)v162, vbicq_s8((int8x16_t)vcgezq_f32(v162), v156)))), (int8x16_t)v148), (int8x16_t)v147));
      a10 += v28;
      v112 -= 2;
      if (v112 < 2) {
        break;
      }
      LOWORD(v113) = *(_WORD *)a10;
      v143 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v143);
        a3 = (int8x16_t *)((char *)a3 + v143);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v143);
    a3 = (int8x16_t *)((char *)a3 + v30 + v143);
LABEL_93:
    for (unint64_t j = a12 - v111 + v112; j; --j)
    {
      if (*a10)
      {
        float32x4_t v165 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v110);
        float32x4_t v166 = vmulq_f32(v165, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v167 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v165)), _Q5, vrev32q_s8(*result));
        float32x4_t v168 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v167, 3);
        int8x16_t v169 = (int8x16_t)vcgtzq_f32(v168);
        int8x16_t v170 = (int8x16_t)vceqzq_f32(v168);
        float32x4_t v171 = vdivq_f32(v167, v168);
        float32x4_t v172 = vaddq_f32(v166, v166);
        float32x4_t v173 = vmulq_f32(vmlaq_laneq_f32(vmlsq_f32(v172, v171, v172), v171, v166, 3), v167);
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v166, 3)), vbslq_s8(v169, (int8x16_t)vaddq_f32(vmlsq_laneq_f32(v166, v166, v167, 3), vaddq_f32(vmlsq_laneq_f32(v167, v167, v166, 3), (float32x4_t)vandq_s8((int8x16_t)v173, vbicq_s8((int8x16_t)vcgezq_f32(v173), v170)))), (int8x16_t)v166), (int8x16_t)v167));
      }
      int8x16_t v174 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v174 >= a8) {
        uint64_t v175 = -(uint64_t)a7;
      }
      else {
        uint64_t v175 = 0;
      }
      a3 = &v174[v175];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v176 = &a5[a4];
    if ((unint64_t)v176 >= a9) {
      uint64_t v177 = v29;
    }
    else {
      uint64_t v177 = 0;
    }
    uint64_t v178 = &v176[v177];
    uint64_t v179 = a8 + 16 * v177 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v178;
      a8 = v179;
      a5 = v178;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)22,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v60 = (int8x16_t *)&a10[v40];
          float32x4_t v61 = (int8x16_t *)a10;
          do
            float32x4_t v62 = v61++;
          while (v61 <= v60 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v62)) & 0x80) != 0);
          do
          {
            float32x4_t v63 = v62;
            float32x4_t v62 = (int8x16_t *)((char *)v62 + 4);
          }
          while (v62 <= v60 && !v63->i32[0]);
          if (v63 < v60)
          {
            while (!v63->i8[0])
            {
              float32x4_t v63 = (int8x16_t *)((char *)v63 + 1);
              if (v63 >= v60)
              {
                float32x4_t v63 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v64 = (char *)v63 - a10;
          int64_t v65 = ((char *)v63 - a10) * a14;
          a3 += v65;
          result += v65;
          a10 += v65;
          v40 -= v64;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v51 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v53 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3);
          float32x4_t v54 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
          float32x4_t v56 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          float32x4_t v57 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v56, 3);
          int8x16_t v58 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v52, v54, 3), vmulq_laneq_f32(v54, v52, 3)), vaddq_f32(vmlsq_laneq_f32(v52, v52, v54, 3), vmlsq_laneq_f32(v54, v54, v52, 3)));
          int8x16_t v59 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v50, v56, 3), vmulq_laneq_f32(v56, v50, 3)), vaddq_f32(vmlsq_laneq_f32(v50, v50, v56, 3), vmlsq_laneq_f32(v56, v56, v50, 3)));
          v59.i32[3] = vaddq_f32(v56, vmlsq_laneq_f32(v51, v57, v50, 3)).i32[3];
          v58.i32[3] = vaddq_f32(v54, vmlsq_laneq_f32(v53, v55, v52, 3)).i32[3];
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32(v55), vbslq_s8((int8x16_t)vcgtzq_f32(v53), v58, (int8x16_t)v54), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v57), vbslq_s8((int8x16_t)vcgtzq_f32(v51), v59, (int8x16_t)v56), (int8x16_t)v50);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v66 = 0;
      while (1)
      {
        float32x4_t v67 = (int8x16_t *)((char *)result + v66);
        float32x4_t v68 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v69 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        int8x16_t v70 = vandq_s8(v21, (int8x16_t)vcgtzq_f32(v69));
        float32x4_t v71 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v68)), _Q5, *(int8x16_t *)((char *)result + v66));
        float32x4_t v72 = vmulq_f32(v68, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v66), v22), v25));
        float32x4_t v73 = vmulq_f32(v69, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v66), v22), v25));
        float32x4_t v74 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 3);
        float32x4_t v75 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3);
        float32x4_t v76 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 3);
        float32x4_t v77 = (float32x4_t)vbslq_s8(v70, _Q5, *(int8x16_t *)((char *)&result[1] + v66));
        float32x4_t v78 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 3);
        int8x16_t v79 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v71, v72, 3), vmulq_laneq_f32(v72, v71, 3)), vaddq_f32(vmlsq_laneq_f32(v71, v71, v72, 3), vmlsq_laneq_f32(v72, v72, v71, 3)));
        int8x16_t v80 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v77, v73, 3), vmulq_laneq_f32(v73, v77, 3)), vaddq_f32(vmlsq_laneq_f32(v77, v77, v73, 3), vmlsq_laneq_f32(v73, v73, v77, 3)));
        v80.i32[3] = vaddq_f32(v73, vmlsq_laneq_f32(v78, v74, v77, 3)).i32[3];
        v79.i32[3] = vaddq_f32(v72, vmlsq_laneq_f32(v76, v75, v71, 3)).i32[3];
        int8x16_t *v67 = vbslq_s8((int8x16_t)vcgtzq_f32(v75), vbslq_s8((int8x16_t)vcgtzq_f32(v76), v79, (int8x16_t)v72), (int8x16_t)v71);
        v67[1] = vbslq_s8((int8x16_t)vcgtzq_f32(v74), vbslq_s8((int8x16_t)vcgtzq_f32(v78), v80, (int8x16_t)v73), (int8x16_t)v77);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v66 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v66);
          a3 = (int8x16_t *)((char *)a3 + v66);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v66);
      a3 = (int8x16_t *)((char *)a3 + v30 + v66);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v82 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v83 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v82)), _Q5, *result);
          float32x4_t v84 = vmulq_f32(v82, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v85 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 3);
          float32x4_t v86 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 3);
          int8x16_t v87 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v84, v84, v83, 3), vmlsq_laneq_f32(v83, v83, v84, 3)), vabdq_f32(vmulq_laneq_f32(v83, v84, 3), vmulq_laneq_f32(v84, v83, 3)));
          v87.i32[3] = vaddq_f32(v84, vmlsq_laneq_f32(v86, v85, v83, 3)).i32[3];
          *float result = vbslq_s8((int8x16_t)vcgtzq_f32(v85), vbslq_s8((int8x16_t)vcgtzq_f32(v86), v87, (int8x16_t)v84), (int8x16_t)v83);
        }
        float32x4_t v88 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v88 >= a8) {
          uint64_t v89 = -(uint64_t)a7;
        }
        else {
          uint64_t v89 = 0;
        }
        a3 = &v88[v89];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      float32x4_t v90 = &a5[a4];
      if ((unint64_t)v90 >= a9) {
        uint64_t v91 = v29;
      }
      else {
        uint64_t v91 = 0;
      }
      float32x4_t v92 = &v90[v91];
      uint64_t v93 = a8 + 16 * v91 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v92;
        a8 = v93;
        a5 = v92;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v94.i64[0] = -1;
  v94.i64[1] = -1;
  float32x4_t v95 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v96 = (a8 - (unint64_t)a3) >> 4;
    if (v96 >= a12) {
      unint64_t v96 = a12;
    }
    unint64_t v97 = v96;
    if (v96 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v98 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v117 = (int8x16_t *)&a10[v97];
        uint64_t v118 = (int8x16_t *)a10;
        do
          int64_t v119 = v118++;
        while (v118 <= v117 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v119)) & 0x80) != 0);
        do
        {
          unint64_t v120 = v119;
          int64_t v119 = (int8x16_t *)((char *)v119 + 4);
        }
        while (v119 <= v117 && !v120->i32[0]);
        if (v120 < v117)
        {
          while (!v120->i8[0])
          {
            unint64_t v120 = (int8x16_t *)((char *)v120 + 1);
            if (v120 >= v117)
            {
              unint64_t v120 = (int8x16_t *)&a10[v97];
              break;
            }
          }
        }
        int64_t v121 = (char *)v120 - a10;
        int64_t v122 = ((char *)v120 - a10) * a14;
        a3 += v122;
        result += v122;
        a10 += v122;
        v97 -= v121;
        goto LABEL_90;
      }
      if (v98 != 0xFFFF) {
        break;
      }
      int8x16_t v99 = (int8x16_t *)&a10[v97];
      float32x4_t v100 = (int8x16_t *)a10;
      do
        float32x4_t v101 = v100++;
      while (v100 <= v99 && (vminvq_u8((uint8x16_t)vceqq_s8(*v101, v94)) & 0x80) != 0);
      do
      {
        float32x4_t v102 = v101;
        float32x4_t v101 = (int8x16_t *)((char *)v101 + 4);
      }
      while (v101 <= v99 && v102->i32[0] == -1);
      if (v102 < v99)
      {
        while (v102->u8[0] == 255)
        {
          float32x4_t v102 = (int8x16_t *)((char *)v102 + 1);
          if (v102 >= v99)
          {
            float32x4_t v102 = (int8x16_t *)&a10[v97];
            break;
          }
        }
      }
      uint64_t v103 = 0;
      int64_t v104 = (char *)v102 - a10;
      unint64_t v105 = (char *)v102 - a10;
      do
      {
        uint64_t v106 = (int8x16_t *)((char *)result + v103);
        float32x4_t v107 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v103)), v26), v27);
        float32x4_t v108 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 3);
        float32x4_t v109 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v103)), v26), v27);
        float32x4_t v110 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v103)), v22), v25);
        float32x4_t v111 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v109, 3);
        float32x4_t v112 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 3);
        float32x4_t v113 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v103)), v22), v25);
        float32x4_t v114 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3);
        int8x16_t v115 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v109, v110, 3), vmulq_laneq_f32(v110, v109, 3)), vaddq_f32(vmlsq_laneq_f32(v109, v109, v110, 3), vmlsq_laneq_f32(v110, v110, v109, 3)));
        int8x16_t v116 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v107, v113, 3), vmulq_laneq_f32(v113, v107, 3)), vaddq_f32(vmlsq_laneq_f32(v107, v107, v113, 3), vmlsq_laneq_f32(v113, v113, v107, 3)));
        v116.i32[3] = vaddq_f32(v113, vmlsq_laneq_f32(v108, v114, v107, 3)).i32[3];
        v115.i32[3] = vaddq_f32(v110, vmlsq_laneq_f32(v111, v112, v109, 3)).i32[3];
        *uint64_t v106 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v114), vbslq_s8((int8x16_t)vcgtzq_f32(v108), v116, (int8x16_t)v113), (int8x16_t)v107));
        v106[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v112), vbslq_s8((int8x16_t)vcgtzq_f32(v111), v115, (int8x16_t)v110), (int8x16_t)v109));
        a10 += v28;
        v105 -= 2;
        v103 += v30;
      }
      while (v105 > 1);
      a3 = (int8x16_t *)((char *)a3 + v103);
      float result = (int8x16_t *)((char *)result + v103);
      unint64_t v97 = v97 - v104 + v105;
LABEL_90:
      if (v97 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v123 = 0;
    while (1)
    {
      float32x4_t v124 = (int8x16_t *)((char *)result + v123);
      float32x4_t v125 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v98)) & 0xFF00FF00FF00FFLL))), v95);
      float32x4_t v126 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v98) & 0xFF00FF00FF00FFLL))), v95);
      float32x4_t v127 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v126)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v123)));
      float32x4_t v128 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v125)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v123)));
      float32x4_t v129 = vmulq_f32(v125, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v123)), v22), v25));
      float32x4_t v130 = vmulq_f32(v126, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v123)), v22), v25));
      float32x4_t v131 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 3);
      float32x4_t v132 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 3);
      float32x4_t v133 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v128, 3);
      float32x4_t v134 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v127, 3);
      int8x16_t v135 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v128, v129, 3), vmulq_laneq_f32(v129, v128, 3)), vaddq_f32(vmlsq_laneq_f32(v128, v128, v129, 3), vmlsq_laneq_f32(v129, v129, v128, 3)));
      int8x16_t v136 = (int8x16_t)vaddq_f32(vabdq_f32(vmulq_laneq_f32(v127, v130, 3), vmulq_laneq_f32(v130, v127, 3)), vaddq_f32(vmlsq_laneq_f32(v127, v127, v130, 3), vmlsq_laneq_f32(v130, v130, v127, 3)));
      v136.i32[3] = vaddq_f32(v130, vmlsq_laneq_f32(v134, v131, v127, 3)).i32[3];
      v135.i32[3] = vaddq_f32(v129, vmlsq_laneq_f32(v133, v132, v128, 3)).i32[3];
      *float32x4_t v124 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v131), vbslq_s8((int8x16_t)vcgtzq_f32(v134), v136, (int8x16_t)v130), (int8x16_t)v127));
      v124[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v132), vbslq_s8((int8x16_t)vcgtzq_f32(v133), v135, (int8x16_t)v129), (int8x16_t)v128));
      a10 += v28;
      v97 -= 2;
      if (v97 < 2) {
        break;
      }
      LOWORD(v98) = *(_WORD *)a10;
      v123 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v123);
        a3 = (int8x16_t *)((char *)a3 + v123);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v123);
    a3 = (int8x16_t *)((char *)a3 + v30 + v123);
LABEL_93:
    for (unint64_t j = a12 - v96 + v97; j; --j)
    {
      if (*a10)
      {
        float32x4_t v138 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v95);
        float32x4_t v139 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v138)), _Q5, vrev32q_s8(*result));
        float32x4_t v140 = vmulq_f32(v138, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v141 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v140, 3);
        float32x4_t v142 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 3);
        int8x16_t v143 = (int8x16_t)vaddq_f32(vaddq_f32(vmlsq_laneq_f32(v140, v140, v139, 3), vmlsq_laneq_f32(v139, v139, v140, 3)), vabdq_f32(vmulq_laneq_f32(v139, v140, 3), vmulq_laneq_f32(v140, v139, 3)));
        v143.i32[3] = vaddq_f32(v140, vmlsq_laneq_f32(v142, v141, v139, 3)).i32[3];
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32(v141), vbslq_s8((int8x16_t)vcgtzq_f32(v142), v143, (int8x16_t)v140), (int8x16_t)v139));
      }
      float32x4_t v144 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v144 >= a8) {
        uint64_t v145 = -(uint64_t)a7;
      }
      else {
        uint64_t v145 = 0;
      }
      a3 = &v144[v145];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v146 = &a5[a4];
    if ((unint64_t)v146 >= a9) {
      uint64_t v147 = v29;
    }
    else {
      uint64_t v147 = 0;
    }
    float32x4_t v148 = &v146[v147];
    uint64_t v149 = a8 + 16 * v147 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v148;
      a8 = v149;
      a5 = v148;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

int8x16_t *composite_pixelmask<(CGCompositeOperation)23,_rgbaf_t>(int8x16_t *result, uint64_t a2, int8x16_t *a3, uint64_t a4, int8x16_t *a5, int a6, int a7, unint64_t a8, unint64_t a9, char *a10, uint64_t a11, int a12, int a13, int a14, int a15, int a16, char a17)
{
  if (a16) {
    unsigned int v19 = 0;
  }
  else {
    unsigned int v19 = -1;
  }
  v20.i64[0] = 0;
  v20.i32[2] = 0;
  v20.i32[3] = v19;
  v21.i64[0] = 0;
  v21.i32[2] = 0;
  int8x16_t v22 = vmvnq_s8(v20);
  int8x16_t v23 = (int8x16_t)vdupq_n_s32(v19);
  if (a15) {
    unsigned int v24 = 0;
  }
  else {
    unsigned int v24 = -1;
  }
  v21.i32[3] = v24;
  int8x16_t v25 = vandq_s8(v23, (int8x16_t)xmmword_1850CDBF0);
  int8x16_t v26 = vmvnq_s8(v21);
  int8x16_t v27 = vandq_s8((int8x16_t)vdupq_n_s32(v24), (int8x16_t)xmmword_1850CDBF0);
  uint64_t v28 = 2 * a14;
  uint64_t v29 = -(a6 * a4);
  uint64_t v30 = 32 * a14;
  uint64_t v31 = 16 * a14;
  __asm { FMOV            V5.4S, #1.0 }
  if ((a17 & 0x30) != 0)
  {
    v37.i64[0] = -1;
    v37.i64[1] = -1;
    float32x4_t v38 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    while (1)
    {
      unint64_t v39 = (a8 - (unint64_t)a3) >> 4;
      if (v39 >= a12) {
        unint64_t v39 = a12;
      }
      unint64_t v40 = v39;
      if (v39 < 2) {
        goto LABEL_43;
      }
      while (1)
      {
        int v41 = *(unsigned __int16 *)a10;
        if (!*(_WORD *)a10)
        {
          float32x4_t v56 = (int8x16_t *)&a10[v40];
          float32x4_t v57 = (int8x16_t *)a10;
          do
            int8x16_t v58 = v57++;
          while (v57 <= v56 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v58)) & 0x80) != 0);
          do
          {
            int8x16_t v59 = v58;
            int8x16_t v58 = (int8x16_t *)((char *)v58 + 4);
          }
          while (v58 <= v56 && !v59->i32[0]);
          if (v59 < v56)
          {
            while (!v59->i8[0])
            {
              int8x16_t v59 = (int8x16_t *)((char *)v59 + 1);
              if (v59 >= v56)
              {
                int8x16_t v59 = (int8x16_t *)&a10[v40];
                break;
              }
            }
          }
          int64_t v60 = (char *)v59 - a10;
          int64_t v61 = ((char *)v59 - a10) * a14;
          a3 += v61;
          result += v61;
          a10 += v61;
          v40 -= v60;
          goto LABEL_40;
        }
        if (v41 != 0xFFFF) {
          break;
        }
        unint64_t v42 = (int8x16_t *)&a10[v40];
        int v43 = (int8x16_t *)a10;
        do
          int64_t v44 = v43++;
        while (v43 <= v42 && (vminvq_u8((uint8x16_t)vceqq_s8(*v44, v37)) & 0x80) != 0);
        do
        {
          int64_t v45 = v44;
          int64_t v44 = (int8x16_t *)((char *)v44 + 4);
        }
        while (v44 <= v42 && v45->i32[0] == -1);
        if (v45 < v42)
        {
          while (v45->u8[0] == 255)
          {
            int64_t v45 = (int8x16_t *)((char *)v45 + 1);
            if (v45 >= v42)
            {
              int64_t v45 = (int8x16_t *)&a10[v40];
              break;
            }
          }
        }
        uint64_t v46 = 0;
        int64_t v47 = (char *)v45 - a10;
        unint64_t v48 = (char *)v45 - a10;
        do
        {
          int64_t v49 = (int8x16_t *)((char *)result + v46);
          float32x4_t v50 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v46), v22), v25);
          float32x4_t v51 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v46), v22), v25);
          float32x4_t v52 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)result + v46), v26), v27);
          float32x4_t v53 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&result[1] + v46), v26), v27);
          float32x4_t v54 = vmlsq_f32(v51, v52, v51);
          float32x4_t v55 = vmlsq_f32(v50, v53, v50);
          v54.i32[3] = v51.i32[3];
          v55.i32[3] = v50.i32[3];
          *int64_t v49 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v52, v51, v52), v54), (int8x16_t)v51), (int8x16_t)v52);
          v49[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v53, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v53, v50, v53), v55), (int8x16_t)v50), (int8x16_t)v53);
          a10 += v28;
          v48 -= 2;
          v46 += v30;
        }
        while (v48 > 1);
        a3 = (int8x16_t *)((char *)a3 + v46);
        float result = (int8x16_t *)((char *)result + v46);
        unint64_t v40 = v40 - v47 + v48;
LABEL_40:
        if (v40 <= 1) {
          goto LABEL_43;
        }
      }
      uint64_t v62 = 0;
      while (1)
      {
        float32x4_t v63 = (int8x16_t *)((char *)result + v62);
        float32x4_t v64 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v41) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v65 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v41)) & 0xFF00FF00FF00FFLL))), v38);
        float32x4_t v66 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v64)), _Q5, *(int8x16_t *)((char *)result + v62));
        float32x4_t v67 = vmulq_f32(v64, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)a3 + v62), v22), v25));
        float32x4_t v68 = vmulq_f32(v65, (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)((char *)&a3[1] + v62), v22), v25));
        float32x4_t v69 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v65)), _Q5, *(int8x16_t *)((char *)&result[1] + v62));
        float32x4_t v70 = vmlsq_f32(v67, v66, v67);
        float32x4_t v71 = vmlsq_f32(v68, v69, v68);
        v70.i32[3] = v67.i32[3];
        v71.i32[3] = v68.i32[3];
        *float32x4_t v63 = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v67, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3)), (int8x16_t)vaddq_f32(v70, vmlsq_f32(v66, v67, v66)), (int8x16_t)v67), (int8x16_t)v66);
        v63[1] = vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3)), (int8x16_t)vaddq_f32(v71, vmlsq_f32(v69, v68, v69)), (int8x16_t)v68), (int8x16_t)v69);
        a10 += v28;
        v40 -= 2;
        if (v40 < 2) {
          break;
        }
        LOWORD(v41) = *(_WORD *)a10;
        v62 += v30;
        if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
        {
          float result = (int8x16_t *)((char *)result + v62);
          a3 = (int8x16_t *)((char *)a3 + v62);
          goto LABEL_40;
        }
      }
      float result = (int8x16_t *)((char *)result + v30 + v62);
      a3 = (int8x16_t *)((char *)a3 + v30 + v62);
LABEL_43:
      for (unint64_t i = a12 - v39 + v40; i; --i)
      {
        if (*a10)
        {
          float32x4_t v73 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v38);
          float32x4_t v74 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v73)), _Q5, *result);
          float32x4_t v75 = vmulq_f32(v73, (float32x4_t)vorrq_s8(vandq_s8(*a3, v22), v25));
          float32x4_t v76 = vmlsq_f32(v75, v74, v75);
          v76.i32[3] = v75.i32[3];
          *float result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v75)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v74)), 3)), (int8x16_t)vaddq_f32(v76, vmlsq_f32(v74, v75, v74)), (int8x16_t)v75), (int8x16_t)v74);
        }
        float32x4_t v77 = &a3[a14];
        a10 += a14;
        if ((unint64_t)v77 >= a8) {
          uint64_t v78 = -(uint64_t)a7;
        }
        else {
          uint64_t v78 = 0;
        }
        a3 = &v77[v78];
        float result = (int8x16_t *)((char *)result + v31);
      }
      a10 += a11;
      result += a2;
      int8x16_t v79 = &a5[a4];
      if ((unint64_t)v79 >= a9) {
        uint64_t v80 = v29;
      }
      else {
        uint64_t v80 = 0;
      }
      float32x4_t v81 = &v79[v80];
      uint64_t v82 = a8 + 16 * v80 + 16 * a4;
      a3 += a4;
      if (a9)
      {
        a3 = v81;
        a8 = v82;
        a5 = v81;
      }
      _VF = __OFSUB__(a13--, 1);
      if ((a13 < 0) ^ _VF | (a13 == 0)) {
        return result;
      }
    }
  }
  v83.i64[0] = -1;
  v83.i64[1] = -1;
  float32x4_t v84 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  while (2)
  {
    unint64_t v85 = (a8 - (unint64_t)a3) >> 4;
    if (v85 >= a12) {
      unint64_t v85 = a12;
    }
    unint64_t v86 = v85;
    if (v85 < 2) {
      goto LABEL_93;
    }
    while (1)
    {
      int v87 = *(unsigned __int16 *)a10;
      if (!*(_WORD *)a10)
      {
        float32x4_t v102 = (int8x16_t *)&a10[v86];
        uint64_t v103 = (int8x16_t *)a10;
        do
          int64_t v104 = v103++;
        while (v103 <= v102 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v104)) & 0x80) != 0);
        do
        {
          unint64_t v105 = v104;
          int64_t v104 = (int8x16_t *)((char *)v104 + 4);
        }
        while (v104 <= v102 && !v105->i32[0]);
        if (v105 < v102)
        {
          while (!v105->i8[0])
          {
            unint64_t v105 = (int8x16_t *)((char *)v105 + 1);
            if (v105 >= v102)
            {
              unint64_t v105 = (int8x16_t *)&a10[v86];
              break;
            }
          }
        }
        int64_t v106 = (char *)v105 - a10;
        int64_t v107 = ((char *)v105 - a10) * a14;
        a3 += v107;
        result += v107;
        a10 += v107;
        v86 -= v106;
        goto LABEL_90;
      }
      if (v87 != 0xFFFF) {
        break;
      }
      float32x4_t v88 = (int8x16_t *)&a10[v86];
      uint64_t v89 = (int8x16_t *)a10;
      do
        float32x4_t v90 = v89++;
      while (v89 <= v88 && (vminvq_u8((uint8x16_t)vceqq_s8(*v90, v83)) & 0x80) != 0);
      do
      {
        uint64_t v91 = v90;
        float32x4_t v90 = (int8x16_t *)((char *)v90 + 4);
      }
      while (v90 <= v88 && v91->i32[0] == -1);
      if (v91 < v88)
      {
        while (v91->u8[0] == 255)
        {
          uint64_t v91 = (int8x16_t *)((char *)v91 + 1);
          if (v91 >= v88)
          {
            uint64_t v91 = (int8x16_t *)&a10[v86];
            break;
          }
        }
      }
      uint64_t v92 = 0;
      int64_t v93 = (char *)v91 - a10;
      unint64_t v94 = (char *)v91 - a10;
      do
      {
        float32x4_t v95 = (int8x16_t *)((char *)result + v92);
        float32x4_t v96 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v92)), v22), v25);
        float32x4_t v97 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v92)), v22), v25);
        float32x4_t v98 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v92)), v26), v27);
        float32x4_t v99 = (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)result + v92)), v26), v27);
        float32x4_t v100 = vmlsq_f32(v96, v99, v96);
        float32x4_t v101 = vmlsq_f32(v97, v98, v97);
        v101.i32[3] = v97.i32[3];
        v100.i32[3] = v96.i32[3];
        *float32x4_t v95 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v96, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v99, v96, v99), v100), (int8x16_t)v96), (int8x16_t)v99));
        v95[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v97, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 3)), (int8x16_t)vaddq_f32(vmlsq_f32(v98, v97, v98), v101), (int8x16_t)v97), (int8x16_t)v98));
        a10 += v28;
        v94 -= 2;
        v92 += v30;
      }
      while (v94 > 1);
      a3 = (int8x16_t *)((char *)a3 + v92);
      float result = (int8x16_t *)((char *)result + v92);
      unint64_t v86 = v86 - v93 + v94;
LABEL_90:
      if (v86 <= 1) {
        goto LABEL_93;
      }
    }
    uint64_t v108 = 0;
    while (1)
    {
      float32x4_t v109 = (int8x16_t *)((char *)result + v108);
      float32x4_t v110 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(BYTE1(v87)) & 0xFF00FF00FF00FFLL))), v84);
      float32x4_t v111 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)(*(void *)&vdup_n_s16(v87) & 0xFF00FF00FF00FFLL))), v84);
      float32x4_t v112 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v111)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)result + v108)));
      float32x4_t v113 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v110)), _Q5, vrev32q_s8(*(int8x16_t *)((char *)&result[1] + v108)));
      float32x4_t v114 = vmulq_f32(v110, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)&a3[1] + v108)), v22), v25));
      float32x4_t v115 = vmulq_f32(v111, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*(int8x16_t *)((char *)a3 + v108)), v22), v25));
      float32x4_t v116 = vmlsq_f32(v115, v112, v115);
      float32x4_t v117 = vmlsq_f32(v114, v113, v114);
      v117.i32[3] = v114.i32[3];
      v116.i32[3] = v115.i32[3];
      *float32x4_t v109 = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v115, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v112, 3)), (int8x16_t)vaddq_f32(v116, vmlsq_f32(v112, v115, v112)), (int8x16_t)v115), (int8x16_t)v112));
      v109[1] = vrev32q_s8(vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v114, 3)), vbslq_s8((int8x16_t)vcgtzq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 3)), (int8x16_t)vaddq_f32(v117, vmlsq_f32(v113, v114, v113)), (int8x16_t)v114), (int8x16_t)v113));
      a10 += v28;
      v86 -= 2;
      if (v86 < 2) {
        break;
      }
      LOWORD(v87) = *(_WORD *)a10;
      v108 += v30;
      if ((unsigned __int16)(*(_WORD *)a10 - 1) >= 0xFFFEu)
      {
        float result = (int8x16_t *)((char *)result + v108);
        a3 = (int8x16_t *)((char *)a3 + v108);
        goto LABEL_90;
      }
    }
    float result = (int8x16_t *)((char *)result + v30 + v108);
    a3 = (int8x16_t *)((char *)a3 + v30 + v108);
LABEL_93:
    for (unint64_t j = a12 - v85 + v86; j; --j)
    {
      if (*a10)
      {
        float32x4_t v119 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)vdup_n_s16(*a10))), v84);
        float32x4_t v120 = (float32x4_t)vbslq_s8(vandq_s8(v21, (int8x16_t)vcgtzq_f32(v119)), _Q5, vrev32q_s8(*result));
        float32x4_t v121 = vmulq_f32(v119, (float32x4_t)vorrq_s8(vandq_s8(vrev32q_s8(*a3), v22), v25));
        float32x4_t v122 = vmlsq_f32(v121, v120, v121);
        v122.i32[3] = v121.i32[3];
        *float result = vrev32q_s8(vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v121)), 3)), vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtzq_f32(v120)), 3)), (int8x16_t)vaddq_f32(v122, vmlsq_f32(v120, v121, v120)), (int8x16_t)v121), (int8x16_t)v120));
      }
      uint64_t v123 = &a3[a14];
      a10 += a14;
      if ((unint64_t)v123 >= a8) {
        uint64_t v124 = -(uint64_t)a7;
      }
      else {
        uint64_t v124 = 0;
      }
      a3 = &v123[v124];
      float result = (int8x16_t *)((char *)result + v31);
    }
    a10 += a11;
    result += a2;
    float32x4_t v125 = &a5[a4];
    if ((unint64_t)v125 >= a9) {
      uint64_t v126 = v29;
    }
    else {
      uint64_t v126 = 0;
    }
    float32x4_t v127 = &v125[v126];
    uint64_t v128 = a8 + 16 * v126 + 16 * a4;
    a3 += a4;
    if (a9)
    {
      a3 = v127;
      a8 = v128;
      a5 = v127;
    }
    _VF = __OFSUB__(a13--, 1);
    if (!((a13 < 0) ^ _VF | (a13 == 0))) {
      continue;
    }
    return result;
  }
}

uint64_t RGBAf_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  memset(v38, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  signed int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v32, (uint64_t)v38) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *(_DWORD *)v6;
  unsigned int v19 = *(_DWORD *)a3;
  unsigned int v33 = v19;
  int v34 = v18;
  if (v19 != 538981289)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      int8x16_t v23 = RGBF_image_sample;
      unint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGBF_image_sample[2 * v20 + 2];
      if (v32)
      {
LABEL_29:
        unsigned int v33 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v36 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v25) = v22;
          LODWORD(v25) = v22;
          switch((v25 >> 3))
          {
            case 0u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v26 = RGBAf_image_mark_RGB32;
              goto LABEL_52;
            case 1u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v27 = RGBAf_image_mark_RGB32;
              goto LABEL_54;
            case 2u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v26 = (uint64_t (*)(uint64_t, int *, int, int, int, int))RGBAf_image_mark_W8;
              goto LABEL_52;
            case 3u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v26 = (uint64_t (*)(uint64_t, int *, int, int, int, int))RGBAf_image_mark_RGB24;
              goto LABEL_52;
            case 4u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v26 = RGBAf_image_mark_rgb32;
LABEL_52:
              uint64_t v28 = v26;
              uint64_t v29 = (uint64_t)a2;
              int v30 = v8;
              int v31 = 0;
              break;
            case 5u:
              unsigned int v33 = *(_DWORD *)a3;
              int8x16_t v27 = RGBAf_image_mark_rgb32;
LABEL_54:
              uint64_t v28 = v27;
              uint64_t v29 = (uint64_t)a2;
              int v30 = v8;
              int v31 = 8;
              break;
            default:
              goto LABEL_37;
          }
          RGBAf_image_mark_image(v29, (uint64_t)&v32, v30, v31, (void (*)(uint64_t, _DWORD *))v28);
          return 1;
        }
        goto LABEL_37;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int8x16_t v23 = RGB8_image_sample;
        unint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB8_image_sample[2 * v20 + 2];
        if (v32)
        {
          int v24 = 4;
LABEL_28:
          int v35 = v24;
          goto LABEL_29;
        }
      }
      int8x16_t v23 = RGB16_image_sample;
      unint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB16_image_sample[2 * v20 + 2];
      if (v32)
      {
        int v24 = 8;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v37 && (~v36 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v36 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      RGBAf_mark_inner(*a1, v17);
      return 1;
    }
  }
  unint64_t v32 = RGBAf_sample_RGBAf_inner;
LABEL_37:
  RGBAf_image_mark((uint64_t)a2, (uint64_t)&v32, v8, v17);
  return 1;
}

void RGBAf_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  v49[0] = a3;
  v49[1] = a4;
  v49[2] = *(_DWORD *)(a2 + 184);
  unint64_t v8 = (unint64_t)*(int *)(a1 + 28) >> 4;
  unint64_t v51 = v8;
  uint64_t v9 = *(void *)(a2 + 120);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  if (v9)
  {
    unsigned int v11 = HIBYTE(v10);
    unint64_t v12 = *(int *)(a2 + 24);
    uint64_t v13 = (uint64_t *)(a2 + 104);
    uint64_t v14 = (uint64_t *)(a2 + 72);
    uint64_t v15 = (uint64_t *)(a2 + 88);
  }
  else
  {
    unsigned int v11 = BYTE2(v10);
    unint64_t v12 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v13 = (uint64_t *)(a2 + 96);
    uint64_t v14 = (uint64_t *)(a2 + 64);
    uint64_t v15 = (uint64_t *)(a2 + 80);
    uint64_t v9 = *(void *)(a2 + 112);
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *v14;
  uint64_t v18 = *v13;
  char v19 = v11;
  uint64_t v54 = v11;
  uint64_t v52 = v18;
  unint64_t v62 = v12;
  uint64_t v60 = v16;
  uint64_t v58 = v17;
  uint64_t v56 = v9;
  uint64_t v20 = *(void *)(a2 + 128);
  uint64_t v48 = v16;
  if (v20)
  {
    unsigned int v21 = BYTE2(v10);
    unint64_t v22 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int8x16_t v23 = (uint64_t *)(a2 + 96);
    int v24 = (uint64_t *)(a2 + 64);
    unint64_t v25 = (uint64_t *)(a2 + 80);
  }
  else
  {
    unsigned int v21 = HIBYTE(v10);
    unint64_t v22 = *(int *)(a2 + 24);
    int8x16_t v23 = (uint64_t *)(a2 + 104);
    int v24 = (uint64_t *)(a2 + 72);
    unint64_t v25 = (uint64_t *)(a2 + 88);
    uint64_t v20 = *(void *)(a2 + 136);
  }
  uint64_t v26 = *v25;
  uint64_t v27 = *v24;
  uint64_t v28 = *v23;
  uint64_t v55 = v21;
  uint64_t v53 = v28;
  unint64_t v63 = v22;
  uint64_t v61 = v26;
  uint64_t v59 = v27;
  uint64_t v57 = v20;
  uint64_t v29 = *(unsigned int *)(a1 + 4);
  if ((v29 & 0x80000000) == 0)
  {
    int v30 = malloc_type_malloc(16 * v29, 0xF23125EEuLL);
    float32x4_t v64 = v30;
    if (v30)
    {
      if (*(void *)(a2 + 176))
      {
        if (v29)
        {
          unint64_t v32 = v30 + 1;
          uint64_t v33 = v48 - v18;
          do
          {
            if (((v18 - v17) | v33) < 0)
            {
              unint64_t v36 = 0;
              uint64_t v37 = 0;
            }
            else
            {
              unint64_t v34 = ((v18 & (unint64_t)~(-1 << v19)) >> (v19 - 4)) & 0xF;
              char v35 = weights_21383[v34];
              if (v34 - 7 >= 9) {
                unint64_t v36 = -(uint64_t)v12;
              }
              else {
                unint64_t v36 = v12;
              }
              uint64_t v37 = v35 & 0xF;
            }
            *(v32 - 1) = v12 * (v18 >> v19);
            *unint64_t v32 = v37 | (16 * v36);
            v32 += 2;
            v18 += v9;
            v33 -= v9;
            --v29;
          }
          while (v29);
        }
      }
      else if (v29)
      {
        float32x4_t v38 = v30 + 1;
        do
        {
          *(v38 - 1) = v12 * (v18 >> v19);
          *float32x4_t v38 = 0;
          v38 += 2;
          v18 += v9;
          --v29;
        }
        while (v29);
      }
      uint64_t v39 = v30;
      int v40 = *(_DWORD *)(a1 + 4);
      int v41 = *(_DWORD *)(a1 + 8);
      int v65 = v41;
      int v66 = v40;
      unint64_t v42 = *(int **)(a1 + 136);
      if (v42)
      {
        int v43 = *(_DWORD *)(a1 + 104);
        v67[0] = *(_DWORD *)(a1 + 108);
        v67[1] = v43;
        shape_enum_clip_alloc((uint64_t)v30, v31, v42, 1, 1, 1, v43, v67[0], v40, v41);
        int64_t v45 = v44;
        if (v44) {
          goto LABEL_27;
        }
      }
      int v46 = 0;
      int v47 = 0;
      int64_t v45 = 0;
      *(void *)float32x4_t v67 = 0;
      while (1)
      {
        uint64_t v50 = *(void *)(a1 + 40) + 16 * v8 * (*(int *)(a1 + 16) + (uint64_t)v47) + 16 * (v46 + *(_DWORD *)(a1 + 12));
        a5(a2, v49);
        if (!v45) {
          break;
        }
LABEL_27:
        if (!shape_enum_clip_next((uint64_t)v45, &v67[1], v67, &v66, &v65))
        {
          free(v45);
          break;
        }
        int v47 = v67[0];
        int v46 = v67[1];
        unint64_t v8 = v51;
      }
      free(v39);
    }
  }
}

void RGBAf_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unsigned int v332 = a3;
  uint64_t v343 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  unint64_t v8 = *(int *)(a1 + 28);
  uint64_t v9 = *(char **)(a1 + 40);
  uint64_t v342 = *(void *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  __n128 v338 = a4;
  float v339 = *(int **)(a1 + 136);
  float v340 = v9;
  uint64_t v10 = *(void *)(a2 + 96);
  uint64_t v334 = *(void *)(a2 + 104);
  uint64_t v335 = v10;
  uint64_t v12 = *(int *)(a1 + 12);
  uint64_t v11 = *(int *)(a1 + 16);
  int v341 = *(_DWORD *)(a1 + 8);
  uint64_t v13 = *(int *)(a2 + 16);
  uint64_t v14 = (v13 + 18) * v5;
  if (v14 > 65439)
  {
    uint64_t v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0xC67F6127uLL);
    uint64_t v16 = v17;
    char v19 = v17;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    uint64_t v16 = (char *)&v326 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    char v19 = 0;
  }
  int8x16_t v329 = v19;
  unint64_t v20 = v8 >> 4;
  unint64_t v21 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v22 = v21 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v13) {
    uint64_t v23 = 16 * v5;
  }
  else {
    uint64_t v23 = 0;
  }
  unint64_t v24 = v22 + v23;
  *(void *)(a2 + 144) = v21;
  *(void *)(a2 + 152) = v22 + v23;
  *(void *)(a2 + 160) = v22;
  unint64_t v25 = (float32x4_t *)&v340[16 * v12 + 16 * v20 * v11];
  unint64_t v327 = v8 >> 4;
  uint64_t v328 = (int)v4;
  unint64_t v337 = v20 - (int)v4;
  uint64_t v26 = *(int *)(a1 + 104);
  int v27 = *(_DWORD *)(a1 + 108);
  int v28 = *(unsigned __int8 *)(a1 + 2);
  if (v28 == 6 || v28 == 1)
  {
    uint64_t v30 = v334;
    uint64_t v29 = v335;
    if (v339)
    {
      uint64_t v31 = 0;
      LODWORD(v32) = 0;
      uint64_t v33 = *(int *)(a1 + 124);
      unint64_t v34 = (unsigned __int8 *)v339 + v26 + (int)v33 * (uint64_t)v27;
      uint64_t v35 = v328;
      uint64_t v333 = v33 - v328;
LABEL_12:
      unsigned int v36 = v332;
      goto LABEL_13;
    }
LABEL_425:
    uint64_t v315 = v329;
    if (v329) {
      goto LABEL_418;
    }
    return;
  }
  if (v339)
  {
    shape_enum_clip_alloc((uint64_t)v17, v18, v339, 1, 1, 1, v26, v27, v4, v341);
    if (v316)
    {
      unint64_t v285 = v316;
      uint64_t v32 = 0;
      uint64_t v317 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
      if (!v13) {
        uint64_t v317 = 16 * v5;
      }
      uint64_t v35 = v328;
      uint64_t v333 = -v328;
      unint64_t v34 = (unsigned __int8 *)(v24 + v317 + 16);
      uint64_t v30 = v334;
      uint64_t v29 = v335;
      goto LABEL_427;
    }
    goto LABEL_425;
  }
  uint64_t v333 = 0;
  uint64_t v31 = 0;
  unint64_t v34 = 0;
  LODWORD(v32) = 0;
  unsigned int v36 = v332;
  uint64_t v35 = v328;
  uint64_t v30 = v334;
  uint64_t v29 = v335;
LABEL_13:
  uint64_t v330 = -v35;
  uint64_t v331 = (v4 - 1) + 1;
  uint64_t v336 = v36;
  uint64_t v37 = v31;
  while (2)
  {
    LODWORD(v339) = v32;
    float v340 = v37;
    uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2, v29, v30, v4);
    uint64_t v52 = *(float32x4_t **)(a2 + 160);
    uint64_t v53 = *(unsigned __int8 **)(a2 + 144);
    unsigned int v54 = *(_DWORD *)(a2 + 8);
    if (v54 == *(_DWORD *)(a2 + 12))
    {
      float v55 = v338.n128_f32[0];
      if (v338.n128_f32[0] < 1.0)
      {
        int v56 = v4;
        uint64_t v57 = *(unsigned char **)(a2 + 144);
        do
        {
          if (*v57) {
            *uint64_t v52 = vmulq_n_f32(*v52, v55);
          }
          ++v57;
          ++v52;
          --v56;
        }
        while (v56);
        v52 += v330;
        v53 += v331 + v330;
      }
    }
    else
    {
      uint64_t v58 = *(void *)(a2 + 152);
      int v59 = HIWORD(v54) & 0x3F;
      double v46 = v338.n128_f64[0];
      if (v59 == 16)
      {
        uint64_t v61 = 0;
        unint64_t v62 = &v52->f32[2];
        if (v338.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v61])
            {
              unint64_t v64 = *(void *)(v58 + 8 * v61);
              *(v62 - 2) = *(float *)&_blt_float[v64 + 256] + *(float *)&_blt_float[BYTE1(v64) + 512];
              *(v62 - 1) = *(float *)&_blt_float[BYTE2(v64) + 256] + *(float *)&_blt_float[BYTE3(v64) | 0x200];
              *unint64_t v62 = *(float *)&_blt_float[BYTE4(v64) + 256] + *(float *)&_blt_float[BYTE5(v64) + 512];
              v62[1] = *(float *)&_blt_float[BYTE6(v64) + 256] + *(float *)&_blt_float[HIBYTE(v64) + 512];
            }
            ++v61;
            v62 += 4;
          }
          while (v4 != v61);
        }
        else
        {
          do
          {
            if (v53[v61])
            {
              unint64_t v63 = *(void *)(v58 + 8 * v61);
              *(v62 - 2) = *(float *)&v46
                         * (float)(*(float *)&_blt_float[v63 + 256]
                                 + *(float *)&_blt_float[BYTE1(v63) + 512]);
              *(v62 - 1) = *(float *)&v46
                         * (float)(*(float *)&_blt_float[BYTE2(v63) + 256] + *(float *)&_blt_float[BYTE3(v63) | 0x200]);
              *unint64_t v62 = *(float *)&v46
                   * (float)(*(float *)&_blt_float[BYTE4(v63) + 256] + *(float *)&_blt_float[BYTE5(v63) + 512]);
              v62[1] = *(float *)&v46
                     * (float)(*(float *)&_blt_float[BYTE6(v63) + 256] + *(float *)&_blt_float[HIBYTE(v63) + 512]);
            }
            ++v61;
            v62 += 4;
          }
          while (v4 != v61);
        }
      }
      else if (v59 == 32)
      {
        uint64_t v60 = 0;
        if (v338.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v60]) {
              v52[v60] = *(float32x4_t *)(v58 + 16 * v60);
            }
            ++v60;
          }
          while (v4 != v60);
        }
        else
        {
          do
          {
            if (v53[v60]) {
              v52[v60] = vmulq_n_f32(*(float32x4_t *)(v58 + 16 * v60), *(float *)&v46);
            }
            ++v60;
          }
          while (v4 != v60);
        }
      }
      else
      {
        uint64_t v65 = 0;
        int v66 = &v52->f32[2];
        if (v338.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v65])
            {
              unint64_t v68 = *(unsigned int *)(v58 + 4 * v65);
              *(v66 - 2) = *(float *)((char *)_blt_float + ((v68 >> 22) & 0x3FC));
              *(v66 - 1) = *(float *)&_blt_float[BYTE2(v68)];
              float *v66 = *(float *)&_blt_float[BYTE1(v68)];
              v66[1] = *(float *)&_blt_float[v68];
            }
            ++v65;
            v66 += 4;
          }
          while (v4 != v65);
        }
        else
        {
          do
          {
            if (v53[v65])
            {
              unint64_t v67 = *(unsigned int *)(v58 + 4 * v65);
              *(v66 - 2) = *(float *)&v46 * *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
              *(v66 - 1) = *(float *)&v46 * *(float *)&_blt_float[BYTE2(v67)];
              float *v66 = *(float *)&v46 * *(float *)&_blt_float[BYTE1(v67)];
              v66[1] = *(float *)&v46 * *(float *)&_blt_float[v67];
            }
            ++v65;
            v66 += 4;
          }
          while (v4 != v65);
        }
      }
    }
    float32x4_t v69 = &xmmword_1850CE000;
    switch(v36)
    {
      case 0u:
        int v70 = v4;
        float32x4_t v71 = v34;
        do
        {
          unsigned int v72 = *v53;
          if (*v53)
          {
            if (v34) {
              unsigned int v72 = (*v71 * v72 + ((*v71 * v72) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v72)
            {
              if (v72 == 255)
              {
                v25->i64[0] = 0;
                v25->i64[1] = 0;
              }
              else
              {
                *unint64_t v25 = vmulq_n_f32(*v25, (float)((float)v72 * -0.0039216) + 1.0);
              }
            }
          }
          ++v53;
          v71 += v34 != 0;
          ++v25;
          --v70;
        }
        while (v70);
        unint64_t v34 = &v71[v333];
        goto LABEL_335;
      case 1u:
        unsigned __int8 v73 = *v53;
        float32x4_t v74 = v53 + 1;
        float32x4_t v75 = v25 - 1;
        int v76 = v4;
        if (v34)
        {
          int v77 = v341;
          do
          {
            if (v73)
            {
              unsigned int v78 = ((unsigned __int16)(*v34 * v73 + ((*v34 * v73) >> 8) + 1) >> 8);
              if (v78)
              {
                if (v78 == 255) {
                  float32x4_t v79 = *v52;
                }
                else {
                  float32x4_t v79 = vmlaq_n_f32(vmulq_n_f32(v75[1], 1.0 - (float)((float)v78 * 0.0039216)), *v52, (float)v78 * 0.0039216);
                }
                v75[1] = v79;
              }
            }
            unsigned __int8 v80 = *v74++;
            unsigned __int8 v73 = v80;
            ++v52;
            ++v34;
            ++v75;
            --v76;
          }
          while (v76);
          goto LABEL_83;
        }
        int v77 = v341;
        do
        {
          if (v73)
          {
            if (v73 == 255) {
              float32x4_t v303 = *v52;
            }
            else {
              float32x4_t v303 = vmlaq_n_f32(vmulq_n_f32(v75[1], 1.0 - (float)((float)v73 * 0.0039216)), *v52, (float)v73 * 0.0039216);
            }
            v75[1] = v303;
          }
          unsigned __int8 v304 = *v74++;
          unsigned __int8 v73 = v304;
          ++v52;
          ++v75;
          --v76;
        }
        while (v76);
        goto LABEL_412;
      case 2u:
        unsigned __int8 v81 = *v53;
        if (v34)
        {
          uint64_t v82 = 0;
          int8x16_t v83 = v53 + 1;
          int v84 = v4;
          int v77 = v341;
          do
          {
            if (v81)
            {
              unsigned int v85 = ((unsigned __int16)(*v34 * v81 + ((*v34 * v81) >> 8) + 1) >> 8);
              if ((unsigned __int16)(*v34 * v81 + ((*v34 * v81) >> 8) + 1) >> 8)
              {
                if (v85 == 255)
                {
                  unint64_t v86 = &v52[v82];
                  float v87 = v52[v82].f32[3];
                  if (v87 >= 1.0)
                  {
                    float32x4_t v95 = &v25[v82];
                    v95->i64[0] = v86->i64[0];
                    v95->i32[2] = v86->i32[2];
                    v95->f32[3] = v87;
                  }
                  else if (v87 > 0.0)
                  {
                    v25[v82] = vmlaq_n_f32(v52[v82], v25[v82], 1.0 - v87);
                  }
                }
                else
                {
                  float v88 = (float)v85 * 0.0039216;
                  uint64_t v89 = (float32x2_t *)&v52[v82];
                  float v90 = v88 * v52[v82].f32[3];
                  if (v90 > 0.0)
                  {
                    float v91 = v88 * v89[1].f32[0];
                    float32x2_t v92 = vmul_n_f32(*v89, v88);
                    int64_t v93 = (float32x2_t *)&v25[v82];
                    *int64_t v93 = vmla_n_f32(v92, *(float32x2_t *)v25[v82].f32, 1.0 - v90);
                    v92.f32[0] = v91 + (float)(v25[v82].f32[2] * (float)(1.0 - v90));
                    float32_t v94 = v90 + (float)(v25[v82].f32[3] * (float)(1.0 - v90));
                    v93[1].i32[0] = v92.i32[0];
                    v93[1].f32[1] = v94;
                  }
                }
              }
            }
            unsigned __int8 v96 = *v83++;
            unsigned __int8 v81 = v96;
            ++v34;
            ++v82;
            --v84;
          }
          while (v84);
          float32x4_t v75 = &v25[v82 - 1];
LABEL_83:
          v34 += v333;
LABEL_413:
          unint64_t v25 = &v75[v337 + 1];
          goto LABEL_364;
        }
        float v305 = &v52->f32[2];
        float32x4_t v75 = v25 - 1;
        float v306 = v53 + 1;
        int v307 = v4;
        int v77 = v341;
        while (1)
        {
          if (v81)
          {
            if (v81 == 255)
            {
              float v308 = v305[1];
              if (v308 < 1.0)
              {
                if (v308 > 0.0) {
                  v75[1] = vmlaq_n_f32(*(float32x4_t *)(v305 - 2), v75[1], 1.0 - v308);
                }
                goto LABEL_411;
              }
              v75[1].i64[0] = *((void *)v305 - 1);
              float v312 = *v305;
              goto LABEL_410;
            }
            float v309 = (float)v81 * 0.0039216;
            float v310 = v309 * v305[1];
            if (v310 > 0.0)
            {
              float v311 = v309 * *v305;
              *(float32x2_t *)v75[1].f32 = vmla_n_f32(vmul_n_f32(*(float32x2_t *)(v305 - 2), v309), *(float32x2_t *)v75[1].f32, 1.0 - v310);
              float v312 = v311 + (float)(v75[1].f32[2] * (float)(1.0 - v310));
              float v308 = v310 + (float)(v75[1].f32[3] * (float)(1.0 - v310));
LABEL_410:
              v75[1].f32[2] = v312;
              v75[1].f32[3] = v308;
            }
          }
LABEL_411:
          unsigned __int8 v313 = *v306++;
          unsigned __int8 v81 = v313;
          v305 += 4;
          ++v75;
          if (!--v307)
          {
LABEL_412:
            unint64_t v34 = 0;
            goto LABEL_413;
          }
        }
      case 3u:
        int v97 = v4;
        float32x4_t v98 = v34;
        do
        {
          unsigned int v99 = *v53;
          if (*v53)
          {
            if (v34) {
              unsigned int v99 = (*v98 * v99 + ((*v98 * v99) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v99)
            {
              if (v99 == 255) {
                float32x4_t v100 = vmulq_n_f32(*v52, v25->f32[3]);
              }
              else {
                float32x4_t v100 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v99 * 0.0039216)), *v52, vmuls_lane_f32((float)v99 * 0.0039216, *v25, 3));
              }
              *unint64_t v25 = v100;
            }
          }
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          --v97;
        }
        while (v97);
        goto LABEL_334;
      case 4u:
        int v101 = v4;
        float32x4_t v98 = v34;
        do
        {
          unsigned int v102 = *v53;
          if (*v53)
          {
            if (v34) {
              unsigned int v102 = (*v98 * v102 + ((*v98 * v102) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v102)
            {
              if (v102 == 255) {
                float32x4_t v103 = vmulq_n_f32(*v52, 1.0 - v25->f32[3]);
              }
              else {
                float32x4_t v103 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v102 * 0.0039216)), *v52, (float)((float)v102 * 0.0039216)* (float)(1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v25))));
              }
              *unint64_t v25 = v103;
            }
          }
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          --v101;
        }
        while (v101);
        goto LABEL_334;
      case 5u:
        int v104 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v105 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_111;
            }
            unsigned int v106 = *v98 * v105 + ((*v98 * v105) >> 8) + 1;
            if (BYTE1(v106)) {
              break;
            }
          }
LABEL_112:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v104) {
            goto LABEL_334;
          }
        }
        unsigned int v105 = v106 >> 8;
LABEL_111:
        float32x4_t v107 = vmulq_n_f32(*v52, (float)v105 * 0.0039216);
        *unint64_t v25 = vmlaq_laneq_f32(vmulq_n_f32(*v25, 1.0 - v107.f32[3]), v107, *v25, 3);
        goto LABEL_112;
      case 6u:
        uint64_t v108 = &v52->f32[2];
        int v109 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v110 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v111 = *v98 * v110 + ((*v98 * v110) >> 8) + 1;
              if (!BYTE1(v111)) {
                goto LABEL_124;
              }
              unsigned int v110 = v111 >> 8;
            }
            float v112 = v25->f32[3];
            float v113 = 1.0 - v112;
            if ((float)(1.0 - v112) >= 1.0)
            {
              float v117 = (float)v110 * 0.0039216;
              *(float32x2_t *)v25->f32 = vmul_n_f32(*(float32x2_t *)(v108 - 2), v117);
              float v118 = v108[1];
              v25->f32[2] = v117 * *v108;
              float v116 = v117 * v118;
              goto LABEL_123;
            }
            if (v113 > 0.0)
            {
              float v114 = v113 * (float)((float)v110 * 0.0039216);
              *(float32x2_t *)v25->f32 = vmla_n_f32(*(float32x2_t *)v25->f32, *(float32x2_t *)(v108 - 2), v114);
              float v115 = v108[1];
              v25->f32[2] = v25->f32[2] + (float)(*v108 * v114);
              float v116 = v112 + (float)(v115 * v114);
LABEL_123:
              v25->f32[3] = v116;
            }
          }
LABEL_124:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v108 += 4;
          if (!--v109) {
            goto LABEL_334;
          }
        }
      case 7u:
        float32x4_t v119 = &v52->f32[3];
        int v120 = v4;
        float32x4_t v98 = v34;
        do
        {
          unsigned int v121 = *v53;
          if (*v53)
          {
            if (v34) {
              unsigned int v121 = (*v98 * v121 + ((*v98 * v121) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v121)
            {
              if (v121 == 255) {
                float32x4_t v122 = vmulq_n_f32(*v25, *v119);
              }
              else {
                float32x4_t v122 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v121 * 0.0039216)), *v25, (float)((float)v121 * 0.0039216) * *v119);
              }
              *unint64_t v25 = v122;
            }
          }
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v119 += 4;
          --v120;
        }
        while (v120);
        goto LABEL_334;
      case 8u:
        uint64_t v123 = &v52->f32[3];
        int v124 = v4;
        float32x4_t v98 = v34;
        do
        {
          unsigned int v125 = *v53;
          if (*v53)
          {
            if (v34) {
              unsigned int v125 = (*v98 * v125 + ((*v98 * v125) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v125)
            {
              if (v125 == 255) {
                float32x4_t v126 = vmulq_n_f32(*v25, 1.0 - *v123);
              }
              else {
                float32x4_t v126 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - (float)((float)v125 * 0.0039216)), *v25, (float)((float)v125 * 0.0039216) * (float)(1.0 - *v123));
              }
              *unint64_t v25 = v126;
            }
          }
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v123 += 4;
          --v124;
        }
        while (v124);
        goto LABEL_334;
      case 9u:
        int v127 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v128 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_153;
            }
            unsigned int v129 = *v98 * v128 + ((*v98 * v128) >> 8) + 1;
            if (BYTE1(v129)) {
              break;
            }
          }
LABEL_154:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v127) {
            goto LABEL_334;
          }
        }
        unsigned int v128 = v129 >> 8;
LABEL_153:
        float v130 = (float)v128 * 0.0039216;
        float v131 = 1.0 - v130;
        float32x4_t v132 = vmulq_n_f32(*v52, v130);
        *unint64_t v25 = vmlaq_n_f32(vmulq_n_f32(*v25, v131 + v132.f32[3]), v132, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v25)));
        goto LABEL_154;
      case 0xAu:
        int v133 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v134 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_161;
            }
            unsigned int v135 = *v98 * v134 + ((*v98 * v134) >> 8) + 1;
            if (BYTE1(v135)) {
              break;
            }
          }
LABEL_162:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v133) {
            goto LABEL_334;
          }
        }
        unsigned int v134 = v135 >> 8;
LABEL_161:
        float32x4_t v136 = vmulq_n_f32(*v52, (float)v134 * 0.0039216);
        *unint64_t v25 = vmlaq_n_f32(vmulq_n_f32(*v25, 1.0 - v136.f32[3]), v136, 1.0 - COERCE_FLOAT(HIDWORD(*(unsigned long long *)v25)));
        goto LABEL_162;
      case 0xBu:
        float32x4_t v137 = &v52->f32[2];
        int v138 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v139 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_169;
            }
            unsigned int v140 = *v98 * v139 + ((*v98 * v139) >> 8) + 1;
            if (BYTE1(v140)) {
              break;
            }
          }
LABEL_177:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v137 += 4;
          if (!--v138) {
            goto LABEL_334;
          }
        }
        unsigned int v139 = v140 >> 8;
LABEL_169:
        float v141 = (float)v139 * 0.0039216;
        float v142 = *(v137 - 2) * v141;
        float v143 = v141 * v137[1];
        if (v342)
        {
          float v144 = v25->f32[3];
          float v145 = (float)(v143 - v142) + (float)(v144 - v25->f32[0]);
          float v146 = 1.0;
          if ((float)(v143 + v144) <= 1.0) {
            float v146 = v143 + v144;
          }
        }
        else
        {
          float v144 = 1.0;
          float v145 = (float)(v143 - v142) + (float)(1.0 - v25->f32[0]);
          if ((float)(v143 + 1.0) <= 1.0) {
            float v146 = v143 + 1.0;
          }
          else {
            float v146 = 1.0;
          }
        }
        float v147 = (float)(v143 - (float)(*(v137 - 1) * v141)) + (float)(v144 - v25->f32[1]);
        float v148 = v141 * *v137;
        v25->f32[0] = v146 - v145;
        float v149 = (float)(v143 - v148) + (float)(v144 - v25->f32[2]);
        v25->f32[1] = v146 - v147;
        v25->f32[2] = v146 - v149;
        v25->f32[3] = v146;
        goto LABEL_177;
      case 0xCu:
        float32x4_t v150 = &v52->f32[3];
        int v151 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v152 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_184;
            }
            unsigned int v153 = *v98 * v152 + ((*v98 * v152) >> 8) + 1;
            if (BYTE1(v153)) {
              break;
            }
          }
LABEL_187:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v150 += 4;
          if (!--v151) {
            goto LABEL_334;
          }
        }
        unsigned int v152 = v153 >> 8;
LABEL_184:
        float v154 = (float)v152 * 0.0039216;
        float v155 = v154 * *(v150 - 1);
        float v156 = v154 * *v150;
        *(float32x2_t *)v25->f32 = vadd_f32(vmul_n_f32(*(float32x2_t *)(v150 - 3), v154), *(float32x2_t *)v25->f32);
        float v157 = v156 + v25->f32[3];
        float v158 = v155 + v25->f32[2];
        if (v157 > 1.0) {
          float v157 = 1.0;
        }
        v25->f32[2] = v158;
        v25->f32[3] = v157;
        goto LABEL_187;
      case 0xDu:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v159 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v161 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v162 = *v160 * v161 + ((*v160 * v161) >> 8) + 1;
              if (!BYTE1(v162)) {
                goto LABEL_200;
              }
              unsigned int v161 = v162 >> 8;
            }
            float32x4_t v163 = *v52;
            int8x16_t v164 = (int8x16_t)vmulq_n_f32(*v52, (float)v161 * *((float *)v69 + 677));
            if (*(float *)&v164.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v165 = 1.0;
LABEL_199:
                v163.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v166 = vextq_s8(v164, v164, 4uLL).u64[0];
                float v167 = PDAmultiplyPDA(v25->f32[0], *(double *)v163.i64, v46, v47, v165, *(double *)v164.i64, v166, v51, *(float *)v164.i32, COERCE_DOUBLE(__PAIR64__(v164.u32[3], HIDWORD(v166))), *(float *)&v164.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v167;
                v25->i32[1] = v168;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_200;
              }
              LODWORD(v47) = v25->i32[3];
              float v165 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_199;
              }
              *unint64_t v25 = (float32x4_t)v164;
            }
          }
LABEL_200:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v159) {
            goto LABEL_361;
          }
        }
      case 0xEu:
        int8x16_t v169 = &v52->f32[2];
        int v170 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v171 = *v53;
          if (*v53)
          {
            if (!v34) {
              goto LABEL_207;
            }
            unsigned int v172 = *v98 * v171 + ((*v98 * v171) >> 8) + 1;
            if (BYTE1(v172)) {
              break;
            }
          }
LABEL_213:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v169 += 4;
          if (!--v170) {
            goto LABEL_334;
          }
        }
        unsigned int v171 = v172 >> 8;
LABEL_207:
        float v173 = (float)v171 * 0.0039216;
        float v174 = v173 * v169[1];
        if (v174 > 0.0)
        {
          float32x2_t v175 = vmul_n_f32(*(float32x2_t *)(v169 - 2), v173);
          float v176 = v173 * *v169;
          float v177 = 1.0;
          if (v342 && (float v177 = v25->f32[3], v177 <= 0.0))
          {
            *(float32x2_t *)v25->f32 = v175;
          }
          else
          {
            float v176 = v25->f32[2] + (float)(v176 * (float)(1.0 - v25->f32[2]));
            __asm { FMOV            V6.2S, #1.0 }
            *(float32x2_t *)v25->f32 = vmla_f32(*(float32x2_t *)v25->f32, vsub_f32(_D6, *(float32x2_t *)v25->f32), v175);
            float v174 = (float)(v174 + v177) - (float)(v177 * v174);
          }
          v25->f32[2] = v176;
          v25->f32[3] = v174;
        }
        goto LABEL_213;
      case 0xFu:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v183 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v184 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v185 = *v160 * v184 + ((*v160 * v184) >> 8) + 1;
              if (!BYTE1(v185)) {
                goto LABEL_226;
              }
              unsigned int v184 = v185 >> 8;
            }
            float32x4_t v186 = *v52;
            int8x16_t v187 = (int8x16_t)vmulq_n_f32(*v52, (float)v184 * *((float *)v69 + 677));
            if (*(float *)&v187.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v188 = 1.0;
LABEL_225:
                v186.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v189 = vextq_s8(v187, v187, 4uLL).u64[0];
                float v190 = PDAoverlayPDA(v25->f32[0], *(double *)v186.i64, v46, v47, v188, *(double *)v187.i64, v189, v51, *(float *)v187.i32, COERCE_DOUBLE(__PAIR64__(v187.u32[3], HIDWORD(v189))), *(float *)&v187.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v190;
                v25->i32[1] = v191;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_226;
              }
              LODWORD(v47) = v25->i32[3];
              float v188 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_225;
              }
              *unint64_t v25 = (float32x4_t)v187;
            }
          }
LABEL_226:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v183) {
            goto LABEL_361;
          }
        }
      case 0x10u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v192 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v193 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v194 = *v160 * v193 + ((*v160 * v193) >> 8) + 1;
              if (!BYTE1(v194)) {
                goto LABEL_239;
              }
              unsigned int v193 = v194 >> 8;
            }
            float32x4_t v195 = *v52;
            int8x16_t v196 = (int8x16_t)vmulq_n_f32(*v52, (float)v193 * *((float *)v69 + 677));
            if (*(float *)&v196.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v197 = 1.0;
LABEL_238:
                v195.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v198 = vextq_s8(v196, v196, 4uLL).u64[0];
                float v199 = PDAdarkenPDA(v25->f32[0], *(double *)v195.i64, v46, v47, v197, *(double *)v196.i64, v198, v51, *(float *)v196.i32, COERCE_DOUBLE(__PAIR64__(v196.u32[3], HIDWORD(v198))), *(float *)&v196.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v199;
                v25->i32[1] = v200;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_239;
              }
              LODWORD(v47) = v25->i32[3];
              float v197 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_238;
              }
              *unint64_t v25 = (float32x4_t)v196;
            }
          }
LABEL_239:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v192) {
            goto LABEL_361;
          }
        }
      case 0x11u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v201 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v202 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v203 = *v160 * v202 + ((*v160 * v202) >> 8) + 1;
              if (!BYTE1(v203)) {
                goto LABEL_252;
              }
              unsigned int v202 = v203 >> 8;
            }
            float32x4_t v204 = *v52;
            int8x16_t v205 = (int8x16_t)vmulq_n_f32(*v52, (float)v202 * *((float *)v69 + 677));
            if (*(float *)&v205.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v206 = 1.0;
LABEL_251:
                v204.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v207 = vextq_s8(v205, v205, 4uLL).u64[0];
                float v208 = PDAlightenPDA(v25->f32[0], *(double *)v204.i64, v46, v47, v206, *(double *)v205.i64, v207, v51, *(float *)v205.i32, COERCE_DOUBLE(__PAIR64__(v205.u32[3], HIDWORD(v207))), *(float *)&v205.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v208;
                v25->i32[1] = v209;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_252;
              }
              LODWORD(v47) = v25->i32[3];
              float v206 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_251;
              }
              *unint64_t v25 = (float32x4_t)v205;
            }
          }
LABEL_252:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v201) {
            goto LABEL_361;
          }
        }
      case 0x12u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v210 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v211 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v212 = *v160 * v211 + ((*v160 * v211) >> 8) + 1;
              if (!BYTE1(v212)) {
                goto LABEL_265;
              }
              unsigned int v211 = v212 >> 8;
            }
            float32x4_t v213 = *v52;
            int8x16_t v214 = (int8x16_t)vmulq_n_f32(*v52, (float)v211 * *((float *)v69 + 677));
            if (*(float *)&v214.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v215 = 1.0;
LABEL_264:
                v213.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v216 = vextq_s8(v214, v214, 4uLL).u64[0];
                float v217 = PDAcolordodgePDA(v25->f32[0], *(double *)v213.i64, v46, v47, v215, *(double *)v214.i64, v216, v51, *(float *)v214.i32, COERCE_DOUBLE(__PAIR64__(v214.u32[3], HIDWORD(v216))), *(float *)&v214.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v217;
                v25->i32[1] = v218;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_265;
              }
              LODWORD(v47) = v25->i32[3];
              float v215 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_264;
              }
              *unint64_t v25 = (float32x4_t)v214;
            }
          }
LABEL_265:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v210) {
            goto LABEL_361;
          }
        }
      case 0x13u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v219 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v220 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v221 = *v160 * v220 + ((*v160 * v220) >> 8) + 1;
              if (!BYTE1(v221)) {
                goto LABEL_278;
              }
              unsigned int v220 = v221 >> 8;
            }
            float32x4_t v222 = *v52;
            int8x16_t v223 = (int8x16_t)vmulq_n_f32(*v52, (float)v220 * *((float *)v69 + 677));
            if (*(float *)&v223.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v224 = 1.0;
LABEL_277:
                v222.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v225 = vextq_s8(v223, v223, 4uLL).u64[0];
                float v226 = PDAcolorburnPDA(v25->f32[0], *(double *)v222.i64, v46, v47, v224, *(double *)v223.i64, v225, v51, *(float *)v223.i32, COERCE_DOUBLE(__PAIR64__(v223.u32[3], HIDWORD(v225))), *(float *)&v223.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v226;
                v25->i32[1] = v227;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_278;
              }
              LODWORD(v47) = v25->i32[3];
              float v224 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_277;
              }
              *unint64_t v25 = (float32x4_t)v223;
            }
          }
LABEL_278:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v219) {
            goto LABEL_361;
          }
        }
      case 0x14u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v228 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v229 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v230 = *v160 * v229 + ((*v160 * v229) >> 8) + 1;
              if (!BYTE1(v230)) {
                goto LABEL_291;
              }
              unsigned int v229 = v230 >> 8;
            }
            int8x16_t v231 = (int8x16_t)vmulq_n_f32(*v52, (float)v229 * *((float *)v69 + 677));
            if (*(float *)&v231.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                LODWORD(v48) = 1.0;
LABEL_290:
                LODWORD(v46) = v25->i32[2];
                DWORD2(v322) = v231.i32[3];
                *(void *)&long long v322 = vextq_s8(v231, v231, 4uLL).u64[0];
                float v232 = PDAsoftlightPDA(v25->f32[0], v25->f32[1], v46, *(int32x2_t *)&v47, v48, *(double *)v231.i64, *(double *)&v322, v51, v38, v39, v40, v41, v42, v43, v44, v45, *(float *)v231.i32, v322, *(uint64_t *)((char *)&v322 + 4),
                         *(float *)&v231.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v232;
                v25->i32[1] = v233;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_291;
              }
              LODWORD(v47) = v25->i32[3];
              LODWORD(v48) = LODWORD(v47);
              if (*(float *)&v47 > 0.0) {
                goto LABEL_290;
              }
              *unint64_t v25 = (float32x4_t)v231;
            }
          }
LABEL_291:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v228) {
            goto LABEL_361;
          }
        }
      case 0x15u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v234 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v235 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v236 = *v160 * v235 + ((*v160 * v235) >> 8) + 1;
              if (!BYTE1(v236)) {
                goto LABEL_304;
              }
              unsigned int v235 = v236 >> 8;
            }
            float32x4_t v237 = *v52;
            int8x16_t v238 = (int8x16_t)vmulq_n_f32(*v52, (float)v235 * *((float *)v69 + 677));
            if (*(float *)&v238.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v239 = 1.0;
LABEL_303:
                v237.i32[0] = v25->i32[1];
                LODWORD(v46) = v25->i32[2];
                *(void *)&double v240 = vextq_s8(v238, v238, 4uLL).u64[0];
                float v241 = PDAhardlightPDA(v25->f32[0], *(double *)v237.i64, v46, v47, v239, *(double *)v238.i64, v240, v51, *(float *)v238.i32, COERCE_DOUBLE(__PAIR64__(v238.u32[3], HIDWORD(v240))), *(float *)&v238.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v241;
                v25->i32[1] = v242;
                v25->i32[2] = LODWORD(v46);
                v25->i32[3] = LODWORD(v47);
                goto LABEL_304;
              }
              LODWORD(v47) = v25->i32[3];
              float v239 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_303;
              }
              *unint64_t v25 = (float32x4_t)v238;
            }
          }
LABEL_304:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v234) {
            goto LABEL_361;
          }
        }
      case 0x16u:
        int v243 = v4;
        float32x4_t v98 = v34;
        while (1)
        {
          unsigned int v244 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v245 = *v98 * v244 + ((*v98 * v244) >> 8) + 1;
              if (!BYTE1(v245)) {
                goto LABEL_319;
              }
              unsigned int v244 = v245 >> 8;
            }
            float32x4_t v246 = vmulq_n_f32(*v52, (float)v244 * 0.0039216);
            if (v246.f32[3] > 0.0)
            {
              if (!v342)
              {
                float v247 = 1.0;
LABEL_316:
                float v248 = v25->f32[2];
                float32x2_t v249 = vmul_laneq_f32(*(float32x2_t *)v25->f32, v246, 3);
                float32x2_t v250 = vmul_n_f32(*(float32x2_t *)v246.f32, v247);
                float32x2_t v251 = vsub_f32(vadd_f32(*(float32x2_t *)v25->f32, *(float32x2_t *)v246.f32), v249);
                float32x2_t v252 = vsub_f32(v249, v250);
                float32x2_t v253 = vadd_f32(vsub_f32(v251, v250), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v252), (int8x8_t)vneg_f32(v252), (int8x8_t)v252));
                float v254 = v248 + v246.f32[2];
                float v255 = v248 * v246.f32[3];
                float v256 = vmuls_lane_f32(v247, v246, 2);
                float v257 = v254 - v255;
                float v258 = v255 - v256;
                v246.f32[0] = v257 - v256;
                if (v258 < 0.0) {
                  float v258 = -v258;
                }
                *(float32x2_t *)v25->f32 = v253;
                v25->f32[2] = v246.f32[0] + v258;
                v25->f32[3] = (float)(v247 + v246.f32[3]) - (float)(v247 * v246.f32[3]);
                goto LABEL_319;
              }
              float v247 = v25->f32[3];
              if (v247 > 0.0) {
                goto LABEL_316;
              }
              *unint64_t v25 = v246;
            }
          }
LABEL_319:
          ++v53;
          ++v52;
          v98 += v34 != 0;
          ++v25;
          if (!--v243) {
            goto LABEL_334;
          }
        }
      case 0x17u:
        float32x4_t v259 = &v52->f32[2];
        int v260 = v4;
        float32x4_t v98 = v34;
        do
        {
          unsigned int v261 = *v53;
          if (!*v53) {
            goto LABEL_333;
          }
          if (v34)
          {
            unsigned int v262 = *v98 * v261 + ((*v98 * v261) >> 8) + 1;
            if (!BYTE1(v262)) {
              goto LABEL_333;
            }
            unsigned int v261 = v262 >> 8;
          }
          float v263 = (float)v261 * 0.0039216;
          float v264 = v263 * v259[1];
          if (v264 > 0.0)
          {
            float32x2_t v265 = vmul_n_f32(*(float32x2_t *)(v259 - 2), v263);
            float v266 = v263 * *v259;
            if (v342)
            {
              float v267 = v25->f32[3];
              if (v267 <= 0.0)
              {
                *(float32x2_t *)v25->f32 = v265;
LABEL_332:
                v25->f32[2] = v266;
                v25->f32[3] = v264;
                goto LABEL_333;
              }
            }
            else
            {
              float v267 = 1.0;
            }
            float v266 = (float)(v266 + v25->f32[2]) + (float)((float)(v266 * v25->f32[2]) * -2.0);
            *(float32x2_t *)v25->f32 = vmla_f32(vadd_f32(v265, *(float32x2_t *)v25->f32), (float32x2_t)0xC0000000C0000000, vmul_f32(v265, *(float32x2_t *)v25->f32));
            float v264 = (float)(v264 + v267) - (float)(v267 * v264);
            goto LABEL_332;
          }
LABEL_333:
          ++v53;
          v98 += v34 != 0;
          ++v25;
          v259 += 4;
          --v260;
        }
        while (v260);
LABEL_334:
        unint64_t v34 = &v98[v333];
LABEL_335:
        v25 += v337;
LABEL_363:
        int v77 = v341;
LABEL_364:
        int v284 = v77 - 1;
        if (!v284)
        {
          uint64_t v31 = v340;
          goto LABEL_415;
        }
        int v341 = v284;
        uint64_t v37 = 0;
        uint64_t v32 = (v339 + 1);
        v29 += *(void *)(a2 + 128);
        v30 += *(void *)(a2 + 136);
        unint64_t v285 = v340;
        if (!v340) {
          continue;
        }
        uint64_t v35 = v328;
LABEL_427:
        uint64_t v31 = v285;
        do
        {
          while (1)
          {
            uint64_t v318 = *((unsigned int *)v34 - 4);
            int v319 = v318 - v32;
            if ((int)v318 <= (int)v32) {
              break;
            }
            v341 -= v319;
            if (v341 < 1) {
              goto LABEL_415;
            }
            v29 += *(void *)(a2 + 128) * v319;
            v30 += *(void *)(a2 + 136) * v319;
            v25 += v327 * v319;
            uint64_t v32 = v318;
          }
          if ((int)v32 < *((_DWORD *)v34 - 3) + (int)v318) {
            goto LABEL_12;
          }
          uint64_t v320 = v32;
          int v321 = shape_enum_clip_scan((uint64_t)v31, (_DWORD *)v34 - 4);
          uint64_t v32 = v320;
        }
        while (v321);
LABEL_415:
        uint64_t v314 = v329;
        if (v31) {
          free(v31);
        }
        uint64_t v315 = v314;
        if (v314) {
LABEL_418:
        }
          free(v315);
        return;
      case 0x18u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v268 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v269 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v270 = *v160 * v269 + ((*v160 * v269) >> 8) + 1;
              if (!BYTE1(v270)) {
                goto LABEL_347;
              }
              unsigned int v269 = v270 >> 8;
            }
            int8x16_t v271 = (int8x16_t)vmulq_n_f32(*v52, (float)v269 * *((float *)v69 + 677));
            if (*(float *)&v271.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v272 = 1.0;
LABEL_346:
                *(void *)&double v323 = vextq_s8(v271, v271, 4uLL).u64[0];
                float v273 = PDAhuePDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v272, *(double *)v271.i64, v323, v51, *(float *)v271.i32, *(float *)&v323, *((float *)&v323 + 1), *(float *)&v271.i32[3], *(float *)&v271.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v273;
                v25->i32[1] = v274;
                v25->i32[2] = v275;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_347;
              }
              LODWORD(v47) = v25->i32[3];
              float v272 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_346;
              }
              *unint64_t v25 = (float32x4_t)v271;
            }
          }
LABEL_347:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v268) {
            goto LABEL_361;
          }
        }
      case 0x19u:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v276 = v4;
        float32x4_t v160 = v34;
        while (1)
        {
          unsigned int v277 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v278 = *v160 * v277 + ((*v160 * v277) >> 8) + 1;
              if (!BYTE1(v278)) {
                goto LABEL_360;
              }
              unsigned int v277 = v278 >> 8;
            }
            int8x16_t v279 = (int8x16_t)vmulq_n_f32(*v52, (float)v277 * *((float *)v69 + 677));
            if (*(float *)&v279.i32[3] > 0.0)
            {
              if (!v342)
              {
                LODWORD(v47) = v25->i32[3];
                float v280 = 1.0;
LABEL_359:
                *(void *)&double v324 = vextq_s8(v279, v279, 4uLL).u64[0];
                float v281 = PDAsaturationPDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v280, *(double *)v279.i64, v324, v51, *(float *)v279.i32, *(float *)&v324, *((float *)&v324 + 1), *(float *)&v279.i32[3], *(float *)&v279.i32[3]);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v281;
                v25->i32[1] = v282;
                v25->i32[2] = v283;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_360;
              }
              LODWORD(v47) = v25->i32[3];
              float v280 = *(float *)&v47;
              if (*(float *)&v47 > 0.0) {
                goto LABEL_359;
              }
              *unint64_t v25 = (float32x4_t)v279;
            }
          }
LABEL_360:
          ++v53;
          ++v52;
          v160 += v34 != 0;
          ++v25;
          if (!--v276)
          {
LABEL_361:
            unint64_t v34 = &v160[v333];
LABEL_362:
            v25 += v337;
            unsigned int v36 = v332;
            uint64_t v30 = v334;
            uint64_t v29 = v335;
            goto LABEL_363;
          }
        }
      case 0x1Au:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        int v286 = v4;
        float v287 = v34;
        while (1)
        {
          unsigned int v288 = *v53;
          if (*v53)
          {
            if (v34)
            {
              unsigned int v289 = *v287 * v288 + ((*v287 * v288) >> 8) + 1;
              if (!BYTE1(v289)) {
                goto LABEL_378;
              }
              unsigned int v288 = v289 >> 8;
            }
            float32x4_t v290 = vmulq_n_f32(*v52, (float)v288 * *((float *)v69 + 677));
            LODWORD(v47) = v290.i32[3];
            if (v290.f32[3] > 0.0)
            {
              if (!v342)
              {
                float v291 = v25->f32[3];
                LODWORD(v49) = 1.0;
LABEL_377:
                LODWORD(v50) = v25->i32[2];
                float v292 = PDAluminosityPDA(v290.f32[0], v290.f32[1], v290.f32[2], v47, v290.f32[3], v49, v50, v51, COERCE_FLOAT(v25->i64[0]), COERCE_FLOAT(HIDWORD(v25->i64[0])), *(float *)&v50, v291, *(float *)&v49);
                float32x4_t v69 = &xmmword_1850CE000;
                v25->f32[0] = v292;
                v25->i32[1] = v293;
                v25->i32[2] = v294;
                v25->i32[3] = LODWORD(v47);
                goto LABEL_378;
              }
              float v291 = v25->f32[3];
              *(float *)&double v49 = v291;
              if (v291 > 0.0) {
                goto LABEL_377;
              }
              *unint64_t v25 = v290;
            }
          }
LABEL_378:
          ++v53;
          ++v52;
          v287 += v34 != 0;
          ++v25;
          if (!--v286) {
            goto LABEL_392;
          }
        }
      case 0x1Bu:
        uint64_t v334 = v30;
        uint64_t v335 = v29;
        float v287 = v34;
        int v295 = v4;
        break;
      default:
        goto LABEL_363;
    }
    break;
  }
  while (1)
  {
    unsigned int v296 = *v53;
    if (*v53)
    {
      if (v34)
      {
        unsigned int v297 = *v287 * v296 + ((*v287 * v296) >> 8) + 1;
        if (!BYTE1(v297)) {
          goto LABEL_391;
        }
        unsigned int v296 = v297 >> 8;
      }
      int8x16_t v298 = (int8x16_t)vmulq_n_f32(*v52, (float)v296 * *((float *)v69 + 677));
      if (*(float *)&v298.i32[3] > 0.0)
      {
        if (!v342)
        {
          LODWORD(v47) = v25->i32[3];
          float v299 = 1.0;
LABEL_390:
          *(void *)&double v325 = vextq_s8(v298, v298, 4uLL).u64[0];
          float v300 = PDAluminosityPDA(v25->f32[0], v25->f32[1], v25->f32[2], v47, v299, *(double *)v298.i64, v325, v51, *(float *)v298.i32, *(float *)&v325, *((float *)&v325 + 1), *(float *)&v298.i32[3], *(float *)&v298.i32[3]);
          float32x4_t v69 = &xmmword_1850CE000;
          v25->f32[0] = v300;
          v25->i32[1] = v301;
          v25->i32[2] = v302;
          v25->i32[3] = LODWORD(v47);
          goto LABEL_391;
        }
        LODWORD(v47) = v25->i32[3];
        float v299 = *(float *)&v47;
        if (*(float *)&v47 > 0.0) {
          goto LABEL_390;
        }
        *unint64_t v25 = (float32x4_t)v298;
      }
    }
LABEL_391:
    ++v53;
    ++v52;
    v287 += v34 != 0;
    ++v25;
    if (!--v295)
    {
LABEL_392:
      unint64_t v34 = &v287[v333];
      goto LABEL_362;
    }
  }
}

uint64_t RGBAf_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6 = *((float *)a2 + 2);
  int v7 = a2[1];
  float v89 = *(float *)a2;
  unint64_t v8 = *(unsigned int **)(a1 + 32);
  if (*(void *)(a1 + 40)) {
    char v9 = 0;
  }
  else {
    char v9 = -1;
  }
  uint64_t v10 = (float *)*((void *)a2 + 2);
  uint64_t v11 = *((void *)a2 + 3) - a5;
  uint64_t v13 = *((void *)a2 + 15);
  uint64_t v12 = *((void *)a2 + 16);
  uint64_t v14 = *((void *)a2 + 7);
  uint64_t v15 = *((void *)a2 + 9);
  uint64_t v16 = *((void *)a2 + 5) + v15 * a4;
  uint64_t v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(void *)(a1 + 176))
  {
    uint64_t v88 = *((void *)a2 + 11);
    uint64_t v87 = *((void *)a2 + 13);
    uint64_t v86 = v12 + 16 * a3 + 8;
    do
    {
      if (((v87 - v16) | (v16 - v88)) < 0)
      {
        uint64_t v19 = 0;
        unsigned int v20 = 0;
      }
      else
      {
        unint64_t v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9) {
          uint64_t v19 = -v13;
        }
        else {
          uint64_t v19 = v13;
        }
        unsigned int v20 = weights_21383[v18] & 0xF;
      }
      uint64_t result = v16 >> v14;
      unint64_t v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v20;
          uint64_t v23 = (uint64_t *)v86;
          uint64_t v24 = a5;
          do
          {
            uint64_t v25 = *(v23 - 1);
            uint64_t v26 = *v23;
            int v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25]) {
              int v28 = (unsigned int *)&v22[v25];
            }
            else {
              int v28 = v17;
            }
            if (v8 > v28) {
              int v28 = v8;
            }
            unsigned int v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              uint64_t v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30) {
                uint64_t v30 = v17;
              }
              if (v8 > v30) {
                uint64_t v30 = v8;
              }
              unsigned int v31 = *v30;
              if (v20)
              {
                uint64_t v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v8 > v33) {
                  uint64_t v33 = v8;
                }
                unsigned int v34 = *v33;
                uint64_t v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35) {
                  uint64_t v35 = v17;
                }
                if (v8 > v35) {
                  uint64_t v35 = v8;
                }
                unsigned int v36 = BLEND8_21385[v20];
                unsigned int v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_21385[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              uint64_t v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19]) {
                uint64_t v37 = v17;
              }
              if (v8 > v37) {
                uint64_t v37 = v8;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v20] & v29) >> v20) + ((BLEND8_21385[v20] & *v37) >> v20);
            }
            unsigned int v38 = __ROL4__(v29, v7);
            float v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              float v40 = *(float *)&_blt_float[BYTE2(v38)];
              float v41 = *(float *)&_blt_float[BYTE1(v38)];
              float v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              float v39 = v6 * v39;
              float v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              float v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              float v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *uint64_t v10 = v39;
            v10[1] = v40;
            void v10[2] = v41;
            v10[3] = v42;
            v10 += 4;
            --v24;
          }
          while (v24);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v43 = (uint64_t *)v86;
        uint64_t result = a5;
        do
        {
          uint64_t v44 = *(v43 - 1);
          uint64_t v45 = *v43;
          double v46 = &v22[v44];
          if (v17 >= (unsigned int *)&v22[v44]) {
            double v47 = (unsigned int *)&v22[v44];
          }
          else {
            double v47 = v17;
          }
          if (v8 > v47) {
            double v47 = v8;
          }
          unsigned int v48 = *v47;
          if ((v45 & 0xF) != 0)
          {
            double v49 = (unsigned int *)&v46[v45 >> 4];
            if (v17 < v49) {
              double v49 = v17;
            }
            if (v8 > v49) {
              double v49 = v8;
            }
            unsigned int v50 = *v49;
            if (v20)
            {
              if (v17 >= (unsigned int *)&v46[v19]) {
                double v51 = (unsigned int *)&v46[v19];
              }
              else {
                double v51 = v17;
              }
              if (v8 > v51) {
                double v51 = v8;
              }
              unsigned int v52 = *v51;
              uint64_t v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
              if (v17 < v53) {
                uint64_t v53 = v17;
              }
              if (v8 > v53) {
                uint64_t v53 = v8;
              }
              unsigned int v54 = BLEND8_21385[v20];
              unsigned int v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
              unsigned int v50 = v50 - ((v54 & v50) >> v20) + ((v54 & *v53) >> v20);
            }
            unsigned int v48 = v48
                - ((BLEND8_21385[*v43 & 0xF] & v48) >> (*v43 & 0xF))
                + ((BLEND8_21385[*v43 & 0xF] & v50) >> (*v43 & 0xF));
          }
          else if (v20)
          {
            float v55 = (unsigned int *)&v46[v19];
            if (v17 < (unsigned int *)&v46[v19]) {
              float v55 = v17;
            }
            if (v8 > v55) {
              float v55 = v8;
            }
            unsigned int v48 = v48 - ((BLEND8_21385[v20] & v48) >> v20) + ((BLEND8_21385[v20] & *v55) >> v20);
          }
          unsigned int v56 = __ROL4__(v48, v7);
          float v57 = *(float *)&_blt_float[HIBYTE(v56)];
          if (v6 >= 1.0)
          {
            float v58 = *(float *)&_blt_float[BYTE2(v56)];
            float v59 = *(float *)&_blt_float[BYTE1(v56)];
            float v60 = *(float *)&_blt_float[(v56 | v9)];
          }
          else
          {
            float v57 = v6 * v57;
            float v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
            float v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
            float v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
          }
          if (v60 >= 1.0)
          {
            *uint64_t v10 = v57;
            v10[1] = v58;
            void v10[2] = v59;
            v10[3] = v60;
          }
          else if (v60 > 0.0)
          {
            float v61 = v10[1];
            *uint64_t v10 = v57 + (float)(*v10 * (float)(1.0 - v60));
            v10[1] = v58 + (float)(v61 * (float)(1.0 - v60));
            float v62 = v59 + (float)(v10[2] * (float)(1.0 - v60));
            float v63 = v60 + (float)(v10[3] * (float)(1.0 - v60));
            void v10[2] = v62;
            v10[3] = v63;
          }
          v43 += 2;
          v10 += 4;
          --result;
        }
        while (result);
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  else
  {
    unint64_t v64 = (uint64_t *)(v12 + 16 * a3);
    do
    {
      uint64_t result = (uint64_t)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v65 = v64;
          uint64_t v66 = a5;
          do
          {
            uint64_t v67 = *v65;
            v65 += 2;
            unint64_t v68 = (unsigned int *)(result + v67);
            if ((unint64_t)v17 < result + v67) {
              unint64_t v68 = v17;
            }
            if (v8 > v68) {
              unint64_t v68 = v8;
            }
            unsigned int v69 = __ROL4__(*v68, v7);
            float v70 = *(float *)&_blt_float[HIBYTE(v69)];
            if (v6 >= 1.0)
            {
              float v71 = *(float *)&_blt_float[BYTE2(v69)];
              float v72 = *(float *)&_blt_float[BYTE1(v69)];
              float v73 = *(float *)&_blt_float[(v69 | v9)];
            }
            else
            {
              float v70 = v6 * v70;
              float v71 = v6 * *(float *)&_blt_float[BYTE2(v69)];
              float v72 = v6 * *(float *)&_blt_float[BYTE1(v69)];
              float v73 = v6 * *(float *)&_blt_float[(v69 | v9)];
            }
            *uint64_t v10 = v70;
            v10[1] = v71;
            void v10[2] = v72;
            v10[3] = v73;
            v10 += 4;
            --v66;
          }
          while (v66);
        }
      }
      else
      {
        float32x4_t v74 = v64;
        uint64_t v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v76 = *v74;
            v74 += 2;
            int v77 = (unsigned int *)(result + v76);
            if ((unint64_t)v17 < result + v76) {
              int v77 = v17;
            }
            if (v8 > v77) {
              int v77 = v8;
            }
            unsigned int v78 = __ROL4__(*v77, v7);
            float v79 = *(float *)&_blt_float[HIBYTE(v78)];
            if (v6 >= 1.0)
            {
              float v80 = *(float *)&_blt_float[BYTE2(v78)];
              float v81 = *(float *)&_blt_float[BYTE1(v78)];
              float v82 = *(float *)&_blt_float[(v78 | v9)];
            }
            else
            {
              float v79 = v6 * v79;
              float v80 = v6 * *(float *)&_blt_float[BYTE2(v78)];
              float v81 = v6 * *(float *)&_blt_float[BYTE1(v78)];
              float v82 = v6 * *(float *)&_blt_float[(v78 | v9)];
            }
            if (v82 >= 1.0)
            {
              *uint64_t v10 = v79;
              v10[1] = v80;
              void v10[2] = v81;
              v10[3] = v82;
            }
            else if (v82 > 0.0)
            {
              float v83 = v10[1];
              *uint64_t v10 = v79 + (float)(*v10 * (float)(1.0 - v82));
              v10[1] = v80 + (float)(v83 * (float)(1.0 - v82));
              float v84 = v81 + (float)(v10[2] * (float)(1.0 - v82));
              float v85 = v82 + (float)(v10[3] * (float)(1.0 - v82));
              void v10[2] = v84;
              v10[3] = v85;
            }
            v10 += 4;
            --v75;
          }
          while (v75);
        }
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAf_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6 = *((float *)a2 + 2);
  int v7 = a2[1];
  float v89 = *(float *)a2;
  unint64_t v8 = *(unsigned int **)(a1 + 32);
  if (*(void *)(a1 + 40)) {
    char v9 = 0;
  }
  else {
    char v9 = -1;
  }
  uint64_t v10 = (float *)*((void *)a2 + 2);
  uint64_t v11 = *((void *)a2 + 3) - a5;
  uint64_t v13 = *((void *)a2 + 15);
  uint64_t v12 = *((void *)a2 + 16);
  uint64_t v14 = *((void *)a2 + 7);
  uint64_t v15 = *((void *)a2 + 9);
  uint64_t v16 = *((void *)a2 + 5) + v15 * a4;
  uint64_t v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(void *)(a1 + 176))
  {
    uint64_t v88 = *((void *)a2 + 11);
    uint64_t v87 = *((void *)a2 + 13);
    uint64_t v86 = v12 + 16 * a3 + 8;
    do
    {
      if (((v87 - v16) | (v16 - v88)) < 0)
      {
        uint64_t v19 = 0;
        unsigned int v20 = 0;
      }
      else
      {
        unint64_t v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9) {
          uint64_t v19 = -v13;
        }
        else {
          uint64_t v19 = v13;
        }
        unsigned int v20 = weights_21383[v18] & 0xF;
      }
      uint64_t result = v16 >> v14;
      unint64_t v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v20;
          uint64_t v23 = (uint64_t *)v86;
          uint64_t v24 = a5;
          do
          {
            uint64_t v25 = *(v23 - 1);
            uint64_t v26 = *v23;
            int v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25]) {
              int v28 = (unsigned int *)&v22[v25];
            }
            else {
              int v28 = v17;
            }
            if (v8 > v28) {
              int v28 = v8;
            }
            unsigned int v29 = bswap32(*v28);
            if ((v26 & 0xF) != 0)
            {
              uint64_t v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30) {
                uint64_t v30 = v17;
              }
              if (v8 > v30) {
                uint64_t v30 = v8;
              }
              unsigned int v31 = bswap32(*v30);
              if (v20)
              {
                uint64_t v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v8 > v33) {
                  uint64_t v33 = v8;
                }
                unsigned int v34 = bswap32(*v33);
                uint64_t v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35) {
                  uint64_t v35 = v17;
                }
                if (v8 > v35) {
                  uint64_t v35 = v8;
                }
                int v36 = BLEND8_21385[v20];
                unsigned int v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((bswap32(*v35) & v36) >> v20);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_21385[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              uint64_t v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19]) {
                uint64_t v37 = v17;
              }
              if (v8 > v37) {
                uint64_t v37 = v8;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v20] & v29) >> v20) + ((bswap32(*v37) & BLEND8_21385[v20]) >> v20);
            }
            unsigned int v38 = __ROL4__(v29, v7);
            float v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              float v40 = *(float *)&_blt_float[BYTE2(v38)];
              float v41 = *(float *)&_blt_float[BYTE1(v38)];
              float v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              float v39 = v6 * v39;
              float v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              float v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              float v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *uint64_t v10 = v39;
            v10[1] = v40;
            void v10[2] = v41;
            v10[3] = v42;
            v10 += 4;
            --v24;
          }
          while (v24);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v43 = (uint64_t *)v86;
        uint64_t result = a5;
        do
        {
          uint64_t v44 = *(v43 - 1);
          uint64_t v45 = *v43;
          double v46 = &v22[v44];
          if (v17 >= (unsigned int *)&v22[v44]) {
            double v47 = (unsigned int *)&v22[v44];
          }
          else {
            double v47 = v17;
          }
          if (v8 > v47) {
            double v47 = v8;
          }
          unsigned int v48 = bswap32(*v47);
          if ((v45 & 0xF) != 0)
          {
            double v49 = (unsigned int *)&v46[v45 >> 4];
            if (v17 < v49) {
              double v49 = v17;
            }
            if (v8 > v49) {
              double v49 = v8;
            }
            unsigned int v50 = bswap32(*v49);
            if (v20)
            {
              if (v17 >= (unsigned int *)&v46[v19]) {
                double v51 = (unsigned int *)&v46[v19];
              }
              else {
                double v51 = v17;
              }
              if (v8 > v51) {
                double v51 = v8;
              }
              unsigned int v52 = bswap32(*v51);
              uint64_t v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
              if (v17 < v53) {
                uint64_t v53 = v17;
              }
              if (v8 > v53) {
                uint64_t v53 = v8;
              }
              int v54 = BLEND8_21385[v20];
              unsigned int v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
              unsigned int v50 = v50 - ((v54 & v50) >> v20) + ((bswap32(*v53) & v54) >> v20);
            }
            unsigned int v48 = v48
                - ((BLEND8_21385[*v43 & 0xF] & v48) >> (*v43 & 0xF))
                + ((BLEND8_21385[*v43 & 0xF] & v50) >> (*v43 & 0xF));
          }
          else if (v20)
          {
            float v55 = (unsigned int *)&v46[v19];
            if (v17 < (unsigned int *)&v46[v19]) {
              float v55 = v17;
            }
            if (v8 > v55) {
              float v55 = v8;
            }
            unsigned int v48 = v48 - ((BLEND8_21385[v20] & v48) >> v20) + ((bswap32(*v55) & BLEND8_21385[v20]) >> v20);
          }
          unsigned int v56 = __ROL4__(v48, v7);
          float v57 = *(float *)&_blt_float[HIBYTE(v56)];
          if (v6 >= 1.0)
          {
            float v58 = *(float *)&_blt_float[BYTE2(v56)];
            float v59 = *(float *)&_blt_float[BYTE1(v56)];
            float v60 = *(float *)&_blt_float[(v56 | v9)];
          }
          else
          {
            float v57 = v6 * v57;
            float v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
            float v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
            float v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
          }
          if (v60 >= 1.0)
          {
            *uint64_t v10 = v57;
            v10[1] = v58;
            void v10[2] = v59;
            v10[3] = v60;
          }
          else if (v60 > 0.0)
          {
            float v61 = v10[1];
            *uint64_t v10 = v57 + (float)(*v10 * (float)(1.0 - v60));
            v10[1] = v58 + (float)(v61 * (float)(1.0 - v60));
            float v62 = v59 + (float)(v10[2] * (float)(1.0 - v60));
            float v63 = v60 + (float)(v10[3] * (float)(1.0 - v60));
            void v10[2] = v62;
            v10[3] = v63;
          }
          v43 += 2;
          v10 += 4;
          --result;
        }
        while (result);
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  else
  {
    unint64_t v64 = (uint64_t *)(v12 + 16 * a3);
    do
    {
      uint64_t result = (uint64_t)v8 + (v16 >> v14) * v13;
      if (LODWORD(v89) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v65 = v64;
          uint64_t v66 = a5;
          do
          {
            uint64_t v67 = *v65;
            v65 += 2;
            unint64_t v68 = (unsigned int *)(result + v67);
            if ((unint64_t)v17 < result + v67) {
              unint64_t v68 = v17;
            }
            if (v8 > v68) {
              unint64_t v68 = v8;
            }
            unsigned int v69 = __ROL4__(bswap32(*v68), v7);
            float v70 = *(float *)&_blt_float[HIBYTE(v69)];
            if (v6 >= 1.0)
            {
              float v71 = *(float *)&_blt_float[BYTE2(v69)];
              float v72 = *(float *)&_blt_float[BYTE1(v69)];
              float v73 = *(float *)&_blt_float[(v69 | v9)];
            }
            else
            {
              float v70 = v6 * v70;
              float v71 = v6 * *(float *)&_blt_float[BYTE2(v69)];
              float v72 = v6 * *(float *)&_blt_float[BYTE1(v69)];
              float v73 = v6 * *(float *)&_blt_float[(v69 | v9)];
            }
            *uint64_t v10 = v70;
            v10[1] = v71;
            void v10[2] = v72;
            v10[3] = v73;
            v10 += 4;
            --v66;
          }
          while (v66);
        }
      }
      else
      {
        float32x4_t v74 = v64;
        uint64_t v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v76 = *v74;
            v74 += 2;
            int v77 = (unsigned int *)(result + v76);
            if ((unint64_t)v17 < result + v76) {
              int v77 = v17;
            }
            if (v8 > v77) {
              int v77 = v8;
            }
            unsigned int v78 = __ROL4__(bswap32(*v77), v7);
            float v79 = *(float *)&_blt_float[HIBYTE(v78)];
            if (v6 >= 1.0)
            {
              float v80 = *(float *)&_blt_float[BYTE2(v78)];
              float v81 = *(float *)&_blt_float[BYTE1(v78)];
              float v82 = *(float *)&_blt_float[(v78 | v9)];
            }
            else
            {
              float v79 = v6 * v79;
              float v80 = v6 * *(float *)&_blt_float[BYTE2(v78)];
              float v81 = v6 * *(float *)&_blt_float[BYTE1(v78)];
              float v82 = v6 * *(float *)&_blt_float[(v78 | v9)];
            }
            if (v82 >= 1.0)
            {
              *uint64_t v10 = v79;
              v10[1] = v80;
              void v10[2] = v81;
              v10[3] = v82;
            }
            else if (v82 > 0.0)
            {
              float v83 = v10[1];
              *uint64_t v10 = v79 + (float)(*v10 * (float)(1.0 - v82));
              v10[1] = v80 + (float)(v83 * (float)(1.0 - v82));
              float v84 = v81 + (float)(v10[2] * (float)(1.0 - v82));
              float v85 = v82 + (float)(v10[3] * (float)(1.0 - v82));
              void v10[2] = v84;
              v10[3] = v85;
            }
            v10 += 4;
            --v75;
          }
          while (v75);
        }
      }
      v10 += 4 * v11;
      v16 += v15;
      --a6;
    }
    while (a6);
  }
  return result;
}

_DWORD *RGBAf_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6 = *((float *)a2 + 2);
  float v7 = *(float *)a2;
  unint64_t v8 = (float *)*((void *)a2 + 2);
  uint64_t v9 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 15);
  uint64_t v11 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v14 = *((void *)a2 + 5) + v13 * a4;
  uint64_t v15 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = _blt_float;
  if (v17)
  {
    uint64_t v96 = *((void *)a2 + 11);
    uint64_t v19 = *((void *)a2 + 13);
    float v20 = 1.0 - v6;
    uint64_t v95 = v11 + 16 * a3 + 8;
    do
    {
      if (((v19 - v14) | (v14 - v96)) < 0)
      {
        uint64_t v22 = 0;
        int v23 = 0;
      }
      else
      {
        unint64_t v21 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v21 - 7 >= 9) {
          uint64_t v22 = -v10;
        }
        else {
          uint64_t v22 = v10;
        }
        int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t v24 = &v15[(v14 >> v12) * v10];
      if (LODWORD(v7) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v25 = (uint64_t *)v95;
          uint64_t v26 = a5;
          do
          {
            uint64_t v27 = *(v25 - 1);
            uint64_t v28 = *v25;
            unsigned int v29 = &v24[v27];
            if (v16 >= &v24[v27]) {
              uint64_t v30 = &v24[v27];
            }
            else {
              uint64_t v30 = v16;
            }
            if (v15 > v30) {
              uint64_t v30 = v15;
            }
            unsigned int v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
            if ((v28 & 0xF) != 0)
            {
              uint64_t v32 = &v29[v28 >> 4];
              if (v16 < v32) {
                uint64_t v32 = v16;
              }
              if (v15 > v32) {
                uint64_t v32 = v15;
              }
              int v33 = (*v32 << 24) | (v32[1] << 16) | (v32[2] << 8);
              if (v23)
              {
                unsigned int v34 = &v29[v22];
                if (v16 >= &v29[v22]) {
                  uint64_t v35 = &v29[v22];
                }
                else {
                  uint64_t v35 = v16;
                }
                if (v15 > v35) {
                  uint64_t v35 = v15;
                }
                int v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                uint64_t v37 = &v34[v28 >> 4];
                if (v16 < v37) {
                  uint64_t v37 = v16;
                }
                if (v15 > v37) {
                  uint64_t v37 = v15;
                }
                unsigned int v38 = BLEND8_21385[v23];
                unsigned int v31 = v31 - ((v38 & v31) >> v23) + ((v38 & v36) >> v23);
                int v33 = v33 - ((v38 & v33) >> v23) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v23);
              }
              unsigned int v31 = v31
                  - ((BLEND8_21385[*v25 & 0xF] & v31) >> (*v25 & 0xF))
                  + ((BLEND8_21385[*v25 & 0xF] & v33) >> (*v25 & 0xF));
            }
            else if (v23)
            {
              float v39 = &v29[v22];
              if (v16 < &v29[v22]) {
                float v39 = v16;
              }
              if (v15 > v39) {
                float v39 = v15;
              }
              unsigned int v31 = v31
                  - ((BLEND8_21385[v23] & v31) >> v23)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_21385[v23]) >> v23);
            }
            float v40 = *(float *)&_blt_float[HIBYTE(v31)];
            if (v6 >= 1.0)
            {
              float v41 = *(float *)&_blt_float[BYTE2(v31)];
              float v42 = *(float *)&_blt_float[BYTE1(v31)];
              float v43 = 1.0;
            }
            else
            {
              float v40 = v6 * v40;
              float v41 = v6 * *(float *)&_blt_float[BYTE2(v31)];
              float v42 = v6 * *(float *)&_blt_float[BYTE1(v31)];
              float v43 = v6;
            }
            v25 += 2;
            *unint64_t v8 = v40;
            v8[1] = v41;
            v8[2] = v42;
            v8[3] = v43;
            v8 += 4;
            --v26;
          }
          while (v26);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v44 = (uint64_t *)v95;
        uint64_t v45 = a5;
        do
        {
          uint64_t v46 = *(v44 - 1);
          uint64_t v47 = *v44;
          unsigned int v48 = &v24[v46];
          if (v16 >= &v24[v46]) {
            double v49 = &v24[v46];
          }
          else {
            double v49 = v16;
          }
          if (v15 > v49) {
            double v49 = v15;
          }
          unsigned int v50 = (*v49 << 24) | (v49[1] << 16) | (v49[2] << 8);
          if ((v47 & 0xF) != 0)
          {
            double v51 = &v48[v47 >> 4];
            if (v16 < v51) {
              double v51 = v16;
            }
            if (v15 > v51) {
              double v51 = v15;
            }
            int v52 = (*v51 << 24) | (v51[1] << 16) | (v51[2] << 8);
            if (v23)
            {
              if (v16 >= &v48[v22]) {
                uint64_t v53 = &v48[v22];
              }
              else {
                uint64_t v53 = v16;
              }
              if (v15 > v53) {
                uint64_t v53 = v15;
              }
              int v54 = (*v53 << 24) | (v53[1] << 16) | (v53[2] << 8);
              float v55 = &v48[v22 + (v47 >> 4)];
              if (v16 < v55) {
                float v55 = v16;
              }
              if (v15 > v55) {
                float v55 = v15;
              }
              unsigned int v56 = BLEND8_21385[v23];
              unsigned int v50 = v50 - ((v56 & v50) >> v23) + ((v56 & v54) >> v23);
              int v52 = v52 - ((v56 & v52) >> v23) + ((((*v55 << 24) | (v55[1] << 16) | (v55[2] << 8)) & v56) >> v23);
            }
            unsigned int v50 = v50
                - ((BLEND8_21385[*v44 & 0xF] & v50) >> (*v44 & 0xF))
                + ((BLEND8_21385[*v44 & 0xF] & v52) >> (*v44 & 0xF));
          }
          else if (v23)
          {
            float v57 = &v48[v22];
            if (v16 < &v48[v22]) {
              float v57 = v16;
            }
            if (v15 > v57) {
              float v57 = v15;
            }
            unsigned int v50 = v50
                - ((BLEND8_21385[v23] & v50) >> v23)
                + ((((*v57 << 24) | (v57[1] << 16) | (v57[2] << 8)) & BLEND8_21385[v23]) >> v23);
          }
          float v58 = *(float *)&_blt_float[HIBYTE(v50)];
          if (v6 >= 1.0)
          {
            int v65 = _blt_float[BYTE2(v50)];
            int v66 = _blt_float[BYTE1(v50)];
            *unint64_t v8 = v58;
            *((_DWORD *)v8 + 1) = v65;
            *((_DWORD *)v8 + 2) = v66;
            v8[3] = 1.0;
          }
          else
          {
            float v59 = v6 * v58;
            float v60 = v6 * *(float *)&_blt_float[BYTE2(v50)];
            float v61 = v6 * *(float *)&_blt_float[BYTE1(v50)];
            if (v6 > 0.0)
            {
              float v62 = v8[1];
              *unint64_t v8 = v59 + (float)(*v8 * v20);
              v8[1] = v60 + (float)(v62 * v20);
              float v63 = v61 + (float)(v8[2] * v20);
              float v64 = v6 + (float)(v8[3] * v20);
              v8[2] = v63;
              v8[3] = v64;
            }
          }
          v44 += 2;
          v8 += 4;
          --v45;
        }
        while (v45);
      }
      v8 += 4 * v9;
      v14 += v13;
      --a6;
    }
    while (a6);
  }
  else
  {
    uint64_t v67 = (uint64_t *)(v11 + 16 * a3);
    float v68 = 1.0 - v6;
    do
    {
      unsigned int v69 = &v15[(v14 >> v12) * v10];
      if (LODWORD(v7) == 1)
      {
        if (a5 >= 1)
        {
          float v70 = v67;
          uint64_t v71 = a5;
          do
          {
            uint64_t v72 = *v70;
            v70 += 2;
            float v73 = &v69[v72];
            if (v16 < &v69[v72]) {
              float v73 = v16;
            }
            if (v15 > v73) {
              float v73 = v15;
            }
            uint64_t v74 = v73[1];
            uint64_t v75 = v73[2];
            float v76 = *(float *)&_blt_float[*v73];
            if (v6 >= 1.0)
            {
              float v77 = *(float *)&_blt_float[v74];
              float v78 = *(float *)&_blt_float[v75];
              float v79 = 1.0;
            }
            else
            {
              float v76 = v6 * v76;
              float v77 = v6 * *(float *)&_blt_float[v74];
              float v78 = v6 * *(float *)&_blt_float[v75];
              float v79 = v6;
            }
            *unint64_t v8 = v76;
            v8[1] = v77;
            v8[2] = v78;
            v8[3] = v79;
            v8 += 4;
            --v71;
          }
          while (v71);
        }
      }
      else
      {
        float v80 = v67;
        uint64_t v81 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v82 = *v80;
            v80 += 2;
            float v83 = &v69[v82];
            if (v16 < &v69[v82]) {
              float v83 = v16;
            }
            if (v15 > v83) {
              float v83 = v15;
            }
            uint64_t v84 = v83[1];
            uint64_t v85 = v83[2];
            float v86 = *(float *)&_blt_float[*v83];
            if (v6 >= 1.0)
            {
              int v93 = _blt_float[v84];
              int v94 = _blt_float[v85];
              *unint64_t v8 = v86;
              *((_DWORD *)v8 + 1) = v93;
              *((_DWORD *)v8 + 2) = v94;
              v8[3] = 1.0;
            }
            else
            {
              float v87 = v6 * v86;
              float v88 = v6 * *(float *)&_blt_float[v84];
              float v89 = v6 * *(float *)&_blt_float[v85];
              if (v6 > 0.0)
              {
                float v90 = v8[1];
                *unint64_t v8 = v87 + (float)(*v8 * v68);
                v8[1] = v88 + (float)(v90 * v68);
                float v91 = v89 + (float)(v8[2] * v68);
                float v92 = v6 + (float)(v8[3] * v68);
                v8[2] = v91;
                v8[3] = v92;
              }
            }
            v8 += 4;
            --v81;
          }
          while (v81);
        }
      }
      v8 += 4 * v9;
      v14 += v13;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAf_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  float v11 = *((float *)a2 + 2);
  float v12 = *(float *)a2;
  uint64_t v13 = (float32x4_t *)*((void *)a2 + 2);
  uint64_t v14 = *((void *)a2 + 3) - a5;
  uint64_t v16 = *((void *)a2 + 15);
  uint64_t v15 = *((void *)a2 + 16);
  uint64_t v17 = *((void *)a2 + 7);
  uint64_t v18 = *((void *)a2 + 9);
  uint64_t v19 = *((void *)a2 + 5) + v18 * a4;
  float v20 = *(unsigned __int8 **)(a1 + 32);
  unint64_t v21 = &v20[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  if (*(void *)(a1 + 176))
  {
    uint64_t v22 = *((void *)a2 + 11);
    uint64_t result = *((void *)a2 + 13);
    float v24 = fminf(v11, 1.0);
    uint64_t v92 = v15 + 16 * a3 + 8;
    __asm { FMOV            V2.2S, #1.0 }
    while (1)
    {
      if (((result - v19) | (v19 - v22)) < 0)
      {
        int v32 = 0;
        uint64_t v31 = 0;
      }
      else
      {
        unint64_t v30 = ((v19 & (unint64_t)~(-1 << v17)) >> (v17 - 4)) & 0xF;
        uint64_t v31 = v30 - 7 >= 9 ? -v16 : v16;
        int v32 = weights_21383[v30] & 0xF;
      }
      int v33 = &v20[(v19 >> v17) * v16];
      if (LODWORD(v12) != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unsigned int v34 = (uint64_t *)v92;
        uint64_t v35 = a5;
        while (1)
        {
          uint64_t v36 = *(v34 - 1);
          uint64_t v37 = *v34;
          unsigned int v38 = &v33[v36];
          if (v21 >= &v33[v36]) {
            float v39 = &v33[v36];
          }
          else {
            float v39 = v21;
          }
          if (v20 > v39) {
            float v39 = v20;
          }
          unsigned int v40 = *v39;
          char v41 = v37 & 0xF;
          if ((v37 & 0xF) != 0) {
            break;
          }
          if (v32)
          {
            int v52 = &v38[v31];
            if (v21 < &v38[v31]) {
              int v52 = v21;
            }
            if (v20 > v52) {
              int v52 = v20;
            }
            int v53 = BLEND8_21385[v32];
            unsigned int v50 = v40 - ((v53 & v40) >> v32);
            unsigned int v51 = (v53 & *v52) >> v32;
            goto LABEL_40;
          }
LABEL_41:
          v34 += 2;
          float32_t v54 = *(float *)&_blt_float[v40] * v24;
          v13->f32[0] = v54;
          v13->f32[1] = v54;
          v13->f32[2] = v54;
          v13->f32[3] = v24;
          ++v13;
          if (!--v35) {
            goto LABEL_79;
          }
        }
        float v42 = &v38[v37 >> 4];
        if (v21 < v42) {
          float v42 = v21;
        }
        if (v20 > v42) {
          float v42 = v20;
        }
        unsigned int v43 = *v42;
        if (v32)
        {
          uint64_t v44 = &v38[v31];
          if (v21 >= v44) {
            uint64_t v45 = v44;
          }
          else {
            uint64_t v45 = v21;
          }
          if (v20 > v45) {
            uint64_t v45 = v20;
          }
          unsigned int v46 = *v45;
          uint64_t v47 = &v44[v37 >> 4];
          if (v21 < v47) {
            uint64_t v47 = v21;
          }
          if (v20 > v47) {
            uint64_t v47 = v20;
          }
          int v48 = BLEND8_21385[v32];
          unsigned int v40 = v40 - ((v48 & v40) >> v32) + ((v48 & v46) >> v32);
          unsigned int v43 = v43 - ((v48 & v43) >> v32) + ((v48 & *v47) >> v32);
        }
        int v49 = BLEND8_21385[*v34 & 0xF];
        unsigned int v50 = v40 - ((v49 & v40) >> v41);
        unsigned int v51 = (v49 & v43) >> v41;
LABEL_40:
        LOBYTE(v40) = v50 + v51;
        goto LABEL_41;
      }
LABEL_79:
      v13 += v14;
      v19 += v18;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_79;
    }
    float v55 = (uint64_t *)v92;
    uint64_t v56 = a5;
    while (1)
    {
      uint64_t v57 = *(v55 - 1);
      uint64_t v58 = *v55;
      float v59 = &v33[v57];
      if (v21 >= &v33[v57]) {
        float v60 = &v33[v57];
      }
      else {
        float v60 = v21;
      }
      if (v20 > v60) {
        float v60 = v20;
      }
      unsigned int v61 = *v60;
      char v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        float v63 = &v59[v58 >> 4];
        if (v21 < v63) {
          float v63 = v21;
        }
        if (v20 > v63) {
          float v63 = v20;
        }
        unsigned int v64 = *v63;
        if (v32)
        {
          int v65 = &v59[v31];
          if (v21 >= v65) {
            int v66 = v65;
          }
          else {
            int v66 = v21;
          }
          if (v20 > v66) {
            int v66 = v20;
          }
          unsigned int v67 = *v66;
          float v68 = &v65[v58 >> 4];
          if (v21 < v68) {
            float v68 = v21;
          }
          if (v20 > v68) {
            float v68 = v20;
          }
          int v69 = BLEND8_21385[v32];
          unsigned int v61 = v61 - ((v69 & v61) >> v32) + ((v69 & v67) >> v32);
          unsigned int v64 = v64 - ((v69 & v64) >> v32) + ((v69 & *v68) >> v32);
        }
        int v70 = BLEND8_21385[*v55 & 0xF];
        unsigned int v71 = v61 - ((v70 & v61) >> v62);
        unsigned int v72 = (v70 & v64) >> v62;
      }
      else
      {
        if (!v32) {
          goto LABEL_74;
        }
        float v73 = &v59[v31];
        if (v21 < &v59[v31]) {
          float v73 = v21;
        }
        if (v20 > v73) {
          float v73 = v20;
        }
        int v74 = BLEND8_21385[v32];
        unsigned int v71 = v61 - ((v74 & v61) >> v32);
        unsigned int v72 = (v74 & *v73) >> v32;
      }
      LOBYTE(v61) = v71 + v72;
LABEL_74:
      v75.i32[1] = HIDWORD(_D2);
      v75.i32[0] = _blt_float[v61];
      *(float32x2_t *)a11.unint64_t i8 = vmul_n_f32(v75, v24);
      float32x4_t v76 = (float32x4_t)vzip1q_s32(a11, a11);
      v76.i32[2] = a11.i32[0];
      if (*(float *)&a11.i32[1] >= 1.0) {
        goto LABEL_77;
      }
      if (*(float *)&a11.i32[1] > 0.0)
      {
        float32x4_t v76 = vmlaq_n_f32(v76, *v13, 1.0 - *(float *)&a11.i32[1]);
LABEL_77:
        float32x4_t *v13 = v76;
      }
      v55 += 2;
      ++v13;
      if (!--v56) {
        goto LABEL_79;
      }
    }
  }
  float v77 = (uint64_t *)(v15 + 16 * a3);
  uint64_t result = a5;
  float v78 = fminf(v11, 1.0);
  __asm { FMOV            V2.2S, #1.0 }
  do
  {
    float v80 = &v20[(v19 >> v17) * v16];
    if (LODWORD(v12) != 1)
    {
      float v86 = v77;
      uint64_t v87 = a5;
      if (a5 < 1) {
        goto LABEL_101;
      }
      while (1)
      {
        uint64_t v88 = *v86;
        v86 += 2;
        float v89 = &v80[v88];
        if (v21 < &v80[v88]) {
          float v89 = v21;
        }
        if (v20 > v89) {
          float v89 = v20;
        }
        v90.i32[1] = HIDWORD(_D2);
        v90.i32[0] = _blt_float[*v89];
        *(float32x2_t *)a11.unint64_t i8 = vmul_n_f32(v90, v78);
        float32x4_t v91 = (float32x4_t)vzip1q_s32(a11, a11);
        v91.i32[2] = a11.i32[0];
        if (*(float *)&a11.i32[1] >= 1.0) {
          goto LABEL_99;
        }
        if (*(float *)&a11.i32[1] > 0.0) {
          break;
        }
LABEL_100:
        ++v13;
        if (!--v87) {
          goto LABEL_101;
        }
      }
      float32x4_t v91 = vmlaq_n_f32(v91, *v13, 1.0 - *(float *)&a11.i32[1]);
LABEL_99:
      float32x4_t *v13 = v91;
      goto LABEL_100;
    }
    if (a5 >= 1)
    {
      uint64_t v81 = v77;
      uint64_t v82 = a5;
      do
      {
        uint64_t v83 = *v81;
        v81 += 2;
        uint64_t v84 = &v80[v83];
        if (v21 < &v80[v83]) {
          uint64_t v84 = v21;
        }
        if (v20 > v84) {
          uint64_t v84 = v20;
        }
        float32_t v85 = *(float *)&_blt_float[*v84] * v78;
        v13->f32[0] = v85;
        v13->f32[1] = v85;
        v13->f32[2] = v85;
        v13->f32[3] = v78;
        ++v13;
        --v82;
      }
      while (v82);
    }
LABEL_101:
    v13 += v14;
    v19 += v18;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t RGBAf_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  float v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  signed int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x3000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    float v12 = RGBAf_shade_radial_RGB;
  }
  else if (*(void *)(v5 + 24))
  {
    float v12 = RGBAf_shade_conic_RGB;
  }
  else if (v16 < 2)
  {
    float v12 = RGBAf_shade_axial_RGB;
  }
  else
  {
    float v12 = RGBAf_shade_custom_RGB;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  RGBAf_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

void RGBAf_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  uint64_t v6 = *(float **)(a1 + 272);
  float v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  float v8 = *(float *)(a1 + 336);
  float v9 = *(float *)(a1 + 344);
  float v10 = *(float *)(a1 + 304);
  float v11 = *(float *)(a1 + 308);
  LODWORD(v12) = *(_DWORD *)(a1 + 320);
  int v13 = *(_DWORD *)(a1 + 324);
  uint64_t v16 = a1 + 144;
  int v14 = *(_DWORD **)(a1 + 144);
  int v15 = *(float32x2_t **)(v16 + 8);
  uint64_t v17 = *(float32x2_t **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v18 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v18 = v6;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  uint64_t v19 = *(void *)(a1 + 40);
  if (v19) {
    unint64_t v21 = *(float **)(a1 + 40);
  }
  else {
    unint64_t v21 = v6;
  }
  if (v5 != 0.0)
  {
    for (unint64_t i = (float *)&v15[1] + 1; ; i += 4)
    {
      LODWORD(v24) = v12;
      if (v7 >= v10)
      {
        LODWORD(v24) = v13;
        if (v7 <= v11) {
          LODWORD(v24) = (int)(float)(v9 * (float)(v7 - v8));
        }
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          char v31 = 0;
          goto LABEL_31;
        }
        float v26 = *v18;
        float32x2_t v29 = vmul_n_f32(*v17, *v18);
        float v30 = *v18 * v17[1].f32[0];
      }
      else
      {
        int v25 = 3 * v24;
        uint64_t v24 = v24;
        if (!v19) {
          uint64_t v24 = 0;
        }
        float v26 = v21[v24];
        uint64_t v27 = (float32x2_t *)(v20 + 4 * v25);
        if (v19) {
          float v28 = v26;
        }
        else {
          float v28 = 1.0;
        }
        float32x2_t v29 = vmul_n_f32(*v27, v28);
        float v30 = v28 * v27[1].f32[0];
      }
      *(float32x2_t *)(i - 3) = v29;
      *(i - 1) = v30;
      *unint64_t i = v26;
      char v31 = -1;
LABEL_31:
      float v7 = v5 + v7;
      *(unsigned char *)int v14 = v31;
      int v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v7 >= v10)
  {
    LODWORD(v12) = v13;
    if (v7 <= v11) {
      LODWORD(v12) = (int)(float)(v9 * (float)(v7 - v8));
    }
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      float v33 = *v18;
      float32x2_t v35 = vmul_n_f32(*v17, *v18);
      float v36 = *v18 * v17[1].f32[0];
    }
    else
    {
      int v32 = (float32x2_t *)(v20 + 12 * v12);
      uint64_t v12 = v12;
      if (!v19) {
        uint64_t v12 = 0;
      }
      float v33 = v21[v12];
      float v34 = 1.0;
      if (v19) {
        float v34 = v21[v12];
      }
      float32x2_t v35 = vmul_n_f32(*v32, v34);
      float v36 = v34 * v32[1].f32[0];
    }
    int v37 = a4 + 4;
    do
    {
      *int v15 = v35;
      v15[1].f32[0] = v36;
      v15[1].f32[1] = v33;
      v15[2] = v35;
      v15[3].f32[0] = v36;
      v15[3].f32[1] = v33;
      v15[4] = v35;
      v15[5].f32[0] = v36;
      v15[5].f32[1] = v33;
      v15[6] = v35;
      v37 -= 4;
      v15[7].f32[0] = v36;
      v15[7].f32[1] = v33;
      v15 += 8;
      *v14++ = -1;
    }
    while (v37 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v22 = 4;
    }
    else {
      int v22 = a4;
    }
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t RGBAf_shade_custom_RGB(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6 = *(void *)(result + 272);
  float v7 = *(float *)(v6 + 4);
  float v8 = v7 * (float)a2;
  float v9 = v7 * (float)a3;
  float32x2_t v10 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.unint64_t i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), v9), v10, v8));
  float32x4_t v11 = *(float32x4_t *)(result + 304);
  float v12 = *(float *)(result + 336);
  float v13 = *(float *)(result + 348);
  float v14 = *(float *)(result + 344);
  float v15 = *(float *)(result + 356);
  uint64_t v16 = *(char **)(result + 144);
  uint64_t v17 = *(float32x2_t **)(result + 384);
  uint64_t v18 = *(float **)(result + 392);
  if (!v18) {
    uint64_t v18 = *(float **)(result + 272);
  }
  uint64_t v19 = *(void *)(result + 32);
  uint64_t v20 = *(void *)(result + 40);
  if (v20) {
    int v21 = *(_DWORD *)(result + 48);
  }
  else {
    int v21 = 0;
  }
  if (v20) {
    uint64_t v6 = *(void *)(result + 40);
  }
  int v22 = 3 * *(_DWORD *)(result + 48);
  int v23 = (float *)(*(void *)(result + 152) + 12);
  do
  {
    float32x4_t v24 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v11, v24))), vmovn_s32(vcgtq_f32(v24, v11))), 0xFuLL))) & 1) == 0)
    {
      int v28 = (int)(float)(v15 * (float)(*(float *)&a6.i32[1] - v13));
      float v29 = v14 * (float)(*(float *)a6.i32 - v12);
      uint64_t v30 = v19 + 4 * v22 * v28;
      int v31 = 3 * (int)v29;
      uint64_t v32 = v6 + 4 * v21 * v28;
      uint64_t result = (int)v29;
      if (!v20) {
        uint64_t result = 0;
      }
      float v25 = *(float *)(v32 + 4 * result);
      float v33 = (float32x2_t *)(v30 + 4 * v31);
      if (v20) {
        float v34 = v25;
      }
      else {
        float v34 = 1.0;
      }
      float32x2_t v26 = vmul_n_f32(*v33, v34);
      float v27 = v34 * v33[1].f32[0];
      goto LABEL_18;
    }
    if (v17)
    {
      float v25 = *v18;
      float32x2_t v26 = vmul_n_f32(*v17, *v18);
      float v27 = *v18 * v17[1].f32[0];
LABEL_18:
      *(float32x2_t *)(v23 - 3) = v26;
      *(v23 - 1) = v27;
      *int v23 = v25;
      char v35 = -1;
      goto LABEL_20;
    }
    char v35 = 0;
LABEL_20:
    *(float32x2_t *)a6.unint64_t i8 = vadd_f32(v10, *(float32x2_t *)a6.i8);
    *v16++ = v35;
    v23 += 4;
    --a4;
  }
  while (a4);
  return result;
}

void RGBAf_shade_conic_RGB(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float32x4_t v11 = (float32x2_t *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  do
  {
    __n128 v32 = a6;
    float v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    LODWORD(v18) = vcvtms_s32_f32(v17);
    float v19 = ceilf(v17);
    unsigned int v20 = vcvtms_s32_f32(v9 + v17);
    if (v17 < 0.0) {
      LODWORD(v18) = v20;
    }
    float v21 = ceilf(v17 - v9);
    if (v17 > v9) {
      float v19 = v21;
    }
    LODWORD(v22) = (int)v19;
    int v23 = (float32x2_t *)(*(void *)&v13 + 12 * v18);
    uint64_t v18 = (int)v18;
    if (!*(void *)&v14) {
      uint64_t v18 = 0;
    }
    float v24 = *(float *)(*(void *)&v15 + 4 * v18);
    float v25 = v23[1].f32[0];
    float32x2_t v26 = (float32x2_t *)(*(void *)&v13 + 12 * v22);
    uint64_t v22 = (int)v22;
    if (!*(void *)&v14) {
      uint64_t v22 = 0;
    }
    float v27 = *(float *)(*(void *)&v15 + 4 * v22);
    float32x2_t v28 = *v23;
    float32x2_t v29 = *v26;
    float v30 = v26[1].f32[0];
    if (v14)
    {
      float32x2_t v28 = vmul_n_f32(v28, v24);
      float v25 = v24 * v25;
      float32x2_t v29 = vmul_n_f32(v29, v27);
      float v30 = v27 * v30;
    }
    a6.n128_u64[1] = v32.n128_u64[1];
    float v31 = v17 - (float)(int)floorf(v17);
    *float32x4_t v11 = vmla_n_f32(v28, vsub_f32(v29, v28), v31);
    v11[1].f32[0] = v25 + (float)(v31 * (float)(v30 - v25));
    v11[1].f32[1] = v24 + (float)(v31 * (float)(v27 - v24));
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v32.n128_u64[0]);
    *v12++ = -1;
    v11 += 2;
    --a4;
  }
  while (a4);
}

void RGBAf_shade_radial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(float **)(a1 + 400);
  float v7 = *(float *)(a1 + 280);
  float v8 = *(float *)(a1 + 284);
  float v9 = *(float **)(a1 + 272);
  float v10 = v9[1];
  float v11 = v10 * (float)a2;
  float v12 = v10 * (float)a3;
  float v13 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v12) + (float)(v7 * v11));
  float v14 = *(float *)(a1 + 300) + (float)((float)(v12 * *(float *)(a1 + 292)) + (float)(v8 * v11));
  float v15 = *(float *)(a1 + 336);
  float v16 = *(float *)(a1 + 344);
  float v17 = *(float *)(a1 + 304);
  float v18 = *(float *)(a1 + 308);
  uint64_t v19 = *(unsigned int *)(a1 + 324);
  float v20 = v6[2];
  float v21 = v6[4];
  float v22 = v6[5];
  float v23 = v6[7];
  uint64_t v26 = a1 + 144;
  float v24 = *(char **)(a1 + 144);
  float v25 = *(float32x2_t **)(v26 + 8);
  float v27 = *(float32x2_t **)(a1 + 384);
  float32x2_t v28 = *(float **)(a1 + 392);
  if (!v28) {
    float32x2_t v28 = v9;
  }
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30) {
    float v9 = *(float **)(a1 + 40);
  }
  if (v20 != 0.0 || v23 != 0.0 || v8 != 0.0)
  {
    int v34 = *(_DWORD *)(a1 + 320);
    float v35 = v6[3];
    float v36 = v6[8];
    float v37 = -v6[6];
    float v38 = v18 - v17;
    for (unint64_t i = (float *)&v25[1] + 1; ; i += 4)
    {
      float v40 = v37 + (float)((float)(v13 + v13) * v20);
      float v41 = (float)((float)(v14 * v14) + (float)(v13 * v13)) - v23;
      if (v22 == 0.0)
      {
        float v48 = v41 / v40;
      }
      else
      {
        float v42 = (float)((float)(v22 * -4.0) * v41) + (float)(v40 * v40);
        if (v42 < 0.0) {
          goto LABEL_48;
        }
        float v43 = sqrtf(v42);
        float v44 = v36 * (float)(v40 - v43);
        float v45 = v40 + v43;
        float v46 = v36 * v45;
        BOOL v47 = (float)(v36 * v45) <= v44;
        if ((float)(v36 * v45) <= v44) {
          float v48 = v36 * v45;
        }
        else {
          float v48 = v44;
        }
        if (v47) {
          float v46 = v44;
        }
        if (v46 < 0.0)
        {
          _NF = v46 < v35;
LABEL_29:
          LODWORD(v50) = v34;
          if (_NF) {
            goto LABEL_48;
          }
LABEL_30:
          if ((v50 & 0x80000000) == 0) {
            goto LABEL_42;
          }
          goto LABEL_48;
        }
        if (v46 <= 1.0)
        {
          float v51 = v17 + (float)(v46 * v38);
          goto LABEL_41;
        }
        if ((v19 & 0x80000000) == 0)
        {
          LODWORD(v50) = v19;
          if (v46 <= v21)
          {
LABEL_42:
            int v52 = 3 * v50;
            uint64_t v50 = v50;
            if (!v30) {
              uint64_t v50 = 0;
            }
            float v53 = v9[v50];
            float32_t v54 = (float32x2_t *)(v29 + 4 * v52);
            if (v30) {
              float v55 = v53;
            }
            else {
              float v55 = 1.0;
            }
            float32x2_t v56 = vmul_n_f32(*v54, v55);
            float v57 = v55 * v54[1].f32[0];
            goto LABEL_50;
          }
        }
      }
      if (v48 < 0.0)
      {
        _NF = v48 < v35;
        goto LABEL_29;
      }
      if (v48 > 1.0)
      {
        LODWORD(v50) = v19;
        if (v48 > v21) {
          goto LABEL_48;
        }
        goto LABEL_30;
      }
      float v51 = v17 + (float)(v48 * v38);
LABEL_41:
      LODWORD(v50) = (int)(float)(v16 * (float)(v51 - v15));
      if ((v50 & 0x80000000) == 0) {
        goto LABEL_42;
      }
LABEL_48:
      if (!v27)
      {
        char v58 = 0;
        goto LABEL_52;
      }
      float v53 = *v28;
      float32x2_t v56 = vmul_n_f32(*v27, *v28);
      float v57 = *v28 * v27[1].f32[0];
LABEL_50:
      *(float32x2_t *)(i - 3) = v56;
      *(i - 1) = v57;
      *unint64_t i = v53;
      char v58 = -1;
LABEL_52:
      float v13 = v7 + v13;
      float v14 = v8 + v14;
      *v24++ = v58;
      if (!--a4) {
        return;
      }
    }
  }
  float v31 = v14 * v14;
  float v32 = -v22;
  if (v31 <= (float)-v22)
  {
    float v59 = fabsf(v6[8]);
    float v60 = v22 * -4.0;
    float v61 = v18 - v17;
    char v62 = (float32x2_t *)(v29 + 12 * (int)v19);
    if (v30) {
      uint64_t v63 = v19;
    }
    else {
      uint64_t v63 = 0;
    }
    int v64 = a4 + 2;
    __asm { FMOV            V19.2S, #1.0 }
    while (1)
    {
      float v69 = v31 + (float)(v13 * v13);
      float v70 = v7 + v13;
      float v71 = v31 + (float)(v70 * v70);
      if (v69 > v32 && v71 > v32)
      {
        if ((v19 & 0x80000000) != 0)
        {
          if (!v27)
          {
            char v97 = 0;
            char v96 = 0;
            goto LABEL_92;
          }
          float v80 = *v28;
          float32x2_t v82 = vmul_n_f32(*v27, *v28);
          float v83 = *v28 * v27[1].f32[0];
        }
        else
        {
          float v80 = v9[v63];
          if (v30) {
            float v81 = v9[v63];
          }
          else {
            float v81 = 1.0;
          }
          float32x2_t v82 = vmul_n_f32(*v62, v81);
          float v83 = v81 * v62[1].f32[0];
        }
        *float v25 = v82;
        v25[1].f32[0] = v83;
        v25[1].f32[1] = v80;
        goto LABEL_90;
      }
      float v73 = sqrtf(v60 * v71);
      float v74 = v59 * sqrtf(v60 * v69);
      float v75 = v59 * v73;
      uint64_t v76 = (int)(float)(v16 * (float)((float)(v17 + (float)(v74 * v61)) - v15));
      uint64_t v77 = (int)(float)(v16 * (float)((float)(v17 + (float)((float)(v59 * v73) * v61)) - v15));
      if (v74 <= 1.0 && v75 <= 1.0)
      {
        uint64_t v84 = (int)v76;
        if (!v30) {
          uint64_t v84 = 0;
        }
        *(float *)v4.unint64_t i32 = v9[v84];
        float32x2_t v85 = (float32x2_t)vbsl_s8((int8x8_t)vceqd_s64(v30, 0), _D19, (int8x8_t)vdup_lane_s32(v4, 0));
        float v86 = (float32x2_t *)(v29 + 12 * v76);
        float32x2_t v87 = *v86;
        float v88 = v86[1].f32[0];
        uint64_t v89 = (int)v77;
        if (v30) {
          float v90 = v9[v84];
        }
        else {
          float v90 = 1.0;
        }
        float v91 = v88 * v90;
        float32x2_t v92 = vmul_f32(v87, v85);
        int v93 = (float32x2_t *)(v29 + 12 * v77);
        if (!v30) {
          uint64_t v89 = 0;
        }
        float v80 = v9[v89];
        float v94 = v93[1].f32[0];
        if (v30) {
          float v95 = v9[v89];
        }
        else {
          float v95 = 1.0;
        }
        float32x2_t v82 = vmul_n_f32(*v93, v95);
        *float v25 = v92;
        float v83 = v95 * v94;
        v25[1].f32[0] = v91;
        v25[1].i32[1] = v4.i32[0];
LABEL_90:
        char v96 = -1;
        goto LABEL_91;
      }
      if (v74 <= 1.0)
      {
        if ((v76 & 0x80000000) == 0)
        {
          uint64_t v79 = 3 * (int)v76;
          if (!v30) {
            uint64_t v76 = 0;
          }
LABEL_97:
          float32x4_t v98 = (float32x2_t *)(v29 + 4 * v79);
          float v99 = v9[v76];
          if (v30) {
            float v100 = v9[v76];
          }
          else {
            float v100 = 1.0;
          }
          int32x2_t v4 = (int32x2_t)vmul_n_f32(*v98, v100);
          float v101 = v100 * v98[1].f32[0];
          goto LABEL_103;
        }
      }
      else if (v74 <= v21)
      {
        uint64_t v76 = v63;
        uint64_t v79 = 3 * (int)v19;
        if ((v19 & 0x80000000) == 0) {
          goto LABEL_97;
        }
      }
      if (!v27)
      {
        char v96 = 0;
        goto LABEL_104;
      }
      float v99 = *v28;
      int32x2_t v4 = (int32x2_t)vmul_n_f32(*v27, *v28);
      float v101 = *v28 * v27[1].f32[0];
LABEL_103:
      *float v25 = (float32x2_t)v4;
      char v96 = -1;
      v25[1].f32[0] = v101;
      v25[1].f32[1] = v99;
LABEL_104:
      if (v75 <= 1.0)
      {
        if ((v77 & 0x80000000) != 0) {
          goto LABEL_115;
        }
        uint64_t v102 = 3 * (int)v77;
        if (!v30) {
          uint64_t v77 = 0;
        }
      }
      else if (v75 > v21 || (uint64_t v77 = v63, v102 = 3 * (int)v19, (v19 & 0x80000000) != 0))
      {
LABEL_115:
        if (!v27)
        {
          char v97 = 0;
          goto LABEL_92;
        }
        float v80 = *v28;
        float32x2_t v82 = vmul_n_f32(*v27, *v28);
        float v83 = *v28 * v27[1].f32[0];
        goto LABEL_91;
      }
      float32x4_t v103 = (float32x2_t *)(v29 + 4 * v102);
      float v80 = v9[v77];
      if (v30) {
        float v104 = v9[v77];
      }
      else {
        float v104 = 1.0;
      }
      float32x2_t v82 = vmul_n_f32(*v103, v104);
      float v83 = v104 * v103[1].f32[0];
LABEL_91:
      v25[2] = v82;
      char v97 = -1;
      v25[3].f32[0] = v83;
      v25[3].f32[1] = v80;
LABEL_92:
      float v13 = v7 + v70;
      v25 += 4;
      *float v24 = v96;
      v24[1] = v97;
      v24 += 2;
      v64 -= 2;
      if (v64 <= 2) {
        return;
      }
    }
  }
  if (v27 || (v19 & 0x80000000) == 0)
  {
    if ((v19 & 0x80000000) != 0)
    {
      float v106 = *v28;
      float32x2_t v109 = vmul_n_f32(*v27, *v28);
      float v108 = *v28 * v27[1].f32[0];
    }
    else
    {
      unsigned int v105 = (float32x2_t *)(v29 + 12 * v19);
      if (!v30) {
        uint64_t v19 = 0;
      }
      float v106 = v9[v19];
      float v107 = 1.0;
      if (v30) {
        float v107 = v9[v19];
      }
      float v108 = v107 * v105[1].f32[0];
      float32x2_t v109 = vmul_n_f32(*v105, v107);
    }
    int v110 = a4 + 4;
    do
    {
      *float v25 = v109;
      v25[1].f32[0] = v108;
      v25[1].f32[1] = v106;
      v25[2] = v109;
      v25[3].f32[0] = v108;
      v25[3].f32[1] = v106;
      v25[4] = v109;
      v25[5].f32[0] = v108;
      v25[5].f32[1] = v106;
      v25[6] = v109;
      v110 -= 4;
      v25[7].f32[0] = v108;
      v25[7].f32[1] = v106;
      v25 += 8;
      *(_DWORD *)float v24 = -1;
      v24 += 4;
    }
    while (v110 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v33 = 4;
    }
    else {
      int v33 = a4;
    }
    bzero(v24, ((a4 - v33 + 3) & 0xFFFFFFFC) + 4);
  }
}

int8x16_t *RGBAF_pattern(uint64_t a1, int8x16_t *a2, unsigned int a3, int a4, uint64_t a5, float a6, double a7, double a8, double a9, double a10, int8x16_t a11)
{
  float v14 = *(unsigned __int32 **)(*(void *)a1 + 64);
  a11.i32[0] = *v14;
  LODWORD(a10) = v14[1];
  if (a2 && a3 > 0xF
    || (unint64_t v22 = a11.i64[0],
        double v23 = a10,
        float v15 = (int8x16_t *)malloc_type_malloc(0x40uLL, 0x705560E0uLL),
        a11.i64[0] = v22,
        a10 = v23,
        (a2 = v15) != 0))
  {
    if (*(float *)a11.i32 <= a6) {
      float v16 = a6;
    }
    else {
      float v16 = *(float *)a11.i32;
    }
    if (*(float *)&a10 < a6) {
      float v16 = *(float *)&a10;
    }
    if (a5) {
      int v17 = a4;
    }
    else {
      int v17 = 0;
    }
    switch(v17)
    {
      case 1:
        *(float *)a11.unint64_t i32 = v16 * *(float *)a5;
        break;
      case 4:
        LODWORD(a7) = *(_DWORD *)(a5 + 16);
        *(float *)a11.unint64_t i32 = v16 * (float)((float)(*(float *)&a10 - *(float *)a5) - *(float *)&a7);
        float32x2_t v18 = vsub_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a10, 0), *(float32x2_t *)(a5 + 4)), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0));
        goto LABEL_19;
      case 3:
        *(float *)a11.unint64_t i32 = v16 * *(float *)a5;
        float32x2_t v18 = *(float32x2_t *)(a5 + 4);
LABEL_19:
        float32x2_t v19 = vmul_n_f32(v18, v16);
        goto LABEL_20;
    }
    float32x2_t v19 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a11.i8, 0);
LABEL_20:
    *a2 = (int8x16_t)xmmword_1850CDBE0;
    a2[1].i32[2] = 0;
    a2[1].i64[0] = 1;
    a11.i32[1] = v19.i32[0];
    a11.i64[1] = __PAIR64__(LODWORD(v16), v19.u32[1]);
    a2[3] = vrev32q_s8(a11);
    if (v16 >= *(float *)&a10) {
      float v20 = 0;
    }
    else {
      float v20 = a2 + 3;
    }
    a2[2].i64[0] = (uint64_t)a2[3].i64;
    a2[2].i64[1] = (uint64_t)v20;
  }
  return a2;
}

uint64_t RGBAF_mark(uint64_t a1, __n128 a2)
{
  return RGBAF_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t RGBAF_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v732 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = *(void *)(v3 + 96);
  uint64_t v18 = *(void *)(v3 + 48);
  uint64_t v19 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v17 == 0) + 4 * (v18 == 0));
  if ((int)v19 > 27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v21 = v3;
  unint64_t v22 = *(unsigned int *)(v3 + 4);
  unsigned int v23 = v22 - 1;
  if ((int)v22 < 1) {
    return 0;
  }
  int v24 = *(_DWORD *)(v3 + 8);
  uint64_t v25 = (v24 - 1);
  if (v24 < 1) {
    return 0;
  }
  uint64_t v26 = *(uint16x4_t **)(v3 + 136);
  uint64_t v692 = v3;
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v26)
  {
    int v28 = *(_DWORD *)v3 & 0xFF00;
    if (v28 == 1024)
    {
      v731[0] = *(_DWORD *)(v3 + 4);
      v721[0] = v24;
      uint64_t v29 = *(void *)(v3 + 40);
      int8x16_t v718 = *(int8x16_t *)*(void *)(v3 + 88);
      float32x4_t v30 = (float32x4_t)vrev32q_s8(v718);
      float v31 = v30.f32[3];
      *(float *)v12.unint64_t i32 = 1.0 - v30.f32[3];
      unint64_t v711 = *(int *)(v3 + 28);
      unint64_t v32 = v711 >> 4;
      unint64_t v33 = *(int *)(v3 + 12) + (v711 >> 4) * *(int *)(v3 + 16);
      uint64_t v34 = v29 + 16 * v33;
      uint64_t v714 = v12.i64[0];
      float32x4_t v716 = v30;
      if (v26)
      {
        shape_enum_clip_alloc(v22, v3, (int *)v26, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v22, v24);
        float v36 = v35;
        if (v35) {
          goto LABEL_895;
        }
        return 1;
      }
      float v36 = 0;
      float v57 = (int8x16_t *)(v29 + 16 * v33);
LABEL_635:
      unint64_t v498 = v32 - (int)v22;
      unint64_t v499 = v22;
      switch((int)v19)
      {
        case 0:
          unsigned int v500 = v721[0];
          int v501 = 16 * v22;
          goto LABEL_898;
        case 1:
          uint64_t v502 = *(void *)(v692 + 88);
          if (v502)
          {
            CGSFillDRAM64((unint64_t)v57, v711 & 0xFFFFFFF0, 16 * v22, v721[0], v502, 16, 16, 1, 0, 0);
            if (v36) {
              goto LABEL_894;
            }
          }
          else
          {
            int v501 = 16 * v22;
            unsigned int v500 = v721[0];
LABEL_898:
            CGBlt_fillBytes(v501, v500, 0, v57->i8, v711 & 0xFFFFFFF0);
            if (v36) {
              goto LABEL_894;
            }
          }
          return 1;
        case 2:
          float32x4_t v503 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.i8, 0);
          int v504 = v721[0];
          do
          {
            if ((int)v22 < 4)
            {
              int v508 = v22;
            }
            else
            {
              unsigned int v505 = (v22 >> 2) + 1;
              do
              {
                int8x16_t v506 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v503, (float32x4_t)vrev32q_s8(v57[1])));
                *float v57 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v503, (float32x4_t)vrev32q_s8(*v57)));
                v57[1] = v506;
                int8x16_t v507 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v503, (float32x4_t)vrev32q_s8(v57[3])));
                v57[2] = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v503, (float32x4_t)vrev32q_s8(v57[2])));
                v57[3] = v507;
                v57 += 4;
                --v505;
              }
              while (v505 > 1);
              int v508 = v22 & 3;
            }
            if (v508 >= 1)
            {
              unsigned int v509 = v508 + 1;
              do
              {
                *float v57 = vrev32q_s8((int8x16_t)vmlaq_f32(v30, v503, (float32x4_t)vrev32q_s8(*v57)));
                ++v57;
                --v509;
              }
              while (v509 > 1);
            }
            v57 += v498;
            --v504;
          }
          while (v504);
          goto LABEL_892;
        case 3:
          int v510 = v721[0];
          do
          {
            int v511 = v22;
            do
            {
              float v512 = COERCE_FLOAT(bswap32(v57->u32[3]));
              if (v512 <= 0.0)
              {
                v57->i64[0] = 0;
                v57->i64[1] = 0;
              }
              else
              {
                if (v512 >= 1.0) {
                  int8x16_t v513 = v718;
                }
                else {
                  int8x16_t v513 = vrev32q_s8((int8x16_t)vmulq_n_f32(v30, v512));
                }
                *float v57 = v513;
              }
              ++v57;
              --v511;
            }
            while (v511);
            v57 += v498;
            --v510;
          }
          while (v510);
          goto LABEL_892;
        case 4:
          int v514 = v721[0];
          do
          {
            int v515 = v22;
            do
            {
              float v516 = 1.0 - COERCE_FLOAT(bswap32(v57->u32[3]));
              if (v516 <= 0.0)
              {
                v57->i64[0] = 0;
                v57->i64[1] = 0;
              }
              else
              {
                if (v516 >= 1.0) {
                  int8x16_t v517 = v718;
                }
                else {
                  int8x16_t v517 = vrev32q_s8((int8x16_t)vmulq_n_f32(v30, v516));
                }
                *float v57 = v517;
              }
              ++v57;
              --v515;
            }
            while (v515);
            v57 += v498;
            --v514;
          }
          while (v514);
          goto LABEL_892;
        case 5:
          int v518 = v721[0];
          do
          {
            int v519 = v22;
            do
            {
              float32x4_t v520 = (float32x4_t)vrev32q_s8(*v57);
              *v57++ = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v520, *(float *)v12.i32), v30, v520, 3));
              --v519;
            }
            while (v519);
            v57 += v498;
            --v518;
          }
          while (v518);
          goto LABEL_892;
        case 6:
          int v521 = v721[0];
          while (1)
          {
            int v522 = v22;
            do
            {
              float v523 = COERCE_FLOAT(bswap32(v57->u32[3]));
              float v524 = 1.0 - v523;
              if ((float)(1.0 - v523) >= 1.0)
              {
                v57->i64[0] = v718.i64[0];
                v57->i32[2] = v718.i32[2];
                unsigned int v526 = v718.u32[3];
              }
              else
              {
                if (v524 <= 0.0) {
                  goto LABEL_685;
                }
                unsigned int v525 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v57->u32[2])) + (float)(v30.f32[2] * v524)));
                unsigned int v526 = bswap32(COERCE_UNSIGNED_INT(v523 + (float)(v31 * v524)));
                *(int8x8_t *)v57->unint64_t i8 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v57->i8), *(float32x2_t *)v30.f32, v524));
                v57->i32[2] = v525;
              }
              v57->i32[3] = v526;
LABEL_685:
              ++v57;
              --v522;
            }
            while (v522);
            v57 += v498;
            if (!--v521) {
              goto LABEL_892;
            }
          }
        case 7:
          int v527 = v721[0];
          do
          {
            int v528 = v22;
            do
            {
              *float v57 = vrev32q_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vrev32q_s8(*v57), v30, 3));
              ++v57;
              --v528;
            }
            while (v528);
            v57 += v498;
            --v527;
          }
          while (v527);
          goto LABEL_892;
        case 8:
          int v529 = v721[0];
          do
          {
            int v530 = v22;
            do
            {
              *float v57 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v57), *(float *)v12.i32));
              ++v57;
              --v530;
            }
            while (v530);
            v57 += v498;
            --v529;
          }
          while (v529);
          goto LABEL_892;
        case 9:
          int v531 = v721[0];
          do
          {
            int v532 = v22;
            do
            {
              float32x4_t v533 = (float32x4_t)vrev32q_s8(*v57);
              *v57++ = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_laneq_f32(v533, v30, 3), v30, 1.0 - v533.f32[3]));
              --v532;
            }
            while (v532);
            v57 += v498;
            --v531;
          }
          while (v531);
          goto LABEL_892;
        case 10:
          int v534 = v721[0];
          do
          {
            int v535 = v22;
            do
            {
              float32x4_t v536 = (float32x4_t)vrev32q_s8(*v57);
              *v57++ = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v536, *(float *)v12.i32), v30, 1.0 - v536.f32[3]));
              --v535;
            }
            while (v535);
            v57 += v498;
            --v534;
          }
          while (v534);
          goto LABEL_892;
        case 11:
          float32x2_t v537 = vsub_f32((float32x2_t)vdup_laneq_s32((int32x4_t)v30, 3), *(float32x2_t *)v30.f32);
          int v538 = v721[0];
          do
          {
            int v539 = v22;
            do
            {
              if (v18) {
                v12.i32[0] = bswap32(v57->u32[3]);
              }
              else {
                v12.i32[0] = 1.0;
              }
              float v540 = *(float *)v12.i32 + v31;
              float32x2_t v541 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v57->i8));
              float v542 = (float)(v31 - v30.f32[2]) + (float)(*(float *)v12.i32 - COERCE_FLOAT(bswap32(v57->u32[2])));
              if (v540 <= 1.0) {
                *(float *)&double v14 = v540;
              }
              else {
                *(float *)&double v14 = 1.0;
              }
              *(float32x2_t *)v543.unint64_t i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v14, 0), vadd_f32(v537, v541));
              *(float *)&v543.i32[2] = *(float *)&v14 - v542;
              v543.i32[3] = LODWORD(v14);
              int8x16_t v12 = vrev32q_s8(v543);
              *v57++ = v12;
              --v539;
            }
            while (v539);
            v57 += v498;
            --v538;
          }
          while (v538);
          goto LABEL_892;
        case 12:
          int v544 = v721[0];
          do
          {
            int v545 = v22;
            do
            {
              float v546 = COERCE_FLOAT(bswap32(v57->u32[2]));
              float v547 = v31 + COERCE_FLOAT(bswap32(v57->u32[3]));
              *(float32x2_t *)v548.unint64_t i8 = vadd_f32(*(float32x2_t *)v30.f32, (float32x2_t)vrev32_s8(*(int8x8_t *)v57->i8));
              if (v547 > 1.0) {
                float v547 = 1.0;
              }
              v548.i64[1] = __PAIR64__(LODWORD(v547), v30.f32[2] + v546);
              *v57++ = vrev32q_s8(v548);
              --v545;
            }
            while (v545);
            v57 += v498;
            --v544;
          }
          while (v544);
          goto LABEL_892;
        case 13:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v549 = v30.i32[2];
          int v550 = v721[0];
          while (1)
          {
            int v551 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v552 = 1.0;
LABEL_733:
                int8x8_t v554 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v554.i32[1];
                *(float *)v555.unint64_t i32 = PDAmultiplyPDA(*(float *)v554.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v552, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v549)), v31);
                v30.i32[0] = v716.i32[0];
                v555.i32[1] = v10.i32[0];
                v555.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v553 = vrev32q_s8(v555);
                goto LABEL_734;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v552 = *(float *)v12.i32;
              int8x16_t v553 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_733;
              }
LABEL_734:
              *v57++ = v553;
              --v551;
            }
            while (v551);
            v57 += v498;
            --v550;
            LODWORD(v22) = v499;
            if (!v550) {
              goto LABEL_892;
            }
          }
        case 14:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          int v556 = v721[0];
          __asm { FMOV            V0.2S, #1.0 }
          int8x16_t v558 = vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL);
          while (1)
          {
            int v559 = v22;
            do
            {
              if (!v18)
              {
                float v560 = 1.0;
LABEL_744:
                LODWORD(v562) = bswap32(v57->u32[2]);
                *(int8x8_t *)v563.f32 = vrev32_s8(*(int8x8_t *)v57->i8);
                *(float32x2_t *)v564.f32 = vsub_f32(_D0, *(float32x2_t *)v563.f32);
                float32x4_t v565 = v30;
                v565.f32[3] = -v560;
                v564.i32[3] = v558.i32[1];
                v564.f32[2] = 1.0 - v562;
                v563.i64[1] = __PAIR64__(v560 + v31, LODWORD(v562));
                int8x16_t v561 = vrev32q_s8((int8x16_t)vmlaq_f32(v563, v564, v565));
                goto LABEL_745;
              }
              float v560 = COERCE_FLOAT(bswap32(v57->u32[3]));
              int8x16_t v561 = v718;
              if (v560 > 0.0) {
                goto LABEL_744;
              }
LABEL_745:
              *v57++ = v561;
              --v559;
            }
            while (v559);
            v57 += v498;
            if (!--v556) {
              goto LABEL_892;
            }
          }
        case 15:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v566 = v30.i32[2];
          int v567 = v721[0];
          while (1)
          {
            int v568 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v569 = 1.0;
LABEL_755:
                int8x8_t v571 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v571.i32[1];
                *(float *)v572.unint64_t i32 = PDAoverlayPDA(*(float *)v571.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v569, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v566)), v31);
                v30.i32[0] = v716.i32[0];
                v572.i32[1] = v10.i32[0];
                v572.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v570 = vrev32q_s8(v572);
                goto LABEL_756;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v569 = *(float *)v12.i32;
              int8x16_t v570 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_755;
              }
LABEL_756:
              *v57++ = v570;
              --v568;
            }
            while (v568);
            v57 += v498;
            --v567;
            LODWORD(v22) = v499;
            if (!v567) {
              goto LABEL_892;
            }
          }
        case 16:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v573 = v30.i32[2];
          int v574 = v721[0];
          while (1)
          {
            int v575 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v576 = 1.0;
LABEL_766:
                int8x8_t v578 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v578.i32[1];
                *(float *)v579.unint64_t i32 = PDAdarkenPDA(*(float *)v578.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v576, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v573)), v31);
                v30.i32[0] = v716.i32[0];
                v579.i32[1] = v10.i32[0];
                v579.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v577 = vrev32q_s8(v579);
                goto LABEL_767;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v576 = *(float *)v12.i32;
              int8x16_t v577 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_766;
              }
LABEL_767:
              *v57++ = v577;
              --v575;
            }
            while (v575);
            v57 += v498;
            --v574;
            LODWORD(v22) = v499;
            if (!v574) {
              goto LABEL_892;
            }
          }
        case 17:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v580 = v30.i32[2];
          int v581 = v721[0];
          while (1)
          {
            int v582 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v583 = 1.0;
LABEL_777:
                int8x8_t v585 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v585.i32[1];
                *(float *)v586.unint64_t i32 = PDAlightenPDA(*(float *)v585.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v583, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v580)), v31);
                v30.i32[0] = v716.i32[0];
                v586.i32[1] = v10.i32[0];
                v586.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v584 = vrev32q_s8(v586);
                goto LABEL_778;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v583 = *(float *)v12.i32;
              int8x16_t v584 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_777;
              }
LABEL_778:
              *v57++ = v584;
              --v582;
            }
            while (v582);
            v57 += v498;
            --v581;
            LODWORD(v22) = v499;
            if (!v581) {
              goto LABEL_892;
            }
          }
        case 18:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v587 = v30.i32[2];
          int v588 = v721[0];
          while (1)
          {
            int v589 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v590 = 1.0;
LABEL_788:
                int8x8_t v592 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v592.i32[1];
                *(float *)v593.unint64_t i32 = PDAcolordodgePDA(*(float *)v592.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v590, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v587)), v31);
                v30.i32[0] = v716.i32[0];
                v593.i32[1] = v10.i32[0];
                v593.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v591 = vrev32q_s8(v593);
                goto LABEL_789;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v590 = *(float *)v12.i32;
              int8x16_t v591 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_788;
              }
LABEL_789:
              *v57++ = v591;
              --v589;
            }
            while (v589);
            v57 += v498;
            --v588;
            LODWORD(v22) = v499;
            if (!v588) {
              goto LABEL_892;
            }
          }
        case 19:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v594 = v30.i32[2];
          int v595 = v721[0];
          while (1)
          {
            int v596 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v597 = 1.0;
LABEL_799:
                int8x8_t v599 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v599.i32[1];
                *(float *)v600.unint64_t i32 = PDAcolorburnPDA(*(float *)v599.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v597, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v594)), v31);
                v30.i32[0] = v716.i32[0];
                v600.i32[1] = v10.i32[0];
                v600.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v598 = vrev32q_s8(v600);
                goto LABEL_800;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v597 = *(float *)v12.i32;
              int8x16_t v598 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_799;
              }
LABEL_800:
              *v57++ = v598;
              --v596;
            }
            while (v596);
            v57 += v498;
            --v595;
            LODWORD(v22) = v499;
            if (!v595) {
              goto LABEL_892;
            }
          }
        case 20:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          unsigned int v601 = v30.u32[1];
          __int32 v602 = v30.i32[2];
          int v603 = v721[0];
          while (1)
          {
            int v604 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                v13.n128_u32[0] = 1.0;
LABEL_810:
                int8x8_t v606 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                *(float *)v607.unint64_t i32 = PDAsoftlightPDA(*(float *)v606.i32, *(float *)&v606.i32[1], *(double *)v11.i64, *(int32x2_t *)v12.i8, v13.n128_f64[0], v14, v15, v16, v22, v3, (uint64_t)v26, v4, v5, v6, v7, v8, v30.f32[0], v601, __SPAIR64__(LODWORD(v31), v602),
                                       v31);
                v30.i32[0] = v716.i32[0];
                v607.i32[1] = v608;
                v607.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v605 = vrev32q_s8(v607);
                goto LABEL_811;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              v13.n128_u32[0] = v12.i32[0];
              int8x16_t v605 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_810;
              }
LABEL_811:
              *v57++ = v605;
              --v604;
            }
            while (v604);
            v57 += v498;
            --v603;
            unint64_t v22 = v499;
            if (!v603) {
              goto LABEL_892;
            }
          }
        case 21:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          __int32 v609 = v30.i32[2];
          int v610 = v721[0];
          while (1)
          {
            int v611 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v612 = 1.0;
LABEL_821:
                int8x8_t v614 = vrev32_s8(*(int8x8_t *)v57->i8);
                v11.i32[0] = bswap32(v57->u32[2]);
                v10.i32[0] = v614.i32[1];
                *(float *)v615.unint64_t i32 = PDAhardlightPDA(*(float *)v614.i32, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v612, v14, v15, v16, v30.f32[0], COERCE_DOUBLE(__PAIR64__(LODWORD(v31), v609)), v31);
                v30.i32[0] = v716.i32[0];
                v615.i32[1] = v10.i32[0];
                v615.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                int8x16_t v613 = vrev32q_s8(v615);
                goto LABEL_822;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v612 = *(float *)v12.i32;
              int8x16_t v613 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_821;
              }
LABEL_822:
              *v57++ = v613;
              --v611;
            }
            while (v611);
            v57 += v498;
            --v610;
            LODWORD(v22) = v499;
            if (!v610) {
              goto LABEL_892;
            }
          }
        case 22:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          int v616 = v721[0];
          while (1)
          {
            int v617 = v22;
            do
            {
              if (v18)
              {
                float v618 = COERCE_FLOAT(bswap32(v57->u32[3]));
                int8x16_t v619 = v718;
                if (v618 <= 0.0) {
                  goto LABEL_835;
                }
              }
              else
              {
                float v618 = 1.0;
              }
              float v620 = COERCE_FLOAT(bswap32(v57->u32[2]));
              float32x2_t v621 = (float32x2_t)vrev32_s8(*(int8x8_t *)v57->i8);
              float32x2_t v622 = vadd_f32(*(float32x2_t *)v30.f32, v621);
              float32x2_t v623 = vmul_laneq_f32(v621, v30, 3);
              float32x2_t v624 = vmul_n_f32(*(float32x2_t *)v30.f32, v618);
              float32x2_t v625 = vsub_f32(v622, v623);
              float32x2_t v626 = vsub_f32(v623, v624);
              *(float32x2_t *)v627.unint64_t i8 = vadd_f32(vsub_f32(v625, v624), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v626), (int8x8_t)vneg_f32(v626), (int8x8_t)v626));
              float v628 = (float)(v31 * v620) - (float)(v30.f32[2] * v618);
              if (v628 < 0.0) {
                float v628 = -v628;
              }
              v627.i64[1] = __PAIR64__((float)(v618 + v31) - (float)(v618 * v31), (float)((float)((float)(v30.f32[2] + v620) - (float)(v31 * v620))- (float)(v30.f32[2] * v618))+ v628);
              int8x16_t v619 = vrev32q_s8(v627);
LABEL_835:
              *v57++ = v619;
              --v617;
            }
            while (v617);
            v57 += v498;
            if (!--v616) {
              goto LABEL_892;
            }
          }
        case 23:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          float32x2_t v629 = (float32x2_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL).u64[0];
          int v630 = v721[0];
          while (1)
          {
            int v631 = v22;
            do
            {
              if (v18)
              {
                LODWORD(v632) = bswap32(v57->u32[3]);
                if (v632 <= 0.0)
                {
                  *float v57 = v718;
                  goto LABEL_846;
                }
              }
              else
              {
                float v632 = 1.0;
              }
              LODWORD(v633) = bswap32(v57->u32[2]);
              v634.f32[0] = -(float)(v633 * v30.f32[2]);
              float32x2_t v635 = (float32x2_t)vrev32_s8(*(int8x8_t *)v57->i8);
              v634.f32[1] = -v632;
              *(int8x8_t *)v57->unint64_t i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v30.f32, v635), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v30.f32, v635)));
              v57->u64[1] = (unint64_t)vrev32_s8((int8x8_t)vmla_f32(vadd_f32(v629, (float32x2_t)__PAIR64__(LODWORD(v632), LODWORD(v633))), (float32x2_t)__PAIR64__(v629.u32[1], 2.0), v634));
LABEL_846:
              ++v57;
              --v631;
            }
            while (v631);
            v57 += v498;
            if (!--v630) {
              goto LABEL_892;
            }
          }
        case 24:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          float v636 = v30.f32[1];
          float v637 = v30.f32[2];
          int v638 = v721[0];
          while (1)
          {
            int v639 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v640 = 1.0;
LABEL_856:
                int8x8_t v642 = vrev32_s8(*(int8x8_t *)v57->i8);
                *(float *)v643.unint64_t i32 = PDAhuePDA(*(float *)v642.i32, *(float *)&v642.i32[1], COERCE_FLOAT(bswap32(v57->u32[2])), *(double *)v12.i64, v640, v14, v15, v16, v30.f32[0], v636, v637, v31, v31);
                v30.i32[0] = v716.i32[0];
                v643.i32[1] = v644;
                v643.i64[1] = __PAIR64__(v12.u32[0], v645);
                int8x16_t v641 = vrev32q_s8(v643);
                goto LABEL_857;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v640 = *(float *)v12.i32;
              int8x16_t v641 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_856;
              }
LABEL_857:
              *v57++ = v641;
              --v639;
            }
            while (v639);
            v57 += v498;
            --v638;
            LODWORD(v22) = v499;
            if (!v638) {
              goto LABEL_892;
            }
          }
        case 25:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          float v646 = v30.f32[1];
          float v647 = v30.f32[2];
          int v648 = v721[0];
          while (1)
          {
            int v649 = v22;
            do
            {
              if (!v18)
              {
                v12.i32[0] = bswap32(v57->u32[3]);
                float v650 = 1.0;
LABEL_867:
                int8x8_t v652 = vrev32_s8(*(int8x8_t *)v57->i8);
                *(float *)v653.unint64_t i32 = PDAsaturationPDA(*(float *)v652.i32, *(float *)&v652.i32[1], COERCE_FLOAT(bswap32(v57->u32[2])), *(double *)v12.i64, v650, v14, v15, v16, v30.f32[0], v646, v647, v31, v31);
                v30.i32[0] = v716.i32[0];
                v653.i32[1] = v654;
                v653.i64[1] = __PAIR64__(v12.u32[0], v655);
                int8x16_t v651 = vrev32q_s8(v653);
                goto LABEL_868;
              }
              v12.i32[0] = bswap32(v57->u32[3]);
              float v650 = *(float *)v12.i32;
              int8x16_t v651 = v718;
              if (*(float *)v12.i32 > 0.0) {
                goto LABEL_867;
              }
LABEL_868:
              *v57++ = v651;
              --v649;
            }
            while (v649);
            v57 += v498;
            --v648;
            LODWORD(v22) = v499;
            if (!v648) {
              goto LABEL_892;
            }
          }
        case 26:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          float v656 = v30.f32[1];
          float v657 = v30.f32[2];
          int v658 = v721[0];
          while (1)
          {
            int v659 = v22;
            do
            {
              if (!v18)
              {
                float v660 = COERCE_FLOAT(bswap32(v57->u32[3]));
                float v661 = 1.0;
LABEL_878:
                int8x8_t v688 = vrev32_s8(*(int8x8_t *)v57->i8);
                *(float *)v12.unint64_t i32 = v31;
                *(float *)v663.unint64_t i32 = PDAluminosityPDA(v30.f32[0], v656, v657, *(double *)v12.i64, v31, v14, v15, v16, *(float *)v688.i32, *(float *)&v688.i32[1], COERCE_FLOAT(bswap32(v57->u32[2])), v660, v661);
                v30.i32[0] = v716.i32[0];
                v663.i32[1] = v664;
                v663.i64[1] = __PAIR64__(v12.u32[0], v665);
                int8x16_t v662 = vrev32q_s8(v663);
                goto LABEL_879;
              }
              float v660 = COERCE_FLOAT(bswap32(v57->u32[3]));
              float v661 = v660;
              int8x16_t v662 = v718;
              if (v660 > 0.0) {
                goto LABEL_878;
              }
LABEL_879:
              *v57++ = v662;
              --v659;
            }
            while (v659);
            v57 += v498;
            --v658;
            LODWORD(v22) = v499;
            if (!v658) {
              goto LABEL_892;
            }
          }
        case 27:
          if (v31 <= 0.0) {
            goto LABEL_893;
          }
          float v666 = v30.f32[1];
          float v667 = v30.f32[2];
          int v668 = v721[0];
          break;
        default:
          goto LABEL_893;
      }
LABEL_884:
      int v669 = v22;
      while (1)
      {
        if (v18)
        {
          v12.i32[0] = bswap32(v57->u32[3]);
          float v670 = *(float *)v12.i32;
          int8x16_t v671 = v718;
          if (*(float *)v12.i32 <= 0.0) {
            goto LABEL_890;
          }
        }
        else
        {
          v12.i32[0] = bswap32(v57->u32[3]);
          float v670 = 1.0;
        }
        int8x8_t v672 = vrev32_s8(*(int8x8_t *)v57->i8);
        *(float *)v673.unint64_t i32 = PDAluminosityPDA(*(float *)v672.i32, *(float *)&v672.i32[1], COERCE_FLOAT(bswap32(v57->u32[2])), *(double *)v12.i64, v670, v14, v15, v16, v30.f32[0], v666, v667, v31, v31);
        v30.i32[0] = v716.i32[0];
        v673.i32[1] = v674;
        v673.i64[1] = __PAIR64__(v12.u32[0], v675);
        int8x16_t v671 = vrev32q_s8(v673);
LABEL_890:
        *v57++ = v671;
        if (!--v669)
        {
          v57 += v498;
          --v668;
          LODWORD(v22) = v499;
          if (!v668)
          {
LABEL_892:
            v721[0] = 0;
LABEL_893:
            if (!v36) {
              return 1;
            }
LABEL_894:
            uint64_t v720 = 0;
LABEL_895:
            if (!shape_enum_clip_next((uint64_t)v36, (int *)&v720 + 1, &v720, v731, v721)) {
              goto LABEL_47;
            }
            float v57 = (int8x16_t *)(v34 + 16 * v32 * (int)v720 + 16 * SHIDWORD(v720));
            unint64_t v22 = v731[0];
            v12.i64[0] = v714;
            float32x4_t v30 = v716;
            goto LABEL_635;
          }
          goto LABEL_884;
        }
      }
    }
    v731[0] = *(_DWORD *)(v3 + 4);
    v721[0] = v24;
    uint64_t v37 = *(void *)(v3 + 88);
    unint64_t v38 = (unint64_t)*(int *)(v3 + 28) >> 4;
    unint64_t v39 = *(void *)(v3 + 40) + 16 * (*(int *)(v3 + 12) + v38 * *(int *)(v3 + 16));
    uint64_t v40 = *(unsigned int *)(v3 + 104);
    uint64_t v41 = *(unsigned int *)(v3 + 108);
    int v42 = *(_DWORD *)(v3 + 56);
    int v43 = *(_DWORD *)(v3 + 60);
    unint64_t v44 = (unint64_t)*(int *)(v3 + 76) >> 4;
    int v689 = v19;
    if (v28 != 256)
    {
      LODWORD(v698) = *(_DWORD *)(v3 + 64);
      uint64_t v695 = *(int *)(v3 + 68);
      unint64_t v717 = v37 + 16 * v44 * v695;
      BOOL v54 = v17 != 0;
      if (v26)
      {
        unint64_t v719 = (unint64_t)*(int *)(v3 + 76) >> 4;
        int v690 = *(_DWORD *)(v3 + 60);
        int v691 = *(_DWORD *)(v3 + 56);
        uint64_t v47 = 1;
        unint64_t v55 = *(void *)(v3 + 88);
        unint64_t v56 = v55;
LABEL_43:
        uint64_t v712 = v47;
        shape_enum_clip_alloc(v22, v3, (int *)v26, v47, v38, 1, v40, v41, v22, v24);
        uint64_t v81 = v80;
        if (!v80) {
          return 1;
        }
        while (2)
        {
          unint64_t v22 = shape_enum_clip_next(v81, (int *)&v720 + 1, &v720, v731, v721);
          if (!v22)
          {
            float32x2_t v82 = (void *)v81;
LABEL_626:
            free(v82);
            return 1;
          }
          uint64_t v696 = v37;
          uint64_t v697 = v81;
          if (v717)
          {
            unint64_t v78 = v39 + 16 * v38 * (int)v720 + 16 * SHIDWORD(v720);
            unint64_t v492 = v37 + 16 * v719 * (((int)v720 + *(_DWORD *)(v21 + 60)) % (int)v695);
            unint64_t v55 = v492 + 16 * ((HIDWORD(v720) + *(_DWORD *)(v21 + 56)) % (int)v698);
            unint64_t v56 = v492 + 16 * (int)v698;
            uint64_t v37 = v55;
            int v713 = v731[0];
            int v493 = v731[0];
            int v690 = ((int)v720 + *(_DWORD *)(v21 + 60)) % (int)v695;
            int v691 = (HIDWORD(v720) + *(_DWORD *)(v21 + 56)) % (int)v698;
          }
          else
          {
            int v713 = v731[0];
            int v493 = v731[0] * v712;
            unint64_t v78 = v39 + 16 * v38 * (int)v720 + 16 * HIDWORD(v720) * (int)v712;
            v37 += 16 * (int)v720 * (int)v698 + 16 * HIDWORD(v720) * (int)v712;
            unint64_t v719 = (int)v698 - v731[0] * (int)v712;
          }
          unint64_t v715 = v38 - v493;
          uint64_t v47 = v712;
LABEL_48:
          uint64_t v712 = v47;
          switch((int)v19)
          {
            case 0:
              unint64_t v83 = v78 - 16 * (v713 - 1);
              uint64_t v84 = v715 + v713;
              if ((int)v47 < 0) {
                uint64_t v84 = v715 - v713;
              }
              else {
                unint64_t v83 = v78;
              }
              float32x2_t v85 = (char *)(v83 + 16 * ((v84 * (v721[0] - 1)) & (v84 >> 63)));
              if (v84 < 0) {
                uint64_t v84 = -v84;
              }
              CGBlt_fillBytes(16 * v713, v721[0], 0, v85, 16 * v84);
              goto LABEL_617;
            case 1:
              int v86 = *(unsigned __int8 *)(v21 + 1);
              if (v86 == 2)
              {
                if (v713 >= 2 && (16 * v698) <= 0x40)
                {
                  LODWORD(v9) = 16 * v698;
                  uint8x8_t v464 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v9);
                  v464.i16[0] = vaddlv_u8(v464);
                  if (v464.i32[0] <= 1u)
                  {
                    uint64_t v37 = v696;
                    CGSFillDRAM64(v78, 16 * (v713 + v715), 16 * v713, v721[0], v696, 16 * v719, 16 * v698, v695, 16 * v691, v690);
                    goto LABEL_618;
                  }
                }
LABEL_574:
                uint64_t v465 = 16 * (int)v47;
                if (v18 == 0 || v54)
                {
                  int v466 = v721[0];
                  do
                  {
                    int v467 = v713;
                    do
                    {
                      *(_OWORD *)unint64_t v78 = *(_OWORD *)v37;
                      unint64_t v468 = v37 + 16 * (int)v47;
                      if (v468 >= v56) {
                        uint64_t v469 = -(uint64_t)(int)v698;
                      }
                      else {
                        uint64_t v469 = 0;
                      }
                      uint64_t v37 = v468 + 16 * v469;
                      v78 += v465;
                      --v467;
                    }
                    while (v467);
                    v78 += 16 * v715;
                    unint64_t v470 = v55 + 16 * v719;
                    if (v470 >= v717) {
                      uint64_t v471 = -(uint64_t)(v719 * (int)v695);
                    }
                    else {
                      uint64_t v471 = 0;
                    }
                    unint64_t v472 = v470 + 16 * v471;
                    uint64_t v473 = v56 + 16 * v471 + 16 * v719;
                    if (v717)
                    {
                      unint64_t v56 = v473;
                      unint64_t v55 = v472;
                      uint64_t v37 = v472;
                    }
                    else
                    {
                      v37 += 16 * v719;
                    }
                    --v466;
                  }
                  while (v466);
                }
                else
                {
                  int v474 = v721[0];
                  do
                  {
                    int v475 = v713;
                    do
                    {
                      int v476 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v476;
                      *(_DWORD *)(v78 + 12) = 32831;
                      unint64_t v477 = v37 + 16 * (int)v47;
                      if (v477 >= v56) {
                        uint64_t v478 = -(uint64_t)(int)v698;
                      }
                      else {
                        uint64_t v478 = 0;
                      }
                      uint64_t v37 = v477 + 16 * v478;
                      v78 += v465;
                      --v475;
                    }
                    while (v475);
                    v78 += 16 * v715;
                    unint64_t v479 = v55 + 16 * v719;
                    if (v479 >= v717) {
                      uint64_t v480 = -(uint64_t)(v719 * (int)v695);
                    }
                    else {
                      uint64_t v480 = 0;
                    }
                    unint64_t v481 = v479 + 16 * v480;
                    uint64_t v482 = v56 + 16 * v480 + 16 * v719;
                    if (v717)
                    {
                      unint64_t v56 = v482;
                      unint64_t v55 = v481;
                      uint64_t v37 = v481;
                    }
                    else
                    {
                      v37 += 16 * v719;
                    }
                    --v474;
                  }
                  while (v474);
                }
                goto LABEL_616;
              }
              if (v86 != 1) {
                goto LABEL_574;
              }
              if (v18 == 0 || v54)
              {
                if ((v47 & 0x80000000) != 0)
                {
                  uint64_t v87 = v719 - v713;
                  v37 -= 16 * (v713 - 1);
                  uint64_t v88 = v715 - v713;
                  v78 -= 16 * (v713 - 1);
                }
                else
                {
                  uint64_t v87 = v719 + v713;
                  uint64_t v88 = v715 + v713;
                }
                uint64_t v494 = v721[0] - 1;
                int8x16_t v495 = (char *)(v37 + 16 * ((v87 * v494) & (v87 >> 63)));
                if (v87 >= 0) {
                  unint64_t v496 = v87;
                }
                else {
                  unint64_t v496 = -v87;
                }
                if (v88 >= 0) {
                  LODWORD(v497) = v88;
                }
                else {
                  uint64_t v497 = -v88;
                }
                unint64_t v719 = v496;
                CGBlt_copyBytes(16 * v713, v721[0], v495, (char *)(v78 + 16 * ((v88 * v494) & (v88 >> 63))), 16 * v496, 16 * v497);
                goto LABEL_617;
              }
              int v483 = v721[0];
              do
              {
                int v484 = v713;
                do
                {
                  int v485 = *(_DWORD *)(v37 + 8);
                  *(void *)unint64_t v78 = *(void *)v37;
                  *(_DWORD *)(v78 + 8) = v485;
                  *(_DWORD *)(v78 + 12) = 32831;
                  unint64_t v486 = v37 + 16 * (int)v47;
                  if (v486 >= v56) {
                    uint64_t v487 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v487 = 0;
                  }
                  uint64_t v37 = v486 + 16 * v487;
                  v78 += 16 * (int)v47;
                  --v484;
                }
                while (v484);
                v78 += 16 * v715;
                unint64_t v488 = v55 + 16 * v719;
                if (v488 >= v717) {
                  uint64_t v489 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v489 = 0;
                }
                unint64_t v490 = v488 + 16 * v489;
                uint64_t v491 = v56 + 16 * v489 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v491;
                  unint64_t v55 = v490;
                  uint64_t v37 = v490;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v483;
              }
              while (v483);
LABEL_616:
              v721[0] = 0;
LABEL_617:
              uint64_t v37 = v696;
LABEL_618:
              uint64_t v81 = v697;
              if (!v697) {
                return 1;
              }
              uint64_t v720 = 0;
              continue;
            case 2:
              int v89 = v721[0];
              do
              {
                int v90 = v713;
                do
                {
                  unsigned int v91 = *(_DWORD *)(v37 + 12);
                  LODWORD(v92) = bswap32(v91);
                  if (v92 >= 1.0)
                  {
                    *(void *)unint64_t v78 = *(void *)v37;
                    *(_DWORD *)(v78 + 8) = *(_DWORD *)(v37 + 8);
                    *(_DWORD *)(v78 + 12) = v91;
                  }
                  else if (v92 > 0.0)
                  {
                    *(int8x8_t *)v93.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v93.i64[1] = __PAIR64__(LODWORD(v92), bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v93, (float32x4_t)vrev32q_s8(*(int8x16_t *)v78), 1.0 - v92));
                  }
                  unint64_t v94 = v37 + 16 * (int)v47;
                  if (v94 >= v56) {
                    uint64_t v95 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v95 = 0;
                  }
                  uint64_t v37 = v94 + 16 * v95;
                  v78 += 16 * (int)v47;
                  --v90;
                }
                while (v90);
                v78 += 16 * v715;
                unint64_t v96 = v55 + 16 * v719;
                if (v96 >= v717) {
                  uint64_t v97 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v97 = 0;
                }
                unint64_t v98 = v96 + 16 * v97;
                uint64_t v99 = v56 + 16 * v97 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v99;
                  unint64_t v55 = v98;
                  uint64_t v37 = v98;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v89;
              }
              while (v89);
              goto LABEL_616;
            case 3:
              do
              {
                int v100 = v731[0];
                do
                {
                  float v101 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12)));
                  if (v101 <= 0.0)
                  {
                    *(void *)unint64_t v78 = 0;
                    *(void *)(v78 + 8) = 0;
                  }
                  else if (v101 >= 1.0)
                  {
                    if (v54) {
                      unsigned int v104 = bswap32(*(_DWORD *)(v37 + 12));
                    }
                    else {
                      unsigned int v104 = 1065353216;
                    }
                    uint64_t v105 = *(void *)(v37 + 4);
                    *(_DWORD *)unint64_t v78 = *(_DWORD *)v37;
                    *(void *)(v78 + 4) = v105;
                    *(_DWORD *)(v78 + 12) = bswap32(v104);
                  }
                  else
                  {
                    unsigned int v102 = 1.0;
                    if (v54) {
                      unsigned int v102 = bswap32(*(_DWORD *)(v37 + 12));
                    }
                    *(int8x8_t *)v103.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v103.i64[1] = __PAIR64__(v102, bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmulq_n_f32(v103, v101));
                  }
                  unint64_t v106 = v37 + 16 * (int)v47;
                  if (v106 >= v56) {
                    uint64_t v107 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v107 = 0;
                  }
                  uint64_t v37 = v106 + 16 * v107;
                  v78 += 16 * (int)v47;
                  --v100;
                }
                while (v100);
                v78 += 16 * v715;
                unint64_t v108 = v55 + 16 * v719;
                if (v108 >= v717) {
                  uint64_t v109 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v109 = 0;
                }
                unint64_t v110 = v108 + 16 * v109;
                uint64_t v111 = v56 + 16 * v109 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v111;
                  unint64_t v55 = v110;
                  uint64_t v37 = v110;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v721[0];
              }
              while (v721[0]);
              goto LABEL_617;
            case 4:
              do
              {
                int v112 = v731[0];
                do
                {
                  float v113 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12)));
                  if (v113 <= 0.0)
                  {
                    *(void *)unint64_t v78 = 0;
                    *(void *)(v78 + 8) = 0;
                  }
                  else if (v113 >= 1.0)
                  {
                    if (v54) {
                      unsigned int v116 = bswap32(*(_DWORD *)(v37 + 12));
                    }
                    else {
                      unsigned int v116 = 1065353216;
                    }
                    uint64_t v117 = *(void *)(v37 + 4);
                    *(_DWORD *)unint64_t v78 = *(_DWORD *)v37;
                    *(void *)(v78 + 4) = v117;
                    *(_DWORD *)(v78 + 12) = bswap32(v116);
                  }
                  else
                  {
                    unsigned int v114 = 1.0;
                    if (v54) {
                      unsigned int v114 = bswap32(*(_DWORD *)(v37 + 12));
                    }
                    *(int8x8_t *)v115.f32 = vrev32_s8(*(int8x8_t *)v37);
                    v115.i64[1] = __PAIR64__(v114, bswap32(*(_DWORD *)(v37 + 8)));
                    *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmulq_n_f32(v115, v113));
                  }
                  unint64_t v118 = v37 + 16 * (int)v47;
                  if (v118 >= v56) {
                    uint64_t v119 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v119 = 0;
                  }
                  uint64_t v37 = v118 + 16 * v119;
                  v78 += 16 * (int)v47;
                  --v112;
                }
                while (v112);
                v78 += 16 * v715;
                unint64_t v120 = v55 + 16 * v719;
                if (v120 >= v717) {
                  uint64_t v121 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v121 = 0;
                }
                unint64_t v122 = v120 + 16 * v121;
                uint64_t v123 = v56 + 16 * v121 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v123;
                  unint64_t v55 = v122;
                  uint64_t v37 = v122;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v721[0];
              }
              while (v721[0]);
              goto LABEL_617;
            case 5:
              int v124 = v721[0];
              do
              {
                int v125 = v713;
                do
                {
                  float32x4_t v126 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  float32x4_t v127 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v78);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v127, 1.0 - v126.f32[3]), v126, v127, 3));
                  unint64_t v128 = v37 + 16 * (int)v47;
                  if (v128 >= v56) {
                    uint64_t v129 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v129 = 0;
                  }
                  uint64_t v37 = v128 + 16 * v129;
                  v78 += 16 * (int)v47;
                  --v125;
                }
                while (v125);
                v78 += 16 * v715;
                unint64_t v130 = v55 + 16 * v719;
                if (v130 >= v717) {
                  uint64_t v131 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v131 = 0;
                }
                unint64_t v132 = v130 + 16 * v131;
                uint64_t v133 = v56 + 16 * v131 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v133;
                  unint64_t v55 = v132;
                  uint64_t v37 = v132;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v124;
              }
              while (v124);
              goto LABEL_616;
            case 6:
              int v134 = v721[0];
              while (1)
              {
                int v135 = v713;
                do
                {
                  float v136 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12)));
                  float v137 = 1.0 - v136;
                  if ((float)(1.0 - v136) >= 1.0)
                  {
                    if (v54) {
                      unsigned int v142 = bswap32(*(_DWORD *)(v37 + 12));
                    }
                    else {
                      unsigned int v142 = 1065353216;
                    }
                    int8x8_t v141 = *(int8x8_t *)v37;
                    unsigned int v139 = *(_DWORD *)(v37 + 8);
                    unsigned int v140 = bswap32(v142);
                  }
                  else
                  {
                    if (v137 <= 0.0) {
                      goto LABEL_150;
                    }
                    float v138 = 1.0;
                    if (v54) {
                      float v138 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                    }
                    unsigned int v139 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8)))+ (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8))) * v137)));
                    unsigned int v140 = bswap32(COERCE_UNSIGNED_INT(v136 + (float)(v138 * v137)));
                    int8x8_t v141 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v78), (float32x2_t)vrev32_s8(*(int8x8_t *)v37), v137));
                  }
                  *(int8x8_t *)unint64_t v78 = v141;
                  *(_DWORD *)(v78 + 8) = v139;
                  *(_DWORD *)(v78 + 12) = v140;
LABEL_150:
                  unint64_t v143 = v37 + 16 * (int)v47;
                  if (v143 >= v56) {
                    uint64_t v144 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v144 = 0;
                  }
                  uint64_t v37 = v143 + 16 * v144;
                  v78 += 16 * (int)v47;
                  --v135;
                }
                while (v135);
                v78 += 16 * v715;
                unint64_t v145 = v55 + 16 * v719;
                if (v145 >= v717) {
                  uint64_t v146 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v146 = 0;
                }
                unint64_t v147 = v145 + 16 * v146;
                uint64_t v148 = v56 + 16 * v146 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v148;
                  unint64_t v55 = v147;
                  uint64_t v37 = v147;
                }
                else
                {
                  v37 += 16 * v719;
                }
                if (!--v134) {
                  goto LABEL_616;
                }
              }
            case 7:
              int v149 = v721[0];
              do
              {
                int v150 = v713;
                do
                {
                  float v151 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  if (v151 <= 0.0)
                  {
                    *(void *)unint64_t v78 = 0;
                    *(void *)(v78 + 8) = 0;
                  }
                  else if (v151 < 1.0)
                  {
                    *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v78), v151));
                  }
                  unint64_t v152 = v37 + 16 * (int)v47;
                  if (v152 >= v56) {
                    uint64_t v153 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v153 = 0;
                  }
                  uint64_t v37 = v152 + 16 * v153;
                  v78 += 16 * (int)v47;
                  --v150;
                }
                while (v150);
                v78 += 16 * v715;
                unint64_t v154 = v55 + 16 * v719;
                if (v154 >= v717) {
                  uint64_t v155 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v155 = 0;
                }
                unint64_t v156 = v154 + 16 * v155;
                uint64_t v157 = v56 + 16 * v155 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v157;
                  unint64_t v55 = v156;
                  uint64_t v37 = v156;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v149;
              }
              while (v149);
              goto LABEL_616;
            case 8:
              int v158 = v721[0];
              do
              {
                int v159 = v713;
                do
                {
                  float v160 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  if (v160 <= 0.0)
                  {
                    *(void *)unint64_t v78 = 0;
                    *(void *)(v78 + 8) = 0;
                  }
                  else if (v160 < 1.0)
                  {
                    *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v78), v160));
                  }
                  unint64_t v161 = v37 + 16 * (int)v47;
                  if (v161 >= v56) {
                    uint64_t v162 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v162 = 0;
                  }
                  uint64_t v37 = v161 + 16 * v162;
                  v78 += 16 * (int)v47;
                  --v159;
                }
                while (v159);
                v78 += 16 * v715;
                unint64_t v163 = v55 + 16 * v719;
                if (v163 >= v717) {
                  uint64_t v164 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v164 = 0;
                }
                unint64_t v165 = v163 + 16 * v164;
                uint64_t v166 = v56 + 16 * v164 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v166;
                  unint64_t v55 = v165;
                  uint64_t v37 = v165;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v158;
              }
              while (v158);
              goto LABEL_616;
            case 9:
              int v167 = v721[0];
              do
              {
                int v168 = v713;
                do
                {
                  float32x4_t v169 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  float32x4_t v170 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v78);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_laneq_f32(v170, v169, 3), v169, 1.0 - v170.f32[3]));
                  unint64_t v171 = v37 + 16 * (int)v47;
                  if (v171 >= v56) {
                    uint64_t v172 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v172 = 0;
                  }
                  uint64_t v37 = v171 + 16 * v172;
                  v78 += 16 * (int)v47;
                  --v168;
                }
                while (v168);
                v78 += 16 * v715;
                unint64_t v173 = v55 + 16 * v719;
                if (v173 >= v717) {
                  uint64_t v174 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v174 = 0;
                }
                unint64_t v175 = v173 + 16 * v174;
                uint64_t v176 = v56 + 16 * v174 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v176;
                  unint64_t v55 = v175;
                  uint64_t v37 = v175;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v167;
              }
              while (v167);
              goto LABEL_616;
            case 10:
              int v177 = v721[0];
              do
              {
                int v178 = v713;
                do
                {
                  float32x4_t v179 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                  float32x4_t v180 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v78);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v180, 1.0 - v179.f32[3]), v179, 1.0 - v180.f32[3]));
                  unint64_t v181 = v37 + 16 * (int)v47;
                  if (v181 >= v56) {
                    uint64_t v182 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v182 = 0;
                  }
                  uint64_t v37 = v181 + 16 * v182;
                  v78 += 16 * (int)v47;
                  --v178;
                }
                while (v178);
                v78 += 16 * v715;
                unint64_t v183 = v55 + 16 * v719;
                if (v183 >= v717) {
                  uint64_t v184 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v184 = 0;
                }
                unint64_t v185 = v183 + 16 * v184;
                uint64_t v186 = v56 + 16 * v184 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v186;
                  unint64_t v55 = v185;
                  uint64_t v37 = v185;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v177;
              }
              while (v177);
              goto LABEL_616;
            case 11:
              int v187 = v721[0];
              do
              {
                int v188 = v713;
                do
                {
                  if (v18) {
                    v10.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                  }
                  else {
                    v10.i32[0] = 1.0;
                  }
                  float v189 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8)));
                  float32x2_t v190 = (float32x2_t)vrev32_s8(*(int8x8_t *)v78);
                  float32x2_t v191 = (float32x2_t)vrev32_s8(*(int8x8_t *)v37);
                  float v192 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                  LODWORD(v15) = bswap32(*(_DWORD *)(v37 + 12));
                  if (!v54) {
                    *(float *)&double v15 = 1.0;
                  }
                  float v193 = *(float *)&v15 + *(float *)v10.i32;
                  float32x2_t v194 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 0), v190);
                  float v195 = (float)(*(float *)&v15 - v192) + (float)(*(float *)v10.i32 - v189);
                  if (v193 <= 1.0) {
                    *(float *)v11.unint64_t i32 = v193;
                  }
                  else {
                    *(float *)v11.unint64_t i32 = 1.0;
                  }
                  *(float32x2_t *)v196.unint64_t i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 0), vadd_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v15, 0), v191), v194));
                  *(float *)&v196.i32[2] = *(float *)v11.i32 - v195;
                  v196.i32[3] = v11.i32[0];
                  int8x16_t v10 = vrev32q_s8(v196);
                  *(int8x16_t *)unint64_t v78 = v10;
                  unint64_t v197 = v37 + 16 * (int)v47;
                  if (v197 >= v56) {
                    uint64_t v198 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v198 = 0;
                  }
                  uint64_t v37 = v197 + 16 * v198;
                  v78 += 16 * (int)v47;
                  --v188;
                }
                while (v188);
                v78 += 16 * v715;
                unint64_t v199 = v55 + 16 * v719;
                if (v199 >= v717) {
                  uint64_t v200 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v200 = 0;
                }
                unint64_t v201 = v199 + 16 * v200;
                uint64_t v202 = v56 + 16 * v200 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v202;
                  unint64_t v55 = v201;
                  uint64_t v37 = v201;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v187;
              }
              while (v187);
              goto LABEL_616;
            case 12:
              int v203 = v721[0];
              do
              {
                int v204 = v713;
                do
                {
                  float v205 = 1.0;
                  if (v54) {
                    float v205 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                  }
                  float v206 = v205 + COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12)));
                  *(float32x2_t *)v207.unint64_t i8 = vadd_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v78), (float32x2_t)vrev32_s8(*(int8x8_t *)v37));
                  float v208 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8))) + COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                  if (v206 > 1.0) {
                    float v206 = 1.0;
                  }
                  v207.i64[1] = __PAIR64__(LODWORD(v206), LODWORD(v208));
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v207);
                  unint64_t v209 = v37 + 16 * (int)v47;
                  if (v209 >= v56) {
                    uint64_t v210 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v210 = 0;
                  }
                  uint64_t v37 = v209 + 16 * v210;
                  v78 += 16 * (int)v47;
                  --v204;
                }
                while (v204);
                v78 += 16 * v715;
                unint64_t v211 = v55 + 16 * v719;
                if (v211 >= v717) {
                  uint64_t v212 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v212 = 0;
                }
                unint64_t v213 = v211 + 16 * v212;
                uint64_t v214 = v56 + 16 * v212 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v214;
                  unint64_t v55 = v213;
                  uint64_t v37 = v213;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v203;
              }
              while (v203);
              goto LABEL_616;
            case 13:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v215 = (int)v47;
              int v216 = v721[0];
              uint64_t v217 = 16 * (int)v47;
              while (1)
              {
                int v699 = v216;
                int v218 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_275;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v219 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v220 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v220;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_275;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v219 = 1.0;
                  }
                  int8x8_t v221 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v222 = *(_OWORD *)v37;
                  LODWORD(v222) = v221.i32[1];
                  int8x16_t v676 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v223.unint64_t i32 = PDAmultiplyPDA(*(float *)v221.i32, *(double *)&v222, *(double *)v11.i64, *(double *)v12.i64, v219, v14, *(double *)v676.i64, v16, *(float *)v676.i32, *(double *)&v676.i64[1], *(float *)&v14);
                  v223.i32[1] = v224;
                  v223.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v223);
LABEL_275:
                  unint64_t v225 = v37 + 16 * v215;
                  if (v225 >= v56) {
                    uint64_t v226 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v226 = 0;
                  }
                  uint64_t v37 = v225 + 16 * v226;
                  v78 += v217;
                  --v218;
                }
                while (v218);
                v78 += 16 * v715;
                unint64_t v227 = v55 + 16 * v719;
                uint64_t v228 = -(uint64_t)(v719 * (int)v695);
                if (v227 < v717) {
                  uint64_t v228 = 0;
                }
                unint64_t v229 = v227 + 16 * v228;
                uint64_t v230 = v56 + 16 * v228 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v230;
                  unint64_t v55 = v229;
                  uint64_t v37 = v229;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v216 = v699 - 1;
                if (v699 == 1) {
                  goto LABEL_569;
                }
              }
            case 14:
              int v231 = v721[0];
              __asm { FMOV            V1.2S, #1.0 }
              do
              {
                int v237 = v713;
                do
                {
                  float v238 = 1.0;
                  float v239 = 1.0;
                  if (!v54 || (float v239 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v239 > 0.0))
                  {
                    if (v18 && (float v238 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12))), v238 <= 0.0))
                    {
                      unsigned int v241 = *(_DWORD *)(v37 + 8);
                      unsigned int v244 = bswap32(LODWORD(v239));
                      *(void *)unint64_t v78 = *(void *)v37;
                    }
                    else
                    {
                      float v240 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8)));
                      unsigned int v241 = bswap32(COERCE_UNSIGNED_INT(v240 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)))
                                                                      * (float)(1.0 - v240))));
                      *(float *)&unsigned int v242 = (float)(v239 + v238) - (float)(v238 * v239);
                      float32x2_t v243 = (float32x2_t)vrev32_s8(*(int8x8_t *)v78);
                      *(int8x8_t *)unint64_t v78 = vrev32_s8((int8x8_t)vmla_f32(v243, vsub_f32(_D1, v243), (float32x2_t)vrev32_s8(*(int8x8_t *)v37)));
                      unsigned int v244 = bswap32(v242);
                    }
                    *(_DWORD *)(v78 + 8) = v241;
                    *(_DWORD *)(v78 + 12) = v244;
                  }
                  unint64_t v245 = v37 + 16 * (int)v47;
                  if (v245 >= v56) {
                    uint64_t v246 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v246 = 0;
                  }
                  uint64_t v37 = v245 + 16 * v246;
                  v78 += 16 * (int)v47;
                  --v237;
                }
                while (v237);
                v78 += 16 * v715;
                unint64_t v247 = v55 + 16 * v719;
                if (v247 >= v717) {
                  uint64_t v248 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v248 = 0;
                }
                unint64_t v249 = v247 + 16 * v248;
                uint64_t v250 = v56 + 16 * v248 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v250;
                  unint64_t v55 = v249;
                  uint64_t v37 = v249;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v231;
              }
              while (v231);
              goto LABEL_616;
            case 15:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v251 = (int)v47;
              int v252 = v721[0];
              uint64_t v253 = 16 * (int)v47;
              while (1)
              {
                int v700 = v252;
                int v254 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_316;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v255 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v256 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v256;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_316;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v255 = 1.0;
                  }
                  int8x8_t v257 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v258 = *(_OWORD *)v37;
                  LODWORD(v258) = v257.i32[1];
                  int8x16_t v677 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v259.unint64_t i32 = PDAoverlayPDA(*(float *)v257.i32, *(double *)&v258, *(double *)v11.i64, *(double *)v12.i64, v255, v14, *(double *)v677.i64, v16, *(float *)v677.i32, *(double *)&v677.i64[1], *(float *)&v14);
                  v259.i32[1] = v260;
                  v259.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v259);
LABEL_316:
                  unint64_t v261 = v37 + 16 * v251;
                  if (v261 >= v56) {
                    uint64_t v262 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v262 = 0;
                  }
                  uint64_t v37 = v261 + 16 * v262;
                  v78 += v253;
                  --v254;
                }
                while (v254);
                v78 += 16 * v715;
                unint64_t v263 = v55 + 16 * v719;
                uint64_t v264 = -(uint64_t)(v719 * (int)v695);
                if (v263 < v717) {
                  uint64_t v264 = 0;
                }
                unint64_t v265 = v263 + 16 * v264;
                uint64_t v266 = v56 + 16 * v264 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v266;
                  unint64_t v55 = v265;
                  uint64_t v37 = v265;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v252 = v700 - 1;
                if (v700 == 1) {
                  goto LABEL_569;
                }
              }
            case 16:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v267 = (int)v47;
              int v268 = v721[0];
              uint64_t v269 = 16 * (int)v47;
              while (1)
              {
                int v701 = v268;
                int v270 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_336;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v271 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v272 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v272;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_336;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v271 = 1.0;
                  }
                  int8x8_t v273 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v274 = *(_OWORD *)v37;
                  LODWORD(v274) = v273.i32[1];
                  int8x16_t v678 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v275.unint64_t i32 = PDAdarkenPDA(*(float *)v273.i32, *(double *)&v274, *(double *)v11.i64, *(double *)v12.i64, v271, v14, *(double *)v678.i64, v16, *(float *)v678.i32, *(double *)&v678.i64[1], *(float *)&v14);
                  v275.i32[1] = v276;
                  v275.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v275);
LABEL_336:
                  unint64_t v277 = v37 + 16 * v267;
                  if (v277 >= v56) {
                    uint64_t v278 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v278 = 0;
                  }
                  uint64_t v37 = v277 + 16 * v278;
                  v78 += v269;
                  --v270;
                }
                while (v270);
                v78 += 16 * v715;
                unint64_t v279 = v55 + 16 * v719;
                uint64_t v280 = -(uint64_t)(v719 * (int)v695);
                if (v279 < v717) {
                  uint64_t v280 = 0;
                }
                unint64_t v281 = v279 + 16 * v280;
                uint64_t v282 = v56 + 16 * v280 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v282;
                  unint64_t v55 = v281;
                  uint64_t v37 = v281;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v268 = v701 - 1;
                if (v701 == 1) {
                  goto LABEL_569;
                }
              }
            case 17:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v283 = (int)v47;
              int v284 = v721[0];
              uint64_t v285 = 16 * (int)v47;
              while (1)
              {
                int v702 = v284;
                int v286 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_356;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v287 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v288 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v288;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_356;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v287 = 1.0;
                  }
                  int8x8_t v289 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v290 = *(_OWORD *)v37;
                  LODWORD(v290) = v289.i32[1];
                  int8x16_t v679 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v291.unint64_t i32 = PDAlightenPDA(*(float *)v289.i32, *(double *)&v290, *(double *)v11.i64, *(double *)v12.i64, v287, v14, *(double *)v679.i64, v16, *(float *)v679.i32, *(double *)&v679.i64[1], *(float *)&v14);
                  v291.i32[1] = v292;
                  v291.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v291);
LABEL_356:
                  unint64_t v293 = v37 + 16 * v283;
                  if (v293 >= v56) {
                    uint64_t v294 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v294 = 0;
                  }
                  uint64_t v37 = v293 + 16 * v294;
                  v78 += v285;
                  --v286;
                }
                while (v286);
                v78 += 16 * v715;
                unint64_t v295 = v55 + 16 * v719;
                uint64_t v296 = -(uint64_t)(v719 * (int)v695);
                if (v295 < v717) {
                  uint64_t v296 = 0;
                }
                unint64_t v297 = v295 + 16 * v296;
                uint64_t v298 = v56 + 16 * v296 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v298;
                  unint64_t v55 = v297;
                  uint64_t v37 = v297;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v284 = v702 - 1;
                if (v702 == 1) {
                  goto LABEL_569;
                }
              }
            case 18:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v299 = (int)v47;
              int v300 = v721[0];
              uint64_t v301 = 16 * (int)v47;
              while (1)
              {
                int v703 = v300;
                int v302 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_376;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v303 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v304 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v304;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_376;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v303 = 1.0;
                  }
                  int8x8_t v305 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v306 = *(_OWORD *)v37;
                  LODWORD(v306) = v305.i32[1];
                  int8x16_t v680 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v307.unint64_t i32 = PDAcolordodgePDA(*(float *)v305.i32, *(double *)&v306, *(double *)v11.i64, *(double *)v12.i64, v303, v14, *(double *)v680.i64, v16, *(float *)v680.i32, *(double *)&v680.i64[1], *(float *)&v14);
                  v307.i32[1] = v308;
                  v307.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v307);
LABEL_376:
                  unint64_t v309 = v37 + 16 * v299;
                  if (v309 >= v56) {
                    uint64_t v310 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v310 = 0;
                  }
                  uint64_t v37 = v309 + 16 * v310;
                  v78 += v301;
                  --v302;
                }
                while (v302);
                v78 += 16 * v715;
                unint64_t v311 = v55 + 16 * v719;
                uint64_t v312 = -(uint64_t)(v719 * (int)v695);
                if (v311 < v717) {
                  uint64_t v312 = 0;
                }
                unint64_t v313 = v311 + 16 * v312;
                uint64_t v314 = v56 + 16 * v312 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v314;
                  unint64_t v55 = v313;
                  uint64_t v37 = v313;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v300 = v703 - 1;
                if (v703 == 1) {
                  goto LABEL_569;
                }
              }
            case 19:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v315 = (int)v47;
              int v316 = v721[0];
              uint64_t v317 = 16 * (int)v47;
              while (1)
              {
                int v704 = v316;
                int v318 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_396;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v319 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v320 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v320;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_396;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v319 = 1.0;
                  }
                  int8x8_t v321 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v322 = *(_OWORD *)v37;
                  LODWORD(v322) = v321.i32[1];
                  int8x16_t v681 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v323.unint64_t i32 = PDAcolorburnPDA(*(float *)v321.i32, *(double *)&v322, *(double *)v11.i64, *(double *)v12.i64, v319, v14, *(double *)v681.i64, v16, *(float *)v681.i32, *(double *)&v681.i64[1], *(float *)&v14);
                  v323.i32[1] = v324;
                  v323.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v323);
LABEL_396:
                  unint64_t v325 = v37 + 16 * v315;
                  if (v325 >= v56) {
                    uint64_t v326 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v326 = 0;
                  }
                  uint64_t v37 = v325 + 16 * v326;
                  v78 += v317;
                  --v318;
                }
                while (v318);
                v78 += 16 * v715;
                unint64_t v327 = v55 + 16 * v719;
                uint64_t v328 = -(uint64_t)(v719 * (int)v695);
                if (v327 < v717) {
                  uint64_t v328 = 0;
                }
                unint64_t v329 = v327 + 16 * v328;
                uint64_t v330 = v56 + 16 * v328 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v330;
                  unint64_t v55 = v329;
                  uint64_t v37 = v329;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v316 = v704 - 1;
                if (v704 == 1) {
                  goto LABEL_569;
                }
              }
            case 20:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v331 = (int)v47;
              int v332 = v721[0];
              uint64_t v333 = 16 * (int)v47;
              while (1)
              {
                int v705 = v332;
                int v334 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_416;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    v13.n128_u32[0] = v12.i32[0];
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v335 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v335;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_416;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    v13.n128_u32[0] = 1.0;
                  }
                  int8x8_t v336 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  int8x16_t v682 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v337.unint64_t i32 = PDAsoftlightPDA(*(float *)v336.i32, *(float *)&v336.i32[1], *(double *)v11.i64, *(int32x2_t *)v12.i8, v13.n128_f64[0], v14, *(double *)v682.i64, v16, v22, v3, (uint64_t)v26, v47, v5, v6, v40, v41, *(float *)v682.i32, v682.u32[1], v682.i64[1],
                                         *(float *)&v14);
                  v337.i32[1] = v338;
                  v337.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v337);
LABEL_416:
                  unint64_t v339 = v37 + 16 * v331;
                  if (v339 >= v56) {
                    uint64_t v340 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v340 = 0;
                  }
                  uint64_t v37 = v339 + 16 * v340;
                  v78 += v333;
                  --v334;
                }
                while (v334);
                v78 += 16 * v715;
                unint64_t v341 = v55 + 16 * v719;
                uint64_t v342 = -(uint64_t)(v719 * (int)v695);
                if (v341 < v717) {
                  uint64_t v342 = 0;
                }
                unint64_t v343 = v341 + 16 * v342;
                uint64_t v344 = v56 + 16 * v342 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v344;
                  unint64_t v55 = v343;
                  uint64_t v37 = v343;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v332 = v705 - 1;
                if (v705 == 1) {
                  goto LABEL_569;
                }
              }
            case 21:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v345 = (int)v47;
              int v346 = v721[0];
              uint64_t v347 = 16 * (int)v47;
              while (1)
              {
                int v706 = v346;
                int v348 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_436;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v349 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v350 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v350;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_436;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v349 = 1.0;
                  }
                  int8x8_t v351 = vrev32_s8(*(int8x8_t *)v78);
                  v11.i32[0] = bswap32(*(_DWORD *)(v78 + 8));
                  long long v352 = *(_OWORD *)v37;
                  LODWORD(v352) = v351.i32[1];
                  int8x16_t v683 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v353.unint64_t i32 = PDAhardlightPDA(*(float *)v351.i32, *(double *)&v352, *(double *)v11.i64, *(double *)v12.i64, v349, v14, *(double *)v683.i64, v16, *(float *)v683.i32, *(double *)&v683.i64[1], *(float *)&v14);
                  v353.i32[1] = v354;
                  v353.i64[1] = __PAIR64__(v12.u32[0], v11.u32[0]);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v353);
LABEL_436:
                  unint64_t v355 = v37 + 16 * v345;
                  if (v355 >= v56) {
                    uint64_t v356 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v356 = 0;
                  }
                  uint64_t v37 = v355 + 16 * v356;
                  v78 += v347;
                  --v348;
                }
                while (v348);
                v78 += 16 * v715;
                unint64_t v357 = v55 + 16 * v719;
                uint64_t v358 = -(uint64_t)(v719 * (int)v695);
                if (v357 < v717) {
                  uint64_t v358 = 0;
                }
                unint64_t v359 = v357 + 16 * v358;
                uint64_t v360 = v56 + 16 * v358 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v360;
                  unint64_t v55 = v359;
                  uint64_t v37 = v359;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v346 = v706 - 1;
                if (v706 == 1) {
                  goto LABEL_569;
                }
              }
            case 22:
              int v361 = v721[0];
              do
              {
                int v362 = v713;
                do
                {
                  float v363 = 1.0;
                  float v364 = 1.0;
                  if (!v54 || (float v364 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v364 > 0.0))
                  {
                    if (v18 && (float v363 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12))), v363 <= 0.0))
                    {
                      int v376 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v376;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v364));
                    }
                    else
                    {
                      float v365 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8)));
                      float32x2_t v366 = (float32x2_t)vrev32_s8(*(int8x8_t *)v78);
                      float32x4_t v367 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v37);
                      float32x2_t v368 = vadd_f32(*(float32x2_t *)v367.f32, v366);
                      float32x2_t v369 = vmul_n_f32(v366, v364);
                      float32x2_t v370 = vmul_n_f32(*(float32x2_t *)v367.f32, v363);
                      float32x2_t v371 = vsub_f32(v368, v369);
                      float32x2_t v372 = vsub_f32(v369, v370);
                      *(float32x2_t *)v373.unint64_t i8 = vadd_f32(vsub_f32(v371, v370), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v372), (int8x8_t)vneg_f32(v372), (int8x8_t)v372));
                      v367.f32[0] = vmuls_lane_f32(v363, v367, 2);
                      float v374 = (float)(v364 * v365) - v367.f32[0];
                      float v375 = (float)((float)(v367.f32[2] + v365) - (float)(v364 * v365)) - v367.f32[0];
                      if (v374 < 0.0) {
                        float v374 = -v374;
                      }
                      *(float *)&v373.i32[2] = v375 + v374;
                      *(float *)&v373.i32[3] = (float)(v363 + v364) - (float)(v363 * v364);
                      *(int8x16_t *)unint64_t v78 = vrev32q_s8(v373);
                    }
                  }
                  unint64_t v377 = v37 + 16 * (int)v47;
                  if (v377 >= v56) {
                    uint64_t v378 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v378 = 0;
                  }
                  uint64_t v37 = v377 + 16 * v378;
                  v78 += 16 * (int)v47;
                  --v362;
                }
                while (v362);
                v78 += 16 * v715;
                unint64_t v379 = v55 + 16 * v719;
                if (v379 >= v717) {
                  uint64_t v380 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v380 = 0;
                }
                unint64_t v381 = v379 + 16 * v380;
                uint64_t v382 = v56 + 16 * v380 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v382;
                  unint64_t v55 = v381;
                  uint64_t v37 = v381;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v361;
              }
              while (v361);
              goto LABEL_616;
            case 23:
              int v383 = v721[0];
              do
              {
                int v384 = v713;
                do
                {
                  float v385 = 1.0;
                  float v386 = 1.0;
                  if (!v54 || (float v386 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12))), v386 > 0.0))
                  {
                    if (v18 && (float v385 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 12))), v385 <= 0.0))
                    {
                      unsigned int v389 = *(_DWORD *)(v37 + 8);
                      unsigned int v393 = bswap32(LODWORD(v386));
                      *(void *)unint64_t v78 = *(void *)v37;
                    }
                    else
                    {
                      float v387 = COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8)));
                      float v388 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 8)));
                      unsigned int v389 = bswap32(COERCE_UNSIGNED_INT((float)(v387 + v388) + (float)((float)(v387 * v388) * -2.0)));
                      *(float *)&unsigned int v390 = (float)(v386 + v385) - (float)(v385 * v386);
                      float32x2_t v391 = (float32x2_t)vrev32_s8(*(int8x8_t *)v78);
                      float32x2_t v392 = (float32x2_t)vrev32_s8(*(int8x8_t *)v37);
                      *(int8x8_t *)unint64_t v78 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(v391, v392), (float32x2_t)0xC0000000C0000000, vmul_f32(v391, v392)));
                      unsigned int v393 = bswap32(v390);
                    }
                    *(_DWORD *)(v78 + 8) = v389;
                    *(_DWORD *)(v78 + 12) = v393;
                  }
                  unint64_t v394 = v37 + 16 * (int)v47;
                  if (v394 >= v56) {
                    uint64_t v395 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v395 = 0;
                  }
                  uint64_t v37 = v394 + 16 * v395;
                  v78 += 16 * (int)v47;
                  --v384;
                }
                while (v384);
                v78 += 16 * v715;
                unint64_t v396 = v55 + 16 * v719;
                if (v396 >= v717) {
                  uint64_t v397 = -(uint64_t)(v719 * (int)v695);
                }
                else {
                  uint64_t v397 = 0;
                }
                unint64_t v398 = v396 + 16 * v397;
                uint64_t v399 = v56 + 16 * v397 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v399;
                  unint64_t v55 = v398;
                  uint64_t v37 = v398;
                }
                else
                {
                  v37 += 16 * v719;
                }
                --v383;
              }
              while (v383);
              goto LABEL_616;
            case 24:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v400 = (int)v47;
              int v401 = v721[0];
              uint64_t v402 = 16 * (int)v47;
              while (1)
              {
                int v707 = v401;
                int v403 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_499;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v404 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v405 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v405;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_499;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v404 = 1.0;
                  }
                  int8x8_t v406 = vrev32_s8(*(int8x8_t *)v78);
                  int8x16_t v684 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v407.unint64_t i32 = PDAhuePDA(*(float *)v406.i32, *(float *)&v406.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8))), *(double *)v12.i64, v404, v14, *(double *)v684.i64, v16, *(float *)v684.i32, *(float *)&v684.i32[1], *(float *)&v684.i32[2], *(float *)&v684.i32[3], *(float *)&v14);
                  v407.i32[1] = v408;
                  v407.i64[1] = __PAIR64__(v12.u32[0], v409);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v407);
LABEL_499:
                  unint64_t v410 = v37 + 16 * v400;
                  if (v410 >= v56) {
                    uint64_t v411 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v411 = 0;
                  }
                  uint64_t v37 = v410 + 16 * v411;
                  v78 += v402;
                  --v403;
                }
                while (v403);
                v78 += 16 * v715;
                unint64_t v412 = v55 + 16 * v719;
                uint64_t v413 = -(uint64_t)(v719 * (int)v695);
                if (v412 < v717) {
                  uint64_t v413 = 0;
                }
                unint64_t v414 = v412 + 16 * v413;
                uint64_t v415 = v56 + 16 * v413 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v415;
                  unint64_t v55 = v414;
                  uint64_t v37 = v414;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v401 = v707 - 1;
                if (v707 == 1) {
                  goto LABEL_569;
                }
              }
            case 25:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v416 = (int)v47;
              int v417 = v721[0];
              uint64_t v418 = 16 * (int)v47;
              while (1)
              {
                int v708 = v417;
                int v419 = v713;
                do
                {
                  LODWORD(v14) = 1.0;
                  if (v54)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12));
                    if (*(float *)&v14 <= 0.0) {
                      goto LABEL_519;
                    }
                  }
                  if (v18)
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v420 = *(float *)v12.i32;
                    if (*(float *)v12.i32 <= 0.0)
                    {
                      int v421 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v421;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
                      goto LABEL_519;
                    }
                  }
                  else
                  {
                    v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
                    float v420 = 1.0;
                  }
                  int8x8_t v422 = vrev32_s8(*(int8x8_t *)v78);
                  int8x16_t v685 = vrev32q_s8(*(int8x16_t *)v37);
                  *(float *)v423.unint64_t i32 = PDAsaturationPDA(*(float *)v422.i32, *(float *)&v422.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8))), *(double *)v12.i64, v420, v14, *(double *)v685.i64, v16, *(float *)v685.i32, *(float *)&v685.i32[1], *(float *)&v685.i32[2], *(float *)&v685.i32[3], *(float *)&v14);
                  v423.i32[1] = v424;
                  v423.i64[1] = __PAIR64__(v12.u32[0], v425);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v423);
LABEL_519:
                  unint64_t v426 = v37 + 16 * v416;
                  if (v426 >= v56) {
                    uint64_t v427 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v427 = 0;
                  }
                  uint64_t v37 = v426 + 16 * v427;
                  v78 += v418;
                  --v419;
                }
                while (v419);
                v78 += 16 * v715;
                unint64_t v428 = v55 + 16 * v719;
                uint64_t v429 = -(uint64_t)(v719 * (int)v695);
                if (v428 < v717) {
                  uint64_t v429 = 0;
                }
                unint64_t v430 = v428 + 16 * v429;
                uint64_t v431 = v56 + 16 * v429 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v431;
                  unint64_t v55 = v430;
                  uint64_t v37 = v430;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v417 = v708 - 1;
                if (v708 == 1) {
                  goto LABEL_569;
                }
              }
            case 26:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v432 = (int)v47;
              int v433 = v721[0];
              uint64_t v434 = 16 * (int)v47;
              while (1)
              {
                int v709 = v433;
                int v435 = v713;
                do
                {
                  float v436 = 1.0;
                  if (v54)
                  {
                    float v436 = COERCE_FLOAT(bswap32(*(_DWORD *)(v37 + 12)));
                    if (v436 <= 0.0) {
                      goto LABEL_539;
                    }
                  }
                  if (v18)
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v78 + 12));
                    LODWORD(v15) = LODWORD(v14);
                    if (*(float *)&v14 <= 0.0)
                    {
                      int v437 = *(_DWORD *)(v37 + 8);
                      *(void *)unint64_t v78 = *(void *)v37;
                      *(_DWORD *)(v78 + 8) = v437;
                      *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v436));
                      goto LABEL_539;
                    }
                  }
                  else
                  {
                    LODWORD(v14) = bswap32(*(_DWORD *)(v78 + 12));
                    LODWORD(v15) = 1.0;
                  }
                  int8x16_t v438 = vrev32q_s8(*(int8x16_t *)v37);
                  v12.i32[0] = v438.i32[3];
                  double v686 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v78));
                  *(float *)v439.unint64_t i32 = PDAluminosityPDA(*(float *)v438.i32, *(float *)&v438.i32[1], *(float *)&v438.i32[2], *(double *)v12.i64, v436, v14, v15, v686, *(float *)&v686, *((float *)&v686 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8))), *(float *)&v14, *(float *)&v15);
                  v439.i32[1] = v440;
                  v439.i64[1] = __PAIR64__(v12.u32[0], v441);
                  *(int8x16_t *)unint64_t v78 = vrev32q_s8(v439);
LABEL_539:
                  unint64_t v442 = v37 + 16 * v432;
                  if (v442 >= v56) {
                    uint64_t v443 = -(uint64_t)(int)v698;
                  }
                  else {
                    uint64_t v443 = 0;
                  }
                  uint64_t v37 = v442 + 16 * v443;
                  v78 += v434;
                  --v435;
                }
                while (v435);
                v78 += 16 * v715;
                unint64_t v444 = v55 + 16 * v719;
                uint64_t v445 = -(uint64_t)(v719 * (int)v695);
                if (v444 < v717) {
                  uint64_t v445 = 0;
                }
                unint64_t v446 = v444 + 16 * v445;
                uint64_t v447 = v56 + 16 * v445 + 16 * v719;
                if (v717)
                {
                  unint64_t v56 = v447;
                  unint64_t v55 = v446;
                  uint64_t v37 = v446;
                }
                else
                {
                  v37 += 16 * v719;
                }
                int v433 = v709 - 1;
                if (v709 == 1) {
                  goto LABEL_569;
                }
              }
            case 27:
              unint64_t v693 = v38;
              unint64_t v694 = v39;
              uint64_t v448 = (int)v47;
              int v449 = v721[0];
              uint64_t v450 = 16 * (int)v47;
              break;
            default:
              goto LABEL_617;
          }
          break;
        }
LABEL_551:
        int v710 = v449;
        int v451 = v713;
        while (1)
        {
          LODWORD(v14) = 1.0;
          if (!v54 || (LODWORD(v14) = bswap32(*(_DWORD *)(v37 + 12)), *(float *)&v14 > 0.0))
          {
            if (!v18)
            {
              v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
              float v452 = 1.0;
LABEL_558:
              int8x8_t v454 = vrev32_s8(*(int8x8_t *)v78);
              int8x16_t v687 = vrev32q_s8(*(int8x16_t *)v37);
              *(float *)v455.unint64_t i32 = PDAluminosityPDA(*(float *)v454.i32, *(float *)&v454.i32[1], COERCE_FLOAT(bswap32(*(_DWORD *)(v78 + 8))), *(double *)v12.i64, v452, v14, *(double *)v687.i64, v16, *(float *)v687.i32, *(float *)&v687.i32[1], *(float *)&v687.i32[2], *(float *)&v687.i32[3], *(float *)&v14);
              v455.i32[1] = v456;
              v455.i64[1] = __PAIR64__(v12.u32[0], v457);
              *(int8x16_t *)unint64_t v78 = vrev32q_s8(v455);
              goto LABEL_559;
            }
            v12.i32[0] = bswap32(*(_DWORD *)(v78 + 12));
            float v452 = *(float *)v12.i32;
            if (*(float *)v12.i32 > 0.0) {
              goto LABEL_558;
            }
            int v453 = *(_DWORD *)(v37 + 8);
            *(void *)unint64_t v78 = *(void *)v37;
            *(_DWORD *)(v78 + 8) = v453;
            *(_DWORD *)(v78 + 12) = bswap32(LODWORD(v14));
          }
LABEL_559:
          unint64_t v458 = v37 + 16 * v448;
          if (v458 >= v56) {
            uint64_t v459 = -(uint64_t)(int)v698;
          }
          else {
            uint64_t v459 = 0;
          }
          uint64_t v37 = v458 + 16 * v459;
          v78 += v450;
          if (!--v451)
          {
            v78 += 16 * v715;
            unint64_t v460 = v55 + 16 * v719;
            uint64_t v461 = -(uint64_t)(v719 * (int)v695);
            if (v460 < v717) {
              uint64_t v461 = 0;
            }
            unint64_t v462 = v460 + 16 * v461;
            uint64_t v463 = v56 + 16 * v461 + 16 * v719;
            if (v717)
            {
              unint64_t v56 = v463;
              unint64_t v55 = v462;
              uint64_t v37 = v462;
            }
            else
            {
              v37 += 16 * v719;
            }
            int v449 = v710 - 1;
            if (v710 == 1)
            {
LABEL_569:
              v721[0] = 0;
              LODWORD(v19) = v689;
              uint64_t v21 = v692;
              unint64_t v38 = v693;
              unint64_t v39 = v694;
              goto LABEL_617;
            }
            goto LABEL_551;
          }
        }
      }
      int v713 = v22;
      unint64_t v715 = v38 - v22;
      if (v37)
      {
        uint64_t v696 = *(void *)(v3 + 88);
        uint64_t v697 = 0;
        int v76 = v42 % (int)v698;
        unint64_t v719 = (unint64_t)*(int *)(v3 + 76) >> 4;
        unint64_t v77 = v37 + 16 * v44 * (v43 % (int)v695);
        unint64_t v55 = v77 + 16 * v76;
        unint64_t v56 = v77 + 16 * (int)v698;
        uint64_t v47 = 1;
        uint64_t v37 = v55;
        unint64_t v78 = *(void *)(v3 + 40) + 16 * (*(int *)(v3 + 12) + v38 * *(int *)(v3 + 16));
        int v690 = v43 % (int)v695;
        int v691 = v76;
        goto LABEL_48;
      }
      int v690 = *(_DWORD *)(v3 + 60);
      int v691 = *(_DWORD *)(v3 + 56);
      unint64_t v56 = 0;
      uint64_t v47 = 1;
      unint64_t v79 = v22;
LABEL_46:
      uint64_t v696 = v37;
      uint64_t v697 = 0;
      unint64_t v717 = 0;
      unint64_t v55 = 0;
      unint64_t v719 = v44 - v79;
      unint64_t v78 = v39;
      goto LABEL_48;
    }
    v37 += 16 * (v42 + v44 * v43);
    if (v44 == v38)
    {
      if ((uint64_t)(v39 - v37) < 1) {
        goto LABEL_20;
      }
      if (v22 < (v39 - v37) >> 4)
      {
        unint64_t v45 = v38 * v25;
        uint64_t v46 = v37 + 16 * v38 * v25;
        if (v39 <= v46 + 16 * (unint64_t)v23)
        {
          v39 += 16 * v45;
          unint64_t v38 = -(uint64_t)v38;
          uint64_t v47 = 1;
          uint64_t v37 = v46;
          goto LABEL_40;
        }
LABEL_20:
        uint64_t v47 = 1;
LABEL_40:
        unint64_t v698 = v38;
        goto LABEL_41;
      }
      v39 += 16 * v23;
      unint64_t v698 = (unint64_t)*(int *)(v3 + 28) >> 4;
      v37 += 16 * v23;
      uint64_t v47 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v47 = 1;
      unint64_t v698 = (unint64_t)*(int *)(v3 + 76) >> 4;
    }
LABEL_41:
    BOOL v54 = v17 != 0;
    int v690 = *(_DWORD *)(v3 + 60);
    int v691 = *(_DWORD *)(v3 + 56);
    if (v26)
    {
      LODWORD(v695) = 0;
      unint64_t v55 = 0;
      unint64_t v717 = 0;
      unint64_t v56 = -1;
      unint64_t v719 = v698;
      goto LABEL_43;
    }
    LODWORD(v695) = 0;
    unint64_t v79 = (int)v47 * (int)v22;
    int v713 = v22;
    unint64_t v715 = v38 - v79;
    unint64_t v56 = -1;
    unint64_t v44 = v698;
    goto LABEL_46;
  }
  uint64_t v27 = *(unsigned int *)(v3 + 128);
  if ((v27 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      RGBAF_mark_constmask(v3, v19, (uint64_t)v26, v4, v5, v6, v27, v8, v9, *(double *)v10.i64, *(double *)v11.i64, *(double *)v12.i64, v13, v14, v15, v16);
    }
    else {
      RGBAF_mark_pixelmask(v3, v19, v9, *(double *)v10.i64, v11, v12, v13.n128_f64[0], v14, v15, v16);
    }
    return 1;
  }
  int v48 = *(_DWORD *)(v3 + 112);
  int v49 = *(_DWORD *)(v3 + 116);
  unsigned int v50 = (v48 + 15) & 0xFFFFFFF0;
  size_t v51 = v50 * v49;
  if ((int)v51 <= 4096)
  {
    float v36 = v731;
    uint64_t v53 = v3;
    goto LABEL_29;
  }
  int v52 = malloc_type_malloc(v51, 0x5EE44C10uLL);
  if (v52)
  {
    float v36 = v52;
    uint64_t v53 = v692;
    uint64_t v26 = *(uint16x4_t **)(v692 + 136);
    LODWORD(v27) = *(_DWORD *)(v692 + 128);
LABEL_29:
    CGSConvertBitsToMask(v26, *(_DWORD *)(v53 + 124), v36, v50, v48, v49, v27);
    long long v70 = *(_OWORD *)(v53 + 112);
    long long v727 = *(_OWORD *)(v53 + 96);
    long long v728 = v70;
    long long v71 = *(_OWORD *)(v53 + 144);
    long long v729 = *(_OWORD *)(v53 + 128);
    long long v730 = v71;
    long long v72 = *(_OWORD *)(v53 + 48);
    long long v723 = *(_OWORD *)(v53 + 32);
    long long v724 = v72;
    long long v73 = *(_OWORD *)(v53 + 80);
    long long v725 = *(_OWORD *)(v53 + 64);
    long long v726 = v73;
    long long v74 = *(_OWORD *)v53;
    long long v75 = *(_OWORD *)(v53 + 16);
    *(_OWORD *)__int32 v721 = *(_OWORD *)v53;
    long long v722 = v75;
    HIDWORD(v728) = (v48 + 15) & 0xFFFFFFF0;
    *((void *)&v729 + 1) = v36;
    if (BYTE1(v721[0]) << 8 == 1024) {
      RGBAF_mark_constmask((uint64_t)v721, v19, v58, v59, v60, v61, v62, v63, *(double *)&v74, *(double *)&v75, *(double *)v64.i64, *(double *)v65.i64, v66, v67, v68, v69);
    }
    else {
      RGBAF_mark_pixelmask((uint64_t)v721, v19, *(double *)&v74, *(double *)&v75, v64, v65, v66.n128_f64[0], v67, v68, v69);
    }
    if (v36 == (unsigned char *)v731) {
      return 1;
    }
LABEL_47:
    float32x2_t v82 = v36;
    goto LABEL_626;
  }
  return 1;
}

void RGBAF_mark_constmask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, __n128 a13, double a14, double a15, double a16)
{
  uint64_t v16 = *(void *)(a1 + 136);
  if (v16)
  {
    int v18 = *(_DWORD *)(a1 + 4);
    int v17 = *(_DWORD *)(a1 + 8);
    uint64_t v19 = *(void *)(a1 + 48);
    int8x16_t v20 = *(int8x16_t *)*(void *)(a1 + 88);
    float32x4_t v21 = (float32x4_t)vrev32q_s8(v20);
    unint64_t v22 = (unint64_t)*(int *)(a1 + 28) >> 4;
    unint64_t v23 = *(void *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v22 * *(int *)(a1 + 16));
    uint64_t v24 = *(int *)(a1 + 124);
    unint64_t v25 = v16 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v24;
    uint64_t v26 = v24 - v18;
    unint64_t v27 = v22 - v18;
    float32x4_t v234 = v21;
    switch((int)a2)
    {
      case 0:
        do
        {
          int v28 = v18;
          do
          {
            int v29 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v29 == 255)
              {
                *(void *)unint64_t v23 = 0;
                *(void *)(v23 + 8) = 0;
              }
              else
              {
                *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)(v29 ^ 0xFFu) * 0.0039216));
              }
            }
            ++v25;
            v23 += 16;
            --v28;
          }
          while (v28);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 1:
        int v30 = -1;
        unsigned int v31 = v25 & 3;
        if ((v25 & 3) != 0)
        {
          v18 += v31;
          int v30 = -1 << (8 * v31);
          unint64_t v32 = v25 & 3;
          v25 &= 0xFFFFFFFFFFFFFFFCLL;
          v23 -= 16 * v32;
        }
        unsigned int v33 = ((_BYTE)v18 + (_BYTE)v25) & 3;
        if ((((_BYTE)v18 + (_BYTE)v25) & 3) != 0)
        {
          unsigned int v34 = 4 - v33;
          v31 += v34;
          unsigned int v35 = 0xFFFFFFFF >> (8 * v34);
          if (v18 >= 4) {
            unsigned int v33 = 0xFFFFFFFF >> (8 * v34);
          }
          else {
            unsigned int v33 = 0;
          }
          if (v18 >= 4) {
            unsigned int v35 = -1;
          }
          v30 &= v35;
        }
        uint64_t v36 = v26 - v31;
        unint64_t v37 = v27 - v31;
        do
        {
          unsigned int v38 = *(_DWORD *)v25 & v30;
          int v39 = v18 >> 2;
          unsigned int v40 = v33;
          if (!v38) {
            goto LABEL_40;
          }
LABEL_22:
          if (v38 == -1)
          {
            *(int8x16_t *)unint64_t v23 = v20;
            *(int8x16_t *)(v23 + 16) = v20;
            *(int8x16_t *)(v23 + 32) = v20;
LABEL_37:
            *(int8x16_t *)(v23 + 48) = v20;
            goto LABEL_40;
          }
          while (1)
          {
            if ((_BYTE)v38)
            {
              int8x16_t v41 = v20;
              if (v38 != 255) {
                int8x16_t v41 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)v38 * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - (float)((float)v38 * 0.0039216)));
              }
              *(int8x16_t *)unint64_t v23 = v41;
            }
            if (BYTE1(v38))
            {
              int8x16_t v42 = v20;
              if (BYTE1(v38) != 255) {
                int8x16_t v42 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)BYTE1(v38) * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16)), 1.0 - (float)((float)BYTE1(v38) * 0.0039216)));
              }
              *(int8x16_t *)(v23 + 16) = v42;
            }
            if (BYTE2(v38))
            {
              int8x16_t v43 = v20;
              if (BYTE2(v38) != 255) {
                int8x16_t v43 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)BYTE2(v38) * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32)), 1.0 - (float)((float)BYTE2(v38) * 0.0039216)));
              }
              *(int8x16_t *)(v23 + 32) = v43;
            }
            unsigned int v44 = HIBYTE(v38);
            if (v44 == 255) {
              goto LABEL_37;
            }
            if (v44) {
              *(int8x16_t *)(v23 + 48) = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)v44 * 0.0039216), (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 48)), 1.0 - (float)((float)v44 * 0.0039216)));
            }
LABEL_40:
            while (1)
            {
              int v45 = v39;
              v23 += 64;
              --v39;
              v25 += 4;
              if (v45 < 2) {
                break;
              }
              unsigned int v38 = *(_DWORD *)v25;
              if (*(_DWORD *)v25) {
                goto LABEL_22;
              }
            }
            if (!v40) {
              break;
            }
            unsigned int v40 = 0;
            unsigned int v38 = *(_DWORD *)v25 & v33;
          }
          v25 += v36;
          v23 += 16 * v37;
          --v17;
        }
        while (v17);
        return;
      case 2:
        int v46 = -1;
        unsigned int v47 = v25 & 3;
        if ((v25 & 3) != 0)
        {
          v18 += v47;
          int v46 = -1 << (8 * v47);
          unint64_t v48 = v25 & 3;
          v25 &= 0xFFFFFFFFFFFFFFFCLL;
          v23 -= 16 * v48;
        }
        unsigned int v49 = ((_BYTE)v18 + (_BYTE)v25) & 3;
        if ((((_BYTE)v18 + (_BYTE)v25) & 3) != 0)
        {
          unsigned int v50 = 4 - v49;
          v47 += v50;
          unsigned int v51 = 0xFFFFFFFF >> (8 * v50);
          if (v18 >= 4) {
            unsigned int v49 = 0xFFFFFFFF >> (8 * v50);
          }
          else {
            unsigned int v49 = 0;
          }
          if (v18 >= 4) {
            unsigned int v51 = -1;
          }
          v46 &= v51;
        }
        uint64_t v52 = v26 - v47;
        *(float *)v20.unint64_t i32 = 1.0 - v21.f32[3];
        float32x4_t v53 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.i8, 0);
        unint64_t v54 = v27 - v47;
        while (1)
        {
          unsigned int v55 = *(_DWORD *)v25 & v46;
          int v56 = v18 >> 2;
          unsigned int v57 = v49;
          if (!v55) {
            goto LABEL_69;
          }
LABEL_58:
          if (v55 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v55)
            {
              float32x4_t v61 = vmulq_n_f32(v21, (float)v55 * 0.0039216);
              *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v61, (float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - v61.f32[3]));
            }
            if ((v55 & 0xFF00) != 0)
            {
              float32x4_t v62 = vmulq_n_f32(v21, (float)BYTE1(v55) * 0.0039216);
              *(int8x16_t *)(v23 + 16) = vrev32q_s8((int8x16_t)vmlaq_n_f32(v62, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16)), 1.0 - v62.f32[3]));
            }
            if ((v55 & 0xFF0000) != 0)
            {
              float32x4_t v63 = vmulq_n_f32(v21, (float)BYTE2(v55) * 0.0039216);
              *(int8x16_t *)(v23 + 32) = vrev32q_s8((int8x16_t)vmlaq_n_f32(v63, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32)), 1.0 - v63.f32[3]));
            }
            unsigned int v64 = HIBYTE(v55);
            if (v64)
            {
              float32x4_t v65 = vmulq_n_f32(v21, (float)v64 * 0.0039216);
              int8x16_t v60 = (int8x16_t)vmlaq_n_f32(v65, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 48)), 1.0 - v65.f32[3]);
              goto LABEL_68;
            }
LABEL_69:
            while (1)
            {
              int v66 = v56;
              v23 += 64;
              --v56;
              v25 += 4;
              if (v66 < 2) {
                break;
              }
              unsigned int v55 = *(_DWORD *)v25;
              if (*(_DWORD *)v25) {
                goto LABEL_58;
              }
            }
            if (!v57) {
              break;
            }
            unsigned int v57 = 0;
            unsigned int v55 = *(_DWORD *)v25 & v49;
          }
          v25 += v52;
          v23 += 16 * v54;
          if (!--v17) {
            return;
          }
        }
        int8x16_t v58 = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 16))));
        *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)v23)));
        *(int8x16_t *)(v23 + 16) = v58;
        int8x16_t v59 = *(int8x16_t *)(v23 + 48);
        *(int8x16_t *)(v23 + 32) = vrev32q_s8((int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(*(int8x16_t *)(v23 + 32))));
        int8x16_t v60 = (int8x16_t)vmlaq_f32(v21, v53, (float32x4_t)vrev32q_s8(v59));
LABEL_68:
        *(_DWORD *)(v23 + 48) = bswap32(v60.u32[0]);
        *(int8x8_t *)(v23 + 52) = vrev32_s8(vext_s8(*(int8x8_t *)v60.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v60, v60, 8uLL), 4uLL));
        *(_DWORD *)(v23 + 60) = bswap32(v60.u32[3]);
        goto LABEL_69;
      case 3:
        do
        {
          int v67 = v18;
          do
          {
            unsigned int v68 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v68 == 255)
              {
                int8x16_t v69 = (int8x16_t)vmulq_n_f32(v21, COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12))));
              }
              else
              {
                float32x4_t v70 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
                int8x16_t v69 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, vmuls_lane_f32((float)v68 * 0.0039216, v70, 3)), v70, 1.0 - (float)((float)v68 * 0.0039216));
              }
              *(int8x16_t *)unint64_t v23 = vrev32q_s8(v69);
            }
            ++v25;
            v23 += 16;
            --v67;
          }
          while (v67);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 4:
        do
        {
          int v71 = v18;
          do
          {
            unsigned int v72 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v72 == 255)
              {
                int8x16_t v73 = (int8x16_t)vmulq_n_f32(v21, 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12))));
              }
              else
              {
                float32x4_t v74 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
                int8x16_t v73 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v21, (float)((float)v72 * 0.0039216) * (float)(1.0 - v74.f32[3])), v74, 1.0 - (float)((float)v72 * 0.0039216));
              }
              *(int8x16_t *)unint64_t v23 = vrev32q_s8(v73);
            }
            ++v25;
            v23 += 16;
            --v71;
          }
          while (v71);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 5:
        do
        {
          int v75 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float32x4_t v76 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              float32x4_t v77 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v77, 1.0 - v76.f32[3]), v76, v77, 3));
            }
            ++v25;
            v23 += 16;
            --v75;
          }
          while (v75);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 6:
        while (1)
        {
          int v78 = v18;
          do
          {
            unsigned int v79 = *(unsigned __int8 *)v25;
            if (!*(unsigned char *)v25) {
              goto LABEL_107;
            }
            float v80 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
            float v81 = 1.0 - v80;
            if ((float)(1.0 - v80) >= 1.0)
            {
              float v86 = (float)v79 * 0.0039216;
              unsigned int v83 = bswap32(COERCE_UNSIGNED_INT(v86 * v21.f32[2]));
              unsigned int v84 = bswap32(COERCE_UNSIGNED_INT(v86 * v21.f32[3]));
              int8x8_t v85 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v21.f32, v86));
            }
            else
            {
              if (v81 <= 0.0) {
                goto LABEL_107;
              }
              float v82 = (float)v79 * 0.0039216;
              unsigned int v83 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))) + (float)((float)(v82 * v21.f32[2]) * v81)));
              unsigned int v84 = bswap32(COERCE_UNSIGNED_INT(v80 + (float)((float)(v82 * v21.f32[3]) * v81)));
              int8x8_t v85 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v23), vmul_n_f32(*(float32x2_t *)v21.f32, v82), v81));
            }
            *(int8x8_t *)unint64_t v23 = v85;
            *(_DWORD *)(v23 + 8) = v83;
            *(_DWORD *)(v23 + 12) = v84;
LABEL_107:
            ++v25;
            v23 += 16;
            --v78;
          }
          while (v78);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 7:
        do
        {
          int v87 = v18;
          do
          {
            unsigned int v88 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v88 == 255) {
                int8x16_t v89 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), v21, 3);
              }
              else {
                int8x16_t v89 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)((float)((float)v88 * 0.0039216) * v21.f32[3])+ (float)(1.0 - (float)((float)v88 * 0.0039216)));
              }
              *(int8x16_t *)unint64_t v23 = vrev32q_s8(v89);
            }
            ++v25;
            v23 += 16;
            --v87;
          }
          while (v87);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 8:
        do
        {
          int v90 = v18;
          do
          {
            unsigned int v91 = *(unsigned __int8 *)v25;
            if (*(unsigned char *)v25)
            {
              if (v91 == 255) {
                int8x16_t v92 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), 1.0 - v21.f32[3]);
              }
              else {
                int8x16_t v92 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*(int8x16_t *)v23), (float)((float)((float)v91 * -0.0039216) * v21.f32[3]) + 1.0);
              }
              *(int8x16_t *)unint64_t v23 = vrev32q_s8(v92);
            }
            ++v25;
            v23 += 16;
            --v90;
          }
          while (v90);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 9:
        do
        {
          int v93 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v94 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              float v95 = 1.0 - v94;
              float32x4_t v96 = vmulq_n_f32(v21, v94);
              float32x4_t v97 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v97, v95 + v96.f32[3]), v96, 1.0 - v97.f32[3]));
            }
            ++v25;
            v23 += 16;
            --v93;
          }
          while (v93);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 10:
        do
        {
          int v98 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float32x4_t v99 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              float32x4_t v100 = (float32x4_t)vrev32q_s8(*(int8x16_t *)v23);
              *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v100, 1.0 - v99.f32[3]), v99, 1.0 - v100.f32[3]));
            }
            ++v25;
            v23 += 16;
            --v98;
          }
          while (v98);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 11:
        do
        {
          int v101 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              if (v19) {
                a13.n128_u32[0] = bswap32(*(_DWORD *)(v23 + 12));
              }
              else {
                a13.n128_u32[0] = 1.0;
              }
              *(float *)&a14 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              float32x2_t v102 = vmul_n_f32(*(float32x2_t *)v21.f32, *(float *)&a14);
              float v103 = *(float *)&a14 * v21.f32[2];
              *(float *)&a14 = *(float *)&a14 * v21.f32[3];
              float32x2_t v104 = vsub_f32((float32x2_t)vdup_lane_s32((int32x2_t)a13.n128_u64[0], 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v23));
              float v105 = *(float *)&a14 + a13.n128_f32[0];
              float32x2_t v106 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a14, 0), v102);
              float v107 = (float)(*(float *)&a14 - v103)
                   + (float)(a13.n128_f32[0] - COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))));
              if (v105 <= 1.0) {
                *(float *)&a14 = v105;
              }
              else {
                *(float *)&a14 = 1.0;
              }
              *(float32x2_t *)v108.unint64_t i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a14, 0), vadd_f32(v106, v104));
              *(float *)&v108.i32[2] = *(float *)&a14 - v107;
              v108.i32[3] = LODWORD(a14);
              a13 = (__n128)vrev32q_s8(v108);
              *(__n128 *)unint64_t v23 = a13;
            }
            ++v25;
            v23 += 16;
            --v101;
          }
          while (v101);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 12:
        do
        {
          int v109 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v110 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              float v111 = v110 * v21.f32[2];
              float v112 = (float)(v110 * v21.f32[3]) + COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
              *(float32x2_t *)v113.unint64_t i8 = vadd_f32(vmul_n_f32(*(float32x2_t *)v21.f32, v110), (float32x2_t)vrev32_s8(*(int8x8_t *)v23));
              float v114 = v111 + COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
              if (v112 > 1.0) {
                float v112 = 1.0;
              }
              v113.i64[1] = __PAIR64__(LODWORD(v112), LODWORD(v114));
              *(int8x16_t *)unint64_t v23 = vrev32q_s8(v113);
            }
            ++v25;
            v23 += 16;
            --v109;
          }
          while (v109);
          v25 += v26;
          v23 += 16 * v27;
          --v17;
        }
        while (v17);
        return;
      case 13:
        while (1)
        {
          int v115 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v116 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v116.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v117 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_168;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v117 = 1.0;
                }
                double v118 = *(double *)v23;
                double v119 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v118) = HIDWORD(v119);
                *(void *)&double v120 = vextq_s8(v116, v116, 4uLL).u64[0];
                *(float *)v116.unint64_t i32 = PDAmultiplyPDA(*(float *)&v119, v118, a11, a12, v117, v119, v120, a16, *(float *)v116.i32, COERCE_DOUBLE(__PAIR64__(v116.u32[3], HIDWORD(v120))), *(float *)&v116.i32[3]);
                float32x4_t v21 = v234;
                v116.i32[1] = v121;
                v116.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_168:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v116);
              }
            }
            ++v25;
            v23 += 16;
            --v115;
          }
          while (v115);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 14:
        float32x2_t v122 = (float32x2_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL).u64[0];
        __asm { FMOV            V3.2S, #1.0 }
        while (1)
        {
          int v128 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v129 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              float32x2_t v130 = vmul_n_f32(v122, v129);
              if (v130.f32[1] > 0.0)
              {
                *(float32x2_t *)v131.unint64_t i8 = vmul_n_f32(*(float32x2_t *)v21.f32, v129);
                if (v19)
                {
                  float v132 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  if (v132 <= 0.0)
                  {
                    v131.u64[1] = (unint64_t)v130;
                    *(int8x16_t *)unint64_t v23 = vrev32q_s8(v131);
                    goto LABEL_181;
                  }
                }
                else
                {
                  float v132 = 1.0;
                }
                float v133 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
                unsigned int v134 = bswap32(COERCE_UNSIGNED_INT(vmlas_n_f32(v133, 1.0 - v133, v130.f32[0])));
                *(float *)&unsigned int v135 = (float)(v130.f32[1] + v132) - (float)(v132 * v130.f32[1]);
                float32x2_t v136 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                *(int8x8_t *)unint64_t v23 = vrev32_s8((int8x8_t)vmla_f32(v136, vsub_f32(_D3, v136), *(float32x2_t *)v131.i8));
                *(_DWORD *)(v23 + 8) = v134;
                *(_DWORD *)(v23 + 12) = bswap32(v135);
              }
            }
LABEL_181:
            ++v25;
            v23 += 16;
            --v128;
          }
          while (v128);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 15:
        while (1)
        {
          int v137 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v138 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v138.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v139 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_192;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v139 = 1.0;
                }
                double v140 = *(double *)v23;
                double v141 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v140) = HIDWORD(v141);
                *(void *)&double v142 = vextq_s8(v138, v138, 4uLL).u64[0];
                *(float *)v138.unint64_t i32 = PDAoverlayPDA(*(float *)&v141, v140, a11, a12, v139, v141, v142, a16, *(float *)v138.i32, COERCE_DOUBLE(__PAIR64__(v138.u32[3], HIDWORD(v142))), *(float *)&v138.i32[3]);
                float32x4_t v21 = v234;
                v138.i32[1] = v143;
                v138.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_192:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v138);
              }
            }
            ++v25;
            v23 += 16;
            --v137;
          }
          while (v137);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 16:
        while (1)
        {
          int v144 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v145 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v145.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v146 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_204;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v146 = 1.0;
                }
                double v147 = *(double *)v23;
                double v148 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v147) = HIDWORD(v148);
                *(void *)&double v149 = vextq_s8(v145, v145, 4uLL).u64[0];
                *(float *)v145.unint64_t i32 = PDAdarkenPDA(*(float *)&v148, v147, a11, a12, v146, v148, v149, a16, *(float *)v145.i32, COERCE_DOUBLE(__PAIR64__(v145.u32[3], HIDWORD(v149))), *(float *)&v145.i32[3]);
                float32x4_t v21 = v234;
                v145.i32[1] = v150;
                v145.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_204:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v145);
              }
            }
            ++v25;
            v23 += 16;
            --v144;
          }
          while (v144);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 17:
        while (1)
        {
          int v151 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v152 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v152.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v153 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_216;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v153 = 1.0;
                }
                double v154 = *(double *)v23;
                double v155 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v154) = HIDWORD(v155);
                *(void *)&double v156 = vextq_s8(v152, v152, 4uLL).u64[0];
                *(float *)v152.unint64_t i32 = PDAlightenPDA(*(float *)&v155, v154, a11, a12, v153, v155, v156, a16, *(float *)v152.i32, COERCE_DOUBLE(__PAIR64__(v152.u32[3], HIDWORD(v156))), *(float *)&v152.i32[3]);
                float32x4_t v21 = v234;
                v152.i32[1] = v157;
                v152.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_216:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v152);
              }
            }
            ++v25;
            v23 += 16;
            --v151;
          }
          while (v151);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 18:
        while (1)
        {
          int v158 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v159 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v159.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v160 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_228;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v160 = 1.0;
                }
                double v161 = *(double *)v23;
                double v162 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v161) = HIDWORD(v162);
                *(void *)&double v163 = vextq_s8(v159, v159, 4uLL).u64[0];
                *(float *)v159.unint64_t i32 = PDAcolordodgePDA(*(float *)&v162, v161, a11, a12, v160, v162, v163, a16, *(float *)v159.i32, COERCE_DOUBLE(__PAIR64__(v159.u32[3], HIDWORD(v163))), *(float *)&v159.i32[3]);
                float32x4_t v21 = v234;
                v159.i32[1] = v164;
                v159.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_228:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v159);
              }
            }
            ++v25;
            v23 += 16;
            --v158;
          }
          while (v158);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 19:
        while (1)
        {
          int v165 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v166 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v166.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v167 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_240;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v167 = 1.0;
                }
                double v168 = *(double *)v23;
                double v169 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v168) = HIDWORD(v169);
                *(void *)&double v170 = vextq_s8(v166, v166, 4uLL).u64[0];
                *(float *)v166.unint64_t i32 = PDAcolorburnPDA(*(float *)&v169, v168, a11, a12, v167, v169, v170, a16, *(float *)v166.i32, COERCE_DOUBLE(__PAIR64__(v166.u32[3], HIDWORD(v170))), *(float *)&v166.i32[3]);
                float32x4_t v21 = v234;
                v166.i32[1] = v171;
                v166.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_240:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v166);
              }
            }
            ++v25;
            v23 += 16;
            --v165;
          }
          while (v165);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 20:
        while (1)
        {
          int v172 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v173 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v173.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  a13.n128_u32[0] = LODWORD(a12);
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_252;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  a13.n128_u32[0] = 1.0;
                }
                double v174 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                DWORD2(v230) = v173.i32[3];
                *(void *)&long long v230 = vextq_s8(v173, v173, 4uLL).u64[0];
                *(float *)v173.unint64_t i32 = PDAsoftlightPDA(*(float *)&v174, *((float *)&v174 + 1), a11, *(int32x2_t *)&a12, a13.n128_f64[0], v174, *(double *)&v230, a16, a1, a2, a3, a4, a5, a6, a7, a8, *(float *)v173.i32, v230, *(uint64_t *)((char *)&v230 + 4),
                                       *(float *)&v173.i32[3]);
                float32x4_t v21 = v234;
                v173.i32[1] = v175;
                v173.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_252:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v173);
              }
            }
            ++v25;
            v23 += 16;
            --v172;
          }
          while (v172);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 21:
        while (1)
        {
          int v176 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v177 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v177.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v178 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_264;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v178 = 1.0;
                }
                double v179 = *(double *)v23;
                double v180 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                LODWORD(a11) = bswap32(*(_DWORD *)(v23 + 8));
                LODWORD(v179) = HIDWORD(v180);
                *(void *)&double v181 = vextq_s8(v177, v177, 4uLL).u64[0];
                *(float *)v177.unint64_t i32 = PDAhardlightPDA(*(float *)&v180, v179, a11, a12, v178, v180, v181, a16, *(float *)v177.i32, COERCE_DOUBLE(__PAIR64__(v177.u32[3], HIDWORD(v181))), *(float *)&v177.i32[3]);
                float32x4_t v21 = v234;
                v177.i32[1] = v182;
                v177.i64[1] = __PAIR64__(LODWORD(a12), LODWORD(a11));
LABEL_264:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v177);
              }
            }
            ++v25;
            v23 += 16;
            --v176;
          }
          while (v176);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 22:
        while (1)
        {
          int v183 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float32x4_t v184 = vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (v184.f32[3] > 0.0)
              {
                if (v19)
                {
                  float v185 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  if (v185 <= 0.0)
                  {
LABEL_278:
                    *(int8x16_t *)unint64_t v23 = vrev32q_s8((int8x16_t)v184);
                    goto LABEL_279;
                  }
                }
                else
                {
                  float v185 = 1.0;
                }
                float v186 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8)));
                float32x2_t v187 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                float32x2_t v188 = vadd_f32(*(float32x2_t *)v184.f32, v187);
                float32x2_t v189 = vmul_laneq_f32(v187, v184, 3);
                float32x2_t v190 = vmul_n_f32(*(float32x2_t *)v184.f32, v185);
                float32x2_t v191 = vsub_f32(v188, v189);
                float32x2_t v192 = vsub_f32(v189, v190);
                v184.f32[0] = vmuls_lane_f32(v185, v184, 2);
                *(float32x2_t *)v193.f32 = vadd_f32(vsub_f32(v191, v190), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v192), (int8x8_t)vneg_f32(v192), (int8x8_t)v192));
                float v194 = (float)(v184.f32[3] * v186) - v184.f32[0];
                v184.f32[0] = (float)((float)(v184.f32[2] + v186) - (float)(v184.f32[3] * v186)) - v184.f32[0];
                if (v194 < 0.0) {
                  float v194 = -v194;
                }
                v193.i64[1] = __PAIR64__((float)(v185 + v184.f32[3]) - (float)(v185 * v184.f32[3]), v184.f32[0] + v194);
                float32x4_t v184 = v193;
                goto LABEL_278;
              }
            }
LABEL_279:
            ++v25;
            v23 += 16;
            --v183;
          }
          while (v183);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 23:
        float32x2_t v195 = (float32x2_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL).u64[0];
        while (1)
        {
          int v196 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              float v197 = (float)*(unsigned __int8 *)v25 * 0.0039216;
              float32x2_t v198 = vmul_n_f32(v195, v197);
              if (v198.f32[1] > 0.0)
              {
                *(float32x2_t *)v199.unint64_t i8 = vmul_n_f32(*(float32x2_t *)v21.f32, v197);
                if (v19)
                {
                  LODWORD(v200) = bswap32(*(_DWORD *)(v23 + 12));
                  if (v200 <= 0.0)
                  {
                    v199.u64[1] = (unint64_t)v198;
                    *(int8x16_t *)unint64_t v23 = vrev32q_s8(v199);
                    goto LABEL_291;
                  }
                }
                else
                {
                  float v200 = 1.0;
                }
                LODWORD(v201) = bswap32(*(_DWORD *)(v23 + 8));
                v202.f32[0] = (float)-v201 * v198.f32[0];
                float32_t v203 = -v200;
                float32x2_t v204 = (float32x2_t)vrev32_s8(*(int8x8_t *)v23);
                float32x2_t v205 = vadd_f32(v198, (float32x2_t)__PAIR64__(LODWORD(v200), LODWORD(v201)));
                v202.f32[1] = v203;
                v198.i32[0] = 2.0;
                *(int8x8_t *)unint64_t v23 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v199.i8, v204), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v199.i8, v204)));
                *(int8x8_t *)(v23 + 8) = vrev32_s8((int8x8_t)vmla_f32(v205, v198, v202));
              }
            }
LABEL_291:
            ++v25;
            v23 += 16;
            --v196;
          }
          while (v196);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 24:
        while (1)
        {
          int v206 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v207 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v207.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v208 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_302;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v208 = 1.0;
                }
                double v209 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(void *)&double v231 = vextq_s8(v207, v207, 4uLL).u64[0];
                *(float *)v207.unint64_t i32 = PDAhuePDA(*(float *)&v209, *((float *)&v209 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v208, v209, v231, a16, *(float *)v207.i32, *(float *)&v231, *((float *)&v231 + 1), *(float *)&v207.i32[3], *(float *)&v207.i32[3]);
                float32x4_t v21 = v234;
                v207.i32[1] = v210;
                v207.i64[1] = __PAIR64__(LODWORD(a12), v211);
LABEL_302:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v207);
              }
            }
            ++v25;
            v23 += 16;
            --v206;
          }
          while (v206);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 25:
        while (1)
        {
          int v212 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v213 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              if (*(float *)&v213.i32[3] > 0.0)
              {
                if (v19)
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v214 = *(float *)&a12;
                  if (*(float *)&a12 <= 0.0) {
                    goto LABEL_314;
                  }
                }
                else
                {
                  LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
                  float v214 = 1.0;
                }
                double v215 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(void *)&double v232 = vextq_s8(v213, v213, 4uLL).u64[0];
                *(float *)v213.unint64_t i32 = PDAsaturationPDA(*(float *)&v215, *((float *)&v215 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v214, v215, v232, a16, *(float *)v213.i32, *(float *)&v232, *((float *)&v232 + 1), *(float *)&v213.i32[3], *(float *)&v213.i32[3]);
                float32x4_t v21 = v234;
                v213.i32[1] = v216;
                v213.i64[1] = __PAIR64__(LODWORD(a12), v217);
LABEL_314:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v213);
              }
            }
            ++v25;
            v23 += 16;
            --v212;
          }
          while (v212);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 26:
        while (1)
        {
          int v218 = v18;
          do
          {
            if (*(unsigned char *)v25)
            {
              int8x16_t v219 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
              LODWORD(a12) = v219.i32[3];
              if (*(float *)&v219.i32[3] > 0.0)
              {
                if (v19)
                {
                  float v220 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  *(float *)&a14 = v220;
                  if (v220 <= 0.0) {
                    goto LABEL_326;
                  }
                }
                else
                {
                  float v220 = COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 12)));
                  LODWORD(a14) = 1.0;
                }
                double v229 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
                *(float *)v219.unint64_t i32 = PDAluminosityPDA(*(float *)v219.i32, *(float *)&v219.i32[1], *(float *)&v219.i32[2], a12, *(float *)&v219.i32[3], a14, v229, a16, *(float *)&v229, *((float *)&v229 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), v220, *(float *)&a14);
                float32x4_t v21 = v234;
                v219.i32[1] = v221;
                v219.i64[1] = __PAIR64__(LODWORD(a12), v222);
LABEL_326:
                *(int8x16_t *)unint64_t v23 = vrev32q_s8(v219);
              }
            }
            ++v25;
            v23 += 16;
            --v218;
          }
          while (v218);
          v25 += v26;
          v23 += 16 * v27;
          if (!--v17) {
            return;
          }
        }
      case 27:
        break;
      default:
        return;
    }
LABEL_330:
    int v223 = v18;
    while (1)
    {
      if (!*(unsigned char *)v25) {
        goto LABEL_339;
      }
      int8x16_t v224 = (int8x16_t)vmulq_n_f32(v21, (float)*(unsigned __int8 *)v25 * 0.0039216);
      if (*(float *)&v224.i32[3] <= 0.0) {
        goto LABEL_339;
      }
      if (v19)
      {
        LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
        float v225 = *(float *)&a12;
        if (*(float *)&a12 <= 0.0) {
          goto LABEL_338;
        }
      }
      else
      {
        LODWORD(a12) = bswap32(*(_DWORD *)(v23 + 12));
        float v225 = 1.0;
      }
      double v226 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v23));
      *(void *)&double v233 = vextq_s8(v224, v224, 4uLL).u64[0];
      *(float *)v224.unint64_t i32 = PDAluminosityPDA(*(float *)&v226, *((float *)&v226 + 1), COERCE_FLOAT(bswap32(*(_DWORD *)(v23 + 8))), a12, v225, v226, v233, a16, *(float *)v224.i32, *(float *)&v233, *((float *)&v233 + 1), *(float *)&v224.i32[3], *(float *)&v224.i32[3]);
      float32x4_t v21 = v234;
      v224.i32[1] = v227;
      v224.i64[1] = __PAIR64__(LODWORD(a12), v228);
LABEL_338:
      *(int8x16_t *)unint64_t v23 = vrev32q_s8(v224);
LABEL_339:
      ++v25;
      v23 += 16;
      if (!--v223)
      {
        v25 += v26;
        v23 += 16 * v27;
        if (!--v17) {
          return;
        }
        goto LABEL_330;
      }
    }
  }
}

void RGBAF_mark_pixelmask(uint64_t a1, uint64_t a2, double a3, double a4, int8x16_t a5, int8x16_t a6, double a7, double a8, double a9, double a10)
{
  uint64_t v10 = *(void *)(a1 + 136);
  if (!v10) {
    return;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 4);
  uint64_t v12 = *(unsigned int *)(a1 + 8);
  uint64_t v13 = (int)v11;
  uint64_t v14 = *(void *)(a1 + 88);
  uint64_t v15 = *(void *)(a1 + 96);
  unint64_t v16 = (unint64_t)*(int *)(a1 + 28) >> 4;
  int v17 = (int8x16_t *)(*(void *)(a1 + 40) + 16 * (*(int *)(a1 + 12) + v16 * *(int *)(a1 + 16)));
  uint64_t v18 = *(int *)(a1 + 124);
  uint64_t v19 = (unsigned char *)(v10 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v18);
  uint64_t v20 = *(int *)(a1 + 56);
  uint64_t v21 = *(int *)(a1 + 60);
  unint64_t v22 = *(int *)(a1 + 76);
  if (*(unsigned __int8 *)(a1 + 1) << 8 == 256)
  {
    uint64_t v23 = v22 >> 4;
    uint64_t v24 = (int8x16_t *)(v14 + 16 * (v20 + (v22 >> 4) * v21));
    if (v22 >> 4 != v16)
    {
      int v26 = 1;
LABEL_14:
      int v27 = 0;
      uint64_t v13 = v26 * (int)v11;
      BOOL v29 = v15 != 0;
      uint64_t v30 = v18 - v13;
      uint64_t v31 = v16 - v13;
      unint64_t v36 = -1;
      int v28 = v23;
      goto LABEL_15;
    }
    if ((char *)v17 - (char *)v24 >= 1)
    {
      if ((int)v11 >= (uint64_t)((unint64_t)((char *)v17 - (char *)v24) >> 4))
      {
        v17 += (int)v11 - 1;
        v24 += (int)v11 - 1;
        v19 += (int)v11 - 1;
        int v26 = -1;
        goto LABEL_13;
      }
      uint64_t v25 = (int)v12 - 1;
      if (v17 <= &v24[v16 * v25 - 1 + (int)v11])
      {
        v17 += v16 * v25;
        uint64_t v23 = -(uint64_t)v16;
        v19 += v18 * v25;
        uint64_t v18 = -v18;
        int v26 = 1;
        v24 += v16 * v25;
        unint64_t v16 = -(uint64_t)v16;
        goto LABEL_14;
      }
    }
    int v26 = 1;
LABEL_13:
    uint64_t v23 = (unint64_t)*(int *)(a1 + 28) >> 4;
    goto LABEL_14;
  }
  int v28 = *(_DWORD *)(a1 + 64);
  int v27 = *(_DWORD *)(a1 + 68);
  uint64_t v23 = v22 >> 4;
  BOOL v29 = v15 != 0;
  uint64_t v30 = v18 - (int)v11;
  uint64_t v31 = v16 - (int)v11;
  if (v14)
  {
    uint64_t v32 = 0;
    unint64_t v33 = v14 + 16 * v23 * v27;
    uint64_t v34 = v14 + 16 * v23 * ((int)v21 % v27);
    unsigned int v35 = (int8x16_t *)(v34 + 16 * ((int)v20 % v28));
    unint64_t v36 = v34 + 16 * v28;
    int v26 = 1;
    uint64_t v24 = v35;
    goto LABEL_16;
  }
  uint64_t v24 = 0;
  unint64_t v36 = 0;
  int v26 = 1;
LABEL_15:
  unint64_t v33 = 0;
  unsigned int v35 = 0;
  v23 -= v13;
  uint64_t v32 = 1;
LABEL_16:
  uint64_t v37 = *(void *)(a1 + 48);
  uint64_t v524 = v30;
  uint64_t v525 = *(unsigned int *)(a1 + 4);
  uint64_t v522 = v31;
  uint64_t v523 = v23;
  int v521 = v32;
  unint64_t v520 = v33;
  switch((int)a2)
  {
    case 0:
      uint64_t v38 = v26;
      uint64_t v39 = 16 * v26;
      do
      {
        int v40 = v11;
        do
        {
          unsigned int v41 = *v19;
          if (*v19)
          {
            if (v41 == 255)
            {
              v17->i64[0] = 0;
              v17->i64[1] = 0;
            }
            else
            {
              *int v17 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v17), (float)((float)v41 * -0.0039216) + 1.0));
            }
          }
          v19 += v38;
          int v17 = (int8x16_t *)((char *)v17 + v39);
          --v40;
        }
        while (v40);
        v19 += v30;
        v17 += v31;
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 1:
      if (v37) {
        char v42 = v29;
      }
      else {
        char v42 = 1;
      }
      uint64_t v43 = -(uint64_t)v28;
      uint64_t v44 = -(v23 * v27);
      uint64_t v45 = 16 * v26;
      if (v42)
      {
        do
        {
          int v46 = v11;
          do
          {
            unsigned int v47 = *v19;
            if (*v19)
            {
              if (v47 == 255) {
                int8x16_t v48 = *v24;
              }
              else {
                int8x16_t v48 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(*v17), 1.0 - (float)((float)v47 * 0.0039216)), (float32x4_t)vrev32q_s8(*v24), (float)v47 * 0.0039216));
              }
              *int v17 = v48;
            }
            v19 += v26;
            unsigned int v49 = &v24[v26];
            if ((unint64_t)v49 >= v36) {
              uint64_t v50 = v43;
            }
            else {
              uint64_t v50 = 0;
            }
            uint64_t v24 = &v49[v50];
            int v17 = (int8x16_t *)((char *)v17 + v45);
            --v46;
          }
          while (v46);
          v19 += v30;
          v17 += v31;
          unsigned int v51 = &v35[v23];
          if ((unint64_t)v51 >= v33) {
            uint64_t v52 = v44;
          }
          else {
            uint64_t v52 = 0;
          }
          float32x4_t v53 = &v51[v52];
          uint64_t v54 = v36 + 16 * v52 + 16 * v23;
          if (v32)
          {
            v24 += v23;
          }
          else
          {
            unint64_t v36 = v54;
            unsigned int v35 = v53;
            uint64_t v24 = v53;
          }
          LODWORD(v12) = v12 - 1;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v485 = v11;
          do
          {
            unsigned int v486 = *v19;
            if (*v19)
            {
              if (v486 == 255)
              {
                __int32 v487 = v24->i32[2];
                v17->i64[0] = v24->i64[0];
                v17->i32[2] = v487;
                v17->i32[3] = 32831;
              }
              else
              {
                float v488 = (float)v486 * 0.0039216;
                *(float32x2_t *)v489.f32 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v488);
                v489.f32[2] = v488 * COERCE_FLOAT(bswap32(v24->u32[2]));
                v489.f32[3] = v488;
                *int v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v489, (float32x4_t)vrev32q_s8(*v17), 1.0 - v488));
              }
            }
            v19 += v26;
            unint64_t v490 = &v24[v26];
            if ((unint64_t)v490 >= v36) {
              uint64_t v491 = v43;
            }
            else {
              uint64_t v491 = 0;
            }
            uint64_t v24 = &v490[v491];
            int v17 = (int8x16_t *)((char *)v17 + v45);
            --v485;
          }
          while (v485);
          v19 += v30;
          v17 += v31;
          unint64_t v492 = &v35[v23];
          if ((unint64_t)v492 >= v33) {
            uint64_t v493 = v44;
          }
          else {
            uint64_t v493 = 0;
          }
          uint64_t v494 = &v492[v493];
          uint64_t v495 = v36 + 16 * v493 + 16 * v23;
          if (v32)
          {
            v24 += v23;
          }
          else
          {
            unint64_t v36 = v495;
            unsigned int v35 = v494;
            uint64_t v24 = v494;
          }
          LODWORD(v12) = v12 - 1;
        }
        while (v12);
      }
      return;
    case 2:
      uint64_t v55 = -(uint64_t)v28;
      uint64_t v56 = -(v23 * v27);
      while (1)
      {
        int v57 = v11;
        do
        {
          unsigned int v58 = *v19;
          if (!*v19) {
            goto LABEL_60;
          }
          if (v58 != 255)
          {
            float v64 = (float)v58 * 0.0039216;
            float v61 = v64 * COERCE_FLOAT(bswap32(v24->u32[3]));
            if (v61 <= 0.0) {
              goto LABEL_60;
            }
            float v63 = v64 * COERCE_FLOAT(bswap32(v24->u32[2]));
            *(float32x2_t *)v62.f32 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v64);
            goto LABEL_58;
          }
          unsigned int v59 = v24->u32[3];
          float v60 = COERCE_FLOAT(bswap32(v59));
          float v61 = v60;
          if (v60 < 1.0)
          {
            if (v60 <= 0.0) {
              goto LABEL_60;
            }
            *(int8x8_t *)v62.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
            LODWORD(v63) = bswap32(v24->u32[2]);
LABEL_58:
            v62.i64[1] = __PAIR64__(LODWORD(v61), LODWORD(v63));
            *int v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(v62, (float32x4_t)vrev32q_s8(*v17), 1.0 - v61));
            goto LABEL_60;
          }
          v17->i64[0] = v24->i64[0];
          v17->i32[2] = v24->i32[2];
          v17->i32[3] = v59;
LABEL_60:
          v19 += v26;
          float32x4_t v65 = &v24[v26];
          if ((unint64_t)v65 >= v36) {
            uint64_t v66 = v55;
          }
          else {
            uint64_t v66 = 0;
          }
          uint64_t v24 = &v65[v66];
          v17 += v26;
          --v57;
        }
        while (v57);
        v19 += v30;
        v17 += v31;
        int v67 = &v35[v23];
        if ((unint64_t)v67 >= v33) {
          uint64_t v68 = v56;
        }
        else {
          uint64_t v68 = 0;
        }
        int8x16_t v69 = &v67[v68];
        uint64_t v70 = v36 + 16 * v68 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v70;
          unsigned int v35 = v69;
          uint64_t v24 = v69;
        }
        LODWORD(v12) = v12 - 1;
        if (!v12) {
          return;
        }
      }
    case 3:
      uint64_t v71 = -(uint64_t)v28;
      uint64_t v72 = -(v23 * v27);
      do
      {
        int v73 = v11;
        do
        {
          unsigned int v74 = *v19;
          if (*v19)
          {
            if (v74 == 255)
            {
              unsigned int v75 = 1.0;
              if (v29) {
                unsigned int v75 = bswap32(v24->u32[3]);
              }
              *(int8x8_t *)v76.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v76.i64[1] = __PAIR64__(v75, bswap32(v24->u32[2]));
              int8x16_t v77 = (int8x16_t)vmulq_n_f32(v76, COERCE_FLOAT(bswap32(v17->u32[3])));
            }
            else
            {
              unsigned int v78 = 1.0;
              if (v29) {
                unsigned int v78 = bswap32(v24->u32[3]);
              }
              float32x4_t v79 = (float32x4_t)vrev32q_s8(*v17);
              *(int8x8_t *)v80.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v80.i64[1] = __PAIR64__(v78, bswap32(v24->u32[2]));
              int8x16_t v77 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v80, vmuls_lane_f32((float)v74 * 0.0039216, v79, 3)), v79, 1.0 - (float)((float)v74 * 0.0039216));
            }
            *int v17 = vrev32q_s8(v77);
          }
          v19 += v26;
          float v81 = &v24[v26];
          if ((unint64_t)v81 >= v36) {
            uint64_t v82 = v71;
          }
          else {
            uint64_t v82 = 0;
          }
          uint64_t v24 = &v81[v82];
          v17 += v26;
          --v73;
        }
        while (v73);
        v19 += v30;
        v17 += v31;
        unsigned int v83 = &v35[v23];
        if ((unint64_t)v83 >= v33) {
          uint64_t v84 = v72;
        }
        else {
          uint64_t v84 = 0;
        }
        int8x8_t v85 = &v83[v84];
        uint64_t v86 = v36 + 16 * v84 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v86;
          unsigned int v35 = v85;
          uint64_t v24 = v85;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 4:
      uint64_t v87 = -(uint64_t)v28;
      uint64_t v88 = -(v23 * v27);
      do
      {
        int v89 = v11;
        do
        {
          unsigned int v90 = *v19;
          if (*v19)
          {
            if (v90 == 255)
            {
              unsigned int v91 = 1.0;
              if (v29) {
                unsigned int v91 = bswap32(v24->u32[3]);
              }
              *(int8x8_t *)v92.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v92.i64[1] = __PAIR64__(v91, bswap32(v24->u32[2]));
              int8x16_t v93 = (int8x16_t)vmulq_n_f32(v92, 1.0 - COERCE_FLOAT(bswap32(v17->u32[3])));
            }
            else
            {
              unsigned int v94 = 1.0;
              if (v29) {
                unsigned int v94 = bswap32(v24->u32[3]);
              }
              float32x4_t v95 = (float32x4_t)vrev32q_s8(*v17);
              *(int8x8_t *)v96.f32 = vrev32_s8(*(int8x8_t *)v24->i8);
              v96.i64[1] = __PAIR64__(v94, bswap32(v24->u32[2]));
              int8x16_t v93 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v96, (float)((float)v90 * 0.0039216) * (float)(1.0 - v95.f32[3])), v95, 1.0 - (float)((float)v90 * 0.0039216));
            }
            *int v17 = vrev32q_s8(v93);
          }
          v19 += v26;
          float32x4_t v97 = &v24[v26];
          if ((unint64_t)v97 >= v36) {
            uint64_t v98 = v87;
          }
          else {
            uint64_t v98 = 0;
          }
          uint64_t v24 = &v97[v98];
          v17 += v26;
          --v89;
        }
        while (v89);
        v19 += v30;
        v17 += v31;
        float32x4_t v99 = &v35[v23];
        if ((unint64_t)v99 >= v33) {
          uint64_t v100 = v88;
        }
        else {
          uint64_t v100 = 0;
        }
        int v101 = &v99[v100];
        uint64_t v102 = v36 + 16 * v100 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v102;
          unsigned int v35 = v101;
          uint64_t v24 = v101;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 5:
      uint64_t v273 = -(uint64_t)v28;
      uint64_t v274 = -(v23 * v27);
      do
      {
        int v275 = v11;
        do
        {
          if (*v19)
          {
            float32x4_t v276 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)*v19 * 0.0039216);
            float32x4_t v277 = (float32x4_t)vrev32q_s8(*v17);
            *int v17 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v277, 1.0 - v276.f32[3]), v276, v277, 3));
          }
          v19 += v26;
          uint64_t v278 = &v24[v26];
          if ((unint64_t)v278 >= v36) {
            uint64_t v279 = v273;
          }
          else {
            uint64_t v279 = 0;
          }
          uint64_t v24 = &v278[v279];
          v17 += v26;
          --v275;
        }
        while (v275);
        v19 += v30;
        v17 += v31;
        uint64_t v280 = &v35[v23];
        if ((unint64_t)v280 >= v33) {
          uint64_t v281 = v274;
        }
        else {
          uint64_t v281 = 0;
        }
        uint64_t v282 = &v280[v281];
        uint64_t v283 = v36 + 16 * v281 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v283;
          unsigned int v35 = v282;
          uint64_t v24 = v282;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 6:
      uint64_t v284 = -(uint64_t)v28;
      uint64_t v285 = -(v23 * v27);
      while (1)
      {
        int v286 = v11;
        do
        {
          unsigned int v287 = *v19;
          if (!*v19) {
            goto LABEL_368;
          }
          float v288 = COERCE_FLOAT(bswap32(v17->u32[3]));
          float v289 = 1.0 - v288;
          if ((float)(1.0 - v288) >= 1.0)
          {
            float v295 = 1.0;
            if (v29) {
              float v295 = COERCE_FLOAT(bswap32(v24->u32[3]));
            }
            float v296 = (float)v287 * 0.0039216;
            unsigned int v292 = bswap32(COERCE_UNSIGNED_INT(v296 * COERCE_FLOAT(bswap32(v24->u32[2]))));
            unsigned int v293 = bswap32(COERCE_UNSIGNED_INT(v296 * v295));
            int8x8_t v294 = vrev32_s8((int8x8_t)vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v296));
          }
          else
          {
            if (v289 <= 0.0) {
              goto LABEL_368;
            }
            float v290 = 1.0;
            if (v29) {
              float v290 = COERCE_FLOAT(bswap32(v24->u32[3]));
            }
            float v291 = (float)((float)v287 * 0.0039216) * v289;
            unsigned int v292 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v17->u32[2])) + (float)(COERCE_FLOAT(bswap32(v24->u32[2]))
                                                                                          * v291)));
            unsigned int v293 = bswap32(COERCE_UNSIGNED_INT(v288 + (float)(v290 * v291)));
            int8x8_t v294 = vrev32_s8((int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v291));
          }
          *(int8x8_t *)v17->unint64_t i8 = v294;
          v17->i32[2] = v292;
          v17->i32[3] = v293;
LABEL_368:
          v19 += v26;
          unint64_t v297 = &v24[v26];
          if ((unint64_t)v297 >= v36) {
            uint64_t v298 = v284;
          }
          else {
            uint64_t v298 = 0;
          }
          uint64_t v24 = &v297[v298];
          v17 += v26;
          --v286;
        }
        while (v286);
        v19 += v30;
        v17 += v31;
        uint64_t v299 = &v35[v23];
        if ((unint64_t)v299 >= v33) {
          uint64_t v300 = v285;
        }
        else {
          uint64_t v300 = 0;
        }
        uint64_t v301 = &v299[v300];
        uint64_t v302 = v36 + 16 * v300 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v302;
          unsigned int v35 = v301;
          uint64_t v24 = v301;
        }
        LODWORD(v12) = v12 - 1;
        if (!v12) {
          return;
        }
      }
    case 7:
      uint64_t v103 = -(uint64_t)v28;
      uint64_t v104 = -(v23 * v27);
      do
      {
        int v105 = v11;
        do
        {
          unsigned int v106 = *v19;
          if (*v19)
          {
            if (v106 == 255)
            {
              int8x16_t v107 = (int8x16_t)vmulq_f32((float32x4_t)vdupq_n_s32(bswap32(v24->u32[3])), (float32x4_t)vrev32q_s8(*v17));
            }
            else
            {
              float32x4_t v108 = (float32x4_t)vrev32q_s8(*v17);
              int8x16_t v107 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v108, 1.0 - (float)((float)v106 * 0.0039216)), v108, (float)((float)v106 * 0.0039216) * COERCE_FLOAT(bswap32(v24->u32[3])));
            }
            *int v17 = vrev32q_s8(v107);
          }
          v19 += v26;
          int v109 = &v24[v26];
          if ((unint64_t)v109 >= v36) {
            uint64_t v110 = v103;
          }
          else {
            uint64_t v110 = 0;
          }
          uint64_t v24 = &v109[v110];
          v17 += v26;
          --v105;
        }
        while (v105);
        v19 += v30;
        v17 += v31;
        float v111 = &v35[v23];
        if ((unint64_t)v111 >= v33) {
          uint64_t v112 = v104;
        }
        else {
          uint64_t v112 = 0;
        }
        int8x16_t v113 = &v111[v112];
        uint64_t v114 = v36 + 16 * v112 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v114;
          unsigned int v35 = v113;
          uint64_t v24 = v113;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 8:
      uint64_t v303 = -(uint64_t)v28;
      uint64_t v304 = -(v23 * v27);
      do
      {
        int v305 = v11;
        do
        {
          unsigned int v306 = *v19;
          if (*v19)
          {
            float32x4_t v307 = (float32x4_t)vrev32q_s8(*v17);
            if (v306 == 255) {
              float v308 = COERCE_FLOAT(bswap32(v24->u32[3]));
            }
            else {
              float v308 = (float)((float)v306 * 0.0039216) * COERCE_FLOAT(bswap32(v24->u32[3]));
            }
            *int v17 = vrev32q_s8((int8x16_t)vmulq_n_f32(v307, 1.0 - v308));
          }
          v19 += v26;
          unint64_t v309 = &v24[v26];
          if ((unint64_t)v309 >= v36) {
            uint64_t v310 = v303;
          }
          else {
            uint64_t v310 = 0;
          }
          uint64_t v24 = &v309[v310];
          v17 += v26;
          --v305;
        }
        while (v305);
        v19 += v30;
        v17 += v31;
        unint64_t v311 = &v35[v23];
        if ((unint64_t)v311 >= v33) {
          uint64_t v312 = v304;
        }
        else {
          uint64_t v312 = 0;
        }
        unint64_t v313 = &v311[v312];
        uint64_t v314 = v36 + 16 * v312 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v314;
          unsigned int v35 = v313;
          uint64_t v24 = v313;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 9:
      uint64_t v115 = -(uint64_t)v28;
      uint64_t v116 = -(v23 * v27);
      do
      {
        int v117 = v11;
        do
        {
          if (*v19)
          {
            float v118 = (float)*v19 * 0.0039216;
            float v119 = 1.0 - v118;
            float32x4_t v120 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), v118);
            float32x4_t v121 = (float32x4_t)vrev32q_s8(*v17);
            *int v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v121, v119 + v120.f32[3]), v120, 1.0 - v121.f32[3]));
          }
          v19 += v26;
          float32x2_t v122 = &v24[v26];
          if ((unint64_t)v122 >= v36) {
            uint64_t v123 = v115;
          }
          else {
            uint64_t v123 = 0;
          }
          uint64_t v24 = &v122[v123];
          v17 += v26;
          --v117;
        }
        while (v117);
        v19 += v30;
        v17 += v31;
        int v124 = &v35[v23];
        if ((unint64_t)v124 >= v33) {
          uint64_t v125 = v116;
        }
        else {
          uint64_t v125 = 0;
        }
        float32x4_t v126 = &v124[v125];
        uint64_t v127 = v36 + 16 * v125 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v127;
          unsigned int v35 = v126;
          uint64_t v24 = v126;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 10:
      uint64_t v315 = -(uint64_t)v28;
      uint64_t v316 = -(v23 * v27);
      do
      {
        int v317 = v11;
        do
        {
          if (*v19)
          {
            float32x4_t v318 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)*v19 * 0.0039216);
            float32x4_t v319 = (float32x4_t)vrev32q_s8(*v17);
            *int v17 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v319, 1.0 - v318.f32[3]), v318, 1.0 - v319.f32[3]));
          }
          v19 += v26;
          int v320 = &v24[v26];
          if ((unint64_t)v320 >= v36) {
            uint64_t v321 = v315;
          }
          else {
            uint64_t v321 = 0;
          }
          uint64_t v24 = &v320[v321];
          v17 += v26;
          --v317;
        }
        while (v317);
        v19 += v30;
        v17 += v31;
        long long v322 = &v35[v23];
        if ((unint64_t)v322 >= v33) {
          uint64_t v323 = v316;
        }
        else {
          uint64_t v323 = 0;
        }
        __int32 v324 = &v322[v323];
        uint64_t v325 = v36 + 16 * v323 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v325;
          unsigned int v35 = v324;
          uint64_t v24 = v324;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 11:
      uint64_t v128 = -(uint64_t)v28;
      uint64_t v129 = -(v23 * v27);
      do
      {
        int v130 = v11;
        do
        {
          if (*v19)
          {
            if (v37) {
              a5.i32[0] = bswap32(v17->u32[3]);
            }
            else {
              a5.i32[0] = 1.0;
            }
            float v131 = (float)*v19 * 0.0039216;
            float v132 = COERCE_FLOAT(bswap32(v24->u32[3]));
            float v133 = v131 * COERCE_FLOAT(bswap32(v24->u32[2]));
            float32x2_t v134 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v131);
            float32x2_t v135 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
            float v136 = COERCE_FLOAT(bswap32(v17->u32[2]));
            if (!v29) {
              float v132 = 1.0;
            }
            *(float *)a6.unint64_t i32 = v131 * v132;
            float v137 = *(float *)a6.i32 + *(float *)a5.i32;
            float32x2_t v138 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a5.i8, 0), v135);
            float v139 = (float)(*(float *)a6.i32 - v133) + (float)(*(float *)a5.i32 - v136);
            if (v137 <= 1.0) {
              *(float *)&a7 = v137;
            }
            else {
              *(float *)&a7 = 1.0;
            }
            *(float32x2_t *)a6.unint64_t i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0), vadd_f32(vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a6.i8, 0), v134), v138));
            *(float *)&a6.i32[2] = *(float *)&a7 - v139;
            a6.i32[3] = LODWORD(a7);
            a5 = vrev32q_s8(a6);
            *int v17 = a5;
          }
          v19 += v26;
          double v140 = &v24[v26];
          if ((unint64_t)v140 >= v36) {
            uint64_t v141 = v128;
          }
          else {
            uint64_t v141 = 0;
          }
          uint64_t v24 = &v140[v141];
          v17 += v26;
          --v130;
        }
        while (v130);
        v19 += v30;
        v17 += v31;
        double v142 = &v35[v23];
        if ((unint64_t)v142 >= v33) {
          uint64_t v143 = v129;
        }
        else {
          uint64_t v143 = 0;
        }
        int v144 = &v142[v143];
        uint64_t v145 = v36 + 16 * v143 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v145;
          unsigned int v35 = v144;
          uint64_t v24 = v144;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 12:
      uint64_t v146 = -(uint64_t)v28;
      uint64_t v147 = -(v23 * v27);
      do
      {
        int v148 = v11;
        do
        {
          if (*v19)
          {
            float v149 = (float)*v19 * 0.0039216;
            float v150 = COERCE_FLOAT(bswap32(v24->u32[3]));
            float v151 = v149 * COERCE_FLOAT(bswap32(v24->u32[2]));
            float v152 = COERCE_FLOAT(bswap32(v17->u32[2]));
            float v153 = COERCE_FLOAT(bswap32(v17->u32[3]));
            if (!v29) {
              float v150 = 1.0;
            }
            float v154 = (float)(v149 * v150) + v153;
            *(float32x2_t *)v155.unint64_t i8 = vadd_f32(vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v149), (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8));
            float v156 = v151 + v152;
            if (v154 > 1.0) {
              float v154 = 1.0;
            }
            v155.i64[1] = __PAIR64__(LODWORD(v154), LODWORD(v156));
            *int v17 = vrev32q_s8(v155);
          }
          v19 += v26;
          __int32 v157 = &v24[v26];
          if ((unint64_t)v157 >= v36) {
            uint64_t v158 = v146;
          }
          else {
            uint64_t v158 = 0;
          }
          uint64_t v24 = &v157[v158];
          v17 += v26;
          --v148;
        }
        while (v148);
        v19 += v30;
        v17 += v31;
        int8x16_t v159 = &v35[v23];
        if ((unint64_t)v159 >= v33) {
          uint64_t v160 = v147;
        }
        else {
          uint64_t v160 = 0;
        }
        double v161 = &v159[v160];
        uint64_t v162 = v36 + 16 * v160 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v162;
          unsigned int v35 = v161;
          uint64_t v24 = v161;
        }
        LODWORD(v12) = v12 - 1;
      }
      while (v12);
      return;
    case 13:
      uint64_t v326 = v26;
      uint64_t v327 = -(uint64_t)v28;
      uint64_t v513 = -(v23 * v27);
      uint64_t v328 = 16 * v26;
      while (1)
      {
        int v531 = v35;
        int v543 = v12;
        int v329 = v11;
        do
        {
          unsigned int v330 = *v19;
          if (*v19)
          {
            int8x16_t v331 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v330 * 0.0039216);
            LODWORD(a10) = v331.i32[3];
            float v332 = v29 ? *(float *)&v331.i32[3] : (float)v330 * 0.0039216;
            if (v332 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v333 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v331.i32[3] = v332;
LABEL_427:
                  *int v17 = vrev32q_s8(v331);
                  goto LABEL_428;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v333 = 1.0;
              }
              double v334 = *(double *)v17->i64;
              double v335 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v334) = HIDWORD(v335);
              float v503 = v332;
              *(void *)&double v336 = vextq_s8(v331, v331, 4uLL).u64[0];
              *(float *)v331.unint64_t i32 = PDAmultiplyPDA(*(float *)&v335, v334, *(double *)a5.i64, *(double *)a6.i64, v333, v335, v336, a10, *(float *)v331.i32, COERCE_DOUBLE(__PAIR64__(v331.u32[3], HIDWORD(v336))), v503);
              v331.i32[1] = v337;
              v331.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_427;
            }
          }
LABEL_428:
          v19 += v326;
          __int32 v338 = &v24[v326];
          if ((unint64_t)v338 >= v36) {
            uint64_t v339 = v327;
          }
          else {
            uint64_t v339 = 0;
          }
          uint64_t v24 = &v338[v339];
          int v17 = (int8x16_t *)((char *)v17 + v328);
          --v329;
        }
        while (v329);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v531;
        uint64_t v340 = &v531[v523];
        uint64_t v341 = v513;
        if ((unint64_t)v340 < v520) {
          uint64_t v341 = 0;
        }
        uint64_t v342 = &v340[v341];
        uint64_t v343 = v36 + 16 * v341 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v343;
          unsigned int v35 = v342;
          uint64_t v24 = v342;
        }
        LODWORD(v12) = v543 - 1;
        LODWORD(v11) = v525;
        if (v543 == 1) {
          return;
        }
      }
    case 14:
      uint64_t v163 = -(uint64_t)v28;
      uint64_t v164 = -(v23 * v27);
      __asm { FMOV            V2.2S, #1.0 }
      while (1)
      {
        int v170 = v11;
        do
        {
          if (*v19)
          {
            float v171 = (float)*v19 * 0.0039216;
            float v172 = COERCE_FLOAT(bswap32(v24->u32[3]));
            if (!v29) {
              float v172 = 1.0;
            }
            float v173 = v171 * v172;
            if (v173 > 0.0)
            {
              *(float32x2_t *)v174.unint64_t i8 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v171);
              float v175 = v171 * COERCE_FLOAT(bswap32(v24->u32[2]));
              if (v37)
              {
                float v176 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v176 <= 0.0)
                {
                  v174.i64[1] = __PAIR64__(LODWORD(v173), LODWORD(v175));
                  *int v17 = vrev32q_s8(v174);
                  goto LABEL_208;
                }
              }
              else
              {
                float v176 = 1.0;
              }
              float v177 = COERCE_FLOAT(bswap32(v17->u32[2]));
              *(float *)&unsigned int v178 = (float)(v173 + v176) - (float)(v176 * v173);
              float32x2_t v179 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              *(int8x8_t *)v17->unint64_t i8 = vrev32_s8((int8x8_t)vmla_f32(v179, vsub_f32(_D2, v179), *(float32x2_t *)v174.i8));
              v17->i32[2] = bswap32(COERCE_UNSIGNED_INT(v177 + (float)(v175 * (float)(1.0 - v177))));
              v17->i32[3] = bswap32(v178);
            }
          }
LABEL_208:
          v19 += v26;
          double v180 = &v24[v26];
          if ((unint64_t)v180 >= v36) {
            uint64_t v181 = v163;
          }
          else {
            uint64_t v181 = 0;
          }
          uint64_t v24 = &v180[v181];
          v17 += v26;
          --v170;
        }
        while (v170);
        v19 += v30;
        v17 += v31;
        __int32 v182 = &v35[v23];
        if ((unint64_t)v182 >= v33) {
          uint64_t v183 = v164;
        }
        else {
          uint64_t v183 = 0;
        }
        float32x4_t v184 = &v182[v183];
        uint64_t v185 = v36 + 16 * v183 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v185;
          unsigned int v35 = v184;
          uint64_t v24 = v184;
        }
        LODWORD(v12) = v12 - 1;
        if (!v12) {
          return;
        }
      }
    case 15:
      uint64_t v186 = v26;
      uint64_t v187 = -(uint64_t)v28;
      uint64_t v508 = -(v23 * v27);
      uint64_t v188 = 16 * v26;
      while (1)
      {
        unsigned int v526 = v35;
        int v538 = v12;
        int v189 = v11;
        do
        {
          unsigned int v190 = *v19;
          if (*v19)
          {
            int8x16_t v191 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v190 * 0.0039216);
            LODWORD(a10) = v191.i32[3];
            float v192 = v29 ? *(float *)&v191.i32[3] : (float)v190 * 0.0039216;
            if (v192 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v193 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v191.i32[3] = v192;
LABEL_232:
                  *int v17 = vrev32q_s8(v191);
                  goto LABEL_233;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v193 = 1.0;
              }
              double v194 = *(double *)v17->i64;
              double v195 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v194) = HIDWORD(v195);
              float v501 = v192;
              *(void *)&double v196 = vextq_s8(v191, v191, 4uLL).u64[0];
              *(float *)v191.unint64_t i32 = PDAoverlayPDA(*(float *)&v195, v194, *(double *)a5.i64, *(double *)a6.i64, v193, v195, v196, a10, *(float *)v191.i32, COERCE_DOUBLE(__PAIR64__(v191.u32[3], HIDWORD(v196))), v501);
              v191.i32[1] = v197;
              v191.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_232;
            }
          }
LABEL_233:
          v19 += v186;
          float32x2_t v198 = &v24[v186];
          if ((unint64_t)v198 >= v36) {
            uint64_t v199 = v187;
          }
          else {
            uint64_t v199 = 0;
          }
          uint64_t v24 = &v198[v199];
          int v17 = (int8x16_t *)((char *)v17 + v188);
          --v189;
        }
        while (v189);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v526;
        float v200 = &v526[v523];
        uint64_t v201 = v508;
        if ((unint64_t)v200 < v520) {
          uint64_t v201 = 0;
        }
        float32x2_t v202 = &v200[v201];
        uint64_t v203 = v36 + 16 * v201 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v203;
          unsigned int v35 = v202;
          uint64_t v24 = v202;
        }
        LODWORD(v12) = v538 - 1;
        LODWORD(v11) = v525;
        if (v538 == 1) {
          return;
        }
      }
    case 16:
      uint64_t v204 = v26;
      uint64_t v205 = -(uint64_t)v28;
      uint64_t v509 = -(v23 * v27);
      uint64_t v206 = 16 * v26;
      while (1)
      {
        int v527 = v35;
        int v539 = v12;
        int v207 = v11;
        do
        {
          unsigned int v208 = *v19;
          if (*v19)
          {
            int8x16_t v209 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v208 * 0.0039216);
            LODWORD(a10) = v209.i32[3];
            float v210 = v29 ? *(float *)&v209.i32[3] : (float)v208 * 0.0039216;
            if (v210 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v211 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v209.i32[3] = v210;
LABEL_256:
                  *int v17 = vrev32q_s8(v209);
                  goto LABEL_257;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v211 = 1.0;
              }
              double v212 = *(double *)v17->i64;
              double v213 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v212) = HIDWORD(v213);
              float v502 = v210;
              *(void *)&double v214 = vextq_s8(v209, v209, 4uLL).u64[0];
              *(float *)v209.unint64_t i32 = PDAdarkenPDA(*(float *)&v213, v212, *(double *)a5.i64, *(double *)a6.i64, v211, v213, v214, a10, *(float *)v209.i32, COERCE_DOUBLE(__PAIR64__(v209.u32[3], HIDWORD(v214))), v502);
              v209.i32[1] = v215;
              v209.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_256;
            }
          }
LABEL_257:
          v19 += v204;
          __int32 v216 = &v24[v204];
          if ((unint64_t)v216 >= v36) {
            uint64_t v217 = v205;
          }
          else {
            uint64_t v217 = 0;
          }
          uint64_t v24 = &v216[v217];
          int v17 = (int8x16_t *)((char *)v17 + v206);
          --v207;
        }
        while (v207);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v527;
        int v218 = &v527[v523];
        uint64_t v219 = v509;
        if ((unint64_t)v218 < v520) {
          uint64_t v219 = 0;
        }
        float v220 = &v218[v219];
        uint64_t v221 = v36 + 16 * v219 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v221;
          unsigned int v35 = v220;
          uint64_t v24 = v220;
        }
        LODWORD(v12) = v539 - 1;
        LODWORD(v11) = v525;
        if (v539 == 1) {
          return;
        }
      }
    case 17:
      uint64_t v344 = v26;
      uint64_t v345 = -(uint64_t)v28;
      uint64_t v514 = -(v23 * v27);
      uint64_t v346 = 16 * v26;
      while (1)
      {
        int v532 = v35;
        int v544 = v12;
        int v347 = v11;
        do
        {
          unsigned int v348 = *v19;
          if (*v19)
          {
            int8x16_t v349 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v348 * 0.0039216);
            LODWORD(a10) = v349.i32[3];
            float v350 = v29 ? *(float *)&v349.i32[3] : (float)v348 * 0.0039216;
            if (v350 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v351 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v349.i32[3] = v350;
LABEL_451:
                  *int v17 = vrev32q_s8(v349);
                  goto LABEL_452;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v351 = 1.0;
              }
              double v352 = *(double *)v17->i64;
              double v353 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v352) = HIDWORD(v353);
              float v504 = v350;
              *(void *)&double v354 = vextq_s8(v349, v349, 4uLL).u64[0];
              *(float *)v349.unint64_t i32 = PDAlightenPDA(*(float *)&v353, v352, *(double *)a5.i64, *(double *)a6.i64, v351, v353, v354, a10, *(float *)v349.i32, COERCE_DOUBLE(__PAIR64__(v349.u32[3], HIDWORD(v354))), v504);
              v349.i32[1] = v355;
              v349.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_451;
            }
          }
LABEL_452:
          v19 += v344;
          uint64_t v356 = &v24[v344];
          if ((unint64_t)v356 >= v36) {
            uint64_t v357 = v345;
          }
          else {
            uint64_t v357 = 0;
          }
          uint64_t v24 = &v356[v357];
          int v17 = (int8x16_t *)((char *)v17 + v346);
          --v347;
        }
        while (v347);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v532;
        uint64_t v358 = &v532[v523];
        uint64_t v359 = v514;
        if ((unint64_t)v358 < v520) {
          uint64_t v359 = 0;
        }
        uint64_t v360 = &v358[v359];
        uint64_t v361 = v36 + 16 * v359 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v361;
          unsigned int v35 = v360;
          uint64_t v24 = v360;
        }
        LODWORD(v12) = v544 - 1;
        LODWORD(v11) = v525;
        if (v544 == 1) {
          return;
        }
      }
    case 18:
      uint64_t v362 = v26;
      uint64_t v363 = -(uint64_t)v28;
      uint64_t v515 = -(v23 * v27);
      uint64_t v364 = 16 * v26;
      while (1)
      {
        float32x4_t v533 = v35;
        int v545 = v12;
        int v365 = v11;
        do
        {
          unsigned int v366 = *v19;
          if (*v19)
          {
            int8x16_t v367 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v366 * 0.0039216);
            LODWORD(a10) = v367.i32[3];
            float v368 = v29 ? *(float *)&v367.i32[3] : (float)v366 * 0.0039216;
            if (v368 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v369 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v367.i32[3] = v368;
LABEL_475:
                  *int v17 = vrev32q_s8(v367);
                  goto LABEL_476;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v369 = 1.0;
              }
              double v370 = *(double *)v17->i64;
              double v371 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v370) = HIDWORD(v371);
              float v505 = v368;
              *(void *)&double v372 = vextq_s8(v367, v367, 4uLL).u64[0];
              *(float *)v367.unint64_t i32 = PDAcolordodgePDA(*(float *)&v371, v370, *(double *)a5.i64, *(double *)a6.i64, v369, v371, v372, a10, *(float *)v367.i32, COERCE_DOUBLE(__PAIR64__(v367.u32[3], HIDWORD(v372))), v505);
              v367.i32[1] = v373;
              v367.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_475;
            }
          }
LABEL_476:
          v19 += v362;
          float v374 = &v24[v362];
          if ((unint64_t)v374 >= v36) {
            uint64_t v375 = v363;
          }
          else {
            uint64_t v375 = 0;
          }
          uint64_t v24 = &v374[v375];
          int v17 = (int8x16_t *)((char *)v17 + v364);
          --v365;
        }
        while (v365);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v533;
        int v376 = &v533[v523];
        uint64_t v377 = v515;
        if ((unint64_t)v376 < v520) {
          uint64_t v377 = 0;
        }
        uint64_t v378 = &v376[v377];
        uint64_t v379 = v36 + 16 * v377 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v379;
          unsigned int v35 = v378;
          uint64_t v24 = v378;
        }
        LODWORD(v12) = v545 - 1;
        LODWORD(v11) = v525;
        if (v545 == 1) {
          return;
        }
      }
    case 19:
      uint64_t v380 = v26;
      uint64_t v381 = -(uint64_t)v28;
      uint64_t v516 = -(v23 * v27);
      uint64_t v382 = 16 * v26;
      while (1)
      {
        int v534 = v35;
        int v546 = v12;
        int v383 = v11;
        do
        {
          unsigned int v384 = *v19;
          if (*v19)
          {
            int8x16_t v385 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v384 * 0.0039216);
            LODWORD(a10) = v385.i32[3];
            float v386 = v29 ? *(float *)&v385.i32[3] : (float)v384 * 0.0039216;
            if (v386 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v387 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v385.i32[3] = v386;
LABEL_499:
                  *int v17 = vrev32q_s8(v385);
                  goto LABEL_500;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v387 = 1.0;
              }
              double v388 = *(double *)v17->i64;
              double v389 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v388) = HIDWORD(v389);
              float v506 = v386;
              *(void *)&double v390 = vextq_s8(v385, v385, 4uLL).u64[0];
              *(float *)v385.unint64_t i32 = PDAcolorburnPDA(*(float *)&v389, v388, *(double *)a5.i64, *(double *)a6.i64, v387, v389, v390, a10, *(float *)v385.i32, COERCE_DOUBLE(__PAIR64__(v385.u32[3], HIDWORD(v390))), v506);
              v385.i32[1] = v391;
              v385.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_499;
            }
          }
LABEL_500:
          v19 += v380;
          float32x2_t v392 = &v24[v380];
          if ((unint64_t)v392 >= v36) {
            uint64_t v393 = v381;
          }
          else {
            uint64_t v393 = 0;
          }
          uint64_t v24 = &v392[v393];
          int v17 = (int8x16_t *)((char *)v17 + v382);
          --v383;
        }
        while (v383);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v534;
        unint64_t v394 = &v534[v523];
        uint64_t v395 = v516;
        if ((unint64_t)v394 < v520) {
          uint64_t v395 = 0;
        }
        unint64_t v396 = &v394[v395];
        uint64_t v397 = v36 + 16 * v395 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v397;
          unsigned int v35 = v396;
          uint64_t v24 = v396;
        }
        LODWORD(v12) = v546 - 1;
        LODWORD(v11) = v525;
        if (v546 == 1) {
          return;
        }
      }
    case 20:
      uint64_t v398 = v26;
      uint64_t v399 = -(uint64_t)v28;
      uint64_t v517 = -(v23 * v27);
      uint64_t v400 = 16 * v26;
      while (1)
      {
        int v535 = v35;
        int v547 = v12;
        int v401 = v11;
        do
        {
          unsigned int v402 = *v19;
          if (*v19)
          {
            int8x16_t v403 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v402 * 0.0039216);
            LODWORD(a10) = v403.i32[3];
            float v404 = v29 ? *(float *)&v403.i32[3] : (float)v402 * 0.0039216;
            if (v404 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                LODWORD(a7) = a6.i32[0];
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v403.i32[3] = v404;
LABEL_523:
                  *int v17 = vrev32q_s8(v403);
                  goto LABEL_524;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                LODWORD(a7) = 1.0;
              }
              double v405 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              DWORD2(v500) = v403.i32[3];
              *(void *)&long long v500 = vextq_s8(v403, v403, 4uLL).u64[0];
              *(float *)v403.unint64_t i32 = PDAsoftlightPDA(*(float *)&v405, *((float *)&v405 + 1), *(double *)a5.i64, *(int32x2_t *)a6.i8, a7, v405, *(double *)&v500, a10, a1, a2, v30, v11, v12, v23, v31, v32, *(float *)v403.i32, v500, *(uint64_t *)((char *)&v500 + 4),
                                     v404);
              v403.i32[1] = v406;
              v403.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_523;
            }
          }
LABEL_524:
          v19 += v398;
          int8x16_t v407 = &v24[v398];
          if ((unint64_t)v407 >= v36) {
            uint64_t v408 = v399;
          }
          else {
            uint64_t v408 = 0;
          }
          uint64_t v24 = &v407[v408];
          int v17 = (int8x16_t *)((char *)v17 + v400);
          --v401;
        }
        while (v401);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v535;
        unsigned int v409 = &v535[v523];
        uint64_t v410 = v517;
        if ((unint64_t)v409 < v520) {
          uint64_t v410 = 0;
        }
        uint64_t v411 = &v409[v410];
        uint64_t v412 = v36 + 16 * v410 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v412;
          unsigned int v35 = v411;
          uint64_t v24 = v411;
        }
        uint64_t v12 = (v547 - 1);
        uint64_t v11 = v525;
        if (v547 == 1) {
          return;
        }
      }
    case 21:
      uint64_t v413 = v26;
      uint64_t v414 = -(uint64_t)v28;
      uint64_t v518 = -(v23 * v27);
      uint64_t v415 = 16 * v26;
      while (1)
      {
        float32x4_t v536 = v35;
        int v548 = v12;
        int v416 = v11;
        do
        {
          unsigned int v417 = *v19;
          if (*v19)
          {
            int8x16_t v418 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v417 * 0.0039216);
            LODWORD(a10) = v418.i32[3];
            float v419 = v29 ? *(float *)&v418.i32[3] : (float)v417 * 0.0039216;
            if (v419 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v420 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v418.i32[3] = v419;
LABEL_547:
                  *int v17 = vrev32q_s8(v418);
                  goto LABEL_548;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v420 = 1.0;
              }
              double v421 = *(double *)v17->i64;
              double v422 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              a5.i32[0] = bswap32(v17->u32[2]);
              LODWORD(v421) = HIDWORD(v422);
              float v507 = v419;
              *(void *)&double v423 = vextq_s8(v418, v418, 4uLL).u64[0];
              *(float *)v418.unint64_t i32 = PDAhardlightPDA(*(float *)&v422, v421, *(double *)a5.i64, *(double *)a6.i64, v420, v422, v423, a10, *(float *)v418.i32, COERCE_DOUBLE(__PAIR64__(v418.u32[3], HIDWORD(v423))), v507);
              v418.i32[1] = v424;
              v418.i64[1] = __PAIR64__(a6.u32[0], a5.u32[0]);
              goto LABEL_547;
            }
          }
LABEL_548:
          v19 += v413;
          unsigned int v425 = &v24[v413];
          if ((unint64_t)v425 >= v36) {
            uint64_t v426 = v414;
          }
          else {
            uint64_t v426 = 0;
          }
          uint64_t v24 = &v425[v426];
          int v17 = (int8x16_t *)((char *)v17 + v415);
          --v416;
        }
        while (v416);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v536;
        uint64_t v427 = &v536[v523];
        uint64_t v428 = v518;
        if ((unint64_t)v427 < v520) {
          uint64_t v428 = 0;
        }
        uint64_t v429 = &v427[v428];
        uint64_t v430 = v36 + 16 * v428 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v430;
          unsigned int v35 = v429;
          uint64_t v24 = v429;
        }
        LODWORD(v12) = v548 - 1;
        LODWORD(v11) = v525;
        if (v548 == 1) {
          return;
        }
      }
    case 22:
      uint64_t v431 = -(uint64_t)v28;
      uint64_t v432 = -(v23 * v27);
      while (1)
      {
        int v433 = v11;
        do
        {
          if (*v19)
          {
            float v434 = (float)*v19 * 0.0039216;
            float32x4_t v435 = vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), v434);
            if (v29) {
              float v434 = v435.f32[3];
            }
            if (v434 > 0.0)
            {
              if (v37)
              {
                float v436 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v436 <= 0.0)
                {
                  v435.f32[3] = v434;
                  int8x16_t v437 = (int8x16_t)v435;
LABEL_572:
                  *int v17 = vrev32q_s8(v437);
                  goto LABEL_573;
                }
              }
              else
              {
                float v436 = 1.0;
              }
              float v438 = COERCE_FLOAT(bswap32(v17->u32[2]));
              float32x2_t v439 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              float32x2_t v440 = vadd_f32(*(float32x2_t *)v435.f32, v439);
              float32x2_t v441 = vmul_n_f32(v439, v434);
              float32x2_t v442 = vmul_n_f32(*(float32x2_t *)v435.f32, v436);
              float32x2_t v443 = vsub_f32(v440, v441);
              float32x2_t v444 = vsub_f32(v441, v442);
              *(float32x2_t *)v437.unint64_t i8 = vadd_f32(vsub_f32(v443, v442), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v444), (int8x8_t)vneg_f32(v444), (int8x8_t)v444));
              v435.f32[0] = vmuls_lane_f32(v436, v435, 2);
              float v445 = (float)(v434 * v438) - v435.f32[0];
              v435.f32[0] = (float)((float)(v435.f32[2] + v438) - (float)(v434 * v438)) - v435.f32[0];
              if (v445 < 0.0) {
                float v445 = -v445;
              }
              *(float *)&v437.i32[2] = v435.f32[0] + v445;
              *(float *)&v437.i32[3] = (float)(v436 + v434) - (float)(v436 * v434);
              goto LABEL_572;
            }
          }
LABEL_573:
          v19 += v26;
          unint64_t v446 = &v24[v26];
          if ((unint64_t)v446 >= v36) {
            uint64_t v447 = v431;
          }
          else {
            uint64_t v447 = 0;
          }
          uint64_t v24 = &v446[v447];
          v17 += v26;
          --v433;
        }
        while (v433);
        v19 += v30;
        v17 += v31;
        uint64_t v448 = &v35[v23];
        if ((unint64_t)v448 >= v33) {
          uint64_t v449 = v432;
        }
        else {
          uint64_t v449 = 0;
        }
        uint64_t v450 = &v448[v449];
        uint64_t v451 = v36 + 16 * v449 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v451;
          unsigned int v35 = v450;
          uint64_t v24 = v450;
        }
        LODWORD(v12) = v12 - 1;
        if (!v12) {
          return;
        }
      }
    case 23:
      uint64_t v452 = -(uint64_t)v28;
      uint64_t v453 = -(v23 * v27);
      while (1)
      {
        int v454 = v11;
        do
        {
          if (*v19)
          {
            float v455 = (float)*v19 * 0.0039216;
            float v456 = COERCE_FLOAT(bswap32(v24->u32[3]));
            if (!v29) {
              float v456 = 1.0;
            }
            float v457 = v455 * v456;
            if (v457 > 0.0)
            {
              *(float32x2_t *)v458.unint64_t i8 = vmul_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), v455);
              float v459 = v455 * COERCE_FLOAT(bswap32(v24->u32[2]));
              if (v37)
              {
                float v460 = COERCE_FLOAT(bswap32(v17->u32[3]));
                if (v460 <= 0.0)
                {
                  v458.i64[1] = __PAIR64__(LODWORD(v457), LODWORD(v459));
                  *int v17 = vrev32q_s8(v458);
                  goto LABEL_596;
                }
              }
              else
              {
                float v460 = 1.0;
              }
              float v461 = COERCE_FLOAT(bswap32(v17->u32[2]));
              *(float *)&unsigned int v462 = (float)(v457 + v460) - (float)(v460 * v457);
              float32x2_t v463 = (float32x2_t)vrev32_s8(*(int8x8_t *)v17->i8);
              *(int8x8_t *)v17->unint64_t i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v458.i8, v463), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v458.i8, v463)));
              v17->i32[2] = bswap32(COERCE_UNSIGNED_INT((float)(v459 + v461) + (float)((float)(v459 * v461) * -2.0)));
              v17->i32[3] = bswap32(v462);
            }
          }
LABEL_596:
          v19 += v26;
          uint8x8_t v464 = &v24[v26];
          if ((unint64_t)v464 >= v36) {
            uint64_t v465 = v452;
          }
          else {
            uint64_t v465 = 0;
          }
          uint64_t v24 = &v464[v465];
          v17 += v26;
          --v454;
        }
        while (v454);
        v19 += v30;
        v17 += v31;
        int v466 = &v35[v23];
        if ((unint64_t)v466 >= v33) {
          uint64_t v467 = v453;
        }
        else {
          uint64_t v467 = 0;
        }
        unint64_t v468 = &v466[v467];
        uint64_t v469 = v36 + 16 * v467 + 16 * v23;
        if (v32)
        {
          v24 += v23;
        }
        else
        {
          unint64_t v36 = v469;
          unsigned int v35 = v468;
          uint64_t v24 = v468;
        }
        LODWORD(v12) = v12 - 1;
        if (!v12) {
          return;
        }
      }
    case 24:
      uint64_t v222 = v26;
      uint64_t v223 = -(uint64_t)v28;
      uint64_t v510 = -(v23 * v27);
      uint64_t v224 = 16 * v26;
      while (1)
      {
        int v528 = v35;
        int v540 = v12;
        int v225 = v11;
        do
        {
          unsigned int v226 = *v19;
          if (*v19)
          {
            int8x16_t v227 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v226 * 0.0039216);
            LODWORD(a10) = v227.i32[3];
            float v228 = v29 ? *(float *)&v227.i32[3] : (float)v226 * 0.0039216;
            if (v228 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v229 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v227.i32[3] = v228;
LABEL_280:
                  *int v17 = vrev32q_s8(v227);
                  goto LABEL_281;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v229 = 1.0;
              }
              double v230 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(void *)&double v497 = vextq_s8(v227, v227, 4uLL).u64[0];
              *(float *)v227.unint64_t i32 = PDAhuePDA(*(float *)&v230, *((float *)&v230 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v229, v230, v497, a10, *(float *)v227.i32, *(float *)&v497, *((float *)&v497 + 1), *(float *)&v227.i32[3], v228);
              v227.i32[1] = v231;
              v227.i64[1] = __PAIR64__(a6.u32[0], v232);
              goto LABEL_280;
            }
          }
LABEL_281:
          v19 += v222;
          double v233 = &v24[v222];
          if ((unint64_t)v233 >= v36) {
            uint64_t v234 = v223;
          }
          else {
            uint64_t v234 = 0;
          }
          uint64_t v24 = &v233[v234];
          int v17 = (int8x16_t *)((char *)v17 + v224);
          --v225;
        }
        while (v225);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v528;
        unsigned int v235 = &v528[v523];
        uint64_t v236 = v510;
        if ((unint64_t)v235 < v520) {
          uint64_t v236 = 0;
        }
        int v237 = &v235[v236];
        uint64_t v238 = v36 + 16 * v236 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v238;
          unsigned int v35 = v237;
          uint64_t v24 = v237;
        }
        LODWORD(v12) = v540 - 1;
        LODWORD(v11) = v525;
        if (v540 == 1) {
          return;
        }
      }
    case 25:
      uint64_t v239 = v26;
      uint64_t v240 = -(uint64_t)v28;
      uint64_t v511 = -(v23 * v27);
      uint64_t v241 = 16 * v26;
      while (1)
      {
        int v529 = v35;
        int v541 = v12;
        int v242 = v11;
        do
        {
          unsigned int v243 = *v19;
          if (*v19)
          {
            int8x16_t v244 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v243 * 0.0039216);
            LODWORD(a10) = v244.i32[3];
            float v245 = v29 ? *(float *)&v244.i32[3] : (float)v243 * 0.0039216;
            if (v245 > 0.0)
            {
              if (v37)
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v246 = *(float *)a6.i32;
                if (*(float *)a6.i32 <= 0.0)
                {
                  *(float *)&v244.i32[3] = v245;
LABEL_304:
                  *int v17 = vrev32q_s8(v244);
                  goto LABEL_305;
                }
              }
              else
              {
                a6.i32[0] = bswap32(v17->u32[3]);
                float v246 = 1.0;
              }
              double v247 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(void *)&double v498 = vextq_s8(v244, v244, 4uLL).u64[0];
              *(float *)v244.unint64_t i32 = PDAsaturationPDA(*(float *)&v247, *((float *)&v247 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v246, v247, v498, a10, *(float *)v244.i32, *(float *)&v498, *((float *)&v498 + 1), *(float *)&v244.i32[3], v245);
              v244.i32[1] = v248;
              v244.i64[1] = __PAIR64__(a6.u32[0], v249);
              goto LABEL_304;
            }
          }
LABEL_305:
          v19 += v239;
          uint64_t v250 = &v24[v239];
          if ((unint64_t)v250 >= v36) {
            uint64_t v251 = v240;
          }
          else {
            uint64_t v251 = 0;
          }
          uint64_t v24 = &v250[v251];
          int v17 = (int8x16_t *)((char *)v17 + v241);
          --v242;
        }
        while (v242);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v529;
        int v252 = &v529[v523];
        uint64_t v253 = v511;
        if ((unint64_t)v252 < v520) {
          uint64_t v253 = 0;
        }
        int v254 = &v252[v253];
        uint64_t v255 = v36 + 16 * v253 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v255;
          unsigned int v35 = v254;
          uint64_t v24 = v254;
        }
        LODWORD(v12) = v541 - 1;
        LODWORD(v11) = v525;
        if (v541 == 1) {
          return;
        }
      }
    case 26:
      uint64_t v470 = v26;
      uint64_t v471 = -(uint64_t)v28;
      uint64_t v519 = -(v23 * v27);
      uint64_t v472 = 16 * v26;
      while (1)
      {
        float32x2_t v537 = v35;
        int v549 = v12;
        int v473 = v11;
        do
        {
          unsigned int v474 = *v19;
          if (*v19)
          {
            int8x16_t v475 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v474 * 0.0039216);
            a6.i32[0] = v475.i32[3];
            float v476 = v29 ? *(float *)&v475.i32[3] : (float)v474 * 0.0039216;
            if (v476 > 0.0)
            {
              if (v37)
              {
                LODWORD(a8) = bswap32(v17->u32[3]);
                LODWORD(a9) = LODWORD(a8);
                if (*(float *)&a8 <= 0.0)
                {
                  *(float *)&v475.i32[3] = v476;
LABEL_620:
                  *int v17 = vrev32q_s8(v475);
                  goto LABEL_621;
                }
              }
              else
              {
                LODWORD(a8) = bswap32(v17->u32[3]);
                LODWORD(a9) = 1.0;
              }
              double v496 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
              *(float *)v475.unint64_t i32 = PDAluminosityPDA(*(float *)v475.i32, *(float *)&v475.i32[1], *(float *)&v475.i32[2], *(double *)a6.i64, v476, a8, a9, v496, *(float *)&v496, *((float *)&v496 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(float *)&a8, *(float *)&a9);
              v475.i32[1] = v477;
              v475.i64[1] = __PAIR64__(a6.u32[0], v478);
              goto LABEL_620;
            }
          }
LABEL_621:
          v19 += v470;
          unint64_t v479 = &v24[v470];
          if ((unint64_t)v479 >= v36) {
            uint64_t v480 = v471;
          }
          else {
            uint64_t v480 = 0;
          }
          uint64_t v24 = &v479[v480];
          int v17 = (int8x16_t *)((char *)v17 + v472);
          --v473;
        }
        while (v473);
        v19 += v524;
        v17 += v522;
        unsigned int v35 = v537;
        unint64_t v481 = &v537[v523];
        uint64_t v482 = v519;
        if ((unint64_t)v481 < v520) {
          uint64_t v482 = 0;
        }
        int v483 = &v481[v482];
        uint64_t v484 = v36 + 16 * v482 + 16 * v523;
        if (v521)
        {
          v24 += v523;
        }
        else
        {
          unint64_t v36 = v484;
          unsigned int v35 = v483;
          uint64_t v24 = v483;
        }
        LODWORD(v12) = v549 - 1;
        LODWORD(v11) = v525;
        if (v549 == 1) {
          return;
        }
      }
    case 27:
      uint64_t v256 = v26;
      uint64_t v257 = -(uint64_t)v28;
      uint64_t v512 = -(v23 * v27);
      uint64_t v258 = 16 * v26;
      break;
    default:
      return;
  }
  do
  {
    int v530 = v35;
    int v542 = v12;
    int v259 = v11;
    do
    {
      unsigned int v260 = *v19;
      if (*v19)
      {
        int8x16_t v261 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)v260 * 0.0039216);
        LODWORD(a10) = v261.i32[3];
        float v262 = v29 ? *(float *)&v261.i32[3] : (float)v260 * 0.0039216;
        if (v262 > 0.0)
        {
          if (v37)
          {
            a6.i32[0] = bswap32(v17->u32[3]);
            float v263 = *(float *)a6.i32;
            if (*(float *)a6.i32 <= 0.0)
            {
              *(float *)&v261.i32[3] = v262;
LABEL_328:
              *int v17 = vrev32q_s8(v261);
              goto LABEL_329;
            }
          }
          else
          {
            a6.i32[0] = bswap32(v17->u32[3]);
            float v263 = 1.0;
          }
          double v264 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v17->i8));
          *(void *)&double v499 = vextq_s8(v261, v261, 4uLL).u64[0];
          *(float *)v261.unint64_t i32 = PDAluminosityPDA(*(float *)&v264, *((float *)&v264 + 1), COERCE_FLOAT(bswap32(v17->u32[2])), *(double *)a6.i64, v263, v264, v499, a10, *(float *)v261.i32, *(float *)&v499, *((float *)&v499 + 1), *(float *)&v261.i32[3], v262);
          v261.i32[1] = v265;
          v261.i64[1] = __PAIR64__(a6.u32[0], v266);
          goto LABEL_328;
        }
      }
LABEL_329:
      v19 += v256;
      uint64_t v267 = &v24[v256];
      if ((unint64_t)v267 >= v36) {
        uint64_t v268 = v257;
      }
      else {
        uint64_t v268 = 0;
      }
      uint64_t v24 = &v267[v268];
      int v17 = (int8x16_t *)((char *)v17 + v258);
      --v259;
    }
    while (v259);
    v19 += v524;
    v17 += v522;
    unsigned int v35 = v530;
    uint64_t v269 = &v530[v523];
    uint64_t v270 = v512;
    if ((unint64_t)v269 < v520) {
      uint64_t v270 = 0;
    }
    float v271 = &v269[v270];
    uint64_t v272 = v36 + 16 * v270 + 16 * v523;
    if (v521)
    {
      v24 += v523;
    }
    else
    {
      unint64_t v36 = v272;
      unsigned int v35 = v271;
      uint64_t v24 = v271;
    }
    LODWORD(v12) = v542 - 1;
    LODWORD(v11) = v525;
  }
  while (v542 != 1);
}

uint64_t RGBAF_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (int *)*a1;
  memset(v38, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  signed int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v32, (uint64_t)v38) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  unsigned int v33 = v19;
  int v34 = v18;
  if (v19 != 538981257)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      uint64_t v23 = RGBF_image_sample;
      uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGBF_image_sample[2 * v20 + 2];
      if (v32)
      {
LABEL_29:
        unsigned int v33 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v36 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v25) = v22;
          LODWORD(v25) = v22;
          switch((v25 >> 3))
          {
            case 0u:
              unsigned int v33 = *(_DWORD *)a3;
              int v26 = RGBAF_image_mark_RGB32;
              goto LABEL_52;
            case 1u:
              unsigned int v33 = *(_DWORD *)a3;
              int v27 = RGBAF_image_mark_RGB32;
              goto LABEL_54;
            case 2u:
              unsigned int v33 = *(_DWORD *)a3;
              int v26 = (uint64_t (*)(uint64_t, int *, int, int, int, int))RGBAF_image_mark_W8;
              goto LABEL_52;
            case 3u:
              unsigned int v33 = *(_DWORD *)a3;
              int v26 = (uint64_t (*)(uint64_t, int *, int, int, int, int))RGBAF_image_mark_RGB24;
              goto LABEL_52;
            case 4u:
              unsigned int v33 = *(_DWORD *)a3;
              int v26 = RGBAF_image_mark_rgb32;
LABEL_52:
              int v28 = v26;
              uint64_t v29 = (uint64_t)a2;
              int v30 = v8;
              int v31 = 0;
              break;
            case 5u:
              unsigned int v33 = *(_DWORD *)a3;
              int v27 = RGBAF_image_mark_rgb32;
LABEL_54:
              int v28 = v27;
              uint64_t v29 = (uint64_t)a2;
              int v30 = v8;
              int v31 = 8;
              break;
            default:
              goto LABEL_37;
          }
          RGBAF_image_mark_image(v29, (uint64_t)&v32, v30, v31, (void (*)(uint64_t, _DWORD *))v28);
          return 1;
        }
        goto LABEL_37;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        uint64_t v23 = RGB8_image_sample;
        uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB8_image_sample[2 * v20 + 2];
        if (v32)
        {
          int v24 = 4;
LABEL_28:
          int v35 = v24;
          goto LABEL_29;
        }
      }
      uint64_t v23 = RGB16_image_sample;
      uint64_t v32 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, double))&RGB16_image_sample[2 * v20 + 2];
      if (v32)
      {
        int v24 = 8;
        goto LABEL_28;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v37 && (~v36 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v36 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      RGBAF_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  uint64_t v32 = RGBAf_sample_RGBAF_inner;
LABEL_37:
  RGBAF_image_mark((uint64_t)a2, (uint64_t)&v32, v8, v17);
  return 1;
}

void RGBAF_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  v49[0] = a3;
  v49[1] = a4;
  v49[2] = *(_DWORD *)(a2 + 184);
  unint64_t v8 = (unint64_t)*(int *)(a1 + 28) >> 4;
  unint64_t v51 = v8;
  uint64_t v9 = *(void *)(a2 + 120);
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  if (v9)
  {
    unsigned int v11 = HIBYTE(v10);
    unint64_t v12 = *(int *)(a2 + 24);
    uint64_t v13 = (uint64_t *)(a2 + 104);
    uint64_t v14 = (uint64_t *)(a2 + 72);
    uint64_t v15 = (uint64_t *)(a2 + 88);
  }
  else
  {
    unsigned int v11 = BYTE2(v10);
    unint64_t v12 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v13 = (uint64_t *)(a2 + 96);
    uint64_t v14 = (uint64_t *)(a2 + 64);
    uint64_t v15 = (uint64_t *)(a2 + 80);
    uint64_t v9 = *(void *)(a2 + 112);
  }
  uint64_t v16 = *v15;
  uint64_t v17 = *v14;
  uint64_t v18 = *v13;
  char v19 = v11;
  uint64_t v54 = v11;
  uint64_t v52 = v18;
  unint64_t v62 = v12;
  uint64_t v60 = v16;
  uint64_t v58 = v17;
  uint64_t v56 = v9;
  uint64_t v20 = *(void *)(a2 + 128);
  uint64_t v48 = v16;
  if (v20)
  {
    unsigned int v21 = BYTE2(v10);
    unint64_t v22 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    uint64_t v23 = (uint64_t *)(a2 + 96);
    int v24 = (uint64_t *)(a2 + 64);
    unint64_t v25 = (uint64_t *)(a2 + 80);
  }
  else
  {
    unsigned int v21 = HIBYTE(v10);
    unint64_t v22 = *(int *)(a2 + 24);
    uint64_t v23 = (uint64_t *)(a2 + 104);
    int v24 = (uint64_t *)(a2 + 72);
    unint64_t v25 = (uint64_t *)(a2 + 88);
    uint64_t v20 = *(void *)(a2 + 136);
  }
  uint64_t v26 = *v25;
  uint64_t v27 = *v24;
  uint64_t v28 = *v23;
  uint64_t v55 = v21;
  uint64_t v53 = v28;
  unint64_t v63 = v22;
  uint64_t v61 = v26;
  uint64_t v59 = v27;
  uint64_t v57 = v20;
  uint64_t v29 = *(unsigned int *)(a1 + 4);
  if ((v29 & 0x80000000) == 0)
  {
    int v30 = malloc_type_malloc(16 * v29, 0x47853941uLL);
    float v64 = v30;
    if (v30)
    {
      if (*(void *)(a2 + 176))
      {
        if (v29)
        {
          uint64_t v32 = v30 + 1;
          uint64_t v33 = v48 - v18;
          do
          {
            if (((v18 - v17) | v33) < 0)
            {
              unint64_t v36 = 0;
              uint64_t v37 = 0;
            }
            else
            {
              unint64_t v34 = ((v18 & (unint64_t)~(-1 << v19)) >> (v19 - 4)) & 0xF;
              char v35 = weights_21383[v34];
              if (v34 - 7 >= 9) {
                unint64_t v36 = -(uint64_t)v12;
              }
              else {
                unint64_t v36 = v12;
              }
              uint64_t v37 = v35 & 0xF;
            }
            *(v32 - 1) = v12 * (v18 >> v19);
            *uint64_t v32 = v37 | (16 * v36);
            v32 += 2;
            v18 += v9;
            v33 -= v9;
            --v29;
          }
          while (v29);
        }
      }
      else if (v29)
      {
        uint64_t v38 = v30 + 1;
        do
        {
          *(v38 - 1) = v12 * (v18 >> v19);
          *uint64_t v38 = 0;
          v38 += 2;
          v18 += v9;
          --v29;
        }
        while (v29);
      }
      uint64_t v39 = v30;
      int v40 = *(_DWORD *)(a1 + 4);
      int v41 = *(_DWORD *)(a1 + 8);
      int v65 = v41;
      int v66 = v40;
      char v42 = *(int **)(a1 + 136);
      if (v42)
      {
        int v43 = *(_DWORD *)(a1 + 104);
        v67[0] = *(_DWORD *)(a1 + 108);
        v67[1] = v43;
        shape_enum_clip_alloc((uint64_t)v30, v31, v42, 1, 1, 1, v43, v67[0], v40, v41);
        uint64_t v45 = v44;
        if (v44) {
          goto LABEL_27;
        }
      }
      int v46 = 0;
      int v47 = 0;
      uint64_t v45 = 0;
      *(void *)int v67 = 0;
      while (1)
      {
        uint64_t v50 = *(void *)(a1 + 40) + 16 * v8 * (*(int *)(a1 + 16) + (uint64_t)v47) + 16 * (v46 + *(_DWORD *)(a1 + 12));
        a5(a2, v49);
        if (!v45) {
          break;
        }
LABEL_27:
        if (!shape_enum_clip_next((uint64_t)v45, &v67[1], v67, &v66, &v65))
        {
          free(v45);
          break;
        }
        int v47 = v67[0];
        int v46 = v67[1];
        unint64_t v8 = v51;
      }
      free(v39);
    }
  }
}

void RGBAF_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unsigned int v344 = a3;
  uint64_t v355 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  unint64_t v8 = *(int *)(a1 + 28);
  uint64_t v9 = *(char **)(a1 + 40);
  uint64_t v354 = *(void *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  __n128 v350 = a4;
  float v351 = *(int **)(a1 + 136);
  double v352 = v9;
  uint64_t v346 = *(void *)(a2 + 96);
  uint64_t v348 = *(void *)(a2 + 104);
  uint64_t v11 = *(int *)(a1 + 12);
  uint64_t v10 = *(int *)(a1 + 16);
  int v353 = *(_DWORD *)(a1 + 8);
  uint64_t v12 = *(int *)(a2 + 16);
  uint64_t v13 = (v12 + 18) * v5;
  if (v13 > 65439)
  {
    uint64_t v16 = (char *)malloc_type_calloc(1uLL, v13 + 96, 0xBBC8A413uLL);
    uint64_t v15 = v16;
    uint64_t v18 = v16;
    if (!v16) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    uint64_t v15 = (char *)&v338 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v14);
    uint64_t v18 = 0;
  }
  uint64_t v341 = v18;
  unint64_t v19 = v8 >> 4;
  unint64_t v20 = (unint64_t)(v15 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v21 = v20 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v12) {
    uint64_t v22 = 16 * v5;
  }
  else {
    uint64_t v22 = 0;
  }
  unint64_t v23 = v21 + v22;
  *(void *)(a2 + 144) = v20;
  *(void *)(a2 + 152) = v21 + v22;
  *(void *)(a2 + 160) = v21;
  int v24 = (int8x16_t *)&v352[16 * v11 + 16 * v19 * v10];
  unint64_t v339 = v8 >> 4;
  uint64_t v340 = (int)v4;
  unint64_t v349 = v19 - (int)v4;
  uint64_t v25 = *(int *)(a1 + 104);
  int v26 = *(_DWORD *)(a1 + 108);
  int v27 = *(unsigned __int8 *)(a1 + 2);
  if (v27 == 6 || v27 == 1)
  {
    uint64_t v28 = v346;
    uint64_t v29 = v348;
    if (v351)
    {
      int v30 = 0;
      LODWORD(v31) = 0;
      uint64_t v32 = *(int *)(a1 + 124);
      uint64_t v33 = (unsigned __int8 *)v351 + v25 + (int)v32 * (uint64_t)v26;
      uint64_t v34 = v340;
      uint64_t v345 = v32 - v340;
LABEL_12:
      unsigned int v35 = v344;
      goto LABEL_13;
    }
LABEL_434:
    uint64_t v326 = v341;
    if (v341) {
      goto LABEL_427;
    }
    return;
  }
  uint64_t v29 = v348;
  if (v351)
  {
    shape_enum_clip_alloc((uint64_t)v16, v17, v351, 1, 1, 1, v25, v26, v4, v353);
    if (v327)
    {
      float v295 = v327;
      uint64_t v31 = 0;
      uint64_t v328 = (int)((v12 * v5 + 15) & 0xFFFFFFF0);
      if (!v12) {
        uint64_t v328 = 16 * v5;
      }
      uint64_t v34 = v340;
      uint64_t v345 = -v340;
      uint64_t v33 = (unsigned __int8 *)(v23 + v328 + 16);
      uint64_t v28 = v346;
      goto LABEL_436;
    }
    goto LABEL_434;
  }
  uint64_t v345 = 0;
  int v30 = 0;
  uint64_t v33 = 0;
  LODWORD(v31) = 0;
  unsigned int v35 = v344;
  uint64_t v34 = v340;
  uint64_t v28 = v346;
LABEL_13:
  uint64_t v342 = -v34;
  uint64_t v343 = (v4 - 1) + 1;
  uint64_t v347 = v35;
  unint64_t v36 = v30;
  while (2)
  {
    LODWORD(v351) = v31;
    double v352 = v36;
    uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))a2)(a2, v28, v29, v4);
    uint64_t v52 = *(float32x4_t **)(a2 + 160);
    uint64_t v53 = *(unsigned __int8 **)(a2 + 144);
    unsigned int v54 = *(_DWORD *)(a2 + 8);
    if (v54 == *(_DWORD *)(a2 + 12))
    {
      int32x2_t v46 = (int32x2_t)v350.n128_u64[0];
      if (v350.n128_f32[0] < 1.0)
      {
        int v55 = v4;
        uint64_t v56 = *(unsigned char **)(a2 + 144);
        do
        {
          if (*v56)
          {
            float32x4_t v45 = vmulq_n_f32(*v52, *(float *)v46.i32);
            *uint64_t v52 = v45;
          }
          ++v56;
          ++v52;
          --v55;
        }
        while (v55);
        v52 += v342;
        v53 += v343 + v342;
      }
    }
    else
    {
      uint64_t v57 = *(void *)(a2 + 152);
      int v58 = HIWORD(v54) & 0x3F;
      double v47 = v350.n128_f64[0];
      if (v58 == 16)
      {
        uint64_t v60 = 0;
        uint64_t v61 = &v52->f32[2];
        if (v350.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v60])
            {
              unint64_t v63 = *(void *)(v57 + 8 * v60);
              *(v61 - 2) = *(float *)&_blt_float[v63 + 256] + *(float *)&_blt_float[BYTE1(v63) + 512];
              *(v61 - 1) = *(float *)&_blt_float[BYTE2(v63) + 256] + *(float *)&_blt_float[BYTE3(v63) | 0x200];
              *uint64_t v61 = *(float *)&_blt_float[BYTE4(v63) + 256] + *(float *)&_blt_float[BYTE5(v63) + 512];
              v61[1] = *(float *)&_blt_float[BYTE6(v63) + 256] + *(float *)&_blt_float[HIBYTE(v63) + 512];
            }
            ++v60;
            v61 += 4;
          }
          while (v4 != v60);
        }
        else
        {
          do
          {
            if (v53[v60])
            {
              unint64_t v62 = *(void *)(v57 + 8 * v60);
              *(v61 - 2) = *(float *)&v47
                         * (float)(*(float *)&_blt_float[v62 + 256]
                                 + *(float *)&_blt_float[BYTE1(v62) + 512]);
              *(v61 - 1) = *(float *)&v47
                         * (float)(*(float *)&_blt_float[BYTE2(v62) + 256] + *(float *)&_blt_float[BYTE3(v62) | 0x200]);
              *uint64_t v61 = *(float *)&v47
                   * (float)(*(float *)&_blt_float[BYTE4(v62) + 256] + *(float *)&_blt_float[BYTE5(v62) + 512]);
              v61[1] = *(float *)&v47
                     * (float)(*(float *)&_blt_float[BYTE6(v62) + 256] + *(float *)&_blt_float[HIBYTE(v62) + 512]);
            }
            ++v60;
            v61 += 4;
          }
          while (v4 != v60);
        }
      }
      else if (v58 == 32)
      {
        uint64_t v59 = 0;
        if (v350.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v59])
            {
              float32x4_t v45 = *(float32x4_t *)(v57 + 16 * v59);
              v52[v59] = v45;
            }
            ++v59;
          }
          while (v4 != v59);
        }
        else
        {
          do
          {
            if (v53[v59])
            {
              float32x4_t v45 = vmulq_n_f32(*(float32x4_t *)(v57 + 16 * v59), *(float *)&v47);
              v52[v59] = v45;
            }
            ++v59;
          }
          while (v4 != v59);
        }
      }
      else
      {
        uint64_t v64 = 0;
        int v65 = &v52->f32[2];
        if (v350.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v53[v64])
            {
              unint64_t v67 = *(unsigned int *)(v57 + 4 * v64);
              *(v65 - 2) = *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
              *(v65 - 1) = *(float *)&_blt_float[BYTE2(v67)];
              *int v65 = *(float *)&_blt_float[BYTE1(v67)];
              v65[1] = *(float *)&_blt_float[v67];
            }
            ++v64;
            v65 += 4;
          }
          while (v4 != v64);
        }
        else
        {
          do
          {
            if (v53[v64])
            {
              unint64_t v66 = *(unsigned int *)(v57 + 4 * v64);
              *(v65 - 2) = *(float *)&v47 * *(float *)((char *)_blt_float + ((v66 >> 22) & 0x3FC));
              *(v65 - 1) = *(float *)&v47 * *(float *)&_blt_float[BYTE2(v66)];
              *int v65 = *(float *)&v47 * *(float *)&_blt_float[BYTE1(v66)];
              v65[1] = *(float *)&v47 * *(float *)&_blt_float[v66];
            }
            ++v64;
            v65 += 4;
          }
          while (v4 != v64);
        }
      }
    }
    uint64_t v68 = &xmmword_1850CE000;
    switch(v35)
    {
      case 0u:
        int v69 = v4;
        uint64_t v70 = v33;
        do
        {
          unsigned int v71 = *v53;
          if (*v53)
          {
            if (v33) {
              unsigned int v71 = (*v70 * v71 + ((*v70 * v71) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v71)
            {
              if (v71 == 255)
              {
                v24->i64[0] = 0;
                v24->i64[1] = 0;
              }
              else
              {
                *int v24 = vrev32q_s8((int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), (float)((float)v71 * -0.0039216) + 1.0));
              }
            }
          }
          ++v53;
          v70 += v33 != 0;
          ++v24;
          --v69;
        }
        while (v69);
        uint64_t v33 = &v70[v345];
        goto LABEL_340;
      case 1u:
        unsigned __int8 v72 = *v53;
        int v73 = v53 + 1;
        unsigned int v74 = v24 - 1;
        int v75 = v4;
        if (v33)
        {
          int v76 = v353;
          do
          {
            if (v72)
            {
              unsigned int v77 = ((unsigned __int16)(*v33 * v72 + ((*v33 * v72) >> 8) + 1) >> 8);
              if (v77)
              {
                if (v77 == 255) {
                  int8x16_t v78 = *(int8x16_t *)v52;
                }
                else {
                  int8x16_t v78 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(v74[1]), 1.0 - (float)((float)v77 * 0.0039216)), *v52, (float)v77 * 0.0039216);
                }
                v74[1] = vrev32q_s8(v78);
              }
            }
            unsigned __int8 v79 = *v73++;
            unsigned __int8 v72 = v79;
            ++v52;
            ++v33;
            ++v74;
            --v75;
          }
          while (v75);
          goto LABEL_84;
        }
        int v76 = v353;
        do
        {
          if (v72)
          {
            if (v72 == 255) {
              int8x16_t v312 = *(int8x16_t *)v52;
            }
            else {
              int8x16_t v312 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32((float32x4_t)vrev32q_s8(v74[1]), 1.0 - (float)((float)v72 * 0.0039216)), *v52, (float)v72 * 0.0039216);
            }
            v74[1] = vrev32q_s8(v312);
          }
          unsigned __int8 v313 = *v73++;
          unsigned __int8 v72 = v313;
          ++v52;
          ++v74;
          --v75;
        }
        while (v75);
        goto LABEL_421;
      case 2u:
        unsigned __int8 v80 = *v53;
        if (!v33)
        {
          unsigned int v74 = v24 - 1;
          uint64_t v314 = &v52->i64[1];
          uint64_t v315 = v53 + 1;
          int v316 = v4;
          int v76 = v353;
          while (1)
          {
            if (v80)
            {
              if (v80 == 255)
              {
                float v317 = *((float *)v314 + 1);
                if (v317 >= 1.0)
                {
                  unsigned int v323 = bswap32(*(_DWORD *)v314);
                  *(int8x8_t *)v74[1].unint64_t i8 = vrev32_s8((int8x8_t)*(v314 - 1));
                  v74[1].i32[2] = v323;
                  v74[1].i32[3] = bswap32(LODWORD(v317));
                  goto LABEL_420;
                }
                if (v317 > 0.0)
                {
                  int8x16_t v318 = (int8x16_t)vmlaq_n_f32(*(float32x4_t *)(v314 - 1), (float32x4_t)vrev32q_s8(v74[1]), 1.0 - v317);
LABEL_418:
                  v74[1] = vrev32q_s8(v318);
                }
              }
              else
              {
                float v319 = (float)v80 * 0.0039216;
                float v320 = v319 * *((float *)v314 + 1);
                if (v320 > 0.0)
                {
                  *(float *)&unsigned int v321 = v319 * *(float *)v314;
                  *(float32x2_t *)v322.f32 = vmul_n_f32((float32x2_t)*(v314 - 1), v319);
                  v322.i64[1] = __PAIR64__(LODWORD(v320), v321);
                  int8x16_t v318 = (int8x16_t)vmlaq_n_f32(v322, (float32x4_t)vrev32q_s8(v74[1]), 1.0 - v320);
                  goto LABEL_418;
                }
              }
            }
LABEL_420:
            unsigned __int8 v324 = *v315++;
            unsigned __int8 v80 = v324;
            ++v74;
            v314 += 2;
            if (!--v316)
            {
LABEL_421:
              uint64_t v33 = 0;
              goto LABEL_422;
            }
          }
        }
        uint64_t v81 = 0;
        uint64_t v82 = v53 + 1;
        int v83 = v4;
        int v76 = v353;
        do
        {
          if (v80)
          {
            unsigned int v84 = ((unsigned __int16)(*v33 * v80 + ((*v33 * v80) >> 8) + 1) >> 8);
            if ((unsigned __int16)(*v33 * v80 + ((*v33 * v80) >> 8) + 1) >> 8)
            {
              if (v84 != 255)
              {
                float v88 = (float)v84 * 0.0039216;
                int v89 = (float32x2_t *)&v52[v81];
                float v90 = v88 * v52[v81].f32[3];
                if (v90 <= 0.0) {
                  goto LABEL_82;
                }
                *(float *)&unsigned int v91 = v88 * v89[1].f32[0];
                *(float32x2_t *)v92.f32 = vmul_n_f32(*v89, v88);
                v92.i64[1] = __PAIR64__(LODWORD(v90), v91);
                int8x16_t v87 = (int8x16_t)vmlaq_n_f32(v92, (float32x4_t)vrev32q_s8(v24[v81]), 1.0 - v90);
                goto LABEL_80;
              }
              int8x8_t v85 = (int8x8_t *)&v52[v81];
              float v86 = v52[v81].f32[3];
              if (v86 < 1.0)
              {
                if (v86 <= 0.0) {
                  goto LABEL_82;
                }
                int8x16_t v87 = (int8x16_t)vmlaq_n_f32(v52[v81], (float32x4_t)vrev32q_s8(v24[v81]), 1.0 - v86);
LABEL_80:
                v24[v81] = vrev32q_s8(v87);
                goto LABEL_82;
              }
              unsigned int v93 = bswap32(v85[1].u32[0]);
              unsigned int v94 = bswap32(LODWORD(v86));
              int8x8_t v95 = vrev32_s8(*v85);
              float32x4_t v96 = (int8x8_t *)&v24[v81];
              *float32x4_t v96 = v95;
              v96[1].i32[0] = v93;
              v96[1].i32[1] = v94;
            }
          }
LABEL_82:
          unsigned __int8 v97 = *v82++;
          unsigned __int8 v80 = v97;
          ++v33;
          ++v81;
          --v83;
        }
        while (v83);
        unsigned int v74 = &v24[v81 - 1];
LABEL_84:
        v33 += v345;
LABEL_422:
        int v24 = &v74[v349 + 1];
LABEL_371:
        int v294 = v76 - 1;
        if (!v294)
        {
          int v30 = v352;
          goto LABEL_424;
        }
        int v353 = v294;
        unint64_t v36 = 0;
        uint64_t v31 = (v351 + 1);
        v28 += *(void *)(a2 + 128);
        v29 += *(void *)(a2 + 136);
        float v295 = v352;
        if (!v352) {
          continue;
        }
        uint64_t v34 = v340;
LABEL_436:
        int v30 = v295;
        do
        {
          while (1)
          {
            uint64_t v329 = *((unsigned int *)v33 - 4);
            int v330 = v329 - v31;
            if ((int)v329 <= (int)v31) {
              break;
            }
            v353 -= v330;
            if (v353 < 1) {
              goto LABEL_424;
            }
            v28 += *(void *)(a2 + 128) * v330;
            v29 += *(void *)(a2 + 136) * v330;
            v24 += v339 * v330;
            uint64_t v31 = v329;
          }
          if ((int)v31 < *((_DWORD *)v33 - 3) + (int)v329) {
            goto LABEL_12;
          }
          uint64_t v331 = v31;
          int v332 = shape_enum_clip_scan((uint64_t)v30, (_DWORD *)v33 - 4);
          uint64_t v31 = v331;
        }
        while (v332);
LABEL_424:
        uint64_t v325 = v341;
        if (v30) {
          free(v30);
        }
        uint64_t v326 = v325;
        if (v325) {
LABEL_427:
        }
          free(v326);
        return;
      case 3u:
        int v98 = v4;
        float32x4_t v99 = v33;
        do
        {
          unsigned int v100 = *v53;
          if (*v53)
          {
            if (v33) {
              unsigned int v100 = (*v99 * v100 + ((*v99 * v100) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v100)
            {
              if (v100 == 255)
              {
                int8x16_t v101 = (int8x16_t)vmulq_n_f32(*v52, COERCE_FLOAT(bswap32(v24->u32[3])));
              }
              else
              {
                float32x4_t v102 = (float32x4_t)vrev32q_s8(*v24);
                int8x16_t v101 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v102, 1.0 - (float)((float)v100 * 0.0039216)), *v52, vmuls_lane_f32((float)v100 * 0.0039216, v102, 3));
              }
              *int v24 = vrev32q_s8(v101);
            }
          }
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          --v98;
        }
        while (v98);
        goto LABEL_339;
      case 4u:
        int v103 = v4;
        float32x4_t v99 = v33;
        do
        {
          unsigned int v104 = *v53;
          if (*v53)
          {
            if (v33) {
              unsigned int v104 = (*v99 * v104 + ((*v99 * v104) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v104)
            {
              if (v104 == 255)
              {
                int8x16_t v105 = (int8x16_t)vmulq_n_f32(*v52, 1.0 - COERCE_FLOAT(bswap32(v24->u32[3])));
              }
              else
              {
                float32x4_t v106 = (float32x4_t)vrev32q_s8(*v24);
                int8x16_t v105 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v106, 1.0 - (float)((float)v104 * 0.0039216)), *v52, (float)((float)v104 * 0.0039216) * (float)(1.0 - v106.f32[3]));
              }
              *int v24 = vrev32q_s8(v105);
            }
          }
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          --v103;
        }
        while (v103);
        goto LABEL_339;
      case 5u:
        int v107 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v108 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_112;
            }
            unsigned int v109 = *v99 * v108 + ((*v99 * v108) >> 8) + 1;
            if (BYTE1(v109)) {
              break;
            }
          }
LABEL_113:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v107) {
            goto LABEL_339;
          }
        }
        unsigned int v108 = v109 >> 8;
LABEL_112:
        float32x4_t v110 = vmulq_n_f32(*v52, (float)v108 * 0.0039216);
        float32x4_t v111 = (float32x4_t)vrev32q_s8(*v24);
        *int v24 = vrev32q_s8((int8x16_t)vmlaq_laneq_f32(vmulq_n_f32(v111, 1.0 - v110.f32[3]), v110, v111, 3));
        goto LABEL_113;
      case 6u:
        uint64_t v112 = &v52->f32[3];
        int v113 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v114 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v115 = *v99 * v114 + ((*v99 * v114) >> 8) + 1;
              if (!BYTE1(v115)) {
                goto LABEL_125;
              }
              unsigned int v114 = v115 >> 8;
            }
            float v116 = COERCE_FLOAT(bswap32(v24->u32[3]));
            float v117 = 1.0 - v116;
            if ((float)(1.0 - v116) >= 1.0)
            {
              float v122 = (float)v114 * 0.0039216;
              unsigned int v119 = bswap32(COERCE_UNSIGNED_INT(v122 * *(v112 - 1)));
              unsigned int v120 = bswap32(COERCE_UNSIGNED_INT(v122 * *v112));
              int8x8_t v121 = (int8x8_t)vmul_n_f32(*(float32x2_t *)(v112 - 3), v122);
              goto LABEL_124;
            }
            if (v117 > 0.0)
            {
              float v118 = (float)((float)v114 * 0.0039216) * v117;
              unsigned int v119 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v24->u32[2])) + (float)(*(v112 - 1) * v118)));
              unsigned int v120 = bswap32(COERCE_UNSIGNED_INT(v116 + (float)(*v112 * v118)));
              int8x8_t v121 = (int8x8_t)vmla_n_f32((float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8), *(float32x2_t *)(v112 - 3), v118);
LABEL_124:
              *(int8x8_t *)v24->unint64_t i8 = vrev32_s8(v121);
              v24->i32[2] = v119;
              v24->i32[3] = v120;
            }
          }
LABEL_125:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v112 += 4;
          if (!--v113) {
            goto LABEL_339;
          }
        }
      case 7u:
        uint64_t v123 = &v52->f32[3];
        int v124 = v4;
        float32x4_t v99 = v33;
        do
        {
          unsigned int v125 = *v53;
          if (*v53)
          {
            if (v33) {
              unsigned int v125 = (*v99 * v125 + ((*v99 * v125) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v125)
            {
              if (v125 == 255)
              {
                int8x16_t v126 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), *v123);
              }
              else
              {
                float32x4_t v127 = (float32x4_t)vrev32q_s8(*v24);
                int8x16_t v126 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v127, 1.0 - (float)((float)v125 * 0.0039216)), v127, (float)((float)v125 * 0.0039216) * *v123);
              }
              *int v24 = vrev32q_s8(v126);
            }
          }
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v123 += 4;
          --v124;
        }
        while (v124);
        goto LABEL_339;
      case 8u:
        uint64_t v128 = &v52->f32[3];
        int v129 = v4;
        float32x4_t v99 = v33;
        do
        {
          unsigned int v130 = *v53;
          if (*v53)
          {
            if (v33) {
              unsigned int v130 = (*v99 * v130 + ((*v99 * v130) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v130)
            {
              if (v130 == 255)
              {
                int8x16_t v131 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev32q_s8(*v24), 1.0 - *v128);
              }
              else
              {
                float32x4_t v132 = (float32x4_t)vrev32q_s8(*v24);
                int8x16_t v131 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(v132, 1.0 - (float)((float)v130 * 0.0039216)), v132, (float)((float)v130 * 0.0039216) * (float)(1.0 - *v128));
              }
              *int v24 = vrev32q_s8(v131);
            }
          }
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v128 += 4;
          --v129;
        }
        while (v129);
        goto LABEL_339;
      case 9u:
        int v133 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v134 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_154;
            }
            unsigned int v135 = *v99 * v134 + ((*v99 * v134) >> 8) + 1;
            if (BYTE1(v135)) {
              break;
            }
          }
LABEL_155:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v133) {
            goto LABEL_339;
          }
        }
        unsigned int v134 = v135 >> 8;
LABEL_154:
        float v136 = (float)v134 * 0.0039216;
        float v137 = 1.0 - v136;
        float32x4_t v138 = vmulq_n_f32(*v52, v136);
        float32x4_t v139 = (float32x4_t)vrev32q_s8(*v24);
        *int v24 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v139, v137 + v138.f32[3]), v138, 1.0 - v139.f32[3]));
        goto LABEL_155;
      case 0xAu:
        int v140 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v141 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_162;
            }
            unsigned int v142 = *v99 * v141 + ((*v99 * v141) >> 8) + 1;
            if (BYTE1(v142)) {
              break;
            }
          }
LABEL_163:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v140) {
            goto LABEL_339;
          }
        }
        unsigned int v141 = v142 >> 8;
LABEL_162:
        float32x4_t v143 = vmulq_n_f32(*v52, (float)v141 * 0.0039216);
        float32x4_t v144 = (float32x4_t)vrev32q_s8(*v24);
        *int v24 = vrev32q_s8((int8x16_t)vmlaq_n_f32(vmulq_n_f32(v144, 1.0 - v143.f32[3]), v143, 1.0 - v144.f32[3]));
        goto LABEL_163;
      case 0xBu:
        uint64_t v145 = &v52->f32[3];
        int v146 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v147 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_170;
            }
            unsigned int v148 = *v99 * v147 + ((*v99 * v147) >> 8) + 1;
            if (BYTE1(v148)) {
              break;
            }
          }
LABEL_175:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v145 += 4;
          if (!--v146) {
            goto LABEL_339;
          }
        }
        unsigned int v147 = v148 >> 8;
LABEL_170:
        v45.i32[0] = 1.0;
        v46.i32[0] = 1.0;
        if (v354) {
          v46.i32[0] = bswap32(v24->u32[3]);
        }
        float v149 = (float)v147 * 0.0039216;
        float v150 = v149 * *(v145 - 1);
        *(float *)&double v49 = v149 * *v145;
        float32x2_t v151 = vsub_f32((float32x2_t)vdup_lane_s32(v46, 0), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8));
        float v152 = *(float *)&v49 + *(float *)v46.i32;
        float32x2_t v153 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v49, 0), vmul_n_f32(*(float32x2_t *)(v145 - 3), v149));
        float v154 = (float)(*(float *)&v49 - v150) + (float)(*(float *)v46.i32 - COERCE_FLOAT(bswap32(v24->u32[2])));
        if (v152 <= 1.0) {
          v45.f32[0] = v152;
        }
        *(float32x2_t *)v155.unint64_t i8 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v45.f32, 0), vadd_f32(v153, v151));
        v155.i64[1] = __PAIR64__(v45.u32[0], v45.f32[0] - v154);
        float32x4_t v45 = (float32x4_t)vrev32q_s8(v155);
        *int v24 = (int8x16_t)v45;
        goto LABEL_175;
      case 0xCu:
        float v156 = &v52->f32[3];
        int v157 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v158 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_182;
            }
            unsigned int v159 = *v99 * v158 + ((*v99 * v158) >> 8) + 1;
            if (BYTE1(v159)) {
              break;
            }
          }
LABEL_185:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v156 += 4;
          if (!--v157) {
            goto LABEL_339;
          }
        }
        unsigned int v158 = v159 >> 8;
LABEL_182:
        float v160 = (float)v158 * 0.0039216;
        float v161 = v160 * *(v156 - 1);
        float v162 = (float)(v160 * *v156) + COERCE_FLOAT(bswap32(v24->u32[3]));
        *(float32x2_t *)v163.unint64_t i8 = vadd_f32(vmul_n_f32(*(float32x2_t *)(v156 - 3), v160), (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8));
        float v164 = v161 + COERCE_FLOAT(bswap32(v24->u32[2]));
        if (v162 > 1.0) {
          float v162 = 1.0;
        }
        v163.i64[1] = __PAIR64__(LODWORD(v162), LODWORD(v164));
        *int v24 = vrev32q_s8(v163);
        goto LABEL_185;
      case 0xDu:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v165 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v167 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v168 = *v166 * v167 + ((*v166 * v167) >> 8) + 1;
              if (!BYTE1(v168)) {
                goto LABEL_199;
              }
              unsigned int v167 = v168 >> 8;
            }
            int8x16_t v169 = (int8x16_t)vmulq_n_f32(*v52, (float)v167 * *((float *)v68 + 677));
            if (*(float *)&v169.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v170 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_198;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v170 = 1.0;
              }
              double v171 = *(double *)v24->i64;
              double v172 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v171) = HIDWORD(v172);
              *(void *)&double v173 = vextq_s8(v169, v169, 4uLL).u64[0];
              *(float *)v169.unint64_t i32 = PDAmultiplyPDA(*(float *)&v172, v171, v47, v48, v170, v172, v173, v51, *(float *)v169.i32, COERCE_DOUBLE(__PAIR64__(v169.u32[3], HIDWORD(v173))), *(float *)&v169.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v169.i32[1] = v174;
              v169.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_198:
              *int v24 = vrev32q_s8(v169);
            }
          }
LABEL_199:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v165) {
            goto LABEL_368;
          }
        }
      case 0xEu:
        float v175 = (float32x2_t *)&v52->u32[2];
        int v176 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v177 = *v53;
          if (*v53)
          {
            if (!v33) {
              goto LABEL_206;
            }
            unsigned int v178 = *v99 * v177 + ((*v99 * v177) >> 8) + 1;
            if (BYTE1(v178)) {
              break;
            }
          }
LABEL_211:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v175 += 2;
          if (!--v176) {
            goto LABEL_339;
          }
        }
        unsigned int v177 = v178 >> 8;
LABEL_206:
        float v179 = (float)v177 * 0.0039216;
        float32x2_t v180 = vmul_n_f32(*v175, v179);
        if (v180.f32[1] > 0.0)
        {
          *(float32x2_t *)v181.unint64_t i8 = vmul_n_f32(v175[-1], v179);
          float v182 = 1.0;
          if (v354 && (float v182 = COERCE_FLOAT(bswap32(v24->u32[3])), v182 <= 0.0))
          {
            v181.u64[1] = (unint64_t)v180;
            *int v24 = vrev32q_s8(v181);
          }
          else
          {
            float v183 = COERCE_FLOAT(bswap32(v24->u32[2]));
            *(float *)&unsigned int v184 = vmlas_n_f32(v183, 1.0 - v183, v180.f32[0]);
            *(float *)&unsigned int v185 = (float)(v180.f32[1] + v182) - (float)(v182 * v180.f32[1]);
            float32x2_t v186 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
            __asm { FMOV            V2.2S, #1.0 }
            *(int8x8_t *)v24->unint64_t i8 = vrev32_s8((int8x8_t)vmla_f32(v186, vsub_f32(_D2, v186), *(float32x2_t *)v181.i8));
            v24->i32[2] = bswap32(v184);
            v24->i32[3] = bswap32(v185);
          }
        }
        goto LABEL_211;
      case 0xFu:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v192 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v193 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v194 = *v166 * v193 + ((*v166 * v193) >> 8) + 1;
              if (!BYTE1(v194)) {
                goto LABEL_225;
              }
              unsigned int v193 = v194 >> 8;
            }
            int8x16_t v195 = (int8x16_t)vmulq_n_f32(*v52, (float)v193 * *((float *)v68 + 677));
            if (*(float *)&v195.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v196 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_224;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v196 = 1.0;
              }
              double v197 = *(double *)v24->i64;
              double v198 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v197) = HIDWORD(v198);
              *(void *)&double v199 = vextq_s8(v195, v195, 4uLL).u64[0];
              *(float *)v195.unint64_t i32 = PDAoverlayPDA(*(float *)&v198, v197, v47, v48, v196, v198, v199, v51, *(float *)v195.i32, COERCE_DOUBLE(__PAIR64__(v195.u32[3], HIDWORD(v199))), *(float *)&v195.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v195.i32[1] = v200;
              v195.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_224:
              *int v24 = vrev32q_s8(v195);
            }
          }
LABEL_225:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v192) {
            goto LABEL_368;
          }
        }
      case 0x10u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v201 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v202 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v203 = *v166 * v202 + ((*v166 * v202) >> 8) + 1;
              if (!BYTE1(v203)) {
                goto LABEL_239;
              }
              unsigned int v202 = v203 >> 8;
            }
            int8x16_t v204 = (int8x16_t)vmulq_n_f32(*v52, (float)v202 * *((float *)v68 + 677));
            if (*(float *)&v204.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v205 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_238;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v205 = 1.0;
              }
              double v206 = *(double *)v24->i64;
              double v207 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v206) = HIDWORD(v207);
              *(void *)&double v208 = vextq_s8(v204, v204, 4uLL).u64[0];
              *(float *)v204.unint64_t i32 = PDAdarkenPDA(*(float *)&v207, v206, v47, v48, v205, v207, v208, v51, *(float *)v204.i32, COERCE_DOUBLE(__PAIR64__(v204.u32[3], HIDWORD(v208))), *(float *)&v204.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v204.i32[1] = v209;
              v204.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_238:
              *int v24 = vrev32q_s8(v204);
            }
          }
LABEL_239:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v201) {
            goto LABEL_368;
          }
        }
      case 0x11u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v210 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v211 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v212 = *v166 * v211 + ((*v166 * v211) >> 8) + 1;
              if (!BYTE1(v212)) {
                goto LABEL_253;
              }
              unsigned int v211 = v212 >> 8;
            }
            int8x16_t v213 = (int8x16_t)vmulq_n_f32(*v52, (float)v211 * *((float *)v68 + 677));
            if (*(float *)&v213.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v214 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_252;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v214 = 1.0;
              }
              double v215 = *(double *)v24->i64;
              double v216 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v215) = HIDWORD(v216);
              *(void *)&double v217 = vextq_s8(v213, v213, 4uLL).u64[0];
              *(float *)v213.unint64_t i32 = PDAlightenPDA(*(float *)&v216, v215, v47, v48, v214, v216, v217, v51, *(float *)v213.i32, COERCE_DOUBLE(__PAIR64__(v213.u32[3], HIDWORD(v217))), *(float *)&v213.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v213.i32[1] = v218;
              v213.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_252:
              *int v24 = vrev32q_s8(v213);
            }
          }
LABEL_253:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v210) {
            goto LABEL_368;
          }
        }
      case 0x12u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v219 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v220 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v221 = *v166 * v220 + ((*v166 * v220) >> 8) + 1;
              if (!BYTE1(v221)) {
                goto LABEL_267;
              }
              unsigned int v220 = v221 >> 8;
            }
            int8x16_t v222 = (int8x16_t)vmulq_n_f32(*v52, (float)v220 * *((float *)v68 + 677));
            if (*(float *)&v222.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v223 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_266;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v223 = 1.0;
              }
              double v224 = *(double *)v24->i64;
              double v225 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v224) = HIDWORD(v225);
              *(void *)&double v226 = vextq_s8(v222, v222, 4uLL).u64[0];
              *(float *)v222.unint64_t i32 = PDAcolordodgePDA(*(float *)&v225, v224, v47, v48, v223, v225, v226, v51, *(float *)v222.i32, COERCE_DOUBLE(__PAIR64__(v222.u32[3], HIDWORD(v226))), *(float *)&v222.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v222.i32[1] = v227;
              v222.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_266:
              *int v24 = vrev32q_s8(v222);
            }
          }
LABEL_267:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v219) {
            goto LABEL_368;
          }
        }
      case 0x13u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v228 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v229 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v230 = *v166 * v229 + ((*v166 * v229) >> 8) + 1;
              if (!BYTE1(v230)) {
                goto LABEL_281;
              }
              unsigned int v229 = v230 >> 8;
            }
            int8x16_t v231 = (int8x16_t)vmulq_n_f32(*v52, (float)v229 * *((float *)v68 + 677));
            if (*(float *)&v231.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v232 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_280;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v232 = 1.0;
              }
              double v233 = *(double *)v24->i64;
              double v234 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v233) = HIDWORD(v234);
              *(void *)&double v235 = vextq_s8(v231, v231, 4uLL).u64[0];
              *(float *)v231.unint64_t i32 = PDAcolorburnPDA(*(float *)&v234, v233, v47, v48, v232, v234, v235, v51, *(float *)v231.i32, COERCE_DOUBLE(__PAIR64__(v231.u32[3], HIDWORD(v235))), *(float *)&v231.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v231.i32[1] = v236;
              v231.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_280:
              *int v24 = vrev32q_s8(v231);
            }
          }
LABEL_281:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v228) {
            goto LABEL_368;
          }
        }
      case 0x14u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v237 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v238 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v239 = *v166 * v238 + ((*v166 * v238) >> 8) + 1;
              if (!BYTE1(v239)) {
                goto LABEL_295;
              }
              unsigned int v238 = v239 >> 8;
            }
            int8x16_t v240 = (int8x16_t)vmulq_n_f32(*v52, (float)v238 * *((float *)v68 + 677));
            if (*(float *)&v240.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                LODWORD(v49) = LODWORD(v48);
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_294;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                LODWORD(v49) = 1.0;
              }
              double v241 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              DWORD2(v334) = v240.i32[3];
              *(void *)&long long v334 = vextq_s8(v240, v240, 4uLL).u64[0];
              *(float *)v240.unint64_t i32 = PDAsoftlightPDA(*(float *)&v241, *((float *)&v241 + 1), v47, *(int32x2_t *)&v48, v49, v241, *(double *)&v334, v51, v37, v38, v39, v40, v41, v42, v43, v44, *(float *)v240.i32, v334, *(uint64_t *)((char *)&v334 + 4),
                                     *(float *)&v240.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v240.i32[1] = v242;
              v240.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_294:
              *int v24 = vrev32q_s8(v240);
            }
          }
LABEL_295:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v237) {
            goto LABEL_368;
          }
        }
      case 0x15u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v243 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v244 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v245 = *v166 * v244 + ((*v166 * v244) >> 8) + 1;
              if (!BYTE1(v245)) {
                goto LABEL_309;
              }
              unsigned int v244 = v245 >> 8;
            }
            int8x16_t v246 = (int8x16_t)vmulq_n_f32(*v52, (float)v244 * *((float *)v68 + 677));
            if (*(float *)&v246.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v247 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_308;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v247 = 1.0;
              }
              double v248 = *(double *)v24->i64;
              double v249 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              LODWORD(v47) = bswap32(v24->u32[2]);
              LODWORD(v248) = HIDWORD(v249);
              *(void *)&double v250 = vextq_s8(v246, v246, 4uLL).u64[0];
              *(float *)v246.unint64_t i32 = PDAhardlightPDA(*(float *)&v249, v248, v47, v48, v247, v249, v250, v51, *(float *)v246.i32, COERCE_DOUBLE(__PAIR64__(v246.u32[3], HIDWORD(v250))), *(float *)&v246.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v246.i32[1] = v251;
              v246.i64[1] = __PAIR64__(LODWORD(v48), LODWORD(v47));
LABEL_308:
              *int v24 = vrev32q_s8(v246);
            }
          }
LABEL_309:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v243) {
            goto LABEL_368;
          }
        }
      case 0x16u:
        int v252 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v253 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v254 = *v99 * v253 + ((*v99 * v253) >> 8) + 1;
              if (!BYTE1(v254)) {
                goto LABEL_325;
              }
              unsigned int v253 = v254 >> 8;
            }
            float32x4_t v255 = vmulq_n_f32(*v52, (float)v253 * 0.0039216);
            if (v255.f32[3] > 0.0)
            {
              if (v354)
              {
                float v256 = COERCE_FLOAT(bswap32(v24->u32[3]));
                if (v256 <= 0.0)
                {
LABEL_324:
                  *int v24 = vrev32q_s8((int8x16_t)v255);
                  goto LABEL_325;
                }
              }
              else
              {
                float v256 = 1.0;
              }
              float v257 = COERCE_FLOAT(bswap32(v24->u32[2]));
              float32x2_t v258 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
              float32x2_t v259 = vadd_f32(*(float32x2_t *)v255.f32, v258);
              float32x2_t v260 = vmul_laneq_f32(v258, v255, 3);
              float32x2_t v261 = vmul_n_f32(*(float32x2_t *)v255.f32, v256);
              float32x2_t v262 = vsub_f32(v259, v260);
              float32x2_t v263 = vsub_f32(v260, v261);
              v255.f32[0] = vmuls_lane_f32(v256, v255, 2);
              *(float32x2_t *)v264.f32 = vadd_f32(vsub_f32(v262, v261), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(v263), (int8x8_t)vneg_f32(v263), (int8x8_t)v263));
              float v265 = (float)(v255.f32[3] * v257) - v255.f32[0];
              v255.f32[0] = (float)((float)(v255.f32[2] + v257) - (float)(v255.f32[3] * v257)) - v255.f32[0];
              if (v265 < 0.0) {
                float v265 = -v265;
              }
              v264.i64[1] = __PAIR64__((float)(v256 + v255.f32[3]) - (float)(v256 * v255.f32[3]), v255.f32[0] + v265);
              float32x4_t v255 = v264;
              goto LABEL_324;
            }
          }
LABEL_325:
          ++v53;
          ++v52;
          v99 += v33 != 0;
          ++v24;
          if (!--v252) {
            goto LABEL_339;
          }
        }
      case 0x17u:
        unsigned int v266 = (float32x2_t *)&v52->u32[2];
        int v267 = v4;
        float32x4_t v99 = v33;
        while (1)
        {
          unsigned int v268 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v269 = *v99 * v268 + ((*v99 * v268) >> 8) + 1;
              if (!BYTE1(v269)) {
                goto LABEL_338;
              }
              unsigned int v268 = v269 >> 8;
            }
            float v270 = (float)v268 * 0.0039216;
            float32x2_t v271 = vmul_n_f32(*v266, v270);
            if (v271.f32[1] > 0.0)
            {
              *(float32x2_t *)v272.unint64_t i8 = vmul_n_f32(v266[-1], v270);
              if (!v354)
              {
                float v273 = 1.0;
LABEL_337:
                float v274 = COERCE_FLOAT(bswap32(v24->u32[2]));
                unsigned int v275 = bswap32(COERCE_UNSIGNED_INT((float)(v271.f32[0] + v274) + (float)((float)(v274 * v271.f32[0])
                                                                                       * -2.0)));
                *(float *)&unsigned int v276 = (float)(v271.f32[1] + v273) - (float)(v273 * v271.f32[1]);
                float32x2_t v277 = (float32x2_t)vrev32_s8(*(int8x8_t *)v24->i8);
                *(int8x8_t *)v24->unint64_t i8 = vrev32_s8((int8x8_t)vmla_f32(vadd_f32(*(float32x2_t *)v272.i8, v277), (float32x2_t)0xC0000000C0000000, vmul_f32(*(float32x2_t *)v272.i8, v277)));
                v24->i32[2] = v275;
                v24->i32[3] = bswap32(v276);
                goto LABEL_338;
              }
              float v273 = COERCE_FLOAT(bswap32(v24->u32[3]));
              if (v273 > 0.0) {
                goto LABEL_337;
              }
              v272.u64[1] = (unint64_t)v271;
              *int v24 = vrev32q_s8(v272);
            }
          }
LABEL_338:
          ++v53;
          v99 += v33 != 0;
          ++v24;
          v266 += 2;
          if (!--v267)
          {
LABEL_339:
            uint64_t v33 = &v99[v345];
LABEL_340:
            v24 += v349;
            goto LABEL_370;
          }
        }
      case 0x18u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v278 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v279 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v280 = *v166 * v279 + ((*v166 * v279) >> 8) + 1;
              if (!BYTE1(v280)) {
                goto LABEL_353;
              }
              unsigned int v279 = v280 >> 8;
            }
            int8x16_t v281 = (int8x16_t)vmulq_n_f32(*v52, (float)v279 * *((float *)v68 + 677));
            if (*(float *)&v281.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v282 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_352;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v282 = 1.0;
              }
              double v283 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(void *)&double v335 = vextq_s8(v281, v281, 4uLL).u64[0];
              *(float *)v281.unint64_t i32 = PDAhuePDA(*(float *)&v283, *((float *)&v283 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v282, v283, v335, v51, *(float *)v281.i32, *(float *)&v335, *((float *)&v335 + 1), *(float *)&v281.i32[3], *(float *)&v281.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v281.i32[1] = v284;
              v281.i64[1] = __PAIR64__(LODWORD(v48), v285);
LABEL_352:
              *int v24 = vrev32q_s8(v281);
            }
          }
LABEL_353:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v278) {
            goto LABEL_368;
          }
        }
      case 0x19u:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v286 = v4;
        int8x16_t v166 = v33;
        while (1)
        {
          unsigned int v287 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v288 = *v166 * v287 + ((*v166 * v287) >> 8) + 1;
              if (!BYTE1(v288)) {
                goto LABEL_367;
              }
              unsigned int v287 = v288 >> 8;
            }
            int8x16_t v289 = (int8x16_t)vmulq_n_f32(*v52, (float)v287 * *((float *)v68 + 677));
            if (*(float *)&v289.i32[3] > 0.0)
            {
              if (v354)
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v290 = *(float *)&v48;
                if (*(float *)&v48 <= 0.0) {
                  goto LABEL_366;
                }
              }
              else
              {
                LODWORD(v48) = bswap32(v24->u32[3]);
                float v290 = 1.0;
              }
              double v291 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(void *)&double v336 = vextq_s8(v289, v289, 4uLL).u64[0];
              *(float *)v289.unint64_t i32 = PDAsaturationPDA(*(float *)&v291, *((float *)&v291 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v290, v291, v336, v51, *(float *)v289.i32, *(float *)&v336, *((float *)&v336 + 1), *(float *)&v289.i32[3], *(float *)&v289.i32[3]);
              uint64_t v68 = &xmmword_1850CE000;
              v289.i32[1] = v292;
              v289.i64[1] = __PAIR64__(LODWORD(v48), v293);
LABEL_366:
              *int v24 = vrev32q_s8(v289);
            }
          }
LABEL_367:
          ++v53;
          ++v52;
          v166 += v33 != 0;
          ++v24;
          if (!--v286)
          {
LABEL_368:
            uint64_t v33 = &v166[v345];
LABEL_369:
            uint64_t v29 = v348;
            v24 += v349;
            unsigned int v35 = v344;
            uint64_t v28 = v346;
LABEL_370:
            int v76 = v353;
            goto LABEL_371;
          }
        }
      case 0x1Au:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        int v296 = v4;
        unint64_t v297 = v33;
        while (1)
        {
          unsigned int v298 = *v53;
          if (*v53)
          {
            if (v33)
            {
              unsigned int v299 = *v297 * v298 + ((*v297 * v298) >> 8) + 1;
              if (!BYTE1(v299)) {
                goto LABEL_386;
              }
              unsigned int v298 = v299 >> 8;
            }
            int8x16_t v300 = (int8x16_t)vmulq_n_f32(*v52, (float)v298 * *((float *)v68 + 677));
            LODWORD(v48) = v300.i32[3];
            if (*(float *)&v300.i32[3] > 0.0)
            {
              if (v354)
              {
                float v301 = COERCE_FLOAT(bswap32(v24->u32[3]));
                *(float *)&double v50 = v301;
                if (v301 <= 0.0) {
                  goto LABEL_385;
                }
              }
              else
              {
                float v301 = COERCE_FLOAT(bswap32(v24->u32[3]));
                LODWORD(v50) = 1.0;
              }
              double v333 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
              *(float *)v300.unint64_t i32 = PDAluminosityPDA(*(float *)v300.i32, *(float *)&v300.i32[1], *(float *)&v300.i32[2], v48, *(float *)&v300.i32[3], v50, v333, v51, *(float *)&v333, *((float *)&v333 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v301, *(float *)&v50);
              uint64_t v68 = &xmmword_1850CE000;
              v300.i32[1] = v302;
              v300.i64[1] = __PAIR64__(LODWORD(v48), v303);
LABEL_385:
              *int v24 = vrev32q_s8(v300);
            }
          }
LABEL_386:
          ++v53;
          ++v52;
          v297 += v33 != 0;
          ++v24;
          if (!--v296) {
            goto LABEL_401;
          }
        }
      case 0x1Bu:
        uint64_t v348 = v29;
        uint64_t v346 = v28;
        unint64_t v297 = v33;
        int v304 = v4;
        break;
      default:
        goto LABEL_370;
    }
    break;
  }
  while (1)
  {
    unsigned int v305 = *v53;
    if (*v53)
    {
      if (v33)
      {
        unsigned int v306 = *v297 * v305 + ((*v297 * v305) >> 8) + 1;
        if (!BYTE1(v306)) {
          goto LABEL_400;
        }
        unsigned int v305 = v306 >> 8;
      }
      int8x16_t v307 = (int8x16_t)vmulq_n_f32(*v52, (float)v305 * *((float *)v68 + 677));
      if (*(float *)&v307.i32[3] > 0.0)
      {
        if (v354)
        {
          LODWORD(v48) = bswap32(v24->u32[3]);
          float v308 = *(float *)&v48;
          if (*(float *)&v48 <= 0.0) {
            goto LABEL_399;
          }
        }
        else
        {
          LODWORD(v48) = bswap32(v24->u32[3]);
          float v308 = 1.0;
        }
        double v309 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)v24->i8));
        *(void *)&double v337 = vextq_s8(v307, v307, 4uLL).u64[0];
        *(float *)v307.unint64_t i32 = PDAluminosityPDA(*(float *)&v309, *((float *)&v309 + 1), COERCE_FLOAT(bswap32(v24->u32[2])), v48, v308, v309, v337, v51, *(float *)v307.i32, *(float *)&v337, *((float *)&v337 + 1), *(float *)&v307.i32[3], *(float *)&v307.i32[3]);
        uint64_t v68 = &xmmword_1850CE000;
        v307.i32[1] = v310;
        v307.i64[1] = __PAIR64__(LODWORD(v48), v311);
LABEL_399:
        *int v24 = vrev32q_s8(v307);
      }
    }
LABEL_400:
    ++v53;
    ++v52;
    v297 += v33 != 0;
    ++v24;
    if (!--v304)
    {
LABEL_401:
      uint64_t v33 = &v297[v345];
      goto LABEL_369;
    }
  }
}

uint64_t RGBAF_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6 = *((float *)a2 + 2);
  int v7 = a2[1];
  float v82 = *(float *)a2;
  unint64_t v8 = *(unsigned int **)(a1 + 32);
  if (*(void *)(a1 + 40)) {
    char v9 = 0;
  }
  else {
    char v9 = -1;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v11 = *((void *)a2 + 3) - a5;
  uint64_t v13 = *((void *)a2 + 15);
  uint64_t v12 = *((void *)a2 + 16);
  uint64_t v14 = *((void *)a2 + 7);
  uint64_t v15 = *((void *)a2 + 9);
  uint64_t v16 = *((void *)a2 + 5) + v15 * a4;
  uint64_t v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(void *)(a1 + 176))
  {
    uint64_t v81 = *((void *)a2 + 11);
    uint64_t v80 = *((void *)a2 + 13);
    uint64_t v79 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v16) | (v16 - v81)) < 0)
      {
        unsigned int v20 = 0;
        uint64_t v19 = 0;
      }
      else
      {
        unint64_t v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9) {
          uint64_t v19 = -v13;
        }
        else {
          uint64_t v19 = v13;
        }
        unsigned int v20 = weights_21383[v18] & 0xF;
      }
      uint64_t result = v16 >> v14;
      uint64_t v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v82) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v20;
          unint64_t v23 = (uint64_t *)v79;
          uint64_t v24 = a5;
          do
          {
            uint64_t v25 = *(v23 - 1);
            uint64_t v26 = *v23;
            int v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25]) {
              uint64_t v28 = (unsigned int *)&v22[v25];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v8 > v28) {
              uint64_t v28 = v8;
            }
            unsigned int v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              int v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30) {
                int v30 = v17;
              }
              if (v8 > v30) {
                int v30 = v8;
              }
              unsigned int v31 = *v30;
              if (v20)
              {
                uint64_t v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v8 > v33) {
                  uint64_t v33 = v8;
                }
                unsigned int v34 = *v33;
                unsigned int v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35) {
                  unsigned int v35 = v17;
                }
                if (v8 > v35) {
                  unsigned int v35 = v8;
                }
                unsigned int v36 = BLEND8_21385[v20];
                unsigned int v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_21385[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              uint64_t v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19]) {
                uint64_t v37 = v17;
              }
              if (v8 > v37) {
                uint64_t v37 = v8;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v20] & v29) >> v20) + ((BLEND8_21385[v20] & *v37) >> v20);
            }
            unsigned int v38 = __ROL4__(v29, v7);
            float v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              float v40 = *(float *)&_blt_float[BYTE2(v38)];
              float v41 = *(float *)&_blt_float[BYTE1(v38)];
              float v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              float v39 = v6 * v39;
              float v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              float v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              float v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *uint64_t v10 = bswap32(LODWORD(v39));
            v10[1] = bswap32(LODWORD(v40));
            void v10[2] = bswap32(LODWORD(v41));
            v10[3] = bswap32(LODWORD(v42));
            v10 += 4;
            --v24;
          }
          while (v24);
        }
        goto LABEL_86;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_86:
      v10 += 4 * v11;
      v16 += v15;
      if (!--a6) {
        return result;
      }
    }
    uint64_t v43 = (uint64_t *)v79;
    uint64_t result = a5;
    while (1)
    {
      uint64_t v44 = *(v43 - 1);
      uint64_t v45 = *v43;
      int32x2_t v46 = &v22[v44];
      if (v17 >= (unsigned int *)&v22[v44]) {
        double v47 = (unsigned int *)&v22[v44];
      }
      else {
        double v47 = v17;
      }
      if (v8 > v47) {
        double v47 = v8;
      }
      unsigned int v48 = *v47;
      if ((v45 & 0xF) != 0)
      {
        double v49 = (unsigned int *)&v46[v45 >> 4];
        if (v17 < v49) {
          double v49 = v17;
        }
        if (v8 > v49) {
          double v49 = v8;
        }
        unsigned int v50 = *v49;
        if (v20)
        {
          if (v17 >= (unsigned int *)&v46[v19]) {
            double v51 = (unsigned int *)&v46[v19];
          }
          else {
            double v51 = v17;
          }
          if (v8 > v51) {
            double v51 = v8;
          }
          unsigned int v52 = *v51;
          uint64_t v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
          if (v17 < v53) {
            uint64_t v53 = v17;
          }
          if (v8 > v53) {
            uint64_t v53 = v8;
          }
          unsigned int v54 = BLEND8_21385[v20];
          unsigned int v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
          unsigned int v50 = v50 - ((v54 & v50) >> v20) + ((v54 & *v53) >> v20);
        }
        unsigned int v48 = v48
            - ((BLEND8_21385[*v43 & 0xF] & v48) >> (*v43 & 0xF))
            + ((BLEND8_21385[*v43 & 0xF] & v50) >> (*v43 & 0xF));
      }
      else if (v20)
      {
        int v55 = (unsigned int *)&v46[v19];
        if (v17 < (unsigned int *)&v46[v19]) {
          int v55 = v17;
        }
        if (v8 > v55) {
          int v55 = v8;
        }
        unsigned int v48 = v48 - ((BLEND8_21385[v20] & v48) >> v20) + ((BLEND8_21385[v20] & *v55) >> v20);
      }
      unsigned int v56 = __ROL4__(v48, v7);
      float v57 = *(float *)&_blt_float[HIBYTE(v56)];
      if (v6 >= 1.0)
      {
        float v58 = *(float *)&_blt_float[BYTE2(v56)];
        float v59 = *(float *)&_blt_float[BYTE1(v56)];
        float v60 = *(float *)&_blt_float[(v56 | v9)];
      }
      else
      {
        float v57 = v6 * v57;
        float v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
        float v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
        float v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
      }
      if (v60 >= 1.0) {
        goto LABEL_84;
      }
      if (v60 > 0.0) {
        break;
      }
LABEL_85:
      v43 += 2;
      v10 += 4;
      if (!--result) {
        goto LABEL_86;
      }
    }
    float v57 = v57 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v60));
    float v58 = v58 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v60));
    float v59 = v59 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v60));
    float v60 = v60 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v60));
LABEL_84:
    *uint64_t v10 = bswap32(LODWORD(v57));
    v10[1] = bswap32(LODWORD(v58));
    void v10[2] = bswap32(LODWORD(v59));
    v10[3] = bswap32(LODWORD(v60));
    goto LABEL_85;
  }
  uint64_t v61 = v12 + 16 * a3;
  uint64_t result = 32;
  do
  {
    unint64_t v62 = (char *)v8 + (v16 >> v14) * v13;
    if (LODWORD(v82) != 1)
    {
      uint64_t result = v61;
      uint64_t v71 = a5;
      if (a5 < 1) {
        goto LABEL_114;
      }
      while (1)
      {
        uint64_t v72 = *(void *)result;
        result += 16;
        int v73 = (unsigned int *)&v62[v72];
        if (v17 < (unsigned int *)&v62[v72]) {
          int v73 = v17;
        }
        if (v8 > v73) {
          int v73 = v8;
        }
        unsigned int v74 = __ROL4__(*v73, v7);
        float v75 = *(float *)&_blt_float[HIBYTE(v74)];
        if (v6 >= 1.0)
        {
          float v76 = *(float *)&_blt_float[BYTE2(v74)];
          float v77 = *(float *)&_blt_float[BYTE1(v74)];
          float v78 = *(float *)&_blt_float[(v74 | v9)];
        }
        else
        {
          float v75 = v6 * v75;
          float v76 = v6 * *(float *)&_blt_float[BYTE2(v74)];
          float v77 = v6 * *(float *)&_blt_float[BYTE1(v74)];
          float v78 = v6 * *(float *)&_blt_float[(v74 | v9)];
        }
        if (v78 >= 1.0) {
          goto LABEL_112;
        }
        if (v78 > 0.0) {
          break;
        }
LABEL_113:
        v10 += 4;
        if (!--v71) {
          goto LABEL_114;
        }
      }
      float v75 = v75 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v78));
      float v76 = v76 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v78));
      float v77 = v77 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v78));
      float v78 = v78 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v78));
LABEL_112:
      *uint64_t v10 = bswap32(LODWORD(v75));
      v10[1] = bswap32(LODWORD(v76));
      void v10[2] = bswap32(LODWORD(v77));
      v10[3] = bswap32(LODWORD(v78));
      goto LABEL_113;
    }
    if (a5 >= 1)
    {
      uint64_t result = v61;
      uint64_t v63 = a5;
      do
      {
        uint64_t v64 = *(void *)result;
        result += 16;
        int v65 = (unsigned int *)&v62[v64];
        if (v17 < (unsigned int *)&v62[v64]) {
          int v65 = v17;
        }
        if (v8 > v65) {
          int v65 = v8;
        }
        unsigned int v66 = __ROL4__(*v65, v7);
        float v67 = *(float *)&_blt_float[HIBYTE(v66)];
        if (v6 >= 1.0)
        {
          float v68 = *(float *)&_blt_float[BYTE2(v66)];
          float v69 = *(float *)&_blt_float[BYTE1(v66)];
          float v70 = *(float *)&_blt_float[(v66 | v9)];
        }
        else
        {
          float v67 = v6 * v67;
          float v68 = v6 * *(float *)&_blt_float[BYTE2(v66)];
          float v69 = v6 * *(float *)&_blt_float[BYTE1(v66)];
          float v70 = v6 * *(float *)&_blt_float[(v66 | v9)];
        }
        *uint64_t v10 = bswap32(LODWORD(v67));
        v10[1] = bswap32(LODWORD(v68));
        void v10[2] = bswap32(LODWORD(v69));
        v10[3] = bswap32(LODWORD(v70));
        v10 += 4;
        --v63;
      }
      while (v63);
    }
LABEL_114:
    v10 += 4 * v11;
    v16 += v15;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t RGBAF_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float v6 = *((float *)a2 + 2);
  int v7 = a2[1];
  float v82 = *(float *)a2;
  unint64_t v8 = *(unsigned int **)(a1 + 32);
  if (*(void *)(a1 + 40)) {
    char v9 = 0;
  }
  else {
    char v9 = -1;
  }
  uint64_t v10 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v11 = *((void *)a2 + 3) - a5;
  uint64_t v13 = *((void *)a2 + 15);
  uint64_t v12 = *((void *)a2 + 16);
  uint64_t v14 = *((void *)a2 + 7);
  uint64_t v15 = *((void *)a2 + 9);
  uint64_t v16 = *((void *)a2 + 5) + v15 * a4;
  uint64_t v17 = (unsigned int *)((char *)v8
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  if (*(void *)(a1 + 176))
  {
    uint64_t v81 = *((void *)a2 + 11);
    uint64_t v80 = *((void *)a2 + 13);
    uint64_t v79 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v80 - v16) | (v16 - v81)) < 0)
      {
        unsigned int v20 = 0;
        uint64_t v19 = 0;
      }
      else
      {
        unint64_t v18 = ((v16 & (unint64_t)~(-1 << v14)) >> (v14 - 4)) & 0xF;
        if (v18 - 7 >= 9) {
          uint64_t v19 = -v13;
        }
        else {
          uint64_t v19 = v13;
        }
        unsigned int v20 = weights_21383[v18] & 0xF;
      }
      uint64_t result = v16 >> v14;
      uint64_t v22 = (char *)v8 + (v16 >> v14) * v13;
      if (LODWORD(v82) == 1)
      {
        if (a5 >= 1)
        {
          uint64_t result = v20;
          unint64_t v23 = (uint64_t *)v79;
          uint64_t v24 = a5;
          do
          {
            uint64_t v25 = *(v23 - 1);
            uint64_t v26 = *v23;
            int v27 = &v22[v25];
            if (v17 >= (unsigned int *)&v22[v25]) {
              uint64_t v28 = (unsigned int *)&v22[v25];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v8 > v28) {
              uint64_t v28 = v8;
            }
            unsigned int v29 = bswap32(*v28);
            if ((v26 & 0xF) != 0)
            {
              int v30 = (unsigned int *)&v27[v26 >> 4];
              if (v17 < v30) {
                int v30 = v17;
              }
              if (v8 > v30) {
                int v30 = v8;
              }
              unsigned int v31 = bswap32(*v30);
              if (v20)
              {
                uint64_t v32 = (unsigned int *)&v27[v19];
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v8 > v33) {
                  uint64_t v33 = v8;
                }
                unsigned int v34 = bswap32(*v33);
                unsigned int v35 = (unsigned int *)((char *)v32 + (v26 >> 4));
                if (v17 < v35) {
                  unsigned int v35 = v17;
                }
                if (v8 > v35) {
                  unsigned int v35 = v8;
                }
                int v36 = BLEND8_21385[v20];
                unsigned int v29 = v29 - ((v36 & v29) >> v20) + ((v36 & v34) >> v20);
                unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((bswap32(*v35) & v36) >> v20);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v23 & 0xF] & v29) >> (*v23 & 0xF))
                  + ((BLEND8_21385[*v23 & 0xF] & v31) >> (*v23 & 0xF));
            }
            else if (v20)
            {
              uint64_t v37 = (unsigned int *)&v27[v19];
              if (v17 < (unsigned int *)&v27[v19]) {
                uint64_t v37 = v17;
              }
              if (v8 > v37) {
                uint64_t v37 = v8;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v20] & v29) >> v20) + ((bswap32(*v37) & BLEND8_21385[v20]) >> v20);
            }
            unsigned int v38 = __ROL4__(v29, v7);
            float v39 = *(float *)&_blt_float[HIBYTE(v38)];
            if (v6 >= 1.0)
            {
              float v40 = *(float *)&_blt_float[BYTE2(v38)];
              float v41 = *(float *)&_blt_float[BYTE1(v38)];
              float v42 = *(float *)&_blt_float[(v38 | v9)];
            }
            else
            {
              float v39 = v6 * v39;
              float v40 = v6 * *(float *)&_blt_float[BYTE2(v38)];
              float v41 = v6 * *(float *)&_blt_float[BYTE1(v38)];
              float v42 = v6 * *(float *)&_blt_float[(v38 | v9)];
            }
            v23 += 2;
            *uint64_t v10 = bswap32(LODWORD(v39));
            v10[1] = bswap32(LODWORD(v40));
            void v10[2] = bswap32(LODWORD(v41));
            v10[3] = bswap32(LODWORD(v42));
            v10 += 4;
            --v24;
          }
          while (v24);
        }
        goto LABEL_86;
      }
      if (a5 >= 1) {
        break;
      }
LABEL_86:
      v10 += 4 * v11;
      v16 += v15;
      if (!--a6) {
        return result;
      }
    }
    uint64_t v43 = (uint64_t *)v79;
    uint64_t result = a5;
    while (1)
    {
      uint64_t v44 = *(v43 - 1);
      uint64_t v45 = *v43;
      int32x2_t v46 = &v22[v44];
      if (v17 >= (unsigned int *)&v22[v44]) {
        double v47 = (unsigned int *)&v22[v44];
      }
      else {
        double v47 = v17;
      }
      if (v8 > v47) {
        double v47 = v8;
      }
      unsigned int v48 = bswap32(*v47);
      if ((v45 & 0xF) != 0)
      {
        double v49 = (unsigned int *)&v46[v45 >> 4];
        if (v17 < v49) {
          double v49 = v17;
        }
        if (v8 > v49) {
          double v49 = v8;
        }
        unsigned int v50 = bswap32(*v49);
        if (v20)
        {
          if (v17 >= (unsigned int *)&v46[v19]) {
            double v51 = (unsigned int *)&v46[v19];
          }
          else {
            double v51 = v17;
          }
          if (v8 > v51) {
            double v51 = v8;
          }
          unsigned int v52 = bswap32(*v51);
          uint64_t v53 = (unsigned int *)&v46[v19 + (v45 >> 4)];
          if (v17 < v53) {
            uint64_t v53 = v17;
          }
          if (v8 > v53) {
            uint64_t v53 = v8;
          }
          int v54 = BLEND8_21385[v20];
          unsigned int v48 = v48 - ((v54 & v48) >> v20) + ((v54 & v52) >> v20);
          unsigned int v50 = v50 - ((v54 & v50) >> v20) + ((bswap32(*v53) & v54) >> v20);
        }
        unsigned int v48 = v48
            - ((BLEND8_21385[*v43 & 0xF] & v48) >> (*v43 & 0xF))
            + ((BLEND8_21385[*v43 & 0xF] & v50) >> (*v43 & 0xF));
      }
      else if (v20)
      {
        int v55 = (unsigned int *)&v46[v19];
        if (v17 < (unsigned int *)&v46[v19]) {
          int v55 = v17;
        }
        if (v8 > v55) {
          int v55 = v8;
        }
        unsigned int v48 = v48 - ((BLEND8_21385[v20] & v48) >> v20) + ((bswap32(*v55) & BLEND8_21385[v20]) >> v20);
      }
      unsigned int v56 = __ROL4__(v48, v7);
      float v57 = *(float *)&_blt_float[HIBYTE(v56)];
      if (v6 >= 1.0)
      {
        float v58 = *(float *)&_blt_float[BYTE2(v56)];
        float v59 = *(float *)&_blt_float[BYTE1(v56)];
        float v60 = *(float *)&_blt_float[(v56 | v9)];
      }
      else
      {
        float v57 = v6 * v57;
        float v58 = v6 * *(float *)&_blt_float[BYTE2(v56)];
        float v59 = v6 * *(float *)&_blt_float[BYTE1(v56)];
        float v60 = v6 * *(float *)&_blt_float[(v56 | v9)];
      }
      if (v60 >= 1.0) {
        goto LABEL_84;
      }
      if (v60 > 0.0) {
        break;
      }
LABEL_85:
      v43 += 2;
      v10 += 4;
      if (!--result) {
        goto LABEL_86;
      }
    }
    float v57 = v57 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v60));
    float v58 = v58 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v60));
    float v59 = v59 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v60));
    float v60 = v60 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v60));
LABEL_84:
    *uint64_t v10 = bswap32(LODWORD(v57));
    v10[1] = bswap32(LODWORD(v58));
    void v10[2] = bswap32(LODWORD(v59));
    v10[3] = bswap32(LODWORD(v60));
    goto LABEL_85;
  }
  uint64_t v61 = v12 + 16 * a3;
  uint64_t result = 32;
  do
  {
    unint64_t v62 = (char *)v8 + (v16 >> v14) * v13;
    if (LODWORD(v82) != 1)
    {
      uint64_t result = v61;
      uint64_t v71 = a5;
      if (a5 < 1) {
        goto LABEL_114;
      }
      while (1)
      {
        uint64_t v72 = *(void *)result;
        result += 16;
        int v73 = (unsigned int *)&v62[v72];
        if (v17 < (unsigned int *)&v62[v72]) {
          int v73 = v17;
        }
        if (v8 > v73) {
          int v73 = v8;
        }
        unsigned int v74 = __ROL4__(bswap32(*v73), v7);
        float v75 = *(float *)&_blt_float[HIBYTE(v74)];
        if (v6 >= 1.0)
        {
          float v76 = *(float *)&_blt_float[BYTE2(v74)];
          float v77 = *(float *)&_blt_float[BYTE1(v74)];
          float v78 = *(float *)&_blt_float[(v74 | v9)];
        }
        else
        {
          float v75 = v6 * v75;
          float v76 = v6 * *(float *)&_blt_float[BYTE2(v74)];
          float v77 = v6 * *(float *)&_blt_float[BYTE1(v74)];
          float v78 = v6 * *(float *)&_blt_float[(v74 | v9)];
        }
        if (v78 >= 1.0) {
          goto LABEL_112;
        }
        if (v78 > 0.0) {
          break;
        }
LABEL_113:
        v10 += 4;
        if (!--v71) {
          goto LABEL_114;
        }
      }
      float v75 = v75 + (float)(COERCE_FLOAT(bswap32(*v10)) * (float)(1.0 - v78));
      float v76 = v76 + (float)(COERCE_FLOAT(bswap32(v10[1])) * (float)(1.0 - v78));
      float v77 = v77 + (float)(COERCE_FLOAT(bswap32(v10[2])) * (float)(1.0 - v78));
      float v78 = v78 + (float)(COERCE_FLOAT(bswap32(v10[3])) * (float)(1.0 - v78));
LABEL_112:
      *uint64_t v10 = bswap32(LODWORD(v75));
      v10[1] = bswap32(LODWORD(v76));
      void v10[2] = bswap32(LODWORD(v77));
      v10[3] = bswap32(LODWORD(v78));
      goto LABEL_113;
    }
    if (a5 >= 1)
    {
      uint64_t result = v61;
      uint64_t v63 = a5;
      do
      {
        uint64_t v64 = *(void *)result;
        result += 16;
        int v65 = (unsigned int *)&v62[v64];
        if (v17 < (unsigned int *)&v62[v64]) {
          int v65 = v17;
        }
        if (v8 > v65) {
          int v65 = v8;
        }
        unsigned int v66 = __ROL4__(bswap32(*v65), v7);
        float v67 = *(float *)&_blt_float[HIBYTE(v66)];
        if (v6 >= 1.0)
        {
          float v68 = *(float *)&_blt_float[BYTE2(v66)];
          float v69 = *(float *)&_blt_float[BYTE1(v66)];
          float v70 = *(float *)&_blt_float[(v66 | v9)];
        }
        else
        {
          float v67 = v6 * v67;
          float v68 = v6 * *(float *)&_blt_float[BYTE2(v66)];
          float v69 = v6 * *(float *)&_blt_float[BYTE1(v66)];
          float v70 = v6 * *(float *)&_blt_float[(v66 | v9)];
        }
        *uint64_t v10 = bswap32(LODWORD(v67));
        v10[1] = bswap32(LODWORD(v68));
        void v10[2] = bswap32(LODWORD(v69));
        v10[3] = bswap32(LODWORD(v70));
        v10 += 4;
        --v63;
      }
      while (v63);
    }
LABEL_114:
    v10 += 4 * v11;
    v16 += v15;
    --a6;
  }
  while (a6);
  return result;
}

_DWORD *RGBAF_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, double a9)
{
  LODWORD(v9) = a2[2];
  int v10 = *a2;
  uint64_t v11 = *((void *)a2 + 2);
  uint64_t v12 = *((void *)a2 + 3) - a5;
  uint64_t v13 = *((void *)a2 + 15);
  uint64_t v14 = *((void *)a2 + 16);
  uint64_t v15 = *((void *)a2 + 7);
  uint64_t v16 = *((void *)a2 + 9);
  uint64_t v17 = *((void *)a2 + 5) + v16 * a4;
  unint64_t v18 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v19 = &v18[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v20 = *(void *)(a1 + 176);
  uint64_t result = _blt_float;
  if (v20)
  {
    uint64_t v90 = *((void *)a2 + 11);
    uint64_t v22 = *((void *)a2 + 13);
    *(float *)&a9 = 1.0 - v9;
    float32x4_t v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    uint64_t v89 = v14 + 16 * a3 + 8;
    __asm { FMOV            V3.2S, #1.0 }
    do
    {
      if (((v22 - v17) | (v17 - v90)) < 0)
      {
        int v31 = 0;
        uint64_t v30 = 0;
      }
      else
      {
        unint64_t v29 = ((v17 & (unint64_t)~(-1 << v15)) >> (v15 - 4)) & 0xF;
        if (v29 - 7 >= 9) {
          uint64_t v30 = -v13;
        }
        else {
          uint64_t v30 = v13;
        }
        int v31 = weights_21383[v29] & 0xF;
      }
      uint64_t v32 = &v18[(v17 >> v15) * v13];
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v33 = (uint64_t *)v89;
          uint64_t v34 = a5;
          do
          {
            uint64_t v35 = *(v33 - 1);
            uint64_t v36 = *v33;
            uint64_t v37 = &v32[v35];
            if (v19 >= &v32[v35]) {
              unsigned int v38 = &v32[v35];
            }
            else {
              unsigned int v38 = v19;
            }
            if (v18 > v38) {
              unsigned int v38 = v18;
            }
            unsigned int v39 = (*v38 << 24) | (v38[1] << 16) | (v38[2] << 8);
            if ((v36 & 0xF) != 0)
            {
              float v40 = &v37[v36 >> 4];
              if (v19 < v40) {
                float v40 = v19;
              }
              if (v18 > v40) {
                float v40 = v18;
              }
              int v41 = (*v40 << 24) | (v40[1] << 16) | (v40[2] << 8);
              if (v31)
              {
                float v42 = &v37[v30];
                if (v19 >= &v37[v30]) {
                  uint64_t v43 = &v37[v30];
                }
                else {
                  uint64_t v43 = v19;
                }
                if (v18 > v43) {
                  uint64_t v43 = v18;
                }
                int v44 = (*v43 << 24) | (v43[1] << 16) | (v43[2] << 8);
                uint64_t v45 = &v42[v36 >> 4];
                if (v19 < v45) {
                  uint64_t v45 = v19;
                }
                if (v18 > v45) {
                  uint64_t v45 = v18;
                }
                unsigned int v46 = BLEND8_21385[v31];
                unsigned int v39 = v39 - ((v46 & v39) >> v31) + ((v46 & v44) >> v31);
                int v41 = v41 - ((v46 & v41) >> v31) + ((((*v45 << 24) | (v45[1] << 16) | (v45[2] << 8)) & v46) >> v31);
              }
              unsigned int v39 = v39
                  - ((BLEND8_21385[*v33 & 0xF] & v39) >> (*v33 & 0xF))
                  + ((BLEND8_21385[*v33 & 0xF] & v41) >> (*v33 & 0xF));
            }
            else if (v31)
            {
              double v47 = &v37[v30];
              if (v19 < &v37[v30]) {
                double v47 = v19;
              }
              if (v18 > v47) {
                double v47 = v18;
              }
              unsigned int v39 = v39
                  - ((BLEND8_21385[v31] & v39) >> v31)
                  + ((((*v47 << 24) | (v47[1] << 16) | (v47[2] << 8)) & BLEND8_21385[v31]) >> v31);
            }
            float v48 = *(float *)&_blt_float[HIBYTE(v39)];
            if (v9 >= 1.0)
            {
              float v49 = *(float *)&_blt_float[BYTE2(v39)];
              v50.i32[1] = HIDWORD(_D3);
              v50.i32[0] = _blt_float[BYTE1(v39)];
            }
            else
            {
              float v48 = v9 * v48;
              float v49 = v9 * *(float *)&_blt_float[BYTE2(v39)];
              *(float *)v50.unint64_t i32 = v9 * *(float *)&_blt_float[BYTE1(v39)];
              *(float *)&v50.i32[1] = v9;
            }
            v33 += 2;
            *(_DWORD *)uint64_t v11 = bswap32(LODWORD(v48));
            *(_DWORD *)(v11 + 4) = bswap32(LODWORD(v49));
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v50);
            v11 += 16;
            --v34;
          }
          while (v34);
        }
      }
      else if (a5 >= 1)
      {
        double v51 = (uint64_t *)v89;
        uint64_t v52 = a5;
        do
        {
          uint64_t v53 = *(v51 - 1);
          uint64_t v54 = *v51;
          int v55 = &v32[v53];
          if (v19 >= &v32[v53]) {
            unsigned int v56 = &v32[v53];
          }
          else {
            unsigned int v56 = v19;
          }
          if (v18 > v56) {
            unsigned int v56 = v18;
          }
          unsigned int v57 = (*v56 << 24) | (v56[1] << 16) | (v56[2] << 8);
          if ((v54 & 0xF) != 0)
          {
            float v58 = &v55[v54 >> 4];
            if (v19 < v58) {
              float v58 = v19;
            }
            if (v18 > v58) {
              float v58 = v18;
            }
            int v59 = (*v58 << 24) | (v58[1] << 16) | (v58[2] << 8);
            if (v31)
            {
              if (v19 >= &v55[v30]) {
                float v60 = &v55[v30];
              }
              else {
                float v60 = v19;
              }
              if (v18 > v60) {
                float v60 = v18;
              }
              int v61 = (*v60 << 24) | (v60[1] << 16) | (v60[2] << 8);
              unint64_t v62 = &v55[v30 + (v54 >> 4)];
              if (v19 < v62) {
                unint64_t v62 = v19;
              }
              if (v18 > v62) {
                unint64_t v62 = v18;
              }
              unsigned int v63 = BLEND8_21385[v31];
              unsigned int v57 = v57 - ((v63 & v57) >> v31) + ((v63 & v61) >> v31);
              int v59 = v59 - ((v63 & v59) >> v31) + ((((*v62 << 24) | (v62[1] << 16) | (v62[2] << 8)) & v63) >> v31);
            }
            unsigned int v57 = v57
                - ((BLEND8_21385[*v51 & 0xF] & v57) >> (*v51 & 0xF))
                + ((BLEND8_21385[*v51 & 0xF] & v59) >> (*v51 & 0xF));
          }
          else if (v31)
          {
            uint64_t v64 = &v55[v30];
            if (v19 < &v55[v30]) {
              uint64_t v64 = v19;
            }
            if (v18 > v64) {
              uint64_t v64 = v18;
            }
            unsigned int v57 = v57
                - ((BLEND8_21385[v31] & v57) >> v31)
                + ((((*v64 << 24) | (v64[1] << 16) | (v64[2] << 8)) & BLEND8_21385[v31]) >> v31);
          }
          v65.i32[0] = _blt_float[HIBYTE(v57)];
          if (v9 >= 1.0)
          {
            v67.i32[1] = HIDWORD(_D3);
            v67.i32[0] = _blt_float[BYTE1(v57)];
            v65.i32[1] = _blt_float[BYTE2(v57)];
            *(int8x8_t *)uint64_t v11 = vrev32_s8((int8x8_t)v65);
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v67);
          }
          else
          {
            v65.i32[1] = _blt_float[BYTE2(v57)];
            *(float32x2_t *)v66.f32 = vmul_n_f32(v65, v9);
            if (v9 > 0.0)
            {
              v66.i64[1] = __PAIR64__(LODWORD(v9), v9 * *(float *)&_blt_float[BYTE1(v57)]);
              *(int8x16_t *)uint64_t v11 = vrev32q_s8((int8x16_t)vmlaq_f32(v66, v23, (float32x4_t)vrev32q_s8(*(int8x16_t *)v11)));
            }
          }
          v51 += 2;
          v11 += 16;
          --v52;
        }
        while (v52);
      }
      v11 += 16 * v12;
      v17 += v16;
      --a6;
    }
    while (a6);
  }
  else
  {
    float v68 = (uint64_t *)(v14 + 16 * a3);
    *(float *)&a9 = 1.0 - v9;
    float32x4_t v69 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a9, 0);
    __asm { FMOV            V3.2S, #1.0 }
    do
    {
      uint64_t v71 = &v18[(v17 >> v15) * v13];
      if (v10 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v72 = v68;
          uint64_t v73 = a5;
          do
          {
            uint64_t v74 = *v72;
            v72 += 2;
            float v75 = &v71[v74];
            if (v19 < &v71[v74]) {
              float v75 = v19;
            }
            if (v18 > v75) {
              float v75 = v18;
            }
            uint64_t v76 = v75[1];
            uint64_t v77 = v75[2];
            float v78 = *(float *)&_blt_float[*v75];
            if (v9 >= 1.0)
            {
              float v79 = *(float *)&_blt_float[v76];
              v80.i32[1] = HIDWORD(_D3);
              v80.i32[0] = _blt_float[v77];
            }
            else
            {
              float v78 = v9 * v78;
              float v79 = v9 * *(float *)&_blt_float[v76];
              *(float *)v80.unint64_t i32 = v9 * *(float *)&_blt_float[v77];
              *(float *)&v80.i32[1] = v9;
            }
            *(_DWORD *)uint64_t v11 = bswap32(LODWORD(v78));
            *(_DWORD *)(v11 + 4) = bswap32(LODWORD(v79));
            *(int8x8_t *)(v11 + 8) = vrev32_s8(v80);
            v11 += 16;
            --v73;
          }
          while (v73);
        }
      }
      else
      {
        uint64_t v81 = v68;
        uint64_t v82 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v83 = *v81;
            v81 += 2;
            unsigned int v84 = &v71[v83];
            if (v19 < &v71[v83]) {
              unsigned int v84 = v19;
            }
            if (v18 > v84) {
              unsigned int v84 = v18;
            }
            uint64_t v85 = v84[2];
            v86.i32[0] = _blt_float[*v84];
            if (v9 >= 1.0)
            {
              v88.i32[1] = HIDWORD(_D3);
              v88.i32[0] = _blt_float[v85];
              v86.i32[1] = _blt_float[v84[1]];
              *(int8x8_t *)uint64_t v11 = vrev32_s8((int8x8_t)v86);
              *(int8x8_t *)(v11 + 8) = vrev32_s8(v88);
            }
            else
            {
              v86.i32[1] = _blt_float[v84[1]];
              *(float32x2_t *)v87.f32 = vmul_n_f32(v86, v9);
              if (v9 > 0.0)
              {
                v87.i64[1] = __PAIR64__(LODWORD(v9), v9 * *(float *)&_blt_float[v85]);
                *(int8x16_t *)uint64_t v11 = vrev32q_s8((int8x16_t)vmlaq_f32(v87, v69, (float32x4_t)vrev32q_s8(*(int8x16_t *)v11)));
              }
            }
            v11 += 16;
            --v82;
          }
          while (v82);
        }
      }
      v11 += 16 * v12;
      v17 += v16;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t RGBAF_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6, double a7, double a8, int32x4_t _Q2, double a10, int8x16_t a11)
{
  float v11 = *((float *)a2 + 2);
  float v12 = *(float *)a2;
  uint64_t v13 = (int8x16_t *)*((void *)a2 + 2);
  uint64_t v14 = *((void *)a2 + 3) - a5;
  uint64_t v16 = *((void *)a2 + 15);
  uint64_t v15 = *((void *)a2 + 16);
  uint64_t v17 = *((void *)a2 + 7);
  uint64_t v18 = *((void *)a2 + 9);
  uint64_t v19 = *((void *)a2 + 5) + v18 * a4;
  uint64_t v20 = *(unsigned __int8 **)(a1 + 32);
  unint64_t v21 = &v20[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  if (*(void *)(a1 + 176))
  {
    uint64_t v22 = *((void *)a2 + 11);
    uint64_t result = *((void *)a2 + 13);
    float v24 = fminf(v11, 1.0);
    uint64_t v92 = v15 + 16 * a3 + 8;
    __asm { FMOV            V2.2S, #1.0 }
    while (1)
    {
      if (((result - v19) | (v19 - v22)) < 0)
      {
        int v31 = 0;
        uint64_t v30 = 0;
      }
      else
      {
        unint64_t v29 = ((v19 & (unint64_t)~(-1 << v17)) >> (v17 - 4)) & 0xF;
        uint64_t v30 = v29 - 7 >= 9 ? -v16 : v16;
        int v31 = weights_21383[v29] & 0xF;
      }
      uint64_t v32 = &v20[(v19 >> v17) * v16];
      if (LODWORD(v12) != 1) {
        break;
      }
      if (a5 >= 1)
      {
        uint64_t v33 = (uint64_t *)v92;
        uint64_t v34 = a5;
        while (1)
        {
          uint64_t v35 = *(v33 - 1);
          uint64_t v36 = *v33;
          uint64_t v37 = &v32[v35];
          if (v21 >= &v32[v35]) {
            unsigned int v38 = &v32[v35];
          }
          else {
            unsigned int v38 = v21;
          }
          if (v20 > v38) {
            unsigned int v38 = v20;
          }
          unsigned int v39 = *v38;
          char v40 = v36 & 0xF;
          if ((v36 & 0xF) != 0) {
            break;
          }
          if (v31)
          {
            double v51 = &v37[v30];
            if (v21 < &v37[v30]) {
              double v51 = v21;
            }
            if (v20 > v51) {
              double v51 = v20;
            }
            int v52 = BLEND8_21385[v31];
            unsigned int v49 = v39 - ((v52 & v39) >> v31);
            unsigned int v50 = (v52 & *v51) >> v31;
            goto LABEL_40;
          }
LABEL_41:
          v33 += 2;
          int32x4_t v53 = _Q2;
          v53.i32[0] = _blt_float[v39];
          *(int8x8_t *)v53.unint64_t i8 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v53.i8, v24));
          a11 = (int8x16_t)vzip1q_s32(v53, v53);
          a11.i32[2] = v53.i32[0];
          *v13++ = a11;
          if (!--v34) {
            goto LABEL_80;
          }
        }
        int v41 = &v37[v36 >> 4];
        if (v21 < v41) {
          int v41 = v21;
        }
        if (v20 > v41) {
          int v41 = v20;
        }
        unsigned int v42 = *v41;
        if (v31)
        {
          uint64_t v43 = &v37[v30];
          if (v21 >= v43) {
            int v44 = v43;
          }
          else {
            int v44 = v21;
          }
          if (v20 > v44) {
            int v44 = v20;
          }
          unsigned int v45 = *v44;
          unsigned int v46 = &v43[v36 >> 4];
          if (v21 < v46) {
            unsigned int v46 = v21;
          }
          if (v20 > v46) {
            unsigned int v46 = v20;
          }
          int v47 = BLEND8_21385[v31];
          unsigned int v39 = v39 - ((v47 & v39) >> v31) + ((v47 & v45) >> v31);
          unsigned int v42 = v42 - ((v47 & v42) >> v31) + ((v47 & *v46) >> v31);
        }
        int v48 = BLEND8_21385[*v33 & 0xF];
        unsigned int v49 = v39 - ((v48 & v39) >> v40);
        unsigned int v50 = (v48 & v42) >> v40;
LABEL_40:
        LOBYTE(v39) = v49 + v50;
        goto LABEL_41;
      }
LABEL_80:
      v13 += v14;
      v19 += v18;
      if (!--a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_80;
    }
    uint64_t v54 = (uint64_t *)v92;
    uint64_t v55 = a5;
    while (1)
    {
      uint64_t v56 = *(v54 - 1);
      uint64_t v57 = *v54;
      float v58 = &v32[v56];
      if (v21 >= &v32[v56]) {
        int v59 = &v32[v56];
      }
      else {
        int v59 = v21;
      }
      if (v20 > v59) {
        int v59 = v20;
      }
      unsigned int v60 = *v59;
      char v61 = v57 & 0xF;
      if ((v57 & 0xF) != 0)
      {
        unint64_t v62 = &v58[v57 >> 4];
        if (v21 < v62) {
          unint64_t v62 = v21;
        }
        if (v20 > v62) {
          unint64_t v62 = v20;
        }
        unsigned int v63 = *v62;
        if (v31)
        {
          uint64_t v64 = &v58[v30];
          if (v21 >= v64) {
            float32x2_t v65 = v64;
          }
          else {
            float32x2_t v65 = v21;
          }
          if (v20 > v65) {
            float32x2_t v65 = v20;
          }
          unsigned int v66 = *v65;
          int8x8_t v67 = &v64[v57 >> 4];
          if (v21 < v67) {
            int8x8_t v67 = v21;
          }
          if (v20 > v67) {
            int8x8_t v67 = v20;
          }
          int v68 = BLEND8_21385[v31];
          unsigned int v60 = v60 - ((v68 & v60) >> v31) + ((v68 & v66) >> v31);
          unsigned int v63 = v63 - ((v68 & v63) >> v31) + ((v68 & *v67) >> v31);
        }
        int v69 = BLEND8_21385[*v54 & 0xF];
        unsigned int v70 = v60 - ((v69 & v60) >> v61);
        unsigned int v71 = (v69 & v63) >> v61;
      }
      else
      {
        if (!v31) {
          goto LABEL_74;
        }
        uint64_t v72 = &v58[v30];
        if (v21 < &v58[v30]) {
          uint64_t v72 = v21;
        }
        if (v20 > v72) {
          uint64_t v72 = v20;
        }
        int v73 = BLEND8_21385[v31];
        unsigned int v70 = v60 - ((v73 & v60) >> v31);
        unsigned int v71 = (v73 & *v72) >> v31;
      }
      LOBYTE(v60) = v70 + v71;
LABEL_74:
      int32x4_t v74 = _Q2;
      v74.i32[0] = _blt_float[v60];
      *(float32x2_t *)v74.unint64_t i8 = vmul_n_f32(*(float32x2_t *)v74.i8, v24);
      if (*(float *)&v74.i32[1] >= 1.0)
      {
        *(int8x8_t *)a11.unint64_t i8 = vrev32_s8(*(int8x8_t *)v74.i8);
        int32x4_t v76 = vzip1q_s32((int32x4_t)a11, (int32x4_t)a11);
        v76.i32[2] = a11.i32[0];
        goto LABEL_78;
      }
      if (*(float *)&v74.i32[1] > 0.0)
      {
        float32x4_t v75 = (float32x4_t)vzip1q_s32(v74, v74);
        v75.i32[2] = v74.i32[0];
        a11 = vrev32q_s8(*v13);
        int32x4_t v76 = (int32x4_t)vrev32q_s8((int8x16_t)vmlaq_n_f32(v75, (float32x4_t)a11, 1.0 - *(float *)&v74.i32[1]));
LABEL_78:
        int8x16_t *v13 = (int8x16_t)v76;
      }
      v54 += 2;
      ++v13;
      if (!--v55) {
        goto LABEL_80;
      }
    }
  }
  uint64_t v77 = (uint64_t *)(v15 + 16 * a3);
  uint64_t result = a5;
  float v78 = fminf(v11, 1.0);
  __asm { FMOV            V2.2S, #1.0 }
  do
  {
    float v79 = &v20[(v19 >> v17) * v16];
    if (LODWORD(v12) != 1)
    {
      uint64_t v85 = v77;
      uint64_t v86 = a5;
      if (a5 < 1) {
        goto LABEL_103;
      }
      while (1)
      {
        uint64_t v87 = *v85;
        v85 += 2;
        int8x8_t v88 = &v79[v87];
        if (v21 < &v79[v87]) {
          int8x8_t v88 = v21;
        }
        if (v20 > v88) {
          int8x8_t v88 = v20;
        }
        int32x4_t v89 = _Q2;
        v89.i32[0] = _blt_float[*v88];
        *(float32x2_t *)v89.unint64_t i8 = vmul_n_f32(*(float32x2_t *)v89.i8, v78);
        if (*(float *)&v89.i32[1] >= 1.0) {
          break;
        }
        if (*(float *)&v89.i32[1] > 0.0)
        {
          float32x4_t v90 = (float32x4_t)vzip1q_s32(v89, v89);
          v90.i32[2] = v89.i32[0];
          a11 = vrev32q_s8(*v13);
          int32x4_t v91 = (int32x4_t)vrev32q_s8((int8x16_t)vmlaq_n_f32(v90, (float32x4_t)a11, 1.0 - *(float *)&v89.i32[1]));
LABEL_101:
          int8x16_t *v13 = (int8x16_t)v91;
        }
        ++v13;
        if (!--v86) {
          goto LABEL_103;
        }
      }
      *(int8x8_t *)a11.unint64_t i8 = vrev32_s8(*(int8x8_t *)v89.i8);
      int32x4_t v91 = vzip1q_s32((int32x4_t)a11, (int32x4_t)a11);
      v91.i32[2] = a11.i32[0];
      goto LABEL_101;
    }
    if (a5 >= 1)
    {
      int8x8_t v80 = v77;
      uint64_t v81 = a5;
      do
      {
        uint64_t v82 = *v80;
        v80 += 2;
        uint64_t v83 = &v79[v82];
        if (v21 < &v79[v82]) {
          uint64_t v83 = v21;
        }
        if (v20 > v83) {
          uint64_t v83 = v20;
        }
        int32x4_t v84 = _Q2;
        v84.i32[0] = _blt_float[*v83];
        *(int8x8_t *)v84.unint64_t i8 = vrev32_s8((int8x8_t)vmul_n_f32(*(float32x2_t *)v84.i8, v78));
        a11 = (int8x16_t)vzip1q_s32(v84, v84);
        a11.i32[2] = v84.i32[0];
        *v13++ = a11;
        --v81;
      }
      while (v81);
    }
LABEL_103:
    v13 += v14;
    v19 += v18;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t RGBAF_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  int v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  signed int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x3000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    float v12 = RGBAf_shade_radial_RGB;
  }
  else if (*(void *)(v5 + 24))
  {
    float v12 = RGBAf_shade_conic_RGB;
  }
  else if (v16 < 2)
  {
    float v12 = RGBAf_shade_axial_RGB;
  }
  else
  {
    float v12 = RGBAf_shade_custom_RGB;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  RGBAF_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

char *CGSConvertARGB8888toMask(char *result, int a2, unsigned char *a3, int a4, int a5, int a6)
{
  if (a6 >= 1)
  {
    do
    {
      uint64_t v6 = a3;
      int v7 = a5;
      BOOL v8 = result;
      if (a5 >= 4)
      {
        do
        {
          unsigned int v9 = v7;
          char v10 = *v8;
          char v11 = v8[4];
          char v12 = v8[8];
          char v13 = v8[12];
          v8 += 16;
          v7 -= 4;
          *uint64_t v6 = v10;
          v6[1] = v11;
          v6[2] = v12;
          v6[3] = v13;
          v6 += 4;
        }
        while (v9 > 7);
      }
      if (v7 >= 1)
      {
        unsigned int v14 = v7 + 1;
        do
        {
          char v15 = *v8;
          v8 += 4;
          *v6++ = v15;
          --v14;
        }
        while (v14 > 1);
      }
      result += a2;
      a3 += a4;
    }
    while (a6-- > 1);
  }
  return result;
}

unsigned char *CGSConvertRGBA8888toMask(unsigned char *result, int a2, unsigned char *a3, int a4, int a5, int a6)
{
  if (a6 >= 1)
  {
    do
    {
      uint64_t v6 = a3;
      int v7 = a5;
      BOOL v8 = result;
      if (a5 >= 4)
      {
        do
        {
          char v9 = v8[3];
          char v10 = v8[7];
          char v11 = v8[11];
          char v12 = v8[15];
          v8 += 16;
          *uint64_t v6 = v9;
          v6[1] = v10;
          v6[2] = v11;
          v6[3] = v12;
          v6 += 4;
          BOOL v13 = v7 > 7;
          v7 -= 4;
        }
        while (v13);
      }
      if (v7 >= 1)
      {
        unsigned int v14 = v8 + 3;
        unsigned int v15 = v7 + 1;
        do
        {
          char v16 = *v14;
          v14 += 4;
          *v6++ = v16;
          --v15;
        }
        while (v15 > 1);
      }
      result += a2;
      a3 += a4;
      BOOL v13 = a6-- <= 1;
    }
    while (!v13);
  }
  return result;
}

uint16x4_t *CGSConvertBitsToMask(uint16x4_t *result, int a2, unsigned char *a3, int a4, int a5, int a6, int a7)
{
  if (a7 > 15)
  {
    if (a7 == 16)
    {
      v20.i64[0] = 0x1000000010;
      v20.i64[1] = 0x1000000010;
      do
      {
        if (a5 >= 4)
        {
          int v21 = a5 >> 2;
          do
          {
            uint16x4_t v22 = *result++;
            uint16x4_t v23 = (uint16x4_t)vand_s8((int8x8_t)vshr_n_u16(v22, 2uLL), (int8x8_t)0xF800F800F800F8);
            int16x8_t v24 = (int16x8_t)vmull_u16((uint16x4_t)vmovn_s32((int32x4_t)vaddw_u16(v20, v23)), v23);
            *(uint16x4_t *)v24.unint64_t i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v24), 8uLL);
            *(_DWORD *)a3 = vmovn_s16(v24).u32[0];
            a3 += 4;
            --v21;
          }
          while (v21);
        }
        if ((a5 & 3) != 0)
        {
          int v25 = a5 & 3;
          do
          {
            unsigned int v26 = result->u16[0];
            uint64_t result = (uint16x4_t *)((char *)result + 2);
            *a3++ = (unsigned __int16)((((v26 >> 2) & 0xF8) + 16) * ((v26 >> 2) & 0xF8)) >> 8;
            --v25;
          }
          while (v25);
        }
        uint64_t result = (uint16x4_t *)((char *)result + a2 - (uint64_t)(2 * a5));
        a3 += a4 - (uint64_t)a5;
        --a6;
      }
      while (a6);
    }
    else if (a7 == 32)
    {
      do
      {
        if (a5 >= 4)
        {
          int v10 = a5 >> 2;
          do
          {
            int32x4_t v11 = *(int32x4_t *)result->i8;
            result += 2;
            v12.i64[1] = v11.i64[1];
            *(int16x4_t *)v12.unint64_t i8 = vmovn_s32(v11);
            *(_DWORD *)a3 = vmovn_s16(v12).u32[0];
            a3 += 4;
            --v10;
          }
          while (v10);
        }
        if ((a5 & 3) != 0)
        {
          int v13 = a5 & 3;
          do
          {
            __int32 v14 = result->i32[0];
            uint64_t result = (uint16x4_t *)((char *)result + 4);
            *a3++ = v14;
            --v13;
          }
          while (v13);
        }
        uint64_t result = (uint16x4_t *)((char *)result + a2 - (uint64_t)(4 * a5));
        a3 += a4 - (uint64_t)a5;
        --a6;
      }
      while (a6);
    }
  }
  else if (a7 == 1)
  {
    uint64_t v15 = a5 + 3;
    do
    {
      if (v15 >= 8)
      {
        int v16 = (int)v15 >> 3;
        do
        {
          unsigned int v17 = result->u8[0];
          uint64_t result = (uint16x4_t *)((char *)result + 1);
          int v18 = _LUT[v17 & 0xF];
          *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT + (((unint64_t)v17 >> 2) & 0x3C));
          *((_DWORD *)a3 + 1) = v18;
          a3 += 8;
          --v16;
        }
        while (v16);
      }
      if ((v15 & 4) != 0)
      {
        unsigned int v19 = result->u8[0];
        uint64_t result = (uint16x4_t *)((char *)result + 1);
        *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT + (((unint64_t)v19 >> 2) & 0x3C));
        a3 += 4;
      }
      uint64_t result = (uint16x4_t *)((char *)result + a2 - (uint64_t)((int)((v15 & 0xFFFFFFFC) + 7) >> 3));
      a3 += a4 - (v15 & 0xFFFFFFFFFFFFFFFCLL);
      --a6;
    }
    while (a6);
  }
  else if (a7 == 4)
  {
    do
    {
      if (a5 >= 2)
      {
        int v7 = a5 >> 1;
        do
        {
          unsigned int v8 = result->u8[0];
          uint64_t result = (uint16x4_t *)((char *)result + 1);
          a3[1] = v8 & 0xF | (16 * v8);
          *a3 = v8 & 0xF0 | (v8 >> 4);
          a3 += 2;
          --v7;
        }
        while (v7);
      }
      if (a5)
      {
        unsigned int v9 = result->u8[0];
        uint64_t result = (uint16x4_t *)((char *)result + 1);
        *a3++ = v9 & 0xF0 | (v9 >> 4);
      }
      uint64_t result = (uint16x4_t *)((char *)result + a2 - (uint64_t)((a5 + 1) >> 1));
      a3 += a4 - (uint64_t)a5;
      --a6;
    }
    while (a6);
  }
  return result;
}

char *cg_function_type3_create(CGPDFDictionary *a1)
{
  uint64_t result = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x10800402B99548FuLL);
  if (!result) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = (const CGFloat *)(result + 8);
  if (!CGPDFDictionaryGetNumbers(a1, "Domain", (uint64_t)(result + 8), (CGPDFArray *)2))
  {
LABEL_46:
    goto LABEL_47;
  }
  CGPDFArrayRef array = 0;
  CGPDFObjectRef value = 0;
  *(void *)uint64_t v3 = 1;
  if (!CGPDFDictionaryGetArray(a1, "Functions", &array))
  {
    goto LABEL_47;
  }
  if (!array)
  {
    *(void *)(v3 + 40) = 0;
    goto LABEL_20;
  }
  uint64_t v5 = *((void *)array + 2);
  *(void *)(v3 + 40) = v5;
  if (!v5)
  {
LABEL_20:
    goto LABEL_47;
  }
  uint64_t v6 = (uint64_t *)malloc_type_calloc(1uLL, 8 * v5, 0x2004093837F09uLL);
  *(void *)(v3 + 48) = v6;
  if (!v6)
  {
LABEL_47:
    type3_release(v3);
    return 0;
  }
  unint64_t v7 = *(void *)(v3 + 40);
  if (v7)
  {
    size_t v8 = 0;
    while (CGPDFArrayGetObject(array, v8, &value))
    {
      if (value && *((_DWORD *)value + 2) == 8 && *((CGPDFDictionary **)value + 4) == a1) {
        Functiounint64_t n = 0;
      }
      else {
        Functiounint64_t n = CGPDFFunctionCreateFunction();
      }
      *(void *)(*(void *)(v3 + 48) + 8 * v8) = Function;
      uint64_t v6 = *(uint64_t **)(v3 + 48);
      if (!v6[v8]) {
        goto LABEL_47;
      }
      ++v8;
      unint64_t v7 = *(void *)(v3 + 40);
      if (v8 >= v7)
      {
        if (v7 >= 2 && *(double *)(v3 + 8) >= *(double *)(v3 + 16)) {
          goto LABEL_46;
        }
        goto LABEL_23;
      }
    }
    goto LABEL_20;
  }
LABEL_23:
  uint64_t v10 = *v6;
  if (*v6) {
    uint64_t v10 = *(void *)(v10 + 48);
  }
  *(void *)(v3 + 24) = v10;
  if (v7 >= 2)
  {
    int32x4_t v11 = v6 + 1;
    unint64_t v12 = v7 - 1;
    do
    {
      uint64_t v13 = *v11;
      if (*v11) {
        uint64_t v13 = *(void *)(v13 + 48);
      }
      if (v10 != v13) {
        goto LABEL_20;
      }
      ++v11;
    }
    while (--v12);
  }
  if (v7)
  {
    while (*v6 && *(void *)(*v6 + 32) == 1)
    {
      ++v6;
      if (!--v7) {
        goto LABEL_35;
      }
    }
    goto LABEL_20;
  }
LABEL_35:
  __int32 v14 = malloc_type_malloc(16 * v10, 0x100004000313F17uLL);
  *(void *)(v3 + 32) = v14;
  if (!v14) {
    goto LABEL_47;
  }
  if (!CGPDFDictionaryGetNumbers(a1, "Range", (uint64_t)v14, (CGPDFArray *)(2 * *(void *)(v3 + 24))))
  {
    free(*(void **)(v3 + 32));
    *(void *)(v3 + 32) = 0;
  }
  uint64_t v15 = malloc_type_malloc(8 * *(void *)(v3 + 40) - 8, 0x100004000313F17uLL);
  *(void *)(v3 + 56) = v15;
  if (!v15) {
    goto LABEL_47;
  }
  if (!CGPDFDictionaryGetNumbers(a1, "Bounds", (uint64_t)v15, (CGPDFArray *)(*(void *)(v3 + 40) - 1)))
  {
    goto LABEL_47;
  }
  unint64_t v16 = *(void *)(v3 + 40);
  if (v16 >= 2)
  {
    unsigned int v17 = *(double **)(v3 + 56);
    double v18 = *v17;
    if (*(double *)(v3 + 8) > *v17) {
      goto LABEL_51;
    }
    unsigned int v19 = v17 + 1;
    unint64_t v20 = v16 - 2;
    while (v20)
    {
      double v21 = *v19++;
      --v20;
      BOOL v22 = v18 <= v21;
      double v18 = v21;
      if (!v22) {
        goto LABEL_51;
      }
    }
    if (v17[v16 - 2] > *(double *)(v3 + 16))
    {
LABEL_51:
      goto LABEL_47;
    }
  }
  uint16x4_t v23 = malloc_type_malloc(16 * v16, 0x100004000313F17uLL);
  *(void *)(v3 + 64) = v23;
  if (!v23) {
    goto LABEL_47;
  }
  if (!CGPDFDictionaryGetNumbers(a1, "Encode", (uint64_t)v23, (CGPDFArray *)(2 * *(void *)(v3 + 40))))
  {
    goto LABEL_47;
  }
  uint64_t result = (char *)CGFunctionCreate((void *)v3, *(void *)v3, v4, *(void *)(v3 + 24), *(const CGFloat **)(v3 + 32), &type3_callbacks);
  if (!result)
  {
    pdf_error("unable to create Type 3 function.");
    goto LABEL_47;
  }
  return result;
}

void type3_release(uint64_t a1)
{
  if (a1)
  {
    free(*(void **)(a1 + 32));
    free(*(void **)(a1 + 56));
    free(*(void **)(a1 + 64));
    uint64_t v2 = *(void **)(a1 + 48);
    if (v2)
    {
      unint64_t v3 = *(void *)(a1 + 40);
      if (v3)
      {
        for (unint64_t i = 0; i < v3; ++i)
        {
          uint64_t v5 = *(const void **)(*(void *)(a1 + 48) + 8 * i);
          if (v5)
          {
            CFRelease(v5);
            unint64_t v3 = *(void *)(a1 + 40);
          }
        }
        uint64_t v2 = *(void **)(a1 + 48);
      }
      free(v2);
    }
    free((void *)a1);
  }
}

uint64_t type3_evaluate(uint64_t result, double *a2, double *a3)
{
  if (result)
  {
    double v3 = *a2;
    uint64_t v4 = *(void *)(result + 40);
    if (v4 == 1)
    {
      double v19 = **(double **)(result + 64)
          + (v3 - *(double *)(result + 8))
          * (*(double *)(*(void *)(result + 64) + 8) - **(double **)(result + 64))
          / (*(double *)(result + 16) - *(double *)(result + 8));
      uint64_t v5 = *(uint64_t **)(result + 48);
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v7 = *(double **)(result + 56);
      while (1)
      {
        double v8 = v7[v6];
        if (v3 < v8) {
          break;
        }
        if (v4 - 1 == ++v6)
        {
          double v9 = v7[v4 - 2];
          double v10 = *(double *)(result + 16);
          uint64_t v11 = *(void *)(result + 64);
          if (v9 == v10) {
            double v19 = *(double *)(v11 + 16 * v4 - 16);
          }
          else {
            double v19 = *(double *)(v11 + 16 * v4 - 16)
          }
                + (v3 - v9) * (*(double *)(v11 + 16 * v4 - 8) - *(double *)(v11 + 16 * v4 - 16)) / (v10 - v9);
          uint64_t v6 = v4 - 1;
          goto LABEL_15;
        }
      }
      unint64_t v12 = *(double **)(result + 64);
      if (v6)
      {
        double v13 = v7[v6 - 1];
        __int32 v14 = &v12[2 * v6];
        double v15 = *v14;
        double v16 = (v3 - v13) * (v14[1] - *v14);
        double v17 = v8 - v13;
      }
      else
      {
        double v18 = *(double *)(result + 8);
        double v15 = *v12;
        double v16 = (v3 - v18) * (v12[1] - *v12);
        double v17 = *v7 - v18;
      }
      double v19 = v15 + v16 / v17;
LABEL_15:
      uint64_t v5 = (uint64_t *)(*(void *)(result + 48) + 8 * v6);
    }
    return CGFunctionEvaluate(*v5, (char *)&v19, a3);
  }
  return result;
}

double *CGContainerCreateWithRect(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (_block_invoke_once_6961 != -1) {
    dispatch_once(&_block_invoke_once_6961, &__block_literal_global_5_6962);
  }
  uint64_t result = (double *)CGTypeCreateInstance(CGContainerGetTypeID_container_type_id, 32, a7, a8, a9, a10, a11, a12);
  result[2] = a1;
  result[3] = a2;
  result[4] = a3;
  result[5] = a4;
  return result;
}

uint64_t __CGContainerGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGContainerGetTypeID_class);
  CGContainerGetTypeID_container_type_id = result;
  return result;
}

uint64_t container_hash()
{
  return 0;
}

BOOL container_equal(uint64_t a1, uint64_t a2)
{
  return CGRectEqualToRect(*(CGRect *)(a1 + 16), *(CGRect *)(a2 + 16));
}

uint64_t CGContainerGetTypeID()
{
  if (_block_invoke_once_6961 != -1) {
    dispatch_once(&_block_invoke_once_6961, &__block_literal_global_5_6962);
  }
  return CGContainerGetTypeID_container_type_id;
}

BOOL CGContainerGetRect(uint64_t a1, _OWORD *a2)
{
  if (a1 && a2)
  {
    long long v2 = *(_OWORD *)(a1 + 32);
    *a2 = *(_OWORD *)(a1 + 16);
    a2[1] = v2;
  }
  return a1 != 0;
}

void FontDescriptor::FontDescriptor(FontDescriptor *this, const PDFFont *a2, int a3)
{
  *(void *)this = a2;
  *((void *)this + 1) = PDFXRefTableAddObject(*(void **)(**((void **)a2 + 1) + 464));
  if (a3) {
    int v6 = 32;
  }
  else {
    int v6 = 4;
  }
  *((_DWORD *)this + 4) = v6;
  font_info = get_font_info(*((void **)a2 + 2));
  if (font_info && font_info[48]) {
    *((_DWORD *)this + 4) |= 1u;
  }
  double v8 = get_font_info(*((void **)a2 + 2));
  if (v8)
  {
    if (v8[49]) {
      *((_DWORD *)this + 4) |= 0x40u;
    }
  }
}

unsigned char *FontDescriptor::emit_definition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = **(void **)(*(void *)a1 + 8);
  PDFDocumentBeginObject(v11, *(void *)(a1 + 8), a3, a4, a5, a6, a7, a8);
  PDFDocumentPrintf(v11, (uint64_t)"<<", v12, v13, v14, v15, v16, v17, v83);
  PDFDocumentPrintf(v11, (uint64_t)"/Type /FontDescriptor", v18, v19, v20, v21, v22, v23, v84);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v30 = a2;
  }
  else {
    uint64_t v30 = *(void *)a2;
  }
  PDFDocumentPrintf(v11, (uint64_t)"/FontName /%N", v24, v25, v26, v27, v28, v29, v30);
  PDFDocumentPrintf(v11, (uint64_t)"/Flags %d", v31, v32, v33, v34, v35, v36, *(unsigned int *)(a1 + 16));
  if (CGFontGetDescriptor(*(void **)(*(void *)a1 + 16), (uint64_t)v86))
  {
    PDFDocumentPrintf(v11, (uint64_t)"/FontBBox %r", v37, v38, v39, v40, v41, v42, (uint64_t)v86);
    PDFDocumentPrintf(v11, (uint64_t)"/ItalicAngle %f", v44, v45, v46, v47, v48, v49, v90);
    PDFDocumentPrintf(v11, (uint64_t)"/Ascent %f", v50, v51, v52, v53, v54, v55, v87);
    PDFDocumentPrintf(v11, (uint64_t)"/Descent %f", v56, v57, v58, v59, v60, v61, v88);
    PDFDocumentPrintf(v11, (uint64_t)"/CapHeight %f", v62, v63, v64, v65, v66, v67, v89);
    PDFDocumentPrintf(v11, (uint64_t)"/StemV %f", v68, v69, v70, v71, v72, v73, v91);
    if (*(double *)&v96 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/Leading %f", v37, v38, v39, v40, v41, v42, v96);
    }
    if (*(double *)&v97 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/XHeight %f", v37, v38, v39, v40, v41, v42, v97);
    }
    if (*(double *)&v92 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/StemH %f", v37, v38, v39, v40, v41, v42, v92);
    }
    if (*(double *)&v93 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/AvgWidth %f", v37, v38, v39, v40, v41, v42, v93);
    }
    if (*(double *)&v94 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/MaxWidth %f", v37, v38, v39, v40, v41, v42, v94);
    }
    v43.n128_u64[0] = v95;
    if (*(double *)&v95 != 0.0) {
      PDFDocumentPrintf(v11, (uint64_t)"/MissingWidth %f", v37, v38, v39, v40, v41, v42, v95);
    }
  }
  if (a3)
  {
    unsigned int v74 = (*(uint64_t (**)(__n128))(**(void **)a1 + 16))(v43) - 1;
    if (v74 <= 4) {
      PDFDocumentPrintReference(v11, (uint64_t)off_1E52B42D0[v74], a3, v38, v39, v40, v41, v42);
    }
  }
  PDFDocumentPrintf(v11, (uint64_t)">>", v37, v38, v39, v40, v41, v42, v85);
  return PDFDocumentEndObject(v11, v75, v76, v77, v78, v79, v80, v81);
}

void *CGPDFDecryptorCreate(void *result, int a2, const void *a3, size_t a4)
{
  if (result)
  {
    unint64_t v7 = result;
    if ((a2 & 0xFFFFFFFE) == 2) {
      size_t v8 = 4144;
    }
    else {
      size_t v8 = 48;
    }
    double v9 = malloc_type_calloc(1uLL, v8, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (!v9) {
      return 0;
    }
    CFRetain(v7);
    void *v9 = v7;
    if (a3) {
      int v10 = a2;
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = decryptor_identity_refill;
    if ((v10 - 2) < 2)
    {
      uint64_t v13 = pdf_aes_create((uint64_t)a3, a4);
      v9[2] = v13;
      if (!v13)
      {
LABEL_18:
        decryptor_finalize((uint64_t)v9);
        return 0;
      }
      *((unsigned char *)v9 + 32) = 0;
      v9[5] = 0;
      uint64_t v11 = decryptor_aes_refill;
    }
    else if (v10)
    {
      if (v10 != 1) {
        goto LABEL_18;
      }
      RC4 = CGCryptorCreateRC4(a3, a4);
      v9[3] = RC4;
      uint64_t v11 = decryptor_rc4_refill;
      if (!RC4) {
        goto LABEL_18;
      }
    }
    uint64_t v14 = v11;
    *((_DWORD *)v9 + 2) = v10;
    uint64_t result = CGPDFSourceCreateInternal(0x1000uLL);
    if (result)
    {
      *((unsigned char *)result + 209) = 1;
      result[6] = decryptor_rewind;
      result[7] = v14;
      *((_OWORD *)result + 4) = xmmword_1ED09BB28;
      result[10] = v9;
      return result;
    }
    goto LABEL_18;
  }
  return result;
}

void decryptor_finalize(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 8);
    if ((v2 - 2) >= 2)
    {
      if (v2 == 1) {
        CGCryptorRelease(*(void *)(a1 + 24));
      }
    }
    else
    {
      pdf_aes_free(*(void **)(a1 + 16));
    }
    if (*(void *)a1) {
      CFRelease(*(CFTypeRef *)a1);
    }
    free((void *)a1);
  }
}

size_t decryptor_rc4_refill(uint64_t *a1, void *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10 = CGPDFSourceRead(*a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10) {
    CGCryptorProcessBytes(a1[3], a2, v10, a2, v10, 0);
  }
  return v10;
}

uint64_t decryptor_identity_refill(uint64_t *a1, uint64_t a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGPDFSourceRead(*a1, a2, a3, a4, a5, a6, a7, a8);
}

size_t decryptor_aes_refill(uint64_t a1, char *dataOut, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a3 <= 0xFFF) {
    _CGHandleAssert("decryptor_aes_refill", 160, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Security/CGPDFDecryptor.c", "buffer_size >= AES_BUFFER_SIZE", "buffer size (%lu) too big", a6, a7, a8, a3);
  }
  if (!*(unsigned char *)(a1 + 32))
  {
    size_t v9 = *(void *)(a1 + 40);
    if (!v9)
    {
      if ((unint64_t)CGPDFSourceRead(*(void *)a1, (uint64_t)&__dst, 0x10uLL, a4, a5, a6, a7, a8) < 0x10)
      {
        size_t v9 = 0;
        goto LABEL_13;
      }
      uint64_t v11 = *(void *)(a1 + 16);
      *(_OWORD *)(v11 + 40) = __dst;
      CCCryptorReset(*(CCCryptorRef *)(v11 + 56), (const void *)(v11 + 40));
      size_t v9 = CGPDFSourceRead(*(void *)a1, a1 + 48, 0x1000uLL, v12, v13, v14, v15, v16);
      *(void *)(a1 + 40) = v9;
    }
    pdf_aes_process_buffer(*(void *)(a1 + 16), (const void *)(a1 + 48), dataOut, v9);
    uint64_t v22 = CGPDFSourceRead(*(void *)a1, a1 + 48, 0x1000uLL, v17, v18, v19, v20, v21);
    *(void *)(a1 + 40) = v22;
    if (v22) {
      return v9;
    }
    if (v9)
    {
      size_t v23 = dataOut[v9 - 1];
      BOOL v24 = v9 >= v23;
      size_t v25 = v9 - v23;
      if (v24) {
        size_t v9 = v25;
      }
      else {
        pdf_error("invalid AES padding.");
      }
    }
LABEL_13:
    *(unsigned char *)(a1 + 32) = 1;
    return v9;
  }
  return 0;
}

uint64_t decryptor_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = CGPDFSourceRewind(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
  int v17 = *(_DWORD *)(a1 + 8);
  if ((v17 - 2) >= 2)
  {
    if (v17 == 1)
    {
      uint64_t v18 = *(CCCryptorRef **)(a1 + 24);
      return CGCryptorReset(v18, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  else
  {
    uint64_t result = pdf_aes_reset(*(void **)(a1 + 16));
    *(unsigned char *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t bits_per_component_type(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a1 - 1;
  if ((a1 - 1) >= 5 || ((0x1Bu >> v8) & 1) == 0) {
    _CGHandleAssert("bits_per_component_type", 66, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", a6, a7, a8, vars0);
  }
  return qword_185210480[v8];
}

void upscale_provider_release_info(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 8)) {
    CGDataProviderUnlock(*(void *)a1);
  }
  CGDataProviderRelease(*(CGDataProviderRef *)a1);
  int v2 = *(vImageConverter **)(a1 + 136);
  if (v2) {
    vImageConverter_Release(v2);
  }
  double v3 = *(void **)(a1 + 144);
  if (v3) {
    free(v3);
  }

  free((void *)a1);
}

uint64_t upscale_provider_get_work_buffer_size(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

uint64_t upscale_provider_get_bytes_per_row_count(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t upscale_provider_release_data(uint64_t *a1)
{
  CGDataProviderReleaseBytePtr(*a1);
  uint64_t v2 = *a1;

  return CGDataProviderReleaseData(v2);
}

uint64_t upscale_provider_retain_data(uint64_t *a1)
{
  CGDataProviderRetainBytePtr(*a1);
  uint64_t v2 = *a1;

  return CGDataProviderRetainData(v2);
}

unint64_t upscale_provider_get_bytes_at_position(uint64_t a1, unsigned char *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 8)) {
    _CGHandleAssert("upscale_provider_get_bytes_at_position", 1196, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "info->src_provider_uses_random_access == true", "", a6, a7, a8, vars0);
  }

  return upscale_provider_get_bytes_at_position_inner(a1, a2, a3, a4, 0, a6, a7, a8);
}

unint64_t upscale_provider_get_bytes_at_position_inner(uint64_t a1, unsigned char *a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 0x8000000000000000) != 0) {
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1103, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "pos >= 0", "position %lld", a6, a7, a8, a3);
  }
  unint64_t v10 = *(void *)(a1 + 40);
  if (v10 <= 7) {
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1108, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "dst_pixel_size != 0", "zero pixel size", a6, a7, a8, v177);
  }
  unint64_t v17 = destination_position_to_source_position(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 80), *(void *)(a1 + 96), a3, a7, a8);
  if (v17 >= 0x7FFFFFFF) {
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1121, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_pos >= 0 && src_byte_pos < INT_MAX", "positions %lld", v14, v15, v16, v17);
  }
  uint64_t v18 = *(void *)(a1 + 80);
  vImagePixelCount v19 = 8 * a4 / v10;
  if (!a3) {
    goto LABEL_8;
  }
  unint64_t v20 = *(void *)(a1 + 40);
  if (!*(void *)(a1 + 96))
  {
    unint64_t v20 = 8 * a3 * v18 / v20;
    goto LABEL_10;
  }
  unint64_t v21 = a3 % *(void *)(a1 + 48);
  if (!v21)
  {
LABEL_8:
    unint64_t v22 = 0;
    goto LABEL_11;
  }
  LOBYTE(v20) = 8 * v21 / v20 * v18;
LABEL_10:
  unint64_t v22 = v20 & 7;
LABEL_11:
  unint64_t v23 = (v18 * v19 + 7) >> 3;
  if (v23 > *(void *)(a1 + 152)) {
    _CGHandleAssert("upscale_provider_get_bytes_at_position_inner", 1135, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "bytes_to_read <= info->work_buffer_size", "%s: bytes_to_read %zd > work_buffer_size %zd", v14, v15, v16, (char)"upscale_provider_get_bytes_at_position_inner");
  }
  BOOL v24 = *(void **)a1;
  bzero(*(void **)(a1 + 144), v23);
  uint64_t v29 = *(char **)(a1 + 144);
  if (*(unsigned char *)(a1 + 8)) {
    size_t BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v24, v29, v17, v23, v25, v26, v27, v28);
  }
  else {
    size_t BytesAtPositionInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v24, (uint64_t)v29, v23);
  }
  size_t v34 = BytesAtPositionInternal;
  if (BytesAtPositionInternal != v23) {
    vImagePixelCount v19 = 8 * BytesAtPositionInternal / *(void *)(a1 + 80);
  }
  int v35 = *(_DWORD *)(a1 + 32);
  unint64_t v36 = *(void *)(a1 + 88);
  uint64_t v37 = *(unsigned __int8 **)(a1 + 144);
  if (*(unsigned char *)(a1 + 9))
  {
    unint64_t v38 = *(void *)(a1 + 80);
    int v39 = *(_DWORD *)(a1 + 120);
    int v40 = *(unsigned __int8 *)(a1 + 160);
    if (v35 != 4)
    {
      if (v35 != 2)
      {
        if (v35 != 1) {
          _CGHandleAssert("expand_components_without_scaling", 1070, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
        }
        if (v39) {
          _CGHandleAssert("expand_packed_to_8bit", 923, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        }
        if (v38 / v36 * v36 != v38) {
          _CGHandleAssert("expand_packed_to_8bit", 926, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu bpc %zu bpp %zu", v31, v32, v33, v38 / v36);
        }
        unint64_t v41 = v38 / v36 * v19;
        if (v22)
        {
          LODWORD(v42) = 0;
          unint64_t v43 = 0;
          do
          {
            if (!v42)
            {
              unsigned int v44 = *v37++;
              unint64_t v43 = v44 | (v43 << 8);
              LODWORD(v42) = 8;
            }
            LODWORD(v42) = v42 - 1;
            --v22;
          }
          while (v22);
          if (!v41) {
            goto LABEL_292;
          }
        }
        else
        {
          unint64_t v43 = 0;
          LODWORD(v42) = 0;
          if (!v41) {
            goto LABEL_292;
          }
        }
        for (uint64_t i = 0; i != v41; ++i)
        {
          if (v36 <= 0x18)
          {
            int v65 = 0;
            unint64_t v66 = v42;
            unint64_t v67 = v36;
          }
          else
          {
            if (v42 > 0x17)
            {
              int v63 = v42;
            }
            else
            {
              do
              {
                unsigned int v62 = *v37++;
                unint64_t v43 = v62 | (v43 << 8);
                int v63 = v42 + 8;
                BOOL v64 = v42 >= 0x10;
                LODWORD(v42) = v42 + 8;
              }
              while (!v64);
            }
            unint64_t v66 = (v63 - 24);
            int v65 = ((v43 >> (v63 - 24)) & 0xFFFFFF) << (v36 - 24);
            LODWORD(v42) = v66;
            unint64_t v67 = v36 - 24;
          }
          if (v67 > v66)
          {
            do
            {
              unsigned int v68 = *v37++;
              unint64_t v43 = v68 | (v43 << 8);
              unint64_t v42 = (v42 + 8);
            }
            while (v67 > v42);
          }
          LODWORD(v42) = v42 - v67;
          int v69 = (v43 >> v42) & ~(-1 << v67) | v65;
          if (v40) {
            int v69 = (int)(*(double *)(a1 + 168)
          }
                      + (double)v69
                      * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                       / (double)((2 << (v36 - 1)) - 1))
                      + 0.5);
          a2[i] = v69;
        }
        goto LABEL_292;
      }
      if (v39) {
        _CGHandleAssert("expand_packed_to_16bit_integer", 954, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
      }
      if (v38 / v36 * v36 != v38) {
        _CGHandleAssert("expand_packed_to_16bit_integer", 957, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  sbc %zu  bpp %zu", v31, v32, v33, v38 / v36);
      }
      unint64_t v57 = v38 / v36 * v19;
      if (v22)
      {
        LODWORD(v58) = 0;
        unint64_t v59 = 0;
        do
        {
          if (!v58)
          {
            unsigned int v60 = *v37++;
            unint64_t v59 = v60 | (v59 << 8);
            LODWORD(v58) = 8;
          }
          LODWORD(v58) = v58 - 1;
          --v22;
        }
        while (v22);
        if (!v57) {
          goto LABEL_292;
        }
      }
      else
      {
        unint64_t v59 = 0;
        LODWORD(v58) = 0;
        if (!v57) {
          goto LABEL_292;
        }
      }
      for (uint64_t j = 0; j != v57; ++j)
      {
        if (v36 <= 0x18)
        {
          int v73 = 0;
          unint64_t v74 = v58;
          unint64_t v75 = v36;
        }
        else
        {
          if (v58 > 0x17)
          {
            int v72 = v58;
          }
          else
          {
            do
            {
              unsigned int v71 = *v37++;
              unint64_t v59 = v71 | (v59 << 8);
              int v72 = v58 + 8;
              BOOL v64 = v58 >= 0x10;
              LODWORD(v58) = v58 + 8;
            }
            while (!v64);
          }
          unint64_t v74 = (v72 - 24);
          int v73 = ((v59 >> (v72 - 24)) & 0xFFFFFF) << (v36 - 24);
          LODWORD(v58) = v74;
          unint64_t v75 = v36 - 24;
        }
        if (v75 > v74)
        {
          do
          {
            unsigned int v76 = *v37++;
            unint64_t v59 = v76 | (v59 << 8);
            unint64_t v58 = (v58 + 8);
          }
          while (v75 > v58);
        }
        LODWORD(v58) = v58 - v75;
        int v77 = (v59 >> v58) & ~(-1 << v75) | v73;
        if (v40) {
          int v77 = (int)(*(double *)(a1 + 168)
        }
                    + (double)(unsigned __int16)v77
                    * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                     / (double)((2 << (v36 - 1)) - 1))
                    + 0.5);
        *(_WORD *)&a2[2 * j] = v77;
      }
      goto LABEL_292;
    }
    if (v39) {
      _CGHandleAssert("expand_components_without_scaling", 1058, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
    }
    if (v36 - 33 <= 0xFFFFFFFFFFFFFFEFLL) {
      _CGHandleAssert("expand_packed_to_32bit", 986, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 16 && src_bits_per_component < 33", "bpc %zu", v31, v32, v33, *(void *)(a1 + 88));
    }
    if (v38 / v36 * v36 != v38) {
      _CGHandleAssert("expand_packed_to_32bit", 989, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  sbc %zu  bpp %zu", v31, v32, v33, v38 / v36);
    }
    unint64_t v53 = v38 / v36 * v19;
    if (v22)
    {
      LODWORD(v54) = 0;
      unint64_t v55 = 0;
      do
      {
        if (!v54)
        {
          unsigned int v56 = *v37++;
          unint64_t v55 = v56 | (v55 << 8);
          LODWORD(v54) = 8;
        }
        LODWORD(v54) = v54 - 1;
        --v22;
      }
      while (v22);
    }
    else
    {
      unint64_t v55 = 0;
      LODWORD(v54) = 0;
    }
    if (v36 == 32 && *(_DWORD *)(a1 + 124) == 0x2000)
    {
      if (v53)
      {
        for (uint64_t k = 0; k != v53; ++k)
        {
          unint64_t v79 = v55;
          if (v54 > 0x17)
          {
            int v81 = v54;
          }
          else
          {
            do
            {
              unsigned int v80 = *v37++;
              unint64_t v79 = v80 | (v79 << 8);
              int v81 = v54 + 8;
              BOOL v64 = v54 >= 0x10;
              LODWORD(v54) = v54 + 8;
            }
            while (!v64);
          }
          char v82 = v81 - 24;
          if ((v81 - 24) > 7)
          {
            unint64_t v55 = v79;
            int v84 = v81 - 24;
          }
          else
          {
            unsigned int v83 = *v37++;
            unint64_t v55 = v83 | (v79 << 8);
            int v84 = v81 - 16;
          }
          unsigned int v85 = (v79 >> v82) << 8;
          LODWORD(v54) = v84 - 8;
          unsigned int v86 = bswap32((v55 >> (v84 - 8)) | v85);
          if (v40) {
            unsigned int v86 = (*(double *)(a1 + 168)
          }
                               + 0.5
                               - (double)v86 * (*(double *)(a1 + 176) - *(double *)(a1 + 168)));
          *(float *)&a2[4 * k] = (float)v86;
        }
      }
    }
    else if (v53)
    {
      for (uint64_t m = 0; m != v53; ++m)
      {
        if (v36 <= 0x18)
        {
          int v90 = 0;
          unint64_t v91 = v54;
          unint64_t v92 = v36;
        }
        else
        {
          if (v54 > 0x17)
          {
            int v89 = v54;
          }
          else
          {
            do
            {
              unsigned int v88 = *v37++;
              unint64_t v55 = v88 | (v55 << 8);
              int v89 = v54 + 8;
              BOOL v64 = v54 >= 0x10;
              LODWORD(v54) = v54 + 8;
            }
            while (!v64);
          }
          unint64_t v91 = (v89 - 24);
          int v90 = ((v55 >> (v89 - 24)) & 0xFFFFFF) << (v36 - 24);
          LODWORD(v54) = v91;
          unint64_t v92 = v36 - 24;
        }
        if (v92 > v91)
        {
          do
          {
            unsigned int v93 = *v37++;
            unint64_t v55 = v93 | (v55 << 8);
            unint64_t v54 = (v54 + 8);
          }
          while (v92 > v54);
        }
        LODWORD(v54) = v54 - v92;
        unsigned int v94 = (v55 >> v54) & ~(-1 << v92) | v90;
        if (v40) {
          unsigned int v94 = (*(double *)(a1 + 168)
        }
                             + (double)v94
                             * ((*(double *)(a1 + 176) - *(double *)(a1 + 168))
                              / (double)((2 << (v36 - 1)) - 1))
                             + 0.5);
        *(float *)&a2[4 * m] = (float)v94;
      }
    }
  }
  else
  {
    int v45 = v35 - 1;
    if ((v35 - 1) >= 5 || ((0x1Bu >> v45) & 1) == 0) {
      _CGHandleAssert("bytes_per_component_type", 87, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
    }
    unint64_t v46 = *(void *)(a1 + 80);
    int v47 = *(_DWORD *)(a1 + 120);
    int v48 = *(_DWORD *)(a1 + 124);
    int v49 = *(_DWORD *)(a1 + 128);
    if (v36 <= 0xC && ((1 << v36) & 0x1016) != 0 && !v22)
    {
      upscale_using_vImage(a2, v37, *(void *)(a1 + 72) * v19, qword_1852104A8[v45] * *(void *)(a1 + 72) * v19, (v46 * v19 + 7) >> 3, *(vImageConverterRef *)(a1 + 136));
      goto LABEL_292;
    }
    switch(v45)
    {
      case 0:
        if (v36 - 8 <= 0xFFFFFFFFFFFFFFF8) {
          _CGHandleAssert("upscale_to_8bit", 435, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 0 && src_bits_per_component < 8", "bpc = %zu", v31, v32, v33, *(void *)(a1 + 88));
        }
        if (v36 != 5) {
          goto LABEL_159;
        }
        if (v47 == 0x10000)
        {
          if (v46 != 16) {
            _CGHandleAssert("upscale_555_RGB_to_8bit", 339, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 16", "src bpp %lu", v31, v32, v33, *(void *)(a1 + 80));
          }
          if ((v49 - 7) <= 0xFFFFFFFB) {
            _CGHandleAssert("upscale_555_RGB_to_8bit", 344, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_alpha_info == kCGImageAlphaLast || src_alpha_info == kCGImageAlphaNoneSkipLast || src_alpha_info == kCGImageAlphaFirst || src_alpha_info == kCGImageAlphaNoneSkipFirst", "src alpha info %u", v31, v32, v33, *(_DWORD *)(a1 + 128));
          }
          if (v48 && v48 != 4096 && v48 != 12288) {
            _CGHandleAssert("upscale_555_RGB_to_8bit", 351, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder16Little|| src_byte_order == kCGImageByteOrder16Big", "byte order = %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
          }
          unsigned int v156 = v49 & 0xFFFFFFFD;
          BOOL v157 = (v49 & 0xFFFFFFFD) != 4;
          if (v48 == 4096 || (v49 & 0xFFFFFFFD) != 4)
          {
            BOOL v163 = v48 != 4096;
            if (v48 != 4096) {
              BOOL v157 = 1;
            }
            if (v157)
            {
              if (v48 == 4096 || v156 == 4)
              {
                if (!v19) {
                  BOOL v163 = 1;
                }
                if (!v163 && v156 != 4)
                {
                  vImagePixelCount v174 = v19;
                  do
                  {
                    unsigned int v175 = *(unsigned __int16 *)v37;
                    v37 += 2;
                    *a2 = expand_5_to_8bpc_table[(unint64_t)v175 >> 11];
                    a2[1] = expand_5_to_8bpc_table[((unint64_t)v175 >> 6) & 0x1F];
                    a2[2] = expand_5_to_8bpc_table[((unint64_t)v175 >> 1) & 0x1F];
                    a2[3] = expand_1_to_8bpc_table[v175 & 1];
                    a2 += 4;
                    --v174;
                  }
                  while (v174);
                }
              }
              else if (v19)
              {
                vImagePixelCount v164 = v19;
                do
                {
                  unsigned int v165 = *(unsigned __int16 *)v37;
                  v37 += 2;
                  unint64_t v166 = bswap32(v165);
                  *a2 = expand_5_to_8bpc_table[(unint64_t)WORD1(v166) >> 11];
                  a2[1] = expand_5_to_8bpc_table[(v166 >> 22) & 0x1F];
                  a2[2] = expand_5_to_8bpc_table[(v166 >> 17) & 0x1F];
                  a2[3] = expand_1_to_8bpc_table[BYTE2(v166) & 1];
                  a2 += 4;
                  --v164;
                }
                while (v164);
              }
            }
            else if (v19)
            {
              vImagePixelCount v172 = v19;
              do
              {
                unsigned int v173 = *(unsigned __int16 *)v37;
                v37 += 2;
                *a2 = expand_1_to_8bpc_table[(unint64_t)v173 >> 15];
                a2[1] = expand_5_to_8bpc_table[((unint64_t)v173 >> 10) & 0x1F];
                a2[2] = expand_5_to_8bpc_table[((unint64_t)v173 >> 5) & 0x1F];
                a2[3] = expand_5_to_8bpc_table[v173 & 0x1F];
                a2 += 4;
                --v172;
              }
              while (v172);
            }
          }
          else if (v19)
          {
            vImagePixelCount v158 = v19;
            do
            {
              unsigned int v159 = *(unsigned __int16 *)v37;
              v37 += 2;
              unint64_t v160 = bswap32(v159);
              *a2 = expand_1_to_8bpc_table[(unint64_t)WORD1(v160) >> 15];
              a2[1] = expand_5_to_8bpc_table[(v160 >> 26) & 0x1F];
              a2[2] = expand_5_to_8bpc_table[(v160 >> 21) & 0x1F];
              a2[3] = expand_5_to_8bpc_table[BYTE2(v160) & 0x1F];
              a2 += 4;
              --v158;
            }
            while (v158);
          }
        }
        else
        {
          if (v47 == 0x20000)
          {
            if (v46 != 16) {
              _CGHandleAssert("upscale_565_RGB_to_8bit", 410, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 16", "src bpp %zu", v31, v32, v33, *(void *)(a1 + 80));
            }
            if (v48)
            {
              if (v48 == 4096)
              {
                if (v19)
                {
                  vImagePixelCount v170 = v19;
                  do
                  {
                    unsigned int v171 = *(unsigned __int16 *)v37;
                    v37 += 2;
                    *a2 = expand_5_to_8bpc_table[(unint64_t)v171 >> 11];
                    a2[1] = expand_6_to_8bpc_table[((unint64_t)v171 >> 5) & 0x3F];
                    a2[2] = expand_5_to_8bpc_table[v171 & 0x1F];
                    a2 += 3;
                    --v170;
                  }
                  while (v170);
                }
                break;
              }
              if (v48 != 12288) {
                _CGHandleAssert("upscale_565_RGB_to_8bit", 413, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder16Little|| src_byte_order == kCGImageByteOrder16Big", "src byte order %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
              }
            }
            if (v19)
            {
              vImagePixelCount v50 = v19;
              do
              {
                unsigned int v51 = *(unsigned __int16 *)v37;
                v37 += 2;
                unint64_t v52 = bswap32(v51);
                *a2 = expand_5_to_8bpc_table[(unint64_t)WORD1(v52) >> 11];
                a2[1] = expand_6_to_8bpc_table[(v52 >> 21) & 0x3F];
                a2[2] = expand_5_to_8bpc_table[BYTE2(v52) & 0x1F];
                a2 += 3;
                --v50;
              }
              while (v50);
            }
            break;
          }
LABEL_159:
          if (v47) {
            _CGHandleAssert("upscale_packed_to_8bit", 203, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %d", v31, v32, v33, *(_DWORD *)(a1 + 120));
          }
          if (v46 / v36 * v36 != v46) {
            _CGHandleAssert("upscale_packed_to_8bit", 206, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %lu bpc %lu bpp %lu", v31, v32, v33, v46 / v36);
          }
          unint64_t v104 = v46 / v36 * v19;
          if (v22)
          {
            LODWORD(v105) = 0;
            unint64_t v106 = 0;
            do
            {
              if (!v105)
              {
                unsigned int v107 = *v37++;
                unint64_t v106 = v107 | (v106 << 8);
                LODWORD(v105) = 8;
              }
              LODWORD(v105) = v105 - 1;
              --v22;
            }
            while (v22);
          }
          else
          {
            unint64_t v106 = 0;
            LODWORD(v105) = 0;
          }
          if (v104)
          {
            uint64_t v140 = 0;
            uint64_t v141 = (uint64_t)*(&off_1E52B42F8 + v36 - 1);
            do
            {
              if (v36 <= 0x18)
              {
                LOBYTE(v144) = 0;
                unint64_t v145 = v105;
                unint64_t v146 = v36;
              }
              else
              {
                if (v105 > 0x17)
                {
                  int v143 = v105;
                }
                else
                {
                  do
                  {
                    unsigned int v142 = *v37++;
                    unint64_t v106 = v142 | (v106 << 8);
                    int v143 = v105 + 8;
                    BOOL v64 = v105 >= 0x10;
                    LODWORD(v105) = v105 + 8;
                  }
                  while (!v64);
                }
                unint64_t v145 = (v143 - 24);
                int v144 = ((v106 >> (v143 - 24)) & 0xFFFFFF) << (v36 - 24);
                LODWORD(v105) = v145;
                unint64_t v146 = v36 - 24;
              }
              if (v146 > v145)
              {
                do
                {
                  unsigned int v147 = *v37++;
                  unint64_t v106 = v147 | (v106 << 8);
                  unint64_t v105 = (v105 + 8);
                }
                while (v146 > v105);
              }
              LODWORD(v105) = v105 - v146;
              a2[v140++] = *(unsigned char *)(v141 + ((v106 >> v105) & ~(-1 << v146) | v144));
            }
            while (v140 != v104);
          }
        }
        break;
      case 1:
        if (v36 - 16 <= 0xFFFFFFFFFFFFFFF8) {
          _CGHandleAssert("upscale_to_16bit", 687, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 8 && src_bits_per_component < 16", "bpc %zu", v31, v32, v33, *(void *)(a1 + 88));
        }
        if (v36 == 10 && v47 == 196608)
        {
          if (v46 != 32) {
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 621, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 32", "bpp %zu", v31, v32, v33, *(void *)(a1 + 80));
          }
          char v95 = v49 - 1;
          if ((v49 - 1) >= 6) {
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 628, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_alpha_info == kCGImageAlphaLast || src_alpha_info == kCGImageAlphaNoneSkipLast || src_alpha_info == kCGImageAlphaPremultipliedLast || src_alpha_info == kCGImageAlphaFirst || src_alpha_info == kCGImageAlphaNoneSkipFirst || src_alpha_info == kCGImageAlphaPremultipliedFirst", "alpha info = %u", v31, v32, v33, *(_DWORD *)(a1 + 128));
          }
          if (v48 && v48 != 0x2000 && v48 != 0x4000) {
            _CGHandleAssert("upscale_101010_RGB_to_16bit", 636, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_byte_order == kCGImageByteOrderDefault || src_byte_order == kCGImageByteOrder32Little|| src_byte_order == kCGImageByteOrder32Big", "byte order %u", v31, v32, v33, *(_DWORD *)(a1 + 124));
          }
          BOOL v96 = (v95 & 1) == 0;
          if (v48 == 0x2000 || (((_BYTE)v49 - 1) & 1) == 0)
          {
            BOOL v132 = v48 != 0x2000;
            if (v48 != 0x2000) {
              BOOL v96 = 1;
            }
            if (v96)
            {
              int v133 = v95 & 1;
              if (v48 == 0x2000 || v133)
              {
                if (!v19) {
                  BOOL v132 = 1;
                }
                if (!v132 && !v133)
                {
                  vImagePixelCount v167 = v19;
                  do
                  {
                    unsigned int v168 = *(_DWORD *)v37;
                    v37 += 4;
                    __int16 v169 = expand_2_to_16bpc_table[v168 & 3];
                    *(_WORD *)a2 = (0x400FC3F0FC3F10 * ((unint64_t)v168 >> 22) + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (((unint64_t)v168 >> 12) & 0x3FF)
                                        + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (((unint64_t)v168 >> 2) & 0x3FF) + 0x800000000000) >> 48;
                    *((_WORD *)a2 + 3) = v169;
                    a2 += 8;
                    --v167;
                  }
                  while (v167);
                }
              }
              else if (v19)
              {
                vImagePixelCount v134 = v19;
                do
                {
                  unsigned int v135 = *(_DWORD *)v37;
                  v37 += 4;
                  unsigned int v136 = bswap32(v135);
                  uint64_t v137 = v136 >> 22;
                  uint64_t v138 = (v136 >> 12) & 0x3FF;
                  uint64_t v139 = (v136 >> 2) & 0x3FF;
                  LOWORD(v136) = expand_2_to_16bpc_table[v136 & 3];
                  *(_WORD *)a2 = (unint64_t)(0x400FC3F0FC3F10 * v137 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 1) = (unint64_t)(0x400FC3F0FC3F10 * v138 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 2) = (unint64_t)(0x400FC3F0FC3F10 * v139 + 0x800000000000) >> 48;
                  *((_WORD *)a2 + 3) = v136;
                  a2 += 8;
                  --v134;
                }
                while (v134);
              }
            }
            else if (v19)
            {
              vImagePixelCount v161 = v19;
              do
              {
                unsigned int v162 = *(_DWORD *)v37;
                v37 += 4;
                *(_WORD *)a2 = *(_WORD *)((char *)expand_2_to_16bpc_table + (((unint64_t)v162 >> 29) & 6));
                *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (((unint64_t)v162 >> 20) & 0x3FF) + 0x800000000000) >> 48;
                *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (((unint64_t)v162 >> 10) & 0x3FF) + 0x800000000000) >> 48;
                *((_WORD *)a2 + 3) = (0x400FC3F0FC3F10 * (unint64_t)(v162 & 0x3FF) + 0x800000000000) >> 48;
                a2 += 8;
                --v161;
              }
              while (v161);
            }
          }
          else if (v19)
          {
            vImagePixelCount v97 = v19;
            do
            {
              unsigned int v98 = *(_DWORD *)v37;
              v37 += 4;
              unsigned int v99 = bswap32(v98);
              *(_WORD *)a2 = expand_2_to_16bpc_table[v99 >> 30];
              *((_WORD *)a2 + 1) = (0x400FC3F0FC3F10 * (unint64_t)((v99 >> 20) & 0x3FF) + 0x800000000000) >> 48;
              *((_WORD *)a2 + 2) = (0x400FC3F0FC3F10 * (unint64_t)((v99 >> 10) & 0x3FF) + 0x800000000000) >> 48;
              *((_WORD *)a2 + 3) = (0x400FC3F0FC3F10 * (unint64_t)(v99 & 0x3FF) + 0x800000000000) >> 48;
              a2 += 8;
              --v97;
            }
            while (v97);
          }
        }
        else
        {
          if (v47) {
            _CGHandleAssert("upscale_packed_to_16bit", 660, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
          }
          if (v46 / v36 * v36 != v46) {
            _CGHandleAssert("upscale_packed_to_16bit", 663, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  bpc %zu  bpp %zu", v31, v32, v33, v46 / v36);
          }
          unint64_t v108 = v46 / v36 * v19;
          if (v22)
          {
            LODWORD(v109) = 0;
            unint64_t v110 = 0;
            do
            {
              if (!v109)
              {
                unsigned int v111 = *v37++;
                unint64_t v110 = v111 | (v110 << 8);
                LODWORD(v109) = 8;
              }
              LODWORD(v109) = v109 - 1;
              --v22;
            }
            while (v22);
          }
          else
          {
            unint64_t v110 = 0;
            LODWORD(v109) = 0;
          }
          if (v108)
          {
            uint64_t v148 = 0;
            uint64_t v149 = rescale_to_16bit_kScaleTable[v36];
            do
            {
              if (v36 <= 0x18)
              {
                LOWORD(v152) = 0;
                unint64_t v153 = v109;
                unint64_t v154 = v36;
              }
              else
              {
                if (v109 > 0x17)
                {
                  int v151 = v109;
                }
                else
                {
                  do
                  {
                    unsigned int v150 = *v37++;
                    unint64_t v110 = v150 | (v110 << 8);
                    int v151 = v109 + 8;
                    BOOL v64 = v109 >= 0x10;
                    LODWORD(v109) = v109 + 8;
                  }
                  while (!v64);
                }
                unint64_t v153 = (v151 - 24);
                int v152 = ((v110 >> (v151 - 24)) & 0xFFFFFF) << (v36 - 24);
                LODWORD(v109) = v153;
                unint64_t v154 = v36 - 24;
              }
              if (v154 > v153)
              {
                do
                {
                  unsigned int v155 = *v37++;
                  unint64_t v110 = v155 | (v110 << 8);
                  unint64_t v109 = (v109 + 8);
                }
                while (v154 > v109);
              }
              LODWORD(v109) = v109 - v154;
              *(_WORD *)&a2[2 * v148++] = (v149
                                         * ((v110 >> v109) & (unsigned __int16)~(-1 << v154) | (unsigned __int16)v152)
                                         + 0x800000000000) >> 48;
            }
            while (v148 != v108);
          }
        }
        break;
      case 3:
        if (v47) {
          _CGHandleAssert("upscale_components_internal", 840, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatPacked", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        }
        if (v36 - 33 <= 0xFFFFFFFFFFFFFFEFLL) {
          _CGHandleAssert("upscale_to_32bit", 762, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component > 16 && src_bits_per_component < 33", "bpc %zu", v31, v32, v33, *(void *)(a1 + 88));
        }
        if (v46 / v36 * v36 != v46) {
          _CGHandleAssert("upscale_to_32bit", 765, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "component_per_pixel_count * src_bits_per_component == src_bits_per_pixel", "cpp %zu  bpc %zu  bpp %zu", v31, v32, v33, v46 / v36);
        }
        unint64_t v100 = v46 / v36 * v19;
        if (v22)
        {
          LODWORD(v101) = 0;
          unint64_t v102 = 0;
          do
          {
            if (!v101)
            {
              unsigned int v103 = *v37++;
              unint64_t v102 = v103 | (v102 << 8);
              LODWORD(v101) = 8;
            }
            LODWORD(v101) = v101 - 1;
            --v22;
          }
          while (v22);
        }
        else
        {
          unint64_t v102 = 0;
          LODWORD(v101) = 0;
        }
        if (v36 == 32 && v48 == 0x2000)
        {
          if (v100)
          {
            for (uint64_t n = 0; n != v100; ++n)
            {
              if (v101 > 0x17)
              {
                int v114 = v101;
              }
              else
              {
                do
                {
                  unsigned int v113 = *v37++;
                  unint64_t v102 = v113 | (v102 << 8);
                  int v114 = v101 + 8;
                  BOOL v64 = v101 >= 0x10;
                  LODWORD(v101) = v101 + 8;
                }
                while (!v64);
              }
              char v115 = v114 - 24;
              if ((v114 - 24) > 7)
              {
                unint64_t v117 = v102;
                int v118 = v114 - 24;
              }
              else
              {
                unsigned int v116 = *v37++;
                unint64_t v117 = v116 | (v102 << 8);
                int v118 = v114 - 16;
              }
              unsigned int v119 = (v102 >> v115) << 8;
              LODWORD(v101) = v118 - 8;
              double v120 = (double)bswap32((v117 >> (v118 - 8)) | v119) / 4294967300.0;
              if (v120 > 1.0) {
                double v120 = 1.0;
              }
              float v121 = v120;
              *(float *)&a2[4 * n] = v121;
              unint64_t v102 = v117;
            }
          }
        }
        else if (v100)
        {
          uint64_t v122 = 0;
          double v123 = rescale_to_float_max_per_component[v36 - 17];
          do
          {
            if (v36 <= 0x18)
            {
              int v126 = 0;
              unint64_t v127 = v101;
              unint64_t v128 = v36;
            }
            else
            {
              if (v101 > 0x17)
              {
                int v125 = v101;
              }
              else
              {
                do
                {
                  unsigned int v124 = *v37++;
                  unint64_t v102 = v124 | (v102 << 8);
                  int v125 = v101 + 8;
                  BOOL v64 = v101 >= 0x10;
                  LODWORD(v101) = v101 + 8;
                }
                while (!v64);
              }
              unint64_t v127 = (v125 - 24);
              int v126 = ((v102 >> (v125 - 24)) & 0xFFFFFF) << (v36 - 24);
              LODWORD(v101) = v127;
              unint64_t v128 = v36 - 24;
            }
            if (v128 > v127)
            {
              do
              {
                unsigned int v129 = *v37++;
                unint64_t v102 = v129 | (v102 << 8);
                unint64_t v101 = (v101 + 8);
              }
              while (v128 > v101);
            }
            LODWORD(v101) = v101 - v128;
            double v130 = (double)((v102 >> v101) & ~(-1 << v128) | v126) / v123;
            if (v130 > 1.0) {
              double v130 = 1.0;
            }
            float v131 = v130;
            *(float *)&a2[4 * v122++] = v131;
          }
          while (v122 != v100);
        }
        break;
      case 4:
        if (v47 != 0x40000) {
          _CGHandleAssert("upscale_components_internal", 832, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_pixel_format == kCGImagePixelFormatRGBCIF10", "pixel format %u", v31, v32, v33, *(_DWORD *)(a1 + 120));
        }
        if (v36 != 10) {
          _CGHandleAssert("convert_CIF10_to_fp16", 717, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_component == 10", "bpc %zu", v31, v32, v33, *(void *)(a1 + 88));
        }
        if (v46 != 32) {
          _CGHandleAssert("convert_CIF10_to_fp16", 718, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "src_bits_per_pixel == 32", "bpp %zu", v31, v32, v33, *(void *)(a1 + 80));
        }
        src.data = *(void **)(a1 + 144);
        src.height = 1;
        src.width = v19;
        src.rowBytes = 4 * v19;
        dest.data = a2;
        dest.height = 1;
        dest.width = v19;
        dest.rowBytes = 8 * v19;
        vImageConvert_XRGB2101010ToARGB16F(&src, 1.0, &dest, 384, 895, 0, 0x810u);
        break;
      default:
        _CGHandleAssert("upscale_components_internal", 850, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", v31, v32, v33, v177);
    }
  }
LABEL_292:
  if (v34 < v23) {
    a4 = (v19 * *(void *)(a1 + 40) + 7) >> 3;
  }
  if (a5)
  {
    *(void *)(a1 + 112) += v34;
    *(void *)(a1 + 64) += a4;
  }
  return a4;
}

void upscale_using_vImage(void *a1, void *a2, vImagePixelCount a3, size_t a4, size_t a5, vImageConverterRef converter)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  srcs.data = a2;
  srcs.height = 1;
  srcs.width = a3;
  srcs.rowBytes = a5;
  dests.data = a1;
  dests.height = 1;
  dests.width = a3;
  dests.rowBytes = a4;
  vImage_Error v7 = vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0x80u);
  if (v7 < 0)
  {
    vImagePixelCount v19 = "vImageConvert_AnyToAny failed to return vImage buffer size %s";
LABEL_14:
    CGPostError((uint64_t)v19, v8, v9, v10, v11, v12, v13, v14, (char)"upscale_using_vImage");
    return;
  }
  if (!v7)
  {
    if (!vImageConvert_AnyToAny(converter, &srcs, &dests, 0, 0)) {
      return;
    }
    goto LABEL_13;
  }
  size_t v16 = MEMORY[0x1F4188790](v7, v15);
  uint64_t v18 = (char *)&v30 - v17;
  if (v16 <= 0x400)
  {
    if (!vImageConvert_AnyToAny(converter, &srcs, &dests, (char *)&v30 - v17, 0)) {
      return;
    }
LABEL_13:
    vImagePixelCount v19 = "%s : vImageConvert_AnyToAny failed to convert data";
    goto LABEL_14;
  }
  unint64_t v20 = (char *)malloc_type_malloc(v16, 0x34DD0371uLL);
  if (!v20)
  {
    CGPostError((uint64_t)"vImageConvert_AnyToAny could not allocate buffer %s", v21, v22, v23, v24, v25, v26, v27, (char)"upscale_using_vImage");
    vImagePixelCount v19 = "%s : vImageConvert_AnyToAny failed to convert data";
    goto LABEL_14;
  }
  uint64_t v28 = v20;
  vImage_Error v29 = vImageConvert_AnyToAny(converter, &srcs, &dests, v20, 0);
  if (v28 != v18) {
    free(v28);
  }
  if (v29) {
    goto LABEL_13;
  }
}

uint64_t upscale_provider_unlock(uint64_t *a1)
{
  return CGDataProviderUnlock(*a1);
}

uint64_t upscale_provider_lock(uint64_t *a1)
{
  return CGDataProviderLock(*a1);
}

void *upscale_provider_rewind(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *result;
  if (!*result) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, v11);
  }
  if ((*(_DWORD *)(v8 + 20) | 2) != 3) {
    _CGHandleAssert("upscale_provider_rewind", 1260, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "", "Unimplemented", a6, a7, a8, v11);
  }
  uint64_t v9 = result;
  uint64_t v10 = *(uint64_t (**)(void))(v8 + 64);
  if (v10) {
    uint64_t result = (void *)v10(*(void *)(v8 + 24));
  }
  *(unsigned char *)(v8 + 261) = 0;
  v9[8] = 0;
  v9[14] = 0;
  return result;
}

unint64_t upscale_provider_skip_forward(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = a2;
  if ((a2 & 0x8000000000000000) != 0) {
    _CGHandleAssert("upscale_provider_skip_forward", 1214, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "count >= 0", "count %lld", a6, a7, a8, a2);
  }
  uint64_t v10 = *(void *)a1;
  unint64_t v11 = byte_count_to_byte_count(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 80), *(void *)(a1 + 96), a2, a8);
  uint64_t v12 = CGDataProviderSkipForwardInternal(v10, v11);
  uint64_t v16 = v12;
  if (v12 < 0) {
    _CGHandleAssert("upscale_provider_skip_forward", 1227, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "skipped >= 0", "skipped %lld", v13, v14, v15, v12);
  }
  if (v12 != v11) {
    unint64_t v8 = byte_count_to_byte_count(*(void *)(a1 + 80), *(void *)(a1 + 96), *(void *)(a1 + 104), *(void *)(a1 + 112), *(void *)(a1 + 40), *(void *)(a1 + 48), v12, v15);
  }
  *(void *)(a1 + 112) += v16;
  *(void *)(a1 + 64) += v8;
  return v8;
}

unint64_t upscale_provider_get_bytes(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 8)) {
    _CGHandleAssert("upscale_provider_get_bytes", 1204, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "info->src_provider_uses_random_access == false", "", a6, a7, a8, vars0);
  }

  return upscale_provider_get_bytes_at_position_inner(a1, a2, 0, a3, 1, a6, a7, a8);
}

uint64_t readingOrder(void *a1, void *a2, double *a3)
{
  double v32 = *a3;
  [a1 bounds];
  CGFloat v5 = v4;
  double v7 = v6;
  double v9 = v8;
  double v11 = v10;
  [a2 bounds];
  CGFloat rect_24 = v12;
  double v14 = v13;
  double v16 = v15;
  double v18 = v17;
  BOOL v19 = v11 < 0.0 || v9 < 0.0;
  double v20 = v7;
  double v21 = v11;
  if (v19)
  {
    v33.origin.x = v5;
    v33.origin.double y = v7;
    v33.size.width = v9;
    v33.size.double height = v11;
    *(CGRect *)(&v20 - 1) = CGRectStandardize(v33);
  }
  double rect_8 = v21;
  double rect_16 = v20;
  CGFloat rect = v5;
  BOOL v22 = v18 < 0.0 || v16 < 0.0;
  double y = v14;
  double height = v18;
  if (v22)
  {
    v36.origin.x = rect_24;
    v36.origin.double y = v14;
    v36.size.width = v16;
    v36.size.double height = v18;
    CGRect v37 = CGRectStandardize(v36);
    double y = v37.origin.y;
    double height = v37.size.height;
    if (!v19)
    {
LABEL_11:
      if (!v22) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else if (!v19)
  {
    goto LABEL_11;
  }
  v38.origin.x = rect;
  v38.origin.double y = v7;
  v38.size.width = v9;
  v38.size.double height = v11;
  CGRect v39 = CGRectStandardize(v38);
  double v7 = v39.origin.y;
  if (v22)
  {
LABEL_12:
    v34.origin.x = rect_24;
    v34.origin.double y = v14;
    v34.size.width = v16;
    v34.size.double height = v18;
    CGRect v35 = CGRectStandardize(v34);
    double v14 = v35.origin.y;
  }
LABEL_13:
  double v25 = rect_16 + rect_8 + v7 * v32;
  double v26 = y + height + v14 * v32;
  if (v25 > v26) {
    return -1;
  }
  else {
    return v25 < v26;
  }
}

uint64_t path_iterator_release(uint64_t this)
{
  if (this) {
    return path_iterator::release(this);
  }
  return this;
}

void path_iterator_create()
{
}

void *path_iterator_begin(void *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = (uint64_t (*)(void, uint64_t, void))result[2];
    if (v2) {
      return (void *)v2(result[1], a2, result[6]);
    }
  }
  return result;
}

uint64_t path_iterator_call(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(a1 + 24))(*(void *)(a1 + 8), a2, a3, *(void *)(a1 + 48));
}

uint64_t path_iterator_move_to_point(uint64_t result, double a2, double a3)
{
  *(double *)double v3 = a2;
  *(double *)&v3[1] = a3;
  if (result) {
    return (*(uint64_t (**)(void, void, void *, void))(result + 24))(*(void *)(result + 8), 0, v3, *(void *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_add_line_to_point(uint64_t result, double a2, double a3)
{
  *(double *)double v3 = a2;
  *(double *)&v3[1] = a3;
  if (result) {
    return (*(uint64_t (**)(void, uint64_t, void *, void))(result + 24))(*(void *)(result + 8), 1, v3, *(void *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_add_quad_curve_to_point(uint64_t result, double a2, double a3, double a4, double a5)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    *(double *)CGFloat v5 = a2;
    *(double *)&v5[1] = a3;
    *(double *)&v5[2] = a4;
    *(double *)&v5[3] = a5;
    return (*(uint64_t (**)(void, uint64_t, void *, void))(result + 24))(*(void *)(result + 8), 2, v5, *(void *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_add_curve_to_point(uint64_t result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  v7[6] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    *(double *)double v7 = a2;
    *(double *)&v7[1] = a3;
    *(double *)&v7[2] = a4;
    *(double *)&v7[3] = a5;
    *(double *)&v7[4] = a6;
    *(double *)&v7[5] = a7;
    return (*(uint64_t (**)(void, uint64_t, void *, void))(result + 24))(*(void *)(result + 8), 3, v7, *(void *)(result + 48));
  }
  return result;
}

uint64_t path_iterator_close_subpath(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void, uint64_t, void, void))(result + 24))(*(void *)(result + 8), 4, 0, *(void *)(result + 48));
  }
  return result;
}

void *path_iterator_end(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t (*)(void, void))result[4];
    if (v1) {
      return (void *)v1(result[1], result[6]);
    }
  }
  return result;
}

void pdf_page_release(uint64_t a1)
{
  if (a1)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 56));
    uint64_t v2 = *(const void **)(a1 + 24);
    if (v2) {
      CFRelease(v2);
    }
    free(*(void **)(a1 + 64));
    CGPropertiesRelease(*(CFTypeRef **)(a1 + 72));
    double v3 = *(const void **)(a1 + 80);
    if (v3) {
      CFRelease(v3);
    }
    double v4 = *(const void **)(a1 + 96);
    if (v4) {
      CFRelease(v4);
    }
    CGFloat v5 = *(const void **)(a1 + 104);
    if (v5) {
      CFRelease(v5);
    }
    free((void *)a1);
  }
}

uint64_t pdf_page_get_thumbnail(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 80);
  if (!result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
    if (*(void *)(a1 + 80)
      || (CGPDFStreamRef value = 0, CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(a1 + 16), "Thumb", &value))
      && (double v3 = (CGImage *)CGPDFImageCreate((uint64_t)value)) != 0
      && (double v4 = v3,
          *(void *)(a1 + 80) = CGPDFImageCreateImageForRenderingSize(v3, 0, 0.0, 0.0),
          CFRelease(v4),
          *(void *)(a1 + 80)))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      return *(void *)(a1 + 80);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
      return 0;
    }
  }
  return result;
}

const void *pdf_page_copy_background_color_hint(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  double v3 = *(const void **)(a1 + 104);
  if (v3) {
    CFRetain(v3);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t GRAYA8_sample_RGBA32_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(result + 8);
  int v9 = v8 >> 6;
  if ((v9 - 3) <= 0xFFFFFFFD) {
    _CGHandleAssert("GRAYA8_sample_RGBA32_inner", 9121, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "skip == FIRST_SKIP || skip == LAST_SKIP", "invalid skip code %d", a6, a7, a8, v8 >> 6);
  }
  unsigned int v10 = (v8 >> 4) & 3;
  if (v10 >= 2) {
    _CGHandleAssert("GRAYA8_sample_RGBA32_inner", 9122, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "reverse == NO_REVERSE || reverse == PIXEL_REVERSE", "invalid reverse code %d", a6, a7, a8, v10);
  }
  if (v9 == 2 && v10 == 0)
  {
    uint64_t v161 = 1;
    uint64_t v162 = 0;
    uint64_t v163 = 2;
    uint64_t v159 = 3;
  }
  else if (v9 == 1 && v10 == 0)
  {
    uint64_t v159 = 0;
    uint64_t v162 = 1;
    uint64_t v161 = 2;
    uint64_t v163 = 3;
  }
  else
  {
    uint64_t v15 = (v9 == 2) & (v10 == 1);
    BOOL v14 = v15 == 0;
    uint64_t v163 = v15;
    uint64_t v16 = 3;
    if (!v14) {
      uint64_t v16 = 0;
    }
    uint64_t v159 = v16;
    if (v14) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = 2;
    }
    uint64_t v18 = 2;
    if (!v14) {
      uint64_t v18 = 3;
    }
    uint64_t v161 = v17;
    uint64_t v162 = v18;
  }
  int v19 = *(_DWORD *)(result + 24);
  uint64_t v20 = *(void *)(result + 112);
  uint64_t v21 = *(void *)(result + 48);
  uint64_t v22 = *(void *)(result + 56);
  if (v21)
  {
    uint64_t v158 = *(void *)(result + 112);
    if (v20 > v21) {
      uint64_t v158 = v20 % v21;
    }
  }
  else
  {
    uint64_t v158 = 0;
  }
  uint64_t v23 = *(void *)(result + 176);
  uint64_t v24 = *(void *)(result + 120);
  uint64_t v160 = *(void *)(result + 32);
  if (v22)
  {
    uint64_t v157 = *(void *)(result + 120);
    if (v24 > v22) {
      uint64_t v157 = v24 % v22;
    }
  }
  else
  {
    uint64_t v157 = 0;
  }
  uint64_t v152 = *(void *)(result + 80);
  int v150 = *(_DWORD *)(result + 188);
  uint64_t v156 = *(void *)(result + 152) - 2;
  uint64_t v154 = *(void *)(result + 88);
  uint64_t v155 = *(void *)(result + 144) - 1;
  uint64_t v25 = *(void *)(result + 40);
  unint64_t v26 = v160 + (4 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v19) - 4;
  uint64_t v153 = *(void *)(result + 72);
  uint64_t v151 = *(void *)(result + 64);
  while (1)
  {
    if (a3 >= v153)
    {
      if (a3 <= v154)
      {
        uint64_t v35 = 0;
        uint64_t v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v37 = 0x3FFFFFFF;
        uint64_t v38 = a3;
        uint64_t v39 = v151;
      }
      else
      {
        uint64_t v31 = *(void *)(result + 216);
        uint64_t v32 = *(void *)(result + 224) + v154;
        uint64_t v33 = v32 - a3 + (v31 >> 1);
        if (v33 < 1) {
          goto LABEL_70;
        }
        if (v33 >= v31) {
          LODWORD(v34) = 0x3FFFFFFF;
        }
        else {
          unint64_t v34 = (unint64_t)(*(void *)(result + 232) * v33) >> 32;
        }
        uint64_t v39 = v151;
        unsigned int v37 = v150 | v34;
        uint64_t v38 = v32 - 0x1000000;
        uint64_t v35 = a3 - (v32 - 0x1000000);
        uint64_t v36 = 448;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(result + 216);
      uint64_t v28 = v153 - *(void *)(result + 224);
      uint64_t v29 = a3 - v28 + (v27 >> 1);
      if (v29 < 1) {
        goto LABEL_70;
      }
      if (v29 >= v27) {
        LODWORD(v30) = 0x3FFFFFFF;
      }
      else {
        unint64_t v30 = (unint64_t)(*(void *)(result + 232) * v29) >> 32;
      }
      uint64_t v39 = v151;
      unsigned int v37 = v150 | v30;
      uint64_t v38 = v28 + 0x1000000;
      uint64_t v35 = a3 - (v28 + 0x1000000);
      uint64_t v36 = 512;
    }
    if (a2 >= v39)
    {
      if (a2 <= v152)
      {
        uint64_t v44 = 0;
        uint64_t v45 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v43 = a2;
      }
      else
      {
        uint64_t v46 = *(void *)(result + 192);
        uint64_t v47 = *(void *)(result + 200) + v152;
        uint64_t v48 = v47 - a2 + (v46 >> 1);
        if (v48 < 1) {
          goto LABEL_70;
        }
        if (v48 < v46) {
          unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v48) >> 32) >> 15)) | v150;
        }
        uint64_t v43 = v47 - 0x1000000;
        uint64_t v44 = a2 - (v47 - 0x1000000);
        uint64_t v45 = 28;
      }
    }
    else
    {
      uint64_t v40 = *(void *)(result + 192);
      uint64_t v41 = v39 - *(void *)(result + 200);
      uint64_t v42 = a2 - v41 + (v40 >> 1);
      if (v42 < 1) {
        goto LABEL_70;
      }
      if (v42 < v40) {
        unsigned int v37 = ((v37 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v150;
      }
      uint64_t v43 = v41 + 0x1000000;
      uint64_t v44 = a2 - (v41 + 0x1000000);
      uint64_t v45 = 32;
    }
    if (v37 >= 0x400000) {
      break;
    }
LABEL_70:
    int v59 = a4 - 1;
    a2 += v20;
    a3 += v24;
    *(unsigned char *)++uint64_t v155 = 0;
    v156 += 2;
LABEL_71:
    a4 = v59;
    if (!v59) {
      return result;
    }
  }
  if (v21)
  {
    uint64_t v49 = (v22 & ((v38 % v22) >> 63)) + v38 % v22;
    uint64_t v50 = (v21 & ((v43 % v21) >> 63)) + v43 % v21;
    if (v49 >= v22) {
      uint64_t v51 = v22;
    }
    else {
      uint64_t v51 = 0;
    }
    uint64_t v38 = v49 - v51;
    if (v50 >= v21) {
      uint64_t v52 = v21;
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t v43 = v50 - v52;
    v35 += v38;
    v44 += v43;
  }
  uint64_t v53 = v160 + SHIDWORD(v38) * (uint64_t)v19;
  uint64_t v54 = v43 >> 32;
  unint64_t v55 = v53 + 4 * v54;
  unint64_t v56 = *(void *)(result + 32);
  if (v26 >= v55) {
    unint64_t v57 = v53 + 4 * v54;
  }
  else {
    unint64_t v57 = v26;
  }
  if (v57 < v56) {
    unint64_t v57 = *(void *)(result + 32);
  }
  if (v25) {
    int v58 = *(unsigned __int8 *)(v57 + v159);
  }
  else {
    int v58 = 255;
  }
  int v60 = *(unsigned __int8 *)(v57 + v162);
  int v61 = *(unsigned __int8 *)(v57 + v161);
  int v62 = *(unsigned __int8 *)(v57 + v163);
  if (v23)
  {
    unsigned int v63 = *(_DWORD *)(v23 + (v45 | v36));
LABEL_77:
    int v64 = v63 & 0xF;
    uint64_t v65 = v63 >> 8;
    int v66 = HIBYTE(v63) & 3;
    switch(v64)
    {
      case 1:
        LODWORD(v101) = SBYTE1(v63);
        if (v21)
        {
          uint64_t v102 = v65 << 56;
          uint64_t v103 = v35 + (v102 >> 24);
          uint64_t v104 = v22 & (v103 >> 63);
          if (v104 + v103 >= v22) {
            uint64_t v105 = v22;
          }
          else {
            uint64_t v105 = 0;
          }
          uint64_t v101 = (v104 + (v102 >> 24) - v105) >> 32;
        }
        unint64_t v106 = v55 + (int)v101 * (uint64_t)v19;
        if (v26 < v106) {
          unint64_t v106 = v26;
        }
        if (v106 >= v56) {
          unint64_t v107 = v106;
        }
        else {
          unint64_t v107 = v56;
        }
        unsigned int v108 = *(unsigned __int8 *)(v107 + v162);
        unsigned int v109 = *(unsigned __int8 *)(v107 + v161);
        unsigned int v110 = *(unsigned __int8 *)(v107 + v163);
        int v62 = 255;
        if (v25) {
          int v62 = *(unsigned __int8 *)(v107 + v159);
        }
        int v111 = interpolate_rgba[4 * v66 + 3];
        int v112 = interpolate_rgba[4 * v111 + 3];
        LOBYTE(v111) = v111 + 1;
        v60 -= (v112 & v60) >> v111;
        unsigned int v113 = v61 - ((v112 & v61) >> v111);
        v58 -= (v112 & v58) >> v111;
        unsigned int v114 = (v112 & v108) >> v111;
        unsigned int v115 = (v112 & v109) >> v111;
        unsigned int v116 = (v112 & v110) >> v111;
        unsigned int v117 = (v112 & v62) >> v111;
        LOBYTE(v60) = v60 + v114;
        LOBYTE(v61) = v113 + v115;
        LOBYTE(v62) = v60 + v116;
        LOWORD(v58) = v58 + v117;
        break;
      case 2:
        uint64_t v118 = SBYTE2(v63);
        if (v21)
        {
          uint64_t v119 = v44 + ((uint64_t)SBYTE2(v63) << 32);
          uint64_t v120 = v21 & (v119 >> 63);
          if (v120 + v119 >= v21) {
            uint64_t v121 = v21;
          }
          else {
            uint64_t v121 = 0;
          }
          uint64_t v118 = (v120 + ((uint64_t)((unint64_t)HIWORD(v63) << 56) >> 24) - v121) >> 32;
        }
        unint64_t v122 = v55 + 4 * v118;
        if (v26 < v122) {
          unint64_t v122 = v26;
        }
        if (v122 >= v56) {
          unint64_t v123 = v122;
        }
        else {
          unint64_t v123 = v56;
        }
        unsigned int v124 = *(unsigned __int8 *)(v123 + v162);
        unsigned int v125 = *(unsigned __int8 *)(v123 + v161);
        unsigned int v126 = *(unsigned __int8 *)(v123 + v163);
        int v127 = 255;
        if (v25) {
          int v127 = *(unsigned __int8 *)(v123 + v159);
        }
        int v128 = (v63 >> 28) & 3;
        int v129 = interpolate_rgba[4 * v128 + 3];
        LOBYTE(v128) = v128 + 1;
        int v60 = v60 - ((v129 & v60) >> v128) + ((v129 & v124) >> v128);
        int v61 = v61 - ((v129 & v61) >> v128) + ((v129 & v125) >> v128);
        int v62 = v60 + ((v129 & v126) >> v128);
        int v58 = v58 - ((v129 & v58) >> v128) + ((v129 & v127) >> v128);
        break;
      case 3:
        LODWORD(v67) = SBYTE1(v63);
        uint64_t v68 = SBYTE2(v63);
        if (v21)
        {
          uint64_t v69 = v65 << 56;
          int64_t v70 = (unint64_t)HIWORD(v63) << 56;
          uint64_t v71 = v35 + (v69 >> 24);
          uint64_t v72 = v44 + (v70 >> 24);
          uint64_t v73 = v22 & (v71 >> 63);
          uint64_t v74 = v21 & (v72 >> 63);
          uint64_t v75 = v74 + v72;
          if (v73 + v71 >= v22) {
            uint64_t v76 = v22;
          }
          else {
            uint64_t v76 = 0;
          }
          if (v75 >= v21) {
            uint64_t v77 = v21;
          }
          else {
            uint64_t v77 = 0;
          }
          uint64_t v67 = (v73 + (v69 >> 24) - v76) >> 32;
          uint64_t v68 = (v74 + (v70 >> 24) - v77) >> 32;
        }
        uint64_t v78 = (int)v67 * (uint64_t)v19;
        unint64_t v79 = v55 + 4 * v68;
        if (v26 < v79) {
          unint64_t v79 = v26;
        }
        if (v79 >= v56) {
          unint64_t v80 = v79;
        }
        else {
          unint64_t v80 = v56;
        }
        unsigned int v81 = *(unsigned __int8 *)(v80 + v162);
        uint64_t v82 = 4 * v68;
        unsigned int v83 = *(unsigned __int8 *)(v80 + v161);
        unsigned int v148 = *(unsigned __int8 *)(v80 + v163);
        int v84 = 255;
        if (v25) {
          int v84 = *(unsigned __int8 *)(v80 + v159);
        }
        int v149 = v84;
        unint64_t v85 = v55 + v78;
        if (v26 >= v85) {
          unint64_t v86 = v85;
        }
        else {
          unint64_t v86 = v26;
        }
        if (v86 < v56) {
          unint64_t v86 = v56;
        }
        unsigned int v87 = *(unsigned __int8 *)(v86 + v162);
        unsigned int v143 = *(unsigned __int8 *)(v86 + v161);
        unsigned int v146 = *(unsigned __int8 *)(v86 + v163);
        int v88 = 255;
        if (v25) {
          int v88 = *(unsigned __int8 *)(v86 + v159);
        }
        int v147 = v88;
        unint64_t v89 = v85 + v82;
        if (v26 < v85 + v82) {
          unint64_t v89 = v26;
        }
        if (v89 < v56) {
          unint64_t v89 = v56;
        }
        unsigned int v90 = *(unsigned __int8 *)(v89 + v162);
        unsigned int v91 = *(unsigned __int8 *)(v89 + v161);
        unsigned int v144 = *(unsigned __int8 *)(v89 + v163);
        int v92 = 255;
        if (v25) {
          int v92 = *(unsigned __int8 *)(v89 + v159);
        }
        int v145 = v92;
        int v93 = (v63 >> 28) & 3;
        int v94 = interpolate_rgba[4 * v66 + 3];
        char v95 = v66 + 1;
        unsigned int v96 = v60 - ((v94 & v60) >> v95) + ((v94 & v87) >> v95);
        unsigned __int8 v97 = interpolate_rgba[4 * v93 + 3];
        int v60 = v96
            - ((v96 & v97) >> (v93 + 1))
            + (((v81 - ((v94 & v81) >> v95) + ((v94 & v90) >> v95)) & v97) >> (v93 + 1));
        unsigned int v98 = v61 - ((v94 & v61) >> v95) + ((v94 & v143) >> v95);
        int v61 = v98
            - ((v98 & v97) >> (v93 + 1))
            + (((v83 - ((v94 & v83) >> v95) + ((v94 & v91) >> v95)) & v97) >> (v93 + 1));
        unsigned int v99 = v62 - ((v94 & v62) >> v95) + ((v94 & v146) >> v95);
        int v62 = v99
            - ((v99 & v97) >> (v93 + 1))
            + (((v148 - ((v94 & v148) >> v95) + ((v94 & v144) >> v95)) & v97) >> (v93 + 1));
        unsigned int v100 = v58 - ((v94 & v58) >> v95) + ((v94 & v147) >> v95);
        int v58 = v100
            - ((v100 & v97) >> (v93 + 1))
            + (((v149 - ((v94 & v149) >> v95) + ((v94 & v145) >> v95)) & v97) >> (v93 + 1));
        break;
    }
  }
  uint64_t v130 = 0;
  uint64_t v131 = 0;
  a3 += v24;
  uint64_t v132 = v154 - a3;
  a2 += v20;
  uint64_t v133 = v152 - a2;
  while (1)
  {
    *(_WORD *)(v156 + 2 + 2 * v131) = ((2 * v60
                                      + v62
                                      + 5 * v61) >> 3) | ((_WORD)v58 << 8);
    *(unsigned char *)(v155 + 1 + v131) = v37 >> 22;
    if (a4 - 1 == v131) {
      return result;
    }
    if ((v132 | v133 | (a3 - v153) | (a2 - v151)) < 0)
    {
      v155 += v131 + 1;
      uint64_t v156 = v156 - v130 + 2;
      int v59 = ~v131 + a4;
      goto LABEL_71;
    }
    if (v21)
    {
      uint64_t v134 = (v22 & ((v35 + v157) >> 63)) + v35 + v157;
      uint64_t v135 = (v21 & ((v44 + v158) >> 63)) + v44 + v158;
      if (v134 >= v22) {
        uint64_t v136 = v22;
      }
      else {
        uint64_t v136 = 0;
      }
      uint64_t v137 = v134 - v136;
      if (v135 >= v21) {
        uint64_t v138 = v21;
      }
      else {
        uint64_t v138 = 0;
      }
      uint64_t v44 = v135 - v138;
      uint64_t v35 = v137;
      uint64_t v139 = v135 - v138;
    }
    else
    {
      HIDWORD(v137) = HIDWORD(a3);
      uint64_t v139 = a2;
    }
    uint64_t v140 = v160 + SHIDWORD(v137) * (uint64_t)v19;
    uint64_t v141 = v139 >> 32;
    unint64_t v55 = v140 + 4 * v141;
    unint64_t v56 = *(void *)(result + 32);
    if (v26 >= v55) {
      unint64_t v142 = v140 + 4 * v141;
    }
    else {
      unint64_t v142 = v26;
    }
    if (v142 < v56) {
      unint64_t v142 = *(void *)(result + 32);
    }
    if (v25) {
      int v58 = *(unsigned __int8 *)(v142 + v159);
    }
    else {
      int v58 = 255;
    }
    int v60 = *(unsigned __int8 *)(v142 + v162);
    int v61 = *(unsigned __int8 *)(v142 + v161);
    int v62 = *(unsigned __int8 *)(v142 + v163);
    if (v23)
    {
      unsigned int v63 = *(_DWORD *)(v23 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v63 & 0xF) != 0)
      {
        v155 += v131 + 1;
        uint64_t v156 = v156 - v130 + 2;
        a4 += ~v131;
        unsigned int v37 = -1;
        goto LABEL_77;
      }
    }
    ++v131;
    v130 -= 2;
    a3 += v24;
    v132 -= v24;
    a2 += v20;
    v133 -= v20;
    unsigned int v37 = -1;
  }
}

void GRAYa8_sample_RGB48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGB48", 11451, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_rgb48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_rgb48", 11456, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBA64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGBA64", 11461, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_rgba64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_rgba64", 11466, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_WF", 11471, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_Wf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_Wf", 11476, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGBF", 11481, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGBf", 11486, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGBAF", 11491, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_RGBAf", 11496, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_CMYKF", 11501, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void GRAYa8_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("GRAYa8_sample_CMYKf", 11506, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

uint64_t PDAmultiplyPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4 = a3 * (a2 ^ 0xFF);
  if (a2 == 255) {
    int v4 = 0;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v4 + ((a4 ^ 0xFF) + a3) * a1 + ((v4 + ((a4 ^ 0xFF) + a3) * a1) >> 8) + 1) >> 8);
}

uint64_t PDAoverlayPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  if (a1 < (a2 + 1) >> 1) {
    unsigned int v4 = (a4 ^ 0xFF) * a1 + (2 * a1 + (a2 ^ 0xFF)) * a3;
  }
  else {
    unsigned int v4 = a3 * (a2 + 255) - (a4 * a2 + 2 * a1 * a3) + (a4 + 255) * a1;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v4 + (v4 >> 8) + 1) >> 8);
}

uint64_t PDAlightenPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4 = a1 * a4;
  if (a3 * a2 > v4) {
    unsigned int v4 = a3 * a2;
  }
  int v5 = (a4 ^ 0xFF) * a1;
  if (a4 == 255) {
    int v5 = 0;
  }
  int v6 = a3 * (a2 ^ 0xFF);
  if (a2 == 255) {
    int v6 = 0;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v5 + v4 + ((v6 + v5 + v4) >> 8) + 1) >> 8);
}

uint64_t PDAdarkenPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4 = a1 * a4;
  if (a3 * a2 < v4) {
    unsigned int v4 = a3 * a2;
  }
  int v5 = (a4 ^ 0xFF) * a1;
  if (a4 == 255) {
    int v5 = 0;
  }
  int v6 = a3 * (a2 ^ 0xFF);
  if (a2 == 255) {
    int v6 = 0;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v5 + v4 + ((v6 + v5 + v4) >> 8) + 1) >> 8);
}

uint64_t PDAcolordodgePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  if (a1)
  {
    if (a4 == a3) {
      int v4 = 65025;
    }
    else {
      int v4 = a1 * a4 * a4 / (a4 - a3);
    }
  }
  else
  {
    int v4 = 0;
  }
  int v5 = a3 * (a2 ^ 0xFF);
  if (a2 == 1) {
    int v5 = 0;
  }
  int v6 = v5 + (a4 ^ 0xFF) * a1 + v4;
  int v7 = 255 * (a4 + a2) - a4 * a2;
  if (v6 >= v7) {
    int v6 = 255 * (a4 + a2) - a4 * a2;
  }
  return (v7 + (v7 >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6
                                                                                              + (v6 >> 8)
                                                                                              + 1) >> 8);
}

uint64_t PDAcolorburnPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4 = a3 * (a2 ^ 0xFF);
  if (a2 == 255) {
    int v4 = 0;
  }
  unsigned int v5 = a4 * a2 + (a4 ^ 0xFF) * a1 + v4;
  if (a2 != a1)
  {
    if (a3) {
      unsigned int v5 = (v5 - (a2 - a1) * a4 * a4 / a3) & ~((int)(v5 - (a2 - a1) * a4 * a4 / a3) >> 31);
    }
    else {
      unsigned int v5 = 0;
    }
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + (v5 >> 8) + 1) >> 8);
}

uint64_t PDAhardlightPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4 = 2 * a1;
  unsigned int v5 = a3 * (a2 + 255) - (a4 * a2 + v4 * a3) + (a4 + 255) * a1;
  if (a3 <= (a4 + 1) >> 1) {
    unsigned int v5 = (a4 ^ 0xFF) * a1 + (v4 + (a2 ^ 0xFF)) * a3;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + (v5 >> 8) + 1) >> 8);
}

uint64_t PDAsoftlightPDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4 = 2 * a1 * a3 - a1 * a1 * (2 * a3 - a4) / a2;
  int v5 = v4 & ~(v4 >> 31);
  int v6 = (a4 ^ 0xFF) * a1;
  if (a4 == 255) {
    int v6 = 0;
  }
  int v7 = a3 * (a2 ^ 0xFF);
  if (a2 == 255) {
    int v7 = 0;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v6 + v7 + v5 + ((v6 + v7 + v5) >> 8) + 1) >> 8);
}

uint64_t PDAdifferencePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  int v4 = a1 * a4;
  int v5 = a3 * a2;
  int v7 = v4 - v5;
  BOOL v6 = v4 - v5 < 0;
  int v8 = 255 * (a3 + a1) - v4 - v5;
  if (v6) {
    int v9 = -v7;
  }
  else {
    int v9 = v7;
  }
  return (255 * (a4 + a2) - a4 * a2 + ((255 * (a4 + a2) - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v8 + v9 + ((v8 + v9) >> 8) + 1) >> 8);
}

uint64_t PDAhuePDA(unsigned __int8 a1, int a2, unsigned __int8 a3, int a4)
{
  unsigned int v4 = a1;
  if (a4 == 255)
  {
    int v5 = 0;
  }
  else
  {
    unsigned int v4 = (a1 * a4 + ((a1 * a4) >> 8) + 1) >> 8;
    int v5 = (a4 ^ 0xFF) * a1;
  }
  int v6 = (a2 ^ 0xFF) * a3;
  if (a2 == 255) {
    int v6 = 0;
  }
  return (a4 + a2 - a4 * a2 + ((a4 + a2 - a4 * a2) >> 8) + 1) & 0xFFFFFF00 | ((unsigned __int16)(v5 + v4 + v6 + ((v5 + v4 + v6) >> 8) + 1) >> 8);
}

uint64_t GRAYa8_mark_pixelmask(uint64_t result, int a2)
{
  uint64_t v3 = *(void *)(result + 136);
  if (!v3) {
    return result;
  }
  int v4 = *(_DWORD *)(result + 4);
  int v5 = *(_DWORD *)(result + 8);
  uint64_t v6 = v4;
  uint64_t v488 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v8 = *(void *)(result + 96);
  unint64_t v9 = (unint64_t)*(int *)(result + 28) >> 1;
  unsigned int v10 = (unsigned __int8 *)(*(void *)(result + 40) + 2 * (*(int *)(result + 12) + v9 * *(int *)(result + 16)));
  uint64_t v11 = *(int *)(result + 124);
  double v12 = (unsigned char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v11);
  uint64_t v13 = *(int *)(result + 56);
  uint64_t v14 = *(int *)(result + 60);
  unint64_t v15 = *(int *)(result + 76);
  if (*(unsigned __int8 *)(result + 1) << 8 == 256)
  {
    uint64_t v16 = v15 >> 1;
    uint64_t v17 = (unsigned __int8 *)(v7 + 2 * (v13 + (v15 >> 1) * v14));
    if (v15 >> 1 != v9)
    {
      int v19 = 1;
LABEL_14:
      int v20 = 0;
      uint64_t v6 = v19 * v4;
      BOOL v22 = v8 != 0;
      uint64_t v23 = v11 - v6;
      unint64_t v24 = v9 - v6;
      unint64_t v29 = -1;
      int v21 = v16;
      goto LABEL_15;
    }
    if (v10 - v17 >= 1)
    {
      if (v4 >= (uint64_t)((unint64_t)(v10 - v17) >> 1))
      {
        v10 += 2 * v4 - 2;
        v17 += 2 * v4 - 2;
        v12 += v4 - 1;
        int v19 = -1;
        goto LABEL_13;
      }
      uint64_t v18 = v5 - 1;
      if (v10 <= &v17[2 * v9 * v18 - 2 + 2 * v4])
      {
        v10 += 2 * v9 * v18;
        uint64_t v16 = -(uint64_t)v9;
        v12 += v11 * v18;
        uint64_t v11 = -v11;
        int v19 = 1;
        v17 += 2 * v9 * v18;
        unint64_t v9 = -(uint64_t)v9;
        goto LABEL_14;
      }
    }
    int v19 = 1;
LABEL_13:
    uint64_t v16 = (unint64_t)*(int *)(result + 28) >> 1;
    goto LABEL_14;
  }
  int v21 = *(_DWORD *)(result + 64);
  int v20 = *(_DWORD *)(result + 68);
  uint64_t v16 = v15 >> 1;
  BOOL v22 = v8 != 0;
  uint64_t v23 = v11 - v4;
  unint64_t v24 = v9 - v4;
  if (v7)
  {
    int v25 = 0;
    unint64_t v26 = v7 + 2 * v16 * v20;
    uint64_t v27 = v7 + 2 * v16 * ((int)v14 % v20);
    uint64_t v28 = (unsigned __int8 *)(v27 + 2 * ((int)v13 % v21));
    unint64_t v29 = v27 + 2 * v21;
    int v19 = 1;
    uint64_t v17 = v28;
    goto LABEL_16;
  }
  uint64_t v17 = 0;
  unint64_t v29 = 0;
  int v19 = 1;
LABEL_15:
  unint64_t v26 = 0;
  uint64_t v28 = 0;
  v16 -= v6;
  int v25 = 1;
LABEL_16:
  uint64_t v459 = v23;
  int v460 = *(_DWORD *)(result + 4);
  unint64_t v457 = v24;
  uint64_t v458 = v16;
  int v456 = v25;
  unint64_t v455 = v26;
  BOOL v487 = v22;
  switch(a2)
  {
    case 0:
      uint64_t v30 = v19;
      uint64_t v31 = 2 * v19;
      do
      {
        int v32 = v4;
        do
        {
          int v33 = *v12;
          if (*v12)
          {
            if (v33 == 255)
            {
              *(_WORD *)unsigned int v10 = 0;
            }
            else
            {
              int v34 = v33 ^ 0xFF;
              *unsigned int v10 = (unsigned __int16)(*v10 * (_WORD)v34 + ((*v10 * v34) >> 8) + 1) >> 8;
              v10[1] = (unsigned __int16)(v10[1] * (_WORD)v34 + ((v10[1] * v34) >> 8) + 1) >> 8;
            }
          }
          v12 += v30;
          v10 += v31;
          --v32;
        }
        while (v32);
        v12 += v23;
        v10 += 2 * v24;
        --v5;
      }
      while (v5);
      return result;
    case 1:
      if (v488) {
        char v35 = v22;
      }
      else {
        char v35 = 1;
      }
      uint64_t v36 = -(uint64_t)v21;
      uint64_t v37 = -(v16 * v20);
      uint64_t v38 = 2 * v19;
      if (v35)
      {
        do
        {
          int v39 = v4;
          do
          {
            int v40 = *v12;
            if (*v12)
            {
              if (v40 == 255)
              {
                *(_WORD *)unsigned int v10 = *(_WORD *)v17;
              }
              else
              {
                unsigned int v41 = *v17 * v40 + *v10 * (v40 ^ 0xFF);
                *unsigned int v10 = (unsigned __int16)(v41 + (v41 >> 8) + 1) >> 8;
                v10[1] = (unsigned __int16)(v17[1] * (_WORD)v40
                                          + v10[1] * (v40 ^ 0xFF)
                                          + ((v17[1] * v40 + v10[1] * (v40 ^ 0xFFu)) >> 8)
                                          + 1) >> 8;
              }
            }
            v12 += v19;
            uint64_t v42 = &v17[2 * v19];
            if ((unint64_t)v42 >= v29) {
              uint64_t v43 = v36;
            }
            else {
              uint64_t v43 = 0;
            }
            uint64_t v17 = &v42[2 * v43];
            v10 += v38;
            --v39;
          }
          while (v39);
          v12 += v23;
          v10 += 2 * v24;
          unint64_t v44 = (unint64_t)&v28[2 * v16];
          if (v44 >= v26) {
            uint64_t v45 = v37;
          }
          else {
            uint64_t v45 = 0;
          }
          uint64_t v46 = (unsigned __int8 *)(v44 + 2 * v45);
          uint64_t v47 = v29 + 2 * v45 + 2 * v16;
          if (v25)
          {
            v17 += 2 * v16;
          }
          else
          {
            unint64_t v29 = v47;
            uint64_t v28 = v46;
            uint64_t v17 = v46;
          }
          --v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          int v432 = v4;
          do
          {
            int v433 = *v12;
            if (*v12)
            {
              if (v433 == 255)
              {
                *unsigned int v10 = *v17;
                v10[1] = -1;
              }
              else
              {
                unsigned int v434 = *v10 * (v433 ^ 0xFF) + *v17 * v433;
                *unsigned int v10 = (unsigned __int16)(v434 + (v434 >> 8) + 1) >> 8;
                int v435 = v10[1] * (v433 ^ 0xFF) - v433;
                v10[1] = (unsigned __int16)(v435 + ((_WORD)v433 << 8) + ((v435 + (v433 << 8)) >> 8) + 1) >> 8;
              }
            }
            v12 += v19;
            float v436 = &v17[2 * v19];
            if ((unint64_t)v436 >= v29) {
              uint64_t v437 = v36;
            }
            else {
              uint64_t v437 = 0;
            }
            uint64_t v17 = &v436[2 * v437];
            v10 += v38;
            --v432;
          }
          while (v432);
          v12 += v23;
          v10 += 2 * v24;
          unint64_t v438 = (unint64_t)&v28[2 * v16];
          if (v438 >= v26) {
            uint64_t v439 = v37;
          }
          else {
            uint64_t v439 = 0;
          }
          float32x2_t v440 = (unsigned __int8 *)(v438 + 2 * v439);
          uint64_t v441 = v29 + 2 * v439 + 2 * v16;
          if (v25)
          {
            v17 += 2 * v16;
          }
          else
          {
            unint64_t v29 = v441;
            uint64_t v28 = v440;
            uint64_t v17 = v440;
          }
          --v5;
        }
        while (v5);
      }
      return result;
    case 2:
      uint64_t v48 = -(uint64_t)v21;
      uint64_t v49 = -(v16 * v20);
      while (1)
      {
        int v50 = v4;
        do
        {
          int v51 = *v12;
          if (!*v12) {
            goto LABEL_59;
          }
          if (v51 == 255)
          {
            int v52 = v17[1];
            if (!v17[1]) {
              goto LABEL_59;
            }
            if (v52 == 255)
            {
              *unsigned int v10 = *v17;
              v10[1] = -1;
              goto LABEL_59;
            }
            *unsigned int v10 = *v17 + ((unsigned __int16)(*v10 * (v52 ^ 0xFF) + ((*v10 * (v52 ^ 0xFFu)) >> 8) + 1) >> 8);
            unsigned int v54 = v52 + ((v10[1] * (v52 ^ 0xFF) + ((v10[1] * (v52 ^ 0xFFu)) >> 8) + 1) >> 8);
          }
          else
          {
            unsigned int v53 = v17[1] * v51 + ((v17[1] * v51) >> 8) + 1;
            if (!BYTE1(v53)) {
              goto LABEL_59;
            }
            *unsigned int v10 = ((unsigned __int16)(((v53 >> 8) ^ 0xFF) * *v10 + ((((v53 >> 8) ^ 0xFF) * *v10) >> 8) + 1) >> 8)
                 + ((unsigned __int16)(*v17 * (_WORD)v51 + ((*v17 * v51) >> 8) + 1) >> 8);
            unsigned int v54 = ((((v53 >> 8) ^ 0xFF) * v10[1] + ((((v53 >> 8) ^ 0xFF) * v10[1]) >> 8) + 1) >> 8) + (v53 >> 8);
          }
          v10[1] = v54;
LABEL_59:
          v12 += v19;
          unint64_t v55 = &v17[2 * v19];
          if ((unint64_t)v55 >= v29) {
            uint64_t v56 = v48;
          }
          else {
            uint64_t v56 = 0;
          }
          uint64_t v17 = &v55[2 * v56];
          v10 += 2 * v19;
          --v50;
        }
        while (v50);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v57 = (unint64_t)&v28[2 * v16];
        if (v57 >= v26) {
          uint64_t v58 = v49;
        }
        else {
          uint64_t v58 = 0;
        }
        int v59 = (unsigned __int8 *)(v57 + 2 * v58);
        uint64_t v60 = v29 + 2 * v58 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v60;
          uint64_t v28 = v59;
          uint64_t v17 = v59;
        }
        if (!--v5) {
          return result;
        }
      }
    case 3:
      uint64_t v61 = -(uint64_t)v21;
      uint64_t v62 = -(v16 * v20);
      do
      {
        unsigned int v63 = v10 + 1;
        int v64 = v4;
        do
        {
          int v65 = *v12;
          if (*v12)
          {
            if (v65 == 255)
            {
              int v66 = *v63;
              *(v63 - 1) = (unsigned __int16)(v66 * *v17 + ((v66 * *v17) >> 8) + 1) >> 8;
              if (v22) {
                int v67 = v17[1];
              }
              else {
                int v67 = 255;
              }
              uint64_t v73 = v10 + 1;
              unsigned int v74 = v67 * v66;
            }
            else
            {
              uint64_t result = *v17;
              int v68 = *v63;
              unsigned int v69 = (v68 * v65 + ((v68 * v65) >> 8) + 1) >> 8;
              int v70 = v65 ^ 0xFF;
              unsigned int v71 = *(v63 - 1) * v70 + v69 * result;
              *(v63 - 1) = (unsigned __int16)(v71 + (v71 >> 8) + 1) >> 8;
              if (v22) {
                int v72 = v17[1];
              }
              else {
                int v72 = 255;
              }
              unsigned int v74 = v68 * v70 + v69 * v72;
              uint64_t v73 = v63;
            }
            *uint64_t v73 = (unsigned __int16)(v74 + (v74 >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          uint64_t v75 = &v17[2 * v19];
          if ((unint64_t)v75 >= v29) {
            uint64_t v76 = v61;
          }
          else {
            uint64_t v76 = 0;
          }
          uint64_t v17 = &v75[2 * v76];
          v63 += 2 * v19;
          --v64;
        }
        while (v64);
        v12 += v23;
        unsigned int v10 = &v63[2 * v24 - 1];
        unint64_t v77 = (unint64_t)&v28[2 * v16];
        if (v77 >= v26) {
          uint64_t v78 = v62;
        }
        else {
          uint64_t v78 = 0;
        }
        unint64_t v79 = (unsigned __int8 *)(v77 + 2 * v78);
        uint64_t v80 = v29 + 2 * v78 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v80;
          uint64_t v28 = v79;
          uint64_t v17 = v79;
        }
        --v5;
      }
      while (v5);
      return result;
    case 4:
      uint64_t v81 = -(uint64_t)v21;
      uint64_t v82 = -(v16 * v20);
      do
      {
        unsigned int v83 = v10 + 1;
        int v84 = v4;
        do
        {
          int v85 = *v12;
          if (*v12)
          {
            if (v85 == 255)
            {
              int v86 = *v83 ^ 0xFF;
              *(v83 - 1) = (unsigned __int16)((*v83 ^ 0xFF) * *v17 + ((v86 * *v17) >> 8) + 1) >> 8;
              if (v22) {
                int v87 = v17[1];
              }
              else {
                int v87 = 255;
              }
              int v93 = v10 + 1;
              unsigned int v94 = v87 * v86;
            }
            else
            {
              uint64_t result = *v17;
              int v88 = *v83;
              unsigned int v89 = ((v88 ^ 0xFF) * v85 + (((v88 ^ 0xFFu) * v85) >> 8) + 1) >> 8;
              int v90 = v85 ^ 0xFF;
              unsigned int v91 = *(v83 - 1) * v90 + v89 * result;
              *(v83 - 1) = (unsigned __int16)(v91 + (v91 >> 8) + 1) >> 8;
              if (v22) {
                int v92 = v17[1];
              }
              else {
                int v92 = 255;
              }
              unsigned int v94 = v88 * v90 + v89 * v92;
              int v93 = v83;
            }
            *int v93 = (unsigned __int16)(v94 + (v94 >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          char v95 = &v17[2 * v19];
          if ((unint64_t)v95 >= v29) {
            uint64_t v96 = v81;
          }
          else {
            uint64_t v96 = 0;
          }
          uint64_t v17 = &v95[2 * v96];
          v83 += 2 * v19;
          --v84;
        }
        while (v84);
        v12 += v23;
        unsigned int v10 = &v83[2 * v24 - 1];
        unint64_t v97 = (unint64_t)&v28[2 * v16];
        if (v97 >= v26) {
          uint64_t v98 = v82;
        }
        else {
          uint64_t v98 = 0;
        }
        unsigned int v99 = (unsigned __int8 *)(v97 + 2 * v98);
        uint64_t v100 = v29 + 2 * v98 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v100;
          uint64_t v28 = v99;
          uint64_t v17 = v99;
        }
        --v5;
      }
      while (v5);
      return result;
    case 5:
      uint64_t v244 = -(uint64_t)v21;
      uint64_t v245 = -(v16 * v20);
      do
      {
        int v246 = v4;
        do
        {
          int v247 = *v12;
          if (*v12)
          {
            unsigned int v248 = (*v17 * v247 + ((*v17 * v247) >> 8) + 1) >> 8;
            unsigned int v249 = v17[1] * v247 + ((v17[1] * v247) >> 8) + 1;
            int v250 = v10[1];
            *unsigned int v10 = (unsigned __int16)(v248 * v250
                                    + ((v249 >> 8) ^ 0xFF) * *v10
                                    + ((v248 * v250 + ((v249 >> 8) ^ 0xFF) * *v10) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)((((v249 >> 8) ^ 0xFF) + (v249 >> 8)) * v250
                                      + (((((v249 >> 8) ^ 0xFF) + (v249 >> 8)) * v250) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          __int32 v251 = &v17[2 * v19];
          if ((unint64_t)v251 >= v29) {
            uint64_t v252 = v244;
          }
          else {
            uint64_t v252 = 0;
          }
          uint64_t v17 = &v251[2 * v252];
          v10 += 2 * v19;
          --v246;
        }
        while (v246);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v253 = (unint64_t)&v28[2 * v16];
        if (v253 >= v26) {
          uint64_t v254 = v245;
        }
        else {
          uint64_t v254 = 0;
        }
        float32x4_t v255 = (unsigned __int8 *)(v253 + 2 * v254);
        uint64_t v256 = v29 + 2 * v254 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v256;
          uint64_t v28 = v255;
          uint64_t v17 = v255;
        }
        --v5;
      }
      while (v5);
      return result;
    case 6:
      uint64_t v257 = -(uint64_t)v21;
      uint64_t v258 = -(v16 * v20);
      do
      {
        int v259 = v4;
        do
        {
          int v260 = *v12;
          if (*v12)
          {
            int v261 = v10[1];
            if ((_BYTE)v261 != 0xFF)
            {
              if (~(_BYTE)v261 == 255)
              {
                *unsigned int v10 = (unsigned __int16)(*v17 * (_WORD)v260 + ((*v17 * v260) >> 8) + 1) >> 8;
                if (v22) {
                  int v262 = v17[1];
                }
                else {
                  int v262 = 255;
                }
                unsigned int v265 = (v262 * v260 + ((v262 * v260) >> 8) + 1) >> 8;
              }
              else
              {
                uint64_t result = *v17;
                unsigned int v263 = (~(_BYTE)v261 * v260
                      + ((~(_BYTE)v261 * v260) >> 8)
                      + 1) >> 8;
                *v10 += (unsigned __int16)(v263 * result + ((v263 * result) >> 8) + 1) >> 8;
                if (v22) {
                  int v264 = v17[1];
                }
                else {
                  int v264 = 255;
                }
                unsigned int v265 = v261 + ((v263 * v264 + ((v263 * v264) >> 8) + 1) >> 8);
              }
              v10[1] = v265;
            }
          }
          v12 += v19;
          unsigned int v266 = &v17[2 * v19];
          if ((unint64_t)v266 >= v29) {
            uint64_t v267 = v257;
          }
          else {
            uint64_t v267 = 0;
          }
          uint64_t v17 = &v266[2 * v267];
          v10 += 2 * v19;
          --v259;
        }
        while (v259);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v268 = (unint64_t)&v28[2 * v16];
        if (v268 >= v26) {
          uint64_t v269 = v258;
        }
        else {
          uint64_t v269 = 0;
        }
        float v270 = (unsigned __int8 *)(v268 + 2 * v269);
        uint64_t v271 = v29 + 2 * v269 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v271;
          uint64_t v28 = v270;
          uint64_t v17 = v270;
        }
        --v5;
      }
      while (v5);
      return result;
    case 7:
      uint64_t v101 = -(uint64_t)v21;
      uint64_t v102 = -(v16 * v20);
      do
      {
        int v103 = v4;
        do
        {
          int v104 = *v12;
          if (*v12)
          {
            if (v104 == 255)
            {
              int v105 = v17[1];
              *unsigned int v10 = (unsigned __int16)(v105 * *v10 + ((v105 * *v10) >> 8) + 1) >> 8;
              unint64_t v107 = v10 + 1;
              unsigned int v106 = v10[1];
            }
            else
            {
              unsigned int v106 = (v104 ^ 0xFF) + ((v17[1] * v104 + ((v17[1] * v104) >> 8) + 1) >> 8);
              *unsigned int v10 = (unsigned __int16)(v106 * *v10 + ((v106 * *v10) >> 8) + 1) >> 8;
              unint64_t v107 = v10 + 1;
              int v105 = v10[1];
            }
            *unint64_t v107 = (unsigned __int16)(v106 * v105 + ((v106 * v105) >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          unsigned int v108 = &v17[2 * v19];
          if ((unint64_t)v108 >= v29) {
            uint64_t v109 = v101;
          }
          else {
            uint64_t v109 = 0;
          }
          uint64_t v17 = &v108[2 * v109];
          --v103;
        }
        while (v103);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v110 = (unint64_t)&v28[2 * v16];
        if (v110 >= v26) {
          uint64_t v111 = v102;
        }
        else {
          uint64_t v111 = 0;
        }
        int v112 = (unsigned __int8 *)(v110 + 2 * v111);
        uint64_t v113 = v29 + 2 * v111 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v113;
          uint64_t v28 = v112;
          uint64_t v17 = v112;
        }
        --v5;
      }
      while (v5);
      return result;
    case 8:
      uint64_t v272 = -(uint64_t)v21;
      uint64_t v273 = -(v16 * v20);
      do
      {
        int v274 = v4;
        do
        {
          int v275 = *v12;
          if (*v12)
          {
            if (v275 == 255)
            {
              int v276 = v17[1] ^ 0xFF;
              *unsigned int v10 = (unsigned __int16)(v276 * *v10 + ((v276 * *v10) >> 8) + 1) >> 8;
              int v278 = v10 + 1;
              unsigned int v277 = v10[1];
            }
            else
            {
              unsigned int v277 = ((v17[1] * v275 + ((v17[1] * v275) >> 8) + 1) >> 8) ^ 0xFF;
              *unsigned int v10 = (unsigned __int16)(v277 * *v10 + ((v277 * *v10) >> 8) + 1) >> 8;
              int v278 = v10 + 1;
              int v276 = v10[1];
            }
            *int v278 = (unsigned __int16)(v277 * v276 + ((v277 * v276) >> 8) + 1) >> 8;
          }
          v12 += v19;
          v10 += 2 * v19;
          unsigned int v279 = &v17[2 * v19];
          if ((unint64_t)v279 >= v29) {
            uint64_t v280 = v272;
          }
          else {
            uint64_t v280 = 0;
          }
          uint64_t v17 = &v279[2 * v280];
          --v274;
        }
        while (v274);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v281 = (unint64_t)&v28[2 * v16];
        if (v281 >= v26) {
          uint64_t v282 = v273;
        }
        else {
          uint64_t v282 = 0;
        }
        double v283 = (unsigned __int8 *)(v281 + 2 * v282);
        uint64_t v284 = v29 + 2 * v282 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v284;
          uint64_t v28 = v283;
          uint64_t v17 = v283;
        }
        --v5;
      }
      while (v5);
      return result;
    case 9:
      uint64_t v114 = -(uint64_t)v21;
      uint64_t v115 = -(v16 * v20);
      do
      {
        int v116 = v4;
        do
        {
          int v117 = *v12;
          if (*v12)
          {
            unsigned int v118 = (*v17 * v117 + ((*v17 * v117) >> 8) + 1) >> 8;
            unsigned int v119 = v17[1] * v117 + ((v17[1] * v117) >> 8) + 1;
            int v120 = v10[1];
            uint64_t result = *v10;
            int v121 = (~(_BYTE)v117 + BYTE1(v119));
            *unsigned int v10 = (unsigned __int16)(v118 * (v120 ^ 0xFF)
                                    + v121 * result
                                    + ((v118 * (v120 ^ 0xFF) + v121 * result) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)((v119 >> 8) * (v120 ^ 0xFF)
                                      + v121 * v120
                                      + (((v119 >> 8) * (v120 ^ 0xFF) + v121 * v120) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          unint64_t v122 = &v17[2 * v19];
          if ((unint64_t)v122 >= v29) {
            uint64_t v123 = v114;
          }
          else {
            uint64_t v123 = 0;
          }
          uint64_t v17 = &v122[2 * v123];
          v10 += 2 * v19;
          --v116;
        }
        while (v116);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v124 = (unint64_t)&v28[2 * v16];
        if (v124 >= v26) {
          uint64_t v125 = v115;
        }
        else {
          uint64_t v125 = 0;
        }
        unsigned int v126 = (unsigned __int8 *)(v124 + 2 * v125);
        uint64_t v127 = v29 + 2 * v125 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v127;
          uint64_t v28 = v126;
          uint64_t v17 = v126;
        }
        --v5;
      }
      while (v5);
      return result;
    case 10:
      uint64_t v285 = -(uint64_t)v21;
      uint64_t v286 = -(v16 * v20);
      do
      {
        int v287 = v4;
        do
        {
          int v288 = *v12;
          if (*v12)
          {
            unsigned int v289 = (*v17 * v288 + ((*v17 * v288) >> 8) + 1) >> 8;
            unsigned int v290 = (v17[1] * v288 + ((v17[1] * v288) >> 8) + 1) >> 8;
            int v291 = v10[1];
            uint64_t result = v291 ^ 0xFFu;
            *unsigned int v10 = (unsigned __int16)(v289 * (v291 ^ 0xFF)
                                    + (v290 ^ 0xFF) * *v10
                                    + ((v289 * (v291 ^ 0xFF) + (v290 ^ 0xFF) * *v10) >> 8)
                                    + 1) >> 8;
            v10[1] = (unsigned __int16)(v290 * (v291 ^ 0xFF)
                                      + (v290 ^ 0xFF) * v291
                                      + ((v290 * (v291 ^ 0xFF) + (v290 ^ 0xFF) * v291) >> 8)
                                      + 1) >> 8;
          }
          v12 += v19;
          __int32 v292 = &v17[2 * v19];
          if ((unint64_t)v292 >= v29) {
            uint64_t v293 = v285;
          }
          else {
            uint64_t v293 = 0;
          }
          uint64_t v17 = &v292[2 * v293];
          v10 += 2 * v19;
          --v287;
        }
        while (v287);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v294 = (unint64_t)&v28[2 * v16];
        if (v294 >= v26) {
          uint64_t v295 = v286;
        }
        else {
          uint64_t v295 = 0;
        }
        int v296 = (unsigned __int8 *)(v294 + 2 * v295);
        uint64_t v297 = v29 + 2 * v295 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v297;
          uint64_t v28 = v296;
          uint64_t v17 = v296;
        }
        --v5;
      }
      while (v5);
      return result;
    case 11:
      uint64_t v128 = -(uint64_t)v21;
      uint64_t v129 = -(v16 * v20);
      do
      {
        int v130 = v4;
        do
        {
          int v131 = *v12;
          if (*v12)
          {
            if (v488) {
              int v132 = v10[1];
            }
            else {
              int v132 = 255;
            }
            unsigned int v133 = *v17 * v131 + ((*v17 * v131) >> 8) + 1;
            uint64_t result = *v10;
            if (v22) {
              LOBYTE(v131) = (unsigned __int16)(v17[1] * (_WORD)v131 + ((v17[1] * v131) >> 8) + 1) >> 8;
            }
            unsigned int v134 = ((v131 - BYTE1(v133)) | (v131 << 16))
                 + (v132 - result)
                 + (v132 << 16);
            int v135 = (255 * ((v134 >> 8) & 0x10001)) | v134;
            *unsigned int v10 = BYTE2(v135) - v135;
            v10[1] = BYTE2(v135);
          }
          v12 += v19;
          uint64_t v136 = &v17[2 * v19];
          if ((unint64_t)v136 >= v29) {
            uint64_t v137 = v128;
          }
          else {
            uint64_t v137 = 0;
          }
          uint64_t v17 = &v136[2 * v137];
          v10 += 2 * v19;
          --v130;
        }
        while (v130);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v138 = (unint64_t)&v28[2 * v16];
        if (v138 >= v26) {
          uint64_t v139 = v129;
        }
        else {
          uint64_t v139 = 0;
        }
        uint64_t v140 = (unsigned __int8 *)(v138 + 2 * v139);
        uint64_t v141 = v29 + 2 * v139 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v141;
          uint64_t v28 = v140;
          uint64_t v17 = v140;
        }
        --v5;
      }
      while (v5);
      return result;
    case 12:
      uint64_t v142 = -(uint64_t)v21;
      uint64_t v143 = -(v16 * v20);
      do
      {
        int v144 = v4;
        do
        {
          int v145 = *v12;
          if (*v12)
          {
            unsigned int v146 = (*v17 * v145 + ((*v17 * v145) >> 8) + 1) >> 8;
            if (v22) {
              LOBYTE(v145) = (unsigned __int16)(v17[1] * (_WORD)v145 + ((v17[1] * v145) >> 8) + 1) >> 8;
            }
            unsigned int v147 = ((v146 + *(_WORD *)v10) | (*(unsigned __int16 *)v10 << 8) & 0xFF0000)
                 + (v145 << 16);
            int v148 = (255 * ((v147 >> 8) & 0x10001)) | v147;
            *unsigned int v10 = v148;
            v10[1] = BYTE2(v148);
          }
          v12 += v19;
          int v149 = &v17[2 * v19];
          if ((unint64_t)v149 >= v29) {
            uint64_t v150 = v142;
          }
          else {
            uint64_t v150 = 0;
          }
          uint64_t v17 = &v149[2 * v150];
          v10 += 2 * v19;
          --v144;
        }
        while (v144);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v151 = (unint64_t)&v28[2 * v16];
        if (v151 >= v26) {
          uint64_t v152 = v143;
        }
        else {
          uint64_t v152 = 0;
        }
        uint64_t v153 = (unsigned __int8 *)(v151 + 2 * v152);
        uint64_t v154 = v29 + 2 * v152 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v154;
          uint64_t v28 = v153;
          uint64_t v17 = v153;
        }
        --v5;
      }
      while (v5);
      return result;
    case 13:
      uint64_t v298 = v19;
      uint64_t v299 = -(uint64_t)v21;
      uint64_t v447 = -(v16 * v20);
      uint64_t v300 = 2 * v19;
      while (1)
      {
        int v466 = v28;
        int v479 = v5;
        int v301 = v4;
        do
        {
          int v302 = *v12;
          if (*v12)
          {
            unsigned int v303 = v17[1] * v302 + ((v17[1] * v302) >> 8) + 1;
            unsigned int v304 = v303 >> 8;
            if (!v22) {
              LOBYTE(v304) = *v12;
            }
            if ((_BYTE)v304)
            {
              unsigned int v305 = (*v17 * v302 + ((*v17 * v302) >> 8) + 1) >> 8;
              if (v488)
              {
                int v306 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v305;
                  v10[1] = v304;
                  goto LABEL_417;
                }
              }
              else
              {
                int v306 = 255;
              }
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | v303 & 0xFF00 | v305;
              uint64_t result = PDAmultiplyPDA(v2, v306, v26, v304);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_417:
          v12 += v298;
          int8x16_t v307 = &v17[2 * v298];
          if ((unint64_t)v307 >= v29) {
            uint64_t v308 = v299;
          }
          else {
            uint64_t v308 = 0;
          }
          uint64_t v17 = &v307[2 * v308];
          v10 += v300;
          --v301;
        }
        while (v301);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v466;
        unint64_t v309 = (unint64_t)&v466[2 * v458];
        uint64_t v310 = v447;
        if (v309 < v455) {
          uint64_t v310 = 0;
        }
        unsigned int v311 = (unsigned __int8 *)(v309 + 2 * v310);
        uint64_t v312 = v29 + 2 * v310 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v312;
          uint64_t v28 = v311;
          uint64_t v17 = v311;
        }
        int v5 = v479 - 1;
        int v4 = v460;
        if (v479 == 1) {
          return result;
        }
      }
    case 14:
      uint64_t v155 = -(uint64_t)v21;
      uint64_t v156 = -(v16 * v20);
      while (1)
      {
        int v157 = v4;
        do
        {
          int v158 = *v12;
          if (*v12)
          {
            unsigned int v159 = (v17[1] * v158 + ((v17[1] * v158) >> 8) + 1) >> 8;
            if (!v22) {
              LOBYTE(v159) = *v12;
            }
            if ((_BYTE)v159)
            {
              unsigned int v160 = (*v17 * v158 + ((*v17 * v158) >> 8) + 1) >> 8;
              if (v488)
              {
                int v161 = v10[1];
                if (!v10[1]) {
                  goto LABEL_206;
                }
              }
              else
              {
                int v161 = 255;
              }
              int v162 = *v10;
              uint64_t result = v162 ^ 0xFFu;
              unsigned int v160 = (result * v160
                    - v162
                    + (v162 << 8)
                    + ((result * v160 - v162 + (v162 << 8)) >> 8)
                    + 1) >> 8;
              unsigned int v159 = (255 * (v161 + v159)
                    - v161 * v159
                    + ((255 * (v161 + v159) - v161 * v159) >> 8)
                    + 1) >> 8;
LABEL_206:
              *unsigned int v10 = v160;
              v10[1] = v159;
            }
          }
          v12 += v19;
          uint64_t v163 = &v17[2 * v19];
          if ((unint64_t)v163 >= v29) {
            uint64_t v164 = v155;
          }
          else {
            uint64_t v164 = 0;
          }
          uint64_t v17 = &v163[2 * v164];
          v10 += 2 * v19;
          --v157;
        }
        while (v157);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v165 = (unint64_t)&v28[2 * v16];
        if (v165 >= v26) {
          uint64_t v166 = v156;
        }
        else {
          uint64_t v166 = 0;
        }
        vImagePixelCount v167 = (unsigned __int8 *)(v165 + 2 * v166);
        uint64_t v168 = v29 + 2 * v166 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v168;
          uint64_t v28 = v167;
          uint64_t v17 = v167;
        }
        if (!--v5) {
          return result;
        }
      }
    case 15:
      uint64_t v169 = v19;
      uint64_t v170 = -(uint64_t)v21;
      uint64_t v442 = -(v16 * v20);
      uint64_t v171 = 2 * v19;
      while (1)
      {
        float v461 = v28;
        int v474 = v5;
        int v172 = v4;
        do
        {
          int v173 = *v12;
          if (*v12)
          {
            unsigned int v174 = v17[1] * v173 + ((v17[1] * v173) >> 8) + 1;
            unsigned int v175 = v174 >> 8;
            if (!v22) {
              LOBYTE(v175) = *v12;
            }
            if ((_BYTE)v175)
            {
              unsigned int v176 = (*v17 * v173 + ((*v17 * v173) >> 8) + 1) >> 8;
              if (v488)
              {
                int v177 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v176;
                  v10[1] = v175;
                  goto LABEL_230;
                }
              }
              else
              {
                int v177 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v174 & 0xFF00 | v176;
              uint64_t result = PDAoverlayPDA(v26, v177, v2, v175);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_230:
          v12 += v169;
          unsigned int v178 = &v17[2 * v169];
          if ((unint64_t)v178 >= v29) {
            uint64_t v179 = v170;
          }
          else {
            uint64_t v179 = 0;
          }
          uint64_t v17 = &v178[2 * v179];
          v10 += v171;
          --v172;
        }
        while (v172);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v461;
        unint64_t v180 = (unint64_t)&v461[2 * v458];
        uint64_t v181 = v442;
        if (v180 < v455) {
          uint64_t v181 = 0;
        }
        float v182 = (unsigned __int8 *)(v180 + 2 * v181);
        uint64_t v183 = v29 + 2 * v181 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v183;
          uint64_t v28 = v182;
          uint64_t v17 = v182;
        }
        int v5 = v474 - 1;
        int v4 = v460;
        if (v474 == 1) {
          return result;
        }
      }
    case 16:
      uint64_t v184 = v19;
      uint64_t v185 = -(uint64_t)v21;
      uint64_t v443 = -(v16 * v20);
      uint64_t v186 = 2 * v19;
      while (1)
      {
        unsigned int v462 = v28;
        int v475 = v5;
        int v187 = v4;
        do
        {
          int v188 = *v12;
          if (*v12)
          {
            unsigned int v189 = v17[1] * v188 + ((v17[1] * v188) >> 8) + 1;
            unsigned int v190 = v189 >> 8;
            if (!v22) {
              LOBYTE(v190) = *v12;
            }
            if ((_BYTE)v190)
            {
              unsigned int v191 = (*v17 * v188 + ((*v17 * v188) >> 8) + 1) >> 8;
              if (v488)
              {
                int v192 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v191;
                  v10[1] = v190;
                  goto LABEL_252;
                }
              }
              else
              {
                int v192 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v189 & 0xFF00 | v191;
              uint64_t result = PDAdarkenPDA(v26, v192, v2, v190);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_252:
          v12 += v184;
          unsigned int v193 = &v17[2 * v184];
          if ((unint64_t)v193 >= v29) {
            uint64_t v194 = v185;
          }
          else {
            uint64_t v194 = 0;
          }
          uint64_t v17 = &v193[2 * v194];
          v10 += v186;
          --v187;
        }
        while (v187);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v462;
        unint64_t v195 = (unint64_t)&v462[2 * v458];
        uint64_t v196 = v443;
        if (v195 < v455) {
          uint64_t v196 = 0;
        }
        double v197 = (unsigned __int8 *)(v195 + 2 * v196);
        uint64_t v198 = v29 + 2 * v196 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v198;
          uint64_t v28 = v197;
          uint64_t v17 = v197;
        }
        int v5 = v475 - 1;
        int v4 = v460;
        if (v475 == 1) {
          return result;
        }
      }
    case 17:
      uint64_t v313 = v19;
      uint64_t v314 = -(uint64_t)v21;
      uint64_t v448 = -(v16 * v20);
      uint64_t v315 = 2 * v19;
      while (1)
      {
        uint64_t v467 = v28;
        int v480 = v5;
        int v316 = v4;
        do
        {
          int v317 = *v12;
          if (*v12)
          {
            unsigned int v318 = v17[1] * v317 + ((v17[1] * v317) >> 8) + 1;
            unsigned int v319 = v318 >> 8;
            if (!v22) {
              LOBYTE(v319) = *v12;
            }
            if ((_BYTE)v319)
            {
              unsigned int v320 = (*v17 * v317 + ((*v17 * v317) >> 8) + 1) >> 8;
              if (v488)
              {
                int v321 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v320;
                  v10[1] = v319;
                  goto LABEL_439;
                }
              }
              else
              {
                int v321 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v318 & 0xFF00 | v320;
              uint64_t result = PDAlightenPDA(v26, v321, v2, v319);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_439:
          v12 += v313;
          float32x4_t v322 = &v17[2 * v313];
          if ((unint64_t)v322 >= v29) {
            uint64_t v323 = v314;
          }
          else {
            uint64_t v323 = 0;
          }
          uint64_t v17 = &v322[2 * v323];
          v10 += v315;
          --v316;
        }
        while (v316);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v467;
        unint64_t v324 = (unint64_t)&v467[2 * v458];
        uint64_t v325 = v448;
        if (v324 < v455) {
          uint64_t v325 = 0;
        }
        uint64_t v326 = (unsigned __int8 *)(v324 + 2 * v325);
        uint64_t v327 = v29 + 2 * v325 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v327;
          uint64_t v28 = v326;
          uint64_t v17 = v326;
        }
        int v5 = v480 - 1;
        int v4 = v460;
        if (v480 == 1) {
          return result;
        }
      }
    case 18:
      uint64_t v328 = v19;
      uint64_t v329 = -(uint64_t)v21;
      uint64_t v449 = -(v16 * v20);
      uint64_t v330 = 2 * v19;
      while (1)
      {
        unint64_t v468 = v28;
        int v481 = v5;
        int v331 = v4;
        do
        {
          int v332 = *v12;
          if (*v12)
          {
            unsigned int v333 = v17[1] * v332 + ((v17[1] * v332) >> 8) + 1;
            unsigned int v334 = v333 >> 8;
            if (!v22) {
              LOBYTE(v334) = *v12;
            }
            if ((_BYTE)v334)
            {
              unsigned int v335 = (*v17 * v332 + ((*v17 * v332) >> 8) + 1) >> 8;
              if (v488)
              {
                int v336 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v335;
                  v10[1] = v334;
                  goto LABEL_461;
                }
              }
              else
              {
                int v336 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v333 & 0xFF00 | v335;
              uint64_t result = PDAcolordodgePDA(v26, v336, v2, v334);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_461:
          v12 += v328;
          double v337 = &v17[2 * v328];
          if ((unint64_t)v337 >= v29) {
            uint64_t v338 = v329;
          }
          else {
            uint64_t v338 = 0;
          }
          uint64_t v17 = &v337[2 * v338];
          v10 += v330;
          --v331;
        }
        while (v331);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v468;
        unint64_t v339 = (unint64_t)&v468[2 * v458];
        uint64_t v340 = v449;
        if (v339 < v455) {
          uint64_t v340 = 0;
        }
        uint64_t v341 = (unsigned __int8 *)(v339 + 2 * v340);
        uint64_t v342 = v29 + 2 * v340 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v342;
          uint64_t v28 = v341;
          uint64_t v17 = v341;
        }
        int v5 = v481 - 1;
        int v4 = v460;
        if (v481 == 1) {
          return result;
        }
      }
    case 19:
      uint64_t v343 = v19;
      uint64_t v344 = -(uint64_t)v21;
      uint64_t v450 = -(v16 * v20);
      uint64_t v345 = 2 * v19;
      while (1)
      {
        uint64_t v469 = v28;
        int v482 = v5;
        int v346 = v4;
        do
        {
          int v347 = *v12;
          if (*v12)
          {
            unsigned int v348 = v17[1] * v347 + ((v17[1] * v347) >> 8) + 1;
            unsigned int v349 = v348 >> 8;
            if (!v22) {
              LOBYTE(v349) = *v12;
            }
            if ((_BYTE)v349)
            {
              unsigned int v350 = (*v17 * v347 + ((*v17 * v347) >> 8) + 1) >> 8;
              if (v488)
              {
                int v351 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v350;
                  v10[1] = v349;
                  goto LABEL_483;
                }
              }
              else
              {
                int v351 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v348 & 0xFF00 | v350;
              uint64_t result = PDAcolorburnPDA(v26, v351, v2, v349);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_483:
          v12 += v343;
          double v352 = &v17[2 * v343];
          if ((unint64_t)v352 >= v29) {
            uint64_t v353 = v344;
          }
          else {
            uint64_t v353 = 0;
          }
          uint64_t v17 = &v352[2 * v353];
          v10 += v345;
          --v346;
        }
        while (v346);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v469;
        unint64_t v354 = (unint64_t)&v469[2 * v458];
        uint64_t v355 = v450;
        if (v354 < v455) {
          uint64_t v355 = 0;
        }
        uint64_t v356 = (unsigned __int8 *)(v354 + 2 * v355);
        uint64_t v357 = v29 + 2 * v355 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v357;
          uint64_t v28 = v356;
          uint64_t v17 = v356;
        }
        int v5 = v482 - 1;
        int v4 = v460;
        if (v482 == 1) {
          return result;
        }
      }
    case 20:
      uint64_t v358 = v19;
      uint64_t v359 = -(uint64_t)v21;
      uint64_t v451 = -(v16 * v20);
      uint64_t v360 = 2 * v19;
      while (1)
      {
        uint64_t v470 = v28;
        int v483 = v5;
        int v361 = v4;
        do
        {
          int v362 = *v12;
          if (*v12)
          {
            unsigned int v363 = v17[1] * v362 + ((v17[1] * v362) >> 8) + 1;
            unsigned int v364 = v363 >> 8;
            if (!v22) {
              LOBYTE(v364) = *v12;
            }
            if ((_BYTE)v364)
            {
              unsigned int v365 = (*v17 * v362 + ((*v17 * v362) >> 8) + 1) >> 8;
              if (v488)
              {
                int v366 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v365;
                  v10[1] = v364;
                  goto LABEL_505;
                }
              }
              else
              {
                int v366 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v363 & 0xFF00 | v365;
              uint64_t result = PDAsoftlightPDA(v26, v366, v2, v364);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_505:
          v12 += v358;
          int8x16_t v367 = &v17[2 * v358];
          if ((unint64_t)v367 >= v29) {
            uint64_t v368 = v359;
          }
          else {
            uint64_t v368 = 0;
          }
          uint64_t v17 = &v367[2 * v368];
          v10 += v360;
          --v361;
        }
        while (v361);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v470;
        uint64_t v369 = v451;
        if ((unint64_t)v470 < v455) {
          uint64_t v369 = 0;
        }
        unint64_t v370 = v29 + 2 * v369;
        double v371 = &v470[2 * v369];
        unint64_t v372 = v370 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v372;
          uint64_t v28 = v371;
          uint64_t v17 = v371;
        }
        int v5 = v483 - 1;
        int v4 = v460;
        if (v483 == 1) {
          return result;
        }
      }
    case 21:
      uint64_t v373 = v19;
      uint64_t v374 = -(uint64_t)v21;
      uint64_t v452 = -(v16 * v20);
      uint64_t v375 = 2 * v19;
      while (1)
      {
        uint64_t v471 = v28;
        int v484 = v5;
        int v376 = v4;
        do
        {
          int v377 = *v12;
          if (*v12)
          {
            unsigned int v378 = v17[1] * v377 + ((v17[1] * v377) >> 8) + 1;
            unsigned int v379 = v378 >> 8;
            if (!v22) {
              LOBYTE(v379) = *v12;
            }
            if ((_BYTE)v379)
            {
              unsigned int v380 = (*v17 * v377 + ((*v17 * v377) >> 8) + 1) >> 8;
              if (v488)
              {
                int v381 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v380;
                  v10[1] = v379;
                  goto LABEL_527;
                }
              }
              else
              {
                int v381 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v378 & 0xFF00 | v380;
              uint64_t result = PDAhardlightPDA(v26, v381, v2, v379);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_527:
          v12 += v373;
          uint64_t v382 = &v17[2 * v373];
          if ((unint64_t)v382 >= v29) {
            uint64_t v383 = v374;
          }
          else {
            uint64_t v383 = 0;
          }
          uint64_t v17 = &v382[2 * v383];
          v10 += v375;
          --v376;
        }
        while (v376);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v471;
        unint64_t v384 = (unint64_t)&v471[2 * v458];
        uint64_t v385 = v452;
        if (v384 < v455) {
          uint64_t v385 = 0;
        }
        float v386 = (unsigned __int8 *)(v384 + 2 * v385);
        uint64_t v387 = v29 + 2 * v385 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v387;
          uint64_t v28 = v386;
          uint64_t v17 = v386;
        }
        int v5 = v484 - 1;
        int v4 = v460;
        if (v484 == 1) {
          return result;
        }
      }
    case 22:
      uint64_t v388 = v19;
      uint64_t v389 = -(uint64_t)v21;
      uint64_t v453 = -(v16 * v20);
      uint64_t v390 = 2 * v19;
      while (1)
      {
        uint64_t v472 = v28;
        int v485 = v5;
        int v391 = v4;
        do
        {
          int v392 = *v12;
          if (*v12)
          {
            unsigned int v393 = v17[1] * v392 + ((v17[1] * v392) >> 8) + 1;
            unsigned int v394 = v393 >> 8;
            if (!v22) {
              LOBYTE(v394) = *v12;
            }
            if ((_BYTE)v394)
            {
              unsigned int v395 = (*v17 * v392 + ((*v17 * v392) >> 8) + 1) >> 8;
              if (v488)
              {
                int v396 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v395;
                  v10[1] = v394;
                  goto LABEL_549;
                }
              }
              else
              {
                int v396 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v393 & 0xFF00 | v395;
              uint64_t result = PDAdifferencePDA(v26, v396, v2, v394);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_549:
          v12 += v388;
          uint64_t v397 = &v17[2 * v388];
          if ((unint64_t)v397 >= v29) {
            uint64_t v398 = v389;
          }
          else {
            uint64_t v398 = 0;
          }
          uint64_t v17 = &v397[2 * v398];
          v10 += v390;
          --v391;
        }
        while (v391);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v472;
        unint64_t v399 = (unint64_t)&v472[2 * v458];
        uint64_t v400 = v453;
        if (v399 < v455) {
          uint64_t v400 = 0;
        }
        int v401 = (unsigned __int8 *)(v399 + 2 * v400);
        uint64_t v402 = v29 + 2 * v400 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v402;
          uint64_t v28 = v401;
          uint64_t v17 = v401;
        }
        int v5 = v485 - 1;
        int v4 = v460;
        if (v485 == 1) {
          return result;
        }
      }
    case 23:
      uint64_t v403 = -(uint64_t)v21;
      uint64_t v404 = -(v16 * v20);
      while (1)
      {
        int v405 = v4;
        do
        {
          int v406 = *v12;
          if (*v12)
          {
            unsigned int v407 = (v17[1] * v406 + ((v17[1] * v406) >> 8) + 1) >> 8;
            if (!v22) {
              LOBYTE(v407) = *v12;
            }
            if ((_BYTE)v407)
            {
              unsigned int v408 = (*v17 * v406 + ((*v17 * v406) >> 8) + 1) >> 8;
              if (v488)
              {
                int v409 = v10[1];
                if (!v10[1]) {
                  goto LABEL_571;
                }
              }
              else
              {
                int v409 = 255;
              }
              int v410 = *v10;
              uint64_t result = 255 * (v408 + v410);
              unsigned int v408 = (result - 2 * v408 * v410 + ((result - 2 * v408 * v410) >> 8) + 1) >> 8;
              unsigned int v407 = (255 * (v409 + v407)
                    - v409 * v407
                    + ((255 * (v409 + v407) - v409 * v407) >> 8)
                    + 1) >> 8;
LABEL_571:
              *unsigned int v10 = v408;
              v10[1] = v407;
            }
          }
          v12 += v19;
          uint64_t v411 = &v17[2 * v19];
          if ((unint64_t)v411 >= v29) {
            uint64_t v412 = v403;
          }
          else {
            uint64_t v412 = 0;
          }
          uint64_t v17 = &v411[2 * v412];
          v10 += 2 * v19;
          --v405;
        }
        while (v405);
        v12 += v23;
        v10 += 2 * v24;
        unint64_t v413 = (unint64_t)&v28[2 * v16];
        if (v413 >= v26) {
          uint64_t v414 = v404;
        }
        else {
          uint64_t v414 = 0;
        }
        uint64_t v415 = (unsigned __int8 *)(v413 + 2 * v414);
        uint64_t v416 = v29 + 2 * v414 + 2 * v16;
        if (v25)
        {
          v17 += 2 * v16;
        }
        else
        {
          unint64_t v29 = v416;
          uint64_t v28 = v415;
          uint64_t v17 = v415;
        }
        if (!--v5) {
          return result;
        }
      }
    case 24:
      uint64_t v199 = v19;
      uint64_t v200 = -(uint64_t)v21;
      uint64_t v444 = -(v16 * v20);
      uint64_t v201 = 2 * v19;
      while (1)
      {
        float32x2_t v463 = v28;
        int v476 = v5;
        int v202 = v4;
        do
        {
          int v203 = *v12;
          if (*v12)
          {
            unsigned int v204 = v17[1] * v203 + ((v17[1] * v203) >> 8) + 1;
            unsigned int v205 = v204 >> 8;
            if (!v22) {
              LOBYTE(v205) = *v12;
            }
            if ((_BYTE)v205)
            {
              unsigned int v206 = (*v17 * v203 + ((*v17 * v203) >> 8) + 1) >> 8;
              if (v488)
              {
                int v207 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v206;
                  v10[1] = v205;
                  goto LABEL_274;
                }
              }
              else
              {
                int v207 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v204 & 0xFF00 | v206;
              uint64_t result = PDAhuePDA(v26, v207, v2, v205);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_274:
          v12 += v199;
          double v208 = &v17[2 * v199];
          if ((unint64_t)v208 >= v29) {
            uint64_t v209 = v200;
          }
          else {
            uint64_t v209 = 0;
          }
          uint64_t v17 = &v208[2 * v209];
          v10 += v201;
          --v202;
        }
        while (v202);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v463;
        unint64_t v210 = (unint64_t)&v463[2 * v458];
        uint64_t v211 = v444;
        if (v210 < v455) {
          uint64_t v211 = 0;
        }
        unsigned int v212 = (unsigned __int8 *)(v210 + 2 * v211);
        uint64_t v213 = v29 + 2 * v211 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v213;
          uint64_t v28 = v212;
          uint64_t v17 = v212;
        }
        int v5 = v476 - 1;
        int v4 = v460;
        if (v476 == 1) {
          return result;
        }
      }
    case 25:
      uint64_t v214 = v19;
      uint64_t v215 = -(uint64_t)v21;
      uint64_t v445 = -(v16 * v20);
      uint64_t v216 = 2 * v19;
      while (1)
      {
        uint8x8_t v464 = v28;
        int v477 = v5;
        int v217 = v4;
        do
        {
          int v218 = *v12;
          if (*v12)
          {
            unsigned int v219 = v17[1] * v218 + ((v17[1] * v218) >> 8) + 1;
            unsigned int v220 = v219 >> 8;
            if (!v22) {
              LOBYTE(v220) = *v12;
            }
            if ((_BYTE)v220)
            {
              unsigned int v221 = (*v17 * v218 + ((*v17 * v218) >> 8) + 1) >> 8;
              if (v488)
              {
                int v222 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v221;
                  v10[1] = v220;
                  goto LABEL_296;
                }
              }
              else
              {
                int v222 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v219 & 0xFF00 | v221;
              uint64_t result = PDAhuePDA(v26, v222, v2, v220);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_296:
          v12 += v214;
          float v223 = &v17[2 * v214];
          if ((unint64_t)v223 >= v29) {
            uint64_t v224 = v215;
          }
          else {
            uint64_t v224 = 0;
          }
          uint64_t v17 = &v223[2 * v224];
          v10 += v216;
          --v217;
        }
        while (v217);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v464;
        unint64_t v225 = (unint64_t)&v464[2 * v458];
        uint64_t v226 = v445;
        if (v225 < v455) {
          uint64_t v226 = 0;
        }
        __int32 v227 = (unsigned __int8 *)(v225 + 2 * v226);
        uint64_t v228 = v29 + 2 * v226 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v228;
          uint64_t v28 = v227;
          uint64_t v17 = v227;
        }
        int v5 = v477 - 1;
        int v4 = v460;
        if (v477 == 1) {
          return result;
        }
      }
    case 26:
      uint64_t v417 = v19;
      uint64_t v418 = -(uint64_t)v21;
      uint64_t v454 = -(v16 * v20);
      uint64_t v419 = 2 * v19;
      while (1)
      {
        int v473 = v28;
        int v486 = v5;
        int v420 = v4;
        do
        {
          int v421 = *v12;
          if (*v12)
          {
            unsigned int v422 = v17[1] * v421 + ((v17[1] * v421) >> 8) + 1;
            unsigned int v423 = v422 >> 8;
            if (!v22) {
              LOBYTE(v423) = *v12;
            }
            if ((_BYTE)v423)
            {
              unsigned int v424 = (*v17 * v421 + ((*v17 * v421) >> 8) + 1) >> 8;
              if (v488)
              {
                int v425 = v10[1];
                if (!v10[1])
                {
                  *unsigned int v10 = v424;
                  v10[1] = v423;
                  goto LABEL_595;
                }
              }
              else
              {
                int v425 = 255;
              }
              unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | v422 & 0xFF00 | v424;
              unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
              uint64_t result = PDAhuePDA(v26, v423, v2, v425);
              BOOL v22 = v487;
              *(_WORD *)unsigned int v10 = result;
            }
          }
LABEL_595:
          v12 += v417;
          uint64_t v426 = &v17[2 * v417];
          if ((unint64_t)v426 >= v29) {
            uint64_t v427 = v418;
          }
          else {
            uint64_t v427 = 0;
          }
          uint64_t v17 = &v426[2 * v427];
          v10 += v419;
          --v420;
        }
        while (v420);
        v12 += v459;
        v10 += 2 * v457;
        uint64_t v28 = v473;
        unint64_t v428 = (unint64_t)&v473[2 * v458];
        uint64_t v429 = v454;
        if (v428 < v455) {
          uint64_t v429 = 0;
        }
        uint64_t v430 = (unsigned __int8 *)(v428 + 2 * v429);
        uint64_t v431 = v29 + 2 * v429 + 2 * v458;
        if (v456)
        {
          v17 += 2 * v458;
        }
        else
        {
          unint64_t v29 = v431;
          uint64_t v28 = v430;
          uint64_t v17 = v430;
        }
        int v5 = v486 - 1;
        int v4 = v460;
        if (v486 == 1) {
          return result;
        }
      }
    case 27:
      uint64_t v229 = v19;
      uint64_t v230 = -(uint64_t)v21;
      uint64_t v446 = -(v16 * v20);
      uint64_t v231 = 2 * v19;
      break;
    default:
      return result;
  }
  do
  {
    uint64_t v465 = v28;
    int v478 = v5;
    int v232 = v4;
    do
    {
      int v233 = *v12;
      if (*v12)
      {
        unsigned int v234 = v17[1] * v233 + ((v17[1] * v233) >> 8) + 1;
        unsigned int v235 = v234 >> 8;
        if (!v22) {
          LOBYTE(v235) = *v12;
        }
        if ((_BYTE)v235)
        {
          unsigned int v236 = (*v17 * v233 + ((*v17 * v233) >> 8) + 1) >> 8;
          if (v488)
          {
            int v237 = v10[1];
            if (!v10[1])
            {
              *unsigned int v10 = v236;
              v10[1] = v235;
              goto LABEL_318;
            }
          }
          else
          {
            int v237 = 255;
          }
          unint64_t v26 = v26 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v10;
          unint64_t v2 = v2 & 0xFFFFFFFFFFFF0000 | v234 & 0xFF00 | v236;
          uint64_t result = PDAhuePDA(v26, v237, v2, v235);
          BOOL v22 = v487;
          *(_WORD *)unsigned int v10 = result;
        }
      }
LABEL_318:
      v12 += v229;
      unsigned int v238 = &v17[2 * v229];
      if ((unint64_t)v238 >= v29) {
        uint64_t v239 = v230;
      }
      else {
        uint64_t v239 = 0;
      }
      uint64_t v17 = &v238[2 * v239];
      v10 += v231;
      --v232;
    }
    while (v232);
    v12 += v459;
    v10 += 2 * v457;
    uint64_t v28 = v465;
    unint64_t v240 = (unint64_t)&v465[2 * v458];
    uint64_t v241 = v446;
    if (v240 < v455) {
      uint64_t v241 = 0;
    }
    __int32 v242 = (unsigned __int8 *)(v240 + 2 * v241);
    uint64_t v243 = v29 + 2 * v241 + 2 * v458;
    if (v456)
    {
      v17 += 2 * v458;
    }
    else
    {
      unint64_t v29 = v243;
      uint64_t v28 = v242;
      uint64_t v17 = v242;
    }
    int v5 = v478 - 1;
    int v4 = v460;
  }
  while (v478 != 1);
  return result;
}

uint64_t GRAYA8_sample_W8_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v104 = *(void *)(result + 80);
  uint64_t v106 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 2;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v13 = *(_DWORD *)(result + 260) - 1;
  uint64_t v14 = *(unsigned int *)(result + 256);
  uint64_t v15 = v4 + v14 + (v13 * v6);
  uint64_t v16 = (__int8 *)(v5 + v14 + (v13 * v7));
  uint64_t v17 = (unsigned __int8 *)(v15 - 1);
  int v103 = *(_DWORD *)(result + 188);
  uint64_t v102 = (unsigned __int8 *)(v15 - 4);
  uint64_t v105 = *(void *)(result + 64);
  uint64_t v107 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v107)
      {
        if (a3 <= v106)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v106;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_39;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          unsigned int v27 = v103 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v107 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_39;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v27 = v103 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v105) {
        break;
      }
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v105 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 >= 1)
      {
        if (v31 < v29) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v103;
        }
        uint64_t v32 = v30 + 0x1000000;
        uint64_t v33 = 32;
        goto LABEL_26;
      }
LABEL_39:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 2;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v104)
    {
      uint64_t v33 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v32 = a2;
      goto LABEL_26;
    }
    uint64_t v34 = *(void *)(result + 192);
    uint64_t v35 = *(void *)(result + 200) + v104;
    uint64_t v36 = v35 - a2 + (v34 >> 1);
    if (v36 < 1) {
      goto LABEL_39;
    }
    if (v36 < v34) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v103;
    }
    uint64_t v32 = v35 - 0x1000000;
    uint64_t v33 = 28;
LABEL_26:
    if (v27 < 0x400000) {
      goto LABEL_39;
    }
    uint64_t v37 = v28 >> 32;
    uint64_t v38 = v4 + SHIDWORD(v28) * (uint64_t)v6;
    unint64_t v39 = v38 + (v32 >> 32);
    int v40 = *(unsigned __int8 **)(result + 32);
    if ((unint64_t)v17 >= v39) {
      unsigned int v41 = (unsigned __int8 *)(v38 + (v32 >> 32));
    }
    else {
      unsigned int v41 = v17;
    }
    if (v41 < v40) {
      unsigned int v41 = *(unsigned __int8 **)(result + 32);
    }
    if (v5)
    {
      unint64_t v42 = v5 + (int)v37 * (uint64_t)v7 + (v32 >> 32);
      uint64_t v43 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v42) {
        unint64_t v44 = (unsigned __int8 *)v42;
      }
      else {
        unint64_t v44 = (unsigned __int8 *)v16;
      }
      if (v44 >= v43) {
        uint64_t v43 = v44;
      }
      int v45 = *v43;
    }
    else
    {
      unint64_t v42 = 0;
      int v45 = 255;
    }
    v46.i32[0] = *v41;
    v46.i32[1] = v45;
    if (!v8) {
      goto LABEL_101;
    }
    unsigned int v47 = *(_DWORD *)(v8 + (v33 | v26));
LABEL_45:
    int v48 = v47 & 0xF;
    unsigned int v49 = HIBYTE(v47) & 3;
    int8x8_t v50 = vand_s8((int8x8_t)v46, (int8x8_t)0xFF000000FFLL);
    switch(v48)
    {
      case 1:
        uint64_t v78 = (unsigned __int8 *)(v39 + SBYTE1(v47) * (uint64_t)v6);
        if (v102 < v78) {
          uint64_t v78 = v102;
        }
        if (v78 < v40) {
          uint64_t v78 = v40;
        }
        unsigned int v79 = *v78;
        int v80 = 255;
        if (v5)
        {
          uint64_t v81 = (__int8 *)(v42 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v81) {
            uint64_t v81 = v16;
          }
          if ((unint64_t)v81 < *(void *)(result + 40)) {
            uint64_t v81 = *(__int8 **)(result + 40);
          }
          int v80 = *v81;
        }
        int8x8_t v82 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v49 + 1]);
        uint32x2_t v83 = (uint32x2_t)vand_s8(v82, v50);
        int32x2_t v84 = vdup_n_s32(v49 + 1);
LABEL_99:
        uint32x2_t v88 = (uint32x2_t)vneg_s32(v84);
        int32x2_t v76 = vsub_s32(v46, (int32x2_t)vshl_u32(v83, v88));
        int32x2_t v77 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v82, (int8x8_t)__PAIR64__(v80, v79)), v88);
LABEL_100:
        int32x2_t v46 = vadd_s32(v76, v77);
        break;
      case 2:
        int v85 = (unsigned __int8 *)(v39 + SBYTE2(v47));
        if (v17 < v85) {
          int v85 = v17;
        }
        if (v85 < v40) {
          int v85 = v40;
        }
        unsigned int v79 = *v85;
        int v80 = 255;
        if (v5)
        {
          int v86 = (__int8 *)(v42 + SBYTE2(v47));
          if (v16 < v86) {
            int v86 = v16;
          }
          if ((unint64_t)v86 < *(void *)(result + 40)) {
            int v86 = *(__int8 **)(result + 40);
          }
          int v80 = *v86;
        }
        unsigned int v87 = (v47 >> 28) & 3;
        int8x8_t v82 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v87 + 1]);
        uint32x2_t v83 = (uint32x2_t)vand_s8(v82, v50);
        int32x2_t v84 = vdup_n_s32(v87 + 1);
        goto LABEL_99;
      case 3:
        int v51 = (unsigned __int8 *)(v39 + SBYTE2(v47));
        if (v17 < v51) {
          int v51 = v17;
        }
        if (v51 < v40) {
          int v51 = v40;
        }
        unsigned int v52 = *v51;
        unint64_t v53 = v39 + SBYTE1(v47) * (uint64_t)v6;
        if ((unint64_t)v17 >= v53) {
          unsigned int v54 = (unsigned __int8 *)(v39 + SBYTE1(v47) * (uint64_t)v6);
        }
        else {
          unsigned int v54 = v17;
        }
        if (v54 < v40) {
          unsigned int v54 = v40;
        }
        __int32 v55 = *v54;
        uint64_t v56 = (unsigned __int8 *)(v53 + SBYTE2(v47));
        if (v17 < v56) {
          uint64_t v56 = v17;
        }
        if (v56 < v40) {
          uint64_t v56 = v40;
        }
        __int32 v57 = *v56;
        int32x2_t v58 = (int32x2_t)0xFF000000FFLL;
        int v59 = 255;
        if (v5)
        {
          uint64_t v60 = (__int8 *)(v42 + SBYTE2(v47));
          unint64_t v61 = *(void *)(result + 40);
          if (v16 < v60) {
            uint64_t v60 = v16;
          }
          if ((unint64_t)v60 < v61) {
            uint64_t v60 = *(__int8 **)(result + 40);
          }
          int v59 = *v60;
          unint64_t v62 = v42 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v62) {
            unsigned int v63 = (__int8 *)(v42 + SBYTE1(v47) * (uint64_t)v7);
          }
          else {
            unsigned int v63 = v16;
          }
          if ((unint64_t)v63 < v61) {
            unsigned int v63 = *(__int8 **)(result + 40);
          }
          int v64 = (__int8 *)(v62 + SBYTE2(v47));
          if (v16 < v64) {
            int v64 = v16;
          }
          if ((unint64_t)v64 < v61) {
            int v64 = *(__int8 **)(result + 40);
          }
          v58.i8[0] = *v63;
          v58.i8[4] = *v64;
        }
        unsigned int v65 = (v47 >> 28) & 3;
        int8x8_t v66 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v49 + 1]);
        uint32x2_t v67 = (uint32x2_t)vneg_s32(vdup_n_s32(v49 + 1));
        int32x2_t v68 = vsub_s32(v46, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, v50), v67));
        int32x2_t v69 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, (int8x8_t)__PAIR64__(v59, v52)), v67);
        int32x2_t v70 = vsub_s32((int32x2_t)__PAIR64__(v59, v52), v69);
        v69.i32[0] = v55;
        int8x8_t v71 = vand_s8(v66, (int8x8_t)0xFF000000FFLL);
        int32x2_t v72 = vadd_s32(v68, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v71, (int8x8_t)vzip1_s32(v69, v58)), v67));
        v58.i32[0] = v57;
        int8x8_t v73 = (int8x8_t)vadd_s32(v70, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v71, (int8x8_t)v58), v67));
        int8x8_t v74 = vand_s8((int8x8_t)vdup_n_s32(interpolate_graya[2 * v65 + 1]), (int8x8_t)0xFF000000FFLL);
        uint32x2_t v75 = (uint32x2_t)vneg_s32(vdup_n_s32(v65 + 1));
        int32x2_t v76 = vsub_s32(v72, (int32x2_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v72, v74), v75));
        int32x2_t v77 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v73, v74), v75);
        goto LABEL_100;
    }
LABEL_101:
    *(unsigned char *)(v11 + 2) = v46.i8[0];
    v11 += 2;
    *(unsigned char *)(v11 + 1) = v46.i8[4];
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v89 = 0;
    int v90 = a4 - 1;
    a2 += v10;
    uint64_t v91 = v104 - a2;
    a3 += v9;
    uint64_t v92 = v106 - a3;
    --a4;
    while (1)
    {
      uint64_t v93 = v12 + v89 + 1;
      if ((v92 | v91 | (a3 - v107) | (a2 - v105)) < 0) {
        break;
      }
      uint64_t v94 = v4 + SHIDWORD(a3) * (uint64_t)v6;
      unint64_t v39 = v94 + (a2 >> 32);
      int v40 = *(unsigned __int8 **)(result + 32);
      if ((unint64_t)v17 >= v39) {
        char v95 = (unsigned __int8 *)(v94 + (a2 >> 32));
      }
      else {
        char v95 = v17;
      }
      if (v95 >= v40) {
        uint64_t v96 = v95;
      }
      else {
        uint64_t v96 = *(unsigned __int8 **)(result + 32);
      }
      if (v5)
      {
        unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        unint64_t v97 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v42) {
          unint64_t v98 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        }
        else {
          unint64_t v98 = (unint64_t)v16;
        }
        if (v98 >= (unint64_t)v97) {
          unint64_t v97 = (unsigned __int8 *)v98;
        }
        int v99 = *v97;
      }
      else
      {
        int v99 = 255;
      }
      unsigned int v100 = *v96;
      if (v8)
      {
        unsigned int v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          int32x2_t v46 = (int32x2_t)__PAIR64__(v99, v100);
          unsigned int v27 = -1;
          uint64_t v12 = v93;
          goto LABEL_45;
        }
      }
      --a4;
      *(unsigned char *)(v11 + 2) = v100;
      v11 += 2;
      *(unsigned char *)(v11 + 1) = v99;
      uint64_t v101 = v12 + v89++;
      a2 += v10;
      *(unsigned char *)(v101 + 2) = -1;
      v91 -= v10;
      a3 += v9;
      v92 -= v9;
      if (v90 == v89) {
        return result;
      }
    }
    v12 += v89 + 1;
  }
  while (a4);
  return result;
}

void GRAYA8_shade_custom_Gray(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v8 = *(float32x2_t *)(a1 + 280);
  *(float32x2_t *)a7.unint64_t i8 = vadd_f32(*(float32x2_t *)(a1 + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(a1 + 288), *(float *)(*(void *)(a1 + 272) + 4) * (float)a3), v8, *(float *)(*(void *)(a1 + 272) + 4) * (float)a2));
  float32x4_t v33 = *(float32x4_t *)(a1 + 304);
  float v9 = *(float *)(a1 + 336);
  float v10 = *(float *)(a1 + 348);
  float v11 = *(float *)(a1 + 344);
  float v12 = *(float *)(a1 + 356);
  uint64_t v14 = *(char **)(a1 + 144);
  int v13 = *(unsigned char **)(a1 + 152);
  uint64_t v15 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v16 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v16 = *(float **)(a1 + 272);
  }
  uint64_t v17 = *(void *)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 40);
  if (v18) {
    int v19 = *(_DWORD *)(a1 + 48);
  }
  else {
    int v19 = 0;
  }
  if (v18) {
    uint64_t v20 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v20 = *(void *)(a1 + 272);
  }
  int v21 = 3 * *(_DWORD *)(a1 + 48);
  do
  {
    float32x4_t v22 = (float32x4_t)vzip1q_s32(a7, a7);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v33, v22))), vmovn_s32(vcgtq_f32(v22, v33))), 0xFuLL))) & 1) == 0)
    {
      int v26 = (int)(float)(v12 * (float)(*(float *)&a7.i32[1] - v10));
      int v27 = (int)(float)(v11 * (float)(*(float *)a7.i32 - v9));
      uint64_t v28 = v17 + 4 * v21 * v26;
      uint64_t v29 = v27;
      uint64_t v30 = v20 + 4 * v19 * v26;
      if (!v18) {
        uint64_t v29 = 0;
      }
      float v23 = *(float *)(v30 + 4 * v29);
      int32x4_t v34 = a7;
      if (v18) {
        float v31 = *(float *)(v30 + 4 * v29);
      }
      else {
        float v31 = 1.0;
      }
      float v24 = *(float *)(v28 + 4 * v27) * v31;
      unint64_t v25 = v13;
      goto LABEL_20;
    }
    if (v15)
    {
      float v23 = *v16;
      float v24 = *v16 * *v15;
      unint64_t v25 = v13;
      int32x4_t v34 = a7;
LABEL_20:
      SHADE(v25, v24, v23);
      a7 = v34;
      char v32 = -1;
      goto LABEL_22;
    }
    char v32 = 0;
LABEL_22:
    *(float32x2_t *)a7.unint64_t i8 = vadd_f32(v8, *(float32x2_t *)a7.i8);
    v13 += 2;
    *v14++ = v32;
    --a4;
  }
  while (a4);
}

void GRAYA8_shade_conic_Gray(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (unsigned char *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  do
  {
    __n128 v31 = a6;
    float v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    signed int v18 = vcvtms_s32_f32(v17);
    float v19 = ceilf(v17);
    unsigned int v20 = vcvtms_s32_f32(v9 + v17);
    float v21 = v17 - (float)(int)floorf(v17);
    if (v17 < 0.0) {
      signed int v18 = v20;
    }
    float v22 = ceilf(v17 - v9);
    if (v17 <= v9) {
      float v23 = v19;
    }
    else {
      float v23 = v22;
    }
    int v24 = (int)v23;
    uint64_t v25 = v18;
    if (!*(void *)&v14) {
      uint64_t v25 = 0;
    }
    float v26 = *(float *)(*(void *)&v13 + 4 * v18);
    uint64_t v27 = v24;
    if (v14)
    {
      float v28 = *(float *)(*(void *)&v15 + 4 * v25);
    }
    else
    {
      uint64_t v27 = 0;
      float v28 = 1.0;
    }
    float v29 = v26 * v28;
    if (v14) {
      float v30 = *(float *)(*(void *)&v15 + 4 * v27);
    }
    else {
      float v30 = 1.0;
    }
    SHADE(v11, v29 + (float)(v21 * (float)((float)(*(float *)(*(void *)&v13 + 4 * v24) * v30) - v29)), *(float *)(*(void *)&v15 + 4 * v25)+ (float)(v21 * (float)(*(float *)(*(void *)&v15 + 4 * v27) - *(float *)(*(void *)&v15 + 4 * v25))));
    a6.n128_u64[1] = v31.n128_u64[1];
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v31.n128_u64[0]);
    v11 += 2;
    *v12++ = -1;
    --a4;
  }
  while (a4);
}

void GRAYA8_shade_radial_Gray(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = a4;
  uint64_t v5 = *(float **)(a1 + 400);
  float v6 = *(float *)(a1 + 280);
  float v7 = *(float *)(a1 + 284);
  float v8 = *(float *)(*(void *)(a1 + 272) + 4);
  float v9 = v8 * (float)a2;
  float v10 = v8 * (float)a3;
  float v11 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v10) + (float)(v6 * v9));
  float v12 = *(float *)(a1 + 300) + (float)((float)(v10 * *(float *)(a1 + 292)) + (float)(v7 * v9));
  float v91 = *(float *)(a1 + 344);
  float v92 = *(float *)(a1 + 336);
  float v93 = *(float *)(a1 + 304);
  float v13 = *(float *)(a1 + 308);
  uint64_t v14 = *(unsigned int *)(a1 + 324);
  float v15 = v5[2];
  float v16 = v5[5];
  float v88 = v5[4];
  float v17 = v5[7];
  signed int v18 = *(char **)(a1 + 144);
  float v19 = *(unsigned char **)(a1 + 152);
  unsigned int v20 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    float v21 = *(float **)(a1 + 392);
  }
  else {
    float v21 = *(float **)(a1 + 272);
  }
  uint64_t v22 = *(void *)(a1 + 40);
  uint64_t v95 = *(void *)(a1 + 32);
  if (v22) {
    uint64_t v23 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v23 = *(void *)(a1 + 272);
  }
  if (v15 != 0.0 || v17 != 0.0 || v7 != 0.0)
  {
    unsigned int v28 = *(_DWORD *)(a1 + 320);
    float v89 = v5[3];
    float v29 = -v5[6];
    float v85 = v13 - v93;
    float v86 = v5[8];
    while (1)
    {
      float v30 = v29 + (float)((float)(v11 + v11) * v15);
      float v31 = (float)((float)(v12 * v12) + (float)(v11 * v11)) - v17;
      if (v16 == 0.0)
      {
        float v38 = v31 / v30;
      }
      else
      {
        float v32 = (float)((float)(v16 * -4.0) * v31) + (float)(v30 * v30);
        if (v32 < 0.0) {
          goto LABEL_51;
        }
        float v33 = sqrtf(v32);
        float v34 = v86 * (float)(v30 - v33);
        float v35 = v30 + v33;
        float v36 = v86 * v35;
        BOOL v37 = (float)(v86 * v35) <= v34;
        if ((float)(v86 * v35) <= v34) {
          float v38 = v86 * v35;
        }
        else {
          float v38 = v34;
        }
        if (v37) {
          float v36 = v34;
        }
        if (v36 < 0.0)
        {
          BOOL v39 = v36 < v89;
LABEL_33:
          unsigned int v40 = v28;
          if (v39) {
            goto LABEL_51;
          }
LABEL_34:
          if ((v40 & 0x80000000) == 0) {
            goto LABEL_46;
          }
          goto LABEL_51;
        }
        if (v36 <= 1.0)
        {
          float v41 = v93 + (float)(v36 * v85);
          goto LABEL_45;
        }
        if ((v14 & 0x80000000) == 0)
        {
          unsigned int v40 = v14;
          if (v36 <= v88)
          {
LABEL_46:
            uint64_t v42 = v40;
            if (!v22) {
              uint64_t v42 = 0;
            }
            float v43 = *(float *)(v23 + 4 * v42);
            float v44 = 1.0;
            if (v22) {
              float v44 = *(float *)(v23 + 4 * v42);
            }
            float v45 = *(float *)(v95 + 4 * v40) * v44;
            goto LABEL_53;
          }
        }
      }
      if (v38 < 0.0)
      {
        BOOL v39 = v38 < v89;
        goto LABEL_33;
      }
      if (v38 > 1.0)
      {
        unsigned int v40 = v14;
        if (v38 > v88) {
          goto LABEL_51;
        }
        goto LABEL_34;
      }
      float v41 = v93 + (float)(v38 * v85);
LABEL_45:
      unsigned int v40 = (int)(float)(v91 * (float)(v41 - v92));
      if ((v40 & 0x80000000) == 0) {
        goto LABEL_46;
      }
LABEL_51:
      if (!v20)
      {
        char v46 = 0;
        goto LABEL_55;
      }
      float v43 = *v21;
      float v45 = *v21 * *v20;
LABEL_53:
      SHADE(v19, v45, v43);
      char v46 = -1;
LABEL_55:
      float v11 = v6 + v11;
      float v12 = v7 + v12;
      v19 += 2;
      *v18++ = v46;
      if (!--v4) {
        return;
      }
    }
  }
  float v24 = v12 * v12;
  float v25 = -v16;
  if ((float)(v12 * v12) <= (float)-v16)
  {
    float v94 = fabsf(v5[8]);
    float v90 = v16 * -4.0;
    float v47 = v13 - v93;
    if (v22) {
      uint64_t v48 = *(unsigned int *)(a1 + 324);
    }
    else {
      uint64_t v48 = 0;
    }
    uint64_t v87 = v48;
    int v49 = a4 + 2;
    while (1)
    {
      float v50 = v24 + (float)(v11 * v11);
      float v51 = v6 + v11;
      float v52 = v24 + (float)(v51 * v51);
      if (v50 <= v25 || v52 <= v25)
      {
        float v54 = v94 * sqrtf(v90 * v50);
        float v55 = v94 * sqrtf(v90 * v52);
        uint64_t v56 = (int)(float)(v91 * (float)((float)(v93 + (float)(v54 * v47)) - v92));
        uint64_t v57 = (int)(float)(v91 * (float)((float)(v93 + (float)(v55 * v47)) - v92));
        if (v54 > 1.0 || v55 > 1.0)
        {
          if (v54 <= 1.0)
          {
            if ((v56 & 0x80000000) != 0) {
              goto LABEL_102;
            }
            if (v22) {
              uint64_t v59 = (int)(float)(v91 * (float)((float)(v93 + (float)(v54 * v47)) - v92));
            }
            else {
              uint64_t v59 = 0;
            }
          }
          else if (v54 > v88 || (v59 = v87, uint64_t v56 = v14, (v14 & 0x80000000) != 0))
          {
LABEL_102:
            if (v20)
            {
              float v72 = *v21;
              float v74 = *v21 * *v20;
              goto LABEL_104;
            }
            char v71 = 0;
LABEL_105:
            if (v55 <= 1.0)
            {
              if ((v57 & 0x80000000) != 0) {
                goto LABEL_117;
              }
              if (v22) {
                uint64_t v75 = (int)(float)(v91 * (float)((float)(v93 + (float)(v55 * v47)) - v92));
              }
              else {
                uint64_t v75 = 0;
              }
            }
            else if (v55 > v88 || (v75 = v87, uint64_t v57 = v14, (v14 & 0x80000000) != 0))
            {
LABEL_117:
              if (!v20) {
                goto LABEL_124;
              }
              float v76 = *v21;
              float v78 = *v21 * *v20;
              goto LABEL_119;
            }
            float v76 = *(float *)(v23 + 4 * v75);
            if (v22) {
              float v77 = *(float *)(v23 + 4 * v75);
            }
            else {
              float v77 = 1.0;
            }
            float v78 = *(float *)(v95 + 4 * v57) * v77;
LABEL_119:
            SHADE(v19 + 2, v78, v76);
            goto LABEL_120;
          }
          float v72 = *(float *)(v23 + 4 * v59);
          if (v22) {
            float v73 = *(float *)(v23 + 4 * v59);
          }
          else {
            float v73 = 1.0;
          }
          float v74 = *(float *)(v95 + 4 * v56) * v73;
LABEL_104:
          SHADE(v19, v74, v72);
          char v71 = -1;
          goto LABEL_105;
        }
        uint64_t v63 = (int)v56;
        if (!v22) {
          uint64_t v63 = 0;
        }
        float v64 = *(float *)(v23 + 4 * v63);
        float v65 = *(float *)(v95 + 4 * (int)v56);
        uint64_t v66 = (int)v57;
        if (v22) {
          float v67 = *(float *)(v23 + 4 * v63);
        }
        else {
          float v67 = 1.0;
        }
        float v68 = v65 * v67;
        if (!v22) {
          uint64_t v66 = 0;
        }
        float v60 = *(float *)(v23 + 4 * v66);
        if (v22) {
          float v69 = *(float *)(v23 + 4 * v66);
        }
        else {
          float v69 = 1.0;
        }
        float v62 = *(float *)(v95 + 4 * (int)v57) * v69;
        int32x2_t v70 = v19;
      }
      else
      {
        if ((v14 & 0x80000000) != 0)
        {
          if (!v20)
          {
            char v71 = 0;
LABEL_124:
            char v79 = 0;
            goto LABEL_121;
          }
          float v60 = *v21;
          float v62 = *v21 * *v20;
        }
        else
        {
          float v60 = *(float *)(v23 + 4 * v87);
          if (v22) {
            float v61 = *(float *)(v23 + 4 * v87);
          }
          else {
            float v61 = 1.0;
          }
          float v62 = *(float *)(v95 + 4 * v14) * v61;
        }
        int32x2_t v70 = v19;
        float v68 = v62;
        float v64 = v60;
      }
      SHADE(v70, v68, v64);
      SHADE(v19 + 2, v62, v60);
      char v71 = -1;
LABEL_120:
      char v79 = -1;
LABEL_121:
      float v11 = v6 + v51;
      v19 += 4;
      *signed int v18 = v71;
      v18[1] = v79;
      v18 += 2;
      v49 -= 2;
      if (v49 <= 2) {
        return;
      }
    }
  }
  if (v20 || (v14 & 0x80000000) == 0)
  {
    if ((v14 & 0x80000000) != 0)
    {
      float v81 = *v21;
      float v83 = *v21 * *v20;
    }
    else
    {
      if (v22) {
        uint64_t v80 = *(unsigned int *)(a1 + 324);
      }
      else {
        uint64_t v80 = 0;
      }
      float v81 = *(float *)(v23 + 4 * v80);
      float v82 = 1.0;
      if (v22) {
        float v82 = *(float *)(v23 + 4 * v80);
      }
      float v83 = *(float *)(v95 + 4 * v14) * v82;
    }
    int v84 = a4 + 4;
    do
    {
      SHADE(v19, v83, v81);
      SHADE(v19 + 2, v83, v81);
      SHADE(v19 + 4, v83, v81);
      SHADE(v19 + 6, v83, v81);
      *(_DWORD *)signed int v18 = -1;
      v18 += 4;
      v84 -= 4;
      v19 += 8;
    }
    while (v84 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v26 = 4;
    }
    else {
      int v26 = a4;
    }
    uint64_t v27 = *(void **)(a1 + 144);
    bzero(v27, ((a4 - v26 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t GRAYA8_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, int8x8_t a7, double a8, int8x8_t a9, int8x8_t a10, uint32x2_t a11)
{
  uint64_t v11 = *(void *)(result + 32);
  int v12 = *(_DWORD *)(result + 24);
  uint64_t v13 = *(void *)(result + 176);
  uint64_t v14 = *(void *)(result + 72);
  uint64_t v15 = *(void *)(result + 88);
  uint64_t v81 = *(void *)(result + 64);
  uint64_t v82 = *(void *)(result + 80);
  uint64_t v16 = *(void *)(result + 112);
  uint64_t v17 = *(void *)(result + 120);
  int v80 = *(_DWORD *)(result + 188);
  uint64_t v18 = *(void *)(result + 152) - 2;
  uint64_t v19 = *(void *)(result + 144) - 1;
  unint64_t v20 = v11 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v12) - 3;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v14)
    {
      if ((uint64_t)a3 <= v15)
      {
        uint64_t v29 = (a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        HIDWORD(v31) = HIDWORD(a3);
        uint64_t v32 = v81;
      }
      else
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = *(void *)(result + 224) + v15;
        uint64_t v27 = v26 - a3 + (v25 >> 1);
        if (v27 < 1) {
          goto LABEL_34;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        uint64_t v32 = v81;
        unsigned int v30 = v28 | v80;
        uint64_t v31 = v26 - 0x1000000;
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(result + 216);
      uint64_t v22 = v14 - *(void *)(result + 224);
      uint64_t v23 = a3 - v22 + (v21 >> 1);
      if (v23 < 1) {
        goto LABEL_34;
      }
      if (v23 >= v21) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
      }
      uint64_t v32 = v81;
      unsigned int v30 = v24 | v80;
      uint64_t v31 = v22 + 0x1000000;
      uint64_t v29 = 512;
    }
    if (a2 >= v32) {
      break;
    }
    uint64_t v33 = *(void *)(result + 192);
    uint64_t v34 = v32 - *(void *)(result + 200);
    uint64_t v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v80;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v16;
    a3 += v17;
    v18 += 2;
    *(unsigned char *)++uint64_t v19 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v82)
  {
    uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v36 = a2;
    goto LABEL_26;
  }
  uint64_t v38 = *(void *)(result + 192);
  uint64_t v39 = *(void *)(result + 200) + v82;
  uint64_t v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1) {
    goto LABEL_34;
  }
  if (v40 < v38) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v80;
  }
  uint64_t v36 = v39 - 0x1000000;
  uint64_t v37 = 28;
LABEL_26:
  if (v30 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v41 = v11 + SHIDWORD(v31) * (uint64_t)v12;
  uint64_t v42 = 3 * (v36 >> 32);
  uint64_t v43 = v41 + v42;
  float v44 = *(__int8 **)(result + 32);
  if (v20 >= v41 + v42) {
    float v45 = (__int8 *)(v41 + v42);
  }
  else {
    float v45 = (__int8 *)v20;
  }
  if (v45 < v44) {
    float v45 = *(__int8 **)(result + 32);
  }
  a7.i8[0] = *v45;
  a7.i8[4] = v45[1];
  unsigned int v46 = v45[2];
  if (!v13) {
    goto LABEL_66;
  }
  unsigned int v47 = *(_DWORD *)(v13 + (v37 | v29));
LABEL_37:
  int v48 = v47 & 0xF;
  unsigned int v49 = HIBYTE(v47) & 3;
  int8x8_t v50 = vand_s8(a7, (int8x8_t)0xFF000000FFLL);
  if (v48 == 1)
  {
    float v68 = (__int8 *)(v43 + SBYTE1(v47) * (uint64_t)v12);
    if (v20 < (unint64_t)v68) {
      float v68 = (__int8 *)v20;
    }
    if (v68 < v44) {
      float v68 = v44;
    }
    unsigned int v69 = interpolate_rgba[4 * interpolate_rgba[4 * v49 + 3] + 3];
    a9.i8[0] = *v68;
    a9.i8[4] = v68[1];
    a10 = (int8x8_t)vdup_n_s32(v69);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(interpolate_rgba[4 * v49 + 3] + 1));
    a7 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a10, v50), a11)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(vand_s8(a10, (int8x8_t)0xFF000000FFLL), a9), a11));
    LOBYTE(v46) = a7.i8[0] + ((v69 & v68[2]) >> (interpolate_rgba[4 * v49 + 3] + 1));
    goto LABEL_66;
  }
  if (v48 == 2)
  {
    int32x2_t v70 = (__int8 *)(v43 + 3 * SBYTE2(v47));
    if (v20 < (unint64_t)v70) {
      int32x2_t v70 = (__int8 *)v20;
    }
    if (v70 < v44) {
      int32x2_t v70 = v44;
    }
    unsigned int v71 = (v47 >> 28) & 3;
    unsigned int v72 = interpolate_rgba[4 * v71++ + 3];
    a9.i8[0] = *v70;
    a9.i8[4] = v70[1];
    a10 = (int8x8_t)vdup_n_s32(v72);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(v71));
    a7 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a10, v50), a11)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(vand_s8(a10, (int8x8_t)0xFF000000FFLL), a9), a11));
    LOBYTE(v46) = a7.i8[0] + ((v72 & v70[2]) >> v71);
LABEL_66:
    LOWORD(v51) = 255;
    goto LABEL_67;
  }
  LOWORD(v51) = 255;
  if (v48 == 3)
  {
    uint64_t v52 = 3 * SBYTE2(v47);
    unint64_t v53 = (__int8 *)(v43 + v52);
    if (v20 < v43 + v52) {
      unint64_t v53 = (__int8 *)v20;
    }
    if (v53 >= v44) {
      float v54 = v53;
    }
    else {
      float v54 = v44;
    }
    unint64_t v55 = v43 + SBYTE1(v47) * (uint64_t)v12;
    if (v20 >= v55) {
      uint64_t v56 = (__int8 *)(v43 + SBYTE1(v47) * (uint64_t)v12);
    }
    else {
      uint64_t v56 = (__int8 *)v20;
    }
    if (v56 >= v44) {
      uint64_t v57 = v56;
    }
    else {
      uint64_t v57 = v44;
    }
    int32x2_t v58 = (__int8 *)(v55 + v52);
    if (v20 < (unint64_t)v58) {
      int32x2_t v58 = (__int8 *)v20;
    }
    if (v58 >= v44) {
      float v44 = v58;
    }
    unsigned int v59 = (v47 >> 28) & 3;
    unsigned int v60 = interpolate_rgba[4 * v49 + 3];
    unsigned int v61 = interpolate_rgba[4 * v59 + 3];
    unsigned int v62 = v49 + 1;
    v50.i8[0] = *v44;
    v50.i8[4] = v44[1];
    int8x8_t v63 = (int8x8_t)vdup_n_s32(v60);
    a10.i8[0] = *v54;
    a10.i8[4] = v54[1];
    a11.i8[0] = *v57;
    a11.i8[4] = v57[1];
    uint32x2_t v64 = (uint32x2_t)vneg_s32(vdup_n_s32(v62));
    int32x2_t v65 = vadd_s32(vsub_s32((int32x2_t)a7, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, a7), v64)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, (int8x8_t)a11), v64));
    int8x8_t v66 = (int8x8_t)vadd_s32(vsub_s32((int32x2_t)a10, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, a10), v64)), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v63, v50), v64));
    a9 = (int8x8_t)vdup_n_s32(v61);
    a11 = (uint32x2_t)vneg_s32(vdup_n_s32(v59 + 1));
    a10 = (int8x8_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v65, a9), a11);
    a7 = (int8x8_t)vadd_s32(vsub_s32(v65, (int32x2_t)a10), (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v66, a9), a11));
    unsigned int v67 = v46 - ((v60 & v46) >> v62) + ((v60 & v57[2]) >> v62);
    unsigned int v46 = v67
        - ((v67 & v61) >> (v59 + 1))
        + (((v54[2]
           - ((v60 & v54[2]) >> v62)
           + ((v60 & v44[2]) >> v62)) & v61) >> (v59 + 1));
    int v51 = ((v61 >> (v59 + 1)) ^ 0xFF) + (v61 >> (v59 + 1));
  }
LABEL_67:
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  a3 += v17;
  uint64_t v75 = v15 - a3;
  a2 += v16;
  uint64_t v76 = v82 - a2;
  while (1)
  {
    a7 = (int8x8_t)vmul_s32((int32x2_t)vand_s8(a7, (int8x8_t)0xFF000000FFLL), (int32x2_t)0x500000002);
    *(_WORD *)(v18 + 2 + 2 * v74) = ((a7.i32[0] + v46 + a7.i32[1]) >> 3) & 0x1FF | ((_WORD)v51 << 8);
    *(unsigned char *)(v19 + 1 + v74) = v30 >> 22;
    if (a4 - 1 == v74) {
      return result;
    }
    if (((v75 | v76 | (a3 - v14) | (a2 - v81)) & 0x8000000000000000) != 0)
    {
      v19 += v74 + 1;
      uint64_t v18 = v18 - v73 + 2;
      a4 += ~v74;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v77 = v11 + SHIDWORD(a3) * (uint64_t)v12;
    uint64_t v78 = 3 * (a2 >> 32);
    uint64_t v43 = v77 + v78;
    float v44 = *(__int8 **)(result + 32);
    if (v20 >= v77 + v78) {
      char v79 = (__int8 *)(v77 + v78);
    }
    else {
      char v79 = (__int8 *)v20;
    }
    if (v79 < v44) {
      char v79 = *(__int8 **)(result + 32);
    }
    a7.i8[0] = *v79;
    a7.i8[4] = v79[1];
    unsigned int v46 = v79[2];
    if (v13)
    {
      unsigned int v47 = *(_DWORD *)(v13 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        v19 += v74 + 1;
        uint64_t v18 = v18 - v73 + 2;
        a4 += ~v74;
        unsigned int v30 = -1;
        goto LABEL_37;
      }
    }
    ++v74;
    v73 -= 2;
    a3 += v17;
    v75 -= v17;
    a2 += v16;
    v76 -= v16;
    unsigned int v30 = -1;
    LOWORD(v51) = 255;
  }
}

uint64_t GRAYA8_sample_CMYK32_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = (*(_DWORD *)(result + 8) >> 4) & 3;
  if (v8 >= 2) {
    _CGHandleAssert("GRAYA8_sample_CMYK32_inner", 9662, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "reverse == NO_REVERSE || reverse == PIXEL_REVERSE", "reverse = %d", a6, a7, a8, v8);
  }
  BOOL v9 = v8 == 0;
  uint64_t v10 = 3;
  if (v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 3;
  }
  uint64_t v12 = 1;
  if (v9) {
    uint64_t v13 = 2;
  }
  else {
    uint64_t v13 = 1;
  }
  if (v9) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v12 = 2;
  }
  uint64_t v138 = v10;
  uint64_t v14 = *(void *)(result + 40);
  uint64_t v15 = *(void *)(result + 176);
  uint64_t v130 = *(void *)(result + 80);
  uint64_t v132 = *(void *)(result + 88);
  uint64_t v16 = *(void *)(result + 112);
  uint64_t v17 = *(void *)(result + 120);
  uint64_t v134 = *(void *)(result + 152) - 2;
  uint64_t v133 = *(void *)(result + 144) - 1;
  int v18 = *(_DWORD *)(result + 260) - 1;
  uint64_t v136 = *(void *)(result + 32);
  int v137 = *(_DWORD *)(result + 24);
  uint64_t v19 = *(unsigned int *)(result + 256);
  int v135 = *(_DWORD *)(result + 28);
  int v126 = *(_DWORD *)(result + 188);
  unint64_t v20 = (unsigned __int8 *)(v14 + v19 + (v18 * v135));
  unint64_t v21 = v136 + (4 * v19) + (v18 * v137) - 4;
  uint64_t v131 = *(void *)(result + 72);
  uint64_t v127 = *(void *)(result + 64);
  while (1)
  {
    if (a3 >= v131)
    {
      if (a3 <= v132)
      {
        uint64_t v31 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v32 = 0x3FFFFFFF;
        uint64_t v33 = a3;
        int v25 = a4;
        uint64_t v34 = v127;
      }
      else
      {
        uint64_t v27 = *(void *)(result + 216);
        uint64_t v28 = *(void *)(result + 224) + v132;
        uint64_t v29 = v28 - a3 + (v27 >> 1);
        int v25 = a4;
        if (v29 < 1) {
          goto LABEL_49;
        }
        if (v29 >= v27) {
          LODWORD(v30) = 0x3FFFFFFF;
        }
        else {
          unint64_t v30 = (unint64_t)(*(void *)(result + 232) * v29) >> 32;
        }
        uint64_t v34 = v127;
        unsigned int v32 = v126 | v30;
        uint64_t v33 = v28 - 0x1000000;
        uint64_t v31 = 448;
      }
    }
    else
    {
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = v131 - *(void *)(result + 224);
      uint64_t v24 = a3 - v23 + (v22 >> 1);
      int v25 = a4;
      if (v24 < 1) {
        goto LABEL_49;
      }
      if (v24 >= v22) {
        LODWORD(v26) = 0x3FFFFFFF;
      }
      else {
        unint64_t v26 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v34 = v127;
      unsigned int v32 = v126 | v26;
      uint64_t v33 = v23 + 0x1000000;
      uint64_t v31 = 512;
    }
    if (a2 >= v34)
    {
      if (a2 <= v130)
      {
        uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v38 = a2;
      }
      else
      {
        uint64_t v40 = *(void *)(result + 192);
        uint64_t v41 = *(void *)(result + 200) + v130;
        uint64_t v42 = v41 - a2 + (v40 >> 1);
        if (v42 < 1) {
          goto LABEL_49;
        }
        if (v42 < v40) {
          unsigned int v32 = ((v32 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v126;
        }
        uint64_t v38 = v41 - 0x1000000;
        uint64_t v39 = 28;
      }
    }
    else
    {
      uint64_t v35 = *(void *)(result + 192);
      uint64_t v36 = v34 - *(void *)(result + 200);
      uint64_t v37 = a2 - v36 + (v35 >> 1);
      if (v37 < 1) {
        goto LABEL_49;
      }
      if (v37 < v35) {
        unsigned int v32 = ((v32 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v126;
      }
      uint64_t v38 = v36 + 0x1000000;
      uint64_t v39 = 32;
    }
    if (v32 >= 0x400000) {
      break;
    }
LABEL_49:
    int v53 = v25 - 1;
    a2 += v16;
    a3 += v17;
    v134 += 2;
    *(unsigned char *)++uint64_t v133 = 0;
LABEL_50:
    a4 = v53;
    if (!v53) {
      return result;
    }
  }
  uint64_t v43 = v33 >> 32;
  uint64_t v44 = v38 >> 32;
  uint64_t v45 = v136 + SHIDWORD(v33) * (uint64_t)v137;
  unint64_t v46 = v45 + 4 * v44;
  unint64_t v47 = *(void *)(result + 32);
  if (v21 >= v46) {
    unint64_t v48 = v45 + 4 * v44;
  }
  else {
    unint64_t v48 = v21;
  }
  if (v48 < v47) {
    unint64_t v48 = *(void *)(result + 32);
  }
  if (v14)
  {
    unint64_t v49 = v14 + (int)v43 * (uint64_t)v135 + v44;
    int8x8_t v50 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v20 >= v49) {
      int v51 = (unsigned __int8 *)v49;
    }
    else {
      int v51 = v20;
    }
    if (v51 >= v50) {
      int8x8_t v50 = v51;
    }
    int v52 = *v50;
  }
  else
  {
    unint64_t v49 = 0;
    int v52 = 255;
  }
  int v54 = *(unsigned __int8 *)(v48 + v138);
  unsigned int v55 = *(unsigned __int8 *)(v48 + v12);
  unsigned int v56 = *(unsigned __int8 *)(v48 + v13);
  int v57 = *(unsigned __int8 *)(v48 + v11);
  if (v15)
  {
    unsigned int v58 = *(_DWORD *)(v15 + (v39 | v31));
LABEL_56:
    int v59 = v58 & 0xF;
    uint64_t v60 = (v58 >> 28) & 3;
    switch(v59)
    {
      case 1:
        int v86 = SBYTE1(v58);
        unint64_t v87 = v46 + SBYTE1(v58) * (uint64_t)v137;
        if (v21 < v87) {
          unint64_t v87 = v21;
        }
        if (v87 < v47) {
          unint64_t v87 = v47;
        }
        unsigned int v88 = *(unsigned __int8 *)(v87 + v13);
        unsigned int v89 = *(unsigned __int8 *)(v87 + v12);
        unsigned int v90 = *(unsigned __int8 *)(v87 + v11);
        int v91 = 255;
        if (v14)
        {
          float v92 = (unsigned __int8 *)(v49 + v86 * (uint64_t)v135);
          if (v20 < v92) {
            float v92 = v20;
          }
          if ((unint64_t)v92 < *(void *)(result + 40)) {
            float v92 = *(unsigned __int8 **)(result + 40);
          }
          int v91 = *v92;
        }
        int v93 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        char v94 = v60 + 1;
        unsigned int v95 = (v93 & v88) >> v94;
        int v54 = v54 - ((v93 & v54) >> v94) + v95;
        unsigned int v55 = v55 - ((v93 & v55) >> v94) + ((v93 & v89) >> v94);
        unsigned int v56 = v56 - ((v93 & v56) >> v94) + v95;
        int v57 = v57 - ((v93 & v57) >> v94) + ((v93 & v90) >> v94);
        int v52 = v52 - ((v93 & v52) >> v94) + ((v93 & v91) >> v94);
        break;
      case 2:
        int64_t v96 = (unint64_t)HIWORD(v58) << 56;
        unint64_t v97 = v46 + (v96 >> 54);
        if (v21 < v97) {
          unint64_t v97 = v21;
        }
        if (v97 < v47) {
          unint64_t v97 = v47;
        }
        unsigned int v98 = *(unsigned __int8 *)(v97 + v138);
        unsigned int v99 = *(unsigned __int8 *)(v97 + v12);
        unsigned int v100 = *(unsigned __int8 *)(v97 + v13);
        unsigned int v101 = *(unsigned __int8 *)(v97 + v11);
        int v102 = 255;
        if (v14)
        {
          int v103 = (unsigned __int8 *)(v49 + (v96 >> 56));
          if (v20 < v103) {
            int v103 = v20;
          }
          if ((unint64_t)v103 < *(void *)(result + 40)) {
            int v103 = *(unsigned __int8 **)(result + 40);
          }
          int v102 = *v103;
        }
        int v104 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        char v105 = v60 + 1;
        int v54 = v54 - ((v104 & v54) >> v105) + ((v104 & v98) >> v105);
        unsigned int v55 = v55 - ((v104 & v55) >> v105) + ((v104 & v99) >> v105);
        unsigned int v56 = v56 - ((v104 & v56) >> v105) + ((v104 & v100) >> v105);
        int v57 = v57 - ((v104 & v57) >> v105) + ((v104 & v101) >> v105);
        int v52 = v52 - ((v104 & v52) >> v105) + ((v104 & v102) >> v105);
        break;
      case 3:
        int v128 = v25;
        int64_t v61 = (unint64_t)HIWORD(v58) << 56;
        unint64_t v62 = v46 + (v61 >> 54);
        if (v21 < v62) {
          unint64_t v62 = v21;
        }
        if (v62 >= v47) {
          unint64_t v63 = v62;
        }
        else {
          unint64_t v63 = v47;
        }
        unsigned int v64 = *(unsigned __int8 *)(v63 + v138);
        unsigned int v119 = *(unsigned __int8 *)(v63 + v12);
        unsigned int v122 = *(unsigned __int8 *)(v63 + v13);
        unsigned int v125 = *(unsigned __int8 *)(v63 + v11);
        unint64_t v65 = v46 + SBYTE1(v58) * (uint64_t)v137;
        if (v21 >= v65) {
          unint64_t v66 = v46 + SBYTE1(v58) * (uint64_t)v137;
        }
        else {
          unint64_t v66 = v21;
        }
        if (v66 >= v47) {
          unint64_t v67 = v66;
        }
        else {
          unint64_t v67 = v47;
        }
        unsigned int v115 = *(unsigned __int8 *)(v67 + v138);
        unsigned int v117 = *(unsigned __int8 *)(v67 + v12);
        unsigned int v121 = *(unsigned __int8 *)(v67 + v13);
        unsigned int v68 = *(unsigned __int8 *)(v67 + v11);
        unint64_t v69 = v65 + (v61 >> 54);
        if (v21 < v69) {
          unint64_t v69 = v21;
        }
        if (v69 < v47) {
          unint64_t v69 = v47;
        }
        unsigned int v70 = *(unsigned __int8 *)(v69 + v138);
        unsigned int v116 = *(unsigned __int8 *)(v69 + v12);
        unsigned int v120 = *(unsigned __int8 *)(v69 + v13);
        unsigned int v123 = *(unsigned __int8 *)(v69 + v11);
        unsigned int v124 = v68;
        int v71 = 255;
        int v72 = 255;
        int v73 = 255;
        if (v14)
        {
          uint64_t v74 = (unsigned __int8 *)(v49 + SBYTE2(v58));
          unint64_t v75 = *(void *)(result + 40);
          if (v20 < v74) {
            uint64_t v74 = v20;
          }
          if ((unint64_t)v74 < v75) {
            uint64_t v74 = *(unsigned __int8 **)(result + 40);
          }
          int v71 = *v74;
          unint64_t v76 = v49 + SBYTE1(v58) * (uint64_t)v135;
          if ((unint64_t)v20 >= v76) {
            uint64_t v77 = (unsigned __int8 *)(v49 + SBYTE1(v58) * (uint64_t)v135);
          }
          else {
            uint64_t v77 = v20;
          }
          if ((unint64_t)v77 < v75) {
            uint64_t v77 = *(unsigned __int8 **)(result + 40);
          }
          int v72 = *v77;
          uint64_t v78 = (unsigned __int8 *)(v76 + SBYTE2(v58));
          if (v20 < v78) {
            uint64_t v78 = v20;
          }
          if ((unint64_t)v78 < v75) {
            uint64_t v78 = *(unsigned __int8 **)(result + 40);
          }
          int v73 = *v78;
        }
        int v118 = v73;
        uint64_t v79 = HIBYTE(v58) & 3;
        int v80 = interpolate_cmyka8[(v79 | (4 * v79)) + 4];
        LOBYTE(v79) = v79 + 1;
        unsigned __int8 v81 = interpolate_cmyka8[(v60 | (4 * v60)) + 4];
        unsigned int v82 = v54 - ((v80 & v54) >> v79) + ((v80 & v115) >> v79);
        char v83 = v60 + 1;
        int v54 = v82
            - ((v82 & v81) >> v83)
            + (((v64 - ((v80 & v64) >> v79) + ((v80 & v70) >> v79)) & v81) >> v83);
        unsigned int v55 = v55
            - ((v80 & v55) >> v79)
            + ((v80 & v117) >> v79)
            - (((v55 - ((v80 & v55) >> v79) + ((v80 & v117) >> v79)) & v81) >> v83)
            + (((v119 - ((v80 & v119) >> v79) + ((v80 & v116) >> v79)) & v81) >> v83);
        unsigned int v56 = v56
            - ((v80 & v56) >> v79)
            + ((v80 & v121) >> v79)
            - (((v56 - ((v80 & v56) >> v79) + ((v80 & v121) >> v79)) & v81) >> v83)
            + (((v122 - ((v80 & v122) >> v79) + ((v80 & v120) >> v79)) & v81) >> v83);
        unsigned int v84 = v57 - ((v80 & v57) >> v79) + ((v80 & v124) >> v79);
        int v57 = v84
            - ((v84 & v81) >> v83)
            + (((v125 - ((v80 & v125) >> v79) + ((v80 & v123) >> v79)) & v81) >> v83);
        unsigned int v85 = v52 - ((v80 & v52) >> v79) + ((v80 & v72) >> v79);
        int v52 = v85
            - ((v85 & v81) >> v83)
            + (((v71 - ((v80 & v71) >> v79) + ((v80 & v118) >> v79)) & v81) >> v83);
        int v25 = v128;
        break;
    }
  }
  uint64_t v106 = 0;
  uint64_t v107 = 0;
  int v129 = v25;
  int v108 = v25 - 1;
  a3 += v17;
  uint64_t v109 = v132 - a3;
  a2 += v16;
  uint64_t v110 = v130 - a2;
  while (1)
  {
    int v111 = (v52 - (v55 + v57)) & ~((v52
                                                                                     - (v55
                                                                                      + v57)) >> 31);
    *(_WORD *)(v134 + 2 + 2 * v107) = ((unsigned __int16)(((v52
                                                          - (v56
                                                           + v57)) & ~(unsigned __int16)((v52 - (v56 + v57)) >> 31))
                                                        + v111
                                                        + 2
                                                        * ((v52
                                                          - (v54
                                                           + v57)) & ~(unsigned __int16)((v52 - (v54 + v57)) >> 31))
                                                        + 4 * v111) >> 3) | ((_WORD)v52 << 8);
    *(unsigned char *)(v133 + 1 + v107) = v32 >> 22;
    if (v108 == v107) {
      return result;
    }
    if ((v109 | v110 | (a3 - v131) | (a2 - v127)) < 0)
    {
      v133 += v107 + 1;
      uint64_t v134 = v134 - v106 + 2;
      int v53 = ~v107 + v129;
      goto LABEL_50;
    }
    unint64_t v46 = v136 + SHIDWORD(a3) * (uint64_t)v137 + 4 * (a2 >> 32);
    unint64_t v47 = *(void *)(result + 32);
    if (v21 >= v46) {
      unint64_t v112 = v136 + SHIDWORD(a3) * (uint64_t)v137 + 4 * (a2 >> 32);
    }
    else {
      unint64_t v112 = v21;
    }
    if (v112 < v47) {
      unint64_t v112 = *(void *)(result + 32);
    }
    if (v14)
    {
      unint64_t v49 = v14 + SHIDWORD(a3) * (uint64_t)v135 + (a2 >> 32);
      uint64_t v113 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v20 >= v49) {
        unint64_t v114 = v14 + SHIDWORD(a3) * (uint64_t)v135 + (a2 >> 32);
      }
      else {
        unint64_t v114 = (unint64_t)v20;
      }
      if (v114 >= (unint64_t)v113) {
        uint64_t v113 = (unsigned __int8 *)v114;
      }
      int v52 = *v113;
    }
    else
    {
      int v52 = 255;
    }
    int v54 = *(unsigned __int8 *)(v112 + v138);
    unsigned int v55 = *(unsigned __int8 *)(v112 + v12);
    unsigned int v56 = *(unsigned __int8 *)(v112 + v13);
    int v57 = *(unsigned __int8 *)(v112 + v11);
    if (v15)
    {
      unsigned int v58 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v58 & 0xF) != 0)
      {
        v133 += v107 + 1;
        uint64_t v134 = v134 - v106 + 2;
        int v25 = ~v107 + v129;
        unsigned int v32 = -1;
        goto LABEL_56;
      }
    }
    ++v107;
    v106 -= 2;
    a3 += v17;
    v109 -= v17;
    a2 += v16;
    v110 -= v16;
    unsigned int v32 = -1;
  }
}

void CoonsMeshFree(void **a1)
{
  free(a1[1]);
  free(a1[3]);
  free(a1[5]);

  free(a1);
}

_OWORD *AllocateCoonsMeshTriangle(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 64);
  if (v2 == -1)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 48);
    int v6 = *(_DWORD *)(a1 + 52);
    uint64_t result = *(_OWORD **)(a1 + 40);
    if (v5 == v6)
    {
      uint64_t result = malloc_type_realloc(result, 48 * (v5 + 50), 0x1000040EED21634uLL);
      *(void *)(a1 + 40) = result;
      if (!result) {
        return result;
      }
      unsigned int v5 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 52) += 50;
    }
    *(_DWORD *)(a1 + 48) = v5 + 1;
    result += 3 * v5;
    *((void *)result + 4) = -1;
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    *uint64_t result = v7;
    result[1] = v7;
  }
  else
  {
    uint64_t result = (_OWORD *)(*(void *)(a1 + 40) + 48 * v2);
    *(_DWORD *)(a1 + 64) = *((_DWORD *)result + 9);
    *(void *)&long long v4 = -1;
    *((void *)&v4 + 1) = -1;
    *uint64_t result = v4;
    result[1] = v4;
    *((void *)result + 4) = -1;
  }
  *((_DWORD *)result + 10) = 1;
  *((_DWORD *)result + 11) = 0;
  return result;
}

void *AllocateCoonsMeshEdge(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 68);
  if (v2 == -1)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 32);
    int v5 = *(_DWORD *)(a1 + 36);
    uint64_t result = *(void **)(a1 + 24);
    if (v4 == v5)
    {
      uint64_t result = malloc_type_realloc(result, 20 * (v4 + 50), 0x1000040A86A77D5uLL);
      *(void *)(a1 + 24) = result;
      if (!result) {
        return result;
      }
      unsigned int v4 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 36) += 50;
    }
    *(_DWORD *)(a1 + 32) = v4 + 1;
    uint64_t result = (void *)((char *)result + 20 * v4);
  }
  else
  {
    uint64_t result = (void *)(*(void *)(a1 + 24) + 20 * v2);
    *(_DWORD *)(a1 + 68) = *((_DWORD *)result + 4);
  }
  *uint64_t result = -1;
  result[1] = -1;
  *((_DWORD *)result + 4) = -1;
  return result;
}

BOOL TriangleGreater(uint64_t a1, int *a2, int *a3)
{
  uint64_t v3 = a1 + 72 * *a2;
  uint64_t v4 = a1 + 72 * a2[1];
  uint64_t v5 = a1 + 72 * a2[2];
  double v6 = (*(double *)(v3 + 24) + *(double *)(v4 + 24) + *(double *)(v5 + 24)) * 0.333330005;
  uint64_t v7 = a1 + 72 * *a3;
  uint64_t v8 = a1 + 72 * a3[1];
  uint64_t v9 = a1 + 72 * a3[2];
  double v10 = (*(double *)(v7 + 24) + *(double *)(v8 + 24) + *(double *)(v9 + 24)) * 0.333330005;
  if (v10 < v6) {
    return 1;
  }
  if (v10 <= v6) {
    return (*(double *)(v7 + 16) + *(double *)(v8 + 16) + *(double *)(v9 + 16)) * 0.333330005 < (*(double *)(v3 + 16)
  }
                                                                                               + *(double *)(v4 + 16)
                                                                                               + *(double *)(v5 + 16))
                                                                                              * 0.333330005;
  return 0;
}

char *CGBacktraceCreate(uint64_t a1)
{
  v13[128] = *(void **)MEMORY[0x1E4F143B8];
  bzero(v13, 0x400uLL);
  memset(&v11, 0, sizeof(v11));
  int v2 = backtrace(v13, 128);
  if (a1) {
    unint64_t v3 = a1 + 1;
  }
  else {
    unint64_t v3 = v2;
  }
  if (v3 >= v2) {
    size_t v4 = v2;
  }
  else {
    size_t v4 = v3;
  }
  uint64_t v5 = (char *)malloc_type_calloc(0x81uLL, v4, 0x48329A03uLL);
  if (v5) {
    BOOL v6 = v4 >= 3;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    unsigned int v7 = 3;
    unint64_t v8 = 2;
    do
    {
      if (dladdr(v13[v8], &v11)) {
        snprintf(__str, 0x80uLL, "%1.*s<%s+%ld>");
      }
      else {
        snprintf(__str, 0x80uLL, "%1.*s%8lx");
      }
      strcat(v5, __str);
      if (v4 - 2 > v8) {
        *(_WORD *)&v5[strlen(v5)] = 10;
      }
      unint64_t v8 = v7;
    }
    while (v4 > v7++);
  }
  return v5;
}

void CGTextClippingRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    while (1)
    {
      int v2 = (void *)a1[1];
      if (!v2) {
        break;
      }
      a1[1] = *v2;
      unint64_t v3 = (const void *)v2[1];
      if (v3) {
        CFRelease(v3);
      }
      free(v2);
    }
    free(a1);
  }
}

uint64_t CGTextClippingEqualToTextClipping(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 1;
  if (a1 && a2)
  {
    size_t v4 = *(uint64_t **)(a2 + 8);
    uint64_t v5 = *(uint64_t **)(a1 + 8);
    BOOL v6 = v5 != 0;
    BOOL v7 = v4 != 0;
    if (v5 && v4)
    {
      while (1)
      {
        uint64_t v8 = v5[1];
        if (v8)
        {
          int v9 = *(_DWORD *)(v8 + 24);
          if (!v9)
          {
            atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v8 + 24), (unsigned int *)&v9, ~atomic_fetch_add_explicit(get_identifier_identifier, 1u, memory_order_relaxed), memory_order_relaxed, memory_order_relaxed);
            int v9 = *(_DWORD *)(v8 + 24);
          }
        }
        else
        {
          int v9 = 0;
        }
        uint64_t v10 = v4[1];
        if (v10)
        {
          int v11 = *(_DWORD *)(v10 + 24);
          if (!v11)
          {
            atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v10 + 24), (unsigned int *)&v11, ~atomic_fetch_add_explicit(get_identifier_identifier, 1u, memory_order_relaxed), memory_order_relaxed, memory_order_relaxed);
            int v11 = *(_DWORD *)(v10 + 24);
          }
        }
        else
        {
          int v11 = 0;
        }
        if (v9 != v11
          || *((double *)v5 + 2) == *((double *)v4 + 2)
          && (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(v5 + 3), *(float64x2_t *)(v4 + 3)), (int32x4_t)vceqq_f64(*(float64x2_t *)(v5 + 5), *(float64x2_t *)(v4 + 5)))), 0xFuLL))) & 1) != 0&& *((double *)v5 + 7) == *((double *)v4 + 7))
        {
          return 0;
        }
        uint64_t v12 = v5[8];
        if (v12 != v4[8]) {
          return 0;
        }
        if (v12)
        {
          uint64_t v13 = (double *)(v5 + 11);
          uint64_t v14 = (double *)(v4 + 11);
          while (*(unsigned __int16 *)v13 == *(unsigned __int16 *)v14)
          {
            if (*(v13 - 2) != *(v14 - 2) || *(v13 - 1) != *(v14 - 1)) {
              break;
            }
            v13 += 3;
            v14 += 3;
            if (!--v12) {
              goto LABEL_28;
            }
          }
          return 0;
        }
LABEL_28:
        size_t v4 = (uint64_t *)*v4;
        uint64_t v5 = (uint64_t *)*v5;
        BOOL v6 = v5 != 0;
        BOOL v7 = v4 != 0;
        if (!v5 || !v4) {
          return !v6 && !v7;
        }
      }
    }
    else
    {
      return !v6 && !v7;
    }
  }
  return result;
}

void *CGTextClippingCreateCopyByApplyingTransform(uint64_t a1, float64x2_t *a2)
{
  size_t v4 = malloc_type_malloc(0x18uLL, 0x2062DE7BuLL);
  *(_DWORD *)size_t v4 = 1;
  v4[1] = 0;
  v4[2] = 0;
  if (!a2) {
    a2 = (float64x2_t *)&CGAffineTransformIdentity;
  }
  for (uint64_t i = *(double **)(a1 + 8); i; uint64_t i = *(double **)i)
  {
    *(_OWORD *)&v14.tx = 0uLL;
    float64x2_t v6 = *a2;
    *(float64x2_t *)&v14.c = a2[1];
    float64x2_t v7 = vaddq_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[7]), v6, i[6]), (float64x2_t)0);
    float64x2_t v8 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[5]), v6, i[4]);
    *(float64x2_t *)&v14.a = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v14.c, i[3]), v6, i[2]);
    *(float64x2_t *)&v14.c = v8;
    *(float64x2_t *)&v14.tx = v7;
    int v9 = add_glyph_clip((uint64_t)v4, *((const void **)i + 1), &v14, *((void *)i + 8));
    if (v9)
    {
      uint64_t v10 = *((void *)i + 8);
      if (v10)
      {
        int v11 = (float64x2_t *)(v9 + 11);
        uint64_t v12 = i + 11;
        do
        {
          LOWORD(v11->f64[0]) = *(_WORD *)v12;
          v11[-1] = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_n_f64(a2[1], *(v12 - 1)), *a2, *(v12 - 2)));
          int v11 = (float64x2_t *)((char *)v11 + 24);
          v12 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return v4;
}

void *add_glyph_clip(uint64_t a1, const void *a2, const CGAffineTransform *a3, uint64_t a4)
{
  float64x2_t v8 = malloc_type_calloc(1uLL, 24 * a4 + 72, 0x64A29F66uLL);
  if (v8)
  {
    if (a2) {
      CFRetain(a2);
    }
    v8[1] = a2;
    int v9 = &CGAffineTransformIdentity;
    if (a3) {
      int v9 = a3;
    }
    long long v10 = *(_OWORD *)&v9->a;
    long long v11 = *(_OWORD *)&v9->tx;
    *((_OWORD *)v8 + 2) = *(_OWORD *)&v9->c;
    *((_OWORD *)v8 + 3) = v11;
    *((_OWORD *)v8 + 1) = v10;
    v8[8] = a4;
    uint64_t v12 = (void *)(a1 + 8);
    if (*(void *)(a1 + 8)) {
      uint64_t v12 = *(void **)(a1 + 16);
    }
    *uint64_t v12 = v8;
    *(void *)(a1 + 16) = v8;
  }
  return v8;
}

double CGTextClippingAppendGlyphs(uint64_t a1, const void *a2, const CGAffineTransform *a3, __int16 *a4, long long *a5, uint64_t a6)
{
  if (a1)
  {
    if (a2)
    {
      float64x2_t v6 = a4;
      if (a4)
      {
        float64x2_t v7 = a5;
        if (a5)
        {
          uint64_t v8 = a6;
          int v9 = add_glyph_clip(a1, a2, a3, a6);
          if (v9)
          {
            long long v11 = v9 + 11;
            do
            {
              __int16 v12 = *v6++;
              *long long v11 = v12;
              long long v13 = *v7++;
              double result = *(double *)&v13;
              *((_OWORD *)v11 - 1) = v13;
              v11 += 12;
              --v8;
            }
            while (v8);
          }
        }
      }
    }
  }
  return result;
}

CGPath *CGTextClippingCreatePath(uint64_t a1)
{
  Mutable = CGPathCreateMutable();
  if (Mutable)
  {
    unint64_t v3 = *(double **)(a1 + 8);
    if (v3)
    {
      memset(&v32, 0, sizeof(v32));
      do
      {
        font_info = get_font_info(*((void **)v3 + 1));
        if (font_info) {
          int v5 = font_info[2];
        }
        else {
          int v5 = 0;
        }
        if (*((void *)v3 + 8))
        {
          unint64_t v6 = 0;
          double v8 = v3[4];
          double v7 = v3[5];
          double v9 = v7 * 0.0;
          double v11 = v3[2];
          double v10 = v3[3];
          double v12 = v7 * 0.0 + v10 * 0.0 + v3[7];
          double v13 = v8 * 0.0;
          double v14 = v3[6] + v8 * 0.0 + v11 * 0.0;
          double v15 = 1.0 / (double)v5;
          double v16 = v15 * v7 + v10 * 0.0;
          double v17 = v15 * v8 + v11 * 0.0;
          double v18 = v9 + v15 * v10;
          double v19 = v13 + v15 * v11;
          double v20 = v19 + v18 * 0.0;
          double v21 = v18 + v19 * 0.0;
          double v22 = v17 + v16 * 0.0;
          double v23 = v16 + v17 * 0.0;
          double v24 = v14 + v12 * 0.0;
          double v25 = v12 + v14 * 0.0;
          unint64_t v26 = v3 + 11;
          do
          {
            uint64_t v27 = *((void *)v3 + 1);
            if (v27) {
              uint64_t v28 = (const CGPath *)(*(uint64_t (**)(void, void, void))(*(void *)(v27 + 16) + 400))(*(void *)(v27 + 112), 0, *(unsigned __int16 *)v26);
            }
            else {
              uint64_t v28 = 0;
            }
            CGFloat v29 = *(v26 - 2) + v24;
            CGFloat v30 = v25 + *(v26 - 1);
            v32.a = v20;
            v32.b = v21;
            v32.c = v22;
            v32.d = v23;
            v32.tx = v29;
            v32.tdouble y = v30;
            CGPathAddPath(Mutable, &v32, v28);
            if (v28) {
              CFRelease(v28);
            }
            ++v6;
            v26 += 3;
          }
          while (v6 < *((void *)v3 + 8));
        }
        unint64_t v3 = *(double **)v3;
      }
      while (v3);
    }
  }
  return Mutable;
}

size_t data_get_bytes_at_position(uint64_t a1, void *__dst, uint64_t a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0) {
    _CGHandleAssert("data_get_bytes_at_position", 64, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "offset >= 0", "offset %lld", a6, a7, a8, a3);
  }
  size_t v8 = a4;
  if ((uint64_t)(a4 + a3) >= 1)
  {
    uint64_t v9 = *(void *)(a1 + 8);
    if (v9 > a3)
    {
      if (a4 + a3 > v9) {
        size_t v8 = v9 - a3;
      }
      memcpy(__dst, (const void *)(*(void *)(a1 + 16) + a3), v8);
    }
  }
  return v8;
}

CGDataProviderRef CGDataProviderCreateWithDataNoCopy(uint64_t a1, const void *a2, size_t a3, uint64_t a4)
{
  check_clients_buffer("CGDataProviderCreateWithDataNoCopy", a2, a3);
  double v7 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
  void *v7 = 0;
  v7[1] = a3;
  v7[2] = a2;
  v7[3] = a4;
  v12.versiouint64_t n = 0;
  memset(&v12.retain, 0, 40);
  v12.info = v7;
  v12.deallocate = (CFAllocatorDeallocateCallBack)no_copy_deallocator_deallocate;
  v12.preferredSize = 0;
  CFAllocatorRef v8 = CFAllocatorCreate(0, &v12);
  CFDataRef v9 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)a2, a3, v8);
  if (v8) {
    CFRelease(v8);
  }
  if (!v9) {
    return 0;
  }
  CGDataProviderRef v10 = CGDataProviderCreateWithCFData(v9);
  CFRelease(v9);
  return v10;
}

size_t cf_get_bytes_at_position(const __CFData *a1, void *a2, uint64_t a3, size_t a4)
{
  CFIndex Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (a3 < 0) {
    _CGHandleAssert("cf_get_bytes_at_position", 292, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "offset >= 0", "offset %lld", v10, v11, v12, a3);
  }
  if ((uint64_t)(a4 + a3) >= 1 && Length > a3)
  {
    if ((uint64_t)(a4 + a3) > Length) {
      a4 = Length - a3;
    }
    memcpy(a2, &BytePtr[a3], a4);
  }
  return a4;
}

void no_copy_deallocator_deallocate(uint64_t a1, void *a2)
{
  unint64_t v3 = (void (*)(void, uint64_t, void))a2[3];
  if (v3) {
    v3(*a2, a1, a2[1]);
  }

  free(a2);
}

__CFData *CGDataProviderCopyPixelData(CFIndex *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v6 = (unint64_t)(a4 * a2 + 7) >> 3;
  CFIndex v7 = v6 * a3;
  if (a5 != v6)
  {
    double v14 = CGAccessSessionCreate((CGDataProvider *)a1);
    if (v14)
    {
      uint64_t v18 = a5 - v6;
      if (a5 <= v6) {
        _CGHandleAssert("CGDataProviderCopyPixelData", 778, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderData.c", "bytes_per_row > pixel_bytes_per_row", "bpr %zu  pbpr %zu", v15, v16, v17, a5);
      }
      double v19 = v14;
      Mutable = CFDataCreateMutable(0, 0);
      if (CGCFDataIncreaseLength(Mutable, v7))
      {
        MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
        CGAccessSessionGetChunksAtPosition(v19, 0, v6, v18, a3, MutableBytePtr, 0, v21);
        CFDataGetLength(Mutable);
        double v22 = v19;
LABEL_9:
        CGAccessSessionRelease(v22);
        return Mutable;
      }
      CFRelease(Mutable);
      double v23 = v19;
      goto LABEL_11;
    }
    return 0;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v8 = CGDataProviderRetainBytePtr((uint64_t)a1);
  if (!v8)
  {
    double v25 = CGAccessSessionCreate((CGDataProvider *)a1);
    CGDataProviderReleaseBytePtr((uint64_t)a1);
    if (!v25) {
      return 0;
    }
    if (*v25)
    {
      uint64_t v26 = *(void *)(*v25 + 32);
      BOOL v27 = v7 == 0;
      uint64_t v28 = v26;
      if (v26 != -1)
      {
LABEL_20:
        if (v27) {
          int64_t v29 = v28;
        }
        else {
          int64_t v29 = v7;
        }
        Mutable = CFDataCreateMutable(0, 0);
        if (CGCFDataIncreaseLength(Mutable, v29))
        {
          CGFloat v30 = (char *)CFDataGetMutableBytePtr(Mutable);
          unint64_t v36 = 0;
          CFIndex v37 = 0;
          unint64_t v38 = v7 - 1;
          while (1)
          {
            uint64_t Bytes = CGAccessSessionGetBytes(v25, v30, v29, v31, v32, v33, v34, v35);
            if (!Bytes) {
              break;
            }
            uint64_t v40 = Bytes;
            int64_t v41 = v29 - Bytes;
            if (v29 <= Bytes)
            {
              if (Bytes == v26) {
                goto LABEL_51;
              }
            }
            else
            {
              v46.locatiouint64_t n = CFDataGetLength(Mutable) - v41;
              v46.length = v41;
              CFDataDeleteBytes(Mutable, v46);
            }
            BOOL v42 = v29 == v40 && v37 <= v29;
            uint64_t v43 = 2 * v29;
            if (!v42) {
              uint64_t v43 = v40;
            }
            if (v43 >= 0x4000000) {
              uint64_t v43 = 0x4000000;
            }
            if (v43 <= 0x4000) {
              CFIndex v37 = 0x4000;
            }
            else {
              CFIndex v37 = v43;
            }
            if ((CGCFDataIncreaseLength(Mutable, v37) & 1) == 0)
            {
              CGAccessSessionRelease(v25);
              CFRelease(Mutable);
              return 0;
            }
            v36 += v40;
            uint64_t v44 = CFDataGetMutableBytePtr(Mutable);
            if (v44)
            {
              CGFloat v30 = (char *)&v44[v36];
            }
            else
            {
              CFRelease(Mutable);
              Mutable = 0;
              CGFloat v30 = 0;
            }
            int64_t v29 = v37;
            if (v38 < v36) {
              goto LABEL_51;
            }
          }
          if (CGAccessSessionHasError((CFTypeRef *)v25) || !v36)
          {
            CFRelease(Mutable);
            Mutable = 0;
          }
          else
          {
            v47.locatiouint64_t n = CFDataGetLength(Mutable) - v29;
            v47.length = v29;
            CFDataDeleteBytes(Mutable, v47);
          }
LABEL_51:
          double v22 = v25;
          goto LABEL_9;
        }
        CFRelease(Mutable);
        double v23 = v25;
LABEL_11:
        CGAccessSessionRelease(v23);
        return 0;
      }
    }
    else
    {
      BOOL v27 = v7 == 0;
      uint64_t v26 = -1;
    }
    uint64_t v28 = 0x10000;
    goto LABEL_20;
  }
  CFDataRef v9 = (const UInt8 *)v8;
  CGDataProviderRetainBytePtr((uint64_t)a1);
  context.versiouint64_t n = 0;
  memset(&context.retain, 0, 40);
  context.info = a1;
  context.deallocate = (CFAllocatorDeallocateCallBack)provider_allocator_deallocate;
  context.preferredSize = 0;
  CFAllocatorRef v10 = CFAllocatorCreate(0, &context);
  Mutable = CFDataCreateWithBytesNoCopy(0, v9, a1[4], v10);
  CGDataProviderReleaseBytePtr((uint64_t)a1);
  CFRelease(v10);
  return Mutable;
}

double CGGStateGetClipRect(uint64_t a1)
{
  return *(double *)(a1 + 80);
}

void CGGStateClipToPath(uint64_t *a1, CFTypeRef cf, int a3)
{
  if (cf)
  {
    if (CGPathDisableTypeValidation || (CFTypeID v6 = CFGetTypeID(cf), v6 == CGPathGetTypeID()))
    {
      if (a3 == 2)
      {
        CFIndex v7 = CGClipStrokeCreateWithGState((uint64_t)a1);
        uint64_t v8 = CGClipCreateWithStrokedPath(cf, (uint64_t)v7);
        CGClipStrokeRelease(v7);
        if (!v8) {
          return;
        }
      }
      else
      {
        uint64_t v8 = (char *)CGClipCreateWithPath(cf, a3, HIBYTE(*(_DWORD *)(a1[15] + 4)) & 1, *(double *)(a1[18] + 8));
        if (!v8) {
          return;
        }
      }
      maybeCopyClipState((uint64_t)a1);
      CGClipStackAddClip(a1[14], (uint64_t)v8);
      CGClipRelease(v8);
    }
  }
}

void CGGStateClipToTextClipping(uint64_t a1, uint64_t a2)
{
  CopyByApplyingTransforuint64_t m = (atomic_uint *)CGTextClippingCreateCopyByApplyingTransform(a2, (float64x2_t *)(a1 + 24));
  if (CopyByApplyingTransform)
  {
    size_t v4 = CopyByApplyingTransform;
    int v5 = CGClipCreateWithTextClipping(CopyByApplyingTransform);
    if (v5)
    {
      CFTypeID v6 = (char *)v5;
      maybeCopyClipState(a1);
      CGClipStackAddClip(*(void *)(a1 + 112), (uint64_t)v6);
      CGClipRelease(v6);
    }
    CGTextClippingRelease(v4);
  }
}

double CGGStateGetClipBoundingBox(uint64_t a1)
{
  uint64_t v1 = *(double **)(a1 + 112);
  if (v1) {
    return CGClipStackGetBounds(v1);
  }
  else {
    return -8.98846567e307;
  }
}

void CGSConvertAlphaByteInterleved(int a1, int a2, int a3, int a4, unsigned __int8 *a5, unsigned char *a6, int a7, int a8, int a9, unsigned __int8 *a10, unsigned char *a11, int a12, int a13, int a14)
{
  double v14 = a6;
  uint64_t v17 = &inverted_8bit_alpha;
  if (a1 >= 0) {
    uint64_t v17 = 0;
  }
  unsigned int v56 = v17;
  if (a9 < 1)
  {
    if (a9 < 0) {
      uint64_t v18 = a4 + 1;
    }
    else {
      uint64_t v18 = 1;
    }
    if (a9 < 0) {
      uint64_t v19 = a4 + 1;
    }
    else {
      uint64_t v19 = a4;
    }
    if (a9 < 0) {
      ++a5;
    }
  }
  else
  {
    double v14 = &a6[a4];
    uint64_t v18 = a4 + 1;
    uint64_t v19 = v18;
  }
  uint64_t v20 = a4;
  uint64_t v21 = 1;
  int v22 = a4 + 1;
  if (a14 >= 0)
  {
    double v23 = a10;
  }
  else
  {
    uint64_t v20 = v22;
    uint64_t v21 = v22;
    double v23 = a10 + 1;
  }
  if (a14 >= 1) {
    uint64_t v24 = v22;
  }
  else {
    uint64_t v24 = v20;
  }
  if (a14 < 1)
  {
    double v25 = a11;
  }
  else
  {
    uint64_t v21 = v22;
    double v25 = &a11[a4];
  }
  if (a14 >= 1) {
    uint64_t v26 = a10;
  }
  else {
    uint64_t v26 = v23;
  }
  if (a4 != 3)
  {
    uint64_t v62 = (a4 - 1);
    size_t v57 = a4;
    int v61 = a4 - 2;
    uint64_t v53 = a7 - (int)v19 * (uint64_t)a2;
    int v54 = a2;
    uint64_t v51 = a12 - (int)v24 * (uint64_t)a2;
    uint64_t v52 = a8 - (int)v18 * (uint64_t)a2;
    uint64_t v50 = a13 - (int)v21 * (uint64_t)a2;
    int v59 = a4;
    uint64_t v60 = v21;
    uint64_t v58 = v19;
    while (1)
    {
      int v55 = a3;
      if (a2 >= 1) {
        break;
      }
LABEL_76:
      a3 = v55 - 1;
      a2 = v54;
      a5 += v53;
      v14 += v52;
      v26 += v51;
      v25 += v50;
      if (v55 <= 1) {
        return;
      }
    }
    int v35 = a2;
    while (1)
    {
      uint64_t v36 = *v14;
      if (v36 == 255)
      {
        unsigned __int8 v37 = a5[(int)v62];
        if (a4 < 2)
        {
          unsigned __int8 v40 = a5[(int)v62];
        }
        else
        {
          int v38 = v61;
          uint64_t v39 = v62;
          do
          {
            unsigned __int8 v40 = a5[v38];
            v26[v39] = v37;
            --v38;
            unsigned __int8 v37 = v40;
            BOOL v34 = v39-- <= 1;
          }
          while (!v34);
        }
      }
      else
      {
        if (!*v14)
        {
          if (a4 >= 1)
          {
            bzero(v26, v57);
            a4 = v59;
            uint64_t v21 = v60;
            uint64_t v19 = v58;
          }
          goto LABEL_74;
        }
        int v41 = a5[(int)v62];
        if (a1)
        {
          if (a1 < 1)
          {
            __int16 v47 = v56[v36];
            if (a4 > 1)
            {
              uint64_t v48 = v62;
              do
              {
                __int16 v49 = v41 * v47;
                BOOL v34 = v48 <= 1;
                LOWORD(v41) = a5[(v48 - 1)];
                v26[v48--] = HIBYTE(v49);
              }
              while (!v34);
            }
            LOWORD(v44) = v41 * v47;
          }
          else
          {
            if (a4 >= 2)
            {
              uint64_t v42 = v62;
              do
              {
                unsigned int v43 = v41 * v36;
                BOOL v34 = v42 <= 1;
                int v41 = a5[(v42 - 1)];
                v26[v42--] = (unsigned __int16)(v43 + (v43 >> 8) + 1) >> 8;
              }
              while (!v34);
            }
            int v44 = v41 * v36 + ((v41 * v36) >> 8) + 1;
          }
          *uint64_t v26 = BYTE1(v44);
          goto LABEL_74;
        }
        if (a4 < 2)
        {
          unsigned __int8 v40 = a5[(int)v62];
        }
        else
        {
          int v45 = v61;
          uint64_t v46 = v62;
          do
          {
            unsigned __int8 v40 = a5[v45];
            v26[v46] = v41;
            --v45;
            LOBYTE(v41) = v40;
            BOOL v34 = v46-- <= 1;
          }
          while (!v34);
        }
      }
      *uint64_t v26 = v40;
LABEL_74:
      v14 += v18;
      a5 += v19;
      *double v25 = v36;
      v26 += v24;
      v25 += v21;
      BOOL v34 = v35-- <= 1;
      if (v34) {
        goto LABEL_76;
      }
    }
  }
  do
  {
    if (a2 >= 1)
    {
      unsigned int v27 = a2 + 1;
      do
      {
        uint64_t v28 = *v14;
        if (*v14)
        {
          if (v28 == 255 || !a1)
          {
            *(_WORD *)uint64_t v26 = *(_WORD *)a5;
            LOBYTE(v31) = a5[2];
          }
          else
          {
            if (a1 < 1)
            {
              int v32 = (unsigned __int16)v56[v28];
              __int16 v33 = a5[1] * (_WORD)v32;
              *uint64_t v26 = (unsigned __int16)(*a5 * (_WORD)v32) >> 8;
              v26[1] = HIBYTE(v33);
              unsigned int v30 = a5[2] * v32;
            }
            else
            {
              unsigned int v29 = a5[1] * v28 + ((a5[1] * v28) >> 8) + 1;
              *uint64_t v26 = (unsigned __int16)(*a5 * (_WORD)v28 + ((*a5 * v28) >> 8) + 1) >> 8;
              v26[1] = BYTE1(v29);
              unsigned int v30 = a5[2] * v28 + ((a5[2] * v28) >> 8) + 1;
            }
            unsigned int v31 = v30 >> 8;
          }
        }
        else
        {
          LOBYTE(v31) = 0;
          *(_WORD *)uint64_t v26 = 0;
        }
        v14 += v18;
        v26[2] = v31;
        a5 += v19;
        *double v25 = v28;
        v26 += v24;
        v25 += v21;
        --v27;
      }
      while (v27 > 1);
    }
    a5 += a7 - (int)v19 * (uint64_t)a2;
    v14 += a8 - (int)v18 * (uint64_t)a2;
    v26 += a12 - (int)v24 * (uint64_t)a2;
    v25 += a13 - (int)v21 * (uint64_t)a2;
    BOOL v34 = a3-- <= 1;
  }
  while (!v34);
}

void CGSConvertAlphaByteMeshed(int a1, int a2, int a3, int a4, uint64_t *a5, int a6, unsigned char **a7, int a8, int a9)
{
  int v10 = a2;
  uint64_t v12 = &inverted_8bit_alpha;
  if (a1 >= 0) {
    uint64_t v12 = 0;
  }
  int v38 = v12;
  int v13 = (a4 + 1) * a2;
  uint64_t v36 = a6 - (uint64_t)v13;
  uint64_t v35 = a8 - (uint64_t)v13;
  if (a9 <= 0) {
    int v14 = -1;
  }
  else {
    int v14 = a4;
  }
  if (v14 >= 1) {
    uint64_t v15 = *a7;
  }
  else {
    uint64_t v15 = *a7 + 1;
  }
  uint64_t v16 = v14;
  if (v14 >= 1) {
    uint64_t v17 = *a5;
  }
  else {
    uint64_t v17 = *a5 + 1;
  }
  uint64_t v18 = (a4 - 1);
  uint64_t v19 = a4 + 1;
  size_t v40 = a4;
  int v41 = a4 - 2;
  do
  {
    int v39 = a3;
    if (v10 >= 1)
    {
      do
      {
        uint64_t v20 = *(unsigned __int8 *)(v17 + v16);
        if (v20 == 255)
        {
          char v21 = *(unsigned char *)(v17 + (int)v18);
          if (a4 < 2)
          {
            char v24 = *(unsigned char *)(v17 + (int)v18);
          }
          else
          {
            unsigned int v22 = v41;
            uint64_t v23 = v18;
            do
            {
              char v24 = *(unsigned char *)(v17 + v22);
              v15[v23] = v21;
              --v22;
              char v21 = v24;
              BOOL v25 = v23-- <= 1;
            }
            while (!v25);
          }
        }
        else
        {
          if (!*(unsigned char *)(v17 + v16))
          {
            if (a4 >= 1) {
              bzero(v15, v40);
            }
            goto LABEL_44;
          }
          int v26 = *(unsigned __int8 *)(v17 + (int)v18);
          if (a1)
          {
            if (a1 < 1)
            {
              __int16 v32 = v38[v20];
              if (a4 > 1)
              {
                uint64_t v33 = v18;
                do
                {
                  __int16 v34 = v26 * v32;
                  BOOL v25 = v33 <= 1;
                  LOWORD(v26) = *(unsigned __int8 *)(v17 + (v33 - 1));
                  v15[v33--] = HIBYTE(v34);
                }
                while (!v25);
              }
              LOWORD(v29) = v26 * v32;
            }
            else
            {
              if (a4 >= 2)
              {
                uint64_t v27 = v18;
                do
                {
                  unsigned int v28 = v26 * v20;
                  BOOL v25 = v27 <= 1;
                  int v26 = *(unsigned __int8 *)(v17 + (v27 - 1));
                  v15[v27--] = (unsigned __int16)(v28 + (v28 >> 8) + 1) >> 8;
                }
                while (!v25);
              }
              int v29 = v26 * v20 + ((v26 * v20) >> 8) + 1;
            }
            *uint64_t v15 = BYTE1(v29);
            goto LABEL_44;
          }
          if (a4 < 2)
          {
            char v24 = *(unsigned char *)(v17 + (int)v18);
          }
          else
          {
            unsigned int v30 = v41;
            uint64_t v31 = v18;
            do
            {
              char v24 = *(unsigned char *)(v17 + v30);
              v15[v31] = v26;
              --v30;
              LOBYTE(v26) = v24;
              BOOL v25 = v31-- <= 1;
            }
            while (!v25);
          }
        }
        *uint64_t v15 = v24;
LABEL_44:
        v17 += v19;
        v15[v16] = v20;
        v15 += v19;
        BOOL v25 = v10-- <= 1;
      }
      while (!v25);
    }
    a3 = v39 - 1;
    v17 += v36;
    v15 += v35;
    int v10 = a2;
  }
  while (v39 > 1);
}

uint64_t CGSConvertAlphaByteMeshedXXXX(uint64_t result, int a2, int a3, unsigned int *a4, int a5, unsigned int *a6, int a7, int a8)
{
  uint64_t v8 = &inverted_8bit_alpha;
  if ((int)result >= 0) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = a5;
  uint64_t v10 = a7;
  if (a8 <= 0)
  {
    do
    {
      int v30 = a2;
      uint64_t v31 = a6;
      __int16 v32 = a4;
      if (a2 >= 4)
      {
        uint64_t v33 = 0;
        int v30 = a2;
        do
        {
          unsigned int v34 = v30;
          uint64_t v35 = &a4[v33];
          unsigned int v36 = a4[v33];
          unsigned int v37 = a4[v33 + 1];
          if (result)
          {
            uint64_t v38 = a4[v33 + 1];
            if ((a4[v33 + 1] & v36) != 0xFF)
            {
              if (a4[v33])
              {
                if (a4[v33] != 255)
                {
                  uint64_t v39 = a4[v33];
                  if ((int)result < 1)
                  {
                    int v47 = (unsigned __int16)v8[v39];
                    unsigned int v48 = v36 >> 8;
                    unsigned int v43 = ((BYTE1(v36) * v47) | (((v36 >> 8) & 0xFF0000) * v47)) & 0xFF00FF00;
                    unsigned int v42 = ((v48 & 0xFF00) * v47) & 0xFF0000 | v39;
                  }
                  else
                  {
                    unsigned int v40 = ((v36 >> 8) & 0xFF00FF) * v39;
                    unsigned int v41 = (v36 & 0xFF0000 | 0xFF) * v39;
                    unsigned int v42 = (v40 + 65537 + ((v40 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    unsigned int v43 = ((v41 + 65537 + ((v41 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  unsigned int v36 = v43 | v42;
                }
              }
              else
              {
                unsigned int v36 = 0;
              }
              if (a4[v33 + 1])
              {
                if (a4[v33 + 1] != 255)
                {
                  if ((int)result < 1)
                  {
                    int v53 = (unsigned __int16)v8[v38];
                    unsigned int v54 = v37 >> 8;
                    unsigned int v52 = ((BYTE1(v37) * v53) | (((v37 >> 8) & 0xFF0000) * v53)) & 0xFF00FF00;
                    unsigned int v51 = ((v54 & 0xFF00) * v53) & 0xFF0000 | v38;
                  }
                  else
                  {
                    unsigned int v49 = ((v37 >> 8) & 0xFF00FF) * v38;
                    unsigned int v50 = (v37 & 0xFF0000 | 0xFF) * v38;
                    unsigned int v51 = (v49 + 65537 + ((v49 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    unsigned int v52 = ((v50 + 65537 + ((v50 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  unsigned int v37 = v52 | v51;
                }
              }
              else
              {
                unsigned int v37 = 0;
              }
            }
            int v55 = &a6[v33];
            *int v55 = v36;
            v55[1] = v37;
            unsigned int v45 = a4[v33 + 2];
            unsigned int v46 = a4[v33 + 3];
            int v56 = v46;
            if ((v46 & v45) != 0xFF)
            {
              if (a4[v33 + 2])
              {
                if (a4[v33 + 2] != 255)
                {
                  uint64_t v57 = a4[v33 + 2];
                  if ((int)result < 1)
                  {
                    int v62 = (unsigned __int16)v8[v57];
                    unsigned int v63 = v45 >> 8;
                    unsigned int v61 = ((BYTE1(v45) * v62) | (((v45 >> 8) & 0xFF0000) * v62)) & 0xFF00FF00;
                    unsigned int v60 = ((v63 & 0xFF00) * v62) & 0xFF0000 | v57;
                  }
                  else
                  {
                    unsigned int v58 = ((v45 >> 8) & 0xFF00FF) * v57;
                    unsigned int v59 = (v45 & 0xFF0000 | 0xFF) * v57;
                    unsigned int v60 = (v58 + 65537 + ((v58 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    unsigned int v61 = ((v59 + 65537 + ((v59 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  unsigned int v45 = v61 | v60;
                }
              }
              else
              {
                unsigned int v45 = 0;
              }
              if ((_BYTE)v46)
              {
                if (v46 != 255)
                {
                  if ((int)result < 1)
                  {
                    int v66 = (unsigned __int16)v8[v46];
                    unsigned int v67 = v46 >> 8;
                    unsigned int v65 = ((BYTE1(v46) * v66) | (((v46 >> 8) & 0xFF0000) * v66)) & 0xFF00FF00;
                    unsigned int v64 = ((v67 & 0xFF00) * v66) & 0xFF0000 | v56;
                  }
                  else
                  {
                    unsigned int v64 = (((v46 >> 8) & 0xFF00FF) * v46
                         + 65537
                         + (((((v46 >> 8) & 0xFF00FF) * v46) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                    unsigned int v65 = (((v46 & 0xFF0000 | 0xFF) * v46
                          + 65537
                          + ((((v46 & 0xFF0000 | 0xFF) * v46) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                  }
                  unsigned int v46 = v65 | v64;
                }
              }
              else
              {
                unsigned int v46 = 0;
              }
            }
          }
          else
          {
            int v44 = &a6[v33];
            *int v44 = v36;
            v44[1] = v37;
            unsigned int v45 = v35[2];
            unsigned int v46 = v35[3];
          }
          unsigned int v68 = &a6[v33];
          v68[2] = v45;
          v68[3] = v46;
          int v30 = v34 - 4;
          v33 += 4;
        }
        while (v34 > 7);
        __int16 v32 = &a4[v33];
        uint64_t v31 = &a6[v33];
      }
      if (v30 >= 1)
      {
        int v69 = v30 + 1;
        do
        {
          unsigned int v70 = *v32;
          if (result)
          {
            if (*v32)
            {
              if (*v32 != 255)
              {
                uint64_t v71 = *v32;
                if ((int)result < 1)
                {
                  int v76 = (unsigned __int16)v8[v71];
                  unsigned int v77 = v70 >> 8;
                  unsigned int v75 = ((BYTE1(v70) * v76) | (((v70 >> 8) & 0xFF0000) * v76)) & 0xFF00FF00;
                  unsigned int v74 = ((v77 & 0xFF00) * v76) & 0xFF0000 | v71;
                }
                else
                {
                  unsigned int v72 = ((v70 >> 8) & 0xFF00FF) * v71;
                  unsigned int v73 = (v70 & 0xFF0000 | 0xFF) * v71;
                  unsigned int v74 = (v72 + 65537 + ((v72 >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  unsigned int v75 = ((v73 + 65537 + ((v73 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                unsigned int v70 = v75 | v74;
              }
            }
            else
            {
              unsigned int v70 = 0;
            }
          }
          *v31++ = v70;
          ++v32;
          --v69;
        }
        while (v69 > 1);
      }
      a4 = (unsigned int *)((char *)a4 + v9);
      a6 = (unsigned int *)((char *)a6 + v10);
      BOOL v29 = a3-- <= 1;
    }
    while (!v29);
  }
  else
  {
    do
    {
      int v11 = a2;
      uint64_t v12 = a6;
      int v13 = a4;
      if (a2 >= 4)
      {
        uint64_t v14 = 0;
        int v11 = a2;
        do
        {
          unsigned int v15 = v11;
          uint64_t v16 = &a4[v14];
          unint64_t v17 = a4[v14];
          unint64_t v18 = a4[v14 + 1];
          if (result)
          {
            unint64_t v19 = v17 >> 24;
            unint64_t v20 = v18 >> 24;
            if ((HIBYTE(a4[v14 + 1]) & HIBYTE(a4[v14])) != 0xFF)
            {
              if (v19 != 255)
              {
                if (BYTE3(v17))
                {
                  if ((int)result < 1) {
                    LODWORD(v17) = (BYTE1(v17) * v8[v19]) & 0xFF00 | v17 & 0xFF000000 | (((v17 >> 8) & 0xFF00)
                  }
                                                                                       * (unsigned __int16)v8[v19]) & 0xFF0000 | ((unsigned __int16)(v17 * v8[v19]) >> 8);
                  else {
                    LODWORD(v17) = ((BYTE1(v17) | 0xFF0000) * v19
                  }
                                  + 65537
                                  + ((((BYTE1(v17) | 0xFF0000) * v19) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v17 & 0xFF00FF) * v19 + 65537 + ((((v17 & 0xFF00FF) * v19) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v17) = 0;
                }
              }
              if (v20 != 255)
              {
                if (BYTE3(v18))
                {
                  if ((int)result < 1) {
                    LODWORD(v18) = (BYTE1(v18) * v8[v20]) & 0xFF00 | v18 & 0xFF000000 | (((v18 >> 8) & 0xFF00)
                  }
                                                                                       * (unsigned __int16)v8[v20]) & 0xFF0000 | ((unsigned __int16)(v18 * v8[v20]) >> 8);
                  else {
                    LODWORD(v18) = ((BYTE1(v18) | 0xFF0000) * v20
                  }
                                  + 65537
                                  + ((((BYTE1(v18) | 0xFF0000) * v20) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v18 & 0xFF00FF) * v20 + 65537 + ((((v18 & 0xFF00FF) * v20) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v18) = 0;
                }
              }
            }
            unsigned int v22 = &a6[v14];
            *unsigned int v22 = v17;
            v22[1] = v18;
            unint64_t v17 = a4[v14 + 2];
            unint64_t v18 = a4[v14 + 3];
            unint64_t v23 = v17 >> 24;
            unint64_t v24 = v18 >> 24;
            if ((HIBYTE(a4[v14 + 3]) & HIBYTE(a4[v14 + 2])) != 0xFF)
            {
              if (v23 != 255)
              {
                if (BYTE3(v17))
                {
                  if ((int)result < 1) {
                    LODWORD(v17) = (BYTE1(v17) * v8[v23]) & 0xFF00 | v17 & 0xFF000000 | (((v17 >> 8) & 0xFF00)
                  }
                                                                                       * (unsigned __int16)v8[v23]) & 0xFF0000 | ((unsigned __int16)(v17 * v8[v23]) >> 8);
                  else {
                    LODWORD(v17) = ((BYTE1(v17) | 0xFF0000) * v23
                  }
                                  + 65537
                                  + ((((BYTE1(v17) | 0xFF0000) * v23) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v17 & 0xFF00FF) * v23 + 65537 + ((((v17 & 0xFF00FF) * v23) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v17) = 0;
                }
              }
              if (v24 != 255)
              {
                if (BYTE3(v18))
                {
                  if ((int)result < 1) {
                    LODWORD(v18) = (BYTE1(v18) * v8[v24]) & 0xFF00 | v18 & 0xFF000000 | (((v18 >> 8) & 0xFF00)
                  }
                                                                                       * (unsigned __int16)v8[v24]) & 0xFF0000 | ((unsigned __int16)(v18 * v8[v24]) >> 8);
                  else {
                    LODWORD(v18) = ((BYTE1(v18) | 0xFF0000) * v24
                  }
                                  + 65537
                                  + ((((BYTE1(v18) | 0xFF0000) * v24) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v18 & 0xFF00FF) * v24 + 65537 + ((((v18 & 0xFF00FF) * v24) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
                }
                else
                {
                  LODWORD(v18) = 0;
                }
              }
            }
          }
          else
          {
            char v21 = &a6[v14];
            *char v21 = v17;
            v21[1] = v18;
            LODWORD(v17) = v16[2];
            LODWORD(v18) = v16[3];
          }
          BOOL v25 = &a6[v14];
          v25[2] = v17;
          v25[3] = v18;
          int v11 = v15 - 4;
          v14 += 4;
        }
        while (v15 > 7);
        int v13 = &a4[v14];
        uint64_t v12 = &a6[v14];
      }
      if (v11 >= 1)
      {
        int v26 = v11 + 1;
        do
        {
          unint64_t v27 = *v13;
          if (result)
          {
            unint64_t v28 = v27 >> 24;
            if (HIBYTE(*v13) != 255)
            {
              if (BYTE3(v27))
              {
                if ((int)result < 1) {
                  LODWORD(v27) = (BYTE1(v27) * v8[v28]) & 0xFF00 | v27 & 0xFF000000 | (((v27 >> 8) & 0xFF00)
                }
                                                                                     * (unsigned __int16)v8[v28]) & 0xFF0000 | ((unsigned __int16)(v27 * v8[v28]) >> 8);
                else {
                  LODWORD(v27) = ((BYTE1(v27) | 0xFF0000) * v28
                }
                                + 65537
                                + ((((BYTE1(v27) | 0xFF0000) * v28) >> 8) & 0xFF00FF)) & 0xFF00FF00 | (((v27 & 0xFF00FF) * v28 + 65537 + ((((v27 & 0xFF00FF) * v28) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
              }
              else
              {
                LODWORD(v27) = 0;
              }
            }
          }
          *v12++ = v27;
          ++v13;
          --v26;
        }
        while (v26 > 1);
      }
      a4 = (unsigned int *)((char *)a4 + v9);
      a6 = (unsigned int *)((char *)a6 + v10);
      BOOL v29 = a3-- <= 1;
    }
    while (!v29);
  }
  return result;
}

void CGSConvertAlphaWordInterleved(int a1, int a2, int a3, uint64_t a4, unsigned __int16 *a5, _WORD *a6, int a7, int a8, int a9, unsigned __int16 *a10, _WORD *a11, int a12, int a13, int a14)
{
  uint64_t v14 = a6;
  unsigned int v15 = a5;
  if (a9 < 1)
  {
    if (a9 < 0) {
      uint64_t v17 = (int)a4 + 1;
    }
    else {
      uint64_t v17 = 1;
    }
    if (a9 < 0) {
      uint64_t v18 = (int)a4 + 1;
    }
    else {
      uint64_t v18 = (int)a4;
    }
    if (a9 < 0) {
      unsigned int v15 = a5 + 1;
    }
  }
  else
  {
    uint64_t v14 = &a6[(int)a4];
    uint64_t v17 = (int)a4 + 1;
    uint64_t v18 = v17;
  }
  uint64_t v19 = 2 * a2;
  uint64_t v20 = a7 - v19 * v18;
  uint64_t v21 = a8 - v19 * v17;
  uint64_t v22 = (int)a4;
  unint64_t v23 = a10 + 1;
  int v24 = a4 + 1;
  uint64_t v25 = (int)a4 + 1;
  if (a14 >= 0) {
    uint64_t v25 = 1;
  }
  else {
    uint64_t v22 = v24;
  }
  if (a14 >= 0) {
    unint64_t v23 = a10;
  }
  if (a14 >= 1) {
    uint64_t v26 = v24;
  }
  else {
    uint64_t v26 = v22;
  }
  if (a14 >= 1) {
    uint64_t v27 = v24;
  }
  else {
    uint64_t v27 = v25;
  }
  if (a14 >= 1) {
    unint64_t v28 = &a11[(int)a4];
  }
  else {
    unint64_t v28 = a11;
  }
  if (a14 >= 1) {
    BOOL v29 = a10;
  }
  else {
    BOOL v29 = v23;
  }
  uint64_t v30 = a12 - v19 * v26;
  uint64_t v31 = a13 - v19 * v27;
  if (a4 != 3)
  {
    uint64_t v70 = (a4 - 1);
    uint64_t v40 = (int)v70;
    uint64_t v41 = 2 * v26;
    int v69 = a4 - 2;
    uint64_t v62 = v20;
    int v63 = a2;
    uint64_t v60 = v30;
    uint64_t v61 = v21;
    uint64_t v59 = v31;
    uint64_t v68 = v17;
    int v67 = a1;
    uint64_t v65 = v41;
    uint64_t v66 = 2 * a4;
    while (1)
    {
      int v64 = a3;
      if (a2 >= 1) {
        break;
      }
LABEL_80:
      a3 = v64 - 1;
      a2 = v63;
      unsigned int v15 = (unsigned __int16 *)((char *)v15 + v62);
      uint64_t v14 = (_WORD *)((char *)v14 + v61);
      BOOL v29 = (unsigned __int16 *)((char *)v29 + v60);
      unint64_t v28 = (_WORD *)((char *)v28 + v59);
      if (v64 <= 1) {
        return;
      }
    }
    int v42 = a2;
    while (1)
    {
      unsigned int v43 = (unsigned __int16)*v14;
      if (v43 == 0xFFFF)
      {
        unsigned __int16 v46 = v15[v40];
        if ((int)a4 < 2)
        {
          unsigned __int16 v49 = v15[v40];
        }
        else
        {
          int v47 = v69;
          uint64_t v48 = v70;
          do
          {
            unsigned __int16 v49 = v15[v47];
            v29[v48] = v46;
            --v47;
            unsigned __int16 v46 = v49;
            BOOL v39 = v48-- <= 1;
          }
          while (!v39);
        }
      }
      else
      {
        if (!*v14)
        {
          if ((int)a4 >= 1)
          {
            uint64_t v44 = a4;
            uint64_t v45 = v40;
            bzero(v29, v66);
            uint64_t v41 = v65;
            uint64_t v40 = v45;
            a4 = v44;
            uint64_t v17 = v68;
            a1 = v67;
          }
          goto LABEL_78;
        }
        int v50 = v15[v40];
        if (a1)
        {
          if (a1 < 1)
          {
            unsigned int v56 = 0xFFFFFFFF / v43;
            if ((int)a4 > 1)
            {
              uint64_t v57 = v70;
              do
              {
                int v58 = v50 * v56;
                BOOL v39 = v57 <= 1;
                int v50 = v15[(v57 - 1)];
                v29[v57--] = HIWORD(v58);
              }
              while (!v39);
            }
            unsigned int v53 = v50 * v56;
          }
          else
          {
            if ((int)a4 >= 2)
            {
              uint64_t v51 = v70;
              do
              {
                unsigned int v52 = v50 * v43;
                BOOL v39 = v51 <= 1;
                int v50 = v15[(v51 - 1)];
                v29[v51--] = (v52 + HIWORD(v52) + 1) >> 16;
              }
              while (!v39);
            }
            unsigned int v53 = v50 * v43 + ((v50 * v43) >> 16) + 1;
          }
          *BOOL v29 = HIWORD(v53);
          goto LABEL_78;
        }
        if ((int)a4 < 2)
        {
          unsigned __int16 v49 = v15[v40];
        }
        else
        {
          int v54 = v69;
          uint64_t v55 = v70;
          do
          {
            unsigned __int16 v49 = v15[v54];
            v29[v55] = v50;
            --v54;
            LOWORD(v50) = v49;
            BOOL v39 = v55-- <= 1;
          }
          while (!v39);
        }
      }
      *BOOL v29 = v49;
LABEL_78:
      v14 += v17;
      v15 += v18;
      *unint64_t v28 = v43;
      BOOL v29 = (unsigned __int16 *)((char *)v29 + v41);
      v28 += v27;
      BOOL v39 = v42-- <= 1;
      if (v39) {
        goto LABEL_80;
      }
    }
  }
  uint64_t v32 = 2 * v26;
  do
  {
    if (a2 >= 1)
    {
      unsigned int v33 = a2 + 1;
      do
      {
        unsigned int v34 = (unsigned __int16)*v14;
        if (*v14)
        {
          if (v34 == 0xFFFF || !a1)
          {
            *(_DWORD *)BOOL v29 = *(_DWORD *)v15;
            LOWORD(v37) = v15[2];
          }
          else
          {
            if (a1 < 1)
            {
              unsigned int v38 = 0xFFFFFFFF / v34 * v15[1];
              *BOOL v29 = (0xFFFFFFFF / v34 * *v15) >> 16;
              v29[1] = HIWORD(v38);
              unsigned int v36 = 0xFFFFFFFF / v34 * v15[2];
            }
            else
            {
              unsigned int v35 = v15[1] * v34 + ((v15[1] * v34) >> 16) + 1;
              *BOOL v29 = (*v15 * v34 + ((*v15 * v34) >> 16) + 1) >> 16;
              v29[1] = HIWORD(v35);
              unsigned int v36 = v15[2] * v34 + ((v15[2] * v34) >> 16) + 1;
            }
            unsigned int v37 = HIWORD(v36);
          }
        }
        else
        {
          LOWORD(v37) = 0;
          *(_DWORD *)BOOL v29 = 0;
        }
        --v33;
        v15 += v18;
        v29[2] = v37;
        *unint64_t v28 = v34;
        v28 += v27;
        v14 += v17;
        BOOL v29 = (unsigned __int16 *)((char *)v29 + v32);
      }
      while (v33 > 1);
    }
    unsigned int v15 = (unsigned __int16 *)((char *)v15 + v20);
    uint64_t v14 = (_WORD *)((char *)v14 + v21);
    BOOL v29 = (unsigned __int16 *)((char *)v29 + v30);
    unint64_t v28 = (_WORD *)((char *)v28 + v31);
    BOOL v39 = a3-- <= 1;
  }
  while (!v39);
}

void CGSConvertAlphaWordMeshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, int a9)
{
  int v9 = a2;
  int v11 = a4 + 1;
  int v12 = (a4 + 1) * a2;
  uint64_t v13 = a6 - 2 * v12;
  if (a9 <= 0) {
    int v14 = -1;
  }
  else {
    int v14 = a4;
  }
  uint64_t v15 = a8 - 2 * v12;
  uint64_t v16 = a5 + 2 * (v14 < 1);
  uint64_t v17 = (_WORD *)(a7 + 2 * (v14 < 1));
  uint64_t v18 = v14;
  if (a4 != 3)
  {
    uint64_t v55 = (a4 - 1);
    uint64_t v33 = v11;
    uint64_t v53 = 2 * a4;
    uint64_t v34 = 2 * v11;
    int v54 = a4 - 2;
    uint64_t v49 = v15;
    uint64_t v50 = a6 - 2 * v12;
    while (1)
    {
      int v52 = a3;
      if (v9 >= 1) {
        break;
      }
LABEL_56:
      int v9 = a2;
      a3 = v52 - 1;
      v16 += v50;
      uint64_t v17 = (_WORD *)((char *)v17 + v49);
      if (v52 <= 1) {
        return;
      }
    }
    while (1)
    {
      unsigned int v35 = *(unsigned __int16 *)(v16 + 2 * v18);
      if (v35 == 0xFFFF)
      {
        __int16 v36 = *(_WORD *)(v16 + 2 * (int)v55);
        if (a4 < 2)
        {
          __int16 v39 = *(_WORD *)(v16 + 2 * (int)v55);
        }
        else
        {
          unsigned int v37 = v54;
          uint64_t v38 = v55;
          do
          {
            __int16 v39 = *(_WORD *)(v16 + 2 * v37);
            v17[v38] = v36;
            --v37;
            __int16 v36 = v39;
            BOOL v31 = v38-- <= 1;
          }
          while (!v31);
        }
      }
      else
      {
        if (!*(_WORD *)(v16 + 2 * v18))
        {
          if (a4 >= 1) {
            bzero(v17, v53);
          }
          goto LABEL_54;
        }
        int v40 = *(unsigned __int16 *)(v16 + 2 * (int)v55);
        if (a1)
        {
          if (a1 < 1)
          {
            unsigned int v46 = 0xFFFFFFFF / v35;
            if (a4 > 1)
            {
              uint64_t v47 = v55;
              do
              {
                int v48 = v40 * v46;
                BOOL v31 = v47 <= 1;
                int v40 = *(unsigned __int16 *)(v16 + 2 * (v47 - 1));
                v17[v47--] = HIWORD(v48);
              }
              while (!v31);
            }
            unsigned int v43 = v40 * v46;
          }
          else
          {
            if (a4 >= 2)
            {
              uint64_t v41 = v55;
              do
              {
                unsigned int v42 = v40 * v35;
                BOOL v31 = v41 <= 1;
                int v40 = *(unsigned __int16 *)(v16 + 2 * (v41 - 1));
                v17[v41--] = (v42 + HIWORD(v42) + 1) >> 16;
              }
              while (!v31);
            }
            unsigned int v43 = v40 * v35 + ((v40 * v35) >> 16) + 1;
          }
          *uint64_t v17 = HIWORD(v43);
          goto LABEL_54;
        }
        if (a4 < 2)
        {
          __int16 v39 = *(_WORD *)(v16 + 2 * (int)v55);
        }
        else
        {
          unsigned int v44 = v54;
          uint64_t v45 = v55;
          do
          {
            __int16 v39 = *(_WORD *)(v16 + 2 * v44);
            v17[v45] = v40;
            --v44;
            LOWORD(v40) = v39;
            BOOL v31 = v45-- <= 1;
          }
          while (!v31);
        }
      }
      *uint64_t v17 = v39;
LABEL_54:
      v16 += 2 * v33;
      v17[v18] = v35;
      uint64_t v17 = (_WORD *)((char *)v17 + v34);
      BOOL v31 = v9-- <= 1;
      if (v31) {
        goto LABEL_56;
      }
    }
  }
  uint64_t v19 = v14;
  do
  {
    if (a2 >= 1)
    {
      unint64_t v20 = 0;
      uint64_t v21 = v16 + v19 * 2;
      unsigned int v22 = a2 + 1;
      do
      {
        unsigned int v23 = *(unsigned __int16 *)(v21 + v20);
        if (*(_WORD *)(v21 + v20))
        {
          if (v23 == 0xFFFF || !a1)
          {
            *(_DWORD *)&v17[v20 / 2] = *(_DWORD *)(v16 + v20);
            LOWORD(v28) = *(_WORD *)(v16 + v20 + 4);
          }
          else
          {
            if (a1 < 1)
            {
              unsigned int v29 = 0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20 + 2);
              uint64_t v30 = &v17[v20 / 2];
              *uint64_t v30 = (0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20)) >> 16;
              v30[1] = HIWORD(v29);
              unsigned int v27 = 0xFFFFFFFF / v23 * *(unsigned __int16 *)(v16 + v20 + 4);
            }
            else
            {
              unsigned int v24 = *(unsigned __int16 *)(v16 + v20 + 2) * v23;
              uint64_t v25 = &v17[v20 / 2];
              *uint64_t v25 = (*(unsigned __int16 *)(v16 + v20) * v23 + ((*(unsigned __int16 *)(v16 + v20) * v23) >> 16) + 1) >> 16;
              v25[1] = (v24 + HIWORD(v24) + 1) >> 16;
              unsigned int v26 = *(unsigned __int16 *)(v16 + v20 + 4) * v23;
              unsigned int v27 = v26 + HIWORD(v26) + 1;
            }
            unsigned int v28 = HIWORD(v27);
          }
        }
        else
        {
          LOWORD(v28) = 0;
          *(_DWORD *)&v17[v20 / 2] = 0;
        }
        v17[v20 / 2 + 2] = v28;
        v17[v19 + v20 / 2] = v23;
        --v22;
        v20 += 8;
      }
      while (v22 > 1);
      v16 += v20;
      uint64_t v17 = (_WORD *)((char *)v17 + v20);
    }
    v16 += v13;
    uint64_t v17 = (_WORD *)((char *)v17 + v15);
    BOOL v31 = a3-- <= 1;
  }
  while (!v31);
}

void CGSConvertAlphaFloatInterleved(int a1, int a2, int a3, int a4, uint64_t a5, float *a6, int a7, int a8, int a9, float *a10, float *a11, int a12, int a13, int a14)
{
  int v14 = a6;
  uint64_t v15 = (float32x2_t *)a5;
  if (a9 < 1)
  {
    if (a9 < 0) {
      int v18 = a4 + 1;
    }
    else {
      int v18 = 1;
    }
    if (a9 >= 0) {
      int v19 = a4;
    }
    else {
      int v19 = a4 + 1;
    }
    if (a9 < 0) {
      uint64_t v15 = (float32x2_t *)(a5 + 4);
    }
  }
  else
  {
    int v14 = &a6[a4];
    int v18 = a4 + 1;
    int v19 = a4 + 1;
  }
  uint64_t v20 = a7 - 4 * v19 * a2;
  uint64_t v21 = a10 + 1;
  if (a14 < 0) {
    int v22 = a4 + 1;
  }
  else {
    int v22 = 1;
  }
  if (a14 >= 0) {
    int v23 = a4;
  }
  else {
    int v23 = a4 + 1;
  }
  if (a14 >= 0) {
    uint64_t v21 = a10;
  }
  if (a14 < 1)
  {
    int v24 = v23;
  }
  else
  {
    int v22 = a4 + 1;
    int v24 = a4 + 1;
  }
  if (a14 >= 1) {
    uint64_t v25 = &a11[a4];
  }
  else {
    uint64_t v25 = a11;
  }
  if (a14 >= 1) {
    unsigned int v26 = a10;
  }
  else {
    unsigned int v26 = v21;
  }
  uint64_t v27 = a12 - 4 * v24 * a2;
  uint64_t v28 = v18;
  if (a4 == 3)
  {
    uint64_t v29 = 4 * v19;
    while (a2 < 1)
    {
LABEL_42:
      uint64_t v15 = (float32x2_t *)((char *)v15 + v20);
      int v14 = (float *)((char *)v14 + a8 - 4 * v18 * a2);
      unsigned int v26 = (float *)((char *)v26 + v27);
      uint64_t v25 = (float *)((char *)v25 + a13 - 4 * v22 * a2);
      BOOL v33 = a3-- <= 1;
      if (v33) {
        return;
      }
    }
    unsigned int v30 = a2 + 1;
    while (1)
    {
      float v31 = *v14;
      if (*v14 != 1.0)
      {
        if (v31 == 0.0)
        {
          *(void *)unsigned int v26 = 0;
          float v32 = 0.0;
          goto LABEL_36;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            *(float32x2_t *)unsigned int v26 = vmul_n_f32(*v15, 1.0 / v31);
            float v32 = (float)(1.0 / v31) * v15[1].f32[0];
          }
          else
          {
            *(float32x2_t *)unsigned int v26 = vmul_n_f32(*v15, v31);
            float v32 = v31 * v15[1].f32[0];
          }
          goto LABEL_36;
        }
      }
      *(float32x2_t *)unsigned int v26 = *v15;
      float v32 = v15[1].f32[0];
LABEL_36:
      --v30;
      uint64_t v15 = (float32x2_t *)((char *)v15 + v29);
      v26[2] = v32;
      *uint64_t v25 = v31;
      v14 += v18;
      v26 += v24;
      v25 += v22;
      if (v30 <= 1) {
        goto LABEL_42;
      }
    }
  }
  uint64_t v55 = (a4 - 1);
  uint64_t v34 = v19;
  uint64_t v35 = v22;
  uint64_t v56 = 4 * a4;
  uint64_t v36 = 4 * v24;
  int v53 = a2;
  uint64_t v51 = a8 - 4 * v18 * a2;
  uint64_t v52 = a7 - 4 * v19 * a2;
  uint64_t v49 = a13 - 4 * v22 * a2;
  uint64_t v50 = v27;
  do
  {
    int v54 = a3;
    if (a2 >= 1)
    {
      int v37 = a2;
      do
      {
        float v38 = *v14;
        if (*v14 == 0.0)
        {
          if (a4 >= 1)
          {
            uint64_t v39 = v36;
            int v57 = v37;
            bzero(v26, v56);
            int v37 = v57;
            uint64_t v36 = v39;
          }
        }
        else
        {
          float v40 = v15->f32[(int)v55];
          if (!a1 || v38 == 1.0)
          {
            if (a4 < 2)
            {
              __int32 v45 = v15->i32[(int)v55];
            }
            else
            {
              uint64_t v44 = v55;
              do
              {
                BOOL v33 = v44 <= 1;
                __int32 v45 = v15->i32[(v44 - 1)];
                v26[v44--] = v40;
                float v40 = *(float *)&v45;
              }
              while (!v33);
            }
            *(_DWORD *)unsigned int v26 = v45;
          }
          else
          {
            if (a1 < 1)
            {
              float v46 = 1.0 / v38;
              if (a4 > 1)
              {
                uint64_t v47 = v55;
                do
                {
                  float v48 = v46 * v40;
                  BOOL v33 = v47 <= 1;
                  float v40 = v15->f32[(v47 - 1)];
                  v26[v47--] = v48;
                }
                while (!v33);
              }
              float v43 = v46 * v40;
            }
            else
            {
              if (a4 >= 2)
              {
                uint64_t v41 = v55;
                do
                {
                  float v42 = v38 * v40;
                  BOOL v33 = v41 <= 1;
                  float v40 = v15->f32[(v41 - 1)];
                  v26[v41--] = v42;
                }
                while (!v33);
              }
              float v43 = v38 * v40;
            }
            *unsigned int v26 = v43;
          }
        }
        v14 += v28;
        uint64_t v15 = (float32x2_t *)((char *)v15 + 4 * v34);
        *uint64_t v25 = v38;
        unsigned int v26 = (float *)((char *)v26 + v36);
        v25 += v35;
        BOOL v33 = v37-- <= 1;
      }
      while (!v33);
    }
    a2 = v53;
    a3 = v54 - 1;
    uint64_t v15 = (float32x2_t *)((char *)v15 + v52);
    int v14 = (float *)((char *)v14 + v51);
    unsigned int v26 = (float *)((char *)v26 + v50);
    uint64_t v25 = (float *)((char *)v25 + v49);
  }
  while (v54 > 1);
}

void CGSConvertAlphaFloatMeshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, int a9)
{
  int v9 = a2;
  int v11 = a4 + 1;
  int v12 = (a4 + 1) * a2;
  if (a9 <= 0) {
    int v13 = -1;
  }
  else {
    int v13 = a4;
  }
  int v14 = (float32x2_t *)(a5 + 4 * (v13 < 1));
  uint64_t v15 = (float *)(a7 + 4 * (v13 < 1));
  uint64_t v16 = v13;
  if (a4 == 3)
  {
    while (a2 < 1)
    {
LABEL_17:
      int v14 = (float32x2_t *)((char *)v14 + a6 - 4 * v12);
      uint64_t v15 = (float *)((char *)v15 + a8 - 4 * v12);
      BOOL v20 = a3-- <= 1;
      if (v20) {
        return;
      }
    }
    int v17 = a2 + 1;
    while (1)
    {
      float v18 = v14->f32[v16];
      if (v18 != 1.0)
      {
        if (v18 == 0.0)
        {
          *(void *)uint64_t v15 = 0;
          float v19 = 0.0;
          goto LABEL_11;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            *(float32x2_t *)uint64_t v15 = vmul_n_f32(*v14, 1.0 / v18);
            float v19 = (float)(1.0 / v18) * v14[1].f32[0];
          }
          else
          {
            *(float32x2_t *)uint64_t v15 = vmul_n_f32(*v14, v18);
            float v19 = v18 * v14[1].f32[0];
          }
          goto LABEL_11;
        }
      }
      *(float32x2_t *)uint64_t v15 = *v14;
      float v19 = v14[1].f32[0];
LABEL_11:
      v15[2] = v19;
      v14 += 2;
      v15[v16] = v18;
      v15 += 4;
      if (--v17 <= 1) {
        goto LABEL_17;
      }
    }
  }
  uint64_t v39 = (a4 - 1);
  uint64_t v22 = v11;
  size_t v23 = 4 * a4;
  uint64_t v24 = 4 * v11;
  uint64_t v35 = a8 - 4 * v12;
  uint64_t v36 = a6 - 4 * v12;
  do
  {
    int v38 = a3;
    if (v9 >= 1)
    {
      do
      {
        float v25 = v14->f32[v16];
        if (v25 == 0.0)
        {
          if (a4 >= 1) {
            bzero(v15, v23);
          }
        }
        else
        {
          float v26 = v14->f32[(int)v39];
          if (!a1 || v25 == 1.0)
          {
            if (a4 < 2)
            {
              __int32 v31 = v14->i32[(int)v39];
            }
            else
            {
              uint64_t v30 = v39;
              do
              {
                BOOL v20 = v30 <= 1;
                __int32 v31 = v14->i32[(v30 - 1)];
                v15[v30--] = v26;
                float v26 = *(float *)&v31;
              }
              while (!v20);
            }
            *(_DWORD *)uint64_t v15 = v31;
          }
          else
          {
            if (a1 < 1)
            {
              float v32 = 1.0 / v25;
              if (a4 > 1)
              {
                uint64_t v33 = v39;
                do
                {
                  float v34 = v32 * v26;
                  BOOL v20 = v33 <= 1;
                  float v26 = v14->f32[(v33 - 1)];
                  v15[v33--] = v34;
                }
                while (!v20);
              }
              float v29 = v32 * v26;
            }
            else
            {
              if (a4 >= 2)
              {
                uint64_t v27 = v39;
                do
                {
                  float v28 = v25 * v26;
                  BOOL v20 = v27 <= 1;
                  float v26 = v14->f32[(v27 - 1)];
                  v15[v27--] = v28;
                }
                while (!v20);
              }
              float v29 = v25 * v26;
            }
            *uint64_t v15 = v29;
          }
        }
        int v14 = (float32x2_t *)((char *)v14 + 4 * v22);
        v15[v16] = v25;
        uint64_t v15 = (float *)((char *)v15 + v24);
        BOOL v20 = v9-- <= 1;
      }
      while (!v20);
    }
    int v9 = a2;
    a3 = v38 - 1;
    int v14 = (float32x2_t *)((char *)v14 + v36);
    uint64_t v15 = (float *)((char *)v15 + v35);
  }
  while (v38 > 1);
}

void convert_alpha_float16_interleved(int a1, int a2, int a3, int a4, short float *a5, short float *a6, int a7, int a8, float _S0, float _S1, int a11, char *a12, short float *a13, int a14, int a15, int a16)
{
  uint64_t v16 = a6;
  int v17 = a5;
  if (a11 < 1)
  {
    if (a11 < 0) {
      int v20 = a4 + 1;
    }
    else {
      int v20 = 1;
    }
    if (a11 >= 0) {
      int v21 = a4;
    }
    else {
      int v21 = a4 + 1;
    }
    if (a11 < 0) {
      int v17 = a5 + 1;
    }
  }
  else
  {
    uint64_t v16 = &a6[a4];
    int v20 = a4 + 1;
    int v21 = a4 + 1;
  }
  uint64_t v22 = a7 - 2 * v21 * a2;
  size_t v23 = a12 + 2;
  if (a16 < 0) {
    int v24 = a4 + 1;
  }
  else {
    int v24 = 1;
  }
  if (a16 >= 0) {
    int v25 = a4;
  }
  else {
    int v25 = a4 + 1;
  }
  if (a16 >= 0) {
    size_t v23 = a12;
  }
  if (a16 < 1)
  {
    int v26 = v25;
  }
  else
  {
    int v24 = a4 + 1;
    int v26 = a4 + 1;
  }
  if (a16 >= 1) {
    uint64_t v27 = &a13[a4];
  }
  else {
    uint64_t v27 = a13;
  }
  if (a16 >= 1) {
    float v28 = a12;
  }
  else {
    float v28 = v23;
  }
  uint64_t v29 = a14 - 2 * v26 * a2;
  uint64_t v30 = v20;
  if (a4 == 3)
  {
    uint64_t v31 = 2 * v21;
    uint64_t v32 = 2 * v26;
    while (a2 < 1)
    {
LABEL_43:
      int v17 = (short float *)((char *)v17 + v22);
      uint64_t v16 = (short float *)((char *)v16 + a8 - 2 * v20 * a2);
      v28 += v29;
      uint64_t v27 = (short float *)((char *)v27 + a15 - 2 * v24 * a2);
      BOOL v51 = a3-- <= 1;
      if (v51) {
        return;
      }
    }
    unsigned int v33 = a2 + 1;
    while (1)
    {
      _H2 = *v16;
      if (*v16 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      {
        __asm { FCMP            H2, #0 }
        if (_ZF)
        {
          *(_DWORD *)float v28 = 0;
          LOWORD(_H3) = 0;
          goto LABEL_37;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            __asm { FCVT            S3, H2 }
            float v42 = 1.0 / _S3;
            _H4 = *v17;
            __asm { FCVT            S4, H4 }
            _H5 = *((_WORD *)v17 + 1);
            __asm { FCVT            S5, H5 }
            _S4 = v42 * _S4;
            _S5 = v42 * _S5;
            __asm { FCVT            H4, S4 }
            *(_WORD *)float v28 = LOWORD(_S4);
            __asm { FCVT            H4, S5 }
            *((_WORD *)v28 + 1) = LOWORD(_S4);
            *(short float *)&_S4 = v17[2];
            __asm { FCVT            S4, H4 }
            _S3 = v42 * _S4;
            __asm { FCVT            H3, S3 }
          }
          else
          {
            short float v40 = v17[1];
            *(short float *)float v28 = _H2 * *v17;
            *((short float *)v28 + 1) = _H2 * v40;
            _H3 = _H2 * v17[2];
          }
          goto LABEL_37;
        }
      }
      *(_DWORD *)float v28 = *(_DWORD *)v17;
      _H3 = v17[2];
LABEL_37:
      --v33;
      int v17 = (short float *)((char *)v17 + v31);
      *((short float *)v28 + 2) = _H3;
      *uint64_t v27 = _H2;
      v27 += v24;
      v16 += v20;
      v28 += v32;
      if (v33 <= 1) {
        goto LABEL_43;
      }
    }
  }
  uint64_t v75 = (a4 - 1);
  uint64_t v52 = v21;
  uint64_t v53 = v24;
  uint64_t v76 = 2 * a4;
  uint64_t v54 = 2 * v26;
  int v73 = a2;
  uint64_t v71 = a8 - 2 * v20 * a2;
  uint64_t v72 = a7 - 2 * v21 * a2;
  uint64_t v69 = a15 - 2 * v24 * a2;
  uint64_t v70 = v29;
  do
  {
    int v74 = a3;
    if (a2 >= 1)
    {
      int v55 = a2;
      do
      {
        __asm { FCMP            H10, #0 }
        if (_ZF)
        {
          if (a4 >= 1)
          {
            uint64_t v57 = v54;
            int v77 = v55;
            bzero(v28, v76);
            int v55 = v77;
            uint64_t v54 = v57;
          }
        }
        else
        {
          *(short float *)&_S0 = v17[(int)v75];
          if (!a1 || _H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            if (a4 < 2)
            {
              _S1 = _S0;
            }
            else
            {
              uint64_t v63 = v75;
              do
              {
                BOOL v51 = v63 <= 1;
                *(short float *)&_S1 = v17[(v63 - 1)];
                *(_WORD *)&v28[2 * v63--] = LOWORD(_S0);
                _S0 = _S1;
              }
              while (!v51);
            }
            *(_WORD *)float v28 = LOWORD(_S1);
          }
          else
          {
            __asm
            {
              FCVT            S1, H10
              FCVT            S0, H0
            }
            if (a1 < 1)
            {
              _S1 = 1.0 / _S1;
              if (a4 > 1)
              {
                uint64_t v64 = v75;
                do
                {
                  _H2 = v17[(v64 - 1)];
                  _S3 = _S1 * _S0;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v28[2 * v64--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S1 * _S0;
            }
            else
            {
              if (a4 >= 2)
              {
                uint64_t v59 = v75;
                do
                {
                  _H2 = v17[(v59 - 1)];
                  _S3 = _S0 * _S1;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v28[2 * v59--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S0 * _S1;
            }
            __asm { FCVT            H0, S0 }
            *(_WORD *)float v28 = _H0;
          }
        }
        v16 += v30;
        v17 += v52;
        *uint64_t v27 = _H10;
        v28 += v54;
        v27 += v53;
        BOOL v51 = v55-- <= 1;
      }
      while (!v51);
    }
    a2 = v73;
    a3 = v74 - 1;
    int v17 = (short float *)((char *)v17 + v72);
    uint64_t v16 = (short float *)((char *)v16 + v71);
    v28 += v70;
    uint64_t v27 = (short float *)((char *)v27 + v69);
  }
  while (v74 > 1);
}

void convert_alpha_float16_meshed(int a1, int a2, int a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, float _S0, float _S1, int a11)
{
  int v11 = a2;
  int v13 = a4 + 1;
  int v14 = (a4 + 1) * a2;
  if (a11 <= 0) {
    int v15 = -1;
  }
  else {
    int v15 = a4;
  }
  uint64_t v16 = (short float *)(a5 + 2 * (v15 < 1));
  int v17 = (char *)(a7 + 2 * (v15 < 1));
  uint64_t v18 = v15;
  if (a4 == 3)
  {
    while (a2 < 1)
    {
LABEL_18:
      uint64_t v16 = (short float *)((char *)v16 + a6 - 2 * v14);
      v17 += a8 - 2 * v14;
      BOOL v37 = a3-- <= 1;
      if (v37) {
        return;
      }
    }
    int v19 = a2 + 1;
    while (1)
    {
      _H2 = v16[v18];
      if (_H2 != COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
      {
        __asm { FCMP            H2, #0 }
        if (_ZF)
        {
          *(_DWORD *)int v17 = 0;
          LOWORD(_H3) = 0;
          goto LABEL_12;
        }
        if (a1)
        {
          if (a1 < 1)
          {
            __asm { FCVT            S3, H2 }
            float v28 = 1.0 / _S3;
            _H4 = *v16;
            __asm { FCVT            S4, H4 }
            _H5 = *((_WORD *)v16 + 1);
            __asm { FCVT            S5, H5 }
            _S4 = v28 * _S4;
            _S5 = v28 * _S5;
            __asm { FCVT            H4, S4 }
            *(_WORD *)int v17 = LOWORD(_S4);
            __asm { FCVT            H4, S5 }
            *((_WORD *)v17 + 1) = LOWORD(_S4);
            *(short float *)&_S4 = v16[2];
            __asm { FCVT            S4, H4 }
            _S3 = v28 * _S4;
            __asm { FCVT            H3, S3 }
          }
          else
          {
            short float v26 = v16[1];
            *(short float *)int v17 = _H2 * *v16;
            *((short float *)v17 + 1) = _H2 * v26;
            _H3 = _H2 * v16[2];
          }
          goto LABEL_12;
        }
      }
      *(_DWORD *)int v17 = *(_DWORD *)v16;
      _H3 = v16[2];
LABEL_12:
      *((short float *)v17 + 2) = _H3;
      v16 += 4;
      *(short float *)&v17[2 * v18] = _H2;
      v17 += 8;
      if (--v19 <= 1) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v58 = (a4 - 1);
  uint64_t v39 = v13;
  size_t v40 = 2 * a4;
  uint64_t v41 = 2 * v13;
  uint64_t v54 = a8 - 2 * v14;
  uint64_t v55 = a6 - 2 * v14;
  do
  {
    int v57 = a3;
    if (v11 >= 1)
    {
      do
      {
        __asm { FCMP            H10, #0 }
        if (_ZF)
        {
          if (a4 >= 1) {
            bzero(v17, v40);
          }
        }
        else
        {
          *(short float *)&_S0 = v16[(int)v58];
          if (!a1 || _H10 == COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
          {
            if (a4 < 2)
            {
              _S1 = _S0;
            }
            else
            {
              uint64_t v48 = v58;
              do
              {
                BOOL v37 = v48 <= 1;
                *(short float *)&_S1 = v16[(v48 - 1)];
                *(_WORD *)&v17[2 * v48--] = LOWORD(_S0);
                _S0 = _S1;
              }
              while (!v37);
            }
            *(_WORD *)int v17 = LOWORD(_S1);
          }
          else
          {
            __asm
            {
              FCVT            S1, H10
              FCVT            S0, H0
            }
            if (a1 < 1)
            {
              _S1 = 1.0 / _S1;
              if (a4 > 1)
              {
                uint64_t v49 = v58;
                do
                {
                  _H2 = v16[(v49 - 1)];
                  _S3 = _S1 * _S0;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v17[2 * v49--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S1 * _S0;
            }
            else
            {
              if (a4 >= 2)
              {
                uint64_t v44 = v58;
                do
                {
                  _H2 = v16[(v44 - 1)];
                  _S3 = _S0 * _S1;
                  __asm
                  {
                    FCVT            S0, H2
                    FCVT            H2, S3
                  }
                  *(_WORD *)&v17[2 * v44--] = _H2;
                }
                while (!(_NF ^ _VF | _ZF));
              }
              _S0 = _S0 * _S1;
            }
            __asm { FCVT            H0, S0 }
            *(_WORD *)int v17 = _H0;
          }
        }
        v16 += v39;
        *(short float *)&v17[2 * v18] = _H10;
        v17 += v41;
        BOOL v37 = v11-- <= 1;
      }
      while (!v37);
    }
    int v11 = a2;
    a3 = v57 - 1;
    uint64_t v16 = (short float *)((char *)v16 + v55);
    v17 += v54;
  }
  while (v57 > 1);
}

BOOL CGPDFCountElementsInCPChunk(void *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return [a1 anchoringTextLine] == 0;
  }
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  unsigned int v4 = [a1 count];
  unsigned int v5 = v4;
  if ((isKindOfClass & 1) == 0)
  {
    if (v4)
    {
      uint64_t v37 = 0;
      uint64_t v2 = 0;
      do
      {
        v2 += CGPDFCountElementsInCPChunk([a1 childAtIndex:v37]);
        uint64_t v37 = (v37 + 1);
      }
      while (v5 != v37);
      return v2;
    }
    return 0;
  }
  if (!v4) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v6 = 0;
  CFIndex v7 = a1;
  uint64_t v39 = v5;
  size_t v40 = a1;
  do
  {
    uint64_t v41 = v6;
    float v43 = objc_msgSend(v7, "childAtIndex:", v39, v40);
    unsigned int v8 = [v43 count];
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v42 = v8;
      do
      {
        uint64_t v44 = v9;
        float v46 = objc_msgSend(v43, "childAtIndex:");
        unsigned int v10 = [v46 count];
        if (v10)
        {
          uint64_t v11 = 0;
          uint64_t v45 = v10;
          do
          {
            int v12 = (void *)[v46 childAtIndex:v11];
            int v13 = (void *)[v12 charSequence];
            unsigned int v14 = [v12 wordCount];
            uint64_t v15 = v14;
            uint64_t v47 = v11;
            if (v14)
            {
              uint64_t v16 = 0;
              uint64_t v48 = v14;
              do
              {
                int v17 = v12;
                uint64_t v18 = [v12 wordAtIndex:v16];
                uint64_t v19 = *(unsigned int *)(v18 + 4);
                if (v19)
                {
                  int v20 = (_DWORD *)v18;
                  uint64_t v21 = 0;
                  uint64_t v22 = 0;
                  do
                  {
                    uint64_t v23 = [v13 charAtIndex:(v21 + *v20)];
                    uint64_t v51 = 0;
                    unsigned int v24 = *(unsigned __int16 *)(v23 + 72);
                    if (!v22 || !isCharacterOverlay(v22, v23))
                    {
                      if (v24 || (short float v26 = *(void **)(*(void *)(v23 + 160) + 64)) == 0)
                      {
                        unsigned int v49 = 0;
                        if (decomposes(v24, &v50, &v49)) {
                          uint64_t v25 = v49;
                        }
                        else {
                          uint64_t v25 = 1;
                        }
                      }
                      else
                      {
                        [v26 uniCharsFor:*(unsigned __int16 *)(v23 + 74) count:&v51 toArray:v52 maxChars:256];
                        if (v51) {
                          uint64_t v27 = v51;
                        }
                        else {
                          uint64_t v27 = 1;
                        }
                        if (v51 == 1) {
                          uint64_t v25 = 1;
                        }
                        else {
                          uint64_t v25 = v27;
                        }
                      }
                      v2 += v25;
                    }
                    ++v21;
                    uint64_t v22 = v23;
                  }
                  while (v19 != v21);
                }
                ++v2;
                ++v16;
                uint64_t v15 = v48;
                int v12 = v17;
              }
              while (v16 != v48);
            }
            uint64_t v28 = [v12 inlineList];
            if (v28)
            {
              uint64_t v29 = v28;
              do
              {
                uint64_t v30 = *(void *)(v29 + 8);
                objc_opt_class();
                if (objc_opt_isKindOfClass()) {
                  uint64_t v31 = 1;
                }
                else {
                  uint64_t v31 = CGPDFCountElementsInCPChunk(v30);
                }
                v2 += v31 + 1;
                uint64_t v29 = *(void *)(v29 + 16);
              }
              while (v29);
            }
            if (objc_msgSend((id)objc_msgSend(v12, "parent"), "isPreformattedWithUnitWidth:", 0))
            {
              uint64_t v32 = 0;
              if (v15)
              {
                for (uint64_t i = 0; i != v15; ++i)
                {
                  unsigned int v34 = [v12 spacesBeforeWordAtIndex:i];
                  if (i) {
                    BOOL v35 = v34 == 0;
                  }
                  else {
                    BOOL v35 = 1;
                  }
                  uint64_t v36 = !v35;
                  uint64_t v32 = v32 + v34 - v36;
                }
              }
              v2 += v32;
            }
            uint64_t v11 = v47 + 1;
          }
          while (v47 + 1 != v45);
        }
        uint64_t v9 = v44 + 1;
      }
      while (v44 + 1 != v42);
    }
    CFIndex v7 = v40;
    uint64_t v6 = v41 + 1;
  }
  while (v41 + 1 != v39);
  return v2;
}

char *CGPDFNodeMakeFromCPChunk(void *a1, uint64_t a2, uint64_t a3, CFDictionaryRef *a4, CFDictionaryRef *a5)
{
  int v10 = CGPDFNodeTypeFromCPChunk();
  if (!v10) {
    return 0;
  }
  int v11 = v10;
  if (!a3)
  {
    int v12 = [a1 count];
    if (v12)
    {
      int v13 = v12;
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = (void *)[a1 childAtIndex:v14];
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          [v15 anchoringTextLine];
        }
        uint64_t v14 = (v14 + 1);
      }
      while (v13 != v14);
    }
  }
  if (a2) {
    uint64_t v16 = *(void *)(a2 + 104);
  }
  else {
    uint64_t v16 = 0;
  }
  if (v11 != 517 || v16)
  {
    int v22 = [a1 conformsToProtocol:&unk_1ED0B0660];
    if (a4 && v22)
    {
      if (*a4)
      {
        Value = (char *)CFDictionaryGetValue(*a4, a1);
        if (Value) {
          return Value;
        }
      }
      else
      {
        *a4 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
      }
      CGPDFNodeInitInPage(v11);
      Value = v29;
      CFDictionaryAddValue(*a4, a1, v29);
    }
    else
    {
      CGPDFNodeInitInPage(v11);
      Value = v23;
    }
  }
  else
  {
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    CGPDFNodeSizeFromCPChunk(a1, Mutable);
    long long context = (unint64_t)[a1 clipBuffer];
    CFSetApplyFunction(Mutable, (CFSetApplierFunction)countClips, &context);
    CFRelease(Mutable);
    uint64_t v18 = malloc_type_calloc(0x98uLL, 1uLL, 0x2C7ACE11uLL);
    *uint64_t v18 = 517;
    v18[10] = 1;
    *((_OWORD *)v18 + 1) = CPRangeNull;
    *((void *)v18 + 4) = 0;
    *((void *)v18 + 7) = 0;
    *(void *)(v18 + 11) = 0;
    *((unsigned char *)v18 + 52) = 0;
    *((CGRect *)v18 + 2) = CGRectNull;
    *((void *)v18 + 13) = a2;
    if (a2)
    {
      v18[10] = 2;
      *(void *)(a2 + 104) = v18;
      CGPDFNodeRelease(v18);
      uint64_t v16 = *(void *)(a2 + 104);
      if (v16)
      {
        size_t v19 = DWORD2(context);
        uint64_t v20 = *(void *)(a2 + 104);
        while (*(_DWORD *)v20 != 517)
        {
          uint64_t v20 = *(void *)(v20 + 8);
          if (!v20) {
            goto LABEL_37;
          }
        }
        unint64_t v24 = *(unsigned int *)(v20 + 112);
        if (v24)
        {
          unint64_t v25 = 0;
          uint64_t v26 = 8;
          do
          {
            uint64_t v27 = *(const void **)(*(void *)(v20 + 120) + v26);
            if (v27)
            {
              CFRelease(v27);
              unint64_t v24 = *(unsigned int *)(v20 + 112);
            }
            ++v25;
            v26 += 32;
          }
          while (v25 < v24);
        }
        free(*(void **)(v20 + 120));
        if (v19) {
          uint64_t v28 = malloc_type_calloc(v19, 0x20uLL, 0x1060040A9AB1A44uLL);
        }
        else {
          uint64_t v28 = 0;
        }
        *(void *)(v20 + 120) = v28;
        *(_DWORD *)(v20 + 112) = 0;
      }
    }
    else
    {
      CGPDFNodeRelease(v18);
      uint64_t v16 = 0;
    }
LABEL_37:
    Value = (char *)v16;
  }
  if (!Value) {
    return Value;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [a1 zoneBounds];
    uint64_t v31 = v30;
    uint64_t v33 = v32;
    uint64_t v35 = v34;
    uint64_t v37 = v36;
    int v38 = (const void *)[a1 newBackgroundColor];
    if (*(_DWORD *)Value == 1538)
    {
      uint64_t v39 = (const void *)*((void *)Value + 14);
      if (v39 != v38)
      {
        if (v39) {
          CFRelease(v39);
        }
        if (v38) {
          CFRetain(v38);
        }
        *((void *)Value + 14) = v38;
      }
    }
    if (v38) {
      CFRelease(v38);
    }
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [a1 cellBounds];
    }
    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        [a1 tableBounds];
      }
      else {
        [a1 renderedBounds];
      }
    }
    uint64_t v31 = v40;
    uint64_t v33 = v41;
    uint64_t v35 = v42;
    uint64_t v37 = v43;
  }
  if ((Value[1] & 3) != 0)
  {
    *((void *)Value + 8) = v31;
    *((void *)Value + 9) = v33;
    *((void *)Value + 10) = v35;
    *((void *)Value + 11) = v37;
  }
  uint64_t v44 = [a1 zOrder];
  if ((Value[1] & 3) != 0) {
    *((void *)Value + 12) = v44;
  }
  if (v11 > 513)
  {
    switch(v11)
    {
      case 514:
        char v63 = [a1 lineBreakAfter];
        uint64_t v64 = Value;
        while (*(_DWORD *)v64 != 514)
        {
          uint64_t v64 = (char *)*((void *)v64 + 1);
          if (!v64) {
            goto LABEL_94;
          }
        }
        v64[104] = v63;
LABEL_94:
        [a1 rotationAngle];
        *((void *)Value + 4) = v67;
        return Value;
      case 516:
        char v65 = [a1 hasRotatedCharacters];
        uint64_t v66 = Value;
        while (*(_DWORD *)v66 != 516)
        {
          uint64_t v66 = (char *)*((void *)v66 + 1);
          if (!v66) {
            return Value;
          }
        }
        v66[104] = v65;
        return Value;
      case 1537:
        *(void *)&long long context = 0;
        if ([a1 isPreformattedWithUnitWidth:&context])
        {
          uint64_t v45 = Value;
          while (*(_DWORD *)v45 != 1537)
          {
            uint64_t v45 = (char *)*((void *)v45 + 1);
            if (!v45) {
              goto LABEL_105;
            }
          }
          *((void *)v45 + 14) = context;
        }
LABEL_105:
        if (!a1) {
          return Value;
        }
        goto LABEL_127;
    }
LABEL_91:
    if ((v11 & 0x100) == 0) {
      goto LABEL_125;
    }
    goto LABEL_111;
  }
  if (v11 == 257)
  {
    uint64_t v46 = [a1 imageData];
    if (!v46) {
      goto LABEL_111;
    }
    uint64_t v47 = v46;
    uint64_t v48 = *(void *)(v46 + 80);
    unsigned int v49 = *(const void **)(v46 + 96);
    uint64_t v50 = *(void *)(v46 + 160);
    uint64_t v51 = *(const void **)(v46 + 168);
    long long v52 = *(_OWORD *)(v46 + 120);
    long long context = *(_OWORD *)(v46 + 104);
    long long v131 = v52;
    long long v132 = *(_OWORD *)(v46 + 136);
    if (*(_DWORD *)Value == 257)
    {
      *((void *)Value + 15) = v48;
      if (v49) {
        CFRetain(v49);
      }
      *((void *)Value + 16) = v49;
      long long v53 = v131;
      *(_OWORD *)(Value + 136) = context;
      *(_OWORD *)(Value + 152) = v53;
      *(_OWORD *)(Value + 168) = v132;
      *((void *)Value + 23) = v50;
      if (v51) {
        CFRetain(v51);
      }
      *((void *)Value + 24) = v51;
    }
    if (*(void *)(v47 + 176) == -1) {
      goto LABEL_111;
    }
    uint64_t v54 = *(void *)(objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext") + 2344);
    int64_t v55 = *(void *)(v47 + 176);
    goto LABEL_110;
  }
  if (v11 != 258)
  {
    if (v11 == 259)
    {
      CGPDFNodeSetCGPDFAnnotation((uint64_t)Value, (CFTypeRef)[a1 cgAnnotation]);
      return Value;
    }
    goto LABEL_91;
  }
  int v125 = [a1 pdfObjectID];
  int v124 = [a1 windingRule];
  [a1 lineWidth];
  uint64_t v57 = v56;
  [a1 miterLimit];
  uint64_t v59 = v58;
  int v123 = [a1 lineCap];
  int v122 = [a1 lineJoin];
  uint64_t v60 = (const void *)[a1 fillColor];
  uint64_t v61 = (const void *)[a1 strokeColor];
  uint64_t v126 = [a1 fillObject];
  uint64_t v62 = [a1 strokeObject];
  if (a1)
  {
    [a1 paintTransform];
  }
  else
  {
    long long v128 = 0u;
    long long v129 = 0u;
    long long v127 = 0u;
  }
  if (*(_DWORD *)Value == 258)
  {
    *((_DWORD *)Value + 30) = v125;
    *((void *)Value + 16) = 0;
    Value[136] = v124 == 1;
    *((void *)Value + 18) = v57;
    *((void *)Value + 19) = v59;
    *((_DWORD *)Value + 40) = v123;
    *((_DWORD *)Value + 41) = v122;
    if (v60) {
      CFRetain(v60);
    }
    *((void *)Value + 21) = v60;
    if (v61) {
      CFRetain(v61);
    }
    *((void *)Value + 22) = v61;
    if (v126 | v62)
    {
      uint64_t v68 = malloc_type_malloc(0x40uLL, 0x1020040038FC326uLL);
      *((void *)Value + 23) = v68;
      void *v68 = v126;
      v68[1] = v62;
      *((_OWORD *)v68 + 2) = v128;
      *((_OWORD *)v68 + 3) = v129;
      *((_OWORD *)v68 + 1) = v127;
    }
    else
    {
      *((void *)Value + 23) = 0;
    }
  }
  if (([a1 mcid] & 0x8000000000000000) == 0)
  {
    uint64_t v69 = *(void *)(objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext") + 2344);
    int64_t v55 = [a1 mcid];
    uint64_t v54 = v69;
LABEL_110:
    CGPDFTaggedContextAddNode(v54, v55, (uint64_t)Value);
  }
LABEL_111:
  if ([a1 user])
  {
    uint64_t v70 = CGPDFNodeMakeFromCPChunk();
    uint64_t v71 = v70;
    if (Value[1]) {
      *((void *)Value + 14) = v70;
    }
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (v71)
      {
        if (*(_DWORD *)v71 == 1538 && (Value[1] & 1) != 0)
        {
          uint64_t v72 = *(void *)(v71 + 104);
          if (v72)
          {
            if (*(_DWORD *)v72 == 3)
            {
              uint64_t v73 = *(unsigned int *)(v72 + 32);
              *(void *)(*(void *)(v72 + 40) + 8 * v73) = Value;
              *(_DWORD *)(v72 + 32) = v73 + 1;
            }
          }
        }
      }
    }
  }
  unsigned int v74 = [a1 clipIndex];
  if (v74)
  {
    unsigned int v75 = v74;
    uint64_t v76 = objc_msgSend((id)objc_msgSend(a1, "page"), "PDFContext");
    int v77 = CGPDFNodeClipMakeFromClipIndex(v76 + 2208, v75, *(void *)(v76 + 2112), v16, a5);
    if (v77)
    {
      if (Value[1]) {
        *((void *)Value + 13) = v77;
      }
    }
  }
LABEL_125:
  if (!a1 || v11 < 0x400) {
    return Value;
  }
LABEL_127:
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    CGPDFNodeMakeSubType((uint64_t)Value, 3);
    int v78 = [a1 rowCount];
    uint64_t v79 = [a1 rowY];
    if (v78)
    {
      int v80 = (const void *)v79;
      if (v79)
      {
        if (*(_DWORD *)Value == 1538)
        {
          uint64_t v81 = *((void *)Value + 13);
          if (v81)
          {
            if (*(_DWORD *)v81 == 3)
            {
              free(*(void **)(v81 + 8));
              unsigned int v82 = malloc_type_malloc(8 * (v78 + 1), 0x100004000313F17uLL);
              *(void *)(v81 + 8) = v82;
              if (v82)
              {
                *(_DWORD *)(v81 + 4) = v78;
                memcpy(v82, v80, 8 * (v78 + 1));
              }
              else
              {
                *(_DWORD *)(v81 + 4) = 0;
              }
            }
          }
        }
      }
    }
    int v111 = [a1 columnCount];
    uint64_t v112 = [a1 columnX];
    if (v111)
    {
      uint64_t v113 = (const void *)v112;
      if (v112)
      {
        if (*(_DWORD *)Value == 1538)
        {
          uint64_t v114 = *((void *)Value + 13);
          if (v114)
          {
            if (*(_DWORD *)v114 == 3)
            {
              free(*(void **)(v114 + 24));
              unsigned int v115 = malloc_type_malloc(8 * (v111 + 1), 0x100004000313F17uLL);
              *(void *)(v114 + 24) = v115;
              if (v115)
              {
                *(_DWORD *)(v114 + 16) = v111;
                memcpy(v115, v113, 8 * (v111 + 1));
              }
              else
              {
                *(_DWORD *)(v114 + 16) = 0;
              }
            }
          }
        }
      }
    }
    unsigned int v116 = [a1 usedGraphicCount];
    if (*(_DWORD *)Value == 1538)
    {
      uint64_t v117 = *((void *)Value + 13);
      if (v117)
      {
        if (*(_DWORD *)v117 == 3)
        {
          unsigned int v118 = v116;
          free(*(void **)(v117 + 40));
          *(void *)(v117 + 40) = malloc_type_calloc(v118, 8uLL, 0x2004093837F09uLL);
          *(_DWORD *)(v117 + 32) = 0;
        }
      }
    }
    uint64_t v109 = [a1 backgroundColor];
    if (*(_DWORD *)Value == 1538)
    {
      uint64_t v110 = *((void *)Value + 13);
      if (v110)
      {
        if (*(_DWORD *)v110 == 3) {
          goto LABEL_180;
        }
      }
    }
    return Value;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return Value;
  }
  CGPDFNodeMakeSubType((uint64_t)Value, 2);
  uint64_t v83 = [a1 rowSpan];
  if (*(_DWORD *)Value == 1538)
  {
    uint64_t v85 = *((void *)Value + 13);
    if (v85)
    {
      if (*(_DWORD *)v85 == 2)
      {
        *(void *)(v85 + 8) = v83;
        *(void *)(v85 + 16) = v84;
      }
    }
  }
  uint64_t v86 = [a1 columnSpan];
  if (*(_DWORD *)Value == 1538)
  {
    uint64_t v88 = *((void *)Value + 13);
    if (v88)
    {
      if (*(_DWORD *)v88 == 2)
      {
        *(void *)(v88 + 24) = v86;
        *(void *)(v88 + 32) = v87;
      }
    }
  }
  for (uint64_t i = 0; i != 4; ++i)
  {
    int v90 = sideMap[i];
    [a1 boundsOfBorder:i];
    uint64_t v92 = v91;
    uint64_t v94 = v93;
    uint64_t v96 = v95;
    uint64_t v98 = v97;
    uint64_t v99 = [a1 colorOfBorder:i];
    if (*(_DWORD *)Value == 1538)
    {
      uint64_t v100 = *((void *)Value + 13);
      if (v100)
      {
        if (*(_DWORD *)v100 == 2)
        {
          unsigned int v101 = (const void *)v99;
          int v102 = *(char **)(v100 + 40);
          if (!v102)
          {
            int v103 = (char *)malloc_type_calloc(4uLL, 0x28uLL, 0x10200405CE47BF4uLL);
            if (!v103) {
              continue;
            }
            int v102 = v103;
            for (uint64_t j = 0; j != 160; j += 40)
              *(CGRect *)&v103[j] = CGRectNull;
          }
          char v105 = &v102[40 * v90];
          *(void *)char v105 = v92;
          *((void *)v105 + 1) = v94;
          *((void *)v105 + 2) = v96;
          *((void *)v105 + 3) = v98;
          int v108 = (const void *)*((void *)v105 + 4);
          uint64_t v107 = v105 + 32;
          uint64_t v106 = v108;
          if (v108 != v101)
          {
            if (v106) {
              CFRelease(v106);
            }
            if (v101) {
              CFRetain(v101);
            }
            *uint64_t v107 = v101;
          }
          *(void *)(v100 + 40) = v102;
        }
      }
    }
  }
  uint64_t v109 = [a1 backgroundColor];
  if (*(_DWORD *)Value != 1538) {
    return Value;
  }
  uint64_t v110 = *((void *)Value + 13);
  if (!v110 || *(_DWORD *)v110 != 2) {
    return Value;
  }
LABEL_180:
  unsigned int v119 = (const void *)v109;
  unsigned int v120 = *(const void **)(v110 + 48);
  if (v120 != v119)
  {
    if (v120) {
      CFRelease(v120);
    }
    if (v119) {
      CFRetain(v119);
    }
    *(void *)(v110 + 48) = v119;
  }
  return Value;
}

uint64_t CGPDFNodePopulateFromCPChunk(int *a1, void *a2, uint64_t a3, unsigned int *a4, CFDictionaryRef *a5, CFDictionaryRef *a6)
{
  uint64_t v288 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
LABEL_13:
    int v20 = [a2 count];
    if (v20)
    {
      int v21 = v20;
      unsigned int v22 = 0;
      uint64_t v23 = 0;
      do
      {
        unint64_t v24 = (void *)[a2 childAtIndex:v23];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0 || ![v24 anchoringTextLine])
        {
          uint64_t result = (uint64_t)CGPDFNodeMakeFromCPChunk(v24, a3, 0, a5, a6);
          if (!result) {
            return result;
          }
          unint64_t v25 = (_DWORD *)result;
          CGPDFNodeAddChild((uint64_t)a1, result, v22);
          CGPDFNodeRelease(v25);
          uint64_t result = CGPDFNodePopulateFromCPChunk(v25, v24, a3, a4, a5, a6);
          if (!result) {
            return result;
          }
          ++v22;
        }
        uint64_t v23 = (v23 + 1);
      }
      while (v21 != v23);
    }
    return 1;
  }
  int v9 = *a1;
  if ((*a1 & 0x100) == 0)
  {
    if (v9 != 516)
    {
      if (v9 == 513)
      {
        uint64_t result = CGPDFNodePopulateFromCPGraphicObject((uint64_t)a1, a2, a3, a4);
        if (!result) {
          return result;
        }
        uint64_t TextRange = CGPDFNodeGetTextRange((uint64_t)a1);
        uint64_t v13 = v12;
        int v14 = [a2 count];
        if (v14)
        {
          int v15 = v14;
          unsigned int v16 = 0;
          uint64_t v17 = 0;
          do
          {
            uint64_t v18 = (void *)[a2 childAtIndex:v17];
            if (![v18 anchoringTextLine])
            {
              uint64_t result = (uint64_t)CGPDFNodeMakeFromCPChunk(v18, a3, 0, a5, a6);
              if (!result) {
                return result;
              }
              uint64_t v19 = result;
              CGPDFNodeAddChild((uint64_t)a1, result, v16);
              CGPDFNodeRelease((_DWORD *)v19);
              *(void *)(v19 + 16) = TextRange;
              *(void *)(v19 + 24) = v13;
              ++v16;
            }
            uint64_t v17 = (v17 + 1);
          }
          while (v15 != v17);
        }
        return 1;
      }
      goto LABEL_13;
    }
    uint64_t v26 = a3;
    if (a3)
    {
      unsigned int v27 = [a2 count];
      uint64_t v28 = 0;
      BOOL v29 = 0;
      uint64_t v30 = 0;
      unint64_t v238 = v27;
      uint64_t v254 = a5;
      while (1)
      {
        BOOL v240 = v29;
        uint64_t v243 = v28;
        uint64_t v244 = v30;
        unsigned int v248 = objc_msgSend(a2, "childAtIndex:");
        int v247 = CGPDFNodeMakeFromCPChunk(v248, v26, 0, a5, a6);
        if (!v247) {
          break;
        }
        CGPDFNodeAddChild((uint64_t)a1, (uint64_t)v247, v244);
        CGPDFNodeRelease(v247);
        unsigned int v31 = [v248 count];
        if (v31)
        {
          __int32 v242 = 0;
          BOOL v32 = 0;
          uint64_t v33 = 0;
          int v34 = 84;
          unint64_t v245 = v31;
          do
          {
            BOOL v246 = v32;
            uint64_t v35 = (void *)[v248 childAtIndex:v33];
            uint64_t v36 = CGPDFNodeMakeFromCPChunk(v35, v26, 0, a5, a6);
            if (!v36)
            {
LABEL_270:
              if (!v246) {
                goto LABEL_273;
              }
              break;
            }
            uint64_t v37 = v36;
            CGPDFNodeAddChild((uint64_t)v247, (uint64_t)v36, v33);
            uint64_t v251 = (uint64_t)v37;
            CGPDFNodeRelease(v37);
            uint64_t v252 = v35;
            int v38 = (void *)[v35 listItem];
            uint64_t v249 = v33;
            if (v38)
            {
              uint64_t v39 = v38;
              if ([v38 paragraphCount])
              {
                uint64_t v40 = v35;
                if ((void *)[v39 paragraphAtIndex:0] != v35) {
                  goto LABEL_34;
                }
                uint64_t v41 = (void *)[v39 list];
                unsigned int v42 = [v41 itemCount];
                if (!v42) {
                  goto LABEL_34;
                }
                unsigned int v43 = v42;
                if ((void *)[v41 itemAtIndex:0] != v39)
                {
                  if (v242)
                  {
                    uint64_t v44 = *v242;
                    int v45 = [v39 paragraphCount];
                    if (v44)
                    {
                      uint64_t v46 = (_DWORD *)v251;
LABEL_66:
                      if (*(_DWORD *)v44 == 1537)
                      {
                        if (v45)
                        {
                          if (*v46 == 1537)
                          {
                            uint64_t v60 = *(void *)(v44 + 104);
                            if (v60)
                            {
                              if (*(_DWORD *)v60 == 1)
                              {
                                uint64_t v61 = *(void *)(v60 + 24);
                                if (v61)
                                {
                                  uint64_t v62 = *(unsigned int *)(v60 + 20);
                                  if (v62)
                                  {
                                    int v63 = *(_DWORD *)(v61 + 4 * (v62 - 1)) + v45;
                                  }
                                  else
                                  {
                                    *(void *)(v60 + 8) = v46;
                                    int v63 = v45 - 1;
                                  }
                                  *(_DWORD *)(v60 + 20) = v62 + 1;
                                  *(_DWORD *)(v61 + 4 * v62) = v63;
                                  if ((_DWORD *)v44 != v46)
                                  {
                                    unsigned int v235 = v46;
                                    CGPDFNodeRemoveSubType((uint64_t)v46);
                                    *((void *)v235 + 13) = v60;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    uint64_t v40 = v252;
                    if ((void *)[v41 itemAtIndex:v43 - 1] == v39)
                    {
                      unsigned int v236 = (uint64_t *)v242[1];
                      free(v242);
                      __int32 v242 = v236;
                      uint64_t v40 = v252;
                    }
                  }
                  else
                  {
                    __int32 v242 = 0;
                  }
LABEL_34:
                  uint64_t v26 = a3;
                  goto LABEL_75;
                }
                CGPDFNodeMakeSubType(v251, 1);
                if (*(_DWORD *)v251 == 1537)
                {
                  uint64_t v47 = *(void *)(v251 + 104);
                  if (v47)
                  {
                    if (*(_DWORD *)v47 == 1)
                    {
                      free(*(void **)(v47 + 24));
                      *(void *)(v47 + 24) = malloc_type_calloc(v43, 4uLL, 0x100004052888210uLL);
                      *(_DWORD *)(v47 + 20) = 0;
                    }
                  }
                }
                unsigned int v48 = [v41 type];
                if (*(_DWORD *)v251 == 1537)
                {
                  unsigned int v49 = *(_DWORD **)(v251 + 104);
                  if (v49)
                  {
                    if (*v49 == 1) {
                      v49[1] = listStyleFromOrdinalType[v48];
                    }
                  }
                }
                int v50 = [v39 number];
                if (*(_DWORD *)v251 == 1537)
                {
                  uint64_t v51 = *(_DWORD **)(v251 + 104);
                  if (v51)
                  {
                    if (*v51 == 1) {
                      v51[4] = v50;
                    }
                  }
                }
                int v52 = [v41 ordinalPrefixLength];
                if (*(_DWORD *)v251 == 1537)
                {
                  long long v53 = *(_DWORD **)(v251 + 104);
                  if (v53)
                  {
                    if (*v53 == 1) {
                      v53[8] = v52;
                    }
                  }
                }
                int v54 = [v41 ordinalSuffixLength];
                if (*(_DWORD *)v251 == 1537)
                {
                  int64_t v55 = *(_DWORD **)(v251 + 104);
                  if (v55)
                  {
                    if (*v55 == 1) {
                      v55[9] = v54;
                    }
                  }
                }
                char v56 = [v41 isMultilevel];
                if (*(_DWORD *)v251 == 1537)
                {
                  uint64_t v57 = *(void *)(v251 + 104);
                  if (v57)
                  {
                    if (*(_DWORD *)v57 == 1) {
                      *(unsigned char *)(v57 + 40) = v56;
                    }
                  }
                }
                uint64_t v58 = (uint64_t *)malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
                if (v58)
                {
                  uint64_t v59 = v58;
                  *uint64_t v58 = v251;
                  v58[1] = (uint64_t)v242;
                  int v45 = [v39 paragraphCount];
                  uint64_t v46 = (_DWORD *)v251;
                  __int32 v242 = v59;
                  uint64_t v44 = v251;
                  goto LABEL_66;
                }
              }
            }
            uint64_t v26 = a3;
            uint64_t v40 = v252;
LABEL_75:
            unsigned int v64 = [v40 count];
            if (v64)
            {
              BOOL v65 = 0;
              uint64_t v66 = 0;
              unint64_t v250 = v64;
              do
              {
                uint64_t v67 = (void *)[v252 childAtIndex:v66];
                uint64_t v261 = *(void *)(v26 + 48);
                [v67 baseline];
                double v268 = v68;
                float v270 = (void *)[v67 charSequence];
                unsigned int v265 = objc_msgSend((id)objc_msgSend(v67, "page"), "PDFContext");
                uint64_t v69 = (unsigned int *)[v67 inlineList];
                uint64_t v70 = v26;
                unsigned int v71 = [v67 wordCount];
                unint64_t v276 = [v67 inlineCount] + (unint64_t)v71;
                uint64_t v72 = CGPDFNodeMakeFromCPChunk(v67, v70, (uint64_t)&v276, a5, a6);
                if (!v72)
                {
                  *(_DWORD *)(v28 + 16) |= 0x20u;
                  uint64_t v26 = a3;
                  if (!v65) {
                    goto LABEL_270;
                  }
                  goto LABEL_261;
                }
                uint64_t v73 = v72;
                uint64_t v253 = v66;
                CGPDFNodeAddChild(v251, (uint64_t)v72, v66);
                uint64_t v260 = (uint64_t)v73;
                CGPDFNodeRelease(v73);
                unsigned int v74 = (void *)[v67 parent];
                double v275 = 0.0;
                int v257 = [v74 isPreformattedWithUnitWidth:&v275];
                if (!v276)
                {
                  uint64_t v26 = a3;
                  uint64_t v82 = v261;
                  goto LABEL_220;
                }
                unint64_t v79 = 0;
                unint64_t v80 = 0;
                unsigned int v81 = v34 | 1;
                unint64_t v259 = v71;
                uint64_t v26 = a3;
                unsigned int v263 = v67;
                uint64_t v82 = v261;
                do
                {
                  if (v69 && v80 >= *v69)
                  {
                    unint64_t v267 = v80;
                    int v103 = (void *)*((void *)v69 + 1);
                    uint64_t v281 = v260;
                    uint64_t v282 = v26;
                    uint64_t v283 = v28;
                    v284[0] = v81;
                    v284[1] = 0;
                    double v285 = v268;
                    uint64_t v286 = v254;
                    int v287 = a6;
                    int v104 = (char *)malloc_type_calloc(0x48uLL, 1uLL, 0x2C7ACE11uLL);
                    *(_DWORD *)int v104 = 1;
                    *((_DWORD *)v104 + 10) = 1;
                    *((_OWORD *)v104 + 1) = CPRangeNull;
                    *((void *)v104 + 4) = 0;
                    *((void *)v104 + 7) = 0;
                    *(void *)(v104 + 44) = 0;
                    v104[52] = 0;
                    CGPDFNodeAddChild(v260, (uint64_t)v104, v79);
                    CGPDFNodeRelease(v104);
                    uint64_t v105 = *(void *)(v26 + 48);
                    uint64_t v106 = CGPDFNodeMakeFromCPChunk(v103, v26, 0, v254, a6);
                    if (!v106) {
                      goto LABEL_215;
                    }
                    uint64_t v107 = v106;
                    if (*(_DWORD *)v104 == 1)
                    {
                      uint64_t v108 = *((void *)v104 + 8);
                      if (v108)
                      {
                        *(void *)(v108 + 8) = 0;
                        v104[52] = 0;
                        CGPDFNodeRelease((_DWORD *)v108);
                      }
                      else
                      {
                        v104[52] = 0;
                      }
                      *((void *)v104 + 8) = v107;
                      v104[52] = 1;
                      ++*((_DWORD *)v107 + 10);
                      *((void *)v107 + 1) = v104;
                    }
                    CGPDFNodeRelease(v107);
                    if (!CGPDFNodePopulateFromCPChunk(v107, v103, v26, v284, v254, a6)) {
                      goto LABEL_215;
                    }
                    uint64_t v109 = v282;
                    if (v282) {
                      uint64_t v110 = *(void *)(v282 + 48);
                    }
                    else {
                      uint64_t v110 = 0;
                    }
                    *((void *)v104 + 2) = v105;
                    *((void *)v104 + 3) = v110 - v105;
                    uint64_t v111 = *(void *)(v109 + 24) + 24 * *(void *)(v109 + 32);
                    uint64_t v28 = v111 - 24;
                    uint64_t v283 = v111 - 24;
                    *(_DWORD *)(v111 - 8) |= 2u;
                    uint64_t v112 = (const CGRect *)closestCharacter(v103);
                    uint64_t v113 = v112;
                    uint64_t v114 = &CGRectZero;
                    if (v112) {
                      uint64_t v114 = v112;
                    }
                    double height = v114->size.height;
                    [v103 renderedBounds];
                    CGFloat v126 = v122;
                    CGFloat v127 = v123;
                    CGFloat v128 = v124;
                    CGFloat v129 = v125;
                    if (v124 < 0.0 || v125 < 0.0)
                    {
                      CGRect v290 = CGRectStandardize(*(CGRect *)&v122);
                      double v130 = v290.origin.x + v290.size.width;
                      v290.origin.double x = v126;
                      v290.origin.double y = v127;
                      v290.size.double width = v128;
                      v290.size.double height = v129;
                      CGRect v291 = CGRectStandardize(v290);
                      double y = v291.origin.y;
                      if (!v113)
                      {
                        v292.origin.double x = v126;
                        v292.origin.double y = v127;
                        v292.size.double width = v128;
                        v292.size.double height = v129;
                        CGRect v293 = CGRectStandardize(v292);
                        CGFloat v127 = v293.origin.y;
                        goto LABEL_207;
                      }
                    }
                    else
                    {
                      double v130 = v122 + v124;
                      double y = v123;
                      if (!v113)
                      {
LABEL_207:
                        int v203 = CGPDFCharacterCreate(32, 0, v130, y, 0.0, height, 0.0, 0.0, 0.0, 0.0, v116, v117, v118, v119, v120, v121, *(uint64_t *)&v127);
                        if (v113)
                        {
                          unsigned int v204 = (const void *)[*(id *)(*(void *)&v113[5].origin.x + 64) cgPDFFont];
                          unsigned int v205 = CGPDFTextStyleCreate(v204, **(const void ***)&v113[5].origin.x, *(const void **)(*(void *)&v113[5].origin.x + 96), *(double *)(*(void *)&v113[5].origin.x + 72), v113[5].origin.y * 0.0174532925, v113[2].size.height - v285);
                          CGPDFLayoutAppendTextElement(v109, v203, v205, 0x400u);
                          if (v205) {
                            CGPDFTextStyleRelease(v205);
                          }
                        }
                        else
                        {
                          CGPDFLayoutAppendTextElement(v109, v203, 0, 0x400u);
                        }
                        uint64_t v26 = a3;
                        if (v203)
                        {
                          BOOL v84 = (*(void *)v203)-- == 1;
                          if (v84) {
                            free(v203);
                          }
                        }
LABEL_215:
                        uint64_t v67 = v263;
                        uint64_t v69 = (unsigned int *)*((void *)v69 + 2);
                        uint64_t v82 = v261;
                        unint64_t v80 = v267;
                        goto LABEL_216;
                      }
                    }
                    CGFloat v127 = v113[2].size.height;
                    goto LABEL_207;
                  }
                  if (v80 >= v259) {
                    goto LABEL_216;
                  }
                  unint64_t v266 = v80;
                  unint64_t v262 = v79;
                  int v264 = v69;
                  if (v257)
                  {
                    unsigned int v83 = [v263 spacesBeforeWordAtIndex:v80];
                    BOOL v84 = !v266 || v83 == 0;
                    uint64_t v85 = !v84;
                    unint64_t v86 = v83 - v85;
                    if (v83 != v85)
                    {
                      uint64_t v87 = (unsigned int *)[v263 wordAtIndex:v266];
                      double v88 = v275;
                      uint64_t v95 = [v270 charAtIndex:*v87];
                      double v96 = *(double *)(v95 + 24);
                      double v97 = *(double *)(v95 + 8);
                      double v98 = *(double *)v95 - (double)v86 * v88;
                      do
                      {
                        uint64_t v99 = CGPDFCharacterCreate(32, 0, v98, v97, v88, v96, 0.0, 0.0, 0.0, 0.0, v89, v90, v91, v92, v93, v94, *(void *)(v95 + 88));
                        if (!v99) {
                          break;
                        }
                        uint64_t v100 = v99;
                        unsigned int v101 = CGPDFTextStyleCreate((const void *)[*(id *)(*(void *)(v95 + 160) + 64) cgPDFFont], **(const void ***)(v95 + 160), *(const void **)(*(void *)(v95 + 160) + 96), *(double *)(*(void *)(v95 + 160) + 72), *(double *)(v95 + 168) * 0.0174532925, *(double *)(v95 + 88) - v268);
                        if (!v101)
                        {
                          BOOL v84 = (*(void *)v100)-- == 1;
                          if (v84) {
                            free(v100);
                          }
                          break;
                        }
                        int v102 = v101;
                        CGPDFLayoutAppendTextElement(a3, v100, v101, 0x400u);
                        BOOL v84 = (*(void *)v100)-- == 1;
                        if (v84) {
                          free(v100);
                        }
                        --v86;
                        CGPDFTextStyleRelease(v102);
                        double v98 = v88 + v98;
                      }
                      while (v86);
                    }
                  }
                  uint64_t v67 = v263;
                  uint64_t v271 = (_DWORD *)[v263 wordAtIndex:v266];
                  uint64_t v132 = v271[1];
                  uint64_t v133 = (char *)malloc_type_calloc(0x48uLL, 1uLL, 0x2C7ACE11uLL);
                  *(_DWORD *)uint64_t v133 = 1;
                  *((_DWORD *)v133 + 10) = 1;
                  *((_OWORD *)v133 + 1) = CPRangeNull;
                  *((void *)v133 + 4) = 0;
                  *((void *)v133 + 7) = 0;
                  *(void *)(v133 + 44) = 0;
                  v133[52] = 0;
                  CGPDFNodeAddChild(v260, (uint64_t)v133, v79);
                  CGPDFNodeRelease(v133);
                  uint64_t v134 = a3;
                  uint64_t v135 = *(void *)(a3 + 48);
                  uint64_t v274 = v132;
                  if (!v132) {
                    goto LABEL_198;
                  }
                  uint64_t v255 = *(void *)(a3 + 48);
                  uint64_t v256 = (uint64_t)v133;
                  uint64_t v136 = 0;
                  uint64_t v137 = 0;
                  uint64_t v138 = 0;
                  do
                  {
                    unint64_t v139 = [v270 charAtIndex:(*v271 + v137)];
                    if (!v138 || !isCharacterOverlay(v138, v139))
                    {
                      uint64_t v140 = *(unsigned __int16 *)(v139 + 72);
                      double v141 = *(double *)v139;
                      double v142 = *(double *)(v139 + 8);
                      double v143 = *(double *)(v139 + 16);
                      double v144 = *(double *)(v139 + 24);
                      double v145 = *(double *)(v139 + 32);
                      double v146 = *(double *)(v139 + 40);
                      double v147 = *(double *)(v139 + 48);
                      double v148 = *(double *)(v139 + 56);
                      double v272 = *(double *)(v139 + 168);
                      if (*(_WORD *)(v139 + 72))
                      {
                        LODWORD(v281) = 0;
                        LODWORD(v277) = 0;
                        if (decomposes(v140, &v281, &v277))
                        {
                          uint64_t v149 = v277;
                          uint64_t v150 = (CFArrayRef *)malloc_type_malloc(2 * v277, 0x1000040BDFB0063uLL);
                          unint64_t v151 = v150;
                          if (v150 && v149)
                          {
                            uint64_t v152 = 0;
                            int v153 = v281;
                            do
                            {
                              unsigned int v154 = ds[(v153 + v152)];
                              if (HIWORD(v154)) {
                                LOWORD(v154) = 0;
                              }
                              *((_WORD *)v150 + v152++) = v154;
                            }
                            while (v149 != v152);
                          }
                          else
                          {
                            uint64_t v149 = 0;
                          }
                        }
                        else
                        {
                          uint64_t v149 = 0;
                          unint64_t v151 = 0;
                        }
                        uint64_t v168 = v151;
                      }
                      else
                      {
                        unint64_t v155 = v265[258];
                        unint64_t v156 = v265[259];
                        unint64_t v157 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v156 - v155) >> 6) + 0xFFFFFFFF;
                        if (v155 >= v156) {
                          LODWORD(v157) = 0;
                        }
                        if (v156 > v139) {
                          unint64_t v158 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v139 - v155) >> 6);
                        }
                        else {
                          LODWORD(v158) = v157;
                        }
                        if (v155 <= v139) {
                          unsigned int v159 = v158;
                        }
                        else {
                          unsigned int v159 = 0;
                        }
                        unint64_t v151 = (CFArrayRef *)v265[287];
                        if (v151)
                        {
                          CFArrayRef v160 = v151[3];
                          if (v160)
                          {
                            CFIndex Count = CFArrayGetCount(v160);
                            if (Count >= 1)
                            {
                              CFIndex v162 = Count;
                              uint64_t v163 = v159;
                              uint64_t v164 = -1;
                              do
                              {
                                uint64_t v165 = v162 + v164;
                                if (v162 + v164 < 0 != __OFADD__(v162, v164)) {
                                  ++v165;
                                }
                                uint64_t v166 = v165 >> 1;
                                ValueAtIndedouble x = CFArrayGetValueAtIndex(v151[3], v165 >> 1);
                                if (!ValueAtIndex) {
                                  break;
                                }
                                if (*ValueAtIndex == v163)
                                {
                                  uint64_t v168 = 0;
                                  uint64_t v149 = ValueAtIndex[2];
                                  unint64_t v151 = (CFArrayRef *)ValueAtIndex[3];
                                  goto LABEL_158;
                                }
                                if (*ValueAtIndex >= v163) {
                                  CFIndex v162 = v166;
                                }
                                else {
                                  uint64_t v164 = v166;
                                }
                              }
                              while (v164 + 1 < v162);
                            }
                          }
                          uint64_t v149 = 0;
                          unint64_t v151 = 0;
                        }
                        else
                        {
                          uint64_t v149 = 0;
                        }
                        uint64_t v168 = 0;
LABEL_158:
                        uint64_t v134 = a3;
                      }
                      int v169 = MEMORY[0x18532B8C0](v140);
                      if (v169 == 13 || v169 == 1) {
                        *(unsigned char *)(v134 + 72) = 1;
                      }
                      unsigned int v176 = CGPDFCharacterCreate(v140, *(_WORD *)(v139 + 74), v141, v142, v143, v144, v145, v146, v147, v148, v170, v171, v172, v173, v174, v175, *(void *)(v139 + 88));
                      if (!v176) {
                        goto LABEL_170;
                      }
                      int v177 = v176;
                      unsigned int v178 = CGPDFTextStyleCreate((const void *)[*(id *)(*(void *)(v139 + 160) + 64) cgPDFFont], **(const void ***)(v139 + 160), *(const void **)(*(void *)(v139 + 160) + 96), *(double *)(*(void *)(v139 + 160) + 72), v272 * 0.0174532925, *(double *)(v139 + 88) - v268);
                      if (v178)
                      {
                        uint64_t v179 = v178;
                        CGPDFLayoutAppendTextElement(v134, v177, v178, v81);
                        if (v149)
                        {
                          unint64_t v180 = *(void **)(v134 + 56);
                          if (!v180)
                          {
                            unint64_t v180 = CPMultiUnicodesCreate();
                            *(void *)(v134 + 56) = v180;
                          }
                          CPMultiUnicodesAppend((uint64_t)v180, *(void *)(v134 + 48) - 1, v149, v151);
                        }
                        CGPDFTextStyleRelease(v179);
                      }
                      BOOL v84 = (*(void *)v177)-- == 1;
                      if (v84)
                      {
                        free(v177);
                        if (v168) {
LABEL_171:
                        }
                          free(v168);
                      }
                      else
                      {
LABEL_170:
                        if (v168) {
                          goto LABEL_171;
                        }
                      }
                      uint64_t v28 = *(void *)(v134 + 24) + 24 * *(void *)(v134 + 32) - 24;
                    }
                    uint64_t v181 = *(void *)(v139 + 184);
                    if (v181 != -1)
                    {
                      if (!v136)
                      {
                        uint64_t v136 = (void *)[objc_alloc(MEMORY[0x1E4F28BD0]) initWithCapacity:v274];
                        uint64_t v181 = *(void *)(v139 + 184);
                      }
                      objc_msgSend(v136, "addObject:", objc_msgSend(NSNumber, "numberWithLongLong:", v181));
                    }
                    unsigned int v81 = (v28 == 0) << 8;
                    ++v137;
                    uint64_t v138 = v139;
                  }
                  while (v137 != v274);
                  if (!v136) {
                    goto LABEL_195;
                  }
                  long long v279 = 0u;
                  long long v280 = 0u;
                  long long v277 = 0u;
                  long long v278 = 0u;
                  uint64_t v182 = [v136 countByEnumeratingWithState:&v277 objects:&v281 count:16];
                  if (!v182)
                  {

LABEL_195:
                    uint64_t v67 = v263;
                    goto LABEL_196;
                  }
                  uint64_t v183 = v182;
                  unint64_t v184 = 0;
                  uint64_t v185 = *(void *)v278;
                  int64_t v186 = -1;
                  do
                  {
                    for (uint64_t i = 0; i != v183; ++i)
                    {
                      if (*(void *)v278 != v185) {
                        objc_enumerationMutation(v136);
                      }
                      int v188 = *(void **)(*((void *)&v277 + 1) + 8 * i);
                      unint64_t v189 = [v136 countForObject:v188];
                      if (v189 > v184)
                      {
                        unint64_t v190 = v189;
                        int64_t v186 = [v188 longLongValue];
                        unint64_t v184 = v190;
                      }
                    }
                    uint64_t v183 = [v136 countByEnumeratingWithState:&v277 objects:&v281 count:16];
                  }
                  while (v183);

                  uint64_t v67 = v263;
                  if (v186 != -1)
                  {
                    uint64_t v133 = (char *)v256;
                    CGPDFTaggedContextAddNode(v265[293], v186, v256);
                    uint64_t v134 = a3;
                    goto LABEL_197;
                  }
                  uint64_t v134 = a3;
LABEL_196:
                  uint64_t v133 = (char *)v256;
LABEL_197:
                  uint64_t v135 = v255;
LABEL_198:
                  uint64_t v191 = *(void *)(v134 + 48) - v135;
                  *((void *)v133 + 2) = v135;
                  *((void *)v133 + 3) = v191;
                  *(_DWORD *)(v28 + 16) |= 2u;
                  uint64_t v192 = [v270 charAtIndex:(*v271 + v271[1] - 1)];
                  uint64_t v199 = CGPDFCharacterCreate(32, 0, *(double *)v192 + *(double *)(v192 + 16), *(double *)(v192 + 8), 0.0, *(double *)(v192 + 24), 0.0, 0.0, 0.0, 0.0, v193, v194, v195, v196, v197, v198, *(void *)(v192 + 88));
                  if (v199)
                  {
                    uint64_t v200 = v199;
                    uint64_t v201 = CGPDFTextStyleCreate((const void *)[*(id *)(*(void *)(v192 + 160) + 64) cgPDFFont], **(const void ***)(v192 + 160), *(const void **)(*(void *)(v192 + 160) + 96), *(double *)(*(void *)(v192 + 160) + 72), *(double *)(v192 + 168) * 0.0174532925, *(double *)(v192 + 88) - v268);
                    if (v201)
                    {
                      int v202 = v201;
                      CGPDFLayoutAppendTextElement(a3, v200, v201, 0x400u);
                      CGPDFTextStyleRelease(v202);
                    }
                    BOOL v84 = (*(void *)v200)-- == 1;
                    if (v84) {
                      free(v200);
                    }
                  }
                  unint64_t v80 = v266 + 1;
                  uint64_t v26 = a3;
                  uint64_t v82 = v261;
                  unint64_t v79 = v262;
                  uint64_t v69 = v264;
LABEL_216:
                  ++v79;
                  unsigned int v81 = 1;
                }
                while (v79 < v276);
LABEL_220:
                *(_DWORD *)(v28 + 16) |= 8u;
                uint64_t v206 = *(void *)(v26 + 48);
                int v207 = v257;
                if (v206 <= v82) {
                  int v207 = 0;
                }
                if (v207 == 1)
                {
                  *(void *)(v260 + 16) = v82;
                  *(void *)(v260 + 24) = v206 + ~v82;
                }
                uint64_t v208 = v206 - 1;
                a5 = v254;
                if (v82 < v206 - 1)
                {
                  while (v82 < 0 || *(void *)(v26 + 48) <= v82)
                  {
                    uint64_t v210 = 0;
                    uint64_t v211 = v82 + 1;
                    if (v211 >= 0) {
                      goto LABEL_230;
                    }
                    uint64_t v213 = v211;
                    p_double height = &CGRectNull.size.height;
                    p_size = &CGRectNull.size;
                    p_double y = &CGRectNull.origin.y;
                    BOOL v216 = 1;
                    double v223 = 0.0;
                    CGFloat v224 = INFINITY;
                    double v222 = 0.0;
                    CGFloat v221 = INFINITY;
                    uint64_t v230 = &CGRectNull;
LABEL_241:
                    double x = v230->origin.x;
                    double v78 = *p_height;
                    double width = p_size->width;
                    if (p_size->width < 0.0 || v78 < 0.0)
                    {
                      uint64_t v232 = *(void *)p_y;
                      double v233 = v230->origin.x;
                      *(CGRect *)(&v76 - 1) = CGRectStandardize(*(CGRect *)(&width - 2));
                      double x = v234;
                    }
                    if (v223 < 0.0 || (double v75 = v221, v222 < 0.0))
                    {
                      v294.origin.double x = v221;
                      v294.origin.double y = v224;
                      v294.size.double width = v223;
                      v294.size.double height = v222;
                      *(CGRect *)&double v75 = CGRectStandardize(v294);
                    }
                    if (!v216)
                    {
                      double v75 = x - v75;
                      *(CGFloat *)(v210 + 16) = v221;
                      *(CGFloat *)(v210 + 24) = v224;
                      *(double *)(v210 + 32) = v75;
                      *(double *)(v210 + 40) = v222;
                    }
                    uint64_t v82 = v213;
                    uint64_t v26 = a3;
                    if (v213 == v208) {
                      goto LABEL_256;
                    }
                  }
                  uint64_t v209 = *(void *)(v26 + 24);
                  if (v209) {
                    uint64_t v210 = *(void *)(v209 + 24 * v82);
                  }
                  else {
                    uint64_t v210 = 0;
                  }
                  uint64_t v211 = v82 + 1;
LABEL_230:
                  if (*(void *)(a3 + 48) <= v211)
                  {
                    uint64_t v213 = v211;
                    uint64_t v212 = 0;
                  }
                  else
                  {
                    uint64_t v212 = *(void *)(a3 + 24);
                    uint64_t v213 = v211;
                    if (v212) {
                      uint64_t v212 = *(void *)(v212 + 24 * v211);
                    }
                  }
                  p_double height = &CGRectNull.size.height;
                  p_size = &CGRectNull.size;
                  BOOL v216 = v210 == 0;
                  int v217 = (const CGRect *)(v210 + 16);
                  int v218 = (CGFloat *)(v210 + 24);
                  unsigned int v219 = (CGSize *)(v210 + 32);
                  unsigned int v220 = (CGFloat *)(v210 + 40);
                  if (!v210)
                  {
                    int v218 = &CGRectNull.origin.y;
                    unsigned int v219 = &CGRectNull.size;
                    unsigned int v220 = &CGRectNull.size.height;
                    int v217 = &CGRectNull;
                  }
                  CGFloat v221 = v217->origin.x;
                  double v222 = *v220;
                  double v223 = v219->width;
                  CGFloat v224 = *v218;
                  unint64_t v225 = (const CGRect *)(v212 + 16);
                  uint64_t v226 = (CGSize *)(v212 + 32);
                  __int32 v227 = (CGFloat *)(v212 + 40);
                  BOOL v228 = v212 == 0;
                  if (v212) {
                    p_double y = (CGFloat *)(v212 + 24);
                  }
                  else {
                    p_double y = &CGRectNull.origin.y;
                  }
                  if (v228)
                  {
                    uint64_t v230 = &CGRectNull;
                  }
                  else
                  {
                    p_size = v226;
                    p_double height = v227;
                    uint64_t v230 = v225;
                  }
                  goto LABEL_241;
                }
LABEL_256:
                if (objc_msgSend(v67, "lineBreakAfter", v75, v76, width, v78)) {
                  *(_WORD *)(*(void *)(*(void *)(v26 + 24) + 24 * *(void *)(v26 + 48) - 24) + 8) = 10;
                }
                uint64_t v66 = v253 + 1;
                int v34 = 4;
                BOOL v65 = v253 + 1 >= v250;
              }
              while (v253 + 1 != v250);
            }
            *(_DWORD *)(v28 + 16) |= 0x20u;
LABEL_261:
            *(_WORD *)(*(void *)(*(void *)(v26 + 24) + 24 * *(void *)(v26 + 48) - 24) + 8) = 10;
            uint64_t v33 = v249 + 1;
            int v34 = 20;
            BOOL v32 = v249 + 1 >= v245;
          }
          while (v249 + 1 != v245);
        }
        int v237 = *(_DWORD *)(v28 + 16) | 0x80;
        *(_DWORD *)(v28 + 16) = v237;
        uint64_t v30 = v244 + 1;
        BOOL v29 = v244 + 1 >= v238;
        if (v244 + 1 == v238) {
          goto LABEL_275;
        }
      }
LABEL_273:
      if (v240)
      {
        uint64_t v28 = v243;
        int v237 = *(_DWORD *)(v243 + 16);
LABEL_275:
        *(_DWORD *)(v28 + 16) = v237 | 0x200;
        return 1;
      }
    }
    return 0;
  }

  return CGPDFNodePopulateFromCPGraphicObject((uint64_t)a1, a2, a3, a4);
}

uint64_t CGPDFNodePopulateFromCPGraphicObject(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  if (!a3) {
    return 0;
  }
  unsigned int v8 = closestCharacter(a2);
  int v9 = v8;
  if (!v8
    || (uint64_t result = (uint64_t)CGPDFTextStyleCreate((const void *)[*(id *)(*((void *)v8 + 20) + 64) cgPDFFont], **((const void ***)v8 + 20), *(const void **)(*((void *)v8 + 20) + 96), *(double *)(*((void *)v8 + 20) + 72), 0.0, 0.0), (v9 = (void *)result) != 0))
  {
    uint64_t v11 = *(void *)(a3 + 48);
    [a2 renderedBounds];
    double v13 = v12;
    double v15 = v14;
    double v17 = v16;
    double v19 = v18;
    int v20 = (void *)[a2 anchoringTextLine];
    uint64_t v27 = *(void *)&v15;
    if (v20) {
      objc_msgSend(v20, "baseline", v15);
    }
    uint64_t v28 = CGPDFCharacterCreate(65532, 0, v13, v15, v17, v19, 0.0, 0.0, 0.0, 0.0, v21, v22, v23, v24, v25, v26, v27);
    CGPDFLayoutAppendTextElement(a3, v28, v9, *a4);
    *a4 = 0;
    if (v28)
    {
      if ((*(void *)v28)-- == 1) {
        free(v28);
      }
    }
    if (v9) {
      CGPDFTextStyleRelease(v9);
    }
    uint64_t result = 1;
    *(void *)(a1 + 16) = v11;
    *(void *)(a1 + 24) = 1;
  }
  return result;
}

void *closestCharacter(void *a1)
{
LABEL_1:
  while (1)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v2 = (void *)[a1 anchoringTextLine];
      if (v2)
      {
        unint64_t v3 = v2;
        uint64_t v4 = [v2 inlineList];
        if (v4)
        {
          unsigned int v5 = (unsigned int *)v4;
          while (*((void **)v5 + 1) != a1)
          {
            unsigned int v5 = (unsigned int *)*((void *)v5 + 2);
            if (!v5) {
              goto LABEL_15;
            }
          }
          uint64_t v6 = (void *)[v3 charSequence];
          int v7 = [v6 length];
          if (v7)
          {
            int v8 = v7;
            unsigned int v9 = *v5;
            if (v9 >= [v3 wordCount])
            {
              uint64_t v11 = (v8 - 1);
            }
            else
            {
              int v10 = (_DWORD *)[v3 wordAtIndex:*v5];
              uint64_t v11 = *v10 ? (*v10 - 1) : 0;
            }
            uint64_t result = (void *)[v6 charAtIndex:v11];
            if (result) {
              return result;
            }
          }
        }
      }
    }
LABEL_15:
    uint64_t result = (void *)[a1 parent];
    if (!result) {
      return result;
    }
    double v13 = result;
    uint64_t v14 = [result indexOf:a1];
    unsigned int v15 = [v13 count];
    unsigned int v16 = v15;
    if (v14 == 0x7FFFFFFFFFFFFFFFLL) {
      int v17 = 0;
    }
    else {
      int v17 = v14;
    }
    BOOL v18 = v17 != 0;
    uint64_t v19 = (v17 + 1);
    BOOL v20 = v19 < v15;
    if (!v17)
    {
      a1 = v13;
      if (v19 >= v15) {
        continue;
      }
    }
    LODWORD(v21) = v17;
    while (1)
    {
      if (v18)
      {
        uint64_t v21 = (v21 - 1);
        uint64_t result = (void *)rightDescendantCharacter((void *)[v13 childAtIndex:v21]);
        if (result) {
          return result;
        }
        if (v20)
        {
LABEL_27:
          uint64_t result = (void *)leftDescendantCharacter((void *)[v13 childAtIndex:v19]);
          int v17 = v19;
          if (result) {
            return result;
          }
        }
      }
      else
      {
        LODWORD(v21) = 0;
        if (v20) {
          goto LABEL_27;
        }
      }
      BOOL v18 = v21 != 0;
      uint64_t v19 = (v17 + 1);
      BOOL v20 = v19 < v16;
      if (!v21 && v19 >= v16)
      {
        a1 = v13;
        goto LABEL_1;
      }
    }
  }
}

  while (1)
  {
    byte = read_byte(a1, a2, a3, a4, a5, a6, a7, a8);
    if (byte == 10 || byte == 13) {
      break;
    }
    if (byte == -1) {
      return 0;
    }
  }
  do
  {
    do
      int v10 = read_byte(a1, a2, a3, a4, a5, a6, a7, a8);
    while (v10 == 10);
  }
  while (v10 == 13);
  if (v10 == -1) {
    return 0;
  }
  uint64_t v11 = 0;
  *a1 = v10;
  while (v11 != 14)
  {
    double v12 = aBoundingbox_0[v11];
    double v13 = read_byte(a1, a2, a3, a4, a5, a6, a7, a8);
    ++v11;
    if (v13 == -1 || v13 != v12) {
      goto LABEL_1;
    }
  }
  return 1;
}

uint64_t rightDescendantCharacter(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && (uint64_t v2 = (void *)[a1 charSequence]) != 0
    && (v3 = v2, (int v4 = [v2 length]) != 0))
  {
    return [v3 charAtIndex:(v4 - 1)];
  }
  else
  {
    uint64_t v6 = [a1 count] - 1;
    while (v6 != -1)
    {
      uint64_t result = rightDescendantCharacter([a1 childAtIndex:v6]);
      uint64_t v6 = (v6 - 1);
      if (result) {
        return result;
      }
    }
    return 0;
  }
}

uint64_t leftDescendantCharacter(void *a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && (uint64_t v2 = (void *)[a1 charSequence]) != 0
    && (unint64_t v3 = v2, [v2 length]))
  {
    return [v3 charAtIndex:0];
  }
  else
  {
    int v5 = [a1 count];
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = 0;
      while (1)
      {
        uint64_t result = leftDescendantCharacter([a1 childAtIndex:v7]);
        if (result) {
          break;
        }
        uint64_t v7 = (v7 + 1);
        if (v6 == v7) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFNodeTypeFromCPChunk()
{
  if (objc_opt_isKindOfClass()) {
    return 257;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 258;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 259;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 513;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 514;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1537;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 515;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 516;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1538;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1538;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1538;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1538;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 1538;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    return 517;
  }
  else {
    return 0;
  }
}

unint64_t CGPDFNodeSizeFromCPChunk(void *a1, const __CFSet *a2)
{
  int v4 = CGPDFNodeTypeFromCPChunk();
  if (v4 != 514)
  {
    int v10 = v4;
    if ((v4 & 0x100) != 0)
    {
      uint64_t v11 = objc_msgSend((id)objc_msgSend(a1, "page"), "clipBuffer");
      for (unsigned int i = [a1 clipIndex]; i; unsigned int i = *(_DWORD *)(*(void *)(v11 + 16) + 52 * v13))
      {
        unint64_t v13 = i;
        if (CFSetContainsValue(a2, (const void *)i)) {
          break;
        }
        CFSetAddValue(a2, (const void *)v13);
      }
    }
    unsigned int v14 = [a1 count];
    if (v14)
    {
      unsigned int v15 = v14;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      unsigned int v18 = v14;
      do
      {
        uint64_t v19 = (void *)[a1 childAtIndex:v16];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 && [v19 anchoringTextLine]) {
          --v18;
        }
        else {
          v17 += CGPDFNodeSizeFromCPChunk(v19, a2);
        }
        uint64_t v16 = (v16 + 1);
      }
      while (v15 != v16);
    }
    else
    {
      unsigned int v18 = 0;
      uint64_t v17 = 0;
    }
    if (v10 <= 513)
    {
      if (v10 > 256)
      {
        if (v10 == 257)
        {
          uint64_t v20 = 200;
          goto LABEL_47;
        }
        if (v10 == 258)
        {
          uint64_t v20 = 192;
          goto LABEL_47;
        }
      }
      else
      {
        if (!v10)
        {
          uint64_t v20 = 0;
          goto LABEL_47;
        }
        if (v10 == 1)
        {
          uint64_t v21 = 72;
          if (!v18) {
            uint64_t v21 = 64;
          }
          return v21 + v17;
        }
      }
    }
    else if (v10 <= 516)
    {
      if (v10 == 516)
      {
        uint64_t v20 = 112;
        goto LABEL_47;
      }
    }
    else
    {
      switch(v10)
      {
        case 517:
          uint64_t v20 = 144;
          goto LABEL_47;
        case 1537:
          uint64_t v20 = 136;
          goto LABEL_47;
        case 1538:
          uint64_t v20 = 120;
LABEL_47:
          uint64_t v21 = v20 + 8 * v18;
          return v21 + v17;
      }
    }
    uint64_t v20 = 112;
    if (v10 < 0x400) {
      uint64_t v20 = 104;
    }
    if ((v10 & 0x200) == 0) {
      uint64_t v20 = 120;
    }
    if ((v10 & 0x300) == 0) {
      uint64_t v20 = 64;
    }
    goto LABEL_47;
  }
  unsigned int v5 = [a1 wordCount];
  unsigned int v6 = [a1 inlineCount];
  unint64_t v7 = ((unint64_t)v5 << 6) + 8 * (v6 + v5) + 112;
  if (v6)
  {
    v7 += 72 * v6;
    uint64_t v8 = [a1 inlineList];
    if (v8)
    {
      uint64_t v9 = v8;
      do
      {
        v7 += CGPDFNodeSizeFromCPChunk(*(void *)(v9 + 8), a2);
        uint64_t v9 = *(void *)(v9 + 16);
      }
      while (v9);
    }
  }
  return v7;
}

const void *CGPDFNodeClipMakeFromClipIndex(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, CFDictionaryRef *a5)
{
  if (!a2) {
    return 0;
  }
  if (a5)
  {
    if (*a5)
    {
      Value = CFDictionaryGetValue(*a5, (const void *)a2);
      if (Value) {
        return Value;
      }
    }
    else
    {
      *a5 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
    }
  }
  uint64_t v11 = *(void *)(a1 + 16);
  unint64_t v12 = a2;
  uint64_t v13 = *(unsigned int *)(v11 + 52 * a2);
  if (v13 == a2) {
    Value = 0;
  }
  else {
    Value = (const void *)CGPDFNodeClipMakeFromClipIndex(a1, v13, a3, a4, a5);
  }
  uint64_t v14 = v11 + 52 * a2;
  uint64_t v24 = (_DWORD *)(v14 + 8);
  if (*(_DWORD *)(v14 + 8))
  {
    unsigned int v15 = *(_DWORD *)(v14 + 8) - 1;
    do
    {
      if (a4 && *(_DWORD *)a4 == 517)
      {
        uint64_t v16 = a3 + 216 * *(unsigned int *)(v11 + 52 * v12 + 4 * v15 + 12);
        int v17 = *(_DWORD *)(v16 + 72);
        unsigned int v18 = *(const void **)(v16 + 96);
        char v19 = *(unsigned char *)(v16 + 104);
        uint64_t v20 = *(unsigned int *)(a4 + 112);
        uint64_t v21 = *(void *)(a4 + 120) + 32 * v20;
        *(_DWORD *)uint64_t v21 = v17;
        if (v18)
        {
          CFRetain(v18);
          LODWORD(v20) = *(_DWORD *)(a4 + 112);
        }
        *(void *)(v21 + 8) = v18;
        *(unsigned char *)(v21 + 16) = v19 ^ 1;
        *(void *)(v21 + 24) = Value;
        *(_DWORD *)(a4 + 112) = v20 + 1;
        Value = (const void *)v21;
      }
      else
      {
        Value = 0;
      }
    }
    while ((unint64_t)v15--);
  }
  if (a5 && *a5 && Value && *v24) {
    CFDictionaryAddValue(*a5, (const void *)v12, Value);
  }
  return Value;
}

uint64_t countClips(uint64_t result, _DWORD *a2)
{
  a2[2] += *(_DWORD *)(*(void *)(*(void *)a2 + 16) + 52 * result + 8);
  return result;
}

uint64_t cmap_create_with_name(const void *a1)
{
  uint64_t v2 = 0;
  while (1)
  {
    unint64_t v3 = bsearch(a1, (&cmap_create_with_name_tables)[v2], (size_t)*(&cmap_create_with_name_tables)[v2 + 1], 0x20uLL, (int (__cdecl *)(const void *, const void *))CMapEntry_compare);
    if (v3) {
      break;
    }
    v2 += 2;
    if (v2 == 10) {
      return 0;
    }
  }
  unsigned int v5 = v3;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  CFDataRef v7 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)v3 + 2), *((void *)v3 + 3), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFDataRef v8 = v7;
  if (v7
    && (BytePtr = CFDataGetBytePtr(v7),
        CFIndex Length = CFDataGetLength(v8),
        (uint64_t v11 = CFReadStreamCreateWithBytesNoCopy(0, BytePtr, Length, v6)) != 0))
  {
    unint64_t v12 = v11;
    CFReadStreamOpen(v11);
    uint64_t v13 = malloc_type_calloc(1uLL, 0x38uLL, 0x10300405646078BuLL);
    uint64_t v4 = (uint64_t)v13;
    if (v13)
    {
      *(_DWORD *)uint64_t v13 = 1;
      v13[41] = 0;
      *((void *)v13 + 1) = read_string(v12);
      *(void *)(v4 + 16) = read_string(v12);
      buffer[0] = 0;
      CFIndex v14 = CFReadStreamRead(v12, buffer, 1);
      int v15 = buffer[0];
      if (!v14) {
        int v15 = 0;
      }
      *(_DWORD *)(v4 + 24) = v15;
      buffer[0] = 0;
      if (CFReadStreamRead(v12, buffer, 1)) {
        BOOL v16 = buffer[0] == 0;
      }
      else {
        BOOL v16 = 1;
      }
      char v17 = !v16;
      *(unsigned char *)(v4 + 40) = v17;
      if (v16)
      {
        *(_DWORD *)buffer = 0;
        CFIndex v18 = CFReadStreamRead(v12, buffer, 4);
        CFIndex v19 = bswap32(*(unsigned int *)buffer);
        if (v18) {
          CFIndex v20 = v19;
        }
        else {
          CFIndex v20 = 0;
        }
        uint64_t v21 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200404BE0E0E6uLL);
        if (v21)
        {
          buffer[0] = 0;
          CFIndex v22 = CFReadStreamRead(v12, buffer, 1);
          UInt8 v23 = buffer[0];
          if (!v22) {
            UInt8 v23 = 0;
          }
          *(unsigned char *)uint64_t v21 = v23;
          buffer[0] = 0;
          CFIndex v24 = CFReadStreamRead(v12, buffer, 1);
          UInt8 v25 = buffer[0];
          if (!v24) {
            UInt8 v25 = 0;
          }
          *((unsigned char *)v21 + 1) = v25;
          if (v20)
          {
            CFMutableArrayRef Mutable = CFArrayCreateMutable(0, v20, 0);
            *((void *)v21 + 1) = Mutable;
            if (Mutable)
            {
              do
              {
                buffer[0] = 0;
                if (CFReadStreamRead(v12, buffer, 1)) {
                  UInt8 v27 = buffer[0];
                }
                else {
                  UInt8 v27 = 0;
                }
                *(_DWORD *)buffer = 0;
                CFIndex v28 = CFReadStreamRead(v12, buffer, 4);
                unsigned int v29 = bswap32(*(unsigned int *)buffer);
                if (v28) {
                  unsigned int v30 = v29;
                }
                else {
                  unsigned int v30 = 0;
                }
                *(_DWORD *)buffer = 0;
                CFIndex v31 = CFReadStreamRead(v12, buffer, 4);
                unsigned int v32 = bswap32(*(unsigned int *)buffer);
                if (v31) {
                  unsigned int v33 = v32;
                }
                else {
                  unsigned int v33 = 0;
                }
                int v34 = csr_create(v27, v30, v33);
                v34[3] = cmap_cid_set_create_with_stream(v12);
                v34[2] = cmap_cid_set_create_with_stream(v12);
                CFArrayAppendValue(*((CFMutableArrayRef *)v21 + 1), v34);
                --v20;
              }
              while (v20);
              *(_DWORD *)buffer = 0;
              if (CFReadStreamRead(v12, buffer, 4) && *(_DWORD *)buffer) {
                operator new();
              }
              *((void *)v21 + 2) = 0;
            }
            else
            {
              cmap_csr_set_release((uint64_t)v21);
              uint64_t v21 = 0;
            }
          }
        }
        *(void *)(v4 + 48) = v21;
      }
    }
    CFReadStreamClose(v12);
    CFRelease(v12);
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFRelease(v8);
  if (v5[1])
  {
    uint64_t v35 = cmap_create_with_name();
    cmap_set_used_cmap(v4, v35);
    cmap_release(v35);
  }
  return v4;
}

uint64_t CMapEntry_compare(const char *a1, const char **a2)
{
  return strcmp(a1, *a2);
}

void function_evaluate_float(uint64_t a1, float *a2, float *a3, __n128 a4)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 48);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  MEMORY[0x1F4188790](a1, a4);
  unint64_t v12 = (char *)v19 - v11;
  if (v10 <= 0x1FFFFFFFFFFFFFFELL) {
    uint64_t v13 = (char *)v19 - v11;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v10 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012) {
    uint64_t v13 = (char *)malloc_type_malloc(8 * v9, 0x46D3CF5AuLL);
  }
  CFIndex v14 = (double *)&v13[8 * v7];
  if (v7)
  {
    int v15 = (double *)v13;
    do
    {
      float v16 = *a2++;
      *v15++ = v16;
      --v7;
    }
    while (v7);
  }
  CGFunctionEvaluate(a1, v13, v14);
  for (; v8; --v8)
  {
    double v17 = *v14++;
    float v18 = v17;
    *a3++ = v18;
  }
  if (v13 != v12) {
    free(v13);
  }
}

uint64_t (*__color_space_state_create_icc_block_invoke_2())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCreateImmutableCopy");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  color_space_state_create_icc_f_12 = (uint64_t (*)(void))v1;
  return result;
}

uint64_t colorsync_smart_null_7440()
{
  return 0;
}

uint64_t (*__color_space_state_create_icc_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  uint64_t result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    uint64_t result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncPrivateAPIVersion");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  color_space_state_create_icc_f = v1;
  return result;
}

CFTypeRef icc_create_icc_profile_ascii_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v8 + 24) != 6) {
    _CGHandleAssert("icc_create_icc_profile_ascii_description", 194, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased", "Colorspace must be ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  uint64_t v9 = *(void *)(v8 + 96);
  CFTypeRef result = *(CFTypeRef *)(v9 + 48);
  if (result) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(v9 + 16);
  if (copy_icc_profile_ascii_description_cglibrarypredicate != -1) {
    dispatch_once(&copy_icc_profile_ascii_description_cglibrarypredicate, &__block_literal_global_73);
  }
  unint64_t v12 = (__CFString *)copy_icc_profile_ascii_description_f(v11);
  uint64_t v13 = 0;
  if (!v12) {
    unint64_t v12 = @"<no description>";
  }
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v9 + 48), (unint64_t *)&v13, (unint64_t)v12, memory_order_relaxed, memory_order_relaxed);
  if (v13) {
    CFRelease(v12);
  }
  CFTypeRef result = *(CFTypeRef *)(v9 + 48);
  if (result)
  {
LABEL_10:
    return CFRetain(result);
  }
  return result;
}

uint64_t (*__copy_icc_profile_ascii_description_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyASCIIDescriptionString");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  copy_icc_profile_ascii_description_f = (uint64_t (*)(void))v1;
  return result;
}

uint64_t icc_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

char *color_space_state_create_icc_derivative_with_state(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  char v9 = a2;
  if (a2 && a3) {
    _CGHandleAssert("color_space_state_create_icc_derivative_with_state", 366, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "(is_scene_referred_derivative && is_display_referred_derivative) == false", "scene referred %d display referred %d", a6, a7, a8, 1);
  }
  if ((a2 & 1) == 0 && (a3 & 1) == 0) {
    _CGHandleAssert("color_space_state_create_icc_derivative_with_state", 368, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "(is_scene_referred_derivative || is_display_referred_derivative) == true", "scene referred %d display referred %d", a6, a7, a8, 0);
  }
  uint64_t v11 = (char *)malloc_type_calloc(0x78uLL, 1uLL, 0x35160744uLL);
  CFIndex v19 = v11;
  if (v11)
  {
    *(_DWORD *)uint64_t v11 = 1;
    *((_WORD *)v11 + 4) = 0;
    v11[10] = *(unsigned char *)(a1 + 10);
    v11[12] = *(unsigned char *)(a1 + 12);
    v11[11] = 0;
    *(_DWORD *)(v11 + 14) = *(_DWORD *)(a1 + 14);
    uint64_t v20 = *(void *)(a1 + 48);
    *((void *)v19 + 6) = v20;
    *((void *)v19 + 14) = icc_vtable;
    int v21 = *(_DWORD *)(a1 + 32);
    *((_DWORD *)v19 + 6) = 6;
    *((_DWORD *)v19 + 7) = v21;
    *((_DWORD *)v19 + 8) = v21;
    *((void *)v19 + 10) = 0;
    *((void *)v19 + 11) = 0;
    *((void *)v19 + 5) = icc_get_default_color_components(v20, v12, v13, v14, v15, v16, v17, v18);
    v19[18] = v9;
    v19[19] = v8;
    CFIndex v22 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F20409491EBA0uLL);
    *((void *)v19 + 12) = v22;
    if (v22)
    {
      UInt8 v23 = v22;
      *(_DWORD *)CFIndex v22 = 0;
      v22[1] = CGDataProviderRetain(*(CGDataProviderRef *)(*(void *)(a1 + 96) + 8));
      v23[2] = CFRetain(*(CFTypeRef *)(*(void *)(a1 + 96) + 16));
      v23[7] = *(void *)(*(void *)(a1 + 96) + 56);
      CFIndex v24 = malloc_type_malloc(16 * *((void *)v19 + 6), 0x100004000313F17uLL);
      v23[8] = v24;
      if (v24)
      {
        v19[13] = 1;
        for (uint64_t i = *(void *)(a1 + 48); i; --i)
          *v24++ = xmmword_1850CD900;
        *(_OWORD *)(v23 + 3) = *(_OWORD *)(*(void *)(a1 + 96) + 24);
        *((void *)v19 + 8) = icc_get_md5(v19, v25, v26, v27, v28, v29, v30, v31);
        *((void *)v19 + 9) = v33;
        return v19;
      }
      free(*((void **)v19 + 12));
    }
    free(v19);
    return 0;
  }
  return v19;
}

uint64_t (*__create_colorspace_using_colorspace_state_block_invoke())()
{
  if (CGLibraryLoadColorSyncDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_21589);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileContainsTag");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = colorsync_smart_null_7440;
  }
  create_colorspace_using_colorspace_state_f = (uint64_t (*)(void, void))v1;
  return result;
}

uint64_t CGColorSpaceICCGetPlatformProfile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v8 + 24) != 6) {
    _CGHandleAssert("CGColorSpaceICCGetPlatformProfile", 701, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased", "Colorspace not ICC based. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }
  return *(void *)(*(void *)(v8 + 96) + 16);
}

CGColorSpaceRef CGColorSpaceCreateFromAttachments(CGColorSpaceRef result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID()) {
      return 0;
    }
    if (CFDictionaryContainsKey(v1, @"kCGColorSpaceAttachment_CICP_data"))
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v1, @"kCGColorSpaceAttachment_CICP_data");
      if (Value)
      {
        CFDataRef v4 = Value;
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFDataGetTypeID() && CFDataGetLength(v4) >= 4)
        {
          BytePtr = CFDataGetBytePtr(v4);
          CFTypeRef result = CGColorSpaceCreateFromCICP(*(_DWORD *)BytePtr);
          if (result) {
            return result;
          }
        }
      }
    }
    if (!CFDictionaryContainsKey(v1, @"kCGColorSpace_Attachment_ICC_Data")) {
      return 0;
    }
    uint64_t v7 = (void *)CFDictionaryGetValue(v1, @"kCGColorSpace_Attachment_ICC_Data");
    return (CGColorSpaceRef)CGColorSpaceFromICCDataCacheGetRetained(v7);
  }
  return result;
}

uint64_t CGColorSpaceGetColorSyncProfile(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    int v2 = *(_DWORD *)(v1 + 24);
    if (v2 == 11)
    {
      uint64_t v3 = *(void *)(v1 + 96);
    }
    else
    {
      if (v2 != 6) {
        return 0;
      }
      uint64_t v3 = *(void *)(v1 + 96) + 16;
    }
    return *(void *)v3;
  }
  return result;
}

void pdf_xref_release(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 160);
    if (v2)
    {
      uint64_t v3 = (void *)(*(void *)(a1 + 168) + 32);
      do
      {
        if ((*((unsigned char *)v3 - 20) & 1) != 0 && *((_DWORD *)v3 - 6) == 9)
        {
          uint64_t v4 = *v3;
          if (*v3)
          {
            if (*(void *)(v4 + 16) == a1) {
              *(void *)(v4 + 16) = 0;
            }
          }
        }
        v3 += 5;
        --v2;
      }
      while (v2);
    }
    if (*(unsigned char *)(a1 + 176))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
      if (*(void *)(a1 + 160))
      {
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        while (1)
        {
          uint64_t v7 = *(void *)(a1 + 168);
          uint64_t v8 = v7 + v5;
          if (*(unsigned char *)(v7 + v5 + 12)) {
            break;
          }
LABEL_26:
          ++v6;
          v5 += 40;
          if (v6 >= *(void *)(a1 + 160)) {
            goto LABEL_27;
          }
        }
        int v9 = *(_DWORD *)(v8 + 8);
        if (v9 == 9)
        {
          uint64_t v12 = *(void *)(*(void *)(v7 + v5 + 32) + 48);
        }
        else
        {
          if (v9 != 8)
          {
            if (v9 == 7)
            {
              uint64_t v10 = *(void *)(v7 + v5 + 32);
              if (v10)
              {
                pthread_mutex_lock((pthread_mutex_t *)(v10 + 64));
                uint64_t v11 = *(const void ***)(v10 + 56);
                if (v11)
                {
                  *(void *)(v10 + 56) = 0;
                  CGPDFAssociationRelease(v11);
                }
                pthread_mutex_unlock((pthread_mutex_t *)(v10 + 64));
              }
            }
            goto LABEL_24;
          }
          uint64_t v12 = *(void *)(v7 + v5 + 32);
        }
        CGPDFDictionaryRemoveAssociation(v12);
LABEL_24:
        if ((*(_DWORD *)(v8 + 8) - 5) <= 4) {
          pdf_object_release_compound_value(v8);
        }
        goto LABEL_26;
      }
LABEL_27:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 96));
    }
    CGPDFSecurityManagerRelease(*(void *)(a1 + 40));
    CGPDFXRefStreamRelease(*(void *)(a1 + 8));
    CGPDFXRefTableRelease(*(void *)(a1 + 16));
    uint64_t v13 = *(const void **)(a1 + 24);
    if (v13) {
      CFRelease(v13);
    }
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    if (*(void *)a1) {
      CFRelease(*(CFTypeRef *)a1);
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
    free(*(void **)(a1 + 168));
    free((void *)a1);
  }
}

uint64_t xt_copy_url_for_name(uint64_t a1, const __CFString *a2)
{
  Copdouble y = CFStringCreateCopy(0, a2);
  if (xt_copy_url_for_name_predicate != -1) {
    dispatch_once(&xt_copy_url_for_name_predicate, &__block_literal_global_7732);
  }
  uint64_t v3 = xt_copy_url_for_name_f(Copy, 7, 0);
  CFRelease(Copy);
  return v3;
}

uint64_t (*__xt_copy_url_for_name_block_invoke())()
{
  if (CGLibraryLoadlibFontRegistryDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadlibFontRegistryDYLD_once, &__block_literal_global_13_21607);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadlibFontRegistryDYLD_handle;
  if (CGLibraryLoadlibFontRegistryDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadlibFontRegistryDYLD_handle, "XTCopyFontWithName");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = font_registry_smart_null;
  }
  xt_copy_url_for_name_f = (uint64_t (*)(void, void, void))v1;
  return result;
}

uint64_t font_registry_smart_null()
{
  return 0;
}

uint64_t xt_copy_all_urls()
{
  if (xt_copy_all_urls_predicate != -1) {
    dispatch_once(&xt_copy_all_urls_predicate, &__block_literal_global_4_7737);
  }
  float v0 = (uint64_t (*)(uint64_t))xt_copy_all_urls_f;

  return v0(7);
}

uint64_t (*__xt_copy_all_urls_block_invoke())()
{
  if (CGLibraryLoadlibFontRegistryDYLD_once != -1) {
    dispatch_once(&CGLibraryLoadlibFontRegistryDYLD_once, &__block_literal_global_13_21607);
  }
  CFTypeRef result = (uint64_t (*)())CGLibraryLoadlibFontRegistryDYLD_handle;
  if (CGLibraryLoadlibFontRegistryDYLD_handle) {
    CFTypeRef result = (uint64_t (*)())dlsym((void *)CGLibraryLoadlibFontRegistryDYLD_handle, "XTCopyAvailableFontURLs");
  }
  if (result) {
    uint64_t v1 = result;
  }
  else {
    uint64_t v1 = font_registry_smart_null;
  }
  xt_copy_all_urls_f = v1;
  return result;
}

CGColorSpaceRef CGColorSpaceCreateIndexed(CGColorSpaceRef baseSpace, size_t lastIndex, const unsigned __int8 *colorTable)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (lastIndex > 0xFF) {
    goto LABEL_23;
  }
  if (!baseSpace) {
    goto LABEL_23;
  }
  if (!colorTable) {
    goto LABEL_23;
  }
  int Type = CGColorSpaceGetType(baseSpace);
  if (Type == 7) {
    goto LABEL_23;
  }
  if (Type == 9) {
    goto LABEL_23;
  }
  uint64_t v12 = (char *)malloc_type_calloc(0x78uLL, 1uLL, 0x3DC1B04EuLL);
  if (!v12) {
    goto LABEL_23;
  }
  uint64_t v13 = (uint64_t)v12;
  *(_DWORD *)uint64_t v12 = 1;
  uint64_t v14 = *((void *)baseSpace + 3);
  v12[12] = *(unsigned char *)(v14 + 12);
  *((_DWORD *)v12 + 2) = 0;
  *((_WORD *)v12 + 7) = 0;
  LODWORD(v14) = *(_DWORD *)(v14 + 32);
  *((void *)v12 + 14) = color_space_state_create_indexed_indexed_vtable;
  *((void *)v12 + 3) = 0x500000007;
  uint64_t v15 = v12 + 24;
  *((_DWORD *)v12 + 8) = v14;
  *((void *)v12 + 10) = 0;
  *((void *)v12 + 11) = 0;
  *((void *)v12 + 5) = &indexed_get_default_color_components_default_indexed;
  *((void *)v12 + 6) = 1;
  uint64_t v16 = (CGColorSpaceRef *)malloc_type_calloc(0x90uLL, 1uLL, 0xDBCE9105uLL);
  *(void *)(v13 + 96) = v16;
  if (!v16)
  {
LABEL_22:
    free((void *)v13);
LABEL_23:
    uint64_t v28 = (CGColorSpace *)CGColorSpaceCreateWithState(0, lastIndex, (uint64_t)colorTable, v3, v4, v5, v6, v7);
    goto LABEL_24;
  }
  uint64_t v17 = v16;
  CFRetain(baseSpace);
  *uint64_t v17 = baseSpace;
  v17[1] = (CGColorSpaceRef)lastIndex;
  size_t v18 = *(void *)(*((void *)baseSpace + 3) + 48) + *(void *)(*((void *)baseSpace + 3) + 48) * lastIndex;
  CFIndex v19 = (CGColorSpace *)malloc_type_malloc(v18, 0xCA8BCBA7uLL);
  v17[2] = v19;
  if (!v19)
  {
    free(*(void **)(v13 + 96));
    goto LABEL_22;
  }
  if (v18)
  {
    for (uint64_t i = 0; i != v18; ++i)
      *((unsigned char *)v17[2] + i) = colorTable[i];
  }
  memset(md, 0, 16);
  int v21 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v21);
  if (v21) {
    CC_MD5_Update(v21, v15, 4u);
  }
  CFIndex v22 = *(uint64_t **)(v13 + 96);
  uint64_t v23 = *v22;
  if (*v22)
  {
    uint64_t v24 = *(void *)(v23 + 24);
    if (v24) {
      BOOL v25 = v21 == 0;
    }
    else {
      BOOL v25 = 1;
    }
    if (v25)
    {
      uint64_t v27 = v22 + 1;
      uint64_t v26 = v22[1];
    }
    else
    {
      CC_MD5_Update(v21, (const void *)(v24 + 64), 0x10u);
      uint64_t v23 = *v22;
      uint64_t v27 = v22 + 1;
      uint64_t v26 = v22[1];
      if (!*v22) {
        goto LABEL_31;
      }
    }
    uint64_t v23 = *(void *)(*(void *)(v23 + 24) + 48);
  }
  else
  {
    uint64_t v27 = v22 + 1;
    uint64_t v26 = v22[1];
  }
  if (v21)
  {
LABEL_31:
    md5_update(v21, (char *)v22[2], v23 + v23 * v26);
    CC_MD5_Update(v21, v27, 8u);
    CC_MD5_Final(md, v21);
    long long v30 = *(_OWORD *)md;
    goto LABEL_33;
  }
  long long v30 = 0uLL;
LABEL_33:
  long long v38 = v30;
  free(v21);
  *(_OWORD *)(v13 + 64) = v38;
  uint64_t v28 = (CGColorSpace *)CGColorSpaceCreateWithState((atomic_uint *)v13, v31, v32, v33, v34, v35, v36, v37);
  if (atomic_fetch_add_explicit((atomic_uint *volatile)v13, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc(v13);
  }
LABEL_24:
  if (v28) {
    *((void *)v28 + 3) = color_space_state_register(*((unsigned char **)v28 + 3));
  }
  return v28;
}

uint64_t indexed_get_descriptor(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void indexed_finalize(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  if (v1)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)v1);
    uint64_t v2 = *(void **)(v1 + 16);
    free(v2);
  }
}

size_t CGColorSpaceGetColorTableCount(size_t space)
{
  if (space)
  {
    uint64_t v1 = *(void *)(space + 24);
    if (*(_DWORD *)(v1 + 28) == 5) {
      return *(void *)(*(void *)(v1 + 96) + 8) + 1;
    }
    else {
      return 0;
    }
  }
  return space;
}

CFDataRef CGColorSpaceCopyColorTable(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v1 + 28) != 5) {
    return 0;
  }
  uint64_t v2 = *(uint64_t **)(v1 + 96);
  uint64_t v3 = *v2;
  if (*v2) {
    uint64_t v3 = *(void *)(*(void *)(v3 + 24) + 48);
  }
  return CFDataCreate(0, (const UInt8 *)v2[2], v3 * (v2[1] + 1));
}

void CGColorSpaceGetColorTable(CGColorSpaceRef space, uint8_t *table)
{
  if (space)
  {
    if (table)
    {
      uint64_t v2 = *((void *)space + 3);
      if (*(_DWORD *)(v2 + 28) == 5)
      {
        uint64_t v3 = *(uint64_t **)(v2 + 96);
        uint64_t v4 = *v3;
        if (*v3) {
          uint64_t v4 = *(void *)(*(void *)(v4 + 24) + 48);
        }
        uint64_t v5 = v4 * (v3[1] + 1);
        if (v5)
        {
          for (uint64_t i = 0; i != v5; ++i)
            table[i] = *(unsigned char *)(v3[2] + i);
        }
      }
    }
  }
}

CGFloat *CGClipCreateWithPath(CFTypeRef cf, __int16 a2, char a3, double a4)
{
  if (!cf) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 != CGPathGetTypeID()) {
      return 0;
    }
  }
  memset(&v13, 0, sizeof(v13));
  if (CGPathIsRect((CGPathRef)cf, &v13)) {
    return CGClipCreateWithRect(0, a3, v13.origin.x, v13.origin.y, v13.size.width, v13.size.height);
  }
  uint64_t v10 = (double *)CGClipCreate(a2, a3);
  int v9 = v10;
  if (v10)
  {
    v10[4] = a4;
    MutableCopdouble y = CGPathCreateMutableCopy((CGPathRef)cf);
    *((void *)v9 + 3) = MutableCopy;
    if (!MutableCopy)
    {
      CGClipRelease((char *)v9);
      return 0;
    }
  }
  return v9;
}

char *CGClipCreateWithStrokedPath(CFTypeRef cf, uint64_t a2)
{
  if (!cf) {
    return 0;
  }
  if (CGPathDisableTypeValidation)
  {
    BOOL v4 = 1;
  }
  else
  {
    CFTypeID v5 = CFGetTypeID(cf);
    BOOL v4 = v5 == CGPathGetTypeID();
  }
  uint64_t v6 = 0;
  if (a2)
  {
    if (v4)
    {
      char v7 = *(unsigned char *)(a2 + 67);
      CFTypeID v8 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
      uint64_t v6 = v8;
      if (v8)
      {
        *(_DWORD *)CFTypeID v8 = 1;
        *((_DWORD *)v8 + 1) = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
        *((_WORD *)v8 + 4) = 514;
        *((void *)v8 + 2) = 0;
        v8[10] = v7;
        *((void *)v8 + 4) = *(void *)(a2 + 88);
        MutableCopdouble y = CGPathCreateMutableCopy((CGPathRef)cf);
        *((void *)v6 + 3) = MutableCopy;
        if (MutableCopy)
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)a2, 1u, memory_order_relaxed);
          *((void *)v6 + 2) = a2;
          return v6;
        }
        CGClipRelease(v6);
        return 0;
      }
    }
  }
  return v6;
}

atomic_uint *CGClipCreateWithTextClipping(atomic_uint *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeRef result = (atomic_uint *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    if (result)
    {
      *CFTypeRef result = 1;
      result[1] = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
      *((_WORD *)result + 4) = 4;
      *((void *)result + 2) = 0;
      *((unsigned char *)result + 10) = 1;
      atomic_fetch_add_explicit(v1, 1u, memory_order_relaxed);
      *((void *)result + 3) = v1;
    }
  }
  return result;
}

atomic_uint *CGClipRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t CGClipGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t CGClipEqualToClip(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    int v5 = *(unsigned __int16 *)(a1 + 8);
    if (v5 != *(unsigned __int16 *)(a2 + 8)) {
      return 0;
    }
    uint64_t result = CGClipStrokeEqualToClipStroke(*(void *)(a1 + 16), *(void *)(a2 + 16));
    if (!result) {
      return result;
    }
    if (*(unsigned __int8 *)(a1 + 10) == *(unsigned __int8 *)(a2 + 10))
    {
      switch((char)v5)
      {
        case 0:
          if (!CGRectEqualToRect(*(CGRect *)(a1 + 24), *(CGRect *)(a2 + 24))) {
            return 0;
          }
          goto LABEL_17;
        case 2:
          uint64_t result = CGPathEqualToPath(*(CGPathRef *)(a1 + 24), *(CGPathRef *)(a2 + 24));
          if (result) {
            goto LABEL_17;
          }
          return result;
        case 3:
          if (!CGClipMaskEqualToClipMask(*(void *)(a1 + 24), *(void *)(a2 + 24))) {
            return 0;
          }
          goto LABEL_17;
        case 4:
          uint64_t result = CGTextClippingEqualToTextClipping(*(void *)(a1 + 24), *(void *)(a2 + 24));
          if (result) {
            goto LABEL_17;
          }
          return result;
        default:
LABEL_17:
          uint64_t result = 1;
          break;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGClipGetMode(uint64_t a1)
{
  return *(char *)(a1 + 9);
}

uint64_t CGClipGetType(uint64_t a1)
{
  return *(char *)(a1 + 8);
}

uint64_t CGClipGetShouldAntialias(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 10);
}

double CGClipGetFlatness(uint64_t a1)
{
  double result = 1.0;
  if (*(unsigned char *)(a1 + 8) == 2) {
    return *(double *)(a1 + 32);
  }
  return result;
}

CGFloat CGClipGetRect(uint64_t a1)
{
  uint64_t v1 = &CGRectNull;
  if (!*(unsigned char *)(a1 + 8)) {
    uint64_t v1 = (const CGRect *)(a1 + 24);
  }
  return v1->origin.x;
}

uint64_t CGClipGetPath(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8) == 2) {
    return *(void *)(a1 + 24);
  }
  else {
    return 0;
  }
}

uint64_t CGClipGetStroke(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 9) << 8 == 512) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

uint64_t CGClipGetTextClipping(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8) == 4) {
    return *(void *)(a1 + 24);
  }
  else {
    return 0;
  }
}

uint64_t CGClipGetMask(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8) == 3) {
    return *(void *)(a1 + 24);
  }
  else {
    return 0;
  }
}

uint64_t CGClipCreateClipPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(char *)(a1 + 8);
  if (!*(unsigned char *)(a1 + 8))
  {
    CGPathRef Path = CGPathCreateWithRect(*(CGRect *)(a1 + 24), 0);
    goto LABEL_10;
  }
  if (v9 == 4)
  {
    CGPathRef Path = CGTextClippingCreatePath(*(void *)(a1 + 24));
LABEL_10:
    uint64_t v20 = (char *)Path;
    uint64_t v21 = *(void *)(a1 + 16);
    if (!v21) {
      return (uint64_t)v20;
    }
    StrokedCGPathRef Path = (void *)CGClipStrokeCreateStrokedPath(v21, v20, v14, v15, v16, v17, v18, v19);
    if (v20) {
      CFRelease(v20);
    }
    return (uint64_t)StrokedPath;
  }
  if (v9 != 2) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  StrokedCGPathRef Path = *(void **)(a1 + 24);
  if (!v10)
  {
    if (StrokedPath) {
      CFRetain(StrokedPath);
    }
    return (uint64_t)StrokedPath;
  }

  return CGClipStrokeCreateStrokedPath(v10, (char *)StrokedPath, a3, a4, a5, a6, a7, a8);
}

void op_EMC_7999(uint64_t a1, uint64_t a2)
{
  BOOL v4 = *(uint64_t **)(a1 + 144);
  if (v4)
  {
    uint64_t v5 = *v4;
    free(v4);
    *(void *)(a1 + 144) = v5;
  }
  uint64_t v6 = *(_DWORD **)(a1 + 96);
  if (v6)
  {
    int v7 = v6[2];
    uint64_t v8 = *(void *)v6;
    free(v6);
    *(void *)(a1 + 96) = v8;
    switch(v7)
    {
      case 1:
        CGPDFDrawingContextRestoreGState(a2);
        CGPDFDrawingContextRestoreGState(a2);
        break;
      case 3:
        if (*(void *)(a2 + 96))
        {
          uint64_t v12 = *(CGContext **)(a2 + 88);
          CGPDFContextEndTag(v12);
        }
        break;
      case 2:
        free(*(void **)(a1 + 24));
        int v9 = *(uint64_t **)(a1 + 32);
        if (v9)
        {
          uint64_t v10 = *v9;
          free(v9);
          *(void *)(a1 + 32) = v10;
          if (v10) {
            uint64_t v11 = *(void *)(v10 + 8);
          }
          else {
            uint64_t v11 = 0;
          }
        }
        else
        {
          uint64_t v11 = 0;
          *(void *)(a1 + 32) = 0;
        }
        *(void *)(a1 + 24) = v11;
        break;
    }
  }
}

void op_BMC_8000(CGPDFScanner *a1)
{
  CGPDFStreamRef value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    if (!strcmp(value, "AAPL:StyleContent"))
    {
      if (a1)
      {
        uint64_t v6 = *((void *)a1 + 12);
        int v7 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        void *v7 = v6;
        v7[1] = 2;
        *((void *)a1 + 12) = v7;
      }
      uint64_t v8 = *((void *)a1 + 18);
      int v9 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      void *v9 = v8;
      v9[1] = 1;
      *((void *)a1 + 18) = v9;
      uint64_t v10 = CGPDFOperatorTableCreate();
      if (v10)
      {
        uint64_t v11 = v10;
        CGPDFOperatorTableSetCallback(v10, "BMC", (CGPDFOperatorCallback)op_BMC_8000);
        CGPDFOperatorTableSetCallback(v11, "BDC", (CGPDFOperatorCallback)op_BDC_8002);
        CGPDFOperatorTableSetCallback(v11, "EMC", (CGPDFOperatorCallback)op_EMC_7999);
        CGPDFScannerPushTable(a1, (uint64_t)v11);
        CFRelease(v11);
      }
    }
    else
    {
      if (a1)
      {
        uint64_t v2 = *((void *)a1 + 12);
        uint64_t v3 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        void *v3 = v2;
        v3[1] = 0;
        *((void *)a1 + 12) = v3;
      }
      uint64_t v4 = *((void *)a1 + 18);
      uint64_t v5 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
      *uint64_t v5 = v4;
      v5[1] = 1;
      *((void *)a1 + 18) = v5;
    }
  }
}

void op_BDC_8002(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 > 0)
  {
    uint64_t v5 = *(void *)(a1 + 80);
    unsigned int v6 = v2 - 1;
    CGPDFObjectRef v42 = (CGPDFObjectRef)(v5 + 40 * (v2 - 1));
    CGPDFStreamRef value = 0;
    *(_DWORD *)(a1 + 72) = v2 - 1;
    if (!CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value)) {
      return;
    }
    if (v5)
    {
      int v7 = *(_DWORD *)(v5 + 40 * v6 + 8);
      if (v7 == 5)
      {
        uint64_t v10 = *(const char **)(v5 + 40 * v6 + 32);
        if (v10)
        {
          CGPDFObjectRef Resource = CGPDFContentStreamGetResource(*(CGPDFContentStreamRef *)a2, "Properties", v10);
          if (!Resource || *((_DWORD *)Resource + 2) != 8)
          {
            BOOL v14 = 0;
            CGPDFInteger v15 = -1;
            goto LABEL_19;
          }
          uint64_t v8 = (CGPDFDictionary **)((char *)Resource + 32);
          goto LABEL_7;
        }
      }
      else if (v7 == 8)
      {
        uint64_t v8 = (CGPDFDictionary **)(v5 + 40 * v6 + 32);
LABEL_7:
        int v9 = *v8;
        goto LABEL_16;
      }
    }
    int v9 = 0;
LABEL_16:
    CGPDFInteger valuePtr = -1;
    BOOL Integer = CGPDFDictionaryGetInteger(v9, "MCID", &valuePtr);
    BOOL v13 = valuePtr >= 0;
    BOOL v14 = Integer && v13;
    if (Integer && v13) {
      CGPDFInteger v15 = valuePtr;
    }
    else {
      CGPDFInteger v15 = -1;
    }
LABEL_19:
    uint64_t v16 = value;
    if (!strcmp(value, "OC"))
    {
      if (v5)
      {
        if (*(_DWORD *)(v5 + 40 * v6 + 8) == 5)
        {
          PropertyList = CGPDFContentStreamGetPropertyList(*(void *)(a1 + 56), *(const char **)(v5 + 40 * v6 + 32));
          if (PropertyList)
          {
            BOOL ShouldDrawOCG = CGPDFDrawingContextShouldDrawOCG(a2, PropertyList[4], PropertyList[5]);
            uint64_t v32 = *(void *)(a1 + 96);
            uint64_t v33 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
            *uint64_t v33 = v32;
            v33[1] = 0;
            *(void *)(a1 + 96) = v33;
            uint64_t v34 = *(void *)(a1 + 144);
            uint64_t v35 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
            *uint64_t v35 = v34;
            v35[1] = ShouldDrawOCG;
LABEL_49:
            *(void *)(a1 + 144) = v35;
            return;
          }
        }
        CGPDFDrawingContextSaveGState(a2);
LABEL_40:
        if (*(_DWORD *)(v5 + 40 * v6 + 8) == 5)
        {
          long long v38 = *(char **)(v5 + 40 * v6 + 32);
          CGPDFStreamRef value = v38;
          uint64_t v39 = a2 ? *(void *)a2 : 0;
          uint64_t v40 = (CGPDFDictionary *)CGPDFContentStreamGetPropertyList(v39, v38);
          if (CGPDFDictionaryGetObject(v40, "Style", &v42)) {
            set_style(a2, (uint64_t)v42);
          }
        }
        goto LABEL_47;
      }
      CGPDFDrawingContextSaveGState(a2);
    }
    else
    {
      if (v14)
      {
        uint64_t v17 = *(void *)(a1 + 96);
        uint64_t v18 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *uint64_t v18 = v17;
        v18[1] = 3;
        *(void *)(a1 + 96) = v18;
        BOOL v25 = *(const void **)(a2 + 96);
        if (v25)
        {
          uint64_t v26 = *(void *)(a2 + 88);
          CGPDFInteger valuePtr = v15;
          if (v26 && *(_DWORD *)(v26 + 16) == 1129601108 && *(_DWORD *)(v26 + 24) == 1)
          {
            CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            CFDictionarySetValue(Mutable, @"PageProperties", v25);
            CGCFDictionarySetNumber(Mutable, @"MCID", kCFNumberSInt64Type, &valuePtr);
            uint64_t v28 = *(void *)(v26 + 40);
            if (v28)
            {
              uint64_t v29 = *(void (**)(void))(v28 + 168);
              if (v29) {
                v29();
              }
            }
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
          else
          {
            handle_invalid_context((char)"CGPDFContextBeginTagWithMCID", v26, v19, v20, v21, v22, v23, v24);
          }
        }
        return;
      }
      if (strcmp(v16, "AAPL:Style"))
      {
        uint64_t v36 = *(void *)(a1 + 96);
        uint64_t v37 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        v37[1] = 0;
LABEL_48:
        *uint64_t v37 = v36;
        *(void *)(a1 + 96) = v37;
        uint64_t v41 = *(void *)(a1 + 144);
        uint64_t v35 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
        *uint64_t v35 = v41;
        v35[1] = 1;
        goto LABEL_49;
      }
      CGPDFDrawingContextSaveGState(a2);
      if (v5) {
        goto LABEL_40;
      }
    }
LABEL_47:
    CGPDFDrawingContextSaveGState(a2);
    uint64_t v36 = *(void *)(a1 + 96);
    uint64_t v37 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    v37[1] = 1;
    goto LABEL_48;
  }

  pdf_error("stack underflow.");
}

void set_style(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (get_shadow_style(a2, (unint64_t *)&cf))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    CFTypeRef v4 = cf;
    CGPDFGStateSetShadowStyle(v3, cf);
    if (v4)
    {
      CFRelease(v4);
    }
  }
  else
  {
    pdf_error("invalid shadow style.");
  }
}

CGColorSpaceRef get_shadow_style(uint64_t a1, unint64_t *a2)
{
  v28[2] = *MEMORY[0x1E4F143B8];
  CGPDFObjectRef v27 = (CGPDFObjectRef)a1;
  if (!a1)
  {
LABEL_7:
    *a2 = 0;
    return (CGColorSpaceRef)1;
  }
  CGPDFReal v25 = 0.0;
  CGPDFStreamRef value = 0;
  int v3 = *(_DWORD *)(a1 + 8);
  if (v3 != 8)
  {
    if (v3 != 5) {
      return 0;
    }
    CFTypeRef v4 = *(const char **)(a1 + 32);
    if (strcmp(v4, "Default") && strcmp(v4, "None"))
    {
      return 0;
    }
    goto LABEL_7;
  }
  unsigned int v6 = *(CGPDFDictionary **)(a1 + 32);
  CGColorSpaceRef result = (CGColorSpaceRef)CGPDFDictionaryGetName(v6, "Subtype", (const char **)&value);
  if (!result) {
    return result;
  }
  if (strcmp(value, "Shadow")) {
    return 0;
  }
  CGColorSpaceRef result = (CGColorSpaceRef)CGPDFDictionaryGetNumbers(v6, "Offset", (uint64_t)v28, (CGPDFArray *)2);
  if (result)
  {
    long double v7 = *(double *)v28;
    long double v8 = *(double *)&v28[1];
    if (!CGPDFDictionaryGetNumber(v6, "Radius", &v25)) {
      CGPDFReal v25 = 0.0;
    }
    if (!CGPDFDictionaryGetObject(v6, "ColorSpace", &v27))
    {
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      CGColorRef v16 = CGColorCreate(DeviceRGB, get_shadow_style_default_components);
      CGColorSpaceRelease(DeviceRGB);
LABEL_29:
      *a2 = CGStyleCreateShadow2((unint64_t)v16, v17, v18, v19, v20, v21, v22, v23, v7, v8, v25);
      if (v16) {
        CFRelease(v16);
      }
      return (CGColorSpaceRef)1;
    }
    CGColorSpaceRef result = cg_create_colorspace((uint64_t)v27);
    if (result)
    {
      uint64_t v10 = result;
      uint64_t v11 = (CGPDFArray *)(*(void *)(*((void *)result + 3) + 48) + 1);
      MEMORY[0x1F4188790](result, v9);
      BOOL v14 = (char *)&v25 - v13;
      if (v12 <= 0x1FFFFFFFFFFFFFFELL) {
        CGPDFInteger v15 = (char *)&v25 - v13;
      }
      else {
        CGPDFInteger v15 = 0;
      }
      if (v12 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL) {
        CGPDFInteger v15 = (char *)malloc_type_malloc(8 * (void)v11, 0x71A9811FuLL);
      }
      if (!v15) {
        return 0;
      }
      if (!CGPDFDictionaryGetNumbers(v6, "Color", (uint64_t)v15, v11))
      {
        if (v15 != v14) {
          free(v15);
        }
        return 0;
      }
      CGColorRef v16 = CGColorCreate(v10, (const CGFloat *)v15);
      if (v15 != v14) {
        free(v15);
      }
      CGColorSpaceRelease(v10);
      goto LABEL_29;
    }
  }
  return result;
}

void op_gs_8018(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v107 = 0.0;
  CGPDFBoolean v106 = 0;
  CGPDFStreamRef value = 0;
  CGPDFInteger v105 = 0;
  CGPDFObjectRef v102 = 0;
  CGPDFArrayRef array = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value)) {
    return;
  }
  uint64_t v3 = a2 ? *(void *)a2 : 0;
  ExtGState = (CGPDFDictionary *)CGPDFContentStreamGetExtGState(v3, value);
  if (!ExtGState) {
    return;
  }
  uint64_t v5 = ExtGState;
  if (CGPDFDictionaryGetNumber(ExtGState, "LW", &v107))
  {
    if (v107 >= 0.0)
    {
      uint64_t v6 = *(void *)(a2 + 32);
      if (v6) {
        *(CGPDFReal *)(v6 + 144) = v107;
      }
    }
    else
    {
      pdf_error("invalid line width: %g.", v107);
    }
  }
  if (CGPDFDictionaryGetInteger(v5, "LC", &v105))
  {
    if ((unint64_t)v105 >= 3)
    {
      pdf_error("invalid line cap: %ld.", v105);
    }
    else
    {
      uint64_t v7 = *(void *)(a2 + 32);
      if (v7) {
        *(_DWORD *)(v7 + 152) = v105;
      }
    }
  }
  if (CGPDFDictionaryGetInteger(v5, "LJ", &v105))
  {
    if ((unint64_t)v105 >= 3)
    {
      pdf_error("invalid line join: %ld.", v105);
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 32);
      if (v8) {
        *(_DWORD *)(v8 + 156) = v105;
      }
    }
  }
  if (CGPDFDictionaryGetNumber(v5, "ML", &v107))
  {
    if (v107 >= 1.0)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      if (v9) {
        *(CGPDFReal *)(v9 + 160) = v107;
      }
    }
    else
    {
      pdf_error("invalid miter limit: %g.", v107);
    }
  }
  if (CGPDFDictionaryGetArray(v5, "D", &array)
    && CGPDFArrayGetNumber(array, 0, &v107)
    && CGPDFArrayGetArray(array, 1uLL, &array))
  {
    v10.n128_f64[0] = v107;
    set_line_dash(a2, (uint64_t)array, v10);
  }
  if (CGPDFDictionaryGetName(v5, "RI", (const char **)&value)) {
    set_rendering_intent(a2, value);
  }
  if (CGPDFDictionaryGetBoolean(v5, "OP", &v106))
  {
    uint64_t v11 = *(void *)(a2 + 32);
    if (v11)
    {
      BOOL v12 = v106 != 0;
      *(unsigned char *)(v11 + 218) = v106 != 0;
      *(unsigned char *)(v11 + 217) = v12;
    }
  }
  if (CGPDFDictionaryGetBoolean(v5, "op", &v106))
  {
    uint64_t v13 = *(void *)(a2 + 32);
    if (v13) {
      *(unsigned char *)(v13 + 217) = v106 != 0;
    }
  }
  if (CGPDFDictionaryGetInteger(v5, "OPM", &v105))
  {
    uint64_t v14 = *(void *)(a2 + 32);
    if (v14) {
      *(_DWORD *)(v14 + 220) = v105;
    }
  }
  if (CGPDFDictionaryGetArray(v5, "Font", &array))
  {
    CGPDFInteger v15 = array;
    CGPDFReal v110 = 0.0;
    v109[0] = 0;
    if (CGPDFArrayGetDictionary(array, 0, v109) && CGPDFArrayGetNumber(v15, 1uLL, &v110))
    {
      CGColorRef v16 = (const void *)CGPDFFontCreate(v109[0]);
      CGPDFGStateSetFont(*(void *)(a2 + 32), v16);
      if (v16) {
        CFRelease(v16);
      }
      uint64_t v17 = *(void *)(a2 + 32);
      if (v17)
      {
        CGPDFReal v18 = v110;
        *(CGPDFReal *)(v17 + 128) = v110;
        uint64_t v19 = *(void *)(v17 + 272);
        if (v19) {
          *(CGPDFReal *)(v19 + 56) = v18;
        }
      }
    }
  }
  if (CGPDFDictionaryGetObject(v5, "BG2", &v102))
  {
    CGPDFObjectRef v20 = v102;
    uint64_t v21 = a2;
    int v22 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "BG", &v102)) {
      goto LABEL_54;
    }
    CGPDFObjectRef v20 = v102;
    uint64_t v21 = a2;
    int v22 = 0;
  }
  set_black_generation(v21, (uint64_t)v20, v22);
LABEL_54:
  if (CGPDFDictionaryGetObject(v5, "UCR2", &v102))
  {
    CGPDFObjectRef v23 = v102;
    uint64_t v24 = a2;
    int v25 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "UCR", &v102)) {
      goto LABEL_59;
    }
    CGPDFObjectRef v23 = v102;
    uint64_t v24 = a2;
    int v25 = 0;
  }
  set_undercolor_removal(v24, (uint64_t)v23, v25);
LABEL_59:
  if (CGPDFDictionaryGetObject(v5, "TR2", &v102))
  {
    CGPDFObjectRef v26 = v102;
    uint64_t v27 = a2;
    int v28 = 1;
  }
  else
  {
    if (!CGPDFDictionaryGetObject(v5, "TR", &v102)) {
      goto LABEL_64;
    }
    CGPDFObjectRef v26 = v102;
    uint64_t v27 = a2;
    int v28 = 0;
  }
  set_transfer(v27, (uint64_t)v26, v28);
LABEL_64:
  CGPDFDictionaryGetObject(v5, "HT", &v102);
  if (CGPDFDictionaryGetNumber(v5, "FL", &v107))
  {
    uint64_t v29 = *(void *)(a2 + 32);
    if (v29) {
      *(CGPDFReal *)(v29 + 248) = v107;
    }
  }
  if (CGPDFDictionaryGetNumber(v5, "SM", &v107))
  {
    uint64_t v30 = *(void *)(a2 + 32);
    if (v30) {
      *(CGPDFReal *)(v30 + 256) = v107;
    }
  }
  if (CGPDFDictionaryGetBoolean(v5, "SA", &v106))
  {
    uint64_t v31 = *(void *)(a2 + 32);
    if (v31) {
      *(unsigned char *)(v31 + 180) = v106 != 0;
    }
  }
  if (CGPDFDictionaryGetObject(v5, "BM", &v102))
  {
    uint64_t v32 = *(void *)(a2 + 32);
    if (v32)
    {
      int v33 = CGPDFBlendModeFromCGPDFObject((uint64_t)v102);
      if (v33 != -1) {
        *(_DWORD *)(v32 + 184) = v33;
      }
    }
  }
  if (!CGPDFDictionaryGetObject(v5, "SMask", &v102)) {
    goto LABEL_91;
  }
  if (v102)
  {
    int v34 = *((_DWORD *)v102 + 2);
    if (v34 == 5)
    {
      if (!strcmp(*((const char **)v102 + 4), "None"))
      {
        uint64_t v56 = *(void *)(a2 + 32);
        if (v56)
        {
          uint64_t v57 = *(const void **)(v56 + 192);
          if (v57)
          {
            CFRelease(v57);
            *(void *)(v56 + 192) = 0;
          }
        }
      }
      else
      {
      }
      goto LABEL_91;
    }
    if (v34 == 8)
    {
      uint64_t v35 = (CGPDFDictionary *)*((void *)v102 + 4);
      uint64_t v36 = CGPDFDictionaryCopyAssociation((uint64_t)v35, "SoftMask");
      if (v36)
      {
        uint64_t v43 = (uint64_t)v36;
        goto LABEL_83;
      }
      if (CGPDFSoftMaskGetTypeID_onceToken != -1) {
        dispatch_once(&CGPDFSoftMaskGetTypeID_onceToken, &__block_literal_global_3739);
      }
      uint64_t cftype = pdf_create_cftype();
      if (!cftype) {
        goto LABEL_168;
      }
      uint64_t v54 = cftype;
      CGPDFReal v110 = 0.0;
      CGPDFStreamRef v108 = 0;
      v109[0] = 0;
      *(void *)(cftype + 16) = v35;
      if (!CGPDFDictionaryGetName(v35, "S", (const char **)&v110))
      {
        goto LABEL_167;
      }
      CGPDFReal v55 = v110;
      if (!strcmp(*(const char **)&v110, "Alpha"))
      {
        int v58 = 0;
      }
      else
      {
        if (strcmp(*(const char **)&v55, "Luminosity"))
        {
LABEL_167:
          CFRelease((CFTypeRef)v54);
LABEL_168:
          CGPDFGStateSetSoftMask(*(void *)(a2 + 32), 0);
          goto LABEL_91;
        }
        int v58 = 1;
      }
      *(_DWORD *)(v54 + 24) = v58;
      if (!CGPDFDictionaryGetStream(v35, "G", &v108))
      {
        goto LABEL_167;
      }
      uint64_t v92 = CGPDFGroupCreate(v108);
      *(void *)(v54 + 32) = v92;
      if (v92)
      {
        if (*(_DWORD *)(v54 + 24) != 1) {
          goto LABEL_157;
        }
        uint64_t v93 = (CGColorSpace *)*((void *)v92 + 12);
        if (v93)
        {
          uint64_t v94 = *(CGPDFArray **)(*((void *)v93 + 3) + 48);
          uint64_t v95 = (CGFloat *)malloc_type_calloc(1uLL, 8 * (void)v94 + 8, 0x100004000313F17uLL);
          if (!v95) {
            goto LABEL_167;
          }
          double v96 = v95;
          if (CGPDFDictionaryGetNumbers(v35, "BC", (uint64_t)v95, v94))
          {
            v96[(void)v94] = 1.0;
            CGColorRef v97 = CGColorCreate(v93, v96);
          }
          else
          {
            CGColorRef v97 = CGColorSpaceCopyDefaultColor((uint64_t)v93);
          }
          *(void *)(v54 + 40) = v97;
          free(v96);
LABEL_157:
          if (CGPDFDictionaryGetName(v35, "TR", (const char **)&v110))
          {
            if (strcmp(*(const char **)&v110, "Identity"))
            {
              goto LABEL_167;
            }
          }
          else if (CGPDFDictionaryGetObject(v35, "TR", v109))
          {
            Functiouint64_t n = CGPDFFunctionCreateFunction((char *)v109[0]);
            *(void *)(v54 + 48) = Function;
            if (!Function) {
              goto LABEL_167;
            }
            if (*((void *)Function + 4) != 1 || *((void *)Function + 6) != 1)
            {
              goto LABEL_167;
            }
          }
          uint64_t v43 = CGPDFDictionarySetAssociation((uint64_t)v35, (const void *)v54, "SoftMask");
          if (v43)
          {
LABEL_83:
            uint64_t v44 = *(double **)(v43 + 32);
            if (v44)
            {
              int v45 = 0;
              double v46 = v44[1];
              if (v46 == INFINITY
                || (double v47 = v44[2], v47 == INFINITY)
                || (int v45 = 0, v48 = v44[3], v48 == 0.0)
                || (double v49 = v44[4], v49 == 0.0))
              {
LABEL_152:
                CFRelease((CFTypeRef)v43);
                CGPDFGStateSetSoftMask(*(void *)(a2 + 32), v45);
                if (v45) {
                  CFRelease(v45);
                }
                goto LABEL_91;
              }
              if (a2) {
                uint64_t v50 = *(void *)a2;
              }
              else {
                uint64_t v50 = 0;
              }
              int v45 = 0;
              int v59 = *(_DWORD *)(v43 + 24);
              if (v59)
              {
                if (v59 != 1) {
                  goto LABEL_152;
                }
                CGColorRef ResolvedColor = CGPDFContentStreamCreateResolvedColor(v50, *(void *)(v43 + 40), v37, v38, v39, v40, v41, v42);
                if (!ResolvedColor) {
                  goto LABEL_151;
                }
              }
              else
              {
                CGColorRef ResolvedColor = 0;
              }
              if (v50 && (uint64_t v61 = *(const void ***)(v50 + 16)) != 0)
              {
                v116.origin.double x = pdf_page_get_box_rect(*(void *)(v50 + 16), 0);
                v117.origin.double x = v46;
                v117.origin.double y = v47;
                v117.size.double width = v48;
                v117.size.double height = v49;
                if (CGRectIntersectsRect(v116, v117))
                {
                  uint64_t v62 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
                  if (v62)
                  {
                    uint64_t v63 = (uint64_t)v62;
                    unsigned int v64 = *v61;
                    if (v64) {
                      CFRetain(v64);
                    }
                    goto LABEL_132;
                  }
                }
              }
              else
              {
                BOOL v65 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
                if (v65)
                {
                  uint64_t v63 = (uint64_t)v65;
                  unsigned int v64 = 0;
LABEL_132:
                  double v101 = v49;
                  *(void *)(v63 + 8) = v64;
                  CFRetain((CFTypeRef)v43);
                  *(void *)uint64_t v63 = v43;
                  uint64_t v72 = *(void *)a2;
                  if (*(void *)a2) {
                    CFRetain(*(CFTypeRef *)a2);
                  }
                  *(void *)(v63 + 16) = v72;
                  double v73 = v44[5];
                  double v74 = v44[6];
                  double v75 = v44[7];
                  double v76 = v44[8];
                  double v77 = v44[9];
                  double v78 = v44[10];
                  unint64_t v79 = &CGAffineTransformIdentity;
                  if (*(void *)(a2 + 32)) {
                    unint64_t v79 = *(const CGAffineTransform **)(a2 + 32);
                  }
                  double b = v79->b;
                  double c = v79->c;
                  double d = v79->d;
                  double v83 = v74 * c + v73 * v79->a;
                  double v84 = v74 * d + v73 * b;
                  double v85 = v76 * c + v75 * v79->a;
                  double v86 = v76 * d + v75 * b;
                  CGFloat v100 = v79->tx + c * v78 + v77 * v79->a;
                  double v87 = d * v78 + v77 * b + v79->ty;
                  CGContextGetBaseCTM(*(void *)(a2 + 88), v66, v67, v68, v69, v70, v71, (uint64_t)&v110);
                  double v88 = *(void **)(v43 + 48);
                  *(double *)uint64_t v109 = v84 * v112 + v83 * v110;
                  *(double *)&v109[1] = v84 * v113 + v83 * v111;
                  *(double *)&v109[2] = v86 * v112 + v85 * v110;
                  *(double *)&v109[3] = v86 * v113 + v85 * v111;
                  *(double *)&v109[4] = v114 + v112 * v87 + v100 * v110;
                  *(double *)&v109[5] = v113 * v87 + v100 * v111 + v115;
                  int v45 = (const void *)CGSoftMaskCreate(v63, (long long *)v109, ResolvedColor, v88, (uint64_t)&pdf_softmask_callbacks, v89, v90, v91, v46, v47, v48, v101);
                  if (ResolvedColor) {
                    CFRelease(ResolvedColor);
                  }
                  if (!v45) {
                    pdf_softmask_release_info((CFTypeRef *)v63);
                  }
                  goto LABEL_152;
                }
              }
              if (ResolvedColor) {
                CFRelease(ResolvedColor);
              }
            }
LABEL_151:
            int v45 = 0;
            goto LABEL_152;
          }
          goto LABEL_168;
        }
      }
      goto LABEL_167;
    }
  }
  pdf_error("invalid soft mask.");
LABEL_91:
  if (CGPDFDictionaryGetNumber(v5, "CA", &v107)) {
    CGPDFGStateSetStrokeAlpha(*(void *)(a2 + 32), v107);
  }
  if (CGPDFDictionaryGetNumber(v5, "ca", &v107)) {
    CGPDFGStateSetFillAlpha(*(void *)(a2 + 32), v107);
  }
  if (CGPDFDictionaryGetBoolean(v5, "AIS", &v106))
  {
    uint64_t v51 = *(void *)(a2 + 32);
    if (v51) {
      *(unsigned char *)(v51 + 216) = v106 != 0;
    }
  }
  if (CGPDFDictionaryGetBoolean(v5, "TK", &v106))
  {
    uint64_t v52 = *(void *)(a2 + 32);
    if (v52) {
      *(unsigned char *)(v52 + 136) = v106 != 0;
    }
  }
  if (CGPDFDictionaryGetObject(v5, "AAPL:ST", &v102)) {
    set_style(a2, (uint64_t)v102);
  }
}

void set_line_dash(uint64_t a1, uint64_t a2, __n128 a3)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  if (a2 && (uint64_t v5 = *(void *)(a2 + 16)) != 0)
  {
    unint64_t v6 = a3.n128_u64[0];
    MEMORY[0x1F4188790](a1, a3);
    uint64_t v9 = (char *)v16 - v8;
    if (v7 <= 0x1FFFFFFFFFFFFFFELL) {
      __n128 v10 = (char *)v16 - v8;
    }
    else {
      __n128 v10 = 0;
    }
    if (v7 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000016) {
      __n128 v10 = (char *)malloc_type_malloc(8 * v5, 0x229C5B94uLL);
    }
    if (v10)
    {
      if (CGPDFArrayGetNumbers(a2, (uint64_t)v10, v5))
      {
        uint64_t v11 = 0;
        double v12 = 0.0;
        do
        {
          double v13 = *(double *)&v10[8 * v11];
          if (v13 < 0.0)
          {
            pdf_error("invalid dash array: lengths may not be negative.");
            goto LABEL_20;
          }
          double v12 = v12 + v13;
          ++v11;
        }
        while (v5 != v11);
        if (v12 == 0.0)
        {
          pdf_error("invalid dash array: at least one length must be greater than zero.");
          goto LABEL_20;
        }
        CGPDFInteger v15 = (atomic_uint *)malloc_type_calloc(1uLL, 8 * v5 + 24, 0x64A29F66uLL);
        *CGPDFInteger v15 = 1;
        *((void *)v15 + 1) = v6;
        *((void *)v15 + 2) = v5;
        memcpy(v15 + 6, v10, 8 * v5);
        if (v10 != v9) {
          free(v10);
        }
        CGPDFGStateSetDash(*(void *)(a1 + 32), v15);
        if (atomic_fetch_add_explicit(v15, 0xFFFFFFFF, memory_order_relaxed) == 1) {
          free(v15);
        }
      }
      else
      {
        pdf_error("invalid dash array.");
LABEL_20:
        if (v10 != v9) {
          free(v10);
        }
      }
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    CGPDFGStateSetDash(v14, 0);
  }
}

void set_rendering_intent(uint64_t a1, char *__s1)
{
  if (!strcmp(__s1, "AbsoluteColorimetric"))
  {
    int v4 = 1;
  }
  else
  {
    if (!strcmp(__s1, "RelativeColorimetric"))
    {
LABEL_6:
      int v4 = 2;
      goto LABEL_10;
    }
    if (!strcmp(__s1, "Saturation"))
    {
      int v4 = 4;
    }
    else
    {
      if (strcmp(__s1, "Perceptual"))
      {
        goto LABEL_6;
      }
      int v4 = 3;
    }
  }
LABEL_10:
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    *(_DWORD *)(v5 + 176) = v4;
  }
}

void set_black_generation(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  if (build_function(a2, a3, (uint64_t *)&cf))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFTypeRef v5 = cf;
    CGPDFGStateSetBlackGeneration(v4, cf);
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void set_undercolor_removal(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0;
  if (build_function(a2, a3, (uint64_t *)&cf))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFTypeRef v5 = cf;
    CGPDFGStateSetUndercolorRemoval(v4, cf);
    if (v5)
    {
      CFRelease(v5);
    }
  }
}

void set_transfer(uint64_t a1, uint64_t a2, int a3)
{
  CGPDFObjectRef value = (CGPDFObjectRef)a2;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    unint64_t v7 = Mutable;
    double v13 = 0;
    if (a2 && *(_DWORD *)(a2 + 8) == 7)
    {
      uint64_t v8 = *(CGPDFArray **)(a2 + 32);
      if (v8 && *((void *)v8 + 2) == 4)
      {
        size_t v9 = 0;
        while (1)
        {
          CGPDFArrayGetObject(v8, v9, &value);
          if (!build_transfer_function((uint64_t)value, a3, (uint64_t *)&v13)) {
            break;
          }
          __n128 v10 = v13;
          CFArrayAppendValue(v7, v13);
          CFRelease(v10);
          if (++v9 == 4) {
            goto LABEL_14;
          }
        }
      }
      else
      {
        pdf_error("invalid transfer array.", v13);
      }
    }
    else if (build_transfer_function(a2, a3, (uint64_t *)&v13))
    {
      uint64_t v11 = v13;
      uint64_t v12 = 4;
      do
      {
        CFArrayAppendValue(v7, v11);
        --v12;
      }
      while (v12);
      CFRelease(v11);
LABEL_14:
      CGPDFGStateSetTransferFunctions(*(void **)(a1 + 32), v7);
    }
    CFRelease(v7);
  }
}

uint64_t build_transfer_function(uint64_t a1, int a2, uint64_t *a3)
{
  if (a1 && *(_DWORD *)(a1 + 8) == 5)
  {
    uint64_t v4 = *(const char **)(a1 + 32);
    if (a2 && !strcmp(*(const char **)(a1 + 32), "Default"))
    {
      *a3 = *MEMORY[0x1E4F1D260];
      return 1;
    }
    if (strcmp(v4, "Identity"))
    {
      return 0;
    }
    uint64_t result = CGFunctionCreateIdentity();
  }
  else
  {
    uint64_t result = (uint64_t)CGPDFFunctionCreateFunction((char *)a1);
    if (!result) {
      return result;
    }
  }
  *a3 = result;
  return 1;
}

uint64_t build_function(uint64_t a1, int a2, uint64_t *a3)
{
  if (a1 && *(_DWORD *)(a1 + 8) == 5)
  {
    uint64_t v4 = *(const char **)(a1 + 32);
    if (a2 && !strcmp(*(const char **)(a1 + 32), "Default"))
    {
      uint64_t result = 0;
    }
    else
    {
      if (strcmp(v4, "Identity"))
      {
        return 0;
      }
      uint64_t result = CGFunctionCreateIdentity();
    }
  }
  else
  {
    uint64_t result = (uint64_t)CGPDFFunctionCreateFunction((char *)a1);
    if (!result) {
      return result;
    }
  }
  *a3 = result;
  return 1;
}

void op_d1_8063(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v17 = 0.0;
  CGPDFReal v15 = 0.0;
  CGPDFReal v16 = 0.0;
  CGPDFReal value = 0.0;
  CGPDFReal v14 = 0.0;
  uint64_t v12 = 0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v12)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16)
    && CGPDFScannerPopNumber(a1, &v17))
  {
    FillColorAsColor = (CGColor *)CGContextGetFillColorAsColor(*(void *)(a2 + 88), v4, v5, v6, v7, v8, v9, v10);
    CGContextSetStrokeColorWithColor(*(CGContextRef *)(a2 + 88), FillColorAsColor);
  }
}

void op_EI_8064(uint64_t *a1, uint64_t a2)
{
  CGPDFStreamRef value = 0;
  if (CGPDFScannerPopStream((CGPDFScannerRef)a1, &value))
  {
    Inline = (CGImage *)CGPDFImageCreateInline(a1[7], (uint64_t)value);
    if (Inline)
    {
      uint64_t v11 = Inline;
      CGPDFDrawingContextDrawImage(a2, Inline, v5, v6, v7, v8, v9, v10);
      CFRelease(v11);
    }
  }
}

void op_sh_8065(CGPDFScanner *a1, uint64_t *a2)
{
  CGPDFStreamRef value = 0;
  BOOL v3 = CGPDFScannerPopName(a1, (const char **)&value);
  if (a2)
  {
    if (v3)
    {
      uint64_t v4 = *a2;
      if (*a2)
      {
        uint64_t v5 = value;
        while (1)
        {
          Shading = CGPDFResourcesGetShading(*(void *)(v4 + 32), v5);
          if (Shading) {
            break;
          }
          uint64_t v4 = *(void *)(v4 + 40);
          if (!v4) {
            return;
          }
        }
        uint64_t v7 = CGPDFShadingGetShading((uint64_t)Shading);
        if (v7)
        {
          uint64_t v8 = (CGShading *)v7;
          CGPDFGStateSynchronizeForImages(a2[4], (CGContextRef)a2[11]);
          CGContextDrawShading((CGContextRef)a2[11], v8);
        }
      }
    }
  }
}

void op_Do_8066(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFObjectRef v102 = 0;
  BOOL v3 = CGPDFScannerPopName(a1, &v102);
  if (!a2) {
    return;
  }
  if (!v3) {
    return;
  }
  uint64_t v4 = *(void *)a2;
  if (!*(void *)a2) {
    return;
  }
  uint64_t v5 = v102;
  while (1)
  {
    uint64_t v6 = CGPDFResourcesCopyXObject(*(void *)(v4 + 32), v5);
    if (v6) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 40);
    if (!v4) {
      return;
    }
  }
  uint64_t v7 = v6;
  int v8 = v6[26];
  if (!v8)
  {
    value.CGFloat a = 0.0;
    uint64_t v9 = *((void *)v6 + 3);
    if (v9) {
      uint64_t v10 = *(CGPDFDictionary **)(v9 + 48);
    }
    else {
      uint64_t v10 = 0;
    }
    if (!CGPDFDictionaryGetDictionary(v10, "OC", (CGPDFDictionaryRef *)&value))
    {
      int v8 = 1;
      v7[26] = 1;
      goto LABEL_38;
    }
    if (*(unsigned char *)(a2 + 112)) {
      int v11 = 1;
    }
    else {
      int v11 = 2;
    }
    v7[26] = v11;
    __s1.CGFloat a = 0.0;
    if (!CGPDFDictionaryGetName(*(CGPDFDictionaryRef *)&value.a, "Type", (const char **)&__s1)) {
      goto LABEL_37;
    }
    if (strcmp(*(const char **)&__s1.a, "OCMD")) {
      goto LABEL_37;
    }
    v104.CGFloat a = 0.0;
    if (!CGPDFDictionaryGetObject(*(CGPDFDictionaryRef *)&value.a, "OCGs", (CGPDFObjectRef *)&v104)
      || !*(void *)&v104.a)
    {
      goto LABEL_37;
    }
    int v12 = *(_DWORD *)(*(void *)&v104.a + 8);
    if (v12 == 7)
    {
      CGPDFReal v15 = *(CGPDFArray **)(*(void *)&v104.a + 32);
      if (!v15 || (unint64_t v16 = *((void *)v15 + 2)) == 0)
      {
        int v14 = 2;
LABEL_36:
        v7[26] = v14;
        goto LABEL_37;
      }
      unint64_t v17 = 1;
      do
      {
        CGPDFObjectRef v103 = 0;
        BOOL Object = CGPDFArrayGetObject(v15, v17 - 1, &v103);
        if (Object) {
          BOOL Object = CGPDFDrawingContextShouldDrawOCG(a2, *((void *)v103 + 2), *((void *)v103 + 3));
        }
        if (v17 >= v16) {
          break;
        }
        ++v17;
      }
      while (!Object);
    }
    else
    {
      if (v12 != 8)
      {
LABEL_37:
        int v8 = v7[26];
        goto LABEL_38;
      }
      BOOL Object = CGPDFDrawingContextShouldDrawOCG(a2, *(void *)(*(void *)&v104.a + 16), *(void *)(*(void *)&v104.a + 24));
    }
    if (Object) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    goto LABEL_36;
  }
LABEL_38:
  if (v8 == 1)
  {
    int v18 = v7[4];
    if (v18 == 2)
    {
      uint64_t v26 = CGPDFXObjectGetValue((uint64_t)v7);
      if (v26)
      {
        uint64_t v27 = v26;
        if (*(unsigned char *)(v26 + 105)) {
          pdf_log("knockout groups aren't supported.");
        }
        if (!*(unsigned char *)(v27 + 104)) {
          pdf_log("non-isolated groups aren't supported.");
        }
        uint64_t v28 = *(void *)(a2 + 32);
        if (v28)
        {
          uint64_t v29 = *(CGContext **)(a2 + 88);
          if (v29)
          {
            CGContextSetAlpha(*(CGContextRef *)(a2 + 88), *(CGFloat *)(v28 + 200));
            CGPDFGStateSynchronizeColorRendering(v28, v29);
            CGPDFGStateSynchronizeRendering(v28, (uint64_t)v29, v30, v31, v32, v33, v34, v35);
          }
        }
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        uint64_t v37 = *(void **)(v27 + 96);
        if (v37 || (uint64_t v37 = *(void **)(a2 + 16)) != 0)
        {
          ResolvedColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(*(void *)a2, v37);
          uint64_t v39 = ResolvedColorSpace;
          if (Mutable && ResolvedColorSpace) {
            CFDictionarySetValue(Mutable, @"kCGContextColorSpace", ResolvedColorSpace);
          }
          CGColorSpaceRelease(v39);
        }
        CGCFDictionarySetRect(Mutable, @"kCGContextBoundingBox", *(double *)(v27 + 8), *(double *)(v27 + 16), *(double *)(v27 + 24), *(double *)(v27 + 32));
        uint64_t v40 = *(CGContext **)(a2 + 88);
        CGContextSaveGState(v40);
        long long v41 = *(_OWORD *)(v27 + 56);
        *(_OWORD *)&value.CGFloat a = *(_OWORD *)(v27 + 40);
        *(_OWORD *)&value.double c = v41;
        *(_OWORD *)&value.tdouble x = *(_OWORD *)(v27 + 72);
        CGContextConcatCTM(v40, &value);
        uint64_t v42 = *(CGPDFStream **)v27;
        uint64_t v43 = *(CGPDFDictionary **)(v27 + 88);
        if (!CGContextIsEmptyClipBoundingBox((uint64_t)v40, v44, v45, v46, v47, v48, v49, v50))
        {
          uint64_t v51 = CGPDFDrawingContextCreateWithStream(v42, v43, (CGPDFContentStreamRef *)a2);
          if (v51)
          {
            uint64_t v52 = v51;
            *(CGPoint *)&value.CGFloat a = CGRectNull.origin;
            *(CGSize *)&value.double c = CGRectNull.size;
            if (Mutable)
            {
              if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
                dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
              }
              CGCFDictionaryGetCFTypeRef(Mutable, @"kCGContextColorSpace", CGColorSpaceGetTypeID_type_id, (uint64_t *)v52 + 2);
              CGCFDictionaryGetRect(Mutable, @"kCGContextBoundingBox", (UInt8 *)&value);
            }
            set_initial_group_gstate(*((void *)v52 + 4));
            set_initial_group_gstate(*((void *)v52 + 3));
            CGContextBeginTransparencyLayer(v40, Mutable);
            CGFloat a = value.a;
            if (value.a != INFINITY)
            {
              CGFloat b = value.b;
              if (value.b != INFINITY)
              {
                long long v55 = *(_OWORD *)&value.c;
                CGContextClipToRect(v40, *(CGRect *)&a);
              }
            }
            *((void *)v52 + 11) = v40;
            if (CGPDFDrawingContextGetOperatorTable_predicate != -1) {
              dispatch_once(&CGPDFDrawingContextGetOperatorTable_predicate, &__block_literal_global_7866);
            }
            uint64_t v56 = CGPDFScannerCreate(*(CGPDFContentStreamRef *)v52, (CGPDFOperatorTableRef)CGPDFDrawingContextGetOperatorTable_operator_table, v52);
            CGPDFScannerScan(v56);
            if (v56) {
              CFRelease(v56);
            }
            CGContextEndTransparencyLayer(v40);
            CGPDFDrawingContextRelease(v52);
          }
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        CGContextRestoreGState(v40);
      }
    }
    else if (v18 == 1)
    {
      uint64_t v57 = CGPDFXObjectGetValue((uint64_t)v7);
      int v58 = *(CGContext **)(a2 + 88);
      CGContextGetBaseCTM((uint64_t)v58, v59, v60, v61, v62, v63, v64, (uint64_t)&value);
      GStateMaruint64_t k = CGContextGetGStateMark((uint64_t)v58, v65, v66, v67, v68, v69, v70, v71);
      double v73 = (const CGAffineTransform *)(v57 + 56);
      if (!v57) {
        double v73 = &CGAffineTransformIdentity;
      }
      long long v74 = *(_OWORD *)&v73->c;
      *(_OWORD *)&__s1.CGFloat a = *(_OWORD *)&v73->a;
      *(_OWORD *)&__s1.double c = v74;
      *(_OWORD *)&__s1.tdouble x = *(_OWORD *)&v73->tx;
      CGContextConcatCTM(v58, &__s1);
      CGContextGetCTM(&__s1, v58);
      CGContextSetBaseCTM((uint64_t)v58, (long long *)&__s1, v75, v76, v77, v78, v79, v80);
      if (v57)
      {
        CGContextClipToRect(v58, *(CGRect *)(v57 + 24));
        unsigned int v81 = *(CGPDFStream **)(v57 + 16);
        uint64_t v82 = *(CGPDFDictionary **)(v57 + 104);
      }
      else
      {
        v107.origin.double x = INFINITY;
        v107.size.double width = 0.0;
        v107.size.double height = 0.0;
        v107.origin.double y = INFINITY;
        CGContextClipToRect(v58, v107);
        unsigned int v81 = 0;
        uint64_t v82 = 0;
      }
      double v83 = CGPDFDrawingContextCreateWithStream(v81, v82, (CGPDFContentStreamRef *)a2);
      CGPDFDrawingContextDraw((uint64_t)v83, (uint64_t)v58, v84, v85, v86, v87, v88, v89);
      CGPDFDrawingContextRelease(v83);
      CGContextRestoreToGStateMark((uint64_t)v58, GStateMark, v90, v91, v92, v93, v94, v95);
      CGAffineTransform v104 = value;
      CGContextSetBaseCTM((uint64_t)v58, (long long *)&v104, v96, v97, v98, v99, v100, v101);
    }
    else if (v18)
    {
      pdf_error("unrecognized or unsupported XObject subtype.");
    }
    else
    {
      uint64_t v19 = (CGImage *)CGPDFXObjectGetValue((uint64_t)v7);
      CGPDFDrawingContextDrawImage(a2, v19, v20, v21, v22, v23, v24, v25);
    }
    CFRelease(v7);
  }
}

void op_TJ_8068(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFArrayRef value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      if (value)
      {
        TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
        if (TextObject)
        {
          uint64_t v4 = (uint64_t)TextObject;
          CGPDFTextObjectAppendStrings((uint64_t)TextObject, value);
          CGPDFDrawingContextDrawText((void *)a2, v4);
        }
      }
      else
      {
      }
    }
    else
    {
    }
  }
}

void op_doublequote(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v13 = 0.0;
  CGPDFStringRef value = 0;
  CGPDFReal v12 = 0.0;
  if (CGPDFScannerPopString(a1, &value) && CGPDFScannerPopNumber(a1, &v13) && CGPDFScannerPopNumber(a1, &v12))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      uint64_t v4 = *(void *)(a2 + 32);
      if (v4)
      {
        CGPDFReal v5 = v13;
        *(CGPDFReal *)(v4 + 72) = v13;
        uint64_t v6 = *(CGPDFReal **)(v4 + 272);
        if (v6)
        {
          *uint64_t v6 = v5;
          CGPDFReal v7 = v12;
          *(CGPDFReal *)(v4 + 80) = v12;
          v6[1] = v7;
        }
        else
        {
          *(CGPDFReal *)(v4 + 80) = v12;
        }
      }
      TextBOOL Object = CGPDFGStateGetTextObject(v4);
      uint64_t v9 = (uint64_t)TextObject;
      uint64_t v10 = *(void *)(a2 + 32);
      if (v10) {
        double v11 = *(double *)(v10 + 96);
      }
      else {
        double v11 = 0.0;
      }
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v11);
      CGPDFTextObjectAppendString(v9, (uint64_t)value);
      CGPDFDrawingContextDrawText((void *)a2, v9);
    }
    else
    {
    }
  }
}

void op_singlequote(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
      uint64_t v4 = (uint64_t)TextObject;
      uint64_t v5 = *(void *)(a2 + 32);
      if (v5) {
        double v6 = *(double *)(v5 + 96);
      }
      else {
        double v6 = 0.0;
      }
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v6);
      CGPDFTextObjectAppendString(v4, (uint64_t)value);
      CGPDFDrawingContextDrawText((void *)a2, v4);
    }
    else
    {
    }
  }
}

void op_Tj_8073(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
      CGPDFTextObjectAppendString((uint64_t)TextObject, (uint64_t)value);
      CGPDFDrawingContextDrawText((void *)a2, (uint64_t)TextObject);
    }
    else
    {
    }
  }
}

double op_Tstar_8075(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 80))
  {
    TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4) {
      double v5 = *(double *)(v4 + 96);
    }
    else {
      double v5 = 0.0;
    }
    *(void *)&double result = CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v5).n128_u64[0];
  }
  else
  {
  }
  return result;
}

void op_Tm_8077(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v15 = 0.0;
  CGPDFReal v16 = 0.0;
  CGPDFReal v13 = 0.0;
  CGPDFReal v14 = 0.0;
  uint64_t v11 = 0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v13)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      uint64_t v4 = v11;
      CGPDFReal v5 = value;
      CGPDFReal v6 = v13;
      CGPDFReal v7 = v14;
      CGPDFReal v8 = v15;
      CGPDFReal v9 = v16;
      TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
      *((CGPDFReal *)TextObject + 9) = v9;
      *((CGPDFReal *)TextObject + 10) = v8;
      *((CGPDFReal *)TextObject + 11) = v7;
      *((CGPDFReal *)TextObject + 12) = v6;
      *((CGPDFReal *)TextObject + 13) = v5;
      *((void *)TextObject + 14) = v4;
      *((CGPDFReal *)TextObject + 15) = v9;
      *((CGPDFReal *)TextObject + 16) = v8;
      *((CGPDFReal *)TextObject + 17) = v7;
      *((CGPDFReal *)TextObject + 18) = v6;
      *((CGPDFReal *)TextObject + 19) = v5;
      *((void *)TextObject + 20) = v4;
    }
    else
    {
    }
  }
}

void op_TD_8079(CGPDFScanner *a1, uint64_t a2)
{
  double v8 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v8) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      uint64_t v4 = *(void *)(a2 + 32);
      if (v4)
      {
        double v5 = -v8;
        *(double *)(v4 + 96) = -v8;
        uint64_t v6 = *(void *)(v4 + 272);
        if (v6) {
          *(double *)(v6 + 24) = v5;
        }
      }
      TextBOOL Object = CGPDFGStateGetTextObject(v4);
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v8);
    }
    else
    {
    }
  }
}

void op_Td_8081(CGPDFScanner *a1, uint64_t a2)
{
  double v5 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(unsigned char *)(a2 + 80))
    {
      TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v5);
    }
    else
    {
    }
  }
}

void op_ET_8083(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 80))
  {
    BOOL v3 = (void *)*((void *)CGPDFGStateGetTextObject(*(void *)(a2 + 32)) + 22);
    if (v3)
    {
      uint64_t v4 = malloc_type_malloc(0x18uLL, 0x2062DE7BuLL);
      *(_DWORD *)uint64_t v4 = 1;
      v4[1] = 0;
      v4[2] = 0;
      CGPDFTextLayoutDrawGlyphs(v3, (void (*)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, char *, char *, void, uint64_t))clip_to_glyphs_22101, (uint64_t)v4, v5);
      CGPDFGStateSynchronizeContextForText(*(void *)(a2 + 32), *(CGContextRef *)(a2 + 88));
      CGContextClipToTextClipping(*(void *)(a2 + 88), (uint64_t)v4, v6, v7, v8, v9, v10, v11);
      CGTextClippingRelease(v4);
    }
    *(unsigned char *)(a2 + 80) = 0;
  }
  else
  {
  }
}

CGFloat op_BT_8085(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 80))
  {
    pdf_error("warning: already in a text object.");
  }
  else
  {
    *(unsigned char *)(a2 + 80) = 1;
    TextBOOL Object = CGPDFGStateGetTextObject(*(void *)(a2 + 32));
    CGFloat result = CGAffineTransformIdentity.a;
    *(CGAffineTransform *)(TextObject + 72) = CGAffineTransformIdentity;
    *(CGAffineTransform *)(TextObject + 120) = CGAffineTransformIdentity;
  }
  return result;
}

BOOL op_Ts_8087(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 104) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 32) = v5;
      }
    }
  }
  return result;
}

void op_Tr_8088(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    int v3 = 0;
    switch(value)
    {
      case 0:
        goto LABEL_13;
      case 1:
        int v3 = 1;
        goto LABEL_13;
      case 2:
        int v3 = 2;
        goto LABEL_13;
      case 3:
        if (*(unsigned char *)(a2 + 176)) {
          int v3 = 0;
        }
        else {
          int v3 = 3;
        }
        goto LABEL_13;
      case 4:
        int v3 = 4;
        goto LABEL_13;
      case 5:
        int v3 = 5;
        goto LABEL_13;
      case 6:
        int v3 = 6;
        goto LABEL_13;
      case 7:
        int v3 = 7;
LABEL_13:
        uint64_t v4 = *(void *)(a2 + 32);
        if (v4)
        {
          *(_DWORD *)(v4 + 112) = v3;
          uint64_t v5 = *(void *)(v4 + 272);
          if (v5) {
            CGPDFTextObjectSetTextDrawingMode(v5, v3);
          }
        }
        break;
      default:
        pdf_error("invalid text drawing mode: %ld.", value);
        break;
    }
  }
}

void op_Tf_8090(CGPDFScanner *a1, uint64_t *a2)
{
  uint64_t v9 = 0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopName(a1, (const char **)&v9))
  {
    if (a2) {
      uint64_t v4 = *a2;
    }
    else {
      uint64_t v4 = 0;
    }
    Font = CGPDFContentStreamGetFont(v4, v9);
    if (Font)
    {
      CGPDFGStateSetFont(a2[4], Font);
      uint64_t v6 = a2[4];
      if (v6)
      {
        CGPDFReal v7 = value;
        *(CGPDFReal *)(v6 + 128) = value;
        uint64_t v8 = *(void *)(v6 + 272);
        if (v8) {
          *(CGPDFReal *)(v8 + 56) = v7;
        }
      }
    }
    else
    {
    }
  }
}

BOOL op_TL_8092(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 96) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 24) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tz_8093(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 88) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 16) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tw_8094(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 80) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 8) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tc_8095(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 72) = value;
      uint64_t v6 = *(CGPDFReal **)(v4 + 272);
      if (v6) {
        *uint64_t v6 = v5;
      }
    }
  }
  return result;
}

void op_Wstar_8096(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  if (v2) {
    *(_WORD *)(v2 + 48) = 256;
  }
}

void op_W_8097(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  if (v2) {
    *(_WORD *)(v2 + 48) = 1;
  }
}

void op_bstar_8098(uint64_t a1, uint64_t a2)
{
}

void op_Bstar_8099(uint64_t a1, uint64_t a2)
{
}

void op_b_8100(uint64_t a1, uint64_t a2)
{
}

void op_B_8101(uint64_t a1, uint64_t a2)
{
}

void op_fstar_8102(uint64_t a1, uint64_t a2)
{
}

void op_f_8103(uint64_t a1, uint64_t a2)
{
}

void op_s_8104(uint64_t a1, uint64_t a2)
{
}

void op_S_8105(uint64_t a1, uint64_t a2)
{
}

void op_n_8106(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v10 = 0;
  int v3 = copy_clip_path(a2, &v10);
  CGContextBeginPath(*(CGContextRef *)(a2 + 88));
  if (v3)
  {
    CGContextAddPath(*(CGContextRef *)(a2 + 88), v3);
    clip(*(void *)(a2 + 88), v10, v4, v5, v6, v7, v8, v9);
    CFRelease(v3);
  }
}

void op_re_8107(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal y = 0.0;
  CGPDFReal x = 0.0;
  double v9 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &y)
    && CGPDFScannerPopNumber(a1, &x))
  {
    CGPDFReal v5 = value;
    CGPDFReal v4 = y;
    uint64_t v6 = *(CGContext **)(a2 + 88);
    CGPDFReal v7 = x;
    if (value < 0.0 || (double v8 = v9, v9 < 0.0))
    {
      CGContextMoveToPoint(v6, x, y);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x + value, y);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x + value, y + v9);
      CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), x, y + v9);
      CGContextClosePath(*(CGContextRef *)(a2 + 88));
    }
    else
    {
      CGContextAddRect(v6, *(CGRect *)&v7);
    }
    *(void *)(a2 + 168) += 4;
  }
}

void op_h_8108(uint64_t a1, uint64_t a2)
{
}

void op_y_8109(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v6 = 0.0;
  CGPDFReal v7 = 0.0;
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7))
  {
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), v7, v6, value, v4, value, v4);
    *(void *)(a2 + 168) += 6;
  }
}

void op_v_8110(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v7 = 0.0;
  CGPDFReal v8 = 0.0;
  CGFloat v5 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v8))
  {
    CGPoint PathCurrentPoint = CGContextGetPathCurrentPoint((CGContextRef)*(void *)(a2 + 88));
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), PathCurrentPoint.x, PathCurrentPoint.y, v8, v7, value, v5);
    *(void *)(a2 + 168) += 6;
  }
}

void op_c_8111(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v9 = 0.0;
  CGPDFReal v7 = 0.0;
  CGPDFReal v8 = 0.0;
  CGPDFReal value = 0.0;
  CGPDFReal v6 = 0.0;
  CGFloat y = 0.0;
  if (CGPDFScannerPopNumber(a1, &y)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v6)
    && CGPDFScannerPopNumber(a1, &v7)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9))
  {
    CGContextAddCurveToPoint(*(CGContextRef *)(a2 + 88), v9, v8, v7, v6, value, y);
    *(void *)(a2 + 168) += 6;
  }
}

void op_l_8112(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value))
  {
    CGContextAddLineToPoint(*(CGContextRef *)(a2 + 88), value, v4);
    ++*(void *)(a2 + 168);
  }
}

void op_m_8113(CGPDFScanner *a1, uint64_t a2)
{
  CGFloat v4 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v4) && CGPDFScannerPopNumber(a1, &value))
  {
    CGContextMoveToPoint(*(CGContextRef *)(a2 + 88), value, v4);
    ++*(void *)(a2 + 168);
  }
}

void op_ri_8114(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value)) {
    set_rendering_intent(a2, value);
  }
}

void op_SCN_8115(CGPDFScanner *a1, uint64_t *a2)
{
  unint64_t StrokeColor = CGPDFGStateGetStrokeColor(a2[4]);
  if (!StrokeColor)
  {
    CGColorSpaceRef ColorSpace = 0;
    goto LABEL_11;
  }
  if ((StrokeColor & 0x8000000000000000) == 0)
  {
    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(StrokeColor + 24);
    if (ColorSpace) {
      goto LABEL_7;
    }
LABEL_11:
    set_color((unint64_t)a1, (uint64_t)a2, ColorSpace, 0, v12);
    return;
  }
  CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(StrokeColor, v5, v6, v7, v8, v9, v10, v11);
  if (!ColorSpace) {
    goto LABEL_11;
  }
LABEL_7:
  if (*(_DWORD *)(*((void *)ColorSpace + 3) + 28) != 6) {
    goto LABEL_11;
  }

  set_pattern(a1, a2, ColorSpace, 0);
}

void set_pattern(CGPDFScanner *a1, uint64_t *a2, CGColorSpace *a3, int a4)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  CGPDFReal value = 0;
  CGPDFReal v73 = 0.0;
  BOOL v8 = CGPDFScannerPopName(a1, (const char **)&value);
  if (!a2) {
    return;
  }
  if (!v8) {
    return;
  }
  uint64_t v9 = *a2;
  if (!*a2) {
    return;
  }
  uint64_t v10 = value;
  while (1)
  {
    Patteruint64_t n = (CGColorSpace *)CGPDFResourcesGetPattern(*(void *)(v9 + 32), v10);
    if (Pattern) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 40);
    if (!v9) {
      return;
    }
  }
  CGPDFReal v13 = Pattern;
  if (a3) {
    uint64_t v14 = *(void *)(*((void *)a3 + 3) + 48);
  }
  else {
    uint64_t v14 = 0;
  }
  if (*((_DWORD *)Pattern + 4) != 1 || (*((unsigned char *)Pattern + 32) ? (BOOL v15 = v14 == 0) : (BOOL v15 = 1), v15))
  {
    CGPDFReal v16 = 0;
  }
  else
  {
    Patteruint64_t n = CGColorSpaceCreatePattern(0);
    CGPDFReal v16 = Pattern;
    uint64_t v14 = 0;
    a3 = Pattern;
  }
  MEMORY[0x1F4188790](Pattern, v12);
  uint64_t v20 = (CGFloat *)((char *)&v70 - v19);
  if (v18 <= 0x1FFFFFFFFFFFFFFELL) {
    uint64_t v21 = (CGFloat *)((char *)&v70 - v19);
  }
  else {
    uint64_t v21 = 0;
  }
  if (v18 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL) {
    uint64_t v21 = (CGFloat *)malloc_type_malloc(8 * v17, 0xD79C9EE2uLL);
  }
  if (!v21)
  {
    CGColorSpaceRelease(v16);
    return;
  }
  CGColorSpaceRef v71 = v16;
  if (!v14)
  {
LABEL_28:
    uint64_t v23 = a2[4];
    if (a4)
    {
      if (v23)
      {
        uint64_t v24 = (double *)(v23 + 200);
LABEL_34:
        double v25 = *v24;
LABEL_39:
        uint64_t v26 = v71;
        v21[v14] = v25;
        CFDictionaryRef Mutable = (const __CFDictionary *)a2[8];
        if (Mutable
          || (CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]),
              (a2[8] = (uint64_t)Mutable) != 0))
        {
          uint64_t v28 = (char *)CFDictionaryGetValue(Mutable, v13);
          if (!v28)
          {
            if (*a2 && (uint64_t v29 = *(const void ***)(*a2 + 16)) != 0) {
              uint64_t v30 = *v29;
            }
            else {
              uint64_t v30 = 0;
            }
            uint64_t v31 = (long long *)a2[3];
            if (v31)
            {
              *(void *)&callbacks.versiouint64_t n = 0;
              int v32 = *((_DWORD *)v13 + 4);
              if (v32 == 2)
              {
                uint64_t Shading = CGPDFShadingGetShading(*((void *)v13 + 18));
                long long v54 = *((_OWORD *)v13 + 7);
                long long v74 = *((_OWORD *)v13 + 6);
                long long v75 = v54;
                long long v76 = *((_OWORD *)v13 + 8);
                if (Shading)
                {
                  long long v55 = (unsigned char *)Shading;
                  if (kCGPatternWillDeallocate_block_invoke_once != -1) {
                    dispatch_once(&kCGPatternWillDeallocate_block_invoke_once, &__block_literal_global_6_18100);
                  }
                  uint64_t Instance = CGTypeCreateInstance(CGPatternGetTypeID_pattern_type_id, 176, v48, v49, v50, v51, v52, v53);
                  if (Instance)
                  {
                    uint64_t v28 = (char *)Instance;
                    *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(identifier_18101, 1u, memory_order_relaxed)
                                               + 1;
                    *(_DWORD *)(Instance + 20) = 1;
                    long long v57 = v75;
                    *(_OWORD *)(Instance + 24) = v74;
                    *(_OWORD *)(Instance + 40) = v57;
                    *(_OWORD *)(Instance + 56) = v76;
                    *(unsigned char *)(Instance + 72) = 1;
                    *(unsigned char *)(Instance + 184) = 0;
                    CFRetain(v55);
                    *((void *)v28 + 10) = v55;
                    if (v55[40])
                    {
                      int v58 = (const CGRect *)(v55 + 48);
                      p_CGFloat y = (CGFloat *)(v55 + 56);
                      p_size = (CGSize *)(v55 + 64);
                      p_double height = (CGFloat *)(v55 + 72);
                    }
                    else
                    {
                      int v58 = &CGRectInfinite;
                      p_double height = &CGRectInfinite.size.height;
                      p_CGFloat y = &CGRectInfinite.origin.y;
                      p_size = &CGRectInfinite.size;
                    }
                    uint64_t v67 = *(void *)p_height;
                    uint64_t v68 = *(void *)p_y;
                    CGFloat width = p_size->width;
                    *((void *)v28 + 13) = *(void *)&v58->origin.x;
                    *((void *)v28 + 14) = v68;
                    *((CGFloat *)v28 + 15) = width;
                    *((void *)v28 + 16) = v67;
                    *((void *)v28 + 17) = 0;
                    *((void *)v28 + 18) = 0;
                    *(_WORD *)(v28 + 185) = 1;
                    *((_OWORD *)v28 + 10) = shading_callbacks;
                    *((void *)v28 + 22) = off_1ED0990A8;
                    *((void *)v28 + 11) = 0;
LABEL_80:
                    uint64_t v26 = v71;
                    CFDictionarySetValue((CFMutableDictionaryRef)a2[8], v13, v28);
                    CFRelease(v28);
                    goto LABEL_70;
                  }
                }
              }
              else if (v32 == 1)
              {
                uint64_t v33 = malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
                __CFSetLastAllocationEventName();
                if (v33)
                {
                  uint64_t v70 = v33;
                  *uint64_t v33 = v13;
                  if (v30) {
                    CFRetain(v30);
                  }
                  uint64_t v34 = v70;
                  v70[1] = v30;
                  uint64_t v35 = v34;
                  v34[2] = CGPDFGStateCreateCopy(v31);
                  if (*((_DWORD *)v13 + 4) == 1)
                  {
                    int v36 = *((unsigned __int8 *)v13 + 32);
                    uint64_t v37 = (void (__cdecl *)(void *, CGContextRef))type1_draw_colored_pattern;
                    if (!*((unsigned char *)v13 + 32)) {
                      uint64_t v37 = (void (__cdecl *)(void *, CGContextRef))type1_draw_uncolored_pattern;
                    }
                    callbacks.drawPatteruint64_t n = v37;
                    callbacks.releaseInfo = (CGPatternReleaseInfoCallback)type1_release_info;
                    uint64_t v38 = *((void *)v13 + 5);
                    uint64_t v39 = *((void *)v13 + 6);
                    uint64_t v40 = *((void *)v13 + 7);
                    uint64_t v41 = *((void *)v13 + 8);
                    long long v42 = *((_OWORD *)v13 + 7);
                    *(_OWORD *)&matrix.CGFloat a = *((_OWORD *)v13 + 6);
                    *(_OWORD *)&matrix.double c = v42;
                    *(_OWORD *)&matrix.tCGPDFReal x = *((_OWORD *)v13 + 8);
                    CGFloat v43 = *((double *)v13 + 9);
                    CGFloat v44 = *((double *)v13 + 10);
                    CGPatternTiling v45 = *((_DWORD *)v13 + 9);
                    BOOL v46 = v36 != 0;
                  }
                  else
                  {
                    BOOL v46 = 0;
                    callbacks.drawPatteruint64_t n = (CGPatternDrawPatternCallback)type1_draw_uncolored_pattern;
                    callbacks.releaseInfo = (CGPatternReleaseInfoCallback)type1_release_info;
                    uint64_t v38 = 0x7FF0000000000000;
                    uint64_t v39 = 0x7FF0000000000000;
                    uint64_t v40 = 0;
                    uint64_t v41 = 0;
                    long long v62 = *((_OWORD *)v13 + 7);
                    *(_OWORD *)&matrix.CGFloat a = *((_OWORD *)v13 + 6);
                    *(_OWORD *)&matrix.double c = v62;
                    *(_OWORD *)&matrix.tCGPDFReal x = *((_OWORD *)v13 + 8);
                    CGFloat v43 = 0.0;
                    CGPatternTiling v45 = kCGPatternTilingConstantSpacingMinimalDistortion;
                    CGFloat v44 = 0.0;
                  }
                  CGPatternRef v63 = CGPatternCreate(v35, *(CGRect *)&v38, &matrix, v43, v44, v45, v46, &callbacks);
                  if (v63)
                  {
                    uint64_t v28 = (char *)v63;
                    uint64_t v64 = (CGColorSpace *)*((void *)v63 + 12);
                    if (v64 != v13)
                    {
                      if (v64) {
                        CFRelease(v64);
                      }
                      CFRetain(v13);
                      *((void *)v28 + 12) = v13;
                    }
                    goto LABEL_80;
                  }
                }
              }
            }
            uint64_t v28 = 0;
            uint64_t v26 = v71;
          }
        }
        else
        {
          uint64_t v28 = 0;
        }
LABEL_70:
        CGColorRef v65 = CGColorCreateWithPattern(a3, (CGPatternRef)v28, v21);
        uint64_t v66 = a2[4];
        if (a4) {
          CGPDFGStateSetFillColor(v66, v65);
        }
        else {
          CGPDFGStateSetStrokeColor(v66, v65);
        }
        if (v65) {
          CFRelease(v65);
        }
        CGColorSpaceRelease(v26);
        if (v21 != v20) {
          free(v21);
        }
        return;
      }
    }
    else if (v23)
    {
      uint64_t v24 = (double *)(v23 + 208);
      goto LABEL_34;
    }
    double v25 = 1.0;
    goto LABEL_39;
  }
  uint64_t v22 = v14 - 1;
  while (CGPDFScannerPopNumber(a1, &v73))
  {
    v21[v22--] = v73;
    if (v22 == -1) {
      goto LABEL_28;
    }
  }
  if (v21 != v20) {
    free(v21);
  }
  CGColorSpaceRelease(v71);
}

void op_scn_8117(CGPDFScanner *a1, uint64_t *a2)
{
  unint64_t FillColor = CGPDFGStateGetFillColor(a2[4]);
  if (!FillColor)
  {
    CGColorSpaceRef ColorSpace = 0;
    goto LABEL_11;
  }
  if ((FillColor & 0x8000000000000000) == 0)
  {
    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(FillColor + 24);
    if (ColorSpace) {
      goto LABEL_7;
    }
LABEL_11:
    set_color((unint64_t)a1, (uint64_t)a2, ColorSpace, 1, v12);
    return;
  }
  CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(FillColor, v5, v6, v7, v8, v9, v10, v11);
  if (!ColorSpace) {
    goto LABEL_11;
  }
LABEL_7:
  if (*(_DWORD *)(*((void *)ColorSpace + 3) + 28) != 6) {
    goto LABEL_11;
  }

  set_pattern(a1, a2, ColorSpace, 1);
}

void op_SC_8118(unint64_t a1, uint64_t a2, __n128 a3)
{
}

void op_sc_8119(unint64_t a1, uint64_t a2, __n128 a3)
{
}

void op_CS_8120(CGPDFScanner *a1, uint64_t *a2)
{
  CGPDFReal value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value)) {
    return;
  }
  if (a2)
  {
    uint64_t v3 = *a2;
    if (*a2)
    {
      CGFloat v4 = value;
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), v4);
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_9;
        }
      }
      uint64_t v7 = ColorSpace;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_9:
  uint64_t v7 = 0;
LABEL_10:
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v3, v7);
  if (ResolvedColorSpace)
  {
    uint64_t v9 = ResolvedColorSpace;
    uint64_t v10 = CGColorSpaceCopyDefaultColor((uint64_t)ResolvedColorSpace);
    CGPDFGStateSetStrokeColor(a2[4], v10);
    CGColorSpaceRelease(v9);
    if (v10) {
      CFRelease(v10);
    }
  }
}

void op_cs_8121(CGPDFScanner *a1, uint64_t *a2)
{
  CGPDFReal value = 0;
  if (!CGPDFScannerPopName(a1, (const char **)&value)) {
    return;
  }
  if (a2)
  {
    uint64_t v3 = *a2;
    if (*a2)
    {
      CGFloat v4 = value;
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), v4);
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_9;
        }
      }
      uint64_t v7 = ColorSpace;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_9:
  uint64_t v7 = 0;
LABEL_10:
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v3, v7);
  if (ResolvedColorSpace)
  {
    uint64_t v9 = ResolvedColorSpace;
    uint64_t v10 = CGColorSpaceCopyDefaultColor((uint64_t)ResolvedColorSpace);
    CGPDFGStateSetFillColor(a2[4], v10);
    CGColorSpaceRelease(v9);
    if (v10) {
      CFRelease(v10);
    }
  }
}

void op_RG_8122(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceRGB");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_rg_8124(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceRGB");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_K_8125(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceCMYK");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_k_8127(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceCMYK");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_G_8128(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceGray");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 0, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

void op_g_8130(unint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = *a2;
      while (1)
      {
        CGColorSpaceRef ColorSpace = CGPDFResourcesGetColorSpace(*(void *)(v5 + 32), "DeviceGray");
        if (ColorSpace) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 40);
        if (!v5) {
          goto LABEL_6;
        }
      }
      a2 = (uint64_t *)ColorSpace;
    }
    else
    {
LABEL_6:
      a2 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGPDFContentStreamCreateResolvedColorSpace(v4, a2);
  set_color(a1, v2, ResolvedColorSpace, 1, v8);

  CGColorSpaceRelease(ResolvedColorSpace);
}

CGPDFReal op_i_8131(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    uint64_t v4 = *(void *)(a2 + 32);
    if (v4)
    {
      CGPDFReal result = value;
      *(CGPDFReal *)(v4 + 248) = value;
    }
  }
  return result;
}

void op_M_8132(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    if (value >= 1.0)
    {
      uint64_t v3 = *(void *)(a2 + 32);
      if (v3) {
        *(CGPDFReal *)(v3 + 160) = value;
      }
    }
    else
    {
      pdf_error("invalid miter limit: %g.", value);
    }
  }
}

void op_d_8133(CGPDFScanner *a1, uint64_t a2)
{
  uint64_t v5 = 0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value) && CGPDFScannerPopArray(a1, (CGPDFArrayRef *)&v5))
  {
    v4.n128_f64[0] = value;
    set_line_dash(a2, v5, v4);
  }
}

void op_w_8134(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value))
  {
    if (value >= 0.0)
    {
      uint64_t v3 = *(void *)(a2 + 32);
      if (v3) {
        *(CGPDFReal *)(v3 + 144) = value;
      }
    }
    else
    {
      pdf_error("invalid line width: %g.", value);
    }
  }
}

void op_J_8135(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    if ((unint64_t)value >= 3)
    {
      pdf_error("invalid line cap: %ld.", value);
    }
    else
    {
      uint64_t v3 = *(void *)(a2 + 32);
      if (v3) {
        *(_DWORD *)(v3 + 152) = value;
      }
    }
  }
}

void op_j_8136(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    if ((unint64_t)value >= 3)
    {
      pdf_error("invalid line join: %ld.", value);
    }
    else
    {
      uint64_t v3 = *(void *)(a2 + 32);
      if (v3) {
        *(_DWORD *)(v3 + 156) = value;
      }
    }
  }
}

void op_cm_8137(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v18 = 0.0;
  CGPDFReal v16 = 0.0;
  CGPDFReal v17 = 0.0;
  CGPDFReal v14 = 0.0;
  CGPDFReal v15 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16)
    && CGPDFScannerPopNumber(a1, &v17)
    && CGPDFScannerPopNumber(a1, &v18))
  {
    CGFloat v4 = v18;
    CGFloat v6 = v16;
    CGFloat v5 = v17;
    CGFloat v8 = v14;
    CGFloat v7 = v15;
    CGFloat v9 = value;
    uint64_t v10 = *(double **)(a2 + 32);
    v12.CGFloat a = v18;
    v12.CGFloat b = v17;
    v12.double c = v16;
    v12.double d = v15;
    v12.tCGPDFReal x = v14;
    v12.tCGFloat y = value;
    CGPDFGStateConcatCTM(v10, &v12.a);
    uint64_t v11 = *(CGContext **)(a2 + 88);
    if (v11)
    {
      v12.CGFloat a = v4;
      v12.CGFloat b = v5;
      v12.double c = v6;
      v12.double d = v7;
      v12.tCGPDFReal x = v8;
      v12.tCGFloat y = v9;
      CGContextConcatCTM(v11, &v12);
    }
  }
}

void op_Q_8138(uint64_t a1, uint64_t a2)
{
  if ((CGPDFDrawingContextRestoreGState(a2) & 1) == 0)
  {
    pdf_error("gstate stack underflow.");
  }
}

void op_q_8140(uint64_t a1, uint64_t a2)
{
}

CGPDFOperatorTable *CGPDFDrawingContextCreateContentTypesTable(char a1)
{
  uint64_t v2 = CGPDFOperatorTableCreate();
  if ((a1 & 2) != 0)
  {
    for (uint64_t i = 0; i != 18; i += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[i], (CGPDFOperatorCallback)(&operators)[i + 1]);
    CGPDFOperatorTableSetCallback(v2, "gs", (CGPDFOperatorCallback)op_gs_8018);
  }
  if ((a1 & 4) != 0)
  {
    for (uint64_t j = 0; j != 26; j += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[j + 18], (CGPDFOperatorCallback)(&operators)[j + 19]);
  }
  if ((a1 & 8) != 0)
  {
    for (uint64_t k = 0; k != 38; k += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[k + 44], (CGPDFOperatorCallback)(&operators)[k + 45]);
  }
  if ((a1 & 0x10) != 0)
  {
    for (uint64_t m = 0; m != 34; m += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[m + 82], (CGPDFOperatorCallback)(&operators)[m + 83]);
  }
  if ((a1 & 0x20) != 0)
  {
    for (uint64_t n = 0; n != 6; n += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[n + 116], (CGPDFOperatorCallback)(&operators)[n + 117]);
  }
  if ((a1 & 0x40) != 0)
  {
    CGPDFOperatorTableSetCallback(v2, "d1", (CGPDFOperatorCallback)op_d1_8063);
    for (iuint64_t i = 0; ii != 6; ii += 2)
      CGPDFOperatorTableSetCallback(v2, (&operators)[ii + 126], (CGPDFOperatorCallback)(&operators)[ii + 127]);
  }
  return v2;
}

void *CGPDFResourcesFinalize(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3) {
    CFRelease(v3);
  }
  CGFloat v4 = (const void *)a1[5];
  if (v4) {
    CFRelease(v4);
  }
  CGFloat v5 = (const void *)a1[6];
  if (v5) {
    CFRelease(v5);
  }
  CGFloat v6 = (const void *)a1[7];
  if (v6) {
    CFRelease(v6);
  }
  CGFloat v7 = (const void *)a1[8];
  if (v7) {
    CFRelease(v7);
  }
  CGFloat v8 = (const void *)a1[9];
  if (v8) {
    CFRelease(v8);
  }
  CGPDFReal result = (void *)a1[2];
  if (result)
  {
    do
    {
      uint64_t v10 = (void *)*result;
      free(result);
      CGPDFReal result = v10;
    }
    while (v10);
  }
  return result;
}

const void *CGPDFResourcesCopyXObject(uint64_t a1, const char *a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    CGFloat v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    CGFloat v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CGFloat v8 = (__CFDictionary **)(a1 + 40);
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 40);
    if (v6) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      uint64_t v2 = CFDictionaryGetValue(v7, v6);
      if (v2) {
        goto LABEL_8;
      }
    }
    CGPDFObjectRef resource = get_resource(a1, "XObject", a2);
    if (resource)
    {
      CGPDFReal value = 0;
      if (*((_DWORD *)resource + 2) == 9)
      {
        uint64_t v11 = *((void *)resource + 4);
        if (v11) {
          CGAffineTransform v12 = *(CGPDFDictionary **)(v11 + 48);
        }
        else {
          CGAffineTransform v12 = 0;
        }
        if (!CGPDFDictionaryGetName(v12, "Subtype", (const char **)&value))
        {
          goto LABEL_19;
        }
        CGPDFReal v13 = value;
        if (!strcmp(value, "Image"))
        {
          int v15 = 0;
        }
        else
        {
          if (strcmp(v13, "Form"))
          {
            goto LABEL_19;
          }
          CGPDFObjectRef v20 = 0;
          if (CGPDFDictionaryGetObject(v12, "Group", &v20) && v20 && *((_DWORD *)v20 + 2) == 8) {
            int v15 = 2;
          }
          else {
            int v15 = 1;
          }
        }
        if (CGPDFXObjectGetTypeID_onceToken[0] != -1) {
          dispatch_once(CGPDFXObjectGetTypeID_onceToken, &__block_literal_global_18962);
        }
        uint64_t cftype = pdf_create_cftype();
        if (cftype)
        {
          CGPDFReal v17 = (void *)cftype;
          *(_DWORD *)(cftype + 16) = v15;
          *(void *)(cftype + 24) = v11;
          *(_DWORD *)(cftype + 104) = 0;
          pthread_mutex_init((pthread_mutex_t *)(cftype + 32), 0);
          CGPDFReal v18 = table_set_value(v8, v6, v17);
          uint64_t v2 = v18;
          if (v18) {
            CFRelease(v18);
          }
LABEL_8:
          CFRelease(v6);
          CFRetain(v2);
LABEL_20:
          os_unfair_lock_unlock(v5);
          return v2;
        }
      }
    }
LABEL_19:
    CFRelease(v6);
    uint64_t v2 = 0;
    goto LABEL_20;
  }
  return v2;
}

const void *CGPDFResourcesGetPattern(uint64_t a1, const char *a2)
{
  uint64_t v2 = 0;
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a1 && a2)
  {
    CGFloat v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    CGFloat v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CGFloat v8 = (__CFDictionary **)(a1 + 48);
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 48);
    if (v6) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      uint64_t v2 = CFDictionaryGetValue(v7, v6);
      if (v2) {
        goto LABEL_41;
      }
    }
    CGPDFObjectRef resource = get_resource(a1, "Pattern", a2);
    if (!resource) {
      goto LABEL_40;
    }
    uint64_t v11 = (uint64_t)resource;
    CGAffineTransform v12 = (void *)CGPDFObjectCopyAssociation((uint64_t)resource, "Pattern");
    if (v12)
    {
      CGPDFReal v13 = v12;
      goto LABEL_11;
    }
    CGPDFInteger value = 0;
    int v15 = *(_DWORD *)(v11 + 8);
    if (v15 == 9)
    {
      uint64_t v17 = *(void *)(v11 + 32);
      if (!v17)
      {
        CGPDFReal v18 = 0;
LABEL_19:
        if (!CGPDFDictionaryGetInteger(v18, "PatternType", &value))
        {
          goto LABEL_40;
        }
        if (value == 2)
        {
          CGPDFObjectRef v33 = (CGPDFObjectRef)v11;
          if (CGPDFPatternGetTypeID_onceToken != -1) {
            dispatch_once(&CGPDFPatternGetTypeID_onceToken, &__block_literal_global_8306);
          }
          uint64_t cftype = pdf_create_cftype();
          uint64_t v20 = cftype;
          if (!cftype)
          {
LABEL_70:
            CGPDFReal v13 = (void *)CGPDFObjectSetAssociation(v11, (const void *)v20, "Pattern");
            if (v13)
            {
LABEL_11:
              CGPDFReal v14 = table_set_value(v8, v6, v13);
              uint64_t v2 = v14;
              if (v14) {
                CFRelease(v14);
              }
              goto LABEL_41;
            }
LABEL_40:
            uint64_t v2 = 0;
LABEL_41:
            CFRelease(v6);
            os_unfair_lock_unlock(v5);
            return v2;
          }
          *(_DWORD *)(cftype + 16) = 2;
          if (*(_DWORD *)(v11 + 8) == 8)
          {
            uint64_t v22 = *(CGPDFDictionary **)(v11 + 32);
            if (CGPDFDictionaryGetObject(v22, "Shading", &v33))
            {
              uint64_t v24 = CGPDFShadingCreateWithObject((uint64_t)v33);
              *(void *)(v20 + 144) = v24;
              if (v24)
              {
                if (CGPDFDictionaryGetNumbers(v22, "Matrix", (uint64_t)&v34, (CGPDFArray *)6))
                {
                  long long v25 = v35;
                  *(_OWORD *)(v20 + 96) = v34;
                  *(_OWORD *)(v20 + 112) = v25;
                  *(_OWORD *)(v20 + 128) = v36;
                }
                else
                {
                  *(CGAffineTransform *)(v20 + 96) = CGAffineTransformIdentity;
                }
                uint64_t v29 = (CGPDFDictionaryRef *)(v20 + 152);
                uint64_t v30 = "ExtGState";
LABEL_63:
                if (!CGPDFDictionaryGetDictionary(v22, v30, v29)) {
                  *uint64_t v29 = 0;
                }
                goto LABEL_70;
              }
            }
            else
            {
            }
          }
          else
          {
            pdf_error("invalid Type 2 pattern: not a dictionary.");
          }
        }
        else
        {
          if (value != 1)
          {
            goto LABEL_40;
          }
          if (CGPDFPatternGetTypeID_onceToken != -1) {
            dispatch_once(&CGPDFPatternGetTypeID_onceToken, &__block_literal_global_8306);
          }
          uint64_t v19 = pdf_create_cftype();
          uint64_t v20 = v19;
          if (!v19) {
            goto LABEL_70;
          }
          CGPDFInteger v32 = 0;
          CGPDFObjectRef v33 = 0;
          *(_DWORD *)(v19 + 16) = 1;
          if (*(_DWORD *)(v11 + 8) == 9)
          {
            uint64_t v21 = *(void *)(v11 + 32);
            *(void *)(v19 + 24) = v21;
            if (v21) {
              uint64_t v22 = *(CGPDFDictionary **)(v21 + 48);
            }
            else {
              uint64_t v22 = 0;
            }
            if (CGPDFDictionaryGetInteger(v22, "PaintType", (CGPDFInteger *)&v33))
            {
              char v27 = (char)v33;
              if (v33 != (CGPDFObjectRef)1)
              {
                if (v33 != (CGPDFObjectRef)2)
                {
                  goto LABEL_69;
                }
                char v27 = 0;
              }
              *(unsigned char *)(v20 + 32) = v27;
              if (CGPDFDictionaryGetInteger(v22, "TilingType", &v32))
              {
                if ((unint64_t)(v32 - 1) >= 3)
                {
                }
                else
                {
                  *(_DWORD *)(v20 + 36) = dword_185210788[v32 - 1];
                  if (CGPDFDictionaryGetRect(v22, "BBox", (double *)(v20 + 40)))
                  {
                    if (CGPDFDictionaryGetNumber(v22, "XStep", (CGPDFReal *)(v20 + 72)))
                    {
                      if (CGPDFDictionaryGetNumber(v22, "YStep", (CGPDFReal *)(v20 + 80)))
                      {
                        if (CGPDFDictionaryGetNumbers(v22, "Matrix", (uint64_t)&v34, (CGPDFArray *)6))
                        {
                          long long v28 = v35;
                          *(_OWORD *)(v20 + 96) = v34;
                          *(_OWORD *)(v20 + 112) = v28;
                          *(_OWORD *)(v20 + 128) = v36;
                        }
                        else
                        {
                          *(CGAffineTransform *)(v20 + 96) = CGAffineTransformIdentity;
                        }
                        uint64_t v29 = (CGPDFDictionaryRef *)(v20 + 88);
                        uint64_t v30 = "Resources";
                        goto LABEL_63;
                      }
                    }
                    else
                    {
                    }
                  }
                  else
                  {
                  }
                }
              }
              else
              {
              }
            }
            else
            {
            }
          }
          else
          {
            pdf_error("invalid Type 1 pattern: not a stream.");
          }
        }
LABEL_69:
        CFRelease((CFTypeRef)v20);
        uint64_t v20 = 0;
        goto LABEL_70;
      }
      CGPDFReal v16 = (CGPDFDictionary **)(v17 + 48);
    }
    else
    {
      if (v15 != 8)
      {
        pdf_error("invalid pattern: not a dictionary or stream.");
        goto LABEL_40;
      }
      CGPDFReal v16 = (CGPDFDictionary **)(v11 + 32);
    }
    CGPDFReal v18 = *v16;
    goto LABEL_19;
  }
  return v2;
}

const void *CGPDFResourcesGetShading(uint64_t a1, const char *a2)
{
  CFDataRef Value = 0;
  if (a1 && a2)
  {
    CGFloat v5 = (os_unfair_lock_s *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 80));
    CGFloat v6 = (__CFString *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 56);
    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8 || (CFDataRef Value = CFDictionaryGetValue(v7, v6)) == 0)
    {
      CGPDFObjectRef resource = get_resource(a1, "Shading", a2);
      uint64_t v10 = (void *)CGPDFShadingCreateWithObject((uint64_t)resource);
      if (v10)
      {
        uint64_t v11 = table_set_value((__CFDictionary **)(a1 + 56), v6, v10);
        CFDataRef Value = v11;
        if (v11) {
          CFRelease(v11);
        }
      }
      else
      {
        CFDataRef Value = 0;
      }
    }
    CFRelease(v6);
    os_unfair_lock_unlock(v5);
  }
  return Value;
}

void __CGPDFResourcesPurgeXObjects_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 16))
  {
    uint64_t Value = CGPDFXObjectGetValue(a3);
    if (Value)
    {
      CGFloat v4 = (const void *)Value;
      uint64_t v5 = *(void *)(Value + 24);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 48);
        if (v6)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v6 + 72));
          CFDictionaryRef v7 = *(const void ***)(v6 + 48);
          if (v7 && *v7 == v4)
          {
            *(void *)(v6 + 48) = 0;
            CGPDFAssociationRelease(v7);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 72));
        }
      }
    }
  }
}

void traverseBoundary(uint64_t a1, int *a2)
{
  if (*(unsigned char *)(a1 + 31))
  {
    int v3 = *a2;
    uint64_t v4 = *a2;
    if ((*a2 - 1) < 3)
    {
      if (!*(unsigned char *)(a1 + 29))
      {
        *(unsigned char *)(a1 + 28) = 1;
LABEL_15:
        uint64_t v6 = 0;
        unint64_t v55 = qword_185210768[v4];
        char v7 = *(unsigned char *)(a1 + 20);
        char v8 = *(unsigned char *)(a1 + 22);
        BOOL v9 = *(double **)a1;
        char v10 = *(unsigned char *)(a1 + 21);
        uint64_t v11 = (double *)(*((void *)a2 + 1) + 8);
        char v12 = *(unsigned char *)(a1 + 23);
        while (1)
        {
          *(unsigned char *)(a1 + 24) = v7;
          *(unsigned char *)(a1 + 25) = v10;
          *(unsigned char *)(a1 + 26) = v8;
          *(unsigned char *)(a1 + 27) = v12;
          *(_DWORD *)(a1 + 20) = 0;
          double v13 = *(v11 - 1);
          double v14 = *v9;
          double v15 = v9[2];
          double v16 = v9[3];
          if (v15 < 0.0 || v16 < 0.0)
          {
            uint64_t v17 = *((void *)v9 + 1);
            *(void *)&double v14 = (unint64_t)CGRectStandardize(*(CGRect *)&v14);
          }
          double v18 = vabdd_f64(v13, v14);
          BOOL v19 = v18 < 0.015;
          *(unsigned char *)(a1 + 21) = v19;
          double v20 = *v9;
          double v21 = v9[2];
          double v22 = v9[3];
          if (v21 < 0.0 || v22 < 0.0)
          {
            uint64_t v23 = *((void *)v9 + 1);
            *(CGRect *)&double v20 = CGRectStandardize(*(CGRect *)&v20);
          }
          double v24 = vabdd_f64(v13, v20 + v21);
          BOOL v25 = v24 < 0.015;
          *(unsigned char *)(a1 + 23) = v25;
          double v26 = *v11;
          double v27 = v9[1];
          double v28 = v9[2];
          double v29 = v9[3];
          uint64_t v56 = v11;
          if (v28 < 0.0 || v29 < 0.0)
          {
            double v30 = *v9;
            *(CGRect *)(&v27 - 1) = CGRectStandardize(*(CGRect *)(&v27 - 1));
          }
          double v31 = vabdd_f64(v26, v27);
          BOOL v32 = v31 < 0.015;
          *(unsigned char *)(a1 + 20) = v32;
          double v33 = v9[1];
          double v34 = v9[2];
          double v35 = v9[3];
          if (v34 < 0.0 || v35 < 0.0)
          {
            double v36 = *v9;
            *(CGRect *)(&v33 - 1) = CGRectStandardize(*(CGRect *)(&v33 - 1));
          }
          double v37 = vabdd_f64(v26, v33 + v35);
          BOOL v38 = v37 < 0.015;
          *(unsigned char *)(a1 + 22) = v38;
          if (++v6 >= v55) {
            break;
          }
          if (v10) {
            BOOL v19 = v18 < 0.015;
          }
          else {
            BOOL v19 = 0;
          }
          *(unsigned char *)(a1 + 21) = v19;
          if (v12) {
            BOOL v25 = v24 < 0.015;
          }
          else {
            BOOL v25 = 0;
          }
          *(unsigned char *)(a1 + 23) = v25;
          if (v7) {
            BOOL v32 = v31 < 0.015;
          }
          else {
            BOOL v32 = 0;
          }
          *(unsigned char *)(a1 + 20) = v32;
          if (v8) {
            BOOL v38 = v37 < 0.015;
          }
          else {
            BOOL v38 = 0;
          }
          *(unsigned char *)(a1 + 22) = v38;
          if (v32 || v25 || v19)
          {
            BOOL v39 = v25;
            goto LABEL_205;
          }
          BOOL v39 = v25;
          if (!v38) {
            break;
          }
LABEL_205:
          char v12 = v39;
          char v10 = v19;
          char v8 = v38;
          char v7 = v32;
          uint64_t v11 = v56 + 2;
          if (v55 == v6) {
            return;
          }
        }
        BOOL v40 = v19;
        char v41 = v38;
        if (!v32 && !v19)
        {
          if (v38)
          {
            BOOL v40 = 0;
            char v41 = 1;
          }
          else
          {
            if (!v25) {
              goto LABEL_207;
            }
            BOOL v40 = 0;
            char v41 = 0;
          }
        }
        if (*(unsigned char *)(a1 + 8))
        {
          if (v7)
          {
            if (v19)
            {
LABEL_54:
              BOOL v42 = 1;
              BOOL v39 = v25;
              BOOL v40 = v19;
              goto LABEL_89;
            }
            BOOL v39 = 0;
            if (v32 && !v25)
            {
              BOOL v42 = 1;
              BOOL v40 = 0;
              goto LABEL_89;
            }
            BOOL v40 = 0;
          }
          if (v10)
          {
            if (v38)
            {
              char v41 = 1;
              BOOL v39 = v25;
LABEL_64:
              BOOL v42 = 1;
              goto LABEL_89;
            }
            char v41 = 0;
            if (!v32 && v19) {
              goto LABEL_54;
            }
            BOOL v40 = v19;
          }
          if (v8)
          {
            if (v25)
            {
              BOOL v42 = 1;
              goto LABEL_56;
            }
            BOOL v39 = 0;
            if (v38)
            {
              BOOL v40 = v19;
              BOOL v43 = !v19;
            }
            else
            {
              BOOL v43 = 0;
            }
            if (v43)
            {
              char v41 = 1;
              BOOL v40 = 0;
              goto LABEL_64;
            }
            char v41 = v38;
          }
          else
          {
            BOOL v39 = v25;
          }
          BOOL v42 = v12 != 0;
          BOOL v44 = v25;
          if (v25) {
            char v45 = v38;
          }
          else {
            char v45 = v41;
          }
          if (v38) {
            BOOL v44 = 0;
          }
          if (v12) {
            BOOL v46 = v25;
          }
          else {
            BOOL v46 = v39;
          }
          if (!v12)
          {
            char v45 = v41;
            BOOL v44 = v12 != 0;
          }
          if (!v32)
          {
            BOOL v39 = v46;
            char v41 = v45;
            BOOL v42 = v44;
          }
LABEL_89:
          *(unsigned char *)(a1 + 8) = v42;
          int v47 = *(unsigned __int8 *)(a1 + 9);
          if (!*(unsigned char *)(a1 + 9)) {
            goto LABEL_133;
          }
          if (v7)
          {
            if (v25)
            {
LABEL_92:
              BOOL v39 = v25;
              goto LABEL_122;
            }
            BOOL v39 = 0;
            if (v32)
            {
              if (!v19)
              {
                BOOL v40 = 0;
                goto LABEL_122;
              }
              BOOL v40 = v19;
              if (v10)
              {
LABEL_122:
                int v47 = 1;
                *(unsigned char *)(a1 + 9) = 1;
                goto LABEL_134;
              }
              goto LABEL_104;
            }
            if (!v10) {
              goto LABEL_104;
            }
          }
          else
          {
            if (!v10) {
              goto LABEL_104;
            }
            if (v32) {
              goto LABEL_122;
            }
          }
          if (!v19)
          {
            if (v8)
            {
LABEL_109:
              if (v38)
              {
                if (v25)
                {
                  char v41 = 1;
                  if (v12)
                  {
                    BOOL v40 = 0;
                    goto LABEL_92;
                  }
                  BOOL v40 = 0;
                  int v47 = 0;
                  goto LABEL_130;
                }
                BOOL v39 = 0;
                BOOL v40 = 0;
LABEL_121:
                char v41 = 1;
                goto LABEL_122;
              }
              if (v12)
              {
                BOOL v40 = 0;
                goto LABEL_123;
              }
              BOOL v40 = 0;
              char v41 = 0;
              goto LABEL_132;
            }
            BOOL v40 = 0;
LABEL_119:
            if (v12)
            {
              if (v38) {
                goto LABEL_121;
              }
LABEL_123:
              char v41 = 0;
              int v47 = !v32 && v25;
LABEL_130:
              BOOL v39 = v25;
              goto LABEL_133;
            }
LABEL_132:
            int v47 = 0;
LABEL_133:
            *(unsigned char *)(a1 + 9) = v47;
            if (((v42 | v47) & 1) == 0) {
              goto LABEL_207;
            }
LABEL_134:
            int v49 = *(_DWORD *)(a1 + 12);
            if (v49)
            {
              switch(*(_DWORD *)(a1 + 16))
              {
                case 1:
                  if (v42)
                  {
                    BOOL v50 = !v38 && v40;
                    if (v38 && v19) {
                      goto LABEL_195;
                    }
                    LOBYTE(v19) = v50;
                  }
                  else
                  {
                    LOBYTE(v19) = v40;
                    LOBYTE(v38) = v41;
                  }
                  if (!v32 || !v47) {
                    goto LABEL_205;
                  }
                  if (v25)
                  {
                    HIDWORD(v52) = 4;
                    LODWORD(v52) = v49 + 1;
                    LOBYTE(v32) = 1;
                    goto LABEL_183;
                  }
                  BOOL v39 = 0;
                  goto LABEL_201;
                case 2:
                  if (v42)
                  {
                    if (v38)
                    {
                      if (v25) {
                        goto LABEL_187;
                      }
                      BOOL v39 = 0;
                      LOBYTE(v38) = 1;
                    }
                  }
                  else
                  {
                    LOBYTE(v38) = v41;
                  }
                  if (!v32 || !v47) {
                    goto LABEL_204;
                  }
                  if (!v19)
                  {
LABEL_201:
                    LOBYTE(v32) = 1;
                    goto LABEL_205;
                  }
                  HIDWORD(v52) = 1;
                  LODWORD(v52) = v49 + 1;
                  LOBYTE(v32) = 1;
                  LOBYTE(v25) = v39;
LABEL_183:
                  char v41 = v38;
                  goto LABEL_197;
                case 3:
                  char v53 = !v32 || !v42;
                  if (v53) {
                    goto LABEL_192;
                  }
                  if (v25)
                  {
                    HIDWORD(v52) = 4;
                    LODWORD(v52) = v49 + 1;
                    LOBYTE(v32) = 1;
                    goto LABEL_188;
                  }
                  BOOL v39 = 0;
LABEL_192:
                  if (!v47) {
                    goto LABEL_199;
                  }
                  if (!v38) {
                    goto LABEL_204;
                  }
                  if (v19)
                  {
LABEL_195:
                    HIDWORD(v52) = 2;
                    LODWORD(v52) = v49 + 1;
                    char v41 = 1;
                    goto LABEL_196;
                  }
                  LOBYTE(v38) = 1;
                  goto LABEL_205;
                case 4:
                  int v54 = !v32 || !v42;
                  if (!v54) {
                    BOOL v40 = 0;
                  }
                  if ((v54 & 1) == 0 && v19)
                  {
                    HIDWORD(v52) = 1;
                    LODWORD(v52) = v49 + 1;
                    goto LABEL_167;
                  }
                  if (!v47)
                  {
LABEL_199:
                    LOBYTE(v19) = v40;
                    goto LABEL_198;
                  }
                  if (!v38) {
                    goto LABEL_204;
                  }
                  if (!v25)
                  {
                    BOOL v39 = 0;
                    LOBYTE(v38) = 1;
                    goto LABEL_204;
                  }
LABEL_187:
                  HIDWORD(v52) = 3;
                  LODWORD(v52) = v49 + 1;
                  char v41 = 1;
LABEL_188:
                  LOBYTE(v19) = v40;
                  break;
                default:
                  goto LABEL_207;
              }
              goto LABEL_197;
            }
            if (v32)
            {
              if (v19)
              {
                uint64_t v52 = 0x100000001;
LABEL_167:
                LOBYTE(v32) = 1;
LABEL_196:
                LOBYTE(v25) = v39;
LABEL_197:
                *(void *)(a1 + 12) = v52;
                BOOL v39 = v25;
LABEL_198:
                LOBYTE(v38) = v41;
                goto LABEL_205;
              }
              BOOL v39 = 0;
              LOBYTE(v32) = 1;
              uint64_t v52 = 0x400000001;
              LOBYTE(v38) = v41;
              if (v25) {
                goto LABEL_197;
              }
            }
            else
            {
              LOBYTE(v32) = 0;
              if (v38)
              {
                if (v19)
                {
                  char v41 = 1;
                  LOBYTE(v25) = v39;
                  uint64_t v52 = 0x200000001;
                  goto LABEL_197;
                }
                BOOL v39 = 0;
                char v41 = 1;
                uint64_t v52 = 0x300000001;
                LOBYTE(v38) = 1;
                if (v25) {
                  goto LABEL_197;
                }
              }
              else
              {
LABEL_204:
                LOBYTE(v19) = v40;
              }
            }
            goto LABEL_205;
          }
          if (!v38)
          {
            char v41 = 0;
            BOOL v40 = v19;
            goto LABEL_122;
          }
          char v41 = 1;
          BOOL v40 = v19;
LABEL_104:
          if (v8)
          {
            BOOL v40 = v19;
            if (v19) {
              goto LABEL_122;
            }
            goto LABEL_109;
          }
          goto LABEL_119;
        }
        BOOL v42 = 0;
LABEL_56:
        BOOL v39 = v25;
        goto LABEL_89;
      }
      goto LABEL_207;
    }
    if (v3)
    {
      if (v3 != 4)
      {
LABEL_207:
        *(unsigned char *)(a1 + 31) = 0;
        return;
      }
      if (*(unsigned char *)(a1 + 28))
      {
LABEL_8:
        *(unsigned char *)(a1 + 29) = 1;
        return;
      }
    }
    else
    {
      int v5 = *(unsigned __int8 *)(a1 + 28);
      if (!*(unsigned char *)(a1 + 28) && *(unsigned char *)(a1 + 30))
      {
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 16) = 0;
        *(_DWORD *)(a1 + 20) = 16843009;
      }
      *(unsigned char *)(a1 + 30) = 1;
      if (v5) {
        goto LABEL_8;
      }
    }
    if (v4 <= 3 && !*(unsigned char *)(a1 + 29)) {
      goto LABEL_15;
    }
  }
}

const CGPath *CGPathIsCongruentToARect(const CGPath *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (CGPathIsEmpty(result))
    {
      return 0;
    }
    else
    {
      PathBoundingBoCGPDFReal x = CGPathGetPathBoundingBox(v1);
      info = &PathBoundingBox;
      uint64_t v5 = 257;
      int v6 = 0;
      uint64_t v7 = 0x101010101010101;
      int v8 = 0x1000000;
      CGPathApply(v1, &info, (CGPathApplierFunction)traverseBoundary);
      return (const CGPath *)(HIBYTE(v8) && HIDWORD(v5) > 3);
    }
  }
  return result;
}

__n128 checkRectilinear(uint64_t a1, uint64_t a2, __n128 result)
{
  if (*(unsigned char *)(a1 + 41))
  {
    int v3 = (_OWORD *)(a1 + 24);
    double v4 = *(double *)(a1 + 24);
    result.n128_u64[0] = *(void *)a1;
    double v5 = *(double *)(a1 + 32);
    unsigned int v6 = *(_DWORD *)a2;
    if ((*(_DWORD *)a2 - 1) >= 3)
    {
      uint64_t v7 = (double *)(a1 + 8);
      if (v6 != 4)
      {
        if (!v6)
        {
          int v8 = *(_OWORD **)(a2 + 8);
          *(_OWORD *)uint64_t v7 = *v8;
          CGPDFReal result = *(__n128 *)v8;
          _OWORD *v3 = *v8;
        }
        return result;
      }
      unsigned int v6 = 1;
    }
    else
    {
      *(unsigned char *)(a1 + 40) = 1;
      uint64_t v7 = *(double **)(a2 + 8);
    }
    uint64_t v9 = v6;
    char v10 = v7;
    while (vabdd_f64(*v10, v4) < result.n128_f64[0])
    {
      v10 += 2;
      if (!--v9) {
        goto LABEL_17;
      }
    }
    uint64_t v11 = v7 + 1;
    uint64_t v12 = v6;
    while (vabdd_f64(*v11, v5) < result.n128_f64[0])
    {
      v11 += 2;
      if (!--v12) {
        goto LABEL_17;
      }
    }
    *(unsigned char *)(a1 + 41) = 0;
LABEL_17:
    CGPDFReal result = *(__n128 *)&v7[2 * v6 - 2];
    _OWORD *v3 = result;
  }
  return result;
}

_DWORD *countElements(_DWORD *result)
{
  return result;
}

unsigned char *elementIsFlat(unsigned char *result, _DWORD *a2)
{
  if (*result)
  {
    if (*a2 > 4u || ((1 << *a2) & 0x13) == 0) {
      *CGPDFReal result = 0;
    }
  }
  return result;
}

void CGPathAddFlattenedCurve(const CGPath *a1, float64_t a2, float64_t a3, float64_t a4, float64_t a5, CGFloat a6, CGFloat a7, double a8)
{
  float64x2_t CurrentPoint = (float64x2_t)CGPathGetCurrentPoint(a1);
  v11.f64[0] = a2;
  v11.f64[1] = a3;
  float64x2_t v12 = vsubq_f64(v11, CurrentPoint);
  float64x2_t v13 = v11;
  v14.f64[0] = a4;
  v14.f64[1] = a5;
  v11.f64[0] = a6;
  v11.f64[1] = a7;
  float64x2_t v15 = vsubq_f64(v14, v13);
  float64x2_t v16 = vsubq_f64(v11, v14);
  float64x2_t v17 = vsubq_f64(v15, v12);
  float64x2_t v18 = vsubq_f64(v16, v15);
  float64x2_t v19 = (float64x2_t)vzip2q_s64((int64x2_t)v17, (int64x2_t)v18);
  float64x2_t v20 = vmulq_f64(v19, v19);
  float64x2_t v21 = (float64x2_t)vzip1q_s64((int64x2_t)v17, (int64x2_t)v18);
  float64x2_t v22 = vmlaq_f64(v20, v21, v21);
  if (v22.f64[0] <= v22.f64[1]) {
    v22.f64[0] = v22.f64[1];
  }
  double v23 = v22.f64[0] * 9.0 * 0.0625;
  if (v23 > a8 * a8)
  {
    float64x2_t v24 = vsubq_f64(v18, v17);
    __asm
    {
      FMOV            V5.2D, #3.0
      FMOV            V6.2D, #6.0
    }
    float64x2_t v31 = vmulq_f64(v24, _Q6);
    float64x2_t v32 = vmlaq_f64(v24, _Q5, vaddq_f64(v12, v17));
    float64x2_t v33 = vmulq_f64(vaddq_f64(v17, v24), _Q6);
    int v34 = 1;
    __asm
    {
      FMOV            V2.2D, #0.125
      FMOV            V3.2D, #0.25
      FMOV            V4.2D, #0.5
    }
    do
    {
      float64x2_t v31 = vmulq_f64(v31, _Q2);
      float64x2_t v33 = vsubq_f64(vmulq_f64(v33, _Q3), v31);
      float64x2_t v32 = vsubq_f64(vmulq_f64(v32, _Q4), vmulq_f64(v33, _Q4));
      v34 *= 2;
      double v23 = v23 * 0.0625;
    }
    while (v23 > a8 * a8 && v34 <= 0x10000);
    if (v34 >= 2)
    {
      unsigned int v38 = v34 + 1;
      do
      {
        float64x2_t v46 = v31;
        float64x2_t v48 = vaddq_f64(CurrentPoint, v32);
        float64x2_t v42 = vaddq_f64(v32, v33);
        float64x2_t v44 = vaddq_f64(v31, v33);
        CGPathAddLineToPoint(a1, 0, v48.f64[0], v48.f64[1]);
        float64x2_t v32 = v42;
        float64x2_t v33 = v44;
        float64x2_t v31 = v46;
        float64x2_t CurrentPoint = v48;
        --v38;
      }
      while (v38 > 2);
    }
  }

  CGPathAddLineToPoint(a1, 0, a6, a7);
}

void addFlattenedElement(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      uint64_t v2 = *(CGPath **)a1;
      int v3 = *(double **)(a2 + 8);
      CGFloat v4 = *v3;
      CGFloat v5 = v3[1];
      CGPathMoveToPoint(v2, 0, v4, v5);
      break;
    case 1:
      unsigned int v6 = *(CGPath **)a1;
      uint64_t v7 = *(double **)(a2 + 8);
      CGFloat v8 = *v7;
      CGFloat v9 = v7[1];
      CGPathAddLineToPoint(v6, 0, v8, v9);
      break;
    case 2:
      char v10 = *(const CGPath **)a1;
      float64x2_t v11 = *(double **)(a2 + 8);
      double v12 = *(double *)(a1 + 8);
      double v13 = *v11;
      double v14 = v11[1];
      double v15 = v11[2];
      double v16 = v11[3];
      CGPoint CurrentPoint = CGPathGetCurrentPoint((CGPathRef)*(void *)a1);
      double v18 = (CurrentPoint.x + v13 * 2.0) / 3.0;
      double v19 = (CurrentPoint.y + v14 * 2.0) / 3.0;
      double v20 = (v15 + v13 * 2.0) / 3.0;
      double v21 = (v16 + v14 * 2.0) / 3.0;
      float64x2_t v22 = v10;
      CGFloat v23 = v15;
      CGFloat v24 = v16;
      double v25 = v12;
      goto LABEL_10;
    case 3:
      double v26 = *(double **)(a2 + 8);
      double v25 = *(double *)(a1 + 8);
      double v18 = *v26;
      double v19 = v26[1];
      double v20 = v26[2];
      double v21 = v26[3];
      CGFloat v23 = v26[4];
      CGFloat v24 = v26[5];
      float64x2_t v22 = *(const CGPath **)a1;
LABEL_10:
      CGPathAddFlattenedCurve(v22, v18, v19, v20, v21, v23, v24, v25);
      break;
    case 4:
      double v27 = *(CGPath **)a1;
      CGPathCloseSubpath(v27);
      break;
    default:
      return;
  }
}

void CGPathAddIntersection(CGPath *a1, const CGPath **a2, unsigned int a3)
{
  CGFloat v4 = a2;
  PolygonFromCGPathRef Path = createPolygonFromPath(*a2);
  uint64_t v7 = a3;
  uint64_t v8 = 1;
  int v264 = a1;
  uint64_t v265 = v7;
  unsigned int v263 = v4;
  do
  {
    CGFloat v9 = createPolygonFromPath(v4[v8]);
    char v10 = (int *)malloc_type_malloc(0x18uLL, 0x1030040B05087B7uLL);
    float64x2_t v11 = PolygonFromPath;
    PolygonFromCGPathRef Path = v10;
    uint64_t v288 = 0;
    uint64_t v289 = 0;
    uint64_t v286 = 0;
    uint64_t v287 = 0;
    uint64_t v284 = 0;
    double v285 = 0;
    int v12 = *v11;
    if (!*v11 || !*v9)
    {
      *char v10 = 0;
      *((void *)v10 + 1) = 0;
      *((void *)v10 + 2) = 0;
      goto LABEL_412;
    }
    BOOL v13 = v12 < 1 || *v9 < 1;
    uint64_t v271 = v11;
    if (!v13)
    {
      uint64_t v14 = v8;
      contour_bboxes = create_contour_bboxes(v11);
      double v16 = create_contour_bboxes(v9);
      float64x2_t v17 = v271;
      double v18 = (double *)v16;
      int v19 = *v271;
      LODWORD(v20) = *v9;
      int v21 = *v9 * *v271;
      if (v21)
      {
        float64x2_t v22 = (int *)malloc_type_malloc(4 * v21, 0x100004052888210uLL);
        float64x2_t v17 = v271;
        CGFloat v23 = v22;
        int v19 = *v271;
        LODWORD(v20) = *v9;
      }
      else
      {
        CGFloat v23 = 0;
      }
      if (v19 >= 1)
      {
        for (uint64_t i = 0; i < v19; ++i)
        {
          if ((int)v20 >= 1)
          {
            uint64_t v25 = 0;
            double v26 = (double *)&contour_bboxes[32 * i];
            double v27 = v26[2];
            double v28 = v18 + 2;
            do
            {
              if (v27 >= *(v28 - 2) && *v26 <= *v28)
              {
                BOOL v30 = v26[3] < *(v28 - 1) || v26[1] > v28[1];
                int v29 = !v30;
              }
              else
              {
                int v29 = 0;
              }
              v23[(int)i + *v17 * (int)v25++] = v29;
              uint64_t v20 = *v9;
              v28 += 4;
            }
            while (v25 < v20);
            int v19 = *v17;
          }
        }
      }
      if ((int)v20 >= 1)
      {
        uint64_t v31 = 0;
        float64x2_t v32 = v23;
        do
        {
          uint64_t v33 = v19 & ~(v19 >> 31);
          int v34 = v32;
          while (v33)
          {
            int v35 = *v34++;
            --v33;
            if (v35) {
              goto LABEL_33;
            }
          }
          *(_DWORD *)(*((void *)v9 + 2) + 16 * v31) = -*(_DWORD *)(*((void *)v9 + 2) + 16 * v31);
LABEL_33:
          ++v31;
          v32 += v19;
        }
        while (v31 != v20);
      }
      if (v19 >= 1)
      {
        uint64_t v36 = 0;
        uint64_t v37 = v19;
        uint64_t v38 = v20 & ~((int)v20 >> 31);
        uint64_t v39 = 4 * v19;
        uint64_t v40 = v38 + 1;
        char v41 = v23;
        do
        {
          uint64_t v42 = v40;
          BOOL v43 = v41;
          while (--v42)
          {
            int v44 = *v43;
            BOOL v43 = (int *)((char *)v43 + v39);
            if (v44) {
              goto LABEL_41;
            }
          }
          *(_DWORD *)(*((void *)v17 + 2) + 16 * v36) = -*(_DWORD *)(*((void *)v17 + 2) + 16 * v36);
LABEL_41:
          ++v36;
          ++v41;
        }
        while (v36 != v37);
      }
      if (contour_bboxes) {
        free(contour_bboxes);
      }
      if (v18) {
        free(v18);
      }
      if (v23) {
        free(v23);
      }
      float64x2_t v11 = v271;
      int v12 = *v271;
      uint64_t v8 = v14;
    }
    if (v12 < 1) {
      char v45 = 0;
    }
    else {
      char v45 = build_lmt((double **)&v286, (double **)&v289, &v284, (unsigned int *)v11, 1);
    }
    uint64_t v269 = v45;
    if (*v9 < 1)
    {
      float64x2_t v46 = 0;
    }
    else
    {
      float64x2_t v46 = build_lmt((double **)&v286, (double **)&v289, &v284, (unsigned int *)v9, 0);
      char v45 = v269;
    }
    float64x2_t v11 = v271;
    double v275 = (double *)v286;
    if (v286)
    {
      unint64_t v267 = v46;
      if (v284)
      {
        int v47 = v284;
        float64x2_t v48 = (double *)malloc_type_malloc(8 * (int)v284, 0x100004000313F17uLL);
      }
      else
      {
        int v47 = 0;
        float64x2_t v48 = 0;
      }
      double v272 = v48;
      build_sbt((int *)&v284 + 1, (uint64_t)v48, v289);
      free_sbtree((void **)&v289);
      if (v271 == PolygonFromPath) {
        gpc_free_polygon((uint64_t)v271);
      }
      if (v9 == PolygonFromPath) {
        gpc_free_polygon((uint64_t)v9);
      }
      int v51 = v47;
      uint64_t v268 = v8;
      if (v47 < 1)
      {
        *((void *)PolygonFromPath + 1) = 0;
        *((void *)PolygonFromPath + 2) = 0;
      }
      else
      {
        float v270 = v9;
        unint64_t v266 = PolygonFromPath;
        uint64_t v52 = 0;
        int v53 = 0;
        int v54 = 0;
        int v55 = 0;
        uint64_t v276 = 0;
        double v56 = 0.0;
        double v57 = 0.0;
        do
        {
          uint64_t v58 = v53 + 1;
          HIDWORD(v284) = v58;
          double v59 = v272[v53];
          if ((int)v58 < v51)
          {
            double v57 = v272[v58];
            double v56 = v57 - v59;
          }
          uint64_t v60 = v275;
          if (v275 && *v275 == v59)
          {
            uint64_t v61 = *((void *)v275 + 1);
            if (v61)
            {
              do
              {
                uint64_t v62 = v287;
                if (v287)
                {
                  uint64_t v63 = 0;
                  double v64 = *(double *)(v61 + 48);
                  CGColorRef v65 = &v287;
                  while (1)
                  {
                    double v66 = *(double *)(v62 + 48);
                    if (v64 < v66) {
                      break;
                    }
                    uint64_t v67 = v62;
                    if (v64 == v66 && *(double *)(v61 + 64) < *(double *)(v62 + 64)) {
                      break;
                    }
                    CGColorRef v65 = (uint64_t *)(v62 + 136);
                    uint64_t v62 = *(void *)(v62 + 136);
                    uint64_t v63 = v67;
                    if (!v62) {
                      goto LABEL_83;
                    }
                  }
                  *(void *)(v61 + 128) = v63;
                  *(void *)(v61 + 136) = *v65;
                  *(void *)(*v65 + 128) = v61;
                  *CGColorRef v65 = v61;
                }
                else
                {
                  uint64_t v67 = 0;
                  CGColorRef v65 = &v287;
LABEL_83:
                  *CGColorRef v65 = v61;
                  *(void *)(v61 + 128) = v67;
                  *(void *)(v61 + 136) = 0;
                }
                uint64_t v61 = *(void *)(v61 + 160);
              }
              while (v61);
              uint64_t v52 = v287;
            }
            uint64_t v60 = (double *)*((void *)v275 + 2);
          }
          double v275 = v60;
          if (v52)
          {
            *(_DWORD *)(v52 + 76 + 4 * *(int *)(v52 + 72)) = *(double *)(v52 + 40) != v59;
            *(_DWORD *)(v52 + 76 + 4 * (*(_DWORD *)(v52 + 72) == 0)) = 0;
            *(_DWORD *)(v52 + 100) = 0;
            uint64_t v68 = *(void *)(v52 + 136);
            for (uint64_t j = v52; v68; uint64_t j = v73)
            {
              uint64_t v70 = v68 + 76;
              *(_DWORD *)(v68 + 76 + 4 * *(int *)(v68 + 72)) = *(double *)(v68 + 40) != v59;
              uint64_t v71 = *(int *)(v68 + 72);
              *(_DWORD *)(v68 + 76 + 4 * (*(_DWORD *)(v68 + 72) == 0)) = 0;
              *(_DWORD *)(v68 + 100) = 0;
              int v72 = *(_DWORD *)(v68 + 76 + 4 * v71);
              if (v72)
              {
                uint64_t v73 = v68;
                if (vabdd_f64(*(double *)(j + 48), *(double *)(v68 + 48)) <= 2.22044605e-16)
                {
                  uint64_t v73 = v68;
                  if (vabdd_f64(*(double *)(j + 64), *(double *)(v68 + 64)) <= 2.22044605e-16)
                  {
                    uint64_t v73 = v68;
                    if (*(double *)(j + 40) != v59)
                    {
                      *(_DWORD *)(v70 + 4 * v71) = *(_DWORD *)(j + 76 + 4 * v71) ^ v72;
                      BOOL v74 = *(_DWORD *)(v68 + 72) == 0;
                      int v75 = *(_DWORD *)(j + 76 + 4 * (*(_DWORD *)(v68 + 72) == 0));
                      *(_DWORD *)(v68 + 100) = 1;
                      *(_DWORD *)(v70 + 4 * v74) = v75;
                      *(_DWORD *)(j + 76) = 0;
                      *(_DWORD *)(j + 80) = 0;
                      *(_DWORD *)(j + 100) = 2;
                      uint64_t v73 = v68;
                    }
                  }
                }
              }
              else
              {
                uint64_t v73 = j;
              }
              uint64_t v68 = *(void *)(v68 + 136);
            }
            uint64_t v76 = 0;
            uint64_t v77 = 0;
            double v78 = -1.79769313e308;
            do
            {
              int v80 = *(_DWORD *)(v52 + 76);
              int v79 = *(_DWORD *)(v52 + 80);
              int v82 = *(_DWORD *)(v52 + 84);
              int v81 = *(_DWORD *)(v52 + 88);
              int v83 = v80 + 2 * v82;
              int v84 = v79 + 2 * v81;
              if (v83 | v84)
              {
                *(_DWORD *)(v52 + 92) = v55;
                *(_DWORD *)(v52 + 96) = v54;
                if (!v83 || (int v85 = 1, !v54) && !v77)
                {
                  if (!v84 || (int v85 = 1, !v55) && !v76)
                  {
                    if (v83) {
                      BOOL v86 = v84 == 0;
                    }
                    else {
                      BOOL v86 = 1;
                    }
                    int v85 = !v86 && v55 == v54;
                  }
                }
                if (v55) {
                  BOOL v88 = v54 == 0;
                }
                else {
                  BOOL v88 = 1;
                }
                int v89 = !v88;
                BOOL v91 = v55 != v80 && v54 != v79;
                int v92 = v55 ^ (v76 != 0);
                int v93 = v77 != 0;
                if (v92) {
                  BOOL v94 = v54 == v93;
                }
                else {
                  BOOL v94 = 1;
                }
                int v95 = !v94;
                int v96 = v81 ^ v93;
                BOOL v98 = v92 != v82 && v96 != v54;
                v55 ^= v80;
                if (v83) {
                  uint64_t v76 = next_h_state[6 * v76 - 2 + 2 * v83 + v55];
                }
                v54 ^= v79;
                if (v84) {
                  uint64_t v77 = next_h_state[6 * v77 - 2 + 2 * v84 + v54];
                }
                if (v85)
                {
                  if (v98) {
                    int v99 = 2;
                  }
                  else {
                    int v99 = 0;
                  }
                  if (v89) {
                    int v100 = 4;
                  }
                  else {
                    int v100 = 0;
                  }
                  if (v91) {
                    int v101 = 8;
                  }
                  else {
                    int v101 = 0;
                  }
                  double v102 = *(double *)(v52 + 48);
                  switch(v100 | v101 | v99 | v95)
                  {
                    case 1:
                      uint64_t v104 = v276;
                      if (v102 != v78)
                      {
                        if (v276)
                        {
                          CGPDFInteger v105 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          double *v105 = v102;
                          v105[1] = v59;
                          uint64_t v106 = *(void *)(v276 + 32);
                          v105[2] = *(double *)(v106 + 8);
                          *(void *)(v106 + 8) = v105;
                          uint64_t v104 = v276;
                        }
                        double v78 = v102;
                      }
                      merge_right(v104, *(void *)(v52 + 120), (uint64_t)v285);
                      goto LABEL_186;
                    case 2:
                      uint64_t v107 = *(void *)(v52 + 120);
                      if (v107)
                      {
                        CGPDFStreamRef v108 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                        *CGPDFStreamRef v108 = v102;
                        v108[1] = v59;
                        uint64_t v109 = *(void *)(v107 + 32);
                        v108[2] = *(double *)(v109 + 8);
                        *(void *)(v109 + 8) = v108;
                        uint64_t v103 = *(void *)(v52 + 120);
LABEL_160:
                        uint64_t v276 = v103;
                      }
                      else
                      {
                        uint64_t v276 = 0;
                      }
                      goto LABEL_197;
                    case 4:
                      uint64_t v110 = v276;
                      if (v102 == v78) {
                        goto LABEL_185;
                      }
                      if (!v276) {
                        goto LABEL_184;
                      }
                      double v111 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                      *double v111 = v102;
                      v111[1] = v59;
                      v111[2] = 0.0;
                      uint64_t v112 = *(void *)(v276 + 32);
                      *(void *)(*(void *)(v112 + 16) + 16) = v111;
                      *(void *)(v112 + 16) = v111;
                      goto LABEL_183;
                    case 5:
                      if (*(double *)(v52 + 24) == v59)
                      {
                        uint64_t v113 = *(void *)(v52 + 120);
                        if (v113)
                        {
                          double v114 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *double v114 = v102;
                          v114[1] = v59;
                          v114[2] = 0.0;
                          uint64_t v115 = *(void *)(v113 + 32);
                          *(void *)(*(void *)(v115 + 16) + 16) = v114;
                          *(void *)(v115 + 16) = v114;
                        }
                      }
                      goto LABEL_179;
                    case 6:
                      uint64_t v116 = v276;
                      if (v102 != v78)
                      {
                        double v78 = *(double *)(v52 + 48);
                        if (v276)
                        {
                          CGRect v117 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *CGRect v117 = v102;
                          v117[1] = v59;
                          v117[2] = 0.0;
                          uint64_t v118 = *(void *)(v276 + 32);
                          *(void *)(*(void *)(v118 + 16) + 16) = v117;
                          *(void *)(v118 + 16) = v117;
                          uint64_t v116 = v276;
                          double v78 = v102;
                        }
                      }
                      merge_left(v116, *(void *)(v52 + 120), (uint64_t)v285);
                      goto LABEL_175;
                    case 7:
                    case 8:
                      add_local_min(&v285, v52, *(double *)(v52 + 48), v59);
                      uint64_t v103 = *(void *)(v52 + 112);
                      goto LABEL_160;
                    case 9:
                      uint64_t v119 = v276;
                      if (v102 != v78)
                      {
                        double v78 = *(double *)(v52 + 48);
                        if (v276)
                        {
                          uint64_t v120 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *uint64_t v120 = v102;
                          v120[1] = v59;
                          uint64_t v121 = *(void *)(v276 + 32);
                          v120[2] = *(double *)(v121 + 8);
                          *(void *)(v121 + 8) = v120;
                          uint64_t v119 = v276;
                          double v78 = v102;
                        }
                      }
                      merge_right(v119, *(void *)(v52 + 120), (uint64_t)v285);
LABEL_175:
                      *(void *)(v52 + 120) = 0;
                      add_local_min(&v285, v52, v102, v59);
                      uint64_t v276 = *(void *)(v52 + 112);
                      break;
                    case 0xA:
                      if (*(double *)(v52 + 24) == v59)
                      {
                        uint64_t v122 = *(void *)(v52 + 120);
                        if (v122)
                        {
                          double v123 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *double v123 = v102;
                          v123[1] = v59;
                          uint64_t v124 = *(void *)(v122 + 32);
                          v123[2] = *(double *)(v124 + 8);
                          *(void *)(v124 + 8) = v123;
                        }
                      }
LABEL_179:
                      *(void *)(v52 + 112) = *(void *)(v52 + 120);
                      goto LABEL_197;
                    case 0xB:
                      uint64_t v110 = v276;
                      if (v102 == v78) {
                        goto LABEL_185;
                      }
                      if (!v276) {
                        goto LABEL_184;
                      }
                      double v125 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                      *double v125 = v102;
                      v125[1] = v59;
                      uint64_t v126 = *(void *)(v276 + 32);
                      v125[2] = *(double *)(v126 + 8);
                      *(void *)(v126 + 8) = v125;
LABEL_183:
                      uint64_t v110 = v276;
LABEL_184:
                      double v78 = v102;
LABEL_185:
                      *(void *)(v52 + 112) = v110;
LABEL_186:
                      uint64_t v276 = 0;
                      break;
                    case 0xD:
                      uint64_t v127 = *(void *)(v52 + 120);
                      if (v127)
                      {
                        CGFloat v128 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                        *CGFloat v128 = v102;
                        v128[1] = v59;
                        v128[2] = 0.0;
                        uint64_t v129 = *(void *)(v127 + 32);
                        *(void *)(*(void *)(v129 + 16) + 16) = v128;
                        *(void *)(v129 + 16) = v128;
                        uint64_t v276 = *(void *)(v52 + 120);
                      }
                      else
                      {
                        uint64_t v276 = 0;
                      }
                      *(void *)(v52 + 120) = 0;
LABEL_197:
                      double v78 = v102;
                      break;
                    case 0xE:
                      uint64_t v130 = v276;
                      if (v102 != v78)
                      {
                        if (v276)
                        {
                          long long v131 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                          *long long v131 = v102;
                          v131[1] = v59;
                          v131[2] = 0.0;
                          uint64_t v132 = *(void *)(v276 + 32);
                          *(void *)(*(void *)(v132 + 16) + 16) = v131;
                          *(void *)(v132 + 16) = v131;
                          uint64_t v130 = v276;
                        }
                        double v78 = v102;
                      }
                      merge_left(v130, *(void *)(v52 + 120), (uint64_t)v285);
                      uint64_t v276 = 0;
                      *(void *)(v52 + 120) = 0;
                      break;
                    default:
                      break;
                  }
                }
              }
              uint64_t v52 = *(void *)(v52 + 136);
            }
            while (v52);
            uint64_t v52 = v287;
            uint64_t v133 = v287;
            if (v287)
            {
              do
              {
                double v134 = *(double *)(v133 + 40);
                if (v134 == v59)
                {
                  uint64_t v135 = *(void *)(v133 + 128);
                  uint64_t v136 = *(void *)(v133 + 136);
                  uint64_t v137 = v136;
                  if (v135)
                  {
                    *(void *)(v135 + 136) = v136;
                    uint64_t v137 = v52;
                  }
                  if (v136) {
                    *(void *)(v136 + 128) = v135;
                  }
                  if (v135)
                  {
                    if (*(_DWORD *)(v133 + 104) == 1 && *(_DWORD *)(v135 + 104) == 2)
                    {
                      *(void *)(v135 + 120) = *(void *)(v133 + 120);
                      *(_DWORD *)(v135 + 104) = 0;
                      uint64_t v138 = *(void *)(v135 + 128);
                      if (v138)
                      {
                        if (*(_DWORD *)(v138 + 104) == 2) {
                          *(_DWORD *)(v135 + 104) = 1;
                        }
                      }
                    }
                  }
                  uint64_t v52 = v137;
                }
                else
                {
                  if (v134 == v57) {
                    double v139 = *(double *)(v133 + 32);
                  }
                  else {
                    double v139 = *(double *)(v133 + 16) + *(double *)(v133 + 64) * (v57 - *(double *)(v133 + 24));
                  }
                  *(double *)(v133 + 56) = v139;
                }
                uint64_t v133 = *(void *)(v133 + 136);
              }
              while (v133);
              uint64_t v287 = v52;
            }
          }
          if (SHIDWORD(v284) >= (int)v284) {
            break;
          }
          int v273 = HIDWORD(v284);
          int v274 = v284;
          uint64_t v140 = v288;
          if (v288)
          {
            do
            {
              double v141 = (void *)v140[4];
              free(v140);
              uint64_t v140 = v141;
            }
            while (v141);
            uint64_t v288 = 0;
          }
          v290[0] = 0;
          if (v52)
          {
            uint64_t v142 = v52;
            while (1)
            {
              if (*(_DWORD *)(v142 + 100) != 1 && !*(_DWORD *)(v142 + 76) && !*(_DWORD *)(v142 + 80)) {
                goto LABEL_251;
              }
              double v143 = (double *)v290[0];
              if (!v290[0])
              {
                double v145 = v290;
                goto LABEL_249;
              }
              double v144 = (double *)(v142 + 64);
              double v145 = v290;
              do
              {
                double v146 = v143[2];
                double v147 = *(double *)(v142 + 56);
                if (v147 >= v146
                  || ((double v148 = v143[1],
                       double v149 = v146 - v148,
                       double v150 = *(double *)(v142 + 48),
                       double v151 = v149 - (v147 - v150),
                       double v152 = fabs(v151),
                       *v144 != v143[3])
                    ? (BOOL v153 = v152 > 2.22044605e-16)
                    : (BOOL v153 = 0),
                      !v153))
                {
                  uint64_t v164 = malloc_type_malloc(0x28uLL, 0x102004060DBCA02uLL);
                  *double v145 = v164;
                  *uint64_t v164 = v142;
                  uint64_t v165 = *v145;
                  *(_OWORD *)(*v145 + 8) = *(_OWORD *)(v142 + 48);
                  goto LABEL_250;
                }
                double v154 = (v150 - v148) / v151;
                double v155 = v154 * v56;
                double v156 = *v143;
                unint64_t v157 = v288;
                if (!v288)
                {
                  unint64_t v158 = &v288;
LABEL_244:
                  CFArrayRef v160 = (double *)malloc_type_malloc(0x28uLL, 0x1020040D4280EFAuLL);
                  unint64_t v157 = 0;
                  goto LABEL_245;
                }
                if (*((double *)v288 + 3) > v155)
                {
                  unint64_t v158 = &v288;
                  goto LABEL_241;
                }
                do
                {
                  unsigned int v159 = v157;
                  unint64_t v157 = (void *)v157[4];
                  if (!v157)
                  {
                    unint64_t v158 = (void **)(v159 + 4);
                    goto LABEL_244;
                  }
                }
                while (*((double *)v157 + 3) <= v155);
                unint64_t v158 = (void **)(v159 + 4);
LABEL_241:
                CFArrayRef v160 = (double *)malloc_type_malloc(0x28uLL, 0x1020040D4280EFAuLL);
LABEL_245:
                *unint64_t v158 = v160;
                *CFArrayRef v160 = v156;
                *((void *)*v158 + 1) = v142;
                int v161 = (double *)*v158;
                v161[2] = v148 + v154 * v149;
                v161[3] = v155;
                *((void *)v161 + 4) = v157;
                uint64_t v162 = *v145;
                uint64_t v163 = *(double **)(v162 + 32);
                double v145 = (void *)(v162 + 32);
                double v143 = v163;
              }
              while (v163);
LABEL_249:
              uint64_t v166 = malloc_type_malloc(0x28uLL, 0x102004060DBCA02uLL);
              double v143 = 0;
              *double v145 = v166;
              *uint64_t v166 = v142;
              uint64_t v165 = *v145;
              *(_OWORD *)(*v145 + 8) = *(_OWORD *)(v142 + 48);
              double v144 = (double *)(v142 + 64);
LABEL_250:
              *(double *)(v165 + 24) = *v144;
              *(void *)(v165 + 32) = v143;
LABEL_251:
              uint64_t v142 = *(void *)(v142 + 136);
              if (!v142)
              {
                vImagePixelCount v167 = (void *)v290[0];
                if (v290[0])
                {
                  do
                  {
                    uint64_t v168 = (void *)v167[4];
                    free(v167);
                    vImagePixelCount v167 = v168;
                  }
                  while (v168);
                }
                break;
              }
            }
          }
          int v169 = (uint64_t *)v288;
          if (v288)
          {
            while (1)
            {
              uint64_t v173 = *v169;
              uint64_t v174 = v169[1];
              int v175 = *(_DWORD *)(*v169 + 76);
              if (!v175) {
                break;
              }
              int v176 = *(_DWORD *)(v174 + 76);
              if (v176)
              {
                int v177 = (uint64_t *)(v173 + 112);
                uint64_t v178 = *(void *)(v173 + 112);
                uint64_t v179 = (uint64_t *)(v174 + 112);
                uint64_t v180 = *(void *)(v174 + 112);
                long long v181 = *((_OWORD *)v169 + 1);
                if (*(_DWORD *)(v173 + 92)) {
                  goto LABEL_262;
                }
                int v172 = 1;
              }
              else
              {
                if (!*(_DWORD *)(v174 + 80)) {
                  goto LABEL_334;
                }
                int v176 = 0;
                int v177 = (uint64_t *)(v173 + 112);
                uint64_t v178 = *(void *)(v173 + 112);
                uint64_t v179 = (uint64_t *)(v174 + 112);
                uint64_t v180 = *(void *)(v174 + 112);
                long long v181 = *((_OWORD *)v169 + 1);
                int v172 = *(_DWORD *)(v173 + 92) == 0;
              }
LABEL_270:
              int v183 = *(_DWORD *)(v173 + 80);
              if (!v183)
              {
                if (!*(_DWORD *)(v174 + 80))
                {
                  int v184 = *(_DWORD *)(v173 + 96);
                  if (!v184) {
                    goto LABEL_278;
                  }
                }
LABEL_276:
                int v184 = *(_DWORD *)(v174 + 96) != 0;
                goto LABEL_278;
              }
              if (*(_DWORD *)(v173 + 96))
              {
                int v184 = *(_DWORD *)(v174 + 80);
                if (v184) {
                  goto LABEL_276;
                }
              }
              else
              {
                int v184 = 1;
              }
LABEL_278:
              BOOL v185 = v176 != v172 && *(_DWORD *)(v174 + 80) != v184;
              BOOL v187 = v175 != v172 && v183 != v184;
              if ((v176 ^ v175) == v172)
              {
                int v188 = 0;
                if (v185) {
                  int v189 = 2;
                }
                else {
                  int v189 = 0;
                }
                if (v187) {
                  int v190 = 4;
                }
                else {
                  int v190 = 0;
                }
              }
              else
              {
                BOOL v191 = (*(_DWORD *)(v174 + 80) ^ v183) != v184;
                if (v185) {
                  int v189 = 2;
                }
                else {
                  int v189 = 0;
                }
                if (v187) {
                  int v190 = 4;
                }
                else {
                  int v190 = 0;
                }
                if (v191) {
                  int v188 = 8;
                }
                else {
                  int v188 = 0;
                }
              }
              double v192 = v59 + *((double *)&v181 + 1);
              switch(v190 | v172 & v184 | v188 | v189)
              {
                case 1:
                  if (v178 && v180)
                  {
                    uint64_t v277 = v181;
                    uint64_t v194 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)uint64_t v194 = v277;
                    v194[1] = v192;
                    uint64_t v195 = *(void *)(v178 + 32);
                    v194[2] = *(double *)(v195 + 8);
                    *(void *)(v195 + 8) = v194;
                    merge_right(v178, v180, (uint64_t)v285);
                    goto LABEL_332;
                  }
                  goto LABEL_334;
                case 2:
                  if (v180)
                  {
                    uint64_t v278 = v181;
                    uint64_t v196 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)uint64_t v196 = v278;
                    v196[1] = v192;
                    uint64_t v197 = *(void *)(v180 + 32);
                    v196[2] = *(double *)(v197 + 8);
                    *(void *)(v197 + 8) = v196;
                    goto LABEL_328;
                  }
                  goto LABEL_334;
                case 4:
                  if (v178)
                  {
                    uint64_t v279 = v181;
                    uint64_t v198 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)uint64_t v198 = v279;
                    v198[1] = v192;
                    v198[2] = 0.0;
                    uint64_t v199 = *(void *)(v178 + 32);
                    *(void *)(*(void *)(v199 + 16) + 16) = v198;
                    *(void *)(v199 + 16) = v198;
                    goto LABEL_325;
                  }
                  goto LABEL_334;
                case 6:
                  if (v178 && v180)
                  {
                    uint64_t v280 = v181;
                    uint64_t v200 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)uint64_t v200 = v280;
                    v200[1] = v192;
                    v200[2] = 0.0;
                    uint64_t v201 = *(void *)(v178 + 32);
                    *(void *)(*(void *)(v201 + 16) + 16) = v200;
                    *(void *)(v201 + 16) = v200;
                    merge_left(v178, v180, (uint64_t)v285);
                    goto LABEL_321;
                  }
                  goto LABEL_334;
                case 7:
                case 8:
                  uint64_t v193 = *v169;
                  goto LABEL_322;
                case 9:
                  if (v178 && v180)
                  {
                    uint64_t v280 = v181;
                    int v202 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)int v202 = v280;
                    v202[1] = v192;
                    uint64_t v203 = *(void *)(v178 + 32);
                    v202[2] = *(double *)(v203 + 8);
                    *(void *)(v203 + 8) = v202;
                    merge_right(v178, v180, (uint64_t)v285);
LABEL_321:
                    uint64_t v193 = v173;
                    *(void *)&long long v181 = v280;
LABEL_322:
                    add_local_min(&v285, v193, *(double *)&v181, v192);
                    *uint64_t v179 = *(void *)(v173 + 112);
                  }
                  goto LABEL_334;
                case 0xB:
                  if (v178)
                  {
                    uint64_t v281 = v181;
                    unsigned int v204 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                    *(void *)unsigned int v204 = v281;
                    v204[1] = v192;
                    uint64_t v205 = *(void *)(v178 + 32);
                    v204[2] = *(double *)(v205 + 8);
                    *(void *)(v205 + 8) = v204;
LABEL_325:
                    *uint64_t v179 = v178;
                    *int v177 = 0;
                  }
                  goto LABEL_334;
                case 0xD:
                  if (!v180) {
                    goto LABEL_334;
                  }
                  uint64_t v282 = v181;
                  uint64_t v206 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                  *(void *)uint64_t v206 = v282;
                  v206[1] = v192;
                  v206[2] = 0.0;
                  uint64_t v207 = *(void *)(v180 + 32);
                  *(void *)(*(void *)(v207 + 16) + 16) = v206;
                  *(void *)(v207 + 16) = v206;
LABEL_328:
                  *int v177 = v180;
                  break;
                case 0xE:
                  if (!v178 || !v180) {
                    goto LABEL_334;
                  }
                  uint64_t v283 = v181;
                  uint64_t v208 = (double *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
                  *(void *)uint64_t v208 = v283;
                  v208[1] = v192;
                  v208[2] = 0.0;
                  uint64_t v209 = *(void *)(v178 + 32);
                  *(void *)(*(void *)(v209 + 16) + 16) = v208;
                  *(void *)(v209 + 16) = v208;
                  merge_left(v178, v180, (uint64_t)v285);
LABEL_332:
                  *int v177 = 0;
                  break;
                default:
                  goto LABEL_334;
              }
              *uint64_t v179 = 0;
LABEL_334:
              if (*(_DWORD *)(v173 + 76)) {
                *(_DWORD *)(v174 + 92) = *(_DWORD *)(v174 + 92) == 0;
              }
              if (*(_DWORD *)(v174 + 76)) {
                *(_DWORD *)(v173 + 92) = *(_DWORD *)(v173 + 92) == 0;
              }
              if (*(_DWORD *)(v173 + 80)) {
                *(_DWORD *)(v174 + 96) = *(_DWORD *)(v174 + 96) == 0;
              }
              if (*(_DWORD *)(v174 + 80)) {
                *(_DWORD *)(v173 + 96) = *(_DWORD *)(v173 + 96) == 0;
              }
              uint64_t v170 = *(void *)(v173 + 128);
              uint64_t v210 = *(void *)(v174 + 136);
              if (v210) {
                *(void *)(v210 + 128) = v173;
              }
              if (*(_DWORD *)(v173 + 100) == 1)
              {
                while (1)
                {
                  uint64_t v170 = *(void *)(v170 + 128);
                  if (!v170) {
                    break;
                  }
                  if (*(_DWORD *)(v170 + 100) != 2) {
                    goto LABEL_349;
                  }
                }
LABEL_256:
                uint64_t v170 = 0;
                *(void *)(v52 + 128) = v174;
                *(void *)(v174 + 136) = v52;
                uint64_t v171 = *(void *)(v173 + 136);
                uint64_t v52 = v171;
                if (!v171) {
                  goto LABEL_353;
                }
                goto LABEL_352;
              }
              if (!v170) {
                goto LABEL_256;
              }
LABEL_349:
              uint64_t v211 = *(void *)(v170 + 136);
              if (!v211) {
                MEMORY[0x80] = v174;
              }
              *(void *)(v174 + 136) = v211;
              *(void *)(v170 + 136) = *(void *)(v173 + 136);
              uint64_t v171 = *(void *)(v173 + 136);
              if (!v171) {
                goto LABEL_353;
              }
LABEL_352:
              *(void *)(v171 + 128) = v170;
LABEL_353:
              uint64_t v212 = *(void *)(v174 + 136);
              if (v212) {
                *(void *)(v212 + 128) = v174;
              }
              *(void *)(v173 + 136) = v210;
              int v169 = (uint64_t *)v169[4];
              if (!v169) {
                goto LABEL_356;
              }
            }
            if (!*(_DWORD *)(v173 + 80)) {
              goto LABEL_334;
            }
            int v176 = *(_DWORD *)(v174 + 76);
            if (v176)
            {
              int v177 = (uint64_t *)(v173 + 112);
              uint64_t v178 = *(void *)(v173 + 112);
              uint64_t v179 = (uint64_t *)(v174 + 112);
              uint64_t v180 = *(void *)(v174 + 112);
              long long v181 = *((_OWORD *)v169 + 1);
              int v182 = *(_DWORD *)(v174 + 92);
            }
            else
            {
              if (!*(_DWORD *)(v174 + 80)) {
                goto LABEL_334;
              }
              int v177 = (uint64_t *)(v173 + 112);
              uint64_t v178 = *(void *)(v173 + 112);
              uint64_t v179 = (uint64_t *)(v174 + 112);
              uint64_t v180 = *(void *)(v174 + 112);
              long long v181 = *((_OWORD *)v169 + 1);
              int v176 = *(_DWORD *)(v173 + 92);
              if (!v176)
              {
                int v172 = 0;
                goto LABEL_270;
              }
              int v176 = 0;
LABEL_262:
              int v182 = *(_DWORD *)(v174 + 92);
            }
            int v172 = v182 != 0;
            goto LABEL_270;
          }
LABEL_356:
          if (v52)
          {
            uint64_t v213 = v52;
            do
            {
              uint64_t v214 = *(void *)(v52 + 136);
              uint64_t v215 = *(void *)(v52 + 152);
              uint64_t v216 = *(void *)(v52 + 112);
              if (*(double *)(v52 + 40) != v57 || v215 == 0)
              {
                *(void *)(v52 + 120) = v216;
                *(_DWORD *)(v52 + 104) = *(_DWORD *)(v52 + 100);
                *(void *)(v52 + 84) = *(void *)(v52 + 76);
                *(void *)(v52 + 48) = *(void *)(v52 + 56);
                uint64_t v218 = v213;
              }
              else
              {
                *(void *)(v215 + 120) = v216;
                *(_DWORD *)(v215 + 104) = *(_DWORD *)(v52 + 100);
                *(_DWORD *)(v215 + 84) = *(_DWORD *)(v52 + 76);
                *(_DWORD *)(v215 + 88) = *(_DWORD *)(v52 + 80);
                uint64_t v219 = *(void *)(v52 + 128);
                uint64_t v218 = v215;
                if (v219)
                {
                  *(void *)(v219 + 136) = v215;
                  uint64_t v218 = v213;
                }
                if (v214) {
                  *(void *)(v214 + 128) = v215;
                }
                *(void *)(v215 + 128) = v219;
                *(void *)(v215 + 136) = v214;
                uint64_t v213 = v218;
              }
              *(void *)(v52 + 112) = 0;
              uint64_t v52 = v214;
            }
            while (v214);
          }
          else
          {
            uint64_t v218 = 0;
          }
          uint64_t v287 = v218;
          uint64_t v52 = v218;
          int v53 = v273;
          int v51 = v274;
        }
        while (v273 < v274);
        unsigned int v220 = v285;
        PolygonFromCGPathRef Path = v266;
        *((void *)v266 + 1) = 0;
        *((void *)v266 + 2) = 0;
        CGFloat v4 = v263;
        a1 = v264;
        CGFloat v9 = v270;
        if (v220)
        {
          int v221 = 0;
          double v222 = v220;
          while (1)
          {
            if (*(_DWORD *)v222)
            {
              uint64_t v223 = v222[4];
              CGFloat v224 = *(void **)(v223 + 8);
              if (!v224) {
                goto LABEL_382;
              }
              unsigned int v225 = -1;
              uint64_t v226 = *(void *)(v223 + 8);
              do
              {
                unsigned int v227 = v225;
                uint64_t v226 = *(void *)(v226 + 16);
                ++v225;
              }
              while (v226);
              if (v225 <= 1)
              {
                do
                {
                  BOOL v228 = (void *)v224[2];
                  free(v224);
                  CGFloat v224 = v228;
                }
                while (v228);
LABEL_382:
                *(_DWORD *)double v222 = 0;
                goto LABEL_383;
              }
              *(_DWORD *)double v222 = v227 + 2;
              ++v221;
            }
LABEL_383:
            double v222 = (void *)v222[3];
            if (!v222)
            {
              *unint64_t v266 = v221;
              if (v221 <= 0)
              {
                do
                {
                  uint64_t v231 = (void *)v220[3];
                  free(v220);
                  unsigned int v220 = v231;
                }
                while (v231);
              }
              else
              {
                *((void *)v266 + 1) = malloc_type_malloc(4 * v221, 0x100004052888210uLL);
                uint64_t v229 = *v266;
                if (v229) {
                  uint64_t v230 = malloc_type_malloc(16 * v229, 0x1020040D5A9D86FuLL);
                }
                else {
                  uint64_t v230 = 0;
                }
                int v232 = 0;
                *((void *)v266 + 2) = v230;
                do
                {
                  double v233 = (void *)v220[3];
                  if (*(_DWORD *)v220)
                  {
                    uint64_t v234 = v220[4];
                    *(_DWORD *)(*((void *)v266 + 1) + 4 * v232) = *(_DWORD *)(v234 + 4);
                    uint64_t v235 = *(int *)v220;
                    uint64_t v236 = *((void *)v266 + 2);
                    *(_DWORD *)(v236 + 16 * v232) = v235;
                    if (v235)
                    {
                      int v237 = malloc_type_malloc(16 * v235, 0x1000040451B5BE8uLL);
                      uint64_t v238 = *((void *)v266 + 2) + 16 * v232;
                      *(void *)(v238 + 8) = v237;
                      LODWORD(v235) = *(_DWORD *)v238;
                      uint64_t v234 = v220[4];
                    }
                    else
                    {
                      *(void *)(v236 + 16 * v232 + 8) = 0;
                    }
                    uint64_t v239 = *(void **)(v234 + 8);
                    if (v239)
                    {
                      uint64_t v240 = 16 * (int)v235 - 16;
                      do
                      {
                        uint64_t v241 = (void *)v239[2];
                        *(_OWORD *)(*(void *)(*((void *)v266 + 2) + 16 * v232 + 8) + v240) = *(_OWORD *)v239;
                        free(v239);
                        v240 -= 16;
                        uint64_t v239 = v241;
                      }
                      while (v241);
                    }
                    ++v232;
                    CGFloat v9 = v270;
                  }
                  free(v220);
                  unsigned int v220 = v233;
                }
                while (v233);
              }
LABEL_402:
              __int32 v242 = v288;
              if (v288)
              {
                do
                {
                  uint64_t v243 = (void *)v242[4];
                  free(v242);
                  __int32 v242 = v243;
                }
                while (v243);
              }
              uint64_t v244 = v286;
              uint64_t v7 = v265;
              uint64_t v8 = v268;
              if (v286)
              {
                do
                {
                  unint64_t v245 = (void *)v244[2];
                  free(v244);
                  uint64_t v244 = v245;
                }
                while (v245);
              }
              if (v267) {
                free(v267);
              }
              if (v269) {
                free(v269);
              }
              float64x2_t v11 = v271;
              BOOL v50 = v272;
              if (v272)
              {
LABEL_411:
                free(v50);
                float64x2_t v11 = v271;
              }
              goto LABEL_412;
            }
          }
        }
      }
      *PolygonFromCGPathRef Path = 0;
      goto LABEL_402;
    }
    *PolygonFromCGPathRef Path = 0;
    *((void *)PolygonFromPath + 1) = 0;
    *((void *)PolygonFromPath + 2) = 0;
    if (v45)
    {
      int v49 = v46;
      free(v45);
      float64x2_t v46 = v49;
      float64x2_t v11 = v271;
    }
    if (v46)
    {
      BOOL v50 = v46;
      goto LABEL_411;
    }
LABEL_412:
    BOOL v246 = v11;
    gpc_free_polygon((uint64_t)v11);
    free(v246);
    gpc_free_polygon((uint64_t)v9);
    free(v9);
    ++v8;
  }
  while (v8 != v7);
  unint64_t v247 = *PolygonFromPath;
  if (v247)
  {
    for (unint64_t k = 0; k < v247; ++k)
    {
      uint64_t v249 = *((void *)PolygonFromPath + 2);
      unint64_t v250 = (unsigned int *)(v249 + 16 * k);
      float64x2_t v251 = 0uLL;
      if (v249)
      {
        uint64_t v252 = *v250;
        if (v252)
        {
          uint64_t v253 = *(float64x2_t **)(v249 + 16 * k + 8);
          float64x2_t v254 = *v253;
          if (v252 == 1)
          {
            float64x2_t v255 = *v253;
          }
          else
          {
            uint64_t v256 = v252 - 1;
            int v257 = v253 + 1;
            float64x2_t v255 = v254;
            do
            {
              float64x2_t v258 = *v257++;
              float64x2_t v255 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v255, v258), (int8x16_t)v258, (int8x16_t)v255);
              float64x2_t v254 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v258, v254), (int8x16_t)v258, (int8x16_t)v254);
              --v256;
            }
            while (v256);
          }
          float64x2_t v251 = vsubq_f64(v254, v255);
        }
      }
      if (v251.f64[0] > 0.01 || v251.f64[1] > 0.01)
      {
        unsigned int v259 = *v250;
        if ((int)*v250 >= 1)
        {
          CGPathMoveToPoint(a1, 0, **(CGFloat **)(v249 + 16 * k + 8), *(CGFloat *)(*(void *)(v249 + 16 * k + 8) + 8));
          unsigned int v259 = *v250;
        }
        if (v259 >= 2)
        {
          uint64_t v260 = 0;
          uint64_t v261 = (void *)(v249 + 16 * k + 8);
          unint64_t v262 = 1;
          do
          {
            CGPathAddLineToPoint(a1, 0, *(CGFloat *)(*v261 + v260 + 16), *(CGFloat *)(*v261 + v260 + 24));
            ++v262;
            v260 += 16;
          }
          while (v262 < *v250);
        }
        CGPathCloseSubpath(a1);
        unint64_t v247 = *PolygonFromPath;
      }
    }
  }
  gpc_free_polygon((uint64_t)PolygonFromPath);

  free(PolygonFromPath);
}

int *createPolygonFromPath(const CGPath *a1)
{
  LOBYTE(info) = 1;
  if (a1)
  {
    CGPathApply(a1, &info, (CGPathApplierFunction)elementIsFlat);
    if ((_BYTE)info)
    {
      CFRetain(a1);
      CFDictionaryRef Mutable = a1;
    }
    else
    {
      CFDictionaryRef Mutable = CGPathCreateMutable();
      info = Mutable;
      float64x2_t v11 = (void *)0x3FE3333333333333;
      CGPathApply(a1, &info, (CGPathApplierFunction)addFlattenedElement);
      if (!Mutable) {
        goto LABEL_9;
      }
    }
    LODWORD(info) = 0;
    CGPathApply(Mutable, &info, (CGPathApplierFunction)countElements);
    unsigned int v3 = info;
    if (info < 0x2711) {
      goto LABEL_10;
    }
    CFRelease(Mutable);
    PathBoundingBoCGFloat x = CGPathGetPathBoundingBox(a1);
    CGFloat x = PathBoundingBox.origin.x;
    CGFloat y = PathBoundingBox.origin.y;
    CGFloat width = PathBoundingBox.size.width;
    CGFloat height = PathBoundingBox.size.height;
    CFDictionaryRef Mutable = CGPathCreateMutable();
    v14.origin.CGFloat x = x;
    v14.origin.CGFloat y = y;
    v14.size.CGFloat width = width;
    v14.size.CGFloat height = height;
    CGPathAddRect(Mutable, 0, v14);
    if (Mutable)
    {
      LODWORD(info) = 0;
      CGPathApply(Mutable, &info, (CGPathApplierFunction)countElements);
      unsigned int v3 = info;
      goto LABEL_10;
    }
  }
  else
  {
    CFDictionaryRef Mutable = 0;
  }
LABEL_9:
  unsigned int v3 = 0;
LABEL_10:
  info = 0;
  float64x2_t v11 = 0;
  uint64_t v8 = (int *)malloc_type_malloc(0x18uLL, 0x1030040B05087B7uLL);
  int v12 = v8;
  *uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  if (v3)
  {
    LODWORD(info) = 0;
    float64x2_t v11 = malloc_type_calloc(v3, 0x10uLL, 0x1000040451B5BE8uLL);
    CGPathApply(Mutable, &info, (CGPathApplierFunction)addVertex);
    if ((int)info >= 2) {
      gpc_add_contour(v12, (int *)&info);
    }
    free(v11);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v12;
}

void addVertex(int *a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      if (*a1 >= 2) {
        gpc_add_contour(*((int **)a1 + 2), a1);
      }
      *(_OWORD *)*((void *)a1 + 1) = *(_OWORD *)*(void *)(a2 + 8);
      goto LABEL_9;
    case 1:
      uint64_t v4 = *((void *)a1 + 1);
      uint64_t v5 = *a1;
      *a1 = v5 + 1;
      long long v6 = *(_OWORD *)*(void *)(a2 + 8);
      goto LABEL_11;
    case 2:
      uint64_t v4 = *((void *)a1 + 1);
      uint64_t v5 = *a1;
      *a1 = v5 + 1;
      long long v6 = *(_OWORD *)(*(void *)(a2 + 8) + 16);
      goto LABEL_11;
    case 3:
      uint64_t v4 = *((void *)a1 + 1);
      uint64_t v5 = *a1;
      *a1 = v5 + 1;
      long long v6 = *(_OWORD *)(*(void *)(a2 + 8) + 32);
LABEL_11:
      *(_OWORD *)(v4 + 16 * v5) = v6;
      break;
    case 4:
      if (*a1 >= 2)
      {
        gpc_add_contour(*((int **)a1 + 2), a1);
LABEL_9:
        *a1 = 1;
      }
      break;
    default:
      return;
  }
}

uint64_t countSubpaths(uint64_t result, _DWORD *a2)
{
  if ((*a2 | 4) == 4)
  {
    *(unsigned char *)(result + 4) = 1;
  }
  else if (*(unsigned char *)(result + 4))
  {
    ++*(_DWORD *)result;
    *(unsigned char *)(result + 4) = 0;
  }
  return result;
}

void createSubpaths(uint64_t a1, int *a2)
{
  if (*a2 == 4)
  {
    if (!*(unsigned char *)(a1 + 32))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 28);
      if (v4 <= *(_DWORD *)(a1 + 24)) {
        CGPathCloseSubpath(*(CGMutablePathRef *)(*(void *)a1 + 8 * (v4 - 1)));
      }
      goto LABEL_4;
    }
  }
  else
  {
    if (!*a2)
    {
      *(_OWORD *)(a1 + 8) = *(_OWORD *)*((void *)a2 + 1);
LABEL_4:
      *(unsigned char *)(a1 + 32) = 1;
      return;
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 28);
    if (*(unsigned char *)(a1 + 32))
    {
      if (v5 < *(_DWORD *)(a1 + 24))
      {
        CFDictionaryRef Mutable = CGPathCreateMutable();
        CGPathMoveToPoint(Mutable, 0, *(CGFloat *)(a1 + 8), *(CGFloat *)(a1 + 16));
        uint64_t v5 = *(unsigned int *)(a1 + 28);
        *(void *)(*(void *)a1 + 8 * v5) = Mutable;
      }
      LODWORD(v5) = v5 + 1;
      *(_DWORD *)(a1 + 28) = v5;
      *(unsigned char *)(a1 + 32) = 0;
    }
    if (v5 <= *(_DWORD *)(a1 + 24))
    {
      int v7 = *a2;
      if (*a2 == 3)
      {
        int v12 = *(CGPath **)(*(void *)a1 + 8 * (v5 - 1));
        BOOL v13 = (double *)*((void *)a2 + 1);
        CGFloat v14 = *v13;
        CGFloat v15 = v13[1];
        CGFloat v16 = v13[2];
        CGFloat v17 = v13[3];
        CGFloat v18 = v13[4];
        CGFloat v19 = v13[5];
        CGPathAddCurveToPoint(v12, 0, v14, v15, v16, v17, v18, v19);
      }
      else if (v7 == 2)
      {
        uint64_t v20 = *(CGPath **)(*(void *)a1 + 8 * (v5 - 1));
        int v21 = (double *)*((void *)a2 + 1);
        CGFloat v22 = *v21;
        CGFloat v23 = v21[1];
        CGFloat v24 = v21[2];
        CGFloat v25 = v21[3];
        CGPathAddQuadCurveToPoint(v20, 0, v22, v23, v24, v25);
      }
      else if (v7 == 1)
      {
        uint64_t v8 = *(CGPath **)(*(void *)a1 + 8 * (v5 - 1));
        CGFloat v9 = (double *)*((void *)a2 + 1);
        CGFloat v10 = *v9;
        CGFloat v11 = v9[1];
        CGPathAddLineToPoint(v8, 0, v10, v11);
      }
    }
  }
}

char *CGClipStrokeCreate(const CGAffineTransform *a1, unsigned __int8 a2, __int16 a3, char a4, char a5, atomic_uint *a6, double a7, double a8, double a9)
{
  CGPDFReal result = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
  *(_DWORD *)CGPDFReal result = 1;
  CGFloat v19 = &CGAffineTransformIdentity;
  if (a1) {
    CGFloat v19 = a1;
  }
  long long v21 = *(_OWORD *)&v19->c;
  long long v20 = *(_OWORD *)&v19->tx;
  *(_OWORD *)(result + 8) = *(_OWORD *)&v19->a;
  *(_OWORD *)(result + 24) = v21;
  *(_OWORD *)(result + 40) = v20;
  *((double *)result + 7) = a7;
  *((_WORD *)result + 32) = a2 | (unsigned __int16)(a3 << 8);
  *((double *)result + 9) = a8;
  result[66] = a4;
  result[67] = a5;
  if (a6) {
    atomic_fetch_add_explicit(a6, 1u, memory_order_relaxed);
  }
  *((void *)result + 10) = a6;
  *((double *)result + 11) = a9;
  return result;
}

char *CGClipStrokeCreateWithGState(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 128);
  return CGClipStrokeCreate((const CGAffineTransform *)(a1 + 24), *(_WORD *)(v1 + 2), *(__int16 *)(v1 + 2) >> 8, *(unsigned char *)(v1 + 1), HIBYTE(*(_DWORD *)(*(void *)(a1 + 120) + 4)) & 1, *(atomic_uint **)(v1 + 32), *(double *)(v1 + 8), *(double *)(v1 + 16), *(double *)(*(void *)(a1 + 144) + 8));
}

atomic_uint *CGClipStrokeCreateCopy(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

atomic_uint *CGClipStrokeRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

char *CGClipStrokeCreateCopyWithTransform(uint64_t a1, const CGAffineTransform *a2)
{
  return CGClipStrokeCreate(a2, *(_WORD *)(a1 + 64), *(__int16 *)(a1 + 64) >> 8, *(unsigned char *)(a1 + 66), *(unsigned char *)(a1 + 67), *(atomic_uint **)(a1 + 80), *(double *)(a1 + 56), *(double *)(a1 + 72), *(double *)(a1 + 88));
}

void CGClipStrokeRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (void *)a1[10];
    if (v2 && atomic_fetch_add_explicit((atomic_uint *volatile)v2, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v2);
    }
    free(a1);
  }
}

BOOL CGClipStrokeEqualToClipStroke(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    if (*(double *)(a1 + 8) != *(double *)(a2 + 8)) {
      return 0;
    }
    uint64_t v2 = 0;
    if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 16), *(float64x2_t *)(a2 + 16)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)(a2 + 32)))), 0xFuLL))) & 1) != 0&& *(double *)(a1 + 48) == *(double *)(a2 + 48))
    {
      if (*(double *)(a1 + 56) != *(double *)(a2 + 56)
        || *(unsigned __int16 *)(a1 + 64) != *(unsigned __int16 *)(a2 + 64)
        || *(double *)(a1 + 72) != *(double *)(a2 + 72)
        || *(unsigned __int8 *)(a1 + 66) != *(unsigned __int8 *)(a2 + 66)
        || *(unsigned __int8 *)(a1 + 67) != *(unsigned __int8 *)(a2 + 67)
        || *(double *)(a1 + 88) != *(double *)(a2 + 88))
      {
        return 0;
      }
      return !CGDashEqualToDash(*(void *)(a1 + 80), *(void *)(a2 + 80));
    }
  }
  return v2;
}

__n128 CGClipStrokeGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1) {
    uint64_t v2 = &CGAffineTransformIdentity;
  }
  long long v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

double CGClipStrokeGetLineWidth(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 56);
  }
  else {
    return 0.0;
  }
}

uint64_t CGClipStrokeGetLineCap(uint64_t result)
{
  if (result) {
    return *(char *)(result + 64);
  }
  return result;
}

uint64_t CGClipStrokeGetLineJoin(uint64_t result)
{
  if (result) {
    return *(char *)(result + 65);
  }
  return result;
}

double CGClipStrokeGetMiterLimit(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 72);
  }
  else {
    return 0.0;
  }
}

BOOL CGClipStrokeGetStrokeAdjust(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 66) != 0;
  }
  return result;
}

BOOL CGClipStrokeGetShouldAntialias(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 67) != 0;
  }
  return result;
}

uint64_t CGClipStrokeGetDash(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

double CGClipStrokeGetFlatness(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 88);
  }
  else {
    return 0.0;
  }
}

uint64_t CGClipStrokeCreateStrokedPath(uint64_t a1, char *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v10 = CFGetTypeID(cf);
    if (v10 != CGPathGetTypeID()) {
      return 0;
    }
  }
  uint64_t v11 = *(void *)(a1 + 80);
  DashedCGPathRef Path = cf;
  if (v11) {
    DashedCGPathRef Path = (char *)CGPathCreateDashedPath(cf, (_anonymous_namespace_ *)(a1 + 8), (const double *)(v11 + 24), *(void *)(v11 + 16), a5, a6, a7, a8, *(double *)(v11 + 8));
  }
  StrokedCGPathRef Path = CGPathCreateStrokedPath(DashedPath, (_anonymous_namespace_ *)(a1 + 8), (char)*(_WORD *)(a1 + 64), (*(__int16 *)(a1 + 64) >> 8), a5, a6, a7, a8, *(double *)(a1 + 56), *(double *)(a1 + 72), *(double *)(a1 + 88));
  if (DashedPath != cf && DashedPath) {
    CFRelease(DashedPath);
  }
  return StrokedPath;
}

uint64_t CGPDFDocumentGetXRef(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 16);
    if (v1) {
      return **(void **)(v1 + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFXRefGetEntry(uint64_t result, unint64_t a2, unsigned __int16 a3, uint64_t a4)
{
  if (!result) {
    return result;
  }
  if (!a4)
  {
    pdf_error("Output parameter is NULL\n");
    return 0;
  }
  uint64_t v7 = *(void *)(result + 16);
  if (!v7)
  {
    __n128 result = *(void *)(result + 8);
    if (result)
    {
      return CGPDFXRefStreamGetEntry(result, a2, a3, a4);
    }
    return result;
  }
  uint64_t v8 = *(void **)(v7 + 8);
  if (!v8) {
    return 0;
  }
  while (1)
  {
    uint64_t v9 = v8[1];
    object_offset = xref_table_get_object_offset(*(void **)(v9 + 40), a2, a3);
    if (object_offset)
    {
      *(_DWORD *)a4 = 0;
      *(void *)(a4 + 8) = object_offset;
      *(unsigned char *)(a4 + 24) = 1;
      *(_WORD *)(a4 + 26) = a3;
    }
    uint64_t v11 = *(void *)(v9 + 32);
    if (v11)
    {
      if (CGPDFXRefStreamGetEntry(v11, a2, a3, a4)) {
        break;
      }
    }
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      return 0;
    }
  }
  return 1;
}

uint64_t CGPDFXRefPrint(uint64_t a1, FILE *__stream)
{
  fwrite("xref\n", 5uLL, 1uLL, __stream);
  uint64_t v4 = *(void *)(a1 + 16);
  CGFloat v16 = __stream;
  if (v4)
  {
    if (__stream) {
      uint64_t v5 = __stream;
    }
    else {
      uint64_t v5 = (FILE *)*MEMORY[0x1E4F143D8];
    }
    long long v6 = *(void **)(v4 + 8);
    if (v6)
    {
      do
      {
        CGFloat v18 = v6;
        uint64_t v7 = v6[1];
        fprintf(v5, "xref table @ offset %lld:\n", *(void *)(v7 + 8));
        uint64_t v17 = v7;
        for (uint64_t i = *(void **)(v7 + 40); i; uint64_t i = (void *)*i)
        {
          uint64_t v9 = (void *)i[1];
          fprintf(v5, "  %ld %ld\n", *v9, v9[1]);
          if ((uint64_t)v9[1] >= 1)
          {
            uint64_t v10 = 0;
            uint64_t v11 = v9 + 3;
            do
            {
              fprintf(v5, "    %.10lld ", v11[v10]);
              uint64_t v12 = v9[2];
              if (v12) {
                LODWORD(v12) = *(unsigned __int16 *)(v12 + 2 * v10);
              }
              fprintf(v5, "%.5hu ", v12);
              if (v11[v10]) {
                uint64_t v13 = 110;
              }
              else {
                uint64_t v13 = 102;
              }
              fprintf(v5, "%c \n", v13);
              ++v10;
            }
            while (v10 < v9[1]);
          }
        }
        CGPDFDictionaryPrintWithIndent(*(void *)(v17 + 16), v5, 0);
        fputc(10, v5);
        uint64_t v14 = *(void *)(v17 + 32);
        if (v14) {
          CGPDFXRefStreamPrint(v14, (uint64_t)v5);
        }
        long long v6 = (void *)*v18;
      }
      while (*v18);
    }
  }
  else
  {
    CGPDFXRefStreamPrint(*(void *)(a1 + 8), (uint64_t)__stream);
  }

  return fputc(10, v16);
}

uint64_t CGPDFXRefEntryPrint(_DWORD *a1, FILE *a2)
{
  if (a2) {
    long long v3 = a2;
  }
  else {
    long long v3 = (FILE *)*MEMORY[0x1E4F143D8];
  }
  fprintf(v3, "CGPDFXRefEntry (%p)\n", a1);
  if (*a1) {
    uint64_t v4 = "kCGPDFXRefEntryKindStream";
  }
  else {
    uint64_t v4 = "kCGPDFXRefEntryKindOffset";
  }
  fprintf(v3, "  kind: %s\n", v4);
  if (*a1 == 1) {
    fprintf(v3, "  object_number = %lu, indeCGFloat x = %ld\n");
  }
  else {
    fprintf(v3, "  offset = %lld\n");
  }
  uint64_t v5 = "true";
  if (!*((unsigned char *)a1 + 24)) {
    uint64_t v5 = "false";
  }
  return fprintf(v3, "  used = %s, generatiouint64_t n = %hu\n", v5, *((unsigned __int16 *)a1 + 13));
}

uint64_t rips_s_BltShade(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (int *)a4;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  int v14 = *(_DWORD *)(a1 + 12);
  if ((v14 & 0x80) == 0)
  {
    if ((v14 & 0x1000) == 0)
    {
      return (uint64_t)RIPLayerBltShade(a2, a3, a4, (uint64_t)a5, a6, a8, a7, a8);
    }
    return 1;
  }
  int32x4_t v89 = 0uLL;
  v88[1] = 0;
  v88[0] = 0;
  v87[1] = 0;
  v87[0] = 0;
  double v17 = *(double *)(a8 + 48);
  float v18 = *(float *)(a1 + 112);
  if (!a3
    || (int32x4_t v89 = vaddq_s32(*(int32x4_t *)(a1 + 96), *a5),
        CGSBoundsIntersection((int *)(a3 + 12), v89.i32, v88)))
  {
    float v19 = v17;
    if ((float)(v18 * v19) <= 0.0039062) {
      goto LABEL_59;
    }
    if (!v11)
    {
      uint64_t v11 = (int *)v87;
      uint64_t result = CGSBoundsIntersection((int *)(a2 + 12), a5->i32, v87);
      if (!result) {
        return result;
      }
    }
    long long v20 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)v11, 0, 0, *(unsigned int *)(a2 + 52), a6, a7, a8);
    if (!v20)
    {
LABEL_59:
      if (!a3) {
        goto LABEL_64;
      }
      goto LABEL_60;
    }
    long long v21 = (uint64_t *)v20;
    long long v22 = *(_OWORD *)(a8 + 16);
    v95[0] = *(_OWORD *)a8;
    v95[1] = v22;
    long long v23 = *(_OWORD *)(a8 + 48);
    v95[2] = *(_OWORD *)(a8 + 32);
    long long v96 = v23;
    uint64_t v24 = *(void *)(a8 + 64);
    LODWORD(v95[0]) = 1;
    uint64_t v97 = v24;
    *(void *)&long long v96 = 0x3FF0000000000000;
    RIPLayerBltShade((uint64_t)v20, 0, (uint64_t)v11, (uint64_t)a5, a6, (uint64_t)v95, a7, a8);
    float v31 = *(float *)(a1 + 116);
    if (v31 >= 0.5) {
      float64x2_t v32 = RIPLayerGaussianBlur((uint64_t)v21, *(unsigned int *)(a2 + 52), v25, v26, v27, v28, v29, v30, v31);
    }
    else {
      float64x2_t v32 = RIPLayerCreateWithLayer(*v21, (uint64_t *)((char *)v21 + 12), v21, *(unsigned int *)(a2 + 52));
    }
    uint64_t v33 = v32;
    if (!v32)
    {
LABEL_58:
      (*(void (**)(uint64_t *))(*v21 + 24))(v21);
      goto LABEL_59;
    }
    int v34 = (int *)(v32 + 12);
    *(int32x2_t *)(v32 + 12) = vadd_s32(*(int32x2_t *)(v32 + 12), *(int32x2_t *)(a1 + 88));
    if (a3) {
      int v35 = (int *)(a3 + 12);
    }
    else {
      int v35 = (int *)(v32 + 12);
    }
    if (!CGSBoundsIntersection(v35, v34, &v89))
    {
LABEL_57:
      (*(void (**)(char *))(*(void *)v33 + 24))(v33);
      goto LABEL_58;
    }
    uint64_t v94 = 0;
    long long v92 = 0u;
    long long v93 = 0u;
    long long v91 = 0u;
    long long v90 = 0u;
    if (*(float *)(a1 + 120) != 0.0 || *(float *)(a1 + 124) != 1.0) {
      RIPLayerResample((uint64_t)v33, (float *)(a1 + 120), v36, v37, v38, v39, v40, v41);
    }
    if (v19 >= 0.99609
      && !*(void *)(a5[3].i64[1] + 72)
      && (*(unsigned char *)(a1 + 13) & 0x10) == 0
      && *(int *)a8 <= 2
      && (!a3 || !*(void *)(a3 + 56)))
    {
      RIPLayerMask(v33, v21, v36, v37, v38, v39, v40, v41);
    }
    uint64_t v42 = *(void *)(a1 + 80);
    if (!v42)
    {
      if (default_shadow_color_predicate != -1) {
        dispatch_once(&default_shadow_color_predicate, &__block_literal_global_3);
      }
      uint64_t v42 = default_shadow_color_shadow_color;
    }
    unint64_t v86 = v42;
    Cache = CGColorTransformGetCache(*(void **)(a8 + 16));
    if (Cache)
    {
      uint64_t v45 = Cache[2];
      if (v45)
      {
        unint64_t v46 = *(void *)(*(void *)(v45 + 24) + 48);
        if (v46 >> 61)
        {
          MEMORY[0x1F4188790](Cache, v44);
          int v82 = (double *)&v78;
          int v55 = 0;
LABEL_44:
          uint64_t v59 = *(void *)(a8 + 16);
          uint64_t v60 = (CGColor *)v86;
          int v84 = v33;
          int v83 = &v79;
          unint64_t v85 = v54;
          int v81 = v55;
          uint64_t v80 = v59;
          if (v86)
          {
            if ((v86 & 0x8000000000000000) != 0)
            {
              CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v86, v47, v48, v49, v50, v51, v52, v53);
              uint64_t v60 = (CGColor *)v86;
            }
            else
            {
              CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(v86 + 24);
            }
          }
          else
          {
            CGColorSpaceRef ColorSpace = 0;
          }
          uint64_t v62 = *(unsigned int *)(a8 + 8);
          Components = (double *)CGColorGetComponents(v60);
          uint64_t v64 = v62;
          CGColorRef v65 = v81;
          if (CGColorTransformConvertColorComponents(v80, ColorSpace, v64, Components, v81))
          {
            RIPColorCreateWithColor(*(_DWORD *)(a8 + 24), v65, v85, 1.0);
            uint64_t v73 = v72;
          }
          else
          {
            uint64_t v73 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
            *uint64_t v73 = &ripc_class;
            v73[1] = 0;
            v73[2] = 0;
            v73[3] = 0;
            *((_DWORD *)v73 + 39) = 1065353216;
          }
          if (v65 != v82) {
            free(v65);
          }
          long long v74 = *(_OWORD *)(a8 + 48);
          long long v92 = *(_OWORD *)(a8 + 32);
          long long v93 = v74;
          uint64_t v94 = *(void *)(a8 + 64);
          long long v75 = *(_OWORD *)a8;
          long long v91 = *(_OWORD *)(a8 + 16);
          long long v90 = v75;
          *(double *)&long long v93 = (float)(v18 * v19);
          uint64_t v33 = v84;
          if ((*(unsigned char *)(a1 + 13) & 0x10) != 0) {
            RIPLayerDefine(a2, (__n128 *)&v89, v66, v67, v68, v69, v70, v71);
          }
          RIPLayerBltShape((int *)a2, a3, v89.i32, (uint64_t)v33, (uint64_t)v73, 0, (uint64_t)&v90, v71);
          free(v73);
          goto LABEL_57;
        }
        Cache = (void *)(8 * v46);
      }
      else
      {
        Cache = 0;
      }
    }
    size_t v56 = MEMORY[0x1F4188790](Cache, v44);
    int v55 = (double *)((char *)&v79 - ((v57 + 15) & 0xFFFFFFFFFFFFFFF0));
    int v82 = v55;
    if (v54 > 0x1FFFFFFFFFFFFFFELL) {
      int v55 = 0;
    }
    if (v54 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022)
    {
      unint64_t v85 = v54;
      uint64_t v58 = (double *)malloc_type_malloc(v56, 0xE11A308CuLL);
      unint64_t v54 = v85;
      int v55 = v58;
    }
    goto LABEL_44;
  }
LABEL_60:
  if (v11) {
    uint64_t v76 = v11;
  }
  else {
    uint64_t v76 = (int *)a5;
  }
  if (!CGSBoundsIntersection((int *)(a3 + 12), v76, v88)) {
    return 1;
  }
LABEL_64:
  if ((*(unsigned char *)(a1 + 13) & 0x10) != 0) {
    return 1;
  }
  if (a3) {
    uint64_t v77 = (int *)v88;
  }
  else {
    uint64_t v77 = v11;
  }
  return (uint64_t)RIPLayerBltShade(a2, a3, (uint64_t)v77, (uint64_t)a5, a6, a8, a7, a8);
}

void __default_shadow_color_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
  long long v1 = xmmword_1852108F0;
  default_shadow_color_shadow_color = (uint64_t)CGColorCreate(DeviceGray, (const CGFloat *)&v1);
  CGColorSpaceRelease(DeviceGray);
}

uint64_t rips_s_BltImage(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int32x4_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (uint64_t)a2;
  if (a2 || (uint64_t v14 = a3) != 0) {
    uint64_t v15 = *(unsigned int *)(v14 + 52);
  }
  else {
    uint64_t v15 = 3;
  }
  int v16 = *(_DWORD *)(a1 + 12);
  if ((v16 & 0x40) == 0)
  {
    if ((v16 & 0x1000) == 0)
    {
      return RIPLayerBltImage((uint64_t)a2, a3, a4, (uint64_t)a5, a8, a6, a7, a8);
    }
    return 1;
  }
  int32x4_t v94 = 0uLL;
  v93[1] = 0;
  v93[0] = 0;
  double v18 = *(double *)(a8 + 48);
  float v19 = *(float *)(a1 + 112);
  if (!a3
    || (int32x4_t v94 = vaddq_s32(*(int32x4_t *)(a1 + 96), *a5),
        CGSBoundsIntersection((int *)(a3 + 12), v94.i32, v93)))
  {
    float v20 = v18;
    if ((float)(v19 * v20) <= 0.0039062
      || (a4 ? (uint64_t v21 = a4) : (uint64_t v21 = (uint64_t)a5),
          (long long v22 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, v21, 0, 0, v15, a6, a7, a8)) == 0))
    {
LABEL_73:
      if (!a3) {
        goto LABEL_78;
      }
      goto LABEL_74;
    }
    long long v23 = (uint64_t *)v22;
    long long v24 = *(_OWORD *)(a8 + 16);
    v100[0] = *(_OWORD *)a8;
    v100[1] = v24;
    long long v25 = *(_OWORD *)(a8 + 48);
    v100[2] = *(_OWORD *)(a8 + 32);
    long long v101 = v25;
    uint64_t v26 = *(void *)(a8 + 64);
    LODWORD(v100[0]) = 1;
    uint64_t v102 = v26;
    *(void *)&long long v101 = 0x3FF0000000000000;
    RIPLayerBltImage((uint64_t)v22, 0, a4, (uint64_t)a5, (uint64_t)v100, a6, a7, a8);
    float v33 = *(float *)(a1 + 116);
    if (v33 >= 0.5) {
      int v34 = RIPLayerGaussianBlur((uint64_t)v23, v15, v27, v28, v29, v30, v31, v32, v33);
    }
    else {
      int v34 = RIPLayerCreateWithLayer(*v23, (uint64_t *)((char *)v23 + 12), v23, v15);
    }
    int v35 = v34;
    if (!v34)
    {
LABEL_72:
      (*(void (**)(uint64_t *))(*v23 + 24))(v23);
      goto LABEL_73;
    }
    uint64_t v36 = (int *)(v34 + 12);
    int v37 = *((_DWORD *)v34 + 3);
    int v38 = *(_DWORD *)(a1 + 88);
    if (v37 < 0)
    {
      if ((int)(0x80000000 - v37) > v38)
      {
LABEL_27:
        (*(void (**)(char *, int *))(*(void *)v34 + 24))(v34, v36);
        return 0;
      }
    }
    else if ((v37 ^ 0x7FFFFFFF) < v38)
    {
      goto LABEL_27;
    }
    int v39 = *((_DWORD *)v34 + 4);
    int v40 = *(_DWORD *)(a1 + 92);
    if (v39 < 0)
    {
      if ((int)(0x80000000 - v39) > v40) {
        goto LABEL_27;
      }
    }
    else if ((v39 ^ 0x7FFFFFFF) < v40)
    {
      goto LABEL_27;
    }
    *((_DWORD *)v34 + 3) = v38 + v37;
    *((_DWORD *)v34 + 4) = v40 + v39;
    if (a3) {
      uint64_t v41 = (int *)(a3 + 12);
    }
    else {
      uint64_t v41 = (int *)(v34 + 12);
    }
    if (!CGSBoundsIntersection(v41, v36, &v94))
    {
LABEL_71:
      (*(void (**)(char *))(*(void *)v35 + 24))(v35);
      goto LABEL_72;
    }
    uint64_t v99 = 0;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v96 = 0u;
    long long v95 = 0u;
    if (*(float *)(a1 + 120) != 0.0 || *(float *)(a1 + 124) != 1.0) {
      RIPLayerResample((uint64_t)v35, (float *)(a1 + 120), v42, v43, v44, v45, v46, v47);
    }
    if (v20 >= 0.99609
      && !*(void *)(a5[1].i64[0] + 88)
      && (*(unsigned char *)(a1 + 13) & 0x10) == 0
      && *(int *)a8 <= 2
      && (!a3 || !*(void *)(a3 + 56)))
    {
      RIPLayerMask(v35, v23, v42, v43, v44, v45, v46, v47);
    }
    unint64_t v48 = *(void *)(a1 + 80);
    if (!v48)
    {
      if (default_shadow_color_predicate != -1) {
        dispatch_once(&default_shadow_color_predicate, &__block_literal_global_3);
      }
      unint64_t v48 = default_shadow_color_shadow_color;
    }
    Cache = CGColorTransformGetCache(*(void **)(a8 + 16));
    if (Cache)
    {
      uint64_t v51 = Cache[2];
      if (v51)
      {
        unint64_t v52 = *(void *)(*(void *)(v51 + 24) + 48);
        if (v52 >> 61)
        {
          MEMORY[0x1F4188790](Cache, v50);
          int32x4_t v89 = (double *)&v86;
          long long v92 = 0;
LABEL_58:
          uint64_t v66 = *(void *)(a8 + 16);
          long long v91 = &v87;
          unint64_t v88 = v60;
          uint64_t v90 = v66;
          if (v48)
          {
            if ((v48 & 0x8000000000000000) != 0)
            {
              CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v48, v53, v54, v55, v56, v57, v58, v59);
              uint64_t v68 = (CGColor *)v48;
              CGColorSpaceRef v69 = ColorSpace;
            }
            else
            {
              uint64_t v68 = (CGColor *)v48;
              CGColorSpaceRef v69 = *(CGColorSpaceRef *)(v48 + 24);
            }
          }
          else
          {
            uint64_t v68 = 0;
            CGColorSpaceRef v69 = 0;
          }
          uint64_t v70 = *(unsigned int *)(a8 + 8);
          Components = (double *)CGColorGetComponents(v68);
          int v72 = v69;
          uint64_t v73 = v92;
          if (CGColorTransformConvertColorComponents(v90, v72, v70, Components, v92))
          {
            RIPColorCreateWithColor(*(_DWORD *)(a8 + 24), v73, v88, 1.0);
            int v81 = v80;
          }
          else
          {
            int v81 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
            *int v81 = &ripc_class;
            v81[1] = 0;
            v81[2] = 0;
            v81[3] = 0;
            *((_DWORD *)v81 + 39) = 1065353216;
          }
          if (v73 != v89) {
            free(v73);
          }
          long long v82 = *(_OWORD *)(a8 + 48);
          long long v97 = *(_OWORD *)(a8 + 32);
          long long v98 = v82;
          uint64_t v99 = *(void *)(a8 + 64);
          long long v83 = *(_OWORD *)a8;
          long long v96 = *(_OWORD *)(a8 + 16);
          long long v95 = v83;
          *(double *)&long long v98 = (float)(v19 * v20);
          if ((*(unsigned char *)(a1 + 13) & 0x10) != 0) {
            RIPLayerDefine((uint64_t)a2, (__n128 *)&v94, v74, v75, v76, v77, v78, v79);
          }
          RIPLayerBltShape(a2, a3, v94.i32, (uint64_t)v35, (uint64_t)v81, 0, (uint64_t)&v95, v79);
          free(v81);
          goto LABEL_71;
        }
        Cache = (void *)(8 * v52);
      }
      else
      {
        Cache = 0;
      }
    }
    size_t v61 = MEMORY[0x1F4188790](Cache, v50);
    int32x4_t v89 = (double *)((char *)&v87 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v60 <= 0x1FFFFFFFFFFFFFFELL) {
      uint64_t v63 = (double *)((char *)&v87 - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0));
    }
    else {
      uint64_t v63 = 0;
    }
    long long v92 = v63;
    if (v60 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022)
    {
      long long v91 = (uint64_t *)v48;
      unint64_t v64 = v60;
      CGColorRef v65 = (double *)malloc_type_malloc(v61, 0x17B18C98uLL);
      unint64_t v60 = v64;
      unint64_t v48 = (unint64_t)v91;
      long long v92 = v65;
    }
    goto LABEL_58;
  }
LABEL_74:
  if (a4) {
    int v84 = (int *)a4;
  }
  else {
    int v84 = (int *)a5;
  }
  if (!CGSBoundsIntersection((int *)(a3 + 12), v84, v93)) {
    return 1;
  }
LABEL_78:
  if ((*(unsigned char *)(a1 + 13) & 0x10) != 0) {
    return 1;
  }
  if (a3) {
    unint64_t v85 = v93;
  }
  else {
    unint64_t v85 = (void *)a4;
  }
  return RIPLayerBltImage((uint64_t)a2, a3, (uint64_t)v85, (uint64_t)a5, a8, a6, a7, a8);
}

CGColorSpaceRef rips_s_ColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 80);
  if (!v8) {
    return (CGColorSpaceRef)rips_s_cs;
  }
  if ((v8 & 0x8000000000000000) != 0) {
    return CGTaggedColorGetColorSpace(v8, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(CGColorSpaceRef *)(v8 + 24);
}

long long *rips_s_super()
{
  return &_rips_class;
}

uint64_t __CGPDFPatternGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFPatternGetTypeID_class);
  CGPDFPatternGetTypeID_idouble d = result;
  return result;
}

void CGPDFPatternFinalize(uint64_t a1)
{
  long long v1 = *(const void **)(a1 + 144);
  if (v1) {
    CFRelease(v1);
  }
}

void path_iterator_dilator_create(double a1, double a2)
{
  uint64_t v4 = (float *)malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
  float v5 = a1;
  *uint64_t v4 = v5;
  float v6 = a2;
  v4[3] = v6;
  v4[1] = 0.0;
  v4[4] = 0.0;
  *((unsigned char *)v4 + 28) = 1;
  v4[6] = 0.0;
  operator new();
}

void path_dilator_end(uint64_t a1, void *a2)
{
  addClosepath(a1, (uint64_t)a2);
  if (a2)
  {
    long long v3 = (void (*)(uint64_t, uint64_t))a2[4];
    if (v3)
    {
      uint64_t v4 = a2[1];
      uint64_t v5 = a2[6];
      v3(v4, v5);
    }
  }
}

void addClosepath(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 28))
  {
    float v4 = addLine(a1, a2, *(float *)(a1 + 8), *(float *)(a1 + 20));
    if (a2) {
      (*(void (**)(void, uint64_t, void, void, float))(a2 + 24))(*(void *)(a2 + 8), 4, 0, *(void *)(a2 + 48), v4);
    }
    *(unsigned char *)(a1 + 28) = 1;
  }
}

float addLine(uint64_t a1, uint64_t a2, double a3, double a4)
{
  float v8 = *(float *)(a1 + 4);
  float v9 = a3 - v8;
  float v10 = *(float *)(a1 + 16);
  float v11 = a4 - v10;
  if (v11 >= 0.0)
  {
    float v12 = 0.0;
    if (v11 > 0.0) {
      float v12 = *(float *)a1;
    }
  }
  else
  {
    float v12 = -*(float *)a1;
  }
  BOOL v13 = v9 <= 0.0;
  if (v9 >= 0.0)
  {
    float v14 = *(float *)(a1 + 12);
    float v15 = 0.0;
    if (!v13) {
      float v15 = -v14;
    }
  }
  else
  {
    float v14 = *(float *)(a1 + 12);
    float v15 = v14;
  }
  double v16 = (float)((float)(v8 + v12) + *(float *)(a1 + 24));
  double v17 = (float)((float)(v10 + v15) + v14);
  if (*(unsigned char *)(a1 + 28))
  {
    double v21 = v16;
    double v22 = v17;
    if (a2) {
      (*(void (**)(void, void, double *, void))(a2 + 24))(*(void *)(a2 + 8), 0, &v21, *(void *)(a2 + 48));
    }
    *(unsigned char *)(a1 + 28) = 0;
  }
  else
  {
    double v21 = v16;
    double v22 = v17;
    if (a2) {
      (*(void (**)(void, uint64_t, double *, void))(a2 + 24))(*(void *)(a2 + 8), 1, &v21, *(void *)(a2 + 48));
    }
  }
  double v18 = v15 + a4 + *(float *)(a1 + 12);
  double v21 = v12 + a3 + *(float *)(a1 + 24);
  double v22 = v18;
  if (a2) {
    (*(void (**)(void, uint64_t, double *, void))(a2 + 24))(*(void *)(a2 + 8), 1, &v21, *(void *)(a2 + 48));
  }
  float v19 = a3;
  *(float *)(a1 + 4) = v19;
  float result = a4;
  *(float *)(a1 + 16) = result;
  return result;
}

void path_dilator_iterate(uint64_t a1, int a2, double *a3, uint64_t a4)
{
  switch(a2)
  {
    case 0:
      double v6 = *a3;
      double v5 = a3[1];
      if (!*(unsigned char *)(a1 + 28)) {
        addClosepath(a1, a4);
      }
      float v7 = v6;
      float v8 = v5;
      *(float *)(a1 + 4) = v7;
      *(float *)(a1 + 8) = v7;
      *(float *)(a1 + 16) = v8;
      *(float *)(a1 + 20) = v8;
      return;
    case 1:
      double v9 = *a3;
      double v10 = a3[1];
      addLine(a1, a4, v9, v10);
      return;
    case 2:
      float v11 = (*a3 + *a3) / 3.0;
      double v12 = a3[2];
      double v13 = a3[3];
      double v14 = v12 / 3.0 + v11;
      float v15 = (a3[1] + a3[1]) / 3.0;
      double v16 = (float)((float)(*(float *)(a1 + 4) / 3.0) + v11);
      double v17 = (float)((float)(*(float *)(a1 + 16) / 3.0) + v15);
      double v18 = v13 / 3.0 + v15;
      goto LABEL_10;
    case 3:
      double v16 = *a3;
      double v17 = a3[1];
      double v14 = a3[2];
      double v18 = a3[3];
      double v12 = a3[4];
      double v13 = a3[5];
LABEL_10:
      addCube(a1, a4, v16, v17, v14, v18, v12, v13);
      break;
    case 4:
      addClosepath(a1, a4);
      break;
    default:
      abort();
  }
}

uint64_t addCube(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v11 = a1;
  double v12 = *(float *)(a1 + 4);
  double v13 = (a3 - a5) * a3 + a5 * (a5 - v12) + a7 * (v12 - a3);
  if (v13 >= 0.0)
  {
    double v14 = *(float *)(a1 + 16);
    double v15 = a7 - v12 + (a3 - a5) * 3.0;
    double v16 = v12 + a5 + a3 * -2.0;
    if (v15 == 0.0)
    {
      if (v16 == 0.0) {
        goto LABEL_22;
      }
      double v17 = 2.0;
      double v18 = (v12 - a3) * 0.5 / v16;
    }
    else if (v16 != 0.0 || (v17 = 0.0, double v18 = 0.0, v13 != 0.0))
    {
      double v19 = 1.0;
      if (v16 < 0.0) {
        double v19 = -1.0;
      }
      double v20 = -(v16 + v19 * sqrt(v13));
      double v21 = v20 / v15;
      double v22 = (a4 - v14) / v20;
      if (v21 >= v22) {
        double v18 = v22;
      }
      else {
        double v18 = v21;
      }
      if (v21 <= v22) {
        double v17 = v22;
      }
      else {
        double v17 = v21;
      }
    }
    double v23 = 2.0;
    if (v18 < 1.0e-10)
    {
      double v24 = v17;
    }
    else
    {
      double v23 = v17;
      double v24 = v18;
    }
    if (v24 >= 1.0e-10 && v24 <= 1.0)
    {
      if (1.0 - v23 >= 1.0e-10)
      {
        double v40 = (v23 - v24) / (1.0 - v24);
        double v41 = v12 + a3 * -2.0 + a5;
        double v42 = v14 + a4 * -2.0 + a6;
        double v43 = v12 + (v24 * ((a7 + (a5 - a3) * -3.0 - v12) * v24 + v41 * 3.0) + (a3 - v12) * 3.0) * v24;
        double v44 = v14 + (v24 * ((a8 + (a6 - a4) * -3.0 - v14) * v24 + v42 * 3.0) + (a4 - v14) * 3.0) * v24;
        double v51 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v24) + (a7 - a5) * -2.0) * (1.0 - v24);
        double v45 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v24) + (a8 - a6) * -2.0) * (1.0 - v24);
        double v46 = a7 - (a7 - a5) * (1.0 - v24);
        double v47 = a8 - (a8 - a6) * (1.0 - v24);
        addCubeMonotonicX(a1, a2, v12 + (a3 - v12) * v24, v14 + (a4 - v14) * v24, v12 + (v41 * v24 + (a3 - v12) * 2.0) * v24, v14 + (v42 * v24 + (a4 - v14) * 2.0) * v24, v43, v44);
        double v48 = a8 - v47;
        double v35 = v43 + (v51 - v43) * v40;
        double v36 = v44 + (v45 - v44) * v40;
        double v49 = v46 + v43 + v51 * -2.0;
        double v37 = v43 + (v40 * v49 + (v51 - v43) * 2.0) * v40;
        double v50 = v47 + v44 + v45 * -2.0;
        double v38 = v44 + (v40 * v50 + (v45 - v44) * 2.0) * v40;
        double v29 = v43 + (v40 * (v40 * (a7 + (v46 - v51) * -3.0 - v43) + v49 * 3.0) + (v51 - v43) * 3.0) * v40;
        double v30 = v44 + (v40 * (v40 * (a8 + (v47 - v45) * -3.0 - v44) + v50 * 3.0) + (v45 - v44) * 3.0) * v40;
        double v31 = a7 + ((1.0 - v40) * (a7 + v46 * -2.0 + v51) + (a7 - v46) * -2.0) * (1.0 - v40);
        double v32 = a8 + ((1.0 - v40) * (a8 + v47 * -2.0 + v45) + (a8 - v47) * -2.0) * (1.0 - v40);
        double v33 = a7 - (a7 - v46) * (1.0 - v40);
        double v34 = a8 - v48 * (1.0 - v40);
        a1 = v11;
      }
      else
      {
        double v25 = v12 + a3 * -2.0 + a5;
        double v26 = v12 + (v25 * v24 + (a3 - v12) * 2.0) * v24;
        double v27 = v14 + a4 * -2.0 + a6;
        double v28 = v14 + (v27 * v24 + (a4 - v14) * 2.0) * v24;
        double v29 = v12 + (v24 * ((a7 + (a5 - a3) * -3.0 - v12) * v24 + v25 * 3.0) + (a3 - v12) * 3.0) * v24;
        double v30 = v14 + (v24 * ((a8 + (a6 - a4) * -3.0 - v14) * v24 + v27 * 3.0) + (a4 - v14) * 3.0) * v24;
        double v31 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v24) + (a7 - a5) * -2.0) * (1.0 - v24);
        double v32 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v24) + (a8 - a6) * -2.0) * (1.0 - v24);
        double v33 = a7 - (a7 - a5) * (1.0 - v24);
        double v34 = a8 - (a8 - a6) * (1.0 - v24);
        double v35 = v12 + (a3 - v12) * v24;
        double v36 = v14 + (a4 - v14) * v24;
        double v37 = v26;
        double v38 = v28;
      }
      addCubeMonotonicX(a1, a2, v35, v36, v37, v38, v29, v30);
      a1 = v11;
      a3 = v31;
      a4 = v32;
      a5 = v33;
      a6 = v34;
    }
  }
LABEL_22:

  return addCubeMonotonicX(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t addCubeMonotonicX(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v11 = a1;
  double v12 = *(float *)(a1 + 16);
  double v13 = (a4 - a6) * a4 + a6 * (a6 - v12) + a8 * (v12 - a4);
  if (v13 >= 0.0)
  {
    double v14 = a8 - v12 + (a4 - a6) * 3.0;
    double v15 = v12 + a6 + a4 * -2.0;
    if (v14 == 0.0)
    {
      if (v15 == 0.0) {
        goto LABEL_22;
      }
      double v16 = 2.0;
      double v17 = (v12 - a4) * 0.5 / v15;
    }
    else if (v15 != 0.0 || (v16 = 0.0, double v17 = 0.0, v13 != 0.0))
    {
      double v18 = 1.0;
      if (v15 < 0.0) {
        double v18 = -1.0;
      }
      double v19 = -(v15 + v18 * sqrt(v13));
      double v20 = v19 / v14;
      double v21 = (a4 - v12) / v19;
      if (v20 >= v21) {
        double v17 = v21;
      }
      else {
        double v17 = v20;
      }
      if (v20 <= v21) {
        double v16 = v21;
      }
      else {
        double v16 = v20;
      }
    }
    double v22 = 2.0;
    if (v17 < 1.0e-10)
    {
      double v23 = v16;
    }
    else
    {
      double v22 = v16;
      double v23 = v17;
    }
    if (v23 >= 1.0e-10 && v23 <= 1.0)
    {
      double v24 = *(float *)(a1 + 4);
      if (1.0 - v22 >= 1.0e-10)
      {
        double v40 = (v22 - v23) / (1.0 - v23);
        double v41 = v24 + a3 * -2.0 + a5;
        double v42 = v12 + a4 * -2.0 + a6;
        double v43 = v24 + (v23 * ((a7 + (a5 - a3) * -3.0 - v24) * v23 + v41 * 3.0) + (a3 - v24) * 3.0) * v23;
        double v44 = v12 + (v23 * ((a8 + (a6 - a4) * -3.0 - v12) * v23 + v42 * 3.0) + (a4 - v12) * 3.0) * v23;
        double v51 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v23) + (a7 - a5) * -2.0) * (1.0 - v23);
        double v45 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v23) + (a8 - a6) * -2.0) * (1.0 - v23);
        double v46 = a7 - (a7 - a5) * (1.0 - v23);
        double v47 = a8 - (a8 - a6) * (1.0 - v23);
        addCubeMonotonic(a1, a2, v24 + (a3 - v24) * v23, v12 + (a4 - v12) * v23, v24 + (v41 * v23 + (a3 - v24) * 2.0) * v23, v12 + (v42 * v23 + (a4 - v12) * 2.0) * v23, v43, v44);
        double v48 = a8 - v47;
        double v35 = v43 + (v51 - v43) * v40;
        double v36 = v44 + (v45 - v44) * v40;
        double v49 = v46 + v43 + v51 * -2.0;
        double v37 = v43 + (v40 * v49 + (v51 - v43) * 2.0) * v40;
        double v50 = v47 + v44 + v45 * -2.0;
        double v38 = v44 + (v40 * v50 + (v45 - v44) * 2.0) * v40;
        double v29 = v43 + (v40 * (v40 * (a7 + (v46 - v51) * -3.0 - v43) + v49 * 3.0) + (v51 - v43) * 3.0) * v40;
        double v30 = v44 + (v40 * (v40 * (a8 + (v47 - v45) * -3.0 - v44) + v50 * 3.0) + (v45 - v44) * 3.0) * v40;
        double v31 = a7 + ((1.0 - v40) * (a7 + v46 * -2.0 + v51) + (a7 - v46) * -2.0) * (1.0 - v40);
        double v32 = a8 + ((1.0 - v40) * (a8 + v47 * -2.0 + v45) + (a8 - v47) * -2.0) * (1.0 - v40);
        double v33 = a7 - (a7 - v46) * (1.0 - v40);
        double v34 = a8 - v48 * (1.0 - v40);
        a1 = v11;
      }
      else
      {
        double v25 = v24 + a3 * -2.0 + a5;
        double v26 = v24 + (v25 * v23 + (a3 - v24) * 2.0) * v23;
        double v27 = v12 + a4 * -2.0 + a6;
        double v28 = v12 + (v27 * v23 + (a4 - v12) * 2.0) * v23;
        double v29 = v24 + (v23 * ((a7 + (a5 - a3) * -3.0 - v24) * v23 + v25 * 3.0) + (a3 - v24) * 3.0) * v23;
        double v30 = v12 + (v23 * ((a8 + (a6 - a4) * -3.0 - v12) * v23 + v27 * 3.0) + (a4 - v12) * 3.0) * v23;
        double v31 = a7 + ((a7 + a5 * -2.0 + a3) * (1.0 - v23) + (a7 - a5) * -2.0) * (1.0 - v23);
        double v32 = a8 + ((a8 + a6 * -2.0 + a4) * (1.0 - v23) + (a8 - a6) * -2.0) * (1.0 - v23);
        double v33 = a7 - (a7 - a5) * (1.0 - v23);
        double v34 = a8 - (a8 - a6) * (1.0 - v23);
        double v35 = v24 + (a3 - v24) * v23;
        double v36 = v12 + (a4 - v12) * v23;
        double v37 = v26;
        double v38 = v28;
      }
      addCubeMonotonic(a1, a2, v35, v36, v37, v38, v29, v30);
      a1 = v11;
      a3 = v31;
      a4 = v32;
      a5 = v33;
      a6 = v34;
    }
  }
LABEL_22:

  return addCubeMonotonic(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t addCubeMonotonic(uint64_t result, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t v15 = result;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  float v16 = *(float *)(result + 4);
  float v17 = a7 - v16;
  float v18 = *(float *)(result + 16);
  float v19 = a8 - v18;
  if (v19 >= 0.0)
  {
    float v20 = 0.0;
    if (v19 > 0.0) {
      float v20 = *(float *)result;
    }
  }
  else
  {
    float v20 = -*(float *)result;
  }
  BOOL v21 = v17 <= 0.0;
  if (v17 >= 0.0)
  {
    float v22 = *(float *)(result + 12);
    float v23 = 0.0;
    if (!v21) {
      float v23 = -v22;
    }
  }
  else
  {
    float v22 = *(float *)(result + 12);
    float v23 = v22;
  }
  double v24 = (float)((float)(v16 + v20) + *(float *)(result + 24));
  double v25 = (float)((float)(v18 + v23) + v22);
  if (*(unsigned char *)(result + 28))
  {
    double v30 = v24;
    double v31 = v25;
    if (a2) {
      float result = (*(uint64_t (**)(void, void, double *, void))(a2 + 24))(*(void *)(a2 + 8), 0, &v30, *(void *)(a2 + 48));
    }
    *(unsigned char *)(v15 + 28) = 0;
  }
  else
  {
    double v30 = v24;
    double v31 = v25;
    if (a2) {
      float result = (*(uint64_t (**)(void, uint64_t, double *, void))(a2 + 24))(*(void *)(a2 + 8), 1, &v30, *(void *)(a2 + 48));
    }
  }
  if (a2)
  {
    double v26 = *(float *)(v15 + 12);
    double v27 = *(float *)(v15 + 24);
    double v30 = v20 + a3 + v27;
    double v31 = v23 + a4 + v26;
    double v32 = v20 + a5 + v27;
    double v33 = v23 + a6 + v26;
    double v34 = v20 + a7 + v27;
    double v35 = v23 + a8 + v26;
    float result = (*(uint64_t (**)(void, uint64_t, double *, void))(a2 + 24))(*(void *)(a2 + 8), 3, &v30, *(void *)(a2 + 48));
  }
  float v28 = a7;
  *(float *)(v15 + 4) = v28;
  float v29 = a8;
  *(float *)(v15 + 16) = v29;
  return result;
}

uint64_t path_dilator_begin(uint64_t result, uint64_t a2, void *a3)
{
  *(unsigned char *)(result + 28) = 1;
  if (a3)
  {
    long long v3 = (uint64_t (*)(void, uint64_t, void))a3[2];
    if (v3) {
      return v3(a3[1], a2, a3[6]);
    }
  }
  return result;
}

void path_iterator_orientation_create()
{
  float v0 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
  long long v1 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
  *long long v1 = 0;
  v1[1] = 0;
  v1[2] = v1 + 64;
  v1[3] = ((unint64_t)v1 + 55) & 0xFFFFFFFFFFFFFFF8;
  v1[4] = 0;
  v1[5] = 464;
  *(void *)float v0 = v1;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  v0[48] = 1;
  operator new();
}

void path_orientation_release_info(void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    path_free(v2);
  }

  free(a1);
}

void path_orientation_end(uint64_t a1, void *a2)
{
  if (!*(unsigned char *)(a1 + 48)) {
    *(double *)(a1 + 40) = *(double *)(a1 + 40)
  }
                         + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                         * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                         * 0.5;
  if (*(void *)a1)
  {
    if (*(double *)(a1 + 40) > 0.0)
    {
      float v4 = malloc_type_malloc(0x20uLL, 0x2062DE7BuLL);
      double v5 = malloc_type_malloc(0x200uLL, 0x95C2046AuLL);
      *double v5 = 0;
      v5[1] = 0;
      v5[2] = v5 + 64;
      v5[3] = ((unint64_t)v5 + 55) & 0xFFFFFFFFFFFFFFF8;
      v5[4] = 0;
      void v5[5] = 464;
      v4[3] = v5;
      operator new();
    }
    path_iterator_iterate(a2, *(void *)a1);
    path_free(*(void **)a1);
    *(void *)a1 = 0;
  }
  if (a2)
  {
    double v6 = (void (*)(uint64_t, uint64_t))a2[4];
    if (v6)
    {
      uint64_t v7 = a2[1];
      uint64_t v8 = a2[6];
      v6(v7, v8);
    }
  }
}

_OWORD *path_orientation_iterate(uint64_t a1, int a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 0:
      if (!*(unsigned char *)(a1 + 48)) {
        *(double *)(a1 + 40) = *(double *)(a1 + 40)
      }
                             + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                             * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                             * 0.5;
      *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)a3;
      *(unsigned char *)(a1 + 48) = 1;
      unsigned int v10 = 0;
      goto LABEL_6;
    case 1:
      *(double *)(a1 + 40) = *(double *)(a1 + 40) + (*a3 - *(double *)(a1 + 24)) * (*(double *)(a1 + 32) + a3[1]) * 0.5;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)a3;
      *(unsigned char *)(a1 + 48) = 0;
      unsigned int v10 = 1;
LABEL_6:
      float result = (_OWORD *)path_add((unsigned __int8 **)a1, v10, (uint64_t)a3, a4, a5, a6, a7, a8);
      *float result = *(_OWORD *)a3;
      break;
    case 2:
      orientation_cubic_segment(a1, *(double *)(a1 + 24), *(double *)(a1 + 32), (*(double *)(a1 + 24) + *a3 * 2.0) / 3.0, (*(double *)(a1 + 32) + a3[1] * 2.0) / 3.0, (a3[2] + *a3 * 2.0) / 3.0, (a3[3] + a3[1] * 2.0) / 3.0, a3[2], a3[3]);
      *(_OWORD *)(a1 + 24) = *((_OWORD *)a3 + 1);
      *(unsigned char *)(a1 + 48) = 0;
      float result = (_OWORD *)path_add((unsigned __int8 **)a1, 2u, v12, v13, v14, v15, v16, v17);
      *float result = *(_OWORD *)a3;
      result[1] = *((_OWORD *)a3 + 1);
      break;
    case 3:
      orientation_cubic_segment(a1, *(double *)(a1 + 24), *(double *)(a1 + 32), *a3, a3[1], a3[2], a3[3], a3[4], a3[5]);
      *(_OWORD *)(a1 + 24) = *((_OWORD *)a3 + 2);
      *(unsigned char *)(a1 + 48) = 0;
      float result = (_OWORD *)path_add((unsigned __int8 **)a1, 3u, v18, v19, v20, v21, v22, v23);
      *float result = *(_OWORD *)a3;
      result[1] = *((_OWORD *)a3 + 1);
      result[2] = *((_OWORD *)a3 + 2);
      break;
    case 4:
      *(double *)(a1 + 40) = *(double *)(a1 + 40)
                           + (*(double *)(a1 + 8) - *(double *)(a1 + 24))
                           * (*(double *)(a1 + 32) + *(double *)(a1 + 16))
                           * 0.5;
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a1 + 8);
      *(unsigned char *)(a1 + 48) = 1;
      float result = (_OWORD *)path_add((unsigned __int8 **)a1, 4u, (uint64_t)a3, a4, a5, a6, a7, a8);
      break;
    default:
      abort();
  }
  return result;
}

double orientation_cubic_segment(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if (a2 == a4 && a3 == a5)
  {
    BOOL v14 = a2 == a6 && a3 == a7;
    if (v14 || a6 == a8 && a7 == a9) {
      *(double *)(a1 + 40) = (a8 - a2) * (a3 + a9) * 0.5 + *(double *)(a1 + 40);
    }
    goto LABEL_24;
  }
  if (a4 != a8 || a5 != a9 || a6 != a8 || a7 != a9)
  {
LABEL_24:
    double v13 = (a8 * (a3 + a7 * 6.0 + a9 * 10.0 + a5 * 3.0)
         - a2 * (a9 + a5 * 6.0 + a3 * 10.0 + a7 * 3.0)
         + a4 * 3.0 * (-(a7 - a3 * 2.0) - a9)
         + a6 * -3.0 * (-(a5 - a9 * 2.0) - a3))
        / 20.0;
    goto LABEL_25;
  }
  double v13 = (a8 - a2) * (a3 + a9) * 0.5;
LABEL_25:
  double result = v13 + *(double *)(a1 + 40);
  *(double *)(a1 + 40) = result;
  return result;
}

uint64_t path_orientation_begin(uint64_t result, uint64_t a2, void *a3)
{
  *(void *)(result + 40) = 0;
  *(unsigned char *)(result + 48) = 1;
  if (a3)
  {
    long long v3 = (uint64_t (*)(void, uint64_t, void))a3[2];
    if (v3) {
      return v3(a3[1], a2, a3[6]);
    }
  }
  return result;
}

double *CGDashCreate(const void *a1, uint64_t a2, double a3)
{
  long long v3 = 0;
  if (a1 && a2)
  {
    long long v3 = (double *)malloc_type_calloc(1uLL, 8 * a2 + 24, 0x64A29F66uLL);
    *(_DWORD *)long long v3 = 1;
    v3[1] = a3;
    *((void *)v3 + 2) = a2;
    memcpy(v3 + 3, a1, 8 * a2);
  }
  return v3;
}

atomic_uint *CGDashRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void CGDashRelease(void *a1)
{
  if (a1)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(a1);
    }
  }
}

uint64_t CGDashGetPattern(uint64_t a1, void *a2, void *a3)
{
  if (a2)
  {
    if (a1) {
      uint64_t v3 = *(void *)(a1 + 8);
    }
    else {
      uint64_t v3 = 0;
    }
    *a2 = v3;
  }
  if (a3)
  {
    if (a1) {
      uint64_t v4 = *(void *)(a1 + 16);
    }
    else {
      uint64_t v4 = 0;
    }
    *a3 = v4;
  }
  if (a1) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void CMYKf16_sample_CMYK32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_CMYK32", 15965, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_cmyk32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_cmyk32", 15969, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYK64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_CMYK64", 15973, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_cmyk64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_cmyk64", 15977, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_WF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_WF", 15981, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_Wf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_Wf", 15984, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_RGBF", 15988, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_RGBf", 15991, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBAF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_RGBAF", 15995, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_RGBAf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_RGBAf", 15999, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYKF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_CMYKF", 16003, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

void CMYKf16_sample_CMYKf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CGHandleAssert("CMYKf16_sample_CMYKf", 16007, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "", "Unimplemented", a6, a7, a8, vars0);
}

_DWORD *CMYKf16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  double v9 = *(float **)(*(void *)a1 + 64);
  _S10 = *v9;
  float v10 = v9[1];
  if (a2 && a3 > 9 || (a2 = malloc_type_malloc(0x3AuLL, 0x705560E0uLL)) != 0)
  {
    if (_S10 <= a6) {
      _S0 = a6;
    }
    else {
      _S0 = _S10;
    }
    if (v10 < a6) {
      _S0 = v10;
    }
    if (a5) {
      int v13 = a4;
    }
    else {
      int v13 = 0;
    }
    if (v13 == 1)
    {
      _S1 = _S0 * (float)(v10 - *a5);
      _S2 = _S10;
      _S3 = _S10;
    }
    else if (v13 == 4)
    {
      _S10 = _S0 * *a5;
      _S2 = _S0 * a5[1];
      _S3 = _S0 * a5[2];
      _S1 = _S0 * a5[3];
    }
    else
    {
      _S2 = _S10;
      _S3 = _S10;
      _S1 = _S10;
      if (v13 == 3)
      {
        float v17 = _S0 * (float)(v10 - *a5);
        float v18 = _S0 * (float)(v10 - a5[1]);
        float v19 = _S0 * (float)(v10 - a5[2]);
        if (v17 >= v18) {
          _S1 = _S0 * (float)(v10 - a5[1]);
        }
        else {
          _S1 = _S0 * (float)(v10 - *a5);
        }
        if (v19 < _S1) {
          _S1 = _S0 * (float)(v10 - a5[2]);
        }
        _S10 = v17 - _S1;
        _S2 = v18 - _S1;
        _S3 = v19 - _S1;
      }
    }
    *(_OWORD *)a2 = xmmword_1850CDC20;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    __asm { FCVT            H4, S10 }
    *((_WORD *)a2 + 24) = _H4;
    __asm { FCVT            H0, S0 }
    *((_WORD *)a2 + 28) = _H0;
    double v26 = (char *)(a2 + 14);
    if (!_NF) {
      double v26 = 0;
    }
    *((void *)a2 + 4) = a2 + 12;
    *((void *)a2 + 5) = v26;
    __asm { FCVT            H0, S2 }
    *((_WORD *)a2 + 25) = _H0;
    __asm { FCVT            H0, S3 }
    *((_WORD *)a2 + 26) = _H0;
    __asm { FCVT            H0, S1 }
    *((_WORD *)a2 + 27) = _H0;
  }
  return a2;
}

uint64_t CMYKf16_mark(uint64_t a1, __n128 a2)
{
  return CMYKf16_mark_inner(*(void *)(*(void *)a1 + 56), a2);
}

uint64_t CMYKf16_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v5 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v865 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = *(char **)(v6 + 96);
  uint64_t v22 = *(void *)(v6 + 48);
  uint64_t v23 = *(unsigned int *)(v5 + 16 * *(_DWORD *)v6 + 8 * (v21 == 0) + 4 * (v22 == 0));
  if ((int)v23 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v25 = v6;
  unint64_t v26 = *(unsigned int *)(v6 + 4);
  unsigned int v27 = v26 - 1;
  if ((int)v26 < 1) {
    return 0;
  }
  int v28 = *(_DWORD *)(v6 + 8);
  uint64_t v29 = (v28 - 1);
  if (v28 < 1) {
    return 0;
  }
  double v30 = *(uint16x4_t **)(v6 + 136);
  unint64_t v806 = v6;
  if ((*(_DWORD *)v6 & 0xFF0000) == 0x50000 || !v30)
  {
    int v32 = *(_DWORD *)v6 & 0xFF00;
    int v809 = *(_DWORD *)(v5 + 16 * *(_DWORD *)v6 + 8 * (v21 == 0) + 4 * (v22 == 0));
    if (v32 == 1024)
    {
      v864[0] = *(_DWORD *)(v6 + 4);
      v854[0] = v28;
      if (v21) {
        _Q5.i16[0] = *(_WORD *)v21;
      }
      else {
        _Q5.i16[0] = COERCE_UNSIGNED_INT(1.0);
      }
      __asm { FCVT            S17, H5 }
      unint64_t v50 = (unint64_t)*(int *)(v6 + 28) >> 3;
      uint64_t v52 = *(int *)(v6 + 12);
      uint64_t v51 = *(int *)(v6 + 16);
      if (v22)
      {
        unint64_t v53 = (unint64_t)*(int *)(v6 + 32) >> 1;
        uint64_t v844 = v22 + 2 * (v52 + v53 * v51);
        unsigned int v840 = 1;
      }
      else
      {
        uint64_t v844 = 0;
        unint64_t v53 = 0;
        unsigned int v840 = 0;
      }
      double v58 = **(double **)(v6 + 88);
      _Q0.n128_f32[0] = 1.0 - *(float *)_D17.i32;
      int32x2_t v834 = (int32x2_t)_Q0.n128_u64[0];
      uint64_t v59 = *(void *)(v6 + 40) + 8 * (v52 + v51 * v50);
      float32x4_t v847 = _Q5;
      double v849 = v58;
      int32x2_t v851 = _D17;
      unint64_t v837 = v53;
      unint64_t v838 = (unint64_t)*(int *)(v6 + 28) >> 3;
      uint64_t v842 = v59;
      if (v30)
      {
        shape_enum_clip_alloc(v5, v6, (int *)v30, 1, 1, 1, *(_DWORD *)(v6 + 104), *(_DWORD *)(v6 + 108), v26, v28);
        double v44 = v60;
        uint64_t v61 = v844;
        unint64_t v62 = v53;
        if (v60) {
          goto LABEL_1278;
        }
        return 1;
      }
      double v44 = 0;
      if (v22) {
        unint64_t v63 = v26;
      }
      else {
        unint64_t v63 = 0;
      }
      unint64_t v64 = v26;
      unint64_t v62 = v53 - v63;
      uint64_t v61 = v844;
      CGColorRef v65 = (float16x4_t *)v59;
      int v66 = v64;
      unint64_t v67 = v64;
LABEL_936:
      uint64_t v59 = v50 - v67;
      switch((int)v23)
      {
        case 0:
          uint64_t v597 = v59 + v66;
          int v598 = v854[0];
          uint64_t v599 = v854[0] - 1;
          int8x16_t v600 = (char *)&v65[(v597 * v599) & (v597 >> 63)];
          if (v597 < 0) {
            uint64_t v597 = -v597;
          }
          CGBlt_fillBytes(8 * v66, v854[0], 0, v600, 8 * v597);
          if (!v22) {
            goto LABEL_1255;
          }
          uint64_t v601 = v62 + v66;
          v61 += 2 * ((v601 * v599) & (v601 >> 63));
          if (v601 >= 0) {
            v62 += v66;
          }
          else {
            unint64_t v62 = -v601;
          }
          int v602 = 2 * v66;
          int v603 = 2 * v62;
          unsigned int v604 = v598;
          int v605 = 0;
          goto LABEL_1254;
        case 1:
          uint64_t v606 = v59 + v66;
          if (v606 < 0)
          {
            v65 += v606 * (v854[0] - 1);
            uint64_t v606 = -v606;
          }
          uint64_t v607 = *(void *)(v806 + 88);
          int v608 = v854[0];
          if (v607) {
            CGSFillDRAM64((unint64_t)v65, 8 * v606, 8 * v66, v854[0], v607, 8, 8, 1, 0, 0);
          }
          else {
            CGBlt_fillBytes(8 * v66, v854[0], 0, (char *)v65, 8 * v606);
          }
          if (v22)
          {
            unint64_t v789 = *(int **)(v806 + 96);
            if (!v789) {
              unint64_t v789 = (int *)&_CMYK_float_alpha;
            }
            v61 += 2 * (((v62 + v66) * (v608 - 1)) & ((uint64_t)(v62 + v66) >> 63));
            if ((uint64_t)(v62 + v66) >= 0) {
              v62 += v66;
            }
            else {
              unint64_t v62 = -(uint64_t)(v62 + v66);
            }
            int v605 = *v789;
            int v602 = 2 * v66;
            int v603 = 2 * v62;
            unsigned int v604 = v608;
LABEL_1254:
            CGBlt_fillBytes(v602, v604, v605, (char *)v61, v603);
          }
LABEL_1255:
          LODWORD(v23) = v809;
          goto LABEL_1275;
        case 2:
          int v609 = v854[0];
          unsigned int v610 = v66 >> 2;
          float32x4_t v611 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          if (v22)
          {
            float32x4_t v612 = (float32x4_t)vdupq_lane_s32(v834, 0);
            unsigned int v613 = v610 + 1;
            do
            {
              int v614 = v66;
              if (v66 >= 4)
              {
                unsigned int v615 = v613;
                do
                {
                  *CGColorRef v65 = vcvt_f16_f32(vmlaq_f32(v611, v612, vcvtq_f32_f16(*v65)));
                  _H2 = *(_WORD *)v61;
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v834.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)uint64_t v61 = LOWORD(_S2);
                  v65[1] = vcvt_f16_f32(vmlaq_f32(v611, v612, vcvtq_f32_f16(v65[1])));
                  LOWORD(_S2) = *(_WORD *)(v61 + 2);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v834.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v61 + 2) = LOWORD(_S2);
                  v65[2] = vcvt_f16_f32(vmlaq_f32(v611, v612, vcvtq_f32_f16(v65[2])));
                  LOWORD(_S2) = *(_WORD *)(v61 + 4);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v834.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v61 + 4) = LOWORD(_S2);
                  v65[3] = vcvt_f16_f32(vmlaq_f32(v611, v612, vcvtq_f32_f16(v65[3])));
                  LOWORD(_S2) = *(_WORD *)(v61 + 6);
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v834.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)(v61 + 6) = LOWORD(_S2);
                  v65 += 4;
                  --v615;
                  v61 += 8 * v840;
                }
                while (v615 > 1);
                int v614 = v66 & 3;
              }
              if (v614 >= 1)
              {
                unsigned int v625 = v614 + 1;
                do
                {
                  *CGColorRef v65 = vcvt_f16_f32(vmlaq_f32(v611, v612, vcvtq_f32_f16(*v65)));
                  ++v65;
                  _H2 = *(_WORD *)v61;
                  __asm { FCVT            S2, H2 }
                  _S2 = *(float *)_D17.i32 + (float)(_S2 * *(float *)v834.i32);
                  __asm { FCVT            H2, S2 }
                  *(_WORD *)uint64_t v61 = LOWORD(_S2);
                  v61 += 2 * v840;
                  --v625;
                }
                while (v625 > 1);
              }
              v65 += v59;
              v61 += 2 * v62;
              --v609;
            }
            while (v609);
          }
          else
          {
            float32x4_t v790 = (float32x4_t)vdupq_lane_s32(v834, 0);
            unsigned int v791 = v610 + 1;
            do
            {
              int v792 = v66;
              if (v66 >= 4)
              {
                unsigned int v793 = v791;
                do
                {
                  float16x8_t v794 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v611, v790, vcvtq_f32_f16(v65[2]))), vmlaq_f32(v611, v790, vcvt_hight_f32_f16(*(float16x8_t *)v65[2].i8)));
                  *(float16x8_t *)v65->unint64_t i8 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v611, v790, vcvtq_f32_f16(*v65))), vmlaq_f32(v611, v790, vcvt_hight_f32_f16(*(float16x8_t *)v65->i8)));
                  *(float16x8_t *)v65[2].unint64_t i8 = v794;
                  v65 += 4;
                  --v793;
                  v61 += 8 * v840;
                }
                while (v793 > 1);
                int v792 = v66 & 3;
              }
              if (v792 >= 1)
              {
                unsigned int v795 = v792 + 1;
                do
                {
                  *CGColorRef v65 = vcvt_f16_f32(vmlaq_f32(v611, v790, vcvtq_f32_f16(*v65)));
                  ++v65;
                  v61 += 2 * v840;
                  --v795;
                }
                while (v795 > 1);
              }
              v65 += v59;
              v61 += 2 * v62;
              --v609;
            }
            while (v609);
          }
          goto LABEL_1274;
        case 3:
          int v629 = v854[0];
          do
          {
            int v630 = v66;
            do
            {
              __asm { FCMP            H1, #0 }
              if (!_ZF & _CF)
              {
                if (_H1 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  *(double *)CGColorRef v65 = v58;
                  short float v632 = *(short float *)_Q5.i16;
                }
                else
                {
                  *CGColorRef v65 = vmul_n_f16(*(float16x4_t *)&v58, _H1);
                  short float v632 = *(short float *)_Q5.i16 * _H1;
                }
              }
              else
              {
                *CGColorRef v65 = 0;
                LOWORD(v632) = 0;
              }
              *(short float *)uint64_t v61 = v632;
              ++v65;
              v61 += 2 * v840;
              --v630;
            }
            while (v630);
            v65 += v59;
            v61 += 2 * v62;
            --v629;
          }
          while (v629);
          goto LABEL_1274;
        case 4:
          float32x4_t v633 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          int v634 = v854[0];
          do
          {
            int v635 = v66;
            do
            {
              _H2 = *(_WORD *)v61;
              __asm { FCVT            S2, H2 }
              float v638 = 1.0 - _S2;
              if (v638 <= 0.0)
              {
                *CGColorRef v65 = 0;
                _H2 = 0;
              }
              else if (v638 >= 1.0)
              {
                *(double *)CGColorRef v65 = v58;
                _H2 = _Q5.i16[0];
              }
              else
              {
                *CGColorRef v65 = vcvt_f16_f32(vmulq_n_f32(v633, v638));
                _S2 = v638 * *(float *)_D17.i32;
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)uint64_t v61 = _H2;
              ++v65;
              v61 += 2 * v840;
              --v635;
            }
            while (v635);
            v65 += v59;
            v61 += 2 * v62;
            --v634;
          }
          while (v634);
          goto LABEL_1274;
        case 5:
          float32x4_t v641 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          int v642 = v854[0];
          do
          {
            int v643 = v66;
            do
            {
              _H1 = *(_WORD *)v61;
              __asm { FCVT            S1, H1 }
              *CGColorRef v65 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), *(float *)v834.i32), v641, _S1));
              ++v65;
              _S1 = (float)(*(float *)v834.i32 * _S1) + (float)(*(float *)_D17.i32 * _S1);
              __asm { FCVT            H1, S1 }
              *(_WORD *)uint64_t v61 = LOWORD(_S1);
              v61 += 2 * v840;
              --v643;
            }
            while (v643);
            v65 += v59;
            v61 += 2 * v62;
            --v642;
          }
          while (v642);
          goto LABEL_1274;
        case 6:
          float32x4_t v647 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          int v648 = v854[0];
          while (1)
          {
            int v649 = v66;
            do
            {
              _H2 = *(_WORD *)v61;
              __asm { FCVT            S2, H2 }
              float v652 = 1.0 - _S2;
              if ((float)(1.0 - _S2) >= 1.0)
              {
                *(double *)CGColorRef v65 = v58;
                _H2 = _Q5.i16[0];
              }
              else
              {
                if (v652 <= 0.0) {
                  goto LABEL_991;
                }
                *CGColorRef v65 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v65), v647, v652));
                _S2 = _S2 + (float)(*(float *)_D17.i32 * v652);
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)uint64_t v61 = _H2;
LABEL_991:
              ++v65;
              v61 += 2 * v840;
              --v649;
            }
            while (v649);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v648)
            {
LABEL_1274:
              v854[0] = 0;
              goto LABEL_1275;
            }
          }
        case 7:
          int v655 = v854[0];
          uint64_t v656 = 2 * v840;
          if (v22)
          {
            do
            {
              int v657 = v66;
              do
              {
                *CGColorRef v65 = vmul_n_f16(*v65, *(short float *)_Q5.i16);
                ++v65;
                *(short float *)uint64_t v61 = *(short float *)_Q5.i16 * *(short float *)v61;
                v61 += v656;
                --v657;
              }
              while (v657);
              v65 += v59;
              v61 += 2 * v62;
              --v655;
            }
            while (v655);
          }
          else
          {
            do
            {
              int v658 = v66;
              do
              {
                *CGColorRef v65 = vmul_n_f16(*v65, *(short float *)_Q5.i16);
                ++v65;
                v61 += v656;
                --v658;
              }
              while (v658);
              v65 += v59;
              v61 += 2 * v62;
              --v655;
            }
            while (v655);
          }
          goto LABEL_1274;
        case 8:
          int v659 = v854[0];
          uint64_t v660 = 2 * v840;
          if (v22)
          {
            do
            {
              int v661 = v66;
              do
              {
                *CGColorRef v65 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), *(float *)v834.i32));
                ++v65;
                _H0 = *(_WORD *)v61;
                __asm { FCVT            S0, H0 }
                _S0 = *(float *)v834.i32 * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)uint64_t v61 = LOWORD(_S0);
                v61 += v660;
                --v661;
              }
              while (v661);
              v65 += v59;
              v61 += 2 * v62;
              --v659;
            }
            while (v659);
          }
          else
          {
            do
            {
              int v796 = v66;
              do
              {
                *CGColorRef v65 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), *(float *)v834.i32));
                ++v65;
                v61 += v660;
                --v796;
              }
              while (v796);
              v65 += v59;
              v61 += 2 * v62;
              --v659;
            }
            while (v659);
          }
          goto LABEL_1274;
        case 9:
          float32x4_t v665 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          int v666 = v854[0];
          do
          {
            int v667 = v66;
            do
            {
              _H2 = *(_WORD *)v61;
              __asm { FCVT            S2, H2 }
              *CGColorRef v65 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), *(float *)_D17.i32), v665, 1.0 - _S2));
              ++v65;
              _S2 = (float)(*(float *)_D17.i32 * _S2) + (float)(*(float *)_D17.i32 * (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              *(_WORD *)uint64_t v61 = LOWORD(_S2);
              v61 += 2 * v840;
              --v667;
            }
            while (v667);
            v65 += v59;
            v61 += 2 * v62;
            --v666;
          }
          while (v666);
          goto LABEL_1274;
        case 10:
          float32x4_t v671 = vcvtq_f32_f16(*(float16x4_t *)&v58);
          int v672 = v854[0];
          do
          {
            int v673 = v66;
            do
            {
              _H2 = *(_WORD *)v61;
              __asm { FCVT            S2, H2 }
              *CGColorRef v65 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), *(float *)v834.i32), v671, 1.0 - _S2));
              ++v65;
              _S2 = (float)(*(float *)v834.i32 * _S2) + (float)(*(float *)_D17.i32 * (float)(1.0 - _S2));
              __asm { FCVT            H2, S2 }
              *(_WORD *)uint64_t v61 = LOWORD(_S2);
              v61 += 2 * v840;
              --v673;
            }
            while (v673);
            v65 += v59;
            v61 += 2 * v62;
            --v672;
          }
          while (v672);
          goto LABEL_1274;
        case 11:
          float32x4_t v677 = vsubq_f32((float32x4_t)vdupq_lane_s32(_D17, 0), vcvtq_f32_f16(*(float16x4_t *)&v58));
          int v678 = v854[0];
          if (v22)
          {
            do
            {
              int v679 = v66;
              do
              {
                _H5 = *(_WORD *)v61;
                __asm { FCVT            S5, H5 }
                _S6 = *(float *)_D17.i32 + _S5;
                _H7 = v65->i16[0];
                __asm { FCVT            S7, H7 }
                float v685 = v677.f32[0] + (float)(_S5 - _S7);
                if ((float)(*(float *)_D17.i32 + _S5) > 1.0) {
                  _S6 = 1.0;
                }
                _H16 = v65->i16[1];
                __asm { FCVT            S16, H16 }
                float v688 = v677.f32[1] + (float)(_S5 - _S16);
                _S7 = _S6 - v685;
                __asm { FCVT            H7, S7 }
                v65->i16[0] = LOWORD(_S7);
                LOWORD(_S7) = *(_WORD *)v61;
                __asm { FCVT            S7, H7 }
                LOWORD(_S16) = v65->i16[2];
                __asm { FCVT            S16, H16 }
                float v692 = v677.f32[2] + (float)(_S7 - _S16);
                _S5 = _S6 - v688;
                __asm { FCVT            H5, S5 }
                v65->i16[1] = LOWORD(_S5);
                LOWORD(_S5) = *(_WORD *)v61;
                __asm { FCVT            S5, H5 }
                LOWORD(_S16) = v65->i16[3];
                __asm { FCVT            S16, H16 }
                _S7 = _S6 - v692;
                __asm { FCVT            H7, S7 }
                v65->i16[2] = LOWORD(_S7);
                __asm { FCVT            H7, S6 }
                *(_WORD *)uint64_t v61 = LOWORD(_S7);
                _S5 = _S6 - (float)(v677.f32[3] + (float)(_S5 - _S16));
                __asm { FCVT            H5, S5 }
                v65->i16[3] = LOWORD(_S5);
                ++v65;
                v61 += 2 * v840;
                --v679;
              }
              while (v679);
              v65 += v59;
              v61 += 2 * v62;
              --v678;
            }
            while (v678);
          }
          else
          {
            __asm { FMOV            V1.4S, #1.0 }
            do
            {
              int v798 = v66;
              do
              {
                *CGColorRef v65 = vcvt_f16_f32(vsubq_f32(_Q1, vaddq_f32(v677, vsubq_f32(_Q1, vcvtq_f32_f16(*v65)))));
                ++v65;
                v61 += 2 * v840;
                --v798;
              }
              while (v798);
              v65 += v59;
              v61 += 2 * v62;
              --v678;
            }
            while (v678);
          }
          goto LABEL_1274;
        case 12:
          int v698 = v854[0];
          uint64_t v699 = 2 * v840;
          if (v22)
          {
            do
            {
              int v700 = v66;
              do
              {
                _H1 = *(_WORD *)v61;
                __asm { FCVT            S1, H1 }
                _S1 = *(float *)_D17.i32 + _S1;
                if (_S1 > 1.0) {
                  _S1 = 1.0;
                }
                __asm { FCVT            H1, S1 }
                v705.i32[0] = v65->i32[0];
                *(_WORD *)uint64_t v61 = _H1;
                v705.i32[1] = v65->i32[1];
                *v65++ = vadd_f16(*(float16x4_t *)&v58, v705);
                v61 += v699;
                --v700;
              }
              while (v700);
              v65 += v59;
              v61 += 2 * v62;
              --v698;
            }
            while (v698);
          }
          else
          {
            do
            {
              int v706 = v66;
              do
              {
                *CGColorRef v65 = vadd_f16(*(float16x4_t *)&v58, *v65);
                ++v65;
                v61 += v699;
                --v706;
              }
              while (v706);
              v65 += v59;
              v61 += 2 * v62;
              --v698;
            }
            while (v698);
          }
          goto LABEL_1274;
        case 13:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 13 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v707 = WORD1(v58);
          int v708 = HIDWORD(v58);
          int v709 = v854[0];
          while (1)
          {
            int v710 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1047;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAmultiplyPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v707, v708,
                     SHIWORD(v708),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1047:
              ++v65;
              v61 += 2 * v840;
              --v710;
            }
            while (v710);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v709) {
              goto LABEL_1245;
            }
          }
        case 14:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 14 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v713 = WORD1(v58);
          int v714 = HIDWORD(v58);
          int v715 = v854[0];
          while (1)
          {
            int v716 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1061;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAscreenPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v713, v714,
                     SHIWORD(v714),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1061:
              ++v65;
              v61 += 2 * v840;
              --v716;
            }
            while (v716);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v715) {
              goto LABEL_1245;
            }
          }
        case 15:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 15 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v719 = WORD1(v58);
          int v720 = HIDWORD(v58);
          int v721 = v854[0];
          while (1)
          {
            int v722 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1075;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAoverlayPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v719, v720,
                     SHIWORD(v720),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1075:
              ++v65;
              v61 += 2 * v840;
              --v722;
            }
            while (v722);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v721) {
              goto LABEL_1245;
            }
          }
        case 16:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 16 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v725 = WORD1(v58);
          __int32 v726 = HIDWORD(v58);
          int v727 = v854[0];
          while (1)
          {
            int v728 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0.n128_u64[0] = v847.i64[0];
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1089;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              v799.i32[1] = v726;
              v799.i16[1] = v725;
              v799.i16[0] = LOWORD(v58);
              uint64_t v5 = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, _Q4, _Q5, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v799, *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1089:
              ++v65;
              v61 += 2 * v840;
              --v728;
            }
            while (v728);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v727) {
              goto LABEL_1245;
            }
          }
        case 17:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 17 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v730 = WORD1(v58);
          __int32 v731 = HIDWORD(v58);
          int v732 = v854[0];
          while (1)
          {
            int v733 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0.n128_u64[0] = v847.i64[0];
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1103;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              v800.i32[1] = v731;
              v800.i16[1] = v730;
              v800.i16[0] = LOWORD(v58);
              uint64_t v5 = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, _Q4, _Q5, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v800, *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1103:
              ++v65;
              v61 += 2 * v840;
              --v733;
            }
            while (v733);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v732) {
              goto LABEL_1245;
            }
          }
        case 18:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 18 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v735 = WORD1(v58);
          int v736 = HIDWORD(v58);
          int v737 = v854[0];
          while (1)
          {
            int v738 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1117;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAcolordodgePDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v735, v736,
                     SHIWORD(v736),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1117:
              ++v65;
              v61 += 2 * v840;
              --v738;
            }
            while (v738);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v737) {
              goto LABEL_1245;
            }
          }
        case 19:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 19 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v741 = WORD1(v58);
          int v742 = HIDWORD(v58);
          int v743 = v854[0];
          while (1)
          {
            int v744 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1131;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAcolorburnPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v741, v742,
                     SHIWORD(v742),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1131:
              ++v65;
              v61 += 2 * v840;
              --v744;
            }
            while (v744);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v743) {
              goto LABEL_1245;
            }
          }
        case 20:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 20 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v747 = WORD1(v58);
          int v748 = HIDWORD(v58);
          int v749 = v854[0];
          while (1)
          {
            int v750 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0.n128_u64[0] = v847.i64[0];
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1145;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              HIWORD(v801) = v747;
              LOWORD(v801) = LOWORD(v58);
              uint64_t v5 = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v801, v748, SHIWORD(v748),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1145:
              ++v65;
              v61 += 2 * v840;
              --v750;
            }
            while (v750);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v749) {
              goto LABEL_1245;
            }
          }
        case 21:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 21 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v752 = WORD1(v58);
          int v753 = HIDWORD(v58);
          int v754 = v854[0];
          while (1)
          {
            int v755 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1159;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAhardlightPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v752, v753,
                     SHIWORD(v753),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1159:
              ++v65;
              v61 += 2 * v840;
              --v755;
            }
            while (v755);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v754) {
              goto LABEL_1245;
            }
          }
        case 22:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 22 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v758 = WORD1(v58);
          int v759 = HIDWORD(v58);
          int v760 = v854[0];
          while (1)
          {
            int v761 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1173;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAdifferencePDA(_Q0, v13, v14, (float16x4_t)v15.n128_u64[0], *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, *(float16x4_t *)&v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v758, v759,
                     SHIWORD(v759),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1173:
              ++v65;
              v61 += 2 * v840;
              --v761;
            }
            while (v761);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v760) {
              goto LABEL_1245;
            }
          }
        case 23:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 23 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v763 = WORD1(v58);
          int v764 = HIDWORD(v58);
          int v765 = v854[0];
          while (1)
          {
            int v766 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1187;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAexclusionPDA(_Q0, v13, v14, (float16x4_t)v15.n128_u64[0], *(double *)_Q4.i64, *(float16x4_t *)_Q5.f32, v58, *(int32x2_t *)&v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v763, v764,
                     SHIWORD(v764),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1187:
              ++v65;
              v61 += 2 * v840;
              --v766;
            }
            while (v766);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v765) {
              goto LABEL_1245;
            }
          }
        case 24:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 24 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v768 = WORD1(v58);
          int v769 = HIDWORD(v58);
          int v770 = v854[0];
          while (1)
          {
            int v771 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1201;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAhuePDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v768, v769,
                     SHIWORD(v769),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1201:
              ++v65;
              v61 += 2 * v840;
              --v771;
            }
            while (v771);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v770) {
              goto LABEL_1245;
            }
          }
        case 25:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 25 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v774 = WORD1(v58);
          int v775 = HIDWORD(v58);
          int v776 = v854[0];
          while (1)
          {
            int v777 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1215;
                }
                __asm { FCVT            S4, H0 }
              }
              else
              {
                _S4 = 1.0;
              }
              _Q0.n128_u16[0] = v65->i16[0];
              v13.n128_u16[0] = v65->u16[1];
              v14.n128_u16[0] = v65->u16[2];
              v15.n128_u16[0] = v65->u16[3];
              uint64_t v5 = PDAsaturationPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v774, v775,
                     SHIWORD(v775),
                     *(float *)_D17.i32);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1215:
              ++v65;
              v61 += 2 * v840;
              --v777;
            }
            while (v777);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v776) {
              goto LABEL_1245;
            }
          }
        case 26:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 26 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          LOWORD(v2) = WORD1(v58);
          LOWORD(v4) = HIWORD(v58);
          LOWORD(v3) = WORD2(v58);
          int v780 = v854[0];
          while (1)
          {
            int v781 = v66;
            do
            {
              if (v22)
              {
                __asm { FCMP            H0, #0 }
                if (!(!_ZF & _CF))
                {
                  *(double *)CGColorRef v65 = v58;
                  _Q0 = (__n128)v847;
                  *(_WORD *)uint64_t v61 = v847.i16[0];
                  goto LABEL_1229;
                }
                __asm { FCVT            S0, H0 }
              }
              else
              {
                _Q0.n128_u32[0] = 1.0;
              }
              float v802 = _Q0.n128_f32[0];
              _Q0.n128_u32[0] = LODWORD(v58);
              v13.n128_u32[0] = v2;
              v14.n128_u32[0] = v3;
              v15.n128_u32[0] = v4;
              uint64_t v5 = PDAluminosityPDA(_Q0, v13, v14, v15, *(float *)_D17.i32, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, v65->i32[0], HIWORD(v65->i32[0]), v65->i32[1],
                     HIWORD(v65->i32[1]),
                     v802);
              *CGColorRef v65 = (float16x4_t)v5;
              if (v22) {
                *(_WORD *)uint64_t v61 = v6;
              }
              double v58 = v849;
              _D17.i32[0] = v851.i32[0];
LABEL_1229:
              ++v65;
              v61 += 2 * v840;
              --v781;
            }
            while (v781);
            v65 += v59;
            v61 += 2 * v62;
            if (!--v780) {
              goto LABEL_1245;
            }
          }
        case 27:
          __asm { FCMP            H5, #0; jumptable 0000000184EA8F88 case 27 }
          if (_NF ^ _VF | _ZF) {
            goto LABEL_1275;
          }
          __int16 v783 = WORD1(v58);
          int v784 = HIDWORD(v58);
          int v785 = v854[0];
          break;
        default:
          goto LABEL_1276;
      }
LABEL_1234:
      int v786 = v66;
      while (v22)
      {
        __asm { FCMP            H0, #0 }
        if (!_ZF & _CF)
        {
          __asm { FCVT            S4, H0 }
LABEL_1240:
          _Q0.n128_u16[0] = v65->i16[0];
          v13.n128_u16[0] = v65->u16[1];
          v14.n128_u16[0] = v65->u16[2];
          v15.n128_u16[0] = v65->u16[3];
          uint64_t v5 = PDAluminosityPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v58, v19, v5, v6, (uint64_t)v30, v7, v8, v9, v10, v11, SLOWORD(v58), v783, v784,
                 SHIWORD(v784),
                 *(float *)_D17.i32);
          *CGColorRef v65 = (float16x4_t)v5;
          if (v22) {
            *(_WORD *)uint64_t v61 = v6;
          }
          double v58 = v849;
          _D17.i32[0] = v851.i32[0];
          goto LABEL_1243;
        }
        *(double *)CGColorRef v65 = v58;
        _Q0 = (__n128)v847;
        *(_WORD *)uint64_t v61 = v847.i16[0];
LABEL_1243:
        ++v65;
        v61 += 2 * v840;
        if (!--v786)
        {
          v65 += v59;
          v61 += 2 * v62;
          if (!--v785)
          {
LABEL_1245:
            v854[0] = 0;
            LODWORD(v23) = v809;
            unint64_t v53 = v837;
            unint64_t v50 = v838;
LABEL_1275:
            uint64_t v59 = v842;
LABEL_1276:
            if (!v44) {
              return 1;
            }
            uint64_t v853 = 0;
LABEL_1278:
            uint64_t v5 = shape_enum_clip_next((uint64_t)v44, (int *)&v853 + 1, &v853, v864, v854);
            if (!v5) {
              goto LABEL_66;
            }
            CGColorRef v65 = (float16x4_t *)(v59 + 8 * v50 * (int)v853 + 8 * SHIDWORD(v853));
            unint64_t v67 = v864[0];
            if (v22)
            {
              uint64_t v61 = v844 + 2 * v53 * (int)v853 + 2 * SHIDWORD(v853);
              unint64_t v62 = v53 - v864[0];
            }
            int v66 = v864[0];
            _Q5 = v847;
            double v58 = v849;
            _D17 = v851;
            goto LABEL_936;
          }
          goto LABEL_1234;
        }
      }
      _S4 = 1.0;
      goto LABEL_1240;
    }
    v864[0] = *(_DWORD *)(v6 + 4);
    v854[0] = v28;
    uint64_t v33 = *(void *)(v6 + 88);
    uint64_t v35 = *(int *)(v6 + 12);
    uint64_t v34 = *(int *)(v6 + 16);
    unint64_t v36 = (unint64_t)*(int *)(v6 + 28) >> 3;
    if (v22)
    {
      unint64_t v37 = (unint64_t)*(int *)(v6 + 32) >> 1;
      unint64_t v811 = (char *)(v22 + 2 * (v35 + v37 * v34));
      uint64_t v38 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v811 = 0;
      unint64_t v37 = 0;
      uint64_t v38 = 0;
    }
    unint64_t v810 = *(void *)(v6 + 40) + 8 * (v35 + v34 * v36);
    uint64_t v54 = *(unsigned int *)(v6 + 104);
    int v55 = *(_DWORD *)(v6 + 56);
    int v56 = *(_DWORD *)(v6 + 60);
    unint64_t v836 = (unint64_t)*(int *)(v6 + 76) >> 3;
    if (v32 == 256)
    {
      if (v21)
      {
        unint64_t v841 = (unint64_t)*(int *)(v6 + 80) >> 1;
        v21 += 2 * v55 + 2 * v841 * v56;
        uint64_t v57 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v841 = 0;
        uint64_t v57 = 0;
      }
      v33 += 8 * (v55 + v56 * v836);
      if (v836 == v36 && (uint64_t)(v810 - v33) >= 1)
      {
        if (v26 >= (v810 - v33) >> 3)
        {
          v810 += 8 * v27;
          v33 += 8 * v27;
          v811 += 2 * (v38 & v27);
          uint64_t v7 = 0xFFFFFFFFLL;
          unint64_t v836 = (unint64_t)*(int *)(v6 + 28) >> 3;
          v21 += 2 * (v57 & v27);
          goto LABEL_49;
        }
        uint64_t v86 = v33 + 8 * v36 * v29;
        if (v810 <= v86 + 8 * (unint64_t)v27)
        {
          v810 += 8 * v36 * v29;
          unint64_t v36 = -(uint64_t)v36;
          v811 += 2 * v37 * v29;
          unint64_t v37 = -(uint64_t)v37;
          v21 += 2 * v841 * v29;
          v38 &= 1u;
          unint64_t v841 = -(uint64_t)v841;
          v57 &= 1u;
          uint64_t v7 = 1;
          uint64_t v33 = v86;
          unint64_t v836 = v36;
          goto LABEL_49;
        }
      }
      v38 &= 1u;
      v57 &= 1u;
      uint64_t v7 = 1;
LABEL_49:
      int v804 = *(_DWORD *)(v6 + 60);
      int v805 = *(_DWORD *)(v6 + 56);
      if (v30)
      {
        uint64_t v850 = v57;
        uint64_t v852 = v38;
        uint64_t v839 = 0;
        unint64_t v835 = 0;
        uint64_t v87 = -1;
        int v814 = v836;
        int v813 = v841;
        goto LABEL_54;
      }
      unint64_t v92 = (int)v7 * (int)v26;
      unint64_t v848 = v37 - (int)v38 * (int)v26;
      unint64_t v93 = -1;
      unint64_t v94 = v841;
      int v812 = v7;
      int v813 = v841;
      unint64_t v95 = v836;
      int v814 = v836;
LABEL_62:
      unint64_t v835 = 0;
      uint64_t v815 = 0;
      uint64_t v816 = v33;
      unint64_t v836 = v95 - v92;
      uint64_t v839 = 0;
      unint64_t v841 = v94 - (int)v57 * (int)v26;
      uint64_t v99 = (uint64_t)v21;
      uint64_t v90 = v21;
      unint64_t v100 = v810;
      long long v91 = v811;
      goto LABEL_67;
    }
    int v814 = *(_DWORD *)(v6 + 64);
    int v813 = *(_DWORD *)(v6 + 68);
    if (v21)
    {
      unint64_t v841 = (unint64_t)*(int *)(v6 + 80) >> 1;
      uint64_t v57 = 1;
    }
    else
    {
      unint64_t v841 = 0;
      uint64_t v57 = 0;
    }
    unint64_t v835 = v33 + 8 * v836 * v813;
    v38 &= 1u;
    if (v30)
    {
      int v804 = *(_DWORD *)(v6 + 60);
      int v805 = *(_DWORD *)(v6 + 56);
      uint64_t v850 = v57;
      uint64_t v852 = v38;
      LODWORD(v7) = 1;
      uint64_t v839 = *(void *)(v6 + 88);
      uint64_t v87 = v839;
LABEL_54:
      int v812 = v7;
      unint64_t v817 = v36;
      shape_enum_clip_alloc(v5, v6, (int *)v30, v7, v36, 1, v54, *(_DWORD *)(v6 + 108), v26, v28);
      uint64_t v89 = v88;
      float v843 = v21;
      uint64_t v90 = v21;
      long long v91 = v811;
      unint64_t v848 = v37;
      if (v88) {
        goto LABEL_888;
      }
      return 1;
    }
    unint64_t v848 = v37 - (v38 * v26);
    if (!v33)
    {
      int v804 = *(_DWORD *)(v6 + 60);
      int v805 = *(_DWORD *)(v6 + 56);
      unint64_t v93 = 0;
      int v812 = 1;
      unint64_t v92 = v26;
      unint64_t v94 = v841;
      unint64_t v95 = (unint64_t)*(int *)(v6 + 76) >> 3;
      goto LABEL_62;
    }
    uint64_t v96 = v56 % v813;
    int v804 = v56 % v813;
    uint64_t v816 = *(void *)(v6 + 88);
    unint64_t v97 = v33 + 8 * v836 * v96;
    int v98 = v55 % v814;
    uint64_t v33 = v97 + 8 * v98;
    unint64_t v93 = v97 + 8 * v814;
    int v805 = v98;
    uint64_t v839 = v33;
    uint64_t v815 = 0;
    if (v21)
    {
      uint64_t v99 = (uint64_t)&v21[2 * v841 * v96 + 2 * v98];
      int v812 = 1;
      uint64_t v57 = 1;
      uint64_t v90 = (char *)v99;
    }
    else
    {
      uint64_t v99 = 0;
      uint64_t v90 = 0;
      int v812 = 1;
    }
    unint64_t v100 = v810;
    long long v91 = v811;
    unint64_t v92 = v26;
LABEL_67:
    uint64_t v852 = v38;
    uint64_t v850 = v57;
    unint64_t v817 = v36;
    unint64_t v845 = v36 - v92;
    int v833 = v26;
    switch((int)v23)
    {
      case 0:
        float v843 = (_WORD *)v99;
        unint64_t v803 = v93;
        uint64_t v102 = v845 - (int)v26;
        unint64_t v103 = v100 - 8 * ((int)v26 - 1);
        if (v812 >= 0)
        {
          unint64_t v103 = v100;
          uint64_t v102 = v845 + (int)v26;
        }
        unsigned int v104 = v854[0];
        uint64_t v105 = v854[0] - 1;
        uint64_t v106 = (char *)(v103 + 8 * ((v102 * v105) & (v102 >> 63)));
        if (v102 < 0) {
          uint64_t v102 = -v102;
        }
        CGBlt_fillBytes(8 * v26, v854[0], 0, v106, 8 * v102);
        if (!v38)
        {
          LODWORD(v23) = v809;
          unint64_t v25 = v806;
          goto LABEL_847;
        }
        if (v812 < 0)
        {
          uint64_t v107 = v848 - (int)v26;
          v91 += -2 * (int)v26 + 2;
        }
        else
        {
          uint64_t v107 = v848 + (int)v26;
        }
        unint64_t v25 = v806;
        v91 += 2 * ((v107 * v105) & (v107 >> 63));
        if (v107 < 0) {
          uint64_t v107 = -v107;
        }
        unint64_t v848 = v107;
        CGBlt_fillBytes(2 * v26, v104, 0, v91, 2 * v107);
        goto LABEL_846;
      case 1:
        int v108 = *(unsigned __int8 *)(v25 + 1);
        if (v108 == 2)
        {
          if ((int)v26 >= 4 && (8 * v814) <= 0x40)
          {
            _Q0.n128_u32[0] = 8 * v814;
            uint8x8_t v547 = (uint8x8_t)vcnt_s8((int8x8_t)_Q0.n128_u64[0]);
            v547.i16[0] = vaddlv_u8(v547);
            if (v547.i32[0] <= 1u)
            {
              float v843 = (_WORD *)v99;
              unint64_t v803 = v93;
              int v548 = v854[0];
              uint64_t v33 = v816;
              CGSFillDRAM64(v100, 8 * (v26 + v845), 8 * v26, v854[0], v816, 8 * v836, 8 * v814, v813, 8 * v805, v804);
              if (v38)
              {
                uint64_t v89 = v815;
                if (v850) {
                  CGSFillDRAM64((unint64_t)v91, 2 * (v26 + v848), 2 * v26, v548, (uint64_t)v21, 2 * v841, 2 * v814, v813, 2 * v805, v804);
                }
                else {
                  CGBlt_fillBytes(2 * v26, v548, 1065353216, v91, 2 * (v26 + v848));
                }
                goto LABEL_849;
              }
LABEL_848:
              uint64_t v89 = v815;
LABEL_849:
              unint64_t v93 = v803;
              goto LABEL_886;
            }
          }
        }
        else if (v108 == 1)
        {
          float v843 = (_WORD *)v99;
          unint64_t v803 = v93;
          if (v812 < 0)
          {
            uint64_t v109 = v836 - (int)v26;
            v33 -= 8 * ((int)v26 - 1);
            uint64_t v110 = v845 - (int)v26;
            v100 -= 8 * ((int)v26 - 1);
          }
          else
          {
            uint64_t v109 = v836 + (int)v26;
            uint64_t v110 = v845 + (int)v26;
          }
          uint64_t v583 = v854[0] - 1;
          int8x16_t v584 = (char *)(v33 + 8 * ((v109 * v583) & (v109 >> 63)));
          if (v109 >= 0) {
            unint64_t v585 = v109;
          }
          else {
            unint64_t v585 = -v109;
          }
          if (v110 >= 0) {
            LODWORD(v586) = v110;
          }
          else {
            uint64_t v586 = -v110;
          }
          unint64_t v836 = v585;
          int v846 = v854[0];
          CGBlt_copyBytes(8 * v26, v854[0], v584, (char *)(v100 + 8 * ((v110 * v583) & (v110 >> 63))), 8 * v585, 8 * v586);
          if (v38)
          {
            int v587 = 2 * v26;
            uint64_t v89 = v815;
            uint64_t v33 = v816;
            if (v850)
            {
              uint64_t v588 = v841 - (int)v26;
              int v589 = &v90[-2 * (int)v26 + 2];
              uint64_t v590 = v848 - (int)v26;
              int8x16_t v591 = &v91[-2 * (int)v26 + 2];
              if (v812 >= 0)
              {
                int v589 = v90;
                int8x16_t v591 = v91;
                uint64_t v588 = v841 + (int)v26;
                uint64_t v590 = v848 + (int)v26;
              }
              uint64_t v90 = &v589[2 * ((v588 * v583) & (v588 >> 63))];
              if (v588 >= 0) {
                unint64_t v592 = v588;
              }
              else {
                unint64_t v592 = -v588;
              }
              long long v91 = &v591[2 * ((v590 * v583) & (v590 >> 63))];
              if (v590 >= 0) {
                uint64_t v593 = v590;
              }
              else {
                uint64_t v593 = -v590;
              }
              unint64_t v841 = v592;
              unint64_t v848 = v593;
              CGBlt_copyBytes(v587, v846, v90, v91, 2 * v592, 2 * v593);
            }
            else
            {
              uint64_t v594 = v848 - (int)v26;
              int v595 = &v91[-2 * (int)v26 + 2];
              if (v812 >= 0)
              {
                int v595 = v91;
                uint64_t v594 = v848 + (int)v26;
              }
              uint64_t v596 = (v594 * v583) & (v594 >> 63);
              long long v91 = &v595[2 * v596];
              if (v594 < 0) {
                uint64_t v594 = -v594;
              }
              unint64_t v848 = v594;
              CGBlt_fillBytes(v587, v846, 1065353216, &v595[2 * v596], 2 * v594);
            }
            LODWORD(v23) = v809;
            goto LABEL_849;
          }
LABEL_846:
          LODWORD(v23) = v809;
LABEL_847:
          uint64_t v33 = v816;
          goto LABEL_848;
        }
        if (v38)
        {
          uint64_t v549 = 2 * (int)v38;
          uint64_t v550 = 8 * v812;
          if (v57)
          {
            uint64_t v551 = (int)v57;
            int v552 = v854[0];
            uint64_t v113 = v839;
            do
            {
              int v553 = v26;
              do
              {
                *(void *)unint64_t v100 = *(void *)v33;
                *(_WORD *)long long v91 = *(_WORD *)v90;
                unint64_t v554 = v33 + 8 * v812;
                if (v554 >= v93) {
                  uint64_t v555 = -(uint64_t)v814;
                }
                else {
                  uint64_t v555 = 0;
                }
                v90 += 2 * v551 + 2 * v555;
                uint64_t v33 = v554 + 8 * v555;
                v91 += v549;
                v100 += v550;
                --v553;
              }
              while (v553);
              if (v835)
              {
                unint64_t v556 = v113 + 8 * v836;
                if (v556 >= v835) {
                  uint64_t v557 = -(uint64_t)(v841 * v813);
                }
                else {
                  uint64_t v557 = 0;
                }
                v99 += 2 * v841 + 2 * v557;
                if (v556 >= v835) {
                  uint64_t v558 = -(uint64_t)(v836 * v813);
                }
                else {
                  uint64_t v558 = 0;
                }
                uint64_t v113 = v556 + 8 * v558;
                v93 += 8 * v558 + 8 * v836;
                uint64_t v90 = (char *)v99;
                uint64_t v33 = v113;
              }
              else
              {
                v33 += 8 * v836;
                v90 += 2 * v841;
              }
              v100 += 8 * v845;
              v91 += 2 * v848;
              --v552;
            }
            while (v552);
LABEL_841:
            uint64_t v839 = v113;
          }
          else
          {
            int v566 = v854[0];
            uint64_t v153 = v839;
            do
            {
              int v567 = v26;
              do
              {
                *(void *)unint64_t v100 = *(void *)v33;
                *(_WORD *)long long v91 = COERCE_UNSIGNED_INT(1.0);
                unint64_t v568 = v33 + 8 * v812;
                if (v568 >= v93) {
                  uint64_t v569 = -(uint64_t)v814;
                }
                else {
                  uint64_t v569 = 0;
                }
                v90 += 2 * v569;
                uint64_t v33 = v568 + 8 * v569;
                v91 += v549;
                v100 += v550;
                --v567;
              }
              while (v567);
              if (v835)
              {
                unint64_t v570 = v153 + 8 * v836;
                if (v570 >= v835) {
                  uint64_t v571 = -(uint64_t)(v841 * v813);
                }
                else {
                  uint64_t v571 = 0;
                }
                v99 += 2 * v841 + 2 * v571;
                if (v570 >= v835) {
                  uint64_t v572 = -(uint64_t)(v836 * v813);
                }
                else {
                  uint64_t v572 = 0;
                }
                uint64_t v153 = v570 + 8 * v572;
                v93 += 8 * v572 + 8 * v836;
                uint64_t v90 = (char *)v99;
                uint64_t v33 = v153;
              }
              else
              {
                v33 += 8 * v836;
                v90 += 2 * v841;
              }
              v100 += 8 * v845;
              v91 += 2 * v848;
              --v566;
            }
            while (v566);
LABEL_883:
            uint64_t v839 = v153;
          }
          goto LABEL_884;
        }
        int v559 = v854[0];
        uint64_t v468 = v839;
        do
        {
          int v560 = v26;
          do
          {
            *(void *)unint64_t v100 = *(void *)v33;
            unint64_t v561 = v33 + 8 * v812;
            if (v561 >= v93) {
              uint64_t v562 = -(uint64_t)v814;
            }
            else {
              uint64_t v562 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v562;
            uint64_t v33 = v561 + 8 * v562;
            v100 += 8 * v812;
            --v560;
          }
          while (v560);
          if (v835)
          {
            unint64_t v563 = v468 + 8 * v836;
            if (v563 >= v835) {
              uint64_t v564 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v564 = 0;
            }
            v99 += 2 * v841 + 2 * v564;
            if (v563 >= v835) {
              uint64_t v565 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v565 = 0;
            }
            uint64_t v468 = v563 + 8 * v565;
            v93 += 8 * v565 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v468;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v559;
        }
        while (v559);
        goto LABEL_866;
      case 2:
        uint64_t v111 = (int)v57;
        if (v38)
        {
          int v112 = v854[0];
          uint64_t v113 = v839;
          while (1)
          {
            int v114 = v26;
            do
            {
              if (*(short float *)v90 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *(void *)unint64_t v100 = *(void *)v33;
                _H2 = *(_WORD *)v90;
              }
              else
              {
                __asm { FCMP            H2, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_88;
                }
                __asm { FCVT            S2, H2 }
                *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v33), vcvtq_f32_f16(*(float16x4_t *)v100), 1.0 - _S2));
                _H4 = *(_WORD *)v91;
                __asm { FCVT            S4, H4 }
                _S2 = _S2 + (float)(_S4 * (float)(1.0 - _S2));
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)long long v91 = _H2;
LABEL_88:
              unint64_t v121 = v33 + 8 * v812;
              if (v121 >= v93) {
                uint64_t v122 = -(uint64_t)v814;
              }
              else {
                uint64_t v122 = 0;
              }
              v90 += 2 * v111 + 2 * v122;
              uint64_t v33 = v121 + 8 * v122;
              v91 += 2 * (int)v38;
              v100 += 8 * v812;
              --v114;
            }
            while (v114);
            if (v835)
            {
              unint64_t v123 = v113 + 8 * v836;
              if (v123 >= v835) {
                uint64_t v124 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v124 = 0;
              }
              v99 += 2 * v841 + 2 * v124;
              if (v123 >= v835) {
                uint64_t v125 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v125 = 0;
              }
              uint64_t v113 = v123 + 8 * v125;
              v93 += 8 * v125 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v113;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v112) {
              goto LABEL_841;
            }
          }
        }
        int v467 = v854[0];
        uint64_t v468 = v839;
LABEL_690:
        int v469 = v26;
        while (*(short float *)v90 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
        {
          __asm { FCMP            H2, #0 }
          if (!(_NF ^ _VF | _ZF))
          {
            __asm { FCVT            S2, H2 }
            float16x4_t v472 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v33), vcvtq_f32_f16(*(float16x4_t *)v100), 1.0 - _S2));
LABEL_695:
            *(float16x4_t *)unint64_t v100 = v472;
          }
          unint64_t v473 = v33 + 8 * v812;
          if (v473 >= v93) {
            uint64_t v474 = -(uint64_t)v814;
          }
          else {
            uint64_t v474 = 0;
          }
          v90 += 2 * (int)v57 + 2 * v474;
          uint64_t v33 = v473 + 8 * v474;
          v100 += 8 * v812;
          if (!--v469)
          {
            if (v835)
            {
              unint64_t v475 = v468 + 8 * v836;
              if (v475 >= v835) {
                uint64_t v476 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v476 = 0;
              }
              v99 += 2 * v841 + 2 * v476;
              if (v475 >= v835) {
                uint64_t v477 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v477 = 0;
              }
              uint64_t v468 = v475 + 8 * v477;
              v93 += 8 * v477 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v468;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v467) {
              goto LABEL_866;
            }
            goto LABEL_690;
          }
        }
        float16x4_t v472 = *(float16x4_t *)v33;
        goto LABEL_695;
      case 3:
        if (v57)
        {
          uint64_t v126 = (int)v57;
          int v127 = v854[0];
          uint64_t v113 = v839;
          do
          {
            int v128 = v26;
            do
            {
              __asm { FCMP            H1, #0 }
              if (!_ZF & _CF)
              {
                short float v130 = *(short float *)v33;
                if (_H1 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  *(short float *)unint64_t v100 = v130;
                  *(_WORD *)(v100 + 2) = *(_WORD *)(v33 + 2);
                  *(_DWORD *)(v100 + 4) = *(_DWORD *)(v33 + 4);
                  short float v131 = *(short float *)v90;
                }
                else
                {
                  *(short float *)unint64_t v100 = _H1 * v130;
                  *(short float *)(v100 + 2) = _H1 * *(short float *)(v33 + 2);
                  *(short float *)(v100 + 4) = _H1 * *(short float *)(v33 + 4);
                  *(short float *)(v100 + 6) = _H1 * *(short float *)(v33 + 6);
                  short float v131 = _H1 * *(short float *)v90;
                }
              }
              else
              {
                *(void *)unint64_t v100 = 0;
                LOWORD(v131) = 0;
              }
              *(short float *)long long v91 = v131;
              unint64_t v132 = v33 + 8 * v812;
              if (v132 >= v93) {
                uint64_t v133 = -(uint64_t)v814;
              }
              else {
                uint64_t v133 = 0;
              }
              v90 += 2 * v126 + 2 * v133;
              uint64_t v33 = v132 + 8 * v133;
              v91 += 2 * (int)v38;
              v100 += 8 * v812;
              --v128;
            }
            while (v128);
            if (v835)
            {
              unint64_t v134 = v113 + 8 * v836;
              if (v134 >= v835) {
                uint64_t v135 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v135 = 0;
              }
              v99 += 2 * v841 + 2 * v135;
              if (v134 >= v835) {
                uint64_t v136 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v136 = 0;
              }
              uint64_t v113 = v134 + 8 * v136;
              v93 += 8 * v136 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v113;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            --v127;
          }
          while (v127);
          goto LABEL_841;
        }
        int v478 = v854[0];
        uint64_t v153 = v839;
        do
        {
          int v479 = v26;
          do
          {
            __asm { FCMP            H1, #0 }
            if (!_ZF & _CF)
            {
              short float v481 = *(short float *)v33;
              if (_H1 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *(short float *)unint64_t v100 = v481;
                *(_WORD *)(v100 + 2) = *(_WORD *)(v33 + 2);
                *(_DWORD *)(v100 + 4) = *(_DWORD *)(v33 + 4);
              }
              else
              {
                *(short float *)unint64_t v100 = _H1 * v481;
                *(short float *)(v100 + 2) = _H1 * *(short float *)(v33 + 2);
                *(short float *)(v100 + 4) = _H1 * *(short float *)(v33 + 4);
                *(short float *)(v100 + 6) = _H1 * *(short float *)(v33 + 6);
              }
            }
            else
            {
              *(void *)unint64_t v100 = 0;
            }
            unint64_t v482 = v33 + 8 * v812;
            if (v482 >= v93) {
              uint64_t v483 = -(uint64_t)v814;
            }
            else {
              uint64_t v483 = 0;
            }
            v90 += 2 * v483;
            uint64_t v33 = v482 + 8 * v483;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v479;
          }
          while (v479);
          if (v835)
          {
            unint64_t v484 = v153 + 8 * v836;
            if (v484 >= v835) {
              uint64_t v485 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v485 = 0;
            }
            v99 += 2 * v841 + 2 * v485;
            if (v484 >= v835) {
              uint64_t v486 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v486 = 0;
            }
            uint64_t v153 = v484 + 8 * v486;
            v93 += 8 * v486 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v153;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v478;
        }
        while (v478);
        goto LABEL_883;
      case 4:
        int v137 = v854[0];
        uint64_t v138 = v839;
        do
        {
          int v139 = v26;
          do
          {
            _H1 = *(_WORD *)v91;
            __asm { FCVT            S1, H1 }
            float v142 = 1.0 - _S1;
            if (v142 <= 0.0)
            {
              *(void *)unint64_t v100 = 0;
              LOWORD(_H1) = 0;
            }
            else if (v142 >= 1.0)
            {
              if (v57) {
                _H1 = *(short float *)v90;
              }
              else {
                LOWORD(_H1) = COERCE_UNSIGNED_INT(1.0);
              }
            }
            else
            {
              *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v33), v142));
              if (v57)
              {
                _H2 = *(short float *)v90;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _S1 = v142 * _S2;
              __asm { FCVT            H1, S1 }
            }
            *(short float *)long long v91 = _H1;
            unint64_t v147 = v33 + 8 * v812;
            if (v147 >= v93) {
              uint64_t v148 = -(uint64_t)v814;
            }
            else {
              uint64_t v148 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v148;
            uint64_t v33 = v147 + 8 * v148;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v139;
          }
          while (v139);
          if (v835)
          {
            unint64_t v149 = v138 + 8 * v836;
            if (v149 >= v835) {
              uint64_t v150 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v150 = 0;
            }
            v99 += 2 * v841 + 2 * v150;
            if (v149 >= v835) {
              uint64_t v151 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v151 = 0;
            }
            uint64_t v138 = v149 + 8 * v151;
            v93 += 8 * v151 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v138;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v137;
        }
        while (v137);
        goto LABEL_327;
      case 5:
        int v152 = v854[0];
        uint64_t v153 = v839;
        do
        {
          int v154 = v26;
          do
          {
            _H1 = *(_WORD *)v91;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v90;
            __asm { FCVT            S2, H2 }
            *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), 1.0 - _S2), vcvtq_f32_f16(*(float16x4_t *)v33), _S1));
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * _S1);
            __asm { FCVT            H1, S1 }
            *(_WORD *)long long v91 = LOWORD(_S1);
            unint64_t v160 = v33 + 8 * v812;
            if (v160 >= v93) {
              uint64_t v161 = -(uint64_t)v814;
            }
            else {
              uint64_t v161 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v161;
            uint64_t v33 = v160 + 8 * v161;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v154;
          }
          while (v154);
          if (v835)
          {
            unint64_t v162 = v153 + 8 * v836;
            if (v162 >= v835) {
              uint64_t v163 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v163 = 0;
            }
            v99 += 2 * v841 + 2 * v163;
            if (v162 >= v835) {
              uint64_t v164 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v164 = 0;
            }
            uint64_t v153 = v162 + 8 * v164;
            v93 += 8 * v164 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v153;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v152;
        }
        while (v152);
        goto LABEL_883;
      case 6:
        int v165 = v854[0];
        uint64_t v138 = v839;
        while (1)
        {
          int v166 = v26;
          do
          {
            _H1 = *(_WORD *)v91;
            __asm { FCVT            S1, H1 }
            float v169 = 1.0 - _S1;
            if ((float)(1.0 - _S1) >= 1.0)
            {
              *(void *)unint64_t v100 = *(void *)v33;
              if (v57) {
                _H1 = *(short float *)v90;
              }
              else {
                LOWORD(_H1) = COERCE_UNSIGNED_INT(1.0);
              }
            }
            else
            {
              if (v169 <= 0.0) {
                goto LABEL_182;
              }
              *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), vcvtq_f32_f16(*(float16x4_t *)v33), v169));
              if (v57)
              {
                _H3 = *(short float *)v90;
                __asm { FCVT            S3, H3 }
              }
              else
              {
                _S3 = 1.0;
              }
              _S1 = _S1 + (float)(_S3 * v169);
              __asm { FCVT            H1, S1 }
            }
            *(short float *)long long v91 = _H1;
LABEL_182:
            unint64_t v174 = v33 + 8 * v812;
            if (v174 >= v93) {
              uint64_t v175 = -(uint64_t)v814;
            }
            else {
              uint64_t v175 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v175;
            uint64_t v33 = v174 + 8 * v175;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v166;
          }
          while (v166);
          if (v835)
          {
            unint64_t v176 = v138 + 8 * v836;
            if (v176 >= v835) {
              uint64_t v177 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v177 = 0;
            }
            v99 += 2 * v841 + 2 * v177;
            if (v176 >= v835) {
              uint64_t v178 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v178 = 0;
            }
            uint64_t v138 = v176 + 8 * v178;
            v93 += 8 * v178 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v138;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          if (!--v165)
          {
LABEL_327:
            uint64_t v839 = v138;
            goto LABEL_884;
          }
        }
      case 7:
        uint64_t v179 = (int)v57;
        if (v38)
        {
          int v180 = v854[0];
          uint64_t v113 = v839;
          while (1)
          {
            int v181 = v26;
            do
            {
              __asm { FCMP            H1, #0 }
              if (!_ZF & _CF)
              {
                if (_H1 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                  goto LABEL_205;
                }
                *(float16x4_t *)unint64_t v100 = vmul_n_f16(*(float16x4_t *)v100, _H1);
                short float v183 = _H1 * *(short float *)v91;
              }
              else
              {
                *(void *)unint64_t v100 = 0;
                LOWORD(v183) = 0;
              }
              *(short float *)long long v91 = v183;
LABEL_205:
              unint64_t v184 = v33 + 8 * v812;
              if (v184 >= v93) {
                uint64_t v185 = -(uint64_t)v814;
              }
              else {
                uint64_t v185 = 0;
              }
              v90 += 2 * v179 + 2 * v185;
              uint64_t v33 = v184 + 8 * v185;
              v91 += 2 * (int)v38;
              v100 += 8 * v812;
              --v181;
            }
            while (v181);
            if (v835)
            {
              unint64_t v186 = v113 + 8 * v836;
              if (v186 >= v835) {
                uint64_t v187 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v187 = 0;
              }
              v99 += 2 * v841 + 2 * v187;
              if (v186 >= v835) {
                uint64_t v188 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v188 = 0;
              }
              uint64_t v113 = v186 + 8 * v188;
              v93 += 8 * v188 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v113;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v180) {
              goto LABEL_841;
            }
          }
        }
        int v487 = v854[0];
        uint64_t v468 = v839;
        do
        {
          int v488 = v26;
          do
          {
            __asm { FCMP            H1, #0 }
            if (!_ZF & _CF)
            {
              if (_H1 < COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0))) {
                *(float16x4_t *)unint64_t v100 = vmul_n_f16(*(float16x4_t *)v100, _H1);
              }
            }
            else
            {
              *(void *)unint64_t v100 = 0;
            }
            unint64_t v490 = v33 + 8 * v812;
            if (v490 >= v93) {
              uint64_t v491 = -(uint64_t)v814;
            }
            else {
              uint64_t v491 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v491;
            uint64_t v33 = v490 + 8 * v491;
            v100 += 8 * v812;
            --v488;
          }
          while (v488);
          if (v835)
          {
            unint64_t v492 = v468 + 8 * v836;
            if (v492 >= v835) {
              uint64_t v493 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v493 = 0;
            }
            v99 += 2 * v841 + 2 * v493;
            if (v492 >= v835) {
              uint64_t v494 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v494 = 0;
            }
            uint64_t v468 = v492 + 8 * v494;
            v93 += 8 * v494 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v468;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v487;
        }
        while (v487);
        goto LABEL_866;
      case 8:
        uint64_t v189 = (int)v57;
        if (!v38)
        {
          int v495 = v854[0];
          uint64_t v468 = v839;
          do
          {
            int v496 = v26;
            do
            {
              _H1 = *(short float *)v90;
              __asm { FCVT            S1, H1 }
              float v499 = 1.0 - _S1;
              if (v499 <= 0.0)
              {
                *(void *)unint64_t v100 = 0;
              }
              else if (v499 < 1.0)
              {
                *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), v499));
              }
              unint64_t v500 = v33 + 8 * v812;
              if (v500 >= v93) {
                uint64_t v501 = -(uint64_t)v814;
              }
              else {
                uint64_t v501 = 0;
              }
              v90 += 2 * (int)v57 + 2 * v501;
              uint64_t v33 = v500 + 8 * v501;
              v100 += 8 * v812;
              --v496;
            }
            while (v496);
            if (v835)
            {
              unint64_t v502 = v468 + 8 * v836;
              if (v502 >= v835) {
                uint64_t v503 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v503 = 0;
              }
              v99 += 2 * v841 + 2 * v503;
              if (v502 >= v835) {
                uint64_t v504 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v504 = 0;
              }
              uint64_t v468 = v502 + 8 * v504;
              v93 += 8 * v504 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v468;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            --v495;
          }
          while (v495);
LABEL_866:
          uint64_t v839 = v468;
LABEL_884:
          float v843 = (_WORD *)v99;
          v854[0] = 0;
          goto LABEL_885;
        }
        int v190 = v854[0];
        uint64_t v113 = v839;
LABEL_222:
        int v191 = v26;
        while (1)
        {
          _H1 = *(short float *)v90;
          __asm { FCVT            S1, H1 }
          float v194 = 1.0 - _S1;
          if (v194 <= 0.0) {
            break;
          }
          if (v194 < 1.0)
          {
            *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), v194));
            _H2 = *(_WORD *)v91;
            __asm { FCVT            S2, H2 }
            _S1 = v194 * _S2;
            __asm { FCVT            H1, S1 }
LABEL_227:
            *(_WORD *)long long v91 = _H1;
          }
          unint64_t v199 = v33 + 8 * v812;
          if (v199 >= v93) {
            uint64_t v200 = -(uint64_t)v814;
          }
          else {
            uint64_t v200 = 0;
          }
          v90 += 2 * v189 + 2 * v200;
          uint64_t v33 = v199 + 8 * v200;
          v91 += 2 * (int)v38;
          v100 += 8 * v812;
          if (!--v191)
          {
            if (v835)
            {
              unint64_t v201 = v113 + 8 * v836;
              if (v201 >= v835) {
                uint64_t v202 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v202 = 0;
              }
              v99 += 2 * v841 + 2 * v202;
              if (v201 >= v835) {
                uint64_t v203 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v203 = 0;
              }
              uint64_t v113 = v201 + 8 * v203;
              v93 += 8 * v203 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v113;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v190) {
              goto LABEL_841;
            }
            goto LABEL_222;
          }
        }
        *(void *)unint64_t v100 = 0;
        _H1 = 0;
        goto LABEL_227;
      case 9:
        int v204 = v854[0];
        uint64_t v153 = v839;
        do
        {
          int v205 = v26;
          do
          {
            _H1 = *(_WORD *)v91;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v90;
            __asm { FCVT            S2, H2 }
            *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), _S2), vcvtq_f32_f16(*(float16x4_t *)v33), 1.0 - _S1));
            _S1 = (float)(_S1 * _S2) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)long long v91 = LOWORD(_S1);
            unint64_t v211 = v33 + 8 * v812;
            if (v211 >= v93) {
              uint64_t v212 = -(uint64_t)v814;
            }
            else {
              uint64_t v212 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v212;
            uint64_t v33 = v211 + 8 * v212;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v205;
          }
          while (v205);
          if (v835)
          {
            unint64_t v213 = v153 + 8 * v836;
            if (v213 >= v835) {
              uint64_t v214 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v214 = 0;
            }
            v99 += 2 * v841 + 2 * v214;
            if (v213 >= v835) {
              uint64_t v215 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v215 = 0;
            }
            uint64_t v153 = v213 + 8 * v215;
            v93 += 8 * v215 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v153;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v204;
        }
        while (v204);
        goto LABEL_883;
      case 10:
        int v216 = v854[0];
        uint64_t v153 = v839;
        do
        {
          int v217 = v26;
          do
          {
            _H1 = *(_WORD *)v91;
            __asm { FCVT            S1, H1 }
            _H2 = *(short float *)v90;
            __asm { FCVT            S2, H2 }
            *(float16x4_t *)unint64_t v100 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v100), 1.0 - _S2), vcvtq_f32_f16(*(float16x4_t *)v33), 1.0 - _S1));
            _S1 = (float)((float)(1.0 - _S2) * _S1) + (float)(_S2 * (float)(1.0 - _S1));
            __asm { FCVT            H1, S1 }
            *(_WORD *)long long v91 = LOWORD(_S1);
            unint64_t v223 = v33 + 8 * v812;
            if (v223 >= v93) {
              uint64_t v224 = -(uint64_t)v814;
            }
            else {
              uint64_t v224 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v224;
            uint64_t v33 = v223 + 8 * v224;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v217;
          }
          while (v217);
          if (v835)
          {
            unint64_t v225 = v153 + 8 * v836;
            if (v225 >= v835) {
              uint64_t v226 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v226 = 0;
            }
            v99 += 2 * v841 + 2 * v226;
            if (v225 >= v835) {
              uint64_t v227 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v227 = 0;
            }
            uint64_t v153 = v225 + 8 * v227;
            v93 += 8 * v227 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v153;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v216;
        }
        while (v216);
        goto LABEL_883;
      case 11:
        if (v38)
        {
          int v228 = v854[0];
          uint64_t v138 = v839;
          do
          {
            int v229 = v26;
            do
            {
              _S1 = 1.0;
              _S2 = 1.0;
              if (v57)
              {
                _H0 = *(short float *)v90;
                __asm { FCVT            S2, H0 }
              }
              _H0 = *(_WORD *)v91;
              __asm { FCVT            S3, H0 }
              _S0 = _S2 + _S3;
              if ((float)(_S2 + _S3) > 1.0) {
                _S0 = 1.0;
              }
              if (v57)
              {
                _H1 = *(short float *)v90;
                __asm { FCVT            S1, H1 }
              }
              _H4 = *(_WORD *)v100;
              __asm { FCVT            S4, H4 }
              _H5 = *(_WORD *)v33;
              __asm { FCVT            S5, H5 }
              float v241 = (float)(_S3 - _S4) + (float)(_S2 - _S5);
              _H6 = *(_WORD *)(v100 + 2);
              _H5 = *(_WORD *)(v33 + 2);
              _S2 = _S0 - v241;
              __asm { FCVT            H2, S2 }
              *(_WORD *)unint64_t v100 = LOWORD(_S2);
              _S2 = 1.0;
              _S4 = 1.0;
              if (v57)
              {
                _H4 = *(short float *)v90;
                __asm { FCVT            S4, H4 }
              }
              __asm
              {
                FCVT            S6, H6
                FCVT            S5, H5
              }
              float v250 = (float)(_S3 - _S6) + (float)(_S1 - _S5);
              _H3 = *(_WORD *)v91;
              _H5 = *(_WORD *)(v100 + 4);
              _H1 = *(_WORD *)(v33 + 4);
              _S6 = _S0 - v250;
              __asm { FCVT            H6, S6 }
              *(_WORD *)(v100 + 2) = LOWORD(_S6);
              _H6 = *(_WORD *)v91;
              if (v57)
              {
                _H2 = *(short float *)v90;
                __asm { FCVT            S2, H2 }
              }
              __asm
              {
                FCVT            S3, H3
                FCVT            S5, H5
                FCVT            S1, H1
              }
              float v260 = (float)(_S3 - _S5) + (float)(_S4 - _S1);
              __asm { FCVT            S3, H6 }
              _H4 = *(_WORD *)(v100 + 6);
              __asm { FCVT            S4, H4 }
              float v264 = _S3 - _S4;
              LOWORD(_S4) = *(_WORD *)(v33 + 6);
              __asm { FCVT            S4, H4 }
              _S1 = _S0 - v260;
              __asm { FCVT            H1, S1 }
              *(_WORD *)(v100 + 4) = LOWORD(_S1);
              __asm { FCVT            H1, S0 }
              *(_WORD *)long long v91 = LOWORD(_S1);
              _S0 = _S0 - (float)(v264 + (float)(_S2 - _S4));
              __asm { FCVT            H0, S0 }
              *(_WORD *)(v100 + 6) = LOWORD(_S0);
              unint64_t v268 = v33 + 8 * v812;
              if (v268 >= v93) {
                uint64_t v269 = -(uint64_t)v814;
              }
              else {
                uint64_t v269 = 0;
              }
              v90 += 2 * (int)v57 + 2 * v269;
              uint64_t v33 = v268 + 8 * v269;
              v91 += 2 * (int)v38;
              v100 += 8 * v812;
              --v229;
            }
            while (v229);
            if (v835)
            {
              unint64_t v270 = v138 + 8 * v836;
              if (v270 >= v835) {
                uint64_t v271 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v271 = 0;
              }
              v99 += 2 * v841 + 2 * v271;
              if (v270 >= v835) {
                uint64_t v272 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v272 = 0;
              }
              uint64_t v138 = v270 + 8 * v272;
              v93 += 8 * v272 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v138;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            --v228;
          }
          while (v228);
          goto LABEL_327;
        }
        int v505 = v854[0];
        uint64_t v468 = v839;
        do
        {
          int v506 = v26;
          do
          {
            _S2 = 1.0;
            if (v57)
            {
              _H2 = *(short float *)v90;
              __asm { FCVT            S2, H2 }
            }
            _S3 = 1.0;
            if (v57)
            {
              _H3 = *(short float *)v90;
              __asm { FCVT            S3, H3 }
            }
            _H4 = *(_WORD *)v100;
            __asm { FCVT            S4, H4 }
            _H5 = *(_WORD *)v33;
            __asm { FCVT            S5, H5 }
            float v515 = (float)(1.0 - _S4) + (float)(_S2 - _S5);
            LOWORD(_S4) = *(_WORD *)(v100 + 2);
            __asm { FCVT            S4, H4 }
            float v517 = 1.0 - _S4;
            LOWORD(_S4) = *(_WORD *)(v33 + 2);
            __asm { FCVT            S4, H4 }
            _S2 = 1.0 - v515;
            __asm { FCVT            H2, S2 }
            *(_WORD *)unint64_t v100 = LOWORD(_S2);
            _S2 = 1.0 - (float)(v517 + (float)(_S3 - _S4));
            __asm { FCVT            H2, S2 }
            *(_WORD *)(v100 + 2) = LOWORD(_S2);
            _S2 = 1.0;
            if (v57)
            {
              _H2 = *(short float *)v90;
              __asm { FCVT            S2, H2 }
            }
            _H4 = *(_WORD *)(v33 + 4);
            _S3 = 1.0;
            if (v57)
            {
              _H3 = *(short float *)v90;
              __asm { FCVT            S3, H3 }
            }
            _H5 = *(_WORD *)(v100 + 4);
            __asm
            {
              FCVT            S5, H5
              FCVT            S4, H4
            }
            float v529 = (float)(1.0 - _S5) + (float)(_S2 - _S4);
            LOWORD(_S4) = *(_WORD *)(v100 + 6);
            __asm { FCVT            S4, H4 }
            float v531 = 1.0 - _S4;
            LOWORD(_S4) = *(_WORD *)(v33 + 6);
            __asm { FCVT            S4, H4 }
            _S2 = 1.0 - v529;
            __asm { FCVT            H2, S2 }
            *(_WORD *)(v100 + 4) = LOWORD(_S2);
            _S1 = 1.0 - (float)(v531 + (float)(_S3 - _S4));
            __asm { FCVT            H1, S1 }
            *(_WORD *)(v100 + 6) = LOWORD(_S1);
            unint64_t v535 = v33 + 8 * v812;
            if (v535 >= v93) {
              uint64_t v536 = -(uint64_t)v814;
            }
            else {
              uint64_t v536 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v536;
            uint64_t v33 = v535 + 8 * v536;
            v100 += 8 * v812;
            --v506;
          }
          while (v506);
          if (v835)
          {
            unint64_t v537 = v468 + 8 * v836;
            if (v537 >= v835) {
              uint64_t v538 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v538 = 0;
            }
            v99 += 2 * v841 + 2 * v538;
            if (v537 >= v835) {
              uint64_t v539 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v539 = 0;
            }
            uint64_t v468 = v537 + 8 * v539;
            v93 += 8 * v539 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v468;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v505;
        }
        while (v505);
        goto LABEL_866;
      case 12:
        if (!v38)
        {
          int v540 = v854[0];
          uint64_t v468 = v839;
          do
          {
            int v541 = v26;
            do
            {
              *(float16x4_t *)unint64_t v100 = vadd_f16(*(float16x4_t *)v100, *(float16x4_t *)v33);
              unint64_t v542 = v33 + 8 * v812;
              if (v542 >= v93) {
                uint64_t v543 = -(uint64_t)v814;
              }
              else {
                uint64_t v543 = 0;
              }
              v90 += 2 * (int)v57 + 2 * v543;
              uint64_t v33 = v542 + 8 * v543;
              v100 += 8 * v812;
              --v541;
            }
            while (v541);
            if (v835)
            {
              unint64_t v544 = v468 + 8 * v836;
              if (v544 >= v835) {
                uint64_t v545 = -(uint64_t)(v841 * v813);
              }
              else {
                uint64_t v545 = 0;
              }
              v99 += 2 * v841 + 2 * v545;
              if (v544 >= v835) {
                uint64_t v546 = -(uint64_t)(v836 * v813);
              }
              else {
                uint64_t v546 = 0;
              }
              uint64_t v468 = v544 + 8 * v546;
              v93 += 8 * v546 + 8 * v836;
              uint64_t v90 = (char *)v99;
              uint64_t v33 = v468;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            v100 += 8 * v845;
            v91 += 2 * v848;
            --v540;
          }
          while (v540);
          goto LABEL_866;
        }
        int v273 = v854[0];
        uint64_t v138 = v839;
        do
        {
          int v274 = v26;
          do
          {
            if (v57)
            {
              _H1 = *(short float *)v90;
              __asm { FCVT            S1, H1 }
            }
            else
            {
              _S1 = 1.0;
            }
            _H2 = *(_WORD *)v91;
            __asm { FCVT            S2, H2 }
            _S1 = _S1 + _S2;
            short float v280 = *(short float *)v100;
            short float v281 = *(short float *)v33;
            if (_S1 > 1.0) {
              _S1 = 1.0;
            }
            short float v282 = *(short float *)(v100 + 2);
            short float v283 = *(short float *)(v33 + 2);
            __asm { FCVT            H1, S1 }
            *(_WORD *)long long v91 = _H1;
            *(short float *)unint64_t v100 = v280 + v281;
            *(short float *)(v100 + 2) = v282 + v283;
            short float v285 = *(short float *)(v100 + 6);
            short float v286 = *(short float *)(v33 + 6);
            *(short float *)(v100 + 4) = *(short float *)(v100 + 4) + *(short float *)(v33 + 4);
            *(short float *)(v100 + 6) = v285 + v286;
            unint64_t v287 = v33 + 8 * v812;
            if (v287 >= v93) {
              uint64_t v288 = -(uint64_t)v814;
            }
            else {
              uint64_t v288 = 0;
            }
            v90 += 2 * (int)v57 + 2 * v288;
            uint64_t v33 = v287 + 8 * v288;
            v91 += 2 * (int)v38;
            v100 += 8 * v812;
            --v274;
          }
          while (v274);
          if (v835)
          {
            unint64_t v289 = v138 + 8 * v836;
            if (v289 >= v835) {
              uint64_t v290 = -(uint64_t)(v841 * v813);
            }
            else {
              uint64_t v290 = 0;
            }
            v99 += 2 * v841 + 2 * v290;
            if (v289 >= v835) {
              uint64_t v291 = -(uint64_t)(v836 * v813);
            }
            else {
              uint64_t v291 = 0;
            }
            uint64_t v138 = v289 + 8 * v291;
            v93 += 8 * v291 + 8 * v836;
            uint64_t v90 = (char *)v99;
            uint64_t v33 = v138;
          }
          else
          {
            v33 += 8 * v836;
            v90 += 2 * v841;
          }
          v100 += 8 * v845;
          v91 += 2 * v848;
          --v273;
        }
        while (v273);
        goto LABEL_327;
      case 13:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v292 = (int)v57;
        int v818 = v854[0];
        uint64_t v293 = 2 * (int)v38;
        uint64_t v294 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_339;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_336;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_336:
            unint64_t v298 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAmultiplyPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v298;
            uint64_t v294 = -(uint64_t)v814;
            goto LABEL_339;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_339:
          unint64_t v299 = v33 + 8 * v812;
          if (v299 >= v93) {
            uint64_t v300 = v294;
          }
          else {
            uint64_t v300 = 0;
          }
          v90 += 2 * v292 + 2 * v300;
          uint64_t v33 = v299 + 8 * v300;
          v91 += v293;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v301 = v839 + 8 * v836;
              uint64_t v302 = -(uint64_t)(v841 * v813);
              if (v301 < v835) {
                uint64_t v302 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v302];
              uint64_t v303 = -(uint64_t)(v836 * v813);
              if (v301 < v835) {
                uint64_t v303 = 0;
              }
              uint64_t v33 = v301 + 8 * v303;
              v93 += 8 * v303 + 8 * v836;
              v843 += v841 + v302;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v818) {
              goto LABEL_687;
            }
          }
        }
      case 14:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v304 = (int)v57;
        int v819 = v854[0];
        uint64_t v305 = 2 * (int)v38;
        uint64_t v306 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_363;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_360;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_360:
            unint64_t v310 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAscreenPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v310;
            uint64_t v306 = -(uint64_t)v814;
            goto LABEL_363;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_363:
          unint64_t v311 = v33 + 8 * v812;
          if (v311 >= v93) {
            uint64_t v312 = v306;
          }
          else {
            uint64_t v312 = 0;
          }
          v90 += 2 * v304 + 2 * v312;
          uint64_t v33 = v311 + 8 * v312;
          v91 += v305;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v313 = v839 + 8 * v836;
              uint64_t v314 = -(uint64_t)(v841 * v813);
              if (v313 < v835) {
                uint64_t v314 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v314];
              uint64_t v315 = -(uint64_t)(v836 * v813);
              if (v313 < v835) {
                uint64_t v315 = 0;
              }
              uint64_t v33 = v313 + 8 * v315;
              v93 += 8 * v315 + 8 * v836;
              v843 += v841 + v314;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v819) {
              goto LABEL_687;
            }
          }
        }
      case 15:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v316 = (int)v57;
        int v820 = v854[0];
        uint64_t v317 = 2 * (int)v38;
        uint64_t v318 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_387;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_384;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_384:
            unint64_t v322 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAoverlayPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v322;
            uint64_t v318 = -(uint64_t)v814;
            goto LABEL_387;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_387:
          unint64_t v323 = v33 + 8 * v812;
          if (v323 >= v93) {
            uint64_t v324 = v318;
          }
          else {
            uint64_t v324 = 0;
          }
          v90 += 2 * v316 + 2 * v324;
          uint64_t v33 = v323 + 8 * v324;
          v91 += v317;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v325 = v839 + 8 * v836;
              uint64_t v326 = -(uint64_t)(v841 * v813);
              if (v325 < v835) {
                uint64_t v326 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v326];
              uint64_t v327 = -(uint64_t)(v836 * v813);
              if (v325 < v835) {
                uint64_t v327 = 0;
              }
              uint64_t v33 = v325 + 8 * v327;
              v93 += 8 * v327 + 8 * v836;
              v843 += v841 + v326;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v820) {
              goto LABEL_687;
            }
          }
        }
      case 16:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v328 = (int)v57;
        int v821 = v854[0];
        uint64_t v329 = 2 * (int)v38;
        uint64_t v330 = -(uint64_t)v814;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_411;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_408;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_408:
            unint64_t v333 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, _Q4, _Q5, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(float16x4_t *)v33, _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v333;
            uint64_t v330 = -(uint64_t)v814;
            goto LABEL_411;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_411:
          unint64_t v334 = v33 + 8 * v812;
          if (v334 >= v93) {
            uint64_t v335 = v330;
          }
          else {
            uint64_t v335 = 0;
          }
          v90 += 2 * v328 + 2 * v335;
          uint64_t v33 = v334 + 8 * v335;
          v91 += v329;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v336 = v839 + 8 * v836;
              uint64_t v337 = -(uint64_t)(v841 * v813);
              if (v336 < v835) {
                uint64_t v337 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v337];
              uint64_t v338 = -(uint64_t)(v836 * v813);
              if (v336 < v835) {
                uint64_t v338 = 0;
              }
              uint64_t v33 = v336 + 8 * v338;
              v93 += 8 * v338 + 8 * v836;
              v843 += v841 + v337;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v821) {
              goto LABEL_687;
            }
          }
        }
      case 17:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v339 = (int)v57;
        int v822 = v854[0];
        uint64_t v340 = 2 * (int)v38;
        uint64_t v341 = -(uint64_t)v814;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_435;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_432;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_432:
            unint64_t v344 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, _Q4, _Q5, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(float16x4_t *)v33, _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v344;
            uint64_t v341 = -(uint64_t)v814;
            goto LABEL_435;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_435:
          unint64_t v345 = v33 + 8 * v812;
          if (v345 >= v93) {
            uint64_t v346 = v341;
          }
          else {
            uint64_t v346 = 0;
          }
          v90 += 2 * v339 + 2 * v346;
          uint64_t v33 = v345 + 8 * v346;
          v91 += v340;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v347 = v839 + 8 * v836;
              uint64_t v348 = -(uint64_t)(v841 * v813);
              if (v347 < v835) {
                uint64_t v348 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v348];
              uint64_t v349 = -(uint64_t)(v836 * v813);
              if (v347 < v835) {
                uint64_t v349 = 0;
              }
              uint64_t v33 = v347 + 8 * v349;
              v93 += 8 * v349 + 8 * v836;
              v843 += v841 + v348;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v822) {
              goto LABEL_687;
            }
          }
        }
      case 18:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v350 = (int)v57;
        int v823 = v854[0];
        uint64_t v351 = 2 * (int)v38;
        uint64_t v352 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_459;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_456;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_456:
            unint64_t v356 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAcolordodgePDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v356;
            uint64_t v352 = -(uint64_t)v814;
            goto LABEL_459;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_459:
          unint64_t v357 = v33 + 8 * v812;
          if (v357 >= v93) {
            uint64_t v358 = v352;
          }
          else {
            uint64_t v358 = 0;
          }
          v90 += 2 * v350 + 2 * v358;
          uint64_t v33 = v357 + 8 * v358;
          v91 += v351;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v359 = v839 + 8 * v836;
              uint64_t v360 = -(uint64_t)(v841 * v813);
              if (v359 < v835) {
                uint64_t v360 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v360];
              uint64_t v361 = -(uint64_t)(v836 * v813);
              if (v359 < v835) {
                uint64_t v361 = 0;
              }
              uint64_t v33 = v359 + 8 * v361;
              v93 += 8 * v361 + 8 * v836;
              v843 += v841 + v360;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v823) {
              goto LABEL_687;
            }
          }
        }
      case 19:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v362 = (int)v57;
        int v824 = v854[0];
        uint64_t v363 = 2 * (int)v38;
        uint64_t v364 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_483;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_480;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_480:
            unint64_t v368 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAcolorburnPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v368;
            uint64_t v364 = -(uint64_t)v814;
            goto LABEL_483;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_483:
          unint64_t v369 = v33 + 8 * v812;
          if (v369 >= v93) {
            uint64_t v370 = v364;
          }
          else {
            uint64_t v370 = 0;
          }
          v90 += 2 * v362 + 2 * v370;
          uint64_t v33 = v369 + 8 * v370;
          v91 += v363;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v371 = v839 + 8 * v836;
              uint64_t v372 = -(uint64_t)(v841 * v813);
              if (v371 < v835) {
                uint64_t v372 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v372];
              uint64_t v373 = -(uint64_t)(v836 * v813);
              if (v371 < v835) {
                uint64_t v373 = 0;
              }
              uint64_t v33 = v371 + 8 * v373;
              v93 += 8 * v373 + 8 * v836;
              v843 += v841 + v372;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v824) {
              goto LABEL_687;
            }
          }
        }
      case 20:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v374 = (int)v57;
        int v825 = v854[0];
        uint64_t v375 = 2 * (int)v38;
        uint64_t v376 = -(uint64_t)v814;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_507;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_504;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_504:
            unint64_t v379 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v13, v14, v15, *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, *(_DWORD *)(v33 + 4), HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v379;
            uint64_t v376 = -(uint64_t)v814;
            goto LABEL_507;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_507:
          unint64_t v380 = v33 + 8 * v812;
          if (v380 >= v93) {
            uint64_t v381 = v376;
          }
          else {
            uint64_t v381 = 0;
          }
          v90 += 2 * v374 + 2 * v381;
          uint64_t v33 = v380 + 8 * v381;
          v91 += v375;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v382 = v839 + 8 * v836;
              uint64_t v383 = -(uint64_t)(v841 * v813);
              if (v382 < v835) {
                uint64_t v383 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v383];
              uint64_t v384 = -(uint64_t)(v836 * v813);
              if (v382 < v835) {
                uint64_t v384 = 0;
              }
              uint64_t v33 = v382 + 8 * v384;
              v93 += 8 * v384 + 8 * v836;
              v843 += v841 + v383;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v825) {
              goto LABEL_687;
            }
          }
        }
      case 21:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v385 = (int)v57;
        int v826 = v854[0];
        uint64_t v386 = 2 * (int)v38;
        uint64_t v387 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_531;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_528;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_528:
            unint64_t v391 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAhardlightPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v391;
            uint64_t v387 = -(uint64_t)v814;
            goto LABEL_531;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_531:
          unint64_t v392 = v33 + 8 * v812;
          if (v392 >= v93) {
            uint64_t v393 = v387;
          }
          else {
            uint64_t v393 = 0;
          }
          v90 += 2 * v385 + 2 * v393;
          uint64_t v33 = v392 + 8 * v393;
          v91 += v386;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v394 = v839 + 8 * v836;
              uint64_t v395 = -(uint64_t)(v841 * v813);
              if (v394 < v835) {
                uint64_t v395 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v395];
              uint64_t v396 = -(uint64_t)(v836 * v813);
              if (v394 < v835) {
                uint64_t v396 = 0;
              }
              uint64_t v33 = v394 + 8 * v396;
              v93 += 8 * v396 + 8 * v836;
              v843 += v841 + v395;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v826) {
              goto LABEL_687;
            }
          }
        }
      case 22:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v397 = (int)v57;
        int v827 = v854[0];
        uint64_t v398 = 2 * (int)v38;
        uint64_t v399 = -(uint64_t)v814;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_555;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_552;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_552:
            unint64_t v402 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAdifferencePDA(_Q0, v13, v14, (float16x4_t)v15.n128_u64[0], *(double *)_Q4.i64, *(int32x2_t *)_Q5.f32, *(float16x4_t *)&v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v402;
            uint64_t v399 = -(uint64_t)v814;
            goto LABEL_555;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_555:
          unint64_t v403 = v33 + 8 * v812;
          if (v403 >= v93) {
            uint64_t v404 = v399;
          }
          else {
            uint64_t v404 = 0;
          }
          v90 += 2 * v397 + 2 * v404;
          uint64_t v33 = v403 + 8 * v404;
          v91 += v398;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v405 = v839 + 8 * v836;
              uint64_t v406 = -(uint64_t)(v841 * v813);
              if (v405 < v835) {
                uint64_t v406 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v406];
              uint64_t v407 = -(uint64_t)(v836 * v813);
              if (v405 < v835) {
                uint64_t v407 = 0;
              }
              uint64_t v33 = v405 + 8 * v407;
              v93 += 8 * v407 + 8 * v836;
              v843 += v841 + v406;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v827) {
              goto LABEL_687;
            }
          }
        }
      case 23:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v408 = (int)v57;
        int v828 = v854[0];
        uint64_t v409 = 2 * (int)v38;
        uint64_t v410 = -(uint64_t)v814;
        while (1)
        {
          _Q4.i32[0] = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_579;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_576;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_576:
            unint64_t v413 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAexclusionPDA(_Q0, v13, v14, (float16x4_t)v15.n128_u64[0], *(double *)_Q4.i64, *(float16x4_t *)_Q5.f32, v18, *(int32x2_t *)&v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v413;
            uint64_t v410 = -(uint64_t)v814;
            goto LABEL_579;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_579:
          unint64_t v414 = v33 + 8 * v812;
          if (v414 >= v93) {
            uint64_t v415 = v410;
          }
          else {
            uint64_t v415 = 0;
          }
          v90 += 2 * v408 + 2 * v415;
          uint64_t v33 = v414 + 8 * v415;
          v91 += v409;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v416 = v839 + 8 * v836;
              uint64_t v417 = -(uint64_t)(v841 * v813);
              if (v416 < v835) {
                uint64_t v417 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v417];
              uint64_t v418 = -(uint64_t)(v836 * v813);
              if (v416 < v835) {
                uint64_t v418 = 0;
              }
              uint64_t v33 = v416 + 8 * v418;
              v93 += 8 * v418 + 8 * v836;
              v843 += v841 + v417;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v828) {
              goto LABEL_687;
            }
          }
        }
      case 24:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v419 = (int)v57;
        int v829 = v854[0];
        uint64_t v420 = 2 * (int)v38;
        uint64_t v421 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_603;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_600;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_600:
            unint64_t v425 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAhuePDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v425;
            uint64_t v421 = -(uint64_t)v814;
            goto LABEL_603;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_603:
          unint64_t v426 = v33 + 8 * v812;
          if (v426 >= v93) {
            uint64_t v427 = v421;
          }
          else {
            uint64_t v427 = 0;
          }
          v90 += 2 * v419 + 2 * v427;
          uint64_t v33 = v426 + 8 * v427;
          v91 += v420;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v428 = v839 + 8 * v836;
              uint64_t v429 = -(uint64_t)(v841 * v813);
              if (v428 < v835) {
                uint64_t v429 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v429];
              uint64_t v430 = -(uint64_t)(v836 * v813);
              if (v428 < v835) {
                uint64_t v430 = 0;
              }
              uint64_t v33 = v428 + 8 * v430;
              v93 += 8 * v430 + 8 * v836;
              v843 += v841 + v429;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v829) {
              goto LABEL_687;
            }
          }
        }
      case 25:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v431 = (int)v57;
        int v830 = v854[0];
        uint64_t v432 = 2 * (int)v38;
        uint64_t v433 = -(uint64_t)v814;
        while (1)
        {
          _S4 = 1.0;
          _Q5.i32[0] = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_627;
            }
            __asm { FCVT            S5, H0 }
          }
          if (!v38) {
            goto LABEL_624;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S4, H0 }
LABEL_624:
            unint64_t v437 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v100;
            v13.n128_u16[0] = *(_WORD *)(v100 + 2);
            v14.n128_u16[0] = *(_WORD *)(v100 + 4);
            v15.n128_u16[0] = *(_WORD *)(v100 + 6);
            uint64_t v5 = PDAsaturationPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
                   HIWORD(*(_DWORD *)(v33 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v437;
            uint64_t v433 = -(uint64_t)v814;
            goto LABEL_627;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S5 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_627:
          unint64_t v438 = v33 + 8 * v812;
          if (v438 >= v93) {
            uint64_t v439 = v433;
          }
          else {
            uint64_t v439 = 0;
          }
          v90 += 2 * v431 + 2 * v439;
          uint64_t v33 = v438 + 8 * v439;
          v91 += v432;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v440 = v839 + 8 * v836;
              uint64_t v441 = -(uint64_t)(v841 * v813);
              if (v440 < v835) {
                uint64_t v441 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v441];
              uint64_t v442 = -(uint64_t)(v836 * v813);
              if (v440 < v835) {
                uint64_t v442 = 0;
              }
              uint64_t v33 = v440 + 8 * v442;
              v93 += 8 * v442 + 8 * v836;
              v843 += v841 + v441;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v830) {
              goto LABEL_687;
            }
          }
        }
      case 26:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v443 = (int)v57;
        int v831 = v854[0];
        uint64_t v444 = 2 * (int)v38;
        uint64_t v445 = -(uint64_t)v814;
        while (1)
        {
          _Q5.i32[0] = 1.0;
          _S4 = 1.0;
          if (v57)
          {
            __asm { FCMP            H0, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_651;
            }
            __asm { FCVT            S4, H0 }
          }
          if (!v38) {
            goto LABEL_648;
          }
          __asm { FCMP            H0, #0 }
          if (!_ZF & _CF)
          {
            __asm { FCVT            S5, H0 }
LABEL_648:
            unint64_t v449 = v93;
            _Q0.n128_u16[0] = *(_WORD *)v33;
            v13.n128_u16[0] = *(_WORD *)(v33 + 2);
            v14.n128_u16[0] = *(_WORD *)(v33 + 4);
            v15.n128_u16[0] = *(_WORD *)(v33 + 6);
            uint64_t v5 = PDAluminosityPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v100, HIWORD(*(_DWORD *)v100), *(_DWORD *)(v100 + 4),
                   HIWORD(*(_DWORD *)(v100 + 4)),
                   _Q5.f32[0]);
            LODWORD(v38) = v852;
            *(void *)unint64_t v100 = v5;
            if (v852) {
              *(_WORD *)long long v91 = v6;
            }
            uint64_t v57 = v850;
            unint64_t v93 = v449;
            uint64_t v445 = -(uint64_t)v814;
            goto LABEL_651;
          }
          _Q0.n128_u64[0] = *(void *)v33;
          *(void *)unint64_t v100 = *(void *)v33;
          __asm { FCVT            H0, S4 }
          *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_651:
          unint64_t v450 = v33 + 8 * v812;
          if (v450 >= v93) {
            uint64_t v451 = v445;
          }
          else {
            uint64_t v451 = 0;
          }
          v90 += 2 * v443 + 2 * v451;
          uint64_t v33 = v450 + 8 * v451;
          v91 += v444;
          v100 += 8 * v812;
          LODWORD(v26) = v26 - 1;
          if (!v26)
          {
            if (v835)
            {
              unint64_t v452 = v839 + 8 * v836;
              uint64_t v453 = -(uint64_t)(v841 * v813);
              if (v452 < v835) {
                uint64_t v453 = 0;
              }
              uint64_t v90 = (char *)&v843[v841 + v453];
              uint64_t v454 = -(uint64_t)(v836 * v813);
              if (v452 < v835) {
                uint64_t v454 = 0;
              }
              uint64_t v33 = v452 + 8 * v454;
              v93 += 8 * v454 + 8 * v836;
              v843 += v841 + v453;
              uint64_t v839 = v33;
            }
            else
            {
              v33 += 8 * v836;
              v90 += 2 * v841;
            }
            LODWORD(v26) = v833;
            v100 += 8 * v845;
            v91 += 2 * v848;
            if (!--v831) {
              goto LABEL_687;
            }
          }
        }
      case 27:
        float v843 = (_WORD *)v99;
        unint64_t v807 = v37;
        unint64_t v808 = v21;
        uint64_t v455 = (int)v57;
        int v832 = v854[0];
        uint64_t v456 = 2 * (int)v38;
        uint64_t v457 = -(uint64_t)v814;
        break;
      default:
        float v843 = (_WORD *)v99;
        goto LABEL_885;
    }
    while (1)
    {
      _S4 = 1.0;
      _Q5.i32[0] = 1.0;
      if (v57)
      {
        __asm { FCMP            H0, #0 }
        if (_NF ^ _VF | _ZF) {
          goto LABEL_675;
        }
        __asm { FCVT            S5, H0 }
      }
      if (!v38) {
        goto LABEL_672;
      }
      __asm { FCMP            H0, #0 }
      if (!_ZF & _CF)
      {
        __asm { FCVT            S4, H0 }
LABEL_672:
        unint64_t v461 = v93;
        _Q0.n128_u16[0] = *(_WORD *)v100;
        v13.n128_u16[0] = *(_WORD *)(v100 + 2);
        v14.n128_u16[0] = *(_WORD *)(v100 + 4);
        v15.n128_u16[0] = *(_WORD *)(v100 + 6);
        uint64_t v5 = PDAluminosityPDA(_Q0, v13, v14, v15, _S4, *(double *)_Q5.i64, v18, v19, v5, v6, (uint64_t)v30, v7, v36, v57, v54, v93, *(_DWORD *)v33, HIWORD(*(_DWORD *)v33), *(_DWORD *)(v33 + 4),
               HIWORD(*(_DWORD *)(v33 + 4)),
               _Q5.f32[0]);
        LODWORD(v38) = v852;
        *(void *)unint64_t v100 = v5;
        if (v852) {
          *(_WORD *)long long v91 = v6;
        }
        uint64_t v57 = v850;
        unint64_t v93 = v461;
        uint64_t v457 = -(uint64_t)v814;
        goto LABEL_675;
      }
      _Q0.n128_u64[0] = *(void *)v33;
      *(void *)unint64_t v100 = *(void *)v33;
      __asm { FCVT            H0, S5 }
      *(_WORD *)long long v91 = _Q0.n128_u16[0];
LABEL_675:
      unint64_t v462 = v33 + 8 * v812;
      if (v462 >= v93) {
        uint64_t v463 = v457;
      }
      else {
        uint64_t v463 = 0;
      }
      v90 += 2 * v455 + 2 * v463;
      uint64_t v33 = v462 + 8 * v463;
      v91 += v456;
      v100 += 8 * v812;
      LODWORD(v26) = v26 - 1;
      if (!v26)
      {
        if (v835)
        {
          unint64_t v464 = v839 + 8 * v836;
          uint64_t v465 = -(uint64_t)(v841 * v813);
          if (v464 < v835) {
            uint64_t v465 = 0;
          }
          uint64_t v90 = (char *)&v843[v841 + v465];
          uint64_t v466 = -(uint64_t)(v836 * v813);
          if (v464 < v835) {
            uint64_t v466 = 0;
          }
          uint64_t v33 = v464 + 8 * v466;
          v93 += 8 * v466 + 8 * v836;
          v843 += v841 + v465;
          uint64_t v839 = v33;
        }
        else
        {
          v33 += 8 * v836;
          v90 += 2 * v841;
        }
        LODWORD(v26) = v833;
        v100 += 8 * v845;
        v91 += 2 * v848;
        if (!--v832)
        {
LABEL_687:
          v854[0] = 0;
          uint64_t v21 = v808;
          LODWORD(v23) = v809;
          unint64_t v25 = v806;
          unint64_t v37 = v807;
LABEL_885:
          uint64_t v89 = v815;
          uint64_t v33 = v816;
LABEL_886:
          if (!v89) {
            return 1;
          }
          uint64_t v87 = v93;
          uint64_t v853 = 0;
LABEL_888:
          uint64_t v5 = shape_enum_clip_next(v89, (int *)&v853 + 1, &v853, v864, v854);
          if (!v5)
          {
            long long v101 = (void *)v89;
LABEL_910:
            free(v101);
            return 1;
          }
          uint64_t v815 = v89;
          uint64_t v816 = v33;
          if (v835)
          {
            unint64_t v36 = v817;
            unint64_t v100 = v810 + 8 * v817 * (int)v853 + 8 * SHIDWORD(v853);
            int v573 = ((int)v853 + *(_DWORD *)(v25 + 60)) % v813;
            unint64_t v92 = v864[0];
            int v574 = (HIDWORD(v853) + *(_DWORD *)(v25 + 56)) % v814;
            unint64_t v575 = v33 + 8 * v836 * v573;
            uint64_t v33 = v575 + 8 * v574;
            unint64_t v93 = v575 + 8 * v814;
            uint64_t v99 = (uint64_t)v843;
            uint64_t v38 = v852;
            if (v852) {
              long long v91 = &v811[2 * v37 * (int)v853 + 2 * SHIDWORD(v853)];
            }
            unint64_t v576 = v848;
            if (v852) {
              unint64_t v576 = v37 - v864[0];
            }
            unint64_t v848 = v576;
            if (v850) {
              uint64_t v57 = v850;
            }
            else {
              uint64_t v57 = 0;
            }
            if (v850)
            {
              uint64_t v99 = (uint64_t)&v21[2 * v841 * v573 + 2 * v574];
              uint64_t v90 = (char *)v99;
            }
            LODWORD(v26) = v864[0];
            uint64_t v839 = v575 + 8 * v574;
            int v804 = ((int)v853 + *(_DWORD *)(v25 + 60)) % v813;
            int v805 = (HIDWORD(v853) + *(_DWORD *)(v25 + 56)) % v814;
          }
          else
          {
            unint64_t v835 = 0;
            int v577 = HIDWORD(v853) * v812;
            LODWORD(v26) = v864[0];
            int v578 = v864[0] * v812;
            unint64_t v36 = v817;
            unint64_t v100 = v810 + 8 * v817 * (int)v853 + 8 * HIDWORD(v853) * v812;
            unint64_t v92 = v864[0] * v812;
            v33 += 8 * (int)v853 * v814 + 8 * HIDWORD(v853) * v812;
            unint64_t v836 = v814 - v864[0] * v812;
            uint64_t v38 = v852;
            if (v852) {
              long long v91 = &v811[2 * v37 * (int)v853 + 2 * v577];
            }
            unint64_t v579 = v848;
            if (v852) {
              unint64_t v579 = v37 - v578;
            }
            unint64_t v848 = v579;
            uint64_t v580 = (uint64_t)&v21[2 * (int)v853 * v813 + 2 * v577];
            unint64_t v581 = v813 - v578;
            uint64_t v57 = v850;
            if (v850) {
              uint64_t v90 = (char *)v580;
            }
            unint64_t v582 = v841;
            if (v850) {
              unint64_t v582 = v581;
            }
            unint64_t v841 = v582;
            unint64_t v93 = v87;
            uint64_t v99 = (uint64_t)v843;
          }
          goto LABEL_67;
        }
      }
    }
  }
  uint64_t v31 = *(unsigned int *)(v6 + 128);
  if ((v31 | 8) == 8)
  {
    if ((*(_DWORD *)v6 & 0xFF00) == 0x400) {
      CMYKf16_mark_constmask(v6, v23, _Q0.n128_f64[0], (int32x4_t)v13, v14.n128_f64[0], v15, _Q4, _Q5, v18, v19, (uint64_t)v30, v7, v8, v9, v31, v11);
    }
    else {
      CMYKf16_mark_pixelmask(v6, v23, _Q0, v13.n128_f64[0], v14, v15, _Q4, _Q5, *(float16x4_t *)&v18, v19, (uint64_t)v30, v7, v8, v9, v31, v11);
    }
  }
  else
  {
    int v39 = *(_DWORD *)(v6 + 112);
    int v40 = *(_DWORD *)(v6 + 116);
    unsigned int v41 = (v39 + 15) & 0xFFFFFFF0;
    size_t v42 = v41 * v40;
    if ((int)v42 <= 4096)
    {
      double v44 = v864;
      unint64_t v45 = v6;
    }
    else
    {
      double v43 = malloc_type_malloc(v42, 0x346A640BuLL);
      if (!v43) {
        return 1;
      }
      double v44 = v43;
      unint64_t v45 = v806;
      double v30 = *(uint16x4_t **)(v806 + 136);
      LODWORD(v31) = *(_DWORD *)(v806 + 128);
    }
    CGSConvertBitsToMask(v30, *(_DWORD *)(v45 + 124), v44, v41, v39, v40, v31);
    long long v80 = *(_OWORD *)(v45 + 112);
    long long v860 = *(_OWORD *)(v45 + 96);
    long long v861 = v80;
    long long v81 = *(_OWORD *)(v45 + 144);
    long long v862 = *(_OWORD *)(v45 + 128);
    long long v863 = v81;
    long long v82 = *(_OWORD *)(v45 + 48);
    long long v856 = *(_OWORD *)(v45 + 32);
    long long v857 = v82;
    long long v83 = *(_OWORD *)(v45 + 80);
    long long v858 = *(_OWORD *)(v45 + 64);
    long long v859 = v83;
    __n128 v84 = *(__n128 *)v45;
    int32x4_t v85 = *(int32x4_t *)(v45 + 16);
    *(_OWORD *)unint64_t v854 = *(_OWORD *)v45;
    int32x4_t v855 = v85;
    HIDWORD(v861) = (v39 + 15) & 0xFFFFFFF0;
    *((void *)&v862 + 1) = v44;
    if (BYTE1(v854[0]) << 8 == 1024) {
      CMYKf16_mark_constmask((unint64_t)v854, v23, v84.n128_f64[0], v85, v74.n128_f64[0], v75, v76, v77, v78, v79, v68, v69, v70, v71, v72, v73);
    }
    else {
      CMYKf16_mark_pixelmask((unint64_t)v854, v23, v84, *(double *)v85.i64, v74, v75, v76, v77, *(float16x4_t *)&v78, v79, v68, v69, v70, v71, v72, v73);
    }
    if (v44 != (unsigned char *)v864)
    {
LABEL_66:
      long long v101 = v44;
      goto LABEL_910;
    }
  }
  return 1;
}

unint64_t PDAmultiplyPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  float v27 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  float v29 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  float v31 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  float v33 = a5 - _S0;
  __asm { FCVT            S0, H17 }
  float v35 = a21 - _S0;
  __asm { FCVT            S1, H16 }
  float v37 = a21 - _S1;
  __asm { FCVT            S2, H7 }
  float v39 = a21 - _S2;
  __asm { FCVT            S3, H6 }
  float v41 = a21 - _S3;
  float v42 = v27 * v35;
  float v43 = v29 * v37;
  float v44 = v31 * v39;
  float v45 = v33 * v41;
  if (a21 != 1.0)
  {
    float v42 = v42 + (float)(v27 * (float)(1.0 - a21));
    float v43 = v43 + (float)(v29 * (float)(1.0 - a21));
    float v44 = v44 + (float)(v31 * (float)(1.0 - a21));
    float v45 = v45 + (float)(v33 * (float)(1.0 - a21));
  }
  float v46 = v42 + (float)(v35 * (float)(1.0 - a5));
  float v47 = v43 + (float)(v37 * (float)(1.0 - a5));
  float v48 = v44 + (float)(v39 * (float)(1.0 - a5));
  float v49 = v45 + (float)(v41 * (float)(1.0 - a5));
  if (a5 == 1.0)
  {
    float v46 = v42;
    float v47 = v43;
    float v48 = v44;
    float v49 = v45;
  }
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  *(float *)&_S0 = _S4 - v46;
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - v47;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - v48;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v49;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t PDAscreenPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H5 = a20;
  _H6 = a19;
  _H7 = a18;
  _H17 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
    FCVT            S3, H3
    FCVT            S17, H17
    FCVT            S7, H7
    FCVT            S6, H6
    FCVT            S5, H5
  }
  float v34 = (float)(a5 - _S0) + (float)((float)(a21 - _S17) * (float)(1.0 - (float)(a5 - _S0)));
  float v35 = (float)(a5 - _S1) + (float)((float)(a21 - _S7) * (float)(1.0 - (float)(a5 - _S1)));
  float v36 = (float)(a5 - _S2) + (float)((float)(a21 - _S6) * (float)(1.0 - (float)(a5 - _S2)));
  float v37 = (float)(a5 - _S3) + (float)((float)(a21 - _S5) * (float)(1.0 - (float)(a5 - _S3)));
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  *(float *)&_S0 = _S4 - v34;
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - v35;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - v36;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v37;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t PDAoverlayPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  float v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  float v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  float v31 = a5 - _S2;
  __asm { FCVT            S3, H3 }
  float v33 = a5 - _S3;
  __asm { FCVT            S17, H17 }
  float v35 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  float v37 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  float v39 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  float v41 = a21 - _S6;
  float v42 = (float)(v27 * v35) + (float)(v27 * v35);
  float v43 = (float)(v29 * v37) + (float)(v29 * v37);
  float v44 = (float)(v31 * v39) + (float)(v31 * v39);
  float v45 = (float)(v33 * v41) + (float)(v33 * v41);
  float v46 = a5 * a21;
  float v47 = a5 * 0.5;
  _NF = v27 < (float)(a5 * 0.5);
  float v48 = a21 + 1.0;
  float v49 = a5 + 1.0;
  float v50 = (float)((float)((float)((float)(a5 + 1.0) * v35) + (float)(v27 * (float)(a21 + 1.0))) - v42) - (float)(a5 * a21);
  float v51 = 1.0 - a21;
  float v52 = 1.0 - a5;
  float v53 = (float)((float)((float)(1.0 - a5) * v35) + (float)(v27 * (float)(1.0 - a21))) + v42;
  if (!_NF) {
    float v53 = v50;
  }
  _NF = v29 < v47;
  float v54 = (float)((float)((float)(v49 * v37) + (float)(v29 * v48)) - v43) - v46;
  float v55 = (float)((float)(v52 * v37) + (float)(v29 * v51)) + v43;
  if (!_NF) {
    float v55 = v54;
  }
  _NF = v31 < v47;
  float v56 = (float)((float)((float)(v49 * v39) + (float)(v31 * v48)) - v44) - v46;
  float v57 = (float)((float)(v52 * v39) + (float)(v31 * v51)) + v44;
  if (!_NF) {
    float v57 = v56;
  }
  _NF = v33 < v47;
  float v58 = (float)((float)((float)(v49 * v41) + (float)(v33 * v48)) - v45) - v46;
  float v59 = (float)((float)(v52 * v41) + (float)(v33 * v51)) + v45;
  if (!_NF) {
    float v59 = v58;
  }
  _S4 = (float)(a5 + a21) - v46;
  *(float *)&_S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - v55;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - v57;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v59;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t PDAlightenPDA(float16x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float16x4_t a17, float a18)
{
  a6.f32[0] = a18;
  a1.i16[1] = a2.n128_u16[0];
  a1.i16[2] = a3.n128_u16[0];
  a1.i16[3] = a4.n128_u16[0];
  float32x4_t v16 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 0), vcvtq_f32_f16(a1));
  _Q1 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0), vcvtq_f32_f16(a17));
  float32x4_t v18 = vmulq_n_f32(v16, a18);
  _Q3 = vmulq_n_f32(_Q1, a5.f32[0]);
  _Q2 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(_Q3, v18), (int8x16_t)_Q3, (int8x16_t)v18);
  _Q3.i32[0] = 1.0;
  float32x4_t v21 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a6, _Q3)), 0), (int8x16_t)vmlaq_n_f32(_Q2, v16, 1.0 - a18), (int8x16_t)_Q2);
  float32x4_t v22 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a5, _Q3)), 0), (int8x16_t)vmlaq_n_f32(v21, _Q1, 1.0 - a5.f32[0]), (int8x16_t)v21);
  _Q1.f32[0] = (float)(a5.f32[0] + a18) - (float)(a5.f32[0] * a18);
  _Q2.f32[0] = _Q1.f32[0] - v22.f32[0];
  __asm { FCVT            H2, S2 }
  _Q3.f32[0] = _Q1.f32[0] - v22.f32[2];
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S1
  }
  v22.i32[0] = vextq_s8(*(int8x16_t *)&v22, *(int8x16_t *)&v22, 8uLL).i32[1];
  *(float32x2_t *)v22.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q1.f32, 0), *(float32x2_t *)v22.f32);
  v22.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v22)).u64[0];
  v28.i64[0] = v22.u32[0];
  v28.i64[1] = v22.u32[1];
  _Q1.i64[0] = 0xFFFFLL;
  _Q1.i64[1] = 0xFFFFLL;
  uint64x2_t v29 = vshlq_u64((uint64x2_t)vandq_s8(v28, (int8x16_t)_Q1), (uint64x2_t)xmmword_1850CDC30);
  return v29.i64[0] | ((unint64_t)_Q3.u32[0] << 32) | _Q2.u32[0] | v29.i64[1];
}

unint64_t PDAdarkenPDA(float16x4_t a1, __n128 a2, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float16x4_t a17, float a18)
{
  a6.f32[0] = a18;
  a1.i16[1] = a2.n128_u16[0];
  a1.i16[2] = a3.n128_u16[0];
  a1.i16[3] = a4.n128_u16[0];
  float32x4_t v16 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a5.f32, 0), vcvtq_f32_f16(a1));
  _Q1 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a6.f32, 0), vcvtq_f32_f16(a17));
  float32x4_t v18 = vmulq_n_f32(v16, a18);
  _Q3 = vmulq_n_f32(_Q1, a5.f32[0]);
  _Q2 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v18, _Q3), (int8x16_t)_Q3, (int8x16_t)v18);
  _Q3.i32[0] = 1.0;
  float32x4_t v21 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a6, _Q3)), 0), (int8x16_t)vmlaq_n_f32(_Q2, v16, 1.0 - a18), (int8x16_t)_Q2);
  float32x4_t v22 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_f32(a5, _Q3)), 0), (int8x16_t)vmlaq_n_f32(v21, _Q1, 1.0 - a5.f32[0]), (int8x16_t)v21);
  _Q1.f32[0] = (float)(a5.f32[0] + a18) - (float)(a5.f32[0] * a18);
  _Q2.f32[0] = _Q1.f32[0] - v22.f32[0];
  __asm { FCVT            H2, S2 }
  _Q3.f32[0] = _Q1.f32[0] - v22.f32[2];
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S1
  }
  v22.i32[0] = vextq_s8(*(int8x16_t *)&v22, *(int8x16_t *)&v22, 8uLL).i32[1];
  *(float32x2_t *)v22.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q1.f32, 0), *(float32x2_t *)v22.f32);
  v22.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v22)).u64[0];
  v28.i64[0] = v22.u32[0];
  v28.i64[1] = v22.u32[1];
  _Q1.i64[0] = 0xFFFFLL;
  _Q1.i64[1] = 0xFFFFLL;
  uint64x2_t v29 = vshlq_u64((uint64x2_t)vandq_s8(v28, (int8x16_t)_Q1), (uint64x2_t)xmmword_1850CDC30);
  return v29.i64[0] | ((unint64_t)_Q3.u32[0] << 32) | _Q2.u32[0] | v29.i64[1];
}

unint64_t PDAcolordodgePDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H17 = a19;
  _H7 = a18;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  float v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  float v28 = a5 - _S0;
  __asm
  {
    FCVT            S18, H2
    FCVT            S0, H16
  }
  float v31 = a21 - _S0;
  __asm { FCVT            S19, H7 }
  float v33 = a21 * a21;
  float v34 = 0.0;
  float v35 = 0.0;
  if (v26 != 0.0)
  {
    if (v31 == a21) {
      float v35 = 1.0;
    }
    else {
      float v35 = (float)(v26 * v33) / (float)(a21 - v31);
    }
  }
  _H20 = a20;
  __asm
  {
    FCVT            S21, H3
    FCVT            S22, H17
  }
  float v39 = a5 - _S18;
  float v40 = a21 - _S19;
  if (v28 != 0.0)
  {
    if (v40 == a21) {
      float v34 = 1.0;
    }
    else {
      float v34 = (float)(v28 * v33) / (float)(a21 - v40);
    }
  }
  __asm { FCVT            S23, H20 }
  float v42 = a5 - _S21;
  float v43 = a21 - _S22;
  float v44 = 0.0;
  float v45 = 0.0;
  if (v39 != 0.0)
  {
    if (v43 == a21) {
      float v45 = 1.0;
    }
    else {
      float v45 = (float)(v39 * v33) / (float)(a21 - v43);
    }
  }
  float v46 = a21 - _S23;
  if (v42 != 0.0)
  {
    if (v46 == a21) {
      float v44 = 1.0;
    }
    else {
      float v44 = (float)(v42 * v33) / (float)(a21 - v46);
    }
  }
  float v47 = v35 + (float)(v26 * (float)(1.0 - a21));
  float v48 = v34 + (float)(v28 * (float)(1.0 - a21));
  float v49 = v45 + (float)(v39 * (float)(1.0 - a21));
  float v50 = v44 + (float)(v42 * (float)(1.0 - a21));
  if (a21 == 1.0)
  {
    float v47 = v35;
    float v48 = v34;
    float v51 = v45;
  }
  else
  {
    float v51 = v49;
  }
  if (a21 == 1.0) {
    float v52 = v44;
  }
  else {
    float v52 = v50;
  }
  float v53 = v47 + (float)(v31 * (float)(1.0 - a5));
  float v54 = v48 + (float)(v40 * (float)(1.0 - a5));
  if (a5 == 1.0) {
    float v53 = v47;
  }
  else {
    float v48 = v54;
  }
  if (a5 == 1.0)
  {
    float v55 = v52;
  }
  else
  {
    float v51 = v51 + (float)(v43 * (float)(1.0 - a5));
    float v55 = v52 + (float)(v46 * (float)(1.0 - a5));
  }
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  if (v53 > _S4) {
    float v53 = _S4;
  }
  if (v48 > _S4) {
    float v48 = _S4;
  }
  if (v51 > _S4) {
    float v51 = _S4;
  }
  if (v55 > _S4) {
    float v55 = _S4;
  }
  *(float *)&_S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - v48;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - v51;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v55;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t PDAcolorburnPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a20;
  _H21 = a19;
  _H18 = a18;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  float v27 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  float v29 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  float v31 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  float v33 = a5 - _S0;
  __asm
  {
    FCVT            S16, H16
    FCVT            S18, H18
    FCVT            S23, H21
    FCVT            S24, H6
  }
  float v38 = a5 * a21;
  float v39 = a5 * a21;
  float v40 = a5 * a21;
  float v41 = a5 * a21;
  float v42 = a5 * a21;
  if (a21 != 1.0)
  {
    float v39 = v38 + (float)(v27 * (float)(1.0 - a21));
    float v40 = v38 + (float)(v29 * (float)(1.0 - a21));
    float v41 = v38 + (float)(v31 * (float)(1.0 - a21));
    float v42 = v38 + (float)(v33 * (float)(1.0 - a21));
  }
  float v43 = a21 - _S16;
  float v44 = a21 - _S18;
  float v45 = a21 - _S23;
  float v46 = a21 - _S24;
  if (a5 != 1.0)
  {
    float v39 = v39 + (float)(v43 * (float)(1.0 - a5));
    float v40 = v40 + (float)(v44 * (float)(1.0 - a5));
    float v41 = v41 + (float)(v45 * (float)(1.0 - a5));
    float v42 = v42 + (float)(v46 * (float)(1.0 - a5));
  }
  float v47 = a5 - v27;
  if (v47 != 0.0)
  {
    if (v43 == 0.0 || (float v39 = v39 - (float)((float)((float)(a21 * a21) * v47) / v43), v39 < 0.0)) {
      float v39 = 0.0;
    }
  }
  float v48 = a5 - v29;
  if (v48 != 0.0)
  {
    if (v44 == 0.0 || (float v40 = v40 - (float)((float)((float)(a21 * a21) * v48) / v44), v40 < 0.0)) {
      float v40 = 0.0;
    }
  }
  float v49 = a5 - v31;
  if (v49 != 0.0)
  {
    if (v45 == 0.0 || (float v41 = v41 - (float)((float)((float)(a21 * a21) * v49) / v45), v41 < 0.0)) {
      float v41 = 0.0;
    }
  }
  float v50 = a5 - v33;
  if (v50 != 0.0)
  {
    if (v46 == 0.0 || (float v42 = v42 - (float)((float)((float)(a21 * a21) * v50) / v46), v42 < 0.0)) {
      float v42 = 0.0;
    }
  }
  _S0 = (float)(a5 + a21) - v38;
  *(float *)&_S1 = _S0 - v39;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S0 - v40;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S0 - v41;
  __asm { FCVT            H3, S3 }
  *(float *)&_S4 = _S0 - v42;
  __asm
  {
    FCVT            H4, S4
    FCVT            H0, S0
  }
  return ((unint64_t)_S3 << 32) | ((unint64_t)_S4 << 48) | ((unint64_t)_S2 << 16) | _S1;
}

unint64_t PDAhardlightPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  float v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  float v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  float v31 = a5 - _S2;
  __asm { FCVT            S3, H3 }
  float v33 = a5 - _S3;
  __asm { FCVT            S17, H17 }
  float v35 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  float v37 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  float v39 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  float v41 = a21 - _S6;
  float v42 = (float)(v27 * v35) + (float)(v27 * v35);
  float v43 = (float)(v29 * v37) + (float)(v29 * v37);
  float v44 = (float)(v31 * v39) + (float)(v31 * v39);
  float v45 = (float)(v33 * v41) + (float)(v33 * v41);
  float v46 = a5 * a21;
  float v47 = a21 * 0.5;
  float v48 = 1.0 - a21;
  float v49 = 1.0 - a5;
  float v50 = (float)((float)((float)(1.0 - a5) * v35) + (float)(v27 * (float)(1.0 - a21))) + v42;
  float v51 = a21 + 1.0;
  float v52 = a5 + 1.0;
  float v53 = (float)((float)((float)((float)(a5 + 1.0) * v35) + (float)(v27 * (float)(a21 + 1.0))) - v42) - (float)(a5 * a21);
  if (v35 <= (float)(a21 * 0.5)) {
    float v53 = v50;
  }
  float v54 = (float)((float)(v49 * v37) + (float)(v29 * v48)) + v43;
  float v55 = (float)((float)((float)(v52 * v37) + (float)(v29 * v51)) - v43) - v46;
  if (v37 <= v47) {
    float v55 = v54;
  }
  float v56 = (float)((float)(v49 * v39) + (float)(v31 * v48)) + v44;
  float v57 = (float)((float)((float)(v52 * v39) + (float)(v31 * v51)) - v44) - v46;
  if (v39 <= v47) {
    float v57 = v56;
  }
  float v58 = (float)((float)(v49 * v41) + (float)(v33 * v48)) + v45;
  float v59 = (float)((float)((float)(v52 * v41) + (float)(v33 * v51)) - v45) - v46;
  if (v41 <= v47) {
    float v59 = v58;
  }
  _S4 = (float)(a5 + a21) - v46;
  *(float *)&_S0 = _S4 - v53;
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - v55;
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - v57;
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - v59;
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t PDAsoftlightPDA(float16x4_t a1, __n128 a2, __n128 _Q2, __n128 _Q3, double a5, int32x2_t a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int32 a17, __int16 a18, __int16 a19, float a20)
{
  *(float *)a6.unint64_t i32 = a20;
  _H7 = a19;
  _H6 = a18;
  v18.i32[0] = a17;
  __asm { FCVT            S2, H2 }
  float v26 = *(float *)&a5 - _S2;
  __asm { FCVT            S3, H3 }
  float v28 = *(float *)&a5 - _S3;
  a1.i16[1] = a2.n128_u16[0];
  float32x2_t v29 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
  float32x2_t v30 = vsub_f32(v29, (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a1));
  _Q0 = vcvtq_f32_f16(v18);
  float32x2_t v31 = (float32x2_t)vdup_lane_s32(a6, 0);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v31, *(float32x2_t *)_Q0.f32);
  __asm { FCVT            S6, H6 }
  float v34 = a20 - _S6;
  __asm { FCVT            S7, H7 }
  float v36 = a20 - _S7;
  if (*(float *)&a5 == 0.0)
  {
    double v39 = 0.0;
    float v40 = 0.0;
    float v41 = 0.0;
  }
  else
  {
    float32x2_t v37 = vmul_f32(v30, *(float32x2_t *)_Q0.f32);
    float32x2_t v38 = vsub_f32(vadd_f32(v37, v37), vdiv_f32(vmul_f32(vmul_f32(v30, v30), vsub_f32(vadd_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)_Q0.f32), v31)), v29));
    double v39 = COERCE_DOUBLE(vbic_s8((int8x8_t)v38, (int8x8_t)vcltz_f32(v38)));
    float v40 = (float)((float)(v26 * v34) + (float)(v26 * v34))
        - (float)((float)((float)(v26 * v26) * (float)((float)(v34 + v34) - a20)) / *(float *)&a5);
    float v41 = 0.0;
    if (v40 < 0.0) {
      float v40 = 0.0;
    }
    if ((float)((float)((float)(v28 * v36) + (float)(v28 * v36))
               - (float)((float)((float)(v28 * v28) * (float)((float)(v36 + v36) - a20)) / *(float *)&a5)) >= 0.0)
      float v41 = (float)((float)(v28 * v36) + (float)(v28 * v36))
          - (float)((float)((float)(v28 * v28) * (float)((float)(v36 + v36) - a20)) / *(float *)&a5);
  }
  double v42 = COERCE_DOUBLE(vmla_n_f32(*(float32x2_t *)&v39, v30, 1.0 - a20));
  float v43 = v40 + (float)(v26 * (float)(1.0 - a20));
  float v44 = v41 + (float)(v28 * (float)(1.0 - a20));
  if (a20 == 1.0) {
    float v45 = v40;
  }
  else {
    float v45 = v43;
  }
  if (a20 == 1.0)
  {
    float v44 = v41;
    double v46 = v39;
  }
  else
  {
    double v46 = v42;
  }
  if (*(float *)&a5 != 1.0)
  {
    double v46 = COERCE_DOUBLE(vmla_n_f32(*(float32x2_t *)&v46, *(float32x2_t *)_Q0.f32, 1.0 - *(float *)&a5));
    float v45 = v45 + (float)(v34 * (float)(1.0 - *(float *)&a5));
    float v44 = v44 + (float)(v36 * (float)(1.0 - *(float *)&a5));
  }
  _Q0.f32[0] = (float)(*(float *)&a5 + a20) - (float)(*(float *)&a5 * a20);
  *(float *)&_S4 = _Q0.f32[0] - *(float *)&v46;
  __asm { FCVT            H4, S4 }
  *(float *)&_S3 = _Q0.f32[0] - v45;
  __asm
  {
    FCVT            H3, S3
    FCVT            H5, S0
  }
  *(float *)&double v46 = v44;
  *(float32x2_t *)_Q0.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q0.f32, 0), *(float32x2_t *)&v46);
  unint64_t v50 = vmovl_u16((uint16x4_t)vcvt_f16_f32(_Q0)).u64[0];
  v51.i64[0] = v50;
  v51.i64[1] = HIDWORD(v50);
  v52.i64[0] = 0xFFFFLL;
  v52.i64[1] = 0xFFFFLL;
  uint64x2_t v53 = vshlq_u64((uint64x2_t)vandq_s8(v51, v52), (uint64x2_t)xmmword_1850CDC30);
  return v53.i64[0] | ((unint64_t)_S3 << 32) | _S4 | v53.i64[1];
}

uint64_t PDAdifferencePDA(__n128 _Q0, __n128 a2, __n128 _Q2, float16x4_t a4, double a5, int32x2_t a6, float16x4_t a7, double _D7, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  a7.i16[0] = a20;
  _H7 = a19;
  *(float *)a6.unint64_t i32 = a21;
  _H16 = a17;
  __asm { FCVT            S0, H0 }
  float v28 = *(float *)&a5 - _S0;
  __asm { FCVT            S2, H2 }
  float v30 = *(float *)&a5 - _S2;
  __asm { FCVT            S16, H16 }
  float v32 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  float v34 = a21 - _S7;
  float v35 = v28 + v32;
  float v36 = v28 * a21;
  float v37 = v32 * *(float *)&a5;
  float v38 = v35 - v36;
  float v39 = v36 - v37;
  float v40 = v38 - v37;
  if (v39 < 0.0) {
    float v39 = -v39;
  }
  float v41 = v40 + v39;
  float v42 = v30 + v34;
  float v43 = v30 * a21;
  float v44 = v34 * *(float *)&a5;
  float v45 = v42 - v43;
  float v46 = v43 - v44;
  *(float *)&_D7 = v45 - v44;
  if (v46 < 0.0) {
    float v46 = -v46;
  }
  float v47 = *(float *)&_D7 + v46;
  *(float *)&_D7 = (float)(*(float *)&a5 + a21) - (float)(*(float *)&a5 * a21);
  *(float *)&_S0 = *(float *)&_D7 - v41;
  __asm { FCVT            H0, S0 }
  *(float *)&_S2 = *(float *)&_D7 - v47;
  __asm
  {
    FCVT            H2, S2
    FCVT            H16, S7
  }
  uint64_t v51 = _S0;
  a4.i16[1] = a2.n128_u16[0];
  uint64_t v52 = _S2;
  float32x4_t v53 = vcvtq_f32_f16(a4);
  *(float32x2_t *)v53.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), *(float32x2_t *)v53.f32);
  a7.i16[1] = a18;
  float32x2_t v54 = vsub_f32((float32x2_t)vdup_lane_s32(a6, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a7));
  float32x2_t v55 = vadd_f32(*(float32x2_t *)v53.f32, v54);
  *(float32x2_t *)v53.f32 = vmul_n_f32(*(float32x2_t *)v53.f32, a21);
  float32x2_t v56 = vmul_n_f32(v54, *(float *)&a5);
  float32x2_t v57 = vsub_f32(v55, *(float32x2_t *)v53.f32);
  *(float32x2_t *)v53.f32 = vsub_f32(*(float32x2_t *)v53.f32, v56);
  *(float32x2_t *)v53.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&_D7, 0), vadd_f32(vsub_f32(v57, v56), (float32x2_t)vbsl_s8((int8x8_t)vcltz_f32(*(float32x2_t *)v53.f32), (int8x8_t)vneg_f32(*(float32x2_t *)v53.f32), *(int8x8_t *)v53.f32)));
  v53.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v53)).u64[0];
  v58.i64[0] = v53.u32[0];
  v58.i64[1] = v53.u32[1];
  v59.i64[0] = 0xFFFFLL;
  v59.i64[1] = 0xFFFFLL;
  uint64x2_t v60 = vshlq_u64((uint64x2_t)vandq_s8(v58, v59), (uint64x2_t)xmmword_1850CDC30);
  return v60.i64[0] | (v52 << 32) | v51 | v60.i64[1];
}

unint64_t PDAexclusionPDA(__n128 _Q0, __n128 a2, __n128 _Q2, float16x4_t a4, double a5, float16x4_t a6, double _D6, int32x2_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  a6.i16[0] = a20;
  LOWORD(_D6) = a19;
  *(float *)a8.unint64_t i32 = a21;
  _H16 = a17;
  __asm
  {
    FCVT            S0, H0
    FCVT            S2, H2
    FCVT            S16, H16
    FCVT            S6, H6
  }
  float v29 = (float)((float)(*(float *)&a5 - _S2) + (float)(a21 - *(float *)&_D6))
      + (float)((float)((float)(a21 - *(float *)&_D6) * (float)(*(float *)&a5 - _S2)) * -2.0);
  *(float *)&_D6 = (float)(*(float *)&a5 + a21) - (float)(*(float *)&a5 * a21);
  *(float *)&_S0 = *(float *)&_D6
                 - (float)((float)((float)(*(float *)&a5 - _S0) + (float)(a21 - _S16))
                         + (float)((float)((float)(a21 - _S16) * (float)(*(float *)&a5 - _S0)) * -2.0));
  __asm { FCVT            H0, S0 }
  *(float *)&_S2 = *(float *)&_D6 - v29;
  __asm
  {
    FCVT            H2, S2
    FCVT            H16, S6
  }
  uint64_t v32 = _S0;
  a4.i16[1] = a2.n128_u16[0];
  float32x4_t v33 = vcvtq_f32_f16(a4);
  *(float32x2_t *)v33.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0), *(float32x2_t *)v33.f32);
  a6.i16[1] = a18;
  float32x2_t v34 = vsub_f32((float32x2_t)vdup_lane_s32(a8, 0), (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(a6));
  *(float32x2_t *)v33.f32 = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&_D6, 0), vmla_f32(vadd_f32(*(float32x2_t *)v33.f32, v34), (float32x2_t)0xC0000000C0000000, vmul_f32(v34, *(float32x2_t *)v33.f32)));
  v33.i64[0] = vmovl_u16((uint16x4_t)vcvt_f16_f32(v33)).u64[0];
  v35.i64[0] = v33.u32[0];
  v35.i64[1] = v33.u32[1];
  v36.i64[0] = 0xFFFFLL;
  v36.i64[1] = 0xFFFFLL;
  uint64x2_t v37 = vshlq_u64((uint64x2_t)vandq_s8(v35, v36), (uint64x2_t)xmmword_1850CDC30);
  return v37.i64[0] | ((unint64_t)_S2 << 32) | v32 | v37.i64[1];
}

unint64_t PDAhuePDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a19;
  _H7 = a18;
  _H16 = a17;
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  __asm { FCVT            S0, H0 }
  float v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  float v28 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  float v30 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  float v32 = a5 - _S0;
  __asm { FCVT            S1, H16 }
  float v34 = a21 - _S1;
  __asm { FCVT            S1, H7 }
  float v36 = a21 - _S1;
  __asm { FCVT            S1, H6 }
  float v38 = a21 - _S1;
  float v39 = 0.0;
  float v40 = v26 - (float)(v26 * a21);
  float v41 = v28 * a21;
  float v42 = v28 - (float)(v28 * a21);
  float v43 = v30 * a21;
  float v44 = v30 - (float)(v30 * a21);
  float v45 = v32 - (float)(v32 * a21);
  if (a21 == 1.0) {
    float v40 = 0.0;
  }
  else {
    float v32 = v32 * a21;
  }
  if (a21 == 1.0)
  {
    float v42 = 0.0;
    float v44 = 0.0;
    float v43 = v30;
  }
  else
  {
    float v39 = v45;
  }
  if (a21 == 1.0) {
    float v41 = v28;
  }
  else {
    float v26 = v26 * a21;
  }
  if (a5 != 1.0)
  {
    _H21 = a20;
    __asm { FCVT            S21, H21 }
    float v48 = v34 + v40;
    float v34 = v34 * a5;
    float v40 = v48 - v34;
    float v49 = v36 + v42;
    float v36 = v36 * a5;
    float v42 = v49 - v36;
    float v50 = v38 + v44;
    float v38 = v38 * a5;
    float v44 = v50 - v38;
    float v39 = (float)((float)(a21 - _S21) + v39) - (float)((float)(a21 - _S21) * a5);
  }
  float v67 = v34;
  float v68 = v36;
  float v69 = v38;
  uint64_t v51 = v34 < v36;
  BOOL v52 = v34 >= v36;
  if (v38 >= *(&v67 + v52))
  {
    uint64_t v53 = v34 >= v36;
    if (v38 > *(&v67 + v51))
    {
      BOOL v52 = v34 < v36;
      uint64_t v51 = 2;
    }
  }
  else
  {
    uint64_t v53 = 2;
  }
  float v54 = *(&v67 + v51);
  float v55 = *(&v67 + v53);
  if (v54 <= v55)
  {
    *(&v67 + v51) = 0.0;
    *(&v67 + v52) = 0.0;
  }
  else
  {
    if (v26 >= v41) {
      float v56 = v41;
    }
    else {
      float v56 = v26;
    }
    if (v26 >= v41) {
      float v57 = v26;
    }
    else {
      float v57 = v41;
    }
    if (v43 > v57) {
      float v58 = v43;
    }
    else {
      float v58 = v57;
    }
    if (v43 >= v56) {
      float v57 = v58;
    }
    else {
      float v56 = v43;
    }
    float v59 = v57 - v56;
    *(&v67 + v51) = v59;
    *(&v67 + v52) = (float)(v59 / (float)(v54 - v55)) * (float)(*(&v67 + v52) - *(&v67 + v53));
  }
  *(&v67 + v53) = 0.0;
  float v60 = (float)((float)((float)(v41 - v68) * 0.59) + (float)((float)(v26 - v67) * 0.3))
      + (float)((float)(v43 - v69) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  *(float *)&_S1 = _S4 - (float)(v40 + (float)(v67 + v60));
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - (float)(v42 + (float)(v68 + v60));
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - (float)(v44 + (float)(v69 + v60));
  __asm { FCVT            H3, S3 }
  *(float *)&_S0 = _S4 - (float)(v32 + v39);
  __asm
  {
    FCVT            H0, S0
    FCVT            H4, S4
  }
  return ((unint64_t)_S0 << 48) | ((unint64_t)_S3 << 32) | ((unint64_t)_S2 << 16) | _S1;
}

unint64_t PDAsaturationPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a19;
  _H7 = a18;
  _H16 = a17;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  __asm { FCVT            S0, H0 }
  float v26 = a5 - _S0;
  __asm { FCVT            S0, H1 }
  float v28 = a5 - _S0;
  __asm { FCVT            S0, H2 }
  float v30 = a5 - _S0;
  __asm { FCVT            S0, H3 }
  float v32 = a5 - _S0;
  __asm { FCVT            S1, H16 }
  float v34 = a21 - _S1;
  __asm { FCVT            S1, H7 }
  float v36 = a21 - _S1;
  __asm { FCVT            S1, H6 }
  float v38 = a21 - _S1;
  float v39 = 0.0;
  float v40 = v26 - (float)(v26 * a21);
  float v41 = v28 * a21;
  float v42 = v28 - (float)(v28 * a21);
  float v43 = v30 * a21;
  float v44 = v30 - (float)(v30 * a21);
  float v45 = v32 - (float)(v32 * a21);
  if (a21 == 1.0) {
    float v40 = 0.0;
  }
  else {
    float v32 = v32 * a21;
  }
  if (a21 == 1.0)
  {
    float v42 = 0.0;
    float v44 = 0.0;
    float v43 = v30;
  }
  else
  {
    float v39 = v45;
  }
  if (a21 == 1.0) {
    float v41 = v28;
  }
  else {
    float v26 = v26 * a21;
  }
  if (a5 != 1.0)
  {
    _H21 = a20;
    __asm { FCVT            S21, H21 }
    float v48 = v34 + v40;
    float v34 = v34 * a5;
    float v40 = v48 - v34;
    float v49 = v36 + v42;
    float v36 = v36 * a5;
    float v42 = v49 - v36;
    float v50 = v38 + v44;
    float v38 = v38 * a5;
    float v44 = v50 - v38;
    float v39 = (float)((float)(a21 - _S21) + v39) - (float)((float)(a21 - _S21) * a5);
  }
  float v66 = v26;
  float v67 = v41;
  float v68 = v43;
  uint64_t v51 = v26 < v41;
  BOOL v52 = v26 >= v41;
  if (v43 >= *(&v66 + v52))
  {
    uint64_t v53 = v26 >= v41;
    if (v43 > *(&v66 + v51))
    {
      BOOL v52 = v26 < v41;
      uint64_t v51 = 2;
    }
  }
  else
  {
    uint64_t v53 = 2;
  }
  float v54 = *(&v66 + v51);
  float v55 = *(&v66 + v53);
  if (v54 <= v55)
  {
    *(&v66 + v51) = 0.0;
    *(&v66 + v52) = 0.0;
  }
  else
  {
    if (v34 >= v36) {
      float v56 = v36;
    }
    else {
      float v56 = v34;
    }
    if (v34 < v36) {
      float v34 = v36;
    }
    if (v38 > v34) {
      float v57 = v38;
    }
    else {
      float v57 = v34;
    }
    if (v38 >= v56)
    {
      float v38 = v56;
      float v34 = v57;
    }
    float v58 = v34 - v38;
    *(&v66 + v51) = v58;
    *(&v66 + v52) = (float)(v58 / (float)(v54 - v55)) * (float)(*(&v66 + v52) - *(&v66 + v53));
  }
  *(&v66 + v53) = 0.0;
  float v59 = (float)((float)((float)(v41 - v67) * 0.59) + (float)((float)(v26 - v66) * 0.3))
      + (float)((float)(v43 - v68) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  *(float *)&_S1 = _S4 - (float)(v40 + (float)(v66 + v59));
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - (float)(v42 + (float)(v67 + v59));
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - (float)(v44 + (float)(v68 + v59));
  __asm { FCVT            H3, S3 }
  *(float *)&_S0 = _S4 - (float)(v32 + v39);
  __asm
  {
    FCVT            H0, S0
    FCVT            H4, S4
  }
  return ((unint64_t)_S0 << 48) | ((unint64_t)_S3 << 32) | ((unint64_t)_S2 << 16) | _S1;
}

unint64_t PDAluminosityPDA(__n128 _Q0, __n128 _Q1, __n128 _Q2, __n128 _Q3, float a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int16 a17, __int16 a18, __int16 a19, __int16 a20,float a21)
{
  _H6 = a20;
  _H7 = a19;
  _H16 = a18;
  _H17 = a17;
  __asm { FCVT            S0, H0 }
  float v27 = a5 - _S0;
  __asm { FCVT            S1, H1 }
  float v29 = a5 - _S1;
  __asm { FCVT            S2, H2 }
  float v31 = a5 - _S2;
  __asm { FCVT            S17, H17 }
  float v33 = a21 - _S17;
  __asm { FCVT            S16, H16 }
  float v35 = a21 - _S16;
  __asm { FCVT            S7, H7 }
  float v37 = a21 - _S7;
  __asm { FCVT            S6, H6 }
  float v39 = a21 - _S6;
  __asm { FCVT            S3, H3 }
  float v41 = v27 - (float)(v27 * a21);
  float v42 = v29 - (float)(v29 * a21);
  float v43 = v31 - (float)(v31 * a21);
  float v44 = (float)(a5 - _S3) - (float)((float)(a5 - _S3) * a21);
  if (_ZF)
  {
    float v41 = 0.0;
    float v42 = 0.0;
    float v43 = 0.0;
    float v44 = 0.0;
  }
  else
  {
    float v31 = v31 * a21;
    float v29 = v29 * a21;
    float v27 = v27 * a21;
  }
  float v45 = (float)(v33 + v41) - (float)(v33 * a5);
  float v46 = (float)(v35 + v42) - (float)(v35 * a5);
  float v47 = (float)(v37 + v43) - (float)(v37 * a5);
  float v48 = (float)(v39 + v44) - (float)(v39 * a5);
  if (a5 == 1.0)
  {
    float v45 = v41;
    float v49 = v42;
  }
  else
  {
    float v33 = v33 * a5;
    float v35 = v35 * a5;
    float v37 = v37 * a5;
    float v39 = v39 * a5;
    float v49 = v46;
  }
  if (a5 == 1.0) {
    float v50 = v43;
  }
  else {
    float v50 = v47;
  }
  if (a5 != 1.0) {
    float v44 = v48;
  }
  float v51 = (float)((float)((float)(v35 - v29) * 0.59) + (float)((float)(v33 - v27) * 0.3))
      + (float)((float)(v37 - v31) * 0.11);
  _S4 = (float)(a5 + a21) - (float)(a5 * a21);
  *(float *)&_S0 = _S4 - (float)(v45 + (float)(v27 + v51));
  __asm { FCVT            H0, S0 }
  *(float *)&_S1 = _S4 - (float)(v49 + (float)(v29 + v51));
  __asm { FCVT            H1, S1 }
  *(float *)&_S2 = _S4 - (float)(v50 + (float)(v31 + v51));
  __asm { FCVT            H2, S2 }
  *(float *)&_S3 = _S4 - (float)(v39 + v44);
  __asm
  {
    FCVT            H3, S3
    FCVT            H4, S4
  }
  return ((unint64_t)_S2 << 32) | ((unint64_t)_S3 << 48) | ((unint64_t)_S1 << 16) | _S0;
}

unint64_t CMYKf16_mark_constmask(unint64_t result, uint64_t a2, double a3, int32x4_t _Q1, double a5, __n128 a6, float32x4_t _Q4, float32x4_t _Q5, double _D6, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16 = *(void *)(result + 48);
  uint64_t v17 = *(void *)(result + 136);
  float16x4_t v18 = *(short float **)(result + 96);
  if (v18) {
    _H1 = *v18;
  }
  else {
    LOWORD(_H1) = COERCE_UNSIGNED_INT(1.0);
  }
  uint64_t v21 = *(int *)(result + 12);
  uint64_t v20 = *(int *)(result + 16);
  if (v16)
  {
    unint64_t v22 = (unint64_t)*(int *)(result + 32) >> 1;
    uint64_t v23 = (short float *)(v16 + 2 * (v21 + v22 * v20));
    uint64_t v24 = 1;
    if (!v17) {
      return result;
    }
  }
  else
  {
    uint64_t v23 = 0;
    unint64_t v22 = 0;
    uint64_t v24 = 0;
    if (!v17) {
      return result;
    }
  }
  int v25 = *(_DWORD *)(result + 4);
  uint64_t v26 = v22 - v25;
  if (v16) {
    unint64_t v27 = v22 - v25;
  }
  else {
    unint64_t v27 = v22;
  }
  int v28 = *(_DWORD *)(result + 8);
  unint64_t v29 = (unint64_t)*(int *)(result + 28) >> 3;
  _Q0.i64[0] = **(void **)(result + 88);
  __asm { FCVT            S8, H1 }
  float v36 = (float16x4_t *)(*(void *)(result + 40) + 8 * (v21 + v29 * v20));
  uint64_t v37 = *(int *)(result + 124);
  unint64_t v38 = v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v37;
  uint64_t v39 = v37 - v25;
  unint64_t v542 = v29 - v25;
  switch((int)a2)
  {
    case 0:
      if (v16)
      {
        uint64_t v40 = 2 * v24;
        do
        {
          int v41 = v25;
          do
          {
            int v42 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              if (v42 == 255)
              {
                *float v36 = 0;
                _H1 = 0;
              }
              else
              {
                float v44 = (float)(v42 ^ 0xFFu) * 0.0039216;
                *float v36 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v44));
                _H2 = *v23;
                __asm { FCVT            S2, H2 }
                _S1 = v44 * _S2;
                __asm { FCVT            H1, S1 }
              }
              *(_WORD *)uint64_t v23 = _H1;
            }
            ++v38;
            ++v36;
            uint64_t v23 = (short float *)((char *)v23 + v40);
            --v41;
          }
          while (v41);
          v38 += v39;
          v36 += v542;
          v23 += v27;
          --v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v351 = v25;
          do
          {
            int v352 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              if (v352 == 255) {
                *float v36 = 0;
              }
              else {
                *float v36 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), (float)(v352 ^ 0xFFu) * 0.0039216));
              }
            }
            ++v38;
            ++v36;
            --v351;
          }
          while (v351);
          v38 += v39;
          v36 += v542;
          --v28;
        }
        while (v28);
      }
      return result;
    case 1:
      unsigned int v48 = v38 & 3;
      if (!v16)
      {
        int v353 = -1 << (8 * v48);
        if ((v38 & 3) != 0) {
          char v354 = v38 & 0xFC;
        }
        else {
          char v354 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v37;
        }
        if ((v38 & 3) != 0)
        {
          uint64_t v355 = (unsigned int *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v353 = -1;
          uint64_t v355 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v37);
        }
        if ((v38 & 3) != 0) {
          unint64_t v356 = &v36[-(v38 & 3)];
        }
        else {
          unint64_t v356 = v36;
        }
        if ((v38 & 3) != 0) {
          int v357 = v48 + v25;
        }
        else {
          int v357 = *(_DWORD *)(result + 4);
        }
        if ((((_BYTE)v357 + v354) & 3) != 0)
        {
          int v358 = 4 - (((_BYTE)v357 + v354) & 3);
          v48 += v358;
          unsigned int v359 = 0xFFFFFFFF >> (8 * v358);
          if (v357 >= 4) {
            unsigned int v360 = v359;
          }
          else {
            unsigned int v360 = 0;
          }
          if (v357 >= 4) {
            unsigned int v359 = -1;
          }
          v353 &= v359;
        }
        else
        {
          unsigned int v360 = 0;
        }
        uint64_t v466 = v39 - v48;
        int v467 = v357 >> 2;
        float32x4_t v468 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
        unint64_t v469 = v542 - v48;
        while (1)
        {
          unsigned int v470 = *v355 & v353;
          int v471 = v467;
          unsigned int v472 = v360;
          if (!v470) {
            goto LABEL_532;
          }
LABEL_514:
          if (v470 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v470)
            {
              float16x4_t v473 = *(float16x4_t *)_Q0.i8;
              if (v470 != 255) {
                float16x4_t v473 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v468, (float)v470 * 0.0039216))), vcvtq_f32_f16(*v356), 1.0 - (float)((float)v470 * 0.0039216)));
              }
              *unint64_t v356 = v473;
            }
            if (BYTE1(v470))
            {
              float16x4_t v474 = *(float16x4_t *)_Q0.i8;
              if (BYTE1(v470) != 255) {
                float16x4_t v474 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v468, (float)BYTE1(v470) * 0.0039216))), vcvtq_f32_f16(v356[1]), 1.0 - (float)((float)BYTE1(v470) * 0.0039216)));
              }
              v356[1] = v474;
            }
            double result = BYTE2(v470);
            if (BYTE2(v470))
            {
              float16x4_t v475 = *(float16x4_t *)_Q0.i8;
              if (BYTE2(v470) != 255) {
                float16x4_t v475 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v468, (float)BYTE2(v470) * 0.0039216))), vcvtq_f32_f16(v356[2]), 1.0 - (float)((float)BYTE2(v470) * 0.0039216)));
              }
              v356[2] = v475;
            }
            unsigned int v476 = HIBYTE(v470);
            if (v476 == 255) {
              goto LABEL_529;
            }
            if (v476) {
              v356[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v468, (float)v476 * 0.0039216))), vcvtq_f32_f16(v356[3]), 1.0 - (float)((float)v476 * 0.0039216)));
            }
LABEL_532:
            while (1)
            {
              int v477 = v471;
              v356 += 4;
              --v471;
              ++v355;
              if (v477 < 2) {
                break;
              }
              unsigned int v470 = *v355;
              if (*v355) {
                goto LABEL_514;
              }
            }
            if (!v472) {
              break;
            }
            unsigned int v472 = 0;
            unsigned int v470 = *v355 & v360;
          }
          uint64_t v355 = (unsigned int *)((char *)v355 + v466);
          v356 += v469;
          if (!--v28) {
            return result;
          }
        }
        *unint64_t v356 = *(float16x4_t *)_Q0.i8;
        v356[1] = *(float16x4_t *)_Q0.i8;
        v356[2] = *(float16x4_t *)_Q0.i8;
LABEL_529:
        v356[3] = *(float16x4_t *)_Q0.i8;
        goto LABEL_532;
      }
      int v49 = -1 << (8 * v48);
      float v50 = &v36[-(v38 & 3)];
      if ((v38 & 3) != 0) {
        char v51 = v38 & 0xFC;
      }
      else {
        char v51 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v37;
      }
      if ((v38 & 3) != 0)
      {
        BOOL v52 = (unsigned int *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v49 = -1;
        BOOL v52 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v37);
      }
      if ((v38 & 3) != 0) {
        uint64_t v53 = &v23[-(v38 & 3)];
      }
      else {
        uint64_t v53 = v23;
      }
      if ((v38 & 3) != 0)
      {
        int v54 = v48 + v25;
      }
      else
      {
        float v50 = v36;
        int v54 = *(_DWORD *)(result + 4);
      }
      if ((((_BYTE)v54 + v51) & 3) != 0)
      {
        int v55 = 4 - (((_BYTE)v54 + v51) & 3);
        v48 += v55;
        unsigned int v56 = 0xFFFFFFFF >> (8 * v55);
        if (v54 >= 4) {
          unsigned int v57 = v56;
        }
        else {
          unsigned int v57 = 0;
        }
        if (v54 >= 4) {
          unsigned int v56 = -1;
        }
        v49 &= v56;
      }
      else
      {
        unsigned int v57 = 0;
      }
      uint64_t v391 = v39 - v48;
      unint64_t v392 = v542 - v48;
      int v393 = v54 >> 2;
      float32x4_t v394 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v395 = v26 - v48;
      do
      {
        unsigned int v396 = *v52 & v49;
        LODWORD(result) = v393;
        unsigned int v397 = v57;
        if (!v396) {
          goto LABEL_483;
        }
LABEL_462:
        if (v396 == -1)
        {
          float16x4_t *v50 = *(float16x4_t *)_Q0.i8;
          short float *v53 = _H1;
          v50[1] = *(float16x4_t *)_Q0.i8;
          v53[1] = _H1;
          v50[2] = *(float16x4_t *)_Q0.i8;
          v53[2] = _H1;
LABEL_480:
          v50[3] = *(float16x4_t *)_Q0.i8;
          v53[3] = _H1;
          goto LABEL_483;
        }
        while (1)
        {
          if ((_BYTE)v396)
          {
            if (v396 == 255)
            {
              float16x4_t *v50 = *(float16x4_t *)_Q0.i8;
              _H5 = _H1;
            }
            else
            {
              float v399 = (float)v396 * 0.0039216;
              _S6 = v399 * _S8;
              __asm { FCVT            H6, S6 }
              float v401 = 1.0 - v399;
              float16x4_t *v50 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v394, v399))), vcvtq_f32_f16(*v50), 1.0 - v399));
              __asm { FCVT            S5, H6 }
              *(short float *)&_S6 = *v53;
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v401);
              __asm { FCVT            H5, S5 }
            }
            short float *v53 = _H5;
          }
          if (BYTE1(v396))
          {
            if (BYTE1(v396) == 255)
            {
              v50[1] = *(float16x4_t *)_Q0.i8;
              _H5 = _H1;
            }
            else
            {
              float v406 = (float)BYTE1(v396) * 0.0039216;
              _S6 = v406 * _S8;
              __asm { FCVT            H6, S6 }
              float v408 = 1.0 - v406;
              v50[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v394, v406))), vcvtq_f32_f16(v50[1]), 1.0 - v406));
              __asm { FCVT            S5, H6 }
              *(short float *)&_S6 = v53[1];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v408);
              __asm { FCVT            H5, S5 }
            }
            v53[1] = _H5;
          }
          if (BYTE2(v396))
          {
            if (BYTE2(v396) == 255)
            {
              v50[2] = *(float16x4_t *)_Q0.i8;
              _H5 = _H1;
            }
            else
            {
              float v413 = (float)BYTE2(v396) * 0.0039216;
              _S6 = v413 * _S8;
              __asm { FCVT            H6, S6 }
              float v415 = 1.0 - v413;
              v50[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v394, v413))), vcvtq_f32_f16(v50[2]), 1.0 - v413));
              __asm { FCVT            S5, H6 }
              *(short float *)&_S6 = v53[2];
              __asm { FCVT            S6, H6 }
              _S5 = _S5 + (float)(_S6 * v415);
              __asm { FCVT            H5, S5 }
            }
            v53[2] = _H5;
          }
          unsigned int v419 = HIBYTE(v396);
          if (v419 == 255) {
            goto LABEL_480;
          }
          if (v419)
          {
            float v420 = (float)v419 * 0.0039216;
            _S6 = v420 * _S8;
            __asm { FCVT            H6, S6 }
            float v422 = 1.0 - v420;
            v50[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v394, v420))), vcvtq_f32_f16(v50[3]), 1.0 - v420));
            __asm { FCVT            S5, H6 }
            *(short float *)&_S6 = v53[3];
            __asm { FCVT            S6, H6 }
            _S5 = _S5 + (float)(_S6 * v422);
            __asm { FCVT            H5, S5 }
            v53[3] = *(short float *)&_S5;
          }
LABEL_483:
          while (1)
          {
            int v426 = result;
            v50 += 4;
            v53 += 4;
            double result = (result - 1);
            ++v52;
            if (v426 < 2) {
              break;
            }
            unsigned int v396 = *v52;
            if (*v52) {
              goto LABEL_462;
            }
          }
          if (!v397) {
            break;
          }
          unsigned int v397 = 0;
          unsigned int v396 = *v52 & v57;
        }
        BOOL v52 = (unsigned int *)((char *)v52 + v391);
        v50 += v392;
        v53 += v395;
        --v28;
      }
      while (v28);
      return result;
    case 2:
      *(float *)_Q1.unint64_t i32 = 1.0 - _S8;
      unsigned int v58 = v38 & 3;
      if (v16)
      {
        int v59 = -1 << (8 * v58);
        float v60 = &v36[-(v38 & 3)];
        if ((v38 & 3) != 0) {
          char v61 = v38 & 0xFC;
        }
        else {
          char v61 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v37;
        }
        if ((v38 & 3) != 0)
        {
          unint64_t v62 = (unsigned int *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v59 = -1;
          unint64_t v62 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v37);
        }
        if ((v38 & 3) != 0) {
          unint64_t v63 = &v23[-(v38 & 3)];
        }
        else {
          unint64_t v63 = v23;
        }
        if ((v38 & 3) != 0)
        {
          int v64 = v58 + v25;
        }
        else
        {
          float v60 = v36;
          int v64 = *(_DWORD *)(result + 4);
        }
        if ((((_BYTE)v64 + v61) & 3) != 0)
        {
          int v65 = 4 - (((_BYTE)v64 + v61) & 3);
          v58 += v65;
          unsigned int v66 = 0xFFFFFFFF >> (8 * v65);
          if (v64 >= 4) {
            unsigned int v67 = v66;
          }
          else {
            unsigned int v67 = 0;
          }
          if (v64 >= 4) {
            unsigned int v66 = -1;
          }
          v59 &= v66;
        }
        else
        {
          unsigned int v67 = 0;
        }
        uint64_t v427 = v39 - v58;
        unint64_t v428 = v542 - v58;
        int v429 = v64 >> 2;
        float32x4_t v430 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
        float32x4_t v431 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
        uint64_t v432 = v26 - v58;
        while (1)
        {
          unsigned int v433 = *v62 & v59;
          LODWORD(result) = v429;
          unsigned int v434 = v67;
          if (!v433) {
            goto LABEL_504;
          }
LABEL_493:
          if (v433 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v433)
            {
              _S5 = (float)v433 * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              float16x4_t *v60 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v430, _S5))), vcvtq_f32_f16(*v60), 1.0 - _S6));
              *(short float *)&_S5 = *v63;
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              *unint64_t v63 = *(short float *)&_S5;
            }
            if ((v433 & 0xFF00) != 0)
            {
              _S5 = (float)BYTE1(v433) * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v60[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v430, _S5))), vcvtq_f32_f16(v60[1]), 1.0 - _S6));
              *(short float *)&_S5 = v63[1];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              v63[1] = *(short float *)&_S5;
            }
            if ((v433 & 0xFF0000) != 0)
            {
              _S5 = (float)BYTE2(v433) * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v60[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v430, _S5))), vcvtq_f32_f16(v60[2]), 1.0 - _S6));
              *(short float *)&_S5 = v63[2];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              __asm { FCVT            H5, S5 }
              v63[2] = *(short float *)&_S5;
            }
            unsigned int v459 = HIBYTE(v433);
            if (v459)
            {
              _S5 = (float)v459 * 0.0039216;
              _S6 = _S5 * _S8;
              __asm
              {
                FCVT            H6, S6
                FCVT            S6, H6
              }
              v60[3] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v430, _S5))), vcvtq_f32_f16(v60[3]), 1.0 - _S6));
              *(short float *)&_S5 = v63[3];
              __asm { FCVT            S5, H5 }
              _S5 = _S6 + (float)(_S5 * (float)(1.0 - _S6));
              goto LABEL_503;
            }
LABEL_504:
            while (1)
            {
              int v465 = result;
              v60 += 4;
              v63 += 4;
              double result = (result - 1);
              ++v62;
              if (v465 < 2) {
                break;
              }
              unsigned int v433 = *v62;
              if (*v62) {
                goto LABEL_493;
              }
            }
            if (!v434) {
              break;
            }
            unsigned int v434 = 0;
            unsigned int v433 = *v62 & v67;
          }
          unint64_t v62 = (unsigned int *)((char *)v62 + v427);
          v60 += v428;
          v63 += v432;
          if (!--v28) {
            return result;
          }
        }
        float16x4_t *v60 = vcvt_f16_f32(vmlaq_f32(v430, v431, vcvtq_f32_f16(*v60)));
        _H5 = *(_WORD *)v63;
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        *unint64_t v63 = *(short float *)&_S5;
        v60[1] = vcvt_f16_f32(vmlaq_f32(v430, v431, vcvtq_f32_f16(v60[1])));
        *(short float *)&_S5 = v63[1];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        v63[1] = *(short float *)&_S5;
        v60[2] = vcvt_f16_f32(vmlaq_f32(v430, v431, vcvtq_f32_f16(v60[2])));
        *(short float *)&_S5 = v63[2];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
        __asm { FCVT            H5, S5 }
        v63[2] = *(short float *)&_S5;
        v60[3] = vcvt_f16_f32(vmlaq_f32(v430, v431, vcvtq_f32_f16(v60[3])));
        *(short float *)&_S5 = v63[3];
        __asm { FCVT            S5, H5 }
        _S5 = _S8 + (float)(_S5 * *(float *)_Q1.i32);
LABEL_503:
        __asm { FCVT            H5, S5 }
        *((_WORD *)v63 + 3) = _H5;
        goto LABEL_504;
      }
      int v361 = -1 << (8 * v58);
      if ((v38 & 3) != 0) {
        char v362 = v38 & 0xFC;
      }
      else {
        char v362 = v17 + *(_DWORD *)(result + 104) + *(_DWORD *)(result + 108) * v37;
      }
      if ((v38 & 3) != 0)
      {
        uint64_t v363 = (unsigned int *)(v38 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v361 = -1;
        uint64_t v363 = (unsigned int *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v37);
      }
      if ((v38 & 3) != 0) {
        uint64_t v364 = &v36[-(v38 & 3)];
      }
      else {
        uint64_t v364 = v36;
      }
      if ((v38 & 3) != 0) {
        int v365 = v58 + v25;
      }
      else {
        int v365 = *(_DWORD *)(result + 4);
      }
      if ((((_BYTE)v365 + v362) & 3) != 0)
      {
        int v366 = 4 - (((_BYTE)v365 + v362) & 3);
        v58 += v366;
        unsigned int v367 = 0xFFFFFFFF >> (8 * v366);
        if (v365 >= 4) {
          unsigned int v368 = v367;
        }
        else {
          unsigned int v368 = 0;
        }
        if (v365 >= 4) {
          unsigned int v367 = -1;
        }
        v361 &= v367;
      }
      else
      {
        unsigned int v368 = 0;
      }
      uint64_t v478 = v39 - v58;
      unint64_t v479 = v542 - v58;
      int v480 = v365 >> 2;
      float32x4_t v481 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      float32x4_t v482 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
      while (1)
      {
        unsigned int v483 = *v363 & v361;
        int v484 = v480;
        unsigned int v485 = v368;
        if (!v483) {
          goto LABEL_553;
        }
LABEL_542:
        if (v483 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v483)
          {
            double result = v483;
            float v495 = (float)v483 * 0.0039216;
            _S17 = v495 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            *uint64_t v364 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v481, v495))), vcvtq_f32_f16(*v364), 1.0 - _S17));
          }
          if ((v483 & 0xFF00) != 0)
          {
            double result = BYTE1(v483);
            float v498 = (float)BYTE1(v483) * 0.0039216;
            _S17 = v498 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            v364[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v481, v498))), vcvtq_f32_f16(v364[1]), 1.0 - _S17));
          }
          if ((v483 & 0xFF0000) != 0)
          {
            double result = BYTE2(v483);
            float v501 = (float)BYTE2(v483) * 0.0039216;
            _S17 = v501 * _S8;
            __asm
            {
              FCVT            H17, S17
              FCVT            S17, H17
            }
            v364[2] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v481, v501))), vcvtq_f32_f16(v364[2]), 1.0 - _S17));
          }
          unsigned int v504 = HIBYTE(v483);
          if (v504)
          {
            float v505 = (float)v504 * 0.0039216;
            _S17 = v505 * v481.f32[0];
            __asm { FCVT            H17, S17 }
            _S18 = v505 * v481.f32[1];
            __asm { FCVT            H18, S18 }
            _S19 = v505 * v481.f32[2];
            __asm { FCVT            H19, S19 }
            _S20 = v505 * v481.f32[3];
            __asm { FCVT            H20, S20 }
            _S16 = v505 * _S8;
            __asm
            {
              FCVT            H16, S16
              FCVT            S17, H17
            }
            _H21 = v364[3].i16[0];
            __asm
            {
              FCVT            S21, H21
              FCVT            S16, H16
            }
            float v515 = 1.0 - _S16;
            _S17 = _S17 + (float)(_S21 * v515);
            __asm { FCVT            H17, S17 }
            v364[3].i16[0] = LOWORD(_S17);
            __asm { FCVT            S17, H18 }
            LOWORD(_S18) = v364[3].i16[1];
            __asm { FCVT            S18, H18 }
            _S17 = _S17 + (float)(_S18 * v515);
            __asm { FCVT            H17, S17 }
            v364[3].i16[1] = LOWORD(_S17);
            __asm { FCVT            S17, H19 }
            LOWORD(_S18) = v364[3].i16[2];
            __asm { FCVT            S18, H18 }
            _S17 = _S17 + (float)(_S18 * v515);
            __asm { FCVT            H17, S17 }
            v364[3].i16[2] = LOWORD(_S17);
            __asm { FCVT            S17, H20 }
            LOWORD(_S18) = v364[3].i16[3];
            __asm { FCVT            S18, H18 }
            _S16 = _S17 + (float)(_S18 * v515);
            goto LABEL_552;
          }
LABEL_553:
          while (1)
          {
            int v526 = v484;
            v364 += 4;
            --v484;
            ++v363;
            if (v526 < 2) {
              break;
            }
            unsigned int v483 = *v363;
            if (*v363) {
              goto LABEL_542;
            }
          }
          if (!v485) {
            break;
          }
          unsigned int v485 = 0;
          unsigned int v483 = *v363 & v368;
        }
        uint64_t v363 = (unsigned int *)((char *)v363 + v478);
        v364 += v479;
        if (!--v28) {
          return result;
        }
      }
      *(float16x8_t *)v364->unint64_t i8 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_f32(v481, v482, vcvtq_f32_f16(*v364))), vmlaq_f32(v481, v482, vcvt_hight_f32_f16(*(float16x8_t *)v364->i8)));
      v364[2] = vcvt_f16_f32(vmlaq_f32(v481, v482, vcvtq_f32_f16(v364[2])));
      _H16 = v364[3].i16[0];
      __asm { FCVT            S16, H16 }
      _S16 = v481.f32[0] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v364[3].i16[0] = LOWORD(_S16);
      LOWORD(_S16) = v364[3].i16[1];
      __asm { FCVT            S16, H16 }
      _S16 = v481.f32[1] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v364[3].i16[1] = LOWORD(_S16);
      LOWORD(_S16) = v364[3].i16[2];
      __asm { FCVT            S16, H16 }
      _S16 = v481.f32[2] + (float)(_S16 * *(float *)_Q1.i32);
      __asm { FCVT            H16, S16 }
      v364[3].i16[2] = LOWORD(_S16);
      LOWORD(_S16) = v364[3].i16[3];
      __asm { FCVT            S16, H16 }
      _S16 = v481.f32[3] + (float)(_S16 * *(float *)_Q1.i32);
LABEL_552:
      __asm { FCVT            H16, S16 }
      v364[3].i16[3] = _H16;
      goto LABEL_553;
    case 3:
      float32x4_t v68 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v69 = 2 * v24;
      do
      {
        int v70 = v25;
        do
        {
          unsigned int v71 = *(unsigned __int8 *)v38;
          if (*(unsigned char *)v38)
          {
            if (v71 == 255)
            {
              _H5 = _H1 * *v23;
              *float v36 = vmul_n_f16(*(float16x4_t *)_Q0.i8, *v23);
            }
            else
            {
              float v73 = (float)v71 * 0.0039216;
              _H6 = *v23;
              __asm { FCVT            S6, H6 }
              float v76 = v73 * _S6;
              _S16 = (float)(v73 * _S6) * _S8;
              __asm { FCVT            H16, S16 }
              float v78 = 1.0 - v73;
              *float v36 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v68, v76))), vcvtq_f32_f16(*v36), v78));
              __asm { FCVT            S7, H16 }
              _S5 = _S7 + (float)(_S6 * v78);
              __asm { FCVT            H5, S5 }
            }
            *uint64_t v23 = _H5;
          }
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v69);
          --v70;
        }
        while (v70);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        --v28;
      }
      while (v28);
      return result;
    case 4:
      float32x4_t v81 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v82 = 2 * v24;
      do
      {
        int v83 = v25;
        do
        {
          unsigned int v84 = *(unsigned __int8 *)v38;
          if (*(unsigned char *)v38)
          {
            if (v84 == 255)
            {
              _H3 = *v23;
              __asm { FCVT            S3, H3 }
              float v87 = 1.0 - _S3;
              _S3 = (float)(1.0 - _S3) * _S8;
              *float v36 = vcvt_f16_f32(vmulq_n_f32(v81, v87));
            }
            else
            {
              float v89 = (float)v84 * 0.0039216;
              _H4 = *v23;
              __asm { FCVT            S4, H4 }
              float v92 = v89 * (float)(1.0 - _S4);
              _S6 = v92 * _S8;
              __asm { FCVT            H6, S6 }
              float v94 = 1.0 - v89;
              *float v36 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v81, v92))), vcvtq_f32_f16(*v36), v94));
              __asm { FCVT            S5, H6 }
              _S3 = _S5 + (float)(_S4 * v94);
            }
            __asm { FCVT            H3, S3 }
            *(_WORD *)uint64_t v23 = _H3;
          }
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v82);
          --v83;
        }
        while (v83);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        --v28;
      }
      while (v28);
      return result;
    case 5:
      float32x4_t v97 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v98 = 2 * v24;
      do
      {
        int v99 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            _H3 = *v23;
            __asm { FCVT            S3, H3 }
            float v102 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _S5 = v102 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            *float v36 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), 1.0 - _S5), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v97, v102))), _S3));
            _S3 = (float)((float)(1.0 - _S5) * _S3) + (float)(_S5 * _S3);
            __asm { FCVT            H3, S3 }
            *uint64_t v23 = *(short float *)&_S3;
          }
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v98);
          --v99;
        }
        while (v99);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        --v28;
      }
      while (v28);
      return result;
    case 6:
      float32x4_t v106 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v107 = 2 * v24;
      while (1)
      {
        int v108 = v25;
        do
        {
          unsigned int v109 = *(unsigned __int8 *)v38;
          if (!*(unsigned char *)v38) {
            goto LABEL_98;
          }
          _H3 = *v23;
          __asm { FCVT            S3, H3 }
          float v112 = 1.0 - _S3;
          if ((float)(1.0 - _S3) >= 1.0)
          {
            float v117 = (float)v109 * 0.0039216;
            _S3 = v117 * _S8;
            *float v36 = vcvt_f16_f32(vmulq_n_f32(v106, v117));
          }
          else
          {
            if (v112 <= 0.0) {
              goto LABEL_98;
            }
            float v113 = (float)v109 * 0.0039216;
            _S6 = v113 * _S8;
            __asm { FCVT            H6, S6 }
            *float v36 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v36), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v106, v113))), v112));
            __asm { FCVT            S5, H6 }
            _S3 = _S3 + (float)(_S5 * v112);
          }
          __asm { FCVT            H3, S3 }
          *(_WORD *)uint64_t v23 = _H3;
LABEL_98:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v107);
          --v108;
        }
        while (v108);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 7:
      if (v16)
      {
        uint64_t v119 = 2 * v24;
        do
        {
          int v120 = v25;
          do
          {
            unsigned int v121 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              if (v121 == 255)
              {
                *float v36 = vmul_n_f16(*v36, _H1);
                _H3 = _H1 * *v23;
              }
              else
              {
                float v123 = (float)((float)((float)v121 * 0.0039216) * _S8) + (float)(1.0 - (float)((float)v121 * 0.0039216));
                *float v36 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v123));
                _H4 = *v23;
                __asm { FCVT            S4, H4 }
                _S3 = v123 * _S4;
                __asm { FCVT            H3, S3 }
              }
              *uint64_t v23 = _H3;
            }
            ++v38;
            ++v36;
            uint64_t v23 = (short float *)((char *)v23 + v119);
            --v120;
          }
          while (v120);
          v38 += v39;
          v36 += v542;
          v23 += v27;
          --v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v369 = v25;
          do
          {
            unsigned int v370 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              if (v370 == 255) {
                float16x4_t v371 = vmul_n_f16(*v36, _H1);
              }
              else {
                float16x4_t v371 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), (float)((float)((float)v370 * 0.0039216) * _S8)+ (float)(1.0 - (float)((float)v370 * 0.0039216))));
              }
              *float v36 = v371;
            }
            ++v38;
            ++v36;
            --v369;
          }
          while (v369);
          v38 += v39;
          v36 += v542;
          --v28;
        }
        while (v28);
      }
      return result;
    case 8:
      float v127 = 1.0 - _S8;
      if (v16)
      {
        uint64_t v128 = 2 * v24;
        do
        {
          int v129 = v25;
          do
          {
            unsigned int v130 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              _H3 = v36->i16[0];
              if (v130 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S4 = v127 * _S3;
                float v134 = 1.0 - _S8;
              }
              else
              {
                __asm { FCVT            S4, H3 }
                float v134 = (float)((float)((float)v130 * -0.0039216) * _S8) + 1.0;
                _S4 = v134 * _S4;
              }
              __asm { FCVT            H4, S4 }
              v36->i16[0] = _H4;
              _H4 = v36->i16[1];
              __asm { FCVT            S4, H4 }
              _S4 = v134 * _S4;
              __asm { FCVT            H4, S4 }
              v36->i16[1] = LOWORD(_S4);
              LOWORD(_S4) = v36->i16[2];
              __asm { FCVT            S4, H4 }
              _S4 = v134 * _S4;
              __asm { FCVT            H4, S4 }
              v36->i16[2] = LOWORD(_S4);
              LOWORD(_S4) = v36->i16[3];
              __asm { FCVT            S4, H4 }
              _S4 = v134 * _S4;
              __asm { FCVT            H4, S4 }
              v36->i16[3] = LOWORD(_S4);
              *(short float *)&_S4 = *v23;
              __asm { FCVT            S4, H4 }
              _S3 = v134 * _S4;
              __asm { FCVT            H3, S3 }
              *uint64_t v23 = *(short float *)&_S3;
            }
            ++v38;
            ++v36;
            uint64_t v23 = (short float *)((char *)v23 + v128);
            --v129;
          }
          while (v129);
          v38 += v39;
          v36 += v542;
          v23 += v27;
          --v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v372 = v25;
          do
          {
            unsigned int v373 = *(unsigned __int8 *)v38;
            if (*(unsigned char *)v38)
            {
              _H3 = v36->i16[0];
              if (v373 == 255)
              {
                __asm { FCVT            S3, H3 }
                _S4 = v127 * _S3;
                float v377 = 1.0 - _S8;
              }
              else
              {
                __asm { FCVT            S4, H3 }
                float v377 = (float)((float)((float)v373 * -0.0039216) * _S8) + 1.0;
                _S4 = v377 * _S4;
              }
              __asm { FCVT            H4, S4 }
              v36->i16[0] = _H4;
              _H4 = v36->i16[1];
              __asm { FCVT            S4, H4 }
              _S4 = v377 * _S4;
              __asm { FCVT            H4, S4 }
              v36->i16[1] = LOWORD(_S4);
              LOWORD(_S4) = v36->i16[2];
              __asm { FCVT            S4, H4 }
              _S4 = v377 * _S4;
              __asm { FCVT            H4, S4 }
              v36->i16[2] = LOWORD(_S4);
              LOWORD(_S4) = v36->i16[3];
              __asm { FCVT            S4, H4 }
              _S3 = v377 * _S4;
              __asm { FCVT            H3, S3 }
              v36->i16[3] = LOWORD(_S3);
            }
            ++v38;
            ++v36;
            --v372;
          }
          while (v372);
          v38 += v39;
          v36 += v542;
          --v28;
        }
        while (v28);
      }
      return result;
    case 9:
      float32x4_t v146 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v147 = 2 * v24;
      do
      {
        int v148 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v149 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _H4 = *v23;
            __asm { FCVT            S4, H4 }
            _S5 = v149 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            float v154 = (float)(1.0 - v149) + _S5;
            *float v36 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), v154), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v146, v149))), 1.0 - _S4));
            _S3 = (float)(v154 * _S4) + (float)(_S5 * (float)(1.0 - _S4));
            __asm { FCVT            H3, S3 }
            *uint64_t v23 = *(short float *)&_S3;
          }
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v147);
          --v148;
        }
        while (v148);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        --v28;
      }
      while (v28);
      return result;
    case 10:
      float32x4_t v156 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v157 = 2 * v24;
      do
      {
        int v158 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            _H3 = *v23;
            __asm { FCVT            S3, H3 }
            float v161 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _S5 = v161 * _S8;
            __asm
            {
              FCVT            H5, S5
              FCVT            S5, H5
            }
            *float v36 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*v36), 1.0 - _S5), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v156, v161))), 1.0 - _S3));
            _S3 = (float)((float)(1.0 - _S5) * _S3) + (float)(_S5 * (float)(1.0 - _S3));
            __asm { FCVT            H3, S3 }
            *uint64_t v23 = *(short float *)&_S3;
          }
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v157);
          --v158;
        }
        while (v158);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        --v28;
      }
      while (v28);
      return result;
    case 11:
      float32x4_t v165 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      if (v16)
      {
        uint64_t v166 = 2 * v24;
        do
        {
          int v167 = v25;
          do
          {
            if (*(unsigned char *)v38)
            {
              float v168 = (float)*(unsigned __int8 *)v38 * 0.0039216;
              _S7 = v168 * v165.f32[0];
              __asm { FCVT            H7, S7 }
              _S16 = v168 * v165.f32[1];
              __asm { FCVT            H16, S16 }
              _S17 = v168 * v165.f32[2];
              __asm { FCVT            H17, S17 }
              _S18 = v168 * v165.f32[3];
              __asm { FCVT            H18, S18 }
              _S6 = v168 * _S8;
              __asm { FCVT            H6, S6 }
              _H19 = *v23;
              __asm
              {
                FCVT            S19, H19
                FCVT            S6, H6
              }
              _S20 = _S6 + _S19;
              _H21 = v36->i16[0];
              __asm
              {
                FCVT            S21, H21
                FCVT            S7, H7
              }
              float v184 = (float)(_S6 - _S7) + (float)(_S19 - _S21);
              if ((float)(_S6 + _S19) > 1.0) {
                _S20 = 1.0;
              }
              _H21 = v36->i16[1];
              __asm
              {
                FCVT            S21, H21
                FCVT            S16, H16
              }
              float v188 = (float)(_S6 - _S16) + (float)(_S19 - _S21);
              _S7 = _S20 - v184;
              __asm { FCVT            H7, S7 }
              v36->i16[0] = LOWORD(_S7);
              *(short float *)&_S7 = *v23;
              __asm { FCVT            S7, H7 }
              _H19 = v36->i16[2];
              __asm
              {
                FCVT            S19, H19
                FCVT            S17, H17
              }
              float v194 = (float)(_S6 - _S17) + (float)(_S7 - _S19);
              _S16 = _S20 - v188;
              __asm { FCVT            H16, S16 }
              v36->i16[1] = LOWORD(_S16);
              *(short float *)&_S16 = *v23;
              __asm { FCVT            S16, H16 }
              LOWORD(_S17) = v36->i16[3];
              __asm { FCVT            S17, H17 }
              float v198 = _S16 - _S17;
              __asm { FCVT            S17, H18 }
              _S7 = _S20 - v194;
              __asm { FCVT            H7, S7 }
              v36->i16[2] = LOWORD(_S7);
              __asm { FCVT            H7, S20 }
              *uint64_t v23 = *(short float *)&_S7;
              _S6 = _S20 - (float)((float)(_S6 - _S17) + v198);
              __asm { FCVT            H6, S6 }
              v36->i16[3] = LOWORD(_S6);
            }
            ++v38;
            ++v36;
            uint64_t v23 = (short float *)((char *)v23 + v166);
            --v167;
          }
          while (v167);
          v38 += v39;
          v36 += v542;
          v23 += v27;
          --v28;
        }
        while (v28);
      }
      else
      {
        __asm { FMOV            V2.4S, #1.0 }
        do
        {
          int v388 = v25;
          do
          {
            if (*(unsigned char *)v38)
            {
              float v389 = (float)*(unsigned __int8 *)v38 * 0.0039216;
              _Q4.f32[0] = v389 * _S8;
              __asm
              {
                FCVT            H4, S4
                FCVT            S4, H4
              }
              _Q4 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q4.f32, 0);
              *float v36 = vcvt_f16_f32(vsubq_f32(_Q2, vaddq_f32(vsubq_f32(_Q4, vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(v165, v389)))), vsubq_f32(_Q2, vcvtq_f32_f16(*v36)))));
            }
            ++v38;
            ++v36;
            --v388;
          }
          while (v388);
          v38 += v39;
          v36 += v542;
          --v28;
        }
        while (v28);
      }
      return result;
    case 12:
      float32x4_t v202 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      if (v16)
      {
        uint64_t v203 = 2 * v24;
        do
        {
          int v204 = v25;
          do
          {
            if (*(unsigned char *)v38)
            {
              float v205 = (float)*(unsigned __int8 *)v38 * 0.0039216;
              _S4 = v205 * _S8;
              __asm { FCVT            H4, S4 }
              _H5 = *v23;
              __asm
              {
                FCVT            S5, H5
                FCVT            S4, H4
              }
              _S4 = _S4 + _S5;
              if (_S4 > 1.0) {
                _S4 = 1.0;
              }
              __asm { FCVT            H4, S4 }
              v212.i32[0] = v36->i32[0];
              *(_WORD *)uint64_t v23 = _H4;
              v212.i32[1] = v36->i32[1];
              *float v36 = vadd_f16(v212, vcvt_f16_f32(vmulq_n_f32(v202, v205)));
            }
            ++v38;
            ++v36;
            uint64_t v23 = (short float *)((char *)v23 + v203);
            --v204;
          }
          while (v204);
          v38 += v39;
          v36 += v542;
          v23 += v27;
          --v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          int v390 = v25;
          do
          {
            if (*(unsigned char *)v38) {
              *float v36 = vadd_f16(*v36, vcvt_f16_f32(vmulq_n_f32(v202, (float)*(unsigned __int8 *)v38 * 0.0039216)));
            }
            ++v38;
            ++v36;
            --v390;
          }
          while (v390);
          v38 += v39;
          v36 += v542;
          --v28;
        }
        while (v28);
      }
      return result;
    case 13:
      float32x4_t v527 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v213 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v215 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v216 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v216 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v217 = (__n128)v527;
              __n128 v218 = (__n128)vmulq_n_f32(v527, v216);
              float16x4_t v219 = vcvt_f16_f32((float32x4_t)v218);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_167;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v218.n128_u16[0] = v36->u16[1];
              v217.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAmultiplyPDA(_Q0, v218, v217, a6, _S4, *(double *)&v219, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v219.i16[0], v219.i16[1], v219.i16[2],
                         v219.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v222.i32[0] = result;
              v222.i32[1] = WORD1(result);
              float16x4_t v219 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v222, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_167:
                *float v36 = v219;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_169;
              }
              *float v36 = v219;
            }
          }
LABEL_169:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v213);
          --v215;
        }
        while (v215);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 14:
      float32x4_t v528 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v223 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v225 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v226 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v226 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v227 = (__n128)v528;
              __n128 v228 = (__n128)vmulq_n_f32(v528, v226);
              float16x4_t v229 = vcvt_f16_f32((float32x4_t)v228);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_182;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v228.n128_u16[0] = v36->u16[1];
              v227.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAscreenPDA(_Q0, v228, v227, a6, _S4, *(double *)&v229, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v229.i16[0], v229.i16[1], v229.i16[2],
                         v229.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v232.i32[0] = result;
              v232.i32[1] = WORD1(result);
              float16x4_t v229 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v232, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_182:
                *float v36 = v229;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_184;
              }
              *float v36 = v229;
            }
          }
LABEL_184:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v223);
          --v225;
        }
        while (v225);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 15:
      float32x4_t v529 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v233 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v235 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v236 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v236 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v237 = (__n128)v529;
              __n128 v238 = (__n128)vmulq_n_f32(v529, v236);
              float16x4_t v239 = vcvt_f16_f32((float32x4_t)v238);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_197;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v238.n128_u16[0] = v36->u16[1];
              v237.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAoverlayPDA(_Q0, v238, v237, a6, _S4, *(double *)&v239, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v239.i16[0], v239.i16[1], v239.i16[2],
                         v239.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v242.i32[0] = result;
              v242.i32[1] = WORD1(result);
              float16x4_t v239 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v242, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_197:
                *float v36 = v239;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_199;
              }
              *float v36 = v239;
            }
          }
LABEL_199:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v233);
          --v235;
        }
        while (v235);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 16:
      float32x4_t v530 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v243 = 2 * v24;
      _Q0.i32[1] = -1;
      while (1)
      {
        int v244 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v245 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            *(float *)_Q0.unint64_t i32 = v245 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v246 = (__n128)v530;
              __n128 v247 = (__n128)vmulq_n_f32(v530, v245);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v247);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_212;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.i16[0] = v36->i16[0];
              v247.n128_u16[0] = v36->u16[1];
              v246.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAdarkenPDA(*(float16x4_t *)_Q0.i8, v247, v246, a6, _Q4, _Q5, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, *(float16x4_t *)_Q5.f32, *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v249.i32[0] = result;
              v249.i32[1] = WORD1(result);
              *(int16x4_t *)_Q5.f32 = vmovn_s32(vmovn_hight_s64(v249, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_212:
                *float v36 = *(float16x4_t *)_Q5.f32;
                *uint64_t v23 = *(short float *)_Q0.i16;
                goto LABEL_214;
              }
              *float v36 = *(float16x4_t *)_Q5.f32;
            }
          }
LABEL_214:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v243);
          --v244;
        }
        while (v244);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 17:
      float32x4_t v531 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v250 = 2 * v24;
      _Q0.i32[1] = -1;
      while (1)
      {
        int v251 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v252 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            *(float *)_Q0.unint64_t i32 = v252 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v253 = (__n128)v531;
              __n128 v254 = (__n128)vmulq_n_f32(v531, v252);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v254);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_227;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.i16[0] = v36->i16[0];
              v254.n128_u16[0] = v36->u16[1];
              v253.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAlightenPDA(*(float16x4_t *)_Q0.i8, v254, v253, a6, _Q4, _Q5, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, *(float16x4_t *)_Q5.f32, *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v256.i32[0] = result;
              v256.i32[1] = WORD1(result);
              *(int16x4_t *)_Q5.f32 = vmovn_s32(vmovn_hight_s64(v256, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_227:
                *float v36 = *(float16x4_t *)_Q5.f32;
                *uint64_t v23 = *(short float *)_Q0.i16;
                goto LABEL_229;
              }
              *float v36 = *(float16x4_t *)_Q5.f32;
            }
          }
LABEL_229:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v250);
          --v251;
        }
        while (v251);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 18:
      float32x4_t v532 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v257 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v259 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v260 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v260 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v261 = (__n128)v532;
              __n128 v262 = (__n128)vmulq_n_f32(v532, v260);
              float16x4_t v263 = vcvt_f16_f32((float32x4_t)v262);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_242;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v262.n128_u16[0] = v36->u16[1];
              v261.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAcolordodgePDA(_Q0, v262, v261, a6, _S4, *(double *)&v263, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v263.i16[0], v263.i16[1], v263.i16[2],
                         v263.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v266.i32[0] = result;
              v266.i32[1] = WORD1(result);
              float16x4_t v263 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v266, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_242:
                *float v36 = v263;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_244;
              }
              *float v36 = v263;
            }
          }
LABEL_244:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v257);
          --v259;
        }
        while (v259);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 19:
      float32x4_t v533 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v267 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v269 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v270 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v270 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v271 = (__n128)v533;
              __n128 v272 = (__n128)vmulq_n_f32(v533, v270);
              float16x4_t v273 = vcvt_f16_f32((float32x4_t)v272);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_257;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v272.n128_u16[0] = v36->u16[1];
              v271.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAcolorburnPDA(_Q0, v272, v271, a6, _S4, *(double *)&v273, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v273.i16[0], v273.i16[1], v273.i16[2],
                         v273.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v276.i32[0] = result;
              v276.i32[1] = WORD1(result);
              float16x4_t v273 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v276, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_257:
                *float v36 = v273;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_259;
              }
              *float v36 = v273;
            }
          }
LABEL_259:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v267);
          --v269;
        }
        while (v269);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 20:
      float32x4_t v534 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v277 = 2 * v24;
      _Q0.i32[1] = -1;
      while (1)
      {
        int v278 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v279 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            *(float *)_Q0.unint64_t i32 = v279 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v280 = (__n128)v534;
              __n128 v281 = (__n128)vmulq_n_f32(v534, v279);
              int32x2_t v282 = (int32x2_t)vcvt_f16_f32((float32x4_t)v281);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_272;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.i16[0] = v36->i16[0];
              v281.n128_u16[0] = v36->u16[1];
              v280.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAsoftlightPDA(*(float16x4_t *)_Q0.i8, v281, v280, a6, *(double *)_Q4.i64, v282, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v282.i32[0], v282.i16[2], v282.i16[3],
                         *(float *)&_D6);
              _Q0 = (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v284.i32[0] = result;
              v284.i32[1] = WORD1(result);
              int32x2_t v282 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v284, _Q0));
              if (v16)
              {
                _Q0.i16[0] = a2;
LABEL_272:
                *float v36 = (float16x4_t)v282;
                *uint64_t v23 = *(short float *)_Q0.i16;
                goto LABEL_274;
              }
              *float v36 = (float16x4_t)v282;
            }
          }
LABEL_274:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v277);
          --v278;
        }
        while (v278);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 21:
      float32x4_t v535 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v285 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v287 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v288 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v288 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v289 = (__n128)v535;
              __n128 v290 = (__n128)vmulq_n_f32(v535, v288);
              float16x4_t v291 = vcvt_f16_f32((float32x4_t)v290);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_287;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v290.n128_u16[0] = v36->u16[1];
              v289.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAhardlightPDA(_Q0, v290, v289, a6, _S4, *(double *)&v291, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v291.i16[0], v291.i16[1], v291.i16[2],
                         v291.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v294.i32[0] = result;
              v294.i32[1] = WORD1(result);
              float16x4_t v291 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v294, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_287:
                *float v36 = v291;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_289;
              }
              *float v36 = v291;
            }
          }
LABEL_289:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v285);
          --v287;
        }
        while (v287);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 22:
      float32x4_t v536 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v295 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v297 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v298 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v298 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v299 = (__n128)v536;
              __n128 v300 = (__n128)vmulq_n_f32(v536, v298);
              int32x2_t v301 = (int32x2_t)vcvt_f16_f32((float32x4_t)v300);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_302;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v300.n128_u16[0] = v36->u16[1];
              v299.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAdifferencePDA(_Q0, v300, v299, (float16x4_t)a6.n128_u64[0], *(double *)_Q4.i64, v301, *(float16x4_t *)&_D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v301.i16[0], v301.i16[1], v301.i16[2],
                         v301.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v303.i32[0] = result;
              v303.i32[1] = WORD1(result);
              int32x2_t v301 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v303, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_302:
                *float v36 = (float16x4_t)v301;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_304;
              }
              *float v36 = (float16x4_t)v301;
            }
          }
LABEL_304:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v295);
          --v297;
        }
        while (v297);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 23:
      float32x4_t v537 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v304 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v306 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v307 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v307 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v308 = (__n128)v537;
              __n128 v309 = (__n128)vmulq_n_f32(v537, v307);
              float16x4_t v310 = vcvt_f16_f32((float32x4_t)v309);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_317;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v309.n128_u16[0] = v36->u16[1];
              v308.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAexclusionPDA(_Q0, v309, v308, (float16x4_t)a6.n128_u64[0], *(double *)_Q4.i64, v310, _D6, *(int32x2_t *)&a10, result, a2, v26, a12, a13, a14, a15, a16, v310.i16[0], v310.i16[1], v310.i16[2],
                         v310.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v312.i32[0] = result;
              v312.i32[1] = WORD1(result);
              float16x4_t v310 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v312, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_317:
                *float v36 = v310;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_319;
              }
              *float v36 = v310;
            }
          }
LABEL_319:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v304);
          --v306;
        }
        while (v306);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 24:
      float32x4_t v538 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v313 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v315 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v316 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v316 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v317 = (__n128)v538;
              __n128 v318 = (__n128)vmulq_n_f32(v538, v316);
              float16x4_t v319 = vcvt_f16_f32((float32x4_t)v318);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_332;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v318.n128_u16[0] = v36->u16[1];
              v317.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAhuePDA(_Q0, v318, v317, a6, _S4, *(double *)&v319, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v319.i16[0], v319.i16[1], v319.i16[2],
                         v319.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v322.i32[0] = result;
              v322.i32[1] = WORD1(result);
              float16x4_t v319 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v322, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_332:
                *float v36 = v319;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_334;
              }
              *float v36 = v319;
            }
          }
LABEL_334:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v313);
          --v315;
        }
        while (v315);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 25:
      float32x4_t v539 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v323 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      while (1)
      {
        int v325 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v326 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            _Q0.n128_f32[0] = v326 * _S8;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v327 = (__n128)v539;
              __n128 v328 = (__n128)vmulq_n_f32(v539, v326);
              float16x4_t v329 = vcvt_f16_f32((float32x4_t)v328);
              if (v16)
              {
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_347;
                }
                __asm { FCVT            S4, H1 }
              }
              else
              {
                _S4 = 1.0;
              }
              __asm { FCVT            S6, H0 }
              _Q0.n128_u16[0] = v36->i16[0];
              v328.n128_u16[0] = v36->u16[1];
              v327.n128_u16[0] = v36->u16[2];
              a6.n128_u16[0] = v36->u16[3];
              double result = PDAsaturationPDA(_Q0, v328, v327, a6, _S4, *(double *)&v329, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v329.i16[0], v329.i16[1], v329.i16[2],
                         v329.i16[3],
                         *(float *)&_D6);
              _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
              v332.i32[0] = result;
              v332.i32[1] = WORD1(result);
              float16x4_t v329 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v332, (int64x2_t)_Q0));
              if (v16)
              {
                _Q0.n128_u16[0] = a2;
LABEL_347:
                *float v36 = v329;
                *uint64_t v23 = *(short float *)_Q0.n128_u16;
                goto LABEL_349;
              }
              *float v36 = v329;
            }
          }
LABEL_349:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v323);
          --v325;
        }
        while (v325);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 26:
      float32x4_t v540 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v333 = 2 * v24;
      while (1)
      {
        int v334 = v25;
        do
        {
          if (*(unsigned char *)v38)
          {
            float v335 = (float)*(unsigned __int8 *)v38 * 0.0039216;
            *(float *)_Q1.unint64_t i32 = v335 * _S8;
            __asm
            {
              FCVT            H1, S1
              FCMP            H1, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v336 = (__n128)v540;
              __n128 v337 = (__n128)vmulq_n_f32(v540, v335);
              v337.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v337);
              if (v16)
              {
                __asm { FCMP            H2, #0 }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_362;
                }
                __asm { FCVT            S5, H2 }
              }
              else
              {
                _Q5.i32[0] = 1.0;
              }
              __asm { FCVT            S4, H1 }
              _Q1.i16[0] = v337.n128_i16[1];
              a6.n128_u16[0] = v337.n128_u16[3];
              v336.n128_u16[0] = v337.n128_u16[2];
              double result = PDAluminosityPDA(v337, (__n128)_Q1, v336, a6, _S4, *(double *)_Q5.i64, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v36->i32[0], HIWORD(v36->i32[0]), v36->i32[1],
                         HIWORD(v36->i32[1]),
                         _Q5.f32[0]);
              v340.i32[0] = result;
              v340.i32[1] = WORD1(result);
              _Q1 = vmovn_hight_s64(v340, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40));
              v337.n128_u64[0] = (unint64_t)vmovn_s32(_Q1);
              if (v16)
              {
                _Q1.i16[0] = a2;
LABEL_362:
                *float v36 = (float16x4_t)v337.n128_u64[0];
                *uint64_t v23 = *(short float *)_Q1.i16;
                goto LABEL_364;
              }
              *float v36 = (float16x4_t)v337.n128_u64[0];
            }
          }
LABEL_364:
          ++v38;
          ++v36;
          uint64_t v23 = (short float *)((char *)v23 + v333);
          --v334;
        }
        while (v334);
        v38 += v39;
        v36 += v542;
        v23 += v27;
        if (!--v28) {
          return result;
        }
      }
    case 27:
      float32x4_t v541 = vcvtq_f32_f16(*(float16x4_t *)_Q0.i8);
      uint64_t v341 = 2 * v24;
      _Q0 = (__n128)xmmword_1850CDC40;
      break;
    default:
      return result;
  }
  do
  {
    int v343 = v25;
    do
    {
      if (*(unsigned char *)v38)
      {
        float v344 = (float)*(unsigned __int8 *)v38 * 0.0039216;
        _Q0.n128_f32[0] = v344 * _S8;
        __asm
        {
          FCVT            H0, S0
          FCMP            H0, #0
        }
        if (!(_NF ^ _VF | _ZF))
        {
          __n128 v345 = (__n128)v541;
          __n128 v346 = (__n128)vmulq_n_f32(v541, v344);
          float16x4_t v347 = vcvt_f16_f32((float32x4_t)v346);
          if (v16)
          {
            __asm { FCMP            H1, #0 }
            if (_NF ^ _VF | _ZF) {
              goto LABEL_377;
            }
            __asm { FCVT            S4, H1 }
          }
          else
          {
            _S4 = 1.0;
          }
          __asm { FCVT            S6, H0 }
          _Q0.n128_u16[0] = v36->i16[0];
          v346.n128_u16[0] = v36->u16[1];
          v345.n128_u16[0] = v36->u16[2];
          a6.n128_u16[0] = v36->u16[3];
          double result = PDAluminosityPDA(_Q0, v346, v345, a6, _S4, *(double *)&v347, _D6, a10, result, a2, v26, a12, a13, a14, a15, a16, v347.i16[0], v347.i16[1], v347.i16[2],
                     v347.i16[3],
                     *(float *)&_D6);
          _Q0 = (__n128)vshlq_u64((uint64x2_t)vdupq_n_s64(result), (uint64x2_t)xmmword_1850CDC40);
          v350.i32[0] = result;
          v350.i32[1] = WORD1(result);
          float16x4_t v347 = (float16x4_t)vmovn_s32(vmovn_hight_s64(v350, (int64x2_t)_Q0));
          if (v16)
          {
            _Q0.n128_u16[0] = a2;
LABEL_377:
            *float v36 = v347;
            *uint64_t v23 = *(short float *)_Q0.n128_u16;
            goto LABEL_379;
          }
          *float v36 = v347;
        }
      }
LABEL_379:
      ++v38;
      ++v36;
      uint64_t v23 = (short float *)((char *)v23 + v341);
      --v343;
    }
    while (v343);
    v38 += v39;
    v36 += v542;
    v23 += v27;
    --v28;
  }
  while (v28);
  return result;
}

unint64_t CMYKf16_mark_pixelmask(unint64_t result, uint64_t a2, __n128 _Q0, double a4, __n128 _Q2, __n128 _Q3, float32x4_t _Q4, float32x4_t _Q5, float16x4_t a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16 = *(void *)(result + 48);
  uint64_t v17 = *(void *)(result + 136);
  uint64_t v19 = *(int *)(result + 12);
  uint64_t v18 = *(int *)(result + 16);
  if (v16)
  {
    unint64_t v20 = (unint64_t)*(int *)(result + 32) >> 1;
    uint64_t v21 = (short float *)(v16 + 2 * (v19 + v20 * v18));
    uint64_t v22 = 0xFFFFFFFFLL;
    if (!v17) {
      return result;
    }
  }
  else
  {
    uint64_t v21 = 0;
    unint64_t v20 = 0;
    uint64_t v22 = 0;
    if (!v17) {
      return result;
    }
  }
  uint64_t v23 = *(unsigned int *)(result + 4);
  int v24 = *(_DWORD *)(result + 8);
  unint64_t v26 = *(void *)(result + 88);
  uint64_t v25 = *(void *)(result + 96);
  unint64_t v27 = (unint64_t)*(int *)(result + 28) >> 3;
  unint64_t v28 = *(void *)(result + 40) + 8 * (v19 + v27 * v18);
  uint64_t v29 = *(int *)(result + 124);
  float v30 = (unsigned char *)(v17 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v29);
  uint64_t v31 = *(int *)(result + 56);
  uint64_t v32 = *(int *)(result + 60);
  unint64_t v33 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v34 = *(_DWORD *)(result + 64);
    int v35 = *(_DWORD *)(result + 68);
    unint64_t v1012 = v33 >> 3;
    uint64_t v1013 = *(__int16 **)(result + 96);
    if (v25)
    {
      unint64_t v1010 = (unint64_t)*(int *)(result + 80) >> 1;
      uint64_t v25 = 1;
    }
    else
    {
      unint64_t v1010 = 0;
    }
    double result = v26 + 8 * v1012 * v35;
    v22 &= 1u;
    int v38 = 1;
    unint64_t v1014 = v26;
    unint64_t v36 = v26;
    goto LABEL_19;
  }
  unint64_t v1012 = v33 >> 3;
  if (v25)
  {
    unint64_t v1010 = (unint64_t)*(int *)(result + 80) >> 1;
    uint64_t v1013 = (__int16 *)(v25 + 2 * (v31 + v1010 * v32));
    uint64_t v25 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v1013 = 0;
    unint64_t v1010 = 0;
  }
  unint64_t v36 = v26 + 8 * (v31 + v1012 * v32);
  if (v1012 == v27 && (uint64_t)(v28 - v36) >= 1)
  {
    if ((int)v23 >= (uint64_t)((v28 - v36) >> 3))
    {
      v28 += 8 * ((int)v23 - 1);
      v36 += 8 * ((int)v23 - 1);
      v30 += (int)v23 - 1;
      v21 += (int)(v22 & (v23 - 1));
      int v38 = -1;
      unint64_t v1012 = (unint64_t)*(int *)(result + 28) >> 3;
      v1013 += (int)(v25 & (v23 - 1));
      goto LABEL_16;
    }
    uint64_t v37 = v24 - 1;
    if (v28 <= v36 + 8 * v27 * v37 + 8 * ((int)v23 - 1))
    {
      v28 += 8 * v27 * v37;
      v30 += v29 * v37;
      uint64_t v29 = -v29;
      v21 += v20 * v37;
      unint64_t v20 = -(uint64_t)v20;
      v22 &= 1u;
      unint64_t v1012 = -(uint64_t)v27;
      v1013 += v1010 * v37;
      unint64_t v1010 = -(uint64_t)v1010;
      v25 &= 1u;
      int v38 = 1;
      v36 += 8 * v27 * v37;
      unint64_t v27 = -(uint64_t)v27;
      goto LABEL_16;
    }
  }
  v22 &= 1u;
  v25 &= 1u;
  int v38 = 1;
LABEL_16:
  double result = 0;
  unint64_t v1014 = 0;
  unint64_t v26 = -1;
  int v35 = v1010;
  int v34 = v1012;
LABEL_19:
  int v39 = v38 * v23;
  int v1011 = v23;
  unint64_t v1007 = result;
  int v1015 = v24;
  if (result)
  {
    uint64_t v40 = (int)v32 % v35;
    unint64_t v41 = v36 + 8 * v1012 * v40;
    double result = (int)v31 % v34;
    unint64_t v36 = v41 + 8 * result;
    unint64_t v26 = v41 + 8 * v34;
    unint64_t v42 = v1010 * v40;
    uint64_t v43 = (uint64_t)v1013;
    uint64_t v44 = (uint64_t)&v1013[v42 + result];
    if (v25) {
      uint64_t v43 = v44;
    }
    uint64_t v1013 = (__int16 *)v43;
    unint64_t v1014 = v41 + 8 * result;
  }
  else
  {
    v1012 -= v39;
    v1010 -= (int)v25 * (int)v23;
  }
  uint64_t v1009 = v29 - v39;
  unint64_t v1008 = v27 - v39;
  unint64_t v1006 = v20 - (int)v22 * (int)v23;
  uint64_t v1016 = v25;
  uint64_t v1017 = v22;
  switch((int)a2)
  {
    case 0:
      if (v22)
      {
        do
        {
          int v45 = v23;
          int v46 = v1015;
          do
          {
            unsigned int v47 = *v30;
            if (*v30)
            {
              if (v47 == 255)
              {
                *(void *)unint64_t v28 = 0;
                _H2 = 0;
              }
              else
              {
                float v49 = (float)((float)v47 * -0.0039216) + 1.0;
                *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), v49));
                _H3 = *v21;
                __asm { FCVT            S3, H3 }
                _S2 = v49 * _S3;
                __asm { FCVT            H2, S2 }
              }
              *(_WORD *)uint64_t v21 = _H2;
            }
            v30 += v38;
            v21 += (int)v22;
            v28 += 8 * v38;
            --v45;
          }
          while (v45);
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
        }
        while (v46 != 1);
      }
      else
      {
        do
        {
          int v793 = v23;
          int v794 = v1015;
          do
          {
            unsigned int v795 = *v30;
            if (*v30)
            {
              if (v795 == 255) {
                *(void *)unint64_t v28 = 0;
              }
              else {
                *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), (float)((float)v795 * -0.0039216) + 1.0));
              }
            }
            v30 += v38;
            v28 += 8 * v38;
            --v793;
          }
          while (v793);
          v30 += v1009;
          v28 += 8 * v1008;
          --v1015;
        }
        while (v794 != 1);
      }
      return result;
    case 1:
      if (v22)
      {
        uint64_t v57 = v38;
        if (v25)
        {
          uint64_t v58 = v35;
          uint64_t v59 = -(uint64_t)(v1012 * v35);
          uint64_t v60 = -(uint64_t)(v1010 * v58);
          char v61 = v1013;
          uint64_t v62 = -(uint64_t)v34;
          do
          {
            int v63 = v1011;
            int v64 = v1015;
            do
            {
              unsigned int v65 = *v30;
              if (*v30)
              {
                if (v65 == 255)
                {
                  *(void *)unint64_t v28 = *(void *)v36;
                  _H2 = *v61;
                }
                else
                {
                  float v67 = (float)v65 * 0.0039216;
                  *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - v67), vcvtq_f32_f16(*(float16x4_t *)v36), v67));
                  _H4 = *v61;
                  __asm { FCVT            S4, H4 }
                  _H5 = *v21;
                  __asm { FCVT            S5, H5 }
                  _S2 = (float)((float)(1.0 - v67) * _S5) + (float)(_S4 * v67);
                  __asm { FCVT            H2, S2 }
                }
                *(_WORD *)uint64_t v21 = _H2;
              }
              v30 += v57;
              unint64_t v73 = v36 + 8 * v57;
              __n128 v74 = &v61[(int)v25];
              if (v73 >= v26) {
                double result = v62;
              }
              else {
                double result = 0;
              }
              char v61 = &v74[result];
              unint64_t v36 = v73 + 8 * result;
              v21 += (int)v22;
              v28 += 8 * v57;
              --v63;
            }
            while (v63);
            if (v1007)
            {
              double result = v1012;
              unint64_t v75 = v1014 + 8 * v1012;
              if (v75 >= v1007) {
                uint64_t v76 = v60;
              }
              else {
                uint64_t v76 = 0;
              }
              uint64_t v77 = (uint64_t)&v1013[v1010 + v76];
              if (v75 >= v1007) {
                uint64_t v78 = v59;
              }
              else {
                uint64_t v78 = 0;
              }
              unint64_t v36 = v75 + 8 * v78;
              v26 += 8 * v78 + 8 * v1012;
              v1013 += v1010 + v76;
              unint64_t v1014 = v36;
              char v61 = (__int16 *)v77;
            }
            else
            {
              v36 += 8 * v1012;
              v61 += v1010;
            }
            v30 += v1009;
            v28 += 8 * v1008;
            v21 += v1006;
            --v1015;
          }
          while (v64 != 1);
        }
        else
        {
          uint64_t v926 = -(uint64_t)v34;
          uint64_t v927 = -(uint64_t)(v1012 * v35);
          double result = v1007;
          do
          {
            int v928 = v23;
            int v929 = v1015;
            do
            {
              unsigned int v930 = *v30;
              if (*v30)
              {
                if (v930 == 255)
                {
                  *(void *)unint64_t v28 = *(void *)v36;
                  _H2 = COERCE_UNSIGNED_INT(1.0);
                }
                else
                {
                  float v932 = (float)v930 * 0.0039216;
                  *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - v932), vcvtq_f32_f16(*(float16x4_t *)v36), v932));
                  _H4 = *v21;
                  __asm { FCVT            S4, H4 }
                  _S2 = v932 + (float)((float)(1.0 - v932) * _S4);
                  __asm { FCVT            H2, S2 }
                }
                *(_WORD *)uint64_t v21 = _H2;
              }
              v30 += v57;
              unint64_t v936 = v36 + 8 * v57;
              if (v936 >= v26) {
                uint64_t v937 = v926;
              }
              else {
                uint64_t v937 = 0;
              }
              unint64_t v36 = v936 + 8 * v937;
              v21 += (int)v22;
              v28 += 8 * v57;
              --v928;
            }
            while (v928);
            v30 += v1009;
            v28 += 8 * v1008;
            v21 += v1006;
            unint64_t v938 = v1014;
            unint64_t v939 = v1014 + 8 * v1012;
            if (v939 >= v1007) {
              uint64_t v940 = v927;
            }
            else {
              uint64_t v940 = 0;
            }
            unint64_t v941 = v939 + 8 * v940;
            uint64_t v942 = v26 + 8 * v940 + 8 * v1012;
            if (v1007)
            {
              unint64_t v26 = v942;
              unint64_t v938 = v941;
              unint64_t v36 = v941;
            }
            else
            {
              v36 += 8 * v1012;
            }
            unint64_t v1014 = v938;
            --v1015;
          }
          while (v929 != 1);
        }
      }
      else
      {
        uint64_t v796 = v38;
        uint64_t v797 = -(uint64_t)v34;
        uint64_t v798 = -(uint64_t)(v1012 * v35);
        uint64_t v799 = 8 * v38;
        do
        {
          int v800 = v23;
          int v801 = v1015;
          do
          {
            unsigned int v802 = *v30;
            if (*v30)
            {
              if (v802 == 255) {
                float16x4_t v803 = *(float16x4_t *)v36;
              }
              else {
                float16x4_t v803 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - (float)((float)v802 * 0.0039216)), vcvtq_f32_f16(*(float16x4_t *)v36), (float)v802 * 0.0039216));
              }
              *(float16x4_t *)unint64_t v28 = v803;
            }
            v30 += v796;
            unint64_t v804 = v36 + 8 * v796;
            if (v804 >= v26) {
              uint64_t v805 = v797;
            }
            else {
              uint64_t v805 = 0;
            }
            unint64_t v36 = v804 + 8 * v805;
            v28 += v799;
            --v800;
          }
          while (v800);
          v30 += v1009;
          v28 += 8 * v1008;
          double result = v1014;
          unint64_t v806 = v1014 + 8 * v1012;
          if (v806 >= v1007) {
            uint64_t v807 = v798;
          }
          else {
            uint64_t v807 = 0;
          }
          unint64_t v808 = v806 + 8 * v807;
          uint64_t v809 = v26 + 8 * v807 + 8 * v1012;
          if (v1007)
          {
            unint64_t v26 = v809;
            double result = v808;
            unint64_t v36 = v808;
          }
          else
          {
            v36 += 8 * v1012;
          }
          unint64_t v1014 = result;
          --v1015;
        }
        while (v801 != 1);
      }
      return result;
    case 2:
      uint64_t v79 = v38;
      uint64_t v80 = -(uint64_t)v34;
      uint64_t v81 = v35;
      if (v22)
      {
        uint64_t v82 = -(uint64_t)(v1012 * v35);
        uint64_t v83 = -(uint64_t)(v1010 * v81);
        unsigned int v84 = (short float *)v1013;
        while (1)
        {
          int v85 = v1011;
          int v86 = v1015;
          do
          {
            unsigned int v87 = *v30;
            if (!*v30) {
              goto LABEL_74;
            }
            if (v87 == 255)
            {
              _H3 = *v84;
              if (*v84 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
              {
                *(void *)unint64_t v28 = *(void *)v36;
                goto LABEL_73;
              }
              __asm { FCMP            H3, #0 }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_74;
              }
              __asm { FCVT            S3, H3 }
              *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S3));
              _H5 = *v21;
              __asm { FCVT            S5, H5 }
              _S3 = _S3 + (float)(_S5 * (float)(1.0 - _S3));
            }
            else
            {
              float v94 = (float)v87 * 0.0039216;
              _H4 = *v84;
              __asm { FCVT            S4, H4 }
              _S4 = v94 * _S4;
              __asm
              {
                FCVT            H4, S4
                FCMP            H4, #0
              }
              if (_NF ^ _VF | _ZF) {
                goto LABEL_74;
              }
              __asm { FCVT            S4, H4 }
              *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v94))), vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S4));
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S3 = _S4 + (float)(_S3 * (float)(1.0 - _S4));
            }
            __asm { FCVT            H3, S3 }
LABEL_73:
            *uint64_t v21 = _H3;
LABEL_74:
            v30 += v79;
            unint64_t v102 = v36 + 8 * v79;
            unint64_t v103 = &v84[(int)v25];
            if (v102 >= v26) {
              double result = v80;
            }
            else {
              double result = 0;
            }
            unsigned int v84 = &v103[result];
            unint64_t v36 = v102 + 8 * result;
            v21 += (int)v22;
            v28 += 8 * v79;
            --v85;
          }
          while (v85);
          if (v1007)
          {
            double result = v1012;
            unint64_t v104 = v1014 + 8 * v1012;
            if (v104 >= v1007) {
              uint64_t v105 = v83;
            }
            else {
              uint64_t v105 = 0;
            }
            uint64_t v106 = (uint64_t)&v1013[v1010 + v105];
            if (v104 >= v1007) {
              uint64_t v107 = v82;
            }
            else {
              uint64_t v107 = 0;
            }
            unint64_t v36 = v104 + 8 * v107;
            v26 += 8 * v107 + 8 * v1012;
            v1013 += v1010 + v105;
            unint64_t v1014 = v36;
            unsigned int v84 = (short float *)v106;
          }
          else
          {
            v36 += 8 * v1012;
            v84 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
          if (v86 == 1) {
            return result;
          }
        }
      }
      uint64_t v810 = -(uint64_t)(v1012 * v35);
      uint64_t v811 = -(uint64_t)(v1010 * v81);
      int v812 = (short float *)v1013;
LABEL_787:
      int v813 = v23;
      while (1)
      {
        unsigned int v814 = *v30;
        if (*v30)
        {
          if (v814 == 255)
          {
            if (*v812 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
            {
              float16x4_t v817 = *(float16x4_t *)v36;
              goto LABEL_796;
            }
            __asm { FCMP            H3, #0 }
            if (!(_NF ^ _VF | _ZF))
            {
              __asm { FCVT            S3, H3 }
              float16x4_t v817 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S3));
LABEL_796:
              *(float16x4_t *)unint64_t v28 = v817;
            }
          }
          else
          {
            float v818 = (float)v814 * 0.0039216;
            _H4 = *v812;
            __asm { FCVT            S4, H4 }
            _S4 = v818 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCMP            H4, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __asm { FCVT            S4, H4 }
              float16x4_t v817 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v818))), vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S4));
              goto LABEL_796;
            }
          }
        }
        v30 += v79;
        unint64_t v824 = v36 + 8 * v79;
        int v825 = &v812[(int)v25];
        if (v824 >= v26) {
          uint64_t v826 = v80;
        }
        else {
          uint64_t v826 = 0;
        }
        int v812 = &v825[v826];
        unint64_t v36 = v824 + 8 * v826;
        v28 += 8 * v79;
        if (!--v813)
        {
          if (v1007)
          {
            unint64_t v827 = v1014 + 8 * v1012;
            if (v827 >= v1007) {
              uint64_t v828 = v811;
            }
            else {
              uint64_t v828 = 0;
            }
            uint64_t v829 = (uint64_t)&v1013[v1010 + v828];
            if (v827 >= v1007) {
              uint64_t v830 = v810;
            }
            else {
              uint64_t v830 = 0;
            }
            unint64_t v36 = v827 + 8 * v830;
            v26 += 8 * v830 + 8 * v1012;
            v1013 += v1010 + v828;
            unint64_t v1014 = v36;
            int v812 = (short float *)v829;
          }
          else
          {
            v36 += 8 * v1012;
            v812 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          double result = (v1015 - 1);
          int v1015 = result;
          if (!result) {
            return result;
          }
          goto LABEL_787;
        }
      }
    case 3:
      uint64_t v108 = v38;
      uint64_t v109 = v35;
      uint64_t v110 = -(uint64_t)(v1012 * v35);
      uint64_t v111 = -(uint64_t)(v1010 * v109);
      uint64_t v112 = 8 * v38;
      uint64_t v113 = -(uint64_t)v34;
      int v114 = v1013;
      do
      {
        int v115 = v1011;
        int v116 = v1015;
        do
        {
          unsigned int v117 = *v30;
          if (*v30)
          {
            if (v117 == 255)
            {
              *(short float *)unint64_t v28 = *(short float *)v36 * *v21;
              *(short float *)(v28 + 2) = *(short float *)(v36 + 2) * *v21;
              *(short float *)(v28 + 4) = *(short float *)(v36 + 4) * *v21;
              *(short float *)(v28 + 6) = *(short float *)(v36 + 6) * *v21;
              if (v25)
              {
                _H1 = *v114;
                __asm { FCVT            S1, H1 }
              }
              else
              {
                _S1 = 1.0;
              }
              _H2 = *v21;
              __asm { FCVT            S2, H2 }
              _S1 = _S1 * _S2;
            }
            else
            {
              float v120 = (float)v117 * 0.0039216;
              _H1 = *v21;
              __asm { FCVT            S1, H1 }
              float v123 = v120 * _S1;
              _S4 = 1.0;
              float v125 = 1.0 - v120;
              *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), v125), vcvtq_f32_f16(*(float16x4_t *)v36), v123));
              if (v25)
              {
                _H4 = *v114;
                __asm { FCVT            S4, H4 }
              }
              _S1 = (float)(v125 * _S1) + (float)(_S4 * v123);
            }
            __asm { FCVT            H1, S1 }
            *(_WORD *)uint64_t v21 = _H1;
          }
          v30 += v108;
          unint64_t v131 = v36 + 8 * v108;
          unint64_t v132 = &v114[(int)v25];
          if (v131 >= v26) {
            double result = v113;
          }
          else {
            double result = 0;
          }
          int v114 = &v132[result];
          unint64_t v36 = v131 + 8 * result;
          v21 += (int)v22;
          v28 += v112;
          --v115;
        }
        while (v115);
        if (v1007)
        {
          double result = v1012;
          unint64_t v133 = v1014 + 8 * v1012;
          if (v133 >= v1007) {
            uint64_t v134 = v111;
          }
          else {
            uint64_t v134 = 0;
          }
          uint64_t v135 = (uint64_t)&v1013[v1010 + v134];
          if (v133 >= v1007) {
            uint64_t v136 = v110;
          }
          else {
            uint64_t v136 = 0;
          }
          unint64_t v36 = v133 + 8 * v136;
          v26 += 8 * v136 + 8 * v1012;
          v1013 += v1010 + v134;
          unint64_t v1014 = v36;
          int v114 = (__int16 *)v135;
        }
        else
        {
          v36 += 8 * v1012;
          v114 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
      }
      while (v116 != 1);
      return result;
    case 4:
      uint64_t v137 = v38;
      uint64_t v138 = v35;
      uint64_t v139 = -(uint64_t)(v1012 * v35);
      uint64_t v140 = -(uint64_t)(v1010 * v138);
      uint64_t v141 = 8 * v38;
      uint64_t v142 = -(uint64_t)v34;
      double v143 = v1013;
      do
      {
        int v144 = v1011;
        int v145 = v1015;
        do
        {
          unsigned int v146 = *v30;
          if (*v30)
          {
            if (v146 == 255)
            {
              _H2 = *(_WORD *)v36;
              __asm { FCVT            S3, H2 }
              _H2 = *v21;
              __asm { FCVT            S4, H2 }
              _S2 = 1.0;
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              *(_WORD *)unint64_t v28 = LOWORD(_S3);
              LOWORD(_S3) = *(_WORD *)(v36 + 2);
              __asm { FCVT            S3, H3 }
              *(short float *)&_S4 = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v28 + 2) = LOWORD(_S3);
              LOWORD(_S3) = *(_WORD *)(v36 + 4);
              __asm { FCVT            S3, H3 }
              *(short float *)&_S4 = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v28 + 4) = LOWORD(_S3);
              LOWORD(_S3) = *(_WORD *)(v36 + 6);
              __asm { FCVT            S3, H3 }
              *(short float *)&_S4 = *v21;
              __asm { FCVT            S4, H4 }
              _S3 = (float)(1.0 - _S4) * _S3;
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v28 + 6) = LOWORD(_S3);
              if (v25)
              {
                _H2 = *v143;
                __asm { FCVT            S2, H2 }
              }
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S2 = _S2 * (float)(1.0 - _S3);
            }
            else
            {
              float v166 = (float)v146 * 0.0039216;
              _H2 = *v21;
              __asm { FCVT            S2, H2 }
              _S4 = 1.0;
              float v170 = v166 * (float)(1.0 - _S2);
              float v171 = 1.0 - v166;
              *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), v171), vcvtq_f32_f16(*(float16x4_t *)v36), v170));
              if (v25)
              {
                _H4 = *v143;
                __asm { FCVT            S4, H4 }
              }
              _S2 = (float)(v171 * _S2) + (float)(_S4 * v170);
            }
            __asm { FCVT            H2, S2 }
            *(_WORD *)uint64_t v21 = _H2;
          }
          v30 += v137;
          unint64_t v174 = v36 + 8 * v137;
          uint64_t v175 = &v143[(int)v25];
          if (v174 >= v26) {
            double result = v142;
          }
          else {
            double result = 0;
          }
          double v143 = &v175[result];
          unint64_t v36 = v174 + 8 * result;
          v21 += (int)v22;
          v28 += v141;
          --v144;
        }
        while (v144);
        if (v1007)
        {
          double result = v1012;
          unint64_t v176 = v1014 + 8 * v1012;
          if (v176 >= v1007) {
            uint64_t v177 = v140;
          }
          else {
            uint64_t v177 = 0;
          }
          uint64_t v178 = (uint64_t)&v1013[v1010 + v177];
          if (v176 >= v1007) {
            uint64_t v179 = v139;
          }
          else {
            uint64_t v179 = 0;
          }
          unint64_t v36 = v176 + 8 * v179;
          v26 += 8 * v179 + 8 * v1012;
          v1013 += v1010 + v177;
          unint64_t v1014 = v36;
          double v143 = (__int16 *)v178;
        }
        else
        {
          v36 += 8 * v1012;
          v143 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
      }
      while (v145 != 1);
      return result;
    case 5:
      uint64_t v180 = v38;
      uint64_t v181 = v35;
      uint64_t v182 = -(uint64_t)(v1012 * v35);
      uint64_t v183 = -(uint64_t)(v1010 * v181);
      uint64_t v184 = 8 * v38;
      uint64_t v185 = -(uint64_t)v34;
      unint64_t v186 = v1013;
      do
      {
        int v187 = v1011;
        int v188 = v1015;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            float v191 = (float)*v30 * 0.0039216;
            _H4 = *v186;
            __asm { FCVT            S4, H4 }
            _S4 = v191 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S4), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v191))), _S2));
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * _S2);
            __asm { FCVT            H2, S2 }
            *uint64_t v21 = *(short float *)&_S2;
          }
          v30 += v180;
          unint64_t v197 = v36 + 8 * v180;
          float v198 = &v186[(int)v25];
          if (v197 >= v26) {
            double result = v185;
          }
          else {
            double result = 0;
          }
          unint64_t v186 = &v198[result];
          unint64_t v36 = v197 + 8 * result;
          v21 += (int)v22;
          v28 += v184;
          --v187;
        }
        while (v187);
        if (v1007)
        {
          double result = v1012;
          unint64_t v199 = v1014 + 8 * v1012;
          if (v199 >= v1007) {
            uint64_t v200 = v183;
          }
          else {
            uint64_t v200 = 0;
          }
          uint64_t v201 = (uint64_t)&v1013[v1010 + v200];
          if (v199 >= v1007) {
            uint64_t v202 = v182;
          }
          else {
            uint64_t v202 = 0;
          }
          unint64_t v36 = v199 + 8 * v202;
          v26 += 8 * v202 + 8 * v1012;
          v1013 += v1010 + v200;
          unint64_t v1014 = v36;
          unint64_t v186 = (__int16 *)v201;
        }
        else
        {
          v36 += 8 * v1012;
          v186 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
      }
      while (v188 != 1);
      return result;
    case 6:
      uint64_t v203 = v38;
      uint64_t v204 = v35;
      uint64_t v205 = -(uint64_t)(v1012 * v35);
      uint64_t v206 = -(uint64_t)(v1010 * v204);
      uint64_t v207 = 8 * v38;
      uint64_t v208 = -(uint64_t)v34;
      uint64_t v209 = v1013;
      while (1)
      {
        int v210 = v1011;
        int v211 = v1015;
        do
        {
          unsigned int v212 = *v30;
          if (!*v30) {
            goto LABEL_175;
          }
          _H2 = *v21;
          __asm { FCVT            S2, H2 }
          float v215 = 1.0 - _S2;
          if ((float)(1.0 - _S2) >= 1.0)
          {
            float v219 = (float)v212 * 0.0039216;
            *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v219));
            if (v25)
            {
              _H3 = *v209;
              __asm { FCVT            S3, H3 }
            }
            else
            {
              _S3 = 1.0;
            }
            _S2 = v219 * _S3;
          }
          else
          {
            if (v215 <= 0.0) {
              goto LABEL_175;
            }
            float v216 = (float)((float)v212 * 0.0039216) * v215;
            *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), vcvtq_f32_f16(*(float16x4_t *)v36), v216));
            if (v25)
            {
              _H4 = *v209;
              __asm { FCVT            S4, H4 }
            }
            else
            {
              _S4 = 1.0;
            }
            _S2 = _S2 + (float)(_S4 * v216);
          }
          __asm { FCVT            H2, S2 }
          *(_WORD *)uint64_t v21 = _H2;
LABEL_175:
          v30 += v203;
          unint64_t v224 = v36 + 8 * v203;
          int v225 = &v209[(int)v25];
          if (v224 >= v26) {
            double result = v208;
          }
          else {
            double result = 0;
          }
          uint64_t v209 = &v225[result];
          unint64_t v36 = v224 + 8 * result;
          v21 += (int)v22;
          v28 += v207;
          --v210;
        }
        while (v210);
        if (v1007)
        {
          double result = v1012;
          unint64_t v226 = v1014 + 8 * v1012;
          if (v226 >= v1007) {
            uint64_t v227 = v206;
          }
          else {
            uint64_t v227 = 0;
          }
          uint64_t v228 = (uint64_t)&v1013[v1010 + v227];
          if (v226 >= v1007) {
            uint64_t v229 = v205;
          }
          else {
            uint64_t v229 = 0;
          }
          unint64_t v36 = v226 + 8 * v229;
          v26 += 8 * v229 + 8 * v1012;
          v1013 += v1010 + v227;
          unint64_t v1014 = v36;
          uint64_t v209 = (__int16 *)v228;
        }
        else
        {
          v36 += 8 * v1012;
          v209 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
        if (v211 == 1) {
          return result;
        }
      }
    case 7:
      uint64_t v230 = v38;
      if (v22)
      {
        uint64_t v231 = v35;
        uint64_t v232 = -(uint64_t)(v1012 * v35);
        uint64_t v233 = -(uint64_t)(v1010 * v231);
        uint64_t v234 = -(uint64_t)v34;
        int v235 = (short float *)v1013;
        do
        {
          int v236 = v1011;
          int v237 = v1015;
          do
          {
            unsigned int v238 = *v30;
            if (*v30)
            {
              if (v238 == 255)
              {
                *(short float *)unint64_t v28 = *(short float *)v28 * *v235;
                *(short float *)(v28 + 2) = *(short float *)(v28 + 2) * *v235;
                *(short float *)(v28 + 4) = *(short float *)(v28 + 4) * *v235;
                *(short float *)(v28 + 6) = *(short float *)(v28 + 6) * *v235;
                _H2 = *v21 * *v235;
              }
              else
              {
                float v240 = (float)v238 * 0.0039216;
                _H3 = *v21;
                __asm { FCVT            S3, H3 }
                _H4 = *(_WORD *)v28;
                __asm { FCVT            S4, H4 }
                _H5 = *v235;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v240) * _S4) + (float)(_S4 * (float)(v240 * _S5));
                __asm { FCVT            H4, S4 }
                *(_WORD *)unint64_t v28 = LOWORD(_S4);
                LOWORD(_S4) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S4, H4 }
                *(short float *)&_S5 = *v235;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v240) * _S4) + (float)(_S4 * (float)(v240 * _S5));
                __asm { FCVT            H4, S4 }
                *(_WORD *)(v28 + 2) = LOWORD(_S4);
                LOWORD(_S4) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S4, H4 }
                *(short float *)&_S5 = *v235;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v240) * _S4) + (float)(_S4 * (float)(v240 * _S5));
                __asm { FCVT            H4, S4 }
                *(_WORD *)(v28 + 4) = LOWORD(_S4);
                LOWORD(_S4) = *(_WORD *)(v28 + 6);
                __asm { FCVT            S4, H4 }
                *(short float *)&_S5 = *v235;
                __asm { FCVT            S5, H5 }
                _S4 = (float)((float)(1.0 - v240) * _S4) + (float)(_S4 * (float)(v240 * _S5));
                __asm { FCVT            H4, S4 }
                *(_WORD *)(v28 + 6) = LOWORD(_S4);
                *(short float *)&_S4 = *v235;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - v240) * _S3) + (float)(_S3 * (float)(v240 * _S4));
                __asm { FCVT            H2, S2 }
              }
              *uint64_t v21 = _H2;
            }
            v30 += v230;
            unint64_t v259 = v36 + 8 * v230;
            float v260 = &v235[(int)v25];
            if (v259 >= v26) {
              double result = v234;
            }
            else {
              double result = 0;
            }
            int v235 = &v260[result];
            unint64_t v36 = v259 + 8 * result;
            v21 += (int)v22;
            v28 += 8 * v230;
            --v236;
          }
          while (v236);
          if (v1007)
          {
            double result = v1012;
            unint64_t v261 = v1014 + 8 * v1012;
            if (v261 >= v1007) {
              uint64_t v262 = v233;
            }
            else {
              uint64_t v262 = 0;
            }
            uint64_t v263 = (uint64_t)&v1013[v1010 + v262];
            if (v261 >= v1007) {
              uint64_t v264 = v232;
            }
            else {
              uint64_t v264 = 0;
            }
            unint64_t v36 = v261 + 8 * v264;
            v26 += 8 * v264 + 8 * v1012;
            v1013 += v1010 + v262;
            unint64_t v1014 = v36;
            int v235 = (short float *)v263;
          }
          else
          {
            v36 += 8 * v1012;
            v235 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
        }
        while (v237 != 1);
      }
      else
      {
        uint64_t v831 = -(uint64_t)v34;
        uint64_t v832 = v35;
        uint64_t v833 = -(uint64_t)(v1012 * v35);
        uint64_t v834 = -(uint64_t)(v1010 * v832);
        unint64_t v835 = (short float *)v1013;
        do
        {
          int v836 = v23;
          do
          {
            unsigned int v837 = *v30;
            if (*v30)
            {
              if (v837 == 255)
              {
                *(short float *)unint64_t v28 = *(short float *)v28 * *v835;
                *(short float *)(v28 + 2) = *(short float *)(v28 + 2) * *v835;
                *(short float *)(v28 + 4) = *(short float *)(v28 + 4) * *v835;
                _H2 = *(short float *)(v28 + 6) * *v835;
              }
              else
              {
                float v839 = (float)v837 * 0.0039216;
                _H3 = *(_WORD *)v28;
                __asm { FCVT            S3, H3 }
                _H4 = *v835;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v839) * _S3) + (float)(_S3 * (float)(v839 * _S4));
                __asm { FCVT            H3, S3 }
                *(_WORD *)unint64_t v28 = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S3, H3 }
                *(short float *)&_S4 = *v835;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v839) * _S3) + (float)(_S3 * (float)(v839 * _S4));
                __asm { FCVT            H3, S3 }
                *(_WORD *)(v28 + 2) = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S3, H3 }
                *(short float *)&_S4 = *v835;
                __asm { FCVT            S4, H4 }
                _S3 = (float)((float)(1.0 - v839) * _S3) + (float)(_S3 * (float)(v839 * _S4));
                __asm { FCVT            H3, S3 }
                *(_WORD *)(v28 + 4) = LOWORD(_S3);
                LOWORD(_S3) = *(_WORD *)(v28 + 6);
                __asm { FCVT            S3, H3 }
                *(short float *)&_S4 = *v835;
                __asm { FCVT            S4, H4 }
                _S2 = (float)((float)(1.0 - v839) * _S3) + (float)(_S3 * (float)(v839 * _S4));
                __asm { FCVT            H2, S2 }
              }
              *(short float *)(v28 + 6) = _H2;
            }
            v30 += v230;
            unint64_t v854 = v36 + 8 * v230;
            int32x4_t v855 = &v835[(int)v25];
            if (v854 >= v26) {
              uint64_t v856 = v831;
            }
            else {
              uint64_t v856 = 0;
            }
            unint64_t v835 = &v855[v856];
            unint64_t v36 = v854 + 8 * v856;
            v28 += 8 * v230;
            --v836;
          }
          while (v836);
          if (v1007)
          {
            unint64_t v857 = v1014 + 8 * v1012;
            if (v857 >= v1007) {
              uint64_t v858 = v834;
            }
            else {
              uint64_t v858 = 0;
            }
            uint64_t v859 = (uint64_t)&v1013[v1010 + v858];
            if (v857 >= v1007) {
              uint64_t v860 = v833;
            }
            else {
              uint64_t v860 = 0;
            }
            unint64_t v36 = v857 + 8 * v860;
            v26 += 8 * v860 + 8 * v1012;
            v1013 += v1010 + v858;
            unint64_t v1014 = v36;
            unint64_t v835 = (short float *)v859;
          }
          else
          {
            v36 += 8 * v1012;
            v835 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          double result = (v1015 - 1);
          int v1015 = result;
        }
        while (result);
      }
      return result;
    case 8:
      uint64_t v265 = v38;
      uint64_t v266 = -(uint64_t)v34;
      uint64_t v267 = v35;
      if (v22)
      {
        uint64_t v268 = -(uint64_t)(v1012 * v35);
        uint64_t v269 = -(uint64_t)(v1010 * v267);
        float v270 = v1013;
        do
        {
          int v271 = v1011;
          int v272 = v1015;
          do
          {
            unsigned int v273 = *v30;
            if (*v30)
            {
              _H2 = *(_WORD *)v28;
              if (v273 == 255)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v28 = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 2) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 4) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 6);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 6) = LOWORD(_S2);
                LOWORD(_S2) = *v270;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v270;
                __asm { FCVT            S3, H3 }
                float v292 = (float)v273 * 0.0039216;
                _S2 = (float)(1.0 - (float)(v292 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v28 = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v292 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 2) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v292 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 4) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 6);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v270;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v292 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 6) = LOWORD(_S2);
                LOWORD(_S2) = *v270;
                __asm { FCVT            S2, H2 }
                _S2 = v292 * _S2;
              }
              _H3 = *v21;
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              *uint64_t v21 = *(short float *)&_S2;
            }
            v30 += v265;
            unint64_t v307 = v36 + 8 * v265;
            __n128 v308 = &v270[(int)v25];
            if (v307 >= v26) {
              double result = v266;
            }
            else {
              double result = 0;
            }
            float v270 = &v308[result];
            unint64_t v36 = v307 + 8 * result;
            v21 += (int)v22;
            v28 += 8 * v265;
            --v271;
          }
          while (v271);
          if (v1007)
          {
            double result = v1012;
            unint64_t v309 = v1014 + 8 * v1012;
            if (v309 >= v1007) {
              uint64_t v310 = v269;
            }
            else {
              uint64_t v310 = 0;
            }
            uint64_t v311 = (uint64_t)&v1013[v1010 + v310];
            if (v309 >= v1007) {
              uint64_t v312 = v268;
            }
            else {
              uint64_t v312 = 0;
            }
            unint64_t v36 = v309 + 8 * v312;
            v26 += 8 * v312 + 8 * v1012;
            v1013 += v1010 + v310;
            unint64_t v1014 = v36;
            float v270 = (__int16 *)v311;
          }
          else
          {
            v36 += 8 * v1012;
            v270 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
        }
        while (v272 != 1);
      }
      else
      {
        uint64_t v861 = -(uint64_t)(v1012 * v35);
        uint64_t v862 = -(uint64_t)(v1010 * v267);
        long long v863 = v1013;
        do
        {
          int v864 = v23;
          do
          {
            unsigned int v865 = *v30;
            if (*v30)
            {
              _H2 = *(_WORD *)v28;
              if (v865 == 255)
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v863;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v28 = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v863;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 2) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v863;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - _S3) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 4) = LOWORD(_S2);
                LOWORD(_S2) = *v863;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                __asm { FCVT            S2, H2 }
                _H3 = *v863;
                __asm { FCVT            S3, H3 }
                float v881 = (float)v865 * 0.0039216;
                _S2 = (float)(1.0 - (float)(v881 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)unint64_t v28 = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 2);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v863;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v881 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 2) = LOWORD(_S2);
                LOWORD(_S2) = *(_WORD *)(v28 + 4);
                __asm { FCVT            S2, H2 }
                LOWORD(_S3) = *v863;
                __asm { FCVT            S3, H3 }
                _S2 = (float)(1.0 - (float)(v881 * _S3)) * _S2;
                __asm { FCVT            H2, S2 }
                *(_WORD *)(v28 + 4) = LOWORD(_S2);
                LOWORD(_S2) = *v863;
                __asm { FCVT            S2, H2 }
                _S2 = v881 * _S2;
              }
              _H3 = *(_WORD *)(v28 + 6);
              __asm { FCVT            S3, H3 }
              _S2 = (float)(1.0 - _S2) * _S3;
              __asm { FCVT            H2, S2 }
              *(_WORD *)(v28 + 6) = LOWORD(_S2);
            }
            v30 += v265;
            unint64_t v893 = v36 + 8 * v265;
            float v894 = &v863[(int)v25];
            if (v893 >= v26) {
              uint64_t v895 = v266;
            }
            else {
              uint64_t v895 = 0;
            }
            long long v863 = &v894[v895];
            unint64_t v36 = v893 + 8 * v895;
            v28 += 8 * v265;
            --v864;
          }
          while (v864);
          if (v1007)
          {
            unint64_t v896 = v1014 + 8 * v1012;
            if (v896 >= v1007) {
              uint64_t v897 = v862;
            }
            else {
              uint64_t v897 = 0;
            }
            uint64_t v898 = (uint64_t)&v1013[v1010 + v897];
            if (v896 >= v1007) {
              uint64_t v899 = v861;
            }
            else {
              uint64_t v899 = 0;
            }
            unint64_t v36 = v896 + 8 * v899;
            v26 += 8 * v899 + 8 * v1012;
            v1013 += v1010 + v897;
            unint64_t v1014 = v36;
            long long v863 = (__int16 *)v898;
          }
          else
          {
            v36 += 8 * v1012;
            v863 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          double result = (v1015 - 1);
          int v1015 = result;
        }
        while (result);
      }
      return result;
    case 9:
      uint64_t v313 = v38;
      uint64_t v314 = v35;
      uint64_t v315 = -(uint64_t)(v1012 * v35);
      uint64_t v316 = -(uint64_t)(v1010 * v314);
      uint64_t v317 = 8 * v38;
      uint64_t v318 = -(uint64_t)v34;
      float16x4_t v319 = v1013;
      do
      {
        int v320 = v1011;
        int v321 = v1015;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            float v324 = (float)*v30 * 0.0039216;
            _H4 = *v319;
            __asm { FCVT            S4, H4 }
            _S4 = v324 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            float v329 = (float)(1.0 - v324) + _S4;
            *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), v329), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v324))), 1.0 - _S2));
            _S2 = (float)(v329 * _S2) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *uint64_t v21 = *(short float *)&_S2;
          }
          v30 += v313;
          unint64_t v331 = v36 + 8 * v313;
          int32x2_t v332 = &v319[(int)v25];
          if (v331 >= v26) {
            double result = v318;
          }
          else {
            double result = 0;
          }
          float16x4_t v319 = &v332[result];
          unint64_t v36 = v331 + 8 * result;
          v21 += (int)v22;
          v28 += v317;
          --v320;
        }
        while (v320);
        if (v1007)
        {
          double result = v1012;
          unint64_t v333 = v1014 + 8 * v1012;
          if (v333 >= v1007) {
            uint64_t v334 = v316;
          }
          else {
            uint64_t v334 = 0;
          }
          uint64_t v335 = (uint64_t)&v1013[v1010 + v334];
          if (v333 >= v1007) {
            uint64_t v336 = v315;
          }
          else {
            uint64_t v336 = 0;
          }
          unint64_t v36 = v333 + 8 * v336;
          v26 += 8 * v336 + 8 * v1012;
          v1013 += v1010 + v334;
          unint64_t v1014 = v36;
          float16x4_t v319 = (__int16 *)v335;
        }
        else
        {
          v36 += 8 * v1012;
          v319 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
      }
      while (v321 != 1);
      return result;
    case 10:
      uint64_t v337 = v38;
      uint64_t v338 = v35;
      uint64_t v339 = -(uint64_t)(v1012 * v35);
      uint64_t v340 = -(uint64_t)(v1010 * v338);
      uint64_t v341 = 8 * v38;
      uint64_t v342 = -(uint64_t)v34;
      int v343 = v1013;
      do
      {
        int v344 = v1011;
        int v345 = v1015;
        do
        {
          if (*v30)
          {
            _H2 = *v21;
            __asm { FCVT            S2, H2 }
            float v348 = (float)*v30 * 0.0039216;
            _H4 = *v343;
            __asm { FCVT            S4, H4 }
            _S4 = v348 * _S4;
            __asm
            {
              FCVT            H4, S4
              FCVT            S4, H4
            }
            *(float16x4_t *)unint64_t v28 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v28), 1.0 - _S4), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v348))), 1.0 - _S2));
            _S2 = (float)((float)(1.0 - _S4) * _S2) + (float)(_S4 * (float)(1.0 - _S2));
            __asm { FCVT            H2, S2 }
            *uint64_t v21 = *(short float *)&_S2;
          }
          v30 += v337;
          unint64_t v354 = v36 + 8 * v337;
          uint64_t v355 = &v343[(int)v25];
          if (v354 >= v26) {
            double result = v342;
          }
          else {
            double result = 0;
          }
          int v343 = &v355[result];
          unint64_t v36 = v354 + 8 * result;
          v21 += (int)v22;
          v28 += v341;
          --v344;
        }
        while (v344);
        if (v1007)
        {
          double result = v1012;
          unint64_t v356 = v1014 + 8 * v1012;
          if (v356 >= v1007) {
            uint64_t v357 = v340;
          }
          else {
            uint64_t v357 = 0;
          }
          uint64_t v358 = (uint64_t)&v1013[v1010 + v357];
          if (v356 >= v1007) {
            uint64_t v359 = v339;
          }
          else {
            uint64_t v359 = 0;
          }
          unint64_t v36 = v356 + 8 * v359;
          v26 += 8 * v359 + 8 * v1012;
          v1013 += v1010 + v357;
          unint64_t v1014 = v36;
          int v343 = (__int16 *)v358;
        }
        else
        {
          v36 += 8 * v1012;
          v343 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        --v1015;
      }
      while (v345 != 1);
      return result;
    case 11:
      uint64_t v360 = v38;
      if (v22)
      {
        uint64_t v361 = v35;
        uint64_t v362 = -(uint64_t)(v1012 * v35);
        uint64_t v363 = -(uint64_t)(v1010 * v361);
        uint64_t v364 = -(uint64_t)v34;
        int v365 = v1013;
        do
        {
          int v366 = v1011;
          int v367 = v1015;
          do
          {
            if (*v30)
            {
              if (v25)
              {
                _H2 = *v365;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _H3 = *(_WORD *)v36;
              __asm { FCVT            S3, H3 }
              _S4 = (float)*v30 * 0.0039216;
              _S3 = _S4 * _S3;
              __asm { FCVT            H3, S3 }
              _H5 = *(_WORD *)(v36 + 2);
              __asm { FCVT            S5, H5 }
              _S5 = _S4 * _S5;
              __asm { FCVT            H5, S5 }
              _H6 = *(_WORD *)(v36 + 4);
              __asm { FCVT            S6, H6 }
              _S6 = _S4 * _S6;
              __asm { FCVT            H6, S6 }
              _H7 = *(_WORD *)(v36 + 6);
              __asm { FCVT            S7, H7 }
              _S7 = _S4 * _S7;
              __asm { FCVT            H7, S7 }
              _S2 = _S4 * _S2;
              __asm { FCVT            H2, S2 }
              *(short float *)&_S4 = *v21;
              __asm
              {
                FCVT            S4, H4
                FCVT            S2, H2
              }
              _S16 = _S4 + _S2;
              _H17 = *(_WORD *)v28;
              __asm
              {
                FCVT            S17, H17
                FCVT            S3, H3
              }
              float v393 = (float)(_S4 - _S17) + (float)(_S2 - _S3);
              if ((float)(_S4 + _S2) > 1.0) {
                _S16 = 1.0;
              }
              _H17 = *(_WORD *)(v28 + 2);
              __asm
              {
                FCVT            S17, H17
                FCVT            S5, H5
              }
              float v397 = (float)(_S2 - _S5) + (float)(_S4 - _S17);
              _S3 = _S16 - v393;
              __asm { FCVT            H3, S3 }
              *(_WORD *)unint64_t v28 = LOWORD(_S3);
              *(short float *)&_S3 = *v21;
              __asm { FCVT            S3, H3 }
              LOWORD(_S5) = *(_WORD *)(v28 + 4);
              __asm { FCVT            S5, H5 }
              float v401 = _S3 - _S5;
              __asm { FCVT            S5, H6 }
              float v403 = (float)(_S2 - _S5) + v401;
              _S4 = _S16 - v397;
              __asm { FCVT            H4, S4 }
              *(_WORD *)(v28 + 2) = LOWORD(_S4);
              *(short float *)&_S4 = *v21;
              __asm { FCVT            S4, H4 }
              LOWORD(_S5) = *(_WORD *)(v28 + 6);
              __asm { FCVT            S5, H5 }
              float v407 = _S4 - _S5;
              __asm { FCVT            S5, H7 }
              _S3 = _S16 - v403;
              __asm { FCVT            H3, S3 }
              *(_WORD *)(v28 + 4) = LOWORD(_S3);
              __asm { FCVT            H3, S16 }
              *uint64_t v21 = *(short float *)&_S3;
              _S2 = _S16 - (float)((float)(_S2 - _S5) + v407);
              __asm { FCVT            H2, S2 }
              *(_WORD *)(v28 + 6) = LOWORD(_S2);
            }
            v30 += v360;
            unint64_t v411 = v36 + 8 * v360;
            uint64_t v412 = &v365[(int)v25];
            if (v411 >= v26) {
              double result = v364;
            }
            else {
              double result = 0;
            }
            int v365 = &v412[result];
            unint64_t v36 = v411 + 8 * result;
            v21 += (int)v22;
            v28 += 8 * v360;
            --v366;
          }
          while (v366);
          if (v1007)
          {
            double result = v1012;
            unint64_t v413 = v1014 + 8 * v1012;
            if (v413 >= v1007) {
              uint64_t v414 = v363;
            }
            else {
              uint64_t v414 = 0;
            }
            uint64_t v415 = (uint64_t)&v1013[v1010 + v414];
            if (v413 >= v1007) {
              uint64_t v416 = v362;
            }
            else {
              uint64_t v416 = 0;
            }
            unint64_t v36 = v413 + 8 * v416;
            v26 += 8 * v416 + 8 * v1012;
            v1013 += v1010 + v414;
            unint64_t v1014 = v36;
            int v365 = (__int16 *)v415;
          }
          else
          {
            v36 += 8 * v1012;
            v365 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
        }
        while (v367 != 1);
      }
      else
      {
        uint64_t v900 = -(uint64_t)v34;
        uint64_t v901 = v35;
        uint64_t v902 = -(uint64_t)(v1012 * v35);
        uint64_t v903 = -(uint64_t)(v1010 * v901);
        __asm { FMOV            V1.4S, #1.0 }
        float v905 = v1013;
        do
        {
          int v906 = v23;
          do
          {
            if (*v30)
            {
              if (v25)
              {
                _H2 = *v905;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _Q2.n128_u32[0] = 1.0;
              }
              float v908 = (float)*v30 * 0.0039216;
              _Q2.n128_f32[0] = v908 * _Q2.n128_f32[0];
              __asm
              {
                FCVT            H2, S2
                FCVT            S2, H2
              }
              _Q2.n128_u64[0] = (unint64_t)vcvt_f16_f32(vsubq_f32(_Q1, vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)_Q2.n128_u64[0], 0), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), v908)))), vsubq_f32(_Q1, vcvtq_f32_f16(*(float16x4_t *)v28)))));
              *(void *)unint64_t v28 = _Q2.n128_u64[0];
            }
            v30 += v360;
            unint64_t v909 = v36 + 8 * v360;
            unint64_t v910 = &v905[(int)v25];
            if (v909 >= v26) {
              uint64_t v911 = v900;
            }
            else {
              uint64_t v911 = 0;
            }
            float v905 = &v910[v911];
            unint64_t v36 = v909 + 8 * v911;
            v28 += 8 * v360;
            --v906;
          }
          while (v906);
          if (v1007)
          {
            unint64_t v912 = v1014 + 8 * v1012;
            if (v912 >= v1007) {
              uint64_t v913 = v903;
            }
            else {
              uint64_t v913 = 0;
            }
            uint64_t v914 = (uint64_t)&v1013[v1010 + v913];
            if (v912 >= v1007) {
              uint64_t v915 = v902;
            }
            else {
              uint64_t v915 = 0;
            }
            unint64_t v36 = v912 + 8 * v915;
            v26 += 8 * v915 + 8 * v1012;
            v1013 += v1010 + v913;
            unint64_t v1014 = v36;
            float v905 = (__int16 *)v914;
          }
          else
          {
            v36 += 8 * v1012;
            v905 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          double result = (v1015 - 1);
          int v1015 = result;
        }
        while (result);
      }
      return result;
    case 12:
      uint64_t v417 = v38;
      if (v22)
      {
        uint64_t v418 = v35;
        uint64_t v419 = -(uint64_t)(v1012 * v35);
        uint64_t v420 = -(uint64_t)(v1010 * v418);
        uint64_t v421 = -(uint64_t)v34;
        float v422 = v1013;
        do
        {
          int v423 = v1011;
          int v424 = v1015;
          do
          {
            if (*v30)
            {
              if (v25)
              {
                _H2 = *v422;
                __asm { FCVT            S2, H2 }
              }
              else
              {
                _S2 = 1.0;
              }
              _S3 = (float)*v30 * 0.0039216;
              float16x4_t v428 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), _S3));
              _S2 = _S3 * _S2;
              __asm { FCVT            H2, S2 }
              *(short float *)&_S3 = *v21;
              __asm
              {
                FCVT            S3, H3
                FCVT            S2, H2
              }
              _S2 = _S3 + _S2;
              if (_S2 > 1.0) {
                _S2 = 1.0;
              }
              __asm { FCVT            H2, S2 }
              v434.i32[0] = *(_DWORD *)v28;
              *(_WORD *)uint64_t v21 = _H2;
              v434.i32[1] = *(_DWORD *)(v28 + 4);
              *(float16x4_t *)unint64_t v28 = vadd_f16(v434, v428);
            }
            v30 += v417;
            unint64_t v435 = v36 + 8 * v417;
            float v436 = &v422[(int)v25];
            if (v435 >= v26) {
              double result = v421;
            }
            else {
              double result = 0;
            }
            float v422 = &v436[result];
            unint64_t v36 = v435 + 8 * result;
            v21 += (int)v22;
            v28 += 8 * v417;
            --v423;
          }
          while (v423);
          if (v1007)
          {
            double result = v1012;
            unint64_t v437 = v1014 + 8 * v1012;
            if (v437 >= v1007) {
              uint64_t v438 = v420;
            }
            else {
              uint64_t v438 = 0;
            }
            uint64_t v439 = (uint64_t)&v1013[v1010 + v438];
            if (v437 >= v1007) {
              uint64_t v440 = v419;
            }
            else {
              uint64_t v440 = 0;
            }
            unint64_t v36 = v437 + 8 * v440;
            v26 += 8 * v440 + 8 * v1012;
            v1013 += v1010 + v438;
            unint64_t v1014 = v36;
            float v422 = (__int16 *)v439;
          }
          else
          {
            v36 += 8 * v1012;
            v422 += v1010;
          }
          v30 += v1009;
          v28 += 8 * v1008;
          v21 += v1006;
          --v1015;
        }
        while (v424 != 1);
      }
      else
      {
        uint64_t v916 = -(uint64_t)v34;
        uint64_t v917 = -(uint64_t)(v1012 * v35);
        do
        {
          int v918 = v23;
          int v919 = v1015;
          do
          {
            if (*v30) {
              *(float16x4_t *)unint64_t v28 = vadd_f16(*(float16x4_t *)v28, vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v36), (float)*v30 * 0.0039216)));
            }
            v30 += v417;
            unint64_t v920 = v36 + 8 * v417;
            if (v920 >= v26) {
              uint64_t v921 = v916;
            }
            else {
              uint64_t v921 = 0;
            }
            unint64_t v36 = v920 + 8 * v921;
            v28 += 8 * v417;
            --v918;
          }
          while (v918);
          v30 += v1009;
          v28 += 8 * v1008;
          double result = v1014;
          unint64_t v922 = v1014 + 8 * v1012;
          if (v922 >= v1007) {
            uint64_t v923 = v917;
          }
          else {
            uint64_t v923 = 0;
          }
          unint64_t v924 = v922 + 8 * v923;
          uint64_t v925 = v26 + 8 * v923 + 8 * v1012;
          if (v1007)
          {
            unint64_t v26 = v925;
            double result = v924;
            unint64_t v36 = v924;
          }
          else
          {
            v36 += 8 * v1012;
          }
          unint64_t v1014 = result;
          --v1015;
        }
        while (v919 != 1);
      }
      return result;
    case 13:
      uint64_t v441 = v38;
      uint64_t v442 = (int)v25;
      uint64_t v443 = v1013;
      uint64_t v961 = -(uint64_t)(v1012 * v35);
      uint64_t v946 = -(uint64_t)(v1010 * v35);
      uint64_t v444 = 2 * (int)v22;
      uint64_t v445 = 8 * v38;
      uint64_t v446 = -(uint64_t)v34;
      uint64_t v976 = v444;
      uint64_t v991 = (int)v25;
      while (1)
      {
        int v447 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v443;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v450 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v450 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v451 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v452 = (__n128)vmulq_n_f32((float32x4_t)v451, v450);
              int32x2_t v453 = (int32x2_t)vcvt_f16_f32((float32x4_t)v452);
              if (v22)
              {
                a9.i16[0] = v453.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v458) = v453.i16[2];
                  LOWORD(v459) = v453.i16[3];
                  goto LABEL_338;
                }
                __asm { FCVT            S4, H1 }
                double v456 = COERCE_DOUBLE(vdup_lane_s32(v453, 1));
              }
              else
              {
                a9.i16[0] = v453.i16[1];
                double v456 = COERCE_DOUBLE(vdup_lane_s32(v453, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v452.n128_u16[0] = *(_WORD *)(v28 + 2);
              v451.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAmultiplyPDA(_Q0, v452, v451, _Q3, _S4, *(double *)&v453, *(double *)&a9, v456, result, a2, v23, v25, v22, a14, a15, a16, v453.i16[0], a9.i16[0], SLOWORD(v456),
                         SWORD1(v456),
                         _S16);
              unint64_t v458 = HIDWORD(result);
              unint64_t v459 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v453.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v444 = v976;
                uint64_t v442 = v991;
LABEL_338:
                *(_WORD *)unint64_t v28 = v453.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v458;
                *(_WORD *)(v28 + 6) = v459;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_340;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v444 = v976;
              uint64_t v442 = v991;
            }
          }
LABEL_340:
          v30 += v441;
          unint64_t v460 = v36 + 8 * v441;
          if (v460 >= v26) {
            uint64_t v461 = v446;
          }
          else {
            uint64_t v461 = 0;
          }
          v443 += v442 + v461;
          unint64_t v36 = v460 + 8 * v461;
          uint64_t v21 = (short float *)((char *)v21 + v444);
          v28 += v445;
          --v447;
        }
        while (v447);
        if (v1007)
        {
          unint64_t v462 = v1014 + 8 * v1012;
          uint64_t v463 = v946;
          if (v462 < v1007) {
            uint64_t v463 = 0;
          }
          uint64_t v443 = &v1013[v1010 + v463];
          uint64_t v464 = v961;
          if (v462 < v1007) {
            uint64_t v464 = 0;
          }
          unint64_t v36 = v462 + 8 * v464;
          v26 += 8 * v464 + 8 * v1012;
          v1013 += v1010 + v463;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v443 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 14:
      uint64_t v465 = v38;
      uint64_t v466 = (int)v25;
      int v467 = v1013;
      uint64_t v962 = -(uint64_t)(v1012 * v35);
      uint64_t v947 = -(uint64_t)(v1010 * v35);
      uint64_t v468 = 2 * (int)v22;
      uint64_t v469 = 8 * v38;
      uint64_t v470 = -(uint64_t)v34;
      uint64_t v977 = v468;
      uint64_t v992 = (int)v25;
      while (1)
      {
        int v471 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v467;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v474 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v474 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v475 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v476 = (__n128)vmulq_n_f32((float32x4_t)v475, v474);
              int32x2_t v477 = (int32x2_t)vcvt_f16_f32((float32x4_t)v476);
              if (v22)
              {
                a9.i16[0] = v477.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v482) = v477.i16[2];
                  LOWORD(v483) = v477.i16[3];
                  goto LABEL_367;
                }
                __asm { FCVT            S4, H1 }
                double v480 = COERCE_DOUBLE(vdup_lane_s32(v477, 1));
              }
              else
              {
                a9.i16[0] = v477.i16[1];
                double v480 = COERCE_DOUBLE(vdup_lane_s32(v477, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v476.n128_u16[0] = *(_WORD *)(v28 + 2);
              v475.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAscreenPDA(_Q0, v476, v475, _Q3, _S4, *(double *)&v477, *(double *)&a9, v480, result, a2, v23, v25, v22, a14, a15, a16, v477.i16[0], a9.i16[0], SLOWORD(v480),
                         SWORD1(v480),
                         _S16);
              unint64_t v482 = HIDWORD(result);
              unint64_t v483 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v477.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v468 = v977;
                uint64_t v466 = v992;
LABEL_367:
                *(_WORD *)unint64_t v28 = v477.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v482;
                *(_WORD *)(v28 + 6) = v483;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_369;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v468 = v977;
              uint64_t v466 = v992;
            }
          }
LABEL_369:
          v30 += v465;
          unint64_t v484 = v36 + 8 * v465;
          if (v484 >= v26) {
            uint64_t v485 = v470;
          }
          else {
            uint64_t v485 = 0;
          }
          v467 += v466 + v485;
          unint64_t v36 = v484 + 8 * v485;
          uint64_t v21 = (short float *)((char *)v21 + v468);
          v28 += v469;
          --v471;
        }
        while (v471);
        if (v1007)
        {
          unint64_t v486 = v1014 + 8 * v1012;
          uint64_t v487 = v947;
          if (v486 < v1007) {
            uint64_t v487 = 0;
          }
          int v467 = &v1013[v1010 + v487];
          uint64_t v488 = v962;
          if (v486 < v1007) {
            uint64_t v488 = 0;
          }
          unint64_t v36 = v486 + 8 * v488;
          v26 += 8 * v488 + 8 * v1012;
          v1013 += v1010 + v487;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v467 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 15:
      uint64_t v489 = v38;
      uint64_t v490 = (int)v25;
      uint64_t v491 = v1013;
      uint64_t v963 = -(uint64_t)(v1012 * v35);
      uint64_t v948 = -(uint64_t)(v1010 * v35);
      uint64_t v492 = 2 * (int)v22;
      uint64_t v493 = 8 * v38;
      uint64_t v494 = -(uint64_t)v34;
      uint64_t v978 = v492;
      uint64_t v993 = (int)v25;
      while (1)
      {
        int v495 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v491;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v498 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v498 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v499 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v500 = (__n128)vmulq_n_f32((float32x4_t)v499, v498);
              int32x2_t v501 = (int32x2_t)vcvt_f16_f32((float32x4_t)v500);
              if (v22)
              {
                a9.i16[0] = v501.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v506) = v501.i16[2];
                  LOWORD(v507) = v501.i16[3];
                  goto LABEL_396;
                }
                __asm { FCVT            S4, H1 }
                double v504 = COERCE_DOUBLE(vdup_lane_s32(v501, 1));
              }
              else
              {
                a9.i16[0] = v501.i16[1];
                double v504 = COERCE_DOUBLE(vdup_lane_s32(v501, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v500.n128_u16[0] = *(_WORD *)(v28 + 2);
              v499.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAoverlayPDA(_Q0, v500, v499, _Q3, _S4, *(double *)&v501, *(double *)&a9, v504, result, a2, v23, v25, v22, a14, a15, a16, v501.i16[0], a9.i16[0], SLOWORD(v504),
                         SWORD1(v504),
                         _S16);
              unint64_t v506 = HIDWORD(result);
              unint64_t v507 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v501.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v492 = v978;
                uint64_t v490 = v993;
LABEL_396:
                *(_WORD *)unint64_t v28 = v501.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v506;
                *(_WORD *)(v28 + 6) = v507;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_398;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v492 = v978;
              uint64_t v490 = v993;
            }
          }
LABEL_398:
          v30 += v489;
          unint64_t v508 = v36 + 8 * v489;
          if (v508 >= v26) {
            uint64_t v509 = v494;
          }
          else {
            uint64_t v509 = 0;
          }
          v491 += v490 + v509;
          unint64_t v36 = v508 + 8 * v509;
          uint64_t v21 = (short float *)((char *)v21 + v492);
          v28 += v493;
          --v495;
        }
        while (v495);
        if (v1007)
        {
          unint64_t v510 = v1014 + 8 * v1012;
          uint64_t v511 = v948;
          if (v510 < v1007) {
            uint64_t v511 = 0;
          }
          uint64_t v491 = &v1013[v1010 + v511];
          uint64_t v512 = v963;
          if (v510 < v1007) {
            uint64_t v512 = 0;
          }
          unint64_t v36 = v510 + 8 * v512;
          v26 += 8 * v512 + 8 * v1012;
          v1013 += v1010 + v511;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v491 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 16:
      uint64_t v513 = v38;
      uint64_t v514 = (int)v25;
      float v515 = v1013;
      uint64_t v964 = -(uint64_t)(v1012 * v35);
      uint64_t v949 = -(uint64_t)(v1010 * v35);
      uint64_t v516 = 2 * (int)v22;
      uint64_t v517 = 8 * v38;
      uint64_t v518 = -(uint64_t)v34;
      uint64_t v979 = v516;
      uint64_t v994 = (int)v25;
      while (1)
      {
        int v519 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v515;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v522 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v522 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v523 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v524 = (__n128)vmulq_n_f32((float32x4_t)v523, v522);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v524);
              if (v22)
              {
                a9.i16[0] = _Q5.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v528) = _Q5.i16[2];
                  LOWORD(v529) = _Q5.i16[3];
                  goto LABEL_425;
                }
                __asm { FCVT            S4, H1 }
                double v526 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
              }
              else
              {
                a9.i16[0] = _Q5.i16[1];
                double v526 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v524.n128_u16[0] = *(_WORD *)(v28 + 2);
              v523.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              v943.i32[1] = LODWORD(v526);
              v943.i16[1] = a9.i16[0];
              v943.i16[0] = _Q5.i16[0];
              double result = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v524, v523, _Q3, _Q4, _Q5, *(double *)&a9, v526, result, a2, v23, v25, v22, a14, a15, a16, v943, _S16);
              unint64_t v528 = HIDWORD(result);
              unint64_t v529 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                _Q5.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v516 = v979;
                uint64_t v514 = v994;
LABEL_425:
                *(_WORD *)unint64_t v28 = _Q5.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v528;
                *(_WORD *)(v28 + 6) = v529;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_427;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v516 = v979;
              uint64_t v514 = v994;
            }
          }
LABEL_427:
          v30 += v513;
          unint64_t v530 = v36 + 8 * v513;
          if (v530 >= v26) {
            uint64_t v531 = v518;
          }
          else {
            uint64_t v531 = 0;
          }
          v515 += v514 + v531;
          unint64_t v36 = v530 + 8 * v531;
          uint64_t v21 = (short float *)((char *)v21 + v516);
          v28 += v517;
          --v519;
        }
        while (v519);
        if (v1007)
        {
          unint64_t v532 = v1014 + 8 * v1012;
          uint64_t v533 = v949;
          if (v532 < v1007) {
            uint64_t v533 = 0;
          }
          float v515 = &v1013[v1010 + v533];
          uint64_t v534 = v964;
          if (v532 < v1007) {
            uint64_t v534 = 0;
          }
          unint64_t v36 = v532 + 8 * v534;
          v26 += 8 * v534 + 8 * v1012;
          v1013 += v1010 + v533;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v515 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 17:
      uint64_t v535 = v38;
      uint64_t v536 = (int)v25;
      float32x4_t v537 = v1013;
      uint64_t v965 = -(uint64_t)(v1012 * v35);
      uint64_t v950 = -(uint64_t)(v1010 * v35);
      uint64_t v538 = 2 * (int)v22;
      uint64_t v539 = 8 * v38;
      uint64_t v540 = -(uint64_t)v34;
      uint64_t v980 = v538;
      uint64_t v995 = (int)v25;
      while (1)
      {
        int v541 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v537;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v544 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v544 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v545 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v546 = (__n128)vmulq_n_f32((float32x4_t)v545, v544);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v546);
              if (v22)
              {
                a9.i16[0] = _Q5.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v550) = _Q5.i16[2];
                  LOWORD(v551) = _Q5.i16[3];
                  goto LABEL_454;
                }
                __asm { FCVT            S4, H1 }
                double v548 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
              }
              else
              {
                a9.i16[0] = _Q5.i16[1];
                double v548 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v546.n128_u16[0] = *(_WORD *)(v28 + 2);
              v545.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              v944.i32[1] = LODWORD(v548);
              v944.i16[1] = a9.i16[0];
              v944.i16[0] = _Q5.i16[0];
              double result = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v546, v545, _Q3, _Q4, _Q5, *(double *)&a9, v548, result, a2, v23, v25, v22, a14, a15, a16, v944, _S16);
              unint64_t v550 = HIDWORD(result);
              unint64_t v551 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                _Q5.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v538 = v980;
                uint64_t v536 = v995;
LABEL_454:
                *(_WORD *)unint64_t v28 = _Q5.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v550;
                *(_WORD *)(v28 + 6) = v551;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_456;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v538 = v980;
              uint64_t v536 = v995;
            }
          }
LABEL_456:
          v30 += v535;
          unint64_t v552 = v36 + 8 * v535;
          if (v552 >= v26) {
            uint64_t v553 = v540;
          }
          else {
            uint64_t v553 = 0;
          }
          v537 += v536 + v553;
          unint64_t v36 = v552 + 8 * v553;
          uint64_t v21 = (short float *)((char *)v21 + v538);
          v28 += v539;
          --v541;
        }
        while (v541);
        if (v1007)
        {
          unint64_t v554 = v1014 + 8 * v1012;
          uint64_t v555 = v950;
          if (v554 < v1007) {
            uint64_t v555 = 0;
          }
          float32x4_t v537 = &v1013[v1010 + v555];
          uint64_t v556 = v965;
          if (v554 < v1007) {
            uint64_t v556 = 0;
          }
          unint64_t v36 = v554 + 8 * v556;
          v26 += 8 * v556 + 8 * v1012;
          v1013 += v1010 + v555;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v537 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 18:
      uint64_t v557 = v38;
      uint64_t v558 = (int)v25;
      int v559 = v1013;
      uint64_t v966 = -(uint64_t)(v1012 * v35);
      uint64_t v951 = -(uint64_t)(v1010 * v35);
      uint64_t v560 = 2 * (int)v22;
      uint64_t v561 = 8 * v38;
      uint64_t v562 = -(uint64_t)v34;
      uint64_t v981 = v560;
      uint64_t v996 = (int)v25;
      while (1)
      {
        int v563 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v559;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v566 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v566 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v567 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v568 = (__n128)vmulq_n_f32((float32x4_t)v567, v566);
              int32x2_t v569 = (int32x2_t)vcvt_f16_f32((float32x4_t)v568);
              if (v22)
              {
                a9.i16[0] = v569.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v574) = v569.i16[2];
                  LOWORD(v575) = v569.i16[3];
                  goto LABEL_483;
                }
                __asm { FCVT            S4, H1 }
                double v572 = COERCE_DOUBLE(vdup_lane_s32(v569, 1));
              }
              else
              {
                a9.i16[0] = v569.i16[1];
                double v572 = COERCE_DOUBLE(vdup_lane_s32(v569, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v568.n128_u16[0] = *(_WORD *)(v28 + 2);
              v567.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAcolordodgePDA(_Q0, v568, v567, _Q3, _S4, *(double *)&v569, *(double *)&a9, v572, result, a2, v23, v25, v22, a14, a15, a16, v569.i16[0], a9.i16[0], SLOWORD(v572),
                         SWORD1(v572),
                         _S16);
              unint64_t v574 = HIDWORD(result);
              unint64_t v575 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v569.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v560 = v981;
                uint64_t v558 = v996;
LABEL_483:
                *(_WORD *)unint64_t v28 = v569.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v574;
                *(_WORD *)(v28 + 6) = v575;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_485;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v560 = v981;
              uint64_t v558 = v996;
            }
          }
LABEL_485:
          v30 += v557;
          unint64_t v576 = v36 + 8 * v557;
          if (v576 >= v26) {
            uint64_t v577 = v562;
          }
          else {
            uint64_t v577 = 0;
          }
          v559 += v558 + v577;
          unint64_t v36 = v576 + 8 * v577;
          uint64_t v21 = (short float *)((char *)v21 + v560);
          v28 += v561;
          --v563;
        }
        while (v563);
        if (v1007)
        {
          unint64_t v578 = v1014 + 8 * v1012;
          uint64_t v579 = v951;
          if (v578 < v1007) {
            uint64_t v579 = 0;
          }
          int v559 = &v1013[v1010 + v579];
          uint64_t v580 = v966;
          if (v578 < v1007) {
            uint64_t v580 = 0;
          }
          unint64_t v36 = v578 + 8 * v580;
          v26 += 8 * v580 + 8 * v1012;
          v1013 += v1010 + v579;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v559 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 19:
      uint64_t v581 = v38;
      uint64_t v582 = (int)v25;
      uint64_t v583 = v1013;
      uint64_t v967 = -(uint64_t)(v1012 * v35);
      uint64_t v952 = -(uint64_t)(v1010 * v35);
      uint64_t v584 = 2 * (int)v22;
      uint64_t v585 = 8 * v38;
      uint64_t v586 = -(uint64_t)v34;
      uint64_t v982 = v584;
      uint64_t v997 = (int)v25;
      while (1)
      {
        int v587 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v583;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v590 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v590 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v591 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v592 = (__n128)vmulq_n_f32((float32x4_t)v591, v590);
              int32x2_t v593 = (int32x2_t)vcvt_f16_f32((float32x4_t)v592);
              if (v22)
              {
                a9.i16[0] = v593.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v598) = v593.i16[2];
                  LOWORD(v599) = v593.i16[3];
                  goto LABEL_512;
                }
                __asm { FCVT            S4, H1 }
                double v596 = COERCE_DOUBLE(vdup_lane_s32(v593, 1));
              }
              else
              {
                a9.i16[0] = v593.i16[1];
                double v596 = COERCE_DOUBLE(vdup_lane_s32(v593, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v592.n128_u16[0] = *(_WORD *)(v28 + 2);
              v591.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAcolorburnPDA(_Q0, v592, v591, _Q3, _S4, *(double *)&v593, *(double *)&a9, v596, result, a2, v23, v25, v22, a14, a15, a16, v593.i16[0], a9.i16[0], SLOWORD(v596),
                         SWORD1(v596),
                         _S16);
              unint64_t v598 = HIDWORD(result);
              unint64_t v599 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v593.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v584 = v982;
                uint64_t v582 = v997;
LABEL_512:
                *(_WORD *)unint64_t v28 = v593.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v598;
                *(_WORD *)(v28 + 6) = v599;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_514;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v584 = v982;
              uint64_t v582 = v997;
            }
          }
LABEL_514:
          v30 += v581;
          unint64_t v600 = v36 + 8 * v581;
          if (v600 >= v26) {
            uint64_t v601 = v586;
          }
          else {
            uint64_t v601 = 0;
          }
          v583 += v582 + v601;
          unint64_t v36 = v600 + 8 * v601;
          uint64_t v21 = (short float *)((char *)v21 + v584);
          v28 += v585;
          --v587;
        }
        while (v587);
        if (v1007)
        {
          unint64_t v602 = v1014 + 8 * v1012;
          uint64_t v603 = v952;
          if (v602 < v1007) {
            uint64_t v603 = 0;
          }
          uint64_t v583 = &v1013[v1010 + v603];
          uint64_t v604 = v967;
          if (v602 < v1007) {
            uint64_t v604 = 0;
          }
          unint64_t v36 = v602 + 8 * v604;
          v26 += 8 * v604 + 8 * v1012;
          v1013 += v1010 + v603;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v583 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 20:
      uint64_t v605 = v38;
      uint64_t v606 = (int)v25;
      uint64_t v607 = v1013;
      uint64_t v968 = -(uint64_t)(v1012 * v35);
      uint64_t v953 = -(uint64_t)(v1010 * v35);
      uint64_t v608 = 2 * (int)v22;
      uint64_t v609 = 8 * v38;
      uint64_t v610 = -(uint64_t)v34;
      uint64_t v983 = v608;
      uint64_t v998 = (int)v25;
      while (1)
      {
        int v611 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v607;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v614 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v614 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v615 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v616 = (__n128)vmulq_n_f32((float32x4_t)v615, v614);
              int32x2_t v617 = (int32x2_t)vcvt_f16_f32((float32x4_t)v616);
              if (v22)
              {
                a9.i16[0] = v617.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v621) = v617.i16[2];
                  LOWORD(v622) = v617.i16[3];
                  goto LABEL_541;
                }
                __asm { FCVT            S4, H1 }
                double v619 = COERCE_DOUBLE(vdup_lane_s32(v617, 1));
              }
              else
              {
                a9.i16[0] = v617.i16[1];
                double v619 = COERCE_DOUBLE(vdup_lane_s32(v617, 1));
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v616.n128_u16[0] = *(_WORD *)(v28 + 2);
              v615.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              HIWORD(v945) = a9.i16[0];
              LOWORD(v945) = v617.i16[0];
              double result = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v616, v615, _Q3, *(double *)_Q4.i64, v617, *(double *)&a9, v619, result, a2, v23, v25, v22, a14, a15, a16, v945, SLOWORD(v619), SWORD1(v619),
                         _S16);
              unint64_t v621 = HIDWORD(result);
              unint64_t v622 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v617.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v608 = v983;
                uint64_t v606 = v998;
LABEL_541:
                *(_WORD *)unint64_t v28 = v617.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v621;
                *(_WORD *)(v28 + 6) = v622;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_543;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v608 = v983;
              uint64_t v606 = v998;
            }
          }
LABEL_543:
          v30 += v605;
          unint64_t v623 = v36 + 8 * v605;
          if (v623 >= v26) {
            uint64_t v624 = v610;
          }
          else {
            uint64_t v624 = 0;
          }
          v607 += v606 + v624;
          unint64_t v36 = v623 + 8 * v624;
          uint64_t v21 = (short float *)((char *)v21 + v608);
          v28 += v609;
          --v611;
        }
        while (v611);
        if (v1007)
        {
          unint64_t v625 = v1014 + 8 * v1012;
          uint64_t v626 = v953;
          if (v625 < v1007) {
            uint64_t v626 = 0;
          }
          uint64_t v607 = &v1013[v1010 + v626];
          uint64_t v627 = v968;
          if (v625 < v1007) {
            uint64_t v627 = 0;
          }
          unint64_t v36 = v625 + 8 * v627;
          v26 += 8 * v627 + 8 * v1012;
          v1013 += v1010 + v626;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v607 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 21:
      uint64_t v628 = v38;
      uint64_t v629 = (int)v25;
      int v630 = v1013;
      uint64_t v969 = -(uint64_t)(v1012 * v35);
      uint64_t v954 = -(uint64_t)(v1010 * v35);
      uint64_t v631 = 2 * (int)v22;
      uint64_t v632 = 8 * v38;
      uint64_t v633 = -(uint64_t)v34;
      uint64_t v984 = v631;
      uint64_t v999 = (int)v25;
      while (1)
      {
        int v634 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v630;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v637 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v637 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v638 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v639 = (__n128)vmulq_n_f32((float32x4_t)v638, v637);
              int32x2_t v640 = (int32x2_t)vcvt_f16_f32((float32x4_t)v639);
              if (v22)
              {
                a9.i16[0] = v640.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v645) = v640.i16[2];
                  LOWORD(v646) = v640.i16[3];
                  goto LABEL_570;
                }
                __asm { FCVT            S4, H1 }
                double v643 = COERCE_DOUBLE(vdup_lane_s32(v640, 1));
              }
              else
              {
                a9.i16[0] = v640.i16[1];
                double v643 = COERCE_DOUBLE(vdup_lane_s32(v640, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v639.n128_u16[0] = *(_WORD *)(v28 + 2);
              v638.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAhardlightPDA(_Q0, v639, v638, _Q3, _S4, *(double *)&v640, *(double *)&a9, v643, result, a2, v23, v25, v22, a14, a15, a16, v640.i16[0], a9.i16[0], SLOWORD(v643),
                         SWORD1(v643),
                         _S16);
              unint64_t v645 = HIDWORD(result);
              unint64_t v646 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v640.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v631 = v984;
                uint64_t v629 = v999;
LABEL_570:
                *(_WORD *)unint64_t v28 = v640.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v645;
                *(_WORD *)(v28 + 6) = v646;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_572;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v631 = v984;
              uint64_t v629 = v999;
            }
          }
LABEL_572:
          v30 += v628;
          unint64_t v647 = v36 + 8 * v628;
          if (v647 >= v26) {
            uint64_t v648 = v633;
          }
          else {
            uint64_t v648 = 0;
          }
          v630 += v629 + v648;
          unint64_t v36 = v647 + 8 * v648;
          uint64_t v21 = (short float *)((char *)v21 + v631);
          v28 += v632;
          --v634;
        }
        while (v634);
        if (v1007)
        {
          unint64_t v649 = v1014 + 8 * v1012;
          uint64_t v650 = v954;
          if (v649 < v1007) {
            uint64_t v650 = 0;
          }
          int v630 = &v1013[v1010 + v650];
          uint64_t v651 = v969;
          if (v649 < v1007) {
            uint64_t v651 = 0;
          }
          unint64_t v36 = v649 + 8 * v651;
          v26 += 8 * v651 + 8 * v1012;
          v1013 += v1010 + v650;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v630 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 22:
      uint64_t v652 = v38;
      uint64_t v653 = (int)v25;
      __int32 v654 = v1013;
      uint64_t v970 = -(uint64_t)(v1012 * v35);
      uint64_t v955 = -(uint64_t)(v1010 * v35);
      uint64_t v655 = 2 * (int)v22;
      uint64_t v656 = 8 * v38;
      uint64_t v657 = -(uint64_t)v34;
      uint64_t v985 = v655;
      uint64_t v1000 = (int)v25;
      while (1)
      {
        int v658 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v654;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v661 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v661 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v662 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v663 = (__n128)vmulq_n_f32((float32x4_t)v662, v661);
              int32x2_t v664 = (int32x2_t)vcvt_f16_f32((float32x4_t)v663);
              if (v22)
              {
                a9.i16[0] = v664.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v668) = v664.i16[2];
                  LOWORD(v669) = v664.i16[3];
                  goto LABEL_599;
                }
                __asm { FCVT            S4, H1 }
                double v666 = COERCE_DOUBLE(vdup_lane_s32(v664, 1));
              }
              else
              {
                a9.i16[0] = v664.i16[1];
                double v666 = COERCE_DOUBLE(vdup_lane_s32(v664, 1));
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v663.n128_u16[0] = *(_WORD *)(v28 + 2);
              v662.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAdifferencePDA(_Q0, v663, v662, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, v664, a9, v666, result, a2, v23, v25, v22, a14, a15, a16, v664.i16[0], a9.i16[0], SLOWORD(v666),
                         SWORD1(v666),
                         _S16);
              unint64_t v668 = HIDWORD(result);
              unint64_t v669 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v664.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v655 = v985;
                uint64_t v653 = v1000;
LABEL_599:
                *(_WORD *)unint64_t v28 = v664.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v668;
                *(_WORD *)(v28 + 6) = v669;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_601;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v655 = v985;
              uint64_t v653 = v1000;
            }
          }
LABEL_601:
          v30 += v652;
          unint64_t v670 = v36 + 8 * v652;
          if (v670 >= v26) {
            uint64_t v671 = v657;
          }
          else {
            uint64_t v671 = 0;
          }
          v654 += v653 + v671;
          unint64_t v36 = v670 + 8 * v671;
          uint64_t v21 = (short float *)((char *)v21 + v655);
          v28 += v656;
          --v658;
        }
        while (v658);
        if (v1007)
        {
          unint64_t v672 = v1014 + 8 * v1012;
          uint64_t v673 = v955;
          if (v672 < v1007) {
            uint64_t v673 = 0;
          }
          __int32 v654 = &v1013[v1010 + v673];
          uint64_t v674 = v970;
          if (v672 < v1007) {
            uint64_t v674 = 0;
          }
          unint64_t v36 = v672 + 8 * v674;
          v26 += 8 * v674 + 8 * v1012;
          v1013 += v1010 + v673;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v654 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 23:
      uint64_t v675 = v38;
      uint64_t v676 = (int)v25;
      float32x4_t v677 = v1013;
      uint64_t v971 = -(uint64_t)(v1012 * v35);
      uint64_t v956 = -(uint64_t)(v1010 * v35);
      uint64_t v678 = 2 * (int)v22;
      uint64_t v679 = 8 * v38;
      uint64_t v680 = -(uint64_t)v34;
      uint64_t v986 = v678;
      uint64_t v1001 = (int)v25;
      while (1)
      {
        int v681 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v677;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v684 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v684 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v685 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v686 = (__n128)vmulq_n_f32((float32x4_t)v685, v684);
              int32x2_t v687 = (int32x2_t)vcvt_f16_f32((float32x4_t)v686);
              if (v22)
              {
                a9.i16[0] = v687.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v691) = v687.i16[2];
                  LOWORD(v692) = v687.i16[3];
                  goto LABEL_628;
                }
                __asm { FCVT            S4, H1 }
                int32x2_t v689 = vdup_lane_s32(v687, 1);
              }
              else
              {
                a9.i16[0] = v687.i16[1];
                int32x2_t v689 = vdup_lane_s32(v687, 1);
                _Q4.i32[0] = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v686.n128_u16[0] = *(_WORD *)(v28 + 2);
              v685.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAexclusionPDA(_Q0, v686, v685, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, (float16x4_t)v687, *(double *)&a9, v689, result, a2, v23, v25, v22, a14, a15, a16, v687.i16[0], a9.i16[0], v689.i16[0],
                         v689.i16[1],
                         _S16);
              unint64_t v691 = HIDWORD(result);
              unint64_t v692 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v687.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v678 = v986;
                uint64_t v676 = v1001;
LABEL_628:
                *(_WORD *)unint64_t v28 = v687.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v691;
                *(_WORD *)(v28 + 6) = v692;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_630;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v678 = v986;
              uint64_t v676 = v1001;
            }
          }
LABEL_630:
          v30 += v675;
          unint64_t v693 = v36 + 8 * v675;
          if (v693 >= v26) {
            uint64_t v694 = v680;
          }
          else {
            uint64_t v694 = 0;
          }
          v677 += v676 + v694;
          unint64_t v36 = v693 + 8 * v694;
          uint64_t v21 = (short float *)((char *)v21 + v678);
          v28 += v679;
          --v681;
        }
        while (v681);
        if (v1007)
        {
          unint64_t v695 = v1014 + 8 * v1012;
          uint64_t v696 = v956;
          if (v695 < v1007) {
            uint64_t v696 = 0;
          }
          float32x4_t v677 = &v1013[v1010 + v696];
          uint64_t v697 = v971;
          if (v695 < v1007) {
            uint64_t v697 = 0;
          }
          unint64_t v36 = v695 + 8 * v697;
          v26 += 8 * v697 + 8 * v1012;
          v1013 += v1010 + v696;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v677 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 24:
      uint64_t v698 = v38;
      uint64_t v699 = (int)v25;
      int v700 = v1013;
      uint64_t v972 = -(uint64_t)(v1012 * v35);
      uint64_t v957 = -(uint64_t)(v1010 * v35);
      uint64_t v701 = 2 * (int)v22;
      uint64_t v702 = 8 * v38;
      uint64_t v703 = -(uint64_t)v34;
      uint64_t v987 = v701;
      uint64_t v1002 = (int)v25;
      while (1)
      {
        int v704 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v700;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v707 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v707 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v708 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v709 = (__n128)vmulq_n_f32((float32x4_t)v708, v707);
              int32x2_t v710 = (int32x2_t)vcvt_f16_f32((float32x4_t)v709);
              if (v22)
              {
                a9.i16[0] = v710.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v715) = v710.i16[2];
                  LOWORD(v716) = v710.i16[3];
                  goto LABEL_657;
                }
                __asm { FCVT            S4, H1 }
                double v713 = COERCE_DOUBLE(vdup_lane_s32(v710, 1));
              }
              else
              {
                a9.i16[0] = v710.i16[1];
                double v713 = COERCE_DOUBLE(vdup_lane_s32(v710, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v709.n128_u16[0] = *(_WORD *)(v28 + 2);
              v708.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAhuePDA(_Q0, v709, v708, _Q3, _S4, *(double *)&v710, *(double *)&a9, v713, result, a2, v23, v25, v22, a14, a15, a16, v710.i16[0], a9.i16[0], SLOWORD(v713),
                         SWORD1(v713),
                         _S16);
              unint64_t v715 = HIDWORD(result);
              unint64_t v716 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v710.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v701 = v987;
                uint64_t v699 = v1002;
LABEL_657:
                *(_WORD *)unint64_t v28 = v710.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v715;
                *(_WORD *)(v28 + 6) = v716;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_659;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v701 = v987;
              uint64_t v699 = v1002;
            }
          }
LABEL_659:
          v30 += v698;
          unint64_t v717 = v36 + 8 * v698;
          if (v717 >= v26) {
            uint64_t v718 = v703;
          }
          else {
            uint64_t v718 = 0;
          }
          v700 += v699 + v718;
          unint64_t v36 = v717 + 8 * v718;
          uint64_t v21 = (short float *)((char *)v21 + v701);
          v28 += v702;
          --v704;
        }
        while (v704);
        if (v1007)
        {
          unint64_t v719 = v1014 + 8 * v1012;
          uint64_t v720 = v957;
          if (v719 < v1007) {
            uint64_t v720 = 0;
          }
          int v700 = &v1013[v1010 + v720];
          uint64_t v721 = v972;
          if (v719 < v1007) {
            uint64_t v721 = 0;
          }
          unint64_t v36 = v719 + 8 * v721;
          v26 += 8 * v721 + 8 * v1012;
          v1013 += v1010 + v720;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v700 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 25:
      uint64_t v722 = v38;
      uint64_t v723 = (int)v25;
      long long v724 = v1013;
      uint64_t v973 = -(uint64_t)(v1012 * v35);
      uint64_t v958 = -(uint64_t)(v1010 * v35);
      uint64_t v725 = 2 * (int)v22;
      uint64_t v726 = 8 * v38;
      uint64_t v727 = -(uint64_t)v34;
      uint64_t v988 = v725;
      uint64_t v1003 = (int)v25;
      while (1)
      {
        int v728 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v724;
              __asm { FCVT            S0, H0 }
            }
            else
            {
              _S0 = 1.0;
            }
            float v731 = (float)*v30 * 0.0039216;
            _Q0.n128_f32[0] = v731 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v732 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v733 = (__n128)vmulq_n_f32((float32x4_t)v732, v731);
              int32x2_t v734 = (int32x2_t)vcvt_f16_f32((float32x4_t)v733);
              if (v22)
              {
                a9.i16[0] = v734.i16[1];
                __asm { FCMP            H1, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v739) = v734.i16[2];
                  LOWORD(v740) = v734.i16[3];
                  goto LABEL_686;
                }
                __asm { FCVT            S4, H1 }
                double v737 = COERCE_DOUBLE(vdup_lane_s32(v734, 1));
              }
              else
              {
                a9.i16[0] = v734.i16[1];
                double v737 = COERCE_DOUBLE(vdup_lane_s32(v734, 1));
                _S4 = 1.0;
              }
              __asm { FCVT            S16, H0 }
              _Q0.n128_u16[0] = *(_WORD *)v28;
              v733.n128_u16[0] = *(_WORD *)(v28 + 2);
              v732.n128_u16[0] = *(_WORD *)(v28 + 4);
              _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
              double result = PDAsaturationPDA(_Q0, v733, v732, _Q3, _S4, *(double *)&v734, *(double *)&a9, v737, result, a2, v23, v25, v22, a14, a15, a16, v734.i16[0], a9.i16[0], SLOWORD(v737),
                         SWORD1(v737),
                         _S16);
              unint64_t v739 = HIDWORD(result);
              unint64_t v740 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v734.i16[0] = result;
                a9.i32[0] = result >> 16;
                _Q0.n128_u16[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v725 = v988;
                uint64_t v723 = v1003;
LABEL_686:
                *(_WORD *)unint64_t v28 = v734.i16[0];
                *(_WORD *)(v28 + 2) = a9.i16[0];
                *(_WORD *)(v28 + 4) = v739;
                *(_WORD *)(v28 + 6) = v740;
                *uint64_t v21 = *(short float *)_Q0.n128_u16;
                goto LABEL_688;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v725 = v988;
              uint64_t v723 = v1003;
            }
          }
LABEL_688:
          v30 += v722;
          unint64_t v741 = v36 + 8 * v722;
          if (v741 >= v26) {
            uint64_t v742 = v727;
          }
          else {
            uint64_t v742 = 0;
          }
          v724 += v723 + v742;
          unint64_t v36 = v741 + 8 * v742;
          uint64_t v21 = (short float *)((char *)v21 + v725);
          v28 += v726;
          --v728;
        }
        while (v728);
        if (v1007)
        {
          unint64_t v743 = v1014 + 8 * v1012;
          uint64_t v744 = v958;
          if (v743 < v1007) {
            uint64_t v744 = 0;
          }
          long long v724 = &v1013[v1010 + v744];
          uint64_t v745 = v973;
          if (v743 < v1007) {
            uint64_t v745 = 0;
          }
          unint64_t v36 = v743 + 8 * v745;
          v26 += 8 * v745 + 8 * v1012;
          v1013 += v1010 + v744;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v724 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 26:
      uint64_t v746 = v38;
      uint64_t v747 = (int)v25;
      int v748 = v1013;
      uint64_t v974 = -(uint64_t)(v1012 * v35);
      uint64_t v959 = -(uint64_t)(v1010 * v35);
      uint64_t v749 = 2 * (int)v22;
      uint64_t v750 = 8 * v38;
      uint64_t v751 = -(uint64_t)v34;
      uint64_t v989 = v749;
      uint64_t v1004 = (int)v25;
      while (1)
      {
        int v752 = v1011;
        do
        {
          if (*v30)
          {
            if (v25)
            {
              _H0 = *v748;
              __asm { FCVT            S1, H0 }
            }
            else
            {
              _S1 = 1.0;
            }
            float v755 = (float)*v30 * 0.0039216;
            _S1 = v755 * _S1;
            __asm
            {
              FCVT            H3, S1
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v758 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
              __n128 v759 = (__n128)vmulq_n_f32((float32x4_t)v758, v755);
              v759.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v759);
              if (v22)
              {
                v758.n128_u16[0] = v759.n128_u16[1];
                __asm { FCMP            H2, #0 }
                if (_NF ^ _VF | _ZF)
                {
                  LOWORD(v762) = v759.n128_u16[2];
                  LOWORD(v763) = v759.n128_u16[3];
                  goto LABEL_715;
                }
                __asm { FCVT            S5, H2 }
                _Q2.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v759.n128_u64[0], 1);
              }
              else
              {
                v758.n128_u16[0] = v759.n128_u16[1];
                _Q2.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v759.n128_u64[0], 1);
                _Q5.i32[0] = 1.0;
              }
              __asm { FCVT            S4, H3 }
              _Q3.n128_u16[0] = _Q2.n128_u16[1];
              double result = PDAluminosityPDA(v759, v758, _Q2, _Q3, _S4, *(double *)_Q5.i64, *(double *)&a9, a10, result, a2, v23, v25, v22, a14, a15, a16, *(_DWORD *)v28, HIWORD(*(_DWORD *)v28), *(_DWORD *)(v28 + 4),
                         HIWORD(*(_DWORD *)(v28 + 4)),
                         _Q5.f32[0]);
              unint64_t v762 = HIDWORD(result);
              unint64_t v763 = HIWORD(result);
              uint64_t v22 = v1017;
              if (v1017)
              {
                v758.n128_u16[0] = WORD1(result);
                v759.n128_u16[0] = result;
                _Q3.n128_u32[0] = a2;
                uint64_t v25 = v1016;
                uint64_t v749 = v989;
                uint64_t v747 = v1004;
LABEL_715:
                *(_WORD *)unint64_t v28 = v759.n128_u16[0];
                *(_WORD *)(v28 + 2) = v758.n128_u16[0];
                *(_WORD *)(v28 + 4) = v762;
                *(_WORD *)(v28 + 6) = v763;
                *uint64_t v21 = *(short float *)_Q3.n128_u16;
                goto LABEL_717;
              }
              *(void *)unint64_t v28 = result;
              uint64_t v25 = v1016;
              uint64_t v749 = v989;
              uint64_t v747 = v1004;
            }
          }
LABEL_717:
          v30 += v746;
          unint64_t v764 = v36 + 8 * v746;
          if (v764 >= v26) {
            uint64_t v765 = v751;
          }
          else {
            uint64_t v765 = 0;
          }
          v748 += v747 + v765;
          unint64_t v36 = v764 + 8 * v765;
          uint64_t v21 = (short float *)((char *)v21 + v749);
          v28 += v750;
          --v752;
        }
        while (v752);
        if (v1007)
        {
          unint64_t v766 = v1014 + 8 * v1012;
          uint64_t v767 = v959;
          if (v766 < v1007) {
            uint64_t v767 = 0;
          }
          int v748 = &v1013[v1010 + v767];
          uint64_t v768 = v974;
          if (v766 < v1007) {
            uint64_t v768 = 0;
          }
          unint64_t v36 = v766 + 8 * v768;
          v26 += 8 * v768 + 8 * v1012;
          v1013 += v1010 + v767;
          unint64_t v1014 = v36;
        }
        else
        {
          v36 += 8 * v1012;
          v748 += v1010;
        }
        v30 += v1009;
        v28 += 8 * v1008;
        v21 += v1006;
        if (!--v1015) {
          return result;
        }
      }
    case 27:
      uint64_t v769 = v38;
      uint64_t v770 = (int)v25;
      int v771 = v1013;
      uint64_t v975 = -(uint64_t)(v1012 * v35);
      uint64_t v960 = -(uint64_t)(v1010 * v35);
      uint64_t v772 = 2 * (int)v22;
      uint64_t v773 = 8 * v38;
      uint64_t v774 = -(uint64_t)v34;
      uint64_t v990 = v772;
      uint64_t v1005 = (int)v25;
      break;
    default:
      return result;
  }
  do
  {
    int v775 = v1011;
    do
    {
      if (*v30)
      {
        if (v25)
        {
          _H0 = *v771;
          __asm { FCVT            S0, H0 }
        }
        else
        {
          _S0 = 1.0;
        }
        float v778 = (float)*v30 * 0.0039216;
        _Q0.n128_f32[0] = v778 * _S0;
        __asm
        {
          FCVT            H0, S0
          FCMP            H0, #0
        }
        if (!(_NF ^ _VF | _ZF))
        {
          __n128 v779 = (__n128)vcvtq_f32_f16(*(float16x4_t *)v36);
          __n128 v780 = (__n128)vmulq_n_f32((float32x4_t)v779, v778);
          int32x2_t v781 = (int32x2_t)vcvt_f16_f32((float32x4_t)v780);
          if (v22)
          {
            a9.i16[0] = v781.i16[1];
            __asm { FCMP            H1, #0 }
            if (_NF ^ _VF | _ZF)
            {
              LOWORD(v786) = v781.i16[2];
              LOWORD(v787) = v781.i16[3];
              goto LABEL_744;
            }
            __asm { FCVT            S4, H1 }
            double v784 = COERCE_DOUBLE(vdup_lane_s32(v781, 1));
          }
          else
          {
            a9.i16[0] = v781.i16[1];
            double v784 = COERCE_DOUBLE(vdup_lane_s32(v781, 1));
            _S4 = 1.0;
          }
          __asm { FCVT            S16, H0 }
          _Q0.n128_u16[0] = *(_WORD *)v28;
          v780.n128_u16[0] = *(_WORD *)(v28 + 2);
          v779.n128_u16[0] = *(_WORD *)(v28 + 4);
          _Q3.n128_u16[0] = *(_WORD *)(v28 + 6);
          double result = PDAluminosityPDA(_Q0, v780, v779, _Q3, _S4, *(double *)&v781, *(double *)&a9, v784, result, a2, v23, v25, v22, a14, a15, a16, v781.i16[0], a9.i16[0], SLOWORD(v784),
                     SWORD1(v784),
                     _S16);
          unint64_t v786 = HIDWORD(result);
          unint64_t v787 = HIWORD(result);
          uint64_t v22 = v1017;
          if (v1017)
          {
            v781.i16[0] = result;
            a9.i32[0] = result >> 16;
            _Q0.n128_u16[0] = a2;
            uint64_t v25 = v1016;
            uint64_t v772 = v990;
            uint64_t v770 = v1005;
LABEL_744:
            *(_WORD *)unint64_t v28 = v781.i16[0];
            *(_WORD *)(v28 + 2) = a9.i16[0];
            *(_WORD *)(v28 + 4) = v786;
            *(_WORD *)(v28 + 6) = v787;
            *uint64_t v21 = *(short float *)_Q0.n128_u16;
            goto LABEL_746;
          }
          *(void *)unint64_t v28 = result;
          uint64_t v25 = v1016;
          uint64_t v772 = v990;
          uint64_t v770 = v1005;
        }
      }
LABEL_746:
      v30 += v769;
      unint64_t v788 = v36 + 8 * v769;
      if (v788 >= v26) {
        uint64_t v789 = v774;
      }
      else {
        uint64_t v789 = 0;
      }
      v771 += v770 + v789;
      unint64_t v36 = v788 + 8 * v789;
      uint64_t v21 = (short float *)((char *)v21 + v772);
      v28 += v773;
      --v775;
    }
    while (v775);
    if (v1007)
    {
      unint64_t v790 = v1014 + 8 * v1012;
      uint64_t v791 = v960;
      if (v790 < v1007) {
        uint64_t v791 = 0;
      }
      int v771 = &v1013[v1010 + v791];
      uint64_t v792 = v975;
      if (v790 < v1007) {
        uint64_t v792 = 0;
      }
      unint64_t v36 = v790 + 8 * v792;
      v26 += 8 * v792 + 8 * v1012;
      v1013 += v1010 + v791;
      unint64_t v1014 = v36;
    }
    else
    {
      v36 += 8 * v1012;
      v771 += v1010;
    }
    v30 += v1009;
    v28 += 8 * v1008;
    v21 += v1006;
    --v1015;
  }
  while (v1015);
  return result;
}