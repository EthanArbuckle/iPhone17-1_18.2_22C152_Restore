uint64_t CMYKf16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  BOOL v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t (*v26)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, float32x4_t);
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  _OWORD v32[64];
  uint64_t v33;

  v33 = *MEMORY[0x1E4F143B8];
  v6 = (int *)*a1;
  memset(v32, 0, 512);
  if (*((void *)a2 + 12)) {
    v7 = 0;
  }
  else {
    v7 = *(float *)(a3 + 8) >= 1.0;
  }
  v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v26, (uint64_t)v32) < 1) {
    return 0xFFFFFFFFLL;
  }
  v18 = *v6;
  v19 = *(_DWORD *)a3;
  v27 = v19;
  v28 = v18;
  if (v19 != 269501477)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 <= 0x1B) {
        _CGHandleAssert("CMYKf16_image_inner", 15096, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_float16/blt_cmyk_float16.cc", "index > SAMPLEF", "index = %d", v21, v22, v23, v20);
      }
      v26 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, float32x4_t))CMYKF16_image_sample[v20 + 1];
      if (v26)
      {
        v27 = 269501477;
        goto LABEL_27;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, float32x4_t))&CMYK8_image_sample[2 * v20 + 2];
        if (v26)
        {
          v24 = 8;
          v25 = 134759444;
LABEL_26:
          v29 = v24;
          v27 = v25;
          goto LABEL_27;
        }
      }
      v26 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int, double, double, double, double, double, double, float32x4_t))&CMYK16_image_sample[2 * v20 + 2];
      if (v26)
      {
        v24 = 16;
        v25 = 269501476;
        goto LABEL_26;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v31 && (~v30 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v30 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      CMYKf16_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  v26 = CMYKf16_sample_CMYKf_inner;
LABEL_27:
  CMYKf16_image_mark((uint64_t)a2, (uint64_t)&v26, v8, v17);
  return 1;
}

void CMYKf16_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v716 = a3;
  uint64_t v728 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  int v721 = *(_DWORD *)(a1 + 8);
  uint64_t v714 = v4;
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  v8 = *(int **)(a1 + 136);
  unint64_t v9 = *(void *)(a2 + 96);
  uint64_t v724 = *(void *)(a2 + 104);
  int v727 = 0;
  *(void *)(a2 + 264) = &v727;
  uint64_t v713 = (int)v4;
  unint64_t v10 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v10 > 0x1FFFFFF) {
    return;
  }
  __n128 v719 = a4;
  uint64_t v13 = *(int *)(a1 + 12);
  uint64_t v12 = *(int *)(a1 + 16);
  v715 = (void *)a2;
  v723 = (void *)*(int *)(a2 + 16);
  uint64_t v14 = ((void)v723 + 12) * v10;
  if (v14 > 65439)
  {
    v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x768749E2uLL);
    v16 = v17;
    v19 = v17;
    v20 = v715;
    if (!v17) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    v16 = (char *)&v709 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    v19 = 0;
    v20 = v715;
  }
  v710 = v19;
  unint64_t v21 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v22 = v21 + ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v723) {
    unint64_t v23 = (10 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    unint64_t v23 = 0;
  }
  unint64_t v24 = v22 + v23;
  unint64_t v25 = v5 >> 3;
  v20[18] = v21;
  v20[19] = v24;
  v20[20] = v22;
  if (v7)
  {
    unint64_t v26 = (unint64_t)*(int *)(a1 + 32) >> 1;
    v27 = (short float *)(v7 + 2 * (v13 + v26 * v12));
    uint64_t v28 = v713;
    int v29 = v714;
    uint64_t v720 = v26 - v713;
    uint64_t v726 = 1;
  }
  else
  {
    v27 = 0;
    uint64_t v720 = 0;
    uint64_t v726 = 0;
    uint64_t v28 = v713;
    int v29 = v714;
  }
  unint64_t v30 = v9;
  uint64_t v31 = v6 + 8 * (v13 + v25 * v12);
  uint64_t v718 = v25 - v28;
  uint64_t v32 = *(int *)(a1 + 104);
  int v33 = *(_DWORD *)(a1 + 108);
  int v34 = *(unsigned __int8 *)(a1 + 2);
  if (v34 == 6 || v34 == 1)
  {
    int v35 = v716;
    v36 = v715;
    if (v8)
    {
      unint64_t v709 = v25;
      v37 = 0;
      int v725 = 0;
      uint64_t v38 = *(int *)(a1 + 124);
      v39 = (unsigned __int8 *)v8 + v32 + (int)v38 * (uint64_t)v33;
      uint64_t v28 = v713;
      uint64_t v717 = v38 - v713;
      goto LABEL_21;
    }
    goto LABEL_586;
  }
  unint64_t v709 = v25;
  int v35 = v716;
  v36 = v715;
  if (v8)
  {
    unint64_t v722 = v24;
    shape_enum_clip_alloc((uint64_t)v17, v18, v8, 1, 1, 1, v32, v33, v29, v721);
    if (!v40) {
      goto LABEL_586;
    }
    v41 = v40;
    int v725 = 0;
    unint64_t v42 = (int)((v723 * v10 + 15) & 0xFFFFFFF0);
    if (!v723) {
      unint64_t v42 = (10 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    uint64_t v43 = v713;
    uint64_t v717 = -v713;
    v39 = (unsigned __int8 *)(v722 + v42 + 16);
LABEL_589:
    uint64_t v699 = v720 + v43;
    int v700 = v725;
LABEL_590:
    int v725 = v700;
    while (1)
    {
      int v701 = *((_DWORD *)v39 - 4);
      int v702 = v700;
      _VF = __OFSUB__(v701, v700);
      int v703 = v701 - v700;
      if (!((v703 < 0) ^ _VF | (v703 == 0)))
      {
        v721 -= v703;
        if (v721 < 1) {
          goto LABEL_584;
        }
        v30 += v36[16] * v703;
        v724 += v36[17] * v703;
        v31 += 8 * v709 * v703;
        uint64_t v705 = v699 * v703;
        if (!v726) {
          uint64_t v705 = 0;
        }
        v27 += v705;
        int v700 = v701;
        goto LABEL_590;
      }
      if (v702 < *((_DWORD *)v39 - 3) + v701) {
        break;
      }
      int v704 = shape_enum_clip_scan((uint64_t)v41, (_DWORD *)v39 - 4);
      int v700 = v725;
      if (!v704) {
        goto LABEL_584;
      }
    }
    uint64_t v28 = v713;
    v37 = v41;
  }
  else
  {
    uint64_t v717 = 0;
    v37 = 0;
    v39 = 0;
    int v725 = 0;
  }
LABEL_21:
  uint64_t v711 = -v28;
  uint64_t v712 = (v29 - 1) + 1;
  uint64_t v44 = 2 * v726;
  v45 = v37;
  int v46 = v721;
  uint64_t v47 = v724;
  while (2)
  {
    unint64_t v722 = v30;
    v723 = v45;
    *((_DWORD *)v36 + 60) = v46;
    v48 = (uint64_t (*)(void *, unint64_t))*v36;
    uint64_t v724 = v47;
    unint64_t v49 = v48(v36, v30);
    v65 = (float16x4_t *)v36[20];
    v66 = (unsigned __int8 *)v36[18];
    unsigned int v67 = *((_DWORD *)v36 + 2);
    if (v67 == *((_DWORD *)v36 + 3))
    {
      _Q1.i64[0] = v719.n128_u64[0];
      if (v719.n128_f32[0] < 1.0)
      {
        int v68 = v29;
        v69 = (unsigned char *)v36[18];
        do
        {
          if (*v69)
          {
            _Q0 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*v65), _Q1.f32[0]);
            _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
            float16x4_t *v65 = (float16x4_t)_Q0.n128_u64[0];
            _Q0.n128_u16[0] = v65[1].u16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = _Q1.f32[0] * _Q0.n128_f32[0];
            __asm { FCVT            H0, S0 }
            v65[1].i16[0] = _Q0.n128_u16[0];
          }
          ++v69;
          v65 = (float16x4_t *)((char *)v65 + 10);
          --v68;
        }
        while (v68);
        v65 = (float16x4_t *)((char *)v65 + 10 * v711);
        v66 += v712 + v711;
      }
    }
    else
    {
      uint64_t v74 = v36[19];
      int v75 = HIWORD(v67) & 0x3F;
      __n128 v59 = v719;
      if (v75 == 16)
      {
        uint64_t v79 = 0;
        v80 = (unsigned __int16 *)(v74 + 8);
        v81 = (_WORD *)v65 + 2;
        if (v719.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v66[v79])
            {
              unint64_t v89 = *v80;
              unint64_t v90 = *((void *)v80 - 1);
              _S0 = *(float *)&_blt_float[v90 + 256] + *(float *)&_blt_float[BYTE1(v90) + 512];
              __asm { FCVT            H0, S0 }
              *(v81 - 2) = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE2(v90) + 256] + *(float *)&_blt_float[BYTE3(v90) | 0x200];
              __asm { FCVT            H0, S0 }
              *(v81 - 1) = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE4(v90) + 256] + *(float *)&_blt_float[BYTE5(v90) + 512];
              __asm { FCVT            H0, S0 }
              _WORD *v81 = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[BYTE6(v90) + 256] + *(float *)&_blt_float[HIBYTE(v90) + 512];
              __asm { FCVT            H0, S0 }
              v81[1] = LOWORD(_S0);
              _S0 = *(float *)&_blt_float[v89 + 256]
                  + *(float *)((char *)&_blt_float[512] + ((v89 >> 6) & 0x3FC));
              __asm { FCVT            H0, S0 }
              v81[2] = LOWORD(_S0);
            }
            v80 += 8;
            ++v79;
            v81 += 5;
          }
          while (v29 != v79);
        }
        else
        {
          do
          {
            if (v66[v79])
            {
              unint64_t v82 = *v80;
              unint64_t v83 = *((void *)v80 - 1);
              _S0 = v59.n128_f32[0]
                  * (float)(*(float *)&_blt_float[v83 + 256] + *(float *)&_blt_float[BYTE1(v83) + 512]);
              __asm { FCVT            H0, S0 }
              *(v81 - 2) = LOWORD(_S0);
              _S0 = v59.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE2(v83) + 256] + *(float *)&_blt_float[BYTE3(v83) | 0x200]);
              __asm { FCVT            H0, S0 }
              *(v81 - 1) = LOWORD(_S0);
              _S0 = v59.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE4(v83) + 256] + *(float *)&_blt_float[BYTE5(v83) + 512]);
              __asm { FCVT            H0, S0 }
              _WORD *v81 = LOWORD(_S0);
              _S0 = v59.n128_f32[0]
                  * (float)(*(float *)&_blt_float[BYTE6(v83) + 256] + *(float *)&_blt_float[HIBYTE(v83) + 512]);
              __asm { FCVT            H0, S0 }
              v81[1] = LOWORD(_S0);
              _S0 = v59.n128_f32[0]
                  * (float)(*(float *)&_blt_float[v82 + 256]
                          + *(float *)((char *)&_blt_float[512] + ((v82 >> 6) & 0x3FC)));
              __asm { FCVT            H0, S0 }
              v81[2] = LOWORD(_S0);
            }
            v80 += 8;
            ++v79;
            v81 += 5;
          }
          while (v29 != v79);
        }
      }
      else if (v75 == 32)
      {
        uint64_t v76 = 0;
        v77 = (_WORD *)(v74 + 8);
        v78 = v65 + 1;
        if (v719.n128_f32[0] >= 1.0)
        {
          do
          {
            if (v66[v76])
            {
              _Q0.n128_u64[0] = *((void *)v77 - 1);
              v78[-1] = (float16x4_t)_Q0.n128_u64[0];
              v78->i16[0] = *v77;
            }
            v77 += 5;
            ++v76;
            v78 = (float16x4_t *)((char *)v78 + 10);
          }
          while (v29 != v76);
        }
        else
        {
          do
          {
            if (v66[v76])
            {
              _Q0 = (__n128)vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)(v77 - 4)), v59.n128_f32[0]);
              _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
              v78[-1] = (float16x4_t)_Q0.n128_u64[0];
              _Q0.n128_u16[0] = *v77;
              __asm { FCVT            S0, H0 }
              _Q0.n128_f32[0] = v59.n128_f32[0] * _Q0.n128_f32[0];
              __asm { FCVT            H0, S0 }
              v78->i16[0] = _Q0.n128_u16[0];
            }
            v77 += 5;
            ++v76;
            v78 = (float16x4_t *)((char *)v78 + 10);
          }
          while (v29 != v76);
        }
      }
      else
      {
        uint64_t v96 = 0;
        if (v719.n128_f32[0] >= 1.0)
        {
          v100 = (_WORD *)v65 + 2;
          do
          {
            if (v66[v96])
            {
              uint64_t v101 = *(void *)(v74 + 8 * v96);
              _S0 = _blt_float[BYTE3(v101)];
              __asm { FCVT            H0, S0 }
              *(v100 - 2) = _S0;
              _S0 = _blt_float[BYTE2(v101)];
              __asm { FCVT            H0, S0 }
              *(v100 - 1) = _S0;
              _S0 = _blt_float[BYTE1(v101)];
              __asm { FCVT            H0, S0 }
              _WORD *v100 = _S0;
              _S0 = _blt_float[v101];
              __asm { FCVT            H0, S0 }
              v100[1] = _S0;
              _S0 = _blt_float[BYTE4(v101)];
              __asm { FCVT            H0, S0 }
              v100[2] = _S0;
            }
            ++v96;
            v100 += 5;
          }
          while (v29 != v96);
        }
        else
        {
          v97 = v65 + 1;
          do
          {
            if (v66[v96])
            {
              uint64_t v98 = *(void *)(v74 + 8 * v96);
              v99.i32[0] = _blt_float[BYTE3(v98)];
              v99.i32[1] = _blt_float[BYTE2(v98)];
              v99.i32[2] = _blt_float[BYTE1(v98)];
              v99.i32[3] = _blt_float[v98];
              _Q0 = (__n128)vmulq_n_f32(v99, v59.n128_f32[0]);
              _Q0.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)_Q0);
              v97[-1] = (float16x4_t)_Q0.n128_u64[0];
              _Q0.n128_f32[0] = v59.n128_f32[0] * *(float *)&_blt_float[BYTE4(v98)];
              __asm { FCVT            H0, S0 }
              v97->i16[0] = _Q0.n128_u16[0];
            }
            ++v96;
            v97 = (float16x4_t *)((char *)v97 + 10);
          }
          while (v29 != v96);
        }
      }
    }
    int v107 = v725;
    v108 = &xmmword_1850CE000;
    switch(v35)
    {
      case 0:
        uint64_t v109 = v39 != 0;
        if (v726)
        {
          int v110 = v29;
          v111 = v39;
          do
          {
            unsigned int v112 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v112 = (*v111 * v112 + ((*v111 * v112) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v112)
              {
                if (v112 == 255)
                {
                  *(void *)uint64_t v31 = 0;
                  _H0 = 0;
                }
                else
                {
                  float v114 = (float)((float)v112 * -0.0039216) + 1.0;
                  *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), v114));
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _S0 = v114 * _S1;
                  __asm { FCVT            H0, S0 }
                }
                *(_WORD *)v27 = _H0;
              }
            }
            ++v66;
            v111 += v109;
            v31 += 8;
            ++v27;
            --v110;
          }
          while (v110);
        }
        else
        {
          int v589 = v29;
          v111 = v39;
          do
          {
            unsigned int v590 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v590 = (*v111 * v590 + ((*v111 * v590) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v590)
              {
                if (v590 == 255) {
                  *(void *)uint64_t v31 = 0;
                }
                else {
                  *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), (float)((float)v590 * -0.0039216) + 1.0));
                }
              }
            }
            ++v66;
            v111 += v109;
            v31 += 8;
            --v589;
          }
          while (v589);
        }
        goto LABEL_522;
      case 1:
        unsigned __int8 v119 = *v66;
        if (v726)
        {
          if (v39)
          {
            uint64_t v120 = 0;
            v121 = v65 + 1;
            v122 = v66 + 1;
            v123 = v27 - 1;
            v124 = (float16x4_t *)(v31 - 8);
            unint64_t v118 = v722;
            do
            {
              if (v119)
              {
                unsigned int v125 = ((unsigned __int16)(v39[v120] * v119
                                                          + ((v39[v120] * v119) >> 8)
                                                          + 1) >> 8);
                if (v125)
                {
                  if (v125 == 255)
                  {
                    *(float16x4_t *)(v31 + 8 * v120) = v121[-1];
                    _H0 = v121->i16[0];
                  }
                  else
                  {
                    float v127 = (float)v125 * 0.0039216;
                    *(float16x4_t *)(v31 + 8 * v120) = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)(v31 + 8 * v120)), 1.0 - v127), vcvtq_f32_f16(v121[-1]), v127));
                    _H2 = v121->i16[0];
                    __asm { FCVT            S2, H2 }
                    _H3 = v27[v120];
                    __asm { FCVT            S3, H3 }
                    _S0 = (float)((float)(1.0 - v127) * _S3) + (float)(_S2 * v127);
                    __asm { FCVT            H0, S0 }
                  }
                  LOWORD(v27[v120]) = _H0;
                }
              }
              unsigned __int8 v119 = v122[v120++];
              v121 = (float16x4_t *)((char *)v121 + 10);
              ++v123;
              ++v124;
            }
            while (v29 != v120);
            v39 += v120 + v717;
          }
          else
          {
            v658 = v65 + 1;
            v659 = v66 + 1;
            v123 = v27 - 1;
            v124 = (float16x4_t *)(v31 - 8);
            int v660 = v29;
            unint64_t v118 = v722;
            do
            {
              if (v119)
              {
                if (v119 == 255)
                {
                  v124[1] = v658[-1];
                  _H0 = v658->i16[0];
                }
                else
                {
                  float v662 = (float)v119 * 0.0039216;
                  v124[1] = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v124[1]), 1.0 - v662), vcvtq_f32_f16(v658[-1]), v662));
                  _H2 = v658->i16[0];
                  __asm { FCVT            S2, H2 }
                  _H3 = *((_WORD *)v123 + 1);
                  __asm { FCVT            S3, H3 }
                  _S0 = (float)((float)(1.0 - v662) * _S3) + (float)(_S2 * v662);
                  __asm { FCVT            H0, S0 }
                }
                *((_WORD *)v123 + 1) = _H0;
              }
              unsigned __int8 v668 = *v659++;
              unsigned __int8 v119 = v668;
              v658 = (float16x4_t *)((char *)v658 + 10);
              ++v123;
              ++v124;
              --v660;
            }
            while (v660);
            v39 = 0;
          }
          uint64_t v31 = (uint64_t)&v124[v718 + 1];
          v27 = &v123[v720 + 1];
          goto LABEL_525;
        }
        v591 = v66 + 1;
        v592 = (float16x4_t *)(v31 - 8);
        int v593 = v29;
        if (v39)
        {
          unint64_t v118 = v722;
          do
          {
            if (v119)
            {
              unsigned int v594 = ((unsigned __int16)(*v39 * v119 + ((*v39 * v119) >> 8) + 1) >> 8);
              if (v594)
              {
                if (v594 == 255) {
                  float16x4_t v595 = *v65;
                }
                else {
                  float16x4_t v595 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v592[1]), 1.0 - (float)((float)v594 * 0.0039216)), vcvtq_f32_f16(*v65), (float)v594 * 0.0039216));
                }
                v592[1] = v595;
              }
            }
            unsigned __int8 v596 = *v591++;
            unsigned __int8 v119 = v596;
            v65 = (float16x4_t *)((char *)v65 + 10);
            ++v39;
            ++v592;
            --v593;
          }
          while (v593);
          v39 += v717;
        }
        else
        {
          unint64_t v118 = v722;
          do
          {
            if (v119)
            {
              if (v119 == 255) {
                float16x4_t v686 = *v65;
              }
              else {
                float16x4_t v686 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(v592[1]), 1.0 - (float)((float)v119 * 0.0039216)), vcvtq_f32_f16(*v65), (float)v119 * 0.0039216));
              }
              v592[1] = v686;
            }
            unsigned __int8 v687 = *v591++;
            unsigned __int8 v119 = v687;
            v65 = (float16x4_t *)((char *)v65 + 10);
            ++v592;
            --v593;
          }
          while (v593);
          v39 = 0;
        }
        v688 = &v592[v718];
        goto LABEL_582;
      case 2:
        unsigned __int8 v133 = *v66;
        if (v726)
        {
          if (v39)
          {
            uint64_t v134 = 0;
            v135 = v66 + 1;
            v136 = v27 - 1;
            v137 = (float16x4_t *)(v31 - 8);
            unint64_t v118 = v722;
            while (1)
            {
              if (!v133) {
                goto LABEL_98;
              }
              unsigned int v138 = ((unsigned __int16)(v39[v134] * v133 + ((v39[v134] * v133) >> 8) + 1) >> 8);
              if (!v138) {
                goto LABEL_98;
              }
              if (v138 == 255)
              {
                _H0 = *(short float *)v65[1].i16;
                if (_H0 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  *(float16x4_t *)(v31 + 8 * v134) = *v65;
                  goto LABEL_97;
                }
                __asm { FCMP            H0, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S0, H0 }
                  *(float16x4_t *)(v31 + 8 * v134) = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v65), vcvtq_f32_f16(*(float16x4_t *)(v31 + 8 * v134)), 1.0 - _S0));
                  _H2 = v27[v134];
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S0));
                  goto LABEL_95;
                }
              }
              else
              {
                float v145 = (float)v138 * 0.0039216;
                _H1 = v65[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v145 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCMP            H1, #0
                }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S1, H1 }
                  *(float16x4_t *)(v31 + 8 * v134) = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), v145))), vcvtq_f32_f16(*(float16x4_t *)(v31 + 8 * v134)), 1.0 - _S1));
                  _H0 = v27[v134];
                  __asm { FCVT            S0, H0 }
                  _S0 = _S1 + (float)(_S0 * (float)(1.0 - _S1));
LABEL_95:
                  __asm { FCVT            H0, S0 }
LABEL_97:
                  v27[v134] = _H0;
                }
              }
LABEL_98:
              unsigned __int8 v133 = v135[v134];
              v65 = (float16x4_t *)((char *)v65 + 10);
              ++v134;
              ++v136;
              ++v137;
              if (v29 == v134)
              {
                v39 += v134 + v717;
LABEL_559:
                uint64_t v31 = (uint64_t)&v137[v718 + 1];
                v27 = &v136[v720 + 1];
                goto LABEL_525;
              }
            }
          }
          v669 = v66 + 1;
          v136 = v27 - 1;
          v137 = (float16x4_t *)(v31 - 8);
          int v670 = v29;
          unint64_t v118 = v722;
          while (1)
          {
            if (v133)
            {
              if (v133 == 255)
              {
                _H0 = *(short float *)v65[1].i16;
                if (_H0 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  v137[1] = *v65;
                  goto LABEL_556;
                }
                __asm { FCMP            H0, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S0, H0 }
                  v137[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v65), vcvtq_f32_f16(v137[1]), 1.0 - _S0));
                  _H2 = *((_WORD *)v136 + 1);
                  __asm { FCVT            S2, H2 }
                  _S0 = _S0 + (float)(_S2 * (float)(1.0 - _S0));
                  goto LABEL_554;
                }
              }
              else
              {
                float v677 = (float)v133 * 0.0039216;
                _H1 = v65[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v677 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCMP            H1, #0
                }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S1, H1 }
                  v137[1] = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), v677))), vcvtq_f32_f16(v137[1]), 1.0 - _S1));
                  _H0 = *((_WORD *)v136 + 1);
                  __asm { FCVT            S0, H0 }
                  _S0 = _S1 + (float)(_S0 * (float)(1.0 - _S1));
LABEL_554:
                  __asm { FCVT            H0, S0 }
LABEL_556:
                  v136[1] = _H0;
                }
              }
            }
            unsigned __int8 v685 = *v669++;
            unsigned __int8 v133 = v685;
            v65 = (float16x4_t *)((char *)v65 + 10);
            ++v136;
            ++v137;
            if (!--v670)
            {
              v39 = 0;
              goto LABEL_559;
            }
          }
        }
        v597 = v66 + 1;
        v598 = (float16x4_t *)(v31 - 8);
        int v599 = v29;
        if (!v39)
        {
          unint64_t v118 = v722;
          while (1)
          {
            if (v133)
            {
              if (v133 == 255)
              {
                if (*(short float *)v65[1].i16 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  float16x4_t v691 = *v65;
                  goto LABEL_578;
                }
                __asm { FCMP            H0, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S0, H0 }
                  float16x4_t v691 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v65), vcvtq_f32_f16(v598[1]), 1.0 - _S0));
LABEL_578:
                  v598[1] = v691;
                }
              }
              else
              {
                float v692 = (float)v133 * 0.0039216;
                _H1 = v65[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v692 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCMP            H1, #0
                }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S1, H1 }
                  float16x4_t v691 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), v692))), vcvtq_f32_f16(v598[1]), 1.0 - _S1));
                  goto LABEL_578;
                }
              }
            }
            unsigned __int8 v698 = *v597++;
            unsigned __int8 v133 = v698;
            v65 = (float16x4_t *)((char *)v65 + 10);
            ++v598;
            if (!--v599)
            {
              v39 = 0;
              goto LABEL_581;
            }
          }
        }
        unint64_t v118 = v722;
        do
        {
          if (v133)
          {
            unsigned int v600 = ((unsigned __int16)(*v39 * v133 + ((*v39 * v133) >> 8) + 1) >> 8);
            if (v600)
            {
              if (v600 == 255)
              {
                if (*(short float *)v65[1].i16 >= COERCE_SHORT_FLOAT(COERCE_UNSIGNED_INT(1.0)))
                {
                  float16x4_t v603 = *v65;
                }
                else
                {
                  __asm { FCMP            H0, #0 }
                  if (_NF ^ _VF | _ZF) {
                    goto LABEL_491;
                  }
                  __asm { FCVT            S0, H0 }
                  float16x4_t v603 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*v65), vcvtq_f32_f16(v598[1]), 1.0 - _S0));
                }
              }
              else
              {
                float v604 = (float)v600 * 0.0039216;
                _H1 = v65[1].i16[0];
                __asm { FCVT            S1, H1 }
                _S1 = v604 * _S1;
                __asm
                {
                  FCVT            H1, S1
                  FCMP            H1, #0
                }
                if (_NF ^ _VF | _ZF) {
                  goto LABEL_491;
                }
                __asm { FCVT            S1, H1 }
                float16x4_t v603 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), v604))), vcvtq_f32_f16(v598[1]), 1.0 - _S1));
              }
              v598[1] = v603;
            }
          }
LABEL_491:
          unsigned __int8 v610 = *v597++;
          unsigned __int8 v133 = v610;
          v65 = (float16x4_t *)((char *)v65 + 10);
          ++v39;
          ++v598;
          --v599;
        }
        while (v599);
        v39 += v717;
LABEL_581:
        v688 = &v598[v718];
LABEL_582:
        uint64_t v31 = (uint64_t)&v688[1];
        v27 += v720;
LABEL_525:
        int v107 = v725;
LABEL_526:
        if (--v46)
        {
          v45 = 0;
          int v725 = v107 + 1;
          unint64_t v30 = v36[16] + v118;
          uint64_t v47 = v36[17] + v724;
          if (v723)
          {
            v724 += v36[17];
            int v721 = v46;
            uint64_t v43 = v713;
            v41 = v723;
            goto LABEL_589;
          }
          continue;
        }
        v41 = v723;
LABEL_584:
        if (v41) {
          free(v41);
        }
LABEL_586:
        if (v710) {
          free(v710);
        }
        return;
      case 3:
        v153 = (short float *)&v65[1];
        int v154 = v29;
        v111 = v39;
        do
        {
          unsigned int v155 = *v66;
          if (*v66)
          {
            if (v39) {
              unsigned int v155 = (*v111 * v155 + ((*v111 * v155) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v155)
            {
              if (v155 == 255)
              {
                *(short float *)uint64_t v31 = *(v153 - 4) * *v27;
                *(short float *)(v31 + 2) = *(v153 - 3) * *v27;
                *(short float *)(v31 + 4) = *(v153 - 2) * *v27;
                *(short float *)(v31 + 6) = *(v153 - 1) * *v27;
                _H0 = *v153 * *v27;
              }
              else
              {
                float v157 = (float)v155 * 0.0039216;
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                float v160 = v157 * _S1;
                float v161 = 1.0 - v157;
                *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), v161), vcvtq_f32_f16(*(float16x4_t *)(v153 - 4)), v160));
                _H3 = *v153;
                __asm { FCVT            S3, H3 }
                _S0 = (float)(v161 * _S1) + (float)(_S3 * v160);
                __asm { FCVT            H0, S0 }
              }
              short float *v27 = _H0;
            }
          }
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v153 += 5;
          v27 = (short float *)((char *)v27 + v44);
          --v154;
        }
        while (v154);
        goto LABEL_522;
      case 4:
        v165 = v65 + 1;
        int v166 = v29;
        v111 = v39;
        do
        {
          unsigned int v167 = *v66;
          if (*v66)
          {
            if (v39) {
              unsigned int v167 = (*v111 * v167 + ((*v111 * v167) >> 8) + 1) >> 8;
            }
            if ((_BYTE)v167)
            {
              if (v167 == 255)
              {
                _H0 = v165[-1].i16[0];
                __asm { FCVT            S0, H0 }
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)uint64_t v31 = LOWORD(_S0);
                LOWORD(_S0) = v165[-1].i16[1];
                __asm { FCVT            S0, H0 }
                *(short float *)&_S1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v31 + 2) = LOWORD(_S0);
                LOWORD(_S0) = v165[-1].i16[2];
                __asm { FCVT            S0, H0 }
                *(short float *)&_S1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v31 + 4) = LOWORD(_S0);
                LOWORD(_S0) = v165[-1].i16[3];
                __asm { FCVT            S0, H0 }
                *(short float *)&_S1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
                __asm { FCVT            H0, S0 }
                *(_WORD *)(v31 + 6) = LOWORD(_S0);
                LOWORD(_S0) = v165->i16[0];
                __asm { FCVT            S0, H0 }
                *(short float *)&_S1 = *v27;
                __asm { FCVT            S1, H1 }
                _S0 = (float)(1.0 - _S1) * _S0;
              }
              else
              {
                float v185 = (float)v167 * 0.0039216;
                _H1 = *v27;
                __asm { FCVT            S1, H1 }
                float v188 = v185 * (float)(1.0 - _S1);
                float v189 = 1.0 - v185;
                *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), v189), vcvtq_f32_f16(v165[-1]), v188));
                _H2 = v165->i16[0];
                __asm { FCVT            S2, H2 }
                _S0 = (float)(v189 * _S1) + (float)(_S2 * v188);
              }
              __asm { FCVT            H0, S0 }
              *(_WORD *)v27 = _H0;
            }
          }
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v165 = (float16x4_t *)((char *)v165 + 10);
          v27 = (short float *)((char *)v27 + v44);
          --v166;
        }
        while (v166);
        goto LABEL_522;
      case 5:
        v193 = v65 + 1;
        int v194 = v29;
        v111 = v39;
        while (1)
        {
          unsigned int v195 = *v66;
          if (*v66)
          {
            if (!v39) {
              goto LABEL_127;
            }
            unsigned int v196 = *v111 * v195 + ((*v111 * v195) >> 8) + 1;
            if (BYTE1(v196)) {
              break;
            }
          }
LABEL_128:
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v193 = (float16x4_t *)((char *)v193 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v194) {
            goto LABEL_522;
          }
        }
        unsigned int v195 = v196 >> 8;
LABEL_127:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        float v199 = (float)v195 * 0.0039216;
        _H2 = v193->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v199 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), 1.0 - _S2), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v193[-1]), v199))), _S0));
        _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * _S0);
        __asm { FCVT            H0, S0 }
        short float *v27 = *(short float *)&_S0;
        goto LABEL_128;
      case 6:
        v205 = v65 + 1;
        int v206 = v29;
        v111 = v39;
        while (1)
        {
          unsigned int v207 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v208 = *v111 * v207 + ((*v111 * v207) >> 8) + 1;
              if (!BYTE1(v208)) {
                goto LABEL_140;
              }
              unsigned int v207 = v208 >> 8;
            }
            _H0 = *v27;
            __asm { FCVT            S0, H0 }
            float v211 = 1.0 - _S0;
            if ((float)(1.0 - _S0) >= 1.0)
            {
              float v216 = (float)v207 * 0.0039216;
              *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v205[-1]), v216));
              _H1 = v205->i16[0];
              __asm { FCVT            S1, H1 }
              _S0 = v216 * _S1;
              goto LABEL_139;
            }
            if (v211 > 0.0)
            {
              float v212 = (float)((float)v207 * 0.0039216) * v211;
              *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), vcvtq_f32_f16(v205[-1]), v212));
              _H2 = v205->i16[0];
              __asm { FCVT            S2, H2 }
              _S0 = _S0 + (float)(_S2 * v212);
LABEL_139:
              __asm { FCVT            H0, S0 }
              *(_WORD *)v27 = _H0;
            }
          }
LABEL_140:
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v205 = (float16x4_t *)((char *)v205 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v206) {
            goto LABEL_522;
          }
        }
      case 7:
        uint64_t v220 = v39 != 0;
        if (v726)
        {
          v221 = (short float *)&v65[1];
          int v222 = v29;
          v111 = v39;
          do
          {
            unsigned int v223 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v223 = (*v111 * v223 + ((*v111 * v223) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v223)
              {
                if (v223 == 255)
                {
                  short float v224 = *v221;
                  *(float16x4_t *)uint64_t v31 = vmul_n_f16(*(float16x4_t *)v31, *v221);
                  _H0 = v224 * *v27;
                }
                else
                {
                  float v226 = (float)v223 * 0.0039216;
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _H2 = *v221;
                  __asm { FCVT            S2, H2 }
                  float v231 = v226 * _S2;
                  float v232 = 1.0 - v226;
                  float32x4_t v233 = vcvtq_f32_f16(*(float16x4_t *)v31);
                  *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v233, v232), v233, v231));
                  _S0 = (float)(v232 * _S1) + (float)(_S1 * v231);
                  __asm { FCVT            H0, S0 }
                }
                short float *v27 = _H0;
              }
            }
            ++v66;
            v111 += v220;
            v31 += 8;
            ++v27;
            v221 += 5;
            --v222;
          }
          while (v222);
        }
        else
        {
          v611 = (short float *)&v65[1];
          int v612 = v29;
          v111 = v39;
          do
          {
            unsigned int v613 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v613 = (*v111 * v613 + ((*v111 * v613) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v613)
              {
                if (v613 == 255)
                {
                  float16x4_t v614 = vmul_n_f16(*(float16x4_t *)v31, *v611);
                }
                else
                {
                  _H1 = *v611;
                  __asm { FCVT            S1, H1 }
                  float32x4_t v617 = vcvtq_f32_f16(*(float16x4_t *)v31);
                  float16x4_t v614 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v617, 1.0 - (float)((float)v613 * 0.0039216)), v617, (float)((float)v613 * 0.0039216) * _S1));
                }
                *(float16x4_t *)uint64_t v31 = v614;
              }
            }
            ++v66;
            v111 += v220;
            v31 += 8;
            v611 += 5;
            --v612;
          }
          while (v612);
        }
        goto LABEL_522;
      case 8:
        uint64_t v235 = v39 != 0;
        if (v726)
        {
          v236 = v65 + 1;
          int v237 = v29;
          v111 = v39;
          do
          {
            unsigned int v238 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v238 = (*v111 * v238 + ((*v111 * v238) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v238)
              {
                if (v238 == 255)
                {
                  _H0 = v236->i16[0];
                  __asm { FCVT            S0, H0 }
                  float v241 = 1.0 - _S0;
                  *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), v241));
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _S0 = v241 * _S1;
                }
                else
                {
                  float v245 = (float)v238 * 0.0039216;
                  _H1 = *v27;
                  __asm { FCVT            S1, H1 }
                  _H2 = v236->i16[0];
                  __asm { FCVT            S2, H2 }
                  float v250 = v245 * (float)(1.0 - _S2);
                  float v251 = 1.0 - v245;
                  float32x4_t v252 = vcvtq_f32_f16(*(float16x4_t *)v31);
                  *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(v252, v251), v252, v250));
                  _S0 = (float)(v251 * _S1) + (float)(_S1 * v250);
                }
                __asm { FCVT            H0, S0 }
                *(_WORD *)v27 = _H0;
              }
            }
            ++v66;
            v111 += v235;
            v31 += 8;
            ++v27;
            v236 = (float16x4_t *)((char *)v236 + 10);
            --v237;
          }
          while (v237);
        }
        else
        {
          v618 = v65 + 1;
          int v619 = v29;
          v111 = v39;
          do
          {
            unsigned int v620 = *v66;
            if (*v66)
            {
              if (v39) {
                unsigned int v620 = (*v111 * v620 + ((*v111 * v620) >> 8) + 1) >> 8;
              }
              if ((_BYTE)v620)
              {
                if (v620 == 255)
                {
                  _H0 = *(_WORD *)v31;
                  __asm { FCVT            S0, H0 }
                  _H1 = v618->i16[0];
                  __asm { FCVT            S1, H1 }
                  float v625 = 1.0 - _S1;
                  _S0 = v625 * _S0;
                  __asm { FCVT            H0, S0 }
                  *(_WORD *)uint64_t v31 = LOWORD(_S0);
                  LOWORD(_S0) = *(_WORD *)(v31 + 2);
                  __asm { FCVT            S0, H0 }
                  _S0 = v625 * _S0;
                  __asm { FCVT            H0, S0 }
                  *(_WORD *)(v31 + 2) = LOWORD(_S0);
                  LOWORD(_S0) = *(_WORD *)(v31 + 4);
                  __asm { FCVT            S0, H0 }
                  _S0 = v625 * _S0;
                  __asm { FCVT            H0, S0 }
                  *(_WORD *)(v31 + 4) = LOWORD(_S0);
                  v631 = (_WORD *)(v31 + 6);
                  LOWORD(_S0) = *(_WORD *)(v31 + 6);
                  __asm { FCVT            S0, H0 }
                  _S0 = v625 * _S0;
                }
                else
                {
                  float v634 = (float)v620 * 0.0039216;
                  _H1 = *(_WORD *)v31;
                  __asm { FCVT            S1, H1 }
                  _H2 = v618->i16[0];
                  __asm { FCVT            S2, H2 }
                  float v639 = v634 * (float)(1.0 - _S2);
                  float v640 = 1.0 - v634;
                  _S1 = (float)(v640 * _S1) + (float)(_S1 * v639);
                  __asm { FCVT            H1, S1 }
                  *(_WORD *)uint64_t v31 = LOWORD(_S1);
                  LOWORD(_S1) = *(_WORD *)(v31 + 2);
                  __asm { FCVT            S1, H1 }
                  _S1 = (float)(v640 * _S1) + (float)(_S1 * v639);
                  __asm { FCVT            H1, S1 }
                  *(_WORD *)(v31 + 2) = LOWORD(_S1);
                  LOWORD(_S1) = *(_WORD *)(v31 + 4);
                  __asm { FCVT            S1, H1 }
                  _S1 = (float)(v640 * _S1) + (float)(_S1 * v639);
                  __asm { FCVT            H1, S1 }
                  *(_WORD *)(v31 + 4) = LOWORD(_S1);
                  v631 = (_WORD *)(v31 + 6);
                  LOWORD(_S1) = *(_WORD *)(v31 + 6);
                  __asm { FCVT            S1, H1 }
                  _S0 = (float)(v640 * _S1) + (float)(_S1 * v639);
                }
                __asm { FCVT            H0, S0 }
                _WORD *v631 = _H0;
              }
            }
            ++v66;
            v111 += v235;
            v31 += 8;
            v618 = (float16x4_t *)((char *)v618 + 10);
            --v619;
          }
          while (v619);
        }
        goto LABEL_522;
      case 9:
        v254 = v65 + 1;
        int v255 = v29;
        v111 = v39;
        while (1)
        {
          unsigned int v256 = *v66;
          if (*v66)
          {
            if (!v39) {
              goto LABEL_171;
            }
            unsigned int v257 = *v111 * v256 + ((*v111 * v256) >> 8) + 1;
            if (BYTE1(v257)) {
              break;
            }
          }
LABEL_172:
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v254 = (float16x4_t *)((char *)v254 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v255) {
            goto LABEL_522;
          }
        }
        unsigned int v256 = v257 >> 8;
LABEL_171:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        float v260 = (float)v256 * 0.0039216;
        _H2 = v254->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v260 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        float v265 = (float)(1.0 - v260) + _S2;
        *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), v265), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v254[-1]), v260))), 1.0 - _S0));
        _S0 = (float)(v265 * _S0) + (float)(_S2 * (float)(1.0 - _S0));
        __asm { FCVT            H0, S0 }
        short float *v27 = *(short float *)&_S0;
        goto LABEL_172;
      case 10:
        v267 = v65 + 1;
        int v268 = v29;
        v111 = v39;
        while (1)
        {
          unsigned int v269 = *v66;
          if (*v66)
          {
            if (!v39) {
              goto LABEL_179;
            }
            unsigned int v270 = *v111 * v269 + ((*v111 * v269) >> 8) + 1;
            if (BYTE1(v270)) {
              break;
            }
          }
LABEL_180:
          ++v66;
          v111 += v39 != 0;
          v31 += 8;
          v267 = (float16x4_t *)((char *)v267 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v268) {
            goto LABEL_522;
          }
        }
        unsigned int v269 = v270 >> 8;
LABEL_179:
        _H0 = *v27;
        __asm { FCVT            S0, H0 }
        float v273 = (float)v269 * 0.0039216;
        _H2 = v267->i16[0];
        __asm { FCVT            S2, H2 }
        _S2 = v273 * _S2;
        __asm
        {
          FCVT            H2, S2
          FCVT            S2, H2
        }
        *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vmlaq_n_f32(vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)v31), 1.0 - _S2), vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v267[-1]), v273))), 1.0 - _S0));
        _S0 = (float)((float)(1.0 - _S2) * _S0) + (float)(_S2 * (float)(1.0 - _S0));
        __asm { FCVT            H0, S0 }
        short float *v27 = *(short float *)&_S0;
        goto LABEL_180;
      case 11:
        uint64_t v279 = v39 != 0;
        if (v726)
        {
          v280 = (__int16 *)v65 + 2;
          int v281 = v29;
          v111 = v39;
          while (1)
          {
            unsigned int v282 = *v66;
            if (*v66)
            {
              if (!v39) {
                goto LABEL_188;
              }
              unsigned int v283 = *v111 * v282 + ((*v111 * v282) >> 8) + 1;
              if (BYTE1(v283)) {
                break;
              }
            }
LABEL_191:
            ++v66;
            v111 += v279;
            v31 += 8;
            ++v27;
            v280 += 5;
            if (!--v281) {
              goto LABEL_522;
            }
          }
          unsigned int v282 = v283 >> 8;
LABEL_188:
          _H0 = *(v280 - 2);
          __asm { FCVT            S0, H0 }
          float v286 = (float)v282 * 0.0039216;
          _S0 = v286 * _S0;
          __asm { FCVT            H0, S0 }
          _H2 = *(v280 - 1);
          __asm { FCVT            S2, H2 }
          _S2 = v286 * _S2;
          __asm { FCVT            H2, S2 }
          _H3 = *v280;
          __asm { FCVT            S3, H3 }
          _S3 = v286 * _S3;
          __asm { FCVT            H3, S3 }
          _H4 = v280[1];
          __asm { FCVT            S4, H4 }
          _S4 = v286 * _S4;
          __asm { FCVT            H4, S4 }
          _H5 = v280[2];
          __asm { FCVT            S5, H5 }
          _S1 = v286 * _S5;
          __asm { FCVT            H1, S1 }
          *(short float *)&_S5 = *v27;
          __asm
          {
            FCVT            S5, H5
            FCVT            S1, H1
          }
          _S6 = _S5 + _S1;
          _H7 = *(_WORD *)v31;
          __asm
          {
            FCVT            S7, H7
            FCVT            S0, H0
          }
          float v309 = (float)(_S5 - _S7) + (float)(_S1 - _S0);
          if ((float)(_S5 + _S1) > 1.0) {
            _S6 = 1.0;
          }
          _H7 = *(_WORD *)(v31 + 2);
          __asm
          {
            FCVT            S7, H7
            FCVT            S2, H2
          }
          float v313 = (float)(_S5 - _S7) + (float)(_S1 - _S2);
          _S0 = _S6 - v309;
          __asm { FCVT            H0, S0 }
          *(_WORD *)uint64_t v31 = LOWORD(_S0);
          *(short float *)&_S0 = *v27;
          __asm { FCVT            S0, H0 }
          _H5 = *(_WORD *)(v31 + 4);
          __asm
          {
            FCVT            S5, H5
            FCVT            S3, H3
          }
          float v319 = (float)(_S1 - _S3) + (float)(_S0 - _S5);
          _S2 = _S6 - v313;
          __asm { FCVT            H2, S2 }
          *(_WORD *)(v31 + 2) = LOWORD(_S2);
          *(short float *)&_S2 = *v27;
          __asm { FCVT            S2, H2 }
          LOWORD(_S3) = *(_WORD *)(v31 + 6);
          __asm { FCVT            S3, H3 }
          float v323 = _S2 - _S3;
          __asm { FCVT            S3, H4 }
          _S0 = _S6 - v319;
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v31 + 4) = LOWORD(_S0);
          __asm { FCVT            H0, S6 }
          short float *v27 = *(short float *)&_S0;
          _S0 = _S6 - (float)((float)(_S1 - _S3) + v323);
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v31 + 6) = LOWORD(_S0);
          goto LABEL_191;
        }
        v648 = v65 + 1;
        int v649 = v29;
        v111 = v39;
        while (1)
        {
          unsigned int v650 = *v66;
          if (*v66)
          {
            if (!v39) {
              goto LABEL_520;
            }
            unsigned int v651 = *v111 * v650 + ((*v111 * v650) >> 8) + 1;
            if (BYTE1(v651)) {
              break;
            }
          }
LABEL_521:
          ++v66;
          v111 += v279;
          v31 += 8;
          v648 = (float16x4_t *)((char *)v648 + 10);
          if (!--v649)
          {
LABEL_522:
            v39 = &v111[v717];
            goto LABEL_523;
          }
        }
        unsigned int v650 = v651 >> 8;
LABEL_520:
        float v652 = (float)v650 * 0.0039216;
        _Q1.i16[0] = v648->i16[0];
        __asm { FCVT            S1, H1 }
        _Q1.f32[0] = v652 * _Q1.f32[0];
        __asm
        {
          FCVT            H1, S1
          FCVT            S1, H1
          FMOV            V3.4S, #1.0
        }
        _Q1 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 0);
        *(float16x4_t *)uint64_t v31 = vcvt_f16_f32(vsubq_f32(_Q3, vaddq_f32(vsubq_f32(_Q1, vcvtq_f32_f16(vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(v648[-1]), v652)))), vsubq_f32(_Q3, vcvtq_f32_f16(*(float16x4_t *)v31)))));
        goto LABEL_521;
      case 12:
        uint64_t v327 = v39 != 0;
        if (v726)
        {
          v328 = v65 + 1;
          int v329 = v29;
          v111 = v39;
          while (1)
          {
            unsigned int v330 = *v66;
            if (*v66)
            {
              if (!v39) {
                goto LABEL_199;
              }
              unsigned int v331 = *v111 * v330 + ((*v111 * v330) >> 8) + 1;
              if (BYTE1(v331)) {
                break;
              }
            }
LABEL_202:
            ++v66;
            v111 += v327;
            v31 += 8;
            ++v27;
            v328 = (float16x4_t *)((char *)v328 + 10);
            if (!--v329) {
              goto LABEL_522;
            }
          }
          unsigned int v330 = v331 >> 8;
LABEL_199:
          float v332 = (float)v330 * 0.0039216;
          _H1 = v328->i16[0];
          __asm { FCVT            S1, H1 }
          _S1 = v332 * _S1;
          __asm { FCVT            H1, S1 }
          _H2 = *v27;
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S2 + _S1;
          if (_S1 > 1.0) {
            _S1 = 1.0;
          }
          __asm { FCVT            H1, S1 }
          float32x4_t v341 = vmulq_n_f32(vcvtq_f32_f16(v328[-1]), v332);
          v342.i32[0] = *(_DWORD *)v31;
          *(_WORD *)v27 = _H1;
          v342.i32[1] = *(_DWORD *)(v31 + 4);
          *(float16x4_t *)uint64_t v31 = vadd_f16(v342, vcvt_f16_f32(v341));
          goto LABEL_202;
        }
        int v654 = v29;
        v655 = v39;
        while (1)
        {
          unsigned int v656 = *v66;
          if (*v66)
          {
            if (!v39) {
              goto LABEL_534;
            }
            unsigned int v657 = *v655 * v656 + ((*v655 * v656) >> 8) + 1;
            if (BYTE1(v657)) {
              break;
            }
          }
LABEL_535:
          ++v66;
          v65 = (float16x4_t *)((char *)v65 + 10);
          v655 += v327;
          v31 += 8;
          if (!--v654)
          {
            v39 = &v655[v717];
LABEL_523:
            v31 += 8 * v718;
            v27 += v720;
LABEL_524:
            unint64_t v118 = v722;
            goto LABEL_525;
          }
        }
        unsigned int v656 = v657 >> 8;
LABEL_534:
        *(float16x4_t *)uint64_t v31 = vadd_f16(*(float16x4_t *)v31, vcvt_f16_f32(vmulq_n_f32(vcvtq_f32_f16(*v65), (float)v656 * 0.0039216)));
        goto LABEL_535;
      case 13:
        int v721 = v46;
        int v343 = v29;
        v344 = v65 + 1;
        int v345 = v343;
        v346 = v39;
        while (1)
        {
          unsigned int v347 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v348 = *v346 * v347 + ((*v346 * v347) >> 8) + 1;
              if (!BYTE1(v348)) {
                goto LABEL_219;
              }
              unsigned int v347 = v348 >> 8;
            }
            float v349 = (float)v347 * *((float *)v108 + 677);
            _H0 = v344->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v349 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v352 = (__n128)vcvtq_f32_f16(v344[-1]);
              __n128 v353 = (__n128)vmulq_n_f32((float32x4_t)v352, v349);
              int32x2_t v354 = (int32x2_t)vcvt_f16_f32((float32x4_t)v353);
              if (v726)
              {
                LOWORD(v63) = v354.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v357 = COERCE_DOUBLE(vdup_lane_s32(v354, 1));
                  goto LABEL_214;
                }
                LOWORD(v359) = v354.i16[2];
                LOWORD(v360) = v354.i16[3];
              }
              else
              {
                LOWORD(v63) = v354.i16[1];
                double v357 = COERCE_DOUBLE(vdup_lane_s32(v354, 1));
                _S4 = 1.0;
LABEL_214:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v353.n128_u16[0] = *(_WORD *)(v31 + 2);
                v352.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAmultiplyPDA(_Q0, v353, v352, _Q3, _S4, *(double *)&v354, v63, v357, v49, v50, v51, v52, v53, v54, v55, v56, v354.i16[0], SLOWORD(v63), SLOWORD(v357),
                        SWORD1(v357),
                        _S16);
                unint64_t v359 = HIDWORD(v49);
                unint64_t v360 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_219;
                }
                v354.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v354.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v359;
              *(_WORD *)(v31 + 6) = v360;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_219:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v344 = (float16x4_t *)((char *)v344 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v345) {
            goto LABEL_458;
          }
        }
      case 14:
        int v721 = v46;
        int v361 = v29;
        v362 = v65 + 1;
        int v363 = v361;
        v346 = v39;
        while (1)
        {
          unsigned int v364 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v365 = *v346 * v364 + ((*v346 * v364) >> 8) + 1;
              if (!BYTE1(v365)) {
                goto LABEL_236;
              }
              unsigned int v364 = v365 >> 8;
            }
            float v366 = (float)v364 * *((float *)v108 + 677);
            _H0 = v362->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v366 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v369 = (__n128)vcvtq_f32_f16(v362[-1]);
              __n128 v370 = (__n128)vmulq_n_f32((float32x4_t)v369, v366);
              int32x2_t v371 = (int32x2_t)vcvt_f16_f32((float32x4_t)v370);
              if (v726)
              {
                LOWORD(v63) = v371.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v374 = COERCE_DOUBLE(vdup_lane_s32(v371, 1));
                  goto LABEL_231;
                }
                LOWORD(v376) = v371.i16[2];
                LOWORD(v377) = v371.i16[3];
              }
              else
              {
                LOWORD(v63) = v371.i16[1];
                double v374 = COERCE_DOUBLE(vdup_lane_s32(v371, 1));
                _S4 = 1.0;
LABEL_231:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v370.n128_u16[0] = *(_WORD *)(v31 + 2);
                v369.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAscreenPDA(_Q0, v370, v369, _Q3, _S4, *(double *)&v371, v63, v374, v49, v50, v51, v52, v53, v54, v55, v56, v371.i16[0], SLOWORD(v63), SLOWORD(v374),
                        SWORD1(v374),
                        _S16);
                unint64_t v376 = HIDWORD(v49);
                unint64_t v377 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_236;
                }
                v371.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v371.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v376;
              *(_WORD *)(v31 + 6) = v377;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_236:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v362 = (float16x4_t *)((char *)v362 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v363) {
            goto LABEL_458;
          }
        }
      case 15:
        int v721 = v46;
        int v378 = v29;
        v379 = v65 + 1;
        int v380 = v378;
        v346 = v39;
        while (1)
        {
          unsigned int v381 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v382 = *v346 * v381 + ((*v346 * v381) >> 8) + 1;
              if (!BYTE1(v382)) {
                goto LABEL_253;
              }
              unsigned int v381 = v382 >> 8;
            }
            float v383 = (float)v381 * *((float *)v108 + 677);
            _H0 = v379->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v383 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v386 = (__n128)vcvtq_f32_f16(v379[-1]);
              __n128 v387 = (__n128)vmulq_n_f32((float32x4_t)v386, v383);
              int32x2_t v388 = (int32x2_t)vcvt_f16_f32((float32x4_t)v387);
              if (v726)
              {
                LOWORD(v63) = v388.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v391 = COERCE_DOUBLE(vdup_lane_s32(v388, 1));
                  goto LABEL_248;
                }
                LOWORD(v393) = v388.i16[2];
                LOWORD(v394) = v388.i16[3];
              }
              else
              {
                LOWORD(v63) = v388.i16[1];
                double v391 = COERCE_DOUBLE(vdup_lane_s32(v388, 1));
                _S4 = 1.0;
LABEL_248:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v387.n128_u16[0] = *(_WORD *)(v31 + 2);
                v386.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAoverlayPDA(_Q0, v387, v386, _Q3, _S4, *(double *)&v388, v63, v391, v49, v50, v51, v52, v53, v54, v55, v56, v388.i16[0], SLOWORD(v63), SLOWORD(v391),
                        SWORD1(v391),
                        _S16);
                unint64_t v393 = HIDWORD(v49);
                unint64_t v394 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_253;
                }
                v388.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v388.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v393;
              *(_WORD *)(v31 + 6) = v394;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_253:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v379 = (float16x4_t *)((char *)v379 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v380) {
            goto LABEL_458;
          }
        }
      case 16:
        int v721 = v46;
        int v395 = v29;
        v396 = v65 + 1;
        int v397 = v395;
        v346 = v39;
        while (1)
        {
          unsigned int v398 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v399 = *v346 * v398 + ((*v346 * v398) >> 8) + 1;
              if (!BYTE1(v399)) {
                goto LABEL_270;
              }
              unsigned int v398 = v399 >> 8;
            }
            float v400 = (float)v398 * *((float *)v108 + 677);
            _H0 = v396->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v400 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v403 = (__n128)vcvtq_f32_f16(v396[-1]);
              __n128 v404 = (__n128)vmulq_n_f32((float32x4_t)v403, v400);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v404);
              if (v726)
              {
                LOWORD(v63) = _Q5.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v406 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                  goto LABEL_265;
                }
                LOWORD(v408) = _Q5.i16[2];
                LOWORD(v409) = _Q5.i16[3];
              }
              else
              {
                LOWORD(v63) = _Q5.i16[1];
                double v406 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                _Q4.i32[0] = 1.0;
LABEL_265:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v404.n128_u16[0] = *(_WORD *)(v31 + 2);
                v403.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                v706.i32[1] = LODWORD(v406);
                v706.i16[1] = LOWORD(v63);
                v706.i16[0] = _Q5.i16[0];
                unint64_t v49 = PDAdarkenPDA((float16x4_t)_Q0.n128_u64[0], v404, v403, _Q3, _Q4, _Q5, v63, v406, v49, v50, v51, v52, v53, v54, v55, v56, v706, _S16);
                unint64_t v408 = HIDWORD(v49);
                unint64_t v409 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_270;
                }
                _Q5.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = _Q5.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v408;
              *(_WORD *)(v31 + 6) = v409;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_270:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v396 = (float16x4_t *)((char *)v396 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v397) {
            goto LABEL_458;
          }
        }
      case 17:
        int v721 = v46;
        int v410 = v29;
        v411 = v65 + 1;
        int v412 = v410;
        v346 = v39;
        while (1)
        {
          unsigned int v413 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v414 = *v346 * v413 + ((*v346 * v413) >> 8) + 1;
              if (!BYTE1(v414)) {
                goto LABEL_287;
              }
              unsigned int v413 = v414 >> 8;
            }
            float v415 = (float)v413 * *((float *)v108 + 677);
            _H0 = v411->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v415 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v418 = (__n128)vcvtq_f32_f16(v411[-1]);
              __n128 v419 = (__n128)vmulq_n_f32((float32x4_t)v418, v415);
              *(float16x4_t *)_Q5.f32 = vcvt_f16_f32((float32x4_t)v419);
              if (v726)
              {
                LOWORD(v63) = _Q5.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v421 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                  goto LABEL_282;
                }
                LOWORD(v423) = _Q5.i16[2];
                LOWORD(v424) = _Q5.i16[3];
              }
              else
              {
                LOWORD(v63) = _Q5.i16[1];
                double v421 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)_Q5.f32, 1));
                _Q4.i32[0] = 1.0;
LABEL_282:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v419.n128_u16[0] = *(_WORD *)(v31 + 2);
                v418.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                v707.i32[1] = LODWORD(v421);
                v707.i16[1] = LOWORD(v63);
                v707.i16[0] = _Q5.i16[0];
                unint64_t v49 = PDAlightenPDA((float16x4_t)_Q0.n128_u64[0], v419, v418, _Q3, _Q4, _Q5, v63, v421, v49, v50, v51, v52, v53, v54, v55, v56, v707, _S16);
                unint64_t v423 = HIDWORD(v49);
                unint64_t v424 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_287;
                }
                _Q5.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = _Q5.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v423;
              *(_WORD *)(v31 + 6) = v424;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_287:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v411 = (float16x4_t *)((char *)v411 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v412) {
            goto LABEL_458;
          }
        }
      case 18:
        int v721 = v46;
        int v425 = v29;
        v426 = v65 + 1;
        int v427 = v425;
        v346 = v39;
        while (1)
        {
          unsigned int v428 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v429 = *v346 * v428 + ((*v346 * v428) >> 8) + 1;
              if (!BYTE1(v429)) {
                goto LABEL_304;
              }
              unsigned int v428 = v429 >> 8;
            }
            float v430 = (float)v428 * *((float *)v108 + 677);
            _H0 = v426->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v430 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v433 = (__n128)vcvtq_f32_f16(v426[-1]);
              __n128 v434 = (__n128)vmulq_n_f32((float32x4_t)v433, v430);
              int32x2_t v435 = (int32x2_t)vcvt_f16_f32((float32x4_t)v434);
              if (v726)
              {
                LOWORD(v63) = v435.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v438 = COERCE_DOUBLE(vdup_lane_s32(v435, 1));
                  goto LABEL_299;
                }
                LOWORD(v440) = v435.i16[2];
                LOWORD(v441) = v435.i16[3];
              }
              else
              {
                LOWORD(v63) = v435.i16[1];
                double v438 = COERCE_DOUBLE(vdup_lane_s32(v435, 1));
                _S4 = 1.0;
LABEL_299:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v434.n128_u16[0] = *(_WORD *)(v31 + 2);
                v433.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAcolordodgePDA(_Q0, v434, v433, _Q3, _S4, *(double *)&v435, v63, v438, v49, v50, v51, v52, v53, v54, v55, v56, v435.i16[0], SLOWORD(v63), SLOWORD(v438),
                        SWORD1(v438),
                        _S16);
                unint64_t v440 = HIDWORD(v49);
                unint64_t v441 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_304;
                }
                v435.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v435.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v440;
              *(_WORD *)(v31 + 6) = v441;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_304:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v426 = (float16x4_t *)((char *)v426 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v427) {
            goto LABEL_458;
          }
        }
      case 19:
        int v721 = v46;
        int v442 = v29;
        v443 = v65 + 1;
        int v444 = v442;
        v346 = v39;
        while (1)
        {
          unsigned int v445 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v446 = *v346 * v445 + ((*v346 * v445) >> 8) + 1;
              if (!BYTE1(v446)) {
                goto LABEL_321;
              }
              unsigned int v445 = v446 >> 8;
            }
            float v447 = (float)v445 * *((float *)v108 + 677);
            _H0 = v443->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v447 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v450 = (__n128)vcvtq_f32_f16(v443[-1]);
              __n128 v451 = (__n128)vmulq_n_f32((float32x4_t)v450, v447);
              int32x2_t v452 = (int32x2_t)vcvt_f16_f32((float32x4_t)v451);
              if (v726)
              {
                LOWORD(v63) = v452.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v455 = COERCE_DOUBLE(vdup_lane_s32(v452, 1));
                  goto LABEL_316;
                }
                LOWORD(v457) = v452.i16[2];
                LOWORD(v458) = v452.i16[3];
              }
              else
              {
                LOWORD(v63) = v452.i16[1];
                double v455 = COERCE_DOUBLE(vdup_lane_s32(v452, 1));
                _S4 = 1.0;
LABEL_316:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v451.n128_u16[0] = *(_WORD *)(v31 + 2);
                v450.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAcolorburnPDA(_Q0, v451, v450, _Q3, _S4, *(double *)&v452, v63, v455, v49, v50, v51, v52, v53, v54, v55, v56, v452.i16[0], SLOWORD(v63), SLOWORD(v455),
                        SWORD1(v455),
                        _S16);
                unint64_t v457 = HIDWORD(v49);
                unint64_t v458 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_321;
                }
                v452.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v452.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v457;
              *(_WORD *)(v31 + 6) = v458;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_321:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v443 = (float16x4_t *)((char *)v443 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v444) {
            goto LABEL_458;
          }
        }
      case 20:
        int v721 = v46;
        int v459 = v29;
        v460 = v65 + 1;
        int v461 = v459;
        v346 = v39;
        while (1)
        {
          unsigned int v462 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v463 = *v346 * v462 + ((*v346 * v462) >> 8) + 1;
              if (!BYTE1(v463)) {
                goto LABEL_338;
              }
              unsigned int v462 = v463 >> 8;
            }
            float v464 = (float)v462 * *((float *)v108 + 677);
            _H0 = v460->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v464 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v467 = (__n128)vcvtq_f32_f16(v460[-1]);
              __n128 v468 = (__n128)vmulq_n_f32((float32x4_t)v467, v464);
              int32x2_t v469 = (int32x2_t)vcvt_f16_f32((float32x4_t)v468);
              if (v726)
              {
                LOWORD(v63) = v469.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v471 = COERCE_DOUBLE(vdup_lane_s32(v469, 1));
                  goto LABEL_333;
                }
                LOWORD(v473) = v469.i16[2];
                LOWORD(v474) = v469.i16[3];
              }
              else
              {
                LOWORD(v63) = v469.i16[1];
                double v471 = COERCE_DOUBLE(vdup_lane_s32(v469, 1));
                _Q4.i32[0] = 1.0;
LABEL_333:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v468.n128_u16[0] = *(_WORD *)(v31 + 2);
                v467.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                HIWORD(v708) = LOWORD(v63);
                LOWORD(v708) = v469.i16[0];
                unint64_t v49 = PDAsoftlightPDA((float16x4_t)_Q0.n128_u64[0], v468, v467, _Q3, *(double *)_Q4.i64, v469, v63, v471, v49, v50, v51, v52, v53, v54, v55, v56, v708, SLOWORD(v471), SWORD1(v471),
                        _S16);
                unint64_t v473 = HIDWORD(v49);
                unint64_t v474 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_338;
                }
                v469.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v469.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v473;
              *(_WORD *)(v31 + 6) = v474;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_338:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v460 = (float16x4_t *)((char *)v460 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v461) {
            goto LABEL_458;
          }
        }
      case 21:
        int v721 = v46;
        int v475 = v29;
        v476 = v65 + 1;
        int v477 = v475;
        v346 = v39;
        while (1)
        {
          unsigned int v478 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v479 = *v346 * v478 + ((*v346 * v478) >> 8) + 1;
              if (!BYTE1(v479)) {
                goto LABEL_355;
              }
              unsigned int v478 = v479 >> 8;
            }
            float v480 = (float)v478 * *((float *)v108 + 677);
            _H0 = v476->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v480 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v483 = (__n128)vcvtq_f32_f16(v476[-1]);
              __n128 v484 = (__n128)vmulq_n_f32((float32x4_t)v483, v480);
              int32x2_t v485 = (int32x2_t)vcvt_f16_f32((float32x4_t)v484);
              if (v726)
              {
                LOWORD(v63) = v485.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v488 = COERCE_DOUBLE(vdup_lane_s32(v485, 1));
                  goto LABEL_350;
                }
                LOWORD(v490) = v485.i16[2];
                LOWORD(v491) = v485.i16[3];
              }
              else
              {
                LOWORD(v63) = v485.i16[1];
                double v488 = COERCE_DOUBLE(vdup_lane_s32(v485, 1));
                _S4 = 1.0;
LABEL_350:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v484.n128_u16[0] = *(_WORD *)(v31 + 2);
                v483.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAhardlightPDA(_Q0, v484, v483, _Q3, _S4, *(double *)&v485, v63, v488, v49, v50, v51, v52, v53, v54, v55, v56, v485.i16[0], SLOWORD(v63), SLOWORD(v488),
                        SWORD1(v488),
                        _S16);
                unint64_t v490 = HIDWORD(v49);
                unint64_t v491 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_355;
                }
                v485.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v485.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v490;
              *(_WORD *)(v31 + 6) = v491;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_355:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v476 = (float16x4_t *)((char *)v476 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v477) {
            goto LABEL_458;
          }
        }
      case 22:
        int v721 = v46;
        int v492 = v29;
        v493 = v65 + 1;
        int v494 = v492;
        v346 = v39;
        while (1)
        {
          unsigned int v495 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v496 = *v346 * v495 + ((*v346 * v495) >> 8) + 1;
              if (!BYTE1(v496)) {
                goto LABEL_372;
              }
              unsigned int v495 = v496 >> 8;
            }
            float v497 = (float)v495 * *((float *)v108 + 677);
            _H0 = v493->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v497 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v500 = (__n128)vcvtq_f32_f16(v493[-1]);
              __n128 v501 = (__n128)vmulq_n_f32((float32x4_t)v500, v497);
              int32x2_t v502 = (int32x2_t)vcvt_f16_f32((float32x4_t)v501);
              if (v726)
              {
                LOWORD(v63) = v502.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v504 = COERCE_DOUBLE(vdup_lane_s32(v502, 1));
                  goto LABEL_367;
                }
                LOWORD(v506) = v502.i16[2];
                LOWORD(v507) = v502.i16[3];
              }
              else
              {
                LOWORD(v63) = v502.i16[1];
                double v504 = COERCE_DOUBLE(vdup_lane_s32(v502, 1));
                _Q4.i32[0] = 1.0;
LABEL_367:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v501.n128_u16[0] = *(_WORD *)(v31 + 2);
                v500.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAdifferencePDA(_Q0, v501, v500, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, v502, *(float16x4_t *)&v63, v504, v49, v50, v51, v52, v53, v54, v55, v56, v502.i16[0], SLOWORD(v63), SLOWORD(v504),
                        SWORD1(v504),
                        _S16);
                unint64_t v506 = HIDWORD(v49);
                unint64_t v507 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_372;
                }
                v502.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v502.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v506;
              *(_WORD *)(v31 + 6) = v507;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_372:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v493 = (float16x4_t *)((char *)v493 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v494) {
            goto LABEL_458;
          }
        }
      case 23:
        int v721 = v46;
        int v508 = v29;
        v509 = v65 + 1;
        int v510 = v508;
        v346 = v39;
        while (1)
        {
          unsigned int v511 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v512 = *v346 * v511 + ((*v346 * v511) >> 8) + 1;
              if (!BYTE1(v512)) {
                goto LABEL_389;
              }
              unsigned int v511 = v512 >> 8;
            }
            float v513 = (float)v511 * *((float *)v108 + 677);
            _H0 = v509->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v513 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v516 = (__n128)vcvtq_f32_f16(v509[-1]);
              __n128 v517 = (__n128)vmulq_n_f32((float32x4_t)v516, v513);
              int32x2_t v518 = (int32x2_t)vcvt_f16_f32((float32x4_t)v517);
              if (v726)
              {
                LOWORD(v63) = v518.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  int32x2_t v520 = vdup_lane_s32(v518, 1);
                  goto LABEL_384;
                }
                LOWORD(v522) = v518.i16[2];
                LOWORD(v523) = v518.i16[3];
              }
              else
              {
                LOWORD(v63) = v518.i16[1];
                int32x2_t v520 = vdup_lane_s32(v518, 1);
                _Q4.i32[0] = 1.0;
LABEL_384:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v517.n128_u16[0] = *(_WORD *)(v31 + 2);
                v516.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAexclusionPDA(_Q0, v517, v516, (float16x4_t)_Q3.n128_u64[0], *(double *)_Q4.i64, (float16x4_t)v518, v63, v520, v49, v50, v51, v52, v53, v54, v55, v56, v518.i16[0], SLOWORD(v63), v520.i16[0],
                        v520.i16[1],
                        _S16);
                unint64_t v522 = HIDWORD(v49);
                unint64_t v523 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_389;
                }
                v518.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v518.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v522;
              *(_WORD *)(v31 + 6) = v523;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_389:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v509 = (float16x4_t *)((char *)v509 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v510) {
            goto LABEL_458;
          }
        }
      case 24:
        int v721 = v46;
        int v524 = v29;
        v525 = v65 + 1;
        int v526 = v524;
        v346 = v39;
        while (1)
        {
          unsigned int v527 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v528 = *v346 * v527 + ((*v346 * v527) >> 8) + 1;
              if (!BYTE1(v528)) {
                goto LABEL_406;
              }
              unsigned int v527 = v528 >> 8;
            }
            float v529 = (float)v527 * *((float *)v108 + 677);
            _H0 = v525->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v529 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v532 = (__n128)vcvtq_f32_f16(v525[-1]);
              __n128 v533 = (__n128)vmulq_n_f32((float32x4_t)v532, v529);
              int32x2_t v534 = (int32x2_t)vcvt_f16_f32((float32x4_t)v533);
              if (v726)
              {
                LOWORD(v63) = v534.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v537 = COERCE_DOUBLE(vdup_lane_s32(v534, 1));
                  goto LABEL_401;
                }
                LOWORD(v539) = v534.i16[2];
                LOWORD(v540) = v534.i16[3];
              }
              else
              {
                LOWORD(v63) = v534.i16[1];
                double v537 = COERCE_DOUBLE(vdup_lane_s32(v534, 1));
                _S4 = 1.0;
LABEL_401:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v533.n128_u16[0] = *(_WORD *)(v31 + 2);
                v532.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAhuePDA(_Q0, v533, v532, _Q3, _S4, *(double *)&v534, v63, v537, v49, v50, v51, v52, v53, v54, v55, v56, v534.i16[0], SLOWORD(v63), SLOWORD(v537),
                        SWORD1(v537),
                        _S16);
                unint64_t v539 = HIDWORD(v49);
                unint64_t v540 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_406;
                }
                v534.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v534.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v539;
              *(_WORD *)(v31 + 6) = v540;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_406:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v525 = (float16x4_t *)((char *)v525 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v526) {
            goto LABEL_458;
          }
        }
      case 25:
        int v721 = v46;
        int v541 = v29;
        v542 = v65 + 1;
        int v543 = v541;
        v346 = v39;
        while (1)
        {
          unsigned int v544 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v545 = *v346 * v544 + ((*v346 * v544) >> 8) + 1;
              if (!BYTE1(v545)) {
                goto LABEL_423;
              }
              unsigned int v544 = v545 >> 8;
            }
            float v546 = (float)v544 * *((float *)v108 + 677);
            _H0 = v542->i16[0];
            __asm { FCVT            S0, H0 }
            _Q0.n128_f32[0] = v546 * _S0;
            __asm
            {
              FCVT            H0, S0
              FCMP            H0, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v549 = (__n128)vcvtq_f32_f16(v542[-1]);
              __n128 v550 = (__n128)vmulq_n_f32((float32x4_t)v549, v546);
              int32x2_t v551 = (int32x2_t)vcvt_f16_f32((float32x4_t)v550);
              if (v726)
              {
                LOWORD(v63) = v551.i16[1];
                __asm { FCMP            H1, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S4, H1 }
                  double v554 = COERCE_DOUBLE(vdup_lane_s32(v551, 1));
                  goto LABEL_418;
                }
                LOWORD(v556) = v551.i16[2];
                LOWORD(v557) = v551.i16[3];
              }
              else
              {
                LOWORD(v63) = v551.i16[1];
                double v554 = COERCE_DOUBLE(vdup_lane_s32(v551, 1));
                _S4 = 1.0;
LABEL_418:
                __asm { FCVT            S16, H0 }
                _Q0.n128_u16[0] = *(_WORD *)v31;
                v550.n128_u16[0] = *(_WORD *)(v31 + 2);
                v549.n128_u16[0] = *(_WORD *)(v31 + 4);
                _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
                unint64_t v49 = PDAsaturationPDA(_Q0, v550, v549, _Q3, _S4, *(double *)&v551, v63, v554, v49, v50, v51, v52, v53, v54, v55, v56, v551.i16[0], SLOWORD(v63), SLOWORD(v554),
                        SWORD1(v554),
                        _S16);
                unint64_t v556 = HIDWORD(v49);
                unint64_t v557 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_423;
                }
                v551.i16[0] = v49;
                LODWORD(v63) = v49 >> 16;
                _Q0.n128_u16[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v551.i16[0];
              *(_WORD *)(v31 + 2) = LOWORD(v63);
              *(_WORD *)(v31 + 4) = v556;
              *(_WORD *)(v31 + 6) = v557;
              short float *v27 = *(short float *)_Q0.n128_u16;
            }
          }
LABEL_423:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v542 = (float16x4_t *)((char *)v542 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v543) {
            goto LABEL_458;
          }
        }
      case 26:
        int v721 = v46;
        v558 = v65 + 1;
        v346 = v39;
        while (1)
        {
          unsigned int v559 = *v66;
          if (*v66)
          {
            if (v39)
            {
              unsigned int v560 = *v346 * v559 + ((*v346 * v559) >> 8) + 1;
              if (!BYTE1(v560)) {
                goto LABEL_440;
              }
              unsigned int v559 = v560 >> 8;
            }
            float v561 = (float)v559 * *((float *)v108 + 677);
            _H1 = v558->i16[0];
            __asm { FCVT            S1, H1 }
            _S1 = v561 * _S1;
            __asm
            {
              FCVT            H3, S1
              FCMP            H3, #0
            }
            if (!(_NF ^ _VF | _ZF))
            {
              __n128 v566 = (__n128)vcvtq_f32_f16(v558[-1]);
              __n128 v567 = (__n128)vmulq_n_f32((float32x4_t)v566, v561);
              v567.n128_u64[0] = (unint64_t)vcvt_f16_f32((float32x4_t)v567);
              if (v726)
              {
                v566.n128_u16[0] = v567.n128_u16[1];
                __asm { FCMP            H2, #0 }
                if (!(_NF ^ _VF | _ZF))
                {
                  __asm { FCVT            S5, H2 }
                  v59.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v567.n128_u64[0], 1);
                  goto LABEL_435;
                }
                LOWORD(v570) = v567.n128_u16[2];
                LOWORD(v571) = v567.n128_u16[3];
              }
              else
              {
                v566.n128_u16[0] = v567.n128_u16[1];
                v59.n128_u64[0] = (unint64_t)vdup_lane_s32((int32x2_t)v567.n128_u64[0], 1);
                _Q5.i32[0] = 1.0;
LABEL_435:
                __asm { FCVT            S4, H3 }
                _Q3.n128_u16[0] = v59.n128_u16[1];
                unint64_t v49 = PDAluminosityPDA(v567, v566, v59, _Q3, _S4, *(double *)_Q5.i64, v63, v64, v49, v50, v51, v52, v53, v54, v55, v56, *(_DWORD *)v31, HIWORD(*(_DWORD *)v31), *(_DWORD *)(v31 + 4),
                        HIWORD(*(_DWORD *)(v31 + 4)),
                        _Q5.f32[0]);
                unint64_t v570 = HIDWORD(v49);
                unint64_t v571 = HIWORD(v49);
                if (!v726)
                {
                  *(void *)uint64_t v31 = v49;
                  v108 = &xmmword_1850CE000;
                  goto LABEL_440;
                }
                v566.n128_u16[0] = WORD1(v49);
                v567.n128_u16[0] = v49;
                _Q3.n128_u32[0] = v50;
                v108 = &xmmword_1850CE000;
              }
              *(_WORD *)uint64_t v31 = v567.n128_u16[0];
              *(_WORD *)(v31 + 2) = v566.n128_u16[0];
              *(_WORD *)(v31 + 4) = v570;
              *(_WORD *)(v31 + 6) = v571;
              short float *v27 = *(short float *)_Q3.n128_u16;
            }
          }
LABEL_440:
          ++v66;
          v346 += v39 != 0;
          v31 += 8;
          v558 = (float16x4_t *)((char *)v558 + 10);
          v27 = (short float *)((char *)v27 + v44);
          if (!--v29) {
            goto LABEL_458;
          }
        }
      case 27:
        int v721 = v46;
        int v572 = v29;
        v573 = v65 + 1;
        int v574 = v572;
        v346 = v39;
        break;
      default:
        unint64_t v118 = v722;
        goto LABEL_526;
    }
    break;
  }
  while (1)
  {
    unsigned int v575 = *v66;
    if (*v66)
    {
      if (v39)
      {
        unsigned int v576 = *v346 * v575 + ((*v346 * v575) >> 8) + 1;
        if (!BYTE1(v576)) {
          goto LABEL_457;
        }
        unsigned int v575 = v576 >> 8;
      }
      float v577 = (float)v575 * *((float *)v108 + 677);
      _H0 = v573->i16[0];
      __asm { FCVT            S0, H0 }
      _Q0.n128_f32[0] = v577 * _S0;
      __asm
      {
        FCVT            H0, S0
        FCMP            H0, #0
      }
      if (!(_NF ^ _VF | _ZF))
      {
        __n128 v580 = (__n128)vcvtq_f32_f16(v573[-1]);
        __n128 v581 = (__n128)vmulq_n_f32((float32x4_t)v580, v577);
        int32x2_t v582 = (int32x2_t)vcvt_f16_f32((float32x4_t)v581);
        if (v726)
        {
          LOWORD(v63) = v582.i16[1];
          __asm { FCMP            H1, #0 }
          if (!(_NF ^ _VF | _ZF))
          {
            __asm { FCVT            S4, H1 }
            double v585 = COERCE_DOUBLE(vdup_lane_s32(v582, 1));
            goto LABEL_452;
          }
          LOWORD(v587) = v582.i16[2];
          LOWORD(v588) = v582.i16[3];
        }
        else
        {
          LOWORD(v63) = v582.i16[1];
          double v585 = COERCE_DOUBLE(vdup_lane_s32(v582, 1));
          _S4 = 1.0;
LABEL_452:
          __asm { FCVT            S16, H0 }
          _Q0.n128_u16[0] = *(_WORD *)v31;
          v581.n128_u16[0] = *(_WORD *)(v31 + 2);
          v580.n128_u16[0] = *(_WORD *)(v31 + 4);
          _Q3.n128_u16[0] = *(_WORD *)(v31 + 6);
          unint64_t v49 = PDAluminosityPDA(_Q0, v581, v580, _Q3, _S4, *(double *)&v582, v63, v585, v49, v50, v51, v52, v53, v54, v55, v56, v582.i16[0], SLOWORD(v63), SLOWORD(v585),
                  SWORD1(v585),
                  _S16);
          unint64_t v587 = HIDWORD(v49);
          unint64_t v588 = HIWORD(v49);
          if (!v726)
          {
            *(void *)uint64_t v31 = v49;
            v108 = &xmmword_1850CE000;
            goto LABEL_457;
          }
          v582.i16[0] = v49;
          LODWORD(v63) = v49 >> 16;
          _Q0.n128_u16[0] = v50;
          v108 = &xmmword_1850CE000;
        }
        *(_WORD *)uint64_t v31 = v582.i16[0];
        *(_WORD *)(v31 + 2) = LOWORD(v63);
        *(_WORD *)(v31 + 4) = v587;
        *(_WORD *)(v31 + 6) = v588;
        short float *v27 = *(short float *)_Q0.n128_u16;
      }
    }
LABEL_457:
    ++v66;
    v346 += v39 != 0;
    v31 += 8;
    v573 = (float16x4_t *)((char *)v573 + 10);
    v27 = (short float *)((char *)v27 + v44);
    if (!--v574)
    {
LABEL_458:
      v39 = &v346[v717];
      v31 += 8 * v718;
      v27 += v720;
      int v35 = v716;
      int v29 = v714;
      v36 = v715;
      int v46 = v721;
      goto LABEL_524;
    }
  }
}

uint64_t CMYKf16_sample_CMYKf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, float32x4_t _Q6)
{
  int v13 = *(_DWORD *)(result + 24);
  int v167 = *(_DWORD *)(result + 28);
  uint64_t v14 = *(void *)(result + 112);
  uint64_t v15 = *(void *)(result + 48);
  uint64_t v16 = *(void *)(result + 56);
  if (v15)
  {
    uint64_t v166 = *(void *)(result + 112);
    if (v14 > v15) {
      uint64_t v166 = v14 % v15;
    }
  }
  else
  {
    uint64_t v166 = 0;
  }
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v19 = *(void *)(result + 32);
  uint64_t v18 = *(void *)(result + 40);
  uint64_t v20 = *(void *)(result + 120);
  if (v16)
  {
    uint64_t v21 = v20 % v16;
    if (v20 <= v16) {
      uint64_t v21 = *(void *)(result + 120);
    }
    uint64_t v165 = v21;
  }
  else
  {
    uint64_t v165 = 0;
  }
  uint64_t v161 = *(void *)(result + 80);
  uint64_t v162 = *(void *)(result + 64);
  uint64_t v163 = *(void *)(result + 88);
  int v160 = *(_DWORD *)(result + 188);
  uint64_t v22 = *(void *)(result + 152) - 10;
  uint64_t v23 = *(void *)(result + 144) - 1;
  int v24 = *(_DWORD *)(result + 260) - 1;
  int v25 = *(_DWORD *)(result + 256);
  unint64_t v26 = v18 + (v24 * v167) + 2 * (v25 - 1);
  unint64_t v27 = v19 + (v24 * v13) + 2 * (4 * v25) - 8;
  int v158 = *(_DWORD *)(result + 240);
  int v159 = a4;
  uint64_t v164 = *(void *)(result + 72);
  while (1)
  {
    if (a3 >= v164)
    {
      if (a3 <= v163)
      {
        uint64_t v36 = 0;
        uint64_t v37 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v38 = 0x3FFFFFFF;
        uint64_t v39 = a3;
        uint64_t v40 = v162;
      }
      else
      {
        uint64_t v32 = *(void *)(result + 216);
        uint64_t v33 = *(void *)(result + 224) + v163;
        uint64_t v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1) {
          goto LABEL_57;
        }
        if (v34 >= v32) {
          LODWORD(v35) = 0x3FFFFFFF;
        }
        else {
          unint64_t v35 = (unint64_t)(*(void *)(result + 232) * v34) >> 32;
        }
        uint64_t v40 = v162;
        unsigned int v38 = v160 | v35;
        uint64_t v39 = v33 - 0x1000000;
        uint64_t v36 = a3 - (v33 - 0x1000000);
        uint64_t v37 = 448;
      }
    }
    else
    {
      uint64_t v28 = *(void *)(result + 216);
      uint64_t v29 = v164 - *(void *)(result + 224);
      uint64_t v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1) {
        goto LABEL_57;
      }
      if (v30 >= v28) {
        LODWORD(v31) = 0x3FFFFFFF;
      }
      else {
        unint64_t v31 = (unint64_t)(*(void *)(result + 232) * v30) >> 32;
      }
      uint64_t v40 = v162;
      unsigned int v38 = v160 | v31;
      uint64_t v39 = v29 + 0x1000000;
      uint64_t v36 = a3 - (v29 + 0x1000000);
      uint64_t v37 = 512;
    }
    if (a2 >= v40) {
      break;
    }
    uint64_t v41 = *(void *)(result + 192);
    uint64_t v42 = v40 - *(void *)(result + 200);
    uint64_t v43 = a2 - v42 + (v41 >> 1);
    if (v43 >= 1)
    {
      if (v43 < v41) {
        unsigned int v38 = ((v38 >> 15) * (((unint64_t)(*(void *)(result + 208) * v43) >> 32) >> 15)) | v160;
      }
      uint64_t v44 = v42 + 0x1000000;
      uint64_t v45 = a2 - (v42 + 0x1000000);
      uint64_t v46 = 32;
      goto LABEL_35;
    }
LABEL_57:
    --a4;
    a2 += v14;
    a3 += v20;
    v22 += 10;
    *(unsigned char *)++uint64_t v23 = 0;
LABEL_58:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v161)
  {
    uint64_t v45 = 0;
    uint64_t v46 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v44 = a2;
    goto LABEL_35;
  }
  uint64_t v47 = *(void *)(result + 192);
  uint64_t v48 = *(void *)(result + 200) + v161;
  uint64_t v49 = v48 - a2 + (v47 >> 1);
  if (v49 < 1) {
    goto LABEL_57;
  }
  if (v49 < v47) {
    unsigned int v38 = ((v38 >> 15) * (((unint64_t)(*(void *)(result + 208) * v49) >> 32) >> 15)) | v160;
  }
  uint64_t v44 = v48 - 0x1000000;
  uint64_t v45 = a2 - (v48 - 0x1000000);
  uint64_t v46 = 28;
LABEL_35:
  if (v38 < 0x400000) {
    goto LABEL_57;
  }
  if (v15)
  {
    uint64_t v50 = (v16 & ((v39 % v16) >> 63)) + v39 % v16;
    uint64_t v51 = (v15 & ((v44 % v15) >> 63)) + v44 % v15;
    if (v50 >= v16) {
      uint64_t v52 = v16;
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t v39 = v50 - v52;
    if (v51 >= v15) {
      uint64_t v53 = v15;
    }
    else {
      uint64_t v53 = 0;
    }
    uint64_t v44 = v51 - v53;
    v36 += v39;
    v45 += v51 - v53;
  }
  uint64_t v54 = v39 >> 32;
  uint64_t v55 = v44 >> 32;
  uint64_t v56 = v19 + SHIDWORD(v39) * (uint64_t)v13;
  unint64_t v57 = v56 + 8 * v55;
  v58 = *(float16x4_t **)(result + 32);
  if (v27 >= v57) {
    __n128 v59 = (float16x4_t *)(v56 + 8 * v55);
  }
  else {
    __n128 v59 = (float16x4_t *)v27;
  }
  if (v59 >= v58) {
    v60 = v59;
  }
  else {
    v60 = *(float16x4_t **)(result + 32);
  }
  if (v18)
  {
    unint64_t v61 = v18 + (int)v54 * (uint64_t)v167 + 2 * v55;
    v62 = *(__int16 **)(result + 40);
    if (v26 >= v61) {
      double v63 = (__int16 *)v61;
    }
    else {
      double v63 = (__int16 *)v26;
    }
    if (v63 >= v62) {
      v62 = v63;
    }
    _H2 = *v62;
  }
  else
  {
    unint64_t v61 = 0;
    _H2 = COERCE_UNSIGNED_INT(1.0);
  }
  float16x4_t v65 = *v60;
  if (!v17) {
    goto LABEL_155;
  }
  unsigned int v66 = *(_DWORD *)(v17 + (v46 | v37));
LABEL_63:
  int v67 = v66 & 0xF;
  uint64_t v68 = v66 >> 8;
  unsigned int v69 = HIBYTE(v66) & 3;
  switch(v67)
  {
    case 1:
      LODWORD(v114) = SBYTE1(v66);
      if (v15)
      {
        uint64_t v115 = v68 << 56;
        uint64_t v116 = v36 + ((uint64_t)(char)v68 << 32);
        uint64_t v117 = v16 & (v116 >> 63);
        if (v117 + v116 >= v16) {
          uint64_t v118 = v16;
        }
        else {
          uint64_t v118 = 0;
        }
        uint64_t v114 = (v117 + (v115 >> 24) - v118) >> 32;
      }
      unsigned __int8 v119 = (float16x4_t *)(v57 + (int)v114 * (uint64_t)v13);
      if (v27 < (unint64_t)v119) {
        unsigned __int8 v119 = (float16x4_t *)v27;
      }
      if (v119 < v58) {
        unsigned __int8 v119 = v58;
      }
      float16x4_t v120 = *v119;
      _H5 = COERCE_UNSIGNED_INT(1.0);
      if (v18)
      {
        v122 = (__int16 *)(v61 + (int)v114 * (uint64_t)v167);
        if (v26 < (unint64_t)v122) {
          v122 = (__int16 *)v26;
        }
        if ((unint64_t)v122 < *(void *)(result + 40)) {
          v122 = *(__int16 **)(result + 40);
        }
        _H5 = *v122;
      }
      _Q6.i16[0] = interpolate_cmykaf[5 * v69 + 4];
      __asm { FCVT            S6, H6 }
      float32x4_t v123 = vcvtq_f32_f16(v65);
      float16x4_t v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v123, v123, *(float32x2_t *)_Q6.f32, 0), vcvtq_f32_f16(v120), _Q6.f32[0]));
      __asm { FCVT            S2, H2 }
      float v125 = _S2 - (float)(_S2 * _Q6.f32[0]);
      __asm { FCVT            S4, H5 }
      goto LABEL_153;
    case 2:
      uint64_t v127 = SBYTE2(v66);
      if (v15)
      {
        int64_t v128 = (unint64_t)HIWORD(v66) << 56;
        uint64_t v129 = v45 + (v128 >> 24);
        uint64_t v130 = v15 & (v129 >> 63);
        if (v130 + v129 >= v15) {
          uint64_t v131 = v15;
        }
        else {
          uint64_t v131 = 0;
        }
        uint64_t v127 = (v130 + (v128 >> 24) - v131) >> 32;
      }
      v132 = (float16x4_t *)(v57 + 8 * v127);
      if (v27 < (unint64_t)v132) {
        v132 = (float16x4_t *)v27;
      }
      if (v132 < v58) {
        v132 = v58;
      }
      float16x4_t v133 = *v132;
      _H4 = COERCE_UNSIGNED_INT(1.0);
      if (v18)
      {
        v135 = (__int16 *)(v61 + 2 * v127);
        if (v26 < (unint64_t)v135) {
          v135 = (__int16 *)v26;
        }
        if ((unint64_t)v135 < *(void *)(result + 40)) {
          v135 = *(__int16 **)(result + 40);
        }
        _H4 = *v135;
      }
      _Q6.i16[0] = interpolate_cmykaf[5 * ((v66 >> 28) & 3) + 4];
      __asm { FCVT            S6, H6 }
      float32x4_t v136 = vcvtq_f32_f16(v65);
      float16x4_t v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v136, v136, *(float32x2_t *)_Q6.f32, 0), vcvtq_f32_f16(v133), _Q6.f32[0]));
      __asm { FCVT            S2, H2 }
      float v125 = _S2 - (float)(_S2 * _Q6.f32[0]);
      __asm { FCVT            S4, H4 }
LABEL_153:
      _S2 = v125 + (float)(_S4 * _Q6.f32[0]);
      goto LABEL_154;
    case 3:
      LODWORD(v70) = SBYTE1(v66);
      uint64_t v71 = SBYTE2(v66);
      if (v15)
      {
        uint64_t v72 = v68 << 56;
        uint64_t v73 = v36 + (v72 >> 24);
        uint64_t v74 = v45 + ((uint64_t)SBYTE2(v66) << 32);
        unsigned int v157 = v38;
        uint64_t v75 = v16 & (v73 >> 63);
        uint64_t v76 = v15 & (v74 >> 63);
        uint64_t v77 = v76 + v74;
        if (v75 + v73 >= v16) {
          uint64_t v78 = v16;
        }
        else {
          uint64_t v78 = 0;
        }
        if (v77 >= v15) {
          uint64_t v79 = v15;
        }
        else {
          uint64_t v79 = 0;
        }
        uint64_t v80 = v75 + (v72 >> 24);
        unsigned int v38 = v157;
        uint64_t v70 = (v80 - v78) >> 32;
        uint64_t v71 = (v76 + ((uint64_t)((unint64_t)HIWORD(v66) << 56) >> 24) - v79) >> 32;
      }
      v81 = (float16x4_t *)(v57 + 8 * v71);
      if (v27 < (unint64_t)v81) {
        v81 = (float16x4_t *)v27;
      }
      if (v81 < v58) {
        v81 = v58;
      }
      unint64_t v82 = v57 + (int)v70 * (uint64_t)v13;
      if (v27 >= v82) {
        unint64_t v83 = (float16x4_t *)(v57 + (int)v70 * (uint64_t)v13);
      }
      else {
        unint64_t v83 = (float16x4_t *)v27;
      }
      if (v83 < v58) {
        unint64_t v83 = v58;
      }
      v84 = (float16x4_t *)(v82 + 8 * v71);
      if (v27 < (unint64_t)v84) {
        v84 = (float16x4_t *)v27;
      }
      if (v84 < v58) {
        v84 = v58;
      }
      float16x4_t v85 = *v81;
      float16x4_t v86 = *v83;
      float16x4_t v87 = *v84;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      _H16 = COERCE_UNSIGNED_INT(1.0);
      _H17 = COERCE_UNSIGNED_INT(1.0);
      if (v18)
      {
        v91 = (__int16 *)(v61 + 2 * v71);
        unint64_t v92 = *(void *)(result + 40);
        if (v26 < (unint64_t)v91) {
          v91 = (__int16 *)v26;
        }
        if ((unint64_t)v91 < v92) {
          v91 = *(__int16 **)(result + 40);
        }
        _H7 = *v91;
        unint64_t v93 = v61 + (int)v70 * (uint64_t)v167;
        if (v26 >= v93) {
          v94 = (__int16 *)(v61 + (int)v70 * (uint64_t)v167);
        }
        else {
          v94 = (__int16 *)v26;
        }
        if ((unint64_t)v94 < v92) {
          v94 = *(__int16 **)(result + 40);
        }
        _H16 = *v94;
        v95 = (__int16 *)(v93 + 2 * v71);
        if (v26 < (unint64_t)v95) {
          v95 = (__int16 *)v26;
        }
        if ((unint64_t)v95 < v92) {
          v95 = *(__int16 **)(result + 40);
        }
        _H17 = *v95;
      }
      _H18 = interpolate_cmykaf[5 * (HIBYTE(v66) & 3) + 4];
      __asm { FCVT            S18, H18 }
      _H19 = interpolate_cmykaf[5 * ((v66 >> 28) & 3) + 4];
      __asm { FCVT            S19, H19 }
      float32x4_t v101 = vcvtq_f32_f16(v65);
      float32x4_t v102 = vcvtq_f32_f16(v85);
      float32x4_t v103 = vcvtq_f32_f16(v86);
      _Q6 = vcvtq_f32_f16(v87);
      __asm
      {
        FCVT            S2, H2
        FCVT            S7, H7
      }
      float v106 = (float)(_S2 - (float)(_S2 * _D19.f32[0])) + (float)(_S7 * _D19.f32[0]);
      if (v106 < 1.0) {
        float v107 = v106;
      }
      else {
        float v107 = 1.0;
      }
      if (v106 > 1.0) {
        float v106 = 1.0;
      }
      if (v107 < 0.0) {
        float v106 = 0.0;
      }
      __asm
      {
        FCVT            S7, H16
        FCVT            S16, H17
      }
      float v110 = (float)(_S7 - (float)(_S7 * _D19.f32[0])) + (float)(_S16 * _D19.f32[0]);
      if (v110 < 1.0) {
        float v111 = v110;
      }
      else {
        float v111 = 1.0;
      }
      if (v110 > 1.0) {
        float v110 = 1.0;
      }
      if (v111 < 0.0) {
        float v110 = 0.0;
      }
      float32x4_t v112 = vmlaq_n_f32(vmlsq_lane_f32(v101, v101, _D19, 0), v102, _D19.f32[0]);
      float16x4_t v65 = vcvt_f16_f32(vmlaq_n_f32(vmlsq_lane_f32(v112, v112, _D18, 0), vmlaq_n_f32(vmlsq_lane_f32(v103, v103, _D19, 0), _Q6, _D19.f32[0]), _D18.f32[0]));
      _S2 = (float)(v106 - (float)(v106 * _D18.f32[0])) + (float)(v110 * _D18.f32[0]);
      if (_S2 >= 1.0) {
        _S2 = 1.0;
      }
      if (_S2 <= 0.0) {
        _S2 = 0.0;
      }
LABEL_154:
      __asm { FCVT            H2, S2 }
      break;
  }
LABEL_155:
  *(float16x4_t *)(v22 + 10) = v65;
  *(_WORD *)(v22 + 18) = _H2;
  *(unsigned char *)++uint64_t v23 = v38 >> 22;
  if (--a4)
  {
    unsigned int v138 = (float16x4_t *)(v22 + 28);
    a2 += v14;
    uint64_t v139 = v161 - a2;
    a3 += v20;
    uint64_t v140 = v163 - a3;
    while (1)
    {
      uint64_t v22 = (uint64_t)&v138[-3] + 6;
      if ((v140 | v139 | (a3 - v164) | (a2 - v162)) < 0) {
        goto LABEL_58;
      }
      if (v15)
      {
        uint64_t v141 = (v16 & ((v36 + v165) >> 63)) + v36 + v165;
        uint64_t v142 = (v15 & ((v45 + v166) >> 63)) + v45 + v166;
        if (v141 >= v16) {
          uint64_t v143 = v16;
        }
        else {
          uint64_t v143 = 0;
        }
        uint64_t v36 = v141 - v143;
        if (v142 >= v15) {
          uint64_t v144 = v15;
        }
        else {
          uint64_t v144 = 0;
        }
        uint64_t v45 = v142 - v144;
        uint64_t v145 = v36;
        uint64_t v146 = v45;
      }
      else
      {
        uint64_t v145 = a3;
        uint64_t v146 = a2;
      }
      uint64_t v147 = v146 >> 32;
      uint64_t v148 = v145 >> 32;
      uint64_t v149 = v19 + (int)v148 * (uint64_t)v13;
      unint64_t v57 = v149 + 8 * v147;
      v58 = *(float16x4_t **)(result + 32);
      if (v27 >= v57) {
        v150 = (float16x4_t *)(v149 + 8 * v147);
      }
      else {
        v150 = (float16x4_t *)v27;
      }
      if (v150 < v58) {
        v150 = *(float16x4_t **)(result + 32);
      }
      if (v18)
      {
        unint64_t v61 = v18 + (int)v148 * (uint64_t)v167 + 2 * v147;
        v151 = *(__int16 **)(result + 40);
        if (v26 >= v61) {
          v152 = (__int16 *)v61;
        }
        else {
          v152 = (__int16 *)v26;
        }
        if (v152 >= v151) {
          v151 = v152;
        }
        _H2 = *v151;
      }
      else
      {
        _H2 = COERCE_UNSIGNED_INT(1.0);
      }
      float16x4_t v65 = *v150;
      if (v17)
      {
        unsigned int v66 = *(_DWORD *)(v17 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        unsigned int v153 = v66 & 0xF;
        if ((v66 & 0xF) != 0)
        {
          int v154 = *(unsigned int **)(result + 264);
          unsigned int v155 = *v154;
          if (a4 + 1 != v159 && a4 != 1 && v158 != 1 && v155 == 3 && v153 < 3) {
            v66 |= 3u;
          }
          unsigned int v38 = -1;
          if (v155 < v153) {
            *int v154 = v153;
          }
          goto LABEL_63;
        }
      }
      v138[-1] = v65;
      v138->i16[0] = _H2;
      unsigned int v138 = (float16x4_t *)((char *)v138 + 10);
      a2 += v14;
      v139 -= v14;
      a3 += v20;
      *(unsigned char *)++uint64_t v23 = -1;
      v140 -= v20;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

uint64_t CMYKf16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x4000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = CMYKf16_shade_radial_CMYK;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = CMYKf16_shade_conic_CMYK;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = CMYKf16_shade_axial_CMYK;
  }
  else
  {
    uint64_t v12 = CMYKf16_shade_custom_CMYK;
  }
  int v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  CMYKf16_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

void CMYKf16_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  uint64_t v6 = *(float **)(a1 + 272);
  float v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  float v8 = *(float *)(a1 + 336);
  float v9 = *(float *)(a1 + 344);
  float v10 = *(float *)(a1 + 304);
  float v11 = *(float *)(a1 + 308);
  LODWORD(v12) = *(_DWORD *)(a1 + 320);
  int v13 = *(_DWORD *)(a1 + 324);
  uint64_t v16 = a1 + 144;
  int v14 = *(_DWORD **)(a1 + 144);
  uint64_t v15 = *(void *)(v16 + 8);
  uint64_t v17 = *(float32x4_t **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v18 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v18 = v6;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  char v19 = *(float **)(a1 + 40);
  if (v19) {
    uint64_t v6 = v19;
  }
  if (v5 != 0.0)
  {
    for (i = (float16x4_t *)(v15 + 8); ; i = (float16x4_t *)((char *)i + 10))
    {
      LODWORD(v23) = v12;
      if (v7 >= v10)
      {
        LODWORD(v23) = v13;
        if (v7 <= v11) {
          LODWORD(v23) = (int)(float)(v9 * (float)(v7 - v8));
        }
      }
      if ((v23 & 0x80000000) != 0)
      {
        if (!v17)
        {
          char v32 = 0;
          goto LABEL_29;
        }
        _S6 = *v18;
        float32x4_t v26 = *v17;
      }
      else
      {
        uint64_t v24 = 16 * v23;
        uint64_t v23 = v23;
        if (!v19) {
          uint64_t v23 = 0;
        }
        _S6 = v6[v23];
        float32x4_t v26 = *(float32x4_t *)(v20 + v24);
        if (!v19) {
          goto LABEL_28;
        }
      }
      float32x4_t v26 = vmulq_n_f32(v26, _S6);
LABEL_28:
      i[-1] = vcvt_f16_f32(v26);
      __asm { FCVT            H6, S6 }
      i->i16[0] = _H6;
      char v32 = -1;
LABEL_29:
      float v7 = v5 + v7;
      *(unsigned char *)int v14 = v32;
      int v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v7 >= v10)
  {
    LODWORD(v12) = v13;
    if (v7 <= v11) {
      LODWORD(v12) = (int)(float)(v9 * (float)(v7 - v8));
    }
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      _S1 = *v18;
      float32x4_t v35 = *v17;
    }
    else
    {
      uint64_t v33 = 16 * v12;
      uint64_t v12 = v12;
      if (!v19) {
        uint64_t v12 = 0;
      }
      _S1 = v6[v12];
      float32x4_t v35 = *(float32x4_t *)(v20 + v33);
      if (!v19) {
        goto LABEL_39;
      }
    }
    float32x4_t v35 = vmulq_n_f32(v35, _S1);
LABEL_39:
    float16x4_t v36 = vcvt_f16_f32(v35);
    __asm { FCVT            H1, S1 }
    int v38 = a4 + 4;
    do
    {
      *(float16x4_t *)uint64_t v15 = v36;
      *(_WORD *)(v15 + 8) = _H1;
      *(float16x4_t *)(v15 + 10) = v36;
      *(_WORD *)(v15 + 18) = _H1;
      *(float16x4_t *)(v15 + 20) = v36;
      *(_WORD *)(v15 + 28) = _H1;
      *(float16x4_t *)(v15 + 30) = v36;
      v38 -= 4;
      *(_WORD *)(v15 + 38) = _H1;
      v15 += 40;
      *v14++ = -1;
    }
    while (v38 > 4);
    return;
  }
  if (a4 >= 4) {
    int v21 = 4;
  }
  else {
    int v21 = a4;
  }
  bzero(v14, ((a4 - v21 + 3) & 0xFFFFFFFC) + 4);
}

uint64_t CMYKf16_shade_custom_CMYK(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6 = *(void *)(result + 272);
  float32x2_t v7 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v6 + 4) * (float)a3), v7, *(float *)(v6 + 4) * (float)a2));
  float32x4_t v8 = *(float32x4_t *)(result + 304);
  float v9 = *(float *)(result + 336);
  float v10 = *(float *)(result + 348);
  float v11 = *(float *)(result + 344);
  float v12 = *(float *)(result + 356);
  int v13 = *(char **)(result + 144);
  int v14 = *(float32x4_t **)(result + 384);
  uint64_t v15 = *(float **)(result + 392);
  if (!v15) {
    uint64_t v15 = *(float **)(result + 272);
  }
  uint64_t v16 = *(void *)(result + 32);
  uint64_t v17 = *(void *)(result + 40);
  if (v17) {
    int v18 = *(_DWORD *)(result + 48);
  }
  else {
    int v18 = 0;
  }
  if (v17) {
    uint64_t v6 = *(void *)(result + 40);
  }
  int v19 = 4 * *(_DWORD *)(result + 48);
  uint64_t v20 = (float16x4_t *)(*(void *)(result + 152) + 8);
  do
  {
    float32x4_t v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      int v24 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      float v25 = v11 * (float)(*(float *)a6.i32 - v9);
      uint64_t v26 = v16 + 4 * v19 * v24;
      uint64_t v27 = 16 * (int)v25;
      uint64_t v28 = v6 + 4 * v18 * v24;
      result = (int)v25;
      if (!v17) {
        result = 0;
      }
      _S7 = *(float *)(v28 + 4 * result);
      float32x4_t v23 = *(float32x4_t *)(v26 + v27);
      if (!v17) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
    if (v14)
    {
      _S7 = *v15;
      float32x4_t v23 = *v14;
LABEL_15:
      float32x4_t v23 = vmulq_n_f32(v23, _S7);
LABEL_16:
      v20[-1] = vcvt_f16_f32(v23);
      __asm { FCVT            H7, S7 }
      v20->i16[0] = _H7;
      char v34 = -1;
      goto LABEL_18;
    }
    char v34 = 0;
LABEL_18:
    *(float32x2_t *)a6.i8 = vadd_f32(v7, *(float32x2_t *)a6.i8);
    *v13++ = v34;
    uint64_t v20 = (float16x4_t *)((char *)v20 + 10);
    --a4;
  }
  while (a4);
  return result;
}

void CMYKf16_shade_conic_CMYK(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, int64x2_t a5, __n128 a6)
{
  float32x2_t v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(void *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(void *)&a1[34] + 4) * (float)a2));
  float v8 = a1[42].f32[0];
  float v9 = a1[43].f32[0];
  float v10 = a1[38].f32[0];
  float v12 = (unsigned char *)a1[18];
  float v11 = (float16x4_t *)a1[19];
  float32x2_t v13 = a1[4];
  float32x2_t v14 = a1[5];
  if (v14) {
    float32x2_t v15 = a1[5];
  }
  else {
    float32x2_t v15 = a1[34];
  }
  float v16 = a1[38].f32[1] - v10;
  *(float32x2_t *)a5.i8 = a1[5];
  int64x2_t v37 = a5;
  __asm { FMOV            V0.4S, #1.0 }
  int8x16_t v36 = (int8x16_t)_Q0;
  do
  {
    _Q0.i64[0] = 0;
    int8x16_t v38 = (int8x16_t)vdupq_lane_s64(vceqq_s64(v37, _Q0).i64[0], 0);
    __n128 v39 = a6;
    *(float *)_Q0.i32 = v9
                      * (float)((float)(v10
                                      + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5)
                                              * v16))
                              - v8);
    float v24 = ceilf(*(float *)_Q0.i32);
    signed int v25 = vcvtms_s32_f32(*(float *)_Q0.i32);
    unsigned int v26 = vcvtms_s32_f32(v9 + *(float *)_Q0.i32);
    if (*(float *)_Q0.i32 < 0.0) {
      signed int v25 = v26;
    }
    float v27 = ceilf(*(float *)_Q0.i32 - v9);
    if (*(float *)_Q0.i32 > v9) {
      float v24 = v27;
    }
    uint64_t v28 = v25;
    if (!*(void *)&v14) {
      uint64_t v28 = 0;
    }
    v22.i32[0] = *(_DWORD *)(*(void *)&v15 + 4 * v28);
    int v29 = (int)v24;
    int8x16_t v30 = (int8x16_t)vdupq_lane_s32(v22, 0);
    uint64_t v31 = v29;
    if (!*(void *)&v14) {
      uint64_t v31 = 0;
    }
    v23.i32[0] = *(_DWORD *)(*(void *)&v15 + 4 * v31);
    float v32 = *(float *)_Q0.i32 - (float)(int)floorf(*(float *)_Q0.i32);
    _Q1 = vmulq_f32(*(float32x4_t *)(*(void *)&v13 + 16 * v25), (float32x4_t)vbslq_s8(v38, v36, v30));
    _S2 = *(float *)v22.i32 + (float)(v32 * (float)(*(float *)v23.i32 - *(float *)v22.i32));
    float16x4_t v35 = vcvt_f16_f32(vmlaq_n_f32(_Q1, vsubq_f32(vmulq_f32(*(float32x4_t *)(*(void *)&v13 + 16 * v29), (float32x4_t)vbslq_s8(v38, v36, (int8x16_t)vdupq_lane_s32(v23, 0))), _Q1), v32));
    __asm { FCVT            H1, S2 }
    *float v11 = v35;
    v11[1].i16[0] = _Q1.i16[0];
    a6.n128_u64[1] = v39.n128_u64[1];
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v39.n128_u64[0]);
    *v12++ = -1;
    float v11 = (float16x4_t *)((char *)v11 + 10);
    --a4;
  }
  while (a4);
}

void CMYKf16_shade_radial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v9 = *(float **)(a1 + 400);
  float v10 = *(float *)(a1 + 280);
  float v11 = *(float *)(a1 + 284);
  float v12 = *(float **)(a1 + 272);
  float v13 = v12[1];
  float v14 = v13 * (float)a2;
  float v15 = v13 * (float)a3;
  float v16 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v15) + (float)(v10 * v14));
  float v17 = *(float *)(a1 + 300) + (float)((float)(v15 * *(float *)(a1 + 292)) + (float)(v11 * v14));
  float v18 = *(float *)(a1 + 336);
  float v19 = *(float *)(a1 + 344);
  float v20 = *(float *)(a1 + 304);
  float v21 = *(float *)(a1 + 308);
  uint64_t v22 = *(unsigned int *)(a1 + 324);
  float v23 = v9[2];
  float v24 = v9[4];
  float v25 = v9[5];
  float v26 = v9[7];
  uint64_t v29 = a1 + 144;
  float v27 = *(char **)(a1 + 144);
  uint64_t v28 = *(void *)(v29 + 8);
  int8x16_t v30 = *(float32x4_t **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v31 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v31 = v12;
  }
  uint64_t v32 = *(void *)(a1 + 32);
  uint64_t v33 = *(void *)(a1 + 40);
  if (v33) {
    char v34 = *(float **)(a1 + 40);
  }
  else {
    char v34 = v12;
  }
  if (v23 != 0.0 || v26 != 0.0 || v11 != 0.0)
  {
    int v38 = *(_DWORD *)(a1 + 320);
    float v39 = v9[3];
    float v40 = v9[8];
    float v41 = -v9[6];
    float v42 = v21 - v20;
    for (i = (float16x4_t *)(v28 + 8); ; i = (float16x4_t *)((char *)i + 10))
    {
      float v44 = v41 + (float)((float)(v16 + v16) * v23);
      float v45 = (float)((float)(v17 * v17) + (float)(v16 * v16)) - v26;
      if (v25 == 0.0)
      {
        float v52 = v45 / v44;
      }
      else
      {
        float v46 = (float)((float)(v25 * -4.0) * v45) + (float)(v44 * v44);
        if (v46 < 0.0) {
          goto LABEL_48;
        }
        float v47 = sqrtf(v46);
        float v48 = v40 * (float)(v44 - v47);
        float v49 = v44 + v47;
        float v50 = v40 * v49;
        BOOL v51 = (float)(v40 * v49) <= v48;
        if ((float)(v40 * v49) <= v48) {
          float v52 = v40 * v49;
        }
        else {
          float v52 = v48;
        }
        if (v51) {
          float v50 = v48;
        }
        if (v50 < 0.0)
        {
          _NF = v50 < v39;
LABEL_31:
          LODWORD(v54) = v38;
          if (_NF) {
            goto LABEL_48;
          }
LABEL_32:
          if ((v54 & 0x80000000) == 0) {
            goto LABEL_44;
          }
          goto LABEL_48;
        }
        if (v50 <= 1.0)
        {
          float v55 = v20 + (float)(v50 * v42);
          goto LABEL_43;
        }
        if ((v22 & 0x80000000) == 0)
        {
          LODWORD(v54) = v22;
          if (v50 <= v24)
          {
LABEL_44:
            uint64_t v56 = 16 * v54;
            uint64_t v54 = v54;
            if (!v33) {
              uint64_t v54 = 0;
            }
            _S25 = v34[v54];
            float32x4_t v58 = *(float32x4_t *)(v32 + v56);
            if (!v33) {
              goto LABEL_51;
            }
            goto LABEL_50;
          }
        }
      }
      if (v52 < 0.0)
      {
        _NF = v52 < v39;
        goto LABEL_31;
      }
      if (v52 > 1.0)
      {
        LODWORD(v54) = v22;
        if (v52 > v24) {
          goto LABEL_48;
        }
        goto LABEL_32;
      }
      float v55 = v20 + (float)(v52 * v42);
LABEL_43:
      LODWORD(v54) = (int)(float)(v19 * (float)(v55 - v18));
      if ((v54 & 0x80000000) == 0) {
        goto LABEL_44;
      }
LABEL_48:
      if (!v30)
      {
        char v63 = 0;
        goto LABEL_53;
      }
      _S25 = *v31;
      float32x4_t v58 = *v30;
LABEL_50:
      float32x4_t v58 = vmulq_n_f32(v58, _S25);
LABEL_51:
      i[-1] = vcvt_f16_f32(v58);
      __asm { FCVT            H25, S25 }
      i->i16[0] = _H25;
      char v63 = -1;
LABEL_53:
      float v16 = v10 + v16;
      float v17 = v11 + v17;
      *v27++ = v63;
      if (!--a4) {
        return;
      }
    }
  }
  float v35 = v17 * v17;
  float v36 = -v25;
  if (v35 <= (float)-v25)
  {
    float v64 = fabsf(v9[8]);
    float v65 = v25 * -4.0;
    float v66 = v21 - v20;
    if (v33) {
      uint64_t v67 = v22;
    }
    else {
      uint64_t v67 = 0;
    }
    uint64_t v68 = (int32x2_t *)(v28 + 10);
    int v69 = a4 + 2;
    v4.i64[0] = *(void *)(a1 + 40);
    __asm { FMOV            V20.4S, #1.0 }
    v5.i64[0] = v4.i64[0];
    while (1)
    {
      float v71 = v35 + (float)(v16 * v16);
      float v72 = v10 + v16;
      float v73 = v35 + (float)(v72 * v72);
      if (v71 > v36 && v73 > v36)
      {
        if ((v22 & 0x80000000) != 0)
        {
          if (!v30)
          {
            char v93 = 0;
            char v90 = 0;
            goto LABEL_103;
          }
          _Q23.f32[0] = *v31;
          _D24 = (int32x2_t)vcvt_f16_f32(vmulq_n_f32(*v30, *v31));
          *(int32x2_t *)((char *)v68 - 10) = _D24;
          __asm { FCVT            H23, S23 }
          v68[-1].i16[3] = _Q23.i16[0];
          *uint64_t v68 = _D24;
        }
        else
        {
          _Q23.i64[0] = 0;
          *(float *)_D24.i32 = v34[v67];
          _Q23 = vmulq_f32(*(float32x4_t *)(v32 + 16 * (int)v22), (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v5, (int64x2_t)_Q23).i64[0], 0), _Q20, (int8x16_t)vdupq_lane_s32(_D24, 0)));
          float16x4_t v82 = vcvt_f16_f32(_Q23);
          *(float16x4_t *)((char *)v68 - 10) = v82;
          __asm { FCVT            H23, S24 }
          v68[-1].i16[3] = _Q23.i16[0];
          *uint64_t v68 = (int32x2_t)v82;
        }
        goto LABEL_101;
      }
      float v75 = sqrtf(v65 * v73);
      float v76 = v64 * sqrtf(v65 * v71);
      float v77 = v64 * v75;
      uint64_t v78 = (int)(float)(v19 * (float)((float)(v20 + (float)(v76 * v66)) - v18));
      uint64_t v79 = (int)(float)(v19 * (float)((float)(v20 + (float)((float)(v64 * v75) * v66)) - v18));
      if (v76 <= 1.0 && v77 <= 1.0)
      {
        uint64_t v83 = 16 * v78;
        uint64_t v78 = (int)v78;
        if (!v33) {
          uint64_t v78 = 0;
        }
        _Q23.f32[0] = v34[v78];
        float32x4_t v84 = *(float32x4_t *)(v32 + v83);
        if (v33)
        {
          float32x4_t v84 = vmulq_n_f32(v84, _Q23.f32[0]);
          _S25 = *(float *)(v33 + 4 * (int)v79);
          float32x4_t v86 = vmulq_n_f32(*(float32x4_t *)(v32 + 16 * (int)v79), _S25);
        }
        else
        {
          _S25 = *v12;
          float32x4_t v86 = *(float32x4_t *)(v32 + 16 * (int)v79);
        }
        _D24 = (int32x2_t)vcvt_f16_f32(v84);
        *(int32x2_t *)((char *)v68 - 10) = _D24;
        __asm { FCVT            H23, S23 }
        v68[-1].i16[3] = _H23;
        *uint64_t v68 = (int32x2_t)vcvt_f16_f32(v86);
        __asm { FCVT            H23, S25 }
LABEL_101:
        char v90 = -1;
        goto LABEL_102;
      }
      if (v76 <= 1.0)
      {
        if ((v78 & 0x80000000) == 0)
        {
          uint64_t v81 = 4 * (int)v78;
          if (!v33) {
            uint64_t v78 = 0;
          }
LABEL_83:
          _S24 = v34[v78];
          float32x4_t v88 = *(float32x4_t *)(v32 + 4 * v81);
          if (!v33) {
            goto LABEL_88;
          }
          goto LABEL_87;
        }
      }
      else if (v76 <= v24)
      {
        uint64_t v78 = v67;
        uint64_t v81 = 4 * (int)v22;
        if ((v22 & 0x80000000) == 0) {
          goto LABEL_83;
        }
      }
      if (!v30)
      {
        char v90 = 0;
        goto LABEL_89;
      }
      _S24 = *v31;
      float32x4_t v88 = *v30;
LABEL_87:
      float32x4_t v88 = vmulq_n_f32(v88, _S24);
LABEL_88:
      *(float16x4_t *)((char *)&v68[-2] + 6) = vcvt_f16_f32(v88);
      __asm { FCVT            H24, S24 }
      v68[-1].i16[3] = _H24;
      char v90 = -1;
LABEL_89:
      if (v77 <= 1.0)
      {
        if ((v79 & 0x80000000) != 0) {
          goto LABEL_97;
        }
        uint64_t v91 = 4 * (int)v79;
        if (!v33) {
          uint64_t v79 = 0;
        }
      }
      else if (v77 > v24 || (uint64_t v79 = v67, v91 = 4 * (int)v22, (v22 & 0x80000000) != 0))
      {
LABEL_97:
        if (!v30)
        {
          char v93 = 0;
          goto LABEL_103;
        }
        _Q23.f32[0] = *v31;
        _D24 = (int32x2_t)vcvt_f16_f32(vmulq_n_f32(*v30, *v31));
        *uint64_t v68 = _D24;
        __asm { FCVT            H23, S23 }
        goto LABEL_102;
      }
      _Q23.i64[0] = 0;
      *(float *)_D24.i32 = v34[v79];
      _Q23 = vmulq_f32(*(float32x4_t *)(v32 + 4 * v91), (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_s64(v4, (int64x2_t)_Q23).i64[0], 0), _Q20, (int8x16_t)vdupq_lane_s32(_D24, 0)));
      *uint64_t v68 = (int32x2_t)vcvt_f16_f32(_Q23);
      __asm { FCVT            H23, S24 }
LABEL_102:
      v68[1].i16[0] = _Q23.i16[0];
      char v93 = -1;
LABEL_103:
      float v16 = v10 + v72;
      char *v27 = v90;
      v27[1] = v93;
      v27 += 2;
      uint64_t v68 = (int32x2_t *)((char *)v68 + 20);
      v69 -= 2;
      if (v69 <= 2) {
        return;
      }
    }
  }
  if (v30 || (v22 & 0x80000000) == 0)
  {
    if ((v22 & 0x80000000) != 0)
    {
      _S1 = *v31;
      float32x4_t v96 = *v30;
    }
    else
    {
      if (v33) {
        uint64_t v94 = v22;
      }
      else {
        uint64_t v94 = 0;
      }
      _S1 = v34[v94];
      float32x4_t v96 = *(float32x4_t *)(v32 + 16 * (int)v22);
      if (!v33) {
        goto LABEL_116;
      }
    }
    float32x4_t v96 = vmulq_n_f32(v96, _S1);
LABEL_116:
    float16x4_t v97 = vcvt_f16_f32(v96);
    __asm { FCVT            H1, S1 }
    int v99 = a4 + 4;
    do
    {
      *(float16x4_t *)uint64_t v28 = v97;
      *(_WORD *)(v28 + 8) = _H1;
      *(float16x4_t *)(v28 + 10) = v97;
      *(_WORD *)(v28 + 18) = _H1;
      *(float16x4_t *)(v28 + 20) = v97;
      *(_WORD *)(v28 + 28) = _H1;
      *(float16x4_t *)(v28 + 30) = v97;
      v99 -= 4;
      *(_WORD *)(v28 + 38) = _H1;
      v28 += 40;
      *(_DWORD *)float v27 = -1;
      v27 += 4;
    }
    while (v99 > 4);
    return;
  }
  if (a4 >= 4) {
    int v37 = 4;
  }
  else {
    int v37 = a4;
  }
  bzero(v27, ((a4 - v37 + 3) & 0xFFFFFFFC) + 4);
}

uint64_t CMYKf16_sample_Wf16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = *(void *)(result + 32);
  uint64_t v6 = *(void *)(result + 40);
  int v7 = *(_DWORD *)(result + 24);
  int v8 = *(_DWORD *)(result + 28);
  uint64_t v9 = *(void *)(result + 176);
  uint64_t v10 = *(void *)(result + 72);
  uint64_t v128 = *(void *)(result + 80);
  uint64_t v126 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  int v125 = *(_DWORD *)(result + 188);
  uint64_t v13 = *(void *)(result + 152) - 10;
  uint64_t v14 = *(void *)(result + 144) - 1;
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  unint64_t v17 = v6 + (v15 * v8) + 2 * (v16 - 1);
  int v123 = *(_DWORD *)(result + 240);
  int v124 = a4;
  unint64_t v18 = v5 + (v15 * v7) + 2 * v16 - 2;
  uint64_t v127 = *(void *)(result + 64);
  LOWORD(v19) = COERCE_UNSIGNED_INT(1.0);
  while (1)
  {
    if (a3 >= v10)
    {
      if (a3 <= v126)
      {
        uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v30 = 0x3FFFFFFF;
        uint64_t v31 = a3;
        uint64_t v23 = v127;
        uint64_t v32 = v128;
      }
      else
      {
        uint64_t v25 = *(void *)(result + 216);
        uint64_t v26 = *(void *)(result + 224) + v126;
        uint64_t v27 = v26 - a3 + (v25 >> 1);
        uint64_t v23 = v127;
        if (v27 < 1) {
          goto LABEL_39;
        }
        if (v27 >= v25) {
          LODWORD(v28) = 0x3FFFFFFF;
        }
        else {
          unint64_t v28 = (unint64_t)(*(void *)(result + 232) * v27) >> 32;
        }
        uint64_t v32 = v128;
        unsigned int v30 = v28 | v125;
        uint64_t v31 = v26 - 0x1000000;
        uint64_t v29 = 448;
      }
    }
    else
    {
      uint64_t v20 = *(void *)(result + 216);
      uint64_t v21 = v10 - *(void *)(result + 224);
      uint64_t v22 = a3 - v21 + (v20 >> 1);
      uint64_t v23 = v127;
      if (v22 < 1) {
        goto LABEL_39;
      }
      if (v22 >= v20) {
        LODWORD(v24) = 0x3FFFFFFF;
      }
      else {
        unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
      }
      uint64_t v32 = v128;
      unsigned int v30 = v24 | v125;
      uint64_t v31 = v21 + 0x1000000;
      uint64_t v29 = 512;
    }
    if (a2 >= v23) {
      break;
    }
    uint64_t v33 = *(void *)(result + 192);
    uint64_t v34 = v23 - *(void *)(result + 200);
    uint64_t v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v125;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v12;
    a3 += v11;
    v13 += 10;
    *(unsigned char *)++uint64_t v14 = 0;
LABEL_40:
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v32)
  {
    uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v36 = a2;
    goto LABEL_26;
  }
  uint64_t v38 = v32;
  uint64_t v39 = *(void *)(result + 192);
  uint64_t v40 = *(void *)(result + 200) + v38;
  uint64_t v41 = v40 - a2 + (v39 >> 1);
  if (v41 < 1) {
    goto LABEL_39;
  }
  if (v41 < v39) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v125;
  }
  uint64_t v36 = v40 - 0x1000000;
  uint64_t v37 = 28;
LABEL_26:
  if (v30 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v42 = v31 >> 32;
  uint64_t v43 = v5 + (int)v42 * (uint64_t)v7;
  uint64_t v44 = v36 >> 31;
  unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v46 = v43 + (v44 & 0xFFFFFFFFFFFFFFFELL);
  float v47 = *(short float **)(result + 32);
  if (v18 >= v46) {
    float v48 = (short float *)(v43 + (v44 & 0xFFFFFFFFFFFFFFFELL));
  }
  else {
    float v48 = (short float *)v18;
  }
  if (v48 < v47) {
    float v48 = *(short float **)(result + 32);
  }
  if (v6)
  {
    unint64_t v49 = v6 + (int)v42 * (uint64_t)v8 + v45;
    float v50 = *(__int16 **)(result + 40);
    if (v17 >= v49) {
      BOOL v51 = (__int16 *)v49;
    }
    else {
      BOOL v51 = (__int16 *)v17;
    }
    if (v51 >= v50) {
      float v50 = v51;
    }
    _H4 = *v50;
  }
  else
  {
    unint64_t v49 = 0;
    _H4 = COERCE_UNSIGNED_INT(1.0);
  }
  _H5 = *v48;
  if (!v9) {
    goto LABEL_119;
  }
  unsigned int v54 = *(_DWORD *)(v9 + (v37 | v29));
LABEL_45:
  int v55 = v54 & 0xF;
  unsigned int v56 = HIBYTE(v54) & 3;
  switch(v55)
  {
    case 1:
      float32x4_t v96 = (short float *)(v46 + SBYTE1(v54) * (uint64_t)v7);
      if (v18 < (unint64_t)v96) {
        float32x4_t v96 = (short float *)v18;
      }
      if (v96 < v47) {
        float32x4_t v96 = v47;
      }
      _H6 = *(_WORD *)v96;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      if (v6)
      {
        int v99 = (__int16 *)(v49 + SBYTE1(v54) * (uint64_t)v8);
        if (v17 < (unint64_t)v99) {
          int v99 = (__int16 *)v17;
        }
        if ((unint64_t)v99 < *(void *)(result + 40)) {
          int v99 = *(__int16 **)(result + 40);
        }
        _H7 = *v99;
      }
      v100 = (char *)&interpolate_waf[2 * v56];
      goto LABEL_117;
    case 2:
      float32x4_t v101 = (short float *)(v46 + 2 * SBYTE2(v54));
      if (v18 < (unint64_t)v101) {
        float32x4_t v101 = (short float *)v18;
      }
      if (v101 < v47) {
        float32x4_t v101 = v47;
      }
      _H6 = *(_WORD *)v101;
      _H7 = COERCE_UNSIGNED_INT(1.0);
      if (v6)
      {
        float32x4_t v102 = (__int16 *)(v49 + 2 * SBYTE2(v54));
        if (v17 < (unint64_t)v102) {
          float32x4_t v102 = (__int16 *)v17;
        }
        if ((unint64_t)v102 < *(void *)(result + 40)) {
          float32x4_t v102 = *(__int16 **)(result + 40);
        }
        _H7 = *v102;
      }
      v100 = (char *)&interpolate_waf[2 * ((v54 >> 28) & 3)];
LABEL_117:
      _H16 = *((_WORD *)v100 + 1);
      __asm
      {
        FCVT            S16, H16
        FCVT            S5, H5
        FCVT            S6, H6
      }
      _S5 = (float)(_S5 - (float)(_S5 * _S16)) + (float)(_S6 * _S16);
      __asm
      {
        FCVT            H5, S5
        FCVT            S4, H4
        FCVT            S6, H7
      }
      _S4 = (float)(_S4 - (float)(_S4 * _S16)) + (float)(_S6 * _S16);
      goto LABEL_118;
    case 3:
      unint64_t v57 = (short float *)(v46 + 2 * SBYTE2(v54));
      if (v18 < (unint64_t)v57) {
        unint64_t v57 = (short float *)v18;
      }
      if (v57 < v47) {
        unint64_t v57 = v47;
      }
      _H6 = *(_WORD *)v57;
      unint64_t v59 = v46 + SBYTE1(v54) * (uint64_t)v7;
      if (v18 >= v59) {
        v60 = (short float *)(v46 + SBYTE1(v54) * (uint64_t)v7);
      }
      else {
        v60 = (short float *)v18;
      }
      if (v60 < v47) {
        v60 = v47;
      }
      _H7 = *(_WORD *)v60;
      v62 = (short float *)(v59 + 2 * SBYTE2(v54));
      if (v18 < (unint64_t)v62) {
        v62 = (short float *)v18;
      }
      if (v62 < v47) {
        v62 = v47;
      }
      _H16 = *(_WORD *)v62;
      _H17 = COERCE_UNSIGNED_INT(1.0);
      _H18 = COERCE_UNSIGNED_INT(1.0);
      _H19 = COERCE_UNSIGNED_INT(1.0);
      if (v6)
      {
        uint64_t v67 = 2 * SBYTE2(v54);
        uint64_t v68 = (__int16 *)(v49 + v67);
        unint64_t v69 = *(void *)(result + 40);
        if (v17 < v49 + v67) {
          uint64_t v68 = (__int16 *)v17;
        }
        if ((unint64_t)v68 < v69) {
          uint64_t v68 = *(__int16 **)(result + 40);
        }
        _H17 = *v68;
        unint64_t v70 = v49 + SBYTE1(v54) * (uint64_t)v8;
        if (v17 >= v70) {
          float v71 = (__int16 *)(v49 + SBYTE1(v54) * (uint64_t)v8);
        }
        else {
          float v71 = (__int16 *)v17;
        }
        if ((unint64_t)v71 < v69) {
          float v71 = *(__int16 **)(result + 40);
        }
        _H18 = *v71;
        float v72 = (__int16 *)(v70 + v67);
        if (v17 < (unint64_t)v72) {
          float v72 = (__int16 *)v17;
        }
        if ((unint64_t)v72 < v69) {
          float v72 = *(__int16 **)(result + 40);
        }
        _H19 = *v72;
      }
      _H20 = interpolate_waf[2 * v56 + 1];
      __asm { FCVT            S20, H20 }
      _H21 = interpolate_waf[2 * ((v54 >> 28) & 3) + 1];
      __asm
      {
        FCVT            S21, H21
        FCVT            S5, H5
        FCVT            S6, H6
      }
      float v82 = (float)(_S5 - (float)(_S5 * _S21)) + (float)(_S6 * _S21);
      __asm
      {
        FCVT            S6, H7
        FCVT            S7, H16
      }
      float v85 = (float)(_S6 - (float)(_S6 * _S21)) + (float)(_S7 * _S21);
      __asm
      {
        FCVT            S4, H4
        FCVT            S7, H17
      }
      float v88 = (float)(_S4 - (float)(_S4 * _S21)) + (float)(_S7 * _S21);
      if (v88 < 1.0) {
        float v89 = v88;
      }
      else {
        float v89 = 1.0;
      }
      if (v88 > 1.0) {
        float v88 = 1.0;
      }
      if (v89 < 0.0) {
        float v88 = 0.0;
      }
      __asm
      {
        FCVT            S7, H18
        FCVT            S16, H19
      }
      float v92 = (float)(_S7 - (float)(_S7 * _S21)) + (float)(_S16 * _S21);
      if (v92 < 1.0) {
        float v93 = v92;
      }
      else {
        float v93 = 1.0;
      }
      if (v92 > 1.0) {
        float v92 = 1.0;
      }
      if (v93 < 0.0) {
        float v92 = 0.0;
      }
      _S5 = (float)(v82 - (float)(v82 * _S20)) + (float)(v85 * _S20);
      __asm { FCVT            H5, S5 }
      _S4 = (float)(v88 - (float)(v88 * _S20)) + (float)(v92 * _S20);
      if (_S4 >= 1.0) {
        _S4 = 1.0;
      }
      if (_S4 <= 0.0) {
        _S4 = 0.0;
      }
LABEL_118:
      __asm { FCVT            H4, S4 }
      break;
  }
LABEL_119:
  *(_WORD *)(v13 + 14) = 0;
  *(_DWORD *)(v13 + 10) = 0;
  *(short float *)(v13 + 16) = v19 - _H5;
  *(_WORD *)(v13 + 18) = _H4;
  *(unsigned char *)++uint64_t v14 = v30 >> 22;
  if (--a4)
  {
    float v110 = (_WORD *)(v13 + 28);
    a3 += v11;
    uint64_t v111 = v126 - a3;
    a2 += v12;
    uint64_t v112 = v128 - a2;
    while (1)
    {
      uint64_t v13 = (uint64_t)(v110 - 9);
      if (((a2 - v127) | v112 | (a3 - v10) | v111) < 0) {
        goto LABEL_40;
      }
      uint64_t v113 = v5 + SHIDWORD(a3) * (uint64_t)v7;
      unint64_t v114 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v46 = v113 + v114;
      float v47 = *(short float **)(result + 32);
      if (v18 >= v113 + v114) {
        uint64_t v115 = (short float *)(v113 + v114);
      }
      else {
        uint64_t v115 = (short float *)v18;
      }
      if (v115 >= v47) {
        uint64_t v116 = v115;
      }
      else {
        uint64_t v116 = *(short float **)(result + 32);
      }
      if (v6)
      {
        unint64_t v49 = v6 + SHIDWORD(a3) * (uint64_t)v8 + v114;
        uint64_t v117 = *(__int16 **)(result + 40);
        if (v17 >= v49) {
          uint64_t v118 = (__int16 *)(v6 + SHIDWORD(a3) * (uint64_t)v8 + v114);
        }
        else {
          uint64_t v118 = (__int16 *)v17;
        }
        if (v118 >= v117) {
          uint64_t v117 = v118;
        }
        _H4 = *v117;
      }
      else
      {
        _H4 = COERCE_UNSIGNED_INT(1.0);
      }
      _H5 = *v116;
      if (v9)
      {
        unsigned int v54 = *(_DWORD *)(v9 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        unsigned int v119 = v54 & 0xF;
        if ((v54 & 0xF) != 0)
        {
          float16x4_t v120 = *(unsigned int **)(result + 264);
          unsigned int v121 = *v120;
          if (a4 != 1 && a4 + 1 != v124 && v123 != 1 && v121 == 3 && v119 < 3) {
            v54 |= 3u;
          }
          unsigned int v30 = -1;
          if (v121 < v119) {
            *float16x4_t v120 = v119;
          }
          goto LABEL_45;
        }
      }
      *(v110 - 2) = 0;
      *((_DWORD *)v110 - 2) = 0;
      *((short float *)v110 - 1) = v19 - _H5;
      *float v110 = _H4;
      *(unsigned char *)++uint64_t v14 = -1;
      v110 += 5;
      v111 -= v11;
      a2 += v12;
      v112 -= v12;
      a3 += v11;
      if (!--a4) {
        return result;
      }
    }
  }
  return result;
}

uint64_t CMYKf16_sample_RGBf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v198 = result;
  int v195 = a4;
  uint64_t v194 = *(void *)(result + 32);
  int v193 = *(_DWORD *)(result + 24);
  uint64_t v192 = *(void *)(result + 176);
  uint64_t v191 = *(void *)(result + 64);
  uint64_t v190 = *(void *)(result + 72);
  uint64_t v189 = *(void *)(result + 112);
  uint64_t v188 = *(void *)(result + 80);
  uint64_t v187 = *(void *)(result + 88);
  uint64_t v186 = *(void *)(result + 120);
  int v185 = *(_DWORD *)(result + 188);
  unsigned int v184 = 0;
  v183 = (_WORD *)(*(void *)(result + 152) - 10);
  uint64_t v182 = *(void *)(result + 144) - 1;
  v181 = (const unsigned __int8 *)(*(void *)(v198 + 32)
                                 + (*(_DWORD *)(v198 + 24) * (*(_DWORD *)(result + 260) - 1))
                                 + 2 * (3 * *(_DWORD *)(result + 256)));
  int v180 = a4 - 1;
  int v179 = *(_DWORD *)(result + 240);
  do
  {
    uint64_t v178 = 0;
    uint64_t v177 = 0;
    unsigned int v176 = 0;
    if (a3 >= v190)
    {
      if (a3 <= v187)
      {
        unsigned int v176 = ((a3 >> 28) & 0xF) << 6;
        unsigned int v184 = 0x3FFFFFFF;
        uint64_t v177 = a3;
      }
      else
      {
        uint64_t v166 = *(void *)(v198 + 224);
        uint64_t v165 = *(void *)(v198 + 216);
        uint64_t v164 = v187 + v166 - (a3 - (v165 >> 1));
        if (v164 > 0)
        {
          if (v164 < v165)
          {
            result = IMAGECOVERAGE_YEDGE(v164, *(void *)(v198 + 232));
            unsigned int v184 = v185 | result;
          }
          else
          {
            unsigned int v184 = v185 | 0x3FFFFFFF;
          }
          unsigned int v176 = 448;
          uint64_t v177 = v187 + v166 - 0x1000000;
          int v168 = 0;
        }
        else
        {
          int v168 = 4;
        }
        if (v168) {
          goto LABEL_102;
        }
      }
    }
    else
    {
      uint64_t v175 = *(void *)(v198 + 224);
      uint64_t v174 = *(void *)(v198 + 216);
      uint64_t v173 = a3 + (v174 >> 1) - (v190 - v175);
      if (v173 > 0)
      {
        if (v173 < v174)
        {
          result = IMAGECOVERAGE_YEDGE(v173, *(void *)(v198 + 232));
          unsigned int v184 = v185 | result;
        }
        else
        {
          unsigned int v184 = v185 | 0x3FFFFFFF;
        }
        unsigned int v176 = 512;
        uint64_t v177 = v190 - v175 + 0x1000000;
        int v167 = 0;
      }
      else
      {
        int v167 = 4;
      }
      if (v167) {
        goto LABEL_102;
      }
    }
    if (a2 >= v191)
    {
      if (a2 <= v188)
      {
        v176 |= 4 * ((a2 >> 28) & 0xF);
        uint64_t v178 = a2;
      }
      else
      {
        uint64_t v160 = *(void *)(v198 + 200);
        uint64_t v159 = *(void *)(v198 + 192);
        uint64_t v158 = v188 + v160 - (a2 - (v159 >> 1));
        if (v158 > 0)
        {
          if (v158 < v159)
          {
            result = IMAGECOVERAGE_XEDGE(v158, *(void *)(v198 + 208), v184);
            unsigned int v184 = v185 | result;
          }
          v176 |= 0x1Cu;
          uint64_t v178 = v188 + v160 - 0x1000000;
          int v170 = 0;
        }
        else
        {
          int v170 = 4;
        }
        if (v170)
        {
LABEL_102:
          --v195;
          a2 += v189;
          a3 += v186;
          v183 += 5;
          *(unsigned char *)++uint64_t v182 = 0;
          int v171 = 0;
          continue;
        }
      }
    }
    else
    {
      uint64_t v163 = *(void *)(v198 + 200);
      uint64_t v162 = *(void *)(v198 + 192);
      uint64_t v161 = a2 + (v162 >> 1) - (v191 - v163);
      if (v161 > 0)
      {
        if (v161 < v162)
        {
          result = IMAGECOVERAGE_XEDGE(v161, *(void *)(v198 + 208), v184);
          unsigned int v184 = v185 | result;
        }
        v176 |= 0x20u;
        uint64_t v178 = v191 - v163 + 0x1000000;
        int v169 = 0;
      }
      else
      {
        int v169 = 4;
      }
      if (v169) {
        goto LABEL_102;
      }
    }
    if (v184 <= 0x3FFFFF) {
      goto LABEL_102;
    }
    v156 = (const unsigned __int8 *)(v194 + v193 * (v177 >> 32) + 6 * (v178 >> 32));
    result = (uint64_t)CLAMP_PTR(v156, *(const unsigned __int8 **)(v198 + 32), v181, 6);
    __int16 v152 = *(_WORD *)result;
    __int16 v153 = *(_WORD *)(result + 2);
    __int16 v154 = *(_WORD *)(result + 4);
    _S0 = 1.0;
    __asm { FCVT            H0, S0 }
    __int16 v155 = LOWORD(_S0);
    if (!v192) {
      goto LABEL_79;
    }
    unsigned int v157 = *(_DWORD *)(v192 + v176);
LABEL_41:
    switch(v157 & 0xF)
    {
      case 3u:
        uint64_t v142 = v193 * (uint64_t)SBYTE1(v157);
        uint64_t v141 = CLAMP_PTR(&v156[6 * SBYTE2(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        __int16 v148 = *(_WORD *)v141;
        __int16 v149 = *((_WORD *)v141 + 1);
        __int16 v150 = *((_WORD *)v141 + 2);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        __int16 v151 = LOWORD(_S0);
        uint64_t v140 = CLAMP_PTR(&v156[v142], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        __int16 v144 = *(_WORD *)v140;
        __int16 v145 = *((_WORD *)v140 + 1);
        __int16 v146 = *((_WORD *)v140 + 2);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        __int16 v147 = LOWORD(_S0);
        result = (uint64_t)CLAMP_PTR(&v156[6 * SBYTE2(v157) + v142], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        __int16 v143 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * (HIBYTE(v157) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v139 = _S0;
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v157 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v138 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = v148;
        __asm { FCVT            S2, H2 }
        float v137 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v144;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        float v136 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v149;
        __asm { FCVT            S2, H2 }
        float v133 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v145;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        float v132 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v150;
        __asm { FCVT            S2, H2 }
        float v135 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v146;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        float v134 = (float)(_S0 - (float)(_S0 * v138)) + (float)(_S2 * v138);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        _H1 = v151;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            S0, H0 }
          _H1 = v151;
          __asm { FCVT            S1, H1 }
          double v30 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
        }
        else
        {
          double v30 = 1.0;
        }
        if (v30 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            S0, H0 }
          _H1 = v151;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
          {
            _H0 = v155;
            __asm { FCVT            S0, H0 }
            _H1 = v151;
            __asm { FCVT            S1, H1 }
            double v35 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
          }
          else
          {
            double v35 = 1.0;
          }
        }
        else
        {
          double v35 = 0.0;
        }
        _S0 = v35;
        float v131 = _S0;
        LOWORD(_S0) = v147;
        __asm { FCVT            S0, H0 }
        _H1 = v143;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
        {
          _H0 = v147;
          __asm { FCVT            S0, H0 }
          _H1 = v143;
          __asm { FCVT            S1, H1 }
          double v48 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
        }
        else
        {
          double v48 = 1.0;
        }
        if (v48 >= 0.0)
        {
          _H0 = v147;
          __asm { FCVT            S0, H0 }
          _H1 = v143;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138)) <= 1.0)
          {
            _H0 = v147;
            __asm { FCVT            S0, H0 }
            _H1 = v143;
            __asm { FCVT            S1, H1 }
            double v53 = (float)((float)(_S0 - (float)(_S0 * v138)) + (float)(_S1 * v138));
          }
          else
          {
            double v53 = 1.0;
          }
        }
        else
        {
          double v53 = 0.0;
        }
        float v62 = v53;
        float v130 = v62;
        _S0 = (float)(v137 - (float)(v137 * v139)) + (float)(v136 * v139);
        __asm { FCVT            H0, S0 }
        __int16 v152 = LOWORD(_S0);
        _S0 = (float)(v133 - (float)(v133 * v139)) + (float)(v132 * v139);
        __asm { FCVT            H0, S0 }
        __int16 v153 = LOWORD(_S0);
        _S0 = (float)(v135 - (float)(v135 * v139)) + (float)(v134 * v139);
        __asm { FCVT            H0, S0 }
        __int16 v154 = LOWORD(_S0);
        if ((float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139)) <= 1.0) {
          double v66 = (float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139));
        }
        else {
          double v66 = 1.0;
        }
        if (v66 >= 0.0)
        {
          if ((float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139)) <= 1.0) {
            _D0 = (float)((float)(v131 + (float)((float)-v131 * v139)) + (float)(v130 * v139));
          }
          else {
            _D0 = 1.0;
          }
        }
        else
        {
          _D0 = 0.0;
        }
        __asm { FCVT            H0, D0 }
        __int16 v155 = _H0;
        break;
      case 2u:
        result = (uint64_t)CLAMP_PTR(&v156[6 * SBYTE2(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        __int16 v129 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v157 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v128 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        __int16 v152 = LOWORD(_S0);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        __int16 v153 = LOWORD(_S0);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        __int16 v154 = LOWORD(_S0);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v129;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v128)) + (float)(_S2 * v128);
        __asm { FCVT            H0, S0 }
        __int16 v155 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        break;
      case 1u:
        result = (uint64_t)CLAMP_PTR(&v156[v193 * (uint64_t)SBYTE1(v157)], *(const unsigned __int8 **)(v198 + 32), v181, 6);
        _S0 = 1.0;
        __asm { FCVT            H0, S0 }
        __int16 v127 = LOWORD(_S0);
        LOWORD(_S0) = interpolate_rgbaf16[4 * (HIBYTE(v157) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v126 = _S0;
        LOWORD(_S0) = v152;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        __int16 v152 = LOWORD(_S0);
        LOWORD(_S0) = v153;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        __int16 v153 = LOWORD(_S0);
        LOWORD(_S0) = v154;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        __int16 v154 = LOWORD(_S0);
        LOWORD(_S0) = v155;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v127;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v126)) + (float)(_S2 * v126);
        __asm { FCVT            H0, S0 }
        __int16 v155 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v155;
          __asm { FCVT            D0, H0 }
        }
        break;
    }
    while (1)
    {
LABEL_79:
      --v195;
      a3 += v186;
      a2 += v189;
      v183 += 5;
      _H0 = v155;
      __asm { FCVT            S0, H0 }
      float v125 = _S0;
      LOWORD(_S0) = v152;
      __asm { FCVT            S0, H0 }
      float v123 = _S0;
      LOWORD(_S0) = v153;
      __asm { FCVT            S0, H0 }
      float v122 = _S0;
      LOWORD(_S0) = v154;
      __asm { FCVT            S0, H0 }
      float v121 = _S0;
      if (v123 <= v122) {
        float v124 = v122;
      }
      else {
        float v124 = v123;
      }
      if (_S0 > v124) {
        float v124 = _S0;
      }
      _S0 = v124 - v123;
      __asm { FCVT            H0, S0 }
      _WORD *v183 = LOWORD(_S0);
      _S0 = v124 - v122;
      __asm { FCVT            H0, S0 }
      v183[1] = LOWORD(_S0);
      _S0 = v124 - v121;
      __asm { FCVT            H0, S0 }
      v183[2] = LOWORD(_S0);
      _S0 = v125 - v124;
      __asm { FCVT            H0, S0 }
      v183[3] = LOWORD(_S0);
      _S0 = v125;
      __asm { FCVT            H0, S0 }
      v183[4] = LOWORD(_S0);
      *(unsigned char *)++uint64_t v182 = v184 >> 22;
      if (!v195)
      {
        int v171 = 2;
        goto LABEL_103;
      }
      if (((v187 - a3) | (a3 - v190) | (v188 - a2) | (a2 - v191)) < 0) {
        break;
      }
      unsigned int v184 = -1;
      v156 = (const unsigned __int8 *)(v194 + v193 * (a3 >> 32) + 6 * (a2 >> 32));
      result = (uint64_t)CLAMP_PTR(v156, *(const unsigned __int8 **)(v198 + 32), v181, 6);
      __int16 v152 = *(_WORD *)result;
      __int16 v153 = *(_WORD *)(result + 2);
      __int16 v154 = *(_WORD *)(result + 4);
      _S0 = 1.0;
      __asm { FCVT            H0, S0 }
      __int16 v155 = LOWORD(_S0);
      if (v192)
      {
        unsigned int v157 = *(_DWORD *)(v192 + ((((a3 >> 28) & 0xF) << 6) | (4 * ((a2 >> 28) & 0xF))));
        unsigned int v120 = v157 & 0xF;
        if ((v157 & 0xF) != 0)
        {
          if (v195 != v180 && v195 != 1 && v179 != 1 && **(_DWORD **)(v198 + 264) == 3 && v120 < 3) {
            v157 |= 3u;
          }
          if (**(_DWORD **)(v198 + 264) < v120) {
            **(_DWORD **)(v198 + 264) = v120;
          }
          int v172 = 7;
        }
        else
        {
          int v172 = 0;
        }
        if (v172) {
          goto LABEL_41;
        }
      }
    }
    int v171 = 3;
LABEL_103:
    ;
  }
  while (v171 != 2 && v195);
  return result;
}

unint64_t IMAGECOVERAGE_YEDGE(uint64_t a1, uint64_t a2)
{
  return (unint64_t)(a2 * a1) >> 32;
}

uint64_t IMAGECOVERAGE_XEDGE(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (a3 >> 15) * (((unint64_t)(a2 * a1) >> 32) >> 15);
}

const unsigned __int8 *CLAMP_PTR(const unsigned __int8 *a1, const unsigned __int8 *a2, const unsigned __int8 *a3, uint64_t a4)
{
  int64x2_t v4 = &a3[-a4];
  if (&a3[-a4] >= a1) {
    int64x2_t v4 = a1;
  }
  if (v4 >= a2) {
    return v4;
  }
  else {
    return a2;
  }
}

uint64_t CMYKf16_sample_RGBAf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v259 = result;
  int v256 = a4;
  uint64_t v255 = *(void *)(result + 32);
  int v254 = *(_DWORD *)(result + 24);
  uint64_t v253 = *(void *)(result + 176);
  uint64_t v252 = *(void *)(result + 64);
  uint64_t v251 = *(void *)(result + 72);
  uint64_t v250 = *(void *)(result + 112);
  uint64_t v249 = *(void *)(result + 80);
  uint64_t v248 = *(void *)(result + 88);
  uint64_t v247 = *(void *)(result + 120);
  int v246 = *(_DWORD *)(result + 188);
  unsigned int v245 = 0;
  v244 = (_WORD *)(*(void *)(result + 152) - 10);
  uint64_t v243 = *(void *)(result + 144) - 1;
  float v4 = 1.0;
  if (*(void *)(result + 40)) {
    float v4 = 0.0;
  }
  float v242 = v4;
  float v241 = (const unsigned __int8 *)(*(void *)(result + 32)
                                 + (*(_DWORD *)(result + 24) * (*(_DWORD *)(result + 260) - 1))
                                 + 2 * (4 * *(_DWORD *)(result + 256)));
  int v240 = a4 - 1;
  int v239 = *(_DWORD *)(result + 240);
  do
  {
    uint64_t v238 = 0;
    uint64_t v237 = 0;
    unsigned int v236 = 0;
    if (a3 >= v251)
    {
      if (a3 <= v248)
      {
        unsigned int v236 = ((a3 >> 28) & 0xF) << 6;
        unsigned int v245 = 0x3FFFFFFF;
        uint64_t v237 = a3;
      }
      else
      {
        uint64_t v226 = *(void *)(v259 + 224);
        uint64_t v225 = *(void *)(v259 + 216);
        uint64_t v224 = v248 + v226 - (a3 - (v225 >> 1));
        if (v224 > 0)
        {
          if (v224 < v225)
          {
            result = IMAGECOVERAGE_YEDGE(v224, *(void *)(v259 + 232));
            unsigned int v245 = v246 | result;
          }
          else
          {
            unsigned int v245 = v246 | 0x3FFFFFFF;
          }
          unsigned int v236 = 448;
          uint64_t v237 = v248 + v226 - 0x1000000;
          int v228 = 0;
        }
        else
        {
          int v228 = 4;
        }
        if (v228) {
          goto LABEL_174;
        }
      }
    }
    else
    {
      uint64_t v235 = *(void *)(v259 + 224);
      uint64_t v234 = *(void *)(v259 + 216);
      uint64_t v233 = a3 + (v234 >> 1) - (v251 - v235);
      if (v233 > 0)
      {
        if (v233 < v234)
        {
          result = IMAGECOVERAGE_YEDGE(v233, *(void *)(v259 + 232));
          unsigned int v245 = v246 | result;
        }
        else
        {
          unsigned int v245 = v246 | 0x3FFFFFFF;
        }
        unsigned int v236 = 512;
        uint64_t v237 = v251 - v235 + 0x1000000;
        int v227 = 0;
      }
      else
      {
        int v227 = 4;
      }
      if (v227) {
        goto LABEL_174;
      }
    }
    if (a2 >= v252)
    {
      if (a2 <= v249)
      {
        v236 |= 4 * ((a2 >> 28) & 0xF);
        uint64_t v238 = a2;
      }
      else
      {
        uint64_t v220 = *(void *)(v259 + 200);
        uint64_t v219 = *(void *)(v259 + 192);
        uint64_t v218 = v249 + v220 - (a2 - (v219 >> 1));
        if (v218 > 0)
        {
          if (v218 < v219)
          {
            result = IMAGECOVERAGE_XEDGE(v218, *(void *)(v259 + 208), v245);
            unsigned int v245 = v246 | result;
          }
          v236 |= 0x1Cu;
          uint64_t v238 = v249 + v220 - 0x1000000;
          int v230 = 0;
        }
        else
        {
          int v230 = 4;
        }
        if (v230)
        {
LABEL_174:
          --v256;
          a2 += v250;
          a3 += v247;
          v244 += 5;
          *(unsigned char *)++uint64_t v243 = 0;
          int v231 = 0;
          continue;
        }
      }
    }
    else
    {
      uint64_t v223 = *(void *)(v259 + 200);
      uint64_t v222 = *(void *)(v259 + 192);
      uint64_t v221 = a2 + (v222 >> 1) - (v252 - v223);
      if (v221 > 0)
      {
        if (v221 < v222)
        {
          result = IMAGECOVERAGE_XEDGE(v221, *(void *)(v259 + 208), v245);
          unsigned int v245 = v246 | result;
        }
        v236 |= 0x20u;
        uint64_t v238 = v252 - v223 + 0x1000000;
        int v229 = 0;
      }
      else
      {
        int v229 = 4;
      }
      if (v229) {
        goto LABEL_174;
      }
    }
    if (v245 <= 0x3FFFFF) {
      goto LABEL_174;
    }
    float v216 = (const unsigned __int8 *)(v255 + v254 * (v237 >> 32) + 8 * (v238 >> 32));
    result = (uint64_t)CLAMP_PTR(v216, *(const unsigned __int8 **)(v259 + 32), v241, 8);
    __int16 v212 = *(_WORD *)result;
    __int16 v213 = *(_WORD *)(result + 2);
    __int16 v214 = *(_WORD *)(result + 4);
    if (v242 == 0.0)
    {
      _H0 = *(_WORD *)(result + 6);
      __asm { FCVT            D0, H0 }
      if (_D0 <= 1.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
      }
      else
      {
        _D0 = 1.0;
      }
      if (_D0 >= 0.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
      }
      else
      {
        _D0 = 0.0;
      }
    }
    else
    {
      _D0 = v242;
    }
    __asm { FCVT            H0, D0 }
    __int16 v215 = _H0;
    if (!v253) {
      goto LABEL_141;
    }
    unsigned int v217 = *(_DWORD *)(v253 + v236);
LABEL_53:
    switch(v217 & 0xF)
    {
      case 3u:
        uint64_t v202 = v254 * (uint64_t)SBYTE1(v217);
        v201 = CLAMP_PTR(&v216[8 * SBYTE2(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        __int16 v208 = *(_WORD *)v201;
        __int16 v209 = *((_WORD *)v201 + 1);
        __int16 v210 = *((_WORD *)v201 + 2);
        if (v242 == 0.0)
        {
          _H0 = *((_WORD *)v201 + 3);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *((_WORD *)v201 + 3);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *((_WORD *)v201 + 3);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *((_WORD *)v201 + 3);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        __int16 v211 = _H0;
        v200 = CLAMP_PTR(&v216[v202], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        __int16 v204 = *(_WORD *)v200;
        __int16 v205 = *((_WORD *)v200 + 1);
        __int16 v206 = *((_WORD *)v200 + 2);
        if (v242 == 0.0)
        {
          _H0 = *((_WORD *)v200 + 3);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *((_WORD *)v200 + 3);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *((_WORD *)v200 + 3);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *((_WORD *)v200 + 3);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        __int16 v207 = _H0;
        result = (uint64_t)CLAMP_PTR(&v216[8 * SBYTE2(v217) + v202], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        __int16 v203 = _H0;
        _H0 = interpolate_rgbaf16[4 * (HIBYTE(v217) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v199 = _S0;
        LOWORD(_S0) = interpolate_rgbaf16[4 * ((v217 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v198 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = v208;
        __asm { FCVT            S2, H2 }
        float v197 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v204;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        float v196 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v209;
        __asm { FCVT            S2, H2 }
        float v193 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v205;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        float v192 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v210;
        __asm { FCVT            S2, H2 }
        float v195 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v206;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        float v194 = (float)(_S0 - (float)(_S0 * v198)) + (float)(_S2 * v198);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        _H1 = v211;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            S0, H0 }
          _H1 = v211;
          __asm { FCVT            S1, H1 }
          double v64 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
        }
        else
        {
          double v64 = 1.0;
        }
        if (v64 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            S0, H0 }
          _H1 = v211;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
          {
            _H0 = v215;
            __asm { FCVT            S0, H0 }
            _H1 = v211;
            __asm { FCVT            S1, H1 }
            double v69 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
          }
          else
          {
            double v69 = 1.0;
          }
        }
        else
        {
          double v69 = 0.0;
        }
        _S0 = v69;
        float v191 = _S0;
        LOWORD(_S0) = v207;
        __asm { FCVT            S0, H0 }
        _H1 = v203;
        __asm { FCVT            S1, H1 }
        if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
        {
          _H0 = v207;
          __asm { FCVT            S0, H0 }
          _H1 = v203;
          __asm { FCVT            S1, H1 }
          double v82 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
        }
        else
        {
          double v82 = 1.0;
        }
        if (v82 >= 0.0)
        {
          _H0 = v207;
          __asm { FCVT            S0, H0 }
          _H1 = v203;
          __asm { FCVT            S1, H1 }
          if ((float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198)) <= 1.0)
          {
            _H0 = v207;
            __asm { FCVT            S0, H0 }
            _H1 = v203;
            __asm { FCVT            S1, H1 }
            double v87 = (float)((float)(_S0 - (float)(_S0 * v198)) + (float)(_S1 * v198));
          }
          else
          {
            double v87 = 1.0;
          }
        }
        else
        {
          double v87 = 0.0;
        }
        float v96 = v87;
        float v190 = v96;
        _S0 = (float)(v197 - (float)(v197 * v199)) + (float)(v196 * v199);
        __asm { FCVT            H0, S0 }
        __int16 v212 = LOWORD(_S0);
        _S0 = (float)(v193 - (float)(v193 * v199)) + (float)(v192 * v199);
        __asm { FCVT            H0, S0 }
        __int16 v213 = LOWORD(_S0);
        _S0 = (float)(v195 - (float)(v195 * v199)) + (float)(v194 * v199);
        __asm { FCVT            H0, S0 }
        __int16 v214 = LOWORD(_S0);
        if ((float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199)) <= 1.0) {
          double v100 = (float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199));
        }
        else {
          double v100 = 1.0;
        }
        if (v100 >= 0.0)
        {
          if ((float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199)) <= 1.0) {
            _D0 = (float)((float)(v191 + (float)((float)-v191 * v199)) + (float)(v190 * v199));
          }
          else {
            _D0 = 1.0;
          }
        }
        else
        {
          _D0 = 0.0;
        }
        __asm { FCVT            H0, D0 }
        __int16 v215 = _H0;
        break;
      case 2u:
        result = (uint64_t)CLAMP_PTR(&v216[8 * SBYTE2(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        __int16 v189 = _H0;
        _H0 = interpolate_rgbaf16[4 * ((v217 >> 28) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v188 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        __int16 v212 = LOWORD(_S0);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        __int16 v213 = LOWORD(_S0);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        __int16 v214 = LOWORD(_S0);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v189;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v188)) + (float)(_S2 * v188);
        __asm { FCVT            H0, S0 }
        __int16 v215 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        break;
      case 1u:
        result = (uint64_t)CLAMP_PTR(&v216[v254 * (uint64_t)SBYTE1(v217)], *(const unsigned __int8 **)(v259 + 32), v241, 8);
        if (v242 == 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
          if (_D0 >= 0.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
            if (_D0 <= 1.0)
            {
              _H0 = *(_WORD *)(result + 6);
              __asm { FCVT            D0, H0 }
            }
            else
            {
              _D0 = 1.0;
            }
          }
          else
          {
            _D0 = 0.0;
          }
        }
        else
        {
          _D0 = v242;
        }
        __asm { FCVT            H0, D0 }
        __int16 v187 = _H0;
        _H0 = interpolate_rgbaf16[4 * (HIBYTE(v217) & 3) + 3];
        __asm { FCVT            S0, H0 }
        float v186 = _S0;
        LOWORD(_S0) = v212;
        __asm { FCVT            S0, H0 }
        _H2 = *(_WORD *)result;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        __int16 v212 = LOWORD(_S0);
        LOWORD(_S0) = v213;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 2);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        __int16 v213 = LOWORD(_S0);
        LOWORD(_S0) = v214;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = *(_WORD *)(result + 4);
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        __int16 v214 = LOWORD(_S0);
        LOWORD(_S0) = v215;
        __asm { FCVT            S0, H0 }
        LOWORD(_S2) = v187;
        __asm { FCVT            S2, H2 }
        _S0 = (float)(_S0 - (float)(_S0 * v186)) + (float)(_S2 * v186);
        __asm { FCVT            H0, S0 }
        __int16 v215 = LOWORD(_S0);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = v215;
          __asm { FCVT            D0, H0 }
        }
        break;
    }
    while (1)
    {
LABEL_141:
      --v256;
      a3 += v247;
      a2 += v250;
      v244 += 5;
      _H0 = v215;
      __asm { FCVT            S0, H0 }
      float v185 = _S0;
      LOWORD(_S0) = v212;
      __asm { FCVT            S0, H0 }
      float v183 = _S0;
      LOWORD(_S0) = v213;
      __asm { FCVT            S0, H0 }
      float v182 = _S0;
      LOWORD(_S0) = v214;
      __asm { FCVT            S0, H0 }
      float v181 = _S0;
      if (v183 <= v182) {
        float v184 = v182;
      }
      else {
        float v184 = v183;
      }
      if (_S0 > v184) {
        float v184 = _S0;
      }
      _S0 = v184 - v183;
      __asm { FCVT            H0, S0 }
      _WORD *v244 = LOWORD(_S0);
      _S0 = v184 - v182;
      __asm { FCVT            H0, S0 }
      v244[1] = LOWORD(_S0);
      _S0 = v184 - v181;
      __asm { FCVT            H0, S0 }
      v244[2] = LOWORD(_S0);
      _S0 = v185 - v184;
      __asm { FCVT            H0, S0 }
      v244[3] = LOWORD(_S0);
      _S0 = v185;
      __asm { FCVT            H0, S0 }
      v244[4] = LOWORD(_S0);
      *(unsigned char *)++uint64_t v243 = v245 >> 22;
      if (!v256)
      {
        int v231 = 2;
        goto LABEL_175;
      }
      if (((v248 - a3) | (a3 - v251) | (v249 - a2) | (a2 - v252)) < 0) {
        break;
      }
      unsigned int v245 = -1;
      float v216 = (const unsigned __int8 *)(v255 + v254 * (a3 >> 32) + 8 * (a2 >> 32));
      result = (uint64_t)CLAMP_PTR(v216, *(const unsigned __int8 **)(v259 + 32), v241, 8);
      __int16 v212 = *(_WORD *)result;
      __int16 v213 = *(_WORD *)(result + 2);
      __int16 v214 = *(_WORD *)(result + 4);
      if (v242 == 0.0)
      {
        _H0 = *(_WORD *)(result + 6);
        __asm { FCVT            D0, H0 }
        if (_D0 <= 1.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
        }
        else
        {
          _D0 = 1.0;
        }
        if (_D0 >= 0.0)
        {
          _H0 = *(_WORD *)(result + 6);
          __asm { FCVT            D0, H0 }
          if (_D0 <= 1.0)
          {
            _H0 = *(_WORD *)(result + 6);
            __asm { FCVT            D0, H0 }
          }
          else
          {
            _D0 = 1.0;
          }
        }
        else
        {
          _D0 = 0.0;
        }
      }
      else
      {
        _D0 = v242;
      }
      __asm { FCVT            H0, D0 }
      __int16 v215 = _H0;
      if (v253)
      {
        unsigned int v217 = *(_DWORD *)(v253 + ((((a3 >> 28) & 0xF) << 6) | (4 * ((a2 >> 28) & 0xF))));
        unsigned int v180 = v217 & 0xF;
        if ((v217 & 0xF) != 0)
        {
          if (v256 != v240 && v256 != 1 && v239 != 1 && **(_DWORD **)(v259 + 264) == 3 && v180 < 3) {
            v217 |= 3u;
          }
          if (**(_DWORD **)(v259 + 264) < v180) {
            **(_DWORD **)(v259 + 264) = v180;
          }
          int v232 = 7;
        }
        else
        {
          int v232 = 0;
        }
        if (v232) {
          goto LABEL_53;
        }
      }
    }
    int v231 = 3;
LABEL_175:
    ;
  }
  while (v231 != 2 && v256);
  return result;
}

void *CGPDFTextExtractorCreateWithPage(uint64_t a1, char a2)
{
  float v4 = CGPDFTextExtractorCreate(0);
  if (v4)
  {
    uint64_t v5 = CGPDFContentStreamCreate(a1);
    v4[5] = v5;
    if (v5)
    {
      if (CGPDFTextStringGetTypeID_onceToken != -1) {
        dispatch_once(&CGPDFTextStringGetTypeID_onceToken, &__block_literal_global_11390);
      }
      uint64_t cftype = pdf_create_cftype();
      if (cftype)
      {
        *(unsigned char *)(cftype + 16) = a2;
        *(_OWORD *)(cftype + 24) = 0u;
        *(_OWORD *)(cftype + 40) = 0u;
        v4[6] = cftype;
        return v4;
      }
      v4[6] = 0;
    }
    CGPDFTextExtractorRelease(v4);
    return 0;
  }
  return v4;
}

void *CGPDFTextExtractorCreate(long long ***a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (a1) {
    Copy = CGPDFRStateCreateCopy(*a1);
  }
  else {
    Copy = CGPDFRStateCreate();
  }
  *uint64_t v2 = Copy;
  if (!Copy) {
    goto LABEL_11;
  }
  v2[1] = *Copy;
  CGPDFOperatorTableRef v4 = CGPDFOperatorTableCreate();
  if (!v4)
  {
    v2[3] = 0;
LABEL_11:
    CGPDFTextExtractorRelease(v2);
    return 0;
  }
  uint64_t v5 = v4;
  for (uint64_t i = 0; i != 44; i += 2)
    CGPDFOperatorTableSetCallback(v5, (&operators_8390)[i], (CGPDFOperatorCallback)(&operators_8390)[i + 1]);
  v2[3] = v5;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  v2[4] = Mutable;
  if (!Mutable) {
    goto LABEL_11;
  }
  return v2;
}

void CGPDFTextExtractorRelease(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[4];
    if (v2) {
      CFRelease(v2);
    }
    CGPDFRStateRelease((void *)*a1);
    v3 = (const void *)a1[3];
    if (v3) {
      CFRelease(v3);
    }
    CGPDFOperatorTableRef v4 = (const void *)a1[6];
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = (const void *)a1[5];
    if (v5) {
      CFRelease(v5);
    }
    free(a1);
  }
}

void op_gs_8435(uint64_t *a1, uint64_t a2)
{
  value = 0;
  CGPDFReal v12 = 0.0;
  CGPDFDictionaryRef v9 = 0;
  CGPDFArrayRef array = 0;
  if (CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&value))
  {
    ExtGState = (CGPDFDictionary *)CGPDFContentStreamGetExtGState(a1[7], value);
    if (ExtGState)
    {
      if (CGPDFDictionaryGetArray(ExtGState, "Font", &array)
        && CGPDFArrayGetDictionary(array, 0, &v9)
        && CGPDFArrayGetNumber(array, 1uLL, &v12))
      {
        uint64_t v5 = (const void *)CGPDFFontCreate(v9);
        if (v5)
        {
          CGPDFGStateSetFont(*(void *)(a2 + 8), v5);
          uint64_t v6 = *(void *)(a2 + 8);
          if (v6)
          {
            CGPDFReal v7 = v12;
            *(CGPDFReal *)(v6 + 128) = v12;
            uint64_t v8 = *(void *)(v6 + 272);
            if (v8) {
              *(CGPDFReal *)(v8 + 56) = v7;
            }
          }
        }
      }
    }
  }
}

void op_Do_8437(CGPDFScanner *a1, uint64_t a2)
{
  value = 0;
  if (CGPDFScannerPopName(a1, (const char **)&value))
  {
    uint64_t v4 = *((void *)a1 + 7);
    if (v4)
    {
      uint64_t v5 = value;
      while (1)
      {
        uint64_t v6 = CGPDFResourcesCopyXObject(*(void *)(v4 + 32), v5);
        if (v6) {
          break;
        }
        uint64_t v4 = *(void *)(v4 + 40);
        if (!v4) {
          return;
        }
      }
      int v7 = v6[4];
      if (v7)
      {
        if (v7 == 2)
        {
          uint64_t v12 = CGPDFXObjectGetValue((uint64_t)v6);
          uint64_t v13 = v12;
          if (v12)
          {
            uint64_t v14 = *(CGPDFStream **)v12;
            int v15 = *(CGPDFDictionary **)(v12 + 88);
          }
          else
          {
            uint64_t v14 = 0;
            int v15 = 0;
          }
          Child = CGPDFTextExtractorCreateChild(a2, v14, v15);
          unint64_t v17 = Child;
          uint64_t v21 = (const CGAffineTransform *)(v13 + 40);
          if (!v13) {
            uint64_t v21 = &CGAffineTransformIdentity;
          }
          long long v22 = *(_OWORD *)&v21->c;
          v23[0] = *(_OWORD *)&v21->a;
          v23[1] = v22;
          v23[2] = *(_OWORD *)&v21->tx;
          uint64_t v20 = v23;
        }
        else
        {
          if (v7 != 1)
          {
            pdf_error("unrecognized or unsupported XObject subtype.");
            return;
          }
          uint64_t v8 = CGPDFXObjectGetValue((uint64_t)v6);
          uint64_t v9 = v8;
          if (v8)
          {
            uint64_t v10 = *(CGPDFStream **)(v8 + 16);
            uint64_t v11 = *(CGPDFDictionary **)(v8 + 104);
          }
          else
          {
            uint64_t v10 = 0;
            uint64_t v11 = 0;
          }
          Child = CGPDFTextExtractorCreateChild(a2, v10, v11);
          unint64_t v17 = Child;
          unint64_t v18 = (const CGAffineTransform *)(v9 + 56);
          if (!v9) {
            unint64_t v18 = &CGAffineTransformIdentity;
          }
          long long v19 = *(_OWORD *)&v18->c;
          v24[0] = *(_OWORD *)&v18->a;
          v24[1] = v19;
          v24[2] = *(_OWORD *)&v18->tx;
          uint64_t v20 = v24;
        }
        draw_child_xobject(Child, v20);
        CGPDFTextExtractorRelease(v17);
      }
    }
  }
}

void *CGPDFTextExtractorCreateChild(uint64_t a1, CGPDFStream *a2, CGPDFDictionary *a3)
{
  uint64_t v6 = CGPDFTextExtractorCreate((long long ***)a1);
  if (v6)
  {
    CGPDFContentStreamRef v7 = CGPDFContentStreamCreateWithStream(a2, a3, *(CGPDFContentStreamRef *)(a1 + 40));
    v6[5] = v7;
    if (v7)
    {
      uint64_t v8 = *(const void **)(a1 + 48);
      if (v8)
      {
        CFRetain(v8);
        v6[6] = v8;
        return v6;
      }
      v6[6] = 0;
    }
    CGPDFTextExtractorRelease(v6);
    return 0;
  }
  return v6;
}

void draw_child_xobject(uint64_t *a1, _OWORD *a2)
{
  if (a1)
  {
    CGPDFRStateGSave(*a1);
    if (*a1) {
      uint64_t v4 = *(double **)*a1;
    }
    else {
      uint64_t v4 = 0;
    }
    long long v5 = a2[1];
    v8[0] = *a2;
    v8[1] = v5;
    v8[2] = a2[2];
    CGPDFGStateConcatCTM(v4, (double *)v8);
    uint64_t v6 = CGPDFTextExtractorCopyTextString((CGPDFContentStreamRef *)a1);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *a1;
    CGPDFRStateGRestore(v7);
  }
}

CGPDFContentStreamRef *CGPDFTextExtractorCopyTextString(CGPDFContentStreamRef *info)
{
  v1 = info;
  if (info)
  {
    if (!*((unsigned char *)info + 56))
    {
      uint64_t v2 = CGPDFScannerCreate(info[5], info[3], info);
      CGPDFScannerScan(v2);
      if (v2) {
        CFRelease(v2);
      }
      *((unsigned char *)v1 + 56) = 1;
    }
    v1 = (CGPDFContentStreamRef *)v1[6];
    if (v1) {
      CFRetain(v1);
    }
  }
  return v1;
}

void op_TJ_8441(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFArrayRef value = 0;
  if (CGPDFScannerPopArray(a1, &value))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
      v4.n128_f64[0] = CGPDFTextObjectAppendStrings((uint64_t)TextObject, value);
      CGPDFTextStringAppendTextLayout(*(void **)(a2 + 48), *(void *)a2, *((void **)TextObject + 21), v4);
    }
    else
    {
    }
  }
}

void op_doublequote_8443(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v14 = 0.0;
  CGPDFStringRef value = 0;
  CGPDFReal v13 = 0.0;
  if (CGPDFScannerPopString(a1, &value) && CGPDFScannerPopNumber(a1, &v14) && CGPDFScannerPopNumber(a1, &v13))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      uint64_t v4 = *(void *)(a2 + 8);
      if (v4)
      {
        CGPDFReal v5 = v14;
        *(CGPDFReal *)(v4 + 72) = v14;
        uint64_t v6 = *(CGPDFReal **)(v4 + 272);
        if (v6)
        {
          *uint64_t v6 = v5;
          CGPDFReal v7 = v13;
          *(CGPDFReal *)(v4 + 80) = v13;
          v6[1] = v7;
        }
        else
        {
          *(CGPDFReal *)(v4 + 80) = v13;
        }
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      uint64_t v9 = (uint64_t)TextObject;
      uint64_t v10 = *(void *)(a2 + 8);
      if (v10) {
        double v11 = *(double *)(v10 + 96);
      }
      else {
        double v11 = 0.0;
      }
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v11);
      v12.n128_f64[0] = CGPDFTextObjectAppendString(v9, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(void **)(a2 + 48), *(void *)a2, *(void **)(v9 + 168), v12);
    }
    else
    {
    }
  }
}

void op_singlequote_8445(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
      uint64_t v4 = (uint64_t)TextObject;
      uint64_t v5 = *(void *)(a2 + 8);
      if (v5) {
        double v6 = *(double *)(v5 + 96);
      }
      else {
        double v6 = 0.0;
      }
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v6);
      v7.n128_f64[0] = CGPDFTextObjectAppendString(v4, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(void **)(a2 + 48), *(void *)a2, *(void **)(v4 + 168), v7);
    }
    else
    {
    }
  }
}

void op_Tj_8447(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFStringRef value = 0;
  if (CGPDFScannerPopString(a1, &value))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
      v4.n128_f64[0] = CGPDFTextObjectAppendString((uint64_t)TextObject, (uint64_t)value);
      CGPDFTextStringAppendTextLayout(*(void **)(a2 + 48), *(void *)a2, *((void **)TextObject + 21), v4);
    }
    else
    {
    }
  }
}

double op_Tstar_8449(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16))
  {
    TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4) {
      double v5 = *(double *)(v4 + 96);
    }
    else {
      double v5 = 0.0;
    }
    *(void *)&double result = CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, 0.0, -v5).n128_u64[0];
  }
  else
  {
  }
  return result;
}

void op_Tm_8451(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v15 = 0.0;
  CGPDFReal v16 = 0.0;
  CGPDFReal v13 = 0.0;
  CGPDFReal v14 = 0.0;
  uint64_t v11 = 0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, (CGPDFReal *)&v11)
    && CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v13)
    && CGPDFScannerPopNumber(a1, &v14)
    && CGPDFScannerPopNumber(a1, &v15)
    && CGPDFScannerPopNumber(a1, &v16))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      uint64_t v4 = v11;
      CGPDFReal v5 = value;
      CGPDFReal v6 = v13;
      CGPDFReal v7 = v14;
      CGPDFReal v8 = v15;
      CGPDFReal v9 = v16;
      TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
      *((CGPDFReal *)TextObject + 9) = v9;
      *((CGPDFReal *)TextObject + 10) = v8;
      *((CGPDFReal *)TextObject + 11) = v7;
      *((CGPDFReal *)TextObject + 12) = v6;
      *((CGPDFReal *)TextObject + 13) = v5;
      *((void *)TextObject + 14) = v4;
      *((CGPDFReal *)TextObject + 15) = v9;
      *((CGPDFReal *)TextObject + 16) = v8;
      *((CGPDFReal *)TextObject + 17) = v7;
      *((CGPDFReal *)TextObject + 18) = v6;
      *((CGPDFReal *)TextObject + 19) = v5;
      *((void *)TextObject + 20) = v4;
    }
    else
    {
    }
  }
}

void op_TD_8453(CGPDFScanner *a1, uint64_t a2)
{
  double v8 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v8) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      uint64_t v4 = *(void *)(a2 + 8);
      if (v4)
      {
        double v5 = -v8;
        *(double *)(v4 + 96) = -v8;
        uint64_t v6 = *(void *)(v4 + 272);
        if (v6) {
          *(double *)(v6 + 24) = v5;
        }
      }
      TextObject = CGPDFGStateGetTextObject(v4);
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v8);
    }
    else
    {
    }
  }
}

void op_Td_8455(CGPDFScanner *a1, uint64_t a2)
{
  double v5 = 0.0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber(a1, &v5) && CGPDFScannerPopNumber(a1, &value))
  {
    if (*(unsigned char *)(a2 + 16))
    {
      TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
      CGPDFTextObjectMoveToNextLine((uint64_t)TextObject, value, v5);
    }
    else
    {
    }
  }
}

void op_ET_8457(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16)) {
    *(unsigned char *)(a2 + 16) = 0;
  }
  else {
}
  }

CGFloat op_BT_8459(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16))
  {
    pdf_error("warning: already in a text object.");
  }
  else
  {
    *(unsigned char *)(a2 + 16) = 1;
    TextObject = CGPDFGStateGetTextObject(*(void *)(a2 + 8));
    CGFloat result = CGAffineTransformIdentity.a;
    *(CGAffineTransform *)(TextObject + 72) = CGAffineTransformIdentity;
    *(CGAffineTransform *)(TextObject + 120) = CGAffineTransformIdentity;
  }
  return result;
}

BOOL op_Ts_8461(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 104) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 32) = v5;
      }
    }
  }
  return result;
}

void op_Tr_8462(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFInteger value = 0;
  if (CGPDFScannerPopInteger(a1, &value))
  {
    int v3 = value;
    if ((unint64_t)value >= 8)
    {
      pdf_error("invalid text drawing mode: %ld.", value);
    }
    else
    {
      uint64_t v4 = *(void *)(a2 + 8);
      if (v4)
      {
        *(_DWORD *)(v4 + 112) = value;
        uint64_t v5 = *(void *)(v4 + 272);
        if (v5) {
          CGPDFTextObjectSetTextDrawingMode(v5, v3);
        }
      }
    }
  }
}

void op_Tf_8464(uint64_t *a1, uint64_t a2)
{
  double v8 = 0;
  CGPDFReal value = 0.0;
  if (CGPDFScannerPopNumber((CGPDFScannerRef)a1, &value)
    && CGPDFScannerPopName((CGPDFScannerRef)a1, (const char **)&v8))
  {
    Font = CGPDFContentStreamGetFont(a1[7], v8);
    if (Font)
    {
      CGPDFGStateSetFont(*(void *)(a2 + 8), Font);
      uint64_t v5 = *(void *)(a2 + 8);
      if (v5)
      {
        CGPDFReal v6 = value;
        *(CGPDFReal *)(v5 + 128) = value;
        uint64_t v7 = *(void *)(v5 + 272);
        if (v7) {
          *(CGPDFReal *)(v7 + 56) = v6;
        }
      }
    }
    else
    {
    }
  }
}

BOOL op_TL_8466(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 96) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 24) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tz_8467(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 88) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 16) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tw_8468(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 80) = value;
      uint64_t v6 = *(void *)(v4 + 272);
      if (v6) {
        *(CGPDFReal *)(v6 + 8) = v5;
      }
    }
  }
  return result;
}

BOOL op_Tc_8469(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal value = 0.0;
  BOOL result = CGPDFScannerPopNumber(a1, &value);
  if (result)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      CGPDFReal v5 = value;
      *(CGPDFReal *)(v4 + 72) = value;
      uint64_t v6 = *(CGPDFReal **)(v4 + 272);
      if (v6) {
        *uint64_t v6 = v5;
      }
    }
  }
  return result;
}

double op_cm_8470(CGPDFScanner *a1, uint64_t a2)
{
  CGPDFReal v11 = 0.0;
  CGPDFReal v12 = 0.0;
  CGPDFReal v9 = 0.0;
  CGPDFReal v10 = 0.0;
  CGPDFReal value = 0.0;
  CGPDFReal v8 = 0.0;
  if (CGPDFScannerPopNumber(a1, &value)
    && CGPDFScannerPopNumber(a1, &v8)
    && CGPDFScannerPopNumber(a1, &v9)
    && CGPDFScannerPopNumber(a1, &v10)
    && CGPDFScannerPopNumber(a1, &v11)
    && CGPDFScannerPopNumber(a1, &v12))
  {
    CGPDFReal v5 = *(double **)(a2 + 8);
    v6[0] = v12;
    v6[1] = v11;
    v6[2] = v10;
    v6[3] = v9;
    v6[4] = v8;
    v6[5] = value;
    return CGPDFGStateConcatCTM(v5, v6);
  }
  return result;
}

void op_Q_8471(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16))
  {
  }
  else
  {
    CGPDFRStateGRestore(*(void *)a2);
    int v3 = *(void **)a2;
    if (*(void *)a2) {
      int v3 = (void *)*v3;
    }
    *(void *)(a2 + 8) = v3;
  }
}

void op_q_8473(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16))
  {
  }
  else
  {
    CGPDFRStateGSave(*(void *)a2);
    int v3 = *(void **)a2;
    if (*(void *)a2) {
      int v3 = (void *)*v3;
    }
    *(void *)(a2 + 8) = v3;
  }
}

void *pdf_aes_create(uint64_t a1, uint64_t a2)
{
  if (a2 == 16 || a2 == 32)
  {
    int v3 = malloc_type_calloc(1uLL, 0x40uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    void *v3 = a2;
    __memcpy_chk();
    pdf_aes_reset(v3);
  }
  else
  {
    pdf_error("invalid AES password length.");
    return 0;
  }
  return v3;
}

uint64_t pdf_aes_reset(void *key)
{
  key[5] = 0;
  key[6] = 0;
  uint64_t v2 = (char *)(key + 5);
  uint64_t v4 = (CCCryptorRef *)(key + 7);
  int v3 = (_CCCryptor *)key[7];
  if (v3) {
    CCCryptorRelease(v3);
  }
  size_t v5 = *key;

  return CCCryptorCreate(1u, 0, 0, key + 1, v5, v2, v4);
}

void pdf_aes_free(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (_CCCryptor *)a1[7];
    if (v2) {
      CCCryptorRelease(v2);
    }
    free(a1);
  }
}

uint64_t pdf_aes_process_buffer(uint64_t a1, const void *a2, void *dataOut, size_t dataOutAvailable)
{
  BOOL v4 = (dataOutAvailable & 0xF) == 0 && dataOutAvailable > 0xF;
  uint64_t v5 = v4;
  if (v4)
  {
    size_t dataOutMoved = 0;
    CCCryptorUpdate(*(CCCryptorRef *)(a1 + 56), a2, dataOutAvailable, dataOut, dataOutAvailable, &dataOutMoved);
  }
  else
  {
    pdf_error("invalid AES block size.", a2, dataOut);
  }
  return v5;
}

uint64_t FontSubset::FontSubset(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1ED0935F8;
  *(void *)(a1 + 8) = a2;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 16), *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    *(void *)(a1 + 32) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 16) = v7;
  }
  *(_DWORD *)(a1 + 40) = a4;
  *(void *)(a1 + 48) = PDFXRefTableAddObject(*(void **)(**(void **)(a2 + 8) + 464));
  *(_DWORD *)(a1 + 56) = 33;
  PDFFont::get_embedded_font_name((std::string *)(a1 + 64), a2);
  *(void *)(a1 + 120) = 0;
  CGPDFReal v8 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 112) = a1 + 120;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(void *)(a1 + 128) = 0;
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 16);
    if (v9) {
      (*(void (**)(void, char **, _WORD *, uint64_t))(*(void *)(v9 + 16) + 280))(*(void *)(v9 + 112), CGPDFEncodingVectorMacRoman, v19, 256);
    }
    for (uint64_t i = 0; i != 256; ++i)
    {
      unsigned int v11 = (unsigned __int16)v19[i];
      unsigned __int16 v18 = v19[i];
      uint64_t v12 = *v8;
      if (!*v8) {
        goto LABEL_19;
      }
      uint64_t v13 = a1 + 120;
      do
      {
        unsigned int v14 = *(unsigned __int16 *)(v12 + 26);
        BOOL v15 = v14 >= v11;
        if (v14 >= v11) {
          CGPDFReal v16 = (uint64_t *)v12;
        }
        else {
          CGPDFReal v16 = (uint64_t *)(v12 + 8);
        }
        if (v15) {
          uint64_t v13 = v12;
        }
        uint64_t v12 = *v16;
      }
      while (*v16);
      if ((uint64_t *)v13 == v8 || v11 < *(unsigned __int16 *)(v13 + 26)) {
LABEL_19:
      }
        *((_WORD *)std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>((uint64_t **)(a1 + 112), v11, &v18)+ 14) = i;
    }
  }
  return a1;
}

void sub_184EBB1BC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 39) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t FontSubset::add_glyph(FontSubset *this, unsigned int a2)
{
  unsigned __int16 v17 = a2;
  uint64_t v2 = (uint64_t **)((char *)this + 96);
  int v3 = (char **)*((void *)this + 12);
  if (v3)
  {
    BOOL v4 = (uint64_t **)((char *)this + 96);
    do
    {
      unsigned int v5 = *((unsigned __int16 *)v3 + 13);
      BOOL v6 = v5 >= a2;
      if (v5 >= a2) {
        long long v7 = v3;
      }
      else {
        long long v7 = v3 + 1;
      }
      if (v6) {
        BOOL v4 = (uint64_t **)v3;
      }
      int v3 = (char **)*v7;
    }
    while (*v7);
    if (v4 != v2 && *((unsigned __int16 *)v4 + 13) <= a2) {
      return 1;
    }
  }
  if (*((_DWORD *)this + 10) == 1)
  {
    CGPDFReal v10 = (char *)*((void *)this + 15);
    CGPDFReal v8 = (char *)this + 120;
    uint64_t v9 = (char **)v10;
    if (v10)
    {
      unsigned int v11 = v8;
      do
      {
        unsigned int v12 = *((unsigned __int16 *)v9 + 13);
        BOOL v13 = v12 >= a2;
        if (v12 >= a2) {
          unsigned int v14 = v9;
        }
        else {
          unsigned int v14 = v9 + 1;
        }
        if (v13) {
          unsigned int v11 = (char *)v9;
        }
        uint64_t v9 = (char **)*v14;
      }
      while (*v14);
      if (v11 != v8 && *((unsigned __int16 *)v11 + 13) <= a2)
      {
        LOWORD(v15) = *((_WORD *)v11 + 14);
LABEL_27:
        *((_WORD *)std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(v2 - 1, a2, &v17)+ 14) = v15;
        return 1;
      }
    }
  }
  else
  {
    int v15 = *((_DWORD *)this + 14);
    if (v15 <= 255)
    {
      *((_DWORD *)this + 14) = v15 + 1;
      goto LABEL_27;
    }
  }
  return 0;
}

char *FontSubset::create_glyph_index_set(FontSubset *this)
{
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040C7309667uLL);
  *(_DWORD *)uint64_t v2 = 1;
  int v3 = (char *)*((void *)this + 11);
  BOOL v4 = (char *)this + 96;
  if (v3 != v4)
  {
    do
    {
      CGFontIndexSetAddIndex(v2, *((unsigned __int16 *)v3 + 13));
      unsigned int v5 = (char *)*((void *)v3 + 1);
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          unsigned int v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          BOOL v6 = (char *)*((void *)v3 + 2);
          BOOL v7 = *(void *)v6 == (void)v3;
          int v3 = v6;
        }
        while (!v7);
      }
      int v3 = v6;
    }
    while (v6 != v4);
  }
  return v2;
}

_WORD *FontSubset::get_encoding_vector(FontSubset *this, uint64_t a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  double result = operator new(0x200uLL);
  uint64_t v5 = 0;
  *(void *)this = result;
  *((void *)this + 1) = result;
  *((void *)this + 2) = result + 256;
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  do
  {
    *(_OWORD *)&result[v5] = v6;
    v5 += 8;
  }
  while (v5 != 256);
  *((void *)this + 1) = result + 256;
  BOOL v7 = *(void **)(a2 + 88);
  if (v7 != (void *)(a2 + 96))
  {
    while (1)
    {
      unint64_t v8 = *((unsigned __int16 *)v7 + 14);
      if (v8 >= 0x100) {
        break;
      }
      result[v8] = *((_WORD *)v7 + 13);
      uint64_t v9 = (void *)v7[1];
      if (v9)
      {
        do
        {
          CGPDFReal v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          CGPDFReal v10 = (void *)v7[2];
          BOOL v11 = *v10 == (void)v7;
          BOOL v7 = v10;
        }
        while (!v11);
      }
      BOOL v7 = v10;
      if (v10 == (void *)(a2 + 96)) {
        return result;
      }
    }
    __break(1u);
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        long long v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        long long v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    BOOL v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *BOOL v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *long long v6 = (uint64_t *)v7;
    CGPDFReal v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void FontSubset::emit_widths(FontSubset *this)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)(*((void *)this + 1) + 8);
  FontSubset::get_encoding_vector((FontSubset *)&v52, (uint64_t)this);
  int v3 = v52;
  uint64_t v4 = (char *)v53 - (char *)v52;
  if (v53 == v52) {
LABEL_35:
  }
    __break(1u);
  CGFontGetGlyphAdvances(*(CGFontRef *)(*((void *)this + 1) + 16), v52, 0x100uLL, advances);
  v50[0] = 0;
  v50[1] = 0;
  unint64_t v49 = (uint64_t *)v50;
  font_info = (int *)get_font_info(*(void **)(*((void *)this + 1) + 16));
  if (font_info) {
    float v6 = (float)font_info[2];
  }
  else {
    float v6 = 0.0;
  }
  uint64_t v7 = 0;
  int v51 = 0;
  uint64_t v8 = v4 >> 1;
  do
  {
    if (v8 == v7) {
      goto LABEL_35;
    }
    if ((__int16)v3[v7] != -1)
    {
      int v9 = advances[v7];
      *((_DWORD *)std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v49, v7, &v51)+ 8) = (int)(float)((float)((float)(1000 * v9) / v6) + 0.5);
    }
    int v51 = ++v7;
  }
  while (v7 != 256);
  operator delete(v3);
  CGPDFReal v16 = v50[0];
  int v17 = *((_DWORD *)v49 + 7);
  if (v50[0])
  {
    do
    {
      unsigned __int16 v18 = v16;
      CGPDFReal v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    long long v19 = v50;
    do
    {
      unsigned __int16 v18 = v19[2];
      BOOL v20 = *v18 == (void)v19;
      long long v19 = (void **)v18;
    }
    while (v20);
  }
  uint64_t v21 = *((unsigned int *)v18 + 7);
  PDFDocumentPrintf(v2, (uint64_t)"/FirstChar %d", v10, v11, v12, v13, v14, v15, *((unsigned int *)v49 + 7));
  PDFDocumentPrintf(v2, (uint64_t)"/LastChar %d", v22, v23, v24, v25, v26, v27, v21);
  PDFDocumentPrintf(v2, (uint64_t)"/Widths [", v28, v29, v30, v31, v32, v33, v47);
  if (v17 <= (int)v21)
  {
    do
    {
      uint64_t v40 = v50[0];
      if (!v50[0]) {
        goto LABEL_28;
      }
      uint64_t v41 = v50;
      do
      {
        uint64_t v42 = v40;
        uint64_t v43 = v41;
        int v44 = *((_DWORD *)v40 + 7);
        if (v44 >= v17) {
          uint64_t v41 = (void **)v40;
        }
        else {
          ++v40;
        }
        uint64_t v40 = (void *)*v40;
      }
      while (v40);
      if (v41 != v50 && (v44 >= v17 ? (unint64_t v45 = v42) : (unint64_t v45 = v43), v17 >= *((_DWORD *)v45 + 7)))
      {
        if (v44 < v17) {
          uint64_t v42 = v43;
        }
        uint64_t v46 = *((unsigned int *)v42 + 8);
      }
      else
      {
LABEL_28:
        uint64_t v46 = 0;
      }
      PDFDocumentPrintf(v2, (uint64_t)"%d", v34, v35, v36, v37, v38, v39, v46);
      BOOL v20 = v17++ == v21;
    }
    while (!v20);
  }
  PDFDocumentPrintf(v2, (uint64_t)"]", v34, v35, v36, v37, v38, v39, v48);
  std::__tree<unsigned long>::destroy(v50[0]);
}

void sub_184EBB790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

unint64_t get_font_stream_8518(uint64_t a1, int *a2)
{
  unint64_t result = CGPDFFontGetFontDescriptor(a1);
  if (result)
  {
    CGPDFStreamRef value = 0;
    if (CGPDFDictionaryGetStream(*(CGPDFDictionaryRef *)(result + 32), "FontFile3", &value)) {
      CGPDFStreamRef v4 = value;
    }
    else {
      CGPDFStreamRef v4 = 0;
    }
    if (!v4) {
      return 0;
    }
    CGPDFStreamRef value = 0;
    BOOL Name = CGPDFDictionaryGetName(*((CGPDFDictionaryRef *)v4 + 6), "Subtype", (const char **)&value);
    unint64_t result = 0;
    if (!Name) {
      return result;
    }
    float v6 = (const char *)value;
    if (!strcmp((const char *)value, "CIDFontType0C"))
    {
      int v7 = 4;
    }
    else
    {
      if (strcmp(v6, "OpenType"))
      {
        return 0;
      }
      int v7 = 6;
    }
    *a2 = v7;
    return (unint64_t)v4;
  }
  return result;
}

uint64_t CGPDFFontHasMatchingROS(uint64_t a1, void *a2)
{
  CIDSystemInfo = (const char **)CGPDFFontGetCIDSystemInfo(a1);
  if (!CIDSystemInfo) {
    return 1;
  }
  uint64_t v5 = *CIDSystemInfo;
  CGPDFStreamRef v4 = CIDSystemInfo[1];
  if (!strcmp(*CIDSystemInfo, "Adobe") && !strcmp(v4, "Identity")) {
    return 1;
  }
  int v13 = 0;
  CFTypeRef v11 = 0;
  CFTypeRef cf2 = 0;
  BOOL RegistryOrderingSupplement = CGFontGetRegistryOrderingSupplement(a2, &cf2, &v11, &v13);
  uint64_t v7 = 0;
  if (RegistryOrderingSupplement)
  {
    CFStringRef v8 = CFStringCreateWithCString(0, v5, 0x600u);
    uint64_t v7 = CFEqual(v8, cf2);
    CFRelease(v8);
    if (v7)
    {
      CFStringRef v9 = CFStringCreateWithCString(0, v4, 0x600u);
      uint64_t v7 = CFEqual(v9, v11) != 0;
      CFRelease(v9);
    }
  }
  return v7;
}

void *CGPDFFontMatchCID(uint64_t a1)
{
  uint64_t v1 = a1;
  unint64_t FontDescriptor = CGPDFFontGetFontDescriptor(a1);
  uint64_t Style = CGPDFFontDescriptorGetStyle(FontDescriptor);
  if (Style)
  {
    double v4 = *(double *)Style;
    BOOL v5 = *(unsigned char *)(Style + 18) != 0;
  }
  else
  {
    BOOL v5 = 0;
    double v4 = 0.0;
  }
  CIDSystemInfo = CGPDFFontGetCIDSystemInfo(v1);
  if (CIDSystemInfo)
  {
    uint64_t v7 = (const char *)*CIDSystemInfo;
    CFStringRef v8 = (const char *)CIDSystemInfo[1];
    int v9 = *((_DWORD *)CIDSystemInfo + 4);
    MatchingFont = CGFontCreateMatchingFont((const char *)*CIDSystemInfo, v8, v9, v5, v4);
    CFTypeRef v11 = MatchingFont;
    if (MatchingFont)
    {
      uint64_t v12 = "CIDFontType2";
      if (v1)
      {
        if (*(_DWORD *)(v1 + 200) == 6) {
          uint64_t v12 = "CIDFontType0";
        }
        uint64_t v1 = *(void *)(v1 + 32);
      }
      int v13 = (const char *)(*(uint64_t (**)(void))(MatchingFont[2] + 144))(MatchingFont[14]);
    }
  }
  else
  {
    return 0;
  }
  return v11;
}

uint64_t zombie_DrawLayer()
{
  return 0;
}

double zombie_GetLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = CGContextDelegateCreate(0, a2, a3, a4, a5, a6, a7, a8);
  if (v8)
  {
    long long v10 = unk_1ED097FC8;
    *(_OWORD *)(v8 + 216) = xmmword_1ED097FB8;
    *(_OWORD *)(v8 + 232) = v10;
    long long v11 = unk_1ED097FE8;
    *(_OWORD *)(v8 + 248) = xmmword_1ED097FD8;
    *(_OWORD *)(v8 + 264) = v11;
    long long v12 = *(_OWORD *)&off_1ED097F88;
    *(_OWORD *)(v8 + 152) = xmmword_1ED097F78;
    *(_OWORD *)(v8 + 168) = v12;
    long long v13 = *(_OWORD *)&off_1ED097FA8;
    *(_OWORD *)(v8 + 184) = xmmword_1ED097F98;
    *(_OWORD *)(v8 + 200) = v13;
    long long v14 = *(_OWORD *)&off_1ED097F48;
    *(_OWORD *)(v8 + 88) = xmmword_1ED097F38;
    *(_OWORD *)(v8 + 104) = v14;
    long long v15 = *(_OWORD *)&off_1ED097F68;
    *(_OWORD *)(v8 + 120) = xmmword_1ED097F58;
    *(_OWORD *)(v8 + 136) = v15;
    long long v16 = *(_OWORD *)&off_1ED097F08;
    *(_OWORD *)(v8 + 24) = gZombieVTable;
    *(_OWORD *)(v8 + 40) = v16;
    double result = *(double *)&xmmword_1ED097F18;
    long long v17 = *(_OWORD *)&off_1ED097F28;
    *(_OWORD *)(v8 + 56) = xmmword_1ED097F18;
    *(_OWORD *)(v8 + 72) = v17;
  }
  return result;
}

uint64_t zombie_DrawWindowContents()
{
  return 0;
}

uint64_t zombie_Operation()
{
  return 0;
}

uint64_t zombie_EndPage()
{
  return 0;
}

uint64_t zombie_BeginPage()
{
  return 0;
}

uint64_t zombie_DrawImageFromRect()
{
  return 0;
}

uint64_t zombie_DrawImages()
{
  return 0;
}

uint64_t zombie_DrawDisplayList()
{
  return 0;
}

uint64_t zombie_DrawConicGradient()
{
  return 0;
}

uint64_t zombie_DrawRadialGradient()
{
  return 0;
}

uint64_t zombie_DrawLinearGradient()
{
  return 0;
}

uint64_t zombie_DrawShading()
{
  return 0;
}

uint64_t zombie_DrawGlyphs()
{
  return 0;
}

uint64_t zombie_DrawImage()
{
  return 0;
}

uint64_t zombie_DrawPath()
{
  return 0;
}

uint64_t zombie_DrawRects()
{
  return 0;
}

double zombie_GetBounds()
{
  return INFINITY;
}

CGFloat zombie_GetTransform@<D0>(CGAffineTransform *a1@<X8>)
{
  *a1 = CGAffineTransformIdentity;
  return CGAffineTransformIdentity.tx;
}

uint64_t zombie_GetColorTransform()
{
  return 0;
}

uint64_t CGContextDelegateGetTypeID()
{
  if (_block_invoke_once_8554 != -1) {
    dispatch_once(&_block_invoke_once_8554, &__block_literal_global_5_8555);
  }
  return CGContextDelegateGetTypeID_context_delegate_id;
}

uint64_t CGContextDelegateCreateWithCallbacks(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  if (_block_invoke_once_8554 != -1) {
    dispatch_once(&_block_invoke_once_8554, &__block_literal_global_5_8555);
  }
  uint64_t result = CGTypeCreateInstance(CGContextDelegateGetTypeID_context_delegate_id, 280, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *(void *)(result + 288) = a1;
    long long v11 = *a2;
    long long v12 = a2[1];
    long long v13 = a2[2];
    *(_OWORD *)(result + 72) = a2[3];
    *(_OWORD *)(result + 56) = v13;
    *(_OWORD *)(result + 40) = v12;
    *(_OWORD *)(result + 24) = v11;
    long long v14 = a2[4];
    long long v15 = a2[5];
    long long v16 = a2[6];
    *(_OWORD *)(result + 136) = a2[7];
    *(_OWORD *)(result + 120) = v16;
    *(_OWORD *)(result + 104) = v15;
    *(_OWORD *)(result + 88) = v14;
    long long v17 = a2[8];
    long long v18 = a2[9];
    long long v19 = a2[10];
    *(_OWORD *)(result + 200) = a2[11];
    *(_OWORD *)(result + 184) = v19;
    *(_OWORD *)(result + 168) = v18;
    *(_OWORD *)(result + 152) = v17;
    long long v20 = a2[12];
    long long v21 = a2[13];
    long long v22 = a2[14];
    *(_OWORD *)(result + 264) = a2[15];
    *(_OWORD *)(result + 248) = v22;
    *(_OWORD *)(result + 232) = v21;
    *(_OWORD *)(result + 216) = v20;
  }
  return result;
}

CFTypeRef CGContextDelegateRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

uint64_t CGContextDelegateImplementsCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = get_callback_address(a1, a2, (uint64_t)"CGContextDelegateImplementsCallback", a4, a5, a6, a7, a8);
  if (result) {
    return *(void *)result != 0;
  }
  return result;
}

uint64_t CGContextDelegateGetDelegate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = a1; i; uint64_t i = *(void *)(i + 16))
  {
    callback_address = (void *)get_callback_address(i, a2, (uint64_t)"CGContextDelegateGetDelegate", a4, a5, a6, a7, a8);
    if (callback_address && *callback_address == a3) {
      break;
    }
  }
  return i;
}

uint64_t CGContextDelegateGetNext(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

void CGContextDelegateSetNext(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 16);
    if (v4 != cf)
    {
      if (cf)
      {
        CFRetain(cf);
        CFTypeRef v4 = *(CFTypeRef *)(a1 + 16);
      }
      if (v4) {
        CFRelease(v4);
      }
      *(void *)(a1 + 16) = cf;
    }
  }
}

uint64_t CGContextDelegateGetColorTransform(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 32)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t CGContextDelegateGetColorSpace(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 264)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

CGFloat CGContextDelegateGetTransform@<D0>(uint64_t a1@<X0>, CGAffineTransform *a2@<X8>)
{
  if (a1 && (uint64_t v2 = *(void (**)(void))(a1 + 40)) != 0)
  {
    v2();
  }
  else
  {
    *a2 = CGAffineTransformIdentity;
    return CGAffineTransformIdentity.tx;
  }
  return result;
}

void CGContextDelegateDrawLines(uint64_t a1, uint64_t a2, uint64_t a3, const CGPoint *a4, unint64_t a5)
{
  if (a1)
  {
    long long v10 = *(void (**)(void))(a1 + 56);
    if (v10)
    {
      v10();
    }
    else
    {
      CFMutableDictionaryRef Mutable = CGPathCreateMutable();
      if (a5)
      {
        unint64_t v12 = 0;
        do
        {
          CGPathAddLines(Mutable, (const CGAffineTransform *)(a3 + 24), a4, 2uLL);
          v12 += 2;
          a4 += 2;
        }
        while (v12 < a5);
      }
      CGContextDelegateDrawPath(a1, a2, a3, 2, Mutable);
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }
  }
}

uint64_t CGContextDelegateDrawShading(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 96);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawRadialGradient(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 112);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawConicGradient(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 120);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawDisplayList(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 128);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawImages(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 136);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawImageFromRect(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 144);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateBeginPage(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 152);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateEndPage(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 160);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateOperation(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 168);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateDrawWindowContents(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 176);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateGetLayer(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 208)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t CGContextDelegateDrawLayer(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 216);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t CGContextDelegateGetBitmapContextInfo(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 248)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t CGContextDelegateDrawImageApplyingToneMapping(uint64_t a1)
{
  if (!a1) {
    return 1000;
  }
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 272);
  if (v1) {
    return v1();
  }
  else {
    return 1006;
  }
}

uint64_t CGContextDelegateSetOwnerIdentity(uint64_t result, int a2)
{
  *(_DWORD *)(result + 280) = a2;
  return result;
}

void *CGCryptorCreateRC4(const void *a1, size_t a2)
{
  if (a2 - 513 < 0xFFFFFFFFFFFFFE00) {
    return 0;
  }
  CFTypeRef v4 = malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *(unsigned char *)CFTypeRef v4 = 0;
  BOOL v5 = malloc_type_malloc(a2, 0x2062DE7BuLL);
  v4[2] = v5;
  memmove(v5, a1, a2);
  v4[1] = a2;
  v4[3] = 0;
  *((_DWORD *)v4 + 8) = 4;
  v4[5] = 0;
  if ((CGCryptorReset((CCCryptorRef *)v4, v6, v7, v8, v9, v10, v11, v12) & 1) == 0)
  {
    CGCryptorRelease((uint64_t)v4);
    return 0;
  }
  return v4;
}

uint64_t CGCryptorReset(CCCryptorRef *cryptorRef, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = cryptorRef + 3;
  uint64_t v9 = cryptorRef[3];
  if (v9)
  {
    CCCryptorRelease(v9);
    *uint64_t v10 = 0;
  }
  int v11 = *((_DWORD *)cryptorRef + 8);
  if (v11)
  {
    if (v11 != 4)
    {
      LOBYTE(v17) = 44;
      goto LABEL_10;
    }
    CCCryptorRef v13 = cryptorRef[1];
    CCCryptorRef v12 = cryptorRef[2];
    CCAlgorithm v14 = 4;
    CCOptions v15 = 0;
    CCCryptorRef v16 = 0;
  }
  else
  {
    CCOptions v15 = *(unsigned __int8 *)cryptorRef != 0;
    CCCryptorRef v13 = cryptorRef[1];
    CCCryptorRef v12 = cryptorRef[2];
    CCCryptorRef v16 = cryptorRef[5];
    CCAlgorithm v14 = 0;
  }
  CCCryptorStatus v17 = CCCryptorCreate(*(unsigned char *)cryptorRef == 0, v14, v15, v12, (size_t)v13, v16, v10);
  if (!v17) {
    return 1;
  }
LABEL_10:
  CGPostError((uint64_t)"CGCryptorReset: CCCryptorCreate failed: error %d.", a2, a3, a4, a5, a6, a7, a8, v17);
  return 0;
}

void CGCryptorRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(_CCCryptor **)(a1 + 24);
    if (v2) {
      CCCryptorRelease(v2);
    }
    int v3 = *(void **)(a1 + 40);
    if (v3) {
      free(v3);
    }
    free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

void *CGCryptorCreateAES(const void *a1, size_t a2, _OWORD *a3, char a4)
{
  if (a2 != 32 && a2 != 16) {
    return 0;
  }
  uint64_t v8 = malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *(unsigned char *)uint64_t v8 = a4;
  uint64_t v9 = malloc_type_malloc(a2, 0x2062DE7BuLL);
  v8[2] = v9;
  memmove(v9, a1, a2);
  v8[1] = a2;
  _OWORD v8[3] = 0;
  *((_DWORD *)v8 + 8) = 0;
  uint64_t v10 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
  v8[5] = v10;
  *uint64_t v10 = *a3;
  if ((CGCryptorReset((CCCryptorRef *)v8, v11, v12, v13, v14, v15, v16, v17) & 1) == 0)
  {
    CGCryptorRelease((uint64_t)v8);
    return 0;
  }
  return v8;
}

void CGCryptorProcessBytes(uint64_t a1, const void *a2, size_t a3, void *a4, size_t a5, size_t *a6)
{
  size_t dataOutMoved = 0;
  CCCryptorStatus v7 = CCCryptorUpdate(*(CCCryptorRef *)(a1 + 24), a2, a3, a4, a5, &dataOutMoved);
  if (v7)
  {
    CGPostError((uint64_t)"CGCryptorProcessBytes: CCCryptorUpdate failed: error %d.", v8, v9, v10, v11, v12, v13, v14, v7);
  }
  else if (a6)
  {
    *a6 = dataOutMoved;
  }
}

void CGCryptorDrain(uint64_t a1, void *a2, size_t a3, size_t *a4)
{
  size_t dataOutMoved = 0;
  CCCryptorStatus v5 = CCCryptorFinal(*(CCCryptorRef *)(a1 + 24), a2, a3, &dataOutMoved);
  if (v5)
  {
    CGPostError((uint64_t)"CGCryptorProcessBytes: CCCryptorFinal failed: error %d.", v6, v7, v8, v9, v10, v11, v12, v5);
  }
  else if (a4)
  {
    *a4 = dataOutMoved;
  }
}

uint64_t CGCryptorGetInitializationVector(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t CGCryptorGetCipher(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t compareUnsigned(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t compareDoubleIndirect(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  double v3 = *(double *)(a1 + 8 * *a2);
  double v4 = *(double *)(a1 + 8 * *a3);
  if (v3 < v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3 > v4;
  }
}

void *CGClipGlyphsCreate(const void *a1, int a2, const CGAffineTransform *a3, const void *a4, const void *a5, uint64_t a6)
{
  uint64_t v6 = 0;
  if (a5 && a4 && a1 && a6)
  {
    uint64_t v13 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    uint64_t v6 = v13;
    *(_DWORD *)uint64_t v13 = 1;
    uint64_t v14 = &CGAffineTransformIdentity;
    if (a3) {
      uint64_t v14 = a3;
    }
    long long v16 = *(_OWORD *)&v14->c;
    long long v15 = *(_OWORD *)&v14->tx;
    *(_OWORD *)(v13 + 8) = *(_OWORD *)&v14->a;
    *(_OWORD *)(v13 + 24) = v16;
    *(_OWORD *)(v13 + 40) = v15;
    *((_DWORD *)v13 + 14) = a2;
    CFRetain(a1);
    v6[8] = a1;
    v6[11] = a6;
    uint64_t v17 = malloc_type_malloc(16 * a6, 0x705560E0uLL);
    v6[10] = v17;
    if (v17
      && (memcpy(v17, a5, 16 * a6), size_t v18 = 2 * a6, v19 = malloc_type_malloc(v18, 0x705560E0uLL), (v6[9] = v19) != 0))
    {
      memcpy(v19, a4, v18);
    }
    else
    {
      CGClipGlyphsRelease((uint64_t)v6);
      return 0;
    }
  }
  return v6;
}

void CGClipGlyphsRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = *(const void **)(a1 + 64);
    if (v2) {
      CFRelease(v2);
    }
    free(*(void **)(a1 + 80));
    free(*(void **)(a1 + 72));
    free((void *)a1);
  }
}

atomic_uint *CGClipGlyphsCreateCopy(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

atomic_uint *CGClipGlyphsRetain(atomic_uint *result)
{
  if (result) {
    atomic_fetch_add_explicit(result, 1u, memory_order_relaxed);
  }
  return result;
}

void *CGClipGlyphsCreateCopyByApplyingTransform(void *a1, float64x2_t *a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    if (a2)
    {
      double v4 = (float64x2_t *)malloc_type_malloc(16 * a1[11], 0x2062DE7BuLL);
      CCCryptorStatus v5 = v4;
      uint64_t v6 = v2[11];
      if (v6)
      {
        uint64_t v7 = (double *)(v2[10] + 8);
        uint64_t v8 = v4;
        uint64_t v9 = v2[11];
        do
        {
          *v8++ = vmlaq_n_f64(vmulq_n_f64(a2[1], *v7), *a2, *(v7 - 1));
          v7 += 2;
          --v9;
        }
        while (v9);
      }
      double v10 = *((double *)v2 + 1);
      double v11 = *((double *)v2 + 2);
      double v12 = *((double *)v2 + 3);
      double v13 = *((double *)v2 + 4);
      double v14 = *((double *)v2 + 5);
      double v15 = *((double *)v2 + 6);
      double v16 = a2->f64[0];
      double v17 = a2->f64[1];
      double v18 = a2[1].f64[0];
      double v19 = a2[1].f64[1];
      double v20 = a2[2].f64[0];
      double v21 = a2[2].f64[1];
      v23.a = v11 * v18 + v10 * a2->f64[0];
      v23.b = v11 * v19 + v10 * v17;
      v23.c = v13 * v18 + v12 * v16;
      v23.d = v13 * v19 + v12 * v17;
      v23.tx = v20 + v18 * v15 + v14 * v16;
      v23.ty = v19 * v15 + v14 * v17 + v21;
      uint64_t v2 = CGClipGlyphsCreate((const void *)v2[8], *((_DWORD *)v2 + 14), &v23, (const void *)v2[9], v4, v6);
      free(v5);
    }
    else
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)a1, 1u, memory_order_relaxed);
    }
  }
  return v2;
}

BOOL CGClipGlyphsEqualToClipGlyphs(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t CGClipGlyphsGetLength(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t CGClipGlyphsGetGlyphAtIndex(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 88) <= a2) {
      return 0;
    }
    else {
      return *(unsigned __int16 *)(*(void *)(result + 72) + 2 * a2);
    }
  }
  return result;
}

CGFloat CGClipGlyphsGetAdvanceAtIndex(uint64_t a1, unint64_t a2)
{
  if (a1 && *(void *)(a1 + 88) > a2) {
    uint64_t v2 = (const CGSize *)(*(void *)(a1 + 80) + 16 * a2);
  }
  else {
    uint64_t v2 = &CGSizeZero;
  }
  return v2->width;
}

uint64_t CGClipGlyphsGetFontAtIndex(uint64_t result, unint64_t a2, void *a3)
{
  if (result)
  {
    unint64_t v3 = *(void *)(result + 88);
    if (v3 <= a2)
    {
      return 0;
    }
    else
    {
      if (a3)
      {
        *a3 = 0;
        a3[1] = v3;
      }
      return *(void *)(result + 64);
    }
  }
  return result;
}

uint64_t CGClipGlyphsGetFontRenderingStyleAtIndex(uint64_t result, uint64_t a2, void *a3)
{
  if (result)
  {
    if (a3)
    {
      uint64_t v3 = *(void *)(result + 88);
      *a3 = 0;
      a3[1] = v3;
    }
    return *(unsigned int *)(result + 56);
  }
  return result;
}

__n128 CGClipGlyphsGetMatrixAtIndex@<Q0>(uint64_t a1@<X0>, void *a2@<X2>, uint64_t a3@<X8>)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v3 = *(void *)(a1 + 88);
      *a2 = 0;
      a2[1] = v3;
    }
    double v4 = (const CGAffineTransform *)(a1 + 8);
  }
  else
  {
    double v4 = &CGAffineTransformIdentity;
  }
  long long v5 = *(_OWORD *)&v4->c;
  *(_OWORD *)a3 = *(_OWORD *)&v4->a;
  *(_OWORD *)(a3 + 16) = v5;
  __n128 result = *(__n128 *)&v4->tx;
  *(__n128 *)(a3 + 32) = result;
  return result;
}

uint64_t CGClipGlyphsGetFont(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

uint64_t CGClipGlyphsGetFontRenderingStyle(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 56);
  }
  return result;
}

__n128 CGClipGlyphsGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1) {
    uint64_t v2 = &CGAffineTransformIdentity;
  }
  long long v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGClipGlyphsGetCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t CGClipGlyphsGetGlyphs(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t CGClipGlyphsGetAdvances(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

double CGClipGlyphsGetBounds(uint64_t a1)
{
  double result = -8.98846567e307;
  if (!a1) {
    return INFINITY;
  }
  return result;
}

void PDFMetaSetRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)a1[2];
    if (v2) {
      CFRelease(v2);
    }
    long long v3 = (const void *)a1[3];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

const void *PDFMetaSetAddDictionary(uint64_t a1, const void *a2)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
  {
    Value = (const void *)PDFXRefTableAddObject(*(void **)(*(void *)(a1 + 8) + 464));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, Value);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  }
  return Value;
}

void write_object(uint64_t *a1, const __CFString *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 == CFNullGetTypeID())
  {
    uint64_t v18 = a1[1];
    PDFDocumentPrintf(v18, (uint64_t)"null", v12, v13, v14, v15, v16, v17, a9);
  }
  else if (v11 == CFBooleanGetTypeID())
  {
    uint64_t v19 = a1[1];
    uint64_t Value = CFBooleanGetValue((CFBooleanRef)cf);
    PDFDocumentPrintf(v19, (uint64_t)"%b", v20, v21, v22, v23, v24, v25, Value);
  }
  else if (v11 == CFNumberGetTypeID())
  {
    float valuePtr = 0.0;
    LODWORD(v71[0]) = 0;
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      PDFDocumentPrintf(a1[1], (uint64_t)"%f", v26, v27, v28, v29, v30, v31, COERCE__INT64(valuePtr));
    }
    else
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, v71);
      PDFDocumentPrintf(a1[1], (uint64_t)"%d", v44, v45, v46, v47, v48, v49, LODWORD(v71[0]));
    }
  }
  else if (v11 == CFDateGetTypeID())
  {
    PDFDocumentPrintf(a1[1], (uint64_t)"%D", v32, v33, v34, v35, v36, v37, (uint64_t)cf);
  }
  else if (v11 == CFURLGetTypeID())
  {
    PDFDocumentPrintf(a1[1], (uint64_t)"%U", v38, v39, v40, v41, v42, v43, (uint64_t)cf);
  }
  else if (v11 == CFStringGetTypeID())
  {
    write_string((uint64_t)a1, cf);
  }
  else if (v11 == CFDataGetTypeID())
  {
    write_data((uint64_t)a1, cf);
  }
  else
  {
    if (_block_invoke_once_6961 != -1) {
      dispatch_once(&_block_invoke_once_6961, &__block_literal_global_5_6962);
    }
    if (v11 == CGContainerGetTypeID_container_type_id)
    {
      if (cf)
      {
        long long v56 = *(_OWORD *)&cf[1].isa;
        v71[0] = *(_OWORD *)&cf->data;
        v71[1] = v56;
        PDFDocumentPrintf(a1[1], (uint64_t)"%r", v50, v51, v52, v53, v54, v55, (uint64_t)v71);
      }
    }
    else if (v11 == CFArrayGetTypeID())
    {
      write_array((uint64_t)a1, (const __CFArray *)cf, v57, v58, v59, v60, v61, v62, a9);
    }
    else if (v11 == CFDictionaryGetTypeID())
    {
      write_dictionary(a1, (const __CFDictionary *)cf, v63, v64, v65, v66, v67, v68, a9);
    }
  }
}

void write_string(uint64_t a1, CFStringRef theString)
{
  if (!CFStringHasPrefix(theString, @"/"))
  {
    PDFDocumentPrintf(*(void *)(a1 + 8), (uint64_t)"%T", v4, v5, v6, v7, v8, v9, (uint64_t)theString);
    return;
  }
  if (!CFStringHasPrefix(theString, @"//"))
  {
    if (CFStringHasPrefix(theString, @"/>"))
    {
      v35.length = CFStringGetLength(theString) - 2;
      v35.location = 2;
      double v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v35);
      DestinationSet = PDFDocumentGetDestinationSet(*(void *)(a1 + 8));
      Destination = PDFDestinationSetGetDestination(DestinationSet, v10);
      uint64_t v24 = *(void *)(a1 + 8);
      if (Destination)
      {
        ObjectNumberForPageNumber = (const void *)Destination[1];
LABEL_13:
        PDFDocumentPrintReference(v24, (uint64_t)"%R", (uint64_t)ObjectNumberForPageNumber, v18, v19, v20, v21, v22);
        goto LABEL_14;
      }
    }
    else
    {
      if (!CFStringHasPrefix(theString, @"/#"))
      {
        PDFDocumentPrintf(*(void *)(a1 + 8), (uint64_t)"%/", v26, v27, v28, v29, v30, v31, (uint64_t)theString);
        return;
      }
      v36.length = CFStringGetLength(theString) - 2;
      v36.location = 2;
      double v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v36);
      Intuint64_t Value = CFStringGetIntValue(v10);
      uint64_t v24 = *(void *)(a1 + 8);
      if (v24 && *(void *)(v24 + 456))
      {
        ObjectNumberForPageNumber = PDFPageTree::getObjectNumberForPageNumber(*(CFDictionaryRef **)(v24 + 456), (const void *)IntValue);
        uint64_t v24 = *(void *)(a1 + 8);
        goto LABEL_13;
      }
    }
    ObjectNumberForPageNumber = 0;
    goto LABEL_13;
  }
  v34.length = CFStringGetLength(theString) - 1;
  v34.location = 1;
  double v10 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, v34);
  PDFDocumentPrintf(*(void *)(a1 + 8), (uint64_t)"%T", v11, v12, v13, v14, v15, v16, (uint64_t)v10);
LABEL_14:

  CFRelease(v10);
}

void write_data(uint64_t a1, const void *a2)
{
  uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value) {
    _CGHandleAssert("write_data", 228, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Annotations/PDFMetaSet.c", "objectNumber != PDFObjectNumberInvalid", "invalid PDF object %lu", v5, v6, v7, 0);
  }
  uint64_t v8 = PDFStreamCreateWithObjectNumber(*(void *)(a1 + 8), (uint64_t)Value);
  PDFDocumentBeginObject(*v8, v8[1], v9, v10, v11, v12, v13, v14);
  PDFDocumentPrintf(*v8, (uint64_t)"<<", v15, v16, v17, v18, v19, v20, v29);
  PDFDocumentPrintf(*(void *)(a1 + 8), (uint64_t)"/Type /Data", v21, v22, v23, v24, v25, v26, v30);
  PDFStreamBeginData((CGDataConsumerRef)v8);
  BytePtr = CFDataGetBytePtr((CFDataRef)a2);
  CFIndex Length = CFDataGetLength((CFDataRef)a2);
  CGDataConsumerPutBytes(v8[3], (uint64_t)BytePtr, Length);
  PDFStreamEndData(v8);
  PDFStreamEnd((CFDataRef *)v8);

  PDFStreamRelease((uint64_t)v8);
}

void write_array(uint64_t a1, const __CFArray *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PDFDocumentPrintf(*(void *)(a1 + 8), (uint64_t)"[", a3, a4, a5, a6, a7, a8, v22);
  CFIndex Count = CFArrayGetCount(a2);
  if (Count)
  {
    CFIndex v18 = Count;
    for (CFIndex i = 0; i != v18; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, i);
      write_object_or_reference(a1, ValueAtIndex);
    }
  }
  uint64_t v21 = *(void *)(a1 + 8);

  PDFDocumentPrintf(v21, (uint64_t)"]", v12, v13, v14, v15, v16, v17, a9);
}

void write_dictionary(uint64_t *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PDFDocumentPrintf(a1[1], (uint64_t)"<<", a3, a4, a5, a6, a7, a8, v18);
  CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)write_dictionary_entry, a1);
  uint64_t v17 = a1[1];

  PDFDocumentPrintf(v17, (uint64_t)">>", v11, v12, v13, v14, v15, v16, a9);
}

void write_object_or_reference(uint64_t a1, void *a2)
{
  uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    uint64_t v10 = (uint64_t)Value;
    uint64_t v11 = *(void *)(a1 + 8);
    PDFDocumentPrintReference(v11, (uint64_t)"%R", v10, v5, v6, v7, v8, v9);
    return;
  }
  CFTypeID v12 = CFGetTypeID(a2);
  if (v12 == CFDictionaryGetTypeID() || v12 == CFURLGetTypeID() || v12 == CFDataGetTypeID()) {
    goto LABEL_18;
  }
  if (_ZZZ22CGDisplayListGetTypeIDEUb_E4once != -1) {
    dispatch_once(&_ZZZ22CGDisplayListGetTypeIDEUb_E4once, &__block_literal_global_161_15385);
  }
  if (v12 == CGDisplayListGetTypeID::display_list2_type_id)
  {
    uint64_t v13 = *((void *)PDFDocumentAddFormWithDisplayList(*(void *)(a1 + 8), a2) + 2);
    if (v13) {
      uint64_t v14 = *(const void **)(v13 + 8);
    }
    else {
      uint64_t v14 = 0;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, v14);
LABEL_18:
    write_object_reference(a1, a2);
    return;
  }

  write_object(a1, a2);
}

void write_object_reference(uint64_t a1, const void *a2)
{
  uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (!Value)
  {
    uint64_t Value = (const void *)PDFXRefTableAddObject(*(void **)(*(void *)(a1 + 8) + 464));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, Value);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  }
  uint64_t v10 = *(void *)(a1 + 8);

  PDFDocumentPrintReference(v10, (uint64_t)"%R", (uint64_t)Value, v4, v5, v6, v7, v8);
}

void write_dictionary_entry(const __CFString *a1, void *a2, uint64_t a3)
{
  if (!CFEqual(a1, @"/P") && !CFEqual(a1, @"/%Stream"))
  {
    write_string(a3, a1);
    write_object_or_reference(a3, a2);
  }
}

void resample_filter_float_normalize(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v5 = a3;
  uint64_t v6 = a1;
  uint64_t v7 = 4 * a2 + 8;
  int v8 = a3;
  uint64_t v9 = a1;
  do
  {
    int v10 = *v9;
    if ((*v9 & 0x80000000) == 0) {
      break;
    }
    --v8;
    uint64_t v11 = v10;
    int v12 = v9[1] + v10;
    *uint64_t v9 = 0;
    v9[1] = v12;
    uint64_t v13 = v9 + 2;
    unsigned int v14 = ~v10;
    float v15 = 0.0;
    uint64_t v16 = (float *)(v9 + 2);
    do
    {
      float v17 = *v16++;
      float v15 = v15 + v17;
    }
    while (!__CFADD__(v10++, 1));
    *(float *)&v9[v14 + 3] = v15 + *(float *)&v9[v14 + 3];
    if (v12)
    {
      uint64_t v19 = -1 * v11;
      do
      {
        uint64_t v20 = v13 + 1;
        *uint64_t v13 = v13[v19];
        ++v13;
        --v12;
      }
      while (v12);
    }
    else
    {
      uint64_t v20 = v9 + 2;
    }
    bzero(v20, 4 * v14 + 4);
    uint64_t v9 = (int *)((char *)v9 + v7);
  }
  while (v8);
  uint64_t v21 = (_DWORD *)((char *)v6 + v7 * (v5 - 1));
  int v22 = v5;
  do
  {
    int v23 = v21[1];
    int v24 = *v21 - a4 + v23;
    if (v24 < 1) {
      break;
    }
    --v22;
    v21[1] = a4 - *v21;
    uint64_t v25 = (float *)&v21[v23 + 1];
    float v26 = 0.0;
    do
    {
      float v26 = v26 + *v25;
      *v25-- = 0.0;
      --v24;
    }
    while (v24);
    *uint64_t v25 = v26 + *v25;
    uint64_t v21 = (_DWORD *)((char *)v21 - v7);
  }
  while (v22);
  do
  {
    int v27 = v6[1];
    if (v27)
    {
      uint64_t v28 = v6 + 2;
      uint64_t v29 = 4 * (v27 - 1) + 8;
      while (*(float *)((char *)v6 + v29) == 0.0)
      {
        v29 -= 4;
        if (!--v27) {
          goto LABEL_33;
        }
      }
      int v30 = 0;
      uint64_t v31 = 2;
      while (*(float *)&v6[v31] == 0.0)
      {
        ++v30;
        ++v31;
        if (v27 == v30)
        {
          int v30 = v27;
          break;
        }
      }
      if (v30)
      {
        int v32 = v27 - v30;
        if (v27 == v30)
        {
          CFRange v34 = v6 + 2;
        }
        else
        {
          int v33 = v30;
          do
          {
            CFRange v34 = v28 + 1;
            *uint64_t v28 = v28[v30];
            ++v33;
            ++v28;
          }
          while (v27 != v33);
        }
        *v6 += v30;
        bzero(v34, 4 * (v30 - 1) + 4);
        int v27 = v32;
      }
    }
LABEL_33:
    v6[1] = v27;
    uint64_t v6 = (_DWORD *)((char *)v6 + v7);
    --v5;
  }
  while (v5);
}

void resample_filter_linear_float(uint64_t a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7 = a3;
  if (a7 == 0.0 || (double v11 = fabs(a7), v11 >= INFINITY) && v11 <= INFINITY)
  {
    if (a5 >= a2) {
      unsigned int v12 = a2;
    }
    else {
      unsigned int v12 = a5;
    }
    if (a7 == 0.0) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 1;
    }
    float __pattern4 = 1.0 / (float)v13;
    if (a3)
    {
      uint64_t v14 = 4 * a2 + 8;
      do
      {
        *(_DWORD *)a1 = 0;
        *(_DWORD *)(a1 + 4) = v13;
        memset_pattern4((void *)(a1 + 8), &__pattern4, 4 * v13);
        if (a2 > v13) {
          bzero((void *)(a1 + 8 + 4 * v13), 4 * (a2 - v13));
        }
        a1 += v14;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    double v15 = 1.0 / a7;
    double v16 = 1.0 / a7 * 0.5;
    if (a7 <= 1.0)
    {
      if (a3)
      {
        double v28 = v16 + a6;
        uint64_t v29 = 4 * a2 + 8;
        do
        {
          double v30 = (floor(v28 - v16) - (v28 - v16) + 1.0) * a7;
          unsigned int v31 = vcvtmd_s64_f64(v28 - v16);
          if (v30 <= 1.0)
          {
            int v33 = 0;
            double v32 = 1.0;
            CFRange v34 = a4;
            do
            {
              *v34++ = v30;
              double v32 = v32 - v30;
              ++v33;
              double v30 = a7;
            }
            while (v32 >= a7);
          }
          else
          {
            double v32 = 1.0;
            int v33 = 0;
            CFRange v34 = a4;
          }
          *CFRange v34 = v32;
          int v35 = v33 + 1;
          uint64_t v36 = 0;
          *(_DWORD *)a1 = v31;
          *(_DWORD *)(a1 + 4) = v35;
          double v37 = 0.0;
          uint64_t v38 = (float *)(a1 + 8);
          do
          {
            float v39 = a4[v36];
            *v38++ = v39;
            double v37 = v37 + v39;
            ++v36;
          }
          while (v35 != v36);
          double v40 = v37 + -1.0;
          if (v40 != 0.0)
          {
            float v41 = v40;
            resample_kernel_float_normalize((float *)(a1 + 8), v35, -v41);
          }
          if ((int)(a2 - v35) >= 1) {
            bzero(v38, 4 * (~v35 + a2) + 4);
          }
          double v28 = v15 + v28;
          a1 += v29;
          --v7;
        }
        while (v7);
      }
    }
    else if (a3)
    {
      double v17 = v16 + a6;
      int v18 = a2 - 2;
      uint64_t v19 = 4 * a2 + 8;
      size_t v20 = 4 * (a2 - 2);
      do
      {
        unsigned int v21 = vcvtmd_s64_f64(v17);
        double v22 = v17 - floor(v17);
        BOOL v23 = v22 < 0.5;
        if (v22 >= 0.5) {
          double v24 = -0.5;
        }
        else {
          double v24 = 0.5;
        }
        double v25 = v22 + v24;
        float v26 = v25;
        *(float *)&double v25 = 1.0 - v25;
        *(_DWORD *)(a1 + 8) = LODWORD(v25);
        *(float *)(a1 + 12) = v26;
        *(_DWORD *)a1 = v21 - v23;
        *(_DWORD *)(a1 + 4) = 2;
        if (v18 >= 1) {
          bzero((void *)(a1 + 16), v20);
        }
        double v17 = v15 + v17;
        a1 += v19;
        --v7;
      }
      while (v7);
    }
  }
}

float resample_kernel_float_normalize(float *a1, int a2, float result)
{
  if (a2)
  {
    int v3 = 0;
    float v4 = 0.0;
    int v5 = a1;
LABEL_3:
    --a2;
    uint64_t v6 = v5;
    do
    {
      if (v4 < *v6)
      {
        int v5 = v6 + 1;
        int v3 = 1;
        float v4 = *v6;
        a1 = v6;
        if (a2) {
          goto LABEL_3;
        }
        goto LABEL_12;
      }
      if (v4 == *v6) {
        ++v3;
      }
      ++v6;
      --a2;
    }
    while (a2 != -1);
    uint64_t v6 = a1;
    if (!v3) {
      return result;
    }
LABEL_12:
    float v7 = result / (float)v3;
    if (v7 != 0.0)
    {
      int v8 = v3;
      uint64_t v9 = v6;
      do
      {
        *uint64_t v9 = v7 + *v9;
        ++v9;
        --v8;
      }
      while (v8);
      double result = result - (float)(v7 * (float)v3);
    }
    int v10 = v3 >> 1;
    double result = result + v6[v10];
    v6[v10] = result;
  }
  return result;
}

void resample_filter_float(_DWORD *a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7 = a3;
  if (a7 == 0.0 || (double v12 = fabs(a7), v12 >= INFINITY) && v12 <= INFINITY)
  {
    if (a5 >= a2) {
      unsigned int v13 = a2;
    }
    else {
      unsigned int v13 = a5;
    }
    if (a7 == 0.0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 1;
    }
    float __pattern4 = 1.0 / (float)v14;
    if (a3)
    {
      uint64_t v15 = 4 * a2 + 8;
      do
      {
        *a1 = 0;
        a1[1] = v14;
        memset_pattern4(a1 + 2, &__pattern4, 4 * v14);
        if (a2 > v14) {
          bzero(&a1[v14 + 2], 4 * (a2 - v14));
        }
        a1 = (_DWORD *)((char *)a1 + v15);
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    double v17 = fmin(a7, 1.0);
    __double2 v18 = __sincos_stret(v17 * 1.57079633);
    if (v7)
    {
      double v45 = 1.0 / a7;
      do
      {
        int v19 = vcvtmd_s64_f64(a6);
        double v20 = v17 * ((double)v19 - a6);
        int v21 = (int)((v20 + 2.0) / v17);
        double v22 = v20 - (double)v21 * v17;
        double v23 = -0.0;
        if (v22 <= -2.0) {
          double v23 = v17;
        }
        double v24 = v22 + v23;
        int v25 = (int)((2.0 - (v22 + v23)) / v17);
        BOOL v26 = v22 <= -2.0;
        if (v22 + v23 + (double)v25 * v17 < 2.0) {
          ++v25;
        }
        if (v25 >= (int)a2) {
          int v27 = a2;
        }
        else {
          int v27 = v25;
        }
        if (v27)
        {
          __double2 v30 = __sincos_stret(v24 * 1.57079633);
          double cosval = v30.__cosval;
          double sinval = v30.__sinval;
          double v31 = 0.0;
          int v32 = v27;
          int v33 = a4;
          do
          {
            double v34 = 1.0;
            if (fabs(v24) >= v17 * 0.5) {
              double v34 = sinval * sinval * cosval / (v24 * v24 * 1.57079633 * 1.57079633);
            }
            *v33++ = v34;
            double v31 = v31 + v34;
            double v24 = v17 + v24;
            double v35 = v18.__sinval * cosval;
            double cosval = cosval * v18.__cosval - sinval * v18.__sinval;
            double sinval = v35 + sinval * v18.__cosval;
            --v32;
          }
          while (v32);
          *a1 = v19 - v21 + v26;
          a1[1] = v27;
          uint64_t v36 = (float *)(a1 + 2);
          float v37 = 0.0;
          uint64_t v38 = a4;
          int v39 = v27;
          double v40 = (float *)(a1 + 2);
          double v41 = 1.0 / v31;
          do
          {
            double v42 = *v38++;
            float v43 = v41 * v42;
            *v40++ = v43;
            float v37 = v37 + v43;
            --v39;
          }
          while (v39);
        }
        else
        {
          *(void *)a1 = (v19 - v21 + v26);
          uint64_t v36 = (float *)(a1 + 2);
          float v37 = 0.0;
          double v40 = (float *)(a1 + 2);
        }
        float v44 = v37 + -1.0;
        if (v44 != 0.0) {
          resample_kernel_float_normalize(v36, v27, -v44);
        }
        if ((int)(a2 - v27) >= 1) {
          bzero(v40, 4 * (~v27 + a2) + 4);
        }
        a6 = v45 + a6;
        a1 += a2 + 2;
        --v7;
      }
      while (v7);
    }
  }
}

double gstate_init(uint64_t a1)
{
  *(_OWORD *)(a1 + 104) = *(_OWORD *)&CGAffineTransformIdentity.a;
  *(void *)(a1 + 48) = 0x3FF0000000000000;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 80) = 2;
  *(void *)(a1 + 64) = 0x4024000000000000;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&CGAffineTransformIdentity.c;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)&CGAffineTransformIdentity.tx;
  DeviceGray = CGColorSpaceCreateDeviceGray();
  int v3 = CGColorSpaceCopyDefaultColor((uint64_t)DeviceGray);
  CGColorSpaceRelease(DeviceGray);
  if (v3)
  {
    CFRetain(v3);
    *(void *)(a1 + 152) = v3;
    CFRetain(v3);
    *(void *)(a1 + 160) = v3;
    CFRelease(v3);
  }
  else
  {
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
  }
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)(a1 + 168) = _Q0;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 200) = 0;
  *(void *)(a1 + 256) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_OWORD *)(a1 + 220) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_DWORD *)(a1 + 248) = 2;
  return result;
}

void gstate_clear(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2 && atomic_fetch_add_explicit((atomic_uint *volatile)v2, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    free(v2);
  }
  int v3 = *(const void **)(a1 + 152);
  if (v3) {
    CFRelease(v3);
  }
  float v4 = *(const void **)(a1 + 160);
  if (v4) {
    CFRelease(v4);
  }
  int v5 = *(const void **)(a1 + 192);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 240);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = *(const void **)(a1 + 208);
  if (v7) {
    CFRelease(v7);
  }
  int v8 = *(const void **)(a1 + 216);
  if (v8) {
    CFRelease(v8);
  }
  PDFClipMaskRelease(*(void ***)(a1 + 232));
  uint64_t v9 = *(void **)(a1 + 256);

  CGClipStackRelease(v9);
}

void PDFGStateReset(uint64_t a1)
{
  if (a1)
  {
    gstate_clear(a1);
    gstate_init(a1);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 40));
    addEmitFunction(a1, write_gstate_reset);
  }
}

void addEmitFunction(uint64_t a1, const void *a2)
{
  v7.length = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  v7.location = 0;
  FirstIndexOfuint64_t Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 40), v7, a2);
  if (FirstIndexOfValue != -1) {
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 40), FirstIndexOfValue);
  }
  int v5 = *(__CFArray **)(a1 + 40);

  CFArrayAppendValue(v5, a2);
}

void write_gstate_reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PDFWriterAnnotate(*(void *)(a1 + 16), (uint64_t)"  BEGIN: resetting gstate.", a3, a4, a5, a6, a7, a8, v23);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"Q q", v10, v11, v12, v13, v14, v15, v24);
  uint64_t v22 = *(void *)(a1 + 16);

  PDFWriterAnnotate(v22, (uint64_t)"  END: resetting gstate.", v16, v17, v18, v19, v20, v21, a9);
}

void PDFGStateEmit(CFArrayRef *a1)
{
  v4.length = CFArrayGetCount(a1[5]);
  v4.location = 0;
  CFArrayApplyFunction(a1[5], v4, (CFArrayApplierFunction)emit, a1);
  uint64_t v2 = a1[5];

  CFArrayRemoveAllValues(v2);
}

uint64_t emit(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void emitLineWidthChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void emitLineCapChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void emitLineJoinChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void emitMiterLimitChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PDFGStateSetLineDash(uint64_t a1, atomic_uint *a2)
{
  CFRange v4 = *(void **)(a1 + 72);
  if (!CGDashEqualToDash((uint64_t)v4, (uint64_t)a2))
  {
    if (v4 && atomic_fetch_add_explicit((atomic_uint *volatile)v4, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v4);
    }
    if (a2) {
      atomic_fetch_add_explicit(a2, 1u, memory_order_relaxed);
    }
    *(void *)(a1 + 72) = a2;
    addEmitFunction(a1, emitLineDashChange);
  }
}

void emitLineDashChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = *(uint64_t **)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = v10[2];
    uint64_t v12 = *(unsigned char ***)(a1 + 16);
    if (v11)
    {
      uint64_t v13 = v10[1];
      uint64_t v14 = v10 + 3;
      PDFWriterPrintf(v12, (uint64_t)"[", a3, a4, a5, a6, a7, a8, v22);
      do
      {
        uint64_t v21 = *v14++;
        PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"%f", v15, v16, v17, v18, v19, v20, v21);
        --v11;
      }
      while (v11);
      PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"] %f d", v15, v16, v17, v18, v19, v20, v13);
      return;
    }
  }
  else
  {
    uint64_t v12 = *(unsigned char ***)(a1 + 16);
  }

  PDFWriterPrintf(v12, (uint64_t)"[] 0 d", a3, a4, a5, a6, a7, a8, a9);
}

void emitRenderingIntentChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v9 = *(_DWORD *)(a1 + 80) - 1;
  if (v9 <= 3) {
    PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)off_1E52B56C0[v9], a3, a4, a5, a6, a7, a8, a9);
  }
}

void emitFlatnessChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void emitStrokeAdjustChange(uint64_t a1)
{
}

void emitEStateWithBool(uint64_t a1, const char *a2, char a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    BOOL v5 = a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (!*(void *)(v4 + 8)) {
      *(void *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    unsigned int v9 = PDFEStateCreate(*(void **)v4, a2);
    uint64_t v10 = (char *)v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 0;
      *((unsigned char *)v9 + 48) = a3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v9, (const void **)&value))
    {
      int v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l(v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      CGPDFStreamRef value = v10;
    }
    PDFEStateRelease((void **)v10);
    uint64_t v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      uint64_t v12 = CGOrderedSetCreate();
      *(void *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    uint64_t v6 = value;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v6);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void PDFGStateSetFillColor(uint64_t a1, unint64_t a2)
{
  if (!CGColorEqualToColor(*(CGColorRef *)(a1 + 152), (CGColorRef)a2))
  {
    uint64_t v11 = *(void *)(a1 + 8);
    if (a2)
    {
      if ((a2 & 0x8000000000000000) != 0) {
        ColorSpace = CGTaggedColorGetColorSpace(a2, v4, v5, v6, v7, v8, v9, v10);
      }
      else {
        ColorSpace = *(CGColorSpace **)(a2 + 24);
      }
    }
    else
    {
      ColorSpace = 0;
    }
    uint64_t v20 = PDFDocumentResolveColorSpace(v11, ColorSpace);
    unint64_t v21 = *(void *)(a1 + 152);
    if (v21)
    {
      if ((v21 & 0x8000000000000000) != 0) {
        unint64_t v21 = (unint64_t)CGTaggedColorGetColorSpace(v21, v13, v14, v15, v16, v17, v18, v19);
      }
      else {
        unint64_t v21 = *(void *)(v21 + 24);
      }
    }
    if ((PDFDocumentPrivate *)v21 != v20) {
      addEmitFunction(a1, emitFillColorSpaceChange);
    }
    uint64_t v22 = *(const void **)(a1 + 152);
    if (v22) {
      CFRelease(v22);
    }
    if (a2) {
      CFRetain((CFTypeRef)a2);
    }
    *(void *)(a1 + 152) = a2;
    addEmitFunction(a1, emitFillColorChange);
  }
}

void emitFillColorChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t ColorSpace = *(void *)(a1 + 152);
  if (ColorSpace)
  {
    if ((ColorSpace & 0x8000000000000000) != 0) {
      unint64_t ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      unint64_t ColorSpace = *(void *)(ColorSpace + 24);
    }
  }
  if (CGColorSpaceGetType((void *)ColorSpace) == 9)
  {
    emitPattern(a1, 1);
  }
  else
  {
    emitColor(a1, 1, v11, v12, v13, v14, v15, v16, a9);
  }
}

void emitColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  uint64_t v11 = 160;
  if (a2) {
    uint64_t v11 = 152;
  }
  unint64_t v12 = *(void *)(a1 + v11);
  if (v12)
  {
    if ((v12 & 0x8000000000000000) != 0) {
      uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(*(void *)(a1 + v11), a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      uint64_t NumberOfComponents = *(void *)(v12 + 56);
    }
    Components = CGColorGetComponents((CGColorRef)v12);
    uint64_t v21 = NumberOfComponents - 1;
    if (NumberOfComponents == 1) {
      goto LABEL_12;
    }
    uint64_t v20 = Components;
  }
  else
  {
    uint64_t v20 = CGColorGetComponents(0);
    uint64_t v21 = -1;
  }
  do
  {
    uint64_t v24 = *(void *)v20++;
    PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"%f", v14, v15, v16, v17, v18, v19, v24);
    --v21;
  }
  while (v21);
  if (v12)
  {
LABEL_12:
    if ((v12 & 0x8000000000000000) != 0) {
      unint64_t ColorSpace = CGTaggedColorGetColorSpace(v12, v23, v14, v15, v16, v17, v18, v19);
    }
    else {
      unint64_t ColorSpace = *(CGColorSpace **)(v12 + 24);
    }
    goto LABEL_16;
  }
  unint64_t ColorSpace = 0;
LABEL_16:
  BOOL v26 = PDFDocumentResolveColorSpace(*(void *)(a1 + 8), ColorSpace);
  int Type = CGColorSpaceGetType(v26);
  if (Type == 2)
  {
    double v34 = *(unsigned char ***)(a1 + 16);
    double v35 = "K";
    uint64_t v36 = "k";
  }
  else if (Type == 1)
  {
    double v34 = *(unsigned char ***)(a1 + 16);
    double v35 = "RG";
    uint64_t v36 = "rg";
  }
  else if (Type)
  {
    double v34 = *(unsigned char ***)(a1 + 16);
    double v35 = "SC";
    uint64_t v36 = "sc";
  }
  else
  {
    double v34 = *(unsigned char ***)(a1 + 16);
    double v35 = "G";
    uint64_t v36 = "g";
  }
  if (v9) {
    uint64_t v37 = (uint64_t)v36;
  }
  else {
    uint64_t v37 = (uint64_t)v35;
  }

  PDFWriterPrintf(v34, v37, v28, v29, v30, v31, v32, v33, a9);
}

void emitPattern(uint64_t a1, int a2)
{
  uint64_t v4 = 160;
  if (a2) {
    uint64_t v4 = 152;
  }
  uint64_t v5 = *(void *)(a1 + v4);
  if (v5 < 1) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(_DWORD **)(v5 + 32);
  }
  uint64_t v7 = *(void *)(a1 + 8);
  long long v43 = *(_OWORD *)(a1 + 104);
  long long v44 = *(_OWORD *)(a1 + 120);
  long long v45 = *(_OWORD *)(a1 + 136);
  uint64_t v8 = *(void **)(v7 + 376);
  if (!v8)
  {
    uint64_t v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8) {
      *(void *)uint64_t v8 = v7;
    }
    *(void *)(v7 + 376) = v8;
  }
  if (v8) {
    BOOL v9 = v6 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    uint64_t Value = 0;
  }
  else
  {
    CFDictionaryRef Mutable = (const __CFDictionary *)*((void *)v8 + 1);
    if (!Mutable)
    {
      CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &patternKeyCallbacks, &patternCallbacks);
      *((void *)v8 + 1) = Mutable;
    }
    uint64_t key = 0;
    LODWORD(key) = v6[4];
    long long v48 = v44;
    long long v49 = v45;
    long long v47 = v43;
    uint64_t Value = CFDictionaryGetValue(Mutable, &key);
    if (!Value)
    {
      uint64_t v12 = *(void *)v8;
      uint64_t v13 = (*((_DWORD *)v8 + 6) + 1);
      *((_DWORD *)v8 + 6) = v13;
      uint64_t Value = malloc_type_calloc(1uLL, 0x68uLL, 0x33BCE901uLL);
      __CFSetLastAllocationEventName();
      if (Value)
      {
        *(_DWORD *)uint64_t Value = 1;
        Value[1] = v12;
        Value[2] = PDFContentStreamCreate(v12, 0);
        CFRetain(v6);
        Value[3] = v6;
        *((_OWORD *)Value + 2) = v43;
        *((_OWORD *)Value + 3) = v44;
        *((_OWORD *)Value + 4) = v45;
        snprintf_l((char *)Value + 80, 0x10uLL, 0, "P%lu", v13);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)v8 + 1), &key, Value);
      PDFPatternRelease(Value, v14, v15, v16, v17, v18, v19, v20);
    }
    uint64_t v21 = (const void **)*((void *)v8 + 2);
    if (!v21)
    {
      uint64_t v21 = CGOrderedSetCreate();
      *((void *)v8 + 2) = v21;
    }
    CGOrderedSetAddValue((CFSetRef *)v21, Value);
  }
  uint64_t v22 = *(void *)(a1 + 32);
  uint64_t v23 = *(const void ***)(v22 + 72);
  if (!v23)
  {
    uint64_t v23 = CGOrderedSetCreate();
    *(void *)(v22 + 72) = v23;
  }
  CGOrderedSetAddValue((CFSetRef *)v23, Value);
  if (v5)
  {
    unint64_t v31 = v5 < 0 ? CGTaggedColorGetNumberOfComponents(v5, v24, v25, v26, v27, v28, v29, v30) : *(void *)(v5 + 56);
    if (v31 >= 2)
    {
      Components = CGColorGetComponents((CGColorRef)v5);
      unint64_t v33 = v31 - 1;
      do
      {
        uint64_t v34 = *(void *)Components++;
        PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"%f", v25, v26, v27, v28, v29, v30, v34);
        --v33;
      }
      while (v33);
    }
  }
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N", v25, v26, v27, v28, v29, v30, (uint64_t)(Value + 10));
  if (a2) {
    double v41 = "scn";
  }
  else {
    double v41 = "SCN";
  }
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)v41, v35, v36, v37, v38, v39, v40, v42);
}

void emitFillColorSpaceChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void emitColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v9 = a2;
  uint64_t v11 = 160;
  if (a2) {
    uint64_t v11 = 152;
  }
  unint64_t v12 = *(void *)(a1 + v11);
  if (v12)
  {
    if ((v12 & 0x8000000000000000) != 0) {
      unint64_t ColorSpace = CGTaggedColorGetColorSpace(v12, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      unint64_t ColorSpace = *(CGColorSpace **)(v12 + 24);
    }
  }
  else
  {
    unint64_t ColorSpace = 0;
  }
  uint64_t v14 = PDFDocumentResolveColorSpace(*(void *)(a1 + 8), ColorSpace);
  if (!v14) {
    _CGHandleAssert("emitColorSpace", 471, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ContentStreams/PDFGState.c", "space != NULL", "PDF document colorspace missing", v15, v16, v17, v45);
  }
  uint64_t v18 = v14;
  unsigned int Type = CGColorSpaceGetType(v14);
  if (Type >= 3)
  {
    if (Type == 9 && !*(void *)(*((void *)v18 + 3) + 48))
    {
      long long v44 = "CS";
      if (v9) {
        long long v44 = "cs";
      }
      PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/Pattern %s", v20, v21, v22, v23, v24, v25, (uint64_t)v44);
    }
    else
    {
      uint64_t v26 = PDFDocumentAddColorSpace(*(void *)(a1 + 8), v18);
      uint64_t v27 = *(void *)(a1 + 32);
      uint64_t v28 = *(const void ***)(v27 + 32);
      if (!v28)
      {
        uint64_t v28 = CGOrderedSetCreate();
        *(void *)(v27 + 32) = v28;
      }
      CGOrderedSetAddValue((CFSetRef *)v28, v26);
      uint64_t v35 = (uint64_t)v26 + 40;
      if (!v26) {
        uint64_t v35 = 0;
      }
      PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N", v29, v30, v31, v32, v33, v34, v35);
      uint64_t v42 = *(unsigned char ***)(a1 + 16);
      if (v9) {
        long long v43 = "cs";
      }
      else {
        long long v43 = "CS";
      }
      PDFWriterPrintf(v42, (uint64_t)v43, v36, v37, v38, v39, v40, v41, a9);
    }
  }
}

void PDFGStateSetStrokeColor(uint64_t a1, unint64_t a2)
{
  if (!CGColorEqualToColor(*(CGColorRef *)(a1 + 160), (CGColorRef)a2))
  {
    uint64_t v11 = *(void *)(a1 + 8);
    if (a2)
    {
      if ((a2 & 0x8000000000000000) != 0) {
        unint64_t ColorSpace = CGTaggedColorGetColorSpace(a2, v4, v5, v6, v7, v8, v9, v10);
      }
      else {
        unint64_t ColorSpace = *(CGColorSpace **)(a2 + 24);
      }
    }
    else
    {
      unint64_t ColorSpace = 0;
    }
    uint64_t v20 = PDFDocumentResolveColorSpace(v11, ColorSpace);
    unint64_t v21 = *(void *)(a1 + 160);
    if (v21)
    {
      if ((v21 & 0x8000000000000000) != 0) {
        unint64_t v21 = (unint64_t)CGTaggedColorGetColorSpace(v21, v13, v14, v15, v16, v17, v18, v19);
      }
      else {
        unint64_t v21 = *(void *)(v21 + 24);
      }
    }
    if ((PDFDocumentPrivate *)v21 != v20) {
      addEmitFunction(a1, emitStrokeColorSpaceChange);
    }
    uint64_t v22 = *(const void **)(a1 + 160);
    if (v22) {
      CFRelease(v22);
    }
    if (a2) {
      CFRetain((CFTypeRef)a2);
    }
    *(void *)(a1 + 160) = a2;
    addEmitFunction(a1, emitStrokeColorChange);
  }
}

void emitStrokeColorChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unint64_t ColorSpace = *(void *)(a1 + 160);
  if (ColorSpace)
  {
    if ((ColorSpace & 0x8000000000000000) != 0) {
      unint64_t ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      unint64_t ColorSpace = *(void *)(ColorSpace + 24);
    }
  }
  if (CGColorSpaceGetType((void *)ColorSpace) == 9)
  {
    emitPattern(a1, 0);
  }
  else
  {
    emitColor(a1, 0, v11, v12, v13, v14, v15, v16, a9);
  }
}

void emitStrokeColorSpaceChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PDFGStateSetPatternMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  int8x16_t v11 = *(int8x16_t *)a2;
  float64x2_t v12 = *(float64x2_t *)(a2 + 16);
  int8x16_t v13 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 32), *(float64x2_t *)a2, a9), v12, a10);
  *(int8x16_t *)(a2 + 32) = v13;
  if (*(double *)(a1 + 104) != *(double *)v11.i64
    || (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 112), (float64x2_t)vextq_s8(v11, (int8x16_t)v12, 8uLL)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 128), (float64x2_t)vextq_s8((int8x16_t)v12, v13, 8uLL)))), 0xFuLL))) & 1) == 0|| *(double *)(a1 + 144) != *(double *)&v13.i64[1])
  {
    float64x2_t v14 = *(float64x2_t *)a2;
    long long v15 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 136) = v15;
    *(float64x2_t *)(a1 + 104) = v14;
    unint64_t ColorSpace = *(void *)(a1 + 152);
    if (ColorSpace)
    {
      if ((ColorSpace & 0x8000000000000000) != 0) {
        unint64_t ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, a2, a3, a4, a5, a6, a7, a8);
      }
      else {
        unint64_t ColorSpace = *(void *)(ColorSpace + 24);
      }
    }
    if (CGColorSpaceGetType((void *)ColorSpace) == 9) {
      addEmitFunction(a1, emitFillColorChange);
    }
    unint64_t v24 = *(void *)(a1 + 160);
    if (v24)
    {
      if ((v24 & 0x8000000000000000) != 0) {
        unint64_t v24 = (unint64_t)CGTaggedColorGetColorSpace(v24, v17, v18, v19, v20, v21, v22, v23);
      }
      else {
        unint64_t v24 = *(void *)(v24 + 24);
      }
    }
    if (CGColorSpaceGetType((void *)v24) == 9)
    {
      addEmitFunction(a1, emitStrokeColorChange);
    }
  }
}

void emitNonStrokeAlphaChange(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(_DWORD *)(v1 + 4);
  if (v2 <= 0)
  {
    *(_DWORD *)(v1 + 4) = 1;
    int v3 = (_DWORD *)(v1 + 8);
LABEL_6:
    _DWORD *v3 = 4;
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    int v4 = *(_DWORD *)(v1 + 8);
    int v3 = (_DWORD *)(v1 + 8);
    if (v4 <= 3) {
      goto LABEL_6;
    }
  }
LABEL_7:
  emitEStateWithReal(a1, "ca", *(double *)(a1 + 168));
}

void emitEStateWithReal(uint64_t a1, const char *a2, double a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    BOOL v5 = a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (!*(void *)(v4 + 8)) {
      *(void *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    uint64_t v9 = PDFEStateCreate(*(void **)v4, a2);
    uint64_t v10 = (char *)v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 2;
      *((double *)v9 + 6) = floor(a3 * 10000.0 + 0.5) / 10000.0;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v9, (const void **)&value))
    {
      int v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l(v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      CGPDFStreamRef value = v10;
    }
    PDFEStateRelease((void **)v10);
    float64x2_t v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      float64x2_t v12 = CGOrderedSetCreate();
      *(void *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    uint64_t v6 = value;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v6);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void emitStrokeAlphaChange(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(_DWORD *)(v1 + 4);
  if (v2 <= 0)
  {
    *(_DWORD *)(v1 + 4) = 1;
    int v3 = (_DWORD *)(v1 + 8);
LABEL_6:
    _DWORD *v3 = 4;
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    int v4 = *(_DWORD *)(v1 + 8);
    int v3 = (_DWORD *)(v1 + 8);
    if (v4 <= 3) {
      goto LABEL_6;
    }
  }
LABEL_7:
  emitEStateWithReal(a1, "CA", *(double *)(a1 + 176));
}

void emitTextDrawingModeChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PDFGStateSetStyle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v4 = *(const void **)(a1 + 192);
  if (!CGStyleEqualToStyle((uint64_t)v4, a2))
  {
    if (v4) {
      CFRelease(v4);
    }
    if (v2)
    {
      if (*(_DWORD *)(v2 + 20) == 1 && *(double *)(v2 + 40) == 45.0 && *(double *)(v2 + 80) == 1.0) {
        CFRetain((CFTypeRef)v2);
      }
      else {
        uint64_t v2 = 0;
      }
    }
    *(void *)(a1 + 192) = v2;
    addEmitFunction(a1, emitStyleChange);
  }
}

void emitStyleChange(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    int v3 = *(const void **)(a1 + 192);
    if (!*(void *)(v2 + 8)) {
      *(void *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    int v4 = PDFEStateCreate(*(void **)v2, "AAPL:ST");
    BOOL v5 = v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 5;
      if (v3) {
        CFRetain(v3);
      }
      v5[6] = (void *)v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v5, (const void **)&value))
    {
      int v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l((char *)v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      CGPDFStreamRef value = v5;
    }
    PDFEStateRelease(v5);
    uint64_t v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      uint64_t v7 = CGOrderedSetCreate();
      *(void *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    uint64_t v8 = value;
  }
  else
  {
    uint64_t v8 = 0;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v8);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void emitNonStrokeOverprintChange(uint64_t a1)
{
}

void PDFGStateSetStrokeOverprint(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 201) != a2)
  {
    *(unsigned char *)(a1 + 201) = a2;
    addEmitFunction(a1, emitStrokeOverprintChange);
    if (*(unsigned __int8 *)(a1 + 200) != *(unsigned __int8 *)(a1 + 201))
    {
      addEmitFunction(a1, emitNonStrokeOverprintChange);
    }
  }
}

void emitStrokeOverprintChange(uint64_t a1)
{
}

void PDFGStateSetOverprintMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a2)
  {
    if (*(unsigned char *)(*(void *)(a1 + 8) + 91))
    {
      unint64_t v10 = *(void *)(a1 + 152);
      if (v10)
      {
        if ((v10 & 0x8000000000000000) != 0)
        {
          unint64_t ColorSpace = CGTaggedColorGetColorSpace(v10, a2, a3, a4, a5, a6, a7, a8);
          if (!ColorSpace) {
            goto LABEL_12;
          }
        }
        else
        {
          unint64_t ColorSpace = *(CGColorSpace **)(v10 + 24);
          if (!ColorSpace) {
            goto LABEL_12;
          }
        }
        uint64_t v12 = PDFDocumentResolveColorSpace(*(void *)(a1 + 8), ColorSpace);
        if (v12 && *(_DWORD *)(*((void *)v12 + 3) + 28) == 2 && CGColorSpaceGetType(v12) == 6) {
          int v8 = 0;
        }
      }
    }
  }
LABEL_12:
  if (*(_DWORD *)(a1 + 204) != v8)
  {
    *(_DWORD *)(a1 + 204) = v8;
    addEmitFunction(a1, emitOverprintModeChange);
  }
}

void emitOverprintModeChange(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    int v3 = *(_DWORD *)(a1 + 204);
    if (!*(void *)(v2 + 8)) {
      *(void *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    int v4 = PDFEStateCreate(*(void **)v2, "OPM");
    BOOL v5 = (char *)v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 1;
      *((_DWORD *)v4 + 12) = v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v4, (const void **)&value))
    {
      int v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l(v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      CGPDFStreamRef value = v5;
    }
    PDFEStateRelease((void **)v5);
    uint64_t v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      uint64_t v7 = CGOrderedSetCreate();
      *(void *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    int v8 = value;
  }
  else
  {
    int v8 = 0;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v8);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void PDFGStateSetBlackGeneration(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 208);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 208) = cf;
    addEmitFunction(a1, emitBlackGenerationChange);
  }
}

void emitBlackGenerationChange(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 208);
  if (v1) {
    emitEStateWithFunction(a1, "BG", v1);
  }
}

void emitEStateWithFunction(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    BOOL v5 = a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    int v6 = 0;
  }
  else
  {
    if (!*(void *)(v4 + 8)) {
      *(void *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    uint64_t v9 = PDFEStateCreate(*(void **)v4, a2);
    uint64_t v10 = v9;
    if (v9)
    {
      *((_DWORD *)v9 + 11) = 4;
      if (a3) {
        CFRetain(a3);
      }
      v10[6] = (void *)a3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v10, (const void **)&value))
    {
      int v11 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v11;
      snprintf_l((char *)v10 + 24, 0x10uLL, 0, "Gs%u", v11);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v10);
      CGPDFStreamRef value = v10;
    }
    PDFEStateRelease(v10);
    uint64_t v12 = *(const void ***)(v4 + 16);
    if (!v12)
    {
      uint64_t v12 = CGOrderedSetCreate();
      *(void *)(v4 + 16) = v12;
    }
    CGOrderedSetAddValue((CFSetRef *)v12, value);
    int v6 = value;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v6);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v13, v14, v15, v16, v17, v18, (uint64_t)v6 + 24);
}

void PDFGStateSetUndercolorRemoval(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 216) = cf;
    addEmitFunction(a1, emitUndercolorRemovalChange);
  }
}

void emitUndercolorRemovalChange(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 216);
  if (v1) {
    emitEStateWithFunction(a1, "UCR", v1);
  }
}

void emitSmoothnessChange(uint64_t a1)
{
}

void emitBlendModeChange(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 248) - 13;
  if (v2 > 0xE) {
    CFTypeRef v3 = "Normal";
  }
  else {
    CFTypeRef v3 = off_1E52B56E0[v2];
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    if (!*(void *)(v4 + 8)) {
      *(void *)(v4 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    BOOL v5 = PDFEStateCreate(*(void **)v4, "BM");
    int v6 = v5;
    if (v5)
    {
      *((_DWORD *)v5 + 11) = 3;
      size_t v7 = strlen(v3);
      int v8 = (char *)malloc_type_malloc(v7 + 1, 0x566C45D1uLL);
      __CFSetLastAllocationEventName();
      double v6[6] = v8;
      strcpy(v8, v3);
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v4 + 8), v6, (const void **)&value))
    {
      int v9 = *(_DWORD *)(v4 + 24) + 1;
      *(_DWORD *)(v4 + 24) = v9;
      snprintf_l((char *)v6 + 24, 0x10uLL, 0, "Gs%u", v9);
      CFSetAddValue(*(CFMutableSetRef *)(v4 + 8), v6);
      CGPDFStreamRef value = v6;
    }
    PDFEStateRelease(v6);
    uint64_t v10 = *(const void ***)(v4 + 16);
    if (!v10)
    {
      uint64_t v10 = CGOrderedSetCreate();
      *(void *)(v4 + 16) = v10;
    }
    CGOrderedSetAddValue((CFSetRef *)v10, value);
    int v11 = value;
  }
  else
  {
    int v11 = 0;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v11);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v12, v13, v14, v15, v16, v17, (uint64_t)v11 + 24);
}

void PDFGStateSetSoftMask(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 240);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 240) = cf;
    addEmitFunction(a1, emitSoftMaskChange);
  }
}

void emitSoftMaskChange(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    CFTypeRef v3 = *(const void **)(a1 + 240);
    if (!*(void *)(v2 + 8)) {
      *(void *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    uint64_t v4 = PDFEStateCreate(*(void **)v2, "SMask");
    BOOL v5 = v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 6;
      if (v3) {
        CFRetain(v3);
      }
      v5[6] = (void *)v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v5, (const void **)&value))
    {
      int v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l((char *)v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      CGPDFStreamRef value = v5;
    }
    PDFEStateRelease(v5);
    size_t v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      size_t v7 = CGOrderedSetCreate();
      *(void *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    int v8 = value;
  }
  else
  {
    int v8 = 0;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v8);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void PDFGStateSetClipStack(uint64_t a1, __CFArray *a2)
{
  uint64_t v2 = *(__CFArray **)(a1 + 256);
  if (v2 != a2)
  {
    CFMutableArrayRef Mutable = a2;
    BOOL v5 = !v2 || a2 == 0;
    if (v5 || *((_DWORD *)v2 + 1) != *((_DWORD *)a2 + 1))
    {
      PDFGStateReset(a1);
      CGClipStackRelease(*(void **)(a1 + 256));
      *(void *)(a1 + 256) = CGClipStackCreateMutableCopy((uint64_t)Mutable);
      addEmitFunction(a1, emitClipStackChange);
      if (Mutable)
      {
        uint64_t v6 = *((void *)Mutable + 15);
        if (v6)
        {
          uint64_t v7 = 0;
          int v8 = (char *)Mutable + 128;
          while (1)
          {
            uint64_t v9 = (uint64_t)v8;
            if (*((void *)Mutable + 14) != 3) {
              uint64_t v9 = *((void *)Mutable + 16) + 8 * v7;
            }
            uint64_t v10 = *(const void **)v9;
            if (*(unsigned char *)(*(void *)v9 + 8) == 3) {
              break;
            }
            ++v7;
            v8 += 8;
            if (!--v6) {
              goto LABEL_14;
            }
          }
          CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
          CFArrayAppendValue(Mutable, v10);
        }
        else
        {
LABEL_14:
          CFMutableArrayRef Mutable = 0;
        }
      }
      uint64_t v11 = *(void *)(a1 + 8);
      uint64_t v12 = *(uint64_t **)(v11 + 392);
      if (!v12)
      {
        uint64_t v12 = (uint64_t *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
        __CFSetLastAllocationEventName();
        if (v12) {
          *uint64_t v12 = v11;
        }
        *(void *)(v11 + 392) = v12;
      }
      if (v12) {
        BOOL v13 = Mutable == 0;
      }
      else {
        BOOL v13 = 1;
      }
      if (v13)
      {
        uint64_t v14 = 0;
      }
      else
      {
        if (!v12[1]) {
          v12[1] = (uint64_t)CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (const CFSetCallBacks *)&callbacks_1058);
        }
        CGPDFStreamRef value = 0;
        uint64_t v15 = *v12;
        if (*v12 && (CFIndex Count = CFArrayGetCount(Mutable)) != 0)
        {
          CFIndex v17 = Count;
          uint64_t v18 = malloc_type_calloc(1uLL, 8 * Count + 40, 0x33BCE901uLL);
          __CFSetLastAllocationEventName();
          if (v18)
          {
            CFIndex v19 = 0;
            *(_DWORD *)uint64_t v18 = 1;
            v18[1] = v15;
            v18[2] = 0;
            *((unsigned char *)v18 + 24) = 0;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v19);
              if (*((unsigned char *)ValueAtIndex + 8) == 3)
              {
                uint64_t v21 = (atomic_uint *)*((void *)ValueAtIndex + 3);
                if (v21) {
                  atomic_fetch_add_explicit(v21, 1u, memory_order_relaxed);
                }
              }
              else
              {
                uint64_t v21 = 0;
              }
              v18[v19++ + 5] = v21;
            }
            while (v17 != v19);
            v18[4] = v17;
          }
        }
        else
        {
          uint64_t v18 = 0;
        }
        if (!CFSetGetValueIfPresent((CFSetRef)v12[1], v18, (const void **)&value))
        {
          CFSetAddValue((CFMutableSetRef)v12[1], v18);
          CGPDFStreamRef value = v18;
        }
        PDFClipMaskRelease((void **)v18);
        uint64_t v22 = (const void **)v12[2];
        if (!v22)
        {
          uint64_t v22 = CGOrderedSetCreate();
          v12[2] = (uint64_t)v22;
        }
        CGOrderedSetAddValue((CFSetRef *)v22, value);
        uint64_t v14 = value;
      }
      uint64_t v23 = *(void ***)(a1 + 232);
      if (!PDFClipMaskEqualToClipMask((uint64_t)v23, (uint64_t)v14))
      {
        PDFClipMaskRelease(v23);
        if (v14) {
          ++*v14;
        }
        *(void *)(a1 + 232) = v14;
        addEmitFunction(a1, emitClipMaskChange);
      }
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }
  }
}

void emitClipMaskChange(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    CFTypeRef v3 = *(_DWORD **)(a1 + 232);
    if (!*(void *)(v2 + 8)) {
      *(void *)(v2 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &callbacks_14821);
    }
    CGPDFStreamRef value = 0;
    uint64_t v4 = PDFEStateCreate(*(void **)v2, "SMask");
    BOOL v5 = (char *)v4;
    if (v4)
    {
      *((_DWORD *)v4 + 11) = 7;
      if (v3) {
        ++*v3;
      }
      v4[6] = v3;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v2 + 8), v4, (const void **)&value))
    {
      int v6 = *(_DWORD *)(v2 + 24) + 1;
      *(_DWORD *)(v2 + 24) = v6;
      snprintf_l(v5 + 24, 0x10uLL, 0, "Gs%u", v6);
      CFSetAddValue(*(CFMutableSetRef *)(v2 + 8), v5);
      CGPDFStreamRef value = v5;
    }
    PDFEStateRelease((void **)v5);
    uint64_t v7 = *(const void ***)(v2 + 16);
    if (!v7)
    {
      uint64_t v7 = CGOrderedSetCreate();
      *(void *)(v2 + 16) = v7;
    }
    CGOrderedSetAddValue((CFSetRef *)v7, value);
    int v8 = value;
  }
  else
  {
    int v8 = 0;
  }
  PDFResourceSetAddEState(*(void *)(a1 + 32), v8);
  PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"/%N gs", v9, v10, v11, v12, v13, v14, (uint64_t)v8 + 24);
}

void emitClipStackChange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFWriterAnnotate(*(void *)(a1 + 16), (uint64_t)"  BEGIN: synchronizing clip.", a3, a4, a5, a6, a7, a8, v75);
  uint64_t v15 = *(void *)(a1 + 256);
  uint64_t v16 = &CGRectInfinite;
  if (v15)
  {
    uint64_t v17 = *(void *)(v15 + 120);
    if (v17)
    {
      uint64_t v18 = 0;
      CFArrayRef v19 = 0;
      CFArrayRef v20 = 0;
      CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      uint64_t v22 = 128;
      while (2)
      {
        uint64_t v23 = *(void *)(a1 + 256);
        if (*(void *)(v23 + 112) == 3) {
          uint64_t v24 = v23 + v22;
        }
        else {
          uint64_t v24 = *(void *)(v23 + 128) + 8 * v18;
        }
        uint64_t v25 = *(const void **)v24;
        switch(*(unsigned char *)(*(void *)v24 + 8))
        {
          case 2:
            if (v19)
            {
              CFMutableArrayRef Mutable = v19;
            }
            else
            {
              CFMutableArrayRef Mutable = CFArrayCreateMutable(v21, 0, 0);
              CFArrayRef v19 = Mutable;
            }
            goto LABEL_14;
          case 3:
            goto LABEL_15;
          case 4:
            if (v20)
            {
              CFMutableArrayRef Mutable = v20;
            }
            else
            {
              CFMutableArrayRef Mutable = CFArrayCreateMutable(v21, 0, 0);
              CFArrayRef v20 = Mutable;
            }
LABEL_14:
            CFArrayAppendValue(Mutable, v25);
LABEL_15:
            ++v18;
            v22 += 8;
            if (v17 != v18) {
              continue;
            }
            if (v19)
            {
              CFIndex Count = CFArrayGetCount(v19);
              if (Count)
              {
                CFIndex v28 = Count;
                for (CFIndex i = 0; i != v28; ++i)
                {
                  ValueAtIndedouble x = CFArrayGetValueAtIndex(v19, i);
                  PDFWriteClipPath(*(unsigned char ***)(a1 + 16), (uint64_t)ValueAtIndex, v31, v32, v33, v34, v35, v36);
                }
              }
              CFRelease(v19);
            }
            if (v20)
            {
              CFIndex v37 = CFArrayGetCount(v20);
              if (v37)
              {
                CFIndex v38 = v37;
                for (CFIndex j = 0; j != v38; ++j)
                {
                  uint64_t v40 = CFArrayGetValueAtIndex(v20, j);
                  PDFWriterAnnotate(*(void *)(a1 + 16), (uint64_t)"Beginning glyph clip.", v41, v42, v43, v44, v45, v46, v76);
                  PDFWriteClipPath(*(unsigned char ***)(a1 + 16), (uint64_t)v40, v47, v48, v49, v50, v51, v52);
                  PDFWriterAnnotate(*(void *)(a1 + 16), (uint64_t)"Ending glyph clip.", v53, v54, v55, v56, v57, v58, v77);
                }
              }
              CFRelease(v20);
            }
            break;
          default:
            abort();
        }
        break;
      }
    }
    p_height = &CGRectInfinite.size.height;
    p_y = &CGRectInfinite.origin.y;
    uint64_t v61 = *(CGSize **)(a1 + 256);
    uint64_t v62 = (const CGRect *)&v61[1];
    uint64_t v63 = &v61[1].height;
    uint64_t v64 = &v61[2].height;
    BOOL v65 = v61 == 0;
    if (v61) {
      p_size = v61 + 2;
    }
    else {
      p_size = &CGRectInfinite.size;
    }
    if (!v65)
    {
      p_y = v63;
      uint64_t v16 = v62;
      p_height = v64;
    }
  }
  else
  {
    p_height = &CGRectInfinite.size.height;
    p_y = &CGRectInfinite.origin.y;
    p_size = &CGRectInfinite.size;
  }
  double v67 = *p_height;
  double x = v16->origin.x;
  double v69 = *p_y;
  double width = p_size->width;
  *(double *)&long long v78 = x;
  *((double *)&v78 + 1) = v69;
  *(double *)&long long v79 = width;
  *((double *)&v79 + 1) = v67;
  if (x != -8.98846567e307 || v69 != -8.98846567e307 || width != 1.79769313e308 || v67 != 1.79769313e308)
  {
    if (x == INFINITY || v69 == INFINITY)
    {
      long long v78 = 0u;
      long long v79 = 0u;
    }
    PDFWriterPrintf(*(unsigned char ***)(a1 + 16), (uint64_t)"%*r re W n", v9, v10, v11, v12, v13, v14, (uint64_t)&v78);
  }
  PDFWriterAnnotate(*(void *)(a1 + 16), (uint64_t)"  END: synchronizing clip.", v9, v10, v11, v12, v13, v14, v76);
}

uint64_t w16_sample_Wf(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v88 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v86 = *(_DWORD *)(result + 188);
  uint64_t v90 = *(void *)(result + 88);
  uint64_t v91 = *(void *)(result + 152) - 4;
  uint64_t v11 = *(void *)(result + 144) - 1;
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  unint64_t v14 = v5 + (v12 * v7) + 4 * (v13 - 1);
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 4;
  uint64_t v89 = *(void *)(result + 72);
  uint64_t v87 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v89)
    {
      if (a3 <= v90)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v87;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v90;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_39;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v87;
        unsigned int v25 = v86 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v89 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_39;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v87;
      unsigned int v25 = v86 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v86;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    v91 += 4;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v88)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_26;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v88;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_39;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v86;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_26:
  if (v25 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v4 + SHIDWORD(v26) * (uint64_t)v6;
  unint64_t v38 = (v31 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v39 = v37 + v38;
  uint64_t v40 = *(float **)(result + 32);
  if (v15 >= v37 + v38) {
    uint64_t v41 = (float *)(v37 + v38);
  }
  else {
    uint64_t v41 = (float *)v15;
  }
  if (v41 < v40) {
    uint64_t v41 = *(float **)(result + 32);
  }
  if (v5)
  {
    unint64_t v42 = v5 + (int)v36 * (uint64_t)v7 + v38;
    uint64_t v43 = *(float **)(result + 40);
    if (v14 >= v42) {
      uint64_t v44 = (float *)v42;
    }
    else {
      uint64_t v44 = (float *)v14;
    }
    if (v44 >= v43) {
      uint64_t v43 = v44;
    }
    float v45 = *v43;
  }
  else
  {
    unint64_t v42 = 0;
    float v45 = 1.0;
  }
  uint64_t v46 = v88;
  float v47 = *v41;
  if (v8)
  {
    unsigned int v48 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_45:
    int v49 = v48 & 0xF;
    unsigned int v50 = v48 >> 8;
    int v51 = HIBYTE(v48) & 3;
    if (v49 == 1)
    {
      int v65 = SBYTE1(v48);
      uint64_t v66 = (float *)(v39 + (char)v50 * (uint64_t)v6);
      if (v15 < (unint64_t)v66) {
        uint64_t v66 = (float *)v15;
      }
      if (v66 < v40) {
        uint64_t v66 = v40;
      }
      float v67 = 1.0;
      if (v5)
      {
        uint64_t v68 = (float *)(v42 + v65 * (uint64_t)v7);
        if (v14 < (unint64_t)v68) {
          uint64_t v68 = (float *)v14;
        }
        if ((unint64_t)v68 < *(void *)(result + 40)) {
          uint64_t v68 = *(float **)(result + 40);
        }
        float v67 = *v68;
      }
      float v69 = interpolate_waf[2 * v51 + 1];
      float v47 = (float)(v47 - (float)(v47 * v69)) + (float)(*v66 * v69);
      float v45 = (float)(v45 - (float)(v45 * v69)) + (float)(v67 * v69);
LABEL_80:
      uint64_t v46 = v88;
    }
    else
    {
      if (v49 != 2)
      {
        if (v49 == 3)
        {
          uint64_t v52 = (float *)(v39 + 4 * SBYTE2(v48));
          if (v15 >= (unint64_t)v52) {
            uint64_t v53 = v52;
          }
          else {
            uint64_t v53 = (float *)v15;
          }
          if (v53 < v40) {
            uint64_t v53 = v40;
          }
          float v54 = *v53;
          uint64_t v55 = (float *)((char *)v52 + SBYTE1(v48) * (uint64_t)v6);
          if (v15 < (unint64_t)v55) {
            uint64_t v55 = (float *)v15;
          }
          if (v55 < v40) {
            uint64_t v55 = v40;
          }
          float v56 = *v55;
          float v57 = 1.0;
          float v58 = 1.0;
          if (v5)
          {
            unint64_t v59 = v42 + 4 * SBYTE2(v48);
            unint64_t v60 = *(void *)(result + 40);
            if (v14 >= v59) {
              uint64_t v61 = (float *)(v42 + 4 * SBYTE2(v48));
            }
            else {
              uint64_t v61 = (float *)v14;
            }
            if ((unint64_t)v61 < v60) {
              uint64_t v61 = *(float **)(result + 40);
            }
            float v57 = *v61;
            uint64_t v62 = (float *)(v59 + SBYTE1(v48) * (uint64_t)v7);
            if (v14 < (unint64_t)v62) {
              uint64_t v62 = (float *)v14;
            }
            if ((unint64_t)v62 < v60) {
              uint64_t v62 = *(float **)(result + 40);
            }
            float v58 = *v62;
          }
          float v63 = interpolate_waf[2 * v51 + 1];
          float v64 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
          float v47 = (float)((float)((float)(v47 - (float)(v47 * v63)) + (float)(v54 * v63))
                      - (float)((float)((float)(v47 - (float)(v47 * v63)) + (float)(v54 * v63)) * v64))
              + (float)((float)((float)(v54 - (float)(v54 * v63)) + (float)(v56 * v63)) * v64);
          float v45 = (float)((float)((float)(v45 - (float)(v45 * v63)) + (float)(v57 * v63))
                      - (float)((float)((float)(v45 - (float)(v45 * v63)) + (float)(v57 * v63)) * v64))
              + (float)((float)((float)(v57 - (float)(v57 * v63)) + (float)(v58 * v63)) * v64);
        }
        goto LABEL_80;
      }
      unint64_t v70 = (float *)(v39 + 4 * SBYTE2(v48));
      if (v15 < (unint64_t)v70) {
        unint64_t v70 = (float *)v15;
      }
      if (v70 < v40) {
        unint64_t v70 = v40;
      }
      float v71 = 1.0;
      uint64_t v46 = v88;
      if (v5)
      {
        float v72 = (float *)(v42 + 4 * SBYTE2(v48));
        if (v14 < (unint64_t)v72) {
          float v72 = (float *)v14;
        }
        if ((unint64_t)v72 < *(void *)(result + 40)) {
          float v72 = *(float **)(result + 40);
        }
        float v71 = *v72;
      }
      float v73 = interpolate_waf[2 * ((v48 >> 28) & 3) + 1];
      float v47 = (float)(v47 - (float)(v47 * v73)) + (float)(*v70 * v73);
      float v45 = (float)(v45 - (float)(v45 * v73)) + (float)(v71 * v73);
    }
  }
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  a3 += v9;
  uint64_t v76 = v90 - a3;
  a2 += v10;
  uint64_t v77 = v46 - a2;
  while (1)
  {
    if (v45 <= 0.0)
    {
      int v80 = 0;
    }
    else
    {
      int v78 = (int)(float)((float)(v45 * 65535.0) + 0.5);
      if (v45 > 1.0)
      {
        int v78 = 0xFFFF;
        float v45 = 1.0;
      }
      int v79 = v78;
      if (v47 <= v45)
      {
        if (v47 >= 0.0) {
          int v79 = (int)(float)((float)(v47 * 65535.0) + 0.5);
        }
        else {
          int v79 = 0;
        }
      }
      int v80 = v79 | (v78 << 16);
    }
    *(_DWORD *)(v91 + 4 + 4 * v75) = v80;
    *(unsigned char *)(v11 + 1 + v75) = v25 >> 22;
    if (a4 - 1 == v75) {
      return result;
    }
    if ((v76 | v77 | (a3 - v89) | (a2 - v87)) < 0)
    {
      v11 += v75 + 1;
      uint64_t v91 = v91 - v74 + 4;
      a4 += ~v75;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v81 = v4 + SHIDWORD(a3) * (uint64_t)v6;
    unint64_t v82 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v39 = v81 + v82;
    uint64_t v40 = *(float **)(result + 32);
    if (v15 >= v81 + v82) {
      uint64_t v83 = (float *)(v81 + v82);
    }
    else {
      uint64_t v83 = (float *)v15;
    }
    if (v83 < v40) {
      uint64_t v83 = *(float **)(result + 32);
    }
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      float32x4_t v84 = *(float **)(result + 40);
      if (v14 >= v42) {
        float v85 = (float *)v42;
      }
      else {
        float v85 = (float *)v14;
      }
      if (v85 >= v84) {
        float32x4_t v84 = v85;
      }
      float v45 = *v84;
    }
    else
    {
      float v45 = 1.0;
    }
    float v47 = *v83;
    if (v8)
    {
      unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        v11 += v75 + 1;
        uint64_t v91 = v91 - v74 + 4;
        a4 += ~v75;
        unsigned int v25 = -1;
        goto LABEL_45;
      }
    }
    ++v75;
    v74 -= 4;
    a3 += v9;
    v76 -= v9;
    a2 += v10;
    v77 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t w16_sample_WF(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v84 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v82 = *(_DWORD *)(result + 188);
  uint64_t v86 = *(void *)(result + 88);
  uint64_t v87 = *(void *)(result + 152) - 4;
  uint64_t v11 = *(void *)(result + 144) - 1;
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  unint64_t v14 = v5 + (v12 * v7) + 4 * (v13 - 1);
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 4;
  uint64_t v85 = *(void *)(result + 72);
  uint64_t v83 = *(void *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v85)
    {
      if (a3 <= v86)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v83;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v86;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_39;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v83;
        unsigned int v25 = v82 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v85 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_39;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v83;
      unsigned int v25 = v82 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v82;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    v87 += 4;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v84)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_26;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v84;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_39;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v82;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_26:
  if (v25 < 0x400000) {
    goto LABEL_39;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v4 + SHIDWORD(v26) * (uint64_t)v6;
  unint64_t v38 = (v31 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v39 = v37 + v38;
  uint64_t v40 = *(unsigned int **)(result + 32);
  if (v15 >= v37 + v38) {
    uint64_t v41 = (unsigned int *)(v37 + v38);
  }
  else {
    uint64_t v41 = (unsigned int *)v15;
  }
  if (v41 < v40) {
    uint64_t v41 = *(unsigned int **)(result + 32);
  }
  if (v5)
  {
    unint64_t v42 = v5 + (int)v36 * (uint64_t)v7 + v38;
    uint64_t v43 = *(unsigned int **)(result + 40);
    if (v14 >= v42) {
      uint64_t v44 = (unsigned int *)v42;
    }
    else {
      uint64_t v44 = (unsigned int *)v14;
    }
    if (v44 >= v43) {
      uint64_t v43 = v44;
    }
    float v45 = COERCE_FLOAT(bswap32(*v43));
  }
  else
  {
    unint64_t v42 = 0;
    float v45 = 1.0;
  }
  float v46 = COERCE_FLOAT(bswap32(*v41));
  if (v8)
  {
    unsigned int v47 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_45:
    int v48 = v47 & 0xF;
    int v49 = HIBYTE(v47) & 3;
    if (v48 == 1)
    {
      float v63 = (unsigned int *)(v39 + SBYTE1(v47) * (uint64_t)v6);
      if (v15 < (unint64_t)v63) {
        float v63 = (unsigned int *)v15;
      }
      if (v63 < v40) {
        float v63 = v40;
      }
      float v64 = COERCE_FLOAT(bswap32(*v63));
      float v65 = 1.0;
      if (v5)
      {
        uint64_t v66 = (unsigned int *)(v42 + SBYTE1(v47) * (uint64_t)v7);
        if (v14 < (unint64_t)v66) {
          uint64_t v66 = (unsigned int *)v14;
        }
        if ((unint64_t)v66 < *(void *)(result + 40)) {
          uint64_t v66 = *(unsigned int **)(result + 40);
        }
        float v65 = COERCE_FLOAT(bswap32(*v66));
      }
    }
    else
    {
      if (v48 != 2)
      {
        if (v48 == 3)
        {
          unint64_t v50 = v39 + 4 * SBYTE2(v47);
          if (v15 >= v50) {
            int v51 = (unsigned int *)(v39 + 4 * SBYTE2(v47));
          }
          else {
            int v51 = (unsigned int *)v15;
          }
          if (v51 < v40) {
            int v51 = v40;
          }
          float v52 = COERCE_FLOAT(bswap32(*v51));
          uint64_t v53 = (unsigned int *)(v50 + SBYTE1(v47) * (uint64_t)v6);
          if (v15 < (unint64_t)v53) {
            uint64_t v53 = (unsigned int *)v15;
          }
          if (v53 < v40) {
            uint64_t v53 = v40;
          }
          float v54 = COERCE_FLOAT(bswap32(*v53));
          float v55 = 1.0;
          float v56 = 1.0;
          if (v5)
          {
            unint64_t v57 = v42 + 4 * SBYTE2(v47);
            unint64_t v58 = *(void *)(result + 40);
            if (v14 >= v57) {
              unint64_t v59 = (unsigned int *)(v42 + 4 * SBYTE2(v47));
            }
            else {
              unint64_t v59 = (unsigned int *)v14;
            }
            if ((unint64_t)v59 < v58) {
              unint64_t v59 = *(unsigned int **)(result + 40);
            }
            float v55 = COERCE_FLOAT(bswap32(*v59));
            unint64_t v60 = (unsigned int *)(v57 + SBYTE1(v47) * (uint64_t)v7);
            if (v14 < (unint64_t)v60) {
              unint64_t v60 = (unsigned int *)v14;
            }
            if ((unint64_t)v60 < v58) {
              unint64_t v60 = *(unsigned int **)(result + 40);
            }
            float v56 = COERCE_FLOAT(bswap32(*v60));
          }
          float v61 = interpolate_waf[2 * v49 + 1];
          float v62 = interpolate_waf[2 * ((v47 >> 28) & 3) + 1];
          float v46 = (float)((float)((float)(v46 - (float)(v46 * v61)) + (float)(v52 * v61))
                      - (float)((float)((float)(v46 - (float)(v46 * v61)) + (float)(v52 * v61)) * v62))
              + (float)((float)((float)(v52 - (float)(v52 * v61)) + (float)(v54 * v61)) * v62);
          float v45 = (float)((float)((float)(v45 - (float)(v45 * v61)) + (float)(v55 * v61))
                      - (float)((float)((float)(v45 - (float)(v45 * v61)) + (float)(v55 * v61)) * v62))
              + (float)((float)((float)(v55 - (float)(v55 * v61)) + (float)(v56 * v61)) * v62);
        }
        goto LABEL_91;
      }
      float v67 = (unsigned int *)(v39 + 4 * SBYTE2(v47));
      if (v15 < (unint64_t)v67) {
        float v67 = (unsigned int *)v15;
      }
      if (v67 < v40) {
        float v67 = v40;
      }
      float v64 = COERCE_FLOAT(bswap32(*v67));
      float v65 = 1.0;
      if (v5)
      {
        uint64_t v68 = (unsigned int *)(v42 + 4 * SBYTE2(v47));
        if (v14 < (unint64_t)v68) {
          uint64_t v68 = (unsigned int *)v14;
        }
        if ((unint64_t)v68 < *(void *)(result + 40)) {
          uint64_t v68 = *(unsigned int **)(result + 40);
        }
        float v65 = COERCE_FLOAT(bswap32(*v68));
      }
      int v49 = (v47 >> 28) & 3;
    }
    float v69 = interpolate_waf[2 * v49 + 1];
    float v46 = (float)(v46 - (float)(v46 * v69)) + (float)(v64 * v69);
    float v45 = (float)(v45 - (float)(v45 * v69)) + (float)(v65 * v69);
  }
LABEL_91:
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  a3 += v9;
  uint64_t v72 = v86 - a3;
  a2 += v10;
  uint64_t v73 = v84 - a2;
  while (1)
  {
    if (v45 <= 0.0)
    {
      int v76 = 0;
    }
    else
    {
      int v74 = (int)(float)((float)(v45 * 65535.0) + 0.5);
      if (v45 > 1.0)
      {
        int v74 = 0xFFFF;
        float v45 = 1.0;
      }
      int v75 = v74;
      if (v46 <= v45)
      {
        if (v46 >= 0.0) {
          int v75 = (int)(float)((float)(v46 * 65535.0) + 0.5);
        }
        else {
          int v75 = 0;
        }
      }
      int v76 = v75 | (v74 << 16);
    }
    *(_DWORD *)(v87 + 4 + 4 * v71) = v76;
    *(unsigned char *)(v11 + 1 + v71) = v25 >> 22;
    if (a4 - 1 == v71) {
      return result;
    }
    if ((v72 | v73 | (a3 - v85) | (a2 - v83)) < 0)
    {
      v11 += v71 + 1;
      uint64_t v87 = v87 - v70 + 4;
      a4 += ~v71;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v77 = v4 + SHIDWORD(a3) * (uint64_t)v6;
    unint64_t v78 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v39 = v77 + v78;
    uint64_t v40 = *(unsigned int **)(result + 32);
    if (v15 >= v77 + v78) {
      int v79 = (unsigned int *)(v77 + v78);
    }
    else {
      int v79 = (unsigned int *)v15;
    }
    if (v79 < v40) {
      int v79 = *(unsigned int **)(result + 32);
    }
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v78;
      int v80 = *(unsigned int **)(result + 40);
      if (v14 >= v42) {
        uint64_t v81 = (unsigned int *)v42;
      }
      else {
        uint64_t v81 = (unsigned int *)v14;
      }
      if (v81 >= v80) {
        int v80 = v81;
      }
      float v45 = COERCE_FLOAT(bswap32(*v80));
    }
    else
    {
      float v45 = 1.0;
    }
    float v46 = COERCE_FLOAT(bswap32(*v79));
    if (v8)
    {
      unsigned int v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v47 & 0xF) != 0)
      {
        v11 += v71 + 1;
        uint64_t v87 = v87 - v70 + 4;
        a4 += ~v71;
        unsigned int v25 = -1;
        goto LABEL_45;
      }
    }
    ++v71;
    v70 -= 4;
    a3 += v9;
    v72 -= v9;
    a2 += v10;
    v73 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t w16_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v103 = *(void *)(result + 80);
  uint64_t v106 = *(void *)(result + 88);
  uint64_t v116 = *(void *)(result + 120);
  uint64_t v117 = *(void *)(result + 112);
  uint64_t v8 = (unsigned int *)(*(void *)(result + 152) - 4);
  uint64_t v107 = *(void *)(result + 144) - 1;
  int v9 = *(_DWORD *)(result + 260) - 1;
  int v114 = *(_DWORD *)(result + 24);
  uint64_t v111 = *(void *)(result + 32);
  uint64_t v10 = *(unsigned int *)(result + 256);
  int v102 = *(_DWORD *)(result + 188);
  int v109 = *(_DWORD *)(result + 28);
  unint64_t v110 = v6 + (v9 * v109) + 2 * (v10 - 1);
  unint64_t v115 = v111 + (v9 * v114) + 8 * v10 - 16;
  uint64_t v104 = *(void *)(result + 72);
  uint64_t v105 = *(void *)(result + 64);
  uint64_t v112 = v6;
  uint64_t v113 = result;
  while (1)
  {
    if (a3 >= v104)
    {
      if (a3 <= v106)
      {
        uint64_t v21 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v22 = 0x3FFFFFFF;
        uint64_t v23 = a3;
        int v14 = a4;
        uint64_t v15 = v105;
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = *(void *)(result + 224) + v106;
        uint64_t v19 = v18 - a3 + (v17 >> 1);
        int v14 = a4;
        uint64_t v15 = v105;
        if (v19 < 1) {
          goto LABEL_37;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        unsigned int v22 = v102 | v20;
        uint64_t v23 = v18 - 0x1000000;
        uint64_t v21 = 448;
      }
    }
    else
    {
      uint64_t v11 = *(void *)(result + 216);
      uint64_t v12 = v104 - *(void *)(result + 224);
      uint64_t v13 = a3 - v12 + (v11 >> 1);
      int v14 = a4;
      uint64_t v15 = v105;
      if (v13 < 1) {
        goto LABEL_37;
      }
      if (v13 >= v11) {
        LODWORD(v16) = 0x3FFFFFFF;
      }
      else {
        unint64_t v16 = (unint64_t)(*(void *)(result + 232) * v13) >> 32;
      }
      unsigned int v22 = v102 | v16;
      uint64_t v23 = v12 + 0x1000000;
      uint64_t v21 = 512;
    }
    if (a2 >= v15)
    {
      if (a2 <= v103)
      {
        uint64_t v28 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v27 = a2;
      }
      else
      {
        uint64_t v29 = *(void *)(result + 192);
        uint64_t v30 = *(void *)(result + 200) + v103;
        uint64_t v31 = v30 - a2 + (v29 >> 1);
        if (v31 < 1) {
          goto LABEL_37;
        }
        if (v31 < v29) {
          unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v102;
        }
        uint64_t v27 = v30 - 0x1000000;
        uint64_t v28 = 28;
      }
    }
    else
    {
      uint64_t v24 = *(void *)(result + 192);
      uint64_t v25 = v15 - *(void *)(result + 200);
      uint64_t v26 = a2 - v25 + (v24 >> 1);
      if (v26 < 1) {
        goto LABEL_37;
      }
      if (v26 < v24) {
        unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v26) >> 32) >> 15)) | v102;
      }
      uint64_t v27 = v25 + 0x1000000;
      uint64_t v28 = 32;
    }
    if (v22 >= 0x400000) {
      break;
    }
LABEL_37:
    int v41 = v14 - 1;
    a2 += v117;
    a3 += v116;
    ++v8;
    *(unsigned char *)++uint64_t v107 = 0;
LABEL_38:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  uint64_t v32 = v23 >> 32;
  uint64_t v33 = v27 >> 32;
  unint64_t v34 = v111 + SHIDWORD(v23) * (uint64_t)v114 + 8 * (v27 >> 32);
  uint64_t v35 = *(unint64_t **)(result + 32);
  uint64_t v36 = (unint64_t *)v115;
  if (v115 >= v34) {
    uint64_t v36 = (unint64_t *)v34;
  }
  if (v36 < v35) {
    uint64_t v36 = *(unint64_t **)(result + 32);
  }
  if (v6)
  {
    unint64_t v37 = v6 + (int)v32 * (uint64_t)v109 + 2 * v33;
    unint64_t v38 = *(unsigned __int16 **)(result + 40);
    uint64_t v39 = (unsigned __int16 *)v110;
    unint64_t v108 = v37;
    if (v110 >= v37) {
      uint64_t v39 = (unsigned __int16 *)v37;
    }
    if (v39 >= v38) {
      unint64_t v38 = v39;
    }
    int v40 = *v38;
  }
  else
  {
    unint64_t v108 = 0;
    int v40 = 0xFFFF;
  }
  unint64_t v42 = *v36;
  if (!v7) {
    goto LABEL_100;
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v28 | v21));
LABEL_44:
  int v44 = v43 & 0xF;
  unsigned int v45 = v43 >> 8;
  unsigned int v46 = HIBYTE(v43) & 3;
  switch(v44)
  {
    case 1:
      unint64_t v78 = (unint64_t *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      if (v115 < (unint64_t)v78) {
        unint64_t v78 = (unint64_t *)v115;
      }
      if (v78 < v35) {
        unint64_t v78 = v35;
      }
      unint64_t v79 = *v78;
      __int16 v80 = -1;
      if (v6)
      {
        uint64_t v81 = (__int16 *)(v108 + (char)v45 * (uint64_t)v109);
        if (v110 < (unint64_t)v81) {
          uint64_t v81 = (__int16 *)v110;
        }
        if ((unint64_t)v81 < *(void *)(result + 40)) {
          uint64_t v81 = *(__int16 **)(result + 40);
        }
        __int16 v80 = *v81;
      }
      int v82 = (char *)&interpolate_cmyk64 + 16 * v46;
      char v83 = v46 + 1;
      unint64_t v42 = v42 - ((*(void *)v82 & v42) >> v83) + ((*(void *)v82 & v79) >> v83);
      unsigned int v77 = v40
          - ((unsigned __int16)(*((_WORD *)v82 + 4) & v40) >> v83)
          + ((unsigned __int16)(*((_WORD *)v82 + 4) & v80) >> v83);
LABEL_99:
      int v40 = (unsigned __int16)v77;
      break;
    case 2:
      int64_t v84 = (unint64_t)HIWORD(v43) << 56;
      uint64_t v85 = (unint64_t *)(v34 + (v84 >> 53));
      if (v115 < (unint64_t)v85) {
        uint64_t v85 = (unint64_t *)v115;
      }
      if (v85 >= v35) {
        uint64_t v35 = v85;
      }
      unint64_t v86 = *v35;
      int v87 = 0xFFFF;
      if (v6)
      {
        uint64_t v88 = (unsigned __int16 *)(v108 + (v84 >> 55));
        if (v110 < (unint64_t)v88) {
          uint64_t v88 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v88 < *(void *)(result + 40)) {
          uint64_t v88 = *(unsigned __int16 **)(result + 40);
        }
        int v87 = *v88;
      }
      unsigned int v89 = (v43 >> 28) & 3;
      uint64_t v90 = (char *)&interpolate_cmyk64 + 16 * v89;
      uint64_t v91 = *(void *)v90;
      LOBYTE(v89) = v89 + 1;
      unint64_t v92 = v42 - ((*(void *)v90 & v42) >> v89);
      LODWORD(v90) = *((unsigned __int16 *)v90 + 4);
      unsigned int v75 = v40 - ((v90 & v40) >> v89);
      unint64_t v93 = (v91 & v86) >> v89;
      unsigned int v77 = (v90 & v87) >> v89;
      unint64_t v42 = v92 + v93;
LABEL_98:
      LOWORD(v77) = v75 + v77;
      goto LABEL_99;
    case 3:
      int64_t v47 = (unint64_t)HIWORD(v43) << 56;
      int v48 = (unint64_t *)(v34 + (v47 >> 53));
      if (v115 < (unint64_t)v48) {
        int v48 = (unint64_t *)v115;
      }
      if (v48 < v35) {
        int v48 = v35;
      }
      unint64_t v49 = *v48;
      unint64_t v50 = v34 + SBYTE1(v43) * (uint64_t)v114;
      if (v115 >= v50) {
        int v51 = (unint64_t *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      }
      else {
        int v51 = (unint64_t *)v115;
      }
      if (v51 < v35) {
        int v51 = v35;
      }
      unint64_t v52 = *v51;
      uint64_t v53 = (unint64_t *)(v50 + (v47 >> 53));
      if (v115 < (unint64_t)v53) {
        uint64_t v53 = (unint64_t *)v115;
      }
      if (v53 >= v35) {
        uint64_t v35 = v53;
      }
      unint64_t v54 = *v35;
      int v55 = 0xFFFF;
      int v56 = 0xFFFF;
      int v57 = 0xFFFF;
      if (v6)
      {
        unint64_t v58 = (unsigned __int16 *)(v108 + (v47 >> 55));
        unint64_t v59 = *(void *)(result + 40);
        if (v110 < (unint64_t)v58) {
          unint64_t v58 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v58 < v59) {
          unint64_t v58 = *(unsigned __int16 **)(result + 40);
        }
        int v55 = *v58;
        unint64_t v60 = v108 + SBYTE1(v43) * (uint64_t)v109;
        if (v110 >= v60) {
          float v61 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        }
        else {
          float v61 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v61 < v59) {
          float v61 = *(unsigned __int16 **)(result + 40);
        }
        int v56 = *v61;
        float v62 = (unsigned __int16 *)(v60 + (v47 >> 55));
        if (v110 < (unint64_t)v62) {
          float v62 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v62 < v59) {
          float v62 = *(unsigned __int16 **)(result + 40);
        }
        int v57 = *v62;
      }
      float v63 = (char *)&interpolate_cmyk64 + 16 * v46;
      uint64_t v64 = *(void *)v63;
      char v65 = v46 + 1;
      unint64_t v66 = v42 - ((*(void *)v63 & v42) >> v65);
      LODWORD(v63) = *((unsigned __int16 *)v63 + 4);
      unint64_t v67 = v66 + ((v64 & v52) >> v65);
      unsigned int v68 = v40 - ((v63 & v40) >> v65) + ((v63 & v56) >> v65);
      unint64_t v69 = v49 - ((v64 & v49) >> v65) + ((v64 & v54) >> v65);
      unsigned int v70 = v55 - ((v63 & v55) >> v65) + ((v63 & v57) >> v65);
      unsigned int v71 = (v43 >> 28) & 3;
      uint64_t v72 = (char *)&interpolate_cmyk64 + 16 * v71;
      unint64_t v73 = *(void *)v72;
      LOBYTE(v71) = v71 + 1;
      unint64_t v74 = v67 - ((v67 & *(void *)v72) >> v71);
      LODWORD(v72) = *((unsigned __int16 *)v72 + 4);
      unsigned int v75 = v68 - ((v68 & v72) >> v71);
      unint64_t v76 = (v69 & v73) >> v71;
      unsigned int v77 = (v70 & v72) >> v71;
      unint64_t v42 = v74 + v76;
      goto LABEL_98;
  }
LABEL_100:
  uint64_t v94 = 0;
  ++v8;
  int v101 = v14;
  int v95 = v14 - 1;
  a3 += v116;
  uint64_t v96 = v106 - a3;
  a2 += v117;
  uint64_t v97 = v103 - a2;
  while (1)
  {
    CMYK64(v8, v42, v40);
    *(unsigned char *)(v107 + 1 + v94) = v22 >> 22;
    uint64_t v6 = v112;
    double result = v113;
    if (v95 == v94) {
      return result;
    }
    if ((v96 | v97 | (a3 - v104) | (a2 - v105)) < 0)
    {
      v107 += v94 + 1;
      int v41 = ~v94 + v101;
      goto LABEL_38;
    }
    unint64_t v34 = v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32);
    uint64_t v35 = *(unint64_t **)(v113 + 32);
    uint64_t v98 = (unint64_t *)v115;
    if (v115 >= v34) {
      uint64_t v98 = (unint64_t *)(v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32));
    }
    if (v98 < v35) {
      uint64_t v98 = *(unint64_t **)(v113 + 32);
    }
    if (v112)
    {
      int v99 = *(unsigned __int16 **)(v113 + 40);
      unint64_t v100 = v110;
      unint64_t v108 = v112 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v110 >= v108) {
        unint64_t v100 = v112 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      }
      if (v100 >= (unint64_t)v99) {
        int v99 = (unsigned __int16 *)v100;
      }
      int v40 = *v99;
    }
    else
    {
      int v40 = 0xFFFF;
    }
    unint64_t v42 = *v98;
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v107 += v94 + 1;
        int v14 = ~v94 + v101;
        unsigned int v22 = -1;
        goto LABEL_44;
      }
    }
    ++v8;
    ++v94;
    a3 += v116;
    v96 -= v116;
    a2 += v117;
    v97 -= v117;
    unsigned int v22 = -1;
  }
}

unsigned int *CMYK64(unsigned int *result, unint64_t a2, int a3)
{
  int v3 = (unsigned __int16)a3 - (HIWORD(a2) + (unsigned __int16)a2);
  int v4 = (unsigned __int16)a3 - (HIWORD(a2) + WORD1(a2));
  int v5 = (unsigned __int16)a3 - (HIWORD(a2) + WORD2(a2));
  *double result = (((v5 & ~(v5 >> 31)) + (v4 & ~(v4 >> 31)) + 2 * (v3 & ~(v3 >> 31)) + 4 * (v4 & ~(v4 >> 31))) >> 3) | (a3 << 16);
  return result;
}

uint64_t w16_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *(void *)(result + 40);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v103 = *(void *)(result + 80);
  uint64_t v104 = *(void *)(result + 88);
  uint64_t v116 = *(void *)(result + 120);
  uint64_t v117 = *(void *)(result + 112);
  uint64_t v8 = (unsigned int *)(*(void *)(result + 152) - 4);
  uint64_t v107 = *(void *)(result + 144) - 1;
  int v9 = *(_DWORD *)(result + 260) - 1;
  int v114 = *(_DWORD *)(result + 24);
  uint64_t v111 = *(void *)(result + 32);
  uint64_t v10 = *(unsigned int *)(result + 256);
  int v102 = *(_DWORD *)(result + 188);
  int v109 = *(_DWORD *)(result + 28);
  unint64_t v110 = v6 + (v9 * v109) + 2 * (v10 - 1);
  unint64_t v115 = v111 + (v9 * v114) + 8 * v10 - 16;
  uint64_t v105 = *(void *)(result + 72);
  uint64_t v106 = *(void *)(result + 64);
  uint64_t v112 = result;
  uint64_t v113 = v6;
  while (1)
  {
    if (a3 >= v105)
    {
      if (a3 <= v104)
      {
        uint64_t v21 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v22 = 0x3FFFFFFF;
        uint64_t v23 = a3;
        int v14 = a4;
        uint64_t v15 = v106;
      }
      else
      {
        uint64_t v17 = *(void *)(result + 216);
        uint64_t v18 = *(void *)(result + 224) + v104;
        uint64_t v19 = v18 - a3 + (v17 >> 1);
        int v14 = a4;
        uint64_t v15 = v106;
        if (v19 < 1) {
          goto LABEL_37;
        }
        if (v19 >= v17) {
          LODWORD(v20) = 0x3FFFFFFF;
        }
        else {
          unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
        }
        unsigned int v22 = v102 | v20;
        uint64_t v23 = v18 - 0x1000000;
        uint64_t v21 = 448;
      }
    }
    else
    {
      uint64_t v11 = *(void *)(result + 216);
      uint64_t v12 = v105 - *(void *)(result + 224);
      uint64_t v13 = a3 - v12 + (v11 >> 1);
      int v14 = a4;
      uint64_t v15 = v106;
      if (v13 < 1) {
        goto LABEL_37;
      }
      if (v13 >= v11) {
        LODWORD(v16) = 0x3FFFFFFF;
      }
      else {
        unint64_t v16 = (unint64_t)(*(void *)(result + 232) * v13) >> 32;
      }
      unsigned int v22 = v102 | v16;
      uint64_t v23 = v12 + 0x1000000;
      uint64_t v21 = 512;
    }
    if (a2 >= v15)
    {
      if (a2 <= v103)
      {
        uint64_t v28 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v27 = a2;
      }
      else
      {
        uint64_t v29 = *(void *)(result + 192);
        uint64_t v30 = *(void *)(result + 200) + v103;
        uint64_t v31 = v30 - a2 + (v29 >> 1);
        if (v31 < 1) {
          goto LABEL_37;
        }
        if (v31 < v29) {
          unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v102;
        }
        uint64_t v27 = v30 - 0x1000000;
        uint64_t v28 = 28;
      }
    }
    else
    {
      uint64_t v24 = *(void *)(result + 192);
      uint64_t v25 = v15 - *(void *)(result + 200);
      uint64_t v26 = a2 - v25 + (v24 >> 1);
      if (v26 < 1) {
        goto LABEL_37;
      }
      if (v26 < v24) {
        unsigned int v22 = ((v22 >> 15) * (((unint64_t)(*(void *)(result + 208) * v26) >> 32) >> 15)) | v102;
      }
      uint64_t v27 = v25 + 0x1000000;
      uint64_t v28 = 32;
    }
    if (v22 >= 0x400000) {
      break;
    }
LABEL_37:
    int v41 = v14 - 1;
    a2 += v117;
    a3 += v116;
    ++v8;
    *(unsigned char *)++uint64_t v107 = 0;
LABEL_38:
    a4 = v41;
    if (!v41) {
      return result;
    }
  }
  uint64_t v32 = v23 >> 32;
  uint64_t v33 = v27 >> 32;
  unint64_t v34 = v111 + SHIDWORD(v23) * (uint64_t)v114 + 8 * (v27 >> 32);
  uint64_t v35 = *(unsigned __int16 **)(result + 32);
  uint64_t v36 = (unsigned __int16 *)v115;
  if (v115 >= v34) {
    uint64_t v36 = (unsigned __int16 *)v34;
  }
  if (v36 < v35) {
    uint64_t v36 = *(unsigned __int16 **)(result + 32);
  }
  if (v6)
  {
    unint64_t v37 = v6 + (int)v32 * (uint64_t)v109 + 2 * v33;
    unint64_t v38 = *(unsigned __int16 **)(result + 40);
    uint64_t v39 = (unsigned __int16 *)v110;
    unint64_t v108 = v37;
    if (v110 >= v37) {
      uint64_t v39 = (unsigned __int16 *)v37;
    }
    if (v39 >= v38) {
      unint64_t v38 = v39;
    }
    unsigned int v40 = bswap32(*v38) >> 16;
  }
  else
  {
    unint64_t v108 = 0;
    unsigned int v40 = 0xFFFF;
  }
  unint64_t v42 = ((unint64_t)(bswap32(v36[2]) >> 16) << 32) | ((unint64_t)(bswap32(v36[3]) >> 16) << 48) | bswap32(v36[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v36) >> 16);
  if (!v7) {
    goto LABEL_100;
  }
  unsigned int v43 = *(_DWORD *)(v7 + (v28 | v21));
LABEL_44:
  int v44 = v43 & 0xF;
  unsigned int v45 = HIBYTE(v43) & 3;
  switch(v44)
  {
    case 1:
      unsigned int v77 = (unsigned __int16 *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      if (v115 < (unint64_t)v77) {
        unsigned int v77 = (unsigned __int16 *)v115;
      }
      if (v77 >= v35) {
        uint64_t v35 = v77;
      }
      unint64_t v78 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      unsigned int v79 = 0xFFFF;
      if (v6)
      {
        __int16 v80 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        if (v110 < (unint64_t)v80) {
          __int16 v80 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v80 < *(void *)(result + 40)) {
          __int16 v80 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v79 = bswap32(*v80) >> 16;
      }
      uint64_t v81 = (char *)&interpolate_cmyk64 + 16 * v45;
      uint64_t v82 = *(void *)v81;
      char v83 = v45 + 1;
      unint64_t v84 = v42 - ((*(void *)v81 & v42) >> v83);
      LODWORD(v81) = *((unsigned __int16 *)v81 + 4);
      unsigned int v74 = v40 - ((v81 & v40) >> v83);
      unint64_t v85 = (v82 & v78) >> v83;
      unsigned int v76 = (v81 & v79) >> v83;
      goto LABEL_98;
    case 2:
      int64_t v86 = (unint64_t)HIWORD(v43) << 56;
      int v87 = (unsigned __int16 *)(v34 + (v86 >> 53));
      if (v115 < (unint64_t)v87) {
        int v87 = (unsigned __int16 *)v115;
      }
      if (v87 >= v35) {
        uint64_t v35 = v87;
      }
      unint64_t v88 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      unsigned int v89 = 0xFFFF;
      if (v6)
      {
        uint64_t v90 = (unsigned __int16 *)(v108 + (v86 >> 55));
        if (v110 < (unint64_t)v90) {
          uint64_t v90 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v90 < *(void *)(result + 40)) {
          uint64_t v90 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v89 = bswap32(*v90) >> 16;
      }
      unsigned int v91 = (v43 >> 28) & 3;
      unint64_t v92 = (char *)&interpolate_cmyk64 + 16 * v91;
      uint64_t v93 = *(void *)v92;
      LOBYTE(v91) = v91 + 1;
      unint64_t v84 = v42 - ((*(void *)v92 & v42) >> v91);
      LODWORD(v92) = *((unsigned __int16 *)v92 + 4);
      unsigned int v74 = v40 - ((v92 & v40) >> v91);
      unint64_t v85 = (v93 & v88) >> v91;
      unsigned int v76 = (v92 & v89) >> v91;
LABEL_98:
      unint64_t v42 = v84 + v85;
      goto LABEL_99;
    case 3:
      int64_t v46 = (unint64_t)HIWORD(v43) << 56;
      int64_t v47 = (unsigned __int16 *)(v34 + (v46 >> 53));
      if (v115 < (unint64_t)v47) {
        int64_t v47 = (unsigned __int16 *)v115;
      }
      if (v47 < v35) {
        int64_t v47 = v35;
      }
      unint64_t v48 = ((unint64_t)(bswap32(v47[2]) >> 16) << 32) | ((unint64_t)(bswap32(v47[3]) >> 16) << 48) | bswap32(v47[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v47) >> 16);
      unint64_t v49 = v34 + SBYTE1(v43) * (uint64_t)v114;
      if (v115 >= v49) {
        unint64_t v50 = (unsigned __int16 *)(v34 + SBYTE1(v43) * (uint64_t)v114);
      }
      else {
        unint64_t v50 = (unsigned __int16 *)v115;
      }
      if (v50 < v35) {
        unint64_t v50 = v35;
      }
      unint64_t v51 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
      unint64_t v52 = (unsigned __int16 *)(v49 + (v46 >> 53));
      if (v115 < (unint64_t)v52) {
        unint64_t v52 = (unsigned __int16 *)v115;
      }
      if (v52 >= v35) {
        uint64_t v35 = v52;
      }
      unint64_t v53 = ((unint64_t)(bswap32(v35[2]) >> 16) << 32) | ((unint64_t)(bswap32(v35[3]) >> 16) << 48) | bswap32(v35[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v35) >> 16);
      unsigned int v54 = 0xFFFF;
      unsigned int v55 = 0xFFFF;
      unsigned int v56 = 0xFFFF;
      if (v6)
      {
        int v57 = (unsigned __int16 *)(v108 + (v46 >> 55));
        unint64_t v58 = *(void *)(result + 40);
        if (v110 < (unint64_t)v57) {
          int v57 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v57 < v58) {
          int v57 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v54 = bswap32(*v57) >> 16;
        unint64_t v59 = v108 + SBYTE1(v43) * (uint64_t)v109;
        if (v110 >= v59) {
          unint64_t v60 = (unsigned __int16 *)(v108 + SBYTE1(v43) * (uint64_t)v109);
        }
        else {
          unint64_t v60 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v60 < v58) {
          unint64_t v60 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v55 = bswap32(*v60) >> 16;
        float v61 = (unsigned __int16 *)(v59 + (v46 >> 55));
        if (v110 < (unint64_t)v61) {
          float v61 = (unsigned __int16 *)v110;
        }
        if ((unint64_t)v61 < v58) {
          float v61 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v56 = bswap32(*v61) >> 16;
      }
      float v62 = (char *)&interpolate_cmyk64 + 16 * v45;
      uint64_t v63 = *(void *)v62;
      char v64 = v45 + 1;
      unint64_t v65 = v42 - ((*(void *)v62 & v42) >> v64);
      LODWORD(v62) = *((unsigned __int16 *)v62 + 4);
      unint64_t v66 = v65 + ((v63 & v51) >> v64);
      unsigned int v67 = v40 - ((v62 & v40) >> v64) + ((v62 & v55) >> v64);
      unint64_t v68 = v48 - ((v63 & v48) >> v64) + ((v63 & v53) >> v64);
      unsigned int v69 = v54 - ((v62 & v54) >> v64) + ((v62 & v56) >> v64);
      unsigned int v70 = (v43 >> 28) & 3;
      unsigned int v71 = (char *)&interpolate_cmyk64 + 16 * v70;
      uint64_t v72 = *(void *)v71;
      LOBYTE(v70) = v70 + 1;
      unint64_t v73 = v66 - ((v66 & *(void *)v71) >> v70);
      LODWORD(v71) = *((unsigned __int16 *)v71 + 4);
      unsigned int v74 = v67 - ((v67 & v71) >> v70);
      unint64_t v75 = (v68 & v72) >> v70;
      unsigned int v76 = (v69 & v71) >> v70;
      unint64_t v42 = v73 + v75;
LABEL_99:
      unsigned int v40 = (unsigned __int16)(v74 + v76);
      break;
  }
LABEL_100:
  uint64_t v94 = 0;
  ++v8;
  int v101 = v14;
  int v95 = v14 - 1;
  a3 += v116;
  uint64_t v96 = v104 - a3;
  a2 += v117;
  uint64_t v97 = v103 - a2;
  while (1)
  {
    CMYK64(v8, v42, v40);
    *(unsigned char *)(v107 + 1 + v94) = v22 >> 22;
    double result = v112;
    uint64_t v6 = v113;
    if (v95 == v94) {
      return result;
    }
    if ((v96 | v97 | (a3 - v105) | (a2 - v106)) < 0)
    {
      v107 += v94 + 1;
      int v41 = ~v94 + v101;
      goto LABEL_38;
    }
    unint64_t v34 = v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32);
    uint64_t v35 = *(unsigned __int16 **)(v112 + 32);
    uint64_t v98 = (unsigned __int16 *)v115;
    if (v115 >= v34) {
      uint64_t v98 = (unsigned __int16 *)(v111 + SHIDWORD(a3) * (uint64_t)v114 + 8 * (a2 >> 32));
    }
    if (v98 < v35) {
      uint64_t v98 = *(unsigned __int16 **)(v112 + 32);
    }
    if (v113)
    {
      int v99 = *(unsigned __int16 **)(v112 + 40);
      unint64_t v100 = v110;
      unint64_t v108 = v113 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      if (v110 >= v108) {
        unint64_t v100 = v113 + SHIDWORD(a3) * (uint64_t)v109 + 2 * (a2 >> 32);
      }
      if (v100 >= (unint64_t)v99) {
        int v99 = (unsigned __int16 *)v100;
      }
      unsigned int v40 = bswap32(*v99) >> 16;
    }
    else
    {
      unsigned int v40 = 0xFFFF;
    }
    unint64_t v42 = ((unint64_t)(bswap32(v98[2]) >> 16) << 32) | ((unint64_t)(bswap32(v98[3]) >> 16) << 48) | bswap32(v98[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v98) >> 16);
    if (v7)
    {
      unsigned int v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v107 += v94 + 1;
        int v14 = ~v94 + v101;
        unsigned int v22 = -1;
        goto LABEL_44;
      }
    }
    ++v94;
    ++v8;
    a3 += v116;
    v96 -= v116;
    a2 += v117;
    v97 -= v117;
    unsigned int v22 = -1;
  }
}

uint64_t w16_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v74 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v72 = *(_DWORD *)(result + 188);
  uint64_t v10 = *(void *)(result + 152) - 4;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v12 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = 0xFFFF000000000000;
  }
  unint64_t v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v73 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_37;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v72 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_37;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v72 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v73) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v73 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v72;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 4;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v74)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_29;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v74;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_37;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v72;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_29:
  if (v24 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v34 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v35 = v29 >> 32;
  unint64_t v36 = v34 + 8 * v35;
  unint64_t v37 = *(unint64_t **)(result + 32);
  if (v14 >= v36) {
    unint64_t v38 = (unint64_t *)(v34 + 8 * v35);
  }
  else {
    unint64_t v38 = (unint64_t *)v14;
  }
  if (v38 < v37) {
    unint64_t v38 = *(unint64_t **)(result + 32);
  }
  unint64_t v39 = *v38;
  if (!v5) {
    goto LABEL_69;
  }
  unsigned int v40 = *(_DWORD *)(v5 + (v30 | v23));
LABEL_40:
  int v41 = v40 & 0xF;
  unsigned int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      unint64_t v59 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      if (v14 < (unint64_t)v59) {
        unint64_t v59 = (unint64_t *)v14;
      }
      if (v59 < v37) {
        unint64_t v59 = v37;
      }
      unint64_t v60 = interpolate_16161616_21355[v42];
      char v61 = v42 + 1;
      unint64_t v57 = v39 - ((v60 & v39) >> v61);
      unint64_t v62 = (v60 & *v59) >> v61;
LABEL_68:
      unint64_t v39 = v57 + v62;
      break;
    case 2:
      uint64_t v63 = (unint64_t *)(v36 + ((uint64_t)((unint64_t)HIWORD(v40) << 56) >> 53));
      if (v14 < (unint64_t)v63) {
        uint64_t v63 = (unint64_t *)v14;
      }
      if (v63 < v37) {
        uint64_t v63 = v37;
      }
      unsigned int v64 = (v40 >> 28) & 3;
      uint64_t v65 = interpolate_16161616_21355[v64];
      char v56 = v64 + 1;
      unint64_t v57 = v39 - ((v65 & v39) >> v56);
      unint64_t v58 = v65 & *v63;
LABEL_67:
      unint64_t v62 = v58 >> v56;
      goto LABEL_68;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v40) << 56;
      int v44 = (unint64_t *)(v36 + (v43 >> 53));
      if (v14 < (unint64_t)v44) {
        int v44 = (unint64_t *)v14;
      }
      if (v44 < v37) {
        int v44 = v37;
      }
      unint64_t v45 = *v44;
      unint64_t v46 = v36 + SBYTE1(v40) * (uint64_t)v4;
      if (v14 >= v46) {
        int64_t v47 = (unint64_t *)(v36 + SBYTE1(v40) * (uint64_t)v4);
      }
      else {
        int64_t v47 = (unint64_t *)v14;
      }
      if (v47 < v37) {
        int64_t v47 = v37;
      }
      unint64_t v48 = *v47;
      unint64_t v49 = (unint64_t *)(v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49) {
        unint64_t v49 = (unint64_t *)v14;
      }
      if (v49 < v37) {
        unint64_t v49 = v37;
      }
      unint64_t v50 = interpolate_16161616_21355[v42];
      char v51 = v42 + 1;
      unint64_t v52 = v39 - ((v50 & v39) >> v51) + ((v50 & v48) >> v51);
      unint64_t v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      unsigned int v54 = (v40 >> 28) & 3;
      unint64_t v55 = interpolate_16161616_21355[v54];
      char v56 = v54 + 1;
      unint64_t v57 = v52 - ((v52 & v55) >> v56);
      unint64_t v58 = v53 & v55;
      goto LABEL_67;
  }
LABEL_69:
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  a3 += v9;
  uint64_t v68 = v7 - a3;
  a2 += v8;
  uint64_t v69 = v74 - a2;
  while (1)
  {
    *(_DWORD *)(v10 + 4 + 4 * v66) = ((v39 | v13) >> 32) & 0xFFFF0000 | ((2 * (unsigned __int16)v39
                                                                                      + WORD1(v39)
                                                                                      + 4 * WORD1(v39)
                                                                                      + (unsigned __int16)((v39 | v13) >> 32)) >> 3);
    *(unsigned char *)(v11 + 1 + v66) = v24 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v68 | v69 | (a3 - v6) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = v10 - v67 + 4;
      v11 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v70 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v36 = v70 + 8 * (a2 >> 32);
    unint64_t v37 = *(unint64_t **)(result + 32);
    if (v14 >= v36) {
      unsigned int v71 = (unint64_t *)(v70 + 8 * (a2 >> 32));
    }
    else {
      unsigned int v71 = (unint64_t *)v14;
    }
    if (v71 < v37) {
      unsigned int v71 = *(unint64_t **)(result + 32);
    }
    unint64_t v39 = *v71;
    if (v5)
    {
      unsigned int v40 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        uint64_t v10 = v10 - v67 + 4;
        v11 += v66 + 1;
        a4 += ~v66;
        unsigned int v24 = -1;
        goto LABEL_40;
      }
    }
    v67 -= 4;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    unsigned int v24 = -1;
  }
}

uint64_t w16_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v73 = *(void *)(result + 80);
  uint64_t v72 = *(void *)(result + 88);
  uint64_t v7 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  int v70 = *(_DWORD *)(result + 188);
  uint64_t v9 = *(void *)(result + 152) - 4;
  uint64_t v10 = *(void *)(result + 144) - 1;
  uint64_t v11 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = 0xFFFF000000000000;
  }
  unint64_t v13 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v71 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v72)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v71;
        uint64_t v26 = v73;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v72;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_37;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v71;
        uint64_t v26 = v73;
        unsigned int v23 = v70 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v6 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_37;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v71;
      uint64_t v26 = v73;
      unsigned int v23 = v70 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v25 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v70;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v7;
    a3 += v8;
    v9 += 4;
    *(unsigned char *)++uint64_t v10 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v26)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v26;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v70;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v23 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v11 + SHIDWORD(v24) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 8 * v36;
  unint64_t v38 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v37) {
    unint64_t v39 = (unsigned __int16 *)(v35 + 8 * v36);
  }
  else {
    unint64_t v39 = (unsigned __int16 *)v13;
  }
  if (v39 < v38) {
    unint64_t v39 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v22));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    switch(v42)
    {
      case 1:
        unint64_t v59 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        if (v13 < (unint64_t)v59) {
          unint64_t v59 = (unsigned __int16 *)v13;
        }
        if (v59 < v38) {
          unint64_t v59 = v38;
        }
        uint64_t v60 = interpolate_16161616_21355[v43];
        char v61 = v43 + 1;
        unint64_t v57 = v40 - ((v60 & v40) >> v61);
        unint64_t v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v60) >> v61;
LABEL_62:
        unint64_t v40 = v57 + v58;
        break;
      case 2:
        unint64_t v62 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
        if (v13 < (unint64_t)v62) {
          unint64_t v62 = (unsigned __int16 *)v13;
        }
        if (v62 < v38) {
          unint64_t v62 = v38;
        }
        int v63 = (v41 >> 28) & 3;
        unint64_t v40 = v40
            - ((interpolate_16161616_21355[v63] & v40) >> (v63 + 1))
            + (((((unint64_t)(bswap32(v62[2]) >> 16) << 32) | ((unint64_t)(bswap32(v62[3]) >> 16) << 48) | bswap32(v62[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v62) >> 16)) & interpolate_16161616_21355[v63]) >> (v63 + 1));
        break;
      case 3:
        int64_t v44 = (unint64_t)HIWORD(v41) << 56;
        unint64_t v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
        if (v13 < (unint64_t)v45) {
          unint64_t v45 = (unsigned __int16 *)v13;
        }
        if (v45 < v38) {
          unint64_t v45 = v38;
        }
        unint64_t v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
        unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
        if (v13 >= v47) {
          unint64_t v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
        }
        else {
          unint64_t v48 = (unsigned __int16 *)v13;
        }
        if (v48 < v38) {
          unint64_t v48 = v38;
        }
        unint64_t v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
        unint64_t v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
        if (v13 < (unint64_t)v50) {
          unint64_t v50 = (unsigned __int16 *)v13;
        }
        if (v50 < v38) {
          unint64_t v50 = v38;
        }
        uint64_t v51 = interpolate_16161616_21355[v43];
        char v52 = v43 + 1;
        unint64_t v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
        unint64_t v54 = v46
            - ((v51 & v46) >> v52)
            + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52);
        int v55 = (v41 >> 28) & 3;
        uint64_t v56 = interpolate_16161616_21355[v55];
        LOBYTE(v55) = v55 + 1;
        unint64_t v57 = v53 - ((v53 & v56) >> v55);
        unint64_t v58 = (v54 & v56) >> v55;
        goto LABEL_62;
    }
  }
  uint64_t v64 = 0;
  uint64_t v65 = 0;
  a3 += v8;
  uint64_t v66 = v72 - a3;
  a2 += v7;
  uint64_t v67 = v73 - a2;
  while (1)
  {
    *(_DWORD *)(v9 + 4 + 4 * v65) = ((v40 | v12) >> 32) & 0xFFFF0000 | ((2 * (unsigned __int16)v40
                                                                                     + WORD1(v40)
                                                                                     + 4 * WORD1(v40)
                                                                                     + (unsigned __int16)((v40 | v12) >> 32)) >> 3);
    *(unsigned char *)(v10 + 1 + v65) = v23 >> 22;
    if (a4 - 1 == v65) {
      return result;
    }
    if (((v66 | v67 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v10 += v65 + 1;
      uint64_t v9 = v9 - v64 + 4;
      a4 += ~v65;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v68 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v68 + 8 * (a2 >> 32);
    unint64_t v38 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v37) {
      uint64_t v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v69 = (unsigned __int16 *)v13;
    }
    if (v69 < v38) {
      uint64_t v69 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v10 += v65 + 1;
        uint64_t v9 = v9 - v64 + 4;
        a4 += ~v65;
        unsigned int v23 = -1;
        goto LABEL_40;
      }
    }
    ++v65;
    v64 -= 4;
    a3 += v8;
    v66 -= v8;
    a2 += v7;
    v67 -= v7;
    unsigned int v23 = -1;
  }
}

uint64_t w16_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v69 = *(void *)(result + 64);
  uint64_t v70 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v68 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v23 = v68 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      unsigned int v23 = v68 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v69) {
      break;
    }
    uint64_t v25 = *(void *)(result + 192);
    uint64_t v26 = v69 - *(void *)(result + 200);
    uint64_t v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v27) >> 32) >> 15)) | v68;
      }
      uint64_t v28 = v26 + 0x1000000;
      uint64_t v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v70)
  {
    uint64_t v29 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v28 = a2;
    goto LABEL_26;
  }
  uint64_t v30 = *(void *)(result + 192);
  uint64_t v31 = *(void *)(result + 200) + v70;
  uint64_t v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1) {
    goto LABEL_34;
  }
  if (v32 < v30) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v68;
  }
  uint64_t v28 = v31 - 0x1000000;
  uint64_t v29 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v33 = v28 >> 32;
  uint64_t v34 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v35 = v34 + 6 * (int)v33;
  uint64_t v36 = *(unsigned int **)(result + 32);
  if (v13 >= v35) {
    unint64_t v37 = (unsigned int *)(v34 + 6 * (int)v33);
  }
  else {
    unint64_t v37 = (unsigned int *)v13;
  }
  if (v37 < v36) {
    unint64_t v37 = *(unsigned int **)(result + 32);
  }
  unint64_t v38 = *v37 | ((unint64_t)*((unsigned __int16 *)v37 + 2) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v39 = *(_DWORD *)(v6 + (v29 | v22));
LABEL_37:
  int v40 = v39 & 0xF;
  int v41 = HIBYTE(v39) & 3;
  switch(v40)
  {
    case 1:
      uint64_t v56 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      if (v13 < (unint64_t)v56) {
        uint64_t v56 = (unsigned int *)v13;
      }
      if (v56 < v36) {
        uint64_t v56 = v36;
      }
      uint64_t v57 = interpolate_16161616_21355[v41];
      char v58 = v41 + 1;
      unint64_t v55 = v38 - ((v57 & v38) >> v58);
      unint64_t v59 = ((*v56 | ((unint64_t)*((unsigned __int16 *)v56 + 2) << 32) | 0xFFFF000000000000) & v57) >> v58;
LABEL_65:
      unint64_t v38 = v55 + v59;
      break;
    case 2:
      uint64_t v60 = (unsigned int *)(v35 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v60) {
        uint64_t v60 = (unsigned int *)v13;
      }
      if (v60 < v36) {
        uint64_t v60 = v36;
      }
      unint64_t v51 = *v60 | ((unint64_t)*((unsigned __int16 *)v60 + 2) << 32) | 0xFFFF000000000000;
      int v61 = (v39 >> 28) & 3;
      uint64_t v53 = interpolate_16161616_21355[v61];
      char v54 = v61 + 1;
      unint64_t v55 = v38 - ((v53 & v38) >> v54);
LABEL_64:
      unint64_t v59 = (v51 & v53) >> v54;
      goto LABEL_65;
    case 3:
      int v42 = (unsigned int *)(v35 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v42) {
        int v42 = (unsigned int *)v13;
      }
      if (v42 < v36) {
        int v42 = v36;
      }
      unint64_t v43 = *v42 | ((unint64_t)*((unsigned __int16 *)v42 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v44 = v35 + SBYTE1(v39) * (uint64_t)v5;
      if (v13 >= v44) {
        unint64_t v45 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      }
      else {
        unint64_t v45 = (unsigned int *)v13;
      }
      if (v45 < v36) {
        unint64_t v45 = v36;
      }
      unint64_t v46 = *v45 | ((unint64_t)*((unsigned __int16 *)v45 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v47 = (unsigned int *)(v44 + 6 * SBYTE2(v39));
      if (v13 < (unint64_t)v47) {
        unint64_t v47 = (unsigned int *)v13;
      }
      if (v47 < v36) {
        unint64_t v47 = v36;
      }
      uint64_t v48 = interpolate_16161616_21355[v41];
      char v49 = v41 + 1;
      unint64_t v50 = v38 - ((v48 & v38) >> v49) + ((v46 & v48) >> v49);
      unint64_t v51 = v43
          - ((v48 & v43) >> v49)
          + (((*v47 | ((unint64_t)*((unsigned __int16 *)v47 + 2) << 32) | 0xFFFF000000000000) & v48) >> v49);
      int v52 = (v39 >> 28) & 3;
      uint64_t v53 = interpolate_16161616_21355[v52];
      char v54 = v52 + 1;
      unint64_t v55 = v50 - ((v50 & v53) >> v54);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  a3 += v10;
  uint64_t v64 = v8 - a3;
  a2 += v9;
  uint64_t v65 = v70 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v63) = HIDWORD(v38) & 0xFFFF0000 | ((2 * (unsigned __int16)v38
                                                                               + WORD1(v38)
                                                                               + 4 * WORD1(v38)
                                                                               + WORD2(v38)) >> 3);
    *(unsigned char *)(v12 + 1 + v63) = v23 >> 22;
    if (a4 - 1 == v63) {
      return result;
    }
    if (((v64 | v65 | (a3 - v7) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v12 += v63 + 1;
      uint64_t v11 = v11 - v62 + 4;
      a4 += ~v63;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v66 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v35 = v66 + 6 * SHIDWORD(a2);
    uint64_t v36 = *(unsigned int **)(result + 32);
    if (v13 >= v35) {
      uint64_t v67 = (unsigned int *)(v66 + 6 * SHIDWORD(a2));
    }
    else {
      uint64_t v67 = (unsigned int *)v13;
    }
    if (v67 < v36) {
      uint64_t v67 = *(unsigned int **)(result + 32);
    }
    unint64_t v38 = *v67 | ((unint64_t)*((unsigned __int16 *)v67 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v39 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v12 += v63 + 1;
        uint64_t v11 = v11 - v62 + 4;
        a4 += ~v63;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v63;
    v62 -= 4;
    a3 += v10;
    v64 -= v10;
    a2 += v9;
    v65 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t w16_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = *(void *)(result + 88);
  uint64_t v70 = *(void *)(result + 64);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v10 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 4;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v69 = *(_DWORD *)(result + 188);
  unint64_t v13 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v8)
      {
        uint64_t v22 = (a3 >> 22) & 0x3C0;
        unsigned int v23 = 0x3FFFFFFF;
        HIDWORD(v24) = HIDWORD(a3);
        uint64_t v25 = v70;
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = *(void *)(result + 224) + v8;
        uint64_t v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_34;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v25 = v70;
        unsigned int v23 = v69 | v21;
        uint64_t v24 = v19 - 0x1000000;
        uint64_t v22 = 448;
      }
    }
    else
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v7 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_34;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      uint64_t v25 = v70;
      unsigned int v23 = v69 | v17;
      uint64_t v24 = v15 + 0x1000000;
      uint64_t v22 = 512;
    }
    if (a2 >= v25) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v25 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v69;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v9;
    a3 += v10;
    v11 += 4;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v71)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v71;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v23 = ((v23 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v69;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v23 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v24) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v36) {
    unint64_t v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  }
  else {
    unint64_t v38 = (unsigned __int16 *)v13;
  }
  if (v38 < v37) {
    unint64_t v38 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v22));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      uint64_t v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v13 < (unint64_t)v57) {
        uint64_t v57 = (unsigned __int16 *)v13;
      }
      if (v57 < v37) {
        uint64_t v57 = v37;
      }
      uint64_t v58 = interpolate_16161616_21355[v42];
      char v59 = v42 + 1;
      unint64_t v56 = v39 - ((v58 & v39) >> v59);
      unint64_t v60 = (((bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000) & v58) >> v59;
LABEL_65:
      unint64_t v39 = v56 + v60;
      break;
    case 2:
      int v61 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v61) {
        int v61 = (unsigned __int16 *)v13;
      }
      if (v61 < v37) {
        int v61 = v37;
      }
      unint64_t v52 = (bswap32(*v61) >> 16) | ((unint64_t)(bswap32(v61[1]) >> 16) << 16) | ((unint64_t)(bswap32(v61[2]) >> 16) << 32) | 0xFFFF000000000000;
      int v62 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v62];
      char v55 = v62 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
LABEL_64:
      unint64_t v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      unint64_t v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v43) {
        unint64_t v43 = (unsigned __int16 *)v13;
      }
      if (v43 < v37) {
        unint64_t v43 = v37;
      }
      unint64_t v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v13 >= v45) {
        unint64_t v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned __int16 *)v13;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      uint64_t v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v13 < (unint64_t)v48) {
        uint64_t v48 = (unsigned __int16 *)v13;
      }
      if (v48 < v37) {
        uint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  a3 += v10;
  uint64_t v65 = v8 - a3;
  a2 += v9;
  uint64_t v66 = v71 - a2;
  while (1)
  {
    *(_DWORD *)(v11 + 4 + 4 * v64) = HIDWORD(v39) & 0xFFFF0000 | ((2 * (unsigned __int16)v39
                                                                               + WORD1(v39)
                                                                               + 4 * WORD1(v39)
                                                                               + WORD2(v39)) >> 3);
    *(unsigned char *)(v12 + 1 + v64) = v23 >> 22;
    if (a4 - 1 == v64) {
      return result;
    }
    if (((v65 | v66 | (a3 - v7) | (a2 - v70)) & 0x8000000000000000) != 0)
    {
      v12 += v64 + 1;
      uint64_t v11 = v11 - v63 + 4;
      a4 += ~v64;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v67 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v36 = v67 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v36) {
      int v68 = (unsigned __int16 *)(v67 + 6 * SHIDWORD(a2));
    }
    else {
      int v68 = (unsigned __int16 *)v13;
    }
    if (v68 < v37) {
      int v68 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v39 = (bswap32(*v68) >> 16) | ((unint64_t)(bswap32(v68[1]) >> 16) << 16) | ((unint64_t)(bswap32(v68[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v12 += v64 + 1;
        uint64_t v11 = v11 - v63 + 4;
        a4 += ~v64;
        unsigned int v23 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 4;
    a3 += v10;
    v65 -= v10;
    a2 += v9;
    v66 -= v9;
    unsigned int v23 = -1;
  }
}

uint64_t w16_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v134 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v133 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v133 = v5 % v6;
    }
  }
  else
  {
    uint64_t v133 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v135 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v132 = v11;
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v128 = *(void *)(result + 80);
  uint64_t v130 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (v9) {
    int v14 = 0;
  }
  else {
    int v14 = -65536;
  }
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  int v127 = *(_DWORD *)(result + 188);
  unint64_t v17 = v9 + (v15 * v134) + 2 * (v16 - 1);
  unint64_t v18 = v135 + (v15 * v4) + 2 * v16 - 2;
  uint64_t v129 = *(void *)(result + 64);
  uint64_t v131 = *(void *)(result + 72);
  while (1)
  {
    if (a3 < v131)
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v131 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      if (v21 < 1) {
        goto LABEL_61;
      }
      if (v21 >= v19) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v30 = v127 | v23;
      uint64_t v31 = v20 + 0x1000000;
      uint64_t v28 = a3 - (v20 + 0x1000000);
      uint64_t v29 = 512;
      goto LABEL_25;
    }
    if (a3 <= v130)
    {
      uint64_t v28 = 0;
      uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v30 = 0x3FFFFFFF;
      uint64_t v31 = a3;
      int v22 = a4;
LABEL_25:
      uint64_t v32 = v129;
      goto LABEL_28;
    }
    uint64_t v24 = *(void *)(result + 216);
    uint64_t v25 = *(void *)(result + 224) + v130;
    uint64_t v26 = v25 - a3 + (v24 >> 1);
    int v22 = a4;
    if (v26 < 1) {
      goto LABEL_61;
    }
    if (v26 >= v24) {
      LODWORD(v27) = 0x3FFFFFFF;
    }
    else {
      unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
    }
    uint64_t v32 = v129;
    unsigned int v30 = v127 | v27;
    uint64_t v31 = v25 - 0x1000000;
    uint64_t v28 = a3 - (v25 - 0x1000000);
    uint64_t v29 = 448;
LABEL_28:
    if (a2 >= v32) {
      break;
    }
    uint64_t v33 = *(void *)(result + 192);
    uint64_t v34 = v32 - *(void *)(result + 200);
    uint64_t v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v127;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = a2 - (v34 + 0x1000000);
      uint64_t v38 = 32;
      goto LABEL_39;
    }
LABEL_61:
    int v56 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 4;
    *(unsigned char *)++uint64_t v13 = 0;
LABEL_62:
    a4 = v56;
    if (!v56) {
      return result;
    }
  }
  if (a2 <= v128)
  {
    uint64_t v37 = 0;
    uint64_t v38 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v36 = a2;
    goto LABEL_39;
  }
  uint64_t v39 = *(void *)(result + 192);
  uint64_t v40 = *(void *)(result + 200) + v128;
  uint64_t v41 = v40 - a2 + (v39 >> 1);
  if (v41 < 1) {
    goto LABEL_61;
  }
  if (v41 < v39) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v127;
  }
  uint64_t v36 = v40 - 0x1000000;
  uint64_t v37 = a2 - (v40 - 0x1000000);
  uint64_t v38 = 28;
LABEL_39:
  if (v30 < 0x400000) {
    goto LABEL_61;
  }
  if (v6)
  {
    uint64_t v42 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    uint64_t v43 = (v6 & ((v36 % v6) >> 63)) + v36 % v6;
    if (v42 >= v7) {
      uint64_t v44 = v7;
    }
    else {
      uint64_t v44 = 0;
    }
    uint64_t v31 = v42 - v44;
    if (v43 >= v6) {
      uint64_t v45 = v6;
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v36 = v43 - v45;
    v28 += v31;
    v37 += v36;
  }
  uint64_t v46 = v31 >> 32;
  uint64_t v47 = v135 + SHIDWORD(v31) * (uint64_t)v4;
  unint64_t v48 = (v36 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v49 = (unsigned __int16 *)(v47 + v48);
  char v50 = *(unsigned __int16 **)(result + 32);
  if (v18 >= v47 + v48) {
    unint64_t v51 = (unsigned __int16 *)(v47 + v48);
  }
  else {
    unint64_t v51 = (unsigned __int16 *)v18;
  }
  if (v51 < v50) {
    unint64_t v51 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v52 = *v51;
  if (!v9)
  {
    unint64_t v53 = 0;
    if (!v8) {
      goto LABEL_140;
    }
LABEL_65:
    unsigned int v57 = *(_DWORD *)(v8 + (v38 | v29));
LABEL_67:
    int v58 = v57 & 0xF;
    uint64_t v59 = v57 >> 8;
    int v60 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v88) = SBYTE1(v57);
      if (v6)
      {
        uint64_t v89 = v59 << 56;
        uint64_t v90 = v28 + (v89 >> 24);
        uint64_t v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      uint64_t v93 = (unsigned __int16 *)((char *)v49 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93) {
        uint64_t v93 = (unsigned __int16 *)v18;
      }
      if (v93 < v50) {
        uint64_t v93 = v50;
      }
      unsigned int v94 = *v93;
      if (v9)
      {
        int v95 = (unsigned __int16 *)(v53 + (int)v88 * (uint64_t)v134);
        if (v17 < (unint64_t)v95) {
          int v95 = (unsigned __int16 *)v17;
        }
        if ((unint64_t)v95 < *(void *)(result + 40)) {
          int v95 = *(unsigned __int16 **)(result + 40);
        }
        v94 |= *v95 << 16;
      }
      int v96 = interpolate_1616[v60];
      unsigned int v97 = v52 - ((v96 & v52) >> (v60 + 1));
      unsigned int v98 = (v96 & v94) >> (v60 + 1);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          int v61 = HIBYTE(v57) & 3;
          unsigned int v126 = v30;
          int v125 = v22;
          LODWORD(v62) = SBYTE1(v57);
          uint64_t v63 = SBYTE2(v57);
          if (v6)
          {
            uint64_t v64 = v59 << 56;
            int64_t v65 = (unint64_t)HIWORD(v57) << 56;
            uint64_t v66 = v28 + (v64 >> 24);
            uint64_t v67 = v37 + (v65 >> 24);
            uint64_t v68 = v7 & (v66 >> 63);
            uint64_t v69 = v6 & (v67 >> 63);
            uint64_t v70 = v69 + v67;
            if (v68 + v66 >= v7) {
              uint64_t v71 = v7;
            }
            else {
              uint64_t v71 = 0;
            }
            if (v70 >= v6) {
              uint64_t v72 = v6;
            }
            else {
              uint64_t v72 = 0;
            }
            uint64_t v62 = (v68 + (v64 >> 24) - v71) >> 32;
            uint64_t v63 = (v69 + (v65 >> 24) - v72) >> 32;
          }
          uint64_t v73 = &v49[v63];
          if (v18 < (unint64_t)v73) {
            uint64_t v73 = (unsigned __int16 *)v18;
          }
          if (v73 < v50) {
            uint64_t v73 = v50;
          }
          unsigned int v74 = *v73;
          unint64_t v75 = (unint64_t)v49 + (int)v62 * (uint64_t)v4;
          if (v18 >= v75) {
            unsigned int v76 = (unsigned __int16 *)((char *)v49 + (int)v62 * (uint64_t)v4);
          }
          else {
            unsigned int v76 = (unsigned __int16 *)v18;
          }
          if (v76 < v50) {
            unsigned int v76 = v50;
          }
          unsigned int v77 = *v76;
          unint64_t v78 = (unsigned __int16 *)(v75 + 2 * v63);
          if (v18 < (unint64_t)v78) {
            unint64_t v78 = (unsigned __int16 *)v18;
          }
          if (v78 >= v50) {
            char v50 = v78;
          }
          unsigned int v79 = *v50;
          if (v9)
          {
            uint64_t v80 = v63;
            uint64_t v81 = (unsigned __int16 *)(v53 + 2 * v63);
            unint64_t v82 = *(void *)(result + 40);
            if (v17 < (unint64_t)v81) {
              uint64_t v81 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v81 < v82) {
              uint64_t v81 = *(unsigned __int16 **)(result + 40);
            }
            v74 |= *v81 << 16;
            char v83 = (unsigned __int16 *)(v53 + (int)v62 * (uint64_t)v134);
            if (v17 >= (unint64_t)v83) {
              unint64_t v84 = v83;
            }
            else {
              unint64_t v84 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v84 < v82) {
              unint64_t v84 = *(unsigned __int16 **)(result + 40);
            }
            v77 |= *v84 << 16;
            unint64_t v85 = &v83[v80];
            if (v17 < (unint64_t)v85) {
              unint64_t v85 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v85 < v82) {
              unint64_t v85 = *(unsigned __int16 **)(result + 40);
            }
            v79 |= *v85 << 16;
          }
          int v86 = interpolate_1616[v61];
          unsigned int v87 = v52 - ((v86 & v52) >> (v61 + 1)) + ((v86 & v77) >> (v61 + 1));
          unsigned int v52 = v87
              - ((v87 & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1))
              + (((v74 - ((v86 & v74) >> (v61 + 1)) + ((v86 & v79) >> (v61 + 1))) & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1));
          int v22 = v125;
          unsigned int v30 = v126;
        }
        goto LABEL_140;
      }
      uint64_t v99 = SBYTE2(v57);
      if (v6)
      {
        int64_t v100 = (unint64_t)HIWORD(v57) << 56;
        uint64_t v101 = v37 + (v100 >> 24);
        uint64_t v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6) {
          uint64_t v103 = v6;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      uint64_t v104 = &v49[v99];
      if (v18 < (unint64_t)v104) {
        uint64_t v104 = (unsigned __int16 *)v18;
      }
      if (v104 < v50) {
        uint64_t v104 = v50;
      }
      unsigned int v105 = *v104;
      if (v9)
      {
        uint64_t v106 = (unsigned __int16 *)(v53 + 2 * v99);
        if (v17 < (unint64_t)v106) {
          uint64_t v106 = (unsigned __int16 *)v17;
        }
        if ((unint64_t)v106 < *(void *)(result + 40)) {
          uint64_t v106 = *(unsigned __int16 **)(result + 40);
        }
        v105 |= *v106 << 16;
      }
      int v107 = (v57 >> 28) & 3;
      int v108 = interpolate_1616[v107];
      LOBYTE(v107) = v107 + 1;
      unsigned int v97 = v52 - ((v108 & v52) >> v107);
      unsigned int v98 = (v108 & v105) >> v107;
    }
    unsigned int v52 = v97 + v98;
    goto LABEL_140;
  }
  unint64_t v53 = v9 + (int)v46 * (uint64_t)v134 + v48;
  uint64_t v54 = *(unsigned __int16 **)(result + 40);
  if (v17 >= v53) {
    char v55 = (unsigned __int16 *)v53;
  }
  else {
    char v55 = (unsigned __int16 *)v17;
  }
  if (v55 >= v54) {
    uint64_t v54 = v55;
  }
  v52 |= *v54 << 16;
  if (v8) {
    goto LABEL_65;
  }
LABEL_140:
  *(_DWORD *)(v12 + 4) = v52 | v14;
  *(unsigned char *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    int v109 = v22;
    uint64_t v110 = 0;
    a2 += v5;
    uint64_t v111 = v128 - a2;
    a3 += v10;
    uint64_t v112 = v130 - a3;
    uint64_t v113 = -4;
    while (((v112 | v111 | (a3 - v131) | (a2 - v129)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        uint64_t v115 = (v6 & ((v37 + v133) >> 63)) + v37 + v133;
        if (v114 >= v7) {
          uint64_t v116 = v7;
        }
        else {
          uint64_t v116 = 0;
        }
        uint64_t v117 = v114 - v116;
        if (v115 >= v6) {
          uint64_t v118 = v6;
        }
        else {
          uint64_t v118 = 0;
        }
        uint64_t v119 = v115 - v118;
        uint64_t v37 = v119;
        uint64_t v28 = v117;
      }
      else
      {
        uint64_t v119 = a2;
        uint64_t v117 = a3;
      }
      uint64_t v120 = v117 >> 32;
      unint64_t v121 = (v119 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v49 = (unsigned __int16 *)(v135 + SHIDWORD(v117) * (uint64_t)v4 + v121);
      char v50 = *(unsigned __int16 **)(result + 32);
      if (v18 >= (unint64_t)v49) {
        float v122 = v49;
      }
      else {
        float v122 = (unsigned __int16 *)v18;
      }
      if (v122 < v50) {
        float v122 = *(unsigned __int16 **)(result + 32);
      }
      unsigned int v52 = *v122;
      if (v9)
      {
        unint64_t v53 = v9 + (int)v120 * (uint64_t)v134 + v121;
        float v123 = *(unsigned __int16 **)(result + 40);
        if (v17 >= v53) {
          float v124 = (unsigned __int16 *)v53;
        }
        else {
          float v124 = (unsigned __int16 *)v17;
        }
        if (v124 >= v123) {
          float v123 = v124;
        }
        v52 |= *v123 << 16;
      }
      if (v8)
      {
        unsigned int v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          int v22 = ~v110 + v109;
          unsigned int v30 = -1;
          goto LABEL_67;
        }
      }
      *(_DWORD *)(v12 + 4 * v110 + 8) = v52 | v14;
      *(unsigned char *)(v13 + v110++ + 2) = -1;
      v113 -= 4;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == v110) {
        return result;
      }
    }
    v13 += v110 + 1;
    v12 -= v113;
    int v56 = ~v110 + v109;
    goto LABEL_62;
  }
  return result;
}

uint64_t w16_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v134 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v133 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v133 = v5 % v6;
    }
  }
  else
  {
    uint64_t v133 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v135 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v132 = v11;
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v128 = *(void *)(result + 80);
  uint64_t v130 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (v9) {
    int v14 = 0;
  }
  else {
    int v14 = -65536;
  }
  int v15 = *(_DWORD *)(result + 260) - 1;
  uint64_t v16 = *(unsigned int *)(result + 256);
  int v127 = *(_DWORD *)(result + 188);
  unint64_t v17 = v9 + (v15 * v134) + 2 * (v16 - 1);
  unint64_t v18 = v135 + (v15 * v4) + 2 * v16 - 2;
  uint64_t v129 = *(void *)(result + 64);
  uint64_t v131 = *(void *)(result + 72);
  while (1)
  {
    if (a3 < v131)
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v131 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      if (v21 < 1) {
        goto LABEL_61;
      }
      if (v21 >= v19) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v30 = v127 | v23;
      uint64_t v31 = v20 + 0x1000000;
      uint64_t v28 = a3 - v31;
      uint64_t v29 = 512;
      goto LABEL_25;
    }
    if (a3 <= v130)
    {
      uint64_t v28 = 0;
      uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v30 = 0x3FFFFFFF;
      uint64_t v31 = a3;
      int v22 = a4;
LABEL_25:
      uint64_t v32 = v129;
      goto LABEL_28;
    }
    uint64_t v24 = *(void *)(result + 216);
    uint64_t v25 = *(void *)(result + 224) + v130;
    uint64_t v26 = v25 - a3 + (v24 >> 1);
    int v22 = a4;
    if (v26 < 1) {
      goto LABEL_61;
    }
    if (v26 >= v24) {
      LODWORD(v27) = 0x3FFFFFFF;
    }
    else {
      unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
    }
    uint64_t v32 = v129;
    unsigned int v30 = v127 | v27;
    uint64_t v31 = v25 - 0x1000000;
    uint64_t v28 = a3 - v31;
    uint64_t v29 = 448;
LABEL_28:
    if (a2 >= v32) {
      break;
    }
    uint64_t v33 = *(void *)(result + 192);
    uint64_t v34 = v32 - *(void *)(result + 200);
    uint64_t v35 = a2 - v34 + (v33 >> 1);
    if (v35 >= 1)
    {
      if (v35 < v33) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v127;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = a2 - (v34 + 0x1000000);
      uint64_t v38 = 32;
      goto LABEL_39;
    }
LABEL_61:
    int v56 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 4;
    *(unsigned char *)++uint64_t v13 = 0;
LABEL_62:
    a4 = v56;
    if (!v56) {
      return result;
    }
  }
  if (a2 <= v128)
  {
    uint64_t v37 = 0;
    uint64_t v38 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v36 = a2;
    goto LABEL_39;
  }
  uint64_t v39 = *(void *)(result + 192);
  uint64_t v40 = *(void *)(result + 200) + v128;
  uint64_t v41 = v40 - a2 + (v39 >> 1);
  if (v41 < 1) {
    goto LABEL_61;
  }
  if (v41 < v39) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v41) >> 32) >> 15)) | v127;
  }
  uint64_t v36 = v40 - 0x1000000;
  uint64_t v37 = a2 - (v40 - 0x1000000);
  uint64_t v38 = 28;
LABEL_39:
  if (v30 < 0x400000) {
    goto LABEL_61;
  }
  if (v6)
  {
    uint64_t v42 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    uint64_t v43 = (v6 & ((v36 % v6) >> 63)) + v36 % v6;
    if (v42 >= v7) {
      uint64_t v44 = v7;
    }
    else {
      uint64_t v44 = 0;
    }
    uint64_t v31 = v42 - v44;
    if (v43 >= v6) {
      uint64_t v45 = v6;
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v36 = v43 - v45;
    v28 += v31;
    v37 += v36;
  }
  uint64_t v46 = v31 >> 32;
  uint64_t v47 = v36 >> 31;
  unint64_t v48 = v47 & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v49 = v135 + (int)v46 * (uint64_t)v4 + (v47 & 0xFFFFFFFFFFFFFFFELL);
  char v50 = *(unsigned __int16 **)(result + 32);
  if (v18 >= v49) {
    unint64_t v51 = (unsigned __int16 *)(v135 + (int)v46 * (uint64_t)v4 + (v47 & 0xFFFFFFFFFFFFFFFELL));
  }
  else {
    unint64_t v51 = (unsigned __int16 *)v18;
  }
  if (v51 < v50) {
    unint64_t v51 = *(unsigned __int16 **)(result + 32);
  }
  unsigned int v52 = bswap32(*v51) >> 16;
  if (!v9)
  {
    unint64_t v53 = 0;
    if (!v8) {
      goto LABEL_140;
    }
LABEL_65:
    unsigned int v57 = *(_DWORD *)(v8 + (v38 | v29));
LABEL_67:
    int v58 = v57 & 0xF;
    uint64_t v59 = v57 >> 8;
    int v60 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v88) = SBYTE1(v57);
      if (v6)
      {
        uint64_t v89 = v59 << 56;
        uint64_t v90 = v28 + (v89 >> 24);
        uint64_t v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      uint64_t v93 = (unsigned __int16 *)(v49 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93) {
        uint64_t v93 = (unsigned __int16 *)v18;
      }
      if (v93 < v50) {
        uint64_t v93 = v50;
      }
      unsigned int v94 = bswap32(*v93) >> 16;
      if (v9)
      {
        int v95 = (unsigned __int16 *)(v53 + (int)v88 * (uint64_t)v134);
        if (v17 < (unint64_t)v95) {
          int v95 = (unsigned __int16 *)v17;
        }
        if ((unint64_t)v95 < *(void *)(result + 40)) {
          int v95 = *(unsigned __int16 **)(result + 40);
        }
        v94 |= bswap32(*v95) & 0xFFFF0000;
      }
      int v96 = interpolate_1616[v60];
      unsigned int v97 = v52 - ((v96 & v52) >> (v60 + 1));
      unsigned int v98 = (v96 & v94) >> (v60 + 1);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          int v61 = HIBYTE(v57) & 3;
          unsigned int v126 = v30;
          int v125 = v22;
          LODWORD(v62) = SBYTE1(v57);
          uint64_t v63 = SBYTE2(v57);
          if (v6)
          {
            uint64_t v64 = v59 << 56;
            int64_t v65 = (unint64_t)HIWORD(v57) << 56;
            uint64_t v66 = v28 + (v64 >> 24);
            uint64_t v67 = v37 + (v65 >> 24);
            uint64_t v68 = v7 & (v66 >> 63);
            uint64_t v69 = v6 & (v67 >> 63);
            uint64_t v70 = v69 + v67;
            if (v68 + v66 >= v7) {
              uint64_t v71 = v7;
            }
            else {
              uint64_t v71 = 0;
            }
            if (v70 >= v6) {
              uint64_t v72 = v6;
            }
            else {
              uint64_t v72 = 0;
            }
            uint64_t v62 = (v68 + (v64 >> 24) - v71) >> 32;
            uint64_t v63 = (v69 + (v65 >> 24) - v72) >> 32;
          }
          uint64_t v73 = (unsigned __int16 *)(v49 + 2 * v63);
          if (v18 < (unint64_t)v73) {
            uint64_t v73 = (unsigned __int16 *)v18;
          }
          if (v73 < v50) {
            uint64_t v73 = v50;
          }
          unsigned int v74 = bswap32(*v73) >> 16;
          unint64_t v75 = v49 + (int)v62 * (uint64_t)v4;
          if (v18 >= v75) {
            unsigned int v76 = (unsigned __int16 *)(v49 + (int)v62 * (uint64_t)v4);
          }
          else {
            unsigned int v76 = (unsigned __int16 *)v18;
          }
          if (v76 < v50) {
            unsigned int v76 = v50;
          }
          unsigned int v77 = bswap32(*v76) >> 16;
          unint64_t v78 = (unsigned __int16 *)(v75 + 2 * v63);
          if (v18 < (unint64_t)v78) {
            unint64_t v78 = (unsigned __int16 *)v18;
          }
          if (v78 >= v50) {
            char v50 = v78;
          }
          unsigned int v79 = bswap32(*v50) >> 16;
          if (v9)
          {
            uint64_t v80 = v63;
            uint64_t v81 = (unsigned __int16 *)(v53 + 2 * v63);
            unint64_t v82 = *(void *)(result + 40);
            if (v17 < (unint64_t)v81) {
              uint64_t v81 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v81 < v82) {
              uint64_t v81 = *(unsigned __int16 **)(result + 40);
            }
            v74 |= bswap32(*v81) & 0xFFFF0000;
            char v83 = (unsigned __int16 *)(v53 + (int)v62 * (uint64_t)v134);
            if (v17 >= (unint64_t)v83) {
              unint64_t v84 = v83;
            }
            else {
              unint64_t v84 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v84 < v82) {
              unint64_t v84 = *(unsigned __int16 **)(result + 40);
            }
            v77 |= bswap32(*v84) & 0xFFFF0000;
            unint64_t v85 = &v83[v80];
            if (v17 < (unint64_t)v85) {
              unint64_t v85 = (unsigned __int16 *)v17;
            }
            if ((unint64_t)v85 < v82) {
              unint64_t v85 = *(unsigned __int16 **)(result + 40);
            }
            v79 |= bswap32(*v85) & 0xFFFF0000;
          }
          int v86 = interpolate_1616[v61];
          unsigned int v87 = v52 - ((v86 & v52) >> (v61 + 1)) + ((v86 & v77) >> (v61 + 1));
          unsigned int v52 = v87
              - ((v87 & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1))
              + (((v74 - ((v86 & v74) >> (v61 + 1)) + ((v86 & v79) >> (v61 + 1))) & interpolate_1616[(v57 >> 28) & 3]) >> (((v57 >> 28) & 3) + 1));
          int v22 = v125;
          unsigned int v30 = v126;
        }
        goto LABEL_140;
      }
      uint64_t v99 = SBYTE2(v57);
      if (v6)
      {
        int64_t v100 = (unint64_t)HIWORD(v57) << 56;
        uint64_t v101 = v37 + (v100 >> 24);
        uint64_t v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6) {
          uint64_t v103 = v6;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      uint64_t v104 = (unsigned __int16 *)(v49 + 2 * v99);
      if (v18 < (unint64_t)v104) {
        uint64_t v104 = (unsigned __int16 *)v18;
      }
      if (v104 < v50) {
        uint64_t v104 = v50;
      }
      unsigned int v105 = bswap32(*v104) >> 16;
      if (v9)
      {
        uint64_t v106 = (unsigned __int16 *)(v53 + 2 * v99);
        if (v17 < (unint64_t)v106) {
          uint64_t v106 = (unsigned __int16 *)v17;
        }
        if ((unint64_t)v106 < *(void *)(result + 40)) {
          uint64_t v106 = *(unsigned __int16 **)(result + 40);
        }
        v105 |= bswap32(*v106) & 0xFFFF0000;
      }
      int v107 = (v57 >> 28) & 3;
      int v108 = interpolate_1616[v107];
      LOBYTE(v107) = v107 + 1;
      unsigned int v97 = v52 - ((v108 & v52) >> v107);
      unsigned int v98 = (v108 & v105) >> v107;
    }
    unsigned int v52 = v97 + v98;
    goto LABEL_140;
  }
  unint64_t v53 = v9 + (int)v46 * (uint64_t)v134 + v48;
  uint64_t v54 = *(unsigned __int16 **)(result + 40);
  if (v17 >= v53) {
    char v55 = (unsigned __int16 *)v53;
  }
  else {
    char v55 = (unsigned __int16 *)v17;
  }
  if (v55 >= v54) {
    uint64_t v54 = v55;
  }
  v52 |= bswap32(*v54) & 0xFFFF0000;
  if (v8) {
    goto LABEL_65;
  }
LABEL_140:
  *(_DWORD *)(v12 + 4) = v52 | v14;
  *(unsigned char *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    int v109 = v22;
    uint64_t v110 = 0;
    a2 += v5;
    uint64_t v111 = v128 - a2;
    a3 += v10;
    uint64_t v112 = v130 - a3;
    uint64_t v113 = -4;
    while (((v112 | v111 | (a3 - v131) | (a2 - v129)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        uint64_t v115 = (v6 & ((v37 + v133) >> 63)) + v37 + v133;
        if (v114 >= v7) {
          uint64_t v116 = v7;
        }
        else {
          uint64_t v116 = 0;
        }
        uint64_t v117 = v114 - v116;
        if (v115 >= v6) {
          uint64_t v118 = v6;
        }
        else {
          uint64_t v118 = 0;
        }
        uint64_t v119 = v115 - v118;
        uint64_t v37 = v119;
        uint64_t v28 = v117;
      }
      else
      {
        uint64_t v119 = a2;
        uint64_t v117 = a3;
      }
      uint64_t v120 = v117 >> 32;
      unint64_t v121 = (v119 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v49 = v135 + SHIDWORD(v117) * (uint64_t)v4 + v121;
      char v50 = *(unsigned __int16 **)(result + 32);
      if (v18 >= v49) {
        float v122 = (unsigned __int16 *)v49;
      }
      else {
        float v122 = (unsigned __int16 *)v18;
      }
      if (v122 < v50) {
        float v122 = *(unsigned __int16 **)(result + 32);
      }
      unsigned int v52 = bswap32(*v122) >> 16;
      if (v9)
      {
        unint64_t v53 = v9 + (int)v120 * (uint64_t)v134 + v121;
        float v123 = *(unsigned __int16 **)(result + 40);
        if (v17 >= v53) {
          float v124 = (unsigned __int16 *)v53;
        }
        else {
          float v124 = (unsigned __int16 *)v17;
        }
        if (v124 >= v123) {
          float v123 = v124;
        }
        v52 |= bswap32(*v123) & 0xFFFF0000;
      }
      if (v8)
      {
        unsigned int v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          int v22 = ~v110 + v109;
          unsigned int v30 = -1;
          goto LABEL_67;
        }
      }
      *(_DWORD *)(v12 + 4 * v110 + 8) = v52 | v14;
      *(unsigned char *)(v13 + v110++ + 2) = -1;
      v113 -= 4;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == v110) {
        return result;
      }
    }
    v13 += v110 + 1;
    v12 -= v113;
    int v56 = ~v110 + v109;
    goto LABEL_62;
  }
  return result;
}

uint64_t w16_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v84 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v88 = *(void *)(result + 152) - 4;
  uint64_t v86 = *(void *)(result + 88);
  uint64_t v87 = *(void *)(result + 144) - 1;
  if (v5) {
    int v11 = 0;
  }
  else {
    int v11 = -16777216;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v82 = *(_DWORD *)(result + 188);
  int v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v7));
  unint64_t v15 = v4 + v13 + (v12 * v6) - 1;
  uint64_t v85 = *(void *)(result + 72);
  uint64_t v83 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v85)
    {
      if (a3 <= v86)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v83;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v86;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v83;
        unsigned int v25 = v82 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v85 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v83;
      unsigned int v25 = v82 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v82;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v10;
    a3 += v9;
    *(unsigned char *)++uint64_t v87 = 0;
    v88 += 4;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v84)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v84;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v82;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v4 + (int)v36 * (uint64_t)v6;
  unint64_t v38 = v37 + (v31 >> 32);
  uint64_t v39 = *(unsigned __int8 **)(result + 32);
  if (v15 >= v38) {
    uint64_t v40 = (unsigned __int8 *)(v37 + (v31 >> 32));
  }
  else {
    uint64_t v40 = (unsigned __int8 *)v15;
  }
  if (v40 < v39) {
    uint64_t v40 = *(unsigned __int8 **)(result + 32);
  }
  unsigned int v41 = *v40;
  if (!v5)
  {
    unint64_t v42 = 0;
    if (!v8) {
      goto LABEL_103;
    }
LABEL_46:
    unsigned int v45 = *(_DWORD *)(v8 + (v32 | v24));
LABEL_48:
    int v46 = v45 & 0xF;
    int v47 = HIBYTE(v45) & 3;
    if (v46 == 1)
    {
      uint64_t v63 = (unsigned __int8 *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      if (v15 < (unint64_t)v63) {
        uint64_t v63 = (unsigned __int8 *)v15;
      }
      if (v63 < v39) {
        uint64_t v63 = v39;
      }
      unsigned int v64 = *v63;
      if (v5)
      {
        int64_t v65 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
        if (v14 < v65) {
          int64_t v65 = v14;
        }
        if ((unint64_t)v65 < *(void *)(result + 40)) {
          int64_t v65 = *(unsigned __int8 **)(result + 40);
        }
        v64 |= *v65 << 24;
      }
      int v66 = interpolate_8888_21358[v47];
      char v67 = v47 + 1;
      unsigned int v68 = v41 - ((v66 & v41) >> v67);
      unsigned int v69 = (v66 & v64) >> v67;
    }
    else
    {
      if (v46 != 2)
      {
        if (v46 == 3)
        {
          unint64_t v48 = (unsigned __int8 *)(v38 + SBYTE2(v45));
          if (v15 < (unint64_t)v48) {
            unint64_t v48 = (unsigned __int8 *)v15;
          }
          if (v48 < v39) {
            unint64_t v48 = v39;
          }
          unsigned int v49 = *v48;
          unint64_t v50 = v38 + SBYTE1(v45) * (uint64_t)v6;
          if (v15 >= v50) {
            unint64_t v51 = (unsigned __int8 *)(v38 + SBYTE1(v45) * (uint64_t)v6);
          }
          else {
            unint64_t v51 = (unsigned __int8 *)v15;
          }
          if (v51 < v39) {
            unint64_t v51 = v39;
          }
          unsigned int v52 = *v51;
          unint64_t v53 = (unsigned __int8 *)(v50 + SBYTE2(v45));
          if (v15 < (unint64_t)v53) {
            unint64_t v53 = (unsigned __int8 *)v15;
          }
          if (v53 < v39) {
            unint64_t v53 = v39;
          }
          unsigned int v54 = *v53;
          if (v5)
          {
            char v55 = (unsigned __int8 *)(v42 + SBYTE2(v45));
            unint64_t v56 = *(void *)(result + 40);
            if (v14 < v55) {
              char v55 = v14;
            }
            if ((unint64_t)v55 < v56) {
              char v55 = *(unsigned __int8 **)(result + 40);
            }
            v49 |= *v55 << 24;
            unint64_t v57 = v42 + SBYTE1(v45) * (uint64_t)v7;
            if ((unint64_t)v14 >= v57) {
              int v58 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v7);
            }
            else {
              int v58 = v14;
            }
            if ((unint64_t)v58 < v56) {
              int v58 = *(unsigned __int8 **)(result + 40);
            }
            v52 |= *v58 << 24;
            uint64_t v59 = (unsigned __int8 *)(v57 + SBYTE2(v45));
            if (v14 < v59) {
              uint64_t v59 = v14;
            }
            if ((unint64_t)v59 < v56) {
              uint64_t v59 = *(unsigned __int8 **)(result + 40);
            }
            v54 |= *v59 << 24;
          }
          int v60 = interpolate_8888_21358[v47];
          char v61 = v47 + 1;
          unsigned int v62 = v41 - ((v60 & v41) >> v61) + ((v60 & v52) >> v61);
          unsigned int v41 = v62
              - ((v62 & interpolate_8888_21358[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1))
              + (((v49 - ((v60 & v49) >> v61) + ((v60 & v54) >> v61)) & interpolate_8888_21358[(v45 >> 28) & 3]) >> (((v45 >> 28) & 3) + 1));
        }
        goto LABEL_103;
      }
      uint64_t v70 = (unsigned __int8 *)(v38 + SBYTE2(v45));
      if (v15 < (unint64_t)v70) {
        uint64_t v70 = (unsigned __int8 *)v15;
      }
      if (v70 < v39) {
        uint64_t v70 = v39;
      }
      unsigned int v71 = *v70;
      if (v5)
      {
        uint64_t v72 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v72) {
          uint64_t v72 = v14;
        }
        if ((unint64_t)v72 < *(void *)(result + 40)) {
          uint64_t v72 = *(unsigned __int8 **)(result + 40);
        }
        v71 |= *v72 << 24;
      }
      int v73 = (v45 >> 28) & 3;
      int v74 = interpolate_8888_21358[v73];
      LOBYTE(v73) = v73 + 1;
      unsigned int v68 = v41 - ((v74 & v41) >> v73);
      unsigned int v69 = (v74 & v71) >> v73;
    }
    unsigned int v41 = v68 + v69;
    goto LABEL_103;
  }
  unint64_t v42 = v5 + (int)v36 * (uint64_t)v7 + (v31 >> 32);
  uint64_t v43 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v14 >= v42) {
    uint64_t v44 = (unsigned __int8 *)v42;
  }
  else {
    uint64_t v44 = v14;
  }
  if (v44 >= v43) {
    uint64_t v43 = v44;
  }
  v41 |= *v43 << 24;
  if (v8) {
    goto LABEL_46;
  }
LABEL_103:
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  a3 += v9;
  uint64_t v77 = v86 - a3;
  a2 += v10;
  uint64_t v78 = v84 - a2;
  while (1)
  {
    *(_DWORD *)(v88 + 4 + 4 * v75) = (v41 | v11) & 0xFF000000 | ((v41 | v11) >> 8) & 0xFFFF0000 | (v41 << 8) | v41;
    *(unsigned char *)(v87 + 1 + v75) = v25 >> 22;
    if (a4 - 1 == v75) {
      return result;
    }
    if ((v77 | v78 | (a3 - v85) | (a2 - v83)) < 0)
    {
      v87 += v75 + 1;
      uint64_t v88 = v88 - v76 + 4;
      a4 += ~v75;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
    uint64_t v39 = *(unsigned __int8 **)(result + 32);
    if (v15 >= v38) {
      unsigned int v79 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
    }
    else {
      unsigned int v79 = (unsigned __int8 *)v15;
    }
    if (v79 < v39) {
      unsigned int v79 = *(unsigned __int8 **)(result + 32);
    }
    unsigned int v41 = *v79;
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      uint64_t v80 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42) {
        unint64_t v81 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
      }
      else {
        unint64_t v81 = (unint64_t)v14;
      }
      if (v81 >= (unint64_t)v80) {
        uint64_t v80 = (unsigned __int8 *)v81;
      }
      v41 |= *v80 << 24;
    }
    if (v8)
    {
      unsigned int v45 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        v87 += v75 + 1;
        uint64_t v88 = v88 - v76 + 4;
        a4 += ~v75;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v76 -= 4;
    ++v75;
    a3 += v9;
    v77 -= v9;
    a2 += v10;
    v78 -= v10;
    unsigned int v25 = -1;
  }
}

uint64_t w16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)unint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x1000000)
  {
    if (*(void *)(v5 + 16))
    {
      int v14 = w16_shade_radial_W;
    }
    else if (*(void *)(v5 + 24))
    {
      int v14 = w16_shade_conic_W;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      int v14 = w16_shade_axial_W;
    }
    else
    {
      int v14 = w16_shade_custom_W;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 1, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 960)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 1, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v16 = malloc_type_malloc(4 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  w16_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void w16_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v436 = *MEMORY[0x1E4F143B8];
  uint64_t v423 = *(unsigned int *)(a1 + 4);
  uint64_t v422 = (int)v423;
  unint64_t v4 = ((int)v423 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    float v9 = *(float *)(a2 + 184);
    __n128 v434 = *(int **)(a1 + 136);
    uint64_t v435 = v7;
    uint64_t v10 = *(void *)(a2 + 104);
    uint64_t v431 = *(void *)(a2 + 96);
    uint64_t v432 = v10;
    uint64_t v11 = *(int *)(a1 + 24);
    unint64_t v12 = *(int *)(a1 + 28);
    uint64_t v13 = *(int *)(a1 + 16);
    uint64_t v433 = *(int *)(a1 + 20);
    uint64_t v14 = *(int *)(a1 + 12);
    int v430 = *(_DWORD *)(a1 + 8);
    unint64_t v424 = (void *)a2;
    uint64_t v15 = *(int *)(a2 + 16);
    uint64_t v16 = (v15 + 6) * v4;
    if (v16 > 65439)
    {
      long long v20 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
      long long v18 = v20;
      long long v21 = v424;
      if (!v20) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](a1, a4);
      long long v18 = (char *)&v413 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v18, v17);
      long long v20 = 0;
      long long v21 = v424;
    }
    uint64_t v421 = a1;
    int v427 = a3;
    unint64_t v22 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v23 = v22 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    v21[20] = v23;
    if (v15) {
      uint64_t v24 = 4 * v4;
    }
    else {
      uint64_t v24 = 0;
    }
    unint64_t v25 = v23 + v24;
    uint64_t v26 = v8 + (v11 - 1) * v12;
    unint64_t v27 = v12 >> 1;
    v21[18] = v22;
    v21[19] = v25;
    if (v435)
    {
      uint64_t v28 = v421;
      unint64_t v29 = (unint64_t)*(int *)(v421 + 32) >> 1;
      long long v30 = (_WORD *)(v435 + 2 * (v14 + v29 * v13));
      uint64_t v428 = v29 - v422;
      uint64_t v31 = v422;
      uint64_t v32 = 1;
    }
    else
    {
      long long v30 = 0;
      uint64_t v428 = 0;
      uint64_t v32 = 0;
      uint64_t v28 = v421;
      uint64_t v31 = v422;
    }
    int v429 = (int)(v9 * 65535.9);
    uint64_t v33 = v26 + 2 * v433;
    long long v34 = (unsigned __int16 *)(v8 + 2 * (v14 + v27 * v13));
    uint64_t v426 = v27 - v31;
    uint64_t v35 = *(int *)(v28 + 104);
    int v36 = *(_DWORD *)(v28 + 108);
    int v37 = *(unsigned __int8 *)(v28 + 2);
    if (v37 == 6 || v37 == 1)
    {
      uint64_t v39 = v423;
      unint64_t v38 = v424;
      uint64_t v40 = v431;
      uint64_t v41 = v432;
      if (v434)
      {
        unint64_t v414 = v27;
        v417 = v20;
        unint64_t v42 = 0;
        int v43 = 0;
        uint64_t v44 = *(int *)(v421 + 124);
        uint64_t v45 = (unsigned __int8 *)v434 + v35 + (int)v44 * (uint64_t)v36;
        uint64_t v31 = v422;
        uint64_t v425 = v44 - v422;
        goto LABEL_31;
      }
LABEL_577:
      if (v20) {
        free(v20);
      }
      return;
    }
    v417 = v20;
    uint64_t v39 = v423;
    unint64_t v38 = v424;
    uint64_t v41 = v432;
    if (v434)
    {
      uint64_t v415 = v33;
      uint64_t v416 = v32;
      shape_enum_clip_alloc((uint64_t)v20, v19, v434, 1, 1, 1, v35, v36, v423, v430);
      if (v46)
      {
        __n128 v434 = v46;
        unint64_t v414 = v27;
        int v47 = 0;
        uint64_t v48 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
        if (!v15) {
          uint64_t v48 = 4 * v4;
        }
        uint64_t v49 = v422;
        uint64_t v425 = -v422;
        uint64_t v45 = (unsigned __int8 *)(v25 + v48 + 16);
        uint64_t v50 = v435;
        uint64_t v40 = v431;
        goto LABEL_21;
      }
LABEL_576:
      long long v20 = v417;
      goto LABEL_577;
    }
    unint64_t v414 = v27;
    uint64_t v45 = 0;
    unint64_t v42 = 0;
    uint64_t v425 = 0;
    int v43 = 0;
    uint64_t v40 = v431;
LABEL_31:
    int v56 = v429 ^ 0xFFFF;
    int32x2_t v57 = vdup_n_s32(v429 ^ 0xFFFFu);
    uint64_t v420 = (v39 - 1) + 1;
    uint64_t v418 = -v31;
    uint64_t v415 = v33;
    __n128 v419 = (unsigned __int16 *)(v33 - 2);
    uint64_t v416 = v32;
    uint64_t v58 = 2 * v32;
    int32x2_t v59 = vdup_n_s32(0x101u);
    int v60 = v42;
LABEL_32:
    LODWORD(v433) = v43;
    __n128 v434 = v60;
    char v61 = (void (*)(void *, uint64_t, uint64_t, uint64_t))*v38;
    uint64_t v431 = v40;
    uint64_t v432 = v41;
    v61(v38, v40, v41, v39);
    uint64_t v63 = (unsigned __int16 *)v38[20];
    unsigned int v64 = (unsigned char *)v38[18];
    unsigned int v65 = *((_DWORD *)v38 + 2);
    if (v65 == *((_DWORD *)v38 + 3))
    {
      if (v429 == 0xFFFF)
      {
        uint64_t v50 = v435;
        int v68 = v433;
      }
      else
      {
        int v66 = v39;
        char v67 = (unsigned char *)v38[18];
        uint64_t v50 = v435;
        int v68 = v433;
        do
        {
          if (*v67) {
            *(_DWORD *)uint64_t v63 = ((unsigned __int16)*(_DWORD *)v63
          }
                            - (((unsigned __int16)*(_DWORD *)v63 * v56
                              + (((unsigned __int16)*(_DWORD *)v63 * v56) >> 16)
                              + 1) >> 16)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((HIWORD(*(_DWORD *)v63) * v56
                                               + ((HIWORD(*(_DWORD *)v63) * v56) >> 16)
                                               + 1) >> 16)) << 16);
          ++v67;
          v63 += 2;
          --v66;
        }
        while (v66);
        v63 += 2 * v418;
        v64 += v420 + v418;
      }
    }
    else
    {
      uint64_t v69 = v38[19];
      int v70 = HIWORD(v65) & 0x3F;
      if (v70 == 16)
      {
        uint64_t v50 = v435;
        int v68 = v433;
        uint64_t v78 = 0;
        if (v429 == 0xFFFF)
        {
          do
          {
            if (v64[v78]) {
              *(_DWORD *)&v63[2 * v78] = *(_DWORD *)(v69 + 4 * v78);
            }
            ++v78;
          }
          while (v39 != v78);
        }
        else
        {
          do
          {
            if (v64[v78])
            {
              int v79 = (unsigned __int16)*(_DWORD *)(v69 + 4 * v78);
              *(_DWORD *)&v63[2 * v78] = (v79 - ((v79 * v56 + ((v79 * v56) >> 16) + 1) >> 16)) | ((HIWORD(*(_DWORD *)(v69 + 4 * v78)) - ((HIWORD(*(_DWORD *)(v69 + 4 * v78)) * v56 + ((HIWORD(*(_DWORD *)(v69 + 4 * v78)) * v56) >> 16) + 1) >> 16)) << 16);
            }
            ++v78;
          }
          while (v39 != v78);
        }
      }
      else
      {
        uint64_t v50 = v435;
        int v68 = v433;
        if (v70 == 32)
        {
          if (v429 == 0xFFFF)
          {
            uint64_t v85 = 0;
            uint64_t v86 = (float *)(v69 + 4);
            do
            {
              if (v64[v85])
              {
                float v87 = *v86;
                if (*v86 <= 0.0)
                {
                  int v91 = 0;
                }
                else
                {
                  int v88 = (int)(float)((float)(v87 * 65535.0) + 0.5);
                  float v89 = *(v86 - 1);
                  if (v87 > 1.0)
                  {
                    int v88 = 0xFFFF;
                    float v87 = 1.0;
                  }
                  int v90 = v88;
                  if (v89 <= v87)
                  {
                    if (v89 >= 0.0) {
                      int v90 = (int)(float)((float)(v89 * 65535.0) + 0.5);
                    }
                    else {
                      int v90 = 0;
                    }
                  }
                  int v91 = v90 | (v88 << 16);
                }
                *(_DWORD *)&v63[2 * v85] = v91;
              }
              v86 += 2;
              ++v85;
            }
            while (v39 != v85);
          }
          else
          {
            uint64_t v71 = 0;
            uint64_t v72 = (float *)(v69 + 4);
            do
            {
              if (v64[v71])
              {
                float v73 = *v72;
                if (*v72 <= 0.0)
                {
                  unsigned int v77 = 0;
                }
                else
                {
                  int v74 = (int)(float)((float)(v73 * 65535.0) + 0.5);
                  float v75 = *(v72 - 1);
                  if (v73 > 1.0)
                  {
                    int v74 = 0xFFFF;
                    float v73 = 1.0;
                  }
                  int v76 = v74;
                  if (v75 <= v73)
                  {
                    if (v75 >= 0.0) {
                      int v76 = (int)(float)((float)(v75 * 65535.0) + 0.5);
                    }
                    else {
                      int v76 = 0;
                    }
                  }
                  unsigned int v77 = (v76 - ((v76 * v56 + ((v76 * v56) >> 16) + 1) >> 16)) | ((v74
                                                                                              - ((v74 * v56
                                                                                                + ((v74 * v56) >> 16)
                                                                                                + 1) >> 16)) << 16);
                }
                *(_DWORD *)&v63[2 * v71] = v77;
              }
              v72 += 2;
              ++v71;
            }
            while (v39 != v71);
          }
        }
        else if (v429 == 0xFFFF)
        {
          uint64_t v92 = 0;
          do
          {
            if (v64[v92]) {
              *(_DWORD *)&v63[2 * v92] = *(_DWORD *)(v69 + 4 * v92) & 0xFF000000 | (*(_DWORD *)(v69 + 4 * v92) >> 8) & 0xFFFF0000 | (*(_DWORD *)(v69 + 4 * v92) << 8) | *(_DWORD *)(v69 + 4 * v92);
            }
            ++v92;
          }
          while (v39 != v92);
        }
        else
        {
          uint64_t v80 = 0;
          do
          {
            if (v64[v80])
            {
              v62.i32[0] = *(_DWORD *)(v69 + 4 * v80);
              v81.i32[0] = vshr_n_u32((uint32x2_t)v62, 0x18uLL).u32[0];
              v81.i32[1] = vdup_n_s32(*(_DWORD *)(v69 + 4 * v80)).u8[4];
              int32x2_t v82 = vmul_s32(v81, v59);
              uint32x2_t v83 = (uint32x2_t)vmul_s32(v82, v57);
              int32x2_t v62 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v83, v83, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL);
              int32x2_t v84 = vsub_s32(v82, v62);
              *(_DWORD *)&v63[2 * v80] = v84.i32[1] | (v84.i32[0] << 16);
            }
            ++v80;
          }
          while (v39 != v80);
        }
      }
    }
    switch(v427)
    {
      case 0:
        uint64_t v93 = v45 != 0;
        int v94 = v39;
        int v95 = v45;
        if (v50)
        {
          uint64_t v96 = v431;
          do
          {
            int v97 = *v64;
            if (*v64)
            {
              if (v45) {
                int v97 = ((unsigned __int16)(*v95 * (_WORD)v97 + ((*v95 * v97) >> 8) + 1) >> 8);
              }
              if (v97)
              {
                if (v97 == 255)
                {
                  LOWORD(v98) = 0;
                  *long long v34 = 0;
                }
                else
                {
                  int v99 = (unsigned __int16)*v30;
                  int v100 = v97 | (v97 << 8);
                  *v34 -= (v100 * *v34 + ((v100 * *v34) >> 16) + 1) >> 16;
                  int v98 = v99 - ((v100 * v99 + ((v100 * v99) >> 16) + 1) >> 16);
                }
                *long long v30 = v98;
              }
            }
            ++v64;
            v95 += v93;
            ++v34;
            ++v30;
            --v94;
          }
          while (v94);
        }
        else
        {
          uint64_t v96 = v431;
          do
          {
            int v356 = *v64;
            if (*v64)
            {
              if (v45) {
                int v356 = ((unsigned __int16)(*v95 * (_WORD)v356 + ((*v95 * v356) >> 8) + 1) >> 8);
              }
              if (v356)
              {
                if (v356 == 255) {
                  LOWORD(v357) = 0;
                }
                else {
                  unsigned int v357 = *v34 - ((257 * v356 * *v34 + ((257 * v356 * *v34) >> 16) + 1) >> 16);
                }
                *long long v34 = v357;
              }
            }
            ++v64;
            v95 += v93;
            ++v34;
            --v94;
          }
          while (v94);
        }
        uint64_t v358 = v425;
        goto LABEL_524;
      case 1:
        int v101 = *v64;
        if (v50)
        {
          uint64_t v102 = v64 + 1;
          uint64_t v103 = v30 - 1;
          uint64_t v104 = v34 - 1;
          int v105 = v39;
          if (v45)
          {
            uint64_t v106 = v432;
            do
            {
              if (v101)
              {
                unsigned int v107 = *v45 * v101 + ((*v45 * v101) >> 8) + 1;
                if (BYTE1(v107))
                {
                  if (BYTE1(v107) == 255)
                  {
                    unsigned int v108 = *(_DWORD *)v63;
                    unsigned int v109 = *(_DWORD *)v63;
                  }
                  else
                  {
                    int v110 = 257 * (v107 >> 8);
                    unsigned int v111 = (unsigned __int16)v110;
                    int v112 = (unsigned __int16)~(_WORD)v110;
                    unsigned int v113 = (unsigned __int16)*(_DWORD *)v63 * v111 + v104[1] * v112;
                    unsigned int v114 = v113 + HIWORD(v113) + 1;
                    unsigned int v109 = HIWORD(*(_DWORD *)v63) * (v112 | v111) + ((HIWORD(*(_DWORD *)v63) * (v112 | v111)) >> 16) + 1;
                    unsigned int v108 = HIWORD(v114);
                  }
                  v104[1] = v108;
                  v103[1] = HIWORD(v109);
                }
              }
              int v115 = *v102++;
              int v101 = v115;
              v63 += 2;
              ++v45;
              ++v103;
              ++v104;
              --v105;
            }
            while (v105);
            v45 += v425;
          }
          else
          {
            uint64_t v106 = v432;
            do
            {
              if (v101)
              {
                if (v101 == 255)
                {
                  unsigned int v379 = *(_DWORD *)v63;
                  unsigned int v380 = *(_DWORD *)v63;
                }
                else
                {
                  int v381 = v101 | (v101 << 8);
                  unsigned int v380 = 0xFFFF * HIWORD(*(_DWORD *)v63) + ((0xFFFF * HIWORD(*(_DWORD *)v63)) >> 16) + 1;
                  unsigned int v379 = ((unsigned __int16)*(_DWORD *)v63 * v381
                        + v104[1] * (v381 ^ 0xFFFF)
                        + (((unsigned __int16)*(_DWORD *)v63 * v381 + v104[1] * (v381 ^ 0xFFFFu)) >> 16)
                        + 1) >> 16;
                }
                v104[1] = v379;
                v103[1] = HIWORD(v380);
              }
              int v382 = *v102++;
              int v101 = v382;
              v63 += 2;
              ++v103;
              ++v104;
              --v105;
            }
            while (v105);
            uint64_t v45 = 0;
          }
          float v383 = &v104[v426];
          goto LABEL_547;
        }
        if (v45)
        {
          unint64_t v359 = v64 + 1;
          int v360 = v39;
          uint64_t v106 = v432;
          do
          {
            if (v101)
            {
              unsigned int v361 = *v45 * v101 + ((*v45 * v101) >> 8) + 1;
              v362 = *(unsigned __int16 **)(v421 + 40);
              int v363 = v419;
              if (v419 >= v34) {
                int v363 = v34;
              }
              if (v363 >= v362) {
                v362 = v363;
              }
              if (BYTE1(v361))
              {
                if (BYTE1(v361) == 255)
                {
                  unsigned int v364 = *(_DWORD *)v63;
                }
                else
                {
                  int v365 = 257 * (v361 >> 8);
                  unsigned int v364 = (*v63 * (unsigned __int16)v365
                        + *v362 * (unsigned __int16)~(_WORD)v365
                        + ((*v63 * (unsigned __int16)v365 + *v362 * (unsigned __int16)~(_WORD)v365) >> 16)
                        + 1) >> 16;
                }
                unsigned __int16 *v362 = v364;
              }
            }
            else
            {
              v362 = v34;
            }
            int v366 = *v359++;
            int v101 = v366;
            v63 += 2;
            ++v45;
            long long v34 = v362 + 1;
            --v360;
          }
          while (v360);
          goto LABEL_514;
        }
        unsigned int v398 = *(unsigned __int16 **)(v421 + 40);
        unsigned int v399 = v64 + 1;
        int v400 = v39;
        uint64_t v106 = v432;
        do
        {
          v362 = v419;
          if (v419 >= v34) {
            v362 = v34;
          }
          if (v362 < v398) {
            v362 = v398;
          }
          if (v101)
          {
            if (v101 == 255)
            {
              unsigned int v401 = *(_DWORD *)v63;
            }
            else
            {
              int v402 = v101 | (v101 << 8);
              unsigned int v401 = (*v63 * v402 + *v362 * (v402 ^ 0xFFFF) + ((*v63 * v402 + *v362 * (v402 ^ 0xFFFFu)) >> 16) + 1) >> 16;
            }
            unsigned __int16 *v362 = v401;
          }
          int v403 = *v399++;
          int v101 = v403;
          v63 += 2;
          long long v34 = v362 + 1;
          --v400;
        }
        while (v400);
        goto LABEL_571;
      case 2:
        int v116 = *v64;
        if (v50)
        {
          uint64_t v117 = v64 + 1;
          uint64_t v103 = v30 - 1;
          uint64_t v118 = v34 - 1;
          int v119 = v39;
          if (v45)
          {
            uint64_t v106 = v432;
            while (1)
            {
              if (!v116) {
                goto LABEL_127;
              }
              unsigned int v120 = *v45 * v116 + ((*v45 * v116) >> 8) + 1;
              if (!BYTE1(v120)) {
                goto LABEL_127;
              }
              if (BYTE1(v120) == 255)
              {
                unsigned int v121 = *(_DWORD *)v63;
                int v122 = HIWORD(*(_DWORD *)v63);
                if (v122)
                {
                  if (v122 == 0xFFFF)
                  {
                    v118[1] = v121;
                    LOWORD(v121) = -1;
                  }
                  else
                  {
                    int v131 = v122 ^ 0xFFFF;
                    unsigned int v132 = v131 * v118[1];
                    unsigned int v133 = (v131 * (unsigned __int16)v103[1]
                          + ((v131 * (unsigned __int16)v103[1]) >> 16)
                          + 1) >> 16;
                    v118[1] = v121 + ((v132 + HIWORD(v132) + 1) >> 16);
                    unsigned int v121 = v133 + HIWORD(v121);
                  }
                  goto LABEL_126;
                }
              }
              else
              {
                int v123 = HIWORD(*(_DWORD *)v63);
                int v124 = (257 * (v120 >> 8)) ^ 0xFFFF;
                unsigned int v125 = v123 * v124 + ((v123 * v124) >> 16) + 1;
                unsigned int v126 = (unsigned __int16)*(_DWORD *)v63
                     - (((unsigned __int16)*(_DWORD *)v63 * v124
                       + (((unsigned __int16)*(_DWORD *)v63 * v124) >> 16)
                       + 1) >> 16);
                unsigned int v127 = v126 | ((v123 - HIWORD(v125)) << 16);
                if (HIWORD(v127))
                {
                  int v128 = HIWORD(v127) ^ 0xFFFF;
                  unsigned int v129 = v128 * v118[1] + ((v128 * v118[1]) >> 16) + 1;
                  unsigned int v130 = (v128 * (unsigned __int16)v103[1] + ((v128 * (unsigned __int16)v103[1]) >> 16) + 1) >> 16;
                  v118[1] = v126 + HIWORD(v129);
                  unsigned int v121 = v130 + HIWORD(v127);
LABEL_126:
                  v103[1] = v121;
                }
              }
LABEL_127:
              int v134 = *v117++;
              int v116 = v134;
              v63 += 2;
              ++v45;
              ++v103;
              ++v118;
              if (!--v119)
              {
                v45 += v425;
                goto LABEL_546;
              }
            }
          }
          uint64_t v106 = v432;
          while (1)
          {
            if (v116)
            {
              if (v116 == 255)
              {
                unsigned int v384 = *(_DWORD *)v63;
                int v385 = HIWORD(*(_DWORD *)v63);
                if (v385)
                {
                  if (v385 == 0xFFFF)
                  {
                    v118[1] = v384;
                    LOWORD(v384) = -1;
                  }
                  else
                  {
                    int v394 = v385 ^ 0xFFFF;
                    unsigned int v395 = v394 * v118[1];
                    unsigned int v396 = (v394 * (unsigned __int16)v103[1]
                          + ((v394 * (unsigned __int16)v103[1]) >> 16)
                          + 1) >> 16;
                    v118[1] = v384 + ((v395 + HIWORD(v395) + 1) >> 16);
                    unsigned int v384 = v396 + HIWORD(v384);
                  }
                  goto LABEL_543;
                }
              }
              else
              {
                int v386 = HIWORD(*(_DWORD *)v63);
                int v387 = (257 * v116) ^ 0xFFFF;
                unsigned int v388 = v386 * v387 + ((v386 * v387) >> 16) + 1;
                unsigned int v389 = (unsigned __int16)*(_DWORD *)v63
                     - (((unsigned __int16)*(_DWORD *)v63 * v387
                       + (((unsigned __int16)*(_DWORD *)v63 * v387) >> 16)
                       + 1) >> 16);
                unsigned int v390 = v389 | ((v386 - HIWORD(v388)) << 16);
                if (HIWORD(v390))
                {
                  int v391 = HIWORD(v390) ^ 0xFFFF;
                  unsigned int v392 = v391 * v118[1] + ((v391 * v118[1]) >> 16) + 1;
                  unsigned int v393 = (v391 * (unsigned __int16)v103[1] + ((v391 * (unsigned __int16)v103[1]) >> 16) + 1) >> 16;
                  v118[1] = v389 + HIWORD(v392);
                  unsigned int v384 = v393 + HIWORD(v390);
LABEL_543:
                  v103[1] = v384;
                }
              }
            }
            int v397 = *v117++;
            int v116 = v397;
            v63 += 2;
            ++v103;
            ++v118;
            if (!--v119)
            {
              uint64_t v45 = 0;
LABEL_546:
              float v383 = &v118[v426];
LABEL_547:
              long long v34 = v383 + 1;
              long long v30 = &v103[v428 + 1];
LABEL_573:
              uint64_t v96 = v431;
LABEL_446:
              if (!--v430)
              {
LABEL_574:
                if (v434) {
                  free(v434);
                }
                goto LABEL_576;
              }
              int v60 = 0;
              int v43 = v68 + 1;
              uint64_t v40 = v38[16] + v96;
              uint64_t v41 = v38[17] + v106;
              if (v434)
              {
                int v47 = v43;
                uint64_t v49 = v422;
LABEL_21:
                uint64_t v51 = v428 + v49;
                while (1)
                {
                  while (1)
                  {
                    int v52 = *((_DWORD *)v45 - 4);
                    int v53 = v52 - v47;
                    if (v52 <= v47) {
                      break;
                    }
                    v430 -= v53;
                    if (v430 < 1) {
                      goto LABEL_574;
                    }
                    v40 += v38[16] * v53;
                    v41 += v38[17] * v53;
                    v34 += v414 * v53;
                    uint64_t v55 = v51 * v53;
                    if (!v50) {
                      uint64_t v55 = 0;
                    }
                    v30 += v55;
                    int v47 = v52;
                  }
                  int v43 = v47;
                  if (v47 < *((_DWORD *)v45 - 3) + v52) {
                    break;
                  }
                  int v54 = shape_enum_clip_scan((uint64_t)v434, (_DWORD *)v45 - 4);
                  uint64_t v50 = v435;
                  if (!v54) {
                    goto LABEL_574;
                  }
                }
                uint64_t v31 = v422;
                uint64_t v32 = v416;
                uint64_t v33 = v415;
                unint64_t v42 = v434;
                goto LABEL_31;
              }
              goto LABEL_32;
            }
          }
        }
        v367 = v64 + 1;
        v362 = v34 - 1;
        int v368 = v39;
        if (v45)
        {
          uint64_t v106 = v432;
          while (1)
          {
            if (!v116) {
              goto LABEL_513;
            }
            unsigned int v369 = *v45 * v116 + ((*v45 * v116) >> 8) + 1;
            if (!BYTE1(v369)) {
              goto LABEL_513;
            }
            if (BYTE1(v369) == 255)
            {
              unsigned int v370 = *(_DWORD *)v63;
              int v371 = HIWORD(*(_DWORD *)v63);
              if (v371)
              {
                if (v371 != 0xFFFF)
                {
                  int v372 = v362[1];
                  unsigned int v373 = v371 ^ 0xFFFF;
                  goto LABEL_511;
                }
                goto LABEL_512;
              }
            }
            else
            {
              int v374 = HIWORD(*(_DWORD *)v63);
              int v375 = (257 * (v369 >> 8)) ^ 0xFFFF;
              unsigned int v376 = v374 * v375 + ((v374 * v375) >> 16) + 1;
              unsigned int v370 = (unsigned __int16)*(_DWORD *)v63
                   - (((unsigned __int16)*(_DWORD *)v63 * v375
                     + (((unsigned __int16)*(_DWORD *)v63 * v375) >> 16)
                     + 1) >> 16);
              unsigned int v377 = v370 | ((v374 - HIWORD(v376)) << 16);
              if (v377 >= 0x10000)
              {
                int v372 = v362[1];
                unsigned int v373 = ~v377 >> 16;
LABEL_511:
                v370 += (v373 * v372 + ((v373 * v372) >> 16) + 1) >> 16;
LABEL_512:
                v362[1] = v370;
              }
            }
LABEL_513:
            int v378 = *v367++;
            int v116 = v378;
            v63 += 2;
            ++v45;
            ++v362;
            if (!--v368)
            {
LABEL_514:
              v45 += v425;
LABEL_572:
              long long v34 = &v362[v426 + 1];
              v30 += v428;
              goto LABEL_573;
            }
          }
        }
        uint64_t v106 = v432;
        while (1)
        {
          if (v116)
          {
            if (v116 == 255)
            {
              unsigned int v404 = *(_DWORD *)v63;
              int v405 = HIWORD(*(_DWORD *)v63);
              if (v405)
              {
                if (v405 != 0xFFFF)
                {
                  int v406 = v362[1];
                  unsigned int v407 = v405 ^ 0xFFFF;
                  goto LABEL_568;
                }
                goto LABEL_569;
              }
            }
            else
            {
              int v408 = HIWORD(*(_DWORD *)v63);
              int v409 = (257 * v116) ^ 0xFFFF;
              unsigned int v410 = v408 * v409 + ((v408 * v409) >> 16) + 1;
              unsigned int v404 = (unsigned __int16)*(_DWORD *)v63
                   - (((unsigned __int16)*(_DWORD *)v63 * v409
                     + (((unsigned __int16)*(_DWORD *)v63 * v409) >> 16)
                     + 1) >> 16);
              unsigned int v411 = v404 | ((v408 - HIWORD(v410)) << 16);
              if (v411 >= 0x10000)
              {
                int v406 = v362[1];
                unsigned int v407 = ~v411 >> 16;
LABEL_568:
                v404 += (v407 * v406 + ((v407 * v406) >> 16) + 1) >> 16;
LABEL_569:
                v362[1] = v404;
              }
            }
          }
          int v412 = *v367++;
          int v116 = v412;
          v63 += 2;
          ++v362;
          if (!--v368)
          {
LABEL_571:
            uint64_t v45 = 0;
            goto LABEL_572;
          }
        }
      case 3:
        int v135 = v39;
        float v136 = v45;
        do
        {
          int v137 = *v64;
          if (*v64)
          {
            if (v45) {
              int v137 = ((unsigned __int16)(*v136 * (_WORD)v137 + ((*v136 * v137) >> 8) + 1) >> 8);
            }
            if (v137)
            {
              if (v137 == 255)
              {
                int v138 = HIWORD(*(_DWORD *)v63);
                int v139 = (unsigned __int16)*v30 ^ 0xFFFF;
                *long long v34 = *(_DWORD *)v63
                     - (((unsigned __int16)*(_DWORD *)v63 * v139
                       + (((unsigned __int16)*(_DWORD *)v63 * v139) >> 16)
                       + 1) >> 16);
                unsigned int v140 = v138 - ((v138 * v139 + ((v138 * v139) >> 16) + 1) >> 16);
              }
              else
              {
                int v141 = v137 | (v137 << 8);
                unsigned int v142 = (unsigned __int16)*v30 * v141 + (((unsigned __int16)*v30 * v141) >> 16) + 1;
                v141 ^= 0xFFFFu;
                unsigned int v143 = *v34 * v141 + HIWORD(v142) * (unsigned __int16)*(_DWORD *)v63;
                unsigned int v144 = (v141 + HIWORD(v142)) * HIWORD(*(_DWORD *)v63);
                unsigned int v140 = (v144 + HIWORD(v144) + 1) >> 16;
                *long long v34 = (v143 + HIWORD(v143) + 1) >> 16;
              }
              *long long v30 = v140;
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v135;
        }
        while (v135);
        goto LABEL_419;
      case 4:
        int v145 = v39;
        float v136 = v45;
        do
        {
          int v146 = *v64;
          if (*v64)
          {
            if (v45) {
              int v146 = ((unsigned __int16)(*v136 * (_WORD)v146 + ((*v136 * v146) >> 8) + 1) >> 8);
            }
            if (v146)
            {
              if (v146 == 255)
              {
                int v147 = HIWORD(*(_DWORD *)v63);
                int v148 = (unsigned __int16)*v30;
                *long long v34 = *(_DWORD *)v63
                     - (((unsigned __int16)*(_DWORD *)v63 * v148
                       + (((unsigned __int16)*(_DWORD *)v63 * v148) >> 16)
                       + 1) >> 16);
                unsigned int v149 = v147 - ((v147 * v148 + ((v147 * v148) >> 16) + 1) >> 16);
              }
              else
              {
                int v150 = v146 | (v146 << 8);
                unsigned int v151 = ((unsigned __int16)*v30 ^ 0xFFFF) * v150
                     + ((((unsigned __int16)*v30 ^ 0xFFFFu) * v150) >> 16)
                     + 1;
                v150 ^= 0xFFFFu;
                unsigned int v152 = *v34 * v150 + HIWORD(v151) * (unsigned __int16)*(_DWORD *)v63;
                unsigned int v153 = (v150 + HIWORD(v151)) * HIWORD(*(_DWORD *)v63);
                unsigned int v149 = (v153 + HIWORD(v153) + 1) >> 16;
                *long long v34 = (v152 + HIWORD(v152) + 1) >> 16;
              }
              *long long v30 = v149;
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v145;
        }
        while (v145);
        goto LABEL_419;
      case 5:
        int v154 = v39;
        float v136 = v45;
        do
        {
          int v155 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v155 = ((unsigned __int16)(*v136 * (_WORD)v155
                                                            + ((*v136 * v155) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v156 = (unsigned __int16)*v30;
              int v157 = (v155 | (v155 << 8)) ^ 0xFFFF;
              unsigned int v158 = (unsigned __int16)*(_DWORD *)v63
                   - (((unsigned __int16)*(_DWORD *)v63 * v157
                     + (((unsigned __int16)*(_DWORD *)v63 * v157) >> 16)
                     + 1) >> 16);
              unsigned int v159 = (v158 | ((HIWORD(*(_DWORD *)v63)
                             - ((HIWORD(*(_DWORD *)v63) * v157
                               + ((HIWORD(*(_DWORD *)v63) * v157) >> 16)
                               + 1) >> 16)) << 16)) >> 16;
              unsigned int v160 = (unsigned __int16)v158 * v156 + (v159 ^ 0xFFFF) * *v34;
              *long long v34 = (v160 + HIWORD(v160) + 1) >> 16;
              *long long v30 = (((v159 ^ 0xFFFF) + v156) * v159 + ((((v159 ^ 0xFFFF) + v156) * v159) >> 16) + 1) >> 16;
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v154;
        }
        while (v154);
        goto LABEL_419;
      case 6:
        int v161 = v39;
        float v136 = v45;
        do
        {
          int v162 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v162 = ((unsigned __int16)(*v136 * (_WORD)v162
                                                            + ((*v136 * v162) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v163 = (unsigned __int16)*v30;
              if ((_WORD)v163 != 0xFFFF)
              {
                if ((unsigned __int16)~(_WORD)v163 == 0xFFFF)
                {
                  int v164 = HIWORD(*(_DWORD *)v63);
                  int v165 = (v162 | (v162 << 8)) ^ 0xFFFF;
                  *long long v34 = *v63
                       - (((unsigned __int16)*(_DWORD *)v63 * v165
                         + (((unsigned __int16)*(_DWORD *)v63 * v165) >> 16)
                         + 1) >> 16);
                  int v166 = v164 - ((v164 * v165 + ((v164 * v165) >> 16) + 1) >> 16);
                }
                else
                {
                  int v167 = HIWORD(*(_DWORD *)v63);
                  unsigned int v168 = (257 * v162 * (unsigned __int16)~(_WORD)v163
                        + ((257 * v162 * (unsigned __int16)~(_WORD)v163) >> 16)
                        + 1) >> 16;
                  *v34 += ((unsigned __int16)*(_DWORD *)v63 * v168
                         + (((unsigned __int16)*(_DWORD *)v63 * v168) >> 16)
                         + 1) >> 16;
                  int v166 = v163 + ((v167 * v168 + ((v167 * v168) >> 16) + 1) >> 16);
                }
                *long long v30 = v166;
              }
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v161;
        }
        while (v161);
        goto LABEL_419;
      case 7:
        uint64_t v169 = v45 != 0;
        int v170 = v39;
        float v136 = v45;
        if (v50)
        {
          do
          {
            int v171 = *v64;
            if (*v64)
            {
              if (v45) {
                int v171 = ((unsigned __int16)(*v136 * (_WORD)v171 + ((*v136 * v171) >> 8) + 1) >> 8);
              }
              if (v171)
              {
                if (v171 == 255)
                {
                  int v172 = (unsigned __int16)*v30;
                  unsigned int v173 = ~*(_DWORD *)v63 >> 16;
                  *v34 -= (v173 * *v34 + ((v173 * *v34) >> 16) + 1) >> 16;
                  unsigned int v174 = v172 - ((v173 * v172 + ((v173 * v172) >> 16) + 1) >> 16);
                }
                else
                {
                  unsigned int v175 = ((v171 | (v171 << 8)) ^ 0xFFFF)
                       + ((v63[1] * (v171 | (v171 << 8)) + ((v63[1] * (v171 | (v171 << 8))) >> 16) + 1) >> 16);
                  unsigned int v176 = v175 * *v34;
                  unsigned int v174 = (v175 * (unsigned __int16)*v30 + ((v175 * (unsigned __int16)*v30) >> 16) + 1) >> 16;
                  *long long v34 = (v176 + HIWORD(v176) + 1) >> 16;
                }
                *long long v30 = v174;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v169;
            ++v34;
            ++v30;
            --v170;
          }
          while (v170);
        }
        else
        {
          do
          {
            int v177 = *v64;
            if (*v64)
            {
              if (v45) {
                int v177 = ((unsigned __int16)(*v136 * (_WORD)v177 + ((*v136 * v177) >> 8) + 1) >> 8);
              }
              if (v177)
              {
                if (v177 == 255)
                {
                  unsigned int v178 = *v34
                       - (((~*(_DWORD *)v63 >> 16) * *v34
                         + (((~*(_DWORD *)v63 >> 16) * *v34) >> 16)
                         + 1) >> 16);
                }
                else
                {
                  int v179 = v177 | (v177 << 8);
                  unsigned int v180 = v63[1] * v179 + ((v63[1] * v179) >> 16) + 1;
                  unsigned int v178 = (((v179 ^ 0xFFFF) + HIWORD(v180)) * *v34
                        + ((((v179 ^ 0xFFFF) + HIWORD(v180)) * *v34) >> 16)
                        + 1) >> 16;
                }
                *long long v34 = v178;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v169;
            ++v34;
            --v170;
          }
          while (v170);
        }
        goto LABEL_419;
      case 8:
        uint64_t v181 = v45 != 0;
        int v182 = v39;
        float v136 = v45;
        if (v50)
        {
          do
          {
            int v183 = *v64;
            if (*v64)
            {
              if (v45) {
                int v183 = ((unsigned __int16)(*v136 * (_WORD)v183 + ((*v136 * v183) >> 8) + 1) >> 8);
              }
              if (v183)
              {
                if (v183 == 255)
                {
                  int v184 = (unsigned __int16)*v30;
                  int v185 = HIWORD(*(_DWORD *)v63);
                  *v34 -= (v185 * *v34 + ((v185 * *v34) >> 16) + 1) >> 16;
                  unsigned int v186 = v184 - ((v185 * v184 + ((v185 * v184) >> 16) + 1) >> 16);
                }
                else
                {
                  unsigned int v187 = ((v183 | (v183 << 8)) ^ 0xFFFF)
                       + (((~*(_DWORD *)v63 >> 16) * (v183 | (v183 << 8))
                         + (((~*(_DWORD *)v63 >> 16) * (v183 | (v183 << 8))) >> 16)
                         + 1) >> 16);
                  unsigned int v188 = v187 * *v34;
                  unsigned int v186 = (v187 * (unsigned __int16)*v30 + ((v187 * (unsigned __int16)*v30) >> 16) + 1) >> 16;
                  *long long v34 = (v188 + HIWORD(v188) + 1) >> 16;
                }
                *long long v30 = v186;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v181;
            ++v34;
            ++v30;
            --v182;
          }
          while (v182);
        }
        else
        {
          do
          {
            int v189 = *v64;
            if (*v64)
            {
              if (v45) {
                int v189 = ((unsigned __int16)(*v136 * (_WORD)v189 + ((*v136 * v189) >> 8) + 1) >> 8);
              }
              if (v189)
              {
                if (v189 == 255)
                {
                  unsigned int v190 = *v34 - ((v63[1] * *v34 + ((v63[1] * *v34) >> 16) + 1) >> 16);
                }
                else
                {
                  int v191 = v189 | (v189 << 8);
                  unsigned int v192 = (~*(_DWORD *)v63 >> 16) * v191
                       + (((~*(_DWORD *)v63 >> 16) * v191) >> 16)
                       + 1;
                  unsigned int v190 = (((v191 ^ 0xFFFF) + HIWORD(v192)) * *v34
                        + ((((v191 ^ 0xFFFF) + HIWORD(v192)) * *v34) >> 16)
                        + 1) >> 16;
                }
                *long long v34 = v190;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v181;
            ++v34;
            --v182;
          }
          while (v182);
        }
        goto LABEL_419;
      case 9:
        int v193 = v39;
        float v136 = v45;
        do
        {
          int v194 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v194 = ((unsigned __int16)(*v136 * (_WORD)v194
                                                            + ((*v136 * v194) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned __int16 v195 = ~(v194 | ((_WORD)v194 << 8));
              unsigned int v196 = ((unsigned __int16)*(_DWORD *)v63
                    - (((unsigned __int16)*(_DWORD *)v63 * v195
                      + (((unsigned __int16)*(_DWORD *)v63 * v195) >> 16)
                      + 1) >> 16)) | ((HIWORD(*(_DWORD *)v63)
                                     - ((HIWORD(*(_DWORD *)v63) * v195
                                       + ((HIWORD(*(_DWORD *)v63) * v195) >> 16)
                                       + 1) >> 16)) << 16);
              int v197 = (unsigned __int16)*v30 ^ 0xFFFF;
              unsigned int v198 = (unsigned __int16)(*(_DWORD *)v63
                                      - (((unsigned __int16)*(_DWORD *)v63 * v195
                                        + (((unsigned __int16)*(_DWORD *)v63 * v195) >> 16)
                                        + 1) >> 16))
                   * v197
                   + (unsigned __int16)(v195 + HIWORD(v196)) * *v34;
              unsigned int v199 = (v197 + (unsigned __int16)(v195 + HIWORD(v196))) * HIWORD(v196);
              *long long v34 = (v198 + HIWORD(v198) + 1) >> 16;
              *long long v30 = (v199 + HIWORD(v199) + 1) >> 16;
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v193;
        }
        while (v193);
        goto LABEL_419;
      case 10:
        int v200 = v39;
        float v136 = v45;
        do
        {
          int v201 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v201 = ((unsigned __int16)(*v136 * (_WORD)v201
                                                            + ((*v136 * v201) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v202 = (v201 | (v201 << 8)) ^ 0xFFFF;
              unsigned int v203 = (unsigned __int16)*(_DWORD *)v63
                   - (((unsigned __int16)*(_DWORD *)v63 * v202
                     + (((unsigned __int16)*(_DWORD *)v63 * v202) >> 16)
                     + 1) >> 16);
              unsigned int v204 = (v203 | ((HIWORD(*(_DWORD *)v63)
                             - ((HIWORD(*(_DWORD *)v63) * v202
                               + ((HIWORD(*(_DWORD *)v63) * v202) >> 16)
                               + 1) >> 16)) << 16)) >> 16;
              int v205 = (unsigned __int16)*v30 ^ 0xFFFF;
              unsigned int v206 = (unsigned __int16)v203 * v205 + (v204 ^ 0xFFFF) * *v34;
              *long long v34 = (v206 + HIWORD(v206) + 1) >> 16;
              *long long v30 = (((v204 ^ 0xFFFF) + v205) * v204 + ((((v204 ^ 0xFFFF) + v205) * v204) >> 16) + 1) >> 16;
            }
          }
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v200;
        }
        while (v200);
        goto LABEL_419;
      case 11:
        uint64_t v207 = v45 != 0;
        int v208 = v39;
        float v136 = v45;
        if (v50)
        {
          do
          {
            int v209 = *v64;
            if (*v64)
            {
              if (!v45
                || (int v209 = ((unsigned __int16)(*v136 * (_WORD)v209
                                                              + ((*v136 * v209) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v210 = (v209 | (v209 << 8)) ^ 0xFFFF;
                unsigned int v211 = (unsigned __int16)*(_DWORD *)v63
                     - ((v210 * (unsigned __int16)*(_DWORD *)v63
                       + ((v210 * (unsigned __int16)*(_DWORD *)v63) >> 16)
                       + 1) >> 16);
                unsigned int v212 = v211 | ((HIWORD(*(_DWORD *)v63)
                              - ((v210 * HIWORD(*(_DWORD *)v63)
                                + ((v210 * HIWORD(*(_DWORD *)v63)) >> 16)
                                + 1) >> 16)) << 16);
                int v213 = (unsigned __int16)*v30;
                int v214 = v213 - (*v34 + (unsigned __int16)v211) + HIWORD(v212);
                unsigned int v215 = v213 + HIWORD(v212);
                if (v214 >= 0xFFFF) {
                  LOWORD(v214) = -1;
                }
                if (v215 >= 0xFFFF) {
                  LOWORD(v215) = -1;
                }
                *long long v34 = v215 - v214;
                *long long v30 = v215;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v207;
            ++v34;
            ++v30;
            --v208;
          }
          while (v208);
        }
        else
        {
          do
          {
            int v216 = *v64;
            if (*v64)
            {
              if (!v45
                || (int v216 = ((unsigned __int16)(*v136 * (_WORD)v216
                                                              + ((*v136 * v216) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v217 = (v216 | (v216 << 8)) ^ 0xFFFF;
                unsigned int v218 = (unsigned __int16)*(_DWORD *)v63
                     - ((v217 * (unsigned __int16)*(_DWORD *)v63
                       + ((v217 * (unsigned __int16)*(_DWORD *)v63) >> 16)
                       + 1) >> 16);
                signed int v219 = (*v34 ^ 0xFFFF)
                     - (unsigned __int16)v218
                     + ((v218 | ((HIWORD(*(_DWORD *)v63)
                                - ((v217 * HIWORD(*(_DWORD *)v63)
                                  + ((v217 * HIWORD(*(_DWORD *)v63)) >> 16)
                                  + 1) >> 16)) << 16)) >> 16);
                if (v219 >= 0xFFFF) {
                  LOWORD(v219) = -1;
                }
                *long long v34 = ~(_WORD)v219;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v207;
            ++v34;
            --v208;
          }
          while (v208);
        }
        goto LABEL_419;
      case 12:
        uint64_t v220 = v45 != 0;
        int v221 = v39;
        float v136 = v45;
        if (v50)
        {
          do
          {
            int v222 = *v64;
            if (*v64)
            {
              if (!v45
                || (int v222 = ((unsigned __int16)(*v136 * (_WORD)v222
                                                              + ((*v136 * v222) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v223 = (v222 | (v222 << 8)) ^ 0xFFFF;
                unsigned int v224 = (unsigned __int16)*(_DWORD *)v63
                     - ((v223 * (unsigned __int16)*(_DWORD *)v63
                       + ((v223 * (unsigned __int16)*(_DWORD *)v63) >> 16)
                       + 1) >> 16);
                unsigned int v225 = *v34 + (unsigned __int16)v224;
                unsigned int v226 = (unsigned __int16)*v30
                     + ((v224 | ((HIWORD(*(_DWORD *)v63)
                                - ((v223 * HIWORD(*(_DWORD *)v63)
                                  + ((v223 * HIWORD(*(_DWORD *)v63)) >> 16)
                                  + 1) >> 16)) << 16)) >> 16);
                if (v225 >= 0xFFFF) {
                  LOWORD(v225) = -1;
                }
                if (v226 >= 0xFFFF) {
                  LOWORD(v226) = -1;
                }
                *long long v34 = v225;
                *long long v30 = v226;
              }
            }
            ++v64;
            v63 += 2;
            v136 += v220;
            ++v34;
            ++v30;
            --v221;
          }
          while (v221);
          goto LABEL_419;
        }
        uint64_t v96 = v431;
        do
        {
          if (*v64
            && (!v45
             || ((*v136 * *v64 + ((*v136 * *v64) >> 8) + 1) & 0xFF00) != 0))
          {
            *long long v34 = (2 * *v34) | ((__int16)*v34 >> 15);
          }
          ++v64;
          v136 += v220;
          ++v34;
          --v221;
        }
        while (v221);
        uint64_t v358 = v420;
        if (!v45) {
          uint64_t v358 = 0;
        }
        int v95 = &v45[v425];
LABEL_524:
        uint64_t v45 = &v95[v358];
        v34 += v426;
        v30 += v428;
        uint64_t v106 = v432;
        goto LABEL_446;
      case 13:
        int v227 = v39;
        float v136 = v45;
        while (1)
        {
          int v228 = *v64;
          if (!*v64) {
            goto LABEL_274;
          }
          if (v45)
          {
            int v228 = ((unsigned __int16)(*v136 * (_WORD)v228 + ((*v136 * v228) >> 8) + 1) >> 8);
            if (!v228) {
              goto LABEL_274;
            }
          }
          int v229 = (v228 | (v228 << 8)) ^ 0xFFFF;
          unsigned int v230 = (unsigned __int16)*(_DWORD *)v63
               - ((v229 * (unsigned __int16)*(_DWORD *)v63
                 + ((v229 * (unsigned __int16)*(_DWORD *)v63) >> 16)
                 + 1) >> 16);
          unsigned int v231 = v230 | ((HIWORD(*(_DWORD *)v63)
                        - ((v229 * HIWORD(*(_DWORD *)v63) + ((v229 * HIWORD(*(_DWORD *)v63)) >> 16) + 1) >> 16)) << 16);
          if (v231 < 0x10000) {
            goto LABEL_274;
          }
          unint64_t v232 = HIWORD(v231);
          if (v50)
          {
            unsigned int v233 = (unsigned __int16)*v30;
            if (!*v30) {
              goto LABEL_272;
            }
          }
          else
          {
            unsigned int v233 = 0xFFFF;
          }
          unint64_t v234 = ((v232 ^ 0xFFFF) + (unsigned __int16)v230) * (unint64_t)*v34
               + (v233 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v230;
          if (v234 <= 0xFFFE8000) {
            unint64_t v235 = v234 + 0x8000;
          }
          else {
            unint64_t v235 = 4294868992;
          }
          unint64_t v236 = (v235 + (v235 >> 16)) >> 16;
          if (!v50)
          {
            *long long v34 = v236;
            goto LABEL_274;
          }
          int64_t v237 = 0xFFFF * (v233 + v232) - v233 * (unint64_t)v232;
          if (v237 <= 4294868992) {
            unint64_t v232 = v237 + 0x8000;
          }
          else {
            unint64_t v232 = 4294868992;
          }
          unsigned int v231 = ((v232 >> 16) + v232) & 0xFFFF0000 | v236;
          LODWORD(v232) = HIWORD(v231);
LABEL_272:
          *long long v34 = v231;
          *long long v30 = v232;
LABEL_274:
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          if (!--v227) {
            goto LABEL_419;
          }
        }
      case 14:
        int v238 = v39;
        float v136 = v45;
        while (1)
        {
          int v239 = *v64;
          if (!*v64) {
            goto LABEL_295;
          }
          if (v45)
          {
            int v239 = ((unsigned __int16)(*v136 * (_WORD)v239 + ((*v136 * v239) >> 8) + 1) >> 8);
            if (!v239) {
              goto LABEL_295;
            }
          }
          int v240 = (v239 | (v239 << 8)) ^ 0xFFFF;
          unsigned int v241 = (unsigned __int16)*(_DWORD *)v63
               - ((v240 * (unsigned __int16)*(_DWORD *)v63
                 + ((v240 * (unsigned __int16)*(_DWORD *)v63) >> 16)
                 + 1) >> 16);
          unsigned int v242 = v241 | ((HIWORD(*(_DWORD *)v63)
                        - ((v240 * HIWORD(*(_DWORD *)v63) + ((v240 * HIWORD(*(_DWORD *)v63)) >> 16) + 1) >> 16)) << 16);
          if (v242 < 0x10000) {
            goto LABEL_295;
          }
          unsigned int v243 = HIWORD(v242);
          if (v50)
          {
            unsigned int v244 = (unsigned __int16)*v30;
            if (!*v30) {
              goto LABEL_293;
            }
          }
          else
          {
            unsigned int v244 = 0xFFFF;
          }
          unint64_t v245 = (*v34 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)v241 - *v34 + ((unint64_t)*v34 << 16);
          if (v245 <= 0xFFFE8000) {
            unint64_t v246 = v245 + 0x8000;
          }
          else {
            unint64_t v246 = 4294868992;
          }
          unint64_t v247 = (v246 + (v246 >> 16)) >> 16;
          if (!v50)
          {
            *long long v34 = v247;
            goto LABEL_295;
          }
          int64_t v248 = 0xFFFF * (v244 + (unint64_t)v243) - v244 * (unint64_t)v243;
          if (v248 <= 4294868992) {
            unint64_t v249 = v248 + 0x8000;
          }
          else {
            unint64_t v249 = 4294868992;
          }
          unsigned int v242 = ((v249 >> 16) + v249) & 0xFFFF0000 | v247;
          unsigned int v243 = HIWORD(v242);
LABEL_293:
          *long long v34 = v242;
          *long long v30 = v243;
LABEL_295:
          ++v64;
          v63 += 2;
          v136 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          if (!--v238) {
            goto LABEL_419;
          }
        }
      case 15:
        uint64_t v250 = v45;
        do
        {
          int v251 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v251 = ((unsigned __int16)(*v250 * (_WORD)v251
                                                            + ((*v250 * v251) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v252 = (unsigned __int16)*(_DWORD *)v63;
              int v253 = (v251 | (v251 << 8)) ^ 0xFFFF;
              unsigned int v254 = v253 * v252 + ((v253 * v252) >> 16) + 1;
              unsigned int v255 = (v252 - HIWORD(v254)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v253 * HIWORD(*(_DWORD *)v63)
                                               + ((v253 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v256 = HIWORD(v255);
              if (HIWORD(v255))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v255 = PDAoverlayPDA_8925(*v34, (unsigned __int16)*v30, (unsigned __int16)(v252 - HIWORD(v254)), v256);
                    uint64_t v50 = v435;
                    unsigned int v256 = HIWORD(v255);
                  }
                  *long long v34 = v255;
                  *long long v30 = v256;
                }
                else
                {
                  unsigned __int16 v257 = PDAoverlayPDA_8925(*v34, 0xFFFFu, (unsigned __int16)(v252 - HIWORD(v254)), v256);
                  uint64_t v50 = v435;
                  *long long v34 = v257;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 16:
        uint64_t v250 = v45;
        do
        {
          int v258 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v258 = ((unsigned __int16)(*v250 * (_WORD)v258
                                                            + ((*v250 * v258) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v259 = (unsigned __int16)*(_DWORD *)v63;
              int v260 = (v258 | (v258 << 8)) ^ 0xFFFF;
              unsigned int v261 = v260 * v259 + ((v260 * v259) >> 16) + 1;
              unsigned int v262 = (v259 - HIWORD(v261)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v260 * HIWORD(*(_DWORD *)v63)
                                               + ((v260 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v263 = HIWORD(v262);
              if (HIWORD(v262))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v262 = PDAdarkenPDA_8927(*v34, (unsigned __int16)*v30, (unsigned __int16)(v259 - HIWORD(v261)), v263);
                    uint64_t v50 = v435;
                    unsigned int v263 = HIWORD(v262);
                  }
                  *long long v34 = v262;
                  *long long v30 = v263;
                }
                else
                {
                  unsigned __int16 v264 = PDAdarkenPDA_8927(*v34, 0xFFFFu, (unsigned __int16)(v259 - HIWORD(v261)), v263);
                  uint64_t v50 = v435;
                  *long long v34 = v264;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 17:
        uint64_t v250 = v45;
        do
        {
          int v265 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v265 = ((unsigned __int16)(*v250 * (_WORD)v265
                                                            + ((*v250 * v265) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v266 = (unsigned __int16)*(_DWORD *)v63;
              int v267 = (v265 | (v265 << 8)) ^ 0xFFFF;
              unsigned int v268 = v267 * v266 + ((v267 * v266) >> 16) + 1;
              unsigned int v269 = (v266 - HIWORD(v268)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v267 * HIWORD(*(_DWORD *)v63)
                                               + ((v267 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v270 = HIWORD(v269);
              if (HIWORD(v269))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v269 = PDAlightenPDA_8926(*v34, (unsigned __int16)*v30, (unsigned __int16)(v266 - HIWORD(v268)), v270);
                    uint64_t v50 = v435;
                    unsigned int v270 = HIWORD(v269);
                  }
                  *long long v34 = v269;
                  *long long v30 = v270;
                }
                else
                {
                  unsigned __int16 v271 = PDAlightenPDA_8926(*v34, 0xFFFFu, (unsigned __int16)(v266 - HIWORD(v268)), v270);
                  uint64_t v50 = v435;
                  *long long v34 = v271;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 18:
        uint64_t v250 = v45;
        do
        {
          int v272 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v272 = ((unsigned __int16)(*v250 * (_WORD)v272
                                                            + ((*v250 * v272) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v273 = (unsigned __int16)*(_DWORD *)v63;
              int v274 = (v272 | (v272 << 8)) ^ 0xFFFF;
              unsigned int v275 = v274 * v273 + ((v274 * v273) >> 16) + 1;
              unsigned int v276 = (v273 - HIWORD(v275)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v274 * HIWORD(*(_DWORD *)v63)
                                               + ((v274 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v277 = HIWORD(v276);
              if (HIWORD(v276))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v276 = PDAcolordodgePDA_8928(*v34, (unsigned __int16)*v30, (unsigned __int16)(v273 - HIWORD(v275)), v277);
                    uint64_t v50 = v435;
                    unsigned int v277 = HIWORD(v276);
                  }
                  *long long v34 = v276;
                  *long long v30 = v277;
                }
                else
                {
                  unsigned __int16 v278 = PDAcolordodgePDA_8928(*v34, 0xFFFFu, (unsigned __int16)(v273 - HIWORD(v275)), v277);
                  uint64_t v50 = v435;
                  *long long v34 = v278;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 19:
        uint64_t v250 = v45;
        do
        {
          int v279 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v279 = ((unsigned __int16)(*v250 * (_WORD)v279
                                                            + ((*v250 * v279) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v280 = (unsigned __int16)*(_DWORD *)v63;
              int v281 = (v279 | (v279 << 8)) ^ 0xFFFF;
              unsigned int v282 = v281 * v280 + ((v281 * v280) >> 16) + 1;
              unsigned int v283 = (v280 - HIWORD(v282)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v281 * HIWORD(*(_DWORD *)v63)
                                               + ((v281 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v284 = HIWORD(v283);
              if (HIWORD(v283))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v283 = PDAcolorburnPDA_8929(*v34, (unsigned __int16)*v30, (unsigned __int16)(v280 - HIWORD(v282)), v284);
                    uint64_t v50 = v435;
                    unsigned int v284 = HIWORD(v283);
                  }
                  *long long v34 = v283;
                  *long long v30 = v284;
                }
                else
                {
                  unsigned __int16 v285 = PDAcolorburnPDA_8929(*v34, 0xFFFFu, (unsigned __int16)(v280 - HIWORD(v282)), v284);
                  uint64_t v50 = v435;
                  *long long v34 = v285;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 20:
        uint64_t v250 = v45;
        do
        {
          int v286 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v286 = ((unsigned __int16)(*v250 * (_WORD)v286
                                                            + ((*v250 * v286) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v287 = (unsigned __int16)*(_DWORD *)v63;
              int v288 = (v286 | (v286 << 8)) ^ 0xFFFF;
              unsigned int v289 = v288 * v287 + ((v288 * v287) >> 16) + 1;
              unsigned int v290 = (v287 - HIWORD(v289)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v288 * HIWORD(*(_DWORD *)v63)
                                               + ((v288 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v291 = HIWORD(v290);
              if (HIWORD(v290))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v290 = PDAsoftlightPDA_8931(*v34, (unsigned __int16)*v30, (unsigned __int16)(v287 - HIWORD(v289)), v291);
                    uint64_t v50 = v435;
                    unsigned int v291 = HIWORD(v290);
                  }
                  *long long v34 = v290;
                  *long long v30 = v291;
                }
                else
                {
                  unsigned __int16 v292 = PDAsoftlightPDA_8931(*v34, 0xFFFFu, (unsigned __int16)(v287 - HIWORD(v289)), v291);
                  uint64_t v50 = v435;
                  *long long v34 = v292;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 21:
        uint64_t v250 = v45;
        do
        {
          int v293 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v293 = ((unsigned __int16)(*v250 * (_WORD)v293
                                                            + ((*v250 * v293) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v294 = (unsigned __int16)*(_DWORD *)v63;
              int v295 = (v293 | (v293 << 8)) ^ 0xFFFF;
              unsigned int v296 = v295 * v294 + ((v295 * v294) >> 16) + 1;
              unsigned int v297 = (v294 - HIWORD(v296)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v295 * HIWORD(*(_DWORD *)v63)
                                               + ((v295 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v298 = HIWORD(v297);
              if (HIWORD(v297))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v297 = PDAhardlightPDA_8930(*v34, (unsigned __int16)*v30, (unsigned __int16)(v294 - HIWORD(v296)), v298);
                    uint64_t v50 = v435;
                    unsigned int v298 = HIWORD(v297);
                  }
                  *long long v34 = v297;
                  *long long v30 = v298;
                }
                else
                {
                  unsigned __int16 v299 = PDAhardlightPDA_8930(*v34, 0xFFFFu, (unsigned __int16)(v294 - HIWORD(v296)), v298);
                  uint64_t v50 = v435;
                  *long long v34 = v299;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 22:
        uint64_t v250 = v45;
        do
        {
          int v300 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v300 = ((unsigned __int16)(*v250 * (_WORD)v300
                                                            + ((*v250 * v300) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v301 = (unsigned __int16)*(_DWORD *)v63;
              int v302 = (v300 | (v300 << 8)) ^ 0xFFFF;
              unsigned int v303 = v302 * v301 + ((v302 * v301) >> 16) + 1;
              unsigned int v304 = (v301 - HIWORD(v303)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v302 * HIWORD(*(_DWORD *)v63)
                                               + ((v302 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v305 = HIWORD(v304);
              if (HIWORD(v304))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v304 = PDAdifferencePDA_8932(*v34, (unsigned __int16)*v30, (unsigned __int16)(v301 - HIWORD(v303)), v305);
                    uint64_t v50 = v435;
                    unsigned int v305 = HIWORD(v304);
                  }
                  *long long v34 = v304;
                  *long long v30 = v305;
                }
                else
                {
                  unsigned __int16 v306 = PDAdifferencePDA_8932(*v34, 0xFFFFu, (unsigned __int16)(v301 - HIWORD(v303)), v305);
                  uint64_t v50 = v435;
                  *long long v34 = v306;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 23:
        int v307 = v39;
        float v136 = v45;
        break;
      case 24:
        uint64_t v250 = v45;
        do
        {
          int v322 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v322 = ((unsigned __int16)(*v250 * (_WORD)v322
                                                            + ((*v250 * v322) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v323 = (unsigned __int16)*(_DWORD *)v63;
              int v324 = (v322 | (v322 << 8)) ^ 0xFFFF;
              unsigned int v325 = v324 * v323 + ((v324 * v323) >> 16) + 1;
              unsigned int v326 = (v323 - HIWORD(v325)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v324 * HIWORD(*(_DWORD *)v63)
                                               + ((v324 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v327 = HIWORD(v326);
              if (HIWORD(v326))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v326 = PDAhuePDA_8933(*v34, (unsigned __int16)*v30, (unsigned __int16)(v323 - HIWORD(v325)), v327);
                    uint64_t v50 = v435;
                    unsigned int v327 = HIWORD(v326);
                  }
                  *long long v34 = v326;
                  *long long v30 = v327;
                }
                else
                {
                  unsigned __int16 v328 = PDAhuePDA_8933(*v34, 0xFFFFu, (unsigned __int16)(v323 - HIWORD(v325)), v327);
                  uint64_t v50 = v435;
                  *long long v34 = v328;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
        goto LABEL_444;
      case 25:
        uint64_t v250 = v45;
        do
        {
          int v329 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v329 = ((unsigned __int16)(*v250 * (_WORD)v329
                                                            + ((*v250 * v329) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v330 = (unsigned __int16)*(_DWORD *)v63;
              int v331 = (v329 | (v329 << 8)) ^ 0xFFFF;
              unsigned int v332 = v331 * v330 + ((v331 * v330) >> 16) + 1;
              unsigned int v333 = (v330 - HIWORD(v332)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v331 * HIWORD(*(_DWORD *)v63)
                                               + ((v331 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v334 = HIWORD(v333);
              if (HIWORD(v333))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v333 = PDAhuePDA_8933(*v34, (unsigned __int16)*v30, (unsigned __int16)(v330 - HIWORD(v332)), v334);
                    uint64_t v50 = v435;
                    unsigned int v334 = HIWORD(v333);
                  }
                  *long long v34 = v333;
                  *long long v30 = v334;
                }
                else
                {
                  unsigned __int16 v335 = PDAhuePDA_8933(*v34, 0xFFFFu, (unsigned __int16)(v330 - HIWORD(v332)), v334);
                  uint64_t v50 = v435;
                  *long long v34 = v335;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v250 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          LODWORD(v39) = v39 - 1;
        }
        while (v39);
LABEL_444:
        uint64_t v45 = &v250[v425];
        goto LABEL_445;
      case 26:
        int v336 = v39;
        v337 = v45;
        int v338 = v336;
        do
        {
          int v339 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v339 = ((unsigned __int16)(*v337 * (_WORD)v339
                                                            + ((*v337 * v339) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v340 = (unsigned __int16)*(_DWORD *)v63;
              int v341 = (v339 | (v339 << 8)) ^ 0xFFFF;
              unsigned int v342 = v341 * v340 + ((v341 * v340) >> 16) + 1;
              unsigned int v343 = (v340 - HIWORD(v342)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v341 * HIWORD(*(_DWORD *)v63)
                                               + ((v341 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v344 = HIWORD(v343);
              if (HIWORD(v343))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v343 = PDAluminosityPDA_8935((unsigned __int16)(v340 - HIWORD(v342)), v344, *v34, (unsigned __int16)*v30);
                    uint64_t v50 = v435;
                    unsigned int v344 = HIWORD(v343);
                  }
                  *long long v34 = v343;
                  *long long v30 = v344;
                }
                else
                {
                  unsigned __int16 v345 = PDAluminosityPDA_8935((unsigned __int16)(v340 - HIWORD(v342)), v344, *v34, 0xFFFFu);
                  uint64_t v50 = v435;
                  *long long v34 = v345;
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v337 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v338;
        }
        while (v338);
        goto LABEL_474;
      case 27:
        int v346 = v39;
        v337 = v45;
        int v347 = v346;
        do
        {
          int v348 = *v64;
          if (*v64)
          {
            if (!v45
              || (int v348 = ((unsigned __int16)(*v337 * (_WORD)v348
                                                            + ((*v337 * v348) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v349 = (unsigned __int16)*(_DWORD *)v63;
              int v350 = (v348 | (v348 << 8)) ^ 0xFFFF;
              unsigned int v351 = v350 * v349 + ((v350 * v349) >> 16) + 1;
              unsigned int v352 = (v349 - HIWORD(v351)) | ((HIWORD(*(_DWORD *)v63)
                                             - ((v350 * HIWORD(*(_DWORD *)v63)
                                               + ((v350 * HIWORD(*(_DWORD *)v63)) >> 16)
                                               + 1) >> 16)) << 16);
              unsigned int v353 = HIWORD(v352);
              if (HIWORD(v352))
              {
                if (v50)
                {
                  if (*v30)
                  {
                    unsigned int v352 = PDAluminosityPDA_8935(*v34, (unsigned __int16)*v30, (unsigned __int16)(v349 - HIWORD(v351)), v353);
                    uint64_t v50 = v435;
                    unsigned int v353 = HIWORD(v352);
                  }
                  *long long v34 = v352;
                  *long long v30 = v353;
                }
                else
                {
                  unsigned int v354 = (unsigned __int16)(v349 - HIWORD(v351));
                  if (v354 >= HIWORD(v352)) {
                    LOWORD(v354) = HIWORD(v352);
                  }
                  unint64_t v355 = *v34 * (unint64_t)(v353 ^ 0xFFFF) + 0x8000;
                  *long long v34 = v354 + (((v355 >> 16) + v355) >> 16);
                }
              }
            }
          }
          ++v64;
          v63 += 2;
          v337 += v45 != 0;
          ++v34;
          long long v30 = (_WORD *)((char *)v30 + v58);
          --v347;
        }
        while (v347);
LABEL_474:
        uint64_t v45 = &v337[v425];
LABEL_445:
        v34 += v426;
        v30 += v428;
        uint64_t v39 = v423;
        unint64_t v38 = v424;
        uint64_t v96 = v431;
        uint64_t v106 = v432;
        int v68 = v433;
        goto LABEL_446;
      default:
        goto LABEL_420;
    }
    while (1)
    {
      int v308 = *v64;
      if (!*v64) {
        goto LABEL_418;
      }
      if (v45)
      {
        int v308 = ((unsigned __int16)(*v136 * (_WORD)v308 + ((*v136 * v308) >> 8) + 1) >> 8);
        if (!v308) {
          goto LABEL_418;
        }
      }
      int v309 = (v308 | (v308 << 8)) ^ 0xFFFF;
      unsigned int v310 = (unsigned __int16)*(_DWORD *)v63
           - ((v309 * (unsigned __int16)*(_DWORD *)v63
             + ((v309 * (unsigned __int16)*(_DWORD *)v63) >> 16)
             + 1) >> 16);
      unsigned int v311 = v310 | ((HIWORD(*(_DWORD *)v63)
                    - ((v309 * HIWORD(*(_DWORD *)v63) + ((v309 * HIWORD(*(_DWORD *)v63)) >> 16) + 1) >> 16)) << 16);
      unsigned int v312 = HIWORD(v311);
      if (!HIWORD(v311)) {
        goto LABEL_418;
      }
      if (v50)
      {
        unsigned int v313 = (unsigned __int16)*v30;
        if (!*v30) {
          goto LABEL_416;
        }
      }
      else
      {
        unsigned int v313 = 0xFFFF;
      }
      if ((unsigned __int16)v310 >= HIWORD(v311)) {
        uint64_t v314 = v312;
      }
      else {
        uint64_t v314 = (unsigned __int16)v310;
      }
      if (*v34 >= v313) {
        uint64_t v315 = v313;
      }
      else {
        uint64_t v315 = *v34;
      }
      int64_t v316 = 0xFFFF * (v315 + v314) - 2 * v314 * (unint64_t)v315;
      if (v316 <= 4294868992) {
        unint64_t v317 = v316 + 0x8000;
      }
      else {
        unint64_t v317 = 4294868992;
      }
      unint64_t v318 = v317 + (v317 >> 16);
      if (!v50)
      {
        *long long v34 = WORD1(v318);
        goto LABEL_418;
      }
      unint64_t v319 = v318 >> 16;
      int64_t v320 = 0xFFFF * (v313 + (unint64_t)v312) - v313 * (unint64_t)v312;
      if (v320 <= 4294868992) {
        unint64_t v321 = v320 + 0x8000;
      }
      else {
        unint64_t v321 = 4294868992;
      }
      unsigned int v311 = ((v321 >> 16) + v321) & 0xFFFF0000 | v319;
      unsigned int v312 = HIWORD(v311);
LABEL_416:
      *long long v34 = v311;
      *long long v30 = v312;
LABEL_418:
      ++v64;
      v63 += 2;
      v136 += v45 != 0;
      ++v34;
      long long v30 = (_WORD *)((char *)v30 + v58);
      if (!--v307)
      {
LABEL_419:
        uint64_t v45 = &v136[v425];
        v34 += v426;
        v30 += v428;
LABEL_420:
        uint64_t v96 = v431;
        uint64_t v106 = v432;
        goto LABEL_446;
      }
    }
  }
}

uint64_t PDAoverlayPDA_8925(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    unsigned int v4 = a4;
  }
  else {
    unsigned int v4 = a3;
  }
  if (a1 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a1;
  }
  unint64_t v6 = 2 * v5 * (unint64_t)v4;
  unint64_t v7 = a4 * (unint64_t)a2;
  unint64_t v8 = (a4 + 0xFFFF) * (unint64_t)v5 + (a2 + 0xFFFF) * (unint64_t)v4 - (v7 + v6);
  uint64_t v9 = (a2 ^ 0xFFFF) * (unint64_t)v4 + (a4 ^ 0xFFFF) * (unint64_t)v5 + v6;
  if (v5 >= ((unint64_t)a2 + 1) >> 1) {
    uint64_t v9 = v8;
  }
  uint64_t v10 = 0xFFFF * (a4 + (unint64_t)a2) - v7;
  unint64_t v11 = v9 + 0x8000;
  if (v9 > 4294868992) {
    unint64_t v11 = 4294868992;
  }
  unint64_t v12 = (v11 + (v11 >> 16)) >> 16;
  if (v10 <= 4294868992) {
    unint64_t v13 = v10 + 0x8000;
  }
  else {
    unint64_t v13 = 4294868992;
  }
  return ((v13 >> 16) + v13) & 0xFFFF0000 | v12;
}

uint64_t PDAlightenPDA_8926(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    unsigned int v4 = a4;
  }
  else {
    unsigned int v4 = a3;
  }
  if (a1 >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a1;
  }
  unint64_t v6 = a4 * (unint64_t)v5;
  if (v4 * (unint64_t)a2 > v6) {
    unint64_t v6 = v4 * (unint64_t)a2;
  }
  unint64_t v7 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v6;
  int64_t v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 <= 0xFFFE8000) {
    unint64_t v9 = v7 + 0x8000;
  }
  else {
    unint64_t v9 = 4294868992;
  }
  unint64_t v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992) {
    unint64_t v11 = v8 + 0x8000;
  }
  else {
    unint64_t v11 = 4294868992;
  }
  return ((v11 >> 16) + v11) & 0xFFFF0000 | v10;
}

uint64_t PDAdarkenPDA_8927(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    unsigned int v4 = a4;
  }
  else {
    unsigned int v4 = a3;
  }
  if (a1 >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a1;
  }
  unint64_t v6 = a4 * (unint64_t)v5;
  if (v4 * (unint64_t)a2 < v6) {
    unint64_t v6 = v4 * (unint64_t)a2;
  }
  unint64_t v7 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v6;
  int64_t v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 <= 0xFFFE8000) {
    unint64_t v9 = v7 + 0x8000;
  }
  else {
    unint64_t v9 = 4294868992;
  }
  unint64_t v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992) {
    unint64_t v11 = v8 + 0x8000;
  }
  else {
    unint64_t v11 = 4294868992;
  }
  return ((v11 >> 16) + v11) & 0xFFFF0000 | v10;
}

uint64_t PDAcolordodgePDA_8928(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a1 >= a2) {
    unsigned int v4 = a2;
  }
  else {
    unsigned int v4 = a1;
  }
  if (a3 >= a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if (v4)
  {
    if (a3 >= a4) {
      uint64_t v6 = 4294836225;
    }
    else {
      uint64_t v6 = (uint64_t)(a4 * v4 * (unint64_t)a4) / (a4 - v5);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  int64_t v7 = (a4 ^ 0xFFFF) * (unint64_t)v4 + (a2 ^ 0xFFFF) * (unint64_t)v5 + v6;
  int64_t v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v7 >= v8) {
    int64_t v7 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  }
  if (v7 <= 4294868992) {
    unint64_t v9 = v7 + 0x8000;
  }
  else {
    unint64_t v9 = 4294868992;
  }
  unint64_t v10 = (v9 + (v9 >> 16)) >> 16;
  if (v8 <= 4294868992) {
    unint64_t v11 = v8 + 0x8000;
  }
  else {
    unint64_t v11 = 4294868992;
  }
  return ((v11 >> 16) + v11) & 0xFFFF0000 | v10;
}

uint64_t PDAcolorburnPDA_8929(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4 = 4294868992;
  if (a3 >= a4) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if (a1 >= a2) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a1;
  }
  unint64_t v7 = (a4 ^ 0xFFFF) * (unint64_t)v6
     + a4 * (unint64_t)a2
     + (a2 ^ 0xFFFF) * (unint64_t)v5;
  if (a2 > a1)
  {
    if (!v5)
    {
      unint64_t v9 = 0x8000;
      goto LABEL_14;
    }
    uint64_t v8 = v7 - (uint64_t)(a4 * (unint64_t)a4 * (a2 - v6)) / v5;
    unint64_t v7 = v8 & ~(v8 >> 63);
  }
  unint64_t v9 = v7 + 0x8000;
  if (v7 > 0xFFFE8000) {
    unint64_t v9 = 4294868992;
  }
LABEL_14:
  int64_t v10 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v10 <= 4294868992) {
    unint64_t v4 = v10 + 0x8000;
  }
  return ((v4 >> 16) + v4) & 0xFFFF0000 | ((v9 + (v9 >> 16)) >> 16);
}

uint64_t PDAhardlightPDA_8930(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a3;
  }
  if (a1 >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a1;
  }
  unint64_t v6 = 2 * v5 * (unint64_t)v4;
  unint64_t v7 = a4 * (unint64_t)a2;
  uint64_t v8 = (a2 ^ 0xFFFF) * (unint64_t)v4 + (a4 ^ 0xFFFF) * (unint64_t)v5 + v6;
  unint64_t v9 = (a4 + 0xFFFF) * (unint64_t)v5 + (a2 + 0xFFFF) * (unint64_t)v4 - (v7 + v6);
  if (v4 > ((unint64_t)a4 + 1) >> 1) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v11 = 0xFFFF * (a4 + (unint64_t)a2) - v7;
  unint64_t v12 = v10 + 0x8000;
  if (v10 > 4294868992) {
    unint64_t v12 = 4294868992;
  }
  unint64_t v13 = (v12 + (v12 >> 16)) >> 16;
  if (v11 <= 4294868992) {
    unint64_t v14 = v11 + 0x8000;
  }
  else {
    unint64_t v14 = 4294868992;
  }
  return ((v14 >> 16) + v14) & 0xFFFF0000 | v13;
}

uint64_t PDAsoftlightPDA_8931(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = a3;
  }
  if (a1 >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a1;
  }
  if (a2)
  {
    int64_t v6 = 2 * v5 * (unint64_t)v4 - (uint64_t)(v5 * (unint64_t)v5 * (2 * v4 - a4)) / a2;
    uint64_t v7 = v6 & ~(v6 >> 63);
  }
  else
  {
    uint64_t v7 = 0;
  }
  unint64_t v8 = (a4 ^ 0xFFFF) * (unint64_t)v5 + (a2 ^ 0xFFFF) * (unint64_t)v4 + v7;
  int64_t v9 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  unint64_t v10 = v8 + 0x8000;
  if (v8 > 0xFFFE8000) {
    unint64_t v10 = 4294868992;
  }
  unint64_t v11 = (v10 + (v10 >> 16)) >> 16;
  if (v9 <= 4294868992) {
    unint64_t v12 = v9 + 0x8000;
  }
  else {
    unint64_t v12 = 4294868992;
  }
  return ((v12 >> 16) + v12) & 0xFFFF0000 | v11;
}

uint64_t PDAdifferencePDA_8932(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = a3;
  }
  if (a1 >= a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = a1;
  }
  int64_t v6 = a4 * (unint64_t)v5 - v4 * (unint64_t)a2;
  unint64_t v7 = 0xFFFF * (v4 + v5) - v4 * (unint64_t)a2 - a4 * (unint64_t)v5;
  if (v6 >= 0) {
    int64_t v8 = v6;
  }
  else {
    int64_t v8 = -v6;
  }
  uint64_t v9 = v7 + v8;
  int64_t v10 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v9 <= 4294868992) {
    unint64_t v11 = v9 + 0x8000;
  }
  else {
    unint64_t v11 = 4294868992;
  }
  unint64_t v12 = (v11 + (v11 >> 16)) >> 16;
  if (v10 <= 4294868992) {
    unint64_t v13 = v10 + 0x8000;
  }
  else {
    unint64_t v13 = 4294868992;
  }
  return ((v13 >> 16) + v13) & 0xFFFF0000 | v12;
}

uint64_t PDAhuePDA_8933(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a1 >= a2) {
    LODWORD(v4) = a2;
  }
  else {
    LODWORD(v4) = a1;
  }
  unint64_t v5 = (a4 ^ 0xFFFF) * (unint64_t)v4;
  if (a4 == 0xFFFF) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v4 = (a4 * (unint64_t)v4 + 0x8000 + ((a4 * (unint64_t)v4 + 0x8000) >> 16)) >> 16;
  }
  if (a3 >= a4) {
    unsigned int v6 = a4;
  }
  else {
    unsigned int v6 = a3;
  }
  unint64_t v7 = v5 + (a2 ^ 0xFFFF) * (unint64_t)v6;
  if (v7 <= 0xFFFE8000) {
    unint64_t v8 = v7 + 0x8000;
  }
  else {
    unint64_t v8 = 4294868992;
  }
  return (((v8 + (v8 >> 16)) >> 16) + v4) | ((a4
                                                                  + a2
                                                                  - ((((a4 * (unint64_t)a2 + 0x8000) >> 16)
                                                                    + a4 * a2
                                                                    + 0x8000) >> 16)) << 16);
}

uint64_t PDAluminosityPDA_8935(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a3;
  }
  if (a1 >= a2) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = a1;
  }
  int64_t v6 = (a4 ^ 0xFFFF) * (unint64_t)v5;
  if (a2 != 0xFFFF)
  {
    int64_t v6 = v6 - v4 + (v4 << 16) - v4 * (unint64_t)a2;
    unint64_t v4 = (v4 * (unint64_t)a2 + 0x8000 + ((v4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  }
  unint64_t v7 = v6 + 0x8000;
  if (v6 > 4294868992) {
    unint64_t v7 = 4294868992;
  }
  return (((v7 + (v7 >> 16)) >> 16) + v4) | ((a4
                                                                  + a2
                                                                  - ((((a4 * (unint64_t)a2 + 0x8000) >> 16)
                                                                    + a4 * a2
                                                                    + 0x8000) >> 16)) << 16);
}

void w16_shade_axial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v4 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  float v7 = *(float *)(a1 + 336);
  float v8 = *(float *)(a1 + 344);
  float v9 = *(float *)(a1 + 304);
  float v10 = *(float *)(a1 + 308);
  int v11 = *(_DWORD *)(a1 + 320);
  int v12 = *(_DWORD *)(a1 + 324);
  uint64_t v15 = a1 + 144;
  unint64_t v13 = *(_DWORD **)(a1 + 144);
  unint64_t v14 = *(_DWORD **)(v15 + 8);
  uint64_t v16 = *(_DWORD **)(a1 + 376);
  uint64_t v17 = *(void *)(a1 + 360);
  if (v4 != 0.0)
  {
    while (1)
    {
      int v19 = v11;
      if (v5 >= v9)
      {
        int v19 = v12;
        if (v5 <= v10) {
          int v19 = (int)(float)(v8 * (float)(v5 - v7));
        }
      }
      if ((v19 & 0x80000000) == 0) {
        break;
      }
      long long v20 = v16;
      if (v16) {
        goto LABEL_17;
      }
LABEL_18:
      float v5 = v4 + v5;
      ++v14;
      *(unsigned char *)unint64_t v13 = (_BYTE)v20;
      unint64_t v13 = (_DWORD *)((char *)v13 + 1);
      if (!--a4) {
        return;
      }
    }
    long long v20 = (_DWORD *)(v17 + 2 * (2 * v19));
LABEL_17:
    *unint64_t v14 = *v20;
    LOBYTE(v20) = -1;
    goto LABEL_18;
  }
  if (v5 >= v9)
  {
    int v11 = v12;
    if (v5 <= v10) {
      int v11 = (int)(float)(v8 * (float)(v5 - v7));
    }
  }
  if ((v11 & 0x80000000) == 0 || v16)
  {
    long long v21 = (int *)(v17 + 2 * (2 * v11));
    if (v11 < 0) {
      long long v21 = v16;
    }
    int v22 = *v21;
    int v23 = a4 + 4;
    do
    {
      *unint64_t v14 = v22;
      v14[1] = v22;
      v14[2] = v22;
      v14[3] = v22;
      v23 -= 4;
      v14 += 4;
      *v13++ = -1;
    }
    while (v23 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v18 = 4;
    }
    else {
      int v18 = a4;
    }
    bzero(v13, ((a4 - v18 + 3) & 0xFFFFFFFC) + 4);
  }
}

float w16_shade_custom_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float result = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(result * v6));
  float v9 = *(float *)(a1 + 284);
  float v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  float v11 = *(float *)(a1 + 304);
  float v12 = *(float *)(a1 + 308);
  float v13 = *(float *)(a1 + 312);
  float v14 = *(float *)(a1 + 316);
  float v15 = *(float *)(a1 + 336);
  float v16 = *(float *)(a1 + 348);
  float v17 = *(float *)(a1 + 344);
  float v18 = *(float *)(a1 + 356);
  int v19 = *(_DWORD **)(a1 + 376);
  uint64_t v20 = *(void *)(a1 + 360);
  int v21 = 2 * *(_DWORD *)(a1 + 48);
  int v23 = *(unsigned char **)(a1 + 144);
  int v22 = *(_DWORD **)(a1 + 152);
  do
  {
    if (v8 < v11 || v10 < v13)
    {
      BOOL v25 = 0;
      BOOL v26 = 0;
    }
    else
    {
      BOOL v25 = v8 == v12;
      BOOL v26 = v8 < v12;
    }
    if (v26 || v25)
    {
      BOOL v27 = v10 == v14;
      BOOL v28 = v10 < v14;
    }
    else
    {
      BOOL v27 = 0;
      BOOL v28 = 0;
    }
    if (v28 || v27)
    {
      unint64_t v29 = (_DWORD *)(v20
                     + 2 * v21 * (int)(float)(v18 * (float)(v10 - v16))
                     + 4 * (int)(float)(v17 * (float)(v8 - v15)));
LABEL_15:
      *int v22 = *v29;
      LOBYTE(v29) = -1;
      goto LABEL_16;
    }
    unint64_t v29 = v19;
    if (v19) {
      goto LABEL_15;
    }
LABEL_16:
    float v8 = result + v8;
    float v10 = v9 + v10;
    ++v22;
    *v23++ = (_BYTE)v29;
    --a4;
  }
  while (a4);
  return result;
}

void w16_shade_conic_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(*(void *)(a1 + 272) + 4);
  float v6 = v5 * (float)a2;
  float v7 = v5 * (float)a3;
  float v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  float v9 = *(float *)(a1 + 284);
  float v10 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v9 * v6));
  float v26 = *(float *)(a1 + 336);
  float v27 = *(float *)(a1 + 304);
  float v12 = *(float *)(a1 + 344);
  uint64_t v13 = *(void *)(a1 + 360);
  float v15 = *(unsigned char **)(a1 + 144);
  float v14 = *(unsigned int **)(a1 + 152);
  float v16 = *(float *)(a1 + 308) - v27;
  do
  {
    float v17 = v12 * (float)((float)(v27 + (float)((float)((float)(atan2f(v10, v8) * 0.15915) + 0.5) * v16)) - v26);
    unsigned int v18 = vcvtms_s32_f32(v17);
    float v19 = ceilf(v17);
    float v20 = (float)((float)(v17 - (float)(int)floorf(v17)) * 255.0) + 0.5;
    unsigned int v21 = vcvtms_s32_f32(v12 + v17);
    float v22 = ceilf(v17 - v12);
    if (v17 < 0.0) {
      unsigned int v18 = v21;
    }
    if (v17 <= v12) {
      float v23 = v19;
    }
    else {
      float v23 = v22;
    }
    int v24 = (int)v20;
    BOOL v25 = (unsigned __int16 *)(v13 + 4 * (int)v23);
    *v14++ = ((v24 * v25[1] + (255 - v24) * *(unsigned __int16 *)(v13 + 2 * (int)(2 * v18) + 2)) << 8) & 0xFFFF0000 | (unsigned __int16)((v24 * *v25 + (255 - v24) * *(unsigned __int16 *)(v13 + 2 * (int)(2 * v18))) >> 8);
    float v8 = v4 + v8;
    float v10 = v9 + v10;
    *v15++ = -1;
    --a4;
  }
  while (a4);
}

void w16_shade_radial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(a1 + 284);
  float v6 = *(float *)(*(void *)(a1 + 272) + 4);
  float v7 = v6 * (float)a2;
  float v8 = v6 * (float)a3;
  float v9 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v8) + (float)(v4 * v7));
  float v10 = *(float *)(a1 + 300) + (float)((float)(v8 * *(float *)(a1 + 292)) + (float)(v5 * v7));
  float v12 = *(float **)(a1 + 400);
  float v13 = *(float *)(a1 + 336);
  float v14 = *(float *)(a1 + 344);
  float v15 = *(float *)(a1 + 304);
  float v16 = *(float *)(a1 + 308);
  uint64_t v17 = *(unsigned int *)(a1 + 324);
  float v18 = v12[2];
  float v19 = v12[4];
  float v20 = v12[5];
  float v21 = v12[7];
  uint64_t v24 = a1 + 144;
  float v22 = *(unsigned char **)(a1 + 144);
  float v23 = *(_DWORD **)(v24 + 8);
  BOOL v25 = *(_DWORD **)(a1 + 376);
  uint64_t v26 = *(void *)(a1 + 360);
  if (v18 != 0.0 || v21 != 0.0 || v5 != 0.0)
  {
    int v30 = *(_DWORD *)(a1 + 320);
    float v31 = v12[3];
    float v32 = v12[8];
    float v33 = -v12[6];
    float v34 = v16 - v15;
    while (1)
    {
      float v35 = v33 + (float)((float)(v9 + v9) * v18);
      float v36 = (float)((float)(v10 * v10) + (float)(v9 * v9)) - v21;
      if (v20 == 0.0)
      {
        float v43 = v36 / v35;
      }
      else
      {
        float v37 = (float)((float)(v20 * -4.0) * v36) + (float)(v35 * v35);
        if (v37 < 0.0) {
          goto LABEL_39;
        }
        float v38 = sqrtf(v37);
        float v39 = v32 * (float)(v35 - v38);
        float v40 = v35 + v38;
        float v41 = v32 * v40;
        BOOL v42 = (float)(v32 * v40) <= v39;
        if ((float)(v32 * v40) <= v39) {
          float v43 = v32 * v40;
        }
        else {
          float v43 = v39;
        }
        if (v42) {
          float v41 = v39;
        }
        if (v41 < 0.0)
        {
          BOOL v44 = v41 < v31;
LABEL_25:
          int v45 = v30;
          if (v44) {
            goto LABEL_39;
          }
LABEL_26:
          if ((v45 & 0x80000000) == 0) {
            goto LABEL_38;
          }
          goto LABEL_39;
        }
        if (v41 <= 1.0)
        {
          float v46 = v15 + (float)(v41 * v34);
          goto LABEL_37;
        }
        if ((v17 & 0x80000000) == 0)
        {
          int v45 = v17;
          if (v41 <= v19)
          {
LABEL_38:
            int v47 = (_DWORD *)(v26 + 2 * (2 * v45));
LABEL_40:
            *float v23 = *v47;
            LOBYTE(v47) = -1;
            goto LABEL_41;
          }
        }
      }
      if (v43 < 0.0)
      {
        BOOL v44 = v43 < v31;
        goto LABEL_25;
      }
      if (v43 > 1.0)
      {
        int v45 = v17;
        if (v43 > v19) {
          goto LABEL_39;
        }
        goto LABEL_26;
      }
      float v46 = v15 + (float)(v43 * v34);
LABEL_37:
      int v45 = (int)(float)(v14 * (float)(v46 - v13));
      if ((v45 & 0x80000000) == 0) {
        goto LABEL_38;
      }
LABEL_39:
      int v47 = v25;
      if (v25) {
        goto LABEL_40;
      }
LABEL_41:
      float v9 = v4 + v9;
      float v10 = v5 + v10;
      ++v23;
      *v22++ = (_BYTE)v47;
      if (!--a4) {
        return;
      }
    }
  }
  float v27 = v10 * v10;
  float v28 = -v20;
  if (v27 <= (float)-v20)
  {
    float v48 = fabsf(v12[8]);
    float v49 = v20 * -4.0;
    float v50 = v16 - v15;
    int v51 = a4 + 2;
    while (1)
    {
      float v52 = v27 + (float)(v9 * v9);
      float v53 = v4 + v9;
      float v54 = v27 + (float)(v53 * v53);
      if (v52 > v28 && v54 > v28)
      {
        if ((v17 & 0x80000000) != 0)
        {
          if (!v25)
          {
            char v65 = 0;
            LOBYTE(v64) = 0;
            goto LABEL_65;
          }
          int v63 = *v25;
        }
        else
        {
          int v63 = *(_DWORD *)(v26 + 4 * v17);
        }
        *float v23 = v63;
        goto LABEL_63;
      }
      float v56 = sqrtf(v49 * v54);
      float v57 = v48 * sqrtf(v49 * v52);
      float v58 = v48 * v56;
      int v59 = (int)(float)(v14 * (float)((float)(v15 + (float)(v57 * v50)) - v13));
      int v60 = (int)(float)(v14 * (float)((float)(v15 + (float)((float)(v48 * v56) * v50)) - v13));
      if (v57 <= 1.0 && v58 <= 1.0)
      {
        int v63 = *(_DWORD *)(v26 + 4 * v60);
        *float v23 = *(_DWORD *)(v26 + 4 * v59);
LABEL_63:
        LOBYTE(v64) = -1;
        goto LABEL_64;
      }
      if (v57 <= 1.0)
      {
        if ((v59 & 0x80000000) == 0)
        {
          uint64_t v62 = (2 * v59);
LABEL_69:
          unsigned int v64 = (_DWORD *)(v26 + 2 * v62);
LABEL_71:
          *float v23 = *v64;
          LOBYTE(v64) = -1;
          goto LABEL_72;
        }
      }
      else if (v57 <= v19)
      {
        uint64_t v62 = 2 * v17;
        if ((v17 & 0x80000000) == 0) {
          goto LABEL_69;
        }
      }
      unsigned int v64 = v25;
      if (v25) {
        goto LABEL_71;
      }
LABEL_72:
      if (v58 <= 1.0)
      {
        if (v60 < 0) {
          goto LABEL_79;
        }
        uint64_t v66 = (2 * v60);
      }
      else if (v58 > v19 || (uint64_t v66 = 2 * v17, (v17 & 0x80000000) != 0))
      {
LABEL_79:
        if (!v25)
        {
          char v65 = 0;
          goto LABEL_65;
        }
        int v63 = *v25;
        goto LABEL_64;
      }
      int v63 = *(_DWORD *)(v26 + 2 * v66);
LABEL_64:
      v23[1] = v63;
      char v65 = -1;
LABEL_65:
      float v9 = v4 + v53;
      v23 += 2;
      *float v22 = (_BYTE)v64;
      v22[1] = v65;
      v22 += 2;
      v51 -= 2;
      if (v51 <= 2) {
        return;
      }
    }
  }
  if (v25 || (v17 & 0x80000000) == 0)
  {
    char v67 = (int *)(v26 + 4 * v17);
    if ((int)v17 < 0) {
      char v67 = v25;
    }
    int v68 = *v67;
    int v69 = a4 + 4;
    do
    {
      *float v23 = v68;
      v23[1] = v68;
      v23[2] = v68;
      _OWORD v23[3] = v68;
      v69 -= 4;
      v23 += 4;
      *(_DWORD *)float v22 = -1;
      v22 += 4;
    }
    while (v69 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v29 = 4;
    }
    else {
      int v29 = a4;
    }
    bzero(v22, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t w16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v47, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v47) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = 68161828;
  unsigned int v19 = *(_DWORD *)a3;
  *((void *)&v30 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 68161828)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        int v22 = 255;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
        int v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v21 = 0;
            int v22 = 16;
            break;
          case 5u:
            char v21 = 0;
            int v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v21 = 0;
            int v22 = 32;
            break;
          case 8u:
            char v21 = 0;
            int v22 = 8;
            break;
          case 9u:
            char v21 = 0;
            int v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(void *)&long long v30 = *(void *)&W16_image_sample[2 * v20 + 2];
      if ((void)v30)
      {
LABEL_27:
        DWORD2(v30) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v31) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v23) = v22;
          LODWORD(v23) = v22;
          switch((v23 >> 3))
          {
            case 0u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = w16_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              DWORD2(v30) = *(_DWORD *)a3;
              BOOL v25 = w16_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = w16_image_mark_W8;
              goto LABEL_50;
            case 3u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = w16_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = w16_image_mark_rgb32;
LABEL_50:
              uint64_t v26 = v24;
              uint64_t v27 = (uint64_t)a2;
              int v28 = v8;
              int v29 = 0;
              break;
            case 5u:
              DWORD2(v30) = *(_DWORD *)a3;
              BOOL v25 = w16_image_mark_rgb32;
LABEL_52:
              uint64_t v26 = v25;
              uint64_t v27 = (uint64_t)a2;
              int v28 = v8;
              int v29 = 8;
              break;
            default:
              goto LABEL_28;
          }
          w16_image_mark_image(v27, (uint64_t)&v30, v28, v29, (void (*)(void, void))v26);
          return 1;
        }
        goto LABEL_28;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(void *)&long long v30 = *(void *)&W8_image_sample[2 * v20 + 2];
        if ((void)v30)
        {
          int v18 = 34083076;
          goto LABEL_27;
        }
      }
      *(void *)&long long v30 = *(void *)&WF_image_sample[2 * v20 + 2];
      if ((void)v30)
      {
        LODWORD(v31) = 8;
        int v18 = 136319269;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v41 && (~DWORD1(v31) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v31) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      w16_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v30 = w16_sample_w16;
LABEL_28:
  w16_image_mark((uint64_t)a2, (uint64_t)&v30, v8, v17);
  return 1;
}

uint64_t w16_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v774 = *MEMORY[0x1E4F143B8];
  float v5 = *(char **)(v3 + 96);
  uint64_t v6 = *(void *)(v3 + 48);
  int v7 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = v3;
  unint64_t v10 = *(unsigned int *)(v3 + 4);
  unsigned int v11 = v10 - 1;
  if ((int)v10 < 1) {
    return 0;
  }
  int v12 = *(_DWORD *)(v3 + 8);
  uint64_t v13 = (v12 - 1);
  if (v12 < 1) {
    return 0;
  }
  uint64_t v14 = *(uint16x4_t **)(v3 + 136);
  int v717 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                   + 16 * *(_DWORD *)v3
                   + 8 * (v5 == 0)
                   + 4 * (v6 == 0));
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    int v16 = *(_DWORD *)v3 & 0xFF00;
    if (v16 == 1024)
    {
      v773[0] = *(_DWORD *)(v3 + 4);
      v763[0] = v12;
      unsigned int v17 = **(unsigned __int16 **)(v3 + 88);
      if (v5) {
        unsigned int v18 = *(unsigned __int16 *)v5;
      }
      else {
        unsigned int v18 = 0xFFFF;
      }
      unint64_t v31 = (unint64_t)*(int *)(v3 + 28) >> 1;
      uint64_t v33 = *(int *)(v3 + 12);
      uint64_t v32 = *(int *)(v3 + 16);
      if (v6)
      {
        unint64_t v34 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v753 = (char *)(v6 + 2 * (v33 + v34 * v32));
        unsigned int v748 = 1;
      }
      else
      {
        unint64_t v34 = 0;
        v753 = 0;
        unsigned int v748 = 0;
      }
      unsigned __int16 v742 = ~(_WORD)v18;
      unint64_t v744 = v34;
      long long v38 = (uint16x4_t *)(*(void *)(v3 + 40) + 2 * (v33 + v32 * v31));
      *(void *)v750 = v38;
      if (v14)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
        uint64_t v40 = v39;
        unint64_t v760 = v34;
        long long v41 = v753;
        if (v39) {
          goto LABEL_393;
        }
        return 1;
      }
      *(void *)v755 = 0;
      if (v6) {
        unint64_t v42 = v10;
      }
      else {
        unint64_t v42 = 0;
      }
      unint64_t v760 = v34 - v42;
      unint64_t v43 = v10;
      long long v41 = v753;
LABEL_66:
      unint64_t v759 = v31 - v43;
      int v745 = v10;
      switch(v7)
      {
        case 0:
          unint64_t v740 = v31;
          uint64_t v67 = v759 + (int)v10;
          int v68 = v10;
          unsigned int v69 = v763[0];
          uint64_t v70 = v763[0] - 1;
          uint64_t v71 = (v67 * v70) & (v67 >> 63);
          if (v67 < 0) {
            uint64_t v67 = -v67;
          }
          CGBlt_fillBytes(2 * v68, v763[0], 0, (char *)v38 + 2 * v71, 2 * v67);
          if (v6)
          {
            uint64_t v72 = v760 + v68;
            if (v72 >= 0) {
              uint64_t v73 = v760 + v68;
            }
            else {
              uint64_t v73 = -v72;
            }
            v41 += 2 * ((v72 * v70) & (v72 >> 63));
            unint64_t v760 = v73;
            CGBlt_fillBytes(2 * v68, v69, 0, v41, 2 * v73);
          }
          goto LABEL_367;
        case 1:
          uint64_t v74 = v759 + (int)v10;
          uint64_t v746 = (int)v10;
          if (v74 < 0)
          {
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v74 * (v763[0] - 1));
            uint64_t v74 = -v74;
          }
          unint64_t v75 = v31;
          int v76 = 0;
          unsigned int v77 = *(int **)(v9 + 88);
          if (v77) {
            int v76 = *v77;
          }
          int v78 = 2 * v10;
          signed int v79 = v763[0];
          CGBlt_fillBytes(v78, v763[0], v76, (char *)v38, 2 * v74);
          if (v6)
          {
            uint64_t v80 = *(int **)(v9 + 96);
            if (!v80) {
              uint64_t v80 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
            }
            uint64_t v81 = v760 + v746;
            if ((uint64_t)(v760 + v746) >= 0) {
              uint64_t v82 = v760 + v746;
            }
            else {
              uint64_t v82 = -v81;
            }
            v41 += 2 * (((v760 + v746) * (v79 - 1)) & (v81 >> 63));
            unint64_t v760 = v82;
            CGBlt_fillBytes(v78, v79, *v80, v41, 2 * v82);
          }
          unint64_t v31 = v75;
          goto LABEL_354;
        case 2:
          int v83 = v763[0];
          unsigned int v84 = v10 >> 2;
          if (v6)
          {
            unsigned int v85 = v84 + 1;
            do
            {
              if ((int)v10 < 4)
              {
                int v91 = v10;
              }
              else
              {
                unsigned int v86 = v85;
                do
                {
                  unsigned int v87 = *(unsigned __int16 *)v41 * v742 + ((*(unsigned __int16 *)v41 * v742) >> 16) + 1;
                  v38->i16[0] = v17 + ((v38->u16[0] * v742 + ((v38->u16[0] * v742) >> 16) + 1) >> 16);
                  *(_WORD *)long long v41 = v18 + HIWORD(v87);
                  unsigned int v88 = *((unsigned __int16 *)v41 + 1) * v742
                      + ((*((unsigned __int16 *)v41 + 1) * v742) >> 16)
                      + 1;
                  v38->i16[1] = v17 + ((v38->u16[1] * v742 + ((v38->u16[1] * v742) >> 16) + 1) >> 16);
                  *((_WORD *)v41 + 1) = v18 + HIWORD(v88);
                  unsigned int v89 = *((unsigned __int16 *)v41 + 2) * v742
                      + ((*((unsigned __int16 *)v41 + 2) * v742) >> 16)
                      + 1;
                  v38->i16[2] = v17 + ((v38->u16[2] * v742 + ((v38->u16[2] * v742) >> 16) + 1) >> 16);
                  *((_WORD *)v41 + 2) = v18 + HIWORD(v89);
                  unsigned int v90 = *((unsigned __int16 *)v41 + 3) * v742
                      + ((*((unsigned __int16 *)v41 + 3) * v742) >> 16)
                      + 1;
                  v38->i16[3] = v17 + ((v38->u16[3] * v742 + ((v38->u16[3] * v742) >> 16) + 1) >> 16);
                  *((_WORD *)v41 + 3) = v18 + HIWORD(v90);
                  ++v38;
                  v41 += 8 * v748;
                  --v86;
                }
                while (v86 > 1);
                int v91 = v10 & 3;
              }
              if (v91 >= 1)
              {
                unsigned int v92 = v91 + 1;
                do
                {
                  unsigned int v93 = *(unsigned __int16 *)v41 * v742 + ((*(unsigned __int16 *)v41 * v742) >> 16);
                  v38->i16[0] = v17 + ((v38->u16[0] * v742 + ((v38->u16[0] * v742) >> 16) + 1) >> 16);
                  long long v38 = (uint16x4_t *)((char *)v38 + 2);
                  *(_WORD *)long long v41 = v18 + ((v93 + 1) >> 16);
                  --v92;
                  v41 += 2 * v748;
                }
                while (v92 > 1);
              }
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v83;
            }
            while (v83);
          }
          else
          {
            int16x4_t v188 = vdup_n_s16(v17);
            unsigned int v189 = v84 + 1;
            uint16x4_t v190 = (uint16x4_t)vdup_n_s16(v742);
            v191.i64[0] = 0x100000001;
            v191.i64[1] = 0x100000001;
            do
            {
              if ((int)v10 < 4)
              {
                int v194 = v10;
              }
              else
              {
                unsigned int v192 = v189;
                do
                {
                  uint32x4_t v193 = vmull_u16(v190, *v38);
                  *v38++ = (uint16x4_t)vadd_s16(v188, vaddhn_s32((int32x4_t)vsraq_n_u32(v193, v193, 0x10uLL), v191));
                  v41 += 8 * v748;
                  --v192;
                }
                while (v192 > 1);
                int v194 = v10 & 3;
              }
              if (v194 >= 1)
              {
                unsigned int v195 = v194 + 1;
                do
                {
                  v38->i16[0] = v17 + ((v38->u16[0] * v742 + ((v38->u16[0] * v742) >> 16) + 1) >> 16);
                  long long v38 = (uint16x4_t *)((char *)v38 + 2);
                  --v195;
                  v41 += 2 * v748;
                }
                while (v195 > 1);
              }
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v83;
            }
            while (v83);
          }
          goto LABEL_390;
        case 3:
          int v94 = v763[0];
          do
          {
            int v95 = v10;
            do
            {
              unsigned int v96 = *(unsigned __int16 *)v41;
              if (v96 == 0xFFFF)
              {
                v38->i16[0] = v17;
                LOWORD(v96) = v18;
              }
              else if (*(_WORD *)v41)
              {
                int v97 = v96 ^ 0xFFFF;
                v38->i16[0] = v17 - ((v97 * v17 + ((v97 * v17) >> 16) + 1) >> 16);
                unsigned int v96 = v18 - ((v97 * v18 + ((v97 * v18) >> 16) + 1) >> 16);
              }
              else
              {
                v38->i16[0] = 0;
              }
              *(_WORD *)long long v41 = v96;
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              v41 += 2 * v748;
              --v95;
            }
            while (v95);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v94;
          }
          while (v94);
          goto LABEL_390;
        case 4:
          int v98 = v763[0];
          do
          {
            int v99 = v10;
            do
            {
              int v100 = *(unsigned __int16 *)v41;
              if (*(_WORD *)v41)
              {
                if (v100 != 0xFFFF)
                {
                  v38->i16[0] = v17 - ((v100 * v17 + ((v100 * v17) >> 16) + 1) >> 16);
                  unsigned int v101 = v18 - ((v100 * v18 + ((v100 * v18) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v101) = 0;
                  v38->i16[0] = 0;
                }
              }
              else
              {
                v38->i16[0] = v17;
                LOWORD(v101) = v18;
              }
              *(_WORD *)long long v41 = v101;
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              v41 += 2 * v748;
              --v99;
            }
            while (v99);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v98;
          }
          while (v98);
          goto LABEL_390;
        case 5:
          int v102 = v763[0];
          do
          {
            int v103 = v10;
            do
            {
              int v104 = *(unsigned __int16 *)v41;
              v38->i16[0] = (v104 * v17 + v38->u16[0] * v742 + ((v104 * v17 + v38->u16[0] * v742) >> 16) + 1) >> 16;
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              *(_WORD *)long long v41 = ((v104 + v742) * v18 + (((v104 + v742) * v18) >> 16) + 1) >> 16;
              v41 += 2 * v748;
              --v103;
            }
            while (v103);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v102;
          }
          while (v102);
          goto LABEL_390;
        case 6:
          int v105 = v763[0];
          do
          {
            int v106 = v10;
            do
            {
              int v107 = *(unsigned __int16 *)v41;
              if ((_WORD)v107 != 0xFFFF)
              {
                if ((unsigned __int16)~(_WORD)v107 == 0xFFFF)
                {
                  v38->i16[0] = v17;
                  LOWORD(v108) = v18;
                }
                else
                {
                  int v109 = (unsigned __int16)~(_WORD)v107;
                  v38->i16[0] += (v109 * v17 + ((v109 * v17) >> 16) + 1) >> 16;
                  int v108 = v107 + ((v109 * v18 + ((v109 * v18) >> 16) + 1) >> 16);
                }
                *(_WORD *)long long v41 = v108;
              }
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              v41 += 2 * v748;
              --v106;
            }
            while (v106);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v105;
          }
          while (v105);
          goto LABEL_390;
        case 7:
          int v110 = v763[0];
          uint64_t v111 = 2 * v748;
          if (v6)
          {
            do
            {
              int v112 = v10;
              do
              {
                int v113 = *(unsigned __int16 *)v41;
                v38->i16[0] -= (v38->u16[0] * v742 + ((v38->u16[0] * v742) >> 16) + 1) >> 16;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                *(_WORD *)long long v41 = v113 - ((v113 * v742 + ((v113 * v742) >> 16) + 1) >> 16);
                v41 += v111;
                --v112;
              }
              while (v112);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v110;
            }
            while (v110);
          }
          else
          {
            do
            {
              int v114 = v10;
              do
              {
                v38->i16[0] -= (v38->u16[0] * v742 + ((v38->u16[0] * v742) >> 16) + 1) >> 16;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                v41 += v111;
                --v114;
              }
              while (v114);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v110;
            }
            while (v110);
          }
          goto LABEL_390;
        case 8:
          int v115 = v763[0];
          uint64_t v116 = 2 * v748;
          if (v6)
          {
            do
            {
              int v117 = v10;
              do
              {
                int v118 = *(unsigned __int16 *)v41;
                v38->i16[0] -= (v38->u16[0] * v18 + ((v38->u16[0] * v18) >> 16) + 1) >> 16;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                *(_WORD *)long long v41 = v118 - ((v118 * v18 + ((v118 * v18) >> 16) + 1) >> 16);
                v41 += v116;
                --v117;
              }
              while (v117);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v115;
            }
            while (v115);
          }
          else
          {
            do
            {
              int v119 = v10;
              do
              {
                v38->i16[0] -= (v38->u16[0] * v18 + ((v38->u16[0] * v18) >> 16) + 1) >> 16;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                v41 += v116;
                --v119;
              }
              while (v119);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v115;
            }
            while (v115);
          }
          goto LABEL_390;
        case 9:
          int v120 = v763[0];
          do
          {
            int v121 = v10;
            do
            {
              int v122 = *(unsigned __int16 *)v41 ^ 0xFFFF;
              v38->i16[0] = (v122 * v17 + v38->u16[0] * v18 + ((v122 * v17 + v38->u16[0] * v18) >> 16) + 1) >> 16;
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              *(_WORD *)long long v41 = ((v122 + v18) * v18 + (((v122 + v18) * v18) >> 16) + 1) >> 16;
              v41 += 2 * v748;
              --v121;
            }
            while (v121);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v120;
          }
          while (v120);
          goto LABEL_390;
        case 10:
          int v123 = v763[0];
          do
          {
            int v124 = v10;
            do
            {
              int v125 = *(unsigned __int16 *)v41 ^ 0xFFFF;
              v38->i16[0] = (v125 * v17 + v38->u16[0] * v742 + ((v125 * v17 + v38->u16[0] * v742) >> 16) + 1) >> 16;
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              *(_WORD *)long long v41 = ((v125 + v742) * v18 + (((v125 + v742) * v18) >> 16) + 1) >> 16;
              v41 += 2 * v748;
              --v124;
            }
            while (v124);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            --v123;
          }
          while (v123);
          goto LABEL_390;
        case 11:
          if (v6)
          {
            int v126 = v763[0];
            do
            {
              int v127 = v10;
              do
              {
                int v128 = *(unsigned __int16 *)v41;
                int v129 = v18 - v17 - v38->u16[0] + v128;
                unsigned int v130 = v128 + v18;
                if (v129 >= 0xFFFF) {
                  LOWORD(v129) = -1;
                }
                if (v130 >= 0xFFFF) {
                  LOWORD(v130) = -1;
                }
                v38->i16[0] = v130 - v129;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                *(_WORD *)long long v41 = v130;
                v41 += 2 * v748;
                --v127;
              }
              while (v127);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v126;
            }
            while (v126);
          }
          else
          {
            int v196 = v763[0];
            do
            {
              int v197 = v10;
              do
              {
                int v198 = v18 - v17 + (v38->u16[0] ^ 0xFFFF);
                if (v198 >= 0xFFFF) {
                  LOWORD(v198) = -1;
                }
                v38->i16[0] = ~(_WORD)v198;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                v41 += 2 * v748;
                --v197;
              }
              while (v197);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v196;
            }
            while (v196);
          }
          goto LABEL_390;
        case 12:
          if (v6)
          {
            int v131 = v763[0];
            do
            {
              int v132 = v10;
              do
              {
                unsigned int v133 = v38->u16[0] + v17;
                unsigned int v134 = *(unsigned __int16 *)v41 + v18;
                if (v133 >= 0xFFFF) {
                  LOWORD(v133) = -1;
                }
                if (v134 >= 0xFFFF) {
                  LOWORD(v134) = -1;
                }
                v38->i16[0] = v133;
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                *(_WORD *)long long v41 = v134;
                v41 += 2 * v748;
                --v132;
              }
              while (v132);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v131;
            }
            while (v131);
          }
          else
          {
            int v199 = v763[0];
            do
            {
              int v200 = v10;
              do
              {
                v38->i16[0] = (2 * v38->i16[0]) | (v38->i16[0] >> 15);
                long long v38 = (uint16x4_t *)((char *)v38 + 2);
                v41 += 2 * v748;
                --v200;
              }
              while (v200);
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v199;
            }
            while (v199);
          }
          goto LABEL_390;
        case 13:
          if (!v18) {
            goto LABEL_391;
          }
          int v135 = v763[0];
          while (1)
          {
            int v136 = v10;
            do
            {
              if (v6)
              {
                unsigned int v137 = *(unsigned __int16 *)v41;
                if (!*(_WORD *)v41)
                {
                  v38->i16[0] = v17;
                  *(_WORD *)long long v41 = v18;
                  goto LABEL_197;
                }
              }
              else
              {
                unsigned int v137 = 0xFFFF;
              }
              uint64_t v138 = v137;
              unint64_t v139 = (v137 ^ 0xFFFF) * (unint64_t)v17 + ((v18 ^ 0xFFFF) + v17) * (unint64_t)v38->u16[0];
              if (v139 <= 0xFFFE8000) {
                unint64_t v140 = v139 + 0x8000;
              }
              else {
                unint64_t v140 = 4294868992;
              }
              unint64_t v141 = (v140 + (v140 >> 16)) >> 16;
              if (v6)
              {
                int64_t v142 = 0xFFFF * (v138 + v18) - v138 * (unint64_t)v18;
                if (v142 <= 4294868992) {
                  unint64_t v143 = v142 + 0x8000;
                }
                else {
                  unint64_t v143 = 4294868992;
                }
                v38->i16[0] = v141;
                *(_WORD *)long long v41 = (v141 | ((v143 >> 16) + v143)) >> 16;
              }
              else
              {
                v38->i16[0] = v141;
              }
LABEL_197:
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              v41 += 2 * v748;
              --v136;
            }
            while (v136);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            if (!--v135)
            {
LABEL_390:
              v763[0] = 0;
LABEL_391:
              long long v38 = *(uint16x4_t **)v750;
              uint64_t v40 = *(void *)v755;
              if (!*(void *)v755) {
                return 1;
              }
              uint64_t v762 = 0;
LABEL_393:
              if (!shape_enum_clip_next(v40, (int *)&v762 + 1, &v762, v773, v763))
              {
                float v49 = (void *)v40;
                goto LABEL_1262;
              }
              *(void *)v755 = v40;
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v31 * (int)v762 + 2 * SHIDWORD(v762));
              unint64_t v43 = v773[0];
              unint64_t v201 = v760;
              if (v6) {
                unint64_t v201 = v34 - v773[0];
              }
              unint64_t v760 = v201;
              if (v6) {
                long long v41 = &v753[2 * v34 * (int)v762 + 2 * SHIDWORD(v762)];
              }
              LODWORD(v10) = v773[0];
              goto LABEL_66;
            }
          }
        case 14:
          if (!v18) {
            goto LABEL_391;
          }
          int v144 = v763[0];
          while (1)
          {
            int v145 = v10;
            do
            {
              if (v6)
              {
                unsigned int v146 = *(unsigned __int16 *)v41;
                if (!*(_WORD *)v41)
                {
                  v38->i16[0] = v17;
                  *(_WORD *)long long v41 = v18;
                  goto LABEL_216;
                }
              }
              else
              {
                unsigned int v146 = 0xFFFF;
              }
              unint64_t v147 = (v38->u16[0] ^ 0xFFFFu) * (unint64_t)v17
                   - v38->u16[0]
                   + ((unint64_t)v38->u16[0] << 16);
              if (v147 <= 0xFFFE8000) {
                unint64_t v148 = v147 + 0x8000;
              }
              else {
                unint64_t v148 = 4294868992;
              }
              unint64_t v149 = (v148 + (v148 >> 16)) >> 16;
              if (v6)
              {
                int64_t v150 = 0xFFFF * (v18 + (unint64_t)v146) - v18 * (unint64_t)v146;
                if (v150 <= 4294868992) {
                  unint64_t v151 = v150 + 0x8000;
                }
                else {
                  unint64_t v151 = 4294868992;
                }
                v38->i16[0] = v149;
                *(_WORD *)long long v41 = (v149 | ((v151 >> 16) + v151)) >> 16;
              }
              else
              {
                v38->i16[0] = v149;
              }
LABEL_216:
              long long v38 = (uint16x4_t *)((char *)v38 + 2);
              v41 += 2 * v748;
              --v145;
            }
            while (v145);
            long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
            v41 += 2 * v760;
            if (!--v144) {
              goto LABEL_390;
            }
          }
        case 15:
          if (!v18) {
            goto LABEL_391;
          }
          int v152 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v153 = PDAoverlayPDA_8925(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v153;
                *(_WORD *)long long v41 = HIWORD(v153);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAoverlayPDA_8925(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v152;
              LODWORD(v10) = v745;
              if (!v152) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 16:
          if (!v18) {
            goto LABEL_391;
          }
          int v154 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v155 = PDAdarkenPDA_8927(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v155;
                *(_WORD *)long long v41 = HIWORD(v155);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAdarkenPDA_8927(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v154;
              LODWORD(v10) = v745;
              if (!v154) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 17:
          if (!v18) {
            goto LABEL_391;
          }
          int v156 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v157 = PDAlightenPDA_8926(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v157;
                *(_WORD *)long long v41 = HIWORD(v157);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAlightenPDA_8926(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v156;
              LODWORD(v10) = v745;
              if (!v156) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 18:
          if (!v18) {
            goto LABEL_391;
          }
          int v158 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v159 = PDAcolordodgePDA_8928(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v159;
                *(_WORD *)long long v41 = HIWORD(v159);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAcolordodgePDA_8928(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v158;
              LODWORD(v10) = v745;
              if (!v158) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 19:
          if (!v18) {
            goto LABEL_391;
          }
          int v160 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v161 = PDAcolorburnPDA_8929(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v161;
                *(_WORD *)long long v41 = HIWORD(v161);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAcolorburnPDA_8929(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v160;
              LODWORD(v10) = v745;
              if (!v160) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 20:
          if (!v18) {
            goto LABEL_391;
          }
          int v162 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v163 = PDAsoftlightPDA_8931(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v163;
                *(_WORD *)long long v41 = HIWORD(v163);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAsoftlightPDA_8931(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v162;
              LODWORD(v10) = v745;
              if (!v162) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 21:
          if (!v18) {
            goto LABEL_391;
          }
          int v164 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v165 = PDAhardlightPDA_8930(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v165;
                *(_WORD *)long long v41 = HIWORD(v165);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAhardlightPDA_8930(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v164;
              LODWORD(v10) = v745;
              if (!v164) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 22:
          if (!v18) {
            goto LABEL_391;
          }
          int v166 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v167 = PDAdifferencePDA_8932(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v167;
                *(_WORD *)long long v41 = HIWORD(v167);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAdifferencePDA_8932(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v166;
              LODWORD(v10) = v745;
              if (!v166) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 23:
          if (!v18) {
            goto LABEL_391;
          }
          if (v17 >= v18) {
            uint64_t v168 = v18;
          }
          else {
            uint64_t v168 = v17;
          }
          int v169 = v763[0];
          break;
        case 24:
          if (!v18) {
            goto LABEL_391;
          }
          int v178 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v179 = PDAhuePDA_8933(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v179;
                *(_WORD *)long long v41 = HIWORD(v179);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAhuePDA_8933(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v178;
              LODWORD(v10) = v745;
              if (!v178) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 25:
          if (!v18) {
            goto LABEL_391;
          }
          int v180 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v181 = PDAhuePDA_8933(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v181;
                *(_WORD *)long long v41 = HIWORD(v181);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAhuePDA_8933(v38->u16[0], 0xFFFFu, v17, v18);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v180;
              LODWORD(v10) = v745;
              if (!v180) {
                break;
              }
            }
          }
          goto LABEL_353;
        case 26:
          if (!v18) {
            goto LABEL_391;
          }
          int v182 = v763[0];
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v183 = PDAluminosityPDA_8935(v17, v18, v38->u16[0], *(unsigned __int16 *)v41);
                v38->i16[0] = v183;
                *(_WORD *)long long v41 = HIWORD(v183);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              v38->i16[0] = PDAluminosityPDA_8935(v17, v18, v38->u16[0], 0xFFFFu);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v182;
              LODWORD(v10) = v745;
              if (!v182) {
                break;
              }
            }
          }
LABEL_353:
          v763[0] = 0;
          int v7 = v717;
          goto LABEL_354;
        case 27:
          if (!v18) {
            goto LABEL_391;
          }
          unint64_t v740 = v31;
          int v184 = v763[0];
          if (v17 >= v18) {
            __int16 v185 = v18;
          }
          else {
            __int16 v185 = v17;
          }
          while (1)
          {
            if (v6)
            {
              if (*(_WORD *)v41)
              {
                int v186 = PDAluminosityPDA_8935(v38->u16[0], *(unsigned __int16 *)v41, v17, v18);
                v38->i16[0] = v186;
                *(_WORD *)long long v41 = HIWORD(v186);
              }
              else
              {
                v38->i16[0] = v17;
                *(_WORD *)long long v41 = v18;
              }
            }
            else
            {
              unint64_t v187 = v38->u16[0] * (unint64_t)v742 + 0x8000;
              v38->i16[0] = v185 + (((v187 >> 16) + v187) >> 16);
            }
            long long v38 = (uint16x4_t *)((char *)v38 + 2);
            v41 += 2 * v748;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
              v41 += 2 * v760;
              --v184;
              LODWORD(v10) = v745;
              if (!v184) {
                break;
              }
            }
          }
          v763[0] = 0;
          int v7 = v717;
LABEL_367:
          unint64_t v31 = v740;
LABEL_354:
          unint64_t v34 = v744;
          goto LABEL_391;
        default:
          goto LABEL_391;
      }
LABEL_304:
      int v170 = v10;
      while (v6)
      {
        unsigned int v171 = *(unsigned __int16 *)v41;
        if (*(_WORD *)v41) {
          goto LABEL_309;
        }
        v38->i16[0] = v17;
        *(_WORD *)long long v41 = v18;
LABEL_321:
        long long v38 = (uint16x4_t *)((char *)v38 + 2);
        v41 += 2 * v748;
        if (!--v170)
        {
          long long v38 = (uint16x4_t *)((char *)v38 + 2 * v759);
          v41 += 2 * v760;
          if (!--v169) {
            goto LABEL_390;
          }
          goto LABEL_304;
        }
      }
      unsigned int v171 = 0xFFFF;
LABEL_309:
      if (v38->u16[0] >= v171) {
        uint64_t v172 = v171;
      }
      else {
        uint64_t v172 = v38->u16[0];
      }
      int64_t v173 = 0xFFFF * (v172 + v168) - (2 * v168) * (unint64_t)v172;
      if (v173 <= 4294868992) {
        unint64_t v174 = v173 + 0x8000;
      }
      else {
        unint64_t v174 = 4294868992;
      }
      unint64_t v175 = (v174 + (v174 >> 16)) >> 16;
      if (v6)
      {
        int64_t v176 = 0xFFFF * (v18 + (unint64_t)v171) - v18 * (unint64_t)v171;
        if (v176 <= 4294868992) {
          unint64_t v177 = v176 + 0x8000;
        }
        else {
          unint64_t v177 = 4294868992;
        }
        v38->i16[0] = v175;
        *(_WORD *)long long v41 = (v175 | ((v177 >> 16) + v177)) >> 16;
      }
      else
      {
        v38->i16[0] = v175;
      }
      goto LABEL_321;
    }
    v773[0] = *(_DWORD *)(v3 + 4);
    v763[0] = v12;
    uint64_t v19 = *(void *)(v3 + 88);
    uint64_t v21 = *(int *)(v3 + 12);
    uint64_t v20 = *(int *)(v3 + 16);
    unint64_t v22 = (unint64_t)*(int *)(v3 + 28) >> 1;
    if (v6)
    {
      unint64_t v23 = (unint64_t)*(int *)(v3 + 32) >> 1;
      uint64_t v720 = (char *)(v6 + 2 * (v21 + v23 * v20));
      uint64_t v24 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v23 = 0;
      uint64_t v720 = 0;
      uint64_t v24 = 0;
    }
    unint64_t v719 = *(void *)(v3 + 40) + 2 * (v21 + v20 * v22);
    int v36 = *(_DWORD *)(v3 + 56);
    int v35 = *(_DWORD *)(v3 + 60);
    unint64_t v743 = (unint64_t)*(int *)(v3 + 76) >> 1;
    unint64_t v713 = v3;
    if (v16 == 256)
    {
      int v712 = *(_DWORD *)(v3 + 60);
      if (v5)
      {
        unint64_t v741 = (unint64_t)*(int *)(v3 + 80) >> 1;
        v5 += 2 * v36 + 2 * v741 * v35;
        uint64_t v37 = 0xFFFFFFFFLL;
      }
      else
      {
        unint64_t v741 = 0;
        uint64_t v37 = 0;
      }
      float v50 = (_WORD *)(v19 + 2 * (v36 + v35 * v743));
      if (v743 == v22 && (uint64_t)(v719 - (void)v50) >= 1)
      {
        if (v10 >= (v719 - (unint64_t)v50) >> 1)
        {
          v719 += 2 * v11;
          v50 += v11;
          v720 += 2 * (v24 & v11);
          int v52 = -1;
          unint64_t v743 = (unint64_t)*(int *)(v3 + 28) >> 1;
          v5 += 2 * (v37 & v11);
          goto LABEL_49;
        }
        int v51 = &v50[v22 * v13];
        if (v719 <= (unint64_t)&v51[v11])
        {
          v719 += 2 * v22 * v13;
          unint64_t v22 = -(uint64_t)v22;
          v720 += 2 * v23 * v13;
          unint64_t v23 = -(uint64_t)v23;
          v5 += 2 * v741 * v13;
          v24 &= 1u;
          unint64_t v741 = -(uint64_t)v741;
          unint64_t v743 = v22;
          v37 &= 1u;
          int v52 = 1;
          float v50 = v51;
          goto LABEL_49;
        }
      }
      v24 &= 1u;
      v37 &= 1u;
      int v52 = 1;
LABEL_49:
      int v711 = *(_DWORD *)(v3 + 56);
      if (v14)
      {
        uint64_t v758 = v37;
        uint64_t v761 = v24;
        v738 = 0;
        unint64_t v739 = 0;
        uint64_t v19 = -1;
        int v723 = v743;
        int v722 = v741;
        goto LABEL_54;
      }
      unint64_t v58 = v52 * (int)v10;
      unint64_t v754 = v23 - (int)v24 * (int)v10;
      unint64_t v59 = -1;
      unint64_t v60 = v741;
      int v721 = v52;
      int v722 = v741;
      unint64_t v61 = v743;
      int v723 = v743;
LABEL_62:
      uint64_t v724 = 0;
      uint64_t v66 = 0;
      unint64_t v743 = v61 - v58;
      unint64_t v739 = 0;
      unint64_t v741 = v60 - (int)v37 * (int)v10;
      uint64_t v718 = (uint64_t)v50;
      char v65 = (_WORD *)v719;
      uint64_t v55 = v720;
      float v56 = v5;
      v749 = v5;
      goto LABEL_400;
    }
    int v723 = *(_DWORD *)(v3 + 64);
    int v722 = *(_DWORD *)(v3 + 68);
    if (v5)
    {
      unint64_t v741 = (unint64_t)*(int *)(v3 + 80) >> 1;
      uint64_t v37 = 1;
    }
    else
    {
      unint64_t v741 = 0;
      uint64_t v37 = 0;
    }
    unint64_t v739 = v19 + 2 * v743 * v722;
    v24 &= 1u;
    if (v14)
    {
      int v711 = *(_DWORD *)(v3 + 56);
      int v712 = *(_DWORD *)(v3 + 60);
      uint64_t v758 = v37;
      uint64_t v761 = v24;
      int v52 = 1;
      v738 = *(_WORD **)(v3 + 88);
      float v50 = v738;
LABEL_54:
      int v721 = v52;
      unint64_t v725 = v22;
      shape_enum_clip_alloc(v2, v3, (int *)v14, v52, v22, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
      uint64_t v54 = v53;
      uint64_t v718 = (uint64_t)v50;
      unint64_t v754 = v23;
      uint64_t v55 = v720;
      float v56 = v5;
      float v57 = v5;
      if (!v53) {
        return 1;
      }
      goto LABEL_1238;
    }
    unint64_t v754 = v23 - (v24 * v10);
    if (!v19)
    {
      int v711 = *(_DWORD *)(v3 + 56);
      int v712 = *(_DWORD *)(v3 + 60);
      float v50 = 0;
      unint64_t v59 = 0;
      int v721 = 1;
      unint64_t v58 = v10;
      unint64_t v60 = v741;
      unint64_t v61 = (unint64_t)*(int *)(v3 + 76) >> 1;
      goto LABEL_62;
    }
    uint64_t v62 = v35 % v722;
    int v712 = v35 % v722;
    uint64_t v718 = *(void *)(v3 + 88);
    unint64_t v63 = v19 + 2 * v743 * v62;
    int v64 = v36 % v723;
    float v50 = (_WORD *)(v63 + 2 * v64);
    unint64_t v59 = v63 + 2 * v723;
    int v711 = v64;
    uint64_t v724 = 0;
    if (v5)
    {
      float v56 = &v5[2 * v741 * v62 + 2 * v64];
      int v721 = 1;
      uint64_t v37 = 1;
      char v65 = (_WORD *)v719;
      uint64_t v55 = v720;
      uint64_t v66 = (_WORD *)(v63 + 2 * v64);
      v749 = v56;
    }
    else
    {
      float v56 = 0;
      v749 = 0;
      int v721 = 1;
      char v65 = (_WORD *)v719;
      uint64_t v55 = v720;
      uint64_t v66 = (_WORD *)(v63 + 2 * v64);
    }
    unint64_t v58 = v10;
LABEL_400:
    uint64_t v758 = v37;
    uint64_t v761 = v24;
    unint64_t v725 = v22;
    *(void *)v751 = v22 - v58;
    switch(v7)
    {
      case 0:
        v738 = v66;
        uint64_t v19 = v59;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v202 = *(void *)v751 - (int)v10;
        unsigned int v203 = &v65[-(int)v10 + 1];
        if (v721 >= 0)
        {
          unsigned int v203 = v65;
          uint64_t v202 = *(void *)v751 + (int)v10;
        }
        unsigned int v204 = v763[0];
        uint64_t v205 = v763[0] - 1;
        unsigned int v206 = (char *)&v203[(v202 * v205) & (v202 >> 63)];
        if (v202 < 0) {
          uint64_t v202 = -v202;
        }
        CGBlt_fillBytes(2 * v10, v763[0], 0, v206, 2 * v202);
        if (v761)
        {
          if (v721 < 0)
          {
            uint64_t v207 = v754 - (int)v10;
            v55 += -2 * (int)v10 + 2;
          }
          else
          {
            uint64_t v207 = v754 + (int)v10;
          }
          if (v207 >= 0) {
            uint64_t v666 = v207;
          }
          else {
            uint64_t v666 = -v207;
          }
          v55 += 2 * ((v207 * v205) & (v207 >> 63));
          unint64_t v754 = v666;
          CGBlt_fillBytes(2 * v10, v204, 0, v55, 2 * v666);
        }
        goto LABEL_1043;
      case 1:
        int v208 = *(unsigned __int8 *)(v713 + 1);
        if (v208 == 2)
        {
          if ((int)v10 >= 16 && (2 * v723) <= 0x40)
          {
            v4.i32[0] = 2 * v723;
            uint8x8_t v652 = (uint8x8_t)vcnt_s8(v4);
            v652.i16[0] = vaddlv_u8(v652);
            if (v652.i32[0] <= 1u)
            {
              v738 = v66;
              uint64_t v19 = v59;
              int v653 = 2 * (v10 + v751[0]);
              unsigned int v757 = 2 * v10;
              int v752 = v763[0];
              CGSFillDRAM64((unint64_t)v65, v653, 2 * v10, v763[0], v718, 2 * v743, 2 * v723, v722, 2 * v711, v712);
              if (!v761) {
                goto LABEL_1153;
              }
              uint64_t v54 = v724;
              if (v37) {
                CGSFillDRAM64((unint64_t)v55, 2 * (v10 + v754), v757, v752, (uint64_t)v5, 2 * v741, 2 * v723, v722, 2 * v711, v712);
              }
              else {
                CGBlt_fillBytes(v757, v752, -1, v55, 2 * (v10 + v754));
              }
              goto LABEL_1154;
            }
          }
        }
        else if (v208 == 1)
        {
          v738 = v66;
          unint64_t v715 = v23;
          uint64_t v19 = v59;
          int v209 = v5;
          if (v721 < 0)
          {
            uint64_t v210 = v743 - (int)v10;
            v50 += -(int)v10 + 1;
            uint64_t v211 = *(void *)v751 - (int)v10;
            v65 += -(int)v10 + 1;
          }
          else
          {
            uint64_t v210 = v743 + (int)v10;
            uint64_t v211 = *(void *)v751 + (int)v10;
          }
          uint64_t v697 = v763[0] - 1;
          if (v210 >= 0) {
            unint64_t v698 = v210;
          }
          else {
            unint64_t v698 = -v210;
          }
          uint64_t v699 = (char *)&v50[(v210 * v697) & (v210 >> 63)];
          int v700 = v763[0];
          if (v211 >= 0) {
            LODWORD(v701) = v211;
          }
          else {
            uint64_t v701 = -v211;
          }
          unint64_t v743 = v698;
          CGBlt_copyBytes(2 * v10, v763[0], v699, (char *)&v65[(v211 * v697) & (v211 >> 63)], 2 * v698, 2 * v701);
          if (v761)
          {
            if (v37)
            {
              uint64_t v702 = v741 - (int)v10;
              int v703 = &v56[-2 * (int)v10 + 2];
              uint64_t v704 = v754 - (int)v10;
              uint64_t v705 = &v55[-2 * (int)v10 + 2];
              if (v721 >= 0)
              {
                uint64_t v702 = v741 + (int)v10;
                uint64_t v704 = v754 + (int)v10;
                uint64_t v705 = v55;
                int v703 = v56;
              }
              if (v702 >= 0) {
                unint64_t v706 = v702;
              }
              else {
                unint64_t v706 = -v702;
              }
              float v56 = &v703[2 * ((v702 * v697) & (v702 >> 63))];
              uint64_t v55 = &v705[2 * ((v704 * v697) & (v704 >> 63))];
              if (v704 >= 0) {
                uint64_t v707 = v704;
              }
              else {
                uint64_t v707 = -v704;
              }
              unint64_t v741 = v706;
              unint64_t v754 = v707;
              CGBlt_copyBytes(2 * v10, v700, v56, &v705[2 * ((v704 * v697) & (v704 >> 63))], 2 * v706, 2 * v707);
            }
            else
            {
              uint64_t v708 = v754 - (int)v10;
              unint64_t v709 = &v55[-2 * (int)v10 + 2];
              if (v721 >= 0)
              {
                uint64_t v708 = v754 + (int)v10;
                unint64_t v709 = v55;
              }
              if (v708 >= 0) {
                uint64_t v710 = v708;
              }
              else {
                uint64_t v710 = -v708;
              }
              uint64_t v55 = &v709[2 * ((v708 * v697) & (v708 >> 63))];
              unint64_t v754 = v710;
              CGBlt_fillBytes(2 * v10, v700, -1, v55, 2 * v710);
            }
          }
          float v5 = v209;
          goto LABEL_1044;
        }
        if (v24)
        {
          uint64_t v654 = 2 * v721;
          uint64_t v655 = 2 * (int)v24;
          if (v37)
          {
            uint64_t v656 = (int)v37;
            int v657 = v763[0];
            float v57 = v749;
            do
            {
              int v658 = v10;
              do
              {
                _WORD *v65 = *v50;
                *(_WORD *)uint64_t v55 = *(_WORD *)v56;
                v659 = &v50[v721];
                if ((unint64_t)v659 >= v59) {
                  uint64_t v660 = -(uint64_t)v723;
                }
                else {
                  uint64_t v660 = 0;
                }
                float v50 = &v659[v660];
                v56 += 2 * v656 + 2 * v660;
                char v65 = (_WORD *)((char *)v65 + v654);
                v55 += v655;
                --v658;
              }
              while (v658);
              if (v739)
              {
                v661 = &v66[v743];
                BOOL v662 = (unint64_t)v661 >= v739;
                if ((unint64_t)v661 >= v739) {
                  uint64_t v663 = -(uint64_t)(v743 * v722);
                }
                else {
                  uint64_t v663 = 0;
                }
                float v50 = &v661[v663];
                unint64_t v664 = v59 + 2 * v663;
                if (v662) {
                  uint64_t v665 = -(uint64_t)(v741 * v722);
                }
                else {
                  uint64_t v665 = 0;
                }
                float v56 = &v57[2 * v741 + 2 * v665];
                unint64_t v59 = v664 + 2 * v743;
                uint64_t v66 = v50;
                float v57 = v56;
              }
              else
              {
                v50 += v743;
                v56 += 2 * v741;
              }
              v65 += *(void *)v751;
              v55 += 2 * v754;
              --v657;
            }
            while (v657);
          }
          else
          {
            int v677 = v763[0];
            float v57 = v749;
            do
            {
              int v678 = v10;
              do
              {
                _WORD *v65 = *v50;
                *(_WORD *)uint64_t v55 = -1;
                v679 = &v50[v721];
                if ((unint64_t)v679 >= v59) {
                  uint64_t v680 = -(uint64_t)v723;
                }
                else {
                  uint64_t v680 = 0;
                }
                float v50 = &v679[v680];
                v56 += 2 * v680;
                char v65 = (_WORD *)((char *)v65 + v654);
                v55 += v655;
                --v678;
              }
              while (v678);
              if (v739)
              {
                v681 = &v66[v743];
                BOOL v682 = (unint64_t)v681 >= v739;
                if ((unint64_t)v681 >= v739) {
                  uint64_t v683 = -(uint64_t)(v743 * v722);
                }
                else {
                  uint64_t v683 = 0;
                }
                float v50 = &v681[v683];
                unint64_t v684 = v59 + 2 * v683;
                if (v682) {
                  uint64_t v685 = -(uint64_t)(v741 * v722);
                }
                else {
                  uint64_t v685 = 0;
                }
                float v56 = &v57[2 * v741 + 2 * v685];
                unint64_t v59 = v684 + 2 * v743;
                uint64_t v66 = v50;
                float v57 = v56;
              }
              else
              {
                v50 += v743;
                v56 += 2 * v741;
              }
              v65 += *(void *)v751;
              v55 += 2 * v754;
              --v677;
            }
            while (v677);
          }
        }
        else
        {
          uint64_t v667 = (int)v37;
          int v668 = v763[0];
          float v57 = v749;
          do
          {
            int v669 = v10;
            do
            {
              _WORD *v65 = *v50;
              int v670 = &v50[v721];
              if ((unint64_t)v670 >= v59) {
                uint64_t v671 = -(uint64_t)v723;
              }
              else {
                uint64_t v671 = 0;
              }
              float v50 = &v670[v671];
              v56 += 2 * v667 + 2 * v671;
              v65 += v721;
              --v669;
            }
            while (v669);
            if (v739)
            {
              v672 = &v66[v743];
              BOOL v673 = (unint64_t)v672 >= v739;
              if ((unint64_t)v672 >= v739) {
                uint64_t v674 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v674 = 0;
              }
              float v50 = &v672[v674];
              unint64_t v675 = v59 + 2 * v674;
              if (v673) {
                uint64_t v676 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v676 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v676];
              unint64_t v59 = v675 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v668;
          }
          while (v668);
        }
        goto LABEL_1236;
      case 2:
        if (v24)
        {
          uint64_t v212 = (int)v37;
          int v213 = v763[0];
          float v57 = v749;
          do
          {
            int v214 = v10;
            do
            {
              int v215 = *(unsigned __int16 *)v56;
              if (*(_WORD *)v56)
              {
                if (v215 == 0xFFFF)
                {
                  _WORD *v65 = *v50;
                  LOWORD(v216) = *(_WORD *)v56;
                }
                else
                {
                  unsigned int v217 = *(unsigned __int16 *)v55 * (v215 ^ 0xFFFF)
                       + ((*(unsigned __int16 *)v55 * (v215 ^ 0xFFFFu)) >> 16)
                       + 1;
                  _WORD *v65 = *v50
                       + (((unsigned __int16)*v65 * (v215 ^ 0xFFFF)
                         + (((unsigned __int16)*v65 * (v215 ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                  int v216 = v215 + HIWORD(v217);
                }
                *(_WORD *)uint64_t v55 = v216;
              }
              unsigned int v218 = &v50[v721];
              if ((unint64_t)v218 >= v59) {
                uint64_t v219 = -(uint64_t)v723;
              }
              else {
                uint64_t v219 = 0;
              }
              float v50 = &v218[v219];
              v56 += 2 * v212 + 2 * v219;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v214;
            }
            while (v214);
            if (v739)
            {
              uint64_t v220 = &v66[v743];
              BOOL v221 = (unint64_t)v220 >= v739;
              if ((unint64_t)v220 >= v739) {
                uint64_t v222 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v222 = 0;
              }
              float v50 = &v220[v222];
              unint64_t v223 = v59 + 2 * v222;
              if (v221) {
                uint64_t v224 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v224 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v224];
              unint64_t v59 = v223 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v213;
          }
          while (v213);
        }
        else
        {
          uint64_t v587 = (int)v37;
          int v588 = v763[0];
          float v57 = v749;
          do
          {
            int v589 = v10;
            do
            {
              int v590 = *(unsigned __int16 *)v56;
              if (*(_WORD *)v56)
              {
                if (v590 == 0xFFFF) {
                  LOWORD(v591) = *v50;
                }
                else {
                  unsigned int v591 = (unsigned __int16)*v50
                }
                       + (((unsigned __int16)*v65 * (v590 ^ 0xFFFF)
                         + (((unsigned __int16)*v65 * (v590 ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                _WORD *v65 = v591;
              }
              v592 = &v50[v721];
              if ((unint64_t)v592 >= v59) {
                uint64_t v593 = -(uint64_t)v723;
              }
              else {
                uint64_t v593 = 0;
              }
              float v50 = &v592[v593];
              v56 += 2 * v587 + 2 * v593;
              v65 += v721;
              --v589;
            }
            while (v589);
            if (v739)
            {
              unsigned int v594 = &v66[v743];
              BOOL v595 = (unint64_t)v594 >= v739;
              if ((unint64_t)v594 >= v739) {
                uint64_t v596 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v596 = 0;
              }
              float v50 = &v594[v596];
              unint64_t v597 = v59 + 2 * v596;
              if (v595) {
                uint64_t v598 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v598 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v598];
              unint64_t v59 = v597 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v588;
          }
          while (v588);
        }
        goto LABEL_1236;
      case 3:
        if (v37)
        {
          uint64_t v225 = (int)v37;
          int v226 = v763[0];
          float v57 = v749;
          do
          {
            int v227 = v10;
            do
            {
              int v228 = *(unsigned __int16 *)v55;
              if (v228 == 0xFFFF)
              {
                _WORD *v65 = *v50;
                LOWORD(v228) = *(_WORD *)v56;
              }
              else if (*(_WORD *)v55)
              {
                int v229 = *(unsigned __int16 *)v56;
                int v230 = v228 ^ 0xFFFF;
                _WORD *v65 = *v50
                     - (((unsigned __int16)*v50 * v230 + (((unsigned __int16)*v50 * v230) >> 16) + 1) >> 16);
                int v228 = v229 - ((v229 * v230 + ((v229 * v230) >> 16) + 1) >> 16);
              }
              else
              {
                _WORD *v65 = 0;
              }
              *(_WORD *)uint64_t v55 = v228;
              unsigned int v231 = &v50[v721];
              if ((unint64_t)v231 >= v59) {
                uint64_t v232 = -(uint64_t)v723;
              }
              else {
                uint64_t v232 = 0;
              }
              float v50 = &v231[v232];
              v56 += 2 * v225 + 2 * v232;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v227;
            }
            while (v227);
            if (v739)
            {
              unsigned int v233 = &v66[v743];
              BOOL v234 = (unint64_t)v233 >= v739;
              if ((unint64_t)v233 >= v739) {
                uint64_t v235 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v235 = 0;
              }
              float v50 = &v233[v235];
              unint64_t v236 = v59 + 2 * v235;
              if (v234) {
                uint64_t v237 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v237 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v237];
              unint64_t v59 = v236 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v226;
          }
          while (v226);
        }
        else
        {
          int v599 = v763[0];
          float v57 = v749;
          do
          {
            int v600 = v10;
            do
            {
              unsigned int v601 = *(unsigned __int16 *)v55;
              if (*(_WORD *)v55)
              {
                if (v601 == 0xFFFF) {
                  LOWORD(v601) = *v50;
                }
                else {
                  unsigned int v601 = (unsigned __int16)*v50
                }
                       - (((unsigned __int16)*v50 * (v601 ^ 0xFFFF)
                         + (((unsigned __int16)*v50 * (v601 ^ 0xFFFF)) >> 16)
                         + 1) >> 16);
              }
              _WORD *v65 = v601;
              v602 = &v50[v721];
              if ((unint64_t)v602 >= v59) {
                uint64_t v603 = -(uint64_t)v723;
              }
              else {
                uint64_t v603 = 0;
              }
              float v50 = &v602[v603];
              v56 += 2 * v603;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v600;
            }
            while (v600);
            if (v739)
            {
              float v604 = &v66[v743];
              BOOL v605 = (unint64_t)v604 >= v739;
              if ((unint64_t)v604 >= v739) {
                uint64_t v606 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v606 = 0;
              }
              float v50 = &v604[v606];
              unint64_t v607 = v59 + 2 * v606;
              if (v605) {
                uint64_t v608 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v608 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v608];
              unint64_t v59 = v607 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v599;
          }
          while (v599);
        }
        goto LABEL_1236;
      case 4:
        int v238 = v763[0];
        do
        {
          int v239 = v10;
          do
          {
            int v240 = *(unsigned __int16 *)v55;
            if (*(_WORD *)v55)
            {
              if (v240 != 0xFFFF)
              {
                if (v37) {
                  int v242 = *(unsigned __int16 *)v56;
                }
                else {
                  int v242 = 0xFFFF;
                }
                _WORD *v65 = *v50
                     - (((unsigned __int16)*v50 * v240 + (((unsigned __int16)*v50 * v240) >> 16) + 1) >> 16);
                unsigned int v241 = v242 - ((v242 * v240 + ((v242 * v240) >> 16) + 1) >> 16);
              }
              else
              {
                LOWORD(v241) = 0;
                _WORD *v65 = 0;
              }
            }
            else if (v37)
            {
              LOWORD(v241) = *(_WORD *)v56;
            }
            else
            {
              LOWORD(v241) = -1;
            }
            *(_WORD *)uint64_t v55 = v241;
            unsigned int v243 = &v50[v721];
            if ((unint64_t)v243 >= v59) {
              uint64_t v244 = -(uint64_t)v723;
            }
            else {
              uint64_t v244 = 0;
            }
            float v50 = &v243[v244];
            v56 += 2 * (int)v37 + 2 * v244;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v239;
          }
          while (v239);
          if (v739)
          {
            unint64_t v245 = &v66[v743];
            BOOL v246 = (unint64_t)v245 >= v739;
            if ((unint64_t)v245 >= v739) {
              uint64_t v247 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v247 = 0;
            }
            float v50 = &v245[v247];
            unint64_t v248 = v59 + 2 * v247;
            if (v246) {
              uint64_t v249 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v249 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v249];
            unint64_t v59 = v248 + 2 * v743;
            uint64_t v66 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v238;
        }
        while (v238);
        goto LABEL_1152;
      case 5:
        uint64_t v250 = (int)v37;
        int v251 = v763[0];
        float v57 = v749;
        do
        {
          int v252 = v10;
          do
          {
            int v253 = *(unsigned __int16 *)v55;
            int v254 = *(unsigned __int16 *)v56;
            unsigned int v255 = (unsigned __int16)*v50 * v253 + (unsigned __int16)*v65 * (v254 ^ 0xFFFF);
            _WORD *v65 = (v255 + HIWORD(v255) + 1) >> 16;
            *(_WORD *)uint64_t v55 = (((v254 ^ 0xFFFF) + v253) * v254 + ((((v254 ^ 0xFFFFu) + v253) * v254) >> 16) + 1) >> 16;
            unsigned int v256 = &v50[v721];
            if ((unint64_t)v256 >= v59) {
              uint64_t v257 = -(uint64_t)v723;
            }
            else {
              uint64_t v257 = 0;
            }
            float v50 = &v256[v257];
            v56 += 2 * v250 + 2 * v257;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v252;
          }
          while (v252);
          if (v739)
          {
            int v258 = &v66[v743];
            BOOL v259 = (unint64_t)v258 >= v739;
            if ((unint64_t)v258 >= v739) {
              uint64_t v260 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v260 = 0;
            }
            float v50 = &v258[v260];
            unint64_t v261 = v59 + 2 * v260;
            if (v259) {
              uint64_t v262 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v262 = 0;
            }
            float v56 = &v57[2 * v741 + 2 * v262];
            unint64_t v59 = v261 + 2 * v743;
            uint64_t v66 = v50;
            float v57 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v251;
        }
        while (v251);
        goto LABEL_1236;
      case 6:
        int v263 = v763[0];
        do
        {
          int v264 = v10;
          do
          {
            int v265 = *(unsigned __int16 *)v55;
            if ((_WORD)v265 != 0xFFFF)
            {
              if ((unsigned __int16)~(_WORD)v265 == 0xFFFF)
              {
                _WORD *v65 = *v50;
                if (v37) {
                  LOWORD(v266) = *(_WORD *)v56;
                }
                else {
                  LOWORD(v266) = -1;
                }
              }
              else
              {
                if (v37) {
                  int v267 = *(unsigned __int16 *)v56;
                }
                else {
                  int v267 = 0xFFFF;
                }
                int v268 = (unsigned __int16)~(_WORD)v265;
                *v65 += ((unsigned __int16)*v50 * v268 + (((unsigned __int16)*v50 * v268) >> 16) + 1) >> 16;
                int v266 = v265 + ((v267 * v268 + ((v267 * v268) >> 16) + 1) >> 16);
              }
              *(_WORD *)uint64_t v55 = v266;
            }
            unsigned int v269 = &v50[v721];
            if ((unint64_t)v269 >= v59) {
              uint64_t v270 = -(uint64_t)v723;
            }
            else {
              uint64_t v270 = 0;
            }
            float v50 = &v269[v270];
            v56 += 2 * (int)v37 + 2 * v270;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v264;
          }
          while (v264);
          if (v739)
          {
            unsigned __int16 v271 = &v66[v743];
            BOOL v272 = (unint64_t)v271 >= v739;
            if ((unint64_t)v271 >= v739) {
              uint64_t v273 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v273 = 0;
            }
            float v50 = &v271[v273];
            unint64_t v274 = v59 + 2 * v273;
            if (v272) {
              uint64_t v275 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v275 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v275];
            unint64_t v59 = v274 + 2 * v743;
            uint64_t v66 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v263;
        }
        while (v263);
        goto LABEL_1152;
      case 7:
        if (v24)
        {
          uint64_t v276 = (int)v37;
          int v277 = v763[0];
          float v57 = v749;
          do
          {
            int v278 = v10;
            do
            {
              int v279 = *(unsigned __int16 *)v56;
              if (v279 != 0xFFFF)
              {
                if (*(_WORD *)v56)
                {
                  int v280 = *(unsigned __int16 *)v55;
                  int v281 = v279 ^ 0xFFFF;
                  *v65 -= ((unsigned __int16)*v65 * v281 + (((unsigned __int16)*v65 * v281) >> 16) + 1) >> 16;
                  int v279 = v280 - ((v280 * v281 + ((v280 * v281) >> 16) + 1) >> 16);
                }
                else
                {
                  _WORD *v65 = 0;
                }
                *(_WORD *)uint64_t v55 = v279;
              }
              unsigned int v282 = &v50[v721];
              if ((unint64_t)v282 >= v59) {
                uint64_t v283 = -(uint64_t)v723;
              }
              else {
                uint64_t v283 = 0;
              }
              float v50 = &v282[v283];
              v56 += 2 * v276 + 2 * v283;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v278;
            }
            while (v278);
            if (v739)
            {
              unsigned int v284 = &v66[v743];
              BOOL v285 = (unint64_t)v284 >= v739;
              if ((unint64_t)v284 >= v739) {
                uint64_t v286 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v286 = 0;
              }
              float v50 = &v284[v286];
              unint64_t v287 = v59 + 2 * v286;
              if (v285) {
                uint64_t v288 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v288 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v288];
              unint64_t v59 = v287 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v277;
          }
          while (v277);
          goto LABEL_1236;
        }
        uint64_t v609 = (int)v37;
        int v610 = v763[0];
        float v57 = v749;
LABEL_1089:
        int v611 = v10;
        while (1)
        {
          unsigned int v612 = *(unsigned __int16 *)v56;
          if (!*(_WORD *)v56) {
            goto LABEL_1093;
          }
          if (v612 != 0xFFFF) {
            break;
          }
LABEL_1094:
          unsigned int v613 = &v50[v721];
          if ((unint64_t)v613 >= v59) {
            uint64_t v614 = -(uint64_t)v723;
          }
          else {
            uint64_t v614 = 0;
          }
          float v50 = &v613[v614];
          v56 += 2 * v609 + 2 * v614;
          v65 += v721;
          if (!--v611)
          {
            if (v739)
            {
              v615 = &v66[v743];
              BOOL v616 = (unint64_t)v615 >= v739;
              if ((unint64_t)v615 >= v739) {
                uint64_t v617 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v617 = 0;
              }
              float v50 = &v615[v617];
              unint64_t v618 = v59 + 2 * v617;
              if (v616) {
                uint64_t v619 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v619 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v619];
              unint64_t v59 = v618 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            if (!--v610) {
              goto LABEL_1236;
            }
            goto LABEL_1089;
          }
        }
        unsigned int v612 = (unsigned __int16)*v65
             - (((unsigned __int16)*v65 * (v612 ^ 0xFFFF) + (((unsigned __int16)*v65 * (v612 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_1093:
        _WORD *v65 = v612;
        goto LABEL_1094;
      case 8:
        uint64_t v289 = (int)v37;
        if (v24)
        {
          int v290 = v763[0];
          float v57 = v749;
          do
          {
            int v291 = v10;
            do
            {
              int v292 = *(unsigned __int16 *)v56;
              if (*(_WORD *)v56)
              {
                if (v292 != 0xFFFF)
                {
                  int v294 = *(unsigned __int16 *)v55;
                  *v65 -= ((unsigned __int16)*v65 * v292 + (((unsigned __int16)*v65 * v292) >> 16) + 1) >> 16;
                  int v293 = v294 - ((v294 * v292 + ((v294 * v292) >> 16) + 1) >> 16);
                }
                else
                {
                  LOWORD(v293) = 0;
                  _WORD *v65 = 0;
                }
                *(_WORD *)uint64_t v55 = v293;
              }
              int v295 = &v50[v721];
              if ((unint64_t)v295 >= v59) {
                uint64_t v296 = -(uint64_t)v723;
              }
              else {
                uint64_t v296 = 0;
              }
              float v50 = &v295[v296];
              v56 += 2 * v289 + 2 * v296;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v291;
            }
            while (v291);
            if (v739)
            {
              unsigned int v297 = &v66[v743];
              BOOL v298 = (unint64_t)v297 >= v739;
              if ((unint64_t)v297 >= v739) {
                uint64_t v299 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v299 = 0;
              }
              float v50 = &v297[v299];
              unint64_t v300 = v59 + 2 * v299;
              if (v298) {
                uint64_t v301 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v301 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v301];
              unint64_t v59 = v300 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v290;
          }
          while (v290);
LABEL_1236:
          v738 = v66;
          uint64_t v19 = v59;
          v763[0] = 0;
          uint64_t v54 = v724;
          if (!v724) {
            return 1;
          }
          goto LABEL_1237;
        }
        int v620 = v763[0];
        float v57 = v749;
LABEL_1110:
        int v621 = v10;
        while (1)
        {
          int v622 = *(unsigned __int16 *)v56;
          if ((_WORD)v622 == 0xFFFF) {
            break;
          }
          if ((unsigned __int16)~(_WORD)v622 != 0xFFFF)
          {
            unsigned int v623 = (unsigned __int16)*v65
                 - (((unsigned __int16)*v65 * v622 + (((unsigned __int16)*v65 * v622) >> 16) + 1) >> 16);
LABEL_1115:
            _WORD *v65 = v623;
          }
          v624 = &v50[v721];
          if ((unint64_t)v624 >= v59) {
            uint64_t v625 = -(uint64_t)v723;
          }
          else {
            uint64_t v625 = 0;
          }
          float v50 = &v624[v625];
          v56 += 2 * v289 + 2 * v625;
          v65 += v721;
          if (!--v621)
          {
            if (v739)
            {
              v626 = &v66[v743];
              BOOL v627 = (unint64_t)v626 >= v739;
              if ((unint64_t)v626 >= v739) {
                uint64_t v628 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v628 = 0;
              }
              float v50 = &v626[v628];
              unint64_t v629 = v59 + 2 * v628;
              if (v627) {
                uint64_t v630 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v630 = 0;
              }
              float v56 = &v57[2 * v741 + 2 * v630];
              unint64_t v59 = v629 + 2 * v743;
              uint64_t v66 = v50;
              float v57 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            if (!--v620) {
              goto LABEL_1236;
            }
            goto LABEL_1110;
          }
        }
        LOWORD(v623) = 0;
        goto LABEL_1115;
      case 9:
        uint64_t v302 = (int)v37;
        int v303 = v763[0];
        float v57 = v749;
        do
        {
          int v304 = v10;
          do
          {
            int v305 = *(unsigned __int16 *)v56;
            int v306 = *(unsigned __int16 *)v55 ^ 0xFFFF;
            unsigned int v307 = (unsigned __int16)*v50 * v306 + (unsigned __int16)*v65 * v305;
            _WORD *v65 = (v307 + HIWORD(v307) + 1) >> 16;
            *(_WORD *)uint64_t v55 = ((v305 + v306) * v305 + (((v305 + v306) * v305) >> 16) + 1) >> 16;
            int v308 = &v50[v721];
            if ((unint64_t)v308 >= v59) {
              uint64_t v309 = -(uint64_t)v723;
            }
            else {
              uint64_t v309 = 0;
            }
            float v50 = &v308[v309];
            v56 += 2 * v302 + 2 * v309;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v304;
          }
          while (v304);
          if (v739)
          {
            unsigned int v310 = &v66[v743];
            BOOL v311 = (unint64_t)v310 >= v739;
            if ((unint64_t)v310 >= v739) {
              uint64_t v312 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v312 = 0;
            }
            float v50 = &v310[v312];
            unint64_t v313 = v59 + 2 * v312;
            if (v311) {
              uint64_t v314 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v314 = 0;
            }
            float v56 = &v57[2 * v741 + 2 * v314];
            unint64_t v59 = v313 + 2 * v743;
            uint64_t v66 = v50;
            float v57 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v303;
        }
        while (v303);
        goto LABEL_1236;
      case 10:
        uint64_t v315 = (int)v37;
        int v316 = v763[0];
        float v57 = v749;
        do
        {
          int v317 = v10;
          do
          {
            int v318 = *(unsigned __int16 *)v56;
            int v319 = *(unsigned __int16 *)v55 ^ 0xFFFF;
            unsigned int v320 = (unsigned __int16)*v50 * v319 + (unsigned __int16)*v65 * (v318 ^ 0xFFFF);
            _WORD *v65 = (v320 + HIWORD(v320) + 1) >> 16;
            *(_WORD *)uint64_t v55 = (((v318 ^ 0xFFFF) + v319) * v318 + ((((v318 ^ 0xFFFFu) + v319) * v318) >> 16) + 1) >> 16;
            unint64_t v321 = &v50[v721];
            if ((unint64_t)v321 >= v59) {
              uint64_t v322 = -(uint64_t)v723;
            }
            else {
              uint64_t v322 = 0;
            }
            float v50 = &v321[v322];
            v56 += 2 * v315 + 2 * v322;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v317;
          }
          while (v317);
          if (v739)
          {
            int v323 = &v66[v743];
            BOOL v324 = (unint64_t)v323 >= v739;
            if ((unint64_t)v323 >= v739) {
              uint64_t v325 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v325 = 0;
            }
            float v50 = &v323[v325];
            unint64_t v326 = v59 + 2 * v325;
            if (v324) {
              uint64_t v327 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v327 = 0;
            }
            float v56 = &v57[2 * v741 + 2 * v327];
            unint64_t v59 = v326 + 2 * v743;
            uint64_t v66 = v50;
            float v57 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v316;
        }
        while (v316);
        goto LABEL_1236;
      case 11:
        if (v24)
        {
          int v328 = v763[0];
          do
          {
            int v329 = v10;
            do
            {
              if (v37) {
                int v330 = *(unsigned __int16 *)v56;
              }
              else {
                int v330 = 0xFFFF;
              }
              int v331 = *(unsigned __int16 *)v55;
              int v332 = v331 - ((unsigned __int16)*v65 + (unsigned __int16)*v50) + v330;
              unsigned int v333 = v330 + v331;
              if (v332 >= 0xFFFF) {
                LOWORD(v332) = -1;
              }
              if (v333 >= 0xFFFF) {
                LOWORD(v333) = -1;
              }
              _WORD *v65 = v333 - v332;
              *(_WORD *)uint64_t v55 = v333;
              unsigned int v334 = &v50[v721];
              if ((unint64_t)v334 >= v59) {
                uint64_t v335 = -(uint64_t)v723;
              }
              else {
                uint64_t v335 = 0;
              }
              float v50 = &v334[v335];
              v56 += 2 * (int)v37 + 2 * v335;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v329;
            }
            while (v329);
            if (v739)
            {
              int v336 = &v66[v743];
              BOOL v337 = (unint64_t)v336 >= v739;
              if ((unint64_t)v336 >= v739) {
                uint64_t v338 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v338 = 0;
              }
              float v50 = &v336[v338];
              unint64_t v339 = v59 + 2 * v338;
              if (v337) {
                uint64_t v340 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v340 = 0;
              }
              float v56 = &v749[2 * v741 + 2 * v340];
              unint64_t v59 = v339 + 2 * v743;
              uint64_t v66 = v50;
              v749 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v328;
          }
          while (v328);
        }
        else
        {
          int v631 = v763[0];
          do
          {
            int v632 = v10;
            do
            {
              if (v37) {
                int v633 = *(unsigned __int16 *)v56;
              }
              else {
                int v633 = 0xFFFF;
              }
              int v634 = v633 - (unsigned __int16)*v50 + ((unsigned __int16)*v65 ^ 0xFFFF);
              if (v634 >= 0xFFFF) {
                LOWORD(v634) = -1;
              }
              _WORD *v65 = ~(_WORD)v634;
              v635 = &v50[v721];
              if ((unint64_t)v635 >= v59) {
                uint64_t v636 = -(uint64_t)v723;
              }
              else {
                uint64_t v636 = 0;
              }
              float v50 = &v635[v636];
              v56 += 2 * (int)v37 + 2 * v636;
              v65 += v721;
              --v632;
            }
            while (v632);
            if (v739)
            {
              v637 = &v66[v743];
              BOOL v638 = (unint64_t)v637 >= v739;
              if ((unint64_t)v637 >= v739) {
                uint64_t v639 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v639 = 0;
              }
              float v50 = &v637[v639];
              unint64_t v640 = v59 + 2 * v639;
              if (v638) {
                uint64_t v641 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v641 = 0;
              }
              float v56 = &v749[2 * v741 + 2 * v641];
              unint64_t v59 = v640 + 2 * v743;
              uint64_t v66 = v50;
              v749 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v631;
          }
          while (v631);
        }
        goto LABEL_1152;
      case 12:
        if (v24)
        {
          int v341 = v763[0];
          do
          {
            int v342 = v10;
            do
            {
              if (v37) {
                int v343 = *(unsigned __int16 *)v56;
              }
              else {
                int v343 = 0xFFFF;
              }
              unsigned int v344 = (unsigned __int16)*v50 + (unsigned __int16)*v65;
              unsigned int v345 = v343 + *(unsigned __int16 *)v55;
              if (v344 >= 0xFFFF) {
                LOWORD(v344) = -1;
              }
              if (v345 >= 0xFFFF) {
                LOWORD(v345) = -1;
              }
              _WORD *v65 = v344;
              *(_WORD *)uint64_t v55 = v345;
              int v346 = &v50[v721];
              if ((unint64_t)v346 >= v59) {
                uint64_t v347 = -(uint64_t)v723;
              }
              else {
                uint64_t v347 = 0;
              }
              float v50 = &v346[v347];
              v56 += 2 * (int)v37 + 2 * v347;
              v65 += v721;
              v55 += 2 * (int)v24;
              --v342;
            }
            while (v342);
            if (v739)
            {
              int v348 = &v66[v743];
              BOOL v349 = (unint64_t)v348 >= v739;
              if ((unint64_t)v348 >= v739) {
                uint64_t v350 = -(uint64_t)(v743 * v722);
              }
              else {
                uint64_t v350 = 0;
              }
              float v50 = &v348[v350];
              unint64_t v351 = v59 + 2 * v350;
              if (v349) {
                uint64_t v352 = -(uint64_t)(v741 * v722);
              }
              else {
                uint64_t v352 = 0;
              }
              float v56 = &v749[2 * v741 + 2 * v352];
              unint64_t v59 = v351 + 2 * v743;
              uint64_t v66 = v50;
              v749 = v56;
            }
            else
            {
              v50 += v743;
              v56 += 2 * v741;
            }
            v65 += *(void *)v751;
            v55 += 2 * v754;
            --v341;
          }
          while (v341);
          goto LABEL_1152;
        }
        uint64_t v642 = (int)v37;
        int v643 = v763[0];
        float v57 = v749;
        do
        {
          int v644 = v10;
          do
          {
            _WORD *v65 = (2 * *v65) | ((__int16)*v65 >> 15);
            v645 = &v50[v721];
            if ((unint64_t)v645 >= v59) {
              uint64_t v646 = -(uint64_t)v723;
            }
            else {
              uint64_t v646 = 0;
            }
            float v50 = &v645[v646];
            v56 += 2 * v642 + 2 * v646;
            v65 += v721;
            --v644;
          }
          while (v644);
          if (v739)
          {
            v647 = &v66[v743];
            BOOL v648 = (unint64_t)v647 >= v739;
            if ((unint64_t)v647 >= v739) {
              uint64_t v649 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v649 = 0;
            }
            float v50 = &v647[v649];
            unint64_t v650 = v59 + 2 * v649;
            if (v648) {
              uint64_t v651 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v651 = 0;
            }
            float v56 = &v57[2 * v741 + 2 * v651];
            unint64_t v59 = v650 + 2 * v743;
            uint64_t v66 = v50;
            float v57 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          --v643;
        }
        while (v643);
        goto LABEL_1236;
      case 13:
        int v353 = v763[0];
        while (1)
        {
          int v354 = v10;
          do
          {
            if (v37)
            {
              unsigned int v355 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_678;
              }
              if (!v24)
              {
LABEL_668:
                unsigned int v356 = 0xFFFF;
                goto LABEL_669;
              }
            }
            else
            {
              unsigned int v355 = 0xFFFF;
              if (!v24) {
                goto LABEL_668;
              }
            }
            unsigned int v356 = *(unsigned __int16 *)v55;
            if (!*(_WORD *)v55)
            {
              _WORD *v65 = *v50;
              *(_WORD *)uint64_t v55 = v355;
              goto LABEL_678;
            }
LABEL_669:
            unint64_t v357 = (v356 ^ 0xFFFF) * (unint64_t)(unsigned __int16)*v50
                 + ((v355 ^ 0xFFFF) + (unsigned __int16)*v50) * (unint64_t)(unsigned __int16)*v65;
            if (v357 <= 0xFFFE8000) {
              unint64_t v358 = v357 + 0x8000;
            }
            else {
              unint64_t v358 = 4294868992;
            }
            unint64_t v359 = (v358 + (v358 >> 16)) >> 16;
            if (v24)
            {
              int64_t v360 = 0xFFFF * (v356 + (unint64_t)v355) - v356 * (unint64_t)v355;
              if (v360 <= 4294868992) {
                unint64_t v361 = v360 + 0x8000;
              }
              else {
                unint64_t v361 = 4294868992;
              }
              _WORD *v65 = v359;
              *(_WORD *)uint64_t v55 = (v359 | ((v361 >> 16) + v361)) >> 16;
            }
            else
            {
              _WORD *v65 = v359;
            }
LABEL_678:
            v362 = &v50[v721];
            if ((unint64_t)v362 >= v59) {
              uint64_t v363 = -(uint64_t)v723;
            }
            else {
              uint64_t v363 = 0;
            }
            float v50 = &v362[v363];
            v56 += 2 * (int)v37 + 2 * v363;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v354;
          }
          while (v354);
          if (v739)
          {
            unsigned int v364 = &v66[v743];
            BOOL v365 = (unint64_t)v364 >= v739;
            if ((unint64_t)v364 >= v739) {
              uint64_t v366 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v366 = 0;
            }
            float v50 = &v364[v366];
            unint64_t v367 = v59 + 2 * v366;
            if (v365) {
              uint64_t v368 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v368 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v368];
            unint64_t v59 = v367 + 2 * v743;
            uint64_t v66 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          if (!--v353) {
            goto LABEL_1152;
          }
        }
      case 14:
        int v369 = v763[0];
        while (1)
        {
          int v370 = v10;
          do
          {
            if (v37)
            {
              unsigned int v371 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_711;
              }
              if (!v24)
              {
LABEL_701:
                unsigned int v372 = 0xFFFF;
                goto LABEL_702;
              }
            }
            else
            {
              unsigned int v371 = 0xFFFF;
              if (!v24) {
                goto LABEL_701;
              }
            }
            unsigned int v372 = *(unsigned __int16 *)v55;
            if (!*(_WORD *)v55)
            {
              _WORD *v65 = *v50;
              *(_WORD *)uint64_t v55 = v371;
              goto LABEL_711;
            }
LABEL_702:
            unint64_t v373 = ((unsigned __int16)*v65 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)*v50
                 - (unsigned __int16)*v65
                 + ((unint64_t)(unsigned __int16)*v65 << 16);
            if (v373 <= 0xFFFE8000) {
              unint64_t v374 = v373 + 0x8000;
            }
            else {
              unint64_t v374 = 4294868992;
            }
            unint64_t v375 = (v374 + (v374 >> 16)) >> 16;
            if (v24)
            {
              int64_t v376 = 0xFFFF * (v372 + (unint64_t)v371) - v372 * (unint64_t)v371;
              if (v376 <= 4294868992) {
                unint64_t v377 = v376 + 0x8000;
              }
              else {
                unint64_t v377 = 4294868992;
              }
              _WORD *v65 = v375;
              *(_WORD *)uint64_t v55 = (v375 | ((v377 >> 16) + v377)) >> 16;
            }
            else
            {
              _WORD *v65 = v375;
            }
LABEL_711:
            int v378 = &v50[v721];
            if ((unint64_t)v378 >= v59) {
              uint64_t v379 = -(uint64_t)v723;
            }
            else {
              uint64_t v379 = 0;
            }
            float v50 = &v378[v379];
            v56 += 2 * (int)v37 + 2 * v379;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v370;
          }
          while (v370);
          if (v739)
          {
            unsigned int v380 = &v66[v743];
            BOOL v381 = (unint64_t)v380 >= v739;
            if ((unint64_t)v380 >= v739) {
              uint64_t v382 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v382 = 0;
            }
            float v50 = &v380[v382];
            unint64_t v383 = v59 + 2 * v382;
            if (v381) {
              uint64_t v384 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v384 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v384];
            unint64_t v59 = v383 + 2 * v743;
            uint64_t v66 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          if (!--v369) {
            goto LABEL_1152;
          }
        }
      case 15:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v385 = (int)v37;
        int v386 = v763[0];
        uint64_t v387 = 2 * (int)v24;
        while (1)
        {
          int v726 = v386;
          int v388 = v10;
          unint64_t v389 = v59;
          do
          {
            if (v37)
            {
              unsigned int v390 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_736;
              }
              if (v24) {
                goto LABEL_731;
              }
            }
            else
            {
              unsigned int v390 = 0xFFFF;
              if (v24)
              {
LABEL_731:
                if (*(_WORD *)v55)
                {
                  int v391 = PDAoverlayPDA_8925((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v390);
                  unint64_t v59 = v389;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v391;
                  *(_WORD *)uint64_t v55 = HIWORD(v391);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v390;
                }
                goto LABEL_736;
              }
            }
            __int16 v392 = PDAoverlayPDA_8925((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v390);
            unint64_t v59 = v389;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v392;
LABEL_736:
            unsigned int v393 = &v50[v721];
            if ((unint64_t)v393 >= v59) {
              uint64_t v394 = -(uint64_t)v723;
            }
            else {
              uint64_t v394 = 0;
            }
            float v50 = &v393[v394];
            v56 += 2 * v385 + 2 * v394;
            v65 += v721;
            v55 += v387;
            --v388;
          }
          while (v388);
          if (v739)
          {
            unsigned int v395 = &v738[v743];
            BOOL v396 = (unint64_t)v395 >= v739;
            uint64_t v397 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v395 < v739) {
              uint64_t v397 = 0;
            }
            float v50 = &v395[v397];
            unint64_t v398 = v59 + 2 * v397;
            uint64_t v399 = -(uint64_t)(v741 * v722);
            if (!v396) {
              uint64_t v399 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v399];
            unint64_t v59 = v398 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v386 = v726 - 1;
          if (v726 == 1)
          {
LABEL_1042:
            uint64_t v19 = v59;
            v763[0] = 0;
            int v7 = v717;
LABEL_1043:
            float v5 = v714;
LABEL_1044:
            unint64_t v23 = v715;
LABEL_1153:
            uint64_t v54 = v724;
LABEL_1154:
            float v57 = v749;
            if (!v54) {
              return 1;
            }
LABEL_1237:
            uint64_t v762 = 0;
LABEL_1238:
            v749 = v57;
            if (!shape_enum_clip_next(v54, (int *)&v762 + 1, &v762, v773, v763))
            {
              float v49 = (void *)v54;
LABEL_1262:
              free(v49);
              return 1;
            }
            uint64_t v724 = v54;
            if (v739)
            {
              unint64_t v22 = v725;
              char v65 = (_WORD *)(v719 + 2 * v725 * (int)v762 + 2 * SHIDWORD(v762));
              int v686 = ((int)v762 + *(_DWORD *)(v713 + 60)) % v722;
              unint64_t v58 = v773[0];
              int v687 = (HIDWORD(v762) + *(_DWORD *)(v713 + 56)) % v723;
              unint64_t v688 = v718 + 2 * v743 * v686;
              float v50 = (_WORD *)(v688 + 2 * v687);
              unint64_t v59 = v688 + 2 * v723;
              uint64_t v24 = v761;
              unint64_t v689 = v754;
              if (v761) {
                unint64_t v689 = v23 - v773[0];
              }
              unint64_t v754 = v689;
              if (v761) {
                uint64_t v55 = &v720[2 * v23 * (int)v762 + 2 * SHIDWORD(v762)];
              }
              if (v758) {
                uint64_t v37 = v758;
              }
              else {
                uint64_t v37 = 0;
              }
              if (v758) {
                float v56 = &v5[2 * v741 * v686 + 2 * v687];
              }
              uint64_t v690 = (uint64_t)v749;
              if (v758) {
                uint64_t v690 = (uint64_t)&v5[2 * v741 * v686 + 2 * v687];
              }
              v749 = (char *)v690;
              LODWORD(v10) = v773[0];
              uint64_t v66 = v50;
              int v711 = (HIDWORD(v762) + *(_DWORD *)(v713 + 56)) % v723;
              int v712 = ((int)v762 + *(_DWORD *)(v713 + 60)) % v722;
            }
            else
            {
              unint64_t v739 = 0;
              int v691 = HIDWORD(v762) * v721;
              LODWORD(v10) = v773[0];
              int v692 = v773[0] * v721;
              unint64_t v22 = v725;
              char v65 = (_WORD *)(v719 + 2 * v725 * (int)v762 + 2 * HIDWORD(v762) * v721);
              unint64_t v58 = v773[0] * v721;
              float v50 = (_WORD *)(v718 + 2 * (int)v762 * v723 + 2 * HIDWORD(v762) * v721);
              unint64_t v743 = v723 - v773[0] * v721;
              uint64_t v37 = v758;
              uint64_t v24 = v761;
              unint64_t v693 = v754;
              if (v761) {
                unint64_t v693 = v23 - v692;
              }
              unint64_t v754 = v693;
              if (v761) {
                uint64_t v55 = &v720[2 * v23 * (int)v762 + 2 * v691];
              }
              uint64_t v694 = (uint64_t)&v5[2 * (int)v762 * v722 + 2 * v691];
              unint64_t v695 = v722 - v692;
              unint64_t v696 = v741;
              if (v758) {
                unint64_t v696 = v695;
              }
              unint64_t v741 = v696;
              if (v758) {
                float v56 = (char *)v694;
              }
              unint64_t v59 = v19;
              uint64_t v66 = v738;
            }
            goto LABEL_400;
          }
        }
      case 16:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v400 = (int)v37;
        int v401 = v763[0];
        uint64_t v402 = 2 * (int)v24;
        while (1)
        {
          int v727 = v401;
          int v403 = v10;
          unint64_t v404 = v59;
          do
          {
            if (v37)
            {
              unsigned int v405 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_759;
              }
              if (v24) {
                goto LABEL_754;
              }
            }
            else
            {
              unsigned int v405 = 0xFFFF;
              if (v24)
              {
LABEL_754:
                if (*(_WORD *)v55)
                {
                  int v406 = PDAdarkenPDA_8927((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v405);
                  unint64_t v59 = v404;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v406;
                  *(_WORD *)uint64_t v55 = HIWORD(v406);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v405;
                }
                goto LABEL_759;
              }
            }
            __int16 v407 = PDAdarkenPDA_8927((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v405);
            unint64_t v59 = v404;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v407;
LABEL_759:
            int v408 = &v50[v721];
            if ((unint64_t)v408 >= v59) {
              uint64_t v409 = -(uint64_t)v723;
            }
            else {
              uint64_t v409 = 0;
            }
            float v50 = &v408[v409];
            v56 += 2 * v400 + 2 * v409;
            v65 += v721;
            v55 += v402;
            --v403;
          }
          while (v403);
          if (v739)
          {
            unsigned int v410 = &v738[v743];
            BOOL v411 = (unint64_t)v410 >= v739;
            uint64_t v412 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v410 < v739) {
              uint64_t v412 = 0;
            }
            float v50 = &v410[v412];
            unint64_t v413 = v59 + 2 * v412;
            uint64_t v414 = -(uint64_t)(v741 * v722);
            if (!v411) {
              uint64_t v414 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v414];
            unint64_t v59 = v413 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v401 = v727 - 1;
          if (v727 == 1) {
            goto LABEL_1042;
          }
        }
      case 17:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v415 = (int)v37;
        int v416 = v763[0];
        uint64_t v417 = 2 * (int)v24;
        while (1)
        {
          int v728 = v416;
          int v418 = v10;
          unint64_t v419 = v59;
          do
          {
            if (v37)
            {
              unsigned int v420 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_782;
              }
              if (v24) {
                goto LABEL_777;
              }
            }
            else
            {
              unsigned int v420 = 0xFFFF;
              if (v24)
              {
LABEL_777:
                if (*(_WORD *)v55)
                {
                  int v421 = PDAlightenPDA_8926((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v420);
                  unint64_t v59 = v419;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v421;
                  *(_WORD *)uint64_t v55 = HIWORD(v421);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v420;
                }
                goto LABEL_782;
              }
            }
            __int16 v422 = PDAlightenPDA_8926((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v420);
            unint64_t v59 = v419;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v422;
LABEL_782:
            uint64_t v423 = &v50[v721];
            if ((unint64_t)v423 >= v59) {
              uint64_t v424 = -(uint64_t)v723;
            }
            else {
              uint64_t v424 = 0;
            }
            float v50 = &v423[v424];
            v56 += 2 * v415 + 2 * v424;
            v65 += v721;
            v55 += v417;
            --v418;
          }
          while (v418);
          if (v739)
          {
            uint64_t v425 = &v738[v743];
            BOOL v426 = (unint64_t)v425 >= v739;
            uint64_t v427 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v425 < v739) {
              uint64_t v427 = 0;
            }
            float v50 = &v425[v427];
            unint64_t v428 = v59 + 2 * v427;
            uint64_t v429 = -(uint64_t)(v741 * v722);
            if (!v426) {
              uint64_t v429 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v429];
            unint64_t v59 = v428 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v416 = v728 - 1;
          if (v728 == 1) {
            goto LABEL_1042;
          }
        }
      case 18:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v430 = (int)v37;
        int v431 = v763[0];
        uint64_t v432 = 2 * (int)v24;
        while (1)
        {
          int v729 = v431;
          int v433 = v10;
          unint64_t v434 = v59;
          do
          {
            if (v37)
            {
              unsigned int v435 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_805;
              }
              if (v24) {
                goto LABEL_800;
              }
            }
            else
            {
              unsigned int v435 = 0xFFFF;
              if (v24)
              {
LABEL_800:
                if (*(_WORD *)v55)
                {
                  int v436 = PDAcolordodgePDA_8928((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v435);
                  unint64_t v59 = v434;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v436;
                  *(_WORD *)uint64_t v55 = HIWORD(v436);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v435;
                }
                goto LABEL_805;
              }
            }
            __int16 v437 = PDAcolordodgePDA_8928((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v435);
            unint64_t v59 = v434;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v437;
LABEL_805:
            double v438 = &v50[v721];
            if ((unint64_t)v438 >= v59) {
              uint64_t v439 = -(uint64_t)v723;
            }
            else {
              uint64_t v439 = 0;
            }
            float v50 = &v438[v439];
            v56 += 2 * v430 + 2 * v439;
            v65 += v721;
            v55 += v432;
            --v433;
          }
          while (v433);
          if (v739)
          {
            unint64_t v440 = &v738[v743];
            BOOL v441 = (unint64_t)v440 >= v739;
            uint64_t v442 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v440 < v739) {
              uint64_t v442 = 0;
            }
            float v50 = &v440[v442];
            unint64_t v443 = v59 + 2 * v442;
            uint64_t v444 = -(uint64_t)(v741 * v722);
            if (!v441) {
              uint64_t v444 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v444];
            unint64_t v59 = v443 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v431 = v729 - 1;
          if (v729 == 1) {
            goto LABEL_1042;
          }
        }
      case 19:
        v738 = v66;
        unint64_t v716 = v23;
        uint64_t v445 = (int)v37;
        int v446 = v763[0];
        uint64_t v447 = 2 * (int)v24;
        while (1)
        {
          int v730 = v446;
          int v448 = v10;
          unint64_t v449 = v59;
          do
          {
            if (v37)
            {
              unsigned int v450 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_828;
              }
              if (v24) {
                goto LABEL_823;
              }
            }
            else
            {
              unsigned int v450 = 0xFFFF;
              if (v24)
              {
LABEL_823:
                if (*(_WORD *)v55)
                {
                  int v451 = PDAcolorburnPDA_8929((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v450);
                  unint64_t v59 = v449;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v451;
                  *(_WORD *)uint64_t v55 = HIWORD(v451);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v450;
                }
                goto LABEL_828;
              }
            }
            __int16 v452 = PDAcolorburnPDA_8929((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v450);
            unint64_t v59 = v449;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v452;
LABEL_828:
            v453 = &v50[v721];
            if ((unint64_t)v453 >= v59) {
              uint64_t v454 = -(uint64_t)v723;
            }
            else {
              uint64_t v454 = 0;
            }
            float v50 = &v453[v454];
            v56 += 2 * v445 + 2 * v454;
            v65 += v721;
            v55 += v447;
            --v448;
          }
          while (v448);
          if (v739)
          {
            double v455 = &v738[v743];
            BOOL v456 = (unint64_t)v455 >= v739;
            uint64_t v457 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v455 < v739) {
              uint64_t v457 = 0;
            }
            float v50 = &v455[v457];
            unint64_t v458 = v59 + 2 * v457;
            uint64_t v459 = -(uint64_t)(v741 * v722);
            if (!v456) {
              uint64_t v459 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v459];
            unint64_t v59 = v458 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v446 = v730 - 1;
          if (v730 == 1)
          {
            uint64_t v19 = v59;
            v763[0] = 0;
            unint64_t v23 = v716;
            int v7 = v717;
            goto LABEL_1153;
          }
        }
      case 20:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v460 = (int)v37;
        int v461 = v763[0];
        uint64_t v462 = 2 * (int)v24;
        while (1)
        {
          int v731 = v461;
          int v463 = v10;
          unint64_t v464 = v59;
          do
          {
            if (v37)
            {
              unsigned int v465 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_851;
              }
              if (v24) {
                goto LABEL_846;
              }
            }
            else
            {
              unsigned int v465 = 0xFFFF;
              if (v24)
              {
LABEL_846:
                if (*(_WORD *)v55)
                {
                  int v466 = PDAsoftlightPDA_8931((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v465);
                  unint64_t v59 = v464;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v466;
                  *(_WORD *)uint64_t v55 = HIWORD(v466);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v465;
                }
                goto LABEL_851;
              }
            }
            __int16 v467 = PDAsoftlightPDA_8931((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v465);
            unint64_t v59 = v464;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v467;
LABEL_851:
            __n128 v468 = &v50[v721];
            if ((unint64_t)v468 >= v59) {
              uint64_t v469 = -(uint64_t)v723;
            }
            else {
              uint64_t v469 = 0;
            }
            float v50 = &v468[v469];
            v56 += 2 * v460 + 2 * v469;
            v65 += v721;
            v55 += v462;
            --v463;
          }
          while (v463);
          if (v739)
          {
            v470 = &v738[v743];
            BOOL v471 = (unint64_t)v470 >= v739;
            uint64_t v472 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v470 < v739) {
              uint64_t v472 = 0;
            }
            float v50 = &v470[v472];
            unint64_t v473 = v59 + 2 * v472;
            uint64_t v474 = -(uint64_t)(v741 * v722);
            if (!v471) {
              uint64_t v474 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v474];
            unint64_t v59 = v473 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v461 = v731 - 1;
          if (v731 == 1) {
            goto LABEL_1042;
          }
        }
      case 21:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v475 = (int)v37;
        int v476 = v763[0];
        uint64_t v477 = 2 * (int)v24;
        while (1)
        {
          int v732 = v476;
          int v478 = v10;
          unint64_t v479 = v59;
          do
          {
            if (v37)
            {
              unsigned int v480 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_874;
              }
              if (v24) {
                goto LABEL_869;
              }
            }
            else
            {
              unsigned int v480 = 0xFFFF;
              if (v24)
              {
LABEL_869:
                if (*(_WORD *)v55)
                {
                  int v481 = PDAhardlightPDA_8930((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v480);
                  unint64_t v59 = v479;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v481;
                  *(_WORD *)uint64_t v55 = HIWORD(v481);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v480;
                }
                goto LABEL_874;
              }
            }
            __int16 v482 = PDAhardlightPDA_8930((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v480);
            unint64_t v59 = v479;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v482;
LABEL_874:
            __n128 v483 = &v50[v721];
            if ((unint64_t)v483 >= v59) {
              uint64_t v484 = -(uint64_t)v723;
            }
            else {
              uint64_t v484 = 0;
            }
            float v50 = &v483[v484];
            v56 += 2 * v475 + 2 * v484;
            v65 += v721;
            v55 += v477;
            --v478;
          }
          while (v478);
          if (v739)
          {
            int32x2_t v485 = &v738[v743];
            BOOL v486 = (unint64_t)v485 >= v739;
            uint64_t v487 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v485 < v739) {
              uint64_t v487 = 0;
            }
            float v50 = &v485[v487];
            unint64_t v488 = v59 + 2 * v487;
            uint64_t v489 = -(uint64_t)(v741 * v722);
            if (!v486) {
              uint64_t v489 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v489];
            unint64_t v59 = v488 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v476 = v732 - 1;
          if (v732 == 1) {
            goto LABEL_1042;
          }
        }
      case 22:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v490 = (int)v37;
        int v491 = v763[0];
        uint64_t v492 = 2 * (int)v24;
        while (1)
        {
          int v733 = v491;
          int v493 = v10;
          unint64_t v494 = v59;
          do
          {
            if (v37)
            {
              unsigned int v495 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_897;
              }
              if (v24) {
                goto LABEL_892;
              }
            }
            else
            {
              unsigned int v495 = 0xFFFF;
              if (v24)
              {
LABEL_892:
                if (*(_WORD *)v55)
                {
                  int v496 = PDAdifferencePDA_8932((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v495);
                  unint64_t v59 = v494;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v496;
                  *(_WORD *)uint64_t v55 = HIWORD(v496);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v495;
                }
                goto LABEL_897;
              }
            }
            __int16 v497 = PDAdifferencePDA_8932((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v495);
            unint64_t v59 = v494;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v497;
LABEL_897:
            v498 = &v50[v721];
            if ((unint64_t)v498 >= v59) {
              uint64_t v499 = -(uint64_t)v723;
            }
            else {
              uint64_t v499 = 0;
            }
            float v50 = &v498[v499];
            v56 += 2 * v490 + 2 * v499;
            v65 += v721;
            v55 += v492;
            --v493;
          }
          while (v493);
          if (v739)
          {
            __n128 v500 = &v738[v743];
            BOOL v501 = (unint64_t)v500 >= v739;
            uint64_t v502 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v500 < v739) {
              uint64_t v502 = 0;
            }
            float v50 = &v500[v502];
            unint64_t v503 = v59 + 2 * v502;
            uint64_t v504 = -(uint64_t)(v741 * v722);
            if (!v501) {
              uint64_t v504 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v504];
            unint64_t v59 = v503 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v491 = v733 - 1;
          if (v733 == 1) {
            goto LABEL_1042;
          }
        }
      case 23:
        int v505 = v763[0];
        while (1)
        {
          int v506 = v10;
          do
          {
            if (v37)
            {
              unsigned int v507 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_934;
              }
              if (!v24)
              {
LABEL_918:
                unsigned int v508 = 0xFFFF;
                goto LABEL_919;
              }
            }
            else
            {
              unsigned int v507 = 0xFFFF;
              if (!v24) {
                goto LABEL_918;
              }
            }
            unsigned int v508 = *(unsigned __int16 *)v55;
            if (!*(_WORD *)v55)
            {
              _WORD *v65 = *v50;
              *(_WORD *)uint64_t v55 = v507;
              goto LABEL_934;
            }
LABEL_919:
            if ((unsigned __int16)*v50 >= v507) {
              uint64_t v509 = v507;
            }
            else {
              uint64_t v509 = (unsigned __int16)*v50;
            }
            if ((unsigned __int16)*v65 >= v508) {
              uint64_t v510 = v508;
            }
            else {
              uint64_t v510 = (unsigned __int16)*v65;
            }
            int64_t v511 = 0xFFFF * (v509 + v510) - 2 * v510 * (unint64_t)v509;
            if (v511 <= 4294868992) {
              unint64_t v512 = v511 + 0x8000;
            }
            else {
              unint64_t v512 = 4294868992;
            }
            unint64_t v513 = (v512 + (v512 >> 16)) >> 16;
            if (v24)
            {
              int64_t v514 = 0xFFFF * (v508 + (unint64_t)v507) - v508 * (unint64_t)v507;
              if (v514 <= 4294868992) {
                unint64_t v515 = v514 + 0x8000;
              }
              else {
                unint64_t v515 = 4294868992;
              }
              _WORD *v65 = v513;
              *(_WORD *)uint64_t v55 = (v513 | ((v515 >> 16) + v515)) >> 16;
            }
            else
            {
              _WORD *v65 = v513;
            }
LABEL_934:
            __n128 v516 = &v50[v721];
            if ((unint64_t)v516 >= v59) {
              uint64_t v517 = -(uint64_t)v723;
            }
            else {
              uint64_t v517 = 0;
            }
            float v50 = &v516[v517];
            v56 += 2 * (int)v37 + 2 * v517;
            v65 += v721;
            v55 += 2 * (int)v24;
            --v506;
          }
          while (v506);
          if (v739)
          {
            int32x2_t v518 = &v66[v743];
            BOOL v519 = (unint64_t)v518 >= v739;
            if ((unint64_t)v518 >= v739) {
              uint64_t v520 = -(uint64_t)(v743 * v722);
            }
            else {
              uint64_t v520 = 0;
            }
            float v50 = &v518[v520];
            unint64_t v521 = v59 + 2 * v520;
            if (v519) {
              uint64_t v522 = -(uint64_t)(v741 * v722);
            }
            else {
              uint64_t v522 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v522];
            unint64_t v59 = v521 + 2 * v743;
            uint64_t v66 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          if (!--v505)
          {
LABEL_1152:
            v738 = v66;
            uint64_t v19 = v59;
            v763[0] = 0;
            goto LABEL_1153;
          }
        }
      case 24:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v523 = (int)v37;
        int v524 = v763[0];
        uint64_t v525 = 2 * (int)v24;
        while (1)
        {
          int v734 = v524;
          int v526 = v10;
          unint64_t v527 = v59;
          do
          {
            if (v37)
            {
              unsigned int v528 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_959;
              }
              if (v24) {
                goto LABEL_954;
              }
            }
            else
            {
              unsigned int v528 = 0xFFFF;
              if (v24)
              {
LABEL_954:
                if (*(_WORD *)v55)
                {
                  int v529 = PDAhuePDA_8933((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v528);
                  unint64_t v59 = v527;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v529;
                  *(_WORD *)uint64_t v55 = HIWORD(v529);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v528;
                }
                goto LABEL_959;
              }
            }
            __int16 v530 = PDAhuePDA_8933((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v528);
            unint64_t v59 = v527;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v530;
LABEL_959:
            v531 = &v50[v721];
            if ((unint64_t)v531 >= v59) {
              uint64_t v532 = -(uint64_t)v723;
            }
            else {
              uint64_t v532 = 0;
            }
            float v50 = &v531[v532];
            v56 += 2 * v523 + 2 * v532;
            v65 += v721;
            v55 += v525;
            --v526;
          }
          while (v526);
          if (v739)
          {
            __n128 v533 = &v738[v743];
            BOOL v534 = (unint64_t)v533 >= v739;
            uint64_t v535 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v533 < v739) {
              uint64_t v535 = 0;
            }
            float v50 = &v533[v535];
            unint64_t v536 = v59 + 2 * v535;
            uint64_t v537 = -(uint64_t)(v741 * v722);
            if (!v534) {
              uint64_t v537 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v537];
            unint64_t v59 = v536 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v524 = v734 - 1;
          if (v734 == 1) {
            goto LABEL_1042;
          }
        }
      case 25:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v538 = (int)v37;
        int v539 = v763[0];
        uint64_t v540 = 2 * (int)v24;
        while (1)
        {
          int v735 = v539;
          int v541 = v10;
          unint64_t v542 = v59;
          do
          {
            if (v37)
            {
              unsigned int v543 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_982;
              }
              if (v24) {
                goto LABEL_977;
              }
            }
            else
            {
              unsigned int v543 = 0xFFFF;
              if (v24)
              {
LABEL_977:
                if (*(_WORD *)v55)
                {
                  int v544 = PDAhuePDA_8933((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v543);
                  unint64_t v59 = v542;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v544;
                  *(_WORD *)uint64_t v55 = HIWORD(v544);
                }
                else
                {
                  _WORD *v65 = *v50;
                  *(_WORD *)uint64_t v55 = v543;
                }
                goto LABEL_982;
              }
            }
            __int16 v545 = PDAhuePDA_8933((unsigned __int16)*v65, 0xFFFFu, (unsigned __int16)*v50, v543);
            unint64_t v59 = v542;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v545;
LABEL_982:
            float v546 = &v50[v721];
            if ((unint64_t)v546 >= v59) {
              uint64_t v547 = -(uint64_t)v723;
            }
            else {
              uint64_t v547 = 0;
            }
            float v50 = &v546[v547];
            v56 += 2 * v538 + 2 * v547;
            v65 += v721;
            v55 += v540;
            --v541;
          }
          while (v541);
          if (v739)
          {
            v548 = &v738[v743];
            BOOL v549 = (unint64_t)v548 >= v739;
            uint64_t v550 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v548 < v739) {
              uint64_t v550 = 0;
            }
            float v50 = &v548[v550];
            unint64_t v551 = v59 + 2 * v550;
            uint64_t v552 = -(uint64_t)(v741 * v722);
            if (!v549) {
              uint64_t v552 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v552];
            unint64_t v59 = v551 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v539 = v735 - 1;
          if (v735 == 1) {
            goto LABEL_1042;
          }
        }
      case 26:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        uint64_t v553 = (int)v37;
        int v554 = v763[0];
        uint64_t v555 = 2 * (int)v24;
        while (1)
        {
          int v736 = v554;
          int v556 = v10;
          unint64_t v557 = v59;
          do
          {
            if (v37)
            {
              unsigned int v558 = *(unsigned __int16 *)v56;
              if (!*(_WORD *)v56) {
                goto LABEL_1005;
              }
              if (v24) {
                goto LABEL_1000;
              }
            }
            else
            {
              unsigned int v558 = 0xFFFF;
              if (v24)
              {
LABEL_1000:
                unsigned int v559 = (unsigned __int16)*v50;
                if (*(_WORD *)v55)
                {
                  int v560 = PDAluminosityPDA_8935(v559, v558, (unsigned __int16)*v65, *(unsigned __int16 *)v55);
                  unint64_t v59 = v557;
                  LODWORD(v37) = v758;
                  LODWORD(v24) = v761;
                  _WORD *v65 = v560;
                  *(_WORD *)uint64_t v55 = HIWORD(v560);
                }
                else
                {
                  _WORD *v65 = v559;
                  *(_WORD *)uint64_t v55 = v558;
                }
                goto LABEL_1005;
              }
            }
            __int16 v561 = PDAluminosityPDA_8935((unsigned __int16)*v50, v558, (unsigned __int16)*v65, 0xFFFFu);
            unint64_t v59 = v557;
            LODWORD(v37) = v758;
            LODWORD(v24) = v761;
            _WORD *v65 = v561;
LABEL_1005:
            v562 = &v50[v721];
            if ((unint64_t)v562 >= v59) {
              uint64_t v563 = -(uint64_t)v723;
            }
            else {
              uint64_t v563 = 0;
            }
            float v50 = &v562[v563];
            v56 += 2 * v553 + 2 * v563;
            v65 += v721;
            v55 += v555;
            --v556;
          }
          while (v556);
          if (v739)
          {
            v564 = &v738[v743];
            BOOL v565 = (unint64_t)v564 >= v739;
            uint64_t v566 = -(uint64_t)(v743 * v722);
            if ((unint64_t)v564 < v739) {
              uint64_t v566 = 0;
            }
            float v50 = &v564[v566];
            unint64_t v567 = v59 + 2 * v566;
            uint64_t v568 = -(uint64_t)(v741 * v722);
            if (!v565) {
              uint64_t v568 = 0;
            }
            float v56 = &v749[2 * v741 + 2 * v568];
            unint64_t v59 = v567 + 2 * v743;
            v738 = v50;
            v749 = v56;
          }
          else
          {
            v50 += v743;
            v56 += 2 * v741;
          }
          v65 += *(void *)v751;
          v55 += 2 * v754;
          int v554 = v736 - 1;
          if (v736 == 1) {
            goto LABEL_1042;
          }
        }
      case 27:
        v738 = v66;
        uint64_t v714 = v5;
        unint64_t v715 = v23;
        int v747 = v10;
        uint64_t v569 = (int)v37;
        int v570 = v763[0];
        uint64_t v571 = 2 * (int)v24;
        uint64_t v572 = -(uint64_t)v723;
        break;
      default:
        v738 = v66;
        uint64_t v19 = v59;
        goto LABEL_1153;
    }
LABEL_1019:
    int v737 = v570;
    int v573 = v747;
    while (1)
    {
      if (v37)
      {
        unsigned int v574 = *(unsigned __int16 *)v56;
        if (!*(_WORD *)v56) {
          goto LABEL_1030;
        }
        if (!v24) {
          goto LABEL_1026;
        }
      }
      else
      {
        unsigned int v574 = 0xFFFF;
        if (!v24)
        {
LABEL_1026:
          unsigned int v578 = (unsigned __int16)*v50;
          if (v578 >= v574) {
            LOWORD(v578) = v574;
          }
          unint64_t v579 = (unsigned __int16)*v65 * (unint64_t)(unsigned __int16)~(_WORD)v574 + 0x8000;
          _WORD *v65 = v578 + (((v579 >> 16) + v579) >> 16);
          goto LABEL_1030;
        }
      }
      if (*(_WORD *)v55)
      {
        unint64_t v575 = v59;
        *(void *)v756 = v56;
        uint64_t v576 = v572;
        int v577 = PDAluminosityPDA_8935((unsigned __int16)*v65, *(unsigned __int16 *)v55, (unsigned __int16)*v50, v574);
        uint64_t v572 = v576;
        float v56 = *(char **)v756;
        LODWORD(v37) = v758;
        unint64_t v59 = v575;
        LODWORD(v24) = v761;
        _WORD *v65 = v577;
        *(_WORD *)uint64_t v55 = HIWORD(v577);
      }
      else
      {
        _WORD *v65 = *v50;
        *(_WORD *)uint64_t v55 = v574;
      }
LABEL_1030:
      __n128 v580 = &v50[v721];
      if ((unint64_t)v580 >= v59) {
        uint64_t v581 = v572;
      }
      else {
        uint64_t v581 = 0;
      }
      float v50 = &v580[v581];
      v56 += 2 * v569 + 2 * v581;
      v65 += v721;
      v55 += v571;
      if (!--v573)
      {
        if (v739)
        {
          int32x2_t v582 = &v738[v743];
          BOOL v583 = (unint64_t)v582 >= v739;
          uint64_t v584 = -(uint64_t)(v743 * v722);
          if ((unint64_t)v582 < v739) {
            uint64_t v584 = 0;
          }
          float v50 = &v582[v584];
          unint64_t v585 = v59 + 2 * v584;
          uint64_t v586 = -(uint64_t)(v741 * v722);
          if (!v583) {
            uint64_t v586 = 0;
          }
          float v56 = &v749[2 * v741 + 2 * v586];
          unint64_t v59 = v585 + 2 * v743;
          v738 = v50;
          v749 = v56;
        }
        else
        {
          v50 += v743;
          v56 += 2 * v741;
        }
        v65 += *(void *)v751;
        v55 += 2 * v754;
        int v570 = v737 - 1;
        if (v737 == 1) {
          goto LABEL_1042;
        }
        goto LABEL_1019;
      }
    }
  }
  int v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      w16_mark_constmask(v3);
    }
    else {
      w16_mark_pixelmask(v3, v7);
    }
  }
  else
  {
    int v25 = *(_DWORD *)(v3 + 112);
    int v26 = *(_DWORD *)(v3 + 116);
    unsigned int v27 = (v25 + 15) & 0xFFFFFFF0;
    size_t v28 = v27 * v26;
    if ((int)v28 <= 4096)
    {
      long long v30 = v773;
    }
    else
    {
      int v29 = malloc_type_malloc(v28, 0x8303D2FuLL);
      if (!v29) {
        return 1;
      }
      long long v30 = v29;
      uint64_t v14 = *(uint16x4_t **)(v9 + 136);
      int v15 = *(_DWORD *)(v9 + 128);
    }
    CGSConvertBitsToMask(v14, *(_DWORD *)(v9 + 124), v30, v27, v25, v26, v15);
    long long v44 = *(_OWORD *)(v9 + 112);
    long long v769 = *(_OWORD *)(v9 + 96);
    long long v770 = v44;
    long long v45 = *(_OWORD *)(v9 + 144);
    long long v771 = *(_OWORD *)(v9 + 128);
    long long v772 = v45;
    long long v46 = *(_OWORD *)(v9 + 48);
    long long v765 = *(_OWORD *)(v9 + 32);
    long long v766 = v46;
    long long v47 = *(_OWORD *)(v9 + 80);
    long long v767 = *(_OWORD *)(v9 + 64);
    long long v768 = v47;
    long long v48 = *(_OWORD *)(v9 + 16);
    *(_OWORD *)v763 = *(_OWORD *)v9;
    long long v764 = v48;
    HIDWORD(v770) = (v25 + 15) & 0xFFFFFFF0;
    *((void *)&v771 + 1) = v30;
    if (BYTE1(v763[0]) << 8 == 1024) {
      w16_mark_constmask((uint64_t)v763);
    }
    else {
      w16_mark_pixelmask((unint64_t)v763, v717);
    }
    if (v30 != (unsigned char *)v773)
    {
      float v49 = v30;
      goto LABEL_1262;
    }
  }
  return 1;
}

void w16_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(void, void))
{
  v79[1] = *MEMORY[0x1E4F143B8];
  v8.n128_u64[1] = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v70 = 0u;
  v8.n128_f64[0] = *(float *)(a2 + 184) * 65535.9;
  v67[0] = a3;
  v67[1] = a4;
  LOWORD(v68) = (int)v8.n128_f64[0];
  unint64_t v9 = (unint64_t)*(int *)(a1 + 28) >> 1;
  *(void *)&long long v69 = v9;
  if (*(void *)(a1 + 48)) {
    unint64_t v10 = (unint64_t)*(int *)(a1 + 32) >> 1;
  }
  else {
    unint64_t v10 = 0;
  }
  *(void *)&long long v70 = v10;
  uint64_t v11 = *(void *)(a2 + 120);
  unsigned int v12 = *(_DWORD *)(a2 + 20);
  unsigned int v13 = HIBYTE(v12);
  unsigned int v14 = BYTE2(v12);
  if (v11)
  {
    unint64_t v15 = *(int *)(a2 + 24);
    int v16 = (uint64_t *)(a2 + 104);
    unsigned int v17 = (uint64_t *)(a2 + 72);
    unsigned int v18 = (uint64_t *)(a2 + 88);
    unsigned int v19 = v13;
  }
  else
  {
    unint64_t v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int v16 = (uint64_t *)(a2 + 96);
    unsigned int v17 = (uint64_t *)(a2 + 64);
    unsigned int v18 = (uint64_t *)(a2 + 80);
    uint64_t v11 = *(void *)(a2 + 112);
    unsigned int v19 = v14;
  }
  uint64_t v20 = *v18;
  uint64_t v21 = *v17;
  uint64_t v22 = *v16;
  char v23 = v19;
  *((void *)&v71 + 1) = v19;
  *((void *)&v70 + 1) = v22;
  *((void *)&v75 + 1) = v15;
  *((void *)&v74 + 1) = v20;
  *((void *)&v73 + 1) = v21;
  *((void *)&v72 + 1) = v11;
  uint64_t v24 = *(void *)(a2 + 128);
  if (v24)
  {
    unint64_t v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int v26 = (uint64_t *)(a2 + 96);
    unsigned int v27 = (uint64_t *)(a2 + 64);
    size_t v28 = (uint64_t *)(a2 + 80);
    unsigned int v13 = v14;
  }
  else
  {
    unint64_t v25 = *(int *)(a2 + 24);
    int v26 = (uint64_t *)(a2 + 104);
    unsigned int v27 = (uint64_t *)(a2 + 72);
    size_t v28 = (uint64_t *)(a2 + 88);
    uint64_t v24 = *(void *)(a2 + 136);
  }
  uint64_t v66 = &v62;
  uint64_t v29 = *v28;
  uint64_t v30 = *v27;
  uint64_t v31 = *v26;
  *(void *)&long long v72 = v13;
  *(void *)&long long v71 = v31;
  *(void *)&long long v76 = v25;
  *(void *)&long long v75 = v29;
  *(void *)&long long v74 = v30;
  *(void *)&long long v73 = v24;
  uint64_t v32 = *(int *)(a1 + 4);
  MEMORY[0x1F4188790](a1, v8);
  char v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL) {
    uint64_t v37 = (char *)&v62 - v34 - 15;
  }
  else {
    uint64_t v37 = 0;
  }
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    uint64_t v63 = v33;
    int v64 = a5;
    uint64_t v38 = v36;
    uint64_t v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    uint64_t v33 = v63;
    uint64_t v36 = v38;
    a5 = v64;
  }
  *((void *)&v76 + 1) = v37;
  if (v37)
  {
    uint64_t v39 = v32;
    if (*(void *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        uint64_t v40 = (uint64_t *)(v37 + 8);
        uint64_t v41 = -v33;
        uint64_t v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            unint64_t v45 = 0;
            uint64_t v46 = 0;
          }
          else
          {
            unint64_t v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            char v44 = weights_21383[v43];
            if (v43 - 7 >= 9) {
              unint64_t v45 = -(uint64_t)v15;
            }
            else {
              unint64_t v45 = v15;
            }
            uint64_t v46 = v44 & 0xF;
          }
          uint64_t v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          uint64_t *v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      long long v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *long long v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    long long v48 = v37;
    int v49 = *(_DWORD *)(a1 + 4);
    int v50 = *(_DWORD *)(a1 + 8);
    int v77 = v50;
    int v78 = v49;
    int v51 = *(int **)(a1 + 136);
    if (v51)
    {
      int v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      uint64_t v54 = v53;
      if (v53) {
        goto LABEL_36;
      }
    }
    int v55 = 0;
    int v56 = 0;
    uint64_t v54 = 0;
    v79[0] = 0;
    while (1)
    {
      uint64_t v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      uint64_t v58 = *(void *)(a1 + 48);
      int v59 = v55 + *(_DWORD *)(a1 + 12);
      uint64_t v60 = *(void *)(a1 + 40) + 2 * v9 * v57 + 2 * v59;
      uint64_t v61 = v58 + 2 * v10 * v57 + 2 * v59;
      if (!v58) {
        uint64_t v61 = 0;
      }
      *((void *)&v68 + 1) = v60;
      *((void *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54) {
        break;
      }
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      int v56 = v79[0];
      int v55 = HIDWORD(v79[0]);
      unint64_t v9 = v69;
      unint64_t v10 = v70;
    }
    if (v48 != v65) {
      free(v48);
    }
  }
}

uint64_t w16_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (_WORD *)*((void *)a2 + 2);
  __n128 v8 = (_WORD *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v120 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v120 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v119 = *a2;
  uint64_t v118 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v117 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v117 * a4;
  unint64_t v15 = *(unsigned int **)(a1 + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v8 != 0);
  if (v17)
  {
    uint64_t v114 = *((void *)a2 + 13);
    uint64_t v112 = ~(-1 << v13);
    uint64_t v113 = *((void *)a2 + 15);
    char v111 = v13 - 4;
    unsigned int v19 = (unsigned int *)(v16 - 4);
    int v20 = v9 ^ 0xFFFF;
    uint64_t v110 = a5;
    uint64_t v109 = v11 + 16 * a3 + 8;
    uint64_t v115 = *((void *)a2 + 9);
    int v116 = a5;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        int v23 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v112) >> v111) & 0xF;
        uint64_t v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v119 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unint64_t v25 = (uint64_t *)v109;
        uint64_t v26 = v110;
        while (1)
        {
          uint64_t v28 = *(v25 - 1);
          uint64_t v27 = *v25;
          uint64_t v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28]) {
            uint64_t v30 = (unsigned int *)&v24[v28];
          }
          else {
            uint64_t v30 = v19;
          }
          if (v30 < v15) {
            uint64_t v30 = v15;
          }
          unsigned int v31 = *v30;
          char v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            unint64_t v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22]) {
              unint64_t v43 = v19;
            }
            if (v43 < v15) {
              unint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (v44 & *v43) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v45 = __ROL4__(v31, v10);
          int v46 = v45 | v6;
          unsigned int v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          int v48 = 32 * v47;
          v47 >>= 6;
          int v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          unsigned int v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v50 = v49;
          }
          *int v7 = v50;
          if (v8) {
            _WORD *v8 = HIWORD(v50);
          }
          v25 += 2;
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          if (!--v26) {
            goto LABEL_96;
          }
        }
        uint64_t v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33) {
          uint64_t v33 = v19;
        }
        if (v33 < v15) {
          uint64_t v33 = v15;
        }
        unsigned int v34 = *v33;
        if (v23)
        {
          unint64_t v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = v19;
          }
          if (v36 < v15) {
            uint64_t v36 = v15;
          }
          unsigned int v37 = *v36;
          uint64_t v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38) {
            uint64_t v38 = v19;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        int v40 = BLEND8_21385[*v25 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_46:
        unsigned int v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v118;
      a5 = v116;
      v14 += v117;
      v8 += v120;
      --a6;
      LOBYTE(v13) = v115;
      if (!a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_96;
    }
    int v52 = (uint64_t *)v109;
    uint64_t v51 = v110;
    while (1)
    {
      uint64_t v54 = *(v52 - 1);
      uint64_t v53 = *v52;
      int v55 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54]) {
        int v56 = (unsigned int *)&v24[v54];
      }
      else {
        int v56 = v19;
      }
      if (v56 < v15) {
        int v56 = v15;
      }
      unsigned int v57 = *v56;
      char v58 = v53 & 0xF;
      if ((v53 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        long long v69 = (unsigned int *)&v55[v22];
        if (v19 < (unsigned int *)&v55[v22]) {
          long long v69 = v19;
        }
        if (v69 < v15) {
          long long v69 = v15;
        }
        int v70 = BLEND8_21385[v23];
        unsigned int v67 = v57 - ((v70 & v57) >> v23);
        unsigned int v68 = (v70 & *v69) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      unsigned int v71 = __ROL4__(v57, v10);
      int v72 = v71 | v6;
      unsigned int v73 = ((v71 >> 23) & 0x1FE) + BYTE1(v71) + (((v71 >> 8) & 0xFF00) >> 6) + (((v71 >> 8) & 0xFF00) >> 8);
      int v74 = 32 * v73;
      v73 >>= 6;
      int v75 = v73 | (v72 << 24) | (v72 << 16) | v74;
      unsigned int v76 = ((v74 | v73) - (((v74 | v73) * v20 + (((v74 | v73) * v20) >> 16) + 1) >> 16)) | (((v72 | (v72 << 8))
                                                                                            - (((v72 | (v72 << 8))
                                                                                              * v20
                                                                                              + (((v72 | (v72 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF) {
        unsigned int v76 = v75;
      }
      unsigned int v77 = HIWORD(v76);
      if (v8)
      {
        if (v77)
        {
          if (v77 == 0xFFFF)
          {
            *int v7 = v76;
            _WORD *v8 = -1;
          }
          else
          {
            int v78 = v77 ^ 0xFFFF;
            unsigned int v79 = v78 * (unsigned __int16)*v7;
            unsigned int v80 = (v78 * (unsigned __int16)*v8 + ((v78 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
            *int v7 = v76 + ((v79 + HIWORD(v79) + 1) >> 16);
            _WORD *v8 = v80 + HIWORD(v76);
          }
        }
      }
      else if (v77)
      {
        if (v77 != 0xFFFF) {
          v76 += ((v77 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v77 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
        }
        *int v7 = v76;
      }
      v52 += 2;
      ++v7;
      __n128 v8 = (_WORD *)((char *)v8 + result);
      if (!--v51) {
        goto LABEL_96;
      }
    }
    int v59 = (unsigned int *)&v55[v53 >> 4];
    if (v19 < v59) {
      int v59 = v19;
    }
    if (v59 < v15) {
      int v59 = v15;
    }
    unsigned int v60 = *v59;
    if (v23)
    {
      uint64_t v61 = (unsigned int *)&v55[v22];
      if (v19 >= v61) {
        uint64_t v62 = v61;
      }
      else {
        uint64_t v62 = v19;
      }
      if (v62 < v15) {
        uint64_t v62 = v15;
      }
      unsigned int v63 = *v62;
      int v64 = (unsigned int *)((char *)v61 + (v53 >> 4));
      if (v19 < v64) {
        int v64 = v19;
      }
      if (v64 < v15) {
        int v64 = v15;
      }
      int v65 = BLEND8_21385[v23];
      unsigned int v57 = v57 - ((v65 & v57) >> v23) + ((v65 & v63) >> v23);
      unsigned int v60 = v60 - ((v65 & v60) >> v23) + ((v65 & *v64) >> v23);
    }
    int v66 = BLEND8_21385[*v52 & 0xF];
    unsigned int v67 = v57 - ((v66 & v57) >> v58);
    unsigned int v68 = (v66 & v60) >> v58;
LABEL_83:
    unsigned int v57 = v67 + v68;
    goto LABEL_84;
  }
  uint64_t v81 = (uint64_t *)(v11 + 16 * a3);
  uint64_t v82 = v16 - 4;
  int v83 = v9 ^ 0xFFFF;
  do
  {
    unsigned int v84 = (char *)v15 + (v14 >> v13) * v12;
    if (v119 == 1)
    {
      if (a5 >= 1)
      {
        unsigned int v85 = v81;
        uint64_t v86 = a5;
        do
        {
          uint64_t v87 = *v85;
          v85 += 2;
          unsigned int v88 = (unsigned int *)&v84[v87];
          if (v82 < &v84[v87]) {
            unsigned int v88 = (unsigned int *)v82;
          }
          if (v88 < v15) {
            unsigned int v88 = v15;
          }
          unsigned int v89 = __ROL4__(*v88, v10);
          int v90 = v89 | v6;
          unsigned int v91 = ((v89 >> 23) & 0x1FE) + BYTE1(v89) + (((v89 >> 8) & 0xFF00) >> 6) + (((v89 >> 8) & 0xFF00) >> 8);
          int v92 = 32 * v91;
          v91 >>= 6;
          int v93 = v91 | (v90 << 24) | (v90 << 16) | v92;
          unsigned int v94 = ((v92 | v91) - (((v92 | v91) * v83 + (((v92 | v91) * v83) >> 16) + 1) >> 16)) | (((v90 | (v90 << 8))
                                                                                                - (((v90 | (v90 << 8)) * v83
                                                                                                  + (((v90 | (v90 << 8)) * v83) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v94 = v93;
          }
          *int v7 = v94;
          if (v8) {
            _WORD *v8 = HIWORD(v94);
          }
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          --v86;
        }
        while (v86);
      }
    }
    else
    {
      int v95 = v81;
      uint64_t v96 = a5;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v97 = *v95;
          v95 += 2;
          int v98 = (unsigned int *)&v84[v97];
          if (v82 < &v84[v97]) {
            int v98 = (unsigned int *)v82;
          }
          if (v98 < v15) {
            int v98 = v15;
          }
          unsigned int v99 = __ROL4__(*v98, v10);
          int v100 = v99 | v6;
          unsigned int v101 = ((v99 >> 23) & 0x1FE) + BYTE1(v99) + (((v99 >> 8) & 0xFF00) >> 6) + (((v99 >> 8) & 0xFF00) >> 8);
          int v102 = 32 * v101;
          v101 >>= 6;
          int v103 = v101 | (v100 << 24) | (v100 << 16) | v102;
          unsigned int v104 = ((v102 | v101) - (((v102 | v101) * v83 + (((v102 | v101) * v83) >> 16) + 1) >> 16)) | (((v100 | (v100 << 8)) - (((v100 | (v100 << 8)) * v83 + (((v100 | (v100 << 8)) * v83) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v104 = v103;
          }
          unsigned int v105 = HIWORD(v104);
          if (v8)
          {
            if (v105)
            {
              if (v105 == 0xFFFF)
              {
                *int v7 = v104;
                _WORD *v8 = -1;
              }
              else
              {
                int v106 = v105 ^ 0xFFFF;
                unsigned int v107 = v106 * (unsigned __int16)*v7;
                unsigned int v108 = (v106 * (unsigned __int16)*v8 + ((v106 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
                *int v7 = v104 + ((v107 + HIWORD(v107) + 1) >> 16);
                _WORD *v8 = v108 + HIWORD(v104);
              }
            }
          }
          else if (v105)
          {
            if (v105 != 0xFFFF) {
              v104 += ((v105 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v105 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
            }
            *int v7 = v104;
          }
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          --v96;
        }
        while (v96);
      }
    }
    v7 += v118;
    v14 += v117;
    v8 += v120;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t w16_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (_WORD *)*((void *)a2 + 2);
  __n128 v8 = (_WORD *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v120 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v120 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v119 = *a2;
  uint64_t v118 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v117 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v117 * a4;
  unint64_t v15 = *(unsigned int **)(a1 + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v8 != 0);
  if (v17)
  {
    uint64_t v114 = *((void *)a2 + 13);
    uint64_t v112 = ~(-1 << v13);
    uint64_t v113 = *((void *)a2 + 15);
    char v111 = v13 - 4;
    unsigned int v19 = (unsigned int *)(v16 - 4);
    int v20 = v9 ^ 0xFFFF;
    uint64_t v110 = a5;
    uint64_t v109 = v11 + 16 * a3 + 8;
    uint64_t v115 = *((void *)a2 + 9);
    int v116 = a5;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        int v23 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v112) >> v111) & 0xF;
        uint64_t v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v119 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        unint64_t v25 = (uint64_t *)v109;
        uint64_t v26 = v110;
        while (1)
        {
          uint64_t v28 = *(v25 - 1);
          uint64_t v27 = *v25;
          uint64_t v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28]) {
            uint64_t v30 = (unsigned int *)&v24[v28];
          }
          else {
            uint64_t v30 = v19;
          }
          if (v30 < v15) {
            uint64_t v30 = v15;
          }
          unsigned int v31 = bswap32(*v30);
          char v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            unint64_t v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22]) {
              unint64_t v43 = v19;
            }
            if (v43 < v15) {
              unint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v45 = __ROL4__(v31, v10);
          int v46 = v45 | v6;
          unsigned int v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          int v48 = 32 * v47;
          v47 >>= 6;
          int v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          unsigned int v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v50 = v49;
          }
          *int v7 = v50;
          if (v8) {
            _WORD *v8 = HIWORD(v50);
          }
          v25 += 2;
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          if (!--v26) {
            goto LABEL_96;
          }
        }
        uint64_t v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33) {
          uint64_t v33 = v19;
        }
        if (v33 < v15) {
          uint64_t v33 = v15;
        }
        unsigned int v34 = bswap32(*v33);
        if (v23)
        {
          unint64_t v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35) {
            uint64_t v36 = v35;
          }
          else {
            uint64_t v36 = v19;
          }
          if (v36 < v15) {
            uint64_t v36 = v15;
          }
          unsigned int v37 = bswap32(*v36);
          uint64_t v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38) {
            uint64_t v38 = v19;
          }
          if (v38 < v15) {
            uint64_t v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        int v40 = BLEND8_21385[*v25 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_46:
        unsigned int v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v118;
      a5 = v116;
      v14 += v117;
      v8 += v120;
      --a6;
      LOBYTE(v13) = v115;
      if (!a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_96;
    }
    int v52 = (uint64_t *)v109;
    uint64_t v51 = v110;
    while (1)
    {
      uint64_t v54 = *(v52 - 1);
      uint64_t v53 = *v52;
      int v55 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54]) {
        int v56 = (unsigned int *)&v24[v54];
      }
      else {
        int v56 = v19;
      }
      if (v56 < v15) {
        int v56 = v15;
      }
      unsigned int v57 = bswap32(*v56);
      char v58 = v53 & 0xF;
      if ((v53 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        long long v69 = (unsigned int *)&v55[v22];
        if (v19 < (unsigned int *)&v55[v22]) {
          long long v69 = v19;
        }
        if (v69 < v15) {
          long long v69 = v15;
        }
        int v70 = BLEND8_21385[v23];
        unsigned int v67 = v57 - ((v70 & v57) >> v23);
        unsigned int v68 = (bswap32(*v69) & v70) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      unsigned int v71 = __ROL4__(v57, v10);
      int v72 = v71 | v6;
      unsigned int v73 = ((v71 >> 23) & 0x1FE) + BYTE1(v71) + (((v71 >> 8) & 0xFF00) >> 6) + (((v71 >> 8) & 0xFF00) >> 8);
      int v74 = 32 * v73;
      v73 >>= 6;
      int v75 = v73 | (v72 << 24) | (v72 << 16) | v74;
      unsigned int v76 = ((v74 | v73) - (((v74 | v73) * v20 + (((v74 | v73) * v20) >> 16) + 1) >> 16)) | (((v72 | (v72 << 8))
                                                                                            - (((v72 | (v72 << 8))
                                                                                              * v20
                                                                                              + (((v72 | (v72 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF) {
        unsigned int v76 = v75;
      }
      unsigned int v77 = HIWORD(v76);
      if (v8)
      {
        if (v77)
        {
          if (v77 == 0xFFFF)
          {
            *int v7 = v76;
            _WORD *v8 = -1;
          }
          else
          {
            int v78 = v77 ^ 0xFFFF;
            unsigned int v79 = v78 * (unsigned __int16)*v7;
            unsigned int v80 = (v78 * (unsigned __int16)*v8 + ((v78 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
            *int v7 = v76 + ((v79 + HIWORD(v79) + 1) >> 16);
            _WORD *v8 = v80 + HIWORD(v76);
          }
        }
      }
      else if (v77)
      {
        if (v77 != 0xFFFF) {
          v76 += ((v77 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v77 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
        }
        *int v7 = v76;
      }
      v52 += 2;
      ++v7;
      __n128 v8 = (_WORD *)((char *)v8 + result);
      if (!--v51) {
        goto LABEL_96;
      }
    }
    int v59 = (unsigned int *)&v55[v53 >> 4];
    if (v19 < v59) {
      int v59 = v19;
    }
    if (v59 < v15) {
      int v59 = v15;
    }
    unsigned int v60 = bswap32(*v59);
    if (v23)
    {
      uint64_t v61 = (unsigned int *)&v55[v22];
      if (v19 >= v61) {
        uint64_t v62 = v61;
      }
      else {
        uint64_t v62 = v19;
      }
      if (v62 < v15) {
        uint64_t v62 = v15;
      }
      unsigned int v63 = bswap32(*v62);
      int v64 = (unsigned int *)((char *)v61 + (v53 >> 4));
      if (v19 < v64) {
        int v64 = v19;
      }
      if (v64 < v15) {
        int v64 = v15;
      }
      int v65 = BLEND8_21385[v23];
      unsigned int v57 = v57 - ((v65 & v57) >> v23) + ((v65 & v63) >> v23);
      unsigned int v60 = v60 - ((v65 & v60) >> v23) + ((bswap32(*v64) & v65) >> v23);
    }
    int v66 = BLEND8_21385[*v52 & 0xF];
    unsigned int v67 = v57 - ((v66 & v57) >> v58);
    unsigned int v68 = (v66 & v60) >> v58;
LABEL_83:
    unsigned int v57 = v67 + v68;
    goto LABEL_84;
  }
  uint64_t v81 = (uint64_t *)(v11 + 16 * a3);
  uint64_t v82 = (unsigned int *)(v16 - 4);
  int v83 = v9 ^ 0xFFFF;
  do
  {
    unsigned int v84 = (char *)v15 + (v14 >> v13) * v12;
    if (v119 == 1)
    {
      if (a5 >= 1)
      {
        unsigned int v85 = v81;
        uint64_t v86 = a5;
        do
        {
          uint64_t v87 = *v85;
          v85 += 2;
          unsigned int v88 = (unsigned int *)&v84[v87];
          if (v82 < (unsigned int *)&v84[v87]) {
            unsigned int v88 = v82;
          }
          if (v88 < v15) {
            unsigned int v88 = v15;
          }
          unsigned int v89 = __ROL4__(bswap32(*v88), v10);
          int v90 = v89 | v6;
          unsigned int v91 = ((v89 >> 23) & 0x1FE) + BYTE1(v89) + (((v89 >> 8) & 0xFF00) >> 6) + (((v89 >> 8) & 0xFF00) >> 8);
          int v92 = 32 * v91;
          v91 >>= 6;
          int v93 = v91 | (v90 << 24) | (v90 << 16) | v92;
          unsigned int v94 = ((v92 | v91) - (((v92 | v91) * v83 + (((v92 | v91) * v83) >> 16) + 1) >> 16)) | (((v90 | (v90 << 8))
                                                                                                - (((v90 | (v90 << 8)) * v83
                                                                                                  + (((v90 | (v90 << 8)) * v83) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v94 = v93;
          }
          *int v7 = v94;
          if (v8) {
            _WORD *v8 = HIWORD(v94);
          }
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          --v86;
        }
        while (v86);
      }
    }
    else
    {
      int v95 = v81;
      uint64_t v96 = a5;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v97 = *v95;
          v95 += 2;
          int v98 = (unsigned int *)&v84[v97];
          if (v82 < (unsigned int *)&v84[v97]) {
            int v98 = v82;
          }
          if (v98 < v15) {
            int v98 = v15;
          }
          unsigned int v99 = __ROL4__(bswap32(*v98), v10);
          int v100 = v99 | v6;
          unsigned int v101 = ((v99 >> 23) & 0x1FE) + BYTE1(v99) + (((v99 >> 8) & 0xFF00) >> 6) + (((v99 >> 8) & 0xFF00) >> 8);
          int v102 = 32 * v101;
          v101 >>= 6;
          int v103 = v101 | (v100 << 24) | (v100 << 16) | v102;
          unsigned int v104 = ((v102 | v101) - (((v102 | v101) * v83 + (((v102 | v101) * v83) >> 16) + 1) >> 16)) | (((v100 | (v100 << 8)) - (((v100 | (v100 << 8)) * v83 + (((v100 | (v100 << 8)) * v83) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v104 = v103;
          }
          unsigned int v105 = HIWORD(v104);
          if (v8)
          {
            if (v105)
            {
              if (v105 == 0xFFFF)
              {
                *int v7 = v104;
                _WORD *v8 = -1;
              }
              else
              {
                int v106 = v105 ^ 0xFFFF;
                unsigned int v107 = v106 * (unsigned __int16)*v7;
                unsigned int v108 = (v106 * (unsigned __int16)*v8 + ((v106 * (unsigned __int16)*v8) >> 16) + 1) >> 16;
                *int v7 = v104 + ((v107 + HIWORD(v107) + 1) >> 16);
                _WORD *v8 = v108 + HIWORD(v104);
              }
            }
          }
          else if (v105)
          {
            if (v105 != 0xFFFF) {
              v104 += ((v105 ^ 0xFFFF) * (unsigned __int16)*v7 + (((v105 ^ 0xFFFF) * (unsigned __int16)*v7) >> 16) + 1) >> 16;
            }
            *int v7 = v104;
          }
          ++v7;
          __n128 v8 = (_WORD *)((char *)v8 + result);
          --v96;
        }
        while (v96);
      }
    }
    v7 += v118;
    v14 += v117;
    v8 += v120;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t w16_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (_WORD *)*((void *)a2 + 2);
  int v7 = (_WORD *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v94 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v94 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v93 = *a2;
  uint64_t v92 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v91 = *((void *)a2 + 11);
  uint64_t v12 = *((void *)a2 + 7) + v91 * a4;
  uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v7 != 0);
  if (v15)
  {
    uint64_t v90 = *((void *)a2 + 13);
    uint64_t v89 = *((void *)a2 + 15);
    uint64_t v17 = v14 - 3;
    int v18 = v8 ^ 0xFFFF;
    unsigned int v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    do
    {
      if (((v89 - v12) | (v12 - v90)) < 0)
      {
        int v22 = 0;
        uint64_t v21 = 0;
      }
      else
      {
        unint64_t v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9) {
          uint64_t v21 = -v10;
        }
        else {
          uint64_t v21 = v10;
        }
        int v22 = weights_21383[v20] & 0xF;
      }
      int v23 = &v13[(v12 >> v11) * v10];
      if (v93 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v24 = (uint64_t *)(v9 + 16 * a3 + 8);
          uint64_t v25 = a5;
          do
          {
            uint64_t v26 = *v24;
            unint64_t v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27) {
              uint64_t v28 = &v23[*(v24 - 1)];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v28 < v13) {
              uint64_t v28 = v13;
            }
            unsigned int v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
            if ((v26 & 0xF) != 0)
            {
              uint64_t v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30) {
                uint64_t v30 = v17;
              }
              if (v30 < v13) {
                uint64_t v30 = v13;
              }
              int v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
              if (v22)
              {
                char v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v33 < v13) {
                  uint64_t v33 = v13;
                }
                int v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
                unint64_t v35 = &v32[v26 >> 4];
                if (v17 < v35) {
                  unint64_t v35 = v17;
                }
                if (v35 < v13) {
                  unint64_t v35 = v13;
                }
                unsigned int v36 = BLEND8_21385[v22];
                unsigned int v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                int v31 = v31 - ((v36 & v31) >> v22) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v22);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_21385[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              unsigned int v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37) {
                unsigned int v37 = v17;
              }
              if (v37 < v13) {
                unsigned int v37 = v13;
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[v22] & v29) >> v22)
                  + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & BLEND8_21385[v22]) >> v22);
            }
            unsigned int v38 = ((v29 >> 23) & 0x1FE) + BYTE1(v29) + (((v29 >> 8) & 0xFF00) >> 6) + (((v29 >> 8) & 0xFF00) >> 8);
            int v39 = 32 * v38;
            v38 >>= 6;
            unsigned int v40 = (unsigned __int16)v38 | (unsigned __int16)v39 | 0xFFFF0000;
            unsigned int v41 = ((v39 | v38) - (((v39 | v38) * v18 + (((v39 | v38) * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF) {
              unsigned int v41 = v40;
            }
            *int v6 = v41;
            if (v7) {
              *int v7 = HIWORD(v41);
            }
            v24 += 2;
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        unint64_t v43 = (uint64_t *)(v9 + 16 * a3 + 8);
        uint64_t v42 = a5;
        do
        {
          uint64_t v44 = *v43;
          unint64_t v45 = (unint64_t)&v23[*(v43 - 1)];
          if ((unint64_t)v17 >= v45) {
            int v46 = &v23[*(v43 - 1)];
          }
          else {
            int v46 = v17;
          }
          if (v46 < v13) {
            int v46 = v13;
          }
          unsigned int v47 = (*v46 << 24) | (v46[1] << 16) | (v46[2] << 8);
          if ((v44 & 0xF) != 0)
          {
            int v48 = (unsigned __int8 *)(v45 + (v44 >> 4));
            if (v17 < v48) {
              int v48 = v17;
            }
            if (v48 < v13) {
              int v48 = v13;
            }
            int v49 = (*v48 << 24) | (v48[1] << 16) | (v48[2] << 8);
            if (v22)
            {
              unsigned int v50 = (unsigned __int8 *)(v45 + v21);
              if (v17 >= v50) {
                uint64_t v51 = v50;
              }
              else {
                uint64_t v51 = v17;
              }
              if (v51 < v13) {
                uint64_t v51 = v13;
              }
              int v52 = (*v51 << 24) | (v51[1] << 16) | (v51[2] << 8);
              uint64_t v53 = &v50[v44 >> 4];
              if (v17 < v53) {
                uint64_t v53 = v17;
              }
              if (v53 < v13) {
                uint64_t v53 = v13;
              }
              unsigned int v54 = BLEND8_21385[v22];
              unsigned int v47 = v47 - ((v54 & v47) >> v22) + ((v54 & v52) >> v22);
              int v49 = v49 - ((v54 & v49) >> v22) + ((((*v53 << 24) | (v53[1] << 16) | (v53[2] << 8)) & v54) >> v22);
            }
            unsigned int v47 = v47
                - ((BLEND8_21385[*v43 & 0xF] & v47) >> (*v43 & 0xF))
                + ((BLEND8_21385[*v43 & 0xF] & v49) >> (*v43 & 0xF));
          }
          else if (v22)
          {
            int v55 = (unsigned __int8 *)(v45 + v21);
            if (v17 < v55) {
              int v55 = v17;
            }
            if (v55 < v13) {
              int v55 = v13;
            }
            unsigned int v47 = v47
                - ((BLEND8_21385[v22] & v47) >> v22)
                + ((((*v55 << 24) | (v55[1] << 16) | (v55[2] << 8)) & BLEND8_21385[v22]) >> v22);
          }
          unsigned int v56 = ((v47 >> 23) & 0x1FE) + BYTE1(v47) + (((v47 >> 8) & 0xFF00) >> 6) + (((v47 >> 8) & 0xFF00) >> 8);
          int v57 = 32 * v56;
          v56 >>= 6;
          unsigned int v58 = (unsigned __int16)v56 | (unsigned __int16)v57 | 0xFFFF0000;
          unsigned int v59 = ((v57 | v56) - (((v57 | v56) * v18 + (((v57 | v56) * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF) {
            unsigned int v60 = v58;
          }
          else {
            unsigned int v60 = v59;
          }
          unsigned int v61 = HIWORD(v60);
          if (v7)
          {
            if (v61)
            {
              if (v61 == 0xFFFF)
              {
                *int v6 = v60;
                *int v7 = -1;
              }
              else
              {
                int v62 = (unsigned __int16)*v7;
                int v63 = v61 ^ 0xFFFF;
                *int v6 = v60
                    + ((v63 * (unsigned __int16)*v6 + ((v63 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                *int v7 = ((v63 * v62 + ((v63 * v62) >> 16) + 1) >> 16) + HIWORD(v60);
              }
            }
          }
          else if (v61)
          {
            if (v61 == 0xFFFF) {
              *int v6 = v60;
            }
            else {
              *int v6 = v60
            }
                  + (((v61 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v61 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
          }
          v43 += 2;
          ++v6;
          int v7 = (_WORD *)((char *)v7 + result);
          --v42;
        }
        while (v42);
      }
      v6 += v92;
      v12 += v91;
      v7 += v94;
      --a6;
    }
    while (a6);
  }
  else
  {
    int v64 = (uint64_t *)(v9 + 16 * a3);
    int v65 = v14 - 3;
    int v66 = v8 ^ 0xFFFF;
    unsigned int v67 = ~(0xFFFF * v66 + ((0xFFFF * v66) >> 16) + 1) & 0xFFFF0000;
    do
    {
      unsigned int v68 = &v13[(v12 >> v11) * v10];
      if (v93 == 1)
      {
        if (a5 >= 1)
        {
          long long v69 = v64;
          uint64_t v70 = a5;
          do
          {
            uint64_t v71 = *v69;
            v69 += 2;
            int v72 = &v68[v71];
            if (v65 < &v68[v71]) {
              int v72 = v65;
            }
            if (v72 < v13) {
              int v72 = v13;
            }
            unsigned int v73 = v72[2] + 2 * *v72 + 4 * v72[1] + v72[1];
            int v74 = 32 * v73;
            v73 >>= 6;
            unsigned int v75 = (unsigned __int16)v73 | (unsigned __int16)v74 | 0xFFFF0000;
            unsigned int v76 = ((v74 | v73) - (((v74 | v73) * v66 + (((v74 | v73) * v66) >> 16) + 1) >> 16)) | v67;
            if (v8 == 0xFFFF) {
              unsigned int v76 = v75;
            }
            *int v6 = v76;
            if (v7) {
              *int v7 = HIWORD(v76);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v70;
          }
          while (v70);
        }
      }
      else
      {
        unsigned int v77 = v64;
        uint64_t v78 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v79 = *v77;
            v77 += 2;
            unsigned int v80 = &v68[v79];
            if (v65 < &v68[v79]) {
              unsigned int v80 = v65;
            }
            if (v80 < v13) {
              unsigned int v80 = v13;
            }
            unsigned int v81 = v80[2] + 2 * *v80 + 4 * v80[1] + v80[1];
            int v82 = 32 * v81;
            v81 >>= 6;
            unsigned int v83 = (unsigned __int16)v81 | (unsigned __int16)v82 | 0xFFFF0000;
            unsigned int v84 = ((v82 | v81) - (((v82 | v81) * v66 + (((v82 | v81) * v66) >> 16) + 1) >> 16)) | v67;
            if (v8 == 0xFFFF) {
              unsigned int v85 = v83;
            }
            else {
              unsigned int v85 = v84;
            }
            unsigned int v86 = HIWORD(v85);
            if (v7)
            {
              if (v86)
              {
                if (v86 == 0xFFFF)
                {
                  *int v6 = v85;
                  *int v7 = -1;
                }
                else
                {
                  int v87 = (unsigned __int16)*v7;
                  int v88 = v86 ^ 0xFFFF;
                  *int v6 = v85
                      + ((v88 * (unsigned __int16)*v6 + ((v88 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                  *int v7 = ((v88 * v87 + ((v88 * v87) >> 16) + 1) >> 16) + HIWORD(v85);
                }
              }
            }
            else if (v86)
            {
              if (v86 == 0xFFFF) {
                *int v6 = v85;
              }
              else {
                *int v6 = v85
              }
                    + (((v86 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v86 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v78;
          }
          while (v78);
        }
      }
      v6 += v92;
      v12 += v91;
      v7 += v94;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t w16_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (_WORD *)*((void *)a2 + 2);
  int v7 = (_WORD *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v91 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v91 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v90 = *a2;
  uint64_t v89 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v88 = *((void *)a2 + 11);
  uint64_t v12 = *((void *)a2 + 7) + v88 * a4;
  uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v7 != 0);
  if (v15)
  {
    uint64_t v87 = *((void *)a2 + 13);
    uint64_t v86 = *((void *)a2 + 15);
    uint64_t v17 = v14 - 4;
    int v18 = v8 ^ 0xFFFF;
    unsigned int v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    uint64_t v85 = v9 + 16 * a3 + 8;
    do
    {
      if (((v86 - v12) | (v12 - v87)) < 0)
      {
        int v22 = 0;
        uint64_t v21 = 0;
      }
      else
      {
        unint64_t v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9) {
          uint64_t v21 = -v10;
        }
        else {
          uint64_t v21 = v10;
        }
        int v22 = weights_21383[v20] & 0xF;
      }
      int v23 = &v13[(v12 >> v11) * v10];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v24 = (uint64_t *)v85;
          uint64_t v25 = a5;
          do
          {
            uint64_t v26 = *v24;
            unint64_t v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27) {
              uint64_t v28 = &v23[*(v24 - 1)];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v28 < v13) {
              uint64_t v28 = v13;
            }
            unsigned int v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              uint64_t v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30) {
                uint64_t v30 = v17;
              }
              if (v30 < v13) {
                uint64_t v30 = v13;
              }
              unsigned int v31 = *v30;
              if (v22)
              {
                char v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32) {
                  uint64_t v33 = v32;
                }
                else {
                  uint64_t v33 = v17;
                }
                if (v33 < v13) {
                  uint64_t v33 = v13;
                }
                unsigned int v34 = *v33;
                unint64_t v35 = &v32[v26 >> 4];
                if (v17 < v35) {
                  unint64_t v35 = v17;
                }
                if (v35 < v13) {
                  unint64_t v35 = v13;
                }
                int v36 = BLEND8_21385[v22];
                unsigned int v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                unsigned int v31 = v31 - ((v36 & v31) >> v22) + ((v36 & *v35) >> v22);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_21385[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              unsigned int v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37) {
                unsigned int v37 = v17;
              }
              if (v37 < v13) {
                unsigned int v37 = v13;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v22] & v29) >> v22) + ((BLEND8_21385[v22] & *v37) >> v22);
            }
            int v38 = v29 | (v29 << 8);
            unsigned int v39 = v38 | 0xFFFF0000;
            unsigned int v40 = (v38 - ((v38 * v18 + ((v38 * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF) {
              unsigned int v40 = v39;
            }
            *int v6 = v40;
            if (v7) {
              *int v7 = HIWORD(v40);
            }
            v24 += 2;
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v42 = (uint64_t *)v85;
        uint64_t v41 = a5;
        do
        {
          uint64_t v43 = *v42;
          unint64_t v44 = (unint64_t)&v23[*(v42 - 1)];
          if ((unint64_t)v17 >= v44) {
            unint64_t v45 = &v23[*(v42 - 1)];
          }
          else {
            unint64_t v45 = v17;
          }
          if (v45 < v13) {
            unint64_t v45 = v13;
          }
          unsigned int v46 = *v45;
          if ((v43 & 0xF) != 0)
          {
            unsigned int v47 = (unsigned __int8 *)(v44 + (v43 >> 4));
            if (v17 < v47) {
              unsigned int v47 = v17;
            }
            if (v47 < v13) {
              unsigned int v47 = v13;
            }
            unsigned int v48 = *v47;
            if (v22)
            {
              int v49 = (unsigned __int8 *)(v44 + v21);
              if (v17 >= v49) {
                unsigned int v50 = v49;
              }
              else {
                unsigned int v50 = v17;
              }
              if (v50 < v13) {
                unsigned int v50 = v13;
              }
              unsigned int v51 = *v50;
              int v52 = &v49[v43 >> 4];
              if (v17 < v52) {
                int v52 = v17;
              }
              if (v52 < v13) {
                int v52 = v13;
              }
              int v53 = BLEND8_21385[v22];
              unsigned int v46 = v46 - ((v53 & v46) >> v22) + ((v53 & v51) >> v22);
              unsigned int v48 = v48 - ((v53 & v48) >> v22) + ((v53 & *v52) >> v22);
            }
            unsigned int v46 = v46
                - ((BLEND8_21385[*v42 & 0xF] & v46) >> (*v42 & 0xF))
                + ((BLEND8_21385[*v42 & 0xF] & v48) >> (*v42 & 0xF));
          }
          else if (v22)
          {
            unsigned int v54 = (unsigned __int8 *)(v44 + v21);
            if (v17 < v54) {
              unsigned int v54 = v17;
            }
            if (v54 < v13) {
              unsigned int v54 = v13;
            }
            unsigned int v46 = v46 - ((BLEND8_21385[v22] & v46) >> v22) + ((BLEND8_21385[v22] & *v54) >> v22);
          }
          int v55 = v46 | (v46 << 8);
          unsigned int v56 = v55 | 0xFFFF0000;
          unsigned int v57 = (v55 - ((v55 * v18 + ((v55 * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF) {
            unsigned int v58 = v56;
          }
          else {
            unsigned int v58 = v57;
          }
          unsigned int v59 = HIWORD(v58);
          if (v7)
          {
            if (v59)
            {
              if (v59 == 0xFFFF)
              {
                *int v6 = v58;
                *int v7 = -1;
              }
              else
              {
                int v60 = (unsigned __int16)*v7;
                int v61 = v59 ^ 0xFFFF;
                *int v6 = v58
                    + ((v61 * (unsigned __int16)*v6 + ((v61 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                *int v7 = ((v61 * v60 + ((v61 * v60) >> 16) + 1) >> 16) + HIWORD(v58);
              }
            }
          }
          else if (v59)
          {
            if (v59 == 0xFFFF) {
              *int v6 = v58;
            }
            else {
              *int v6 = v58
            }
                  + (((v59 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v59 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
          }
          v42 += 2;
          ++v6;
          int v7 = (_WORD *)((char *)v7 + result);
          --v41;
        }
        while (v41);
      }
      v6 += v89;
      v12 += v88;
      v7 += v91;
      --a6;
    }
    while (a6);
  }
  else
  {
    int v62 = (uint64_t *)(v9 + 16 * a3);
    int v63 = v14 - 4;
    int v64 = v8 ^ 0xFFFF;
    unsigned int v65 = ~(0xFFFF * v64 + ((0xFFFF * v64) >> 16) + 1) & 0xFFFF0000;
    do
    {
      int v66 = &v13[(v12 >> v11) * v10];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          unsigned int v67 = v62;
          uint64_t v68 = a5;
          do
          {
            uint64_t v69 = *v67;
            v67 += 2;
            uint64_t v70 = &v66[v69];
            if (v63 < &v66[v69]) {
              uint64_t v70 = v63;
            }
            if (v70 < v13) {
              uint64_t v70 = v13;
            }
            int v71 = *v70 | (*v70 << 8);
            unsigned int v72 = v71 | 0xFFFF0000;
            unsigned int v73 = (v71 - ((v71 * v64 + ((v71 * v64) >> 16) + 1) >> 16)) | v65;
            if (v8 == 0xFFFF) {
              unsigned int v73 = v72;
            }
            *int v6 = v73;
            if (v7) {
              *int v7 = HIWORD(v73);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v68;
          }
          while (v68);
        }
      }
      else
      {
        int v74 = v62;
        uint64_t v75 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v76 = *v74;
            v74 += 2;
            unsigned int v77 = &v66[v76];
            if (v63 < &v66[v76]) {
              unsigned int v77 = v63;
            }
            if (v77 < v13) {
              unsigned int v77 = v13;
            }
            int v78 = *v77 | (*v77 << 8);
            unsigned int v79 = v78 | 0xFFFF0000;
            unsigned int v80 = (v78 - ((v78 * v64 + ((v78 * v64) >> 16) + 1) >> 16)) | v65;
            if (v8 == 0xFFFF) {
              unsigned int v81 = v79;
            }
            else {
              unsigned int v81 = v80;
            }
            unsigned int v82 = HIWORD(v81);
            if (v7)
            {
              if (v82)
              {
                if (v82 == 0xFFFF)
                {
                  *int v6 = v81;
                  *int v7 = -1;
                }
                else
                {
                  int v83 = (unsigned __int16)*v7;
                  int v84 = v82 ^ 0xFFFF;
                  *int v6 = v81
                      + ((v84 * (unsigned __int16)*v6 + ((v84 * (unsigned __int16)*v6) >> 16) + 1) >> 16);
                  *int v7 = ((v84 * v83 + ((v84 * v83) >> 16) + 1) >> 16) + HIWORD(v81);
                }
              }
            }
            else if (v82)
            {
              if (v82 == 0xFFFF) {
                *int v6 = v81;
              }
              else {
                *int v6 = v81
              }
                    + (((v82 ^ 0xFFFF) * (unsigned __int16)*v6 + (((v82 ^ 0xFFFF) * (unsigned __int16)*v6) >> 16) + 1) >> 16);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v75;
          }
          while (v75);
        }
      }
      v6 += v89;
      v12 += v88;
      v7 += v91;
      --a6;
    }
    while (a6);
  }
  return result;
}

unint64_t w16_mark_constmask(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(unsigned __int16 **)(a1 + 96);
  unsigned int v4 = **(unsigned __int16 **)(a1 + 88);
  if (v3) {
    unsigned int v5 = *v3 << 16;
  }
  else {
    unsigned int v5 = -65536;
  }
  int v7 = *(_DWORD *)(a1 + 4);
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 136);
  int v9 = v5 | v4;
  unint64_t v318 = *(int *)(a1 + 28);
  uint64_t v320 = *(void *)(a1 + 40);
  pthread_mutex_lock(&w16_cacheColorLock);
  uint64_t v10 = w16_cacheColor;
  int v317 = v7;
  if (!w16_cacheColor || *(_DWORD *)(w16_cacheColor + 16) != v9)
  {
    uint64_t v11 = 0;
    while (1)
    {
      if (!v10) {
        goto LABEL_11;
      }
      uint64_t v12 = v10;
      uint64_t v13 = v11;
      if (*(_DWORD *)(v10 + 16) == v9) {
        break;
      }
      uint64_t v10 = *(void *)v10;
      uint64_t v11 = (void *)v12;
      if (!*(void *)v12)
      {
        if (w16_cacheColorCount > 6)
        {
          *uint64_t v13 = 0;
        }
        else
        {
LABEL_11:
          uint64_t v14 = (char *)w16_cacheColorBase;
          if (w16_cacheColorBase)
          {
            unsigned int v15 = w16_cacheColorCount;
          }
          else
          {
            uint64_t v14 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            unsigned int v15 = 0;
            w16_cacheColorBase = (uint64_t)v14;
          }
          uint64_t v12 = (uint64_t)&v14[24 * v15];
          *(void *)(v12 + 8) = &v14[1024 * (unint64_t)v15 + 168];
          w16_cacheColorCFIndex Count = v15 + 1;
        }
        uint64_t v18 = 0;
        *(void *)uint64_t v12 = w16_cacheColor;
        w16_cacheColor = v12;
        *(_DWORD *)(v12 + 16) = v9;
        uint64_t v20 = *(void *)(v12 + 8);
        uint64_t v17 = v12 + 8;
        uint64_t v19 = v20;
        int32x4_t v21 = vdupq_n_s32(v4);
        int32x4_t v22 = vdupq_n_s32(HIWORD(v5));
        int32x4_t v23 = (int32x4_t)xmmword_1850CDC50;
        int32x4_t v24 = vdupq_n_s32(0x101u);
        v25.i64[0] = 0xFFFF0000FFFFLL;
        v25.i64[1] = 0xFFFF0000FFFFLL;
        v26.i64[0] = 0x400000004;
        v26.i64[1] = 0x400000004;
        do
        {
          int32x4_t v27 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v23, v24), v25);
          int8x16_t v28 = (int8x16_t)vmulq_s32(v27, v21);
          int8x16_t v29 = (int8x16_t)vmulq_s32(v27, v22);
          *(int8x16_t *)(v19 + v18) = vorrq_s8((int8x16_t)vshlq_n_s32(vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL), (int32x4_t)vmvnq_s8(v29)), 0x10uLL)), 0x10uLL), (int8x16_t)vsubq_s32(v21, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v28, 0x10uLL), (int32x4_t)vmvnq_s8(v28)),
                                                                  0x10uLL)));
          int32x4_t v23 = vaddq_s32(v23, v26);
          v18 += 16;
        }
        while (v18 != 1024);
        unint64_t result = pthread_mutex_unlock(&w16_cacheColorLock);
        goto LABEL_22;
      }
    }
    if (v11)
    {
      *uint64_t v11 = *(void *)v10;
      *(void *)uint64_t v10 = w16_cacheColor;
      w16_cacheColor = v10;
    }
  }
  unint64_t result = pthread_mutex_unlock(&w16_cacheColorLock);
  uint64_t v17 = v10 + 8;
LABEL_22:
  uint64_t v30 = *(void *)v17;
  unsigned int v31 = *(_DWORD *)(*(void *)v17 + 1020);
  uint64_t v33 = *(int *)(a1 + 12);
  uint64_t v32 = *(int *)(a1 + 16);
  if (v2)
  {
    unint64_t v34 = (unint64_t)*(int *)(a1 + 32) >> 1;
    unint64_t v35 = (unsigned __int16 *)(v2 + 2 * (v33 + v34 * v32));
    uint64_t v36 = 1;
  }
  else
  {
    unint64_t v35 = 0;
    unint64_t v34 = 0;
    uint64_t v36 = 0;
  }
  if (v8)
  {
    unint64_t v37 = v34 - v317;
    if (v2) {
      unint64_t result = v34 - v317;
    }
    else {
      unint64_t result = v34;
    }
    unsigned int v38 = HIWORD(v31);
    unsigned int v39 = (int16x4_t *)(v320 + 2 * (v33 + (v318 >> 1) * v32));
    uint64_t v40 = *(int *)(a1 + 124);
    unint64_t v41 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v40;
    uint64_t v42 = v40 - v317;
    unint64_t v43 = (v318 >> 1) - v317;
    uint64_t v319 = v42;
    unint64_t v321 = v43;
    unint64_t v44 = result;
    switch((int)result)
    {
      case 0:
        if (v2)
        {
          uint64_t v45 = 2 * v36;
          do
          {
            int v46 = v317;
            do
            {
              int v47 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v47 == 255)
                {
                  LOWORD(v48) = 0;
                  v39->i16[0] = 0;
                }
                else
                {
                  int v49 = *v35;
                  int v50 = (v47 ^ 0xFF | ((v47 ^ 0xFF) << 8)) ^ 0xFFFF;
                  v39->i16[0] -= (v50 * v39->u16[0] + ((v50 * v39->u16[0]) >> 16) + 1) >> 16;
                  int v48 = v49 - ((v50 * v49 + ((v50 * v49) >> 16) + 1) >> 16);
                }
                *unint64_t v35 = v48;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              unint64_t v35 = (unsigned __int16 *)((char *)v35 + v45);
              --v46;
            }
            while (v46);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            v35 += result;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v51 = v317;
            do
            {
              int v52 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v52 == 255)
                {
                  LOWORD(v53) = 0;
                }
                else
                {
                  int v54 = v39->u16[0];
                  unsigned int v55 = ((v52 ^ 0xFF | ((v52 ^ 0xFF) << 8)) ^ 0xFFFF) * v54;
                  int v53 = v54 - ((v55 + HIWORD(v55) + 1) >> 16);
                }
                v39->i16[0] = v53;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              --v51;
            }
            while (v51);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            --v6;
          }
          while (v6);
        }
        return result;
      case 1:
        unsigned int v56 = v41 & 3;
        if (!v2)
        {
          int v219 = -1 << (8 * v56);
          if ((v41 & 3) != 0) {
            char v220 = v41 & 0xFC;
          }
          else {
            char v220 = v41;
          }
          if ((v41 & 3) != 0)
          {
            BOOL v221 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
          }
          else
          {
            int v219 = -1;
            BOOL v221 = (unsigned int *)v41;
          }
          if ((v41 & 3) != 0) {
            uint64_t v222 = (int16x4_t *)((char *)v39 - 2 * (v41 & 3));
          }
          else {
            uint64_t v222 = v39;
          }
          if ((v41 & 3) != 0) {
            int v223 = v56 + v317;
          }
          else {
            int v223 = v317;
          }
          if ((((_BYTE)v223 + v220) & 3) != 0)
          {
            int v224 = 4 - (((_BYTE)v223 + v220) & 3);
            v56 += v224;
            unsigned int v225 = 0xFFFFFFFF >> (8 * v224);
            if (v223 >= 4) {
              unsigned int v226 = v225;
            }
            else {
              unsigned int v226 = 0;
            }
            if (v223 >= 4) {
              unsigned int v225 = -1;
            }
            v219 &= v225;
          }
          else
          {
            unsigned int v226 = 0;
          }
          uint64_t v294 = v42 - v56;
          unint64_t v295 = (v223 >> 2);
          int16x4_t v296 = vdup_n_s16(v31);
          unint64_t v297 = v43 - v56;
          while (1)
          {
            unsigned int v298 = *v221 & v219;
            unint64_t v299 = v295;
            unsigned int v300 = v226;
            if (!v298) {
              goto LABEL_532;
            }
LABEL_514:
            if (v298 == -1)
            {
              *uint64_t v222 = v296;
              goto LABEL_532;
            }
            while (1)
            {
              if ((_BYTE)v298)
              {
                LOWORD(v301) = v31;
                if (v298 != 255)
                {
                  unsigned int v302 = v222->u16[0] * ((v298 | (v298 << 8)) ^ 0xFFFF);
                  unsigned int v301 = *(_DWORD *)(v30 + 4 * v298) + ((v302 + HIWORD(v302) + 1) >> 16);
                }
                v222->i16[0] = v301;
              }
              if (BYTE1(v298))
              {
                LOWORD(v303) = v31;
                if (BYTE1(v298) != 255) {
                  unsigned int v303 = *(_DWORD *)(v30 + 4 * BYTE1(v298))
                }
                       + ((v222->u16[1] * ((BYTE1(v298) | (BYTE1(v298) << 8)) ^ 0xFFFF)
                         + ((v222->u16[1] * ((BYTE1(v298) | (BYTE1(v298) << 8)) ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                v222->i16[1] = v303;
              }
              if (BYTE2(v298))
              {
                LOWORD(v304) = v31;
                if (BYTE2(v298) != 255) {
                  unsigned int v304 = *(_DWORD *)(v30 + 4 * BYTE2(v298))
                }
                       + ((v222->u16[2] * ((BYTE2(v298) | (BYTE2(v298) << 8)) ^ 0xFFFF)
                         + ((v222->u16[2] * ((BYTE2(v298) | (BYTE2(v298) << 8)) ^ 0xFFFFu)) >> 16)
                         + 1) >> 16);
                v222->i16[2] = v304;
              }
              unsigned int v305 = HIBYTE(v298);
              if (v305 == 255)
              {
                v222->i16[3] = v31;
              }
              else if (v305)
              {
                v222->i16[3] = *(_WORD *)(v30 + 4 * v305)
                             + ((((v305 | (v305 << 8)) ^ 0xFFFF) * v222->u16[3]
                               + ((((v305 | (v305 << 8)) ^ 0xFFFF) * v222->u16[3]) >> 16)
                               + 1) >> 16);
              }
LABEL_532:
              while (1)
              {
                unint64_t result = v299;
                ++v222;
                unint64_t v299 = (v299 - 1);
                ++v221;
                if ((int)result < 2) {
                  break;
                }
                unsigned int v298 = *v221;
                if (*v221) {
                  goto LABEL_514;
                }
              }
              if (!v300) {
                break;
              }
              unsigned int v300 = 0;
              unsigned int v298 = *v221 & v226;
            }
            BOOL v221 = (unsigned int *)((char *)v221 + v294);
            uint64_t v222 = (int16x4_t *)((char *)v222 + 2 * v297);
            if (!--v6) {
              return result;
            }
          }
        }
        int v57 = -1 << (8 * v56);
        unsigned int v58 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v59 = 2 * (v41 & 3);
        int v60 = (int16x4_t *)((char *)v39 - v59);
        int v61 = &v35[v59 / 0xFFFFFFFFFFFFFFFELL];
        if ((v41 & 3) != 0) {
          char v62 = v41 & 0xFC;
        }
        else {
          char v62 = v41;
        }
        if ((v41 & 3) != 0)
        {
          int v63 = v56 + v317;
        }
        else
        {
          int v57 = -1;
          unsigned int v58 = (unsigned int *)v41;
          int v61 = v35;
          int v60 = v39;
          int v63 = v317;
        }
        if ((((_BYTE)v63 + v62) & 3) != 0)
        {
          int v64 = 4 - (((_BYTE)v63 + v62) & 3);
          v56 += v64;
          unsigned int v65 = 0xFFFFFFFF >> (8 * v64);
          if (v63 >= 4) {
            unsigned int v66 = v65;
          }
          else {
            unsigned int v66 = 0;
          }
          if (v63 >= 4) {
            unsigned int v65 = -1;
          }
          v57 &= v65;
        }
        else
        {
          unsigned int v66 = 0;
        }
        uint64_t v239 = v42 - v56;
        unint64_t v240 = v43 - v56;
        int v241 = v63 >> 2;
        unint64_t result = v37 - v56;
        do
        {
          unsigned int v242 = *v58 & v57;
          int v243 = v241;
          unsigned int v244 = v66;
          if (!v242) {
            goto LABEL_483;
          }
LABEL_462:
          if (v242 == -1)
          {
            v60->i16[0] = v31;
            *int v61 = HIWORD(v31);
            v60->i16[1] = v31;
            v61[1] = HIWORD(v31);
            v60->i16[2] = v31;
            v61[2] = HIWORD(v31);
LABEL_480:
            v60->i16[3] = v31;
            v61[3] = HIWORD(v31);
            goto LABEL_483;
          }
          while (1)
          {
            if ((_BYTE)v242)
            {
              if (v242 == 255)
              {
                v60->i16[0] = v31;
                unsigned int v245 = HIWORD(v31);
              }
              else
              {
                unsigned int v246 = *(_DWORD *)(v30 + 4 * v242);
                int v247 = *v61;
                int v248 = (v242 | (v242 << 8)) ^ 0xFFFF;
                v60->i16[0] = v246 + ((v60->u16[0] * v248 + ((v60->u16[0] * v248) >> 16) + 1) >> 16);
                unsigned int v245 = ((v247 * v248 + ((v247 * v248) >> 16) + 1) >> 16) + HIWORD(v246);
              }
              *int v61 = v245;
            }
            if (BYTE1(v242))
            {
              if (BYTE1(v242) == 255)
              {
                v60->i16[1] = v31;
                unsigned int v249 = HIWORD(v31);
              }
              else
              {
                unsigned int v250 = *(_DWORD *)(v30 + 4 * BYTE1(v242));
                int v251 = (BYTE1(v242) | (BYTE1(v242) << 8)) ^ 0xFFFF;
                unsigned int v252 = v60->u16[1] * v251;
                unsigned int v253 = (v61[1] * v251 + ((v61[1] * v251) >> 16) + 1) >> 16;
                v60->i16[1] = v250 + ((v252 + HIWORD(v252) + 1) >> 16);
                unsigned int v249 = v253 + HIWORD(v250);
              }
              v61[1] = v249;
            }
            if (BYTE2(v242))
            {
              if (BYTE2(v242) == 255)
              {
                v60->i16[2] = v31;
                unsigned int v254 = HIWORD(v31);
              }
              else
              {
                unsigned int v255 = *(_DWORD *)(v30 + 4 * BYTE2(v242));
                int v256 = v61[2];
                int v257 = (BYTE2(v242) | (BYTE2(v242) << 8)) ^ 0xFFFF;
                v60->i16[2] = v255 + ((v60->u16[2] * v257 + ((v60->u16[2] * v257) >> 16) + 1) >> 16);
                unsigned int v254 = ((v256 * v257 + ((v256 * v257) >> 16) + 1) >> 16) + HIWORD(v255);
              }
              v61[2] = v254;
            }
            unsigned int v258 = HIBYTE(v242);
            if (v258 == 255) {
              goto LABEL_480;
            }
            if (v258)
            {
              int v259 = v258 | (v258 << 8);
              int v260 = *(_DWORD *)(v30 + 4 * v258);
              v259 ^= 0xFFFFu;
              unsigned int v261 = v259 * v60->u16[3];
              unsigned int v262 = (v259 * v61[3] + ((v259 * v61[3]) >> 16) + 1) >> 16;
              v60->i16[3] = v260 + ((v261 + HIWORD(v261) + 1) >> 16);
              v61[3] = v262 + HIWORD(v260);
            }
LABEL_483:
            while (1)
            {
              int v263 = v243;
              ++v60;
              v61 += 4;
              --v243;
              ++v58;
              if (v263 < 2) {
                break;
              }
              unsigned int v242 = *v58;
              if (*v58) {
                goto LABEL_462;
              }
            }
            if (!v244) {
              break;
            }
            unsigned int v244 = 0;
            unsigned int v242 = *v58 & v66;
          }
          unsigned int v58 = (unsigned int *)((char *)v58 + v239);
          int v60 = (int16x4_t *)((char *)v60 + 2 * v240);
          v61 += result;
          --v6;
        }
        while (v6);
        return result;
      case 2:
        unsigned int v67 = v41 & 3;
        if (v2)
        {
          int v68 = -1 << (8 * v67);
          uint64_t v69 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
          uint64_t v70 = 2 * (v41 & 3);
          int v71 = (int16x4_t *)((char *)v39 - v70);
          unsigned int v72 = &v35[v70 / 0xFFFFFFFFFFFFFFFELL];
          if ((v41 & 3) != 0) {
            char v73 = v41 & 0xFC;
          }
          else {
            char v73 = v41;
          }
          if ((v41 & 3) != 0)
          {
            int v74 = v67 + v317;
          }
          else
          {
            int v68 = -1;
            uint64_t v69 = (unsigned int *)v41;
            unsigned int v72 = v35;
            int v71 = v39;
            int v74 = v317;
          }
          if ((((_BYTE)v74 + v73) & 3) != 0)
          {
            int v75 = 4 - (((_BYTE)v74 + v73) & 3);
            v67 += v75;
            unsigned int v76 = 0xFFFFFFFF >> (8 * v75);
            if (v74 >= 4) {
              unsigned int v77 = v76;
            }
            else {
              unsigned int v77 = 0;
            }
            if (v74 >= 4) {
              unsigned int v76 = -1;
            }
            v68 &= v76;
          }
          else
          {
            unsigned int v77 = 0;
          }
          uint64_t v264 = v42 - v67;
          unint64_t v265 = v43 - v67;
          int v266 = v74 >> 2;
          unint64_t result = (unsigned __int16)~HIWORD(v31);
          unint64_t v267 = v37 - v67;
          while (1)
          {
            unsigned int v268 = *v69 & v68;
            int v269 = v266;
            unsigned int v270 = v77;
            if (!v268) {
              goto LABEL_504;
            }
LABEL_493:
            if (v268 == -1) {
              break;
            }
            while (1)
            {
              if ((_BYTE)v268)
              {
                unsigned int v280 = *(_DWORD *)(v30 + 4 * v268);
                int v281 = HIWORD(v280) ^ 0xFFFF;
                unsigned int v282 = v281 * v71->u16[0];
                unsigned int v283 = (v281 * *v72 + ((v281 * *v72) >> 16) + 1) >> 16;
                v71->i16[0] = v280 + ((v282 + HIWORD(v282) + 1) >> 16);
                *unsigned int v72 = v283 + HIWORD(v280);
              }
              if ((v268 & 0xFF00) != 0)
              {
                unsigned int v284 = *(_DWORD *)(v30 + 4 * BYTE1(v268));
                int v285 = HIWORD(v284) ^ 0xFFFF;
                unsigned int v286 = v285 * v71->u16[1];
                unsigned int v287 = (v285 * v72[1] + ((v285 * v72[1]) >> 16) + 1) >> 16;
                v71->i16[1] = v284 + ((v286 + HIWORD(v286) + 1) >> 16);
                v72[1] = v287 + HIWORD(v284);
              }
              if ((v268 & 0xFF0000) != 0)
              {
                unsigned int v288 = *(_DWORD *)(v30 + 4 * BYTE2(v268));
                int v289 = HIWORD(v288) ^ 0xFFFF;
                unsigned int v290 = v289 * v71->u16[2];
                unsigned int v291 = (v289 * v72[2] + ((v289 * v72[2]) >> 16) + 1) >> 16;
                v71->i16[2] = v288 + ((v290 + HIWORD(v290) + 1) >> 16);
                v72[2] = v291 + HIWORD(v288);
              }
              unsigned int v292 = HIBYTE(v268);
              if (v292)
              {
                unsigned int v278 = *(_DWORD *)(v30 + 4 * v292);
                unsigned int v279 = HIWORD(v278);
                int v276 = v71->u16[3];
                int v277 = v72[3];
                int v274 = HIWORD(v278) ^ 0xFFFF;
                int v275 = v274;
                goto LABEL_503;
              }
LABEL_504:
              while (1)
              {
                int v293 = v269;
                ++v71;
                v72 += 4;
                --v269;
                ++v69;
                if (v293 < 2) {
                  break;
                }
                unsigned int v268 = *v69;
                if (*v69) {
                  goto LABEL_493;
                }
              }
              if (!v270) {
                break;
              }
              unsigned int v270 = 0;
              unsigned int v268 = *v69 & v77;
            }
            uint64_t v69 = (unsigned int *)((char *)v69 + v264);
            int v71 = (int16x4_t *)((char *)v71 + 2 * v265);
            v72 += v267;
            if (!--v6) {
              return result;
            }
          }
          unsigned int v271 = (*v72 * result + ((*v72 * result) >> 16) + 1) >> 16;
          v71->i16[0] = v31 + ((v71->u16[0] * result + ((v71->u16[0] * result) >> 16) + 1) >> 16);
          *unsigned int v72 = v271 + HIWORD(v31);
          unsigned int v272 = (v72[1] * result + ((v72[1] * result) >> 16) + 1) >> 16;
          v71->i16[1] = v31 + ((v71->u16[1] * result + ((v71->u16[1] * result) >> 16) + 1) >> 16);
          v72[1] = v272 + HIWORD(v31);
          unsigned int v273 = (v72[2] * result + ((v72[2] * result) >> 16) + 1) >> 16;
          v71->i16[2] = v31 + ((v71->u16[2] * result + ((v71->u16[2] * result) >> 16) + 1) >> 16);
          v72[2] = v273 + HIWORD(v31);
          int v274 = v71->u16[3];
          int v275 = v72[3];
          int v276 = (unsigned __int16)~HIWORD(v31);
          int v277 = v276;
          LOWORD(v278) = v31;
          unsigned int v279 = HIWORD(v31);
LABEL_503:
          v71->i16[3] = v278 + ((v274 * v276 + ((v274 * v276) >> 16) + 1) >> 16);
          v72[3] = v279 + ((v275 * v277 + ((v275 * v277) >> 16) + 1) >> 16);
          goto LABEL_504;
        }
        int v227 = -1 << (8 * v67);
        if ((v41 & 3) != 0) {
          char v228 = v41 & 0xFC;
        }
        else {
          char v228 = v41;
        }
        if ((v41 & 3) != 0)
        {
          int v229 = (unsigned int *)(v41 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v227 = -1;
          int v229 = (unsigned int *)v41;
        }
        if ((v41 & 3) != 0) {
          int v230 = (int16x4_t *)((char *)v39 - 2 * (v41 & 3));
        }
        else {
          int v230 = v39;
        }
        if ((v41 & 3) != 0) {
          int v231 = v67 + v317;
        }
        else {
          int v231 = v317;
        }
        if ((((_BYTE)v231 + v228) & 3) != 0)
        {
          int v232 = 4 - (((_BYTE)v231 + v228) & 3);
          v67 += v232;
          unsigned int v233 = 0xFFFFFFFF >> (8 * v232);
          if (v231 >= 4) {
            unsigned int v234 = -1;
          }
          else {
            unsigned int v234 = 0xFFFFFFFF >> (8 * v232);
          }
          v227 &= v234;
          if (v231 < 4) {
            unsigned int v233 = 0;
          }
        }
        else
        {
          unsigned int v233 = 0;
        }
        uint64_t v306 = v42 - v67;
        int v307 = v231 >> 2;
        int v308 = (unsigned __int16)~HIWORD(v31);
        unint64_t v309 = v43 - v67;
        while (1)
        {
          unsigned int v310 = *v229 & v227;
          unsigned int v311 = v233;
          LODWORD(result) = v307;
          if (!v310) {
            goto LABEL_553;
          }
LABEL_542:
          if (v310 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v310) {
              v230->i16[0] = *(_WORD *)(v30 + 4 * v310)
            }
                           + (((~*(_DWORD *)(v30 + 4 * v310) >> 16) * v230->u16[0]
                             + (((~*(_DWORD *)(v30 + 4 * v310) >> 16) * v230->u16[0]) >> 16)
                             + 1) >> 16);
            if ((v310 & 0xFF00) != 0) {
              v230->i16[1] = *(_WORD *)(v30 + 4 * BYTE1(v310))
            }
                           + (((~*(_DWORD *)(v30 + 4 * BYTE1(v310)) >> 16) * v230->u16[1]
                             + (((~*(_DWORD *)(v30 + 4 * BYTE1(v310)) >> 16) * v230->u16[1]) >> 16)
                             + 1) >> 16);
            if ((v310 & 0xFF0000) != 0) {
              v230->i16[2] = *(_WORD *)(v30 + 4 * BYTE2(v310))
            }
                           + (((~*(_DWORD *)(v30 + 4 * BYTE2(v310)) >> 16) * v230->u16[2]
                             + (((~*(_DWORD *)(v30 + 4 * BYTE2(v310)) >> 16) * v230->u16[2]) >> 16)
                             + 1) >> 16);
            unsigned int v315 = HIBYTE(v310);
            if (v315)
            {
              int v314 = *(_DWORD *)(v30 + 4 * v315);
              int v313 = v230->u16[3];
              unsigned int v312 = ~v314 >> 16;
              goto LABEL_552;
            }
LABEL_553:
            while (1)
            {
              int v316 = result;
              ++v230;
              unint64_t result = (result - 1);
              ++v229;
              if (v316 < 2) {
                break;
              }
              unsigned int v310 = *v229;
              if (*v229) {
                goto LABEL_542;
              }
            }
            if (!v311) {
              break;
            }
            unsigned int v311 = 0;
            unsigned int v310 = *v229 & v233;
          }
          int v229 = (unsigned int *)((char *)v229 + v306);
          int v230 = (int16x4_t *)((char *)v230 + 2 * v309);
          if (!--v6) {
            return result;
          }
        }
        v230->i16[0] = v31 + ((v230->u16[0] * v308 + ((v230->u16[0] * v308) >> 16) + 1) >> 16);
        v230->i16[1] = v31 + ((v230->u16[1] * v308 + ((v230->u16[1] * v308) >> 16) + 1) >> 16);
        v230->i16[2] = v31 + ((v230->u16[2] * v308 + ((v230->u16[2] * v308) >> 16) + 1) >> 16);
        unsigned int v312 = v230->u16[3];
        int v313 = (unsigned __int16)~HIWORD(v31);
        LOWORD(v314) = v31;
LABEL_552:
        v230->i16[3] = v314 + ((v312 * v313 + ((v312 * v313) >> 16) + 1) >> 16);
        goto LABEL_553;
      case 3:
        uint64_t v78 = 2 * v36;
        do
        {
          int v79 = v317;
          do
          {
            int v80 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              if (v80 == 255)
              {
                unsigned int v81 = *(_DWORD *)(v30 + (((unint64_t)*v35 >> 6) & 0x3FC));
                v39->i16[0] = v81;
                unsigned int v82 = HIWORD(v81);
              }
              else
              {
                int v83 = v80 | (v80 << 8);
                int v84 = *v35;
                unsigned int v85 = *(_DWORD *)(v30 + 4 * ((v84 * v83 + ((v84 * v83) >> 16) + 1) >> 24));
                v83 ^= 0xFFFFu;
                v39->i16[0] = v85 + ((v39->u16[0] * v83 + ((v39->u16[0] * v83) >> 16) + 1) >> 16);
                unsigned int v82 = ((v84 * v83 + ((v84 * v83) >> 16) + 1) >> 16) + HIWORD(v85);
              }
              *unint64_t v35 = v82;
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v78);
            --v79;
          }
          while (v79);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 4:
        uint64_t v86 = 2 * v36;
        do
        {
          int v87 = v317;
          do
          {
            int v88 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              if (v88 == 255)
              {
                unsigned int v89 = *(_DWORD *)(v30 + 4 * ((unsigned __int16)~*v35 >> 8));
                v39->i16[0] = v89;
                unsigned int v90 = HIWORD(v89);
              }
              else
              {
                int v91 = v88 | (v88 << 8);
                int v92 = *v35;
                unsigned int v93 = *(_DWORD *)(v30 + 4 * (((v92 ^ 0xFFFF) * v91 + (((v92 ^ 0xFFFFu) * v91) >> 16) + 1) >> 24));
                v91 ^= 0xFFFFu;
                v39->i16[0] = v93 + ((v39->u16[0] * v91 + ((v39->u16[0] * v91) >> 16) + 1) >> 16);
                unsigned int v90 = ((v92 * v91 + ((v92 * v91) >> 16) + 1) >> 16) + HIWORD(v93);
              }
              *unint64_t v35 = v90;
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v86);
            --v87;
          }
          while (v87);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 5:
        uint64_t v94 = 2 * v36;
        do
        {
          int v95 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              int v96 = *v35;
              unsigned int v97 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
              int v98 = HIWORD(v97) ^ 0xFFFF;
              v39->i16[0] = ((unsigned __int16)v97 * v96
                           + v98 * v39->u16[0]
                           + (((unsigned __int16)v97 * v96 + v98 * v39->u16[0]) >> 16)
                           + 1) >> 16;
              *unint64_t v35 = ((v98 + v96) * HIWORD(v97) + (((v98 + v96) * HIWORD(v97)) >> 16) + 1) >> 16;
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v94);
            --v95;
          }
          while (v95);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 6:
        uint64_t v99 = 2 * v36;
        do
        {
          int v100 = v317;
          do
          {
            uint64_t v101 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              int v102 = *v35;
              if ((_WORD)v102 != 0xFFFF)
              {
                if ((unsigned __int16)~(_WORD)v102 == 0xFFFF)
                {
                  unsigned int v103 = *(_DWORD *)(v30 + 4 * v101);
                  v39->i16[0] = v103;
                  unsigned int v104 = HIWORD(v103);
                }
                else
                {
                  unsigned int v105 = *(_DWORD *)(v30 + 4 * v101);
                  int v106 = (unsigned __int16)~(_WORD)v102;
                  v39->i16[0] += ((unsigned __int16)v105 * v106
                                + (((unsigned __int16)v105 * v106) >> 16)
                                + 1) >> 16;
                  unsigned int v104 = v102 + ((HIWORD(v105) * v106 + ((HIWORD(v105) * v106) >> 16) + 1) >> 16);
                }
                *unint64_t v35 = v104;
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v99);
            --v100;
          }
          while (v100);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 7:
        int v107 = v38 ^ 0xFFFF;
        if (v2)
        {
          uint64_t v108 = 2 * v36;
          do
          {
            int v109 = v317;
            do
            {
              int v110 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v110 == 255)
                {
                  int v111 = v39->u16[0];
                  int v112 = *v35;
                  unsigned int v113 = v107 * v111;
                  unsigned int v114 = v107 * v112;
                }
                else
                {
                  int v115 = v110 | (v110 << 8);
                  int v111 = v39->u16[0];
                  int v112 = *v35;
                  int v116 = (unsigned __int16)(v115 - ((v38 * v115 + ((v38 * v115) >> 16) + 1) >> 16));
                  unsigned int v113 = v111 * v116;
                  unsigned int v114 = v112 * v116;
                }
                v39->i16[0] = v111 - ((v113 + HIWORD(v113) + 1) >> 16);
                *unint64_t v35 = v112 - ((v114 + HIWORD(v114) + 1) >> 16);
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              unint64_t v35 = (unsigned __int16 *)((char *)v35 + v108);
              --v109;
            }
            while (v109);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            v35 += result;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v117 = v317;
            do
            {
              int v118 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                if (v118 == 255)
                {
                  LOWORD(v119) = v39->i16[0];
                  int v120 = v38 ^ 0xFFFF;
                }
                else
                {
                  int v121 = v118 | (v118 << 8);
                  int v120 = v39->u16[0];
                  unsigned int v119 = v121 - ((v38 * v121 + ((v38 * v121) >> 16) + 1) >> 16);
                }
                v39->i16[0] -= (v120 * (unsigned __int16)v119 + ((v120 * (unsigned __int16)v119) >> 16) + 1) >> 16;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              --v117;
            }
            while (v117);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            --v6;
          }
          while (v6);
        }
        return result;
      case 8:
        int v122 = 257 * v38;
        if (v2)
        {
          uint64_t v123 = 2 * v36;
          do
          {
            int v124 = v317;
            do
            {
              int v125 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                unsigned int v126 = v38;
                if (v125 != 255) {
                  unsigned int v126 = (v122 * v125 + ((v122 * v125) >> 16) + 1) >> 16;
                }
                int v127 = *v35;
                v39->i16[0] -= (v126 * v39->u16[0] + ((v126 * v39->u16[0]) >> 16) + 1) >> 16;
                *unint64_t v35 = v127 - ((v126 * v127 + ((v126 * v127) >> 16) + 1) >> 16);
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              unint64_t v35 = (unsigned __int16 *)((char *)v35 + v123);
              --v124;
            }
            while (v124);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            v35 += result;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v128 = v317;
            do
            {
              int v129 = *(unsigned __int8 *)v41;
              if (*(unsigned char *)v41)
              {
                unsigned int v130 = v38;
                if (v129 != 255) {
                  unsigned int v130 = (v122 * v129 + ((v122 * v129) >> 16) + 1) >> 16;
                }
                v39->i16[0] -= (v130 * v39->u16[0] + ((v130 * v39->u16[0]) >> 16) + 1) >> 16;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              --v128;
            }
            while (v128);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            --v6;
          }
          while (v6);
        }
        return result;
      case 9:
        uint64_t v131 = 2 * v36;
        do
        {
          int v132 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unsigned int v133 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
              int v134 = *v35 ^ 0xFFFF;
              unsigned __int16 v135 = ~(*(unsigned __int8 *)v41 | (*(unsigned __int8 *)v41 << 8)) + HIWORD(v133);
              v39->i16[0] = ((unsigned __int16)v133 * v134
                           + v135 * v39->u16[0]
                           + (((unsigned __int16)v133 * v134 + v135 * v39->u16[0]) >> 16)
                           + 1) >> 16;
              *unint64_t v35 = ((v134 + v135) * HIWORD(v133) + (((v134 + v135) * HIWORD(v133)) >> 16) + 1) >> 16;
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v131);
            --v132;
          }
          while (v132);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 10:
        uint64_t v136 = 2 * v36;
        do
        {
          int v137 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unsigned int v138 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
              int v139 = *v35 ^ 0xFFFF;
              int v140 = HIWORD(v138) ^ 0xFFFF;
              v39->i16[0] = ((unsigned __int16)v138 * v139
                           + v140 * v39->u16[0]
                           + (((unsigned __int16)v138 * v139 + v140 * v39->u16[0]) >> 16)
                           + 1) >> 16;
              *unint64_t v35 = ((v140 + v139) * HIWORD(v138) + (((v140 + v139) * HIWORD(v138)) >> 16) + 1) >> 16;
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v136);
            --v137;
          }
          while (v137);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          --v6;
        }
        while (v6);
        return result;
      case 11:
        if (v2)
        {
          uint64_t v141 = 2 * v36;
          do
          {
            int v142 = v317;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v143 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
                int v144 = *v35;
                int v145 = HIWORD(v143) - (v39->u16[0] + (unsigned __int16)v143) + v144;
                unsigned int v146 = v144 + HIWORD(v143);
                if (v145 >= 0xFFFF) {
                  LOWORD(v145) = -1;
                }
                if (v146 >= 0xFFFF) {
                  LOWORD(v146) = -1;
                }
                v39->i16[0] = v146 - v145;
                *unint64_t v35 = v146;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              unint64_t v35 = (unsigned __int16 *)((char *)v35 + v141);
              --v142;
            }
            while (v142);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            v35 += result;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v235 = v317;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v236 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
                int v237 = (v39->u16[0] ^ 0xFFFF) - (unsigned __int16)v236 + HIWORD(v236);
                if (v237 >= 0xFFFF) {
                  LOWORD(v237) = -1;
                }
                v39->i16[0] = ~(_WORD)v237;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              --v235;
            }
            while (v235);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            --v6;
          }
          while (v6);
        }
        return result;
      case 12:
        if (v2)
        {
          uint64_t v147 = 2 * v36;
          do
          {
            int v148 = v317;
            do
            {
              if (*(unsigned char *)v41)
              {
                unsigned int v149 = *(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
                unsigned int v150 = v39->u16[0] + (unsigned __int16)v149;
                unsigned int v151 = *v35 + HIWORD(v149);
                if (v150 >= 0xFFFF) {
                  LOWORD(v150) = -1;
                }
                if (v151 >= 0xFFFF) {
                  LOWORD(v151) = -1;
                }
                v39->i16[0] = v150;
                *unint64_t v35 = v151;
              }
              ++v41;
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              unint64_t v35 = (unsigned __int16 *)((char *)v35 + v147);
              --v148;
            }
            while (v148);
            v41 += v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            v35 += result;
            --v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            uint64_t v238 = 0;
            do
            {
              if (*(unsigned char *)(v41 + v238)) {
                v39->i16[0] = (2 * v39->i16[0]) | (v39->i16[0] >> 15);
              }
              unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
              ++v238;
            }
            while (v317 != v238);
            v41 += (v317 - 1) + 1 + v42;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
            --v6;
          }
          while (v6);
        }
        return result;
      case 13:
        uint64_t v152 = 2 * v36;
        while (1)
        {
          int v153 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t v154 = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              if (v154 >= 0x10000)
              {
                unint64_t v155 = v154 >> 16;
                if (v2)
                {
                  unsigned int v156 = *v35;
                  if (!*v35) {
                    goto LABEL_208;
                  }
                }
                else
                {
                  unsigned int v156 = 0xFFFF;
                }
                unint64_t v157 = (v156 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v154
                     + ((v155 ^ 0xFFFF) + (unsigned __int16)v154) * (unint64_t)v39->u16[0];
                if (v157 <= 0xFFFE8000) {
                  unint64_t v158 = v157 + 0x8000;
                }
                else {
                  unint64_t v158 = 4294868992;
                }
                unint64_t v159 = v158 + (v158 >> 16);
                if (v2)
                {
                  unint64_t v154 = v159 >> 16;
                  int64_t v160 = 0xFFFF * (v156 + v155) - v156 * (unint64_t)v155;
                  if (v160 <= 4294868992) {
                    unint64_t v155 = v160 + 0x8000;
                  }
                  else {
                    unint64_t v155 = 4294868992;
                  }
                  LODWORD(v154) = ((v155 >> 16) + v155) & 0xFFFF0000 | v154;
                  LODWORD(v155) = WORD1(v154);
LABEL_208:
                  v39->i16[0] = v154;
                  *unint64_t v35 = v155;
                  goto LABEL_210;
                }
                v39->i16[0] = WORD1(v159);
              }
            }
LABEL_210:
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v152);
            --v153;
          }
          while (v153);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          if (!--v6) {
            return result;
          }
        }
      case 14:
        uint64_t v161 = 2 * v36;
        while (1)
        {
          int v162 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t v163 = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              if (v163 >= 0x10000)
              {
                unint64_t v164 = v163 >> 16;
                if (v2)
                {
                  unsigned int v165 = *v35;
                  if (!*v35) {
                    goto LABEL_229;
                  }
                }
                else
                {
                  unsigned int v165 = 0xFFFF;
                }
                unint64_t v166 = (v39->u16[0] ^ 0xFFFFu)
                     * (unint64_t)(unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41)
                     - v39->u16[0]
                     + ((unint64_t)v39->u16[0] << 16);
                if (v166 <= 0xFFFE8000) {
                  unint64_t v167 = v166 + 0x8000;
                }
                else {
                  unint64_t v167 = 4294868992;
                }
                unint64_t v163 = (v167 + (v167 >> 16)) >> 16;
                if (v2)
                {
                  int64_t v168 = 0xFFFF * (v164 + v165) - v164 * (unint64_t)v165;
                  if (v168 <= 4294868992) {
                    unint64_t v164 = v168 + 0x8000;
                  }
                  else {
                    unint64_t v164 = 4294868992;
                  }
                  LODWORD(v163) = ((v164 >> 16) + v164) & 0xFFFF0000 | v163;
                  LODWORD(v164) = WORD1(v163);
LABEL_229:
                  v39->i16[0] = v163;
                  *unint64_t v35 = v164;
                  goto LABEL_231;
                }
                v39->i16[0] = v163;
              }
            }
LABEL_231:
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v161);
            --v162;
          }
          while (v162);
          v41 += v42;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
          v35 += result;
          if (!--v6) {
            return result;
          }
        }
      case 15:
        uint64_t v169 = 2 * v36;
        do
        {
          int v170 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v171 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAoverlayPDA_8925(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v171);
                    unsigned int v171 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v171;
                }
                else
                {
                  unint64_t result = PDAoverlayPDA_8925(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v171);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v169);
            --v170;
          }
          while (v170);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 16:
        uint64_t v172 = 2 * v36;
        do
        {
          int v173 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v174 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAdarkenPDA_8927(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v174);
                    unsigned int v174 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v174;
                }
                else
                {
                  unint64_t result = PDAdarkenPDA_8927(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v174);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v172);
            --v173;
          }
          while (v173);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 17:
        uint64_t v175 = 2 * v36;
        do
        {
          int v176 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v177 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAlightenPDA_8926(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v177);
                    unsigned int v177 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v177;
                }
                else
                {
                  unint64_t result = PDAlightenPDA_8926(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v177);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v175);
            --v176;
          }
          while (v176);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 18:
        uint64_t v178 = 2 * v36;
        do
        {
          int v179 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v180 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAcolordodgePDA_8928(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v180);
                    unsigned int v180 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v180;
                }
                else
                {
                  unint64_t result = PDAcolordodgePDA_8928(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v180);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v178);
            --v179;
          }
          while (v179);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 19:
        uint64_t v181 = 2 * v36;
        do
        {
          int v182 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v183 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAcolorburnPDA_8929(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v183);
                    unsigned int v183 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v183;
                }
                else
                {
                  unint64_t result = PDAcolorburnPDA_8929(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v183);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v181);
            --v182;
          }
          while (v182);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 20:
        uint64_t v184 = 2 * v36;
        do
        {
          int v185 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v186 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAsoftlightPDA_8931(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v186);
                    unsigned int v186 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v186;
                }
                else
                {
                  unint64_t result = PDAsoftlightPDA_8931(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v186);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v184);
            --v185;
          }
          while (v185);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 21:
        uint64_t v187 = 2 * v36;
        do
        {
          int v188 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v189 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAhardlightPDA_8930(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v189);
                    unsigned int v189 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v189;
                }
                else
                {
                  unint64_t result = PDAhardlightPDA_8930(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v189);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v187);
            --v188;
          }
          while (v188);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 22:
        uint64_t v190 = 2 * v36;
        do
        {
          int v191 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v192 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAdifferencePDA_8932(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v192);
                    unsigned int v192 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v192;
                }
                else
                {
                  unint64_t result = PDAdifferencePDA_8932(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v192);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v190);
            --v191;
          }
          while (v191);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 23:
        uint64_t v193 = 2 * v36;
        break;
      case 24:
        uint64_t v204 = 2 * v36;
        do
        {
          int v205 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v206 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAhuePDA_8933(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v206);
                    unsigned int v206 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v206;
                }
                else
                {
                  unint64_t result = PDAhuePDA_8933(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v206);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v204);
            --v205;
          }
          while (v205);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 25:
        uint64_t v207 = 2 * v36;
        do
        {
          int v208 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v209 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAhuePDA_8933(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v209);
                    unsigned int v209 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v209;
                }
                else
                {
                  unint64_t result = PDAhuePDA_8933(v39->u16[0], 0xFFFFu, (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v209);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v207);
            --v208;
          }
          while (v208);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 26:
        uint64_t v210 = 2 * v36;
        do
        {
          int v211 = v317;
          do
          {
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
              unsigned int v212 = WORD1(result);
              if (WORD1(result))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAluminosityPDA_8935((unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v212, v39->u16[0], *v35);
                    unsigned int v212 = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v212;
                }
                else
                {
                  unint64_t result = PDAluminosityPDA_8935((unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41), v212, v39->u16[0], 0xFFFFu);
                  v39->i16[0] = result;
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v210);
            --v211;
          }
          while (v211);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      case 27:
        uint64_t v213 = 2 * v36;
        do
        {
          int v214 = v317;
          do
          {
            uint64_t v215 = *(unsigned __int8 *)v41;
            if (*(unsigned char *)v41)
            {
              unint64_t result = *(unsigned int *)(v30 + 4 * v215);
              unint64_t v216 = result >> 16;
              if (HIWORD(*(_DWORD *)(v30 + 4 * v215)))
              {
                if (v2)
                {
                  if (*v35)
                  {
                    unint64_t result = PDAluminosityPDA_8935(v39->u16[0], *v35, (unsigned __int16)*(_DWORD *)(v30 + 4 * v215), v216);
                    LODWORD(v216) = WORD1(result);
                  }
                  v39->i16[0] = result;
                  *unint64_t v35 = v216;
                }
                else
                {
                  unsigned __int16 v217 = *(_DWORD *)(v30 + 4 * v215);
                  if (v217 >= v216) {
                    unsigned __int16 v217 = HIWORD(*(_DWORD *)(v30 + 4 * v215));
                  }
                  unint64_t v218 = (v216 ^ 0xFFFF) * (unint64_t)v39->u16[0] + 0x8000;
                  v39->i16[0] = v217 + (((v218 >> 16) + v218) >> 16);
                }
              }
            }
            ++v41;
            unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
            unint64_t v35 = (unsigned __int16 *)((char *)v35 + v213);
            --v214;
          }
          while (v214);
          v41 += v319;
          unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v321);
          v35 += v44;
          --v6;
        }
        while (v6);
        return result;
      default:
        return result;
    }
LABEL_331:
    int v194 = v317;
    while (1)
    {
      if (!*(unsigned char *)v41) {
        goto LABEL_354;
      }
      unint64_t v195 = *(unsigned int *)(v30 + 4 * *(unsigned __int8 *)v41);
      unint64_t v196 = v195 >> 16;
      if (!HIWORD(*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41))) {
        goto LABEL_354;
      }
      if (v2)
      {
        unsigned int v197 = *v35;
        if (!*v35) {
          goto LABEL_352;
        }
      }
      else
      {
        unsigned int v197 = 0xFFFF;
      }
      if ((unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41) >= v196) {
        uint64_t v198 = v196;
      }
      else {
        uint64_t v198 = (unsigned __int16)*(_DWORD *)(v30 + 4 * *(unsigned __int8 *)v41);
      }
      if (v39->u16[0] >= v197) {
        uint64_t v199 = v197;
      }
      else {
        uint64_t v199 = v39->u16[0];
      }
      int64_t v200 = 0xFFFF * (v199 + v198) - 2 * v198 * (unint64_t)v199;
      if (v200 <= 4294868992) {
        unint64_t v201 = v200 + 0x8000;
      }
      else {
        unint64_t v201 = 4294868992;
      }
      unint64_t v202 = v201 + (v201 >> 16);
      if (!v2)
      {
        v39->i16[0] = WORD1(v202);
        goto LABEL_354;
      }
      unint64_t v195 = v202 >> 16;
      int64_t v203 = 0xFFFF * (v196 + v197) - v196 * (unint64_t)v197;
      if (v203 <= 4294868992) {
        unint64_t v196 = v203 + 0x8000;
      }
      else {
        unint64_t v196 = 4294868992;
      }
      LODWORD(v195) = ((v196 >> 16) + v196) & 0xFFFF0000 | v195;
      LODWORD(v196) = WORD1(v195);
LABEL_352:
      v39->i16[0] = v195;
      *unint64_t v35 = v196;
LABEL_354:
      ++v41;
      unsigned int v39 = (int16x4_t *)((char *)v39 + 2);
      unint64_t v35 = (unsigned __int16 *)((char *)v35 + v193);
      if (!--v194)
      {
        v41 += v42;
        unsigned int v39 = (int16x4_t *)((char *)v39 + 2 * v43);
        v35 += result;
        if (!--v6) {
          return result;
        }
        goto LABEL_331;
      }
    }
  }
  return result;
}

unint64_t w16_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  uint64_t v4 = *(int *)(result + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(result + 32) >> 1;
    int v7 = (_WORD *)(v2 + 2 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    int v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v10 = *(_DWORD *)(result + 4);
  int v9 = *(_DWORD *)(result + 8);
  unint64_t v12 = *(void *)(result + 88);
  uint64_t v11 = *(_WORD **)(result + 96);
  unint64_t v13 = (unint64_t)*(int *)(result + 28) >> 1;
  uint64_t v14 = (char *)(*(void *)(result + 40) + 2 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(result + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(result + 56);
  uint64_t v18 = *(int *)(result + 60);
  unint64_t v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v23 = *(_DWORD *)(result + 64);
    int v24 = *(_DWORD *)(result + 68);
    uint64_t v20 = v19 >> 1;
    if (v11)
    {
      unint64_t v21 = (unint64_t)*(int *)(result + 80) >> 1;
      int v22 = 1;
    }
    else
    {
      unint64_t v21 = 0;
      int v22 = 0;
    }
    unint64_t v28 = v12 + 2 * v20 * v24;
    v8 &= 1u;
    int v27 = 1;
    int8x16_t v29 = *(char **)(result + 88);
    int8x16_t v25 = v29;
    goto LABEL_19;
  }
  uint64_t v20 = v19 >> 1;
  if (v11)
  {
    unint64_t v21 = (unint64_t)*(int *)(result + 80) >> 1;
    v11 += v17 + v21 * v18;
    int v22 = -1;
  }
  else
  {
    unint64_t v21 = 0;
    int v22 = 0;
  }
  int8x16_t v25 = (char *)(v12 + 2 * (v17 + v20 * v18));
  if (v20 == v13 && v14 - v25 >= 1)
  {
    if (v10 >= (uint64_t)((unint64_t)(v14 - v25) >> 1))
    {
      v14 += 2 * v10 - 2;
      v25 += 2 * v10 - 2;
      v16 += v10 - 1;
      v7 += v8 & (v10 - 1);
      int v27 = -1;
      uint64_t v20 = (unint64_t)*(int *)(result + 28) >> 1;
      v11 += v22 & (v10 - 1);
      goto LABEL_16;
    }
    uint64_t v26 = v9 - 1;
    if (v14 <= &v25[2 * v13 * v26 - 2 + 2 * v10])
    {
      v14 += 2 * v13 * v26;
      uint64_t v20 = -(uint64_t)v13;
      v16 += v15 * v26;
      uint64_t v15 = -v15;
      v7 += v6 * v26;
      unint64_t v6 = -(uint64_t)v6;
      v8 &= 1u;
      v11 += v21 * v26;
      unint64_t v21 = -(uint64_t)v21;
      v22 &= 1u;
      int v27 = 1;
      v25 += 2 * v13 * v26;
      unint64_t v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v22 &= 1u;
  int v27 = 1;
LABEL_16:
  unint64_t v28 = 0;
  int8x16_t v29 = 0;
  unint64_t v12 = -1;
  int v24 = v21;
  int v23 = v20;
LABEL_19:
  int v30 = v27 * v10;
  if (v28)
  {
    uint64_t v31 = (int)v18 % v24;
    uint64_t v32 = &v25[2 * v20 * v31];
    unint64_t result = (int)v17 % v23;
    int8x16_t v25 = &v32[2 * result];
    unint64_t v12 = (unint64_t)&v32[2 * v23];
    if (v22) {
      v11 += v21 * v31 + result;
    }
    uint64_t v707 = v11;
    uint64_t v708 = &v32[2 * result];
  }
  else
  {
    uint64_t v707 = v11;
    uint64_t v708 = v29;
    v20 -= v30;
    v21 -= v22 * v10;
  }
  uint64_t v33 = v15 - v30;
  unint64_t v34 = v13 - v30;
  unint64_t v706 = v6 - v8 * v10;
  uint64_t v691 = v20;
  int v692 = v10;
  unint64_t v689 = v34;
  uint64_t v690 = v33;
  unint64_t v693 = v28;
  unint64_t v688 = v21;
  int v721 = v22;
  int v722 = v8;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          int v35 = v10;
          do
          {
            int v36 = *v16;
            if (*v16)
            {
              if (v36 == 255)
              {
                LOWORD(v37) = 0;
                *(_WORD *)uint64_t v14 = 0;
              }
              else
              {
                int v38 = (unsigned __int16)*v7;
                int v39 = v36 | (v36 << 8);
                *(_WORD *)v14 -= (v39 * *(unsigned __int16 *)v14
                                + ((v39 * *(unsigned __int16 *)v14) >> 16)
                                + 1) >> 16;
                int v37 = v38 - ((v39 * v38 + ((v39 * v38) >> 16) + 1) >> 16);
              }
              *int v7 = v37;
            }
            v16 += v27;
            v7 += v8;
            v14 += 2 * v27;
            --v35;
          }
          while (v35);
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v557 = v10;
          do
          {
            int v558 = *v16;
            if (*v16)
            {
              if (v558 == 255) {
                LOWORD(v559) = 0;
              }
              else {
                unsigned int v559 = *(unsigned __int16 *)v14
              }
                     - ((257 * v558 * *(unsigned __int16 *)v14
                       + ((257 * v558 * *(unsigned __int16 *)v14) >> 16)
                       + 1) >> 16);
              *(_WORD *)uint64_t v14 = v559;
            }
            v16 += v27;
            v14 += 2 * v27;
            --v557;
          }
          while (v557);
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v40 = v27;
        if (v22)
        {
          uint64_t v41 = -(uint64_t)v23;
          uint64_t v42 = v24;
          uint64_t v43 = -(v20 * v24);
          uint64_t v44 = -(uint64_t)(v21 * v42);
          uint64_t v45 = v707;
          do
          {
            int v46 = v10;
            do
            {
              int v47 = *v16;
              if (*v16)
              {
                if (v47 == 255)
                {
                  *(_WORD *)uint64_t v14 = *(_WORD *)v25;
                  LOWORD(v48) = *v45;
                }
                else
                {
                  unsigned int v49 = *(unsigned __int16 *)v25 * (v47 | (v47 << 8))
                      + *(unsigned __int16 *)v14 * ((v47 | (v47 << 8)) ^ 0xFFFF);
                  unsigned int v50 = (v49 + HIWORD(v49) + 1) >> 16;
                  unsigned int v48 = (0xFFFF * (unsigned __int16)*v45 + ((0xFFFF * (unsigned __int16)*v45) >> 16) + 1) >> 16;
                  *(_WORD *)uint64_t v14 = v50;
                }
                *int v7 = v48;
              }
              v16 += v40;
              int v51 = &v25[2 * v40];
              int v52 = &v45[v22];
              if ((unint64_t)v51 >= v12) {
                unint64_t result = v41;
              }
              else {
                unint64_t result = 0;
              }
              uint64_t v45 = &v52[result];
              int8x16_t v25 = &v51[2 * result];
              v7 += v8;
              v14 += 2 * v40;
              --v46;
            }
            while (v46);
            if (v28)
            {
              int v53 = &v708[2 * v20];
              if ((unint64_t)v53 >= v28) {
                uint64_t v54 = v44;
              }
              else {
                uint64_t v54 = 0;
              }
              unint64_t result = (unint64_t)&v707[v21 + v54];
              if ((unint64_t)v53 >= v28) {
                uint64_t v55 = v43;
              }
              else {
                uint64_t v55 = 0;
              }
              int8x16_t v25 = &v53[2 * v55];
              v12 += 2 * v55 + 2 * v20;
              v707 += v21 + v54;
              uint64_t v708 = v25;
              uint64_t v45 = (_WORD *)result;
            }
            else
            {
              v25 += 2 * v20;
              v45 += v21;
            }
            v16 += v33;
            v14 += 2 * v34;
            v7 += v706;
            --v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v640 = -(uint64_t)v23;
          uint64_t v641 = -(v20 * v24);
          do
          {
            int v642 = v10;
            do
            {
              int v643 = *v16;
              if (*v16)
              {
                if (v643 == 255) {
                  LOWORD(v644) = *(_WORD *)v25;
                }
                else {
                  unsigned int v644 = (*(unsigned __int16 *)v25 * (v643 | (v643 << 8))
                }
                        + *(unsigned __int16 *)v14 * ((v643 | (v643 << 8)) ^ 0xFFFF)
                        + ((*(unsigned __int16 *)v25 * (v643 | (v643 << 8))
                          + *(unsigned __int16 *)v14 * ((v643 | (v643 << 8)) ^ 0xFFFFu)) >> 16)
                        + 1) >> 16;
                *(_WORD *)uint64_t v14 = v644;
                *int v7 = -1;
              }
              v16 += v40;
              v645 = &v25[2 * v40];
              if ((unint64_t)v645 >= v12) {
                uint64_t v646 = v640;
              }
              else {
                uint64_t v646 = 0;
              }
              int8x16_t v25 = &v645[2 * v646];
              v7 += v8;
              v14 += 2 * v40;
              --v642;
            }
            while (v642);
            v16 += v33;
            v14 += 2 * v34;
            v7 += v706;
            v647 = v708;
            BOOL v648 = &v708[2 * v20];
            if ((unint64_t)v648 >= v28) {
              uint64_t v649 = v641;
            }
            else {
              uint64_t v649 = 0;
            }
            unint64_t v650 = &v648[2 * v649];
            uint64_t v651 = v12 + 2 * v649 + 2 * v20;
            if (v28)
            {
              unint64_t v12 = v651;
              v647 = v650;
            }
            uint64_t v708 = v647;
            if (v28) {
              int8x16_t v25 = v650;
            }
            else {
              v25 += 2 * v20;
            }
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        uint64_t v560 = v27;
        uint64_t v561 = -(uint64_t)v23;
        uint64_t v562 = -(v20 * v24);
        uint64_t v563 = 2 * v27;
        do
        {
          int v564 = v10;
          do
          {
            int v565 = *v16;
            if (*v16)
            {
              if (v565 == 255) {
                LOWORD(v566) = *(_WORD *)v25;
              }
              else {
                unsigned int v566 = (*(unsigned __int16 *)v25 * (v565 | (v565 << 8))
              }
                      + *(unsigned __int16 *)v14 * ((v565 | (v565 << 8)) ^ 0xFFFF)
                      + ((*(unsigned __int16 *)v25 * (v565 | (v565 << 8))
                        + *(unsigned __int16 *)v14 * ((v565 | (v565 << 8)) ^ 0xFFFFu)) >> 16)
                      + 1) >> 16;
              *(_WORD *)uint64_t v14 = v566;
            }
            v16 += v560;
            unint64_t v567 = &v25[2 * v560];
            if ((unint64_t)v567 >= v12) {
              uint64_t v568 = v561;
            }
            else {
              uint64_t v568 = 0;
            }
            int8x16_t v25 = &v567[2 * v568];
            v14 += v563;
            --v564;
          }
          while (v564);
          v16 += v33;
          v14 += 2 * v34;
          uint64_t v569 = v708;
          int v570 = &v708[2 * v20];
          if ((unint64_t)v570 >= v28) {
            uint64_t v571 = v562;
          }
          else {
            uint64_t v571 = 0;
          }
          uint64_t v572 = &v570[2 * v571];
          uint64_t v573 = v12 + 2 * v571 + 2 * v20;
          if (v28)
          {
            unint64_t v12 = v573;
            uint64_t v569 = v572;
          }
          uint64_t v708 = v569;
          if (v28) {
            int8x16_t v25 = v572;
          }
          else {
            v25 += 2 * v20;
          }
          --v9;
        }
        while (v9);
      }
      return result;
    case 2:
      uint64_t v56 = v27;
      if (v8)
      {
        uint64_t v57 = v24;
        uint64_t v58 = -(v20 * v24);
        uint64_t v59 = -(uint64_t)(v21 * v57);
        uint64_t v60 = 2 * v8;
        int v61 = v707;
        uint64_t v62 = -(uint64_t)v23;
        while (1)
        {
          int v63 = v10;
          do
          {
            int v64 = *v16;
            if (!*v16) {
              goto LABEL_73;
            }
            if (v64 == 255)
            {
              int v65 = (unsigned __int16)*v61;
              if (!*v61) {
                goto LABEL_73;
              }
              if (v65 == 0xFFFF)
              {
                *(_WORD *)uint64_t v14 = *(_WORD *)v25;
                LOWORD(v66) = -1;
              }
              else
              {
                unsigned int v75 = (unsigned __int16)*v7 * (v65 ^ 0xFFFF) + (((unsigned __int16)*v7 * (v65 ^ 0xFFFFu)) >> 16) + 1;
                *(_WORD *)uint64_t v14 = *(_WORD *)v25
                              + ((*(unsigned __int16 *)v14 * (v65 ^ 0xFFFF)
                                + ((*(unsigned __int16 *)v14 * (v65 ^ 0xFFFFu)) >> 16)
                                + 1) >> 16);
                unsigned int v66 = v65 + HIWORD(v75);
              }
            }
            else
            {
              int v67 = (unsigned __int16)*v61;
              int v68 = (v64 | (v64 << 8)) ^ 0xFFFF;
              unsigned int v69 = v68 * v67 + ((v68 * v67) >> 16) + 1;
              unsigned int v70 = *(unsigned __int16 *)v25
                  - ((v68 * *(unsigned __int16 *)v25 + ((v68 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
              unsigned int v71 = v70 | ((v67 - HIWORD(v69)) << 16);
              if (!HIWORD(v71)) {
                goto LABEL_73;
              }
              int v72 = HIWORD(v71) ^ 0xFFFF;
              unsigned int v73 = v72 * *(unsigned __int16 *)v14 + ((v72 * *(unsigned __int16 *)v14) >> 16) + 1;
              unsigned int v74 = (v72 * (unsigned __int16)*v7 + ((v72 * (unsigned __int16)*v7) >> 16) + 1) >> 16;
              *(_WORD *)uint64_t v14 = v70 + HIWORD(v73);
              unsigned int v66 = v74 + HIWORD(v71);
            }
            *int v7 = v66;
LABEL_73:
            v16 += v27;
            unint64_t result = (unint64_t)&v25[2 * v27];
            unsigned int v76 = &v61[v22];
            if (result >= v12) {
              uint64_t v77 = v62;
            }
            else {
              uint64_t v77 = 0;
            }
            int v61 = &v76[v77];
            int8x16_t v25 = (char *)(result + 2 * v77);
            int v7 = (_WORD *)((char *)v7 + v60);
            v14 += 2 * v27;
            --v63;
          }
          while (v63);
          if (v28)
          {
            uint64_t v78 = &v708[2 * v20];
            if ((unint64_t)v78 >= v28) {
              uint64_t v79 = v59;
            }
            else {
              uint64_t v79 = 0;
            }
            uint64_t v80 = (uint64_t)&v707[v21 + v79];
            if ((unint64_t)v78 >= v28) {
              uint64_t v81 = v58;
            }
            else {
              uint64_t v81 = 0;
            }
            unint64_t result = v12 + 2 * v81;
            int8x16_t v25 = &v78[2 * v81];
            unint64_t v12 = result + 2 * v20;
            uint64_t v707 = (_WORD *)v80;
            uint64_t v708 = v25;
            int v61 = (_WORD *)v80;
          }
          else
          {
            v25 += 2 * v20;
            v61 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          if (!--v9) {
            return result;
          }
        }
      }
      uint64_t v574 = -(uint64_t)v23;
      uint64_t v575 = v24;
      uint64_t v576 = -(v20 * v24);
      uint64_t v577 = -(uint64_t)(v21 * v575);
      unsigned int v578 = v707;
LABEL_777:
      int v579 = v10;
      while (1)
      {
        int v580 = *v16;
        if (*v16)
        {
          if (v580 == 255)
          {
            int v581 = (unsigned __int16)*v578;
            if (*v578)
            {
              if (v581 == 0xFFFF) {
                LOWORD(v582) = *(_WORD *)v25;
              }
              else {
                unsigned int v582 = *(unsigned __int16 *)v25
              }
                     + ((*(unsigned __int16 *)v14 * (v581 ^ 0xFFFF)
                       + ((*(unsigned __int16 *)v14 * (v581 ^ 0xFFFFu)) >> 16)
                       + 1) >> 16);
              goto LABEL_786;
            }
          }
          else
          {
            int v583 = (unsigned __int16)*v578;
            int v584 = (v580 | (v580 << 8)) ^ 0xFFFF;
            unsigned int v585 = v584 * v583 + ((v584 * v583) >> 16) + 1;
            unsigned int v586 = *(unsigned __int16 *)v25
                 - ((v584 * *(unsigned __int16 *)v25 + ((v584 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            unsigned int v587 = v586 | ((v583 - HIWORD(v585)) << 16);
            if (v587 >= 0x10000)
            {
              unsigned int v582 = v586
                   + (((~v587 >> 16) * *(unsigned __int16 *)v14 + (((~v587 >> 16) * *(unsigned __int16 *)v14) >> 16) + 1) >> 16);
LABEL_786:
              *(_WORD *)uint64_t v14 = v582;
            }
          }
        }
        v16 += v56;
        int v588 = &v25[2 * v56];
        int v589 = &v578[v22];
        if ((unint64_t)v588 >= v12) {
          unint64_t result = v574;
        }
        else {
          unint64_t result = 0;
        }
        unsigned int v578 = &v589[result];
        int8x16_t v25 = &v588[2 * result];
        v14 += 2 * v56;
        if (!--v579)
        {
          if (v28)
          {
            int v590 = &v708[2 * v20];
            if ((unint64_t)v590 >= v28) {
              uint64_t v591 = v577;
            }
            else {
              uint64_t v591 = 0;
            }
            unint64_t result = (unint64_t)&v707[v21 + v591];
            if ((unint64_t)v590 >= v28) {
              uint64_t v592 = v576;
            }
            else {
              uint64_t v592 = 0;
            }
            int8x16_t v25 = &v590[2 * v592];
            v12 += 2 * v592 + 2 * v20;
            v707 += v21 + v591;
            uint64_t v708 = v25;
            unsigned int v578 = (_WORD *)result;
          }
          else
          {
            v25 += 2 * v20;
            v578 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          if (!--v9) {
            return result;
          }
          goto LABEL_777;
        }
      }
    case 3:
      uint64_t v82 = v27;
      uint64_t v83 = v24;
      uint64_t v84 = -(v20 * v24);
      uint64_t v85 = -(uint64_t)(v21 * v83);
      uint64_t v86 = 2 * v27;
      int v87 = v707;
      uint64_t v88 = -(uint64_t)v23;
      do
      {
        int v89 = v10;
        do
        {
          int v90 = *v16;
          if (*v16)
          {
            if (v90 == 255)
            {
              if (v22) {
                int v91 = *v87;
              }
              else {
                int v91 = 0xFFFF;
              }
              int v93 = (unsigned __int16)*v7 ^ 0xFFFF;
              *(_WORD *)uint64_t v14 = *(_WORD *)v25
                            - ((v93 * *(unsigned __int16 *)v25
                              + ((v93 * *(unsigned __int16 *)v25) >> 16)
                              + 1) >> 16);
              unsigned int v94 = v91 - ((v93 * v91 + ((v93 * v91) >> 16) + 1) >> 16);
            }
            else
            {
              if (v22) {
                int v92 = *v87;
              }
              else {
                int v92 = 0xFFFF;
              }
              int v95 = v90 | (v90 << 8);
              unsigned int v96 = (unsigned __int16)*v7 * v95 + (((unsigned __int16)*v7 * v95) >> 16) + 1;
              v95 ^= 0xFFFFu;
              unsigned int v97 = HIWORD(v96) * *(unsigned __int16 *)v25 + *(unsigned __int16 *)v14 * v95;
              unsigned int v94 = ((v95 + HIWORD(v96)) * v92 + (((v95 + HIWORD(v96)) * v92) >> 16) + 1) >> 16;
              *(_WORD *)uint64_t v14 = (v97 + HIWORD(v97) + 1) >> 16;
            }
            *int v7 = v94;
          }
          v16 += v82;
          int v98 = &v25[2 * v82];
          uint64_t v99 = &v87[v22];
          if ((unint64_t)v98 >= v12) {
            unint64_t result = v88;
          }
          else {
            unint64_t result = 0;
          }
          int v87 = &v99[result];
          int8x16_t v25 = &v98[2 * result];
          v7 += v8;
          v14 += v86;
          --v89;
        }
        while (v89);
        if (v28)
        {
          int v100 = &v708[2 * v20];
          if ((unint64_t)v100 >= v28) {
            uint64_t v101 = v85;
          }
          else {
            uint64_t v101 = 0;
          }
          unint64_t result = (unint64_t)&v707[v21 + v101];
          if ((unint64_t)v100 >= v28) {
            uint64_t v102 = v84;
          }
          else {
            uint64_t v102 = 0;
          }
          int8x16_t v25 = &v100[2 * v102];
          v12 += 2 * v102 + 2 * v20;
          v707 += v21 + v101;
          uint64_t v708 = v25;
          int v87 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v87 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 4:
      uint64_t v103 = v27;
      uint64_t v104 = v24;
      uint64_t v105 = -(v20 * v24);
      uint64_t v106 = -(uint64_t)(v21 * v104);
      uint64_t v107 = 2 * v27;
      uint64_t v108 = v707;
      uint64_t v109 = -(uint64_t)v23;
      do
      {
        int v110 = v10;
        do
        {
          int v111 = *v16;
          if (*v16)
          {
            if (v111 == 255)
            {
              if (v22) {
                int v112 = *v108;
              }
              else {
                int v112 = 0xFFFF;
              }
              int v114 = (unsigned __int16)*v7;
              *(_WORD *)uint64_t v14 = *(_WORD *)v25
                            - ((v114 * *(unsigned __int16 *)v25
                              + ((v114 * *(unsigned __int16 *)v25) >> 16)
                              + 1) >> 16);
              unsigned int v115 = v112 - ((v114 * v112 + ((v114 * v112) >> 16) + 1) >> 16);
            }
            else
            {
              if (v22) {
                int v113 = *v108;
              }
              else {
                int v113 = 0xFFFF;
              }
              int v116 = v111 | (v111 << 8);
              unsigned int v117 = ((unsigned __int16)*v7 ^ 0xFFFF) * v116 + ((((unsigned __int16)*v7 ^ 0xFFFFu) * v116) >> 16) + 1;
              v116 ^= 0xFFFFu;
              unsigned int v118 = HIWORD(v117) * *(unsigned __int16 *)v25 + *(unsigned __int16 *)v14 * v116;
              unsigned int v115 = ((v116 + HIWORD(v117)) * v113 + (((v116 + HIWORD(v117)) * v113) >> 16) + 1) >> 16;
              *(_WORD *)uint64_t v14 = (v118 + HIWORD(v118) + 1) >> 16;
            }
            *int v7 = v115;
          }
          v16 += v103;
          unsigned int v119 = &v25[2 * v103];
          int v120 = &v108[v22];
          if ((unint64_t)v119 >= v12) {
            unint64_t result = v109;
          }
          else {
            unint64_t result = 0;
          }
          uint64_t v108 = &v120[result];
          int8x16_t v25 = &v119[2 * result];
          v7 += v8;
          v14 += v107;
          --v110;
        }
        while (v110);
        if (v28)
        {
          int v121 = &v708[2 * v20];
          if ((unint64_t)v121 >= v28) {
            uint64_t v122 = v106;
          }
          else {
            uint64_t v122 = 0;
          }
          unint64_t result = (unint64_t)&v707[v21 + v122];
          if ((unint64_t)v121 >= v28) {
            uint64_t v123 = v105;
          }
          else {
            uint64_t v123 = 0;
          }
          int8x16_t v25 = &v121[2 * v123];
          v12 += 2 * v123 + 2 * v20;
          v707 += v21 + v122;
          uint64_t v708 = v25;
          uint64_t v108 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v108 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 5:
      uint64_t v124 = v27;
      uint64_t v125 = v24;
      uint64_t v126 = -(v20 * v24);
      uint64_t v127 = -(uint64_t)(v21 * v125);
      uint64_t v128 = 2 * v27;
      int v129 = v707;
      uint64_t v130 = -(uint64_t)v23;
      do
      {
        int v131 = v10;
        do
        {
          if (*v16)
          {
            int v132 = (unsigned __int16)*v7;
            int v133 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v134 = *(unsigned __int16 *)v25
                 - ((v133 * *(unsigned __int16 *)v25 + ((v133 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            unsigned int v135 = (v134 | ((*v129 - ((v133 * *v129 + ((v133 * *v129) >> 16) + 1) >> 16)) << 16)) >> 16;
            unsigned int v136 = (unsigned __int16)v134 * v132 + (v135 ^ 0xFFFF) * *(unsigned __int16 *)v14;
            *(_WORD *)uint64_t v14 = (v136 + HIWORD(v136) + 1) >> 16;
            *int v7 = (((v135 ^ 0xFFFF) + v132) * v135 + ((((v135 ^ 0xFFFF) + v132) * v135) >> 16) + 1) >> 16;
          }
          v16 += v124;
          int v137 = &v25[2 * v124];
          unsigned int v138 = &v129[v22];
          if ((unint64_t)v137 >= v12) {
            unint64_t result = v130;
          }
          else {
            unint64_t result = 0;
          }
          int v129 = &v138[result];
          int8x16_t v25 = &v137[2 * result];
          v7 += v8;
          v14 += v128;
          --v131;
        }
        while (v131);
        if (v28)
        {
          int v139 = &v708[2 * v20];
          if ((unint64_t)v139 >= v28) {
            uint64_t v140 = v127;
          }
          else {
            uint64_t v140 = 0;
          }
          unint64_t result = (unint64_t)&v707[v21 + v140];
          if ((unint64_t)v139 >= v28) {
            uint64_t v141 = v126;
          }
          else {
            uint64_t v141 = 0;
          }
          int8x16_t v25 = &v139[2 * v141];
          v12 += 2 * v141 + 2 * v20;
          v707 += v21 + v140;
          uint64_t v708 = v25;
          int v129 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v129 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 6:
      uint64_t v142 = v22;
      uint64_t v143 = -(uint64_t)v23;
      uint64_t v144 = v24;
      uint64_t v145 = -(v20 * v24);
      uint64_t v146 = -(uint64_t)(v21 * v144);
      uint64_t v147 = v707;
      do
      {
        int v148 = v10;
        do
        {
          int v149 = *v16;
          if (*v16)
          {
            int v150 = (unsigned __int16)*v7;
            if ((_WORD)v150 != 0xFFFF)
            {
              if ((unsigned __int16)~(_WORD)v150 == 0xFFFF)
              {
                if (v22) {
                  int v151 = *v147;
                }
                else {
                  int v151 = 0xFFFF;
                }
                int v153 = (v149 | (v149 << 8)) ^ 0xFFFF;
                *(_WORD *)uint64_t v14 = *(_WORD *)v25
                              - ((v153 * *(unsigned __int16 *)v25
                                + ((v153 * *(unsigned __int16 *)v25) >> 16)
                                + 1) >> 16);
                unsigned int v154 = v151 - ((v153 * v151 + ((v153 * v151) >> 16) + 1) >> 16);
              }
              else
              {
                if (v22) {
                  int v152 = *v147;
                }
                else {
                  int v152 = 0xFFFF;
                }
                unsigned int v155 = (257 * v149 * (unsigned __int16)~(_WORD)v150
                      + ((257 * v149 * (unsigned __int16)~(_WORD)v150) >> 16)
                      + 1) >> 16;
                *(_WORD *)v14 += (v155 * *(unsigned __int16 *)v25 + ((v155 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16;
                unsigned int v154 = v150 + ((v155 * v152 + ((v155 * v152) >> 16) + 1) >> 16);
                int v22 = v721;
              }
              *int v7 = v154;
            }
          }
          v16 += v27;
          unint64_t result = (unint64_t)&v25[2 * v27];
          unsigned int v156 = &v147[v142];
          if (result >= v12) {
            uint64_t v157 = v143;
          }
          else {
            uint64_t v157 = 0;
          }
          uint64_t v147 = &v156[v157];
          int8x16_t v25 = (char *)(result + 2 * v157);
          v7 += v8;
          v14 += 2 * v27;
          --v148;
        }
        while (v148);
        if (v28)
        {
          unint64_t v158 = &v708[2 * v20];
          if ((unint64_t)v158 >= v28) {
            uint64_t v159 = v146;
          }
          else {
            uint64_t v159 = 0;
          }
          uint64_t v160 = (uint64_t)&v707[v21 + v159];
          if ((unint64_t)v158 >= v28) {
            uint64_t v161 = v145;
          }
          else {
            uint64_t v161 = 0;
          }
          unint64_t result = v12 + 2 * v161;
          int8x16_t v25 = &v158[2 * v161];
          unint64_t v12 = result + 2 * v20;
          uint64_t v707 = (_WORD *)v160;
          uint64_t v708 = v25;
          uint64_t v147 = (unsigned __int16 *)v160;
        }
        else
        {
          v25 += 2 * v20;
          v147 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 7:
      uint64_t v162 = v27;
      if (v8)
      {
        uint64_t v163 = v24;
        uint64_t v164 = -(v20 * v24);
        uint64_t v165 = -(uint64_t)(v21 * v163);
        unint64_t v166 = v707;
        uint64_t v167 = -(uint64_t)v23;
        do
        {
          int v168 = v10;
          do
          {
            int v169 = *v16;
            if (*v16)
            {
              if (v169 == 255)
              {
                int v170 = (unsigned __int16)*v7;
                int v171 = *v166 ^ 0xFFFF;
                *(_WORD *)v14 -= (v171 * *(unsigned __int16 *)v14
                                + ((v171 * *(unsigned __int16 *)v14) >> 16)
                                + 1) >> 16;
                unsigned int v172 = v170 - ((v171 * v170 + ((v171 * v170) >> 16) + 1) >> 16);
              }
              else
              {
                unsigned int v173 = ((v169 | (v169 << 8)) ^ 0xFFFF)
                     + ((*v166 * (v169 | (v169 << 8)) + ((*v166 * (v169 | (v169 << 8))) >> 16) + 1) >> 16);
                unsigned int v174 = v173 * *(unsigned __int16 *)v14;
                unsigned int v172 = (v173 * (unsigned __int16)*v7 + ((v173 * (unsigned __int16)*v7) >> 16) + 1) >> 16;
                *(_WORD *)uint64_t v14 = (v174 + HIWORD(v174) + 1) >> 16;
              }
              *int v7 = v172;
            }
            v16 += v162;
            uint64_t v175 = &v25[2 * v162];
            int v176 = &v166[v22];
            if ((unint64_t)v175 >= v12) {
              unint64_t result = v167;
            }
            else {
              unint64_t result = 0;
            }
            unint64_t v166 = &v176[result];
            int8x16_t v25 = &v175[2 * result];
            v7 += v8;
            v14 += 2 * v162;
            --v168;
          }
          while (v168);
          if (v28)
          {
            unsigned int v177 = &v708[2 * v20];
            if ((unint64_t)v177 >= v28) {
              uint64_t v178 = v165;
            }
            else {
              uint64_t v178 = 0;
            }
            unint64_t result = (unint64_t)&v707[v21 + v178];
            if ((unint64_t)v177 >= v28) {
              uint64_t v179 = v164;
            }
            else {
              uint64_t v179 = 0;
            }
            int8x16_t v25 = &v177[2 * v179];
            v12 += 2 * v179 + 2 * v20;
            v707 += v21 + v178;
            uint64_t v708 = v25;
            unint64_t v166 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v166 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v593 = -(uint64_t)v23;
        uint64_t v594 = v24;
        uint64_t v595 = -(v20 * v24);
        uint64_t v596 = -(uint64_t)(v21 * v594);
        unint64_t v597 = v707;
        do
        {
          int v598 = v10;
          do
          {
            int v599 = *v16;
            if (*v16)
            {
              if (v599 == 255)
              {
                unsigned int v600 = *(unsigned __int16 *)v14
                     - (((*v597 ^ 0xFFFF) * *(unsigned __int16 *)v14
                       + (((*v597 ^ 0xFFFF) * *(unsigned __int16 *)v14) >> 16)
                       + 1) >> 16);
              }
              else
              {
                int v601 = v599 | (v599 << 8);
                unint64_t result = *v597 * v601 + ((*v597 * v601) >> 16) + 1;
                unsigned int v600 = (((v601 ^ 0xFFFF) + WORD1(result)) * *(unsigned __int16 *)v14
                      + ((((v601 ^ 0xFFFF) + WORD1(result)) * *(unsigned __int16 *)v14) >> 16)
                      + 1) >> 16;
              }
              *(_WORD *)uint64_t v14 = v600;
            }
            v16 += v162;
            v602 = &v25[2 * v162];
            uint64_t v603 = &v597[v22];
            if ((unint64_t)v602 >= v12) {
              uint64_t v604 = v593;
            }
            else {
              uint64_t v604 = 0;
            }
            unint64_t v597 = &v603[v604];
            int8x16_t v25 = &v602[2 * v604];
            v14 += 2 * v162;
            --v598;
          }
          while (v598);
          if (v28)
          {
            BOOL v605 = &v708[2 * v20];
            if ((unint64_t)v605 >= v28) {
              uint64_t v606 = v596;
            }
            else {
              uint64_t v606 = 0;
            }
            uint64_t v607 = (uint64_t)&v707[v21 + v606];
            if ((unint64_t)v605 >= v28) {
              uint64_t v608 = v595;
            }
            else {
              uint64_t v608 = 0;
            }
            int8x16_t v25 = &v605[2 * v608];
            v12 += 2 * v608 + 2 * v20;
            v707 += v21 + v606;
            uint64_t v708 = v25;
            unint64_t v597 = (unsigned __int16 *)v607;
          }
          else
          {
            v25 += 2 * v20;
            v597 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 8:
      uint64_t v180 = v27;
      if (v8)
      {
        uint64_t v181 = v24;
        uint64_t v182 = -(v20 * v24);
        uint64_t v183 = -(uint64_t)(v21 * v181);
        uint64_t v184 = v707;
        uint64_t v185 = -(uint64_t)v23;
        do
        {
          int v186 = v10;
          do
          {
            int v187 = *v16;
            if (*v16)
            {
              int v188 = (unsigned __int16)*v7;
              if (v187 == 255) {
                unsigned int v189 = *v184;
              }
              else {
                unsigned int v189 = (257 * v187 * *v184 + ((257 * v187 * *v184) >> 16) + 1) >> 16;
              }
              *(_WORD *)v14 -= (v189 * *(unsigned __int16 *)v14 + ((v189 * *(unsigned __int16 *)v14) >> 16) + 1) >> 16;
              *int v7 = v188 - ((v189 * v188 + ((v189 * v188) >> 16) + 1) >> 16);
            }
            v16 += v180;
            uint64_t v190 = &v25[2 * v180];
            int v191 = &v184[v22];
            if ((unint64_t)v190 >= v12) {
              unint64_t result = v185;
            }
            else {
              unint64_t result = 0;
            }
            uint64_t v184 = &v191[result];
            int8x16_t v25 = &v190[2 * result];
            v7 += v8;
            v14 += 2 * v180;
            --v186;
          }
          while (v186);
          if (v28)
          {
            unsigned int v192 = &v708[2 * v20];
            if ((unint64_t)v192 >= v28) {
              uint64_t v193 = v183;
            }
            else {
              uint64_t v193 = 0;
            }
            unint64_t result = (unint64_t)&v707[v21 + v193];
            if ((unint64_t)v192 >= v28) {
              uint64_t v194 = v182;
            }
            else {
              uint64_t v194 = 0;
            }
            int8x16_t v25 = &v192[2 * v194];
            v12 += 2 * v194 + 2 * v20;
            v707 += v21 + v193;
            uint64_t v708 = v25;
            uint64_t v184 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v184 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v609 = -(uint64_t)v23;
        uint64_t v610 = v24;
        uint64_t v611 = -(v20 * v24);
        uint64_t v612 = -(uint64_t)(v21 * v610);
        unsigned int v613 = v707;
        do
        {
          int v614 = v10;
          do
          {
            int v615 = *v16;
            if (*v16)
            {
              if (v615 == 255) {
                unsigned int v616 = *v613;
              }
              else {
                unsigned int v616 = (257 * v615 * *v613 + ((257 * v615 * *v613) >> 16) + 1) >> 16;
              }
              *(_WORD *)v14 -= (v616 * *(unsigned __int16 *)v14 + ((v616 * *(unsigned __int16 *)v14) >> 16) + 1) >> 16;
            }
            v16 += v180;
            uint64_t v617 = &v25[2 * v180];
            unint64_t v618 = &v613[v22];
            if ((unint64_t)v617 >= v12) {
              uint64_t v619 = v609;
            }
            else {
              uint64_t v619 = 0;
            }
            unsigned int v613 = &v618[v619];
            int8x16_t v25 = &v617[2 * v619];
            v14 += 2 * v180;
            --v614;
          }
          while (v614);
          if (v28)
          {
            int v620 = &v708[2 * v20];
            if ((unint64_t)v620 >= v28) {
              uint64_t v621 = v612;
            }
            else {
              uint64_t v621 = 0;
            }
            uint64_t v622 = (uint64_t)&v707[v21 + v621];
            if ((unint64_t)v620 >= v28) {
              uint64_t v623 = v611;
            }
            else {
              uint64_t v623 = 0;
            }
            int8x16_t v25 = &v620[2 * v623];
            v12 += 2 * v623 + 2 * v20;
            v707 += v21 + v621;
            uint64_t v708 = v25;
            unsigned int v613 = (unsigned __int16 *)v622;
          }
          else
          {
            v25 += 2 * v20;
            v613 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 9:
      uint64_t v195 = -(uint64_t)v23;
      uint64_t v196 = v24;
      uint64_t v197 = -(v20 * v24);
      uint64_t v198 = -(uint64_t)(v21 * v196);
      uint64_t v199 = 2 * v8;
      int64_t v200 = v707;
      do
      {
        int v201 = v10;
        do
        {
          if (*v16)
          {
            unsigned __int16 v202 = ~(*v16 | (*v16 << 8));
            int v203 = v202;
            unsigned int v204 = *(unsigned __int16 *)v25
                 - ((*(unsigned __int16 *)v25 * v203 + ((*(unsigned __int16 *)v25 * v203) >> 16) + 1) >> 16);
            unsigned int v205 = v204 | ((*v200 - ((*v200 * v203 + ((*v200 * v203) >> 16) + 1) >> 16)) << 16);
            int v206 = (unsigned __int16)*v7 ^ 0xFFFF;
            unsigned int v207 = (unsigned __int16)v204 * v206 + (unsigned __int16)(v202 + HIWORD(v205)) * *(unsigned __int16 *)v14;
            unsigned int v208 = (v206 + (unsigned __int16)(v202 + HIWORD(v205))) * HIWORD(v205);
            *(_WORD *)uint64_t v14 = (v207 + HIWORD(v207) + 1) >> 16;
            *int v7 = (v208 + HIWORD(v208) + 1) >> 16;
          }
          v16 += v27;
          unint64_t result = (unint64_t)&v25[2 * v27];
          unsigned int v209 = &v200[v22];
          if (result >= v12) {
            uint64_t v210 = v195;
          }
          else {
            uint64_t v210 = 0;
          }
          int64_t v200 = &v209[v210];
          int8x16_t v25 = (char *)(result + 2 * v210);
          int v7 = (_WORD *)((char *)v7 + v199);
          v14 += 2 * v27;
          --v201;
        }
        while (v201);
        if (v28)
        {
          int v211 = &v708[2 * v20];
          if ((unint64_t)v211 >= v28) {
            uint64_t v212 = v198;
          }
          else {
            uint64_t v212 = 0;
          }
          uint64_t v213 = (uint64_t)&v707[v21 + v212];
          if ((unint64_t)v211 >= v28) {
            uint64_t v214 = v197;
          }
          else {
            uint64_t v214 = 0;
          }
          unint64_t result = v12 + 2 * v214;
          int8x16_t v25 = &v211[2 * v214];
          unint64_t v12 = result + 2 * v20;
          uint64_t v707 = (_WORD *)v213;
          uint64_t v708 = v25;
          int64_t v200 = (unsigned __int16 *)v213;
        }
        else
        {
          v25 += 2 * v20;
          v200 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 10:
      uint64_t v215 = v27;
      uint64_t v216 = v24;
      uint64_t v217 = -(v20 * v24);
      uint64_t v218 = -(uint64_t)(v21 * v216);
      uint64_t v219 = 2 * v27;
      char v220 = v707;
      uint64_t v221 = -(uint64_t)v23;
      do
      {
        int v222 = v10;
        do
        {
          if (*v16)
          {
            int v223 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v224 = *(unsigned __int16 *)v25
                 - ((v223 * *(unsigned __int16 *)v25 + ((v223 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            unsigned int v225 = (v224 | ((*v220 - ((v223 * *v220 + ((v223 * *v220) >> 16) + 1) >> 16)) << 16)) >> 16;
            int v226 = (unsigned __int16)*v7 ^ 0xFFFF;
            unsigned int v227 = (unsigned __int16)v224 * v226 + (v225 ^ 0xFFFF) * *(unsigned __int16 *)v14;
            *(_WORD *)uint64_t v14 = (v227 + HIWORD(v227) + 1) >> 16;
            *int v7 = (((v225 ^ 0xFFFF) + v226) * v225 + ((((v225 ^ 0xFFFF) + v226) * v225) >> 16) + 1) >> 16;
          }
          v16 += v215;
          char v228 = &v25[2 * v215];
          int v229 = &v220[v22];
          if ((unint64_t)v228 >= v12) {
            unint64_t result = v221;
          }
          else {
            unint64_t result = 0;
          }
          char v220 = &v229[result];
          int8x16_t v25 = &v228[2 * result];
          v7 += v8;
          v14 += v219;
          --v222;
        }
        while (v222);
        if (v28)
        {
          int v230 = &v708[2 * v20];
          if ((unint64_t)v230 >= v28) {
            uint64_t v231 = v218;
          }
          else {
            uint64_t v231 = 0;
          }
          unint64_t result = (unint64_t)&v707[v21 + v231];
          if ((unint64_t)v230 >= v28) {
            uint64_t v232 = v217;
          }
          else {
            uint64_t v232 = 0;
          }
          int8x16_t v25 = &v230[2 * v232];
          v12 += 2 * v232 + 2 * v20;
          v707 += v21 + v231;
          uint64_t v708 = v25;
          char v220 = (unsigned __int16 *)result;
        }
        else
        {
          v25 += 2 * v20;
          v220 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        --v9;
      }
      while (v9);
      return result;
    case 11:
      uint64_t v233 = v27;
      if (v8)
      {
        uint64_t v234 = v24;
        uint64_t v235 = -(v20 * v24);
        uint64_t v236 = -(uint64_t)(v21 * v234);
        int v237 = v707;
        uint64_t v238 = -(uint64_t)v23;
        do
        {
          int v239 = v10;
          do
          {
            if (*v16)
            {
              if (v22) {
                int v240 = *v237;
              }
              else {
                int v240 = 0xFFFF;
              }
              int v241 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v242 = (*(unsigned __int16 *)v25
                    - ((v241 * *(unsigned __int16 *)v25 + ((v241 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v240 - ((v240 * v241 + ((v240 * v241) >> 16) + 1) >> 16)) << 16);
              int v243 = (unsigned __int16)*v7;
              int v244 = v243
                   - (*(unsigned __int16 *)v14
                    + (unsigned __int16)(*(_WORD *)v25
                                       - ((v241 * *(unsigned __int16 *)v25
                                         + ((v241 * *(unsigned __int16 *)v25) >> 16)
                                         + 1) >> 16)))
                   + HIWORD(v242);
              unsigned int v245 = v243 + HIWORD(v242);
              if (v244 >= 0xFFFF) {
                LOWORD(v244) = -1;
              }
              if (v245 >= 0xFFFF) {
                LOWORD(v245) = -1;
              }
              *(_WORD *)uint64_t v14 = v245 - v244;
              *int v7 = v245;
            }
            v16 += v27;
            unint64_t result = (unint64_t)&v25[2 * v27];
            unsigned int v246 = &v237[v22];
            if (result >= v12) {
              uint64_t v247 = v238;
            }
            else {
              uint64_t v247 = 0;
            }
            int v237 = &v246[v247];
            int8x16_t v25 = (char *)(result + 2 * v247);
            v7 += v8;
            v14 += 2 * v27;
            --v239;
          }
          while (v239);
          if (v28)
          {
            int v248 = &v708[2 * v20];
            if ((unint64_t)v248 >= v28) {
              uint64_t v249 = v236;
            }
            else {
              uint64_t v249 = 0;
            }
            uint64_t v250 = (uint64_t)&v707[v21 + v249];
            if ((unint64_t)v248 >= v28) {
              uint64_t v251 = v235;
            }
            else {
              uint64_t v251 = 0;
            }
            unint64_t result = v12 + 2 * v251;
            int8x16_t v25 = &v248[2 * v251];
            unint64_t v12 = result + 2 * v20;
            uint64_t v707 = (_WORD *)v250;
            uint64_t v708 = v25;
            int v237 = (unsigned __int16 *)v250;
          }
          else
          {
            v25 += 2 * v20;
            v237 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v624 = -(uint64_t)v23;
        uint64_t v625 = v24;
        uint64_t v626 = -(v20 * v24);
        uint64_t v627 = -(uint64_t)(v21 * v625);
        uint64_t v628 = v707;
        do
        {
          int v629 = v10;
          do
          {
            if (*v16)
            {
              if (v22) {
                int v630 = *v628;
              }
              else {
                int v630 = 0xFFFF;
              }
              int v631 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              signed int v632 = (*(unsigned __int16 *)v14 ^ 0xFFFF)
                   - (unsigned __int16)(*(_WORD *)v25
                                      - ((v631 * *(unsigned __int16 *)v25
                                        + ((v631 * *(unsigned __int16 *)v25) >> 16)
                                        + 1) >> 16))
                   + (((*(unsigned __int16 *)v25
                      - ((v631 * *(unsigned __int16 *)v25 + ((v631 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v630 - ((v630 * v631 + ((v630 * v631) >> 16) + 1) >> 16)) << 16)) >> 16);
              if (v632 >= 0xFFFF) {
                LOWORD(v632) = -1;
              }
              *(_WORD *)uint64_t v14 = ~(_WORD)v632;
            }
            v16 += v233;
            int v633 = &v25[2 * v233];
            int v634 = &v628[v22];
            if ((unint64_t)v633 >= v12) {
              unint64_t result = v624;
            }
            else {
              unint64_t result = 0;
            }
            uint64_t v628 = &v634[result];
            int8x16_t v25 = &v633[2 * result];
            v14 += 2 * v233;
            --v629;
          }
          while (v629);
          if (v28)
          {
            v635 = &v708[2 * v20];
            if ((unint64_t)v635 >= v28) {
              uint64_t v636 = v627;
            }
            else {
              uint64_t v636 = 0;
            }
            unint64_t result = (unint64_t)&v707[v21 + v636];
            if ((unint64_t)v635 >= v28) {
              uint64_t v637 = v626;
            }
            else {
              uint64_t v637 = 0;
            }
            int8x16_t v25 = &v635[2 * v637];
            v12 += 2 * v637 + 2 * v20;
            v707 += v21 + v636;
            uint64_t v708 = v25;
            uint64_t v628 = (unsigned __int16 *)result;
          }
          else
          {
            v25 += 2 * v20;
            v628 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 12:
      if (v8)
      {
        uint64_t v252 = v24;
        uint64_t v253 = -(v20 * v24);
        uint64_t v254 = -(uint64_t)(v21 * v252);
        unsigned int v255 = v707;
        uint64_t v256 = -(uint64_t)v23;
        do
        {
          int v257 = v10;
          do
          {
            if (*v16)
            {
              if (v22) {
                int v258 = *v255;
              }
              else {
                int v258 = 0xFFFF;
              }
              int v259 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v260 = (*(unsigned __int16 *)v25
                    - ((v259 * *(unsigned __int16 *)v25 + ((v259 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16)) | ((v258 - ((v258 * v259 + ((v258 * v259) >> 16) + 1) >> 16)) << 16);
              unsigned int v261 = *(unsigned __int16 *)v14
                   + (unsigned __int16)(*(_WORD *)v25
                                      - ((v259 * *(unsigned __int16 *)v25
                                        + ((v259 * *(unsigned __int16 *)v25) >> 16)
                                        + 1) >> 16));
              unsigned int v262 = (unsigned __int16)*v7 + HIWORD(v260);
              if (v261 >= 0xFFFF) {
                LOWORD(v261) = -1;
              }
              if (v262 >= 0xFFFF) {
                LOWORD(v262) = -1;
              }
              *(_WORD *)uint64_t v14 = v261;
              *int v7 = v262;
            }
            v16 += v27;
            unint64_t result = (unint64_t)&v25[2 * v27];
            int v263 = &v255[v22];
            if (result >= v12) {
              uint64_t v264 = v256;
            }
            else {
              uint64_t v264 = 0;
            }
            unsigned int v255 = &v263[v264];
            int8x16_t v25 = (char *)(result + 2 * v264);
            v7 += v8;
            v14 += 2 * v27;
            --v257;
          }
          while (v257);
          if (v28)
          {
            unint64_t v265 = &v708[2 * v20];
            if ((unint64_t)v265 >= v28) {
              uint64_t v266 = v254;
            }
            else {
              uint64_t v266 = 0;
            }
            uint64_t v267 = (uint64_t)&v707[v21 + v266];
            if ((unint64_t)v265 >= v28) {
              uint64_t v268 = v253;
            }
            else {
              uint64_t v268 = 0;
            }
            unint64_t result = v12 + 2 * v268;
            int8x16_t v25 = &v265[2 * v268];
            unint64_t v12 = result + 2 * v20;
            uint64_t v707 = (_WORD *)v267;
            uint64_t v708 = v25;
            unsigned int v255 = (unsigned __int16 *)v267;
          }
          else
          {
            v25 += 2 * v20;
            v255 += v21;
          }
          v16 += v33;
          v14 += 2 * v34;
          v7 += v706;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v638 = v10;
          uint64_t v639 = v16;
          do
          {
            if (*v639) {
              *(_WORD *)uint64_t v14 = (2 * *(_WORD *)v14) | (*(__int16 *)v14 >> 15);
            }
            v639 += v27;
            v14 += 2 * v27;
            --v638;
          }
          while (v638);
          v16 += v27 + v27 * (unint64_t)(v10 - 1) + v33;
          v14 += 2 * v34;
          --v9;
        }
        while (v9);
      }
      return result;
    case 13:
      uint64_t v269 = v27;
      uint64_t v270 = v24;
      uint64_t v271 = -(uint64_t)v23;
      uint64_t v272 = -(v20 * v24);
      uint64_t v273 = -(uint64_t)(v21 * v270);
      uint64_t v274 = 2 * v8;
      uint64_t v275 = 2 * v27;
      int v276 = v707;
      while (1)
      {
        int v277 = v10;
        do
        {
          if (*v16)
          {
            int v278 = v22 ? *v276 : 0xFFFF;
            int v279 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v280 = *(unsigned __int16 *)v25
                 - ((v279 * *(unsigned __int16 *)v25 + ((v279 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            unsigned int v281 = v280 | ((v278 - ((v278 * v279 + ((v278 * v279) >> 16) + 1) >> 16)) << 16);
            if (v281 >= 0x10000)
            {
              unint64_t v282 = HIWORD(v281);
              if (v8)
              {
                unsigned int v283 = (unsigned __int16)*v7;
                if (!*v7) {
                  goto LABEL_349;
                }
              }
              else
              {
                unsigned int v283 = 0xFFFF;
              }
              unint64_t v284 = ((v282 ^ 0xFFFF) + (unsigned __int16)v280)
                   * (unint64_t)*(unsigned __int16 *)v14
                   + (v283 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v280;
              int v8 = v722;
              if (v284 <= 0xFFFE8000) {
                unint64_t v285 = v284 + 0x8000;
              }
              else {
                unint64_t v285 = 4294868992;
              }
              unint64_t v286 = v285 + (v285 >> 16);
              if (v722)
              {
                unint64_t v287 = v286 >> 16;
                int v8 = v722;
                int64_t v288 = 0xFFFF * (v283 + v282) - v283 * (unint64_t)v282;
                if (v288 <= 4294868992) {
                  unint64_t v282 = v288 + 0x8000;
                }
                else {
                  unint64_t v282 = 4294868992;
                }
                unsigned int v281 = ((v282 >> 16) + v282) & 0xFFFF0000 | v287;
                LODWORD(v282) = HIWORD(v281);
LABEL_349:
                *(_WORD *)uint64_t v14 = v281;
                *int v7 = v282;
                goto LABEL_351;
              }
              *(_WORD *)uint64_t v14 = WORD1(v286);
            }
          }
LABEL_351:
          v16 += v269;
          unint64_t result = (unint64_t)&v25[2 * v269];
          int v289 = &v276[v22];
          if (result >= v12) {
            uint64_t v290 = v271;
          }
          else {
            uint64_t v290 = 0;
          }
          int v276 = &v289[v290];
          int8x16_t v25 = (char *)(result + 2 * v290);
          int v7 = (_WORD *)((char *)v7 + v274);
          v14 += v275;
          --v277;
        }
        while (v277);
        if (v28)
        {
          unsigned int v291 = &v708[2 * v20];
          if ((unint64_t)v291 >= v28) {
            uint64_t v292 = v273;
          }
          else {
            uint64_t v292 = 0;
          }
          uint64_t v293 = (uint64_t)&v707[v21 + v292];
          if ((unint64_t)v291 >= v28) {
            uint64_t v294 = v272;
          }
          else {
            uint64_t v294 = 0;
          }
          unint64_t result = v12 + 2 * v294;
          int8x16_t v25 = &v291[2 * v294];
          unint64_t v12 = result + 2 * v20;
          uint64_t v707 = (_WORD *)v293;
          uint64_t v708 = v25;
          int v276 = (unsigned __int16 *)v293;
        }
        else
        {
          v25 += 2 * v20;
          v276 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        if (!--v9) {
          return result;
        }
      }
    case 14:
      uint64_t v295 = v27;
      uint64_t v296 = v24;
      uint64_t v297 = -(uint64_t)v23;
      uint64_t v298 = -(v20 * v24);
      uint64_t v299 = -(uint64_t)(v21 * v296);
      uint64_t v300 = 2 * v8;
      uint64_t v301 = 2 * v27;
      unsigned int v302 = v707;
      while (1)
      {
        int v303 = v10;
        do
        {
          if (*v16)
          {
            int v304 = v22 ? *v302 : 0xFFFF;
            int v305 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v306 = *(unsigned __int16 *)v25
                 - ((v305 * *(unsigned __int16 *)v25 + ((v305 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
            unsigned int v307 = v306 | ((v304 - ((v304 * v305 + ((v304 * v305) >> 16) + 1) >> 16)) << 16);
            if (v307 >= 0x10000)
            {
              unsigned int v308 = HIWORD(v307);
              if (v8)
              {
                unsigned int v309 = (unsigned __int16)*v7;
                if (!*v7) {
                  goto LABEL_385;
                }
              }
              else
              {
                unsigned int v309 = 0xFFFF;
              }
              int v8 = v722;
              unint64_t v310 = (*(unsigned __int16 *)v14 ^ 0xFFFFu) * (unint64_t)(unsigned __int16)v306
                   - *(unsigned __int16 *)v14
                   + ((unint64_t)*(unsigned __int16 *)v14 << 16);
              if (v310 <= 0xFFFE8000) {
                unint64_t v311 = v310 + 0x8000;
              }
              else {
                unint64_t v311 = 4294868992;
              }
              unint64_t v312 = (v311 + (v311 >> 16)) >> 16;
              if (v722)
              {
                int v8 = v722;
                int64_t v313 = 0xFFFF * (v309 + (unint64_t)v308) - v309 * (unint64_t)v308;
                if (v313 <= 4294868992) {
                  unint64_t v314 = v313 + 0x8000;
                }
                else {
                  unint64_t v314 = 4294868992;
                }
                unsigned int v307 = ((v314 >> 16) + v314) & 0xFFFF0000 | v312;
                unsigned int v308 = HIWORD(v307);
LABEL_385:
                *(_WORD *)uint64_t v14 = v307;
                *int v7 = v308;
                goto LABEL_387;
              }
              *(_WORD *)uint64_t v14 = v312;
            }
          }
LABEL_387:
          v16 += v295;
          unint64_t result = (unint64_t)&v25[2 * v295];
          unsigned int v315 = &v302[v22];
          if (result >= v12) {
            uint64_t v316 = v297;
          }
          else {
            uint64_t v316 = 0;
          }
          unsigned int v302 = &v315[v316];
          int8x16_t v25 = (char *)(result + 2 * v316);
          int v7 = (_WORD *)((char *)v7 + v300);
          v14 += v301;
          --v303;
        }
        while (v303);
        if (v28)
        {
          int v317 = &v708[2 * v20];
          if ((unint64_t)v317 >= v28) {
            uint64_t v318 = v299;
          }
          else {
            uint64_t v318 = 0;
          }
          uint64_t v319 = (uint64_t)&v707[v21 + v318];
          if ((unint64_t)v317 >= v28) {
            uint64_t v320 = v298;
          }
          else {
            uint64_t v320 = 0;
          }
          unint64_t result = v12 + 2 * v320;
          int8x16_t v25 = &v317[2 * v320];
          unint64_t v12 = result + 2 * v20;
          uint64_t v707 = (_WORD *)v319;
          uint64_t v708 = v25;
          unsigned int v302 = (unsigned __int16 *)v319;
        }
        else
        {
          v25 += 2 * v20;
          v302 += v21;
        }
        v16 += v33;
        v14 += 2 * v34;
        v7 += v706;
        if (!--v9) {
          return result;
        }
      }
    case 15:
      uint64_t v321 = v27;
      uint64_t v322 = v22;
      uint64_t v652 = -(uint64_t)(v21 * v24);
      uint64_t v664 = -(v20 * v24);
      uint64_t v323 = 2 * v8;
      uint64_t v324 = 2 * v27;
      uint64_t v325 = v707;
      uint64_t v326 = -(uint64_t)v23;
      uint64_t v676 = v22;
      do
      {
        int v694 = v9;
        int v327 = v10;
        unint64_t v709 = v12;
        do
        {
          if (*v16)
          {
            int v328 = v22 ? *v325 : 0xFFFF;
            int v329 = *(unsigned __int16 *)v25;
            int v330 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v331 = v330 * v329 + ((v330 * v329) >> 16) + 1;
            unint64_t result = (v329 - HIWORD(v331)) | ((v328 - ((v328 * v330 + ((v328 * v330) >> 16) + 1) >> 16)) << 16);
            unsigned int v332 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAoverlayPDA_8925(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v329 - HIWORD(v331)), v332);
                  uint64_t v322 = v676;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v709;
                  unsigned int v332 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v332;
              }
              else
              {
                unint64_t result = PDAoverlayPDA_8925(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v329 - HIWORD(v331)), v332);
                uint64_t v322 = v676;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v709;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v321;
          unsigned int v333 = &v25[2 * v321];
          if ((unint64_t)v333 >= v12) {
            uint64_t v334 = v326;
          }
          else {
            uint64_t v334 = 0;
          }
          v325 += v322 + v334;
          int8x16_t v25 = &v333[2 * v334];
          int v7 = (_WORD *)((char *)v7 + v323);
          v14 += v324;
          --v327;
        }
        while (v327);
        if (v693)
        {
          uint64_t v335 = &v708[2 * v691];
          uint64_t v336 = v652;
          if ((unint64_t)v335 < v693) {
            uint64_t v336 = 0;
          }
          uint64_t v325 = &v707[v688 + v336];
          uint64_t v337 = v664;
          if ((unint64_t)v335 < v693) {
            uint64_t v337 = 0;
          }
          int8x16_t v25 = &v335[2 * v337];
          v12 += 2 * v337 + 2 * v691;
          v707 += v688 + v336;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v325 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v694 - 1;
      }
      while (v694 != 1);
      return result;
    case 16:
      uint64_t v338 = v27;
      uint64_t v339 = v22;
      uint64_t v653 = -(uint64_t)(v21 * v24);
      uint64_t v665 = -(v20 * v24);
      uint64_t v340 = 2 * v8;
      uint64_t v341 = 2 * v27;
      int v342 = v707;
      uint64_t v343 = -(uint64_t)v23;
      uint64_t v677 = v22;
      do
      {
        int v695 = v9;
        int v344 = v10;
        unint64_t v710 = v12;
        do
        {
          if (*v16)
          {
            int v345 = v22 ? *v342 : 0xFFFF;
            int v346 = *(unsigned __int16 *)v25;
            int v347 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v348 = v347 * v346 + ((v347 * v346) >> 16) + 1;
            unint64_t result = (v346 - HIWORD(v348)) | ((v345 - ((v345 * v347 + ((v345 * v347) >> 16) + 1) >> 16)) << 16);
            unsigned int v349 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAdarkenPDA_8927(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v346 - HIWORD(v348)), v349);
                  uint64_t v339 = v677;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v710;
                  unsigned int v349 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v349;
              }
              else
              {
                unint64_t result = PDAdarkenPDA_8927(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v346 - HIWORD(v348)), v349);
                uint64_t v339 = v677;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v710;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v338;
          uint64_t v350 = &v25[2 * v338];
          if ((unint64_t)v350 >= v12) {
            uint64_t v351 = v343;
          }
          else {
            uint64_t v351 = 0;
          }
          v342 += v339 + v351;
          int8x16_t v25 = &v350[2 * v351];
          int v7 = (_WORD *)((char *)v7 + v340);
          v14 += v341;
          --v344;
        }
        while (v344);
        if (v693)
        {
          uint64_t v352 = &v708[2 * v691];
          uint64_t v353 = v653;
          if ((unint64_t)v352 < v693) {
            uint64_t v353 = 0;
          }
          int v342 = &v707[v688 + v353];
          uint64_t v354 = v665;
          if ((unint64_t)v352 < v693) {
            uint64_t v354 = 0;
          }
          int8x16_t v25 = &v352[2 * v354];
          v12 += 2 * v354 + 2 * v691;
          v707 += v688 + v353;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v342 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v695 - 1;
      }
      while (v695 != 1);
      return result;
    case 17:
      uint64_t v355 = v27;
      uint64_t v356 = v22;
      uint64_t v654 = -(uint64_t)(v21 * v24);
      uint64_t v666 = -(v20 * v24);
      uint64_t v357 = 2 * v8;
      uint64_t v358 = 2 * v27;
      unint64_t v359 = v707;
      uint64_t v360 = -(uint64_t)v23;
      uint64_t v678 = v22;
      do
      {
        int v696 = v9;
        int v361 = v10;
        unint64_t v711 = v12;
        do
        {
          if (*v16)
          {
            int v362 = v22 ? *v359 : 0xFFFF;
            int v363 = *(unsigned __int16 *)v25;
            int v364 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v365 = v364 * v363 + ((v364 * v363) >> 16) + 1;
            unint64_t result = (v363 - HIWORD(v365)) | ((v362 - ((v362 * v364 + ((v362 * v364) >> 16) + 1) >> 16)) << 16);
            unsigned int v366 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAlightenPDA_8926(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v363 - HIWORD(v365)), v366);
                  uint64_t v356 = v678;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v711;
                  unsigned int v366 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v366;
              }
              else
              {
                unint64_t result = PDAlightenPDA_8926(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v363 - HIWORD(v365)), v366);
                uint64_t v356 = v678;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v711;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v355;
          unint64_t v367 = &v25[2 * v355];
          if ((unint64_t)v367 >= v12) {
            uint64_t v368 = v360;
          }
          else {
            uint64_t v368 = 0;
          }
          v359 += v356 + v368;
          int8x16_t v25 = &v367[2 * v368];
          int v7 = (_WORD *)((char *)v7 + v357);
          v14 += v358;
          --v361;
        }
        while (v361);
        if (v693)
        {
          int v369 = &v708[2 * v691];
          uint64_t v370 = v654;
          if ((unint64_t)v369 < v693) {
            uint64_t v370 = 0;
          }
          unint64_t v359 = &v707[v688 + v370];
          uint64_t v371 = v666;
          if ((unint64_t)v369 < v693) {
            uint64_t v371 = 0;
          }
          int8x16_t v25 = &v369[2 * v371];
          v12 += 2 * v371 + 2 * v691;
          v707 += v688 + v370;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v359 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v696 - 1;
      }
      while (v696 != 1);
      return result;
    case 18:
      uint64_t v372 = v27;
      uint64_t v373 = v22;
      uint64_t v655 = -(uint64_t)(v21 * v24);
      uint64_t v667 = -(v20 * v24);
      uint64_t v374 = 2 * v8;
      uint64_t v375 = 2 * v27;
      int64_t v376 = v707;
      uint64_t v377 = -(uint64_t)v23;
      uint64_t v679 = v22;
      do
      {
        int v697 = v9;
        int v378 = v10;
        unint64_t v712 = v12;
        do
        {
          if (*v16)
          {
            int v379 = v22 ? *v376 : 0xFFFF;
            int v380 = *(unsigned __int16 *)v25;
            int v381 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v382 = v381 * v380 + ((v381 * v380) >> 16) + 1;
            unint64_t result = (v380 - HIWORD(v382)) | ((v379 - ((v379 * v381 + ((v379 * v381) >> 16) + 1) >> 16)) << 16);
            unsigned int v383 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolordodgePDA_8928(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v380 - HIWORD(v382)), v383);
                  uint64_t v373 = v679;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v712;
                  unsigned int v383 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v383;
              }
              else
              {
                unint64_t result = PDAcolordodgePDA_8928(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v380 - HIWORD(v382)), v383);
                uint64_t v373 = v679;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v712;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v372;
          uint64_t v384 = &v25[2 * v372];
          if ((unint64_t)v384 >= v12) {
            uint64_t v385 = v377;
          }
          else {
            uint64_t v385 = 0;
          }
          v376 += v373 + v385;
          int8x16_t v25 = &v384[2 * v385];
          int v7 = (_WORD *)((char *)v7 + v374);
          v14 += v375;
          --v378;
        }
        while (v378);
        if (v693)
        {
          int v386 = &v708[2 * v691];
          uint64_t v387 = v655;
          if ((unint64_t)v386 < v693) {
            uint64_t v387 = 0;
          }
          int64_t v376 = &v707[v688 + v387];
          uint64_t v388 = v667;
          if ((unint64_t)v386 < v693) {
            uint64_t v388 = 0;
          }
          int8x16_t v25 = &v386[2 * v388];
          v12 += 2 * v388 + 2 * v691;
          v707 += v688 + v387;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v376 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v697 - 1;
      }
      while (v697 != 1);
      return result;
    case 19:
      uint64_t v389 = v27;
      uint64_t v390 = v22;
      uint64_t v656 = -(uint64_t)(v21 * v24);
      uint64_t v668 = -(v20 * v24);
      uint64_t v391 = 2 * v8;
      uint64_t v392 = 2 * v27;
      unsigned int v393 = v707;
      uint64_t v394 = -(uint64_t)v23;
      uint64_t v680 = v22;
      do
      {
        int v698 = v9;
        int v395 = v10;
        unint64_t v713 = v12;
        do
        {
          if (*v16)
          {
            int v396 = v22 ? *v393 : 0xFFFF;
            int v397 = *(unsigned __int16 *)v25;
            int v398 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v399 = v398 * v397 + ((v398 * v397) >> 16) + 1;
            unint64_t result = (v397 - HIWORD(v399)) | ((v396 - ((v396 * v398 + ((v396 * v398) >> 16) + 1) >> 16)) << 16);
            unsigned int v400 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAcolorburnPDA_8929(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v397 - HIWORD(v399)), v400);
                  uint64_t v390 = v680;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v713;
                  unsigned int v400 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v400;
              }
              else
              {
                unint64_t result = PDAcolorburnPDA_8929(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v397 - HIWORD(v399)), v400);
                uint64_t v390 = v680;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v713;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v389;
          int v401 = &v25[2 * v389];
          if ((unint64_t)v401 >= v12) {
            uint64_t v402 = v394;
          }
          else {
            uint64_t v402 = 0;
          }
          v393 += v390 + v402;
          int8x16_t v25 = &v401[2 * v402];
          int v7 = (_WORD *)((char *)v7 + v391);
          v14 += v392;
          --v395;
        }
        while (v395);
        if (v693)
        {
          int v403 = &v708[2 * v691];
          uint64_t v404 = v656;
          if ((unint64_t)v403 < v693) {
            uint64_t v404 = 0;
          }
          unsigned int v393 = &v707[v688 + v404];
          uint64_t v405 = v668;
          if ((unint64_t)v403 < v693) {
            uint64_t v405 = 0;
          }
          int8x16_t v25 = &v403[2 * v405];
          v12 += 2 * v405 + 2 * v691;
          v707 += v688 + v404;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v393 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v698 - 1;
      }
      while (v698 != 1);
      return result;
    case 20:
      uint64_t v406 = v27;
      uint64_t v407 = v22;
      uint64_t v657 = -(uint64_t)(v21 * v24);
      uint64_t v669 = -(v20 * v24);
      uint64_t v408 = 2 * v8;
      uint64_t v409 = 2 * v27;
      unsigned int v410 = v707;
      uint64_t v411 = -(uint64_t)v23;
      uint64_t v681 = v22;
      do
      {
        int v699 = v9;
        int v412 = v10;
        unint64_t v714 = v12;
        do
        {
          if (*v16)
          {
            int v413 = v22 ? *v410 : 0xFFFF;
            int v414 = *(unsigned __int16 *)v25;
            int v415 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v416 = v415 * v414 + ((v415 * v414) >> 16) + 1;
            unint64_t result = (v414 - HIWORD(v416)) | ((v413 - ((v413 * v415 + ((v413 * v415) >> 16) + 1) >> 16)) << 16);
            unsigned int v417 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAsoftlightPDA_8931(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                  uint64_t v407 = v681;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v714;
                  unsigned int v417 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v417;
              }
              else
              {
                unint64_t result = PDAsoftlightPDA_8931(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                uint64_t v407 = v681;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v714;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v406;
          int v418 = &v25[2 * v406];
          if ((unint64_t)v418 >= v12) {
            uint64_t v419 = v411;
          }
          else {
            uint64_t v419 = 0;
          }
          v410 += v407 + v419;
          int8x16_t v25 = &v418[2 * v419];
          int v7 = (_WORD *)((char *)v7 + v408);
          v14 += v409;
          --v412;
        }
        while (v412);
        if (v693)
        {
          unsigned int v420 = &v708[2 * v691];
          uint64_t v421 = v657;
          if ((unint64_t)v420 < v693) {
            uint64_t v421 = 0;
          }
          unsigned int v410 = &v707[v688 + v421];
          uint64_t v422 = v669;
          if ((unint64_t)v420 < v693) {
            uint64_t v422 = 0;
          }
          int8x16_t v25 = &v420[2 * v422];
          v12 += 2 * v422 + 2 * v691;
          v707 += v688 + v421;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v410 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v699 - 1;
      }
      while (v699 != 1);
      return result;
    case 21:
      uint64_t v423 = v27;
      uint64_t v424 = v22;
      uint64_t v658 = -(uint64_t)(v21 * v24);
      uint64_t v670 = -(v20 * v24);
      uint64_t v425 = 2 * v8;
      uint64_t v426 = 2 * v27;
      uint64_t v427 = v707;
      uint64_t v428 = -(uint64_t)v23;
      uint64_t v682 = v22;
      do
      {
        int v700 = v9;
        int v429 = v10;
        unint64_t v715 = v12;
        do
        {
          if (*v16)
          {
            int v430 = v22 ? *v427 : 0xFFFF;
            int v431 = *(unsigned __int16 *)v25;
            int v432 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v433 = v432 * v431 + ((v432 * v431) >> 16) + 1;
            unint64_t result = (v431 - HIWORD(v433)) | ((v430 - ((v430 * v432 + ((v430 * v432) >> 16) + 1) >> 16)) << 16);
            unsigned int v434 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAhardlightPDA_8930(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v431 - HIWORD(v433)), v434);
                  uint64_t v424 = v682;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v715;
                  unsigned int v434 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v434;
              }
              else
              {
                unint64_t result = PDAhardlightPDA_8930(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v431 - HIWORD(v433)), v434);
                uint64_t v424 = v682;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v715;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v423;
          unsigned int v435 = &v25[2 * v423];
          if ((unint64_t)v435 >= v12) {
            uint64_t v436 = v428;
          }
          else {
            uint64_t v436 = 0;
          }
          v427 += v424 + v436;
          int8x16_t v25 = &v435[2 * v436];
          int v7 = (_WORD *)((char *)v7 + v425);
          v14 += v426;
          --v429;
        }
        while (v429);
        if (v693)
        {
          __int16 v437 = &v708[2 * v691];
          uint64_t v438 = v658;
          if ((unint64_t)v437 < v693) {
            uint64_t v438 = 0;
          }
          uint64_t v427 = &v707[v688 + v438];
          uint64_t v439 = v670;
          if ((unint64_t)v437 < v693) {
            uint64_t v439 = 0;
          }
          int8x16_t v25 = &v437[2 * v439];
          v12 += 2 * v439 + 2 * v691;
          v707 += v688 + v438;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v427 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v700 - 1;
      }
      while (v700 != 1);
      return result;
    case 22:
      uint64_t v440 = v27;
      uint64_t v441 = v22;
      uint64_t v659 = -(uint64_t)(v21 * v24);
      uint64_t v671 = -(v20 * v24);
      uint64_t v442 = 2 * v8;
      uint64_t v443 = 2 * v27;
      uint64_t v444 = v707;
      uint64_t v445 = -(uint64_t)v23;
      uint64_t v683 = v22;
      do
      {
        int v701 = v9;
        int v446 = v10;
        unint64_t v716 = v12;
        do
        {
          if (*v16)
          {
            int v447 = v22 ? *v444 : 0xFFFF;
            int v448 = *(unsigned __int16 *)v25;
            int v449 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v450 = v449 * v448 + ((v449 * v448) >> 16) + 1;
            unint64_t result = (v448 - HIWORD(v450)) | ((v447 - ((v447 * v449 + ((v447 * v449) >> 16) + 1) >> 16)) << 16);
            unsigned int v451 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAdifferencePDA_8932(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v448 - HIWORD(v450)), v451);
                  uint64_t v441 = v683;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v716;
                  unsigned int v451 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v451;
              }
              else
              {
                unint64_t result = PDAdifferencePDA_8932(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v448 - HIWORD(v450)), v451);
                uint64_t v441 = v683;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v716;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v440;
          __int16 v452 = &v25[2 * v440];
          if ((unint64_t)v452 >= v12) {
            uint64_t v453 = v445;
          }
          else {
            uint64_t v453 = 0;
          }
          v444 += v441 + v453;
          int8x16_t v25 = &v452[2 * v453];
          int v7 = (_WORD *)((char *)v7 + v442);
          v14 += v443;
          --v446;
        }
        while (v446);
        if (v693)
        {
          uint64_t v454 = &v708[2 * v691];
          uint64_t v455 = v659;
          if ((unint64_t)v454 < v693) {
            uint64_t v455 = 0;
          }
          uint64_t v444 = &v707[v688 + v455];
          uint64_t v456 = v671;
          if ((unint64_t)v454 < v693) {
            uint64_t v456 = 0;
          }
          int8x16_t v25 = &v454[2 * v456];
          v12 += 2 * v456 + 2 * v691;
          v707 += v688 + v455;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v444 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v701 - 1;
      }
      while (v701 != 1);
      return result;
    case 23:
      uint64_t v457 = v27;
      uint64_t v458 = v22;
      uint64_t v459 = v24;
      uint64_t v460 = -(uint64_t)v23;
      uint64_t v461 = -(v20 * v24);
      uint64_t v462 = -(uint64_t)(v21 * v459);
      uint64_t v463 = 2 * v8;
      uint64_t v464 = 2 * v27;
      unsigned int v465 = v707;
      break;
    case 24:
      uint64_t v487 = v27;
      uint64_t v488 = v22;
      uint64_t v660 = -(uint64_t)(v21 * v24);
      uint64_t v672 = -(v20 * v24);
      uint64_t v489 = 2 * v8;
      uint64_t v490 = 2 * v27;
      int v491 = v707;
      uint64_t v492 = -(uint64_t)v23;
      uint64_t v684 = v22;
      do
      {
        int v702 = v9;
        int v493 = v10;
        unint64_t v717 = v12;
        do
        {
          if (*v16)
          {
            int v494 = v22 ? *v491 : 0xFFFF;
            int v495 = *(unsigned __int16 *)v25;
            int v496 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v497 = v496 * v495 + ((v496 * v495) >> 16) + 1;
            unint64_t result = (v495 - HIWORD(v497)) | ((v494 - ((v494 * v496 + ((v494 * v496) >> 16) + 1) >> 16)) << 16);
            unsigned int v498 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAhuePDA_8933(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v495 - HIWORD(v497)), v498);
                  uint64_t v488 = v684;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v717;
                  unsigned int v498 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v498;
              }
              else
              {
                unint64_t result = PDAhuePDA_8933(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v495 - HIWORD(v497)), v498);
                uint64_t v488 = v684;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v717;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v487;
          uint64_t v499 = &v25[2 * v487];
          if ((unint64_t)v499 >= v12) {
            uint64_t v500 = v492;
          }
          else {
            uint64_t v500 = 0;
          }
          v491 += v488 + v500;
          int8x16_t v25 = &v499[2 * v500];
          int v7 = (_WORD *)((char *)v7 + v489);
          v14 += v490;
          --v493;
        }
        while (v493);
        if (v693)
        {
          BOOL v501 = &v708[2 * v691];
          uint64_t v502 = v660;
          if ((unint64_t)v501 < v693) {
            uint64_t v502 = 0;
          }
          int v491 = &v707[v688 + v502];
          uint64_t v503 = v672;
          if ((unint64_t)v501 < v693) {
            uint64_t v503 = 0;
          }
          int8x16_t v25 = &v501[2 * v503];
          v12 += 2 * v503 + 2 * v691;
          v707 += v688 + v502;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v491 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v702 - 1;
      }
      while (v702 != 1);
      return result;
    case 25:
      uint64_t v504 = v27;
      uint64_t v505 = v22;
      uint64_t v661 = -(uint64_t)(v21 * v24);
      uint64_t v673 = -(v20 * v24);
      uint64_t v506 = 2 * v8;
      uint64_t v507 = 2 * v27;
      unsigned int v508 = v707;
      uint64_t v509 = -(uint64_t)v23;
      uint64_t v685 = v22;
      do
      {
        int v703 = v9;
        int v510 = v10;
        unint64_t v718 = v12;
        do
        {
          if (*v16)
          {
            int v511 = v22 ? *v508 : 0xFFFF;
            int v512 = *(unsigned __int16 *)v25;
            int v513 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v514 = v513 * v512 + ((v513 * v512) >> 16) + 1;
            unint64_t result = (v512 - HIWORD(v514)) | ((v511 - ((v511 * v513 + ((v511 * v513) >> 16) + 1) >> 16)) << 16);
            unsigned int v515 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAhuePDA_8933(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v512 - HIWORD(v514)), v515);
                  uint64_t v505 = v685;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v718;
                  unsigned int v515 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v515;
              }
              else
              {
                unint64_t result = PDAhuePDA_8933(*(unsigned __int16 *)v14, 0xFFFFu, (unsigned __int16)(v512 - HIWORD(v514)), v515);
                uint64_t v505 = v685;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v718;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v504;
          __n128 v516 = &v25[2 * v504];
          if ((unint64_t)v516 >= v12) {
            uint64_t v517 = v509;
          }
          else {
            uint64_t v517 = 0;
          }
          v508 += v505 + v517;
          int8x16_t v25 = &v516[2 * v517];
          int v7 = (_WORD *)((char *)v7 + v506);
          v14 += v507;
          --v510;
        }
        while (v510);
        if (v693)
        {
          int32x2_t v518 = &v708[2 * v691];
          uint64_t v519 = v661;
          if ((unint64_t)v518 < v693) {
            uint64_t v519 = 0;
          }
          unsigned int v508 = &v707[v688 + v519];
          uint64_t v520 = v673;
          if ((unint64_t)v518 < v693) {
            uint64_t v520 = 0;
          }
          int8x16_t v25 = &v518[2 * v520];
          v12 += 2 * v520 + 2 * v691;
          v707 += v688 + v519;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v508 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v703 - 1;
      }
      while (v703 != 1);
      return result;
    case 26:
      uint64_t v521 = v27;
      uint64_t v522 = v22;
      uint64_t v662 = -(uint64_t)(v21 * v24);
      uint64_t v674 = -(v20 * v24);
      uint64_t v523 = 2 * v8;
      uint64_t v524 = 2 * v27;
      uint64_t v525 = v707;
      uint64_t v526 = -(uint64_t)v23;
      uint64_t v686 = v22;
      do
      {
        int v704 = v9;
        int v527 = v10;
        unint64_t v719 = v12;
        do
        {
          if (*v16)
          {
            int v528 = v22 ? *v525 : 0xFFFF;
            int v529 = *(unsigned __int16 *)v25;
            int v530 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v531 = v530 * v529 + ((v530 * v529) >> 16) + 1;
            unint64_t result = (v529 - HIWORD(v531)) | ((v528 - ((v528 * v530 + ((v528 * v530) >> 16) + 1) >> 16)) << 16);
            unsigned int v532 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_8935((unsigned __int16)(v529 - HIWORD(v531)), v532, *(unsigned __int16 *)v14, (unsigned __int16)*v7);
                  uint64_t v522 = v686;
                  int v22 = v721;
                  int v8 = v722;
                  unint64_t v12 = v719;
                  unsigned int v532 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v532;
              }
              else
              {
                unint64_t result = PDAluminosityPDA_8935((unsigned __int16)(v529 - HIWORD(v531)), v532, *(unsigned __int16 *)v14, 0xFFFFu);
                uint64_t v522 = v686;
                int v22 = v721;
                int v8 = v722;
                unint64_t v12 = v719;
                *(_WORD *)uint64_t v14 = result;
              }
            }
          }
          v16 += v521;
          __n128 v533 = &v25[2 * v521];
          if ((unint64_t)v533 >= v12) {
            uint64_t v534 = v526;
          }
          else {
            uint64_t v534 = 0;
          }
          v525 += v522 + v534;
          int8x16_t v25 = &v533[2 * v534];
          int v7 = (_WORD *)((char *)v7 + v523);
          v14 += v524;
          --v527;
        }
        while (v527);
        if (v693)
        {
          uint64_t v535 = &v708[2 * v691];
          uint64_t v536 = v662;
          if ((unint64_t)v535 < v693) {
            uint64_t v536 = 0;
          }
          uint64_t v525 = &v707[v688 + v536];
          uint64_t v537 = v674;
          if ((unint64_t)v535 < v693) {
            uint64_t v537 = 0;
          }
          int8x16_t v25 = &v535[2 * v537];
          v12 += 2 * v537 + 2 * v691;
          v707 += v688 + v536;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v691;
          v525 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v704 - 1;
      }
      while (v704 != 1);
      return result;
    case 27:
      uint64_t v538 = v27;
      uint64_t v539 = v22;
      uint64_t v663 = -(uint64_t)(v21 * v24);
      uint64_t v675 = -(v20 * v24);
      uint64_t v540 = 2 * v8;
      uint64_t v541 = 2 * v27;
      unint64_t v542 = v707;
      uint64_t v543 = -(uint64_t)v23;
      uint64_t v720 = v27;
      uint64_t v687 = v540;
      do
      {
        int v705 = v9;
        int v544 = v10;
        do
        {
          if (*v16)
          {
            int v545 = v22 ? *v542 : 0xFFFF;
            int v546 = *(unsigned __int16 *)v25;
            int v547 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v548 = v547 * v546 + ((v547 * v546) >> 16) + 1;
            unint64_t result = (v546 - HIWORD(v548)) | ((v545 - ((v545 * v547 + ((v545 * v547) >> 16) + 1) >> 16)) << 16);
            unsigned int v549 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*v7)
                {
                  unint64_t result = PDAluminosityPDA_8935(*(unsigned __int16 *)v14, (unsigned __int16)*v7, (unsigned __int16)(v546 - HIWORD(v548)), v549);
                  uint64_t v538 = v720;
                  uint64_t v540 = v687;
                  int v22 = v721;
                  int v8 = v722;
                  unsigned int v549 = WORD1(result);
                }
                *(_WORD *)uint64_t v14 = result;
                *int v7 = v549;
              }
              else
              {
                unsigned int v550 = (unsigned __int16)(v546 - HIWORD(v548));
                if (v550 >= WORD1(result)) {
                  LOWORD(v550) = WORD1(result);
                }
                unint64_t v551 = *(unsigned __int16 *)v14 * (unint64_t)(v549 ^ 0xFFFF) + 0x8000;
                *(_WORD *)uint64_t v14 = v550 + (((v551 >> 16) + v551) >> 16);
              }
            }
          }
          v16 += v538;
          uint64_t v552 = &v25[2 * v538];
          if ((unint64_t)v552 >= v12) {
            uint64_t v553 = v543;
          }
          else {
            uint64_t v553 = 0;
          }
          v542 += v539 + v553;
          int8x16_t v25 = &v552[2 * v553];
          int v7 = (_WORD *)((char *)v7 + v540);
          v14 += v541;
          --v544;
        }
        while (v544);
        if (v693)
        {
          int v554 = &v708[2 * v20];
          uint64_t v555 = v663;
          if ((unint64_t)v554 < v693) {
            uint64_t v555 = 0;
          }
          unint64_t v542 = &v707[v688 + v555];
          uint64_t v556 = v675;
          if ((unint64_t)v554 < v693) {
            uint64_t v556 = 0;
          }
          int8x16_t v25 = &v554[2 * v556];
          v12 += 2 * v556 + 2 * v20;
          v707 += v688 + v555;
          uint64_t v708 = v25;
        }
        else
        {
          v25 += 2 * v20;
          v542 += v688;
        }
        int v10 = v692;
        v16 += v690;
        v14 += 2 * v689;
        v7 += v706;
        int v9 = v705 - 1;
      }
      while (v705 != 1);
      return result;
    default:
      return result;
  }
  do
  {
    int v466 = v10;
    do
    {
      if (*v16)
      {
        int v467 = v22 ? *v465 : 0xFFFF;
        int v468 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        unsigned int v469 = *(unsigned __int16 *)v25
             - ((v468 * *(unsigned __int16 *)v25 + ((v468 * *(unsigned __int16 *)v25) >> 16) + 1) >> 16);
        unsigned int v470 = v469 | ((v467 - ((v467 * v468 + ((v467 * v468) >> 16) + 1) >> 16)) << 16);
        unsigned int v471 = HIWORD(v470);
        if (HIWORD(v470))
        {
          if (v8)
          {
            unsigned int v472 = (unsigned __int16)*v7;
            if (!*v7) {
              goto LABEL_627;
            }
          }
          else
          {
            unsigned int v472 = 0xFFFF;
          }
          if ((unsigned __int16)v469 >= HIWORD(v470)) {
            uint64_t v473 = v471;
          }
          else {
            uint64_t v473 = (unsigned __int16)v469;
          }
          if (*(unsigned __int16 *)v14 >= v472) {
            uint64_t v474 = v472;
          }
          else {
            uint64_t v474 = *(unsigned __int16 *)v14;
          }
          int64_t v475 = 0xFFFF * (v474 + v473) - 2 * v473 * (unint64_t)v474;
          int v8 = v722;
          if (v475 <= 4294868992) {
            unint64_t v476 = v475 + 0x8000;
          }
          else {
            unint64_t v476 = 4294868992;
          }
          unint64_t v477 = v476 + (v476 >> 16);
          if (v722)
          {
            unint64_t v478 = v477 >> 16;
            int v22 = v721;
            int v8 = v722;
            int64_t v479 = 0xFFFF * (v472 + (unint64_t)v471) - v472 * (unint64_t)v471;
            if (v479 <= 4294868992) {
              unint64_t v480 = v479 + 0x8000;
            }
            else {
              unint64_t v480 = 4294868992;
            }
            unsigned int v470 = ((v480 >> 16) + v480) & 0xFFFF0000 | v478;
            unsigned int v471 = HIWORD(v470);
LABEL_627:
            *(_WORD *)uint64_t v14 = v470;
            *int v7 = v471;
            goto LABEL_629;
          }
          *(_WORD *)uint64_t v14 = WORD1(v477);
          int v22 = v721;
        }
      }
LABEL_629:
      v16 += v457;
      unint64_t result = (unint64_t)&v25[2 * v457];
      int v481 = &v465[v458];
      if (result >= v12) {
        uint64_t v482 = v460;
      }
      else {
        uint64_t v482 = 0;
      }
      unsigned int v465 = &v481[v482];
      int8x16_t v25 = (char *)(result + 2 * v482);
      int v7 = (_WORD *)((char *)v7 + v463);
      v14 += v464;
      --v466;
    }
    while (v466);
    if (v28)
    {
      __n128 v483 = &v708[2 * v20];
      if ((unint64_t)v483 >= v28) {
        uint64_t v484 = v462;
      }
      else {
        uint64_t v484 = 0;
      }
      uint64_t v485 = (uint64_t)&v707[v21 + v484];
      if ((unint64_t)v483 >= v28) {
        uint64_t v486 = v461;
      }
      else {
        uint64_t v486 = 0;
      }
      unint64_t result = v12 + 2 * v486;
      int8x16_t v25 = &v483[2 * v486];
      unint64_t v12 = result + 2 * v20;
      uint64_t v707 = (_WORD *)v485;
      uint64_t v708 = v25;
      unsigned int v465 = (unsigned __int16 *)v485;
    }
    else
    {
      v25 += 2 * v20;
      v465 += v21;
    }
    v16 += v33;
    v14 += 2 * v34;
    v7 += v706;
    --v9;
  }
  while (v9);
  return result;
}

_DWORD *w16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8 = PIXELCONSTANT_8939(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDC60;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = (unsigned __int16)v8 | ((unsigned __int16)v8 << 16);
    *((void *)a2 + 4) = a2 + 12;
    if (HIWORD(v8) == 0xFFFF)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = v8 & 0xFFFF0000 | HIWORD(v8);
      *((void *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t PIXELCONSTANT_8939(float *a1, int a2, float *a3, float a4)
{
  float v4 = *a1;
  float v5 = a1[1];
  float v6 = v5;
  if (v5 >= a4)
  {
    float v6 = a4;
    if (v4 > a4) {
      float v6 = *a1;
    }
  }
  float v7 = a1[3];
  float v8 = v6 * a1[2];
  if (a3) {
    int v9 = a2;
  }
  else {
    int v9 = 0;
  }
  if (v9 == 4)
  {
    float v15 = a3[4];
    float v16 = *a3;
    float v17 = a1[1];
    if (v15 <= v5)
    {
      float v17 = a3[4];
      if (v15 < v4) {
        float v17 = *a1;
      }
    }
    float v19 = a3[1];
    float v18 = a3[2];
    float v20 = a1[1];
    if (v16 <= v5)
    {
      float v20 = *a3;
      if (v16 < v4) {
        float v20 = *a1;
      }
    }
    if (v19 < v4) {
      float v21 = *a1;
    }
    else {
      float v21 = a3[1];
    }
    if (v19 > v5) {
      float v21 = a1[1];
    }
    if (v18 < v4) {
      float v22 = *a1;
    }
    else {
      float v22 = a3[2];
    }
    BOOL v23 = v18 <= v5;
    float v24 = v5 - (float)(a1[4] * v20);
    if (v23) {
      float v5 = v22;
    }
    float v25 = (float)((float)(v24 - (float)(a1[5] * v21)) - (float)(a1[6] * v5)) - v17;
    if (v25 >= v4) {
      float v4 = v7 + (float)(v25 * v8);
    }
    goto LABEL_46;
  }
  if (v9 == 3)
  {
    float v11 = a3[1];
    float v12 = a1[1];
    if (*a3 <= v5)
    {
      float v12 = *a3;
      if (*a3 < v4) {
        float v12 = *a1;
      }
    }
    float v13 = a3[2];
    float v14 = a1[1];
    if (v11 <= v5)
    {
      float v14 = a3[1];
      if (v11 < v4) {
        float v14 = *a1;
      }
    }
    if (v13 >= v4) {
      float v4 = a3[2];
    }
    if (v13 > v5) {
      float v4 = a1[1];
    }
    float v4 = (float)((float)(v14 * a1[5]) + (float)(a1[4] * v12)) + (float)(a1[6] * v4);
    goto LABEL_26;
  }
  int v10 = 0;
  if (v9 == 1)
  {
    if (*a3 >= v4) {
      float v4 = *a3;
    }
    if (*a3 > v5) {
      float v4 = a1[1];
    }
LABEL_26:
    float v4 = v7 + (float)(v4 * v8);
LABEL_46:
    int v10 = (int)v4;
  }
  return v10 | ((int)(float)(v7 + v8) << 16);
}

uint64_t W16_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)int v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x1000000)
  {
    if (*(void *)(v5 + 16))
    {
      float v14 = w16_shade_radial_W;
    }
    else if (*(void *)(v5 + 24))
    {
      float v14 = w16_shade_conic_W;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      float v14 = w16_shade_axial_W;
    }
    else
    {
      float v14 = w16_shade_custom_W;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 1, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 960)
    {
      float v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 1, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    float v16 = malloc_type_malloc(4 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  W16_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void W16_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v457 = *MEMORY[0x1E4F143B8];
  uint64_t v446 = *(unsigned int *)(a1 + 4);
  uint64_t v443 = (int)v446;
  unint64_t v4 = ((int)v446 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 > 0x1FFFFFF) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  float v9 = *(float *)(a2 + 184);
  unsigned int v451 = *(int **)(a1 + 136);
  uint64_t v10 = *(void *)(a2 + 104);
  uint64_t v453 = *(void *)(a2 + 96);
  uint64_t v454 = v10;
  uint64_t v12 = *(int *)(a1 + 24);
  unint64_t v11 = *(int *)(a1 + 28);
  uint64_t v13 = *(int *)(a1 + 16);
  uint64_t v455 = *(int *)(a1 + 20);
  uint64_t v456 = v7;
  uint64_t v14 = *(int *)(a1 + 12);
  int v452 = *(_DWORD *)(a1 + 8);
  uint64_t v439 = a1;
  uint64_t v15 = *(int *)(a2 + 16);
  uint64_t v16 = (v15 + 6) * v4;
  if (v16 > 65439)
  {
    long long v20 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
    long long v18 = v20;
    if (!v20) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    long long v18 = (char *)&v435 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v17);
    long long v20 = 0;
  }
  int v448 = a3;
  unint64_t v21 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v22 = v21 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(void *)(a2 + 160) = v22;
  if (v15) {
    uint64_t v23 = 4 * v4;
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = a2;
  unint64_t v25 = v22 + v23;
  uint64_t v26 = v8 + (v12 - 1) * v11;
  unint64_t v27 = v11 >> 1;
  *(void *)(v24 + 144) = v21;
  *(void *)(v24 + 152) = v25;
  uint64_t v445 = v24;
  if (v456)
  {
    unint64_t v28 = (unint64_t)*(int *)(v439 + 32) >> 1;
    long long v29 = (unsigned __int16 *)(v456 + 2 * (v14 + v28 * v13));
    uint64_t v30 = v439;
    uint64_t v449 = v28 - v443;
    uint64_t v31 = v443;
    uint64_t v32 = 1;
  }
  else
  {
    long long v29 = 0;
    uint64_t v449 = 0;
    uint64_t v32 = 0;
    uint64_t v30 = v439;
    uint64_t v31 = v443;
  }
  int v450 = (int)(v9 * 65535.9);
  uint64_t v33 = v26 + 2 * v455;
  long long v34 = (unsigned __int16 *)(v8 + 2 * (v14 + v27 * v13));
  uint64_t v447 = v27 - v31;
  uint64_t v35 = *(int *)(v30 + 104);
  int v36 = *(_DWORD *)(v30 + 108);
  int v37 = *(unsigned __int8 *)(v30 + 2);
  if (v37 == 6 || v37 == 1)
  {
    uint64_t v38 = v445;
    uint64_t v39 = v453;
    uint64_t v40 = v454;
    if (v451)
    {
      unint64_t v435 = v27;
      uint64_t v438 = v20;
      LODWORD(v455) = 0;
      uint64_t v41 = *(int *)(v30 + 124);
      uint64_t v42 = 0;
      int v43 = (unsigned __int8 *)v451 + v35 + (int)v41 * (uint64_t)v36;
      uint64_t v31 = v443;
      uint64_t v44 = v41 - v443;
      uint64_t v45 = v446;
      goto LABEL_24;
    }
    goto LABEL_21;
  }
  uint64_t v438 = v20;
  uint64_t v40 = v454;
  if (v451)
  {
    uint64_t v436 = v33;
    uint64_t v437 = v32;
    shape_enum_clip_alloc((uint64_t)v20, v19, v451, 1, 1, 1, v35, v36, v446, v452);
    if (!v46) {
      goto LABEL_619;
    }
    uint64_t v42 = v46;
    unint64_t v435 = v27;
    LODWORD(v455) = 0;
    uint64_t v47 = (int)((v15 * v4 + 15) & 0xFFFFFFF0);
    if (!v15) {
      uint64_t v47 = 4 * v4;
    }
    uint64_t v48 = v443;
    uint64_t v44 = -v443;
    int v43 = (unsigned __int8 *)(v25 + v47 + 16);
    uint64_t v38 = v445;
    uint64_t v45 = v446;
    uint64_t v49 = v456;
    uint64_t v39 = v453;
LABEL_620:
    uint64_t v454 = v449 + v48;
LABEL_621:
    uint64_t v429 = v44;
    while (1)
    {
      int v430 = *((_DWORD *)v43 - 4);
      int v431 = v430 - v455;
      if (v430 > (int)v455)
      {
        v452 -= v431;
        if (v452 < 1) {
          goto LABEL_617;
        }
        uint64_t v44 = v429;
        v39 += *(void *)(v38 + 128) * v431;
        v40 += *(void *)(v38 + 136) * v431;
        v34 += v435 * v431;
        uint64_t v434 = v454 * v431;
        if (!v49) {
          uint64_t v434 = 0;
        }
        v29 += v434;
        LODWORD(v455) = v430;
        goto LABEL_621;
      }
      if ((int)v455 < *((_DWORD *)v43 - 3) + v430) {
        break;
      }
      int v432 = v42;
      int v433 = shape_enum_clip_scan((uint64_t)v42, (_DWORD *)v43 - 4);
      uint64_t v42 = v432;
      uint64_t v49 = v456;
      if (!v433) {
        goto LABEL_617;
      }
    }
    uint64_t v31 = v443;
    uint64_t v32 = v437;
    uint64_t v33 = v436;
    uint64_t v44 = v429;
  }
  else
  {
    unint64_t v435 = v27;
    int v43 = 0;
    uint64_t v42 = 0;
    uint64_t v44 = 0;
    LODWORD(v455) = 0;
    uint64_t v38 = v445;
    uint64_t v45 = v446;
    uint64_t v39 = v453;
  }
LABEL_24:
  int v50 = v450 ^ 0xFFFF;
  int32x2_t v51 = vdup_n_s32(v450 ^ 0xFFFFu);
  uint64_t v442 = (v45 - 1) + 1;
  uint64_t v440 = -v31;
  uint64_t v436 = v33;
  uint64_t v441 = (unsigned __int16 *)(v33 - 2);
  uint64_t v437 = v32;
  uint64_t v52 = 2 * v32;
  int32x2_t v53 = vdup_n_s32(0x101u);
  uint64_t v54 = v42;
  uint64_t v444 = v44;
  while (2)
  {
    unsigned int v451 = v54;
    uint64_t v55 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v38;
    uint64_t v453 = v39;
    uint64_t v454 = v40;
    v55(v38, v39, v40, v45);
    uint64_t v57 = *(unsigned __int16 **)(v38 + 160);
    uint64_t v58 = *(unsigned char **)(v38 + 144);
    unsigned int v59 = *(_DWORD *)(v38 + 8);
    if (v59 == *(_DWORD *)(v38 + 12))
    {
      if (v450 == 0xFFFF)
      {
        uint64_t v49 = v456;
      }
      else
      {
        int v60 = v45;
        int v61 = *(unsigned char **)(v38 + 144);
        uint64_t v49 = v456;
        do
        {
          if (*v61) {
            *(_DWORD *)uint64_t v57 = ((unsigned __int16)*(_DWORD *)v57
          }
                            - (((unsigned __int16)*(_DWORD *)v57 * v50
                              + (((unsigned __int16)*(_DWORD *)v57 * v50) >> 16)
                              + 1) >> 16)) | ((HIWORD(*(_DWORD *)v57)
                                             - ((HIWORD(*(_DWORD *)v57) * v50
                                               + ((HIWORD(*(_DWORD *)v57) * v50) >> 16)
                                               + 1) >> 16)) << 16);
          ++v61;
          v57 += 2;
          --v60;
        }
        while (v60);
        v57 += 2 * v440;
        v58 += v442 + v440;
      }
    }
    else
    {
      uint64_t v62 = *(void *)(v38 + 152);
      int v63 = HIWORD(v59) & 0x3F;
      if (v63 == 16)
      {
        uint64_t v49 = v456;
        uint64_t v71 = 0;
        if (v450 == 0xFFFF)
        {
          do
          {
            if (v58[v71]) {
              *(_DWORD *)&v57[2 * v71] = *(_DWORD *)(v62 + 4 * v71);
            }
            ++v71;
          }
          while (v45 != v71);
        }
        else
        {
          do
          {
            if (v58[v71])
            {
              int v72 = (unsigned __int16)*(_DWORD *)(v62 + 4 * v71);
              *(_DWORD *)&v57[2 * v71] = (v72 - ((v72 * v50 + ((v72 * v50) >> 16) + 1) >> 16)) | ((HIWORD(*(_DWORD *)(v62 + 4 * v71)) - ((HIWORD(*(_DWORD *)(v62 + 4 * v71)) * v50 + ((HIWORD(*(_DWORD *)(v62 + 4 * v71)) * v50) >> 16) + 1) >> 16)) << 16);
            }
            ++v71;
          }
          while (v45 != v71);
        }
      }
      else
      {
        uint64_t v49 = v456;
        if (v63 == 32)
        {
          if (v450 == 0xFFFF)
          {
            uint64_t v78 = 0;
            uint64_t v79 = (float *)(v62 + 4);
            do
            {
              if (v58[v78])
              {
                float v80 = *v79;
                if (*v79 <= 0.0)
                {
                  int v84 = 0;
                }
                else
                {
                  int v81 = (int)(float)((float)(v80 * 65535.0) + 0.5);
                  float v82 = *(v79 - 1);
                  if (v80 > 1.0)
                  {
                    int v81 = 0xFFFF;
                    float v80 = 1.0;
                  }
                  int v83 = v81;
                  if (v82 <= v80)
                  {
                    if (v82 >= 0.0) {
                      int v83 = (int)(float)((float)(v82 * 65535.0) + 0.5);
                    }
                    else {
                      int v83 = 0;
                    }
                  }
                  int v84 = v83 | (v81 << 16);
                }
                *(_DWORD *)&v57[2 * v78] = v84;
              }
              v79 += 2;
              ++v78;
            }
            while (v45 != v78);
          }
          else
          {
            uint64_t v64 = 0;
            int v65 = (float *)(v62 + 4);
            do
            {
              if (v58[v64])
              {
                float v66 = *v65;
                if (*v65 <= 0.0)
                {
                  unsigned int v70 = 0;
                }
                else
                {
                  int v67 = (int)(float)((float)(v66 * 65535.0) + 0.5);
                  float v68 = *(v65 - 1);
                  if (v66 > 1.0)
                  {
                    int v67 = 0xFFFF;
                    float v66 = 1.0;
                  }
                  int v69 = v67;
                  if (v68 <= v66)
                  {
                    if (v68 >= 0.0) {
                      int v69 = (int)(float)((float)(v68 * 65535.0) + 0.5);
                    }
                    else {
                      int v69 = 0;
                    }
                  }
                  unsigned int v70 = (v69 - ((v69 * v50 + ((v69 * v50) >> 16) + 1) >> 16)) | ((v67
                                                                                              - ((v67 * v50
                                                                                                + ((v67 * v50) >> 16)
                                                                                                + 1) >> 16)) << 16);
                }
                *(_DWORD *)&v57[2 * v64] = v70;
              }
              v65 += 2;
              ++v64;
            }
            while (v45 != v64);
          }
        }
        else if (v450 == 0xFFFF)
        {
          uint64_t v85 = 0;
          do
          {
            if (v58[v85]) {
              *(_DWORD *)&v57[2 * v85] = *(_DWORD *)(v62 + 4 * v85) & 0xFF000000 | (*(_DWORD *)(v62 + 4 * v85) >> 8) & 0xFFFF0000 | (*(_DWORD *)(v62 + 4 * v85) << 8) | *(_DWORD *)(v62 + 4 * v85);
            }
            ++v85;
          }
          while (v45 != v85);
        }
        else
        {
          uint64_t v73 = 0;
          do
          {
            if (v58[v73])
            {
              v56.i32[0] = *(_DWORD *)(v62 + 4 * v73);
              v74.i32[0] = vshr_n_u32((uint32x2_t)v56, 0x18uLL).u32[0];
              v74.i32[1] = vdup_n_s32(*(_DWORD *)(v62 + 4 * v73)).u8[4];
              int32x2_t v75 = vmul_s32(v74, v53);
              uint32x2_t v76 = (uint32x2_t)vmul_s32(v75, v51);
              int32x2_t v56 = (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v76, v76, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL);
              int32x2_t v77 = vsub_s32(v75, v56);
              *(_DWORD *)&v57[2 * v73] = v77.i32[1] | (v77.i32[0] << 16);
            }
            ++v73;
          }
          while (v45 != v73);
        }
      }
    }
    switch(v448)
    {
      case 0:
        uint64_t v86 = v43 != 0;
        int v87 = v45;
        uint64_t v88 = v43;
        if (v49)
        {
          uint64_t v89 = v454;
          do
          {
            int v90 = *v58;
            if (*v58)
            {
              if (v43) {
                int v90 = ((unsigned __int16)(*v88 * (_WORD)v90 + ((*v88 * v90) >> 8) + 1) >> 8);
              }
              if (v90)
              {
                if (v90 == 255)
                {
                  LOWORD(v91) = 0;
                  *long long v34 = 0;
                }
                else
                {
                  unsigned int v92 = bswap32(*v34) >> 16;
                  unsigned int v93 = bswap32(*v29) >> 16;
                  int v94 = v90 | (v90 << 8);
                  *long long v34 = bswap32(v92 - ((v94 * v92 + ((v94 * v92) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v91 = bswap32(v93 - ((v94 * v93 + ((v94 * v93) >> 16) + 1) >> 16)) >> 16;
                }
                *long long v29 = v91;
              }
            }
            ++v58;
            v88 += v86;
            ++v34;
            ++v29;
            --v87;
          }
          while (v87);
        }
        else
        {
          uint64_t v89 = v454;
          do
          {
            int v370 = *v58;
            if (*v58)
            {
              if (v43) {
                int v370 = ((unsigned __int16)(*v88 * (_WORD)v370 + ((*v88 * v370) >> 8) + 1) >> 8);
              }
              if (v370)
              {
                if (v370 == 255)
                {
                  LOWORD(v371) = 0;
                }
                else
                {
                  unsigned int v372 = bswap32(*v34) >> 16;
                  unsigned int v371 = bswap32(v372 - ((257 * v370 * v372 + ((257 * v370 * v372) >> 16) + 1) >> 16)) >> 16;
                }
                *long long v34 = v371;
              }
            }
            ++v58;
            v88 += v86;
            ++v34;
            --v87;
          }
          while (v87);
        }
        int v43 = &v88[v44];
        goto LABEL_568;
      case 1:
        int v95 = *v58;
        if (v49)
        {
          unsigned int v96 = v58 + 1;
          unsigned int v97 = v29 - 1;
          int v98 = v34 - 1;
          int v99 = v45;
          if (v43)
          {
            uint64_t v100 = v453;
            do
            {
              if (v95)
              {
                unsigned int v101 = *v43 * v95 + ((*v43 * v95) >> 8) + 1;
                if (BYTE1(v101))
                {
                  if (BYTE1(v101) == 255)
                  {
                    unsigned int v102 = *(_DWORD *)v57;
                    unsigned int v103 = *(_DWORD *)v57;
                  }
                  else
                  {
                    int v104 = 257 * (v101 >> 8);
                    unsigned int v105 = (unsigned __int16)v104;
                    int v106 = (unsigned __int16)~(_WORD)v104;
                    unsigned int v107 = (unsigned __int16)*(_DWORD *)v57 * v105 + (bswap32(v98[1]) >> 16) * v106;
                    unsigned int v103 = HIWORD(*(_DWORD *)v57) * (v106 | v105) + ((HIWORD(*(_DWORD *)v57) * (v106 | v105)) >> 16) + 1;
                    unsigned int v102 = (v107 + HIWORD(v107) + 1) >> 16;
                  }
                  v98[1] = bswap32(v102) >> 16;
                  v97[1] = bswap32(v103);
                }
              }
              int v108 = *v96++;
              int v95 = v108;
              v57 += 2;
              ++v43;
              ++v97;
              ++v98;
              --v99;
            }
            while (v99);
            goto LABEL_122;
          }
          uint64_t v100 = v453;
          do
          {
            if (v95)
            {
              if (v95 == 255)
              {
                unsigned int v395 = *(_DWORD *)v57;
                unsigned int v396 = *(_DWORD *)v57;
              }
              else
              {
                int v397 = v95 | (v95 << 8);
                unsigned int v398 = bswap32(v98[1]) >> 16;
                unsigned int v399 = (unsigned __int16)*(_DWORD *)v57 * v397
                     + v398 * (v397 ^ 0xFFFF)
                     + (((unsigned __int16)*(_DWORD *)v57 * v397 + v398 * (v397 ^ 0xFFFF)) >> 16)
                     + 1;
                unsigned int v396 = 0xFFFF * HIWORD(*(_DWORD *)v57) + ((0xFFFF * HIWORD(*(_DWORD *)v57)) >> 16) + 1;
                unsigned int v395 = HIWORD(v399);
              }
              v98[1] = bswap32(v395) >> 16;
              v97[1] = bswap32(v396);
            }
            int v400 = *v96++;
            int v95 = v400;
            v57 += 2;
            ++v97;
            ++v98;
            --v99;
          }
          while (v99);
          goto LABEL_589;
        }
        if (v43)
        {
          uint64_t v373 = v58 + 1;
          int v374 = v45;
          uint64_t v100 = v453;
          do
          {
            if (v95)
            {
              unsigned int v375 = *v43 * v95 + ((*v43 * v95) >> 8) + 1;
              int64_t v376 = *(unsigned __int16 **)(v439 + 40);
              uint64_t v377 = v441;
              if (v441 >= v34) {
                uint64_t v377 = v34;
              }
              if (v377 >= v376) {
                int64_t v376 = v377;
              }
              if (BYTE1(v375))
              {
                if (BYTE1(v375) == 255)
                {
                  unsigned int v378 = *(_DWORD *)v57;
                }
                else
                {
                  unsigned int v379 = bswap32(*v376) >> 16;
                  unsigned int v378 = (*v57 * (unsigned __int16)(257 * (v375 >> 8))
                        + v379 * (unsigned __int16)~(257 * (v375 >> 8))
                        + ((*v57 * (unsigned __int16)(257 * (v375 >> 8)) + v379 * (unsigned __int16)~(257 * (v375 >> 8))) >> 16)
                        + 1) >> 16;
                }
                *int64_t v376 = bswap32(v378) >> 16;
              }
            }
            else
            {
              int64_t v376 = v34;
            }
            int v380 = *v373++;
            int v95 = v380;
            v57 += 2;
            ++v43;
            long long v34 = v376 + 1;
            --v374;
          }
          while (v374);
          goto LABEL_558;
        }
        int v414 = *(unsigned __int16 **)(v439 + 40);
        int v415 = v58 + 1;
        int v416 = v45;
        uint64_t v100 = v453;
        do
        {
          int64_t v376 = v441;
          if (v441 >= v34) {
            int64_t v376 = v34;
          }
          if (v376 < v414) {
            int64_t v376 = v414;
          }
          if (v95)
          {
            if (v95 == 255)
            {
              unsigned int v417 = *(_DWORD *)v57;
            }
            else
            {
              unsigned int v418 = bswap32(*v376) >> 16;
              unsigned int v417 = (*v57 * (v95 | (v95 << 8))
                    + v418 * ((v95 | (v95 << 8)) ^ 0xFFFF)
                    + ((*v57 * (v95 | (v95 << 8))
                      + v418 * ((v95 | (v95 << 8)) ^ 0xFFFF)) >> 16)
                    + 1) >> 16;
            }
            *int64_t v376 = bswap32(v417) >> 16;
          }
          int v419 = *v415++;
          int v95 = v419;
          v57 += 2;
          long long v34 = v376 + 1;
          --v416;
        }
        while (v416);
        goto LABEL_614;
      case 2:
        int v109 = *v58;
        if (v49)
        {
          int v110 = v58 + 1;
          unsigned int v97 = v29 - 1;
          int v98 = v34 - 1;
          int v111 = v45;
          if (v43)
          {
            uint64_t v100 = v453;
            while (1)
            {
              if (!v109) {
                goto LABEL_121;
              }
              unsigned int v112 = *v43 * v109 + ((*v43 * v109) >> 8) + 1;
              if (!BYTE1(v112)) {
                goto LABEL_121;
              }
              if (BYTE1(v112) == 255)
              {
                unsigned int v113 = *(_DWORD *)v57;
                int v114 = HIWORD(*(_DWORD *)v57);
                if (v114)
                {
                  if (v114 == 0xFFFF)
                  {
                    v98[1] = bswap32(v113) >> 16;
                    LOWORD(v113) = -1;
                  }
                  else
                  {
                    unsigned int v122 = bswap32(v97[1]) >> 16;
                    int v123 = v114 ^ 0xFFFF;
                    unsigned int v124 = v123 * (bswap32(v98[1]) >> 16);
                    v98[1] = bswap32(v113 + ((v124 + HIWORD(v124) + 1) >> 16)) >> 16;
                    unsigned int v121 = ((v123 * v122 + ((v123 * v122) >> 16) + 1) >> 16) + HIWORD(v113);
LABEL_119:
                    unsigned int v113 = bswap32(v121) >> 16;
                  }
                  v97[1] = v113;
                }
              }
              else
              {
                int v115 = (257 * (v112 >> 8)) ^ 0xFFFF;
                unsigned int v116 = (unsigned __int16)*(_DWORD *)v57
                     - (((unsigned __int16)*(_DWORD *)v57 * v115
                       + (((unsigned __int16)*(_DWORD *)v57 * v115) >> 16)
                       + 1) >> 16);
                unsigned int v117 = v116 | ((HIWORD(*(_DWORD *)v57)
                              - ((HIWORD(*(_DWORD *)v57) * v115
                                + ((HIWORD(*(_DWORD *)v57) * v115) >> 16)
                                + 1) >> 16)) << 16);
                if (HIWORD(v117))
                {
                  unsigned int v118 = bswap32(v98[1]);
                  unsigned int v119 = bswap32(v97[1]) >> 16;
                  int v120 = HIWORD(v117) ^ 0xFFFF;
                  v98[1] = bswap32(v116 + ((v120 * HIWORD(v118) + ((v120 * HIWORD(v118)) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v121 = ((v120 * v119 + ((v120 * v119) >> 16) + 1) >> 16) + HIWORD(v117);
                  goto LABEL_119;
                }
              }
LABEL_121:
              int v125 = *v110++;
              int v109 = v125;
              v57 += 2;
              ++v43;
              ++v97;
              ++v98;
              if (!--v111)
              {
LABEL_122:
                v43 += v44;
LABEL_590:
                long long v34 = &v98[v447 + 1];
                long long v29 = &v97[v449 + 1];
                goto LABEL_483;
              }
            }
          }
          uint64_t v100 = v453;
          while (1)
          {
            if (v109)
            {
              if (v109 == 255)
              {
                unsigned int v401 = *(_DWORD *)v57;
                int v402 = HIWORD(*(_DWORD *)v57);
                if (v402)
                {
                  if (v402 == 0xFFFF)
                  {
                    v98[1] = bswap32(v401) >> 16;
                    LOWORD(v401) = -1;
                  }
                  else
                  {
                    unsigned int v410 = bswap32(v97[1]) >> 16;
                    int v411 = v402 ^ 0xFFFF;
                    unsigned int v412 = v411 * (bswap32(v98[1]) >> 16);
                    v98[1] = bswap32(v401 + ((v412 + HIWORD(v412) + 1) >> 16)) >> 16;
                    unsigned int v409 = ((v411 * v410 + ((v411 * v410) >> 16) + 1) >> 16) + HIWORD(v401);
LABEL_586:
                    unsigned int v401 = bswap32(v409) >> 16;
                  }
                  v97[1] = v401;
                }
              }
              else
              {
                int v403 = (257 * v109) ^ 0xFFFF;
                unsigned int v404 = (unsigned __int16)*(_DWORD *)v57
                     - (((unsigned __int16)*(_DWORD *)v57 * v403
                       + (((unsigned __int16)*(_DWORD *)v57 * v403) >> 16)
                       + 1) >> 16);
                unsigned int v405 = v404 | ((HIWORD(*(_DWORD *)v57)
                              - ((HIWORD(*(_DWORD *)v57) * v403
                                + ((HIWORD(*(_DWORD *)v57) * v403) >> 16)
                                + 1) >> 16)) << 16);
                if (HIWORD(v405))
                {
                  unsigned int v406 = bswap32(v98[1]);
                  unsigned int v407 = bswap32(v97[1]) >> 16;
                  int v408 = HIWORD(v405) ^ 0xFFFF;
                  v98[1] = bswap32(v404 + ((v408 * HIWORD(v406) + ((v408 * HIWORD(v406)) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v409 = ((v408 * v407 + ((v408 * v407) >> 16) + 1) >> 16) + HIWORD(v405);
                  goto LABEL_586;
                }
              }
            }
            int v413 = *v110++;
            int v109 = v413;
            v57 += 2;
            ++v97;
            ++v98;
            if (!--v111)
            {
LABEL_589:
              int v43 = 0;
              goto LABEL_590;
            }
          }
        }
        int v381 = v58 + 1;
        int64_t v376 = v34 - 1;
        int v382 = v45;
        if (v43)
        {
          uint64_t v100 = v453;
          while (1)
          {
            if (!v109) {
              goto LABEL_557;
            }
            unsigned int v383 = *v43 * v109 + ((*v43 * v109) >> 8) + 1;
            if (!BYTE1(v383)) {
              goto LABEL_557;
            }
            if (BYTE1(v383) == 255)
            {
              unsigned int v384 = *(_DWORD *)v57;
              int v385 = HIWORD(*(_DWORD *)v57);
              if (v385)
              {
                if (v385 != 0xFFFF)
                {
                  unsigned int v386 = bswap32(v376[1]) >> 16;
                  unsigned int v387 = v385 ^ 0xFFFF;
                  goto LABEL_555;
                }
                goto LABEL_556;
              }
            }
            else
            {
              int v388 = HIWORD(*(_DWORD *)v57);
              int v389 = (257 * (v383 >> 8)) ^ 0xFFFF;
              unsigned int v390 = v388 * v389 + ((v388 * v389) >> 16) + 1;
              unsigned int v384 = (unsigned __int16)*(_DWORD *)v57
                   - (((unsigned __int16)*(_DWORD *)v57 * v389
                     + (((unsigned __int16)*(_DWORD *)v57 * v389) >> 16)
                     + 1) >> 16);
              unsigned int v391 = v384 | ((v388 - HIWORD(v390)) << 16);
              if (v391 >= 0x10000)
              {
                unsigned int v386 = bswap32(v376[1]) >> 16;
                unsigned int v387 = ~v391 >> 16;
LABEL_555:
                v384 += (v387 * v386 + ((v387 * v386) >> 16) + 1) >> 16;
LABEL_556:
                v376[1] = bswap32(v384) >> 16;
              }
            }
LABEL_557:
            int v392 = *v381++;
            int v109 = v392;
            v57 += 2;
            ++v43;
            ++v376;
            if (!--v382)
            {
LABEL_558:
              v43 += v44;
              goto LABEL_615;
            }
          }
        }
        uint64_t v100 = v453;
        do
        {
          if (!v109) {
            goto LABEL_613;
          }
          if (v109 == 255)
          {
            unsigned int v420 = *(_DWORD *)v57;
            int v421 = HIWORD(*(_DWORD *)v57);
            if (!v421) {
              goto LABEL_613;
            }
            if (v421 == 0xFFFF) {
              goto LABEL_612;
            }
            unsigned int v422 = bswap32(v376[1]) >> 16;
            unsigned int v423 = v421 ^ 0xFFFF;
          }
          else
          {
            int v424 = HIWORD(*(_DWORD *)v57);
            int v425 = (257 * v109) ^ 0xFFFF;
            unsigned int v426 = v424 * v425 + ((v424 * v425) >> 16) + 1;
            unsigned int v420 = (unsigned __int16)*(_DWORD *)v57
                 - (((unsigned __int16)*(_DWORD *)v57 * v425
                   + (((unsigned __int16)*(_DWORD *)v57 * v425) >> 16)
                   + 1) >> 16);
            unsigned int v427 = v420 | ((v424 - HIWORD(v426)) << 16);
            if (v427 < 0x10000) {
              goto LABEL_613;
            }
            unsigned int v422 = bswap32(v376[1]) >> 16;
            unsigned int v423 = ~v427 >> 16;
          }
          v420 += (v423 * v422 + ((v423 * v422) >> 16) + 1) >> 16;
LABEL_612:
          v376[1] = bswap32(v420) >> 16;
LABEL_613:
          int v428 = *v381++;
          int v109 = v428;
          v57 += 2;
          ++v376;
          --v382;
        }
        while (v382);
LABEL_614:
        int v43 = 0;
LABEL_615:
        long long v34 = &v376[v447 + 1];
        v29 += v449;
LABEL_483:
        uint64_t v89 = v454;
LABEL_484:
        if (--v452)
        {
          uint64_t v54 = 0;
          LODWORD(v455) = v455 + 1;
          uint64_t v39 = *(void *)(v38 + 128) + v100;
          uint64_t v40 = *(void *)(v38 + 136) + v89;
          uint64_t v42 = v451;
          if (v451)
          {
            uint64_t v48 = v443;
            goto LABEL_620;
          }
          continue;
        }
        uint64_t v42 = v451;
LABEL_617:
        if (v42) {
          free(v42);
        }
LABEL_619:
        long long v20 = v438;
LABEL_21:
        if (v20) {
          free(v20);
        }
        return;
      case 3:
        int v126 = v45;
        uint64_t v127 = v43;
        do
        {
          int v128 = *v58;
          if (*v58)
          {
            if (v43) {
              int v128 = ((unsigned __int16)(*v127 * (_WORD)v128 + ((*v127 * v128) >> 8) + 1) >> 8);
            }
            if (v128)
            {
              if (v128 == 255)
              {
                int v129 = HIWORD(*(_DWORD *)v57);
                unsigned int v130 = bswap32(~*v29) >> 16;
                *long long v34 = bswap32(*(_DWORD *)v57- (((unsigned __int16)*(_DWORD *)v57 * v130+ (((unsigned __int16)*(_DWORD *)v57 * v130) >> 16)+ 1) >> 16)) >> 16;
                unsigned int v131 = v129 - ((v129 * v130 + ((v129 * v130) >> 16) + 1) >> 16);
              }
              else
              {
                int v132 = v128 | (v128 << 8);
                unsigned int v133 = bswap32(*v29);
                unsigned int v134 = HIWORD(v133) * v132 + ((HIWORD(v133) * v132) >> 16) + 1;
                v132 ^= 0xFFFFu;
                unsigned int v135 = (bswap32(*v34) >> 16) * v132 + HIWORD(v134) * (unsigned __int16)*(_DWORD *)v57;
                unsigned int v131 = ((v132 + HIWORD(v134)) * HIWORD(*(_DWORD *)v57)
                      + (((v132 + HIWORD(v134)) * HIWORD(*(_DWORD *)v57)) >> 16)
                      + 1) >> 16;
                *long long v34 = bswap32(v135 + HIWORD(v135) + 1);
              }
              *long long v29 = bswap32(v131) >> 16;
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v126;
        }
        while (v126);
        goto LABEL_448;
      case 4:
        int v136 = v45;
        uint64_t v127 = v43;
        do
        {
          int v137 = *v58;
          if (*v58)
          {
            if (v43) {
              int v137 = ((unsigned __int16)(*v127 * (_WORD)v137 + ((*v127 * v137) >> 8) + 1) >> 8);
            }
            if (v137)
            {
              if (v137 == 255)
              {
                int v138 = HIWORD(*(_DWORD *)v57);
                unsigned int v139 = bswap32(*v29) >> 16;
                *long long v34 = bswap32(*(_DWORD *)v57- (((unsigned __int16)*(_DWORD *)v57 * v139+ (((unsigned __int16)*(_DWORD *)v57 * v139) >> 16)+ 1) >> 16)) >> 16;
                unsigned int v140 = v138 - ((v138 * v139 + ((v138 * v139) >> 16) + 1) >> 16);
              }
              else
              {
                int v141 = v137 | (v137 << 8);
                unsigned int v142 = bswap32(~*v29);
                unsigned int v143 = HIWORD(v142) * v141 + ((HIWORD(v142) * v141) >> 16) + 1;
                v141 ^= 0xFFFFu;
                unsigned int v144 = (bswap32(*v34) >> 16) * v141 + HIWORD(v143) * (unsigned __int16)*(_DWORD *)v57;
                unsigned int v140 = ((v141 + HIWORD(v143)) * HIWORD(*(_DWORD *)v57)
                      + (((v141 + HIWORD(v143)) * HIWORD(*(_DWORD *)v57)) >> 16)
                      + 1) >> 16;
                *long long v34 = bswap32(v144 + HIWORD(v144) + 1);
              }
              *long long v29 = bswap32(v140) >> 16;
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v136;
        }
        while (v136);
        goto LABEL_448;
      case 5:
        int v145 = v45;
        uint64_t v127 = v43;
        do
        {
          int v146 = *v58;
          if (*v58)
          {
            if (!v43
              || (int v146 = ((unsigned __int16)(*v127 * (_WORD)v146
                                                            + ((*v127 * v146) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v147 = bswap32(*v29);
              int v148 = (v146 | (v146 << 8)) ^ 0xFFFF;
              unsigned int v149 = (unsigned __int16)*(_DWORD *)v57
                   - (((unsigned __int16)*(_DWORD *)v57 * v148
                     + (((unsigned __int16)*(_DWORD *)v57 * v148) >> 16)
                     + 1) >> 16);
              unsigned int v150 = (v149 | ((HIWORD(*(_DWORD *)v57)
                             - ((HIWORD(*(_DWORD *)v57) * v148
                               + ((HIWORD(*(_DWORD *)v57) * v148) >> 16)
                               + 1) >> 16)) << 16)) >> 16;
              unsigned int v151 = (unsigned __int16)v149 * HIWORD(v147) + (v150 ^ 0xFFFF) * (bswap32(*v34) >> 16);
              *long long v34 = bswap32(v151 + HIWORD(v151) + 1);
              *long long v29 = bswap32(((v150 ^ 0xFFFF) + HIWORD(v147)) * v150 + ((((v150 ^ 0xFFFF) + HIWORD(v147)) * v150) >> 16) + 1);
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v145;
        }
        while (v145);
        goto LABEL_448;
      case 6:
        int v152 = v45;
        uint64_t v127 = v43;
        do
        {
          int v153 = *v58;
          if (*v58)
          {
            if (!v43
              || (int v153 = ((unsigned __int16)(*v127 * (_WORD)v153
                                                            + ((*v127 * v153) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned int v154 = bswap32(*v29);
              if (HIWORD(v154) != 0xFFFF)
              {
                if ((unsigned __int16)~HIWORD(v154) == 0xFFFF)
                {
                  int v155 = HIWORD(*(_DWORD *)v57);
                  int v156 = (v153 | (v153 << 8)) ^ 0xFFFF;
                  *long long v34 = bswap32(*(_DWORD *)v57- (((unsigned __int16)*(_DWORD *)v57 * v156+ (((unsigned __int16)*(_DWORD *)v57 * v156) >> 16)+ 1) >> 16)) >> 16;
                  unsigned int v157 = v155 - ((v155 * v156 + ((v155 * v156) >> 16) + 1) >> 16);
                }
                else
                {
                  int v158 = HIWORD(*(_DWORD *)v57);
                  unsigned int v159 = (257 * v153 * (unsigned __int16)~HIWORD(v154)
                        + ((257 * v153 * (unsigned __int16)~HIWORD(v154)) >> 16)
                        + 1) >> 16;
                  *long long v34 = bswap32((bswap32(*v34) >> 16)+ (((unsigned __int16)*(_DWORD *)v57 * v159+ (((unsigned __int16)*(_DWORD *)v57 * v159) >> 16)+ 1) >> 16)) >> 16;
                  unsigned int v157 = HIWORD(v154) + ((v158 * v159 + ((v158 * v159) >> 16) + 1) >> 16);
                }
                *long long v29 = bswap32(v157) >> 16;
              }
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v152;
        }
        while (v152);
        goto LABEL_448;
      case 7:
        uint64_t v160 = v43 != 0;
        int v161 = v45;
        uint64_t v127 = v43;
        if (v49)
        {
          do
          {
            int v162 = *v58;
            if (*v58)
            {
              if (v43) {
                int v162 = ((unsigned __int16)(*v127 * (_WORD)v162 + ((*v127 * v162) >> 8) + 1) >> 8);
              }
              if (v162)
              {
                if (v162 == 255)
                {
                  unsigned int v163 = bswap32(*v34) >> 16;
                  unsigned int v164 = bswap32(*v29) >> 16;
                  unsigned int v165 = ~*(_DWORD *)v57 >> 16;
                  *long long v34 = bswap32(v163 - ((v165 * v163 + ((v165 * v163) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v166 = v164 - ((v165 * v164 + ((v165 * v164) >> 16) + 1) >> 16);
                }
                else
                {
                  unsigned int v167 = bswap32(*v29);
                  unsigned int v168 = ((v162 | (v162 << 8)) ^ 0xFFFF)
                       + ((v57[1] * (v162 | (v162 << 8)) + ((v57[1] * (v162 | (v162 << 8))) >> 16) + 1) >> 16);
                  unsigned int v169 = v168 * (bswap32(*v34) >> 16);
                  unsigned int v166 = (v168 * HIWORD(v167) + ((v168 * HIWORD(v167)) >> 16) + 1) >> 16;
                  *long long v34 = bswap32(v169 + HIWORD(v169) + 1);
                }
                *long long v29 = bswap32(v166) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v160;
            ++v34;
            ++v29;
            --v161;
          }
          while (v161);
        }
        else
        {
          do
          {
            int v170 = *v58;
            if (*v58)
            {
              if (v43) {
                int v170 = ((unsigned __int16)(*v127 * (_WORD)v170 + ((*v127 * v170) >> 8) + 1) >> 8);
              }
              if (v170)
              {
                if (v170 == 255)
                {
                  unsigned int v171 = bswap32(*v34) >> 16;
                  unsigned int v172 = v171
                       - (((~*(_DWORD *)v57 >> 16) * v171
                         + (((~*(_DWORD *)v57 >> 16) * v171) >> 16)
                         + 1) >> 16);
                }
                else
                {
                  int v173 = v170 | (v170 << 8);
                  unsigned int v174 = bswap32(*v34) >> 16;
                  unsigned int v175 = v57[1] * v173 + ((v57[1] * v173) >> 16) + 1;
                  unsigned int v172 = (((v173 ^ 0xFFFF) + HIWORD(v175)) * v174 + ((((v173 ^ 0xFFFF) + HIWORD(v175)) * v174) >> 16) + 1) >> 16;
                }
                *long long v34 = bswap32(v172) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v160;
            ++v34;
            --v161;
          }
          while (v161);
        }
        goto LABEL_448;
      case 8:
        uint64_t v176 = v43 != 0;
        int v177 = v45;
        uint64_t v127 = v43;
        if (v49)
        {
          do
          {
            int v178 = *v58;
            if (*v58)
            {
              if (v43) {
                int v178 = ((unsigned __int16)(*v127 * (_WORD)v178 + ((*v127 * v178) >> 8) + 1) >> 8);
              }
              if (v178)
              {
                if (v178 == 255)
                {
                  unsigned int v179 = bswap32(*v34) >> 16;
                  unsigned int v180 = bswap32(*v29) >> 16;
                  int v181 = HIWORD(*(_DWORD *)v57);
                  *long long v34 = bswap32(v179 - ((v181 * v179 + ((v181 * v179) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v182 = v180 - ((v181 * v180 + ((v181 * v180) >> 16) + 1) >> 16);
                }
                else
                {
                  unsigned int v183 = bswap32(*v29);
                  unsigned int v184 = ((v178 | (v178 << 8)) ^ 0xFFFF)
                       + (((~*(_DWORD *)v57 >> 16) * (v178 | (v178 << 8))
                         + (((~*(_DWORD *)v57 >> 16) * (v178 | (v178 << 8))) >> 16)
                         + 1) >> 16);
                  unsigned int v185 = v184 * (bswap32(*v34) >> 16);
                  unsigned int v182 = (v184 * HIWORD(v183) + ((v184 * HIWORD(v183)) >> 16) + 1) >> 16;
                  *long long v34 = bswap32(v185 + HIWORD(v185) + 1);
                }
                *long long v29 = bswap32(v182) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v176;
            ++v34;
            ++v29;
            --v177;
          }
          while (v177);
        }
        else
        {
          do
          {
            int v186 = *v58;
            if (*v58)
            {
              if (v43) {
                int v186 = ((unsigned __int16)(*v127 * (_WORD)v186 + ((*v127 * v186) >> 8) + 1) >> 8);
              }
              if (v186)
              {
                if (v186 == 255)
                {
                  unsigned int v187 = bswap32(*v34) >> 16;
                  unsigned int v188 = v187 - ((v57[1] * v187 + ((v57[1] * v187) >> 16) + 1) >> 16);
                }
                else
                {
                  int v189 = v186 | (v186 << 8);
                  unsigned int v190 = bswap32(*v34) >> 16;
                  unsigned int v191 = (~*(_DWORD *)v57 >> 16) * v189
                       + (((~*(_DWORD *)v57 >> 16) * v189) >> 16)
                       + 1;
                  unsigned int v188 = (((v189 ^ 0xFFFF) + HIWORD(v191)) * v190 + ((((v189 ^ 0xFFFF) + HIWORD(v191)) * v190) >> 16) + 1) >> 16;
                }
                *long long v34 = bswap32(v188) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v176;
            ++v34;
            --v177;
          }
          while (v177);
        }
        goto LABEL_448;
      case 9:
        int v192 = v45;
        uint64_t v127 = v43;
        do
        {
          int v193 = *v58;
          if (*v58)
          {
            if (!v43
              || (int v193 = ((unsigned __int16)(*v127 * (_WORD)v193
                                                            + ((*v127 * v193) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              unsigned __int16 v194 = ~(v193 | ((_WORD)v193 << 8));
              unsigned int v195 = ((unsigned __int16)*(_DWORD *)v57
                    - (((unsigned __int16)*(_DWORD *)v57 * v194
                      + (((unsigned __int16)*(_DWORD *)v57 * v194) >> 16)
                      + 1) >> 16)) | ((HIWORD(*(_DWORD *)v57)
                                     - ((HIWORD(*(_DWORD *)v57) * v194
                                       + ((HIWORD(*(_DWORD *)v57) * v194) >> 16)
                                       + 1) >> 16)) << 16);
              unsigned int v196 = bswap32(~*v29) >> 16;
              unsigned int v197 = (unsigned __int16)(*(_DWORD *)v57
                                      - (((unsigned __int16)*(_DWORD *)v57 * v194
                                        + (((unsigned __int16)*(_DWORD *)v57 * v194) >> 16)
                                        + 1) >> 16))
                   * v196
                   + (unsigned __int16)(v194 + HIWORD(v195)) * (bswap32(*v34) >> 16);
              unsigned int v198 = (v196 + (unsigned __int16)(v194 + HIWORD(v195))) * HIWORD(v195);
              *long long v34 = bswap32(v197 + HIWORD(v197) + 1);
              *long long v29 = bswap32(v198 + HIWORD(v198) + 1);
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v192;
        }
        while (v192);
        goto LABEL_448;
      case 10:
        int v199 = v45;
        uint64_t v127 = v43;
        do
        {
          int v200 = *v58;
          if (*v58)
          {
            if (!v43
              || (int v200 = ((unsigned __int16)(*v127 * (_WORD)v200
                                                            + ((*v127 * v200) >> 8)
                                                            + 1) >> 8)) != 0)
            {
              int v201 = (v200 | (v200 << 8)) ^ 0xFFFF;
              unsigned int v202 = (unsigned __int16)*(_DWORD *)v57
                   - (((unsigned __int16)*(_DWORD *)v57 * v201
                     + (((unsigned __int16)*(_DWORD *)v57 * v201) >> 16)
                     + 1) >> 16);
              unsigned int v203 = (v202 | ((HIWORD(*(_DWORD *)v57)
                             - ((HIWORD(*(_DWORD *)v57) * v201
                               + ((HIWORD(*(_DWORD *)v57) * v201) >> 16)
                               + 1) >> 16)) << 16)) >> 16;
              unsigned int v204 = bswap32(~*v29);
              unsigned int v205 = (unsigned __int16)v202 * HIWORD(v204) + (v203 ^ 0xFFFF) * (bswap32(*v34) >> 16);
              *long long v34 = bswap32(v205 + HIWORD(v205) + 1);
              *long long v29 = bswap32(((v203 ^ 0xFFFF) + HIWORD(v204)) * v203 + ((((v203 ^ 0xFFFF) + HIWORD(v204)) * v203) >> 16) + 1);
            }
          }
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          --v199;
        }
        while (v199);
        goto LABEL_448;
      case 11:
        uint64_t v206 = v43 != 0;
        int v207 = v45;
        uint64_t v127 = v43;
        if (v49)
        {
          do
          {
            int v208 = *v58;
            if (*v58)
            {
              if (!v43
                || (int v208 = ((unsigned __int16)(*v127 * (_WORD)v208
                                                              + ((*v127 * v208) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v209 = (v208 | (v208 << 8)) ^ 0xFFFF;
                unsigned int v210 = (unsigned __int16)*(_DWORD *)v57
                     - ((v209 * (unsigned __int16)*(_DWORD *)v57
                       + ((v209 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                       + 1) >> 16);
                unsigned int v211 = bswap32(*v29);
                unsigned int v212 = (v210 | ((HIWORD(*(_DWORD *)v57)
                               - ((v209 * HIWORD(*(_DWORD *)v57)
                                 + ((v209 * HIWORD(*(_DWORD *)v57)) >> 16)
                                 + 1) >> 16)) << 16)) >> 16;
                int v213 = HIWORD(v211) - ((bswap32(*v34) >> 16) + (unsigned __int16)v210) + v212;
                unsigned int v214 = v212 + HIWORD(v211);
                if (v213 >= 0xFFFF) {
                  int v213 = 0xFFFF;
                }
                if (v214 >= 0xFFFF) {
                  unsigned int v214 = 0xFFFF;
                }
                *long long v34 = bswap32(v214 - v213) >> 16;
                *long long v29 = bswap32(v214) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v206;
            ++v34;
            ++v29;
            --v207;
          }
          while (v207);
        }
        else
        {
          do
          {
            int v215 = *v58;
            if (*v58)
            {
              if (!v43
                || (int v215 = ((unsigned __int16)(*v127 * (_WORD)v215
                                                              + ((*v127 * v215) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v216 = (v215 | (v215 << 8)) ^ 0xFFFF;
                unsigned int v217 = (unsigned __int16)*(_DWORD *)v57
                     - ((v216 * (unsigned __int16)*(_DWORD *)v57
                       + ((v216 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                       + 1) >> 16);
                signed int v218 = (bswap32(~*v34) >> 16)
                     - (unsigned __int16)v217
                     + ((v217 | ((HIWORD(*(_DWORD *)v57)
                                - ((v216 * HIWORD(*(_DWORD *)v57)
                                  + ((v216 * HIWORD(*(_DWORD *)v57)) >> 16)
                                  + 1) >> 16)) << 16)) >> 16);
                if (v218 >= 0xFFFF) {
                  signed int v218 = 0xFFFF;
                }
                *long long v34 = bswap32(~v218) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v206;
            ++v34;
            --v207;
          }
          while (v207);
        }
        goto LABEL_448;
      case 12:
        uint64_t v219 = v43 != 0;
        int v220 = v45;
        uint64_t v127 = v43;
        if (v49)
        {
          do
          {
            int v221 = *v58;
            if (*v58)
            {
              if (!v43
                || (int v221 = ((unsigned __int16)(*v127 * (_WORD)v221
                                                              + ((*v127 * v221) >> 8)
                                                              + 1) >> 8)) != 0)
              {
                int v222 = (v221 | (v221 << 8)) ^ 0xFFFF;
                unsigned int v223 = (unsigned __int16)*(_DWORD *)v57
                     - ((v222 * (unsigned __int16)*(_DWORD *)v57
                       + ((v222 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                       + 1) >> 16);
                unsigned int v224 = (bswap32(*v34) >> 16) + (unsigned __int16)v223;
                unsigned int v225 = ((v223 | ((HIWORD(*(_DWORD *)v57)
                                - ((v222 * HIWORD(*(_DWORD *)v57)
                                  + ((v222 * HIWORD(*(_DWORD *)v57)) >> 16)
                                  + 1) >> 16)) << 16)) >> 16)
                     + (bswap32(*v29) >> 16);
                if (v224 >= 0xFFFF) {
                  unsigned int v224 = 0xFFFF;
                }
                if (v225 >= 0xFFFF) {
                  unsigned int v225 = 0xFFFF;
                }
                *long long v34 = bswap32(v224) >> 16;
                *long long v29 = bswap32(v225) >> 16;
              }
            }
            ++v58;
            v57 += 2;
            v127 += v219;
            ++v34;
            ++v29;
            --v220;
          }
          while (v220);
          goto LABEL_448;
        }
        uint64_t v89 = v454;
        do
        {
          if (*v58
            && (!v43
             || ((*v127 * *v58 + ((*v127 * *v58) >> 8) + 1) & 0xFF00) != 0))
          {
            int v393 = bswap32(*v34);
            *long long v34 = bswap32((v393 >> 15) & 0xFFFE | ((v393 >> 16) >> 15)) >> 16;
          }
          ++v58;
          v127 += v219;
          ++v34;
          --v220;
        }
        while (v220);
        uint64_t v394 = v442;
        if (!v43) {
          uint64_t v394 = 0;
        }
        v43 += v44 + v394;
LABEL_568:
        v34 += v447;
        v29 += v449;
        uint64_t v100 = v453;
        goto LABEL_484;
      case 13:
        int v226 = v45;
        uint64_t v127 = v43;
        while (1)
        {
          int v227 = *v58;
          if (!*v58) {
            goto LABEL_269;
          }
          if (v43)
          {
            int v227 = ((unsigned __int16)(*v127 * (_WORD)v227 + ((*v127 * v227) >> 8) + 1) >> 8);
            if (!v227) {
              goto LABEL_269;
            }
          }
          int v228 = (v227 | (v227 << 8)) ^ 0xFFFF;
          unsigned int v229 = (unsigned __int16)*(_DWORD *)v57
               - ((v228 * (unsigned __int16)*(_DWORD *)v57
                 + ((v228 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                 + 1) >> 16);
          unsigned int v230 = v229 | ((HIWORD(*(_DWORD *)v57)
                        - ((v228 * HIWORD(*(_DWORD *)v57) + ((v228 * HIWORD(*(_DWORD *)v57)) >> 16) + 1) >> 16)) << 16);
          if (v230 < 0x10000) {
            goto LABEL_269;
          }
          unint64_t v231 = HIWORD(v230);
          if (v49)
          {
            if (!*v29) {
              goto LABEL_266;
            }
            unsigned int v232 = __rev16(*v29);
          }
          else
          {
            unsigned int v232 = 0xFFFF;
          }
          unint64_t v233 = (v232 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v229
               + ((v231 ^ 0xFFFF) + (unsigned __int16)v229) * (unint64_t)(bswap32(*v34) >> 16);
          if (v233 <= 0xFFFE8000) {
            unint64_t v234 = v233 + 0x8000;
          }
          else {
            unint64_t v234 = 4294868992;
          }
          unint64_t v235 = (v234 + (v234 >> 16)) >> 16;
          if (!v49)
          {
            LODWORD(v231) = v235;
            int v237 = v34;
            goto LABEL_268;
          }
          int64_t v236 = 0xFFFF * (v232 + v231) - v232 * (unint64_t)v231;
          if (v236 <= 4294868992) {
            unint64_t v231 = v236 + 0x8000;
          }
          else {
            unint64_t v231 = 4294868992;
          }
          unsigned int v230 = ((v231 >> 16) + v231) & 0xFFFF0000 | v235;
          LODWORD(v231) = HIWORD(v230);
LABEL_266:
          *long long v34 = bswap32(v230) >> 16;
          int v237 = v29;
LABEL_268:
          *int v237 = bswap32(v231) >> 16;
LABEL_269:
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          if (!--v226) {
            goto LABEL_448;
          }
        }
      case 14:
        int v238 = v45;
        uint64_t v127 = v43;
        while (1)
        {
          int v239 = *v58;
          if (!*v58) {
            goto LABEL_291;
          }
          if (v43)
          {
            int v239 = ((unsigned __int16)(*v127 * (_WORD)v239 + ((*v127 * v239) >> 8) + 1) >> 8);
            if (!v239) {
              goto LABEL_291;
            }
          }
          int v240 = (v239 | (v239 << 8)) ^ 0xFFFF;
          unsigned int v241 = (unsigned __int16)*(_DWORD *)v57
               - ((v240 * (unsigned __int16)*(_DWORD *)v57
                 + ((v240 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                 + 1) >> 16);
          unsigned int v242 = v241 | ((HIWORD(*(_DWORD *)v57)
                        - ((v240 * HIWORD(*(_DWORD *)v57) + ((v240 * HIWORD(*(_DWORD *)v57)) >> 16) + 1) >> 16)) << 16);
          if (v242 < 0x10000) {
            goto LABEL_291;
          }
          unsigned int v243 = HIWORD(v242);
          if (v49)
          {
            if (!*v29) {
              goto LABEL_288;
            }
            unsigned int v244 = __rev16(*v29);
          }
          else
          {
            unsigned int v244 = 0xFFFF;
          }
          uint64_t v245 = bswap32(*v34) >> 16;
          unint64_t v246 = (v245 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v241 - v245 + (v245 << 16);
          if (v246 <= 0xFFFE8000) {
            unint64_t v247 = v246 + 0x8000;
          }
          else {
            unint64_t v247 = 4294868992;
          }
          unint64_t v248 = (v247 + (v247 >> 16)) >> 16;
          if (!v49)
          {
            unsigned int v243 = v248;
            uint64_t v251 = v34;
            goto LABEL_290;
          }
          int64_t v249 = 0xFFFF * (v244 + (unint64_t)v243) - v244 * (unint64_t)v243;
          if (v249 <= 4294868992) {
            unint64_t v250 = v249 + 0x8000;
          }
          else {
            unint64_t v250 = 4294868992;
          }
          unsigned int v242 = ((v250 >> 16) + v250) & 0xFFFF0000 | v248;
          unsigned int v243 = HIWORD(v242);
LABEL_288:
          *long long v34 = bswap32(v242) >> 16;
          uint64_t v251 = v29;
LABEL_290:
          *uint64_t v251 = bswap32(v243) >> 16;
LABEL_291:
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          if (!--v238) {
            goto LABEL_448;
          }
        }
      case 15:
        uint64_t v252 = v43;
        while (1)
        {
          int v253 = *v58;
          if (!*v58) {
            goto LABEL_307;
          }
          if (v43)
          {
            int v253 = ((unsigned __int16)(*v252 * (_WORD)v253 + ((*v252 * v253) >> 8) + 1) >> 8);
            if (!v253) {
              goto LABEL_307;
            }
          }
          int v254 = (unsigned __int16)*(_DWORD *)v57;
          int v255 = (v253 | (v253 << 8)) ^ 0xFFFF;
          unsigned int v256 = v255 * v254 + ((v255 * v254) >> 16) + 1;
          unsigned int v257 = (v254 - HIWORD(v256)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v255 * HIWORD(*(_DWORD *)v57)
                                           + ((v255 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v258 = HIWORD(v257);
          if (!HIWORD(v257)) {
            goto LABEL_307;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_304;
            }
            unsigned int v259 = __rev16(*v29);
          }
          else
          {
            unsigned int v259 = 0xFFFF;
          }
          unsigned int v257 = PDAoverlayPDA_8925(bswap32(*v34) >> 16, v259, (unsigned __int16)(v254 - HIWORD(v256)), v258);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v258 = v257;
            unsigned int v260 = v34;
            goto LABEL_306;
          }
          unsigned int v258 = HIWORD(v257);
LABEL_304:
          *long long v34 = bswap32(v257) >> 16;
          unsigned int v260 = v29;
LABEL_306:
          *unsigned int v260 = bswap32(v258) >> 16;
LABEL_307:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 16:
        uint64_t v252 = v43;
        while (1)
        {
          int v261 = *v58;
          if (!*v58) {
            goto LABEL_323;
          }
          if (v43)
          {
            int v261 = ((unsigned __int16)(*v252 * (_WORD)v261 + ((*v252 * v261) >> 8) + 1) >> 8);
            if (!v261) {
              goto LABEL_323;
            }
          }
          int v262 = (unsigned __int16)*(_DWORD *)v57;
          int v263 = (v261 | (v261 << 8)) ^ 0xFFFF;
          unsigned int v264 = v263 * v262 + ((v263 * v262) >> 16) + 1;
          unsigned int v265 = (v262 - HIWORD(v264)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v263 * HIWORD(*(_DWORD *)v57)
                                           + ((v263 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v266 = HIWORD(v265);
          if (!HIWORD(v265)) {
            goto LABEL_323;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_320;
            }
            unsigned int v267 = __rev16(*v29);
          }
          else
          {
            unsigned int v267 = 0xFFFF;
          }
          unsigned int v265 = PDAdarkenPDA_8927(bswap32(*v34) >> 16, v267, (unsigned __int16)(v262 - HIWORD(v264)), v266);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v266 = v265;
            uint64_t v268 = v34;
            goto LABEL_322;
          }
          unsigned int v266 = HIWORD(v265);
LABEL_320:
          *long long v34 = bswap32(v265) >> 16;
          uint64_t v268 = v29;
LABEL_322:
          *uint64_t v268 = bswap32(v266) >> 16;
LABEL_323:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 17:
        uint64_t v252 = v43;
        while (1)
        {
          int v269 = *v58;
          if (!*v58) {
            goto LABEL_339;
          }
          if (v43)
          {
            int v269 = ((unsigned __int16)(*v252 * (_WORD)v269 + ((*v252 * v269) >> 8) + 1) >> 8);
            if (!v269) {
              goto LABEL_339;
            }
          }
          int v270 = (unsigned __int16)*(_DWORD *)v57;
          int v271 = (v269 | (v269 << 8)) ^ 0xFFFF;
          unsigned int v272 = v271 * v270 + ((v271 * v270) >> 16) + 1;
          unsigned int v273 = (v270 - HIWORD(v272)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v271 * HIWORD(*(_DWORD *)v57)
                                           + ((v271 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v274 = HIWORD(v273);
          if (!HIWORD(v273)) {
            goto LABEL_339;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_336;
            }
            unsigned int v275 = __rev16(*v29);
          }
          else
          {
            unsigned int v275 = 0xFFFF;
          }
          unsigned int v273 = PDAlightenPDA_8926(bswap32(*v34) >> 16, v275, (unsigned __int16)(v270 - HIWORD(v272)), v274);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v274 = v273;
            int v276 = v34;
            goto LABEL_338;
          }
          unsigned int v274 = HIWORD(v273);
LABEL_336:
          *long long v34 = bswap32(v273) >> 16;
          int v276 = v29;
LABEL_338:
          *int v276 = bswap32(v274) >> 16;
LABEL_339:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 18:
        uint64_t v252 = v43;
        while (1)
        {
          int v277 = *v58;
          if (!*v58) {
            goto LABEL_355;
          }
          if (v43)
          {
            int v277 = ((unsigned __int16)(*v252 * (_WORD)v277 + ((*v252 * v277) >> 8) + 1) >> 8);
            if (!v277) {
              goto LABEL_355;
            }
          }
          int v278 = (unsigned __int16)*(_DWORD *)v57;
          int v279 = (v277 | (v277 << 8)) ^ 0xFFFF;
          unsigned int v280 = v279 * v278 + ((v279 * v278) >> 16) + 1;
          unsigned int v281 = (v278 - HIWORD(v280)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v279 * HIWORD(*(_DWORD *)v57)
                                           + ((v279 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v282 = HIWORD(v281);
          if (!HIWORD(v281)) {
            goto LABEL_355;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_352;
            }
            unsigned int v283 = __rev16(*v29);
          }
          else
          {
            unsigned int v283 = 0xFFFF;
          }
          unsigned int v281 = PDAcolordodgePDA_8928(bswap32(*v34) >> 16, v283, (unsigned __int16)(v278 - HIWORD(v280)), v282);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v282 = v281;
            unint64_t v284 = v34;
            goto LABEL_354;
          }
          unsigned int v282 = HIWORD(v281);
LABEL_352:
          *long long v34 = bswap32(v281) >> 16;
          unint64_t v284 = v29;
LABEL_354:
          *unint64_t v284 = bswap32(v282) >> 16;
LABEL_355:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 19:
        uint64_t v252 = v43;
        while (1)
        {
          int v285 = *v58;
          if (!*v58) {
            goto LABEL_371;
          }
          if (v43)
          {
            int v285 = ((unsigned __int16)(*v252 * (_WORD)v285 + ((*v252 * v285) >> 8) + 1) >> 8);
            if (!v285) {
              goto LABEL_371;
            }
          }
          int v286 = (unsigned __int16)*(_DWORD *)v57;
          int v287 = (v285 | (v285 << 8)) ^ 0xFFFF;
          unsigned int v288 = v287 * v286 + ((v287 * v286) >> 16) + 1;
          unsigned int v289 = (v286 - HIWORD(v288)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v287 * HIWORD(*(_DWORD *)v57)
                                           + ((v287 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v290 = HIWORD(v289);
          if (!HIWORD(v289)) {
            goto LABEL_371;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_368;
            }
            unsigned int v291 = __rev16(*v29);
          }
          else
          {
            unsigned int v291 = 0xFFFF;
          }
          unsigned int v289 = PDAcolorburnPDA_8929(bswap32(*v34) >> 16, v291, (unsigned __int16)(v286 - HIWORD(v288)), v290);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v290 = v289;
            uint64_t v292 = v34;
            goto LABEL_370;
          }
          unsigned int v290 = HIWORD(v289);
LABEL_368:
          *long long v34 = bswap32(v289) >> 16;
          uint64_t v292 = v29;
LABEL_370:
          *uint64_t v292 = bswap32(v290) >> 16;
LABEL_371:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 20:
        uint64_t v252 = v43;
        while (1)
        {
          int v293 = *v58;
          if (!*v58) {
            goto LABEL_387;
          }
          if (v43)
          {
            int v293 = ((unsigned __int16)(*v252 * (_WORD)v293 + ((*v252 * v293) >> 8) + 1) >> 8);
            if (!v293) {
              goto LABEL_387;
            }
          }
          int v294 = (unsigned __int16)*(_DWORD *)v57;
          int v295 = (v293 | (v293 << 8)) ^ 0xFFFF;
          unsigned int v296 = v295 * v294 + ((v295 * v294) >> 16) + 1;
          unsigned int v297 = (v294 - HIWORD(v296)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v295 * HIWORD(*(_DWORD *)v57)
                                           + ((v295 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v298 = HIWORD(v297);
          if (!HIWORD(v297)) {
            goto LABEL_387;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_384;
            }
            unsigned int v299 = __rev16(*v29);
          }
          else
          {
            unsigned int v299 = 0xFFFF;
          }
          unsigned int v297 = PDAsoftlightPDA_8931(bswap32(*v34) >> 16, v299, (unsigned __int16)(v294 - HIWORD(v296)), v298);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v298 = v297;
            uint64_t v300 = v34;
            goto LABEL_386;
          }
          unsigned int v298 = HIWORD(v297);
LABEL_384:
          *long long v34 = bswap32(v297) >> 16;
          uint64_t v300 = v29;
LABEL_386:
          *uint64_t v300 = bswap32(v298) >> 16;
LABEL_387:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 21:
        uint64_t v252 = v43;
        while (1)
        {
          int v301 = *v58;
          if (!*v58) {
            goto LABEL_403;
          }
          if (v43)
          {
            int v301 = ((unsigned __int16)(*v252 * (_WORD)v301 + ((*v252 * v301) >> 8) + 1) >> 8);
            if (!v301) {
              goto LABEL_403;
            }
          }
          int v302 = (unsigned __int16)*(_DWORD *)v57;
          int v303 = (v301 | (v301 << 8)) ^ 0xFFFF;
          unsigned int v304 = v303 * v302 + ((v303 * v302) >> 16) + 1;
          unsigned int v305 = (v302 - HIWORD(v304)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v303 * HIWORD(*(_DWORD *)v57)
                                           + ((v303 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v306 = HIWORD(v305);
          if (!HIWORD(v305)) {
            goto LABEL_403;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_400;
            }
            unsigned int v307 = __rev16(*v29);
          }
          else
          {
            unsigned int v307 = 0xFFFF;
          }
          unsigned int v305 = PDAhardlightPDA_8930(bswap32(*v34) >> 16, v307, (unsigned __int16)(v302 - HIWORD(v304)), v306);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v306 = v305;
            unsigned int v308 = v34;
            goto LABEL_402;
          }
          unsigned int v306 = HIWORD(v305);
LABEL_400:
          *long long v34 = bswap32(v305) >> 16;
          unsigned int v308 = v29;
LABEL_402:
          *unsigned int v308 = bswap32(v306) >> 16;
LABEL_403:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 22:
        uint64_t v252 = v43;
        while (1)
        {
          int v309 = *v58;
          if (!*v58) {
            goto LABEL_419;
          }
          if (v43)
          {
            int v309 = ((unsigned __int16)(*v252 * (_WORD)v309 + ((*v252 * v309) >> 8) + 1) >> 8);
            if (!v309) {
              goto LABEL_419;
            }
          }
          int v310 = (unsigned __int16)*(_DWORD *)v57;
          int v311 = (v309 | (v309 << 8)) ^ 0xFFFF;
          unsigned int v312 = v311 * v310 + ((v311 * v310) >> 16) + 1;
          unsigned int v313 = (v310 - HIWORD(v312)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v311 * HIWORD(*(_DWORD *)v57)
                                           + ((v311 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v314 = HIWORD(v313);
          if (!HIWORD(v313)) {
            goto LABEL_419;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_416;
            }
            unsigned int v315 = __rev16(*v29);
          }
          else
          {
            unsigned int v315 = 0xFFFF;
          }
          unsigned int v313 = PDAdifferencePDA_8932(bswap32(*v34) >> 16, v315, (unsigned __int16)(v310 - HIWORD(v312)), v314);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v314 = v313;
            uint64_t v316 = v34;
            goto LABEL_418;
          }
          unsigned int v314 = HIWORD(v313);
LABEL_416:
          *long long v34 = bswap32(v313) >> 16;
          uint64_t v316 = v29;
LABEL_418:
          *uint64_t v316 = bswap32(v314) >> 16;
LABEL_419:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 23:
        int v317 = v45;
        uint64_t v127 = v43;
        while (1)
        {
          int v318 = *v58;
          if (!*v58) {
            goto LABEL_447;
          }
          if (v43)
          {
            int v318 = ((unsigned __int16)(*v127 * (_WORD)v318 + ((*v127 * v318) >> 8) + 1) >> 8);
            if (!v318) {
              goto LABEL_447;
            }
          }
          int v319 = (v318 | (v318 << 8)) ^ 0xFFFF;
          unsigned int v320 = (unsigned __int16)*(_DWORD *)v57
               - ((v319 * (unsigned __int16)*(_DWORD *)v57
                 + ((v319 * (unsigned __int16)*(_DWORD *)v57) >> 16)
                 + 1) >> 16);
          unsigned int v321 = v320 | ((HIWORD(*(_DWORD *)v57)
                        - ((v319 * HIWORD(*(_DWORD *)v57) + ((v319 * HIWORD(*(_DWORD *)v57)) >> 16) + 1) >> 16)) << 16);
          LODWORD(v322) = HIWORD(v321);
          if (!HIWORD(v321)) {
            goto LABEL_447;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_444;
            }
            unsigned int v323 = __rev16(*v29);
          }
          else
          {
            unsigned int v323 = 0xFFFF;
          }
          unsigned int v324 = bswap32(*v34) >> 16;
          if ((unsigned __int16)v320 >= HIWORD(v321)) {
            uint64_t v325 = v322;
          }
          else {
            uint64_t v325 = (unsigned __int16)v320;
          }
          if (v324 >= v323) {
            uint64_t v326 = v323;
          }
          else {
            uint64_t v326 = v324;
          }
          int64_t v327 = 0xFFFF * (v326 + v325) - 2 * v325 * (unint64_t)v326;
          if (v327 <= 4294868992) {
            unint64_t v328 = v327 + 0x8000;
          }
          else {
            unint64_t v328 = 4294868992;
          }
          unint64_t v329 = v328 + (v328 >> 16);
          if (!v49)
          {
            unint64_t v322 = v329 >> 16;
            unsigned int v332 = v34;
            goto LABEL_446;
          }
          unint64_t v330 = v329 >> 16;
          int64_t v331 = 0xFFFF * (v323 + (unint64_t)v322) - v323 * (unint64_t)v322;
          if (v331 <= 4294868992) {
            unint64_t v322 = v331 + 0x8000;
          }
          else {
            unint64_t v322 = 4294868992;
          }
          unsigned int v321 = ((v322 >> 16) + v322) & 0xFFFF0000 | v330;
          LODWORD(v322) = HIWORD(v321);
LABEL_444:
          *long long v34 = bswap32(v321) >> 16;
          unsigned int v332 = v29;
LABEL_446:
          *unsigned int v332 = bswap32(v322) >> 16;
LABEL_447:
          ++v58;
          v57 += 2;
          v127 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          if (!--v317)
          {
LABEL_448:
            int v43 = &v127[v44];
            v34 += v447;
            v29 += v449;
LABEL_482:
            uint64_t v100 = v453;
            goto LABEL_483;
          }
        }
      case 24:
        uint64_t v252 = v43;
        while (1)
        {
          int v333 = *v58;
          if (!*v58) {
            goto LABEL_463;
          }
          if (v43)
          {
            int v333 = ((unsigned __int16)(*v252 * (_WORD)v333 + ((*v252 * v333) >> 8) + 1) >> 8);
            if (!v333) {
              goto LABEL_463;
            }
          }
          int v334 = (unsigned __int16)*(_DWORD *)v57;
          int v335 = (v333 | (v333 << 8)) ^ 0xFFFF;
          unsigned int v336 = v335 * v334 + ((v335 * v334) >> 16) + 1;
          unsigned int v337 = (v334 - HIWORD(v336)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v335 * HIWORD(*(_DWORD *)v57)
                                           + ((v335 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v338 = HIWORD(v337);
          if (!HIWORD(v337)) {
            goto LABEL_463;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_460;
            }
            unsigned int v339 = __rev16(*v29);
          }
          else
          {
            unsigned int v339 = 0xFFFF;
          }
          unsigned int v337 = PDAhuePDA_8933(bswap32(*v34) >> 16, v339, (unsigned __int16)(v334 - HIWORD(v336)), v338);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v338 = v337;
            uint64_t v340 = v34;
            goto LABEL_462;
          }
          unsigned int v338 = HIWORD(v337);
LABEL_460:
          *long long v34 = bswap32(v337) >> 16;
          uint64_t v340 = v29;
LABEL_462:
          *uint64_t v340 = bswap32(v338) >> 16;
LABEL_463:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45) {
            goto LABEL_480;
          }
        }
      case 25:
        uint64_t v252 = v43;
        while (1)
        {
          int v341 = *v58;
          if (!*v58) {
            goto LABEL_479;
          }
          if (v43)
          {
            int v341 = ((unsigned __int16)(*v252 * (_WORD)v341 + ((*v252 * v341) >> 8) + 1) >> 8);
            if (!v341) {
              goto LABEL_479;
            }
          }
          int v342 = (unsigned __int16)*(_DWORD *)v57;
          int v343 = (v341 | (v341 << 8)) ^ 0xFFFF;
          unsigned int v344 = v343 * v342 + ((v343 * v342) >> 16) + 1;
          unsigned int v345 = (v342 - HIWORD(v344)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v343 * HIWORD(*(_DWORD *)v57)
                                           + ((v343 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v346 = HIWORD(v345);
          if (!HIWORD(v345)) {
            goto LABEL_479;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_476;
            }
            unsigned int v347 = __rev16(*v29);
          }
          else
          {
            unsigned int v347 = 0xFFFF;
          }
          unsigned int v345 = PDAhuePDA_8933(bswap32(*v34) >> 16, v347, (unsigned __int16)(v342 - HIWORD(v344)), v346);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v346 = v345;
            unsigned int v348 = v34;
            goto LABEL_478;
          }
          unsigned int v346 = HIWORD(v345);
LABEL_476:
          *long long v34 = bswap32(v345) >> 16;
          unsigned int v348 = v29;
LABEL_478:
          *unsigned int v348 = bswap32(v346) >> 16;
LABEL_479:
          ++v58;
          v57 += 2;
          v252 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          LODWORD(v45) = v45 - 1;
          if (!v45)
          {
LABEL_480:
            int v43 = &v252[v444];
            uint64_t v44 = v444;
LABEL_481:
            uint64_t v45 = v446;
            v34 += v447;
            v29 += v449;
            uint64_t v38 = v445;
            goto LABEL_482;
          }
        }
      case 26:
        int v349 = v45;
        uint64_t v350 = v43;
        int v351 = v349;
        while (1)
        {
          int v352 = *v58;
          if (!*v58) {
            goto LABEL_501;
          }
          if (v43)
          {
            int v352 = ((unsigned __int16)(*v350 * (_WORD)v352 + ((*v350 * v352) >> 8) + 1) >> 8);
            if (!v352) {
              goto LABEL_501;
            }
          }
          int v353 = (unsigned __int16)*(_DWORD *)v57;
          int v354 = (v352 | (v352 << 8)) ^ 0xFFFF;
          unsigned int v355 = v354 * v353 + ((v354 * v353) >> 16) + 1;
          unsigned int v356 = (v353 - HIWORD(v355)) | ((HIWORD(*(_DWORD *)v57)
                                         - ((v354 * HIWORD(*(_DWORD *)v57)
                                           + ((v354 * HIWORD(*(_DWORD *)v57)) >> 16)
                                           + 1) >> 16)) << 16);
          unsigned int v357 = HIWORD(v356);
          if (!HIWORD(v356)) {
            goto LABEL_501;
          }
          if (v49)
          {
            if (!*v29) {
              goto LABEL_498;
            }
            unsigned int v358 = __rev16(*v29);
          }
          else
          {
            unsigned int v358 = 0xFFFF;
          }
          unsigned int v356 = PDAluminosityPDA_8935((unsigned __int16)(v353 - HIWORD(v355)), v357, bswap32(*v34) >> 16, v358);
          uint64_t v49 = v456;
          if (!v456)
          {
            unsigned int v357 = v356;
            unint64_t v359 = v34;
            goto LABEL_500;
          }
          unsigned int v357 = HIWORD(v356);
LABEL_498:
          *long long v34 = bswap32(v356) >> 16;
          unint64_t v359 = v29;
LABEL_500:
          *unint64_t v359 = bswap32(v357) >> 16;
LABEL_501:
          ++v58;
          v57 += 2;
          v350 += v43 != 0;
          ++v34;
          long long v29 = (unsigned __int16 *)((char *)v29 + v52);
          if (!--v351) {
            goto LABEL_518;
          }
        }
      case 27:
        int v360 = v45;
        uint64_t v350 = v43;
        int v361 = v360;
        break;
      default:
        goto LABEL_482;
    }
    break;
  }
  while (1)
  {
    int v362 = *v58;
    if (!*v58) {
      goto LABEL_517;
    }
    if (v43)
    {
      int v362 = ((unsigned __int16)(*v350 * (_WORD)v362 + ((*v350 * v362) >> 8) + 1) >> 8);
      if (!v362) {
        goto LABEL_517;
      }
    }
    int v363 = (unsigned __int16)*(_DWORD *)v57;
    int v364 = (v362 | (v362 << 8)) ^ 0xFFFF;
    unsigned int v365 = v364 * v363 + ((v364 * v363) >> 16) + 1;
    unsigned int v366 = (v363 - HIWORD(v365)) | ((HIWORD(*(_DWORD *)v57)
                                   - ((v364 * HIWORD(*(_DWORD *)v57)
                                     + ((v364 * HIWORD(*(_DWORD *)v57)) >> 16)
                                     + 1) >> 16)) << 16);
    unsigned int v367 = HIWORD(v366);
    if (!HIWORD(v366)) {
      goto LABEL_517;
    }
    if (v49)
    {
      if (!*v29) {
        goto LABEL_514;
      }
      unsigned int v368 = __rev16(*v29);
    }
    else
    {
      unsigned int v368 = 0xFFFF;
    }
    unsigned int v366 = PDAluminosityPDA_8935(bswap32(*v34) >> 16, v368, (unsigned __int16)(v363 - HIWORD(v365)), v367);
    uint64_t v49 = v456;
    if (!v456)
    {
      unsigned int v367 = v366;
      int v369 = v34;
      goto LABEL_516;
    }
    unsigned int v367 = HIWORD(v366);
LABEL_514:
    *long long v34 = bswap32(v366) >> 16;
    int v369 = v29;
LABEL_516:
    *int v369 = bswap32(v367) >> 16;
LABEL_517:
    ++v58;
    v57 += 2;
    v350 += v43 != 0;
    ++v34;
    long long v29 = (unsigned __int16 *)((char *)v29 + v52);
    if (!--v361)
    {
LABEL_518:
      uint64_t v44 = v444;
      int v43 = &v350[v444];
      goto LABEL_481;
    }
  }
}

uint64_t W16_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v47, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v47) < 1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v18 = *(_DWORD *)a3;
  *((void *)&v30 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v18 != 68161796)
  {
    unsigned int v19 = SAMPLEINDEX(v18, v10, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      if (v19 > 0xB)
      {
LABEL_20:
        int v21 = 255;
        char v20 = 1;
      }
      else
      {
        char v20 = 0;
        int v21 = 0;
        switch(v19)
        {
          case 2u:
            if (*((void *)a2 + 12)) {
              goto LABEL_20;
            }
            char v20 = 0;
            int v21 = 16;
            break;
          case 5u:
            char v20 = 0;
            int v21 = 24;
            break;
          case 6u:
            break;
          case 7u:
            char v20 = 0;
            int v21 = 32;
            break;
          case 8u:
            char v20 = 0;
            int v21 = 8;
            break;
          case 9u:
            char v20 = 0;
            int v21 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(void *)&long long v30 = *(void *)&W16_image_sample[2 * v19 + 2];
      if ((void)v30)
      {
        int v22 = 68161828;
        goto LABEL_28;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 8)
      {
        *(void *)&long long v30 = *(void *)&W8_image_sample[2 * v19 + 2];
        if ((void)v30)
        {
          int v22 = 34083076;
          goto LABEL_28;
        }
      }
      *(void *)&long long v30 = *(void *)&WF_image_sample[2 * v19 + 2];
      if ((void)v30)
      {
        LODWORD(v31) = 8;
        int v22 = 136319269;
LABEL_28:
        DWORD2(v30) = v22;
        if ((v20 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v31) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v19 <= 0xB)
        {
          HIDWORD(v23) = v21;
          LODWORD(v23) = v21;
          switch((v23 >> 3))
          {
            case 0u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = W16_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v30) = *(_DWORD *)a3;
              unint64_t v25 = W16_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = W16_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = W16_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v30) = *(_DWORD *)a3;
              uint64_t v24 = W16_image_mark_rgb32;
LABEL_51:
              uint64_t v26 = v24;
              uint64_t v27 = (uint64_t)a2;
              int v28 = v8;
              int v29 = 0;
              break;
            case 5u:
              DWORD2(v30) = *(_DWORD *)a3;
              unint64_t v25 = W16_image_mark_rgb32;
LABEL_53:
              uint64_t v26 = v25;
              uint64_t v27 = (uint64_t)a2;
              int v28 = v8;
              int v29 = 8;
              break;
            default:
              goto LABEL_29;
          }
          w16_image_mark_image(v27, (uint64_t)&v30, v28, v29, (void (*)(void, void))v26);
          return 1;
        }
        goto LABEL_29;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(void)v41 && (~DWORD1(v31) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((BYTE4(v31) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      W16_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(void *)&long long v30 = w16_sample_W16;
LABEL_29:
  W16_image_mark((uint64_t)a2, (uint64_t)&v30, v8, v17);
  return 1;
}

uint64_t W16_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v852 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned int **)(v3 + 96);
  uint64_t v6 = *(void *)(v3 + 48);
  int v7 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                 + 16 * *(_DWORD *)v3
                 + 8 * (v5 == 0)
                 + 4 * (v6 == 0));
  if (v7 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = v3;
  unint64_t v10 = *(unsigned int *)(v3 + 4);
  unsigned int v11 = v10 - 1;
  if ((int)v10 < 1) {
    return 0;
  }
  int v12 = *(_DWORD *)(v3 + 8);
  uint64_t v13 = (v12 - 1);
  if (v12 < 1) {
    return 0;
  }
  uint64_t v14 = *(uint16x4_t **)(v3 + 136);
  int v784 = *(_DWORD *)(*(void *)(*(void *)v2 + 56)
                   + 16 * *(_DWORD *)v3
                   + 8 * (v5 == 0)
                   + 4 * (v6 == 0));
  unint64_t v780 = v3;
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v14)
  {
    int v16 = *(_DWORD *)v3 & 0xFF00;
    if (v16 == 1024)
    {
      v851[0] = *(_DWORD *)(v3 + 4);
      v841[0] = v12;
      unsigned int v828 = **(_DWORD **)(v3 + 88);
      unsigned int v17 = bswap32(v828);
      if (v5) {
        unsigned int v18 = bswap32(*v5);
      }
      else {
        unsigned int v18 = 0xFFFF;
      }
      uint64_t v32 = *(void *)(v3 + 40);
      unint64_t v33 = (unint64_t)*(int *)(v3 + 28) >> 1;
      uint64_t v35 = *(int *)(v3 + 12);
      uint64_t v34 = *(int *)(v3 + 16);
      unsigned int v36 = v17 | (v18 << 16);
      if (v6)
      {
        unint64_t v832 = (unint64_t)*(int *)(v3 + 32) >> 1;
        v830 = (char *)(v6 + 2 * (v35 + v832 * v34));
        unsigned int v811 = 1;
      }
      else
      {
        v830 = 0;
        unint64_t v832 = 0;
        unsigned int v811 = 0;
      }
      uint64_t v41 = HIWORD(v36);
      int v794 = ~HIWORD(v36);
      uint64_t v42 = v32 + 2 * (v35 + v34 * v33);
      unint64_t v807 = (unint64_t)*(int *)(v3 + 28) >> 1;
      int v809 = v17 | (v18 << 16);
      uint64_t v826 = v42;
      if (v14)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v14, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
        uint64_t v44 = v43;
        long long v45 = v830;
        unint64_t v838 = v832;
        if (v43) {
          goto LABEL_1373;
        }
        return 1;
      }
      *(void *)v834 = 0;
      if (v6) {
        unint64_t v46 = v10;
      }
      else {
        unint64_t v46 = 0;
      }
      long long v45 = v830;
      unint64_t v838 = v832 - v46;
      unint64_t v47 = v10;
      uint64_t v48 = (int8x8_t *)(v32 + 2 * (v35 + v34 * v33));
LABEL_1003:
      unint64_t v837 = v33 - v47;
      uint64_t v42 = HIWORD(v828);
      int v825 = v10;
      switch(v7)
      {
        case 0:
          unint64_t v599 = v33;
          uint64_t v600 = v837 + (int)v10;
          unsigned int v601 = v841[0];
          int v602 = v10;
          uint64_t v603 = v841[0] - 1;
          uint64_t v604 = (v600 * v603) & (v600 >> 63);
          if (v600 < 0) {
            uint64_t v600 = -v600;
          }
          CGBlt_fillBytes(2 * v602, v841[0], 0, (char *)v48 + 2 * v604, 2 * v600);
          if (v6)
          {
            uint64_t v605 = v838 + v602;
            if (v605 >= 0) {
              uint64_t v606 = v838 + v602;
            }
            else {
              uint64_t v606 = -v605;
            }
            v45 += 2 * ((v605 * v603) & (v605 >> 63));
            unint64_t v838 = v606;
            CGBlt_fillBytes(2 * v602, v601, 0, v45, 2 * v606);
          }
          unint64_t v33 = v599;
          goto LABEL_1336;
        case 1:
          uint64_t v607 = v837 + (int)v10;
          if (v607 < 0)
          {
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v607 * (v841[0] - 1));
            uint64_t v607 = -v607;
          }
          int v608 = 0;
          uint64_t v609 = *(int **)(v780 + 88);
          if (v609) {
            int v608 = *v609;
          }
          signed int v610 = v841[0];
          CGBlt_fillBytes(2 * v10, v841[0], v608, (char *)v48, 2 * v607);
          if (v6)
          {
            uint64_t v611 = *(int **)(v780 + 96);
            if (!v611) {
              uint64_t v611 = (int *)&PIXELALPHAPLANARCONSTANT_17534;
            }
            uint64_t v612 = v838 + (int)v10;
            if (v612 >= 0) {
              uint64_t v613 = v838 + (int)v10;
            }
            else {
              uint64_t v613 = -v612;
            }
            v45 += 2 * (((v838 + (int)v10) * (v610 - 1)) & (v612 >> 63));
            unint64_t v838 = v613;
            CGBlt_fillBytes(2 * v10, v610, *v611, v45, 2 * v613);
          }
          goto LABEL_1337;
        case 2:
          int v614 = v841[0];
          unsigned int v615 = v10 >> 2;
          if (v6)
          {
            unsigned int v616 = v615 + 1;
            uint64_t v42 = v826;
            do
            {
              if ((int)v10 < 4)
              {
                int v626 = v10;
              }
              else
              {
                unsigned int v617 = v616;
                do
                {
                  unsigned int v618 = bswap32(v48->u16[0]);
                  unsigned int v619 = bswap32(*(unsigned __int16 *)v45);
                  v48->i16[0] = bswap32(v17+ ((HIWORD(v618) * (unsigned __int16)v794+ ((HIWORD(v618) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  *(_WORD *)long long v45 = bswap32(((HIWORD(v619) * (unsigned __int16)v794+ ((HIWORD(v619) * (unsigned __int16)v794) >> 16)+ 1) >> 16)+ HIWORD(v36)) >> 16;
                  unsigned int v620 = bswap32(v48->u16[1]);
                  unsigned int v621 = bswap32(*((unsigned __int16 *)v45 + 1));
                  v48->i16[1] = bswap32(v17+ ((HIWORD(v620) * (unsigned __int16)v794+ ((HIWORD(v620) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v45 + 1) = bswap32(((HIWORD(v621) * (unsigned __int16)v794+ ((HIWORD(v621) * (unsigned __int16)v794) >> 16)+ 1) >> 16)+ HIWORD(v36)) >> 16;
                  unsigned int v622 = bswap32(v48->u16[2]);
                  unsigned int v623 = bswap32(*((unsigned __int16 *)v45 + 2));
                  v48->i16[2] = bswap32(v17+ ((HIWORD(v622) * (unsigned __int16)v794+ ((HIWORD(v622) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v45 + 2) = bswap32(((HIWORD(v623) * (unsigned __int16)v794+ ((HIWORD(v623) * (unsigned __int16)v794) >> 16)+ 1) >> 16)+ HIWORD(v36)) >> 16;
                  unsigned int v624 = bswap32(v48->u16[3]);
                  unsigned int v625 = bswap32(*((unsigned __int16 *)v45 + 3));
                  v48->i16[3] = bswap32(v17+ ((HIWORD(v624) * (unsigned __int16)v794+ ((HIWORD(v624) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  *((_WORD *)v45 + 3) = bswap32(((HIWORD(v625) * (unsigned __int16)v794+ ((HIWORD(v625) * (unsigned __int16)v794) >> 16)+ 1) >> 16)+ HIWORD(v36)) >> 16;
                  ++v48;
                  v45 += 8 * v811;
                  --v617;
                }
                while (v617 > 1);
                int v626 = v10 & 3;
              }
              if (v626 >= 1)
              {
                unsigned int v627 = v626 + 1;
                do
                {
                  unsigned int v628 = bswap32(v48->u16[0]);
                  unsigned int v629 = bswap32(*(unsigned __int16 *)v45);
                  v48->i16[0] = bswap32(v17+ ((HIWORD(v628) * (unsigned __int16)v794+ ((HIWORD(v628) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                  *(_WORD *)long long v45 = bswap32(((HIWORD(v629) * (unsigned __int16)v794+ ((HIWORD(v629) * (unsigned __int16)v794) >> 16)+ 1) >> 16)+ HIWORD(v36)) >> 16;
                  --v627;
                  v45 += 2 * v811;
                }
                while (v627 > 1);
              }
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v614;
            }
            while (v614);
          }
          else
          {
            int16x4_t v758 = vdup_n_s16(v17);
            unsigned int v759 = v615 + 1;
            uint16x4_t v760 = (uint16x4_t)vdup_n_s16((unsigned __int16)v794);
            v761.i64[0] = 0x100000001;
            v761.i64[1] = 0x100000001;
            uint64_t v42 = v826;
            do
            {
              if ((int)v10 < 4)
              {
                int v764 = v10;
              }
              else
              {
                unsigned int v762 = v759;
                do
                {
                  uint32x4_t v763 = vmull_u16(v760, (uint16x4_t)vrev16_s8(*v48));
                  *v48++ = vrev16_s8((int8x8_t)vadd_s16(v758, vaddhn_s32((int32x4_t)vsraq_n_u32(v763, v763, 0x10uLL), v761)));
                  v45 += 8 * v811;
                  --v762;
                }
                while (v762 > 1);
                int v764 = v10 & 3;
              }
              if (v764 >= 1)
              {
                unsigned int v765 = v764 + 1;
                do
                {
                  unsigned int v766 = bswap32(v48->u16[0]);
                  v48->i16[0] = bswap32(v17+ ((HIWORD(v766) * (unsigned __int16)v794+ ((HIWORD(v766) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                  uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                  --v765;
                  v45 += 2 * v811;
                }
                while (v765 > 1);
              }
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v614;
            }
            while (v614);
          }
          goto LABEL_1370;
        case 3:
          __int16 v630 = bswap32(v36);
          int v631 = v841[0];
          do
          {
            int v632 = v10;
            do
            {
              unsigned int v633 = bswap32(*(unsigned __int16 *)v45) >> 16;
              if (v633 == 0xFFFF)
              {
                v48->i16[0] = HIWORD(v828);
                LOWORD(v633) = v630;
              }
              else if (v633)
              {
                int v634 = v633 ^ 0xFFFF;
                v48->i16[0] = bswap32(v17- (((unsigned __int16)v17 * v634 + (((unsigned __int16)v17 * v634) >> 16) + 1) >> 16)) >> 16;
                unsigned int v633 = bswap32(v41 - ((v41 * v634 + ((v41 * v634) >> 16) + 1) >> 16)) >> 16;
              }
              else
              {
                v48->i16[0] = 0;
              }
              *(_WORD *)long long v45 = v633;
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v632;
            }
            while (v632);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v631;
          }
          while (v631);
          goto LABEL_1283;
        case 4:
          __int16 v635 = bswap32(v36);
          int v636 = v841[0];
          do
          {
            int v637 = v10;
            do
            {
              unsigned int v638 = bswap32(*(unsigned __int16 *)v45) >> 16;
              if (v638)
              {
                if (v638 != 0xFFFF)
                {
                  v48->i16[0] = bswap32(v17- (((unsigned __int16)v17 * v638 + (((unsigned __int16)v17 * v638) >> 16) + 1) >> 16)) >> 16;
                  unsigned int v639 = bswap32(v41 - ((v41 * v638 + ((v41 * v638) >> 16) + 1) >> 16)) >> 16;
                }
                else
                {
                  LOWORD(v639) = 0;
                  v48->i16[0] = 0;
                }
              }
              else
              {
                v48->i16[0] = HIWORD(v828);
                LOWORD(v639) = v635;
              }
              *(_WORD *)long long v45 = v639;
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v637;
            }
            while (v637);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v636;
          }
          while (v636);
          goto LABEL_1283;
        case 5:
          int v640 = v841[0];
          uint64_t v42 = v826;
          do
          {
            int v641 = v10;
            do
            {
              unsigned int v642 = bswap32(*(unsigned __int16 *)v45);
              unsigned int v643 = bswap32(v48->u16[0]);
              v48->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v642)+ HIWORD(v643) * (unsigned __int16)v794+ (((unsigned __int16)v17 * HIWORD(v642)+ HIWORD(v643) * (unsigned __int16)v794) >> 16)+ 1);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              *(_WORD *)long long v45 = bswap32(((unsigned __int16)v794 + HIWORD(v642)) * v41+ ((((unsigned __int16)v794 + HIWORD(v642)) * v41) >> 16)+ 1);
              v45 += 2 * v811;
              --v641;
            }
            while (v641);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v640;
          }
          while (v640);
          goto LABEL_1370;
        case 6:
          __int16 v644 = bswap32(v36);
          int v645 = v841[0];
          do
          {
            int v646 = v10;
            do
            {
              unsigned int v647 = bswap32(*(unsigned __int16 *)v45);
              if (HIWORD(v647) != 0xFFFF)
              {
                if ((unsigned __int16)~HIWORD(v647) == 0xFFFF)
                {
                  v48->i16[0] = HIWORD(v828);
                  LOWORD(v648) = v644;
                }
                else
                {
                  unsigned int v649 = HIWORD(v647);
                  int v650 = (unsigned __int16)~HIWORD(v647);
                  v48->i16[0] = bswap32((bswap32(v48->u16[0]) >> 16)+ (((unsigned __int16)v17 * v650+ (((unsigned __int16)v17 * v650) >> 16)+ 1) >> 16)) >> 16;
                  unsigned int v648 = bswap32(v649 + ((v41 * v650 + ((v41 * v650) >> 16) + 1) >> 16)) >> 16;
                }
                *(_WORD *)long long v45 = v648;
              }
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v646;
            }
            while (v646);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v645;
          }
          while (v645);
          goto LABEL_1283;
        case 7:
          int v651 = v841[0];
          uint64_t v652 = 2 * v811;
          if (v6)
          {
            uint64_t v42 = v826;
            do
            {
              int v653 = v10;
              do
              {
                unsigned int v654 = bswap32(v48->u16[0]);
                unsigned int v655 = bswap32(*(unsigned __int16 *)v45);
                v48->i16[0] = bswap32(HIWORD(v654)- ((HIWORD(v654) * (unsigned __int16)v794+ ((HIWORD(v654) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                *(_WORD *)long long v45 = bswap32(HIWORD(v655)- ((HIWORD(v655) * (unsigned __int16)v794+ ((HIWORD(v655) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                v45 += v652;
                --v653;
              }
              while (v653);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v651;
            }
            while (v651);
          }
          else
          {
            uint64_t v42 = v826;
            do
            {
              int v767 = v10;
              do
              {
                unsigned int v768 = bswap32(v48->u16[0]);
                v48->i16[0] = bswap32(HIWORD(v768)- ((HIWORD(v768) * (unsigned __int16)v794+ ((HIWORD(v768) * (unsigned __int16)v794) >> 16)+ 1) >> 16)) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                v45 += v652;
                --v767;
              }
              while (v767);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v651;
            }
            while (v651);
          }
          goto LABEL_1370;
        case 8:
          int v656 = v841[0];
          uint64_t v657 = 2 * v811;
          if (v6)
          {
            uint64_t v42 = v826;
            do
            {
              int v658 = v10;
              do
              {
                unsigned int v659 = bswap32(v48->u16[0]);
                unsigned int v660 = bswap32(*(unsigned __int16 *)v45);
                v48->i16[0] = bswap32(HIWORD(v659)- ((v41 * HIWORD(v659) + ((v41 * HIWORD(v659)) >> 16) + 1) >> 16)) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                *(_WORD *)long long v45 = bswap32(HIWORD(v660)- ((v41 * HIWORD(v660) + ((v41 * HIWORD(v660)) >> 16) + 1) >> 16)) >> 16;
                v45 += v657;
                --v658;
              }
              while (v658);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v656;
            }
            while (v656);
          }
          else
          {
            uint64_t v42 = v826;
            do
            {
              int v769 = v10;
              do
              {
                unsigned int v770 = bswap32(v48->u16[0]);
                v48->i16[0] = bswap32(HIWORD(v770)- ((v41 * HIWORD(v770) + ((v41 * HIWORD(v770)) >> 16) + 1) >> 16)) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                v45 += v657;
                --v769;
              }
              while (v769);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v656;
            }
            while (v656);
          }
          goto LABEL_1370;
        case 9:
          int v661 = v841[0];
          uint64_t v42 = v826;
          do
          {
            int v662 = v10;
            do
            {
              unsigned int v663 = bswap32(~*(unsigned __int16 *)v45);
              unsigned int v664 = bswap32(v48->u16[0]);
              v48->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v663)+ v41 * HIWORD(v664)+ (((unsigned __int16)v17 * HIWORD(v663) + v41 * HIWORD(v664)) >> 16)+ 1);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              *(_WORD *)long long v45 = bswap32((v41 + HIWORD(v663)) * v41+ (((v41 + HIWORD(v663)) * v41) >> 16)+ 1);
              v45 += 2 * v811;
              --v662;
            }
            while (v662);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v661;
          }
          while (v661);
          goto LABEL_1370;
        case 10:
          int v665 = v841[0];
          uint64_t v42 = v826;
          do
          {
            int v666 = v10;
            do
            {
              unsigned int v667 = bswap32(~*(unsigned __int16 *)v45);
              unsigned int v668 = bswap32(v48->u16[0]);
              v48->i16[0] = bswap32((unsigned __int16)v17 * HIWORD(v667)+ HIWORD(v668) * (unsigned __int16)v794+ (((unsigned __int16)v17 * HIWORD(v667)+ HIWORD(v668) * (unsigned __int16)v794) >> 16)+ 1);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              *(_WORD *)long long v45 = bswap32(((unsigned __int16)v794 + HIWORD(v667)) * v41+ ((((unsigned __int16)v794 + HIWORD(v667)) * v41) >> 16)+ 1);
              v45 += 2 * v811;
              --v666;
            }
            while (v666);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            --v665;
          }
          while (v665);
          goto LABEL_1370;
        case 11:
          if (v6)
          {
            int v669 = v841[0];
            uint64_t v42 = v826;
            do
            {
              int v670 = v10;
              do
              {
                unsigned int v671 = bswap32(*(unsigned __int16 *)v45);
                int v672 = v41 - ((unsigned __int16)v17 + (bswap32(v48->u16[0]) >> 16)) + HIWORD(v671);
                unsigned int v673 = v41 + HIWORD(v671);
                if (v672 >= 0xFFFF) {
                  int v672 = 0xFFFF;
                }
                if (v673 >= 0xFFFF) {
                  unsigned int v673 = 0xFFFF;
                }
                v48->i16[0] = bswap32(v673 - v672) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                *(_WORD *)long long v45 = bswap32(v673) >> 16;
                v45 += 2 * v811;
                --v670;
              }
              while (v670);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v669;
            }
            while (v669);
          }
          else
          {
            int v771 = v841[0];
            uint64_t v42 = v826;
            do
            {
              int v772 = v10;
              do
              {
                int v773 = v41 - (unsigned __int16)v17 + (bswap32(~v48->u16[0]) >> 16);
                if (v773 >= 0xFFFF) {
                  int v773 = 0xFFFF;
                }
                v48->i16[0] = bswap32(~v773) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                v45 += 2 * v811;
                --v772;
              }
              while (v772);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v771;
            }
            while (v771);
          }
          goto LABEL_1370;
        case 12:
          if (v6)
          {
            int v674 = v841[0];
            uint64_t v42 = v826;
            do
            {
              int v675 = v10;
              do
              {
                unsigned int v676 = (unsigned __int16)v17 + (bswap32(v48->u16[0]) >> 16);
                unsigned int v677 = v41 + (bswap32(*(unsigned __int16 *)v45) >> 16);
                if (v676 >= 0xFFFF) {
                  unsigned int v676 = 0xFFFF;
                }
                v48->i16[0] = bswap32(v676) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                if (v677 >= 0xFFFF) {
                  unsigned int v678 = 0xFFFF;
                }
                else {
                  unsigned int v678 = v677;
                }
                *(_WORD *)long long v45 = bswap32(v678) >> 16;
                v45 += 2 * v811;
                --v675;
              }
              while (v675);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v674;
            }
            while (v674);
          }
          else
          {
            int v774 = v841[0];
            uint64_t v42 = v826;
            do
            {
              int v775 = v10;
              do
              {
                int v776 = bswap32(v48->u16[0]);
                v48->i16[0] = bswap32((v776 >> 15) & 0xFFFE | ((v776 >> 16) >> 15)) >> 16;
                uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
                v45 += 2 * v811;
                --v775;
              }
              while (v775);
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v774;
            }
            while (v774);
          }
LABEL_1370:
          v841[0] = 0;
          goto LABEL_1371;
        case 13:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v679 = bswap32(v36);
          int v680 = v841[0];
          while (1)
          {
            int v681 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v45)
                {
                  v48->i16[0] = HIWORD(v828);
                  *(_WORD *)long long v45 = v679;
                  goto LABEL_1131;
                }
                unsigned int v682 = __rev16(*(unsigned __int16 *)v45);
              }
              else
              {
                unsigned int v682 = 0xFFFF;
              }
              uint64_t v683 = v682;
              unint64_t v684 = (v682 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v17
                   + ((v41 ^ 0xFFFF) + (unsigned __int16)v17)
                   * (unint64_t)(bswap32(v48->u16[0]) >> 16);
              if (v684 <= 0xFFFE8000) {
                unint64_t v685 = v684 + 0x8000;
              }
              else {
                unint64_t v685 = 4294868992;
              }
              unint64_t v686 = v685 + (v685 >> 16);
              if (v6)
              {
                int64_t v687 = 0xFFFF * (v683 + v41) - v683 * (unint64_t)v41;
                if (v687 <= 4294868992) {
                  unint64_t v688 = v687 + 0x8000;
                }
                else {
                  unint64_t v688 = 4294868992;
                }
                v48->i16[0] = bswap32(v686);
                *(_WORD *)long long v45 = bswap32((v686 >> 16) | ((v688 >> 16) + v688));
              }
              else
              {
                v48->i16[0] = bswap32(v686);
              }
LABEL_1131:
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v681;
            }
            while (v681);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            if (!--v680) {
              goto LABEL_1283;
            }
          }
        case 14:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v689 = bswap32(v36);
          int v690 = v841[0];
          while (1)
          {
            int v691 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v45)
                {
                  v48->i16[0] = HIWORD(v828);
                  *(_WORD *)long long v45 = v689;
                  goto LABEL_1151;
                }
                unsigned int v692 = __rev16(*(unsigned __int16 *)v45);
              }
              else
              {
                unsigned int v692 = 0xFFFF;
              }
              unsigned int v693 = bswap32(v48->u16[0]);
              unint64_t v694 = (HIWORD(v693) ^ 0xFFFF) * (unint64_t)(unsigned __int16)v17
                   - HIWORD(v693)
                   + ((unint64_t)HIWORD(v693) << 16);
              if (v694 <= 0xFFFE8000) {
                unint64_t v695 = v694 + 0x8000;
              }
              else {
                unint64_t v695 = 4294868992;
              }
              unint64_t v696 = v695 + (v695 >> 16);
              if (v6)
              {
                int64_t v697 = 0xFFFF * (v41 + v692) - v41 * (unint64_t)v692;
                if (v697 <= 4294868992) {
                  unint64_t v698 = v697 + 0x8000;
                }
                else {
                  unint64_t v698 = 4294868992;
                }
                v48->i16[0] = bswap32(v696);
                *(_WORD *)long long v45 = bswap32((v696 >> 16) | ((v698 >> 16) + v698));
              }
              else
              {
                v48->i16[0] = bswap32(v696);
              }
LABEL_1151:
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v691;
            }
            while (v691);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            if (!--v690)
            {
LABEL_1283:
              v841[0] = 0;
LABEL_1337:
              uint64_t v42 = v826;
LABEL_1371:
              uint64_t v44 = *(void *)v834;
              if (!*(void *)v834) {
                return 1;
              }
              uint64_t v840 = 0;
LABEL_1373:
              if (!shape_enum_clip_next(v44, (int *)&v840 + 1, &v840, v851, v841)) {
                goto LABEL_1379;
              }
              *(void *)v834 = v44;
              uint64_t v48 = (int8x8_t *)(v42 + 2 * v33 * (int)v840 + 2 * SHIDWORD(v840));
              unint64_t v47 = v851[0];
              unint64_t v777 = v838;
              if (v6) {
                unint64_t v777 = v832 - v851[0];
              }
              unint64_t v838 = v777;
              if (v6) {
                long long v45 = &v830[2 * v832 * (int)v840 + 2 * SHIDWORD(v840)];
              }
              LODWORD(v10) = v851[0];
              goto LABEL_1003;
            }
          }
        case 15:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v699 = bswap32(v36);
          int v700 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v701 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1160;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v702) = v699;
LABEL_1163:
            *(_WORD *)long long v45 = v702;
LABEL_1164:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v700;
              LODWORD(v10) = v825;
              if (!v700) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v701 = 0xFFFF;
LABEL_1160:
          unsigned int v702 = bswap32(PDAoverlayPDA_8925(bswap32(v48->u16[0]) >> 16, v701, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v702);
          if (!v6) {
            goto LABEL_1164;
          }
          goto LABEL_1163;
        case 16:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v703 = bswap32(v36);
          int v704 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v705 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1173;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v706) = v703;
LABEL_1176:
            *(_WORD *)long long v45 = v706;
LABEL_1177:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v704;
              LODWORD(v10) = v825;
              if (!v704) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v705 = 0xFFFF;
LABEL_1173:
          unsigned int v706 = bswap32(PDAdarkenPDA_8927(bswap32(v48->u16[0]) >> 16, v705, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v706);
          if (!v6) {
            goto LABEL_1177;
          }
          goto LABEL_1176;
        case 17:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v707 = bswap32(v36);
          int v708 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v709 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1186;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v710) = v707;
LABEL_1189:
            *(_WORD *)long long v45 = v710;
LABEL_1190:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v708;
              LODWORD(v10) = v825;
              if (!v708) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v709 = 0xFFFF;
LABEL_1186:
          unsigned int v710 = bswap32(PDAlightenPDA_8926(bswap32(v48->u16[0]) >> 16, v709, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v710);
          if (!v6) {
            goto LABEL_1190;
          }
          goto LABEL_1189;
        case 18:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v711 = bswap32(v36);
          int v712 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v713 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1199;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v714) = v711;
LABEL_1202:
            *(_WORD *)long long v45 = v714;
LABEL_1203:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v712;
              LODWORD(v10) = v825;
              if (!v712) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v713 = 0xFFFF;
LABEL_1199:
          unsigned int v714 = bswap32(PDAcolordodgePDA_8928(bswap32(v48->u16[0]) >> 16, v713, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v714);
          if (!v6) {
            goto LABEL_1203;
          }
          goto LABEL_1202;
        case 19:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v715 = bswap32(v36);
          int v716 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v717 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1212;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v718) = v715;
LABEL_1215:
            *(_WORD *)long long v45 = v718;
LABEL_1216:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v716;
              LODWORD(v10) = v825;
              if (!v716) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v717 = 0xFFFF;
LABEL_1212:
          unsigned int v718 = bswap32(PDAcolorburnPDA_8929(bswap32(v48->u16[0]) >> 16, v717, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v718);
          if (!v6) {
            goto LABEL_1216;
          }
          goto LABEL_1215;
        case 20:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v719 = bswap32(v36);
          int v720 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v721 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1225;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v722) = v719;
LABEL_1228:
            *(_WORD *)long long v45 = v722;
LABEL_1229:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v720;
              LODWORD(v10) = v825;
              if (!v720) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v721 = 0xFFFF;
LABEL_1225:
          unsigned int v722 = bswap32(PDAsoftlightPDA_8931(bswap32(v48->u16[0]) >> 16, v721, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v722);
          if (!v6) {
            goto LABEL_1229;
          }
          goto LABEL_1228;
        case 21:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v723 = bswap32(v36);
          int v724 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v725 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1238;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v726) = v723;
LABEL_1241:
            *(_WORD *)long long v45 = v726;
LABEL_1242:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v724;
              LODWORD(v10) = v825;
              if (!v724) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v725 = 0xFFFF;
LABEL_1238:
          unsigned int v726 = bswap32(PDAhardlightPDA_8930(bswap32(v48->u16[0]) >> 16, v725, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v726);
          if (!v6) {
            goto LABEL_1242;
          }
          goto LABEL_1241;
        case 22:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v727 = bswap32(v36);
          int v728 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v729 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1251;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v730) = v727;
LABEL_1254:
            *(_WORD *)long long v45 = v730;
LABEL_1255:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v728;
              LODWORD(v10) = v825;
              if (!v728) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v729 = 0xFFFF;
LABEL_1251:
          unsigned int v730 = bswap32(PDAdifferencePDA_8932(bswap32(v48->u16[0]) >> 16, v729, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v730);
          if (!v6) {
            goto LABEL_1255;
          }
          goto LABEL_1254;
        case 23:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v731 = __rev16(v41);
          if ((unsigned __int16)v17 >= HIWORD(v36)) {
            uint64_t v732 = v41;
          }
          else {
            uint64_t v732 = (unsigned __int16)v17;
          }
          int v733 = v841[0];
          while (1)
          {
            int v734 = v10;
            do
            {
              if (v6)
              {
                if (!*(_WORD *)v45)
                {
                  v48->i16[0] = HIWORD(v828);
                  *(_WORD *)long long v45 = v731;
                  goto LABEL_1281;
                }
                unsigned int v735 = __rev16(*(unsigned __int16 *)v45);
              }
              else
              {
                unsigned int v735 = 0xFFFF;
              }
              LODWORD(v736) = bswap32(v48->u16[0]) >> 16;
              if (v736 >= v735) {
                uint64_t v736 = v735;
              }
              else {
                uint64_t v736 = v736;
              }
              int64_t v737 = 0xFFFF * (v736 + v732) - (2 * v732) * (unint64_t)v736;
              if (v737 <= 4294868992) {
                unint64_t v738 = v737 + 0x8000;
              }
              else {
                unint64_t v738 = 4294868992;
              }
              unint64_t v739 = v738 + (v738 >> 16);
              if (v6)
              {
                int64_t v740 = 0xFFFF * (v41 + v735) - v41 * (unint64_t)v735;
                if (v740 <= 4294868992) {
                  unint64_t v741 = v740 + 0x8000;
                }
                else {
                  unint64_t v741 = 4294868992;
                }
                v48->i16[0] = bswap32(v739);
                *(_WORD *)long long v45 = bswap32((v739 >> 16) | ((v741 >> 16) + v741));
              }
              else
              {
                v48->i16[0] = bswap32(v739);
              }
LABEL_1281:
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
              v45 += 2 * v811;
              --v734;
            }
            while (v734);
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
            v45 += 2 * v838;
            if (!--v733) {
              goto LABEL_1283;
            }
          }
        case 24:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v742 = bswap32(v36);
          int v743 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v744 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1290;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v745) = v742;
LABEL_1293:
            *(_WORD *)long long v45 = v745;
LABEL_1294:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v743;
              LODWORD(v10) = v825;
              if (!v743) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v744 = 0xFFFF;
LABEL_1290:
          unsigned int v745 = bswap32(PDAhuePDA_8933(bswap32(v48->u16[0]) >> 16, v744, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v745);
          if (!v6) {
            goto LABEL_1294;
          }
          goto LABEL_1293;
        case 25:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v746 = bswap32(v36);
          int v747 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v748 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1303;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v749) = v746;
LABEL_1306:
            *(_WORD *)long long v45 = v749;
LABEL_1307:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v747;
              LODWORD(v10) = v825;
              if (!v747) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v748 = 0xFFFF;
LABEL_1303:
          unsigned int v749 = bswap32(PDAhuePDA_8933(bswap32(v48->u16[0]) >> 16, v748, (unsigned __int16)v17, v41));
          v48->i16[0] = HIWORD(v749);
          if (!v6) {
            goto LABEL_1307;
          }
          goto LABEL_1306;
        case 26:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v750 = bswap32(v36);
          int v751 = v841[0];
          while (v6)
          {
            if (*(_WORD *)v45)
            {
              unsigned int v752 = __rev16(*(unsigned __int16 *)v45);
              goto LABEL_1316;
            }
            v48->i16[0] = HIWORD(v828);
            LOWORD(v753) = v750;
LABEL_1319:
            *(_WORD *)long long v45 = v753;
LABEL_1320:
            uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
            v45 += 2 * v811;
            LODWORD(v10) = v10 - 1;
            if (!v10)
            {
              uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
              v45 += 2 * v838;
              --v751;
              LODWORD(v10) = v825;
              if (!v751) {
                goto LABEL_1335;
              }
            }
          }
          unsigned int v752 = 0xFFFF;
LABEL_1316:
          unsigned int v753 = bswap32(PDAluminosityPDA_8935((unsigned __int16)v17, v41, bswap32(v48->u16[0]) >> 16, v752));
          v48->i16[0] = HIWORD(v753);
          if (!v6) {
            goto LABEL_1320;
          }
          goto LABEL_1319;
        case 27:
          if (!v41) {
            goto LABEL_1337;
          }
          __int16 v754 = bswap32(v36);
          int v755 = v841[0];
          break;
        default:
          goto LABEL_1371;
      }
      while (v6)
      {
        if (*(_WORD *)v45)
        {
          unsigned int v756 = __rev16(*(unsigned __int16 *)v45);
          goto LABEL_1329;
        }
        v48->i16[0] = HIWORD(v828);
        LOWORD(v757) = v754;
LABEL_1332:
        *(_WORD *)long long v45 = v757;
LABEL_1333:
        uint64_t v48 = (int8x8_t *)((char *)v48 + 2);
        v45 += 2 * v811;
        LODWORD(v10) = v10 - 1;
        if (!v10)
        {
          uint64_t v48 = (int8x8_t *)((char *)v48 + 2 * v837);
          v45 += 2 * v838;
          --v755;
          LODWORD(v10) = v825;
          if (!v755)
          {
LABEL_1335:
            v841[0] = 0;
            int v7 = v784;
            unint64_t v33 = v807;
LABEL_1336:
            unsigned int v36 = v809;
            goto LABEL_1337;
          }
        }
      }
      unsigned int v756 = 0xFFFF;
LABEL_1329:
      unsigned int v757 = bswap32(PDAluminosityPDA_8935(bswap32(v48->u16[0]) >> 16, v756, (unsigned __int16)v17, v41));
      v48->i16[0] = HIWORD(v757);
      if (!v6) {
        goto LABEL_1333;
      }
      goto LABEL_1332;
    }
    v851[0] = *(_DWORD *)(v3 + 4);
    v841[0] = v12;
    uint64_t v19 = *(void *)(v3 + 88);
    uint64_t v21 = *(int *)(v3 + 12);
    uint64_t v20 = *(int *)(v3 + 16);
    unint64_t v22 = (unint64_t)*(int *)(v3 + 28) >> 1;
    if (v6)
    {
      unint64_t v23 = (unint64_t)*(int *)(v3 + 32) >> 1;
      v787 = (char *)(v6 + 2 * (v21 + v23 * v20));
      uint64_t v24 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v23 = 0;
      v787 = 0;
      uint64_t v24 = 0;
    }
    unint64_t v785 = *(void *)(v3 + 40) + 2 * (v21 + v20 * v22);
    unint64_t v786 = v23;
    int v37 = *(_DWORD *)(v3 + 56);
    int v38 = *(_DWORD *)(v3 + 60);
    unint64_t v812 = (unint64_t)*(int *)(v3 + 76) >> 1;
    if (v16 != 256)
    {
      int v790 = *(_DWORD *)(v3 + 64);
      int v789 = *(_DWORD *)(v3 + 68);
      if (v5)
      {
        unint64_t v39 = (unint64_t)*(int *)(v3 + 80) >> 1;
        uint64_t v40 = 1;
      }
      else
      {
        unint64_t v39 = 0;
        uint64_t v40 = 0;
      }
      unint64_t v810 = v19 + 2 * v812 * v789;
      v24 &= 1u;
      if (v14)
      {
        int v778 = *(_DWORD *)(v3 + 56);
        int v779 = *(_DWORD *)(v3 + 60);
        uint64_t v836 = v40;
        uint64_t v839 = v24;
        unint64_t v833 = v39;
        int v57 = 1;
        v808 = *(_WORD **)(v3 + 88);
        uint64_t v58 = (uint64_t)v808;
        uint64_t v55 = v808;
        goto LABEL_54;
      }
      unint64_t v831 = v23 - (v24 * v10);
      if (v19)
      {
        uint64_t v67 = v38 % v789;
        int v779 = v38 % v789;
        uint64_t v792 = *(void *)(v3 + 88);
        unint64_t v68 = v19 + 2 * v812 * v67;
        int v69 = v37 % v790;
        uint64_t v55 = (_WORD *)(v68 + 2 * v69);
        unint64_t v65 = v68 + 2 * v790;
        uint64_t v61 = (uint64_t)v5;
        unint64_t v833 = v39;
        int v778 = v69;
        uint64_t v791 = 0;
        if (v5)
        {
          uint64_t v62 = (char *)v5 + 2 * v39 * v67 + 2 * v69;
          int v788 = 1;
          uint64_t v40 = 1;
          unsigned int v70 = (_WORD *)v785;
          int v60 = v787;
          uint64_t v71 = (_WORD *)(v68 + 2 * v69);
          uint64_t v827 = (uint64_t)v62;
        }
        else
        {
          uint64_t v62 = 0;
          uint64_t v827 = 0;
          int v788 = 1;
          unsigned int v70 = (_WORD *)v785;
          int v60 = v787;
          uint64_t v71 = (_WORD *)(v68 + 2 * v69);
        }
        unint64_t v64 = v10;
        goto LABEL_66;
      }
      int v778 = *(_DWORD *)(v3 + 56);
      int v779 = *(_DWORD *)(v3 + 60);
      uint64_t v55 = 0;
      unint64_t v65 = 0;
      int v788 = 1;
      unint64_t v64 = v10;
      unint64_t v66 = (unint64_t)*(int *)(v3 + 76) >> 1;
LABEL_62:
      uint64_t v61 = (uint64_t)v5;
      uint64_t v791 = 0;
      uint64_t v792 = (uint64_t)v55;
      uint64_t v71 = 0;
      unint64_t v810 = 0;
      unint64_t v812 = v66 - v64;
      unint64_t v833 = v39 - (int)v40 * (int)v10;
      unsigned int v70 = (_WORD *)v785;
      int v60 = v787;
      uint64_t v62 = (char *)v61;
      uint64_t v827 = v61;
      goto LABEL_66;
    }
    if (v5)
    {
      unint64_t v39 = (unint64_t)*(int *)(v3 + 80) >> 1;
      uint64_t v5 = (unsigned int *)((char *)v5 + 2 * v37 + 2 * v39 * v38);
      uint64_t v40 = 0xFFFFFFFFLL;
    }
    else
    {
      unint64_t v39 = 0;
      uint64_t v40 = 0;
    }
    uint64_t v55 = (_WORD *)(v19 + 2 * (v37 + v38 * v812));
    if (v812 == v22 && (uint64_t)(v785 - (void)v55) >= 1)
    {
      if (v10 >= (v785 - (unint64_t)v55) >> 1)
      {
        v785 += 2 * v11;
        v55 += v11;
        v787 += 2 * (v24 & v11);
        int v57 = -1;
        unint64_t v812 = (unint64_t)*(int *)(v3 + 28) >> 1;
        uint64_t v5 = (unsigned int *)((char *)v5 + 2 * (v40 & v11));
        goto LABEL_49;
      }
      int32x2_t v56 = &v55[v22 * v13];
      if (v785 <= (unint64_t)&v56[v11])
      {
        v785 += 2 * v22 * v13;
        unint64_t v22 = -(uint64_t)v22;
        unint64_t v786 = -(uint64_t)v23;
        v787 += 2 * v23 * v13;
        uint64_t v5 = (unsigned int *)((char *)v5 + 2 * v39 * v13);
        v24 &= 1u;
        unint64_t v39 = -(uint64_t)v39;
        v40 &= 1u;
        int v57 = 1;
        uint64_t v55 = v56;
        unint64_t v812 = v22;
        goto LABEL_49;
      }
    }
    v24 &= 1u;
    v40 &= 1u;
    int v57 = 1;
LABEL_49:
    int v778 = *(_DWORD *)(v3 + 56);
    int v779 = *(_DWORD *)(v3 + 60);
    if (v14)
    {
      uint64_t v836 = v40;
      uint64_t v839 = v24;
      v808 = 0;
      unint64_t v810 = 0;
      uint64_t v58 = -1;
      unint64_t v833 = v39;
      int v789 = v39;
      int v790 = v812;
LABEL_54:
      int v788 = v57;
      unint64_t v793 = v22;
      shape_enum_clip_alloc(v19, v3, (int *)v14, v57, v22, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v10, v12);
      uint64_t v44 = v59;
      int v60 = v787;
      unint64_t v831 = v786;
      uint64_t v61 = (uint64_t)v5;
      uint64_t v62 = (char *)v5;
      int v63 = (char *)v5;
      if (!v59) {
        return 1;
      }
      while (2)
      {
        uint64_t v827 = (uint64_t)v63;
        if (!shape_enum_clip_next(v44, (int *)&v840 + 1, &v840, v851, v841))
        {
LABEL_1379:
          uint64_t v54 = (void *)v44;
LABEL_1380:
          free(v54);
          return 1;
        }
        uint64_t v791 = v44;
        uint64_t v792 = (uint64_t)v55;
        if (v810)
        {
          unint64_t v22 = v793;
          unsigned int v70 = (_WORD *)(v785 + 2 * v793 * (int)v840 + 2 * SHIDWORD(v840));
          int v571 = ((int)v840 + *(_DWORD *)(v9 + 60)) % v789;
          unint64_t v64 = v851[0];
          int v572 = (HIDWORD(v840) + *(_DWORD *)(v9 + 56)) % v790;
          uint64_t v573 = &v55[v812 * v571];
          uint64_t v55 = &v573[v572];
          unint64_t v65 = (unint64_t)&v573[v790];
          uint64_t v24 = v839;
          unint64_t v574 = v831;
          if (v839) {
            unint64_t v574 = v786 - v851[0];
          }
          unint64_t v831 = v574;
          if (v839) {
            int v60 = &v787[2 * v786 * (int)v840 + 2 * SHIDWORD(v840)];
          }
          if (v836) {
            uint64_t v40 = v836;
          }
          else {
            uint64_t v40 = 0;
          }
          if (v836) {
            uint64_t v62 = (char *)(v61 + 2 * v833 * v571 + 2 * v572);
          }
          uint64_t v575 = v827;
          if (v836) {
            uint64_t v575 = v61 + 2 * v833 * v571 + 2 * v572;
          }
          uint64_t v827 = v575;
          LODWORD(v10) = v851[0];
          uint64_t v71 = v55;
          int v778 = (HIDWORD(v840) + *(_DWORD *)(v9 + 56)) % v790;
          int v779 = ((int)v840 + *(_DWORD *)(v9 + 60)) % v789;
        }
        else
        {
          int v576 = HIDWORD(v840) * v788;
          LODWORD(v10) = v851[0];
          int v577 = v851[0] * v788;
          unint64_t v22 = v793;
          unsigned int v70 = (_WORD *)(v785 + 2 * v793 * (int)v840 + 2 * HIDWORD(v840) * v788);
          unint64_t v64 = v851[0] * v788;
          v55 += (int)v840 * v790 + HIDWORD(v840) * v788;
          unint64_t v810 = 0;
          unint64_t v812 = v790 - v851[0] * v788;
          uint64_t v40 = v836;
          uint64_t v24 = v839;
          if (v839) {
            unint64_t v578 = v786 - v577;
          }
          else {
            unint64_t v578 = v831;
          }
          if (v839) {
            int v60 = &v787[2 * v786 * (int)v840 + 2 * v576];
          }
          uint64_t v579 = v61 + 2 * (int)v840 * v789 + 2 * v576;
          unint64_t v580 = v789 - v577;
          unint64_t v581 = v833;
          if (v836) {
            unint64_t v581 = v580;
          }
          unint64_t v831 = v578;
          unint64_t v833 = v581;
          if (v836) {
            uint64_t v62 = (char *)v579;
          }
          unint64_t v65 = v58;
          uint64_t v71 = v808;
        }
LABEL_66:
        uint64_t v836 = v40;
        uint64_t v839 = v24;
        unint64_t v793 = v22;
        unint64_t v829 = v22 - v64;
        switch(v7)
        {
          case 0:
            uint64_t v781 = v61;
            v808 = v71;
            uint64_t v58 = v65;
            uint64_t v72 = v829 - (int)v10;
            uint64_t v73 = &v70[-(int)v10 + 1];
            if (v788 >= 0)
            {
              uint64_t v73 = v70;
              uint64_t v72 = v829 + (int)v10;
            }
            unsigned int v74 = v841[0];
            uint64_t v75 = v841[0] - 1;
            uint32x2_t v76 = (char *)&v73[(v72 * v75) & (v72 >> 63)];
            if (v72 < 0) {
              uint64_t v72 = -v72;
            }
            CGBlt_fillBytes(2 * v10, v841[0], 0, v76, 2 * v72);
            if (!v839)
            {
              uint64_t v55 = (_WORD *)v792;
              goto LABEL_999;
            }
            if (v788 < 0)
            {
              uint64_t v77 = v831 - (int)v10;
              v60 += -2 * (int)v10 + 2;
            }
            else
            {
              uint64_t v77 = v831 + (int)v10;
            }
            if (v77 >= 0) {
              uint64_t v551 = v77;
            }
            else {
              uint64_t v551 = -v77;
            }
            v60 += 2 * ((v77 * v75) & (v77 >> 63));
            unint64_t v831 = v551;
            CGBlt_fillBytes(2 * v10, v74, 0, v60, 2 * v551);
            goto LABEL_911;
          case 1:
            int v78 = *(unsigned __int8 *)(v9 + 1);
            if (v78 == 2)
            {
              if ((int)v10 < 16
                || (2 * v790) > 0x40
                || (v4.i32[0] = 2 * v790, uint8x8_t v537 = (uint8x8_t)vcnt_s8(v4), v537.i16[0] = vaddlv_u8(v537), v537.i32[0] > 1u))
              {
LABEL_887:
                if (v24)
                {
                  uint64_t v539 = 2 * v788;
                  uint64_t v540 = 2 * (int)v24;
                  if (v40)
                  {
                    uint64_t v541 = (int)v40;
                    int v542 = v841[0];
                    int v63 = (char *)v827;
                    do
                    {
                      int v543 = v10;
                      do
                      {
                        *unsigned int v70 = *v55;
                        *(_WORD *)int v60 = *(_WORD *)v62;
                        int v544 = &v55[v788];
                        if ((unint64_t)v544 >= v65) {
                          uint64_t v545 = -(uint64_t)v790;
                        }
                        else {
                          uint64_t v545 = 0;
                        }
                        uint64_t v55 = &v544[v545];
                        v62 += 2 * v541 + 2 * v545;
                        unsigned int v70 = (_WORD *)((char *)v70 + v539);
                        v60 += v540;
                        --v543;
                      }
                      while (v543);
                      if (v810)
                      {
                        int v546 = &v71[v812];
                        BOOL v547 = (unint64_t)v546 >= v810;
                        if ((unint64_t)v546 >= v810) {
                          uint64_t v548 = -(uint64_t)(v812 * v789);
                        }
                        else {
                          uint64_t v548 = 0;
                        }
                        uint64_t v55 = &v546[v548];
                        unint64_t v549 = v65 + 2 * v548;
                        if (v547) {
                          uint64_t v550 = -(uint64_t)(v833 * v789);
                        }
                        else {
                          uint64_t v550 = 0;
                        }
                        uint64_t v62 = &v63[2 * v833 + 2 * v550];
                        unint64_t v65 = v549 + 2 * v812;
                        uint64_t v71 = v55;
                        int v63 = v62;
                      }
                      else
                      {
                        v55 += v812;
                        v62 += 2 * v833;
                      }
                      v70 += v829;
                      v60 += 2 * v831;
                      --v542;
                    }
                    while (v542);
                  }
                  else
                  {
                    int v562 = v841[0];
                    int v63 = (char *)v827;
                    do
                    {
                      int v563 = v10;
                      do
                      {
                        *unsigned int v70 = *v55;
                        *(_WORD *)int v60 = -1;
                        int v564 = &v55[v788];
                        if ((unint64_t)v564 >= v65) {
                          uint64_t v565 = -(uint64_t)v790;
                        }
                        else {
                          uint64_t v565 = 0;
                        }
                        uint64_t v55 = &v564[v565];
                        v62 += 2 * v565;
                        unsigned int v70 = (_WORD *)((char *)v70 + v539);
                        v60 += v540;
                        --v563;
                      }
                      while (v563);
                      if (v810)
                      {
                        unsigned int v566 = &v71[v812];
                        BOOL v567 = (unint64_t)v566 >= v810;
                        if ((unint64_t)v566 >= v810) {
                          uint64_t v568 = -(uint64_t)(v812 * v789);
                        }
                        else {
                          uint64_t v568 = 0;
                        }
                        uint64_t v55 = &v566[v568];
                        unint64_t v569 = v65 + 2 * v568;
                        if (v567) {
                          uint64_t v570 = -(uint64_t)(v833 * v789);
                        }
                        else {
                          uint64_t v570 = 0;
                        }
                        uint64_t v62 = &v63[2 * v833 + 2 * v570];
                        unint64_t v65 = v569 + 2 * v812;
                        uint64_t v71 = v55;
                        int v63 = v62;
                      }
                      else
                      {
                        v55 += v812;
                        v62 += 2 * v833;
                      }
                      v70 += v829;
                      v60 += 2 * v831;
                      --v562;
                    }
                    while (v562);
                  }
                }
                else
                {
                  uint64_t v552 = (int)v40;
                  int v553 = v841[0];
                  int v63 = (char *)v827;
                  do
                  {
                    int v554 = v10;
                    do
                    {
                      *unsigned int v70 = *v55;
                      uint64_t v555 = &v55[v788];
                      if ((unint64_t)v555 >= v65) {
                        uint64_t v556 = -(uint64_t)v790;
                      }
                      else {
                        uint64_t v556 = 0;
                      }
                      uint64_t v55 = &v555[v556];
                      v62 += 2 * v552 + 2 * v556;
                      v70 += v788;
                      --v554;
                    }
                    while (v554);
                    if (v810)
                    {
                      int v557 = &v71[v812];
                      BOOL v558 = (unint64_t)v557 >= v810;
                      if ((unint64_t)v557 >= v810) {
                        uint64_t v559 = -(uint64_t)(v812 * v789);
                      }
                      else {
                        uint64_t v559 = 0;
                      }
                      uint64_t v55 = &v557[v559];
                      unint64_t v560 = v65 + 2 * v559;
                      if (v558) {
                        uint64_t v561 = -(uint64_t)(v833 * v789);
                      }
                      else {
                        uint64_t v561 = 0;
                      }
                      uint64_t v62 = &v63[2 * v833 + 2 * v561];
                      unint64_t v65 = v560 + 2 * v812;
                      uint64_t v71 = v55;
                      int v63 = v62;
                    }
                    else
                    {
                      v55 += v812;
                      v62 += 2 * v833;
                    }
                    v70 += v829;
                    v60 += 2 * v831;
                    --v553;
                  }
                  while (v553);
                }
                goto LABEL_947;
              }
              v808 = v71;
              uint64_t v58 = v65;
              int v538 = v841[0];
              CGSFillDRAM64((unint64_t)v70, 2 * (v10 + v829), 2 * v10, v841[0], v792, 2 * v812, 2 * v790, v789, 2 * v778, v779);
              if (!v839)
              {
                int v63 = (char *)v827;
                goto LABEL_948;
              }
              if (v40) {
                CGSFillDRAM64((unint64_t)v60, 2 * (v10 + v831), 2 * v10, v538, v61, 2 * v833, 2 * v790, v789, 2 * v778, v779);
              }
              else {
                CGBlt_fillBytes(2 * v10, v538, -1, v60, 2 * (v10 + v831));
              }
LABEL_862:
              uint64_t v44 = v791;
              uint64_t v55 = (_WORD *)v792;
              int v63 = (char *)v827;
              if (!v791) {
                return 1;
              }
            }
            else
            {
              if (v78 != 1) {
                goto LABEL_887;
              }
              v808 = v71;
              uint64_t v79 = (int)v10;
              uint64_t v781 = v61;
              uint64_t v58 = v65;
              if (v788 < 0)
              {
                uint64_t v80 = v812 - (int)v10;
                v55 += -(int)v10 + 1;
                uint64_t v81 = v829 - (int)v10;
                v70 += -(int)v10 + 1;
              }
              else
              {
                uint64_t v80 = v812 + (int)v10;
                uint64_t v81 = v829 + (int)v10;
              }
              int v582 = v10;
              uint64_t v583 = v841[0] - 1;
              if (v80 >= 0) {
                unint64_t v584 = v80;
              }
              else {
                unint64_t v584 = -v80;
              }
              unsigned int v585 = (char *)&v55[(v80 * v583) & (v80 >> 63)];
              unsigned int v586 = (char *)&v70[(v81 * v583) & (v81 >> 63)];
              if (v81 >= 0) {
                LODWORD(v587) = v81;
              }
              else {
                uint64_t v587 = -v81;
              }
              int v588 = v582;
              int v589 = 2 * v582;
              unint64_t v812 = v584;
              int v835 = v841[0];
              CGBlt_copyBytes(2 * v582, v841[0], v585, v586, 2 * v584, 2 * v587);
              if (v839)
              {
                uint64_t v55 = (_WORD *)v792;
                if (v40)
                {
                  uint64_t v590 = v833 - v79;
                  uint64_t v591 = &v62[-2 * v588 + 2];
                  uint64_t v592 = v831 - v79;
                  uint64_t v593 = &v60[-2 * v588 + 2];
                  if (v788 >= 0)
                  {
                    uint64_t v590 = v833 + v79;
                    uint64_t v592 = v831 + v79;
                    uint64_t v593 = v60;
                    uint64_t v591 = v62;
                  }
                  if (v590 >= 0) {
                    uint64_t v594 = v590;
                  }
                  else {
                    uint64_t v594 = -v590;
                  }
                  uint64_t v62 = &v591[2 * ((v590 * v583) & (v590 >> 63))];
                  int v60 = &v593[2 * ((v592 * v583) & (v592 >> 63))];
                  if (v592 >= 0) {
                    uint64_t v595 = v592;
                  }
                  else {
                    uint64_t v595 = -v592;
                  }
                  unint64_t v831 = v595;
                  unint64_t v833 = v594;
                  CGBlt_copyBytes(v589, v835, v62, &v593[2 * ((v592 * v583) & (v592 >> 63))], 2 * v594, 2 * v595);
                }
                else
                {
                  uint64_t v596 = v831 - v79;
                  unint64_t v597 = &v60[-2 * v588 + 2];
                  if (v788 >= 0)
                  {
                    uint64_t v596 = v831 + v79;
                    unint64_t v597 = v60;
                  }
                  if (v596 >= 0) {
                    uint64_t v598 = v596;
                  }
                  else {
                    uint64_t v598 = -v596;
                  }
                  int v60 = &v597[2 * ((v596 * v583) & (v596 >> 63))];
                  unint64_t v831 = v598;
                  CGBlt_fillBytes(v589, v835, -1, v60, 2 * v598);
                }
LABEL_999:
                uint64_t v44 = v791;
                int v63 = (char *)v827;
                uint64_t v61 = v781;
                if (!v791) {
                  return 1;
                }
              }
              else
              {
LABEL_911:
                uint64_t v44 = v791;
                int v63 = (char *)v827;
LABEL_912:
                uint64_t v61 = v781;
                uint64_t v55 = (_WORD *)v792;
                if (!v44) {
                  return 1;
                }
              }
            }
            goto LABEL_949;
          case 2:
            if (v24)
            {
              uint64_t v781 = v61;
              uint64_t v82 = (int)v40;
              int v83 = v841[0];
              int v63 = (char *)v827;
              do
              {
                int v84 = v10;
                do
                {
                  unsigned int v85 = bswap32(*(unsigned __int16 *)v62) >> 16;
                  if (v85)
                  {
                    if (v85 == 0xFFFF)
                    {
                      *unsigned int v70 = *v55;
                      LOWORD(v86) = *(_WORD *)v62;
                    }
                    else
                    {
                      unsigned int v87 = bswap32((unsigned __int16)*v70);
                      unsigned int v88 = bswap32(*(unsigned __int16 *)v60);
                      *unsigned int v70 = bswap32((bswap32((unsigned __int16)*v55) >> 16)+ ((HIWORD(v87) * (v85 ^ 0xFFFF) + ((HIWORD(v87) * (v85 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                      unsigned int v86 = bswap32(v85 + ((HIWORD(v88) * (v85 ^ 0xFFFF) + ((HIWORD(v88) * (v85 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                    }
                    *(_WORD *)int v60 = v86;
                  }
                  uint64_t v89 = &v55[v788];
                  if ((unint64_t)v89 >= v65) {
                    uint64_t v90 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v90 = 0;
                  }
                  uint64_t v55 = &v89[v90];
                  v62 += 2 * v82 + 2 * v90;
                  v70 += v788;
                  v60 += 2 * (int)v24;
                  --v84;
                }
                while (v84);
                if (v810)
                {
                  unsigned int v91 = &v71[v812];
                  BOOL v92 = (unint64_t)v91 >= v810;
                  if ((unint64_t)v91 >= v810) {
                    uint64_t v93 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v93 = 0;
                  }
                  uint64_t v55 = &v91[v93];
                  unint64_t v94 = v65 + 2 * v93;
                  if (v92) {
                    uint64_t v95 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v95 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v95];
                  unint64_t v65 = v94 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v83;
              }
              while (v83);
              v808 = v71;
              uint64_t v58 = v65;
              v841[0] = 0;
              uint64_t v44 = v791;
              goto LABEL_912;
            }
            uint64_t v467 = (int)v40;
            int v468 = v841[0];
            int v63 = (char *)v827;
            do
            {
              int v469 = v10;
              do
              {
                unsigned int v470 = bswap32(*(unsigned __int16 *)v62) >> 16;
                if (v470)
                {
                  if (v470 == 0xFFFF)
                  {
                    LOWORD(v471) = *v55;
                  }
                  else
                  {
                    unsigned int v472 = bswap32((unsigned __int16)*v70) >> 16;
                    unsigned int v471 = bswap32((bswap32((unsigned __int16)*v55) >> 16)+ ((v472 * (v470 ^ 0xFFFF) + ((v472 * (v470 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                  }
                  *unsigned int v70 = v471;
                }
                uint64_t v473 = &v55[v788];
                if ((unint64_t)v473 >= v65) {
                  uint64_t v474 = -(uint64_t)v790;
                }
                else {
                  uint64_t v474 = 0;
                }
                uint64_t v55 = &v473[v474];
                v62 += 2 * v467 + 2 * v474;
                v70 += v788;
                --v469;
              }
              while (v469);
              if (v810)
              {
                int64_t v475 = &v71[v812];
                BOOL v476 = (unint64_t)v475 >= v810;
                if ((unint64_t)v475 >= v810) {
                  uint64_t v477 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v477 = 0;
                }
                uint64_t v55 = &v475[v477];
                unint64_t v478 = v65 + 2 * v477;
                if (v476) {
                  uint64_t v479 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v479 = 0;
                }
                uint64_t v62 = &v63[2 * v833 + 2 * v479];
                unint64_t v65 = v478 + 2 * v812;
                uint64_t v71 = v55;
                int v63 = v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v468;
            }
            while (v468);
            goto LABEL_947;
          case 3:
            if (v40)
            {
              uint64_t v96 = (int)v40;
              int v97 = v841[0];
              int v63 = (char *)v827;
              do
              {
                int v98 = v10;
                do
                {
                  unsigned int v99 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  if (v99 == 0xFFFF)
                  {
                    *unsigned int v70 = *v55;
                    LOWORD(v99) = *(_WORD *)v62;
                  }
                  else if (v99)
                  {
                    unsigned int v100 = bswap32((unsigned __int16)*v55) >> 16;
                    unsigned int v101 = bswap32(*(unsigned __int16 *)v62) >> 16;
                    int v102 = v99 ^ 0xFFFF;
                    *unsigned int v70 = bswap32(v100 - ((v100 * v102 + ((v100 * v102) >> 16) + 1) >> 16)) >> 16;
                    unsigned int v99 = bswap32(v101 - ((v101 * v102 + ((v101 * v102) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    *unsigned int v70 = 0;
                  }
                  *(_WORD *)int v60 = v99;
                  unsigned int v103 = &v55[v788];
                  if ((unint64_t)v103 >= v65) {
                    uint64_t v104 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v104 = 0;
                  }
                  uint64_t v55 = &v103[v104];
                  v62 += 2 * v96 + 2 * v104;
                  v70 += v788;
                  v60 += 2 * (int)v24;
                  --v98;
                }
                while (v98);
                if (v810)
                {
                  unsigned int v105 = &v71[v812];
                  BOOL v106 = (unint64_t)v105 >= v810;
                  if ((unint64_t)v105 >= v810) {
                    uint64_t v107 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v107 = 0;
                  }
                  uint64_t v55 = &v105[v107];
                  unint64_t v108 = v65 + 2 * v107;
                  if (v106) {
                    uint64_t v109 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v109 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v109];
                  unint64_t v65 = v108 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v97;
              }
              while (v97);
            }
            else
            {
              int v480 = v841[0];
              int v63 = (char *)v827;
              do
              {
                int v481 = v10;
                do
                {
                  unsigned int v482 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  if (v482)
                  {
                    if (v482 == 0xFFFF)
                    {
                      LOWORD(v482) = *v55;
                    }
                    else
                    {
                      unsigned int v483 = bswap32((unsigned __int16)*v55) >> 16;
                      unsigned int v482 = bswap32(v483 - ((v483 * (v482 ^ 0xFFFF) + ((v483 * (v482 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
                    }
                  }
                  *unsigned int v70 = v482;
                  uint64_t v484 = &v55[v788];
                  if ((unint64_t)v484 >= v65) {
                    uint64_t v485 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v485 = 0;
                  }
                  uint64_t v55 = &v484[v485];
                  v62 += 2 * v485;
                  v70 += v788;
                  v60 += 2 * (int)v24;
                  --v481;
                }
                while (v481);
                if (v810)
                {
                  uint64_t v486 = &v71[v812];
                  BOOL v487 = (unint64_t)v486 >= v810;
                  if ((unint64_t)v486 >= v810) {
                    uint64_t v488 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v488 = 0;
                  }
                  uint64_t v55 = &v486[v488];
                  unint64_t v489 = v65 + 2 * v488;
                  if (v487) {
                    uint64_t v490 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v490 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v490];
                  unint64_t v65 = v489 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v480;
              }
              while (v480);
            }
            goto LABEL_947;
          case 4:
            int v110 = v841[0];
            do
            {
              int v111 = v10;
              do
              {
                unsigned int v112 = bswap32(*(unsigned __int16 *)v60) >> 16;
                if (v112)
                {
                  if (v112 != 0xFFFF)
                  {
                    if (v40) {
                      unsigned int v114 = bswap32(*(unsigned __int16 *)v62) >> 16;
                    }
                    else {
                      unsigned int v114 = 0xFFFF;
                    }
                    unsigned int v115 = bswap32((unsigned __int16)*v55) >> 16;
                    *unsigned int v70 = bswap32(v115 - ((v115 * v112 + ((v115 * v112) >> 16) + 1) >> 16)) >> 16;
                    unsigned int v113 = bswap32(v114 - ((v114 * v112 + ((v114 * v112) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    LOWORD(v113) = 0;
                    *unsigned int v70 = 0;
                  }
                }
                else
                {
                  if (v40) {
                    unsigned int v113 = bswap32(*(unsigned __int16 *)v62) >> 16;
                  }
                  else {
                    unsigned int v113 = 0xFFFF;
                  }
                  LOWORD(v113) = __rev16(v113);
                }
                *(_WORD *)int v60 = v113;
                unsigned int v116 = &v55[v788];
                if ((unint64_t)v116 >= v65) {
                  uint64_t v117 = -(uint64_t)v790;
                }
                else {
                  uint64_t v117 = 0;
                }
                uint64_t v55 = &v116[v117];
                v62 += 2 * (int)v40 + 2 * v117;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v111;
              }
              while (v111);
              if (v810)
              {
                unsigned int v118 = &v71[v812];
                BOOL v119 = (unint64_t)v118 >= v810;
                if ((unint64_t)v118 >= v810) {
                  uint64_t v120 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v120 = 0;
                }
                uint64_t v55 = &v118[v120];
                unint64_t v121 = v65 + 2 * v120;
                if (v119) {
                  uint64_t v122 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v122 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v122);
                unint64_t v65 = v121 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v110;
            }
            while (v110);
            goto LABEL_861;
          case 5:
            uint64_t v123 = (int)v40;
            int v124 = v841[0];
            int v63 = (char *)v827;
            do
            {
              int v125 = v10;
              do
              {
                unsigned int v126 = bswap32(*(unsigned __int16 *)v60);
                unsigned int v127 = bswap32(*(unsigned __int16 *)v62) >> 16;
                unsigned int v128 = bswap32((unsigned __int16)*v70);
                unsigned int v129 = (bswap32((unsigned __int16)*v55) >> 16) * HIWORD(v126);
                *unsigned int v70 = bswap32(v129 + HIWORD(v128) * (v127 ^ 0xFFFF) + ((v129 + HIWORD(v128) * (v127 ^ 0xFFFF)) >> 16) + 1);
                *(_WORD *)int v60 = bswap32(((v127 ^ 0xFFFF) + HIWORD(v126)) * v127+ ((((v127 ^ 0xFFFF) + HIWORD(v126)) * v127) >> 16)+ 1);
                unsigned int v130 = &v55[v788];
                if ((unint64_t)v130 >= v65) {
                  uint64_t v131 = -(uint64_t)v790;
                }
                else {
                  uint64_t v131 = 0;
                }
                uint64_t v55 = &v130[v131];
                v62 += 2 * v123 + 2 * v131;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v125;
              }
              while (v125);
              if (v810)
              {
                int v132 = &v71[v812];
                BOOL v133 = (unint64_t)v132 >= v810;
                if ((unint64_t)v132 >= v810) {
                  uint64_t v134 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v134 = 0;
                }
                uint64_t v55 = &v132[v134];
                unint64_t v135 = v65 + 2 * v134;
                if (v133) {
                  uint64_t v136 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v136 = 0;
                }
                uint64_t v62 = &v63[2 * v833 + 2 * v136];
                unint64_t v65 = v135 + 2 * v812;
                uint64_t v71 = v55;
                int v63 = v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v124;
            }
            while (v124);
            goto LABEL_947;
          case 6:
            int v137 = v841[0];
            uint64_t v138 = 2 * (int)v24;
            do
            {
              int v139 = v10;
              do
              {
                unsigned int v140 = bswap32(*(unsigned __int16 *)v60);
                if (HIWORD(v140) != 0xFFFF)
                {
                  if ((unsigned __int16)~HIWORD(v140) == 0xFFFF)
                  {
                    *unsigned int v70 = *v55;
                    if (v40) {
                      unsigned int v141 = bswap32(*(unsigned __int16 *)v62) >> 16;
                    }
                    else {
                      unsigned int v141 = 0xFFFF;
                    }
                  }
                  else
                  {
                    if (v40) {
                      unsigned int v142 = bswap32(*(unsigned __int16 *)v62) >> 16;
                    }
                    else {
                      unsigned int v142 = 0xFFFF;
                    }
                    unsigned int v143 = HIWORD(v140);
                    int v144 = (unsigned __int16)~HIWORD(v140);
                    unsigned int v145 = (bswap32((unsigned __int16)*v55) >> 16) * v144;
                    *unsigned int v70 = bswap32((bswap32((unsigned __int16)*v70) >> 16) + ((v145 + HIWORD(v145) + 1) >> 16)) >> 16;
                    unsigned int v141 = v143 + ((v142 * v144 + ((v142 * v144) >> 16) + 1) >> 16);
                  }
                  *(_WORD *)int v60 = bswap32(v141) >> 16;
                }
                int v146 = &v55[v788];
                if ((unint64_t)v146 >= v65) {
                  uint64_t v147 = -(uint64_t)v790;
                }
                else {
                  uint64_t v147 = 0;
                }
                uint64_t v55 = &v146[v147];
                v62 += 2 * (int)v40 + 2 * v147;
                v70 += v788;
                v60 += v138;
                --v139;
              }
              while (v139);
              if (v810)
              {
                int v148 = &v71[v812];
                BOOL v149 = (unint64_t)v148 >= v810;
                if ((unint64_t)v148 >= v810) {
                  uint64_t v150 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v150 = 0;
                }
                uint64_t v55 = &v148[v150];
                unint64_t v151 = v65 + 2 * v150;
                if (v149) {
                  uint64_t v152 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v152 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v152);
                unint64_t v65 = v151 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v137;
            }
            while (v137);
            goto LABEL_861;
          case 7:
            if (v24)
            {
              uint64_t v153 = (int)v40;
              int v154 = v841[0];
              int v63 = (char *)v827;
              do
              {
                int v155 = v10;
                do
                {
                  unsigned int v156 = bswap32(*(unsigned __int16 *)v62) >> 16;
                  if (v156 != 0xFFFF)
                  {
                    if (v156)
                    {
                      unsigned int v157 = bswap32((unsigned __int16)*v70) >> 16;
                      unsigned int v158 = bswap32(*(unsigned __int16 *)v60) >> 16;
                      int v159 = v156 ^ 0xFFFF;
                      *unsigned int v70 = bswap32(v157 - ((v157 * v159 + ((v157 * v159) >> 16) + 1) >> 16)) >> 16;
                      unsigned int v156 = bswap32(v158 - ((v158 * v159 + ((v158 * v159) >> 16) + 1) >> 16)) >> 16;
                    }
                    else
                    {
                      *unsigned int v70 = 0;
                    }
                    *(_WORD *)int v60 = v156;
                  }
                  uint64_t v160 = &v55[v788];
                  if ((unint64_t)v160 >= v65) {
                    uint64_t v161 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v161 = 0;
                  }
                  uint64_t v55 = &v160[v161];
                  v62 += 2 * v153 + 2 * v161;
                  v70 += v788;
                  v60 += 2 * (int)v24;
                  --v155;
                }
                while (v155);
                if (v810)
                {
                  int v162 = &v71[v812];
                  BOOL v163 = (unint64_t)v162 >= v810;
                  if ((unint64_t)v162 >= v810) {
                    uint64_t v164 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v164 = 0;
                  }
                  uint64_t v55 = &v162[v164];
                  unint64_t v165 = v65 + 2 * v164;
                  if (v163) {
                    uint64_t v166 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v166 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v166];
                  unint64_t v65 = v165 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v154;
              }
              while (v154);
              goto LABEL_947;
            }
            uint64_t v491 = (int)v40;
            int v492 = v841[0];
            int v63 = (char *)v827;
LABEL_798:
            int v493 = v10;
            while (1)
            {
              unsigned int v494 = bswap32(*(unsigned __int16 *)v62) >> 16;
              if (!v494) {
                goto LABEL_802;
              }
              if (v494 != 0xFFFF) {
                break;
              }
LABEL_803:
              int v496 = &v55[v788];
              if ((unint64_t)v496 >= v65) {
                uint64_t v497 = -(uint64_t)v790;
              }
              else {
                uint64_t v497 = 0;
              }
              uint64_t v55 = &v496[v497];
              v62 += 2 * v491 + 2 * v497;
              v70 += v788;
              if (!--v493)
              {
                if (v810)
                {
                  unsigned int v498 = &v71[v812];
                  BOOL v499 = (unint64_t)v498 >= v810;
                  if ((unint64_t)v498 >= v810) {
                    uint64_t v500 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v500 = 0;
                  }
                  uint64_t v55 = &v498[v500];
                  unint64_t v501 = v65 + 2 * v500;
                  if (v499) {
                    uint64_t v502 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v502 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v502];
                  unint64_t v65 = v501 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                if (!--v492) {
                  goto LABEL_947;
                }
                goto LABEL_798;
              }
            }
            unsigned int v495 = bswap32((unsigned __int16)*v70) >> 16;
            unsigned int v494 = bswap32(v495 - ((v495 * (v494 ^ 0xFFFF) + ((v495 * (v494 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
LABEL_802:
            *unsigned int v70 = v494;
            goto LABEL_803;
          case 8:
            uint64_t v167 = (int)v40;
            if (!v24)
            {
              int v503 = v841[0];
              int v63 = (char *)v827;
              while (1)
              {
                int v504 = v10;
                do
                {
                  unsigned int v505 = bswap32(*(unsigned __int16 *)v62);
                  if (HIWORD(v505) == 0xFFFF)
                  {
                    unsigned int v507 = ~HIWORD(v505);
                  }
                  else
                  {
                    if ((unsigned __int16)~HIWORD(v505) == 0xFFFF) {
                      goto LABEL_825;
                    }
                    unsigned int v506 = bswap32((unsigned __int16)*v70) >> 16;
                    unsigned int v507 = bswap32(v506 - ((v506 * HIWORD(v505) + ((v506 * HIWORD(v505)) >> 16) + 1) >> 16)) >> 16;
                  }
                  *unsigned int v70 = v507;
LABEL_825:
                  unsigned int v508 = &v55[v788];
                  if ((unint64_t)v508 >= v65) {
                    uint64_t v509 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v509 = 0;
                  }
                  uint64_t v55 = &v508[v509];
                  v62 += 2 * v167 + 2 * v509;
                  v70 += v788;
                  --v504;
                }
                while (v504);
                if (v810)
                {
                  int v510 = &v71[v812];
                  BOOL v511 = (unint64_t)v510 >= v810;
                  if ((unint64_t)v510 >= v810) {
                    uint64_t v512 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v512 = 0;
                  }
                  uint64_t v55 = &v510[v512];
                  unint64_t v513 = v65 + 2 * v512;
                  if (v511) {
                    uint64_t v514 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v514 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v514];
                  unint64_t v65 = v513 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                if (!--v503) {
                  goto LABEL_947;
                }
              }
            }
            int v168 = v841[0];
            int v63 = (char *)v827;
            do
            {
              int v169 = v10;
              do
              {
                unsigned int v170 = bswap32(*(unsigned __int16 *)v62) >> 16;
                if (v170)
                {
                  if (v170 != 0xFFFF)
                  {
                    unsigned int v172 = bswap32((unsigned __int16)*v70) >> 16;
                    unsigned int v173 = bswap32(*(unsigned __int16 *)v60) >> 16;
                    *unsigned int v70 = bswap32(v172 - ((v172 * v170 + ((v172 * v170) >> 16) + 1) >> 16)) >> 16;
                    unsigned int v171 = bswap32(v173 - ((v173 * v170 + ((v173 * v170) >> 16) + 1) >> 16)) >> 16;
                  }
                  else
                  {
                    LOWORD(v171) = 0;
                    *unsigned int v70 = 0;
                  }
                  *(_WORD *)int v60 = v171;
                }
                unsigned int v174 = &v55[v788];
                if ((unint64_t)v174 >= v65) {
                  uint64_t v175 = -(uint64_t)v790;
                }
                else {
                  uint64_t v175 = 0;
                }
                uint64_t v55 = &v174[v175];
                v62 += 2 * v167 + 2 * v175;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v169;
              }
              while (v169);
              if (v810)
              {
                uint64_t v176 = &v71[v812];
                BOOL v177 = (unint64_t)v176 >= v810;
                if ((unint64_t)v176 >= v810) {
                  uint64_t v178 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v178 = 0;
                }
                uint64_t v55 = &v176[v178];
                unint64_t v179 = v65 + 2 * v178;
                if (v177) {
                  uint64_t v180 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v180 = 0;
                }
                uint64_t v62 = &v63[2 * v833 + 2 * v180];
                unint64_t v65 = v179 + 2 * v812;
                uint64_t v71 = v55;
                int v63 = v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v168;
            }
            while (v168);
LABEL_947:
            v808 = v71;
            uint64_t v58 = v65;
            v841[0] = 0;
LABEL_948:
            uint64_t v44 = v791;
            uint64_t v55 = (_WORD *)v792;
            if (!v791) {
              return 1;
            }
LABEL_949:
            uint64_t v840 = 0;
            continue;
          case 9:
            uint64_t v181 = (int)v40;
            int v182 = v841[0];
            int v63 = (char *)v827;
            do
            {
              int v183 = v10;
              do
              {
                unsigned int v184 = bswap32(*(unsigned __int16 *)v62) >> 16;
                unsigned int v185 = bswap32(~*(unsigned __int16 *)v60);
                unsigned int v186 = (bswap32((unsigned __int16)*v55) >> 16) * HIWORD(v185)
                     + (bswap32((unsigned __int16)*v70) >> 16) * v184;
                *unsigned int v70 = bswap32(v186 + HIWORD(v186) + 1);
                *(_WORD *)int v60 = bswap32((v184 + HIWORD(v185)) * v184 + (((v184 + HIWORD(v185)) * v184) >> 16) + 1);
                unsigned int v187 = &v55[v788];
                if ((unint64_t)v187 >= v65) {
                  uint64_t v188 = -(uint64_t)v790;
                }
                else {
                  uint64_t v188 = 0;
                }
                uint64_t v55 = &v187[v188];
                v62 += 2 * v181 + 2 * v188;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v183;
              }
              while (v183);
              if (v810)
              {
                int v189 = &v71[v812];
                BOOL v190 = (unint64_t)v189 >= v810;
                if ((unint64_t)v189 >= v810) {
                  uint64_t v191 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v191 = 0;
                }
                uint64_t v55 = &v189[v191];
                unint64_t v192 = v65 + 2 * v191;
                if (v190) {
                  uint64_t v193 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v193 = 0;
                }
                uint64_t v62 = &v63[2 * v833 + 2 * v193];
                unint64_t v65 = v192 + 2 * v812;
                uint64_t v71 = v55;
                int v63 = v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v182;
            }
            while (v182);
            goto LABEL_947;
          case 10:
            uint64_t v194 = (int)v40;
            int v195 = v841[0];
            int v63 = (char *)v827;
            do
            {
              int v196 = v10;
              do
              {
                unsigned int v197 = bswap32(*(unsigned __int16 *)v62) >> 16;
                unsigned int v198 = bswap32(~*(unsigned __int16 *)v60);
                unsigned int v199 = (bswap32((unsigned __int16)*v55) >> 16) * HIWORD(v198)
                     + (bswap32((unsigned __int16)*v70) >> 16) * (v197 ^ 0xFFFF);
                *unsigned int v70 = bswap32(v199 + HIWORD(v199) + 1);
                *(_WORD *)int v60 = bswap32(((v197 ^ 0xFFFF) + HIWORD(v198)) * v197+ ((((v197 ^ 0xFFFF) + HIWORD(v198)) * v197) >> 16)+ 1);
                int v200 = &v55[v788];
                if ((unint64_t)v200 >= v65) {
                  uint64_t v201 = -(uint64_t)v790;
                }
                else {
                  uint64_t v201 = 0;
                }
                uint64_t v55 = &v200[v201];
                v62 += 2 * v194 + 2 * v201;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v196;
              }
              while (v196);
              if (v810)
              {
                unsigned int v202 = &v71[v812];
                BOOL v203 = (unint64_t)v202 >= v810;
                if ((unint64_t)v202 >= v810) {
                  uint64_t v204 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v204 = 0;
                }
                uint64_t v55 = &v202[v204];
                unint64_t v205 = v65 + 2 * v204;
                if (v203) {
                  uint64_t v206 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v206 = 0;
                }
                uint64_t v62 = &v63[2 * v833 + 2 * v206];
                unint64_t v65 = v205 + 2 * v812;
                uint64_t v71 = v55;
                int v63 = v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v195;
            }
            while (v195);
            goto LABEL_947;
          case 11:
            if (v24)
            {
              int v207 = v841[0];
              do
              {
                int v208 = v10;
                do
                {
                  if (v40) {
                    unsigned int v209 = bswap32(*(unsigned __int16 *)v62) >> 16;
                  }
                  else {
                    unsigned int v209 = 0xFFFF;
                  }
                  unsigned int v210 = bswap32(*(unsigned __int16 *)v60) >> 16;
                  int v211 = v210
                       - ((bswap32((unsigned __int16)*v70) >> 16)
                        + (bswap32((unsigned __int16)*v55) >> 16))
                       + v209;
                  unsigned int v212 = v209 + v210;
                  if (v211 >= 0xFFFF) {
                    int v211 = 0xFFFF;
                  }
                  if (v212 >= 0xFFFF) {
                    unsigned int v212 = 0xFFFF;
                  }
                  *unsigned int v70 = bswap32(v212 - v211) >> 16;
                  *(_WORD *)int v60 = bswap32(v212) >> 16;
                  int v213 = &v55[v788];
                  if ((unint64_t)v213 >= v65) {
                    uint64_t v214 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v214 = 0;
                  }
                  uint64_t v55 = &v213[v214];
                  v62 += 2 * (int)v40 + 2 * v214;
                  v70 += v788;
                  v60 += 2 * (int)v24;
                  --v208;
                }
                while (v208);
                if (v810)
                {
                  int v215 = &v71[v812];
                  BOOL v216 = (unint64_t)v215 >= v810;
                  if ((unint64_t)v215 >= v810) {
                    uint64_t v217 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v217 = 0;
                  }
                  uint64_t v55 = &v215[v217];
                  unint64_t v218 = v65 + 2 * v217;
                  if (v216) {
                    uint64_t v219 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v219 = 0;
                  }
                  uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v219);
                  unint64_t v65 = v218 + 2 * v812;
                  uint64_t v71 = v55;
                  uint64_t v827 = (uint64_t)v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v207;
              }
              while (v207);
            }
            else
            {
              int v515 = v841[0];
              do
              {
                int v516 = v10;
                do
                {
                  if (v40) {
                    unsigned int v517 = bswap32(*(unsigned __int16 *)v62) >> 16;
                  }
                  else {
                    unsigned int v517 = 0xFFFF;
                  }
                  signed int v518 = v517 - (bswap32((unsigned __int16)*v55) >> 16) + (bswap32(~(unsigned __int16)*v70) >> 16);
                  if (v518 >= 0xFFFF) {
                    signed int v518 = 0xFFFF;
                  }
                  *unsigned int v70 = bswap32(~v518) >> 16;
                  uint64_t v519 = &v55[v788];
                  if ((unint64_t)v519 >= v65) {
                    uint64_t v520 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v520 = 0;
                  }
                  uint64_t v55 = &v519[v520];
                  v62 += 2 * (int)v40 + 2 * v520;
                  v70 += v788;
                  --v516;
                }
                while (v516);
                if (v810)
                {
                  uint64_t v521 = &v71[v812];
                  BOOL v522 = (unint64_t)v521 >= v810;
                  if ((unint64_t)v521 >= v810) {
                    uint64_t v523 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v523 = 0;
                  }
                  uint64_t v55 = &v521[v523];
                  unint64_t v524 = v65 + 2 * v523;
                  if (v522) {
                    uint64_t v525 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v525 = 0;
                  }
                  uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v525);
                  unint64_t v65 = v524 + 2 * v812;
                  uint64_t v71 = v55;
                  uint64_t v827 = (uint64_t)v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v515;
              }
              while (v515);
            }
            goto LABEL_861;
          case 12:
            if (!v24)
            {
              uint64_t v526 = (int)v40;
              int v527 = v841[0];
              int v63 = (char *)v827;
              do
              {
                int v528 = v10;
                do
                {
                  int v529 = bswap32((unsigned __int16)*v70);
                  *unsigned int v70 = bswap32((v529 >> 15) & 0xFFFE | ((v529 >> 16) >> 15)) >> 16;
                  int v530 = &v55[v788];
                  if ((unint64_t)v530 >= v65) {
                    uint64_t v531 = -(uint64_t)v790;
                  }
                  else {
                    uint64_t v531 = 0;
                  }
                  uint64_t v55 = &v530[v531];
                  v62 += 2 * v526 + 2 * v531;
                  v70 += v788;
                  --v528;
                }
                while (v528);
                if (v810)
                {
                  unsigned int v532 = &v71[v812];
                  BOOL v533 = (unint64_t)v532 >= v810;
                  if ((unint64_t)v532 >= v810) {
                    uint64_t v534 = -(uint64_t)(v812 * v789);
                  }
                  else {
                    uint64_t v534 = 0;
                  }
                  uint64_t v55 = &v532[v534];
                  unint64_t v535 = v65 + 2 * v534;
                  if (v533) {
                    uint64_t v536 = -(uint64_t)(v833 * v789);
                  }
                  else {
                    uint64_t v536 = 0;
                  }
                  uint64_t v62 = &v63[2 * v833 + 2 * v536];
                  unint64_t v65 = v535 + 2 * v812;
                  uint64_t v71 = v55;
                  int v63 = v62;
                }
                else
                {
                  v55 += v812;
                  v62 += 2 * v833;
                }
                v70 += v829;
                v60 += 2 * v831;
                --v527;
              }
              while (v527);
              goto LABEL_947;
            }
            int v220 = v841[0];
            do
            {
              int v221 = v10;
              do
              {
                if (v40) {
                  unsigned int v222 = bswap32(*(unsigned __int16 *)v62) >> 16;
                }
                else {
                  unsigned int v222 = 0xFFFF;
                }
                unsigned int v223 = (bswap32((unsigned __int16)*v55) >> 16) + (bswap32((unsigned __int16)*v70) >> 16);
                unsigned int v224 = v222 + (bswap32(*(unsigned __int16 *)v60) >> 16);
                if (v223 >= 0xFFFF) {
                  unsigned int v223 = 0xFFFF;
                }
                if (v224 >= 0xFFFF) {
                  unsigned int v224 = 0xFFFF;
                }
                *unsigned int v70 = bswap32(v223) >> 16;
                *(_WORD *)int v60 = bswap32(v224) >> 16;
                unsigned int v225 = &v55[v788];
                if ((unint64_t)v225 >= v65) {
                  uint64_t v226 = -(uint64_t)v790;
                }
                else {
                  uint64_t v226 = 0;
                }
                uint64_t v55 = &v225[v226];
                v62 += 2 * (int)v40 + 2 * v226;
                v70 += v788;
                v60 += 2 * (int)v24;
                --v221;
              }
              while (v221);
              if (v810)
              {
                int v227 = &v71[v812];
                BOOL v228 = (unint64_t)v227 >= v810;
                if ((unint64_t)v227 >= v810) {
                  uint64_t v229 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v229 = 0;
                }
                uint64_t v55 = &v227[v229];
                unint64_t v230 = v65 + 2 * v229;
                if (v228) {
                  uint64_t v231 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v231 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v231);
                unint64_t v65 = v230 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              --v220;
            }
            while (v220);
LABEL_861:
            v808 = v71;
            uint64_t v58 = v65;
            v841[0] = 0;
            goto LABEL_862;
          case 13:
            int v232 = v841[0];
            while (1)
            {
              int v233 = v10;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_348;
                  }
                  LODWORD(v234) = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_335:
                    unsigned int v235 = 0xFFFF;
                    goto LABEL_336;
                  }
                }
                else
                {
                  LODWORD(v234) = 0xFFFF;
                  if (!v24) {
                    goto LABEL_335;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
LABEL_346:
                  unsigned int v242 = v60;
                  goto LABEL_347;
                }
                unsigned int v235 = __rev16(*(unsigned __int16 *)v60);
LABEL_336:
                unsigned int v236 = bswap32((unsigned __int16)*v55);
                unint64_t v237 = (v235 ^ 0xFFFF) * (unint64_t)HIWORD(v236)
                     + ((v234 ^ 0xFFFF) + HIWORD(v236))
                     * (unint64_t)(bswap32((unsigned __int16)*v70) >> 16);
                if (v237 <= 0xFFFE8000) {
                  unint64_t v238 = v237 + 0x8000;
                }
                else {
                  unint64_t v238 = 4294868992;
                }
                unint64_t v239 = v238 + (v238 >> 16);
                if (v24)
                {
                  int64_t v240 = 0xFFFF * (v235 + (unint64_t)v234)
                       - v235 * (unint64_t)v234;
                  if (v240 <= 4294868992) {
                    unint64_t v241 = v240 + 0x8000;
                  }
                  else {
                    unint64_t v241 = 4294868992;
                  }
                  *unsigned int v70 = bswap32(v239);
                  unint64_t v234 = ((v239 >> 16) | (v241 + (v241 >> 16))) >> 16;
                  goto LABEL_346;
                }
                unint64_t v234 = v239 >> 16;
                unsigned int v242 = (char *)v70;
LABEL_347:
                *(_WORD *)unsigned int v242 = bswap32(v234) >> 16;
LABEL_348:
                v60 += 2 * (int)v24;
                unsigned int v243 = &v55[v788];
                if ((unint64_t)v243 >= v65) {
                  uint64_t v244 = -(uint64_t)v790;
                }
                else {
                  uint64_t v244 = 0;
                }
                uint64_t v55 = &v243[v244];
                v62 += 2 * (int)v40 + 2 * v244;
                v70 += v788;
                --v233;
              }
              while (v233);
              if (v810)
              {
                uint64_t v245 = &v71[v812];
                BOOL v246 = (unint64_t)v245 >= v810;
                if ((unint64_t)v245 >= v810) {
                  uint64_t v247 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v247 = 0;
                }
                uint64_t v55 = &v245[v247];
                unint64_t v248 = v65 + 2 * v247;
                if (v246) {
                  uint64_t v249 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v249 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v249);
                unint64_t v65 = v248 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              if (!--v232) {
                goto LABEL_861;
              }
            }
          case 14:
            int v250 = v841[0];
            while (1)
            {
              int v251 = v10;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_384;
                  }
                  LODWORD(v252) = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_371:
                    unsigned int v253 = 0xFFFF;
                    goto LABEL_372;
                  }
                }
                else
                {
                  LODWORD(v252) = 0xFFFF;
                  if (!v24) {
                    goto LABEL_371;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
LABEL_382:
                  unsigned int v260 = v60;
                  goto LABEL_383;
                }
                unsigned int v253 = __rev16(*(unsigned __int16 *)v60);
LABEL_372:
                uint64_t v254 = bswap32((unsigned __int16)*v70) >> 16;
                unint64_t v255 = (v254 ^ 0xFFFF) * (unint64_t)(bswap32((unsigned __int16)*v55) >> 16)
                     - v254
                     + (v254 << 16);
                if (v255 <= 0xFFFE8000) {
                  unint64_t v256 = v255 + 0x8000;
                }
                else {
                  unint64_t v256 = 4294868992;
                }
                unint64_t v257 = v256 + (v256 >> 16);
                if (v24)
                {
                  int64_t v258 = 0xFFFF * (v253 + (unint64_t)v252)
                       - v253 * (unint64_t)v252;
                  if (v258 <= 4294868992) {
                    unint64_t v259 = v258 + 0x8000;
                  }
                  else {
                    unint64_t v259 = 4294868992;
                  }
                  *unsigned int v70 = bswap32(v257);
                  unint64_t v252 = ((v257 >> 16) | (v259 + (v259 >> 16))) >> 16;
                  goto LABEL_382;
                }
                unint64_t v252 = v257 >> 16;
                unsigned int v260 = (char *)v70;
LABEL_383:
                *(_WORD *)unsigned int v260 = bswap32(v252) >> 16;
LABEL_384:
                v60 += 2 * (int)v24;
                int v261 = &v55[v788];
                if ((unint64_t)v261 >= v65) {
                  uint64_t v262 = -(uint64_t)v790;
                }
                else {
                  uint64_t v262 = 0;
                }
                uint64_t v55 = &v261[v262];
                v62 += 2 * (int)v40 + 2 * v262;
                v70 += v788;
                --v251;
              }
              while (v251);
              if (v810)
              {
                int v263 = &v71[v812];
                BOOL v264 = (unint64_t)v263 >= v810;
                if ((unint64_t)v263 >= v810) {
                  uint64_t v265 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v265 = 0;
                }
                uint64_t v55 = &v263[v265];
                unint64_t v266 = v65 + 2 * v265;
                if (v264) {
                  uint64_t v267 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v267 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v267);
                unint64_t v65 = v266 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              if (!--v250) {
                goto LABEL_861;
              }
            }
          case 15:
            v808 = v71;
            uint64_t v782 = v61;
            int v813 = v10;
            uint64_t v268 = (int)v40;
            int v269 = v841[0];
            uint64_t v270 = 2 * (int)v24;
            while (1)
            {
              int v795 = v269;
              int v271 = v813;
              unint64_t v272 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_412;
                  }
                  unsigned int v273 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_407:
                    unsigned int v274 = 0xFFFF;
                    goto LABEL_408;
                  }
                }
                else
                {
                  unsigned int v273 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_407;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_411;
                }
                unsigned int v274 = __rev16(*(unsigned __int16 *)v60);
LABEL_408:
                unsigned int v275 = PDAoverlayPDA_8925(bswap32((unsigned __int16)*v70) >> 16, v274, bswap32((unsigned __int16)*v55) >> 16, v273);
                *unsigned int v70 = bswap32(v275) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v272;
                if (!v839) {
                  goto LABEL_412;
                }
                unsigned int v273 = HIWORD(v275);
LABEL_411:
                *(_WORD *)int v60 = __rev16(v273);
LABEL_412:
                int v276 = &v55[v788];
                if ((unint64_t)v276 >= v65) {
                  uint64_t v277 = -(uint64_t)v790;
                }
                else {
                  uint64_t v277 = 0;
                }
                uint64_t v55 = &v276[v277];
                v62 += 2 * v268 + 2 * v277;
                v70 += v788;
                v60 += v270;
                --v271;
              }
              while (v271);
              if (v810)
              {
                int v278 = &v808[v812];
                BOOL v279 = (unint64_t)v278 >= v810;
                uint64_t v280 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v278 < v810) {
                  uint64_t v280 = 0;
                }
                uint64_t v55 = &v278[v280];
                unint64_t v281 = v65 + 2 * v280;
                uint64_t v282 = -(uint64_t)(v833 * v789);
                if (!v279) {
                  uint64_t v282 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v282);
                unint64_t v65 = v281 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v269 = v795 - 1;
              if (v795 == 1) {
                goto LABEL_752;
              }
            }
          case 16:
            v808 = v71;
            uint64_t v782 = v61;
            int v814 = v10;
            uint64_t v283 = (int)v40;
            int v284 = v841[0];
            uint64_t v285 = 2 * (int)v24;
            while (1)
            {
              int v796 = v284;
              int v286 = v814;
              unint64_t v287 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_438;
                  }
                  unsigned int v288 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_433:
                    unsigned int v289 = 0xFFFF;
                    goto LABEL_434;
                  }
                }
                else
                {
                  unsigned int v288 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_433;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_437;
                }
                unsigned int v289 = __rev16(*(unsigned __int16 *)v60);
LABEL_434:
                unsigned int v290 = PDAdarkenPDA_8927(bswap32((unsigned __int16)*v70) >> 16, v289, bswap32((unsigned __int16)*v55) >> 16, v288);
                *unsigned int v70 = bswap32(v290) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v287;
                if (!v839) {
                  goto LABEL_438;
                }
                unsigned int v288 = HIWORD(v290);
LABEL_437:
                *(_WORD *)int v60 = __rev16(v288);
LABEL_438:
                unsigned int v291 = &v55[v788];
                if ((unint64_t)v291 >= v65) {
                  uint64_t v292 = -(uint64_t)v790;
                }
                else {
                  uint64_t v292 = 0;
                }
                uint64_t v55 = &v291[v292];
                v62 += 2 * v283 + 2 * v292;
                v70 += v788;
                v60 += v285;
                --v286;
              }
              while (v286);
              if (v810)
              {
                int v293 = &v808[v812];
                BOOL v294 = (unint64_t)v293 >= v810;
                uint64_t v295 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v293 < v810) {
                  uint64_t v295 = 0;
                }
                uint64_t v55 = &v293[v295];
                unint64_t v296 = v65 + 2 * v295;
                uint64_t v297 = -(uint64_t)(v833 * v789);
                if (!v294) {
                  uint64_t v297 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v297);
                unint64_t v65 = v296 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v284 = v796 - 1;
              if (v796 == 1) {
                goto LABEL_752;
              }
            }
          case 17:
            v808 = v71;
            uint64_t v782 = v61;
            int v815 = v10;
            uint64_t v298 = (int)v40;
            int v299 = v841[0];
            uint64_t v300 = 2 * (int)v24;
            while (1)
            {
              int v797 = v299;
              int v301 = v815;
              unint64_t v302 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_464;
                  }
                  unsigned int v303 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_459:
                    unsigned int v304 = 0xFFFF;
                    goto LABEL_460;
                  }
                }
                else
                {
                  unsigned int v303 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_459;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_463;
                }
                unsigned int v304 = __rev16(*(unsigned __int16 *)v60);
LABEL_460:
                unsigned int v305 = PDAlightenPDA_8926(bswap32((unsigned __int16)*v70) >> 16, v304, bswap32((unsigned __int16)*v55) >> 16, v303);
                *unsigned int v70 = bswap32(v305) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v302;
                if (!v839) {
                  goto LABEL_464;
                }
                unsigned int v303 = HIWORD(v305);
LABEL_463:
                *(_WORD *)int v60 = __rev16(v303);
LABEL_464:
                unsigned int v306 = &v55[v788];
                if ((unint64_t)v306 >= v65) {
                  uint64_t v307 = -(uint64_t)v790;
                }
                else {
                  uint64_t v307 = 0;
                }
                uint64_t v55 = &v306[v307];
                v62 += 2 * v298 + 2 * v307;
                v70 += v788;
                v60 += v300;
                --v301;
              }
              while (v301);
              if (v810)
              {
                unsigned int v308 = &v808[v812];
                BOOL v309 = (unint64_t)v308 >= v810;
                uint64_t v310 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v308 < v810) {
                  uint64_t v310 = 0;
                }
                uint64_t v55 = &v308[v310];
                unint64_t v311 = v65 + 2 * v310;
                uint64_t v312 = -(uint64_t)(v833 * v789);
                if (!v309) {
                  uint64_t v312 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v312);
                unint64_t v65 = v311 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v299 = v797 - 1;
              if (v797 == 1) {
                goto LABEL_752;
              }
            }
          case 18:
            v808 = v71;
            uint64_t v782 = v61;
            int v816 = v10;
            uint64_t v313 = (int)v40;
            int v314 = v841[0];
            uint64_t v315 = 2 * (int)v24;
            while (1)
            {
              int v798 = v314;
              int v316 = v816;
              unint64_t v317 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_490;
                  }
                  unsigned int v318 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_485:
                    unsigned int v319 = 0xFFFF;
                    goto LABEL_486;
                  }
                }
                else
                {
                  unsigned int v318 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_485;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_489;
                }
                unsigned int v319 = __rev16(*(unsigned __int16 *)v60);
LABEL_486:
                unsigned int v320 = PDAcolordodgePDA_8928(bswap32((unsigned __int16)*v70) >> 16, v319, bswap32((unsigned __int16)*v55) >> 16, v318);
                *unsigned int v70 = bswap32(v320) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v317;
                if (!v839) {
                  goto LABEL_490;
                }
                unsigned int v318 = HIWORD(v320);
LABEL_489:
                *(_WORD *)int v60 = __rev16(v318);
LABEL_490:
                unsigned int v321 = &v55[v788];
                if ((unint64_t)v321 >= v65) {
                  uint64_t v322 = -(uint64_t)v790;
                }
                else {
                  uint64_t v322 = 0;
                }
                uint64_t v55 = &v321[v322];
                v62 += 2 * v313 + 2 * v322;
                v70 += v788;
                v60 += v315;
                --v316;
              }
              while (v316);
              if (v810)
              {
                unsigned int v323 = &v808[v812];
                BOOL v324 = (unint64_t)v323 >= v810;
                uint64_t v325 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v323 < v810) {
                  uint64_t v325 = 0;
                }
                uint64_t v55 = &v323[v325];
                unint64_t v326 = v65 + 2 * v325;
                uint64_t v327 = -(uint64_t)(v833 * v789);
                if (!v324) {
                  uint64_t v327 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v327);
                unint64_t v65 = v326 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v314 = v798 - 1;
              if (v798 == 1) {
                goto LABEL_752;
              }
            }
          case 19:
            v808 = v71;
            uint64_t v782 = v61;
            int v817 = v10;
            uint64_t v328 = (int)v40;
            int v329 = v841[0];
            uint64_t v330 = 2 * (int)v24;
            while (1)
            {
              int v799 = v329;
              int v331 = v817;
              unint64_t v332 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_516;
                  }
                  unsigned int v333 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_511:
                    unsigned int v334 = 0xFFFF;
                    goto LABEL_512;
                  }
                }
                else
                {
                  unsigned int v333 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_511;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_515;
                }
                unsigned int v334 = __rev16(*(unsigned __int16 *)v60);
LABEL_512:
                unsigned int v335 = PDAcolorburnPDA_8929(bswap32((unsigned __int16)*v70) >> 16, v334, bswap32((unsigned __int16)*v55) >> 16, v333);
                *unsigned int v70 = bswap32(v335) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v332;
                if (!v839) {
                  goto LABEL_516;
                }
                unsigned int v333 = HIWORD(v335);
LABEL_515:
                *(_WORD *)int v60 = __rev16(v333);
LABEL_516:
                unsigned int v336 = &v55[v788];
                if ((unint64_t)v336 >= v65) {
                  uint64_t v337 = -(uint64_t)v790;
                }
                else {
                  uint64_t v337 = 0;
                }
                uint64_t v55 = &v336[v337];
                v62 += 2 * v328 + 2 * v337;
                v70 += v788;
                v60 += v330;
                --v331;
              }
              while (v331);
              if (v810)
              {
                unsigned int v338 = &v808[v812];
                BOOL v339 = (unint64_t)v338 >= v810;
                uint64_t v340 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v338 < v810) {
                  uint64_t v340 = 0;
                }
                uint64_t v55 = &v338[v340];
                unint64_t v341 = v65 + 2 * v340;
                uint64_t v342 = -(uint64_t)(v833 * v789);
                if (!v339) {
                  uint64_t v342 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v342);
                unint64_t v65 = v341 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v329 = v799 - 1;
              if (v799 == 1) {
                goto LABEL_752;
              }
            }
          case 20:
            v808 = v71;
            uint64_t v783 = v61;
            int v818 = v10;
            uint64_t v343 = (int)v40;
            int v344 = v841[0];
            uint64_t v345 = 2 * (int)v24;
            while (1)
            {
              int v800 = v344;
              int v346 = v818;
              unint64_t v347 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_542;
                  }
                  unsigned int v348 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_537:
                    unsigned int v349 = 0xFFFF;
                    goto LABEL_538;
                  }
                }
                else
                {
                  unsigned int v348 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_537;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_541;
                }
                unsigned int v349 = __rev16(*(unsigned __int16 *)v60);
LABEL_538:
                unsigned int v350 = PDAsoftlightPDA_8931(bswap32((unsigned __int16)*v70) >> 16, v349, bswap32((unsigned __int16)*v55) >> 16, v348);
                *unsigned int v70 = bswap32(v350) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v347;
                if (!v839) {
                  goto LABEL_542;
                }
                unsigned int v348 = HIWORD(v350);
LABEL_541:
                *(_WORD *)int v60 = __rev16(v348);
LABEL_542:
                int v351 = &v55[v788];
                if ((unint64_t)v351 >= v65) {
                  uint64_t v352 = -(uint64_t)v790;
                }
                else {
                  uint64_t v352 = 0;
                }
                uint64_t v55 = &v351[v352];
                v62 += 2 * v343 + 2 * v352;
                v70 += v788;
                v60 += v345;
                --v346;
              }
              while (v346);
              if (v810)
              {
                int v353 = &v808[v812];
                BOOL v354 = (unint64_t)v353 >= v810;
                uint64_t v355 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v353 < v810) {
                  uint64_t v355 = 0;
                }
                uint64_t v55 = &v353[v355];
                unint64_t v356 = v65 + 2 * v355;
                uint64_t v357 = -(uint64_t)(v833 * v789);
                if (!v354) {
                  uint64_t v357 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v357);
                unint64_t v65 = v356 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v344 = v800 - 1;
              if (v800 == 1) {
                goto LABEL_726;
              }
            }
          case 21:
            v808 = v71;
            uint64_t v782 = v61;
            int v819 = v10;
            uint64_t v358 = (int)v40;
            int v359 = v841[0];
            uint64_t v360 = 2 * (int)v24;
            while (1)
            {
              int v801 = v359;
              int v361 = v819;
              unint64_t v362 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_568;
                  }
                  unsigned int v363 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_563:
                    unsigned int v364 = 0xFFFF;
                    goto LABEL_564;
                  }
                }
                else
                {
                  unsigned int v363 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_563;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_567;
                }
                unsigned int v364 = __rev16(*(unsigned __int16 *)v60);
LABEL_564:
                unsigned int v365 = PDAhardlightPDA_8930(bswap32((unsigned __int16)*v70) >> 16, v364, bswap32((unsigned __int16)*v55) >> 16, v363);
                *unsigned int v70 = bswap32(v365) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v362;
                if (!v839) {
                  goto LABEL_568;
                }
                unsigned int v363 = HIWORD(v365);
LABEL_567:
                *(_WORD *)int v60 = __rev16(v363);
LABEL_568:
                unsigned int v366 = &v55[v788];
                if ((unint64_t)v366 >= v65) {
                  uint64_t v367 = -(uint64_t)v790;
                }
                else {
                  uint64_t v367 = 0;
                }
                uint64_t v55 = &v366[v367];
                v62 += 2 * v358 + 2 * v367;
                v70 += v788;
                v60 += v360;
                --v361;
              }
              while (v361);
              if (v810)
              {
                unsigned int v368 = &v808[v812];
                BOOL v369 = (unint64_t)v368 >= v810;
                uint64_t v370 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v368 < v810) {
                  uint64_t v370 = 0;
                }
                uint64_t v55 = &v368[v370];
                unint64_t v371 = v65 + 2 * v370;
                uint64_t v372 = -(uint64_t)(v833 * v789);
                if (!v369) {
                  uint64_t v372 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v372);
                unint64_t v65 = v371 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v359 = v801 - 1;
              if (v801 == 1) {
                goto LABEL_752;
              }
            }
          case 22:
            v808 = v71;
            uint64_t v783 = v61;
            int v820 = v10;
            uint64_t v373 = (int)v40;
            int v374 = v841[0];
            uint64_t v375 = 2 * (int)v24;
            while (1)
            {
              int v802 = v374;
              int v376 = v820;
              unint64_t v377 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_594;
                  }
                  unsigned int v378 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_589:
                    unsigned int v379 = 0xFFFF;
                    goto LABEL_590;
                  }
                }
                else
                {
                  unsigned int v378 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_589;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_593;
                }
                unsigned int v379 = __rev16(*(unsigned __int16 *)v60);
LABEL_590:
                unsigned int v380 = PDAdifferencePDA_8932(bswap32((unsigned __int16)*v70) >> 16, v379, bswap32((unsigned __int16)*v55) >> 16, v378);
                *unsigned int v70 = bswap32(v380) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v377;
                if (!v839) {
                  goto LABEL_594;
                }
                unsigned int v378 = HIWORD(v380);
LABEL_593:
                *(_WORD *)int v60 = __rev16(v378);
LABEL_594:
                int v381 = &v55[v788];
                if ((unint64_t)v381 >= v65) {
                  uint64_t v382 = -(uint64_t)v790;
                }
                else {
                  uint64_t v382 = 0;
                }
                uint64_t v55 = &v381[v382];
                v62 += 2 * v373 + 2 * v382;
                v70 += v788;
                v60 += v375;
                --v376;
              }
              while (v376);
              if (v810)
              {
                unsigned int v383 = &v808[v812];
                BOOL v384 = (unint64_t)v383 >= v810;
                uint64_t v385 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v383 < v810) {
                  uint64_t v385 = 0;
                }
                uint64_t v55 = &v383[v385];
                unint64_t v386 = v65 + 2 * v385;
                uint64_t v387 = -(uint64_t)(v833 * v789);
                if (!v384) {
                  uint64_t v387 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v387);
                unint64_t v65 = v386 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v374 = v802 - 1;
              if (v802 == 1) {
                goto LABEL_726;
              }
            }
          case 23:
            int v388 = v841[0];
            while (1)
            {
              int v389 = v10;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_634;
                  }
                  LODWORD(v390) = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_615:
                    unsigned int v391 = 0xFFFF;
                    goto LABEL_616;
                  }
                }
                else
                {
                  LODWORD(v390) = 0xFFFF;
                  if (!v24) {
                    goto LABEL_615;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
LABEL_632:
                  unsigned int v399 = v60;
                  goto LABEL_633;
                }
                unsigned int v391 = __rev16(*(unsigned __int16 *)v60);
LABEL_616:
                LODWORD(v392) = bswap32((unsigned __int16)*v70) >> 16;
                LODWORD(v393) = bswap32((unsigned __int16)*v55) >> 16;
                if (v393 >= v390) {
                  uint64_t v393 = v390;
                }
                else {
                  uint64_t v393 = v393;
                }
                if (v392 >= v391) {
                  uint64_t v392 = v391;
                }
                else {
                  uint64_t v392 = v392;
                }
                int64_t v394 = 0xFFFF * (v393 + v392) - 2 * v392 * (unint64_t)v393;
                if (v394 <= 4294868992) {
                  unint64_t v395 = v394 + 0x8000;
                }
                else {
                  unint64_t v395 = 4294868992;
                }
                unint64_t v396 = v395 + (v395 >> 16);
                if (v24)
                {
                  int64_t v397 = 0xFFFF * (v391 + (unint64_t)v390)
                       - v391 * (unint64_t)v390;
                  if (v397 <= 4294868992) {
                    unint64_t v398 = v397 + 0x8000;
                  }
                  else {
                    unint64_t v398 = 4294868992;
                  }
                  *unsigned int v70 = bswap32(v396);
                  unint64_t v390 = ((v396 >> 16) | (v398 + (v398 >> 16))) >> 16;
                  goto LABEL_632;
                }
                unint64_t v390 = v396 >> 16;
                unsigned int v399 = (char *)v70;
LABEL_633:
                *(_WORD *)unsigned int v399 = bswap32(v390) >> 16;
LABEL_634:
                v60 += 2 * (int)v24;
                int v400 = &v55[v788];
                if ((unint64_t)v400 >= v65) {
                  uint64_t v401 = -(uint64_t)v790;
                }
                else {
                  uint64_t v401 = 0;
                }
                uint64_t v55 = &v400[v401];
                v62 += 2 * (int)v40 + 2 * v401;
                v70 += v788;
                --v389;
              }
              while (v389);
              if (v810)
              {
                int v402 = &v71[v812];
                BOOL v403 = (unint64_t)v402 >= v810;
                if ((unint64_t)v402 >= v810) {
                  uint64_t v404 = -(uint64_t)(v812 * v789);
                }
                else {
                  uint64_t v404 = 0;
                }
                uint64_t v55 = &v402[v404];
                unint64_t v405 = v65 + 2 * v404;
                if (v403) {
                  uint64_t v406 = -(uint64_t)(v833 * v789);
                }
                else {
                  uint64_t v406 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v406);
                unint64_t v65 = v405 + 2 * v812;
                uint64_t v71 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              if (!--v388) {
                goto LABEL_861;
              }
            }
          case 24:
            v808 = v71;
            uint64_t v783 = v61;
            int v821 = v10;
            uint64_t v407 = (int)v40;
            int v408 = v841[0];
            uint64_t v409 = 2 * (int)v24;
            while (1)
            {
              int v803 = v408;
              int v410 = v821;
              unint64_t v411 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_662;
                  }
                  unsigned int v412 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_657:
                    unsigned int v413 = 0xFFFF;
                    goto LABEL_658;
                  }
                }
                else
                {
                  unsigned int v412 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_657;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_661;
                }
                unsigned int v413 = __rev16(*(unsigned __int16 *)v60);
LABEL_658:
                unsigned int v414 = PDAhuePDA_8933(bswap32((unsigned __int16)*v70) >> 16, v413, bswap32((unsigned __int16)*v55) >> 16, v412);
                *unsigned int v70 = bswap32(v414) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v411;
                if (!v839) {
                  goto LABEL_662;
                }
                unsigned int v412 = HIWORD(v414);
LABEL_661:
                *(_WORD *)int v60 = __rev16(v412);
LABEL_662:
                int v415 = &v55[v788];
                if ((unint64_t)v415 >= v65) {
                  uint64_t v416 = -(uint64_t)v790;
                }
                else {
                  uint64_t v416 = 0;
                }
                uint64_t v55 = &v415[v416];
                v62 += 2 * v407 + 2 * v416;
                v70 += v788;
                v60 += v409;
                --v410;
              }
              while (v410);
              if (v810)
              {
                unsigned int v417 = &v808[v812];
                BOOL v418 = (unint64_t)v417 >= v810;
                uint64_t v419 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v417 < v810) {
                  uint64_t v419 = 0;
                }
                uint64_t v55 = &v417[v419];
                unint64_t v420 = v65 + 2 * v419;
                uint64_t v421 = -(uint64_t)(v833 * v789);
                if (!v418) {
                  uint64_t v421 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v421);
                unint64_t v65 = v420 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v408 = v803 - 1;
              if (v803 == 1) {
                goto LABEL_726;
              }
            }
          case 25:
            v808 = v71;
            uint64_t v783 = v61;
            int v822 = v10;
            uint64_t v422 = (int)v40;
            int v423 = v841[0];
            uint64_t v424 = 2 * (int)v24;
            while (1)
            {
              int v804 = v423;
              int v425 = v822;
              unint64_t v426 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_688;
                  }
                  unsigned int v427 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_683:
                    unsigned int v428 = 0xFFFF;
                    goto LABEL_684;
                  }
                }
                else
                {
                  unsigned int v427 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_683;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_687;
                }
                unsigned int v428 = __rev16(*(unsigned __int16 *)v60);
LABEL_684:
                unsigned int v429 = PDAhuePDA_8933(bswap32((unsigned __int16)*v70) >> 16, v428, bswap32((unsigned __int16)*v55) >> 16, v427);
                *unsigned int v70 = bswap32(v429) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v426;
                if (!v839) {
                  goto LABEL_688;
                }
                unsigned int v427 = HIWORD(v429);
LABEL_687:
                *(_WORD *)int v60 = __rev16(v427);
LABEL_688:
                int v430 = &v55[v788];
                if ((unint64_t)v430 >= v65) {
                  uint64_t v431 = -(uint64_t)v790;
                }
                else {
                  uint64_t v431 = 0;
                }
                uint64_t v55 = &v430[v431];
                v62 += 2 * v422 + 2 * v431;
                v70 += v788;
                v60 += v424;
                --v425;
              }
              while (v425);
              if (v810)
              {
                int v432 = &v808[v812];
                BOOL v433 = (unint64_t)v432 >= v810;
                uint64_t v434 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v432 < v810) {
                  uint64_t v434 = 0;
                }
                uint64_t v55 = &v432[v434];
                unint64_t v435 = v65 + 2 * v434;
                uint64_t v436 = -(uint64_t)(v833 * v789);
                if (!v433) {
                  uint64_t v436 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v436);
                unint64_t v65 = v435 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v423 = v804 - 1;
              if (v804 == 1) {
                goto LABEL_726;
              }
            }
          case 26:
            v808 = v71;
            uint64_t v783 = v61;
            int v823 = v10;
            uint64_t v437 = (int)v40;
            int v438 = v841[0];
            uint64_t v439 = 2 * (int)v24;
            while (1)
            {
              int v805 = v438;
              int v440 = v823;
              unint64_t v441 = v65;
              do
              {
                if (v40)
                {
                  if (!*(_WORD *)v62) {
                    goto LABEL_714;
                  }
                  unsigned int v442 = __rev16(*(unsigned __int16 *)v62);
                  if (!v24)
                  {
LABEL_709:
                    unsigned int v443 = 0xFFFF;
                    goto LABEL_710;
                  }
                }
                else
                {
                  unsigned int v442 = 0xFFFF;
                  if (!v24) {
                    goto LABEL_709;
                  }
                }
                if (!*(_WORD *)v60)
                {
                  *unsigned int v70 = *v55;
                  goto LABEL_713;
                }
                unsigned int v443 = __rev16(*(unsigned __int16 *)v60);
LABEL_710:
                unsigned int v444 = PDAluminosityPDA_8935(bswap32((unsigned __int16)*v55) >> 16, v442, bswap32((unsigned __int16)*v70) >> 16, v443);
                *unsigned int v70 = bswap32(v444) >> 16;
                LODWORD(v40) = v836;
                LODWORD(v24) = v839;
                unint64_t v65 = v441;
                if (!v839) {
                  goto LABEL_714;
                }
                unsigned int v442 = HIWORD(v444);
LABEL_713:
                *(_WORD *)int v60 = __rev16(v442);
LABEL_714:
                uint64_t v445 = &v55[v788];
                if ((unint64_t)v445 >= v65) {
                  uint64_t v446 = -(uint64_t)v790;
                }
                else {
                  uint64_t v446 = 0;
                }
                uint64_t v55 = &v445[v446];
                v62 += 2 * v437 + 2 * v446;
                v70 += v788;
                v60 += v439;
                --v440;
              }
              while (v440);
              if (v810)
              {
                uint64_t v447 = &v808[v812];
                BOOL v448 = (unint64_t)v447 >= v810;
                uint64_t v449 = -(uint64_t)(v812 * v789);
                if ((unint64_t)v447 < v810) {
                  uint64_t v449 = 0;
                }
                uint64_t v55 = &v447[v449];
                unint64_t v450 = v65 + 2 * v449;
                uint64_t v451 = -(uint64_t)(v833 * v789);
                if (!v448) {
                  uint64_t v451 = 0;
                }
                uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v451);
                unint64_t v65 = v450 + 2 * v812;
                v808 = v55;
                uint64_t v827 = (uint64_t)v62;
              }
              else
              {
                v55 += v812;
                v62 += 2 * v833;
              }
              v70 += v829;
              v60 += 2 * v831;
              int v438 = v805 - 1;
              if (v805 == 1)
              {
LABEL_726:
                uint64_t v58 = v65;
                v841[0] = 0;
                uint64_t v61 = v783;
                int v7 = v784;
                unint64_t v9 = v780;
                goto LABEL_862;
              }
            }
          case 27:
            v808 = v71;
            uint64_t v782 = v61;
            int v824 = v10;
            uint64_t v452 = (int)v40;
            int v453 = v841[0];
            uint64_t v454 = 2 * (int)v24;
            break;
          default:
            v808 = v71;
            uint64_t v58 = v65;
            goto LABEL_862;
        }
        break;
      }
LABEL_728:
      int v806 = v453;
      int v455 = v824;
      unint64_t v456 = v65;
      while (1)
      {
        if (v40)
        {
          if (!*(_WORD *)v62) {
            goto LABEL_740;
          }
          unsigned int v457 = __rev16(*(unsigned __int16 *)v62);
          if (v24)
          {
LABEL_732:
            if (!*(_WORD *)v60)
            {
              *unsigned int v70 = *v55;
              goto LABEL_739;
            }
            unsigned int v458 = __rev16(*(unsigned __int16 *)v60);
            goto LABEL_736;
          }
        }
        else
        {
          unsigned int v457 = 0xFFFF;
          if (v24) {
            goto LABEL_732;
          }
        }
        unsigned int v458 = 0xFFFF;
LABEL_736:
        unsigned int v459 = PDAluminosityPDA_8935(bswap32((unsigned __int16)*v70) >> 16, v458, bswap32((unsigned __int16)*v55) >> 16, v457);
        *unsigned int v70 = bswap32(v459) >> 16;
        LODWORD(v40) = v836;
        LODWORD(v24) = v839;
        unint64_t v65 = v456;
        if (v839)
        {
          unsigned int v457 = HIWORD(v459);
LABEL_739:
          *(_WORD *)int v60 = __rev16(v457);
        }
LABEL_740:
        uint64_t v460 = &v55[v788];
        if ((unint64_t)v460 >= v65) {
          uint64_t v461 = -(uint64_t)v790;
        }
        else {
          uint64_t v461 = 0;
        }
        uint64_t v55 = &v460[v461];
        v62 += 2 * v452 + 2 * v461;
        v70 += v788;
        v60 += v454;
        if (!--v455)
        {
          if (v810)
          {
            uint64_t v462 = &v808[v812];
            BOOL v463 = (unint64_t)v462 >= v810;
            uint64_t v464 = -(uint64_t)(v812 * v789);
            if ((unint64_t)v462 < v810) {
              uint64_t v464 = 0;
            }
            uint64_t v55 = &v462[v464];
            unint64_t v465 = v65 + 2 * v464;
            uint64_t v466 = -(uint64_t)(v833 * v789);
            if (!v463) {
              uint64_t v466 = 0;
            }
            uint64_t v62 = (char *)(v827 + 2 * v833 + 2 * v466);
            unint64_t v65 = v465 + 2 * v812;
            v808 = v55;
            uint64_t v827 = (uint64_t)v62;
          }
          else
          {
            v55 += v812;
            v62 += 2 * v833;
          }
          v70 += v829;
          v60 += 2 * v831;
          int v453 = v806 - 1;
          if (v806 == 1)
          {
LABEL_752:
            uint64_t v58 = v65;
            v841[0] = 0;
            uint64_t v61 = v782;
            int v7 = v784;
            unint64_t v9 = v780;
            goto LABEL_862;
          }
          goto LABEL_728;
        }
      }
    }
    unint64_t v64 = v57 * (int)v10;
    unint64_t v831 = v786 - (int)v24 * (int)v10;
    unint64_t v65 = -1;
    int v788 = v57;
    int v789 = v39;
    unint64_t v66 = v812;
    int v790 = v812;
    goto LABEL_62;
  }
  int v15 = *(_DWORD *)(v3 + 128);
  if ((v15 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400) {
      W16_mark_constmask(v3, v7);
    }
    else {
      W16_mark_pixelmask(v3, v7);
    }
    return 1;
  }
  int v25 = *(_DWORD *)(v3 + 112);
  int v26 = *(_DWORD *)(v3 + 116);
  unsigned int v27 = (v25 + 15) & 0xFFFFFFF0;
  size_t v28 = v27 * v26;
  if ((int)v28 <= 4096)
  {
    long long v30 = v851;
    unint64_t v31 = v3;
    goto LABEL_38;
  }
  int v29 = malloc_type_malloc(v28, 0x8303D2FuLL);
  if (v29)
  {
    long long v30 = v29;
    unint64_t v31 = v780;
    uint64_t v14 = *(uint16x4_t **)(v780 + 136);
    int v15 = *(_DWORD *)(v780 + 128);
LABEL_38:
    CGSConvertBitsToMask(v14, *(_DWORD *)(v31 + 124), v30, v27, v25, v26, v15);
    long long v49 = *(_OWORD *)(v31 + 112);
    long long v847 = *(_OWORD *)(v31 + 96);
    long long v848 = v49;
    long long v50 = *(_OWORD *)(v31 + 144);
    long long v849 = *(_OWORD *)(v31 + 128);
    long long v850 = v50;
    long long v51 = *(_OWORD *)(v31 + 48);
    long long v843 = *(_OWORD *)(v31 + 32);
    long long v844 = v51;
    long long v52 = *(_OWORD *)(v31 + 80);
    long long v845 = *(_OWORD *)(v31 + 64);
    long long v846 = v52;
    long long v53 = *(_OWORD *)(v31 + 16);
    *(_OWORD *)v841 = *(_OWORD *)v31;
    long long v842 = v53;
    HIDWORD(v848) = (v25 + 15) & 0xFFFFFFF0;
    *((void *)&v849 + 1) = v30;
    if (BYTE1(v841[0]) << 8 == 1024) {
      W16_mark_constmask((uint64_t)v841, v784);
    }
    else {
      W16_mark_pixelmask((unint64_t)v841, v784);
    }
    if (v30 == (unsigned char *)v851) {
      return 1;
    }
    uint64_t v54 = v30;
    goto LABEL_1380;
  }
  return 1;
}

uint64_t W16_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (_WORD *)*((void *)a2 + 2);
  int v8 = (_WORD *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v124 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v124 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v123 = *a2;
  uint64_t v122 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v121 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v121 * a4;
  int v15 = *(unsigned int **)(a1 + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v8 != 0);
  if (v17)
  {
    uint64_t v118 = *((void *)a2 + 13);
    uint64_t v116 = ~(-1 << v13);
    uint64_t v117 = *((void *)a2 + 15);
    char v115 = v13 - 4;
    uint64_t v19 = (unsigned int *)(v16 - 4);
    int v20 = v9 ^ 0xFFFF;
    uint64_t v114 = a5;
    uint64_t v113 = v11 + 16 * a3 + 8;
    uint64_t v119 = *((void *)a2 + 9);
    int v120 = a5;
    while (1)
    {
      if (((v117 - v14) | (v14 - v118)) < 0)
      {
        int v23 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v116) >> v115) & 0xF;
        uint64_t v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v123 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        int v25 = (uint64_t *)v113;
        uint64_t v26 = v114;
        while (1)
        {
          uint64_t v27 = *(v25 - 1);
          uint64_t v28 = *v25;
          int v29 = &v24[v27];
          if (v19 >= (unsigned int *)&v24[v27]) {
            long long v30 = (unsigned int *)&v24[v27];
          }
          else {
            long long v30 = v19;
          }
          if (v30 < v15) {
            long long v30 = v15;
          }
          unsigned int v31 = *v30;
          char v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            uint64_t v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22]) {
              uint64_t v43 = v19;
            }
            if (v43 < v15) {
              uint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (v44 & *v43) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v45 = __ROL4__(v31, v10);
          int v46 = v45 | v6;
          unsigned int v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          int v48 = 32 * v47;
          v47 >>= 6;
          int v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          unsigned int v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v50 = v49;
          }
          unsigned int v51 = bswap32(v50);
          *int v7 = HIWORD(v51);
          if (v8) {
            _WORD *v8 = v51;
          }
          v25 += 2;
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          if (!--v26) {
            goto LABEL_96;
          }
        }
        unint64_t v33 = (unsigned int *)&v29[v28 >> 4];
        if (v19 < v33) {
          unint64_t v33 = v19;
        }
        if (v33 < v15) {
          unint64_t v33 = v15;
        }
        unsigned int v34 = *v33;
        if (v23)
        {
          uint64_t v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35) {
            unsigned int v36 = v35;
          }
          else {
            unsigned int v36 = v19;
          }
          if (v36 < v15) {
            unsigned int v36 = v15;
          }
          unsigned int v37 = *v36;
          int v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v19 < v38) {
            int v38 = v19;
          }
          if (v38 < v15) {
            int v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        int v40 = BLEND8_21385[*v25 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_46:
        unsigned int v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v122;
      a5 = v120;
      v14 += v121;
      v8 += v124;
      --a6;
      LOBYTE(v13) = v119;
      if (!a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_96;
    }
    long long v53 = (uint64_t *)v113;
    uint64_t v52 = v114;
    while (1)
    {
      uint64_t v54 = *(v53 - 1);
      uint64_t v55 = *v53;
      int32x2_t v56 = &v24[v54];
      if (v19 >= (unsigned int *)&v24[v54]) {
        int v57 = (unsigned int *)&v24[v54];
      }
      else {
        int v57 = v19;
      }
      if (v57 < v15) {
        int v57 = v15;
      }
      unsigned int v58 = *v57;
      char v59 = v55 & 0xF;
      if ((v55 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        unsigned int v70 = (unsigned int *)&v56[v22];
        if (v19 < (unsigned int *)&v56[v22]) {
          unsigned int v70 = v19;
        }
        if (v70 < v15) {
          unsigned int v70 = v15;
        }
        int v71 = BLEND8_21385[v23];
        unsigned int v68 = v58 - ((v71 & v58) >> v23);
        unsigned int v69 = (v71 & *v70) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      unsigned int v72 = __ROL4__(v58, v10);
      int v73 = v72 | v6;
      unsigned int v74 = ((v72 >> 23) & 0x1FE) + BYTE1(v72) + (((v72 >> 8) & 0xFF00) >> 6) + (((v72 >> 8) & 0xFF00) >> 8);
      int v75 = 32 * v74;
      v74 >>= 6;
      int v76 = v74 | (v73 << 24) | (v73 << 16) | v75;
      unsigned int v77 = ((v75 | v74) - (((v75 | v74) * v20 + (((v75 | v74) * v20) >> 16) + 1) >> 16)) | (((v73 | (v73 << 8))
                                                                                            - (((v73 | (v73 << 8))
                                                                                              * v20
                                                                                              + (((v73 | (v73 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF) {
        unsigned int v77 = v76;
      }
      unsigned int v78 = HIWORD(v77);
      if (v8)
      {
        if (v78)
        {
          if (v78 == 0xFFFF)
          {
            *int v7 = bswap32(v77) >> 16;
            _WORD *v8 = -1;
          }
          else
          {
            unsigned int v80 = bswap32((unsigned __int16)*v8) >> 16;
            int v81 = v78 ^ 0xFFFF;
            unsigned int v82 = v81 * (bswap32((unsigned __int16)*v7) >> 16);
            *int v7 = bswap32(v77 + ((v82 + HIWORD(v82) + 1) >> 16)) >> 16;
            _WORD *v8 = bswap32(((v81 * v80 + ((v81 * v80) >> 16) + 1) >> 16) + HIWORD(v77)) >> 16;
          }
        }
      }
      else if (v78)
      {
        if (v78 != 0xFFFF)
        {
          unsigned int v79 = bswap32((unsigned __int16)*v7) >> 16;
          v77 += ((v78 ^ 0xFFFF) * v79 + (((v78 ^ 0xFFFF) * v79) >> 16) + 1) >> 16;
        }
        *int v7 = bswap32(v77) >> 16;
      }
      v53 += 2;
      ++v7;
      int v8 = (_WORD *)((char *)v8 + result);
      if (!--v52) {
        goto LABEL_96;
      }
    }
    int v60 = (unsigned int *)&v56[v55 >> 4];
    if (v19 < v60) {
      int v60 = v19;
    }
    if (v60 < v15) {
      int v60 = v15;
    }
    unsigned int v61 = *v60;
    if (v23)
    {
      uint64_t v62 = &v56[v22];
      if (v19 >= (unsigned int *)&v56[v22]) {
        int v63 = (unsigned int *)&v56[v22];
      }
      else {
        int v63 = v19;
      }
      if (v63 < v15) {
        int v63 = v15;
      }
      unsigned int v64 = *v63;
      unint64_t v65 = (unsigned int *)&v62[v55 >> 4];
      if (v19 < v65) {
        unint64_t v65 = v19;
      }
      if (v65 < v15) {
        unint64_t v65 = v15;
      }
      int v66 = BLEND8_21385[v23];
      unsigned int v58 = v58 - ((v66 & v58) >> v23) + ((v66 & v64) >> v23);
      unsigned int v61 = v61 - ((v66 & v61) >> v23) + ((v66 & *v65) >> v23);
    }
    int v67 = BLEND8_21385[*v53 & 0xF];
    unsigned int v68 = v58 - ((v67 & v58) >> v59);
    unsigned int v69 = (v67 & v61) >> v59;
LABEL_83:
    unsigned int v58 = v68 + v69;
    goto LABEL_84;
  }
  int v83 = (uint64_t *)(v11 + 16 * a3);
  int v84 = v16 - 4;
  int v85 = v9 ^ 0xFFFF;
  do
  {
    unsigned int v86 = (char *)v15 + (v14 >> v13) * v12;
    if (v123 == 1)
    {
      if (a5 >= 1)
      {
        unsigned int v87 = v83;
        uint64_t v88 = a5;
        do
        {
          uint64_t v89 = *v87;
          v87 += 2;
          uint64_t v90 = (unsigned int *)&v86[v89];
          if (v84 < &v86[v89]) {
            uint64_t v90 = (unsigned int *)v84;
          }
          if (v90 < v15) {
            uint64_t v90 = v15;
          }
          unsigned int v91 = __ROL4__(*v90, v10);
          int v92 = v91 | v6;
          unsigned int v93 = ((v91 >> 23) & 0x1FE) + BYTE1(v91) + (((v91 >> 8) & 0xFF00) >> 6) + (((v91 >> 8) & 0xFF00) >> 8);
          int v94 = 32 * v93;
          v93 >>= 6;
          int v95 = v93 | (v92 << 24) | (v92 << 16) | v94;
          unsigned int v96 = ((v94 | v93) - (((v94 | v93) * v85 + (((v94 | v93) * v85) >> 16) + 1) >> 16)) | (((v92 | (v92 << 8))
                                                                                                - (((v92 | (v92 << 8)) * v85
                                                                                                  + (((v92 | (v92 << 8)) * v85) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v96 = v95;
          }
          unsigned int v97 = bswap32(v96);
          *int v7 = HIWORD(v97);
          if (v8) {
            _WORD *v8 = v97;
          }
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          --v88;
        }
        while (v88);
      }
    }
    else
    {
      int v98 = v83;
      uint64_t v99 = a5;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v100 = *v98;
          v98 += 2;
          unsigned int v101 = (unsigned int *)&v86[v100];
          if (v84 < &v86[v100]) {
            unsigned int v101 = (unsigned int *)v84;
          }
          if (v101 < v15) {
            unsigned int v101 = v15;
          }
          unsigned int v102 = __ROL4__(*v101, v10);
          int v103 = v102 | v6;
          unsigned int v104 = ((v102 >> 23) & 0x1FE) + BYTE1(v102) + (((v102 >> 8) & 0xFF00) >> 6) + (((v102 >> 8) & 0xFF00) >> 8);
          int v105 = 32 * v104;
          v104 >>= 6;
          int v106 = v104 | (v103 << 24) | (v103 << 16) | v105;
          unsigned int v107 = ((v105 | v104) - (((v105 | v104) * v85 + (((v105 | v104) * v85) >> 16) + 1) >> 16)) | (((v103 | (v103 << 8)) - (((v103 | (v103 << 8)) * v85 + (((v103 | (v103 << 8)) * v85) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v107 = v106;
          }
          unsigned int v108 = HIWORD(v107);
          if (v8)
          {
            if (v108)
            {
              if (v108 == 0xFFFF)
              {
                *int v7 = bswap32(v107) >> 16;
                _WORD *v8 = -1;
              }
              else
              {
                unsigned int v110 = bswap32((unsigned __int16)*v8) >> 16;
                int v111 = v108 ^ 0xFFFF;
                unsigned int v112 = v111 * (bswap32((unsigned __int16)*v7) >> 16);
                *int v7 = bswap32(v107 + ((v112 + HIWORD(v112) + 1) >> 16)) >> 16;
                _WORD *v8 = bswap32(((v111 * v110 + ((v111 * v110) >> 16) + 1) >> 16) + HIWORD(v107)) >> 16;
              }
            }
          }
          else if (v108)
          {
            if (v108 != 0xFFFF)
            {
              unsigned int v109 = bswap32((unsigned __int16)*v7) >> 16;
              v107 += ((v108 ^ 0xFFFF) * v109 + (((v108 ^ 0xFFFF) * v109) >> 16) + 1) >> 16;
            }
            *int v7 = bswap32(v107) >> 16;
          }
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          --v99;
        }
        while (v99);
      }
    }
    v7 += v122;
    v14 += v121;
    v8 += v124;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t W16_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  if (*(void *)(a1 + 40)) {
    int v6 = 0;
  }
  else {
    int v6 = 255;
  }
  int v7 = (_WORD *)*((void *)a2 + 2);
  int v8 = (_WORD *)*((void *)a2 + 4);
  if (v8) {
    uint64_t v124 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v124 = 0;
  }
  int v9 = *((unsigned __int16 *)a2 + 4);
  int v10 = a2[1];
  int v123 = *a2;
  uint64_t v122 = *((void *)a2 + 3) - a5;
  uint64_t v12 = *((void *)a2 + 17);
  uint64_t v11 = *((void *)a2 + 18);
  uint64_t v13 = *((void *)a2 + 9);
  uint64_t v121 = *((void *)a2 + 11);
  uint64_t v14 = *((void *)a2 + 7) + v121 * a4;
  int v15 = *(unsigned int **)(a1 + 32);
  int v16 = (char *)v15
      + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
      + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3);
  uint64_t v17 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v8 != 0);
  if (v17)
  {
    uint64_t v118 = *((void *)a2 + 13);
    uint64_t v116 = ~(-1 << v13);
    uint64_t v117 = *((void *)a2 + 15);
    char v115 = v13 - 4;
    uint64_t v19 = (unsigned int *)(v16 - 4);
    int v20 = v9 ^ 0xFFFF;
    uint64_t v114 = a5;
    uint64_t v113 = v11 + 16 * a3 + 8;
    uint64_t v119 = *((void *)a2 + 9);
    int v120 = a5;
    while (1)
    {
      if (((v117 - v14) | (v14 - v118)) < 0)
      {
        int v23 = 0;
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v21 = ((v14 & (unint64_t)v116) >> v115) & 0xF;
        uint64_t v22 = (unint64_t)(v21 - 7) >= 9 ? -v12 : v12;
        int v23 = weights_21383[v21] & 0xF;
      }
      uint64_t v24 = (char *)v15 + (v14 >> v13) * v12;
      if (v123 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        int v25 = (uint64_t *)v113;
        uint64_t v26 = v114;
        while (1)
        {
          uint64_t v28 = *(v25 - 1);
          uint64_t v27 = *v25;
          int v29 = &v24[v28];
          if (v19 >= (unsigned int *)&v24[v28]) {
            long long v30 = (unsigned int *)&v24[v28];
          }
          else {
            long long v30 = v19;
          }
          if (v30 < v15) {
            long long v30 = v15;
          }
          unsigned int v31 = bswap32(*v30);
          char v32 = v27 & 0xF;
          if ((v27 & 0xF) != 0) {
            break;
          }
          if (v23)
          {
            uint64_t v43 = (unsigned int *)&v29[v22];
            if (v19 < (unsigned int *)&v29[v22]) {
              uint64_t v43 = v19;
            }
            if (v43 < v15) {
              uint64_t v43 = v15;
            }
            int v44 = BLEND8_21385[v23];
            unsigned int v41 = v31 - ((v44 & v31) >> v23);
            unsigned int v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_46;
          }
LABEL_47:
          unsigned int v45 = __ROL4__(v31, v10);
          int v46 = v45 | v6;
          unsigned int v47 = ((v45 >> 23) & 0x1FE) + BYTE1(v45) + (((v45 >> 8) & 0xFF00) >> 6) + (((v45 >> 8) & 0xFF00) >> 8);
          int v48 = 32 * v47;
          v47 >>= 6;
          int v49 = v47 | (v46 << 24) | (v46 << 16) | v48;
          unsigned int v50 = ((v48 | v47) - (((v48 | v47) * v20 + (((v48 | v47) * v20) >> 16) + 1) >> 16)) | (((v46 | (v46 << 8))
                                                                                                - (((v46 | (v46 << 8)) * v20
                                                                                                  + (((v46 | (v46 << 8)) * v20) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v50 = v49;
          }
          unsigned int v51 = bswap32(v50);
          *int v7 = HIWORD(v51);
          if (v8) {
            _WORD *v8 = v51;
          }
          v25 += 2;
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          if (!--v26) {
            goto LABEL_96;
          }
        }
        unint64_t v33 = (unsigned int *)&v29[v27 >> 4];
        if (v19 < v33) {
          unint64_t v33 = v19;
        }
        if (v33 < v15) {
          unint64_t v33 = v15;
        }
        unsigned int v34 = bswap32(*v33);
        if (v23)
        {
          uint64_t v35 = (unsigned int *)&v29[v22];
          if (v19 >= v35) {
            unsigned int v36 = v35;
          }
          else {
            unsigned int v36 = v19;
          }
          if (v36 < v15) {
            unsigned int v36 = v15;
          }
          unsigned int v37 = bswap32(*v36);
          int v38 = (unsigned int *)((char *)v35 + (v27 >> 4));
          if (v19 < v38) {
            int v38 = v19;
          }
          if (v38 < v15) {
            int v38 = v15;
          }
          int v39 = BLEND8_21385[v23];
          unsigned int v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          unsigned int v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        int v40 = BLEND8_21385[*v25 & 0xF];
        unsigned int v41 = v31 - ((v40 & v31) >> v32);
        unsigned int v42 = (v40 & v34) >> v32;
LABEL_46:
        unsigned int v31 = v41 + v42;
        goto LABEL_47;
      }
LABEL_96:
      v7 += v122;
      a5 = v120;
      v14 += v121;
      v8 += v124;
      --a6;
      LOBYTE(v13) = v119;
      if (!a6) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_96;
    }
    long long v53 = (uint64_t *)v113;
    uint64_t v52 = v114;
    while (1)
    {
      uint64_t v55 = *(v53 - 1);
      uint64_t v54 = *v53;
      int32x2_t v56 = &v24[v55];
      if (v19 >= (unsigned int *)&v24[v55]) {
        int v57 = (unsigned int *)&v24[v55];
      }
      else {
        int v57 = v19;
      }
      if (v57 < v15) {
        int v57 = v15;
      }
      unsigned int v58 = bswap32(*v57);
      char v59 = v54 & 0xF;
      if ((v54 & 0xF) != 0) {
        break;
      }
      if (v23)
      {
        unsigned int v70 = (unsigned int *)&v56[v22];
        if (v19 < (unsigned int *)&v56[v22]) {
          unsigned int v70 = v19;
        }
        if (v70 < v15) {
          unsigned int v70 = v15;
        }
        int v71 = BLEND8_21385[v23];
        unsigned int v68 = v58 - ((v71 & v58) >> v23);
        unsigned int v69 = (bswap32(*v70) & v71) >> v23;
        goto LABEL_83;
      }
LABEL_84:
      unsigned int v72 = __ROL4__(v58, v10);
      int v73 = v72 | v6;
      unsigned int v74 = ((v72 >> 23) & 0x1FE) + BYTE1(v72) + (((v72 >> 8) & 0xFF00) >> 6) + (((v72 >> 8) & 0xFF00) >> 8);
      int v75 = 32 * v74;
      v74 >>= 6;
      int v76 = v74 | (v73 << 24) | (v73 << 16) | v75;
      unsigned int v77 = ((v75 | v74) - (((v75 | v74) * v20 + (((v75 | v74) * v20) >> 16) + 1) >> 16)) | (((v73 | (v73 << 8))
                                                                                            - (((v73 | (v73 << 8))
                                                                                              * v20
                                                                                              + (((v73 | (v73 << 8)) * v20) >> 16)
                                                                                              + 1) >> 16)) << 16);
      if (v9 == 0xFFFF) {
        unsigned int v77 = v76;
      }
      unsigned int v78 = HIWORD(v77);
      if (v8)
      {
        if (v78)
        {
          if (v78 == 0xFFFF)
          {
            *int v7 = bswap32(v77) >> 16;
            _WORD *v8 = -1;
          }
          else
          {
            unsigned int v80 = bswap32((unsigned __int16)*v8) >> 16;
            int v81 = v78 ^ 0xFFFF;
            unsigned int v82 = v81 * (bswap32((unsigned __int16)*v7) >> 16);
            *int v7 = bswap32(v77 + ((v82 + HIWORD(v82) + 1) >> 16)) >> 16;
            _WORD *v8 = bswap32(((v81 * v80 + ((v81 * v80) >> 16) + 1) >> 16) + HIWORD(v77)) >> 16;
          }
        }
      }
      else if (v78)
      {
        if (v78 != 0xFFFF)
        {
          unsigned int v79 = bswap32((unsigned __int16)*v7) >> 16;
          v77 += ((v78 ^ 0xFFFF) * v79 + (((v78 ^ 0xFFFF) * v79) >> 16) + 1) >> 16;
        }
        *int v7 = bswap32(v77) >> 16;
      }
      v53 += 2;
      ++v7;
      int v8 = (_WORD *)((char *)v8 + result);
      if (!--v52) {
        goto LABEL_96;
      }
    }
    int v60 = (unsigned int *)&v56[v54 >> 4];
    if (v19 < v60) {
      int v60 = v19;
    }
    if (v60 < v15) {
      int v60 = v15;
    }
    unsigned int v61 = bswap32(*v60);
    if (v23)
    {
      uint64_t v62 = (unsigned int *)&v56[v22];
      if (v19 >= v62) {
        int v63 = v62;
      }
      else {
        int v63 = v19;
      }
      if (v63 < v15) {
        int v63 = v15;
      }
      unsigned int v64 = bswap32(*v63);
      unint64_t v65 = (unsigned int *)((char *)v62 + (v54 >> 4));
      if (v19 < v65) {
        unint64_t v65 = v19;
      }
      if (v65 < v15) {
        unint64_t v65 = v15;
      }
      int v66 = BLEND8_21385[v23];
      unsigned int v58 = v58 - ((v66 & v58) >> v23) + ((v66 & v64) >> v23);
      unsigned int v61 = v61 - ((v66 & v61) >> v23) + ((bswap32(*v65) & v66) >> v23);
    }
    int v67 = BLEND8_21385[*v53 & 0xF];
    unsigned int v68 = v58 - ((v67 & v58) >> v59);
    unsigned int v69 = (v67 & v61) >> v59;
LABEL_83:
    unsigned int v58 = v68 + v69;
    goto LABEL_84;
  }
  int v83 = (uint64_t *)(v11 + 16 * a3);
  int v84 = (unsigned int *)(v16 - 4);
  int v85 = v9 ^ 0xFFFF;
  do
  {
    unsigned int v86 = (char *)v15 + (v14 >> v13) * v12;
    if (v123 == 1)
    {
      if (a5 >= 1)
      {
        unsigned int v87 = v83;
        uint64_t v88 = a5;
        do
        {
          uint64_t v89 = *v87;
          v87 += 2;
          uint64_t v90 = (unsigned int *)&v86[v89];
          if (v84 < (unsigned int *)&v86[v89]) {
            uint64_t v90 = v84;
          }
          if (v90 < v15) {
            uint64_t v90 = v15;
          }
          unsigned int v91 = __ROL4__(bswap32(*v90), v10);
          int v92 = v91 | v6;
          unsigned int v93 = ((v91 >> 23) & 0x1FE) + BYTE1(v91) + (((v91 >> 8) & 0xFF00) >> 6) + (((v91 >> 8) & 0xFF00) >> 8);
          int v94 = 32 * v93;
          v93 >>= 6;
          int v95 = v93 | (v92 << 24) | (v92 << 16) | v94;
          unsigned int v96 = ((v94 | v93) - (((v94 | v93) * v85 + (((v94 | v93) * v85) >> 16) + 1) >> 16)) | (((v92 | (v92 << 8))
                                                                                                - (((v92 | (v92 << 8)) * v85
                                                                                                  + (((v92 | (v92 << 8)) * v85) >> 16)
                                                                                                  + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v96 = v95;
          }
          unsigned int v97 = bswap32(v96);
          *int v7 = HIWORD(v97);
          if (v8) {
            _WORD *v8 = v97;
          }
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          --v88;
        }
        while (v88);
      }
    }
    else
    {
      int v98 = v83;
      uint64_t v99 = a5;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v100 = *v98;
          v98 += 2;
          unsigned int v101 = (unsigned int *)&v86[v100];
          if (v84 < (unsigned int *)&v86[v100]) {
            unsigned int v101 = v84;
          }
          if (v101 < v15) {
            unsigned int v101 = v15;
          }
          unsigned int v102 = __ROL4__(bswap32(*v101), v10);
          int v103 = v102 | v6;
          unsigned int v104 = ((v102 >> 23) & 0x1FE) + BYTE1(v102) + (((v102 >> 8) & 0xFF00) >> 6) + (((v102 >> 8) & 0xFF00) >> 8);
          int v105 = 32 * v104;
          v104 >>= 6;
          int v106 = v104 | (v103 << 24) | (v103 << 16) | v105;
          unsigned int v107 = ((v105 | v104) - (((v105 | v104) * v85 + (((v105 | v104) * v85) >> 16) + 1) >> 16)) | (((v103 | (v103 << 8)) - (((v103 | (v103 << 8)) * v85 + (((v103 | (v103 << 8)) * v85) >> 16) + 1) >> 16)) << 16);
          if (v9 == 0xFFFF) {
            unsigned int v107 = v106;
          }
          unsigned int v108 = HIWORD(v107);
          if (v8)
          {
            if (v108)
            {
              if (v108 == 0xFFFF)
              {
                *int v7 = bswap32(v107) >> 16;
                _WORD *v8 = -1;
              }
              else
              {
                unsigned int v110 = bswap32((unsigned __int16)*v8) >> 16;
                int v111 = v108 ^ 0xFFFF;
                unsigned int v112 = v111 * (bswap32((unsigned __int16)*v7) >> 16);
                *int v7 = bswap32(v107 + ((v112 + HIWORD(v112) + 1) >> 16)) >> 16;
                _WORD *v8 = bswap32(((v111 * v110 + ((v111 * v110) >> 16) + 1) >> 16) + HIWORD(v107)) >> 16;
              }
            }
          }
          else if (v108)
          {
            if (v108 != 0xFFFF)
            {
              unsigned int v109 = bswap32((unsigned __int16)*v7) >> 16;
              v107 += ((v108 ^ 0xFFFF) * v109 + (((v108 ^ 0xFFFF) * v109) >> 16) + 1) >> 16;
            }
            *int v7 = bswap32(v107) >> 16;
          }
          ++v7;
          int v8 = (_WORD *)((char *)v8 + result);
          --v99;
        }
        while (v99);
      }
    }
    v7 += v122;
    v14 += v121;
    v8 += v124;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t W16_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (_WORD *)*((void *)a2 + 2);
  int v7 = (_WORD *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v102 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v102 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v101 = *a2;
  uint64_t v100 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v99 = *((void *)a2 + 11);
  uint64_t v12 = *((void *)a2 + 7) + v99 * a4;
  uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v7 != 0);
  if (v15)
  {
    uint64_t v98 = *((void *)a2 + 13);
    uint64_t v97 = *((void *)a2 + 15);
    uint64_t v17 = v14 - 3;
    int v18 = v8 ^ 0xFFFF;
    unsigned int v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    do
    {
      if (((v97 - v12) | (v12 - v98)) < 0)
      {
        int v22 = 0;
        uint64_t v21 = 0;
      }
      else
      {
        unint64_t v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9) {
          uint64_t v21 = -v10;
        }
        else {
          uint64_t v21 = v10;
        }
        int v22 = weights_21383[v20] & 0xF;
      }
      int v23 = &v13[(v12 >> v11) * v10];
      if (v101 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v24 = (uint64_t *)(v9 + 16 * a3 + 8);
          uint64_t v25 = a5;
          do
          {
            uint64_t v26 = *v24;
            unint64_t v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27) {
              uint64_t v28 = &v23[*(v24 - 1)];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v28 < v13) {
              uint64_t v28 = v13;
            }
            unsigned int v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
            if ((v26 & 0xF) != 0)
            {
              long long v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30) {
                long long v30 = v17;
              }
              if (v30 < v13) {
                long long v30 = v13;
              }
              int v31 = (*v30 << 24) | (v30[1] << 16) | (v30[2] << 8);
              if (v22)
              {
                char v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32) {
                  unint64_t v33 = v32;
                }
                else {
                  unint64_t v33 = v17;
                }
                if (v33 < v13) {
                  unint64_t v33 = v13;
                }
                int v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
                uint64_t v35 = &v32[v26 >> 4];
                if (v17 < v35) {
                  uint64_t v35 = v17;
                }
                if (v35 < v13) {
                  uint64_t v35 = v13;
                }
                unsigned int v36 = BLEND8_21385[v22];
                unsigned int v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                int v31 = v31 - ((v36 & v31) >> v22) + ((((*v35 << 24) | (v35[1] << 16) | (v35[2] << 8)) & v36) >> v22);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_21385[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              unsigned int v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37) {
                unsigned int v37 = v17;
              }
              if (v37 < v13) {
                unsigned int v37 = v13;
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[v22] & v29) >> v22)
                  + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & BLEND8_21385[v22]) >> v22);
            }
            unsigned int v38 = ((v29 >> 23) & 0x1FE) + BYTE1(v29) + (((v29 >> 8) & 0xFF00) >> 6) + (((v29 >> 8) & 0xFF00) >> 8);
            int v39 = 32 * v38;
            v38 >>= 6;
            unsigned int v40 = (unsigned __int16)v38 | (unsigned __int16)v39 | 0xFFFF0000;
            unsigned int v41 = ((v39 | v38) - (((v39 | v38) * v18 + (((v39 | v38) * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF) {
              unsigned int v41 = v40;
            }
            unsigned int v42 = bswap32(v41);
            *int v6 = HIWORD(v42);
            if (v7) {
              *int v7 = v42;
            }
            v24 += 2;
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        int v44 = (uint64_t *)(v9 + 16 * a3 + 8);
        uint64_t v43 = a5;
        do
        {
          uint64_t v45 = *v44;
          unint64_t v46 = (unint64_t)&v23[*(v44 - 1)];
          if ((unint64_t)v17 >= v46) {
            unsigned int v47 = &v23[*(v44 - 1)];
          }
          else {
            unsigned int v47 = v17;
          }
          if (v47 < v13) {
            unsigned int v47 = v13;
          }
          unsigned int v48 = (*v47 << 24) | (v47[1] << 16) | (v47[2] << 8);
          if ((v45 & 0xF) != 0)
          {
            int v49 = (unsigned __int8 *)(v46 + (v45 >> 4));
            if (v17 < v49) {
              int v49 = v17;
            }
            if (v49 < v13) {
              int v49 = v13;
            }
            int v50 = (*v49 << 24) | (v49[1] << 16) | (v49[2] << 8);
            if (v22)
            {
              unsigned int v51 = (unsigned __int8 *)(v46 + v21);
              if (v17 >= v51) {
                uint64_t v52 = v51;
              }
              else {
                uint64_t v52 = v17;
              }
              if (v52 < v13) {
                uint64_t v52 = v13;
              }
              int v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
              uint64_t v54 = &v51[v45 >> 4];
              if (v17 < v54) {
                uint64_t v54 = v17;
              }
              if (v54 < v13) {
                uint64_t v54 = v13;
              }
              unsigned int v55 = BLEND8_21385[v22];
              unsigned int v48 = v48 - ((v55 & v48) >> v22) + ((v55 & v53) >> v22);
              int v50 = v50 - ((v55 & v50) >> v22) + ((((*v54 << 24) | (v54[1] << 16) | (v54[2] << 8)) & v55) >> v22);
            }
            unsigned int v48 = v48
                - ((BLEND8_21385[*v44 & 0xF] & v48) >> (*v44 & 0xF))
                + ((BLEND8_21385[*v44 & 0xF] & v50) >> (*v44 & 0xF));
          }
          else if (v22)
          {
            int32x2_t v56 = (unsigned __int8 *)(v46 + v21);
            if (v17 < v56) {
              int32x2_t v56 = v17;
            }
            if (v56 < v13) {
              int32x2_t v56 = v13;
            }
            unsigned int v48 = v48
                - ((BLEND8_21385[v22] & v48) >> v22)
                + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & BLEND8_21385[v22]) >> v22);
          }
          unsigned int v57 = ((v48 >> 23) & 0x1FE) + BYTE1(v48) + (((v48 >> 8) & 0xFF00) >> 6) + (((v48 >> 8) & 0xFF00) >> 8);
          int v58 = 32 * v57;
          v57 >>= 6;
          unsigned int v59 = (unsigned __int16)v57 | (unsigned __int16)v58 | 0xFFFF0000;
          unsigned int v60 = ((v58 | v57) - (((v58 | v57) * v18 + (((v58 | v57) * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF) {
            unsigned int v61 = v59;
          }
          else {
            unsigned int v61 = v60;
          }
          unsigned int v62 = HIWORD(v61);
          if (v7)
          {
            if (v62)
            {
              if (v62 == 0xFFFF)
              {
                *int v6 = bswap32(v61) >> 16;
                *int v7 = -1;
              }
              else
              {
                unsigned int v64 = bswap32((unsigned __int16)*v6);
                unsigned int v65 = bswap32((unsigned __int16)*v7) >> 16;
                int v66 = v62 ^ 0xFFFF;
                *int v6 = bswap32(v61 + ((v66 * HIWORD(v64) + ((v66 * HIWORD(v64)) >> 16) + 1) >> 16)) >> 16;
                *int v7 = bswap32(((v66 * v65 + ((v66 * v65) >> 16) + 1) >> 16) + HIWORD(v61)) >> 16;
              }
            }
          }
          else if (v62)
          {
            if (v62 == 0xFFFF)
            {
              unsigned int v63 = bswap32(v61);
            }
            else
            {
              unsigned int v67 = bswap32((unsigned __int16)*v6) >> 16;
              unsigned int v63 = bswap32(v61 + (((v62 ^ 0xFFFF) * v67 + (((v62 ^ 0xFFFF) * v67) >> 16) + 1) >> 16));
            }
            *int v6 = HIWORD(v63);
          }
          v44 += 2;
          ++v6;
          int v7 = (_WORD *)((char *)v7 + result);
          --v43;
        }
        while (v43);
      }
      v6 += v100;
      v12 += v99;
      v7 += v102;
      --a6;
    }
    while (a6);
  }
  else
  {
    unsigned int v68 = (uint64_t *)(v9 + 16 * a3);
    unsigned int v69 = v14 - 3;
    int v70 = v8 ^ 0xFFFF;
    unsigned int v71 = ~(0xFFFF * v70 + ((0xFFFF * v70) >> 16) + 1) & 0xFFFF0000;
    do
    {
      unsigned int v72 = &v13[(v12 >> v11) * v10];
      if (v101 == 1)
      {
        if (a5 >= 1)
        {
          int v73 = v68;
          uint64_t v74 = a5;
          do
          {
            uint64_t v75 = *v73;
            v73 += 2;
            int v76 = &v72[v75];
            if (v69 < &v72[v75]) {
              int v76 = v69;
            }
            if (v76 < v13) {
              int v76 = v13;
            }
            unsigned int v77 = v76[2] + 2 * *v76 + 4 * v76[1] + v76[1];
            int v78 = 32 * v77;
            v77 >>= 6;
            unsigned int v79 = (unsigned __int16)v77 | (unsigned __int16)v78 | 0xFFFF0000;
            unsigned int v80 = ((v78 | v77) - (((v78 | v77) * v70 + (((v78 | v77) * v70) >> 16) + 1) >> 16)) | v71;
            if (v8 == 0xFFFF) {
              unsigned int v80 = v79;
            }
            unsigned int v81 = bswap32(v80);
            *int v6 = HIWORD(v81);
            if (v7) {
              *int v7 = v81;
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v74;
          }
          while (v74);
        }
      }
      else
      {
        unsigned int v82 = v68;
        uint64_t v83 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v84 = *v82;
            v82 += 2;
            int v85 = &v72[v84];
            if (v69 < &v72[v84]) {
              int v85 = v69;
            }
            if (v85 < v13) {
              int v85 = v13;
            }
            unsigned int v86 = v85[2] + 2 * *v85 + 4 * v85[1] + v85[1];
            int v87 = 32 * v86;
            v86 >>= 6;
            unsigned int v88 = (unsigned __int16)v86 | (unsigned __int16)v87 | 0xFFFF0000;
            unsigned int v89 = ((v87 | v86) - (((v87 | v86) * v70 + (((v87 | v86) * v70) >> 16) + 1) >> 16)) | v71;
            if (v8 == 0xFFFF) {
              unsigned int v90 = v88;
            }
            else {
              unsigned int v90 = v89;
            }
            unsigned int v91 = HIWORD(v90);
            if (v7)
            {
              if (v91)
              {
                if (v91 == 0xFFFF)
                {
                  *int v6 = bswap32(v90) >> 16;
                  *int v7 = -1;
                }
                else
                {
                  unsigned int v93 = bswap32((unsigned __int16)*v6);
                  unsigned int v94 = bswap32((unsigned __int16)*v7) >> 16;
                  int v95 = v91 ^ 0xFFFF;
                  *int v6 = bswap32(v90 + ((v95 * HIWORD(v93) + ((v95 * HIWORD(v93)) >> 16) + 1) >> 16)) >> 16;
                  *int v7 = bswap32(((v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16) + HIWORD(v90)) >> 16;
                }
              }
            }
            else if (v91)
            {
              if (v91 == 0xFFFF)
              {
                unsigned int v92 = bswap32(v90);
              }
              else
              {
                unsigned int v96 = bswap32((unsigned __int16)*v6) >> 16;
                unsigned int v92 = bswap32(v90 + (((v91 ^ 0xFFFF) * v96 + (((v91 ^ 0xFFFF) * v96) >> 16) + 1) >> 16));
              }
              *int v6 = HIWORD(v92);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v83;
          }
          while (v83);
        }
      }
      v6 += v100;
      v12 += v99;
      v7 += v102;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t W16_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = (_WORD *)*((void *)a2 + 2);
  int v7 = (_WORD *)*((void *)a2 + 4);
  if (v7) {
    uint64_t v97 = *((void *)a2 + 5) - a5;
  }
  else {
    uint64_t v97 = 0;
  }
  int v8 = *((unsigned __int16 *)a2 + 4);
  int v96 = *a2;
  uint64_t v95 = *((void *)a2 + 3) - a5;
  uint64_t v10 = *((void *)a2 + 17);
  uint64_t v9 = *((void *)a2 + 18);
  uint64_t v11 = *((void *)a2 + 9);
  uint64_t v94 = *((void *)a2 + 11);
  uint64_t v12 = *((void *)a2 + 7) + v94 * a4;
  uint64_t v13 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v14 = &v13[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  uint64_t v15 = *(void *)(a1 + 176);
  uint64_t result = 2 * (v7 != 0);
  if (v15)
  {
    uint64_t v93 = *((void *)a2 + 13);
    uint64_t v92 = *((void *)a2 + 15);
    uint64_t v17 = v14 - 4;
    int v18 = v8 ^ 0xFFFF;
    unsigned int v19 = ~(0xFFFF * v18 + ((0xFFFF * v18) >> 16) + 1) & 0xFFFF0000;
    uint64_t v91 = v9 + 16 * a3 + 8;
    do
    {
      if (((v92 - v12) | (v12 - v93)) < 0)
      {
        int v22 = 0;
        uint64_t v21 = 0;
      }
      else
      {
        unint64_t v20 = ((v12 & (unint64_t)~(-1 << v11)) >> (v11 - 4)) & 0xF;
        if (v20 - 7 >= 9) {
          uint64_t v21 = -v10;
        }
        else {
          uint64_t v21 = v10;
        }
        int v22 = weights_21383[v20] & 0xF;
      }
      int v23 = &v13[(v12 >> v11) * v10];
      if (v96 == 1)
      {
        if (a5 >= 1)
        {
          uint64_t v24 = (uint64_t *)v91;
          uint64_t v25 = a5;
          do
          {
            uint64_t v26 = *v24;
            unint64_t v27 = (unint64_t)&v23[*(v24 - 1)];
            if ((unint64_t)v17 >= v27) {
              uint64_t v28 = &v23[*(v24 - 1)];
            }
            else {
              uint64_t v28 = v17;
            }
            if (v28 < v13) {
              uint64_t v28 = v13;
            }
            unsigned int v29 = *v28;
            if ((v26 & 0xF) != 0)
            {
              long long v30 = (unsigned __int8 *)(v27 + (v26 >> 4));
              if (v17 < v30) {
                long long v30 = v17;
              }
              if (v30 < v13) {
                long long v30 = v13;
              }
              unsigned int v31 = *v30;
              if (v22)
              {
                char v32 = (unsigned __int8 *)(v27 + v21);
                if (v17 >= v32) {
                  unint64_t v33 = v32;
                }
                else {
                  unint64_t v33 = v17;
                }
                if (v33 < v13) {
                  unint64_t v33 = v13;
                }
                unsigned int v34 = *v33;
                uint64_t v35 = &v32[v26 >> 4];
                if (v17 < v35) {
                  uint64_t v35 = v17;
                }
                if (v35 < v13) {
                  uint64_t v35 = v13;
                }
                int v36 = BLEND8_21385[v22];
                unsigned int v29 = v29 - ((v36 & v29) >> v22) + ((v36 & v34) >> v22);
                unsigned int v31 = v31 - ((v36 & v31) >> v22) + ((v36 & *v35) >> v22);
              }
              unsigned int v29 = v29
                  - ((BLEND8_21385[*v24 & 0xF] & v29) >> (*v24 & 0xF))
                  + ((BLEND8_21385[*v24 & 0xF] & v31) >> (*v24 & 0xF));
            }
            else if (v22)
            {
              unsigned int v37 = (unsigned __int8 *)(v27 + v21);
              if (v17 < v37) {
                unsigned int v37 = v17;
              }
              if (v37 < v13) {
                unsigned int v37 = v13;
              }
              unsigned int v29 = v29 - ((BLEND8_21385[v22] & v29) >> v22) + ((BLEND8_21385[v22] & *v37) >> v22);
            }
            int v38 = v29 | (v29 << 8);
            unsigned int v39 = v38 | 0xFFFF0000;
            unsigned int v40 = (v38 - ((v38 * v18 + ((v38 * v18) >> 16) + 1) >> 16)) | v19;
            if (v8 == 0xFFFF) {
              unsigned int v40 = v39;
            }
            unsigned int v41 = bswap32(v40);
            *int v6 = HIWORD(v41);
            if (v7) {
              *int v7 = v41;
            }
            v24 += 2;
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v25;
          }
          while (v25);
        }
      }
      else if (a5 >= 1)
      {
        uint64_t v43 = (uint64_t *)v91;
        uint64_t v42 = a5;
        do
        {
          uint64_t v44 = *v43;
          unint64_t v45 = (unint64_t)&v23[*(v43 - 1)];
          if ((unint64_t)v17 >= v45) {
            unint64_t v46 = &v23[*(v43 - 1)];
          }
          else {
            unint64_t v46 = v17;
          }
          if (v46 < v13) {
            unint64_t v46 = v13;
          }
          unsigned int v47 = *v46;
          if ((v44 & 0xF) != 0)
          {
            unsigned int v48 = (unsigned __int8 *)(v45 + (v44 >> 4));
            if (v17 < v48) {
              unsigned int v48 = v17;
            }
            if (v48 < v13) {
              unsigned int v48 = v13;
            }
            unsigned int v49 = *v48;
            if (v22)
            {
              int v50 = (unsigned __int8 *)(v45 + v21);
              if (v17 >= v50) {
                unsigned int v51 = v50;
              }
              else {
                unsigned int v51 = v17;
              }
              if (v51 < v13) {
                unsigned int v51 = v13;
              }
              unsigned int v52 = *v51;
              int v53 = &v50[v44 >> 4];
              if (v17 < v53) {
                int v53 = v17;
              }
              if (v53 < v13) {
                int v53 = v13;
              }
              int v54 = BLEND8_21385[v22];
              unsigned int v47 = v47 - ((v54 & v47) >> v22) + ((v54 & v52) >> v22);
              unsigned int v49 = v49 - ((v54 & v49) >> v22) + ((v54 & *v53) >> v22);
            }
            unsigned int v47 = v47
                - ((BLEND8_21385[*v43 & 0xF] & v47) >> (*v43 & 0xF))
                + ((BLEND8_21385[*v43 & 0xF] & v49) >> (*v43 & 0xF));
          }
          else if (v22)
          {
            unsigned int v55 = (unsigned __int8 *)(v45 + v21);
            if (v17 < v55) {
              unsigned int v55 = v17;
            }
            if (v55 < v13) {
              unsigned int v55 = v13;
            }
            unsigned int v47 = v47 - ((BLEND8_21385[v22] & v47) >> v22) + ((BLEND8_21385[v22] & *v55) >> v22);
          }
          int v56 = v47 | (v47 << 8);
          unsigned int v57 = v56 | 0xFFFF0000;
          unsigned int v58 = (v56 - ((v56 * v18 + ((v56 * v18) >> 16) + 1) >> 16)) | v19;
          if (v8 == 0xFFFF) {
            unsigned int v59 = v57;
          }
          else {
            unsigned int v59 = v58;
          }
          unsigned int v60 = HIWORD(v59);
          if (v7)
          {
            if (v60)
            {
              if (v60 == 0xFFFF)
              {
                *int v6 = bswap32(v59) >> 16;
                *int v7 = -1;
              }
              else
              {
                unsigned int v62 = bswap32((unsigned __int16)*v6);
                unsigned int v63 = bswap32((unsigned __int16)*v7);
                *int v6 = bswap32(v59 + (((v60 ^ 0xFFFF) * HIWORD(v62) + (((v60 ^ 0xFFFF) * HIWORD(v62)) >> 16) + 1) >> 16)) >> 16;
                *int v7 = bswap32((((v60 ^ 0xFFFF) * HIWORD(v63) + (((v60 ^ 0xFFFF) * HIWORD(v63)) >> 16) + 1) >> 16)+ HIWORD(v59)) >> 16;
              }
            }
          }
          else if (v60)
          {
            if (v60 == 0xFFFF)
            {
              unsigned int v61 = bswap32(v59);
            }
            else
            {
              unsigned int v64 = bswap32((unsigned __int16)*v6);
              unsigned int v61 = bswap32(v59 + (((v60 ^ 0xFFFF) * HIWORD(v64) + (((v60 ^ 0xFFFF) * HIWORD(v64)) >> 16) + 1) >> 16));
            }
            *int v6 = HIWORD(v61);
          }
          v43 += 2;
          ++v6;
          int v7 = (_WORD *)((char *)v7 + result);
          --v42;
        }
        while (v42);
      }
      v6 += v95;
      v12 += v94;
      v7 += v97;
      --a6;
    }
    while (a6);
  }
  else
  {
    unsigned int v65 = (uint64_t *)(v9 + 16 * a3);
    int v66 = v14 - 4;
    int v67 = v8 ^ 0xFFFF;
    unsigned int v68 = ~(0xFFFF * v67 + ((0xFFFF * v67) >> 16) + 1) & 0xFFFF0000;
    do
    {
      unsigned int v69 = &v13[(v12 >> v11) * v10];
      if (v96 == 1)
      {
        if (a5 >= 1)
        {
          int v70 = v65;
          uint64_t v71 = a5;
          do
          {
            uint64_t v72 = *v70;
            v70 += 2;
            int v73 = &v69[v72];
            if (v66 < &v69[v72]) {
              int v73 = v66;
            }
            if (v73 < v13) {
              int v73 = v13;
            }
            int v74 = *v73 | (*v73 << 8);
            unsigned int v75 = v74 | 0xFFFF0000;
            unsigned int v76 = (v74 - ((v74 * v67 + ((v74 * v67) >> 16) + 1) >> 16)) | v68;
            if (v8 == 0xFFFF) {
              unsigned int v76 = v75;
            }
            unsigned int v77 = bswap32(v76);
            *int v6 = HIWORD(v77);
            if (v7) {
              *int v7 = v77;
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v71;
          }
          while (v71);
        }
      }
      else
      {
        int v78 = v65;
        uint64_t v79 = a5;
        if (a5 >= 1)
        {
          do
          {
            uint64_t v80 = *v78;
            v78 += 2;
            unsigned int v81 = &v69[v80];
            if (v66 < &v69[v80]) {
              unsigned int v81 = v66;
            }
            if (v81 < v13) {
              unsigned int v81 = v13;
            }
            int v82 = *v81 | (*v81 << 8);
            unsigned int v83 = v82 | 0xFFFF0000;
            unsigned int v84 = (v82 - ((v82 * v67 + ((v82 * v67) >> 16) + 1) >> 16)) | v68;
            if (v8 == 0xFFFF) {
              unsigned int v85 = v83;
            }
            else {
              unsigned int v85 = v84;
            }
            unsigned int v86 = HIWORD(v85);
            if (v7)
            {
              if (v86)
              {
                if (v86 == 0xFFFF)
                {
                  *int v6 = bswap32(v85) >> 16;
                  *int v7 = -1;
                }
                else
                {
                  unsigned int v88 = bswap32((unsigned __int16)*v6);
                  unsigned int v89 = bswap32((unsigned __int16)*v7);
                  *int v6 = bswap32(v85 + (((v86 ^ 0xFFFF) * HIWORD(v88) + (((v86 ^ 0xFFFF) * HIWORD(v88)) >> 16) + 1) >> 16)) >> 16;
                  *int v7 = bswap32((((v86 ^ 0xFFFF) * HIWORD(v89) + (((v86 ^ 0xFFFF) * HIWORD(v89)) >> 16) + 1) >> 16)+ HIWORD(v85)) >> 16;
                }
              }
            }
            else if (v86)
            {
              if (v86 == 0xFFFF)
              {
                unsigned int v87 = bswap32(v85);
              }
              else
              {
                unsigned int v90 = bswap32((unsigned __int16)*v6);
                unsigned int v87 = bswap32(v85 + (((v86 ^ 0xFFFF) * HIWORD(v90) + (((v86 ^ 0xFFFF) * HIWORD(v90)) >> 16) + 1) >> 16));
              }
              *int v6 = HIWORD(v87);
            }
            ++v6;
            int v7 = (_WORD *)((char *)v7 + result);
            --v79;
          }
          while (v79);
        }
      }
      v6 += v95;
      v12 += v94;
      v7 += v97;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t W16_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  int8x8_t v4 = *(unsigned int **)(a1 + 96);
  unsigned int v5 = bswap32(**(_DWORD **)(a1 + 88));
  if (v4) {
    unsigned int v7 = bswap32(*v4) << 16;
  }
  else {
    unsigned int v7 = -65536;
  }
  int v8 = *(_DWORD *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 136);
  unint64_t v372 = *(int *)(a1 + 28);
  unsigned int v10 = v7 | v5;
  uint64_t v374 = *(void *)(a1 + 40);
  int v376 = *(_DWORD *)(a1 + 4);
  pthread_mutex_lock(&W16_cacheColorLock);
  uint64_t v11 = W16_cacheColor;
  if (!W16_cacheColor || *(_DWORD *)(W16_cacheColor + 16) != v10)
  {
    uint64_t v14 = 0;
    while (1)
    {
      if (!v11) {
        goto LABEL_12;
      }
      uint64_t v15 = v11;
      int v16 = v14;
      if (*(_DWORD *)(v11 + 16) == v10) {
        break;
      }
      uint64_t v11 = *(void *)v11;
      uint64_t v14 = (void *)v15;
      if (!*(void *)v15)
      {
        if (W16_cacheColorCount > 6)
        {
          void *v16 = 0;
        }
        else
        {
LABEL_12:
          uint64_t v17 = (char *)W16_cacheColorBase;
          if (W16_cacheColorBase)
          {
            unsigned int v18 = W16_cacheColorCount;
          }
          else
          {
            uint64_t v17 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            unsigned int v18 = 0;
            W16_cacheColorBase = (uint64_t)v17;
          }
          uint64_t v15 = (uint64_t)&v17[24 * v18];
          *(void *)(v15 + 8) = &v17[1024 * (unint64_t)v18 + 168];
          W16_cacheColorCFIndex Count = v18 + 1;
        }
        uint64_t v19 = 0;
        *(void *)uint64_t v15 = W16_cacheColor;
        W16_cacheColor = v15;
        *(_DWORD *)(v15 + 16) = v10;
        uint64_t v21 = *(void *)(v15 + 8);
        uint64_t v13 = v15 + 8;
        uint64_t v20 = v21;
        int32x4_t v22 = vdupq_n_s32((unsigned __int16)v5);
        int32x4_t v23 = vdupq_n_s32(HIWORD(v10));
        int32x4_t v24 = (int32x4_t)xmmword_1850CDC50;
        int32x4_t v25 = vdupq_n_s32(0x101u);
        v26.i64[0] = 0xFFFF0000FFFFLL;
        v26.i64[1] = 0xFFFF0000FFFFLL;
        v27.i64[0] = 0x400000004;
        v27.i64[1] = 0x400000004;
        do
        {
          int32x4_t v28 = (int32x4_t)veorq_s8((int8x16_t)vmulq_s32(v24, v25), v26);
          int8x16_t v29 = (int8x16_t)vmulq_s32(v28, v22);
          int8x16_t v30 = (int8x16_t)vmulq_s32(v28, v23);
          *(int8x16_t *)(v20 + v19) = vorrq_s8((int8x16_t)vshlq_n_s32(vsubq_s32(v23, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v30, 0x10uLL), (int32x4_t)vmvnq_s8(v30)), 0x10uLL)), 0x10uLL), (int8x16_t)vsubq_s32(v22, (int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v29, 0x10uLL), (int32x4_t)vmvnq_s8(v29)),
                                                                  0x10uLL)));
          int32x4_t v24 = vaddq_s32(v24, v27);
          v19 += 16;
        }
        while (v19 != 1024);
        uint64_t result = pthread_mutex_unlock(&W16_cacheColorLock);
        goto LABEL_23;
      }
    }
    if (v14)
    {
      *uint64_t v14 = *(void *)v11;
      *(void *)uint64_t v11 = W16_cacheColor;
      W16_cacheColor = v11;
    }
  }
  uint64_t result = pthread_mutex_unlock(&W16_cacheColorLock);
  uint64_t v13 = v11 + 8;
LABEL_23:
  int v31 = v376;
  uint64_t v32 = *(void *)v13;
  unsigned int v33 = *(_DWORD *)(*(void *)v13 + 1020);
  uint64_t v35 = *(int *)(a1 + 12);
  uint64_t v34 = *(int *)(a1 + 16);
  if (v3)
  {
    unint64_t v36 = (unint64_t)*(int *)(a1 + 32) >> 1;
    unsigned int v37 = (unsigned __int16 *)(v3 + 2 * (v35 + v36 * v34));
    uint64_t v38 = 1;
    if (!v9) {
      return result;
    }
  }
  else
  {
    unsigned int v37 = 0;
    unint64_t v36 = 0;
    uint64_t v38 = 0;
    if (!v9) {
      return result;
    }
  }
  unint64_t v39 = v36 - v376;
  if (v3) {
    uint64_t result = v36 - v376;
  }
  else {
    uint64_t result = v36;
  }
  unsigned int v40 = HIWORD(v33);
  unsigned int v41 = (int16x4_t *)(v374 + 2 * (v35 + (v372 >> 1) * v34));
  uint64_t v42 = *(int *)(a1 + 124);
  unint64_t v43 = v9 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v42;
  uint64_t v44 = v42 - v376;
  unint64_t v45 = (v372 >> 1) - v376;
  uint64_t v373 = v44;
  unint64_t v375 = v45;
  uint64_t v46 = result;
  switch(a2)
  {
    case 0:
      if (v3)
      {
        uint64_t v47 = 2 * v38;
        do
        {
          int v48 = v376;
          do
          {
            int v49 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              if (v49 == 255)
              {
                LOWORD(v50) = 0;
                v41->i16[0] = 0;
              }
              else
              {
                unsigned int v51 = bswap32(v41->u16[0]) >> 16;
                unsigned int v52 = bswap32(*v37) >> 16;
                int v53 = (v49 ^ 0xFF | ((v49 ^ 0xFF) << 8)) ^ 0xFFFF;
                v41->i16[0] = bswap32(v51 - ((v53 * v51 + ((v53 * v51) >> 16) + 1) >> 16)) >> 16;
                unsigned int v50 = bswap32(v52 - ((v53 * v52 + ((v53 * v52) >> 16) + 1) >> 16)) >> 16;
              }
              unsigned __int16 *v37 = v50;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            unsigned int v37 = (unsigned __int16 *)((char *)v37 + v47);
            --v48;
          }
          while (v48);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          v37 += result;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v54 = v376;
          do
          {
            int v55 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              if (v55 == 255)
              {
                LOWORD(v56) = 0;
              }
              else
              {
                unsigned int v57 = bswap32(v41->u16[0]) >> 16;
                unsigned int v58 = ((v55 ^ 0xFF | ((v55 ^ 0xFF) << 8)) ^ 0xFFFF) * v57;
                unsigned int v56 = bswap32(v57 - ((v58 + HIWORD(v58) + 1) >> 16)) >> 16;
              }
              v41->i16[0] = v56;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            --v54;
          }
          while (v54);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          --v8;
        }
        while (v8);
      }
      return result;
    case 1:
      unsigned int v59 = v43 & 3;
      if (!v3)
      {
        int v257 = -1 << (8 * v59);
        if ((v43 & 3) != 0) {
          char v258 = v43 & 0xFC;
        }
        else {
          char v258 = v43;
        }
        if ((v43 & 3) != 0)
        {
          unint64_t v259 = (unsigned int *)(v43 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          int v257 = -1;
          unint64_t v259 = (unsigned int *)v43;
        }
        if ((v43 & 3) != 0) {
          unsigned int v260 = (int16x4_t *)((char *)v41 - 2 * (v43 & 3));
        }
        else {
          unsigned int v260 = v41;
        }
        if ((v43 & 3) != 0) {
          int v261 = v59 + v376;
        }
        else {
          int v261 = v376;
        }
        if ((((_BYTE)v261 + v258) & 3) != 0)
        {
          int v262 = 4 - (((_BYTE)v261 + v258) & 3);
          v59 += v262;
          unsigned int v263 = 0xFFFFFFFF >> (8 * v262);
          if (v261 >= 4) {
            unsigned int v264 = v263;
          }
          else {
            unsigned int v264 = 0;
          }
          if (v261 >= 4) {
            unsigned int v263 = -1;
          }
          v257 &= v263;
        }
        else
        {
          unsigned int v264 = 0;
        }
        uint64_t v339 = v44 - v59;
        unint64_t v340 = v45 - v59;
        uint64_t v341 = (v261 >> 2);
        unsigned int v342 = bswap32(v33) >> 16;
        int16x4_t v343 = vdup_n_s16(v342);
        while (1)
        {
          unsigned int v344 = *v259 & v257;
          uint64_t v345 = v341;
          unsigned int v346 = v264;
          if (!v344) {
            goto LABEL_583;
          }
LABEL_565:
          if (v344 == -1)
          {
            *unsigned int v260 = v343;
            goto LABEL_583;
          }
          while (1)
          {
            if ((_BYTE)v344)
            {
              LOWORD(v347) = v342;
              if (v344 != 255)
              {
                unsigned int v348 = (bswap32(v260->u16[0]) >> 16) * ((v344 | (v344 << 8)) ^ 0xFFFF);
                unsigned int v347 = bswap32(*(_DWORD *)(v32 + 4 * v344) + ((v348 + HIWORD(v348) + 1) >> 16)) >> 16;
              }
              v260->i16[0] = v347;
            }
            if (BYTE1(v344))
            {
              LOWORD(v349) = v342;
              if (BYTE1(v344) != 255)
              {
                unsigned int v350 = bswap32(v260->u16[1]) >> 16;
                unsigned int v349 = bswap32(*(_DWORD *)(v32 + 4 * BYTE1(v344))+ ((v350 * ((BYTE1(v344) | (BYTE1(v344) << 8)) ^ 0xFFFF)+ ((v350 * ((BYTE1(v344) | (BYTE1(v344) << 8)) ^ 0xFFFF)) >> 16)+ 1) >> 16)) >> 16;
              }
              v260->i16[1] = v349;
            }
            if (BYTE2(v344))
            {
              LOWORD(v351) = v342;
              if (BYTE2(v344) != 255)
              {
                unsigned int v352 = bswap32(v260->u16[2]) >> 16;
                unsigned int v351 = bswap32(*(_DWORD *)(v32 + 4 * BYTE2(v344))+ ((v352 * ((BYTE2(v344) | (BYTE2(v344) << 8)) ^ 0xFFFF)+ ((v352 * ((BYTE2(v344) | (BYTE2(v344) << 8)) ^ 0xFFFF)) >> 16)+ 1) >> 16)) >> 16;
              }
              v260->i16[2] = v351;
            }
            unsigned int v353 = HIBYTE(v344);
            if (v353 == 255)
            {
              v260->i16[3] = v342;
            }
            else if (v353)
            {
              unsigned int v354 = bswap32(v260->u16[3]) >> 16;
              v260->i16[3] = bswap32(*(_DWORD *)(v32 + 4 * v353)+ ((((v353 | (v353 << 8)) ^ 0xFFFF) * v354+ ((((v353 | (v353 << 8)) ^ 0xFFFF) * v354) >> 16)+ 1) >> 16)) >> 16;
            }
LABEL_583:
            while (1)
            {
              uint64_t result = v345;
              ++v260;
              uint64_t v345 = (v345 - 1);
              ++v259;
              if ((int)result < 2) {
                break;
              }
              unsigned int v344 = *v259;
              if (*v259) {
                goto LABEL_565;
              }
            }
            if (!v346) {
              break;
            }
            unsigned int v346 = 0;
            unsigned int v344 = *v259 & v264;
          }
          unint64_t v259 = (unsigned int *)((char *)v259 + v339);
          unsigned int v260 = (int16x4_t *)((char *)v260 + 2 * v340);
          if (!--v8) {
            return result;
          }
        }
      }
      int v60 = -1 << (8 * v59);
      unsigned int v61 = (unsigned int *)(v43 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v62 = 2 * (v43 & 3);
      unsigned int v63 = (int16x4_t *)((char *)v41 - v62);
      unsigned int v64 = &v37[v62 / 0xFFFFFFFFFFFFFFFELL];
      if ((v43 & 3) != 0) {
        char v65 = v43 & 0xFC;
      }
      else {
        char v65 = v43;
      }
      if ((v43 & 3) != 0)
      {
        int v66 = v59 + v376;
      }
      else
      {
        int v60 = -1;
        unsigned int v61 = (unsigned int *)v43;
        unsigned int v64 = v37;
        unsigned int v63 = v41;
        int v66 = v376;
      }
      if ((((_BYTE)v66 + v65) & 3) != 0)
      {
        int v67 = 4 - (((_BYTE)v66 + v65) & 3);
        v59 += v67;
        unsigned int v68 = 0xFFFFFFFF >> (8 * v67);
        if (v66 >= 4) {
          unsigned int v69 = v68;
        }
        else {
          unsigned int v69 = 0;
        }
        if (v66 >= 4) {
          unsigned int v68 = -1;
        }
        v60 &= v68;
      }
      else
      {
        unsigned int v69 = 0;
      }
      uint64_t v278 = v44 - v59;
      unint64_t v279 = v45 - v59;
      int v280 = v66 >> 2;
      unsigned int v281 = bswap32(v33);
      uint64_t result = v39 - v59;
      do
      {
        unsigned int v282 = *v61 & v60;
        int v283 = v280;
        unsigned int v284 = v69;
        if (!v282) {
          goto LABEL_534;
        }
LABEL_513:
        if (v282 == -1)
        {
          v63->i16[0] = HIWORD(v281);
          *unsigned int v64 = v281;
          v63->i16[1] = HIWORD(v281);
          v64[1] = v281;
          v63->i16[2] = HIWORD(v281);
          v64[2] = v281;
LABEL_531:
          v63->i16[3] = HIWORD(v281);
          v64[3] = v281;
          goto LABEL_534;
        }
        while (1)
        {
          if ((_BYTE)v282)
          {
            if (v282 == 255)
            {
              v63->i16[0] = HIWORD(v281);
              LOWORD(v285) = v281;
            }
            else
            {
              unsigned int v286 = *(_DWORD *)(v32 + 4 * v282);
              unsigned int v287 = bswap32(v63->u16[0]);
              unsigned int v288 = bswap32(*v64) >> 16;
              int v289 = (v282 | (v282 << 8)) ^ 0xFFFF;
              v63->i16[0] = bswap32(v286 + ((HIWORD(v287) * v289 + ((HIWORD(v287) * v289) >> 16) + 1) >> 16)) >> 16;
              unsigned int v285 = bswap32(((v288 * v289 + ((v288 * v289) >> 16) + 1) >> 16) + HIWORD(v286)) >> 16;
            }
            *unsigned int v64 = v285;
          }
          if (BYTE1(v282))
          {
            if (BYTE1(v282) == 255)
            {
              v63->i16[1] = HIWORD(v281);
              LOWORD(v290) = v281;
            }
            else
            {
              unsigned int v291 = *(_DWORD *)(v32 + 4 * BYTE1(v282));
              unsigned int v292 = bswap32(v64[1]) >> 16;
              int v293 = (BYTE1(v282) | (BYTE1(v282) << 8)) ^ 0xFFFF;
              unsigned int v294 = (bswap32(v63->u16[1]) >> 16) * v293;
              v63->i16[1] = bswap32(v291 + ((v294 + HIWORD(v294) + 1) >> 16)) >> 16;
              unsigned int v290 = bswap32(((v292 * v293 + ((v292 * v293) >> 16) + 1) >> 16) + HIWORD(v291)) >> 16;
            }
            v64[1] = v290;
          }
          if (BYTE2(v282))
          {
            if (BYTE2(v282) == 255)
            {
              v63->i16[2] = HIWORD(v281);
              LOWORD(v295) = v281;
            }
            else
            {
              unsigned int v296 = *(_DWORD *)(v32 + 4 * BYTE2(v282));
              unsigned int v297 = bswap32(v63->u16[2]);
              unsigned int v298 = bswap32(v64[2]) >> 16;
              int v299 = (BYTE2(v282) | (BYTE2(v282) << 8)) ^ 0xFFFF;
              v63->i16[2] = bswap32(v296 + ((HIWORD(v297) * v299 + ((HIWORD(v297) * v299) >> 16) + 1) >> 16)) >> 16;
              unsigned int v295 = bswap32(((v298 * v299 + ((v298 * v299) >> 16) + 1) >> 16) + HIWORD(v296)) >> 16;
            }
            v64[2] = v295;
          }
          unsigned int v300 = HIBYTE(v282);
          if (v300 == 255) {
            goto LABEL_531;
          }
          if (v300)
          {
            int v301 = v300 | (v300 << 8);
            unsigned int v302 = *(_DWORD *)(v32 + 4 * v300);
            unsigned int v303 = bswap32(v64[3]) >> 16;
            v301 ^= 0xFFFFu;
            unsigned int v304 = v301 * (bswap32(v63->u16[3]) >> 16);
            v63->i16[3] = bswap32(v302 + ((v304 + HIWORD(v304) + 1) >> 16)) >> 16;
            v64[3] = bswap32(((v301 * v303 + ((v301 * v303) >> 16) + 1) >> 16) + HIWORD(v302)) >> 16;
          }
LABEL_534:
          while (1)
          {
            int v305 = v283;
            ++v63;
            v64 += 4;
            --v283;
            ++v61;
            if (v305 < 2) {
              break;
            }
            unsigned int v282 = *v61;
            if (*v61) {
              goto LABEL_513;
            }
          }
          if (!v284) {
            break;
          }
          unsigned int v284 = 0;
          unsigned int v282 = *v61 & v69;
        }
        unsigned int v61 = (unsigned int *)((char *)v61 + v278);
        unsigned int v63 = (int16x4_t *)((char *)v63 + 2 * v279);
        v64 += result;
        --v8;
      }
      while (v8);
      return result;
    case 2:
      unsigned int v70 = v43 & 3;
      if (v3)
      {
        int v71 = -1 << (8 * v70);
        uint64_t v72 = (unsigned int *)(v43 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v73 = 2 * (v43 & 3);
        int v74 = (int16x4_t *)((char *)v41 - v73);
        unsigned int v75 = &v37[v73 / 0xFFFFFFFFFFFFFFFELL];
        if ((v43 & 3) != 0) {
          char v76 = v43 & 0xFC;
        }
        else {
          char v76 = v43;
        }
        if ((v43 & 3) != 0)
        {
          int v77 = v70 + v376;
        }
        else
        {
          int v71 = -1;
          uint64_t v72 = (unsigned int *)v43;
          unsigned int v75 = v37;
          int v74 = v41;
          int v77 = v376;
        }
        if ((((_BYTE)v77 + v76) & 3) != 0)
        {
          int v78 = 4 - (((_BYTE)v77 + v76) & 3);
          v70 += v78;
          unsigned int v79 = 0xFFFFFFFF >> (8 * v78);
          if (v77 >= 4) {
            unsigned int v80 = v79;
          }
          else {
            unsigned int v80 = 0;
          }
          if (v77 >= 4) {
            unsigned int v79 = -1;
          }
          v71 &= v79;
        }
        else
        {
          unsigned int v80 = 0;
        }
        uint64_t v306 = v44 - v70;
        unint64_t v307 = v45 - v70;
        int v308 = v77 >> 2;
        uint64_t result = (unsigned __int16)~HIWORD(v33);
        unint64_t v309 = v39 - v70;
        while (1)
        {
          unsigned int v310 = *v72 & v71;
          int v311 = v308;
          unsigned int v312 = v80;
          if (!v310) {
            goto LABEL_555;
          }
LABEL_544:
          if (v310 == -1) {
            break;
          }
          while (1)
          {
            if ((_BYTE)v310)
            {
              unsigned int v325 = *(_DWORD *)(v32 + 4 * v310);
              unsigned int v326 = bswap32(*v75) >> 16;
              int v327 = HIWORD(v325) ^ 0xFFFF;
              unsigned int v328 = v327 * (bswap32(v74->u16[0]) >> 16);
              v74->i16[0] = bswap32(v325 + ((v328 + HIWORD(v328) + 1) >> 16)) >> 16;
              *unsigned int v75 = bswap32(((v327 * v326 + ((v327 * v326) >> 16) + 1) >> 16) + HIWORD(v325)) >> 16;
            }
            if ((v310 & 0xFF00) != 0)
            {
              unsigned int v329 = *(_DWORD *)(v32 + 4 * BYTE1(v310));
              unsigned int v330 = bswap32(v75[1]) >> 16;
              int v331 = HIWORD(v329) ^ 0xFFFF;
              unsigned int v332 = v331 * (bswap32(v74->u16[1]) >> 16);
              v74->i16[1] = bswap32(v329 + ((v332 + HIWORD(v332) + 1) >> 16)) >> 16;
              v75[1] = bswap32(((v331 * v330 + ((v331 * v330) >> 16) + 1) >> 16) + HIWORD(v329)) >> 16;
            }
            if ((v310 & 0xFF0000) != 0)
            {
              unsigned int v333 = *(_DWORD *)(v32 + 4 * BYTE2(v310));
              unsigned int v334 = bswap32(v75[2]) >> 16;
              int v335 = HIWORD(v333) ^ 0xFFFF;
              unsigned int v336 = v335 * (bswap32(v74->u16[2]) >> 16);
              v74->i16[2] = bswap32(v333 + ((v336 + HIWORD(v336) + 1) >> 16)) >> 16;
              v75[2] = bswap32(((v335 * v334 + ((v335 * v334) >> 16) + 1) >> 16) + HIWORD(v333)) >> 16;
            }
            unsigned int v337 = HIBYTE(v310);
            if (v337)
            {
              unsigned int v323 = *(_DWORD *)(v32 + 4 * v337);
              unsigned int v324 = HIWORD(v323);
              unsigned int v321 = bswap32(v74->u16[3]) >> 16;
              unsigned int v322 = bswap32(v75[3]) >> 16;
              unsigned int v319 = HIWORD(v323) ^ 0xFFFF;
              unsigned int v320 = v319;
              goto LABEL_554;
            }
LABEL_555:
            while (1)
            {
              int v338 = v311;
              ++v74;
              v75 += 4;
              --v311;
              ++v72;
              if (v338 < 2) {
                break;
              }
              unsigned int v310 = *v72;
              if (*v72) {
                goto LABEL_544;
              }
            }
            if (!v312) {
              break;
            }
            unsigned int v312 = 0;
            unsigned int v310 = *v72 & v80;
          }
          uint64_t v72 = (unsigned int *)((char *)v72 + v306);
          int v74 = (int16x4_t *)((char *)v74 + 2 * v307);
          v75 += v309;
          if (!--v8) {
            return result;
          }
        }
        unsigned int v313 = bswap32(v74->u16[0]);
        unsigned int v314 = bswap32(*v75);
        v74->i16[0] = bswap32(v33+ ((HIWORD(v313) * result + ((HIWORD(v313) * result) >> 16) + 1) >> 16)) >> 16;
        *unsigned int v75 = bswap32(((HIWORD(v314) * result + ((HIWORD(v314) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        unsigned int v315 = bswap32(v74->u16[1]);
        unsigned int v316 = bswap32(v75[1]);
        v74->i16[1] = bswap32(v33+ ((HIWORD(v315) * result + ((HIWORD(v315) * result) >> 16) + 1) >> 16)) >> 16;
        v75[1] = bswap32(((HIWORD(v316) * result + ((HIWORD(v316) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        unsigned int v317 = bswap32(v74->u16[2]);
        unsigned int v318 = bswap32(v75[2]);
        v74->i16[2] = bswap32(v33+ ((HIWORD(v317) * result + ((HIWORD(v317) * result) >> 16) + 1) >> 16)) >> 16;
        v75[2] = bswap32(((HIWORD(v318) * result + ((HIWORD(v318) * result) >> 16) + 1) >> 16)+ HIWORD(v33)) >> 16;
        unsigned int v319 = bswap32(v74->u16[3]) >> 16;
        unsigned int v320 = bswap32(v75[3]) >> 16;
        unsigned int v321 = (unsigned __int16)~HIWORD(v33);
        unsigned int v322 = v321;
        unsigned int v323 = v33;
        unsigned int v324 = HIWORD(v33);
LABEL_554:
        v74->i16[3] = bswap32(v323 + ((v319 * v321 + ((v319 * v321) >> 16) + 1) >> 16)) >> 16;
        v75[3] = bswap32(v324 + ((v320 * v322 + ((v320 * v322) >> 16) + 1) >> 16)) >> 16;
        goto LABEL_555;
      }
      int v265 = -1 << (8 * v70);
      if ((v43 & 3) != 0) {
        char v266 = v43 & 0xFC;
      }
      else {
        char v266 = v43;
      }
      if ((v43 & 3) != 0)
      {
        uint64_t v267 = (unsigned int *)(v43 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        int v265 = -1;
        uint64_t v267 = (unsigned int *)v43;
      }
      if ((v43 & 3) != 0) {
        uint64_t v268 = (int16x4_t *)((char *)v41 - 2 * (v43 & 3));
      }
      else {
        uint64_t v268 = v41;
      }
      if ((v43 & 3) != 0) {
        int v269 = v70 + v376;
      }
      else {
        int v269 = v376;
      }
      if ((((_BYTE)v269 + v266) & 3) != 0)
      {
        int v270 = 4 - (((_BYTE)v269 + v266) & 3);
        v70 += v270;
        unsigned int v271 = 0xFFFFFFFF >> (8 * v270);
        if (v269 >= 4) {
          unsigned int v272 = -1;
        }
        else {
          unsigned int v272 = 0xFFFFFFFF >> (8 * v270);
        }
        v265 &= v272;
        if (v269 < 4) {
          unsigned int v271 = 0;
        }
      }
      else
      {
        unsigned int v271 = 0;
      }
      uint64_t v355 = v44 - v70;
      int v356 = v269 >> 2;
      int v357 = (unsigned __int16)~HIWORD(v33);
      unint64_t v358 = v45 - v70;
      while (1)
      {
        unsigned int v359 = *v267 & v265;
        unsigned int v360 = v271;
        LODWORD(result) = v356;
        if (!v359) {
          goto LABEL_604;
        }
LABEL_593:
        if (v359 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v359)
          {
            unsigned int v367 = bswap32(v268->u16[0]);
            v268->i16[0] = bswap32(*(_DWORD *)(v32 + 4 * v359)+ (((~*(_DWORD *)(v32 + 4 * v359) >> 16) * HIWORD(v367)+ (((~*(_DWORD *)(v32 + 4 * v359) >> 16) * HIWORD(v367)) >> 16)+ 1) >> 16)) >> 16;
          }
          if ((v359 & 0xFF00) != 0)
          {
            unsigned int v368 = bswap32(v268->u16[1]);
            v268->i16[1] = bswap32(*(_DWORD *)(v32 + 4 * BYTE1(v359))+ (((~*(_DWORD *)(v32 + 4 * BYTE1(v359)) >> 16) * HIWORD(v368)+ (((~*(_DWORD *)(v32 + 4 * BYTE1(v359)) >> 16) * HIWORD(v368)) >> 16)+ 1) >> 16)) >> 16;
          }
          if ((v359 & 0xFF0000) != 0)
          {
            unsigned int v369 = bswap32(v268->u16[2]);
            v268->i16[2] = bswap32(*(_DWORD *)(v32 + 4 * BYTE2(v359))+ (((~*(_DWORD *)(v32 + 4 * BYTE2(v359)) >> 16) * HIWORD(v369)+ (((~*(_DWORD *)(v32 + 4 * BYTE2(v359)) >> 16) * HIWORD(v369)) >> 16)+ 1) >> 16)) >> 16;
          }
          unsigned int v370 = HIBYTE(v359);
          if (v370)
          {
            unsigned int v366 = *(_DWORD *)(v32 + 4 * v370);
            unsigned int v365 = bswap32(v268->u16[3]) >> 16;
            unsigned int v364 = ~v366 >> 16;
            goto LABEL_603;
          }
LABEL_604:
          while (1)
          {
            int v371 = result;
            ++v268;
            uint64_t result = (result - 1);
            ++v267;
            if (v371 < 2) {
              break;
            }
            unsigned int v359 = *v267;
            if (*v267) {
              goto LABEL_593;
            }
          }
          if (!v360) {
            break;
          }
          unsigned int v360 = 0;
          unsigned int v359 = *v267 & v271;
        }
        uint64_t v267 = (unsigned int *)((char *)v267 + v355);
        uint64_t v268 = (int16x4_t *)((char *)v268 + 2 * v358);
        if (!--v8) {
          return result;
        }
      }
      unsigned int v361 = bswap32(v268->u16[0]);
      v268->i16[0] = bswap32(v33 + ((HIWORD(v361) * v357 + ((HIWORD(v361) * v357) >> 16) + 1) >> 16)) >> 16;
      unsigned int v362 = bswap32(v268->u16[1]);
      v268->i16[1] = bswap32(v33 + ((HIWORD(v362) * v357 + ((HIWORD(v362) * v357) >> 16) + 1) >> 16)) >> 16;
      unsigned int v363 = bswap32(v268->u16[2]);
      v268->i16[2] = bswap32(v33 + ((HIWORD(v363) * v357 + ((HIWORD(v363) * v357) >> 16) + 1) >> 16)) >> 16;
      unsigned int v364 = bswap32(v268->u16[3]) >> 16;
      unsigned int v365 = (unsigned __int16)~HIWORD(v33);
      unsigned int v366 = v33;
LABEL_603:
      v268->i16[3] = bswap32(v366 + ((v364 * v365 + ((v364 * v365) >> 16) + 1) >> 16)) >> 16;
      goto LABEL_604;
    case 3:
      uint64_t v81 = 2 * v38;
      do
      {
        int v82 = v376;
        do
        {
          int v83 = *(unsigned __int8 *)v43;
          if (*(unsigned char *)v43)
          {
            if (v83 == 255)
            {
              unsigned int v84 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v37);
              v41->i16[0] = bswap32(v84) >> 16;
              unsigned int v85 = HIWORD(v84);
            }
            else
            {
              int v86 = v83 | (v83 << 8);
              unsigned int v87 = bswap32(*v37) >> 16;
              unsigned int v88 = *(_DWORD *)(v32 + 4 * ((v87 * v86 + ((v87 * v86) >> 16) + 1) >> 24));
              v86 ^= 0xFFFFu;
              unsigned int v89 = (bswap32(v41->u16[0]) >> 16) * v86;
              v41->i16[0] = bswap32(v88 + ((v89 + HIWORD(v89) + 1) >> 16)) >> 16;
              unsigned int v85 = ((v87 * v86 + ((v87 * v86) >> 16) + 1) >> 16) + HIWORD(v88);
            }
            unsigned __int16 *v37 = bswap32(v85) >> 16;
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v81);
          --v82;
        }
        while (v82);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 4:
      uint64_t v90 = 2 * v38;
      do
      {
        int v91 = v376;
        do
        {
          int v92 = *(unsigned __int8 *)v43;
          if (*(unsigned char *)v43)
          {
            if (v92 == 255)
            {
              unsigned int v93 = *(_DWORD *)(v32 + 4 * ~*(unsigned char *)v37);
              v41->i16[0] = bswap32(v93) >> 16;
              unsigned int v94 = HIWORD(v93);
            }
            else
            {
              int v95 = v92 | (v92 << 8);
              unsigned int v96 = bswap32(*v37) >> 16;
              unsigned int v97 = *(_DWORD *)(v32 + 4 * (((v96 ^ 0xFFFF) * v95 + (((v96 ^ 0xFFFF) * v95) >> 16) + 1) >> 24));
              v95 ^= 0xFFFFu;
              unsigned int v98 = (bswap32(v41->u16[0]) >> 16) * v95;
              v41->i16[0] = bswap32(v97 + ((v98 + HIWORD(v98) + 1) >> 16)) >> 16;
              unsigned int v94 = ((v96 * v95 + ((v96 * v95) >> 16) + 1) >> 16) + HIWORD(v97);
            }
            unsigned __int16 *v37 = bswap32(v94) >> 16;
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v90);
          --v91;
        }
        while (v91);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 5:
      uint64_t v99 = 2 * v38;
      do
      {
        int v100 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unsigned int v101 = bswap32(*v37);
            unsigned int v102 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v103 = bswap32(v41->u16[0]);
            int v104 = HIWORD(v102) ^ 0xFFFF;
            v41->i16[0] = bswap32((unsigned __int16)v102 * HIWORD(v101)+ v104 * HIWORD(v103)+ (((unsigned __int16)v102 * HIWORD(v101) + v104 * HIWORD(v103)) >> 16)+ 1);
            unsigned __int16 *v37 = bswap32((v104 + HIWORD(v101)) * HIWORD(v102)+ (((v104 + HIWORD(v101)) * HIWORD(v102)) >> 16)+ 1);
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v99);
          --v100;
        }
        while (v100);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 6:
      do
      {
        int v105 = v376;
        do
        {
          uint64_t v106 = *(unsigned __int8 *)v43;
          if (*(unsigned char *)v43)
          {
            unsigned int v107 = bswap32(*v37);
            if (HIWORD(v107) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v107) == 0xFFFF)
              {
                unsigned int v108 = *(_DWORD *)(v32 + 4 * v106);
                v41->i16[0] = bswap32(v108) >> 16;
                unsigned int v109 = HIWORD(v108);
              }
              else
              {
                unsigned int v110 = HIWORD(v107);
                unsigned int v111 = *(_DWORD *)(v32 + 4 * v106);
                int v112 = (unsigned __int16)~HIWORD(v107);
                v41->i16[0] = bswap32((bswap32(v41->u16[0]) >> 16)+ (((unsigned __int16)v111 * v112+ (((unsigned __int16)v111 * v112) >> 16)+ 1) >> 16)) >> 16;
                unsigned int v109 = v110 + ((HIWORD(v111) * v112 + ((HIWORD(v111) * v112) >> 16) + 1) >> 16);
              }
              unsigned __int16 *v37 = bswap32(v109) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          v37 += v38;
          --v105;
        }
        while (v105);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 7:
      int v113 = v40 ^ 0xFFFF;
      if (v3)
      {
        uint64_t v114 = 2 * v38;
        do
        {
          int v115 = v376;
          do
          {
            int v116 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              if (v116 == 255)
              {
                unsigned int v117 = bswap32(v41->u16[0]) >> 16;
                unsigned int v118 = bswap32(*v37) >> 16;
                unsigned int v119 = v113 * v117;
                unsigned int v120 = v113 * v118;
              }
              else
              {
                int v121 = v116 | (v116 << 8);
                unsigned int v117 = bswap32(v41->u16[0]) >> 16;
                unsigned int v118 = bswap32(*v37) >> 16;
                int v122 = (unsigned __int16)(v121 - ((v40 * v121 + ((v40 * v121) >> 16) + 1) >> 16));
                unsigned int v119 = v117 * v122;
                unsigned int v120 = v118 * v122;
              }
              v41->i16[0] = bswap32(v117 - ((v119 + HIWORD(v119) + 1) >> 16)) >> 16;
              unsigned __int16 *v37 = bswap32(v118 - ((v120 + HIWORD(v120) + 1) >> 16)) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            unsigned int v37 = (unsigned __int16 *)((char *)v37 + v114);
            --v115;
          }
          while (v115);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          v37 += result;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v123 = v376;
          do
          {
            int v124 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              if (v124 == 255)
              {
                unsigned int v125 = bswap32(v41->u16[0]) >> 16;
                unsigned int v126 = v40 ^ 0xFFFF;
                unsigned int v127 = v125;
              }
              else
              {
                int v128 = v124 | (v124 << 8);
                unsigned int v126 = bswap32(v41->u16[0]) >> 16;
                unsigned int v125 = v128 - ((v40 * v128 + ((v40 * v128) >> 16) + 1) >> 16);
                unsigned int v127 = v126;
              }
              v41->i16[0] = bswap32(v127- ((v126 * (unsigned __int16)v125 + ((v126 * (unsigned __int16)v125) >> 16) + 1) >> 16)) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            --v123;
          }
          while (v123);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          --v8;
        }
        while (v8);
      }
      return result;
    case 8:
      int v129 = 257 * v40;
      if (v3)
      {
        uint64_t v130 = 2 * v38;
        do
        {
          int v131 = v376;
          do
          {
            int v132 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              unsigned int v133 = bswap32(v41->u16[0]) >> 16;
              unsigned int v134 = bswap32(*v37) >> 16;
              if (v132 == 255) {
                unsigned int v135 = v40;
              }
              else {
                unsigned int v135 = (v129 * v132 + ((v129 * v132) >> 16) + 1) >> 16;
              }
              v41->i16[0] = bswap32(v133 - ((v135 * v133 + ((v135 * v133) >> 16) + 1) >> 16)) >> 16;
              unsigned __int16 *v37 = bswap32(v134 - ((v135 * v134 + ((v135 * v134) >> 16) + 1) >> 16)) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            unsigned int v37 = (unsigned __int16 *)((char *)v37 + v130);
            --v131;
          }
          while (v131);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          v37 += result;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v136 = v376;
          do
          {
            int v137 = *(unsigned __int8 *)v43;
            if (*(unsigned char *)v43)
            {
              unsigned int v138 = bswap32(v41->u16[0]) >> 16;
              if (v137 == 255) {
                unsigned int v139 = v40;
              }
              else {
                unsigned int v139 = (v129 * v137 + ((v129 * v137) >> 16) + 1) >> 16;
              }
              v41->i16[0] = bswap32(v138 - ((v139 * v138 + ((v139 * v138) >> 16) + 1) >> 16)) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            --v136;
          }
          while (v136);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          --v8;
        }
        while (v8);
      }
      return result;
    case 9:
      uint64_t v140 = 2 * v38;
      do
      {
        int v141 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unsigned int v142 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v143 = bswap32(~*v37) >> 16;
            unsigned int v144 = bswap32(v41->u16[0]) >> 16;
            unsigned __int16 v145 = ~(*(unsigned __int8 *)v43 | (*(unsigned __int8 *)v43 << 8)) + HIWORD(v142);
            v41->i16[0] = bswap32((unsigned __int16)v142 * v143+ v145 * v144+ (((unsigned __int16)v142 * v143 + v145 * v144) >> 16)+ 1);
            unsigned __int16 *v37 = bswap32((v143 + v145) * HIWORD(v142) + (((v143 + v145) * HIWORD(v142)) >> 16) + 1);
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v140);
          --v141;
        }
        while (v141);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 10:
      uint64_t v146 = 2 * v38;
      do
      {
        int v147 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unsigned int v148 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v149 = bswap32(~*v37);
            unsigned int v150 = bswap32(v41->u16[0]);
            int v151 = HIWORD(v148) ^ 0xFFFF;
            v41->i16[0] = bswap32((unsigned __int16)v148 * HIWORD(v149)+ v151 * HIWORD(v150)+ (((unsigned __int16)v148 * HIWORD(v149) + v151 * HIWORD(v150)) >> 16)+ 1);
            unsigned __int16 *v37 = bswap32((v151 + HIWORD(v149)) * HIWORD(v148)+ (((v151 + HIWORD(v149)) * HIWORD(v148)) >> 16)+ 1);
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v146);
          --v147;
        }
        while (v147);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        --v8;
      }
      while (v8);
      return result;
    case 11:
      if (v3)
      {
        uint64_t v152 = 2 * v38;
        do
        {
          int v153 = v376;
          do
          {
            if (*(unsigned char *)v43)
            {
              unsigned int v154 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
              unsigned int v155 = bswap32(*v37);
              unsigned int v156 = HIWORD(v154);
              signed int v157 = HIWORD(v154) - ((bswap32(v41->u16[0]) >> 16) + (unsigned __int16)v154) + HIWORD(v155);
              unsigned int v158 = v156 + HIWORD(v155);
              if (v157 >= 0xFFFF) {
                signed int v157 = 0xFFFF;
              }
              if (v158 >= 0xFFFF) {
                unsigned int v158 = 0xFFFF;
              }
              v41->i16[0] = bswap32(v158 - v157) >> 16;
              unsigned __int16 *v37 = bswap32(v158) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            unsigned int v37 = (unsigned __int16 *)((char *)v37 + v152);
            --v153;
          }
          while (v153);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          v37 += result;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          int v273 = v376;
          do
          {
            if (*(unsigned char *)v43)
            {
              unsigned int v274 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
              signed int v275 = HIWORD(v274) - (unsigned __int16)v274 + (bswap32(~v41->u16[0]) >> 16);
              if (v275 >= 0xFFFF) {
                signed int v275 = 0xFFFF;
              }
              v41->i16[0] = bswap32(~v275) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            --v273;
          }
          while (v273);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          --v8;
        }
        while (v8);
      }
      return result;
    case 12:
      if (v3)
      {
        uint64_t v159 = 2 * v38;
        do
        {
          int v160 = v376;
          do
          {
            if (*(unsigned char *)v43)
            {
              unsigned int v161 = *(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
              unsigned int v162 = HIWORD(v161);
              unsigned int v163 = (bswap32(v41->u16[0]) >> 16) + (unsigned __int16)v161;
              unsigned int v164 = v162 + (bswap32(*v37) >> 16);
              if (v163 >= 0xFFFF) {
                unsigned int v163 = 0xFFFF;
              }
              if (v164 >= 0xFFFF) {
                unsigned int v164 = 0xFFFF;
              }
              v41->i16[0] = bswap32(v163) >> 16;
              unsigned __int16 *v37 = bswap32(v164) >> 16;
            }
            ++v43;
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            unsigned int v37 = (unsigned __int16 *)((char *)v37 + v159);
            --v160;
          }
          while (v160);
          v43 += v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          v37 += result;
          --v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v276 = 0;
          do
          {
            if (*(unsigned char *)(v43 + v276))
            {
              int v277 = bswap32(v41->u16[0]);
              v41->i16[0] = bswap32((v277 >> 15) & 0xFFFE | ((v277 >> 16) >> 15)) >> 16;
            }
            unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
            ++v276;
          }
          while (v376 != v276);
          v43 += (v376 - 1) + 1 + v44;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
          --v8;
        }
        while (v8);
      }
      return result;
    case 13:
      uint64_t v165 = 2 * v38;
      while (1)
      {
        int v166 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unint64_t v167 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            if (v167 >= 0x10000)
            {
              unint64_t v168 = v167 >> 16;
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v169 = __rev16(*v37);
                  goto LABEL_202;
                }
LABEL_210:
                v41->i16[0] = bswap32(v167) >> 16;
                unsigned int v174 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v169 = 0xFFFF;
LABEL_202:
                unint64_t v170 = (v169 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v167
                     + ((v168 ^ 0xFFFF) + (unsigned __int16)v167)
                     * (unint64_t)(bswap32(v41->u16[0]) >> 16);
                if (v170 <= 0xFFFE8000) {
                  unint64_t v171 = v170 + 0x8000;
                }
                else {
                  unint64_t v171 = 4294868992;
                }
                unint64_t v172 = v171 + (v171 >> 16);
                if (v3)
                {
                  unint64_t v167 = v172 >> 16;
                  int64_t v173 = 0xFFFF * (v169 + v168) - v169 * (unint64_t)v168;
                  if (v173 <= 4294868992) {
                    unint64_t v168 = v173 + 0x8000;
                  }
                  else {
                    unint64_t v168 = 4294868992;
                  }
                  LODWORD(v167) = ((v168 >> 16) + v168) & 0xFFFF0000 | v167;
                  LODWORD(v168) = WORD1(v167);
                  goto LABEL_210;
                }
                unint64_t v168 = v172 >> 16;
                unsigned int v174 = v41;
              }
              v174->i16[0] = bswap32(v168) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v165);
          --v166;
        }
        while (v166);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        if (!--v8) {
          return result;
        }
      }
    case 14:
      uint64_t v175 = 2 * v38;
      while (1)
      {
        int v176 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unint64_t v177 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            if (v177 >= 0x10000)
            {
              unint64_t v178 = v177 >> 16;
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v179 = __rev16(*v37);
                  goto LABEL_224;
                }
LABEL_232:
                v41->i16[0] = bswap32(v177) >> 16;
                unsigned int v184 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v179 = 0xFFFF;
LABEL_224:
                uint64_t v180 = bswap32(v41->u16[0]) >> 16;
                unint64_t v181 = (v180 ^ 0xFFFF)
                     * (unint64_t)(unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43)
                     - v180
                     + (v180 << 16);
                if (v181 <= 0xFFFE8000) {
                  unint64_t v182 = v181 + 0x8000;
                }
                else {
                  unint64_t v182 = 4294868992;
                }
                unint64_t v177 = (v182 + (v182 >> 16)) >> 16;
                if (v3)
                {
                  int64_t v183 = 0xFFFF * (v178 + v179) - v178 * (unint64_t)v179;
                  if (v183 <= 4294868992) {
                    unint64_t v178 = v183 + 0x8000;
                  }
                  else {
                    unint64_t v178 = 4294868992;
                  }
                  LODWORD(v177) = ((v178 >> 16) + v178) & 0xFFFF0000 | v177;
                  LODWORD(v178) = WORD1(v177);
                  goto LABEL_232;
                }
                LODWORD(v178) = v177;
                unsigned int v184 = v41;
              }
              v184->i16[0] = bswap32(v178) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v175);
          --v176;
        }
        while (v176);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        if (!--v8) {
          return result;
        }
      }
    case 15:
      uint64_t v185 = 2 * v38;
      while (1)
      {
        int v186 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v187 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v188 = __rev16(*v37);
                  goto LABEL_246;
                }
LABEL_248:
                v41->i16[0] = bswap32(result) >> 16;
                int v189 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v188 = 0xFFFF;
LABEL_246:
                uint64_t result = PDAoverlayPDA_8925(bswap32(v41->u16[0]) >> 16, v188, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v187);
                if (v3)
                {
                  unsigned int v187 = WORD1(result);
                  goto LABEL_248;
                }
                unsigned int v187 = result;
                int v189 = v41;
              }
              v189->i16[0] = bswap32(v187) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v185);
          --v186;
        }
        while (v186);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 16:
      uint64_t v190 = 2 * v38;
      while (1)
      {
        int v191 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v192 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v193 = __rev16(*v37);
                  goto LABEL_262;
                }
LABEL_264:
                v41->i16[0] = bswap32(result) >> 16;
                uint64_t v194 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v193 = 0xFFFF;
LABEL_262:
                uint64_t result = PDAdarkenPDA_8927(bswap32(v41->u16[0]) >> 16, v193, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v192);
                if (v3)
                {
                  unsigned int v192 = WORD1(result);
                  goto LABEL_264;
                }
                unsigned int v192 = result;
                uint64_t v194 = v41;
              }
              v194->i16[0] = bswap32(v192) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v190);
          --v191;
        }
        while (v191);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 17:
      uint64_t v195 = 2 * v38;
      while (1)
      {
        int v196 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v197 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v198 = __rev16(*v37);
                  goto LABEL_278;
                }
LABEL_280:
                v41->i16[0] = bswap32(result) >> 16;
                unsigned int v199 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v198 = 0xFFFF;
LABEL_278:
                uint64_t result = PDAlightenPDA_8926(bswap32(v41->u16[0]) >> 16, v198, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v197);
                if (v3)
                {
                  unsigned int v197 = WORD1(result);
                  goto LABEL_280;
                }
                unsigned int v197 = result;
                unsigned int v199 = v41;
              }
              v199->i16[0] = bswap32(v197) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v195);
          --v196;
        }
        while (v196);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 18:
      uint64_t v200 = 2 * v38;
      while (1)
      {
        int v201 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v202 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v203 = __rev16(*v37);
                  goto LABEL_294;
                }
LABEL_296:
                v41->i16[0] = bswap32(result) >> 16;
                uint64_t v204 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v203 = 0xFFFF;
LABEL_294:
                uint64_t result = PDAcolordodgePDA_8928(bswap32(v41->u16[0]) >> 16, v203, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v202);
                if (v3)
                {
                  unsigned int v202 = WORD1(result);
                  goto LABEL_296;
                }
                unsigned int v202 = result;
                uint64_t v204 = v41;
              }
              v204->i16[0] = bswap32(v202) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v200);
          --v201;
        }
        while (v201);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 19:
      uint64_t v205 = 2 * v38;
      while (1)
      {
        int v206 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v207 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v208 = __rev16(*v37);
                  goto LABEL_310;
                }
LABEL_312:
                v41->i16[0] = bswap32(result) >> 16;
                unsigned int v209 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v208 = 0xFFFF;
LABEL_310:
                uint64_t result = PDAcolorburnPDA_8929(bswap32(v41->u16[0]) >> 16, v208, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v207);
                if (v3)
                {
                  unsigned int v207 = WORD1(result);
                  goto LABEL_312;
                }
                unsigned int v207 = result;
                unsigned int v209 = v41;
              }
              v209->i16[0] = bswap32(v207) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v205);
          --v206;
        }
        while (v206);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 20:
      uint64_t v210 = 2 * v38;
      while (1)
      {
        int v211 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v212 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v213 = __rev16(*v37);
                  goto LABEL_326;
                }
LABEL_328:
                v41->i16[0] = bswap32(result) >> 16;
                uint64_t v214 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v213 = 0xFFFF;
LABEL_326:
                uint64_t result = PDAsoftlightPDA_8931(bswap32(v41->u16[0]) >> 16, v213, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v212);
                if (v3)
                {
                  unsigned int v212 = WORD1(result);
                  goto LABEL_328;
                }
                unsigned int v212 = result;
                uint64_t v214 = v41;
              }
              v214->i16[0] = bswap32(v212) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v210);
          --v211;
        }
        while (v211);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 21:
      uint64_t v215 = 2 * v38;
      while (1)
      {
        int v216 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v217 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v218 = __rev16(*v37);
                  goto LABEL_342;
                }
LABEL_344:
                v41->i16[0] = bswap32(result) >> 16;
                uint64_t v219 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v218 = 0xFFFF;
LABEL_342:
                uint64_t result = PDAhardlightPDA_8930(bswap32(v41->u16[0]) >> 16, v218, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v217);
                if (v3)
                {
                  unsigned int v217 = WORD1(result);
                  goto LABEL_344;
                }
                unsigned int v217 = result;
                uint64_t v219 = v41;
              }
              v219->i16[0] = bswap32(v217) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v215);
          --v216;
        }
        while (v216);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 22:
      uint64_t v220 = 2 * v38;
      while (1)
      {
        int v221 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v222 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v223 = __rev16(*v37);
                  goto LABEL_358;
                }
LABEL_360:
                v41->i16[0] = bswap32(result) >> 16;
                unsigned int v224 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v223 = 0xFFFF;
LABEL_358:
                uint64_t result = PDAdifferencePDA_8932(bswap32(v41->u16[0]) >> 16, v223, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v222);
                if (v3)
                {
                  unsigned int v222 = WORD1(result);
                  goto LABEL_360;
                }
                unsigned int v222 = result;
                unsigned int v224 = v41;
              }
              v224->i16[0] = bswap32(v222) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v220);
          --v221;
        }
        while (v221);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 23:
      uint64_t v225 = 2 * v38;
      while (1)
      {
        int v226 = v376;
        do
        {
          if (*(unsigned char *)v43)
          {
            unint64_t v227 = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unint64_t v228 = v227 >> 16;
            if (HIWORD(*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43)))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v229 = __rev16(*v37);
                  goto LABEL_374;
                }
LABEL_388:
                v41->i16[0] = bswap32(v227) >> 16;
                unsigned int v236 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v229 = 0xFFFF;
LABEL_374:
                LODWORD(v230) = bswap32(v41->u16[0]) >> 16;
                if ((unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43) >= v228) {
                  uint64_t v231 = v228;
                }
                else {
                  uint64_t v231 = (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43);
                }
                if (v230 >= v229) {
                  uint64_t v230 = v229;
                }
                else {
                  uint64_t v230 = v230;
                }
                int64_t v232 = 0xFFFF * (v230 + v231) - 2 * v231 * (unint64_t)v230;
                if (v232 <= 4294868992) {
                  unint64_t v233 = v232 + 0x8000;
                }
                else {
                  unint64_t v233 = 4294868992;
                }
                unint64_t v234 = v233 + (v233 >> 16);
                if (v3)
                {
                  unint64_t v227 = v234 >> 16;
                  int64_t v235 = 0xFFFF * (v228 + v229) - v228 * (unint64_t)v229;
                  if (v235 <= 4294868992) {
                    unint64_t v228 = v235 + 0x8000;
                  }
                  else {
                    unint64_t v228 = 4294868992;
                  }
                  LODWORD(v227) = ((v228 >> 16) + v228) & 0xFFFF0000 | v227;
                  LODWORD(v228) = WORD1(v227);
                  goto LABEL_388;
                }
                unint64_t v228 = v234 >> 16;
                unsigned int v236 = v41;
              }
              v236->i16[0] = bswap32(v228) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v225);
          --v226;
        }
        while (v226);
        v43 += v44;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v45);
        v37 += result;
        if (!--v8) {
          return result;
        }
      }
    case 24:
      uint64_t v237 = 2 * v38;
      while (1)
      {
        int v238 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v239 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v240 = __rev16(*v37);
                  goto LABEL_402;
                }
LABEL_404:
                v41->i16[0] = bswap32(result) >> 16;
                unint64_t v241 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v240 = 0xFFFF;
LABEL_402:
                uint64_t result = PDAhuePDA_8933(bswap32(v41->u16[0]) >> 16, v240, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v239);
                if (v3)
                {
                  unsigned int v239 = WORD1(result);
                  goto LABEL_404;
                }
                unsigned int v239 = result;
                unint64_t v241 = v41;
              }
              v241->i16[0] = bswap32(v239) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v237);
          --v238;
        }
        while (v238);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 25:
      uint64_t v242 = 2 * v38;
      while (1)
      {
        int v243 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v244 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v245 = __rev16(*v37);
                  goto LABEL_418;
                }
LABEL_420:
                v41->i16[0] = bswap32(result) >> 16;
                BOOL v246 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v245 = 0xFFFF;
LABEL_418:
                uint64_t result = PDAhuePDA_8933(bswap32(v41->u16[0]) >> 16, v245, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v244);
                if (v3)
                {
                  unsigned int v244 = WORD1(result);
                  goto LABEL_420;
                }
                unsigned int v244 = result;
                BOOL v246 = v41;
              }
              v246->i16[0] = bswap32(v244) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v242);
          --v243;
        }
        while (v243);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 26:
      uint64_t v247 = 2 * v38;
      while (1)
      {
        int v248 = v31;
        do
        {
          if (*(unsigned char *)v43)
          {
            uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
            unsigned int v249 = WORD1(result);
            if (WORD1(result))
            {
              if (v3)
              {
                if (*v37)
                {
                  unsigned int v250 = __rev16(*v37);
                  goto LABEL_434;
                }
LABEL_436:
                v41->i16[0] = bswap32(result) >> 16;
                int v251 = (int16x4_t *)v37;
              }
              else
              {
                unsigned int v250 = 0xFFFF;
LABEL_434:
                uint64_t result = PDAluminosityPDA_8935((unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v249, bswap32(v41->u16[0]) >> 16, v250);
                if (v3)
                {
                  unsigned int v249 = WORD1(result);
                  goto LABEL_436;
                }
                unsigned int v249 = result;
                int v251 = v41;
              }
              v251->i16[0] = bswap32(v249) >> 16;
            }
          }
          ++v43;
          unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
          unsigned int v37 = (unsigned __int16 *)((char *)v37 + v247);
          --v248;
        }
        while (v248);
        v43 += v373;
        int v31 = v376;
        unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
        v37 += v46;
        if (!--v8) {
          return result;
        }
      }
    case 27:
      uint64_t v252 = 2 * v38;
      break;
    default:
      return result;
  }
  do
  {
    int v253 = v31;
    do
    {
      if (*(unsigned char *)v43)
      {
        uint64_t result = *(unsigned int *)(v32 + 4 * *(unsigned __int8 *)v43);
        unsigned int v254 = WORD1(result);
        if (WORD1(result))
        {
          if (v3)
          {
            if (*v37)
            {
              unsigned int v255 = __rev16(*v37);
              goto LABEL_450;
            }
LABEL_452:
            v41->i16[0] = bswap32(result) >> 16;
            unint64_t v256 = (int16x4_t *)v37;
          }
          else
          {
            unsigned int v255 = 0xFFFF;
LABEL_450:
            uint64_t result = PDAluminosityPDA_8935(bswap32(v41->u16[0]) >> 16, v255, (unsigned __int16)*(_DWORD *)(v32 + 4 * *(unsigned __int8 *)v43), v254);
            if (v3)
            {
              unsigned int v254 = WORD1(result);
              goto LABEL_452;
            }
            unsigned int v254 = result;
            unint64_t v256 = v41;
          }
          v256->i16[0] = bswap32(v254) >> 16;
        }
      }
      ++v43;
      unsigned int v41 = (int16x4_t *)((char *)v41 + 2);
      unsigned int v37 = (unsigned __int16 *)((char *)v37 + v252);
      --v253;
    }
    while (v253);
    v43 += v373;
    int v31 = v376;
    unsigned int v41 = (int16x4_t *)((char *)v41 + 2 * v375);
    v37 += v46;
    --v8;
  }
  while (v8);
  return result;
}

unint64_t W16_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 48);
  uint64_t v3 = *(void *)(result + 136);
  uint64_t v5 = *(int *)(result + 12);
  uint64_t v4 = *(int *)(result + 16);
  if (v2)
  {
    unint64_t v6 = (unint64_t)*(int *)(result + 32) >> 1;
    unsigned int v7 = (char *)(v2 + 2 * (v5 + v6 * v4));
    int v8 = -1;
    if (!v3) {
      return result;
    }
  }
  else
  {
    unsigned int v7 = 0;
    unint64_t v6 = 0;
    int v8 = 0;
    if (!v3) {
      return result;
    }
  }
  int v10 = *(_DWORD *)(result + 4);
  int v9 = *(_DWORD *)(result + 8);
  unint64_t v12 = *(void *)(result + 88);
  uint64_t v11 = *(void *)(result + 96);
  unint64_t v13 = (unint64_t)*(int *)(result + 28) >> 1;
  uint64_t v14 = (char *)(*(void *)(result + 40) + 2 * (v5 + v13 * v4));
  uint64_t v15 = *(int *)(result + 124);
  int v16 = (unsigned char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  uint64_t v17 = *(int *)(result + 56);
  uint64_t v18 = *(int *)(result + 60);
  unint64_t v19 = *(int *)(result + 76);
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    int v21 = *(_DWORD *)(result + 64);
    int v22 = *(_DWORD *)(result + 68);
    unint64_t v767 = v19 >> 1;
    int v769 = *(unsigned __int16 **)(result + 96);
    if (v11)
    {
      unint64_t v766 = (unint64_t)*(int *)(result + 80) >> 1;
      int v20 = 1;
    }
    else
    {
      unint64_t v766 = 0;
      int v20 = 0;
    }
    unint64_t v26 = v12 + 2 * v767 * v22;
    v8 &= 1u;
    int v25 = 1;
    unsigned int v768 = *(char **)(result + 88);
    int32x4_t v23 = v768;
    goto LABEL_19;
  }
  unint64_t v767 = v19 >> 1;
  if (v11)
  {
    unint64_t v766 = (unint64_t)*(int *)(result + 80) >> 1;
    int v769 = (unsigned __int16 *)(v11 + 2 * (v17 + v766 * v18));
    int v20 = -1;
  }
  else
  {
    int v769 = 0;
    unint64_t v766 = 0;
    int v20 = 0;
  }
  int32x4_t v23 = (char *)(v12 + 2 * (v17 + v767 * v18));
  if (v767 == v13 && v14 - v23 >= 1)
  {
    if (v10 >= (uint64_t)((unint64_t)(v14 - v23) >> 1))
    {
      v14 += 2 * v10 - 2;
      v23 += 2 * v10 - 2;
      v16 += v10 - 1;
      v7 += 2 * (v8 & (v10 - 1));
      int v25 = -1;
      unint64_t v767 = (unint64_t)*(int *)(result + 28) >> 1;
      v769 += v20 & (v10 - 1);
      goto LABEL_16;
    }
    uint64_t v24 = v9 - 1;
    if (v14 <= &v23[2 * v13 * v24 - 2 + 2 * v10])
    {
      v14 += 2 * v13 * v24;
      v16 += v15 * v24;
      uint64_t v15 = -v15;
      v7 += 2 * v6 * v24;
      unint64_t v6 = -(uint64_t)v6;
      v8 &= 1u;
      v769 += v766 * v24;
      unint64_t v766 = -(uint64_t)v766;
      unint64_t v767 = -(uint64_t)v13;
      v20 &= 1u;
      int v25 = 1;
      v23 += 2 * v13 * v24;
      unint64_t v13 = -(uint64_t)v13;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v20 &= 1u;
  int v25 = 1;
LABEL_16:
  unint64_t v26 = 0;
  unsigned int v768 = 0;
  unint64_t v12 = -1;
  int v22 = v766;
  int v21 = v767;
LABEL_19:
  int v27 = v25 * v10;
  unint64_t v763 = v26;
  if (v26)
  {
    uint64_t v28 = (int)v18 % v22;
    int8x16_t v29 = &v23[2 * v767 * v28];
    uint64_t result = (int)v17 % v21;
    int32x4_t v23 = &v29[2 * result];
    unint64_t v12 = (unint64_t)&v29[2 * v21];
    unint64_t v30 = v766 * v28;
    uint64_t v31 = (uint64_t)v769;
    uint64_t v32 = (uint64_t)&v769[v30 + result];
    if (v20) {
      uint64_t v31 = v32;
    }
    unsigned int v768 = &v29[2 * result];
    int v769 = (unsigned __int16 *)v31;
  }
  else
  {
    v767 -= v27;
    v766 -= v20 * v10;
  }
  uint64_t v765 = v15 - v27;
  unint64_t v764 = v13 - v27;
  unint64_t v762 = v6 - v8 * v10;
  int v749 = v10;
  int v782 = v8;
  int v783 = v20;
  switch(a2)
  {
    case 0:
      if (v8)
      {
        do
        {
          int v33 = v10;
          do
          {
            int v34 = *v16;
            if (*v16)
            {
              if (v34 == 255)
              {
                LOWORD(v35) = 0;
                *(_WORD *)uint64_t v14 = 0;
              }
              else
              {
                unsigned int v36 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v37 = bswap32(*(unsigned __int16 *)v7) >> 16;
                int v38 = v34 | (v34 << 8);
                *(_WORD *)uint64_t v14 = bswap32(v36 - ((v38 * v36 + ((v38 * v36) >> 16) + 1) >> 16)) >> 16;
                unsigned int v35 = bswap32(v37 - ((v38 * v37 + ((v38 * v37) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)unsigned int v7 = v35;
            }
            v16 += v25;
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v33;
          }
          while (v33);
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v600 = v10;
          do
          {
            int v601 = *v16;
            if (*v16)
            {
              if (v601 == 255)
              {
                LOWORD(v602) = 0;
              }
              else
              {
                unsigned int v603 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v602 = bswap32(v603 - ((257 * v601 * v603 + ((257 * v601 * v603) >> 16) + 1) >> 16)) >> 16;
              }
              *(_WORD *)uint64_t v14 = v602;
            }
            v16 += v25;
            v14 += 2 * v25;
            --v600;
          }
          while (v600);
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 1:
      if (v8)
      {
        uint64_t v39 = v25;
        if (v20)
        {
          uint64_t v40 = -(uint64_t)v21;
          uint64_t v41 = v22;
          uint64_t v42 = -(uint64_t)(v767 * v22);
          uint64_t v43 = -(uint64_t)(v766 * v41);
          uint64_t v44 = v769;
          do
          {
            int v45 = v10;
            do
            {
              int v46 = *v16;
              if (*v16)
              {
                if (v46 == 255)
                {
                  *(_WORD *)uint64_t v14 = *(_WORD *)v23;
                  unsigned __int16 v47 = *v44;
                }
                else
                {
                  unsigned int v48 = bswap32(*v44);
                  unsigned int v49 = (bswap32(*(unsigned __int16 *)v23) >> 16) * (v46 | (v46 << 8))
                      + (bswap32(*(unsigned __int16 *)v14) >> 16) * ((v46 | (v46 << 8)) ^ 0xFFFF);
                  *(_WORD *)uint64_t v14 = bswap32(v49 + HIWORD(v49) + 1);
                  unsigned __int16 v47 = bswap32(0xFFFF * HIWORD(v48) + ((0xFFFF * HIWORD(v48)) >> 16) + 1);
                }
                *(_WORD *)unsigned int v7 = v47;
              }
              v16 += v39;
              unsigned int v50 = &v23[2 * v39];
              unsigned int v51 = &v44[v20];
              if ((unint64_t)v50 >= v12) {
                uint64_t result = v40;
              }
              else {
                uint64_t result = 0;
              }
              uint64_t v44 = &v51[result];
              int32x4_t v23 = &v50[2 * result];
              v7 += 2 * v8;
              v14 += 2 * v39;
              --v45;
            }
            while (v45);
            if (v763)
            {
              uint64_t result = v767;
              unsigned int v52 = &v768[2 * v767];
              if ((unint64_t)v52 >= v763) {
                uint64_t v53 = v43;
              }
              else {
                uint64_t v53 = 0;
              }
              uint64_t v54 = (uint64_t)&v769[v766 + v53];
              if ((unint64_t)v52 >= v763) {
                uint64_t v55 = v42;
              }
              else {
                uint64_t v55 = 0;
              }
              int32x4_t v23 = &v52[2 * v55];
              v12 += 2 * v55 + 2 * v767;
              unsigned int v768 = v23;
              v769 += v766 + v53;
              uint64_t v44 = (unsigned __int16 *)v54;
            }
            else
            {
              v23 += 2 * v767;
              v44 += v766;
            }
            v16 += v765;
            v14 += 2 * v764;
            v7 += 2 * v762;
            --v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v699 = -(uint64_t)v21;
          uint64_t v700 = -(uint64_t)(v767 * v22);
          do
          {
            int v701 = v10;
            do
            {
              int v702 = *v16;
              if (*v16)
              {
                if (v702 == 255)
                {
                  __int16 v703 = *(_WORD *)v23;
                }
                else
                {
                  int v704 = v702 | (v702 << 8);
                  unsigned int v705 = bswap32(*(unsigned __int16 *)v14) >> 16;
                  unsigned int v706 = (bswap32(*(unsigned __int16 *)v23) >> 16) * v704;
                  __int16 v703 = bswap32(v706 + v705 * (v704 ^ 0xFFFF) + ((v706 + v705 * (v704 ^ 0xFFFF)) >> 16) + 1);
                }
                *(_WORD *)uint64_t v14 = v703;
                *(_WORD *)unsigned int v7 = -1;
              }
              v16 += v39;
              __int16 v707 = &v23[2 * v39];
              if ((unint64_t)v707 >= v12) {
                uint64_t v708 = v699;
              }
              else {
                uint64_t v708 = 0;
              }
              int32x4_t v23 = &v707[2 * v708];
              v7 += 2 * v8;
              v14 += 2 * v39;
              --v701;
            }
            while (v701);
            v16 += v765;
            v14 += 2 * v764;
            v7 += 2 * v762;
            uint64_t result = (unint64_t)v768;
            unsigned int v709 = &v768[2 * v767];
            if ((unint64_t)v709 >= v763) {
              uint64_t v710 = v700;
            }
            else {
              uint64_t v710 = 0;
            }
            __int16 v711 = &v709[2 * v710];
            uint64_t v712 = v12 + 2 * v710 + 2 * v767;
            if (v763)
            {
              unint64_t v12 = v712;
              uint64_t result = (unint64_t)v711;
            }
            unsigned int v768 = (char *)result;
            if (v763) {
              int32x4_t v23 = v711;
            }
            else {
              v23 += 2 * v767;
            }
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        uint64_t v604 = v25;
        uint64_t v605 = -(uint64_t)v21;
        uint64_t v606 = -(uint64_t)(v767 * v22);
        uint64_t v607 = 2 * v25;
        do
        {
          int v608 = v10;
          do
          {
            int v609 = *v16;
            if (*v16)
            {
              if (v609 == 255)
              {
                __int16 v610 = *(_WORD *)v23;
              }
              else
              {
                int v611 = v609 | (v609 << 8);
                unsigned int v612 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v613 = (bswap32(*(unsigned __int16 *)v23) >> 16) * v611;
                __int16 v610 = bswap32(v613 + v612 * (v611 ^ 0xFFFF) + ((v613 + v612 * (v611 ^ 0xFFFF)) >> 16) + 1);
              }
              *(_WORD *)uint64_t v14 = v610;
            }
            v16 += v604;
            int v614 = &v23[2 * v604];
            if ((unint64_t)v614 >= v12) {
              uint64_t v615 = v605;
            }
            else {
              uint64_t v615 = 0;
            }
            int32x4_t v23 = &v614[2 * v615];
            v14 += v607;
            --v608;
          }
          while (v608);
          v16 += v765;
          v14 += 2 * v764;
          unsigned int v616 = v768;
          unsigned int v617 = &v768[2 * v767];
          if ((unint64_t)v617 >= v763) {
            uint64_t v618 = v606;
          }
          else {
            uint64_t v618 = 0;
          }
          unsigned int v619 = &v617[2 * v618];
          uint64_t v620 = v12 + 2 * v618 + 2 * v767;
          if (v763)
          {
            unint64_t v12 = v620;
            unsigned int v616 = v619;
          }
          unsigned int v768 = v616;
          if (v763) {
            int32x4_t v23 = v619;
          }
          else {
            v23 += 2 * v767;
          }
          --v9;
        }
        while (v9);
      }
      return result;
    case 2:
      uint64_t v56 = v25;
      if (v8)
      {
        uint64_t v57 = v22;
        uint64_t v58 = -(uint64_t)(v767 * v22);
        uint64_t v59 = -(uint64_t)(v766 * v57);
        int v60 = v769;
        uint64_t v61 = -(uint64_t)v21;
        while (1)
        {
          int v62 = v10;
          do
          {
            int v63 = *v16;
            if (!*v16) {
              goto LABEL_74;
            }
            if (v63 != 255)
            {
              unsigned int v66 = bswap32(*(unsigned __int16 *)v23) >> 16;
              unsigned int v67 = bswap32(*v60);
              int v68 = (v63 | (v63 << 8)) ^ 0xFFFF;
              unsigned int v69 = v66 - ((v68 * v66 + ((v68 * v66) >> 16) + 1) >> 16);
              unsigned int v70 = v69 | ((HIWORD(v67) - ((v68 * HIWORD(v67) + ((v68 * HIWORD(v67)) >> 16) + 1) >> 16)) << 16);
              if (!HIWORD(v70)) {
                goto LABEL_74;
              }
              unsigned int v71 = bswap32(*(unsigned __int16 *)v14);
              unsigned int v72 = bswap32(*(unsigned __int16 *)v7) >> 16;
              int v73 = HIWORD(v70) ^ 0xFFFF;
              *(_WORD *)uint64_t v14 = bswap32(v69 + ((v73 * HIWORD(v71) + ((v73 * HIWORD(v71)) >> 16) + 1) >> 16)) >> 16;
              unsigned int v74 = ((v73 * v72 + ((v73 * v72) >> 16) + 1) >> 16) + HIWORD(v70);
              goto LABEL_72;
            }
            unsigned int v64 = *v60;
            unsigned int v65 = __rev16(v64);
            if (!v65) {
              goto LABEL_74;
            }
            if (v65 != 0xFFFF)
            {
              unsigned int v75 = bswap32(*(unsigned __int16 *)v14);
              unsigned int v76 = bswap32(*(unsigned __int16 *)v7);
              *(_WORD *)uint64_t v14 = bswap32((bswap32(*(unsigned __int16 *)v23) >> 16)+ ((HIWORD(v75) * (v65 ^ 0xFFFF) + ((HIWORD(v75) * (v65 ^ 0xFFFF)) >> 16) + 1) >> 16)) >> 16;
              unsigned int v74 = v65 + ((HIWORD(v76) * (v65 ^ 0xFFFF) + ((HIWORD(v76) * (v65 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_72:
              unsigned int v64 = bswap32(v74) >> 16;
              goto LABEL_73;
            }
            *(_WORD *)uint64_t v14 = *(_WORD *)v23;
LABEL_73:
            *(_WORD *)unsigned int v7 = v64;
LABEL_74:
            v16 += v25;
            uint64_t result = (unint64_t)&v23[2 * v25];
            int v77 = &v60[v20];
            if (result >= v12) {
              uint64_t v78 = v61;
            }
            else {
              uint64_t v78 = 0;
            }
            int v60 = &v77[v78];
            int32x4_t v23 = (char *)(result + 2 * v78);
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v62;
          }
          while (v62);
          if (v763)
          {
            unsigned int v79 = &v768[2 * v767];
            if ((unint64_t)v79 >= v763) {
              uint64_t v80 = v59;
            }
            else {
              uint64_t v80 = 0;
            }
            uint64_t v81 = (uint64_t)&v769[v766 + v80];
            if ((unint64_t)v79 >= v763) {
              uint64_t v82 = v58;
            }
            else {
              uint64_t v82 = 0;
            }
            uint64_t result = v12 + 2 * v82;
            int32x4_t v23 = &v79[2 * v82];
            unint64_t v12 = result + 2 * v767;
            unsigned int v768 = v23;
            int v769 = (unsigned __int16 *)v81;
            int v60 = (unsigned __int16 *)v81;
          }
          else
          {
            v23 += 2 * v767;
            v60 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          if (!--v9) {
            return result;
          }
        }
      }
      uint64_t v621 = -(uint64_t)v21;
      uint64_t v622 = v22;
      uint64_t v623 = -(uint64_t)(v767 * v22);
      uint64_t v624 = -(uint64_t)(v766 * v622);
      unsigned int v625 = v769;
LABEL_827:
      int v626 = v10;
      while (1)
      {
        int v627 = *v16;
        if (*v16)
        {
          if (v627 == 255)
          {
            unsigned int v628 = bswap32(*v625) >> 16;
            if (v628)
            {
              if (v628 == 0xFFFF)
              {
                LOWORD(v629) = *(_WORD *)v23;
              }
              else
              {
                unsigned int v638 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v637 = (bswap32(*(unsigned __int16 *)v23) >> 16)
                     + ((v638 * (v628 ^ 0xFFFF) + ((v638 * (v628 ^ 0xFFFF)) >> 16) + 1) >> 16);
LABEL_836:
                unsigned int v629 = bswap32(v637) >> 16;
              }
              *(_WORD *)uint64_t v14 = v629;
            }
          }
          else
          {
            unsigned int v630 = bswap32(*(unsigned __int16 *)v23);
            unsigned int v631 = bswap32(*v625) >> 16;
            int v632 = (v627 | (v627 << 8)) ^ 0xFFFF;
            unsigned int v633 = v632 * v631 + ((v632 * v631) >> 16) + 1;
            unsigned int v634 = HIWORD(v630) - ((v632 * HIWORD(v630) + ((v632 * HIWORD(v630)) >> 16) + 1) >> 16);
            unsigned int v635 = v634 | ((v631 - HIWORD(v633)) << 16);
            if (v635 >= 0x10000)
            {
              unsigned int v636 = bswap32(*(unsigned __int16 *)v14) >> 16;
              unsigned int v637 = v634 + (((~v635 >> 16) * v636 + (((~v635 >> 16) * v636) >> 16) + 1) >> 16);
              goto LABEL_836;
            }
          }
        }
        v16 += v56;
        unsigned int v639 = &v23[2 * v56];
        int v640 = &v625[v20];
        if ((unint64_t)v639 >= v12) {
          uint64_t result = v621;
        }
        else {
          uint64_t result = 0;
        }
        unsigned int v625 = &v640[result];
        int32x4_t v23 = &v639[2 * result];
        v14 += 2 * v56;
        if (!--v626)
        {
          if (v763)
          {
            uint64_t result = v767;
            int v641 = &v768[2 * v767];
            if ((unint64_t)v641 >= v763) {
              uint64_t v642 = v624;
            }
            else {
              uint64_t v642 = 0;
            }
            uint64_t v643 = (uint64_t)&v769[v766 + v642];
            if ((unint64_t)v641 >= v763) {
              uint64_t v644 = v623;
            }
            else {
              uint64_t v644 = 0;
            }
            int32x4_t v23 = &v641[2 * v644];
            v12 += 2 * v644 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v642;
            unsigned int v625 = (unsigned __int16 *)v643;
          }
          else
          {
            v23 += 2 * v767;
            v625 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          if (!--v9) {
            return result;
          }
          goto LABEL_827;
        }
      }
    case 3:
      uint64_t v83 = v25;
      uint64_t v84 = v22;
      uint64_t v85 = -(uint64_t)(v767 * v22);
      uint64_t v86 = -(uint64_t)(v766 * v84);
      uint64_t v87 = 2 * v25;
      unsigned int v88 = v769;
      uint64_t v89 = -(uint64_t)v21;
      do
      {
        int v90 = v10;
        do
        {
          int v91 = *v16;
          if (*v16)
          {
            if (v91 == 255)
            {
              if (v20) {
                unsigned int v92 = bswap32(*v88) >> 16;
              }
              else {
                unsigned int v92 = 0xFFFF;
              }
              unsigned int v94 = bswap32(*(unsigned __int16 *)v23) >> 16;
              unsigned int v95 = bswap32(~*(unsigned __int16 *)v7) >> 16;
              *(_WORD *)uint64_t v14 = bswap32(v94 - ((v95 * v94 + ((v95 * v94) >> 16) + 1) >> 16)) >> 16;
              unsigned int v96 = v92 - ((v95 * v92 + ((v95 * v92) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20) {
                unsigned int v93 = bswap32(*v88) >> 16;
              }
              else {
                unsigned int v93 = 0xFFFF;
              }
              int v97 = v91 | (v91 << 8);
              unsigned int v98 = bswap32(*(unsigned __int16 *)v7);
              unsigned int v99 = HIWORD(v98) * v97 + ((HIWORD(v98) * v97) >> 16) + 1;
              v97 ^= 0xFFFFu;
              unsigned int v100 = HIWORD(v99) * (bswap32(*(unsigned __int16 *)v23) >> 16)
                   + (bswap32(*(unsigned __int16 *)v14) >> 16) * v97;
              unsigned int v96 = ((v97 + HIWORD(v99)) * v93 + (((v97 + HIWORD(v99)) * v93) >> 16) + 1) >> 16;
              *(_WORD *)uint64_t v14 = bswap32(v100 + HIWORD(v100) + 1);
            }
            *(_WORD *)unsigned int v7 = bswap32(v96) >> 16;
          }
          v16 += v83;
          unsigned int v101 = &v23[2 * v83];
          unsigned int v102 = &v88[v20];
          if ((unint64_t)v101 >= v12) {
            uint64_t result = v89;
          }
          else {
            uint64_t result = 0;
          }
          unsigned int v88 = &v102[result];
          int32x4_t v23 = &v101[2 * result];
          v7 += 2 * v8;
          v14 += v87;
          --v90;
        }
        while (v90);
        if (v763)
        {
          uint64_t result = v767;
          unsigned int v103 = &v768[2 * v767];
          if ((unint64_t)v103 >= v763) {
            uint64_t v104 = v86;
          }
          else {
            uint64_t v104 = 0;
          }
          uint64_t v105 = (uint64_t)&v769[v766 + v104];
          if ((unint64_t)v103 >= v763) {
            uint64_t v106 = v85;
          }
          else {
            uint64_t v106 = 0;
          }
          int32x4_t v23 = &v103[2 * v106];
          v12 += 2 * v106 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v104;
          unsigned int v88 = (unsigned __int16 *)v105;
        }
        else
        {
          v23 += 2 * v767;
          v88 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 4:
      uint64_t v107 = v25;
      uint64_t v108 = v22;
      uint64_t v109 = -(uint64_t)(v767 * v22);
      uint64_t v110 = -(uint64_t)(v766 * v108);
      uint64_t v111 = 2 * v25;
      int v112 = v769;
      uint64_t v113 = -(uint64_t)v21;
      do
      {
        int v114 = v10;
        do
        {
          int v115 = *v16;
          if (*v16)
          {
            if (v115 == 255)
            {
              if (v20) {
                unsigned int v116 = bswap32(*v112) >> 16;
              }
              else {
                unsigned int v116 = 0xFFFF;
              }
              unsigned int v118 = bswap32(*(unsigned __int16 *)v23) >> 16;
              unsigned int v119 = bswap32(*(unsigned __int16 *)v7) >> 16;
              *(_WORD *)uint64_t v14 = bswap32(v118 - ((v119 * v118 + ((v119 * v118) >> 16) + 1) >> 16)) >> 16;
              unsigned int v120 = v116 - ((v119 * v116 + ((v119 * v116) >> 16) + 1) >> 16);
            }
            else
            {
              if (v20) {
                unsigned int v117 = bswap32(*v112) >> 16;
              }
              else {
                unsigned int v117 = 0xFFFF;
              }
              int v121 = v115 | (v115 << 8);
              unsigned int v122 = bswap32(~*(unsigned __int16 *)v7);
              unsigned int v123 = HIWORD(v122) * v121 + ((HIWORD(v122) * v121) >> 16) + 1;
              v121 ^= 0xFFFFu;
              unsigned int v124 = HIWORD(v123) * (bswap32(*(unsigned __int16 *)v23) >> 16)
                   + (bswap32(*(unsigned __int16 *)v14) >> 16) * v121;
              unsigned int v120 = ((v121 + HIWORD(v123)) * v117 + (((v121 + HIWORD(v123)) * v117) >> 16) + 1) >> 16;
              *(_WORD *)uint64_t v14 = bswap32(v124 + HIWORD(v124) + 1);
            }
            *(_WORD *)unsigned int v7 = bswap32(v120) >> 16;
          }
          v16 += v107;
          unsigned int v125 = &v23[2 * v107];
          unsigned int v126 = &v112[v20];
          if ((unint64_t)v125 >= v12) {
            uint64_t result = v113;
          }
          else {
            uint64_t result = 0;
          }
          int v112 = &v126[result];
          int32x4_t v23 = &v125[2 * result];
          v7 += 2 * v8;
          v14 += v111;
          --v114;
        }
        while (v114);
        if (v763)
        {
          uint64_t result = v767;
          unsigned int v127 = &v768[2 * v767];
          if ((unint64_t)v127 >= v763) {
            uint64_t v128 = v110;
          }
          else {
            uint64_t v128 = 0;
          }
          uint64_t v129 = (uint64_t)&v769[v766 + v128];
          if ((unint64_t)v127 >= v763) {
            uint64_t v130 = v109;
          }
          else {
            uint64_t v130 = 0;
          }
          int32x4_t v23 = &v127[2 * v130];
          v12 += 2 * v130 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v128;
          int v112 = (unsigned __int16 *)v129;
        }
        else
        {
          v23 += 2 * v767;
          v112 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 5:
      uint64_t v131 = v25;
      uint64_t v132 = v22;
      uint64_t v133 = -(uint64_t)(v767 * v22);
      uint64_t v134 = -(uint64_t)(v766 * v132);
      uint64_t v135 = 2 * v25;
      int v136 = v769;
      uint64_t v137 = -(uint64_t)v21;
      do
      {
        int v138 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v139 = bswap32(*(unsigned __int16 *)v7);
            unsigned int v140 = bswap32(*(unsigned __int16 *)v23);
            unsigned int v141 = bswap32(*v136);
            int v142 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v143 = HIWORD(v140) - ((v142 * HIWORD(v140) + ((v142 * HIWORD(v140)) >> 16) + 1) >> 16);
            unsigned int v144 = (v143 | ((HIWORD(v141)
                           - ((v142 * HIWORD(v141) + ((v142 * HIWORD(v141)) >> 16) + 1) >> 16)) << 16)) >> 16;
            unsigned int v145 = (unsigned __int16)v143 * HIWORD(v139) + (v144 ^ 0xFFFF) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            *(_WORD *)uint64_t v14 = bswap32(v145 + HIWORD(v145) + 1);
            *(_WORD *)unsigned int v7 = bswap32(((v144 ^ 0xFFFF) + HIWORD(v139)) * v144+ ((((v144 ^ 0xFFFF) + HIWORD(v139)) * v144) >> 16)+ 1);
          }
          v16 += v131;
          uint64_t v146 = &v23[2 * v131];
          int v147 = &v136[v20];
          if ((unint64_t)v146 >= v12) {
            uint64_t result = v137;
          }
          else {
            uint64_t result = 0;
          }
          int v136 = &v147[result];
          int32x4_t v23 = &v146[2 * result];
          v7 += 2 * v8;
          v14 += v135;
          --v138;
        }
        while (v138);
        if (v763)
        {
          uint64_t result = v767;
          unsigned int v148 = &v768[2 * v767];
          if ((unint64_t)v148 >= v763) {
            uint64_t v149 = v134;
          }
          else {
            uint64_t v149 = 0;
          }
          uint64_t v150 = (uint64_t)&v769[v766 + v149];
          if ((unint64_t)v148 >= v763) {
            uint64_t v151 = v133;
          }
          else {
            uint64_t v151 = 0;
          }
          int32x4_t v23 = &v148[2 * v151];
          v12 += 2 * v151 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v149;
          int v136 = (unsigned __int16 *)v150;
        }
        else
        {
          v23 += 2 * v767;
          v136 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 6:
      uint64_t v152 = v20;
      uint64_t v153 = -(uint64_t)v21;
      uint64_t v154 = v22;
      uint64_t v155 = -(uint64_t)(v767 * v22);
      uint64_t v156 = -(uint64_t)(v766 * v154);
      signed int v157 = v769;
      do
      {
        int v158 = v10;
        do
        {
          int v159 = *v16;
          if (*v16)
          {
            unsigned int v160 = bswap32(*(unsigned __int16 *)v7);
            if (HIWORD(v160) != 0xFFFF)
            {
              if ((unsigned __int16)~HIWORD(v160) == 0xFFFF)
              {
                if (v20) {
                  unsigned int v161 = bswap32(*v157) >> 16;
                }
                else {
                  unsigned int v161 = 0xFFFF;
                }
                unsigned int v163 = bswap32(*(unsigned __int16 *)v23) >> 16;
                int v164 = (v159 | (v159 << 8)) ^ 0xFFFF;
                *(_WORD *)uint64_t v14 = bswap32(v163 - ((v164 * v163 + ((v164 * v163) >> 16) + 1) >> 16)) >> 16;
                unsigned int v165 = v161 - ((v164 * v161 + ((v164 * v161) >> 16) + 1) >> 16);
              }
              else
              {
                if (v20) {
                  unsigned int v162 = bswap32(*v157) >> 16;
                }
                else {
                  unsigned int v162 = 0xFFFF;
                }
                unsigned int v166 = bswap32(*(unsigned __int16 *)v23);
                unsigned int v167 = (257 * v159 * (unsigned __int16)~HIWORD(v160)
                      + ((257 * v159 * (unsigned __int16)~HIWORD(v160)) >> 16)
                      + 1) >> 16;
                *(_WORD *)uint64_t v14 = bswap32((bswap32(*(unsigned __int16 *)v14) >> 16)+ ((v167 * HIWORD(v166) + ((v167 * HIWORD(v166)) >> 16) + 1) >> 16)) >> 16;
                unsigned int v165 = HIWORD(v160) + ((v167 * v162 + ((v167 * v162) >> 16) + 1) >> 16);
                int v20 = v783;
              }
              *(_WORD *)unsigned int v7 = bswap32(v165) >> 16;
            }
          }
          v16 += v25;
          unint64_t v168 = &v23[2 * v25];
          unsigned int v169 = &v157[v152];
          if ((unint64_t)v168 >= v12) {
            uint64_t v170 = v153;
          }
          else {
            uint64_t v170 = 0;
          }
          signed int v157 = &v169[v170];
          int32x4_t v23 = &v168[2 * v170];
          v7 += 2 * v8;
          v14 += 2 * v25;
          --v158;
        }
        while (v158);
        if (v763)
        {
          unint64_t v171 = &v768[2 * v767];
          if ((unint64_t)v171 >= v763) {
            uint64_t v172 = v156;
          }
          else {
            uint64_t v172 = 0;
          }
          uint64_t v173 = (uint64_t)&v769[v766 + v172];
          if ((unint64_t)v171 >= v763) {
            uint64_t v174 = v155;
          }
          else {
            uint64_t v174 = 0;
          }
          int32x4_t v23 = &v171[2 * v174];
          v12 += 2 * v174 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v172;
          signed int v157 = (unsigned __int16 *)v173;
        }
        else
        {
          v23 += 2 * v767;
          v157 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        uint64_t result = v6 - v8 * v10;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 7:
      uint64_t v175 = v25;
      if (v8)
      {
        uint64_t v176 = v22;
        uint64_t v177 = -(uint64_t)(v767 * v22);
        uint64_t v178 = -(uint64_t)(v766 * v176);
        unsigned int v179 = v769;
        uint64_t v180 = -(uint64_t)v21;
        do
        {
          int v181 = v10;
          do
          {
            int v182 = *v16;
            if (*v16)
            {
              if (v182 == 255)
              {
                unsigned int v183 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v184 = bswap32(*(unsigned __int16 *)v7) >> 16;
                unsigned int v185 = bswap32(~*v179) >> 16;
                *(_WORD *)uint64_t v14 = bswap32(v183 - ((v185 * v183 + ((v185 * v183) >> 16) + 1) >> 16)) >> 16;
                unsigned int v186 = v184 - ((v185 * v184 + ((v185 * v184) >> 16) + 1) >> 16);
              }
              else
              {
                unsigned int v187 = bswap32(*(unsigned __int16 *)v7);
                unsigned int v188 = bswap32(*v179);
                unsigned int v189 = ((v182 | (v182 << 8)) ^ 0xFFFF)
                     + ((HIWORD(v188) * (v182 | (v182 << 8))
                       + ((HIWORD(v188) * (v182 | (v182 << 8))) >> 16)
                       + 1) >> 16);
                unsigned int v190 = v189 * (bswap32(*(unsigned __int16 *)v14) >> 16);
                unsigned int v186 = (v189 * HIWORD(v187) + ((v189 * HIWORD(v187)) >> 16) + 1) >> 16;
                *(_WORD *)uint64_t v14 = bswap32(v190 + HIWORD(v190) + 1);
              }
              *(_WORD *)unsigned int v7 = bswap32(v186) >> 16;
            }
            v16 += v175;
            int v191 = &v23[2 * v175];
            unsigned int v192 = &v179[v20];
            if ((unint64_t)v191 >= v12) {
              uint64_t result = v180;
            }
            else {
              uint64_t result = 0;
            }
            unsigned int v179 = &v192[result];
            int32x4_t v23 = &v191[2 * result];
            v7 += 2 * v8;
            v14 += 2 * v175;
            --v181;
          }
          while (v181);
          if (v763)
          {
            uint64_t result = v767;
            unsigned int v193 = &v768[2 * v767];
            if ((unint64_t)v193 >= v763) {
              uint64_t v194 = v178;
            }
            else {
              uint64_t v194 = 0;
            }
            uint64_t v195 = (uint64_t)&v769[v766 + v194];
            if ((unint64_t)v193 >= v763) {
              uint64_t v196 = v177;
            }
            else {
              uint64_t v196 = 0;
            }
            int32x4_t v23 = &v193[2 * v196];
            v12 += 2 * v196 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v194;
            unsigned int v179 = (unsigned __int16 *)v195;
          }
          else
          {
            v23 += 2 * v767;
            v179 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v645 = -(uint64_t)v21;
        uint64_t v646 = v22;
        uint64_t v647 = -(uint64_t)(v767 * v22);
        uint64_t v648 = -(uint64_t)(v766 * v646);
        unsigned int v649 = v769;
        do
        {
          int v650 = v10;
          do
          {
            int v651 = *v16;
            if (*v16)
            {
              if (v651 == 255)
              {
                unsigned int v652 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v653 = bswap32(~*v649);
                unsigned int v654 = v652 - ((HIWORD(v653) * v652 + ((HIWORD(v653) * v652) >> 16) + 1) >> 16);
              }
              else
              {
                int v655 = v651 | (v651 << 8);
                unsigned int v656 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unsigned int v657 = bswap32(*v649);
                uint64_t result = HIWORD(v657) * v655 + ((HIWORD(v657) * v655) >> 16) + 1;
                unsigned int v654 = (((v655 ^ 0xFFFF) + WORD1(result)) * v656 + ((((v655 ^ 0xFFFF) + WORD1(result)) * v656) >> 16) + 1) >> 16;
              }
              *(_WORD *)uint64_t v14 = bswap32(v654) >> 16;
            }
            v16 += v175;
            int v658 = &v23[2 * v175];
            unsigned int v659 = &v649[v20];
            if ((unint64_t)v658 >= v12) {
              uint64_t v660 = v645;
            }
            else {
              uint64_t v660 = 0;
            }
            unsigned int v649 = &v659[v660];
            int32x4_t v23 = &v658[2 * v660];
            v14 += 2 * v175;
            --v650;
          }
          while (v650);
          if (v763)
          {
            int v661 = &v768[2 * v767];
            if ((unint64_t)v661 >= v763) {
              uint64_t v662 = v648;
            }
            else {
              uint64_t v662 = 0;
            }
            uint64_t result = (unint64_t)&v769[v766 + v662];
            if ((unint64_t)v661 >= v763) {
              uint64_t v663 = v647;
            }
            else {
              uint64_t v663 = 0;
            }
            int32x4_t v23 = &v661[2 * v663];
            v12 += 2 * v663 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v662;
            unsigned int v649 = (unsigned __int16 *)result;
          }
          else
          {
            v23 += 2 * v767;
            v649 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 8:
      uint64_t v197 = v25;
      if (v8)
      {
        uint64_t v198 = v22;
        uint64_t v199 = -(uint64_t)(v767 * v22);
        uint64_t v200 = -(uint64_t)(v766 * v198);
        int v201 = v769;
        uint64_t v202 = -(uint64_t)v21;
        do
        {
          int v203 = v10;
          do
          {
            int v204 = *v16;
            if (*v16)
            {
              unsigned int v205 = bswap32(*(unsigned __int16 *)v14) >> 16;
              unsigned int v206 = bswap32(*(unsigned __int16 *)v7) >> 16;
              if (v204 == 255)
              {
                unsigned int v207 = bswap32(*v201);
              }
              else
              {
                unsigned int v208 = bswap32(*v201) >> 16;
                unsigned int v207 = 257 * v204 * v208 + ((257 * v204 * v208) >> 16) + 1;
              }
              *(_WORD *)uint64_t v14 = bswap32(v205 - ((HIWORD(v207) * v205 + ((HIWORD(v207) * v205) >> 16) + 1) >> 16)) >> 16;
              *(_WORD *)unsigned int v7 = bswap32(v206 - ((HIWORD(v207) * v206 + ((HIWORD(v207) * v206) >> 16) + 1) >> 16)) >> 16;
            }
            v16 += v197;
            unsigned int v209 = &v23[2 * v197];
            uint64_t v210 = &v201[v20];
            if ((unint64_t)v209 >= v12) {
              uint64_t result = v202;
            }
            else {
              uint64_t result = 0;
            }
            int v201 = &v210[result];
            int32x4_t v23 = &v209[2 * result];
            v7 += 2 * v8;
            v14 += 2 * v197;
            --v203;
          }
          while (v203);
          if (v763)
          {
            uint64_t result = v767;
            int v211 = &v768[2 * v767];
            if ((unint64_t)v211 >= v763) {
              uint64_t v212 = v200;
            }
            else {
              uint64_t v212 = 0;
            }
            uint64_t v213 = (uint64_t)&v769[v766 + v212];
            if ((unint64_t)v211 >= v763) {
              uint64_t v214 = v199;
            }
            else {
              uint64_t v214 = 0;
            }
            int32x4_t v23 = &v211[2 * v214];
            v12 += 2 * v214 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v212;
            int v201 = (unsigned __int16 *)v213;
          }
          else
          {
            v23 += 2 * v767;
            v201 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v664 = -(uint64_t)v21;
        uint64_t v665 = v22;
        uint64_t v666 = -(uint64_t)(v767 * v22);
        uint64_t v667 = -(uint64_t)(v766 * v665);
        unsigned int v668 = v769;
        do
        {
          int v669 = v10;
          do
          {
            int v670 = *v16;
            if (*v16)
            {
              unsigned int v671 = bswap32(*(unsigned __int16 *)v14) >> 16;
              if (v670 == 255)
              {
                unsigned int v672 = bswap32(*v668);
              }
              else
              {
                uint64_t result = bswap32(*v668) >> 16;
                unsigned int v672 = 257 * v670 * result + ((257 * v670 * result) >> 16) + 1;
              }
              *(_WORD *)uint64_t v14 = bswap32(v671 - ((HIWORD(v672) * v671 + ((HIWORD(v672) * v671) >> 16) + 1) >> 16)) >> 16;
            }
            v16 += v197;
            unsigned int v673 = &v23[2 * v197];
            int v674 = &v668[v20];
            if ((unint64_t)v673 >= v12) {
              uint64_t v675 = v664;
            }
            else {
              uint64_t v675 = 0;
            }
            unsigned int v668 = &v674[v675];
            int32x4_t v23 = &v673[2 * v675];
            v14 += 2 * v197;
            --v669;
          }
          while (v669);
          if (v763)
          {
            unsigned int v676 = &v768[2 * v767];
            if ((unint64_t)v676 >= v763) {
              uint64_t v677 = v667;
            }
            else {
              uint64_t v677 = 0;
            }
            uint64_t result = (unint64_t)&v769[v766 + v677];
            if ((unint64_t)v676 >= v763) {
              uint64_t v678 = v666;
            }
            else {
              uint64_t v678 = 0;
            }
            int32x4_t v23 = &v676[2 * v678];
            v12 += 2 * v678 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v677;
            unsigned int v668 = (unsigned __int16 *)result;
          }
          else
          {
            v23 += 2 * v767;
            v668 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 9:
      uint64_t v215 = -(uint64_t)v21;
      uint64_t v216 = v22;
      uint64_t v217 = -(uint64_t)(v767 * v22);
      uint64_t v218 = -(uint64_t)(v766 * v216);
      uint64_t v219 = v769;
      do
      {
        int v220 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v221 = bswap32(*(unsigned __int16 *)v23);
            unsigned int v222 = bswap32(*v219);
            unsigned __int16 v223 = ~(*v16 | (*v16 << 8));
            int v224 = v223;
            unsigned int v225 = HIWORD(v221) - ((HIWORD(v221) * v224 + ((HIWORD(v221) * v224) >> 16) + 1) >> 16);
            unsigned int v226 = v225 | ((HIWORD(v222)
                          - ((HIWORD(v222) * v224 + ((HIWORD(v222) * v224) >> 16) + 1) >> 16)) << 16);
            unsigned int v227 = bswap32(~*(unsigned __int16 *)v7) >> 16;
            unsigned int v228 = (unsigned __int16)v225 * v227
                 + (unsigned __int16)(v223 + HIWORD(v226)) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            unsigned int v229 = (v227 + (unsigned __int16)(v223 + HIWORD(v226))) * HIWORD(v226);
            *(_WORD *)uint64_t v14 = bswap32(v228 + HIWORD(v228) + 1);
            *(_WORD *)unsigned int v7 = bswap32(v229 + HIWORD(v229) + 1);
          }
          v16 += v25;
          uint64_t result = (unint64_t)&v23[2 * v25];
          uint64_t v230 = &v219[v20];
          if (result >= v12) {
            uint64_t v231 = v215;
          }
          else {
            uint64_t v231 = 0;
          }
          uint64_t v219 = &v230[v231];
          int32x4_t v23 = (char *)(result + 2 * v231);
          v7 += 2 * v8;
          v14 += 2 * v25;
          --v220;
        }
        while (v220);
        if (v763)
        {
          int64_t v232 = &v768[2 * v767];
          if ((unint64_t)v232 >= v763) {
            uint64_t v233 = v218;
          }
          else {
            uint64_t v233 = 0;
          }
          uint64_t v234 = (uint64_t)&v769[v766 + v233];
          if ((unint64_t)v232 >= v763) {
            uint64_t v235 = v217;
          }
          else {
            uint64_t v235 = 0;
          }
          uint64_t result = v12 + 2 * v235;
          int32x4_t v23 = &v232[2 * v235];
          unint64_t v12 = result + 2 * v767;
          unsigned int v768 = v23;
          int v769 = (unsigned __int16 *)v234;
          uint64_t v219 = (unsigned __int16 *)v234;
        }
        else
        {
          v23 += 2 * v767;
          v219 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 10:
      uint64_t v236 = v25;
      uint64_t v237 = v22;
      uint64_t v238 = -(uint64_t)(v767 * v22);
      uint64_t v239 = -(uint64_t)(v766 * v237);
      uint64_t v240 = 2 * v25;
      unint64_t v241 = v769;
      uint64_t v242 = -(uint64_t)v21;
      do
      {
        int v243 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v244 = bswap32(*(unsigned __int16 *)v23);
            unsigned int v245 = bswap32(*v241);
            int v246 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v247 = HIWORD(v244) - ((v246 * HIWORD(v244) + ((v246 * HIWORD(v244)) >> 16) + 1) >> 16);
            unsigned int v248 = (v247 | ((HIWORD(v245)
                           - ((v246 * HIWORD(v245) + ((v246 * HIWORD(v245)) >> 16) + 1) >> 16)) << 16)) >> 16;
            unsigned int v249 = bswap32(~*(unsigned __int16 *)v7);
            unsigned int v250 = (unsigned __int16)v247 * HIWORD(v249) + (v248 ^ 0xFFFF) * (bswap32(*(unsigned __int16 *)v14) >> 16);
            *(_WORD *)uint64_t v14 = bswap32(v250 + HIWORD(v250) + 1);
            *(_WORD *)unsigned int v7 = bswap32(((v248 ^ 0xFFFF) + HIWORD(v249)) * v248+ ((((v248 ^ 0xFFFF) + HIWORD(v249)) * v248) >> 16)+ 1);
          }
          v16 += v236;
          int v251 = &v23[2 * v236];
          uint64_t v252 = &v241[v20];
          if ((unint64_t)v251 >= v12) {
            uint64_t result = v242;
          }
          else {
            uint64_t result = 0;
          }
          unint64_t v241 = &v252[result];
          int32x4_t v23 = &v251[2 * result];
          v7 += 2 * v8;
          v14 += v240;
          --v243;
        }
        while (v243);
        if (v763)
        {
          uint64_t result = v767;
          int v253 = &v768[2 * v767];
          if ((unint64_t)v253 >= v763) {
            uint64_t v254 = v239;
          }
          else {
            uint64_t v254 = 0;
          }
          uint64_t v255 = (uint64_t)&v769[v766 + v254];
          if ((unint64_t)v253 >= v763) {
            uint64_t v256 = v238;
          }
          else {
            uint64_t v256 = 0;
          }
          int32x4_t v23 = &v253[2 * v256];
          v12 += 2 * v256 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v254;
          unint64_t v241 = (unsigned __int16 *)v255;
        }
        else
        {
          v23 += 2 * v767;
          v241 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        --v9;
      }
      while (v9);
      return result;
    case 11:
      uint64_t v257 = v25;
      if (v8)
      {
        uint64_t v258 = v22;
        uint64_t v259 = -(uint64_t)(v767 * v22);
        uint64_t v260 = -(uint64_t)(v766 * v258);
        uint64_t v261 = 2 * v8;
        int v262 = v769;
        uint64_t v263 = -(uint64_t)v21;
        do
        {
          int v264 = v10;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v265 = bswap32(*v262) >> 16;
              }
              else {
                unsigned int v265 = 0xFFFF;
              }
              unsigned int v266 = bswap32(*(unsigned __int16 *)v23);
              int v267 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v268 = HIWORD(v266) - ((v267 * HIWORD(v266) + ((v267 * HIWORD(v266)) >> 16) + 1) >> 16);
              unsigned int v269 = bswap32(*(unsigned __int16 *)v7);
              unsigned int v270 = (v268 | ((v265 - ((v265 * v267 + ((v265 * v267) >> 16) + 1) >> 16)) << 16)) >> 16;
              int v271 = HIWORD(v269) - ((bswap32(*(unsigned __int16 *)v14) >> 16) + (unsigned __int16)v268) + v270;
              unsigned int v272 = v270 + HIWORD(v269);
              if (v271 >= 0xFFFF) {
                int v271 = 0xFFFF;
              }
              if (v272 >= 0xFFFF) {
                unsigned int v272 = 0xFFFF;
              }
              *(_WORD *)uint64_t v14 = bswap32(v272 - v271) >> 16;
              *(_WORD *)unsigned int v7 = bswap32(v272) >> 16;
            }
            v16 += v25;
            uint64_t result = (unint64_t)&v23[2 * v25];
            int v273 = &v262[v20];
            if (result >= v12) {
              uint64_t v274 = v263;
            }
            else {
              uint64_t v274 = 0;
            }
            int v262 = &v273[v274];
            int32x4_t v23 = (char *)(result + 2 * v274);
            v7 += v261;
            v14 += 2 * v25;
            --v264;
          }
          while (v264);
          if (v763)
          {
            signed int v275 = &v768[2 * v767];
            if ((unint64_t)v275 >= v763) {
              uint64_t v276 = v260;
            }
            else {
              uint64_t v276 = 0;
            }
            uint64_t v277 = (uint64_t)&v769[v766 + v276];
            if ((unint64_t)v275 >= v763) {
              uint64_t v278 = v259;
            }
            else {
              uint64_t v278 = 0;
            }
            uint64_t result = v12 + 2 * v278;
            int32x4_t v23 = &v275[2 * v278];
            unint64_t v12 = result + 2 * v767;
            unsigned int v768 = v23;
            int v769 = (unsigned __int16 *)v277;
            int v262 = (unsigned __int16 *)v277;
          }
          else
          {
            v23 += 2 * v767;
            v262 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        uint64_t v679 = -(uint64_t)v21;
        uint64_t v680 = v22;
        uint64_t v681 = -(uint64_t)(v767 * v22);
        uint64_t v682 = -(uint64_t)(v766 * v680);
        uint64_t v683 = v769;
        do
        {
          int v684 = v10;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v685 = bswap32(*v683) >> 16;
              }
              else {
                unsigned int v685 = 0xFFFF;
              }
              unsigned int v686 = bswap32(*(unsigned __int16 *)v23);
              int v687 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v688 = HIWORD(v686) - ((v687 * HIWORD(v686) + ((v687 * HIWORD(v686)) >> 16) + 1) >> 16);
              signed int v689 = (bswap32(~*(unsigned __int16 *)v14) >> 16)
                   - (unsigned __int16)v688
                   + ((v688 | ((v685 - ((v685 * v687 + ((v685 * v687) >> 16) + 1) >> 16)) << 16)) >> 16);
              if (v689 >= 0xFFFF) {
                signed int v689 = 0xFFFF;
              }
              *(_WORD *)uint64_t v14 = bswap32(~v689) >> 16;
            }
            v16 += v257;
            int v690 = &v23[2 * v257];
            int v691 = &v683[v20];
            if ((unint64_t)v690 >= v12) {
              uint64_t result = v679;
            }
            else {
              uint64_t result = 0;
            }
            uint64_t v683 = &v691[result];
            int32x4_t v23 = &v690[2 * result];
            v14 += 2 * v257;
            --v684;
          }
          while (v684);
          if (v763)
          {
            uint64_t result = v767;
            unsigned int v692 = &v768[2 * v767];
            if ((unint64_t)v692 >= v763) {
              uint64_t v693 = v682;
            }
            else {
              uint64_t v693 = 0;
            }
            uint64_t v694 = (uint64_t)&v769[v766 + v693];
            if ((unint64_t)v692 >= v763) {
              uint64_t v695 = v681;
            }
            else {
              uint64_t v695 = 0;
            }
            int32x4_t v23 = &v692[2 * v695];
            v12 += 2 * v695 + 2 * v767;
            unsigned int v768 = v23;
            v769 += v766 + v693;
            uint64_t v683 = (unsigned __int16 *)v694;
          }
          else
          {
            v23 += 2 * v767;
            v683 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 12:
      if (v8)
      {
        uint64_t v279 = v22;
        uint64_t v280 = -(uint64_t)(v767 * v22);
        uint64_t v281 = -(uint64_t)(v766 * v279);
        unsigned int v282 = v769;
        uint64_t v283 = -(uint64_t)v21;
        do
        {
          int v284 = v10;
          do
          {
            if (*v16)
            {
              if (v20) {
                unsigned int v285 = bswap32(*v282) >> 16;
              }
              else {
                unsigned int v285 = 0xFFFF;
              }
              unsigned int v286 = bswap32(*(unsigned __int16 *)v23);
              int v287 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
              unsigned int v288 = HIWORD(v286) - ((v287 * HIWORD(v286) + ((v287 * HIWORD(v286)) >> 16) + 1) >> 16);
              unsigned int v289 = v288 | ((v285 - ((v285 * v287 + ((v285 * v287) >> 16) + 1) >> 16)) << 16);
              unsigned int v290 = (bswap32(*(unsigned __int16 *)v14) >> 16) + (unsigned __int16)v288;
              unsigned int v291 = HIWORD(v289) + (bswap32(*(unsigned __int16 *)v7) >> 16);
              if (v290 >= 0xFFFF) {
                unsigned int v290 = 0xFFFF;
              }
              if (v291 >= 0xFFFF) {
                unsigned int v291 = 0xFFFF;
              }
              *(_WORD *)uint64_t v14 = bswap32(v290) >> 16;
              *(_WORD *)unsigned int v7 = bswap32(v291) >> 16;
            }
            v16 += v25;
            uint64_t result = (unint64_t)&v23[2 * v25];
            unsigned int v292 = &v282[v20];
            if (result >= v12) {
              uint64_t v293 = v283;
            }
            else {
              uint64_t v293 = 0;
            }
            unsigned int v282 = &v292[v293];
            int32x4_t v23 = (char *)(result + 2 * v293);
            v7 += 2 * v8;
            v14 += 2 * v25;
            --v284;
          }
          while (v284);
          if (v763)
          {
            unsigned int v294 = &v768[2 * v767];
            if ((unint64_t)v294 >= v763) {
              uint64_t v295 = v281;
            }
            else {
              uint64_t v295 = 0;
            }
            uint64_t v296 = (uint64_t)&v769[v766 + v295];
            if ((unint64_t)v294 >= v763) {
              uint64_t v297 = v280;
            }
            else {
              uint64_t v297 = 0;
            }
            uint64_t result = v12 + 2 * v297;
            int32x4_t v23 = &v294[2 * v297];
            unint64_t v12 = result + 2 * v767;
            unsigned int v768 = v23;
            int v769 = (unsigned __int16 *)v296;
            unsigned int v282 = (unsigned __int16 *)v296;
          }
          else
          {
            v23 += 2 * v767;
            v282 += v766;
          }
          v16 += v765;
          v14 += 2 * v764;
          v7 += 2 * v762;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v696 = v10;
          int64_t v697 = v16;
          do
          {
            if (*v697)
            {
              int v698 = bswap32(*(unsigned __int16 *)v14);
              *(_WORD *)uint64_t v14 = bswap32((v698 >> 15) & 0xFFFE | ((v698 >> 16) >> 15)) >> 16;
            }
            v697 += v25;
            v14 += 2 * v25;
            --v696;
          }
          while (v696);
          v16 += v25 + v25 * (unint64_t)(v10 - 1) + v765;
          v14 += 2 * v764;
          --v9;
        }
        while (v9);
      }
      return result;
    case 13:
      uint64_t v298 = v25;
      uint64_t v299 = v22;
      uint64_t v300 = -(uint64_t)v21;
      uint64_t v301 = -(uint64_t)(v767 * v22);
      uint64_t v302 = -(uint64_t)(v766 * v299);
      uint64_t v303 = 2 * v8;
      uint64_t v304 = 2 * v25;
      int v305 = v769;
      while (1)
      {
        int v306 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v307 = v20 ? bswap32(*v305) >> 16 : 0xFFFF;
            unsigned int v308 = bswap32(*(unsigned __int16 *)v23);
            int v309 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v310 = HIWORD(v308) - ((v309 * HIWORD(v308) + ((v309 * HIWORD(v308)) >> 16) + 1) >> 16);
            unsigned int v311 = v310 | ((v307 - ((v307 * v309 + ((v307 * v309) >> 16) + 1) >> 16)) << 16);
            if (v311 >= 0x10000)
            {
              unint64_t v312 = HIWORD(v311);
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v313 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_342;
                }
LABEL_350:
                *(_WORD *)uint64_t v14 = bswap32(v311) >> 16;
                unsigned int v319 = v7;
              }
              else
              {
                unsigned int v313 = 0xFFFF;
LABEL_342:
                unint64_t v314 = (v313 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v310
                     + ((v312 ^ 0xFFFF) + (unsigned __int16)v310)
                     * (unint64_t)(bswap32(*(unsigned __int16 *)v14) >> 16);
                if (v314 <= 0xFFFE8000) {
                  unint64_t v315 = v314 + 0x8000;
                }
                else {
                  unint64_t v315 = 4294868992;
                }
                unint64_t v316 = v315 + (v315 >> 16);
                int v8 = v782;
                if (v782)
                {
                  unint64_t v317 = v316 >> 16;
                  int64_t v318 = 0xFFFF * (v313 + v312) - v313 * (unint64_t)v312;
                  if (v318 <= 4294868992) {
                    unint64_t v312 = v318 + 0x8000;
                  }
                  else {
                    unint64_t v312 = 4294868992;
                  }
                  unsigned int v311 = ((v312 >> 16) + v312) & 0xFFFF0000 | v317;
                  LODWORD(v312) = HIWORD(v311);
                  goto LABEL_350;
                }
                unint64_t v312 = v316 >> 16;
                unsigned int v319 = v14;
              }
              *(_WORD *)unsigned int v319 = bswap32(v312) >> 16;
            }
          }
          v16 += v298;
          v14 += v304;
          uint64_t result = (unint64_t)&v23[2 * v298];
          unsigned int v320 = &v305[v20];
          if (result >= v12) {
            uint64_t v321 = v300;
          }
          else {
            uint64_t v321 = 0;
          }
          int v305 = &v320[v321];
          int32x4_t v23 = (char *)(result + 2 * v321);
          v7 += v303;
          --v306;
        }
        while (v306);
        if (v763)
        {
          unsigned int v322 = &v768[2 * v767];
          if ((unint64_t)v322 >= v763) {
            uint64_t v323 = v302;
          }
          else {
            uint64_t v323 = 0;
          }
          uint64_t v324 = (uint64_t)&v769[v766 + v323];
          if ((unint64_t)v322 >= v763) {
            uint64_t v325 = v301;
          }
          else {
            uint64_t v325 = 0;
          }
          uint64_t result = v12 + 2 * v325;
          int32x4_t v23 = &v322[2 * v325];
          unint64_t v12 = result + 2 * v767;
          unsigned int v768 = v23;
          int v769 = (unsigned __int16 *)v324;
          int v305 = (unsigned __int16 *)v324;
        }
        else
        {
          v23 += 2 * v767;
          v305 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9) {
          return result;
        }
      }
    case 14:
      uint64_t v326 = v25;
      uint64_t v327 = v22;
      uint64_t v328 = -(uint64_t)v21;
      uint64_t v329 = -(uint64_t)(v767 * v22);
      uint64_t v330 = 2 * v25;
      int v331 = v769;
      while (1)
      {
        int v332 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v333 = v20 ? bswap32(*v331) >> 16 : 0xFFFF;
            unsigned int v334 = bswap32(*(unsigned __int16 *)v23);
            int v335 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v336 = HIWORD(v334) - ((v335 * HIWORD(v334) + ((v335 * HIWORD(v334)) >> 16) + 1) >> 16);
            unsigned int v337 = v336 | ((v333 - ((v333 * v335 + ((v333 * v335) >> 16) + 1) >> 16)) << 16);
            if (v337 >= 0x10000)
            {
              unsigned int v338 = HIWORD(v337);
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v339 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_379;
                }
LABEL_387:
                *(_WORD *)uint64_t v14 = bswap32(v337) >> 16;
                unsigned int v346 = v7;
              }
              else
              {
                unsigned int v339 = 0xFFFF;
LABEL_379:
                uint64_t v340 = bswap32(*(unsigned __int16 *)v14) >> 16;
                unint64_t v341 = (v340 ^ 0xFFFF) * (unint64_t)(unsigned __int16)v336 - v340 + (v340 << 16);
                if (v341 <= 0xFFFE8000) {
                  unint64_t v342 = v341 + 0x8000;
                }
                else {
                  unint64_t v342 = 4294868992;
                }
                unint64_t v343 = (v342 + (v342 >> 16)) >> 16;
                if (v8)
                {
                  int64_t v344 = 0xFFFF * (v339 + (unint64_t)v338) - v339 * (unint64_t)v338;
                  if (v344 <= 4294868992) {
                    unint64_t v345 = v344 + 0x8000;
                  }
                  else {
                    unint64_t v345 = 4294868992;
                  }
                  unsigned int v337 = ((v345 >> 16) + v345) & 0xFFFF0000 | v343;
                  unsigned int v338 = HIWORD(v337);
                  goto LABEL_387;
                }
                unsigned int v338 = v343;
                unsigned int v346 = v14;
              }
              *(_WORD *)unsigned int v346 = bswap32(v338) >> 16;
            }
          }
          v16 += v326;
          v14 += v330;
          uint64_t result = (unint64_t)&v23[2 * v326];
          unsigned int v347 = &v331[v20];
          if (result >= v12) {
            uint64_t v348 = v328;
          }
          else {
            uint64_t v348 = 0;
          }
          int v331 = &v347[v348];
          int32x4_t v23 = (char *)(result + 2 * v348);
          v7 += 2 * v8;
          --v332;
        }
        while (v332);
        if (v763)
        {
          unsigned int v349 = &v768[2 * v767];
          if ((unint64_t)v349 >= v763) {
            uint64_t v350 = -(uint64_t)(v766 * v327);
          }
          else {
            uint64_t v350 = 0;
          }
          uint64_t v351 = (uint64_t)&v769[v766 + v350];
          if ((unint64_t)v349 >= v763) {
            uint64_t v352 = v329;
          }
          else {
            uint64_t v352 = 0;
          }
          uint64_t result = v12 + 2 * v352;
          int32x4_t v23 = &v349[2 * v352];
          unint64_t v12 = result + 2 * v767;
          unsigned int v768 = v23;
          int v769 = (unsigned __int16 *)v351;
          int v331 = (unsigned __int16 *)v351;
        }
        else
        {
          v23 += 2 * v767;
          v331 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9) {
          return result;
        }
      }
    case 15:
      uint64_t v353 = v25;
      uint64_t v354 = v20;
      uint64_t v725 = -(uint64_t)(v767 * v22);
      uint64_t v737 = v20;
      uint64_t v713 = -(uint64_t)(v766 * v22);
      uint64_t v355 = 2 * v8;
      uint64_t v356 = 2 * v25;
      int v357 = v769;
      uint64_t v358 = -(uint64_t)v21;
      while (1)
      {
        int v750 = v9;
        unint64_t v770 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v359 = v20 ? bswap32(*v357) >> 16 : 0xFFFF;
            unsigned int v360 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v361 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v362 = v361 * v360 + ((v361 * v360) >> 16) + 1;
            uint64_t result = (v360 - HIWORD(v362)) | ((v359 - ((v359 * v361 + ((v359 * v361) >> 16) + 1) >> 16)) << 16);
            unsigned int v363 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v364 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_416;
                }
LABEL_418:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                unsigned int v365 = v7;
              }
              else
              {
                unsigned int v364 = 0xFFFF;
LABEL_416:
                uint64_t result = PDAoverlayPDA_8925(bswap32(*(unsigned __int16 *)v14) >> 16, v364, (unsigned __int16)(v360 - HIWORD(v362)), v363);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v363 = WORD1(result);
                  unint64_t v12 = v770;
                  int v20 = v783;
                  uint64_t v354 = v737;
                  goto LABEL_418;
                }
                unsigned int v363 = result;
                unsigned int v365 = v14;
                unint64_t v12 = v770;
                int v20 = v783;
                uint64_t v354 = v737;
              }
              *(_WORD *)unsigned int v365 = bswap32(v363) >> 16;
            }
          }
          v16 += v353;
          v14 += v356;
          unsigned int v366 = &v23[2 * v353];
          if ((unint64_t)v366 >= v12) {
            uint64_t v367 = v358;
          }
          else {
            uint64_t v367 = 0;
          }
          v357 += v354 + v367;
          int32x4_t v23 = &v366[2 * v367];
          v7 += v355;
          --v10;
        }
        while (v10);
        if (v763)
        {
          unsigned int v368 = &v768[2 * v767];
          uint64_t v369 = v713;
          if ((unint64_t)v368 < v763) {
            uint64_t v369 = 0;
          }
          int v357 = &v769[v766 + v369];
          uint64_t v370 = v725;
          if ((unint64_t)v368 < v763) {
            uint64_t v370 = 0;
          }
          int32x4_t v23 = &v368[2 * v370];
          v12 += 2 * v370 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v369;
        }
        else
        {
          v23 += 2 * v767;
          v357 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v750 - 1;
        if (v750 == 1) {
          return result;
        }
      }
    case 16:
      uint64_t v371 = v25;
      uint64_t v372 = v20;
      uint64_t v726 = -(uint64_t)(v767 * v22);
      uint64_t v738 = v20;
      uint64_t v714 = -(uint64_t)(v766 * v22);
      uint64_t v373 = 2 * v8;
      uint64_t v374 = 2 * v25;
      unint64_t v375 = v769;
      uint64_t v376 = -(uint64_t)v21;
      while (1)
      {
        int v751 = v9;
        unint64_t v771 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v377 = v20 ? bswap32(*v375) >> 16 : 0xFFFF;
            unsigned int v378 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v379 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v380 = v379 * v378 + ((v379 * v378) >> 16) + 1;
            uint64_t result = (v378 - HIWORD(v380)) | ((v377 - ((v377 * v379 + ((v377 * v379) >> 16) + 1) >> 16)) << 16);
            unsigned int v381 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v382 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_445;
                }
LABEL_447:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                unsigned int v383 = v7;
              }
              else
              {
                unsigned int v382 = 0xFFFF;
LABEL_445:
                uint64_t result = PDAdarkenPDA_8927(bswap32(*(unsigned __int16 *)v14) >> 16, v382, (unsigned __int16)(v378 - HIWORD(v380)), v381);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v381 = WORD1(result);
                  unint64_t v12 = v771;
                  int v20 = v783;
                  uint64_t v372 = v738;
                  goto LABEL_447;
                }
                unsigned int v381 = result;
                unsigned int v383 = v14;
                unint64_t v12 = v771;
                int v20 = v783;
                uint64_t v372 = v738;
              }
              *(_WORD *)unsigned int v383 = bswap32(v381) >> 16;
            }
          }
          v16 += v371;
          v14 += v374;
          BOOL v384 = &v23[2 * v371];
          if ((unint64_t)v384 >= v12) {
            uint64_t v385 = v376;
          }
          else {
            uint64_t v385 = 0;
          }
          v375 += v372 + v385;
          int32x4_t v23 = &v384[2 * v385];
          v7 += v373;
          --v10;
        }
        while (v10);
        if (v763)
        {
          unint64_t v386 = &v768[2 * v767];
          uint64_t v387 = v714;
          if ((unint64_t)v386 < v763) {
            uint64_t v387 = 0;
          }
          unint64_t v375 = &v769[v766 + v387];
          uint64_t v388 = v726;
          if ((unint64_t)v386 < v763) {
            uint64_t v388 = 0;
          }
          int32x4_t v23 = &v386[2 * v388];
          v12 += 2 * v388 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v387;
        }
        else
        {
          v23 += 2 * v767;
          v375 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v751 - 1;
        if (v751 == 1) {
          return result;
        }
      }
    case 17:
      uint64_t v389 = v25;
      uint64_t v390 = v20;
      uint64_t v727 = -(uint64_t)(v767 * v22);
      uint64_t v739 = v20;
      uint64_t v715 = -(uint64_t)(v766 * v22);
      uint64_t v391 = 2 * v8;
      uint64_t v392 = 2 * v25;
      uint64_t v393 = v769;
      uint64_t v394 = -(uint64_t)v21;
      while (1)
      {
        int v752 = v9;
        unint64_t v772 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v395 = v20 ? bswap32(*v393) >> 16 : 0xFFFF;
            unsigned int v396 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v397 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v398 = v397 * v396 + ((v397 * v396) >> 16) + 1;
            uint64_t result = (v396 - HIWORD(v398)) | ((v395 - ((v395 * v397 + ((v395 * v397) >> 16) + 1) >> 16)) << 16);
            unsigned int v399 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v400 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_474;
                }
LABEL_476:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v401 = v7;
              }
              else
              {
                unsigned int v400 = 0xFFFF;
LABEL_474:
                uint64_t result = PDAlightenPDA_8926(bswap32(*(unsigned __int16 *)v14) >> 16, v400, (unsigned __int16)(v396 - HIWORD(v398)), v399);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v399 = WORD1(result);
                  unint64_t v12 = v772;
                  int v20 = v783;
                  uint64_t v390 = v739;
                  goto LABEL_476;
                }
                unsigned int v399 = result;
                uint64_t v401 = v14;
                unint64_t v12 = v772;
                int v20 = v783;
                uint64_t v390 = v739;
              }
              *(_WORD *)uint64_t v401 = bswap32(v399) >> 16;
            }
          }
          v16 += v389;
          v14 += v392;
          int v402 = &v23[2 * v389];
          if ((unint64_t)v402 >= v12) {
            uint64_t v403 = v394;
          }
          else {
            uint64_t v403 = 0;
          }
          v393 += v390 + v403;
          int32x4_t v23 = &v402[2 * v403];
          v7 += v391;
          --v10;
        }
        while (v10);
        if (v763)
        {
          uint64_t v404 = &v768[2 * v767];
          uint64_t v405 = v715;
          if ((unint64_t)v404 < v763) {
            uint64_t v405 = 0;
          }
          uint64_t v393 = &v769[v766 + v405];
          uint64_t v406 = v727;
          if ((unint64_t)v404 < v763) {
            uint64_t v406 = 0;
          }
          int32x4_t v23 = &v404[2 * v406];
          v12 += 2 * v406 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v405;
        }
        else
        {
          v23 += 2 * v767;
          v393 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v752 - 1;
        if (v752 == 1) {
          return result;
        }
      }
    case 18:
      uint64_t v407 = v25;
      uint64_t v408 = v20;
      uint64_t v728 = -(uint64_t)(v767 * v22);
      uint64_t v740 = v20;
      uint64_t v716 = -(uint64_t)(v766 * v22);
      uint64_t v409 = 2 * v8;
      uint64_t v410 = 2 * v25;
      unint64_t v411 = v769;
      uint64_t v412 = -(uint64_t)v21;
      while (1)
      {
        int v753 = v9;
        unint64_t v773 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v413 = v20 ? bswap32(*v411) >> 16 : 0xFFFF;
            unsigned int v414 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v415 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v416 = v415 * v414 + ((v415 * v414) >> 16) + 1;
            uint64_t result = (v414 - HIWORD(v416)) | ((v413 - ((v413 * v415 + ((v413 * v415) >> 16) + 1) >> 16)) << 16);
            unsigned int v417 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v418 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_503;
                }
LABEL_505:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v419 = v7;
              }
              else
              {
                unsigned int v418 = 0xFFFF;
LABEL_503:
                uint64_t result = PDAcolordodgePDA_8928(bswap32(*(unsigned __int16 *)v14) >> 16, v418, (unsigned __int16)(v414 - HIWORD(v416)), v417);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v417 = WORD1(result);
                  unint64_t v12 = v773;
                  int v20 = v783;
                  uint64_t v408 = v740;
                  goto LABEL_505;
                }
                unsigned int v417 = result;
                uint64_t v419 = v14;
                unint64_t v12 = v773;
                int v20 = v783;
                uint64_t v408 = v740;
              }
              *(_WORD *)uint64_t v419 = bswap32(v417) >> 16;
            }
          }
          v16 += v407;
          v14 += v410;
          unint64_t v420 = &v23[2 * v407];
          if ((unint64_t)v420 >= v12) {
            uint64_t v421 = v412;
          }
          else {
            uint64_t v421 = 0;
          }
          v411 += v408 + v421;
          int32x4_t v23 = &v420[2 * v421];
          v7 += v409;
          --v10;
        }
        while (v10);
        if (v763)
        {
          uint64_t v422 = &v768[2 * v767];
          uint64_t v423 = v716;
          if ((unint64_t)v422 < v763) {
            uint64_t v423 = 0;
          }
          unint64_t v411 = &v769[v766 + v423];
          uint64_t v424 = v728;
          if ((unint64_t)v422 < v763) {
            uint64_t v424 = 0;
          }
          int32x4_t v23 = &v422[2 * v424];
          v12 += 2 * v424 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v423;
        }
        else
        {
          v23 += 2 * v767;
          v411 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v753 - 1;
        if (v753 == 1) {
          return result;
        }
      }
    case 19:
      uint64_t v425 = v25;
      uint64_t v426 = v20;
      uint64_t v729 = -(uint64_t)(v767 * v22);
      uint64_t v741 = v20;
      uint64_t v717 = -(uint64_t)(v766 * v22);
      uint64_t v427 = 2 * v8;
      uint64_t v428 = 2 * v25;
      unsigned int v429 = v769;
      uint64_t v430 = -(uint64_t)v21;
      while (1)
      {
        int v754 = v9;
        unint64_t v774 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v431 = v20 ? bswap32(*v429) >> 16 : 0xFFFF;
            unsigned int v432 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v433 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v434 = v433 * v432 + ((v433 * v432) >> 16) + 1;
            uint64_t result = (v432 - HIWORD(v434)) | ((v431 - ((v431 * v433 + ((v431 * v433) >> 16) + 1) >> 16)) << 16);
            unsigned int v435 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v436 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_532;
                }
LABEL_534:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v437 = v7;
              }
              else
              {
                unsigned int v436 = 0xFFFF;
LABEL_532:
                uint64_t result = PDAcolorburnPDA_8929(bswap32(*(unsigned __int16 *)v14) >> 16, v436, (unsigned __int16)(v432 - HIWORD(v434)), v435);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v435 = WORD1(result);
                  unint64_t v12 = v774;
                  int v20 = v783;
                  uint64_t v426 = v741;
                  goto LABEL_534;
                }
                unsigned int v435 = result;
                uint64_t v437 = v14;
                unint64_t v12 = v774;
                int v20 = v783;
                uint64_t v426 = v741;
              }
              *(_WORD *)uint64_t v437 = bswap32(v435) >> 16;
            }
          }
          v16 += v425;
          v14 += v428;
          int v438 = &v23[2 * v425];
          if ((unint64_t)v438 >= v12) {
            uint64_t v439 = v430;
          }
          else {
            uint64_t v439 = 0;
          }
          v429 += v426 + v439;
          int32x4_t v23 = &v438[2 * v439];
          v7 += v427;
          --v10;
        }
        while (v10);
        if (v763)
        {
          int v440 = &v768[2 * v767];
          uint64_t v441 = v717;
          if ((unint64_t)v440 < v763) {
            uint64_t v441 = 0;
          }
          unsigned int v429 = &v769[v766 + v441];
          uint64_t v442 = v729;
          if ((unint64_t)v440 < v763) {
            uint64_t v442 = 0;
          }
          int32x4_t v23 = &v440[2 * v442];
          v12 += 2 * v442 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v441;
        }
        else
        {
          v23 += 2 * v767;
          v429 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v754 - 1;
        if (v754 == 1) {
          return result;
        }
      }
    case 20:
      uint64_t v443 = v25;
      uint64_t v444 = v20;
      uint64_t v730 = -(uint64_t)(v767 * v22);
      uint64_t v742 = v20;
      uint64_t v718 = -(uint64_t)(v766 * v22);
      uint64_t v445 = 2 * v8;
      uint64_t v446 = 2 * v25;
      uint64_t v447 = v769;
      uint64_t v448 = -(uint64_t)v21;
      while (1)
      {
        int v755 = v9;
        unint64_t v775 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v449 = v20 ? bswap32(*v447) >> 16 : 0xFFFF;
            unsigned int v450 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v451 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v452 = v451 * v450 + ((v451 * v450) >> 16) + 1;
            uint64_t result = (v450 - HIWORD(v452)) | ((v449 - ((v449 * v451 + ((v449 * v451) >> 16) + 1) >> 16)) << 16);
            unsigned int v453 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v454 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_561;
                }
LABEL_563:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                int v455 = v7;
              }
              else
              {
                unsigned int v454 = 0xFFFF;
LABEL_561:
                uint64_t result = PDAsoftlightPDA_8931(bswap32(*(unsigned __int16 *)v14) >> 16, v454, (unsigned __int16)(v450 - HIWORD(v452)), v453);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v453 = WORD1(result);
                  unint64_t v12 = v775;
                  int v20 = v783;
                  uint64_t v444 = v742;
                  goto LABEL_563;
                }
                unsigned int v453 = result;
                int v455 = v14;
                unint64_t v12 = v775;
                int v20 = v783;
                uint64_t v444 = v742;
              }
              *(_WORD *)int v455 = bswap32(v453) >> 16;
            }
          }
          v16 += v443;
          v14 += v446;
          unint64_t v456 = &v23[2 * v443];
          if ((unint64_t)v456 >= v12) {
            uint64_t v457 = v448;
          }
          else {
            uint64_t v457 = 0;
          }
          v447 += v444 + v457;
          int32x4_t v23 = &v456[2 * v457];
          v7 += v445;
          --v10;
        }
        while (v10);
        if (v763)
        {
          unsigned int v458 = &v768[2 * v767];
          uint64_t v459 = v718;
          if ((unint64_t)v458 < v763) {
            uint64_t v459 = 0;
          }
          uint64_t v447 = &v769[v766 + v459];
          uint64_t v460 = v730;
          if ((unint64_t)v458 < v763) {
            uint64_t v460 = 0;
          }
          int32x4_t v23 = &v458[2 * v460];
          v12 += 2 * v460 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v459;
        }
        else
        {
          v23 += 2 * v767;
          v447 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v755 - 1;
        if (v755 == 1) {
          return result;
        }
      }
    case 21:
      uint64_t v461 = v25;
      uint64_t v462 = v20;
      uint64_t v731 = -(uint64_t)(v767 * v22);
      uint64_t v743 = v20;
      uint64_t v719 = -(uint64_t)(v766 * v22);
      uint64_t v463 = 2 * v8;
      uint64_t v464 = 2 * v25;
      unint64_t v465 = v769;
      uint64_t v466 = -(uint64_t)v21;
      while (1)
      {
        int v756 = v9;
        unint64_t v776 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v467 = v20 ? bswap32(*v465) >> 16 : 0xFFFF;
            unsigned int v468 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v469 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v470 = v469 * v468 + ((v469 * v468) >> 16) + 1;
            uint64_t result = (v468 - HIWORD(v470)) | ((v467 - ((v467 * v469 + ((v467 * v469) >> 16) + 1) >> 16)) << 16);
            unsigned int v471 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v472 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_590;
                }
LABEL_592:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v473 = v7;
              }
              else
              {
                unsigned int v472 = 0xFFFF;
LABEL_590:
                uint64_t result = PDAhardlightPDA_8930(bswap32(*(unsigned __int16 *)v14) >> 16, v472, (unsigned __int16)(v468 - HIWORD(v470)), v471);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v471 = WORD1(result);
                  unint64_t v12 = v776;
                  int v20 = v783;
                  uint64_t v462 = v743;
                  goto LABEL_592;
                }
                unsigned int v471 = result;
                uint64_t v473 = v14;
                unint64_t v12 = v776;
                int v20 = v783;
                uint64_t v462 = v743;
              }
              *(_WORD *)uint64_t v473 = bswap32(v471) >> 16;
            }
          }
          v16 += v461;
          v14 += v464;
          uint64_t v474 = &v23[2 * v461];
          if ((unint64_t)v474 >= v12) {
            uint64_t v475 = v466;
          }
          else {
            uint64_t v475 = 0;
          }
          v465 += v462 + v475;
          int32x4_t v23 = &v474[2 * v475];
          v7 += v463;
          --v10;
        }
        while (v10);
        if (v763)
        {
          BOOL v476 = &v768[2 * v767];
          uint64_t v477 = v719;
          if ((unint64_t)v476 < v763) {
            uint64_t v477 = 0;
          }
          unint64_t v465 = &v769[v766 + v477];
          uint64_t v478 = v731;
          if ((unint64_t)v476 < v763) {
            uint64_t v478 = 0;
          }
          int32x4_t v23 = &v476[2 * v478];
          v12 += 2 * v478 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v477;
        }
        else
        {
          v23 += 2 * v767;
          v465 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v756 - 1;
        if (v756 == 1) {
          return result;
        }
      }
    case 22:
      uint64_t v479 = v25;
      uint64_t v480 = v20;
      uint64_t v732 = -(uint64_t)(v767 * v22);
      uint64_t v744 = v20;
      uint64_t v720 = -(uint64_t)(v766 * v22);
      uint64_t v481 = 2 * v8;
      uint64_t v482 = 2 * v25;
      unsigned int v483 = v769;
      uint64_t v484 = -(uint64_t)v21;
      while (1)
      {
        int v757 = v9;
        unint64_t v777 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v485 = v20 ? bswap32(*v483) >> 16 : 0xFFFF;
            unsigned int v486 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v487 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v488 = v487 * v486 + ((v487 * v486) >> 16) + 1;
            uint64_t result = (v486 - HIWORD(v488)) | ((v485 - ((v485 * v487 + ((v485 * v487) >> 16) + 1) >> 16)) << 16);
            unsigned int v489 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v490 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_619;
                }
LABEL_621:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v491 = v7;
              }
              else
              {
                unsigned int v490 = 0xFFFF;
LABEL_619:
                uint64_t result = PDAdifferencePDA_8932(bswap32(*(unsigned __int16 *)v14) >> 16, v490, (unsigned __int16)(v486 - HIWORD(v488)), v489);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v489 = WORD1(result);
                  unint64_t v12 = v777;
                  int v20 = v783;
                  uint64_t v480 = v744;
                  goto LABEL_621;
                }
                unsigned int v489 = result;
                uint64_t v491 = v14;
                unint64_t v12 = v777;
                int v20 = v783;
                uint64_t v480 = v744;
              }
              *(_WORD *)uint64_t v491 = bswap32(v489) >> 16;
            }
          }
          v16 += v479;
          v14 += v482;
          int v492 = &v23[2 * v479];
          if ((unint64_t)v492 >= v12) {
            uint64_t v493 = v484;
          }
          else {
            uint64_t v493 = 0;
          }
          v483 += v480 + v493;
          int32x4_t v23 = &v492[2 * v493];
          v7 += v481;
          --v10;
        }
        while (v10);
        if (v763)
        {
          unsigned int v494 = &v768[2 * v767];
          uint64_t v495 = v720;
          if ((unint64_t)v494 < v763) {
            uint64_t v495 = 0;
          }
          unsigned int v483 = &v769[v766 + v495];
          uint64_t v496 = v732;
          if ((unint64_t)v494 < v763) {
            uint64_t v496 = 0;
          }
          int32x4_t v23 = &v494[2 * v496];
          v12 += 2 * v496 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v495;
        }
        else
        {
          v23 += 2 * v767;
          v483 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v757 - 1;
        if (v757 == 1) {
          return result;
        }
      }
    case 23:
      uint64_t v497 = v25;
      uint64_t v498 = v22;
      uint64_t v499 = -(uint64_t)v21;
      uint64_t v500 = -(uint64_t)(v767 * v22);
      uint64_t v501 = -(uint64_t)(v766 * v498);
      uint64_t v502 = 2 * v8;
      uint64_t v503 = 2 * v25;
      int v504 = v769;
      while (1)
      {
        int v505 = v10;
        do
        {
          if (*v16)
          {
            unsigned int v506 = v20 ? bswap32(*v504) >> 16 : 0xFFFF;
            unsigned int v507 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v508 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v509 = v507 - ((v508 * v507 + ((v508 * v507) >> 16) + 1) >> 16);
            unsigned int v510 = v509 | ((v506 - ((v506 * v508 + ((v506 * v508) >> 16) + 1) >> 16)) << 16);
            LODWORD(v511) = HIWORD(v510);
            if (HIWORD(v510))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v512 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_648;
                }
LABEL_662:
                *(_WORD *)uint64_t v14 = bswap32(v510) >> 16;
                uint64_t v521 = v7;
              }
              else
              {
                unsigned int v512 = 0xFFFF;
LABEL_648:
                unsigned int v513 = bswap32(*(unsigned __int16 *)v14) >> 16;
                if ((unsigned __int16)v509 >= HIWORD(v510)) {
                  uint64_t v514 = v511;
                }
                else {
                  uint64_t v514 = (unsigned __int16)v509;
                }
                if (v513 >= v512) {
                  uint64_t v515 = v512;
                }
                else {
                  uint64_t v515 = v513;
                }
                int64_t v516 = 0xFFFF * (v515 + v514) - 2 * v514 * (unint64_t)v515;
                if (v516 <= 4294868992) {
                  unint64_t v517 = v516 + 0x8000;
                }
                else {
                  unint64_t v517 = 4294868992;
                }
                unint64_t v518 = v517 + (v517 >> 16);
                int v8 = v782;
                if (v782)
                {
                  unint64_t v519 = v518 >> 16;
                  int64_t v520 = 0xFFFF * (v512 + (unint64_t)v511)
                       - v512 * (unint64_t)v511;
                  if (v520 <= 4294868992) {
                    unint64_t v511 = v520 + 0x8000;
                  }
                  else {
                    unint64_t v511 = 4294868992;
                  }
                  unsigned int v510 = ((v511 >> 16) + v511) & 0xFFFF0000 | v519;
                  LODWORD(v511) = HIWORD(v510);
                  goto LABEL_662;
                }
                unint64_t v511 = v518 >> 16;
                uint64_t v521 = v14;
              }
              *(_WORD *)uint64_t v521 = bswap32(v511) >> 16;
            }
          }
          v16 += v497;
          v14 += v503;
          uint64_t result = (unint64_t)&v23[2 * v497];
          BOOL v522 = &v504[v20];
          if (result >= v12) {
            uint64_t v523 = v499;
          }
          else {
            uint64_t v523 = 0;
          }
          int v504 = &v522[v523];
          int32x4_t v23 = (char *)(result + 2 * v523);
          v7 += v502;
          --v505;
        }
        while (v505);
        if (v763)
        {
          unint64_t v524 = &v768[2 * v767];
          if ((unint64_t)v524 >= v763) {
            uint64_t v525 = v501;
          }
          else {
            uint64_t v525 = 0;
          }
          uint64_t v526 = (uint64_t)&v769[v766 + v525];
          if ((unint64_t)v524 >= v763) {
            uint64_t v527 = v500;
          }
          else {
            uint64_t v527 = 0;
          }
          uint64_t result = v12 + 2 * v527;
          int32x4_t v23 = &v524[2 * v527];
          unint64_t v12 = result + 2 * v767;
          unsigned int v768 = v23;
          int v769 = (unsigned __int16 *)v526;
          int v504 = (unsigned __int16 *)v526;
        }
        else
        {
          v23 += 2 * v767;
          v504 += v766;
        }
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        if (!--v9) {
          return result;
        }
      }
    case 24:
      uint64_t v528 = v25;
      uint64_t v529 = v20;
      uint64_t v733 = -(uint64_t)(v767 * v22);
      uint64_t v745 = v20;
      uint64_t v721 = -(uint64_t)(v766 * v22);
      uint64_t v530 = 2 * v8;
      uint64_t v531 = 2 * v25;
      unsigned int v532 = v769;
      uint64_t v533 = -(uint64_t)v21;
      while (1)
      {
        int v758 = v9;
        unint64_t v778 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v534 = v20 ? bswap32(*v532) >> 16 : 0xFFFF;
            unsigned int v535 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v536 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v537 = v536 * v535 + ((v536 * v535) >> 16) + 1;
            uint64_t result = (v535 - HIWORD(v537)) | ((v534 - ((v534 * v536 + ((v534 * v536) >> 16) + 1) >> 16)) << 16);
            unsigned int v538 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v539 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_691;
                }
LABEL_693:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                uint64_t v540 = v7;
              }
              else
              {
                unsigned int v539 = 0xFFFF;
LABEL_691:
                uint64_t result = PDAhuePDA_8933(bswap32(*(unsigned __int16 *)v14) >> 16, v539, (unsigned __int16)(v535 - HIWORD(v537)), v538);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v538 = WORD1(result);
                  unint64_t v12 = v778;
                  int v20 = v783;
                  uint64_t v529 = v745;
                  goto LABEL_693;
                }
                unsigned int v538 = result;
                uint64_t v540 = v14;
                unint64_t v12 = v778;
                int v20 = v783;
                uint64_t v529 = v745;
              }
              *(_WORD *)uint64_t v540 = bswap32(v538) >> 16;
            }
          }
          v16 += v528;
          v14 += v531;
          uint64_t v541 = &v23[2 * v528];
          if ((unint64_t)v541 >= v12) {
            uint64_t v542 = v533;
          }
          else {
            uint64_t v542 = 0;
          }
          v532 += v529 + v542;
          int32x4_t v23 = &v541[2 * v542];
          v7 += v530;
          --v10;
        }
        while (v10);
        if (v763)
        {
          int v543 = &v768[2 * v767];
          uint64_t v544 = v721;
          if ((unint64_t)v543 < v763) {
            uint64_t v544 = 0;
          }
          unsigned int v532 = &v769[v766 + v544];
          uint64_t v545 = v733;
          if ((unint64_t)v543 < v763) {
            uint64_t v545 = 0;
          }
          int32x4_t v23 = &v543[2 * v545];
          v12 += 2 * v545 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v544;
        }
        else
        {
          v23 += 2 * v767;
          v532 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v758 - 1;
        if (v758 == 1) {
          return result;
        }
      }
    case 25:
      uint64_t v546 = v25;
      uint64_t v547 = v20;
      uint64_t v734 = -(uint64_t)(v767 * v22);
      uint64_t v746 = v20;
      uint64_t v722 = -(uint64_t)(v766 * v22);
      uint64_t v548 = 2 * v8;
      uint64_t v549 = 2 * v25;
      uint64_t v550 = v769;
      uint64_t v551 = -(uint64_t)v21;
      while (1)
      {
        int v759 = v9;
        unint64_t v779 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v552 = v20 ? bswap32(*v550) >> 16 : 0xFFFF;
            unsigned int v553 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v554 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v555 = v554 * v553 + ((v554 * v553) >> 16) + 1;
            uint64_t result = (v553 - HIWORD(v555)) | ((v552 - ((v552 * v554 + ((v552 * v554) >> 16) + 1) >> 16)) << 16);
            unsigned int v556 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v557 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_720;
                }
LABEL_722:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                BOOL v558 = v7;
              }
              else
              {
                unsigned int v557 = 0xFFFF;
LABEL_720:
                uint64_t result = PDAhuePDA_8933(bswap32(*(unsigned __int16 *)v14) >> 16, v557, (unsigned __int16)(v553 - HIWORD(v555)), v556);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v556 = WORD1(result);
                  unint64_t v12 = v779;
                  int v20 = v783;
                  uint64_t v547 = v746;
                  goto LABEL_722;
                }
                unsigned int v556 = result;
                BOOL v558 = v14;
                unint64_t v12 = v779;
                int v20 = v783;
                uint64_t v547 = v746;
              }
              *(_WORD *)BOOL v558 = bswap32(v556) >> 16;
            }
          }
          v16 += v546;
          v14 += v549;
          uint64_t v559 = &v23[2 * v546];
          if ((unint64_t)v559 >= v12) {
            uint64_t v560 = v551;
          }
          else {
            uint64_t v560 = 0;
          }
          v550 += v547 + v560;
          int32x4_t v23 = &v559[2 * v560];
          v7 += v548;
          --v10;
        }
        while (v10);
        if (v763)
        {
          uint64_t v561 = &v768[2 * v767];
          uint64_t v562 = v722;
          if ((unint64_t)v561 < v763) {
            uint64_t v562 = 0;
          }
          uint64_t v550 = &v769[v766 + v562];
          uint64_t v563 = v734;
          if ((unint64_t)v561 < v763) {
            uint64_t v563 = 0;
          }
          int32x4_t v23 = &v561[2 * v563];
          v12 += 2 * v563 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v562;
        }
        else
        {
          v23 += 2 * v767;
          v550 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v759 - 1;
        if (v759 == 1) {
          return result;
        }
      }
    case 26:
      uint64_t v564 = v25;
      uint64_t v565 = v20;
      uint64_t v735 = -(uint64_t)(v767 * v22);
      uint64_t v747 = v20;
      uint64_t v723 = -(uint64_t)(v766 * v22);
      uint64_t v566 = 2 * v8;
      uint64_t v567 = 2 * v25;
      uint64_t v568 = v769;
      uint64_t v569 = -(uint64_t)v21;
      while (1)
      {
        int v760 = v9;
        unint64_t v780 = v12;
        do
        {
          if (*v16)
          {
            unsigned int v570 = v20 ? bswap32(*v568) >> 16 : 0xFFFF;
            unsigned int v571 = bswap32(*(unsigned __int16 *)v23) >> 16;
            int v572 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
            unsigned int v573 = v572 * v571 + ((v572 * v571) >> 16) + 1;
            uint64_t result = (v571 - HIWORD(v573)) | ((v570 - ((v570 * v572 + ((v570 * v572) >> 16) + 1) >> 16)) << 16);
            unsigned int v574 = WORD1(result);
            if (WORD1(result))
            {
              if (v8)
              {
                if (*(_WORD *)v7)
                {
                  unsigned int v575 = __rev16(*(unsigned __int16 *)v7);
                  goto LABEL_749;
                }
LABEL_751:
                *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
                int v576 = v7;
              }
              else
              {
                unsigned int v575 = 0xFFFF;
LABEL_749:
                uint64_t result = PDAluminosityPDA_8935((unsigned __int16)(v571 - HIWORD(v573)), v574, bswap32(*(unsigned __int16 *)v14) >> 16, v575);
                int v8 = v782;
                if (v782)
                {
                  unsigned int v574 = WORD1(result);
                  unint64_t v12 = v780;
                  int v20 = v783;
                  uint64_t v565 = v747;
                  goto LABEL_751;
                }
                unsigned int v574 = result;
                int v576 = v14;
                unint64_t v12 = v780;
                int v20 = v783;
                uint64_t v565 = v747;
              }
              *(_WORD *)int v576 = bswap32(v574) >> 16;
            }
          }
          v16 += v564;
          v14 += v567;
          int v577 = &v23[2 * v564];
          if ((unint64_t)v577 >= v12) {
            uint64_t v578 = v569;
          }
          else {
            uint64_t v578 = 0;
          }
          v568 += v565 + v578;
          int32x4_t v23 = &v577[2 * v578];
          v7 += v566;
          --v10;
        }
        while (v10);
        if (v763)
        {
          uint64_t v579 = &v768[2 * v767];
          uint64_t v580 = v723;
          if ((unint64_t)v579 < v763) {
            uint64_t v580 = 0;
          }
          uint64_t v568 = &v769[v766 + v580];
          uint64_t v581 = v735;
          if ((unint64_t)v579 < v763) {
            uint64_t v581 = 0;
          }
          int32x4_t v23 = &v579[2 * v581];
          v12 += 2 * v581 + 2 * v767;
          unsigned int v768 = v23;
          v769 += v766 + v580;
        }
        else
        {
          v23 += 2 * v767;
          v568 += v766;
        }
        int v10 = v749;
        v16 += v765;
        v14 += 2 * v764;
        v7 += 2 * v762;
        int v9 = v760 - 1;
        if (v760 == 1) {
          return result;
        }
      }
    case 27:
      uint64_t v582 = v25;
      uint64_t v583 = v20;
      uint64_t v736 = -(uint64_t)(v767 * v22);
      uint64_t v748 = v20;
      uint64_t v724 = -(uint64_t)(v766 * v22);
      uint64_t v584 = 2 * v8;
      uint64_t v585 = 2 * v25;
      unsigned int v586 = v769;
      uint64_t v587 = -(uint64_t)v21;
      break;
    default:
      return result;
  }
  do
  {
    int v761 = v9;
    unint64_t v781 = v12;
    do
    {
      if (*v16)
      {
        unsigned int v588 = v20 ? bswap32(*v586) >> 16 : 0xFFFF;
        unsigned int v589 = bswap32(*(unsigned __int16 *)v23) >> 16;
        int v590 = (*v16 | (*v16 << 8)) ^ 0xFFFF;
        unsigned int v591 = v590 * v589 + ((v590 * v589) >> 16) + 1;
        uint64_t result = (v589 - HIWORD(v591)) | ((v588 - ((v588 * v590 + ((v588 * v590) >> 16) + 1) >> 16)) << 16);
        unsigned int v592 = WORD1(result);
        if (WORD1(result))
        {
          if (v8)
          {
            if (!*(_WORD *)v7) {
              goto LABEL_780;
            }
            unsigned int v593 = __rev16(*(unsigned __int16 *)v7);
          }
          else
          {
            unsigned int v593 = 0xFFFF;
          }
          uint64_t result = PDAluminosityPDA_8935(bswap32(*(unsigned __int16 *)v14) >> 16, v593, (unsigned __int16)(v589 - HIWORD(v591)), v592);
          int v8 = v782;
          if (!v782)
          {
            unsigned int v592 = result;
            uint64_t v594 = v14;
            unint64_t v12 = v781;
            int v20 = v783;
            uint64_t v583 = v748;
            goto LABEL_782;
          }
          unsigned int v592 = WORD1(result);
          unint64_t v12 = v781;
          int v20 = v783;
          uint64_t v583 = v748;
LABEL_780:
          *(_WORD *)uint64_t v14 = bswap32(result) >> 16;
          uint64_t v594 = v7;
LABEL_782:
          *(_WORD *)uint64_t v594 = bswap32(v592) >> 16;
        }
      }
      v16 += v582;
      v14 += v585;
      uint64_t v595 = &v23[2 * v582];
      if ((unint64_t)v595 >= v12) {
        uint64_t v596 = v587;
      }
      else {
        uint64_t v596 = 0;
      }
      v586 += v583 + v596;
      int32x4_t v23 = &v595[2 * v596];
      v7 += v584;
      --v10;
    }
    while (v10);
    if (v763)
    {
      unint64_t v597 = &v768[2 * v767];
      uint64_t v598 = v724;
      if ((unint64_t)v597 < v763) {
        uint64_t v598 = 0;
      }
      unsigned int v586 = &v769[v766 + v598];
      uint64_t v599 = v736;
      if ((unint64_t)v597 < v763) {
        uint64_t v599 = 0;
      }
      int32x4_t v23 = &v597[2 * v599];
      v12 += 2 * v599 + 2 * v767;
      unsigned int v768 = v23;
      v769 += v766 + v598;
    }
    else
    {
      v23 += 2 * v767;
      v586 += v766;
    }
    int v10 = v749;
    v16 += v765;
    v14 += 2 * v764;
    v7 += 2 * v762;
    int v9 = v761 - 1;
  }
  while (v761 != 1);
  return result;
}

_DWORD *W16_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  unsigned int v8 = PIXELCONSTANT_8939(*(float **)(*(void *)a1 + 64), a4, a5, a6);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_1850CDC60;
    a2[6] = 0;
    *((void *)a2 + 2) = 1;
    a2[12] = bswap32((unsigned __int16)v8 | ((unsigned __int16)v8 << 16));
    *((void *)a2 + 4) = a2 + 12;
    if (HIWORD(v8) == 0xFFFF)
    {
      *((void *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = bswap32(v8 & 0xFFFF0000 | HIWORD(v8));
      *((void *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t CGImageTextureDataGetTypeID()
{
  if (_block_invoke_once_8946 != -1) {
    dispatch_once(&_block_invoke_once_8946, &__block_literal_global_33);
  }
  return CGImageTextureDataGetTypeID_texture_data_type_id;
}

uint64_t CGImageTextureDataGetDataWithBlock(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    if (a5)
    {
      uint64_t v6 = result;
      unsigned int v7 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t))(result + 40);
      if (v7)
      {
        char v8 = a2;
        double v9 = *(double *)(result + 72);
        double v10 = *(double *)(result + 80);
        unint64_t v11 = *(void *)(result + 88);
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        uint64_t v15 = 0;
        uint64_t v12 = v7(*(void *)(result + 24), a2, a3, &v17, &v16, &v15, a4);
        if (v12)
        {
          uint64_t v13 = v12;
          ERROR_CGDataProvider_BufferIsNotReadable();
          if (v15)
          {
            ERROR_CGDataProvider_BufferIsNotBigEnough();
            uint64_t v14 = v15;
          }
          else
          {
            uint64_t v14 = 0;
          }
          (*(void (**)(uint64_t, unint64_t, unint64_t, unint64_t, uint64_t, uint64_t))(a5 + 16))(a5, (unint64_t)v9 >> v8, (unint64_t)v10 >> v8, v11 >> v8, v13 + v16, v14);
        }
        return (*(uint64_t (**)(void))(v6 + 48))(*(void *)(v6 + 24));
      }
    }
  }
  return result;
}

uint64_t CGImageTextureDataCopyProperties()
{
  return 0;
}

void CGImageTextureDataSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    if (!*(void *)(a1 + 64))
    {
      uint64_t v6 = (CFTypeRef *)CGPropertiesCreate();
      uint64_t v7 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 64), (unint64_t *)&v7, (unint64_t)v6, memory_order_relaxed, memory_order_relaxed);
      if (v7) {
        CGPropertiesRelease(v6);
      }
    }
    uint64_t v8 = *(void *)(a1 + 64);
    CGPropertiesSetProperty(v8, a2, a3);
  }
}

const void *CGImageTextureDataGetProperty(uint64_t a1, const void *a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 64)) != 0) {
    return CGPropertiesGetProperty(v2, a2);
  }
  else {
    return 0;
  }
}

uint64_t CGImageIOSurfaceSetCreate(uint64_t a1, CFTypeRef cf, uint64_t a3, _DWORD *a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10)
{
  uint64_t Instance = 0;
  if (a1 && cf)
  {
    CFTypeID v21 = CFGetTypeID(cf);
    if (v21 != CFArrayGetTypeID() || a4 && *a4) {
      return 0;
    }
    uint64_t Instance = 0;
    if (a5 <= 0.0 || a6 <= 0.0) {
      return Instance;
    }
    if (a5 != (double)(unint64_t)a5) {
      return 0;
    }
    if (a6 != (double)(unint64_t)a6) {
      return 0;
    }
    v30.origin.double x = a7;
    v30.origin.y = a8;
    v30.size.double width = a9;
    v30.size.height = a10;
    CGRect v32 = CGRectIntegral(v30);
    v31.origin.double x = a7;
    v31.origin.y = a8;
    v31.size.double width = a9;
    v31.size.height = a10;
    if (!CGRectEqualToRect(v31, v32)) {
      return 0;
    }
    if (_block_invoke_once_8982 != -1) {
      dispatch_once(&_block_invoke_once_8982, &__block_literal_global_5_8983);
    }
    uint64_t Instance = CGTypeCreateInstance(CGImageIOSurfaceSetGetTypeID_iosurfaceset_type_id, 120, v22, v23, v24, v25, v26, v27);
    if (Instance)
    {
      CFRetain((CFTypeRef)a1);
      *(void *)(Instance + 16) = a1;
      *(double *)(Instance + 24) = a5;
      *(double *)(Instance + 32) = a6;
      *(CGFloat *)(Instance + 40) = a7;
      *(CGFloat *)(Instance + 48) = a8;
      *(CGFloat *)(Instance + 56) = a9;
      *(CGFloat *)(Instance + 64) = a10;
      *(_DWORD *)(Instance + 72) = *(_DWORD *)(a1 + 32);
      *(void *)(Instance + 80) = *(void *)(a1 + 48);
      *(void *)(Instance + 88) = CGImageProviderGetColorSpace((void *)a1);
      *(void *)(Instance + 96) = 0;
      *(void *)(Instance + 104) = a3;
      uint64_t v28 = (_OWORD *)(Instance + 112);
      if (a4)
      {
        *uint64_t v28 = *(_OWORD *)a4;
      }
      else
      {
        *(void *)uint64_t v28 = 0;
        *(void *)(Instance + 120) = 0;
      }
      *(void *)(Instance + 128) = CFArrayCreateCopy(0, (CFArrayRef)cf);
    }
  }
  return Instance;
}

uint64_t __CGImageIOSurfaceSetGetTypeID_block_invoke_2()
{
  uint64_t result = __CGTypeRegisterInternal(CGImageIOSurfaceSetGetTypeID_class);
  CGImageIOSurfaceSetGetTypeID_iosurfaceset_type_id = result;
  return result;
}

void image_iosurfaceset_finalize(uint64_t a1)
{
  uint64_t v2 = *(void (**)(void))(a1 + 120);
  if (v2) {
    v2(*(void *)(a1 + 104));
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
    CFRelease(v3);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 88));
  uint64_t v4 = *(CFTypeRef **)(a1 + 96);

  CGPropertiesRelease(v4);
}

uint64_t CGImageIOSurfaceSetGetTypeID()
{
  if (_block_invoke_once_8982 != -1) {
    dispatch_once(&_block_invoke_once_8982, &__block_literal_global_5_8983);
  }
  return CGImageIOSurfaceSetGetTypeID_iosurfaceset_type_id;
}

CFTypeRef CGImageIOSurfaceSetRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void CGImageIOSurfaceSetRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGImageIOSurfaceSetGetComponentType(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 72);
  }
  return result;
}

uint64_t CGImageIOSurfaceSetGetColorSpace(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t CGImageIOSurfaceSetGetPixelSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

CGFloat CGImageIOSurfaceSetGetSize(uint64_t a1)
{
  uint64_t v1 = (const CGSize *)(a1 + 24);
  if (!a1) {
    uint64_t v1 = &CGSizeZero;
  }
  return v1->width;
}

CGFloat CGImageIOSurfaceSetGetRect(uint64_t a1)
{
  uint64_t v1 = &CGRectZero;
  if (a1) {
    uint64_t v1 = (const CGRect *)(a1 + 40);
  }
  return v1->origin.x;
}

CFIndex CGImageIOSurfaceSetGetCount(CFIndex result)
{
  if (result) {
    return CFArrayGetCount(*(CFArrayRef *)(result + 128));
  }
  return result;
}

const void *CGImageSurfaceSetGetIOSurface(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 128));
  if ((Count & 0x8000000000000000) != 0 || Count <= a2) {
    return 0;
  }
  CFArrayRef v5 = *(const __CFArray **)(a1 + 128);

  return CFArrayGetValueAtIndex(v5, a2);
}

void CGImageIOSurfaceSetSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a2 && a3)
  {
    if (!*(void *)(a1 + 96))
    {
      uint64_t v6 = (CFTypeRef *)CGPropertiesCreate();
      uint64_t v7 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 96), (unint64_t *)&v7, (unint64_t)v6, memory_order_relaxed, memory_order_relaxed);
      if (v7) {
        CGPropertiesRelease(v6);
      }
    }
    uint64_t v8 = *(void *)(a1 + 96);
    CGPropertiesSetProperty(v8, a2, a3);
  }
}

const void *CGImageIOSurfaceSetGetProperty(uint64_t a1, const void *a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 96)) != 0) {
    return CGPropertiesGetProperty(v2, a2);
  }
  else {
    return 0;
  }
}

void CGGlyphLockRelease(CFTypeRef **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      CGGlyphBuilderUnlockBitmaps(v2);
      CGGlyphBuilderRelease(*a1);
    }
    free(a1);
  }
}

void CGGlyphLockAccess()
{
}

unint64_t *scan(void **a1)
{
  uint64_t v2 = (unint64_t *)malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  double v9 = v2;
  if (!v2) {
    return v9;
  }
  long long v22 = 0uLL;
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = 0;
  while (1)
  {
    int v10 = type4_lexer_scan(a1, (uint64_t)&v22, v3, v4, v5, v6, v7, v8);
    if (v10 == 123)
    {
      uint64_t v11 = scan(a1);
      if (!v11) {
        goto LABEL_25;
      }
      LODWORD(v22) = 259;
      *((void *)&v22 + 1) = v11;
      goto LABEL_9;
    }
    if (v10 == 125) {
      break;
    }
    if (v10 == -1)
    {
      pdf_error("EOF encountered before end of Type4 function.");
LABEL_25:
      type4_program_release(v9);
      return 0;
    }
LABEL_9:
    unint64_t v12 = *v9;
    if (*v9 == v9[1])
    {
      uint64_t v13 = 2 * v12 + 24;
      v9[1] = v13;
      uint64_t v14 = malloc_type_realloc((void *)v9[2], 16 * v13, 0x10A204033A3C712uLL);
      v9[2] = (unint64_t)v14;
      unint64_t v12 = *v9;
    }
    else
    {
      uint64_t v14 = (_OWORD *)v9[2];
    }
    *double v9 = v12 + 1;
    v14[v12] = v22;
  }
  int v23 = 0;
  unint64_t v15 = *v9;
  while (v15)
  {
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    char v17 = 0;
    unint64_t v18 = v9[2];
    do
    {
      uint64_t v19 = 0;
      unint64_t v20 = v18 + 16 * v15++;
      *(_OWORD *)unint64_t v20 = *(_OWORD *)(v18 + 16 * v16);
      while (*(uint64_t (**)())(v20 + 8) != *(uint64_t (**)())((char *)&type4_program_peephole_peepholers
                                                                                  + v19)
           || !(*(unsigned int (**)(unint64_t, unint64_t, int *))((char *)&type4_program_peephole_peepholers
                                                                                         + v19
                                                                                         + 8))(v20, v15, &v23))
      {
        v19 += 16;
        if (v19 == 288) {
          goto LABEL_22;
        }
      }
      v15 += v23;
      char v17 = 1;
LABEL_22:
      ++v16;
    }
    while (v16 < *v9);
    *double v9 = v15;
    if ((v17 & 1) == 0) {
      return v9;
    }
  }
  *double v9 = 0;
  return v9;
}

void type4_program_release(unint64_t *a1)
{
  if (a1)
  {
    unint64_t v2 = *a1;
    if (*a1)
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        unint64_t v5 = a1[2];
        if (*(_DWORD *)(v5 + v3) == 259)
        {
          type4_program_release(*(void *)(v5 + v3 + 8));
          unint64_t v2 = *a1;
        }
        ++v4;
        v3 += 16;
      }
      while (v4 < v2);
    }
    free((void *)a1[2]);
    free(a1);
  }
}

uint64_t type4_program_execute(void *a1, uint64_t *a2)
{
  if (!*a1) {
    return 1;
  }
  uint64_t v4 = 0;
  for (uint64_t i = a1[2]; *(_DWORD *)i == 260; i += 16)
  {
    if (((*(uint64_t (**)(uint64_t *))(i + 8))(a2) & 1) == 0) {
      return 0;
    }
LABEL_8:
    if ((unint64_t)++v4 >= *a1) {
      return 1;
    }
  }
  uint64_t v6 = *a2;
  if (*a2 != 200)
  {
    *a2 = v6 + 1;
    *(_OWORD *)&a2[2 * v6 + 2] = *(_OWORD *)i;
    goto LABEL_8;
  }
  uint64_t result = 0;
  *((_DWORD *)a2 + 804) = 3;
  return result;
}

uint64_t get_program_string_length(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 3;
  }
  unint64_t v2 = (void *)(a1[2] + 8);
  uint64_t v3 = 2;
  do
  {
    switch(*((_DWORD *)v2 - 2))
    {
      case 0x100:
        uint64_t v4 = v3 + 5;
        break;
      case 0x101:
      case 0x102:
        uint64_t v4 = v3 + 16;
        break;
      case 0x103:
        uint64_t v4 = get_program_string_length(*v2) + v3;
        break;
      case 0x104:
        uint64_t v4 = v3 + 8;
        break;
      default:
        uint64_t v4 = v3;
        break;
    }
    uint64_t v3 = v4 + 1;
    v2 += 2;
    --v1;
  }
  while (v1);
  return v4 + 2;
}

uint64_t print_program(char *a1, unint64_t *a2)
{
  strcpy(a1, "{ ");
  if (*a2)
  {
    unint64_t v4 = 0;
    uint64_t v5 = 2;
    do
    {
      unint64_t v6 = a2[2];
      switch(*(_DWORD *)(v6 + 16 * v4))
      {
        case 0x100:
          uint64_t v7 = &a1[v5];
          goto LABEL_17;
        case 0x101:
          uint64_t v8 = &a1[v5];
          goto LABEL_21;
        case 0x102:
          uint64_t v8 = &a1[v5];
          double v9 = *(double *)(v6 + 16 * v4 + 8);
          double v10 = fabs(v9);
          if (v10 == INFINITY) {
            goto LABEL_21;
          }
          if (v9 < -2147483650.0 || v9 > 2147483650.0) {
            goto LABEL_18;
          }
          double v11 = ceil(v9 + -0.5);
          double v12 = floor(v9 + 0.5);
          if (v9 >= 0.0) {
            double v11 = v12;
          }
          if (vabdd_f64(v9, v11) < 0.000001)
          {
LABEL_21:
            int v16 = sprintf(v8, "%d");
          }
          else
          {
LABEL_18:
            if (v10 >= 1.0)
            {
              if (v10 <= 10000000.0) {
                int v16 = sprintf(v8, "%0.7g");
              }
              else {
                int v16 = sprintf(v8, "%0.0f");
              }
            }
            else if (v10 >= 0.000001)
            {
              if (v10 >= 0.0001) {
                int v16 = sprintf(v8, "%0.06g");
              }
              else {
                int v16 = sprintf(v8, "%0.06f");
              }
            }
            else
            {
              *(_WORD *)uint64_t v8 = 48;
              int v16 = 1;
            }
          }
          goto LABEL_22;
        case 0x103:
          v5 += print_program(&a1[v5], *(void *)(v6 + 16 * v4 + 8));
          break;
        case 0x104:
          uint64_t v13 = 0;
          uint64_t v7 = &a1[v5];
          uint64_t v14 = *(void *)(v6 + 16 * v4 + 8);
          unint64_t v15 = &qword_1ED099428;
          do
          {
            if (*v15 == v14) {
              break;
            }
            ++v13;
            v15 += 2;
          }
          while (v13 != 48);
LABEL_17:
          int v16 = sprintf(v7, "%s");
LABEL_22:
          v5 += v16;
          break;
        default:
          break;
      }
      *(_WORD *)&a1[v5++] = 32;
      ++v4;
    }
    while (v4 < *a2);
  }
  else
  {
    uint64_t v5 = 2;
  }
  *(_WORD *)&a1[v5] = 125;
  return v5 + 1;
}

void startIndent(__CFString *a1, int *a2)
{
  CFStringAppend(a1, @"\n");
  if (a2)
  {
    int v4 = *a2;
    if (*a2)
    {
      do
      {
        --v4;
        CFStringAppend(a1, @"\t");
      }
      while (v4);
      int v5 = *a2 + 1;
    }
    else
    {
      int v5 = 1;
    }
    *a2 = v5;
  }
}

void startTagWithAttributes(__CFString *a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  CFStringAppend(a1, @"<");
  CFStringAppend(a1, a2);
  char v17 = &a10;
  for (uint64_t i = a9; i; uint64_t i = *v16)
  {
    uint64_t v14 = v17;
    unint64_t v18 = v17 + 1;
    uint64_t v15 = *v14;
    if (!v15) {
      break;
    }
    CFStringAppendFormat(a1, 0, @" %@=\"%@\"", i, v15);
    int v16 = v18;
    char v17 = v18 + 1;
  }
  if (a3) {
    CFStringAppend(a1, @"/");
  }
  CFStringAppend(a1, @">");
}

void startTag(__CFString *a1, const __CFString *a2, int a3)
{
  CFStringAppend(a1, @"<");
  CFStringAppend(a1, a2);
  if (a3) {
    CFStringAppend(a1, @"/");
  }

  CFStringAppend(a1, @">");
}

CFMutableStringRef CGPDFCopyStringEscapingElementMarkup(__CFString *theString)
{
  CFMutableStringRef MutableCopy = theString;
  if (!theString) {
    return MutableCopy;
  }
  if (CFStringFind(theString, @"&", 0).location != -1
    || CFStringFind(MutableCopy, @"<", 0).location != -1
    || CFStringFind(MutableCopy, @">", 0).location != -1)
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MutableCopy);
    v4.length = CFStringGetLength(MutableCopy);
    v4.location = 0;
    CFStringFindAndReplace(MutableCopy, @"&", @"&amp;", v4, 0);
    v5.length = CFStringGetLength(MutableCopy);
    v5.location = 0;
    CFStringFindAndReplace(MutableCopy, @"<", @"&lt;", v5, 0);
    v6.length = CFStringGetLength(MutableCopy);
    v6.location = 0;
    CFStringFindAndReplace(MutableCopy, @">", @"&gt;", v6, 0);
    return MutableCopy;
  }

  return (CFMutableStringRef)CFRetain(MutableCopy);
}

void endIndent(__CFString *a1, int *a2)
{
  CFStringAppend(a1, @"\n");
  if (a2)
  {
    int v4 = *a2;
    if (*a2)
    {
      int v5 = v4 - 1;
      *a2 = v4 - 1;
      if (v4 != 1)
      {
        do
        {
          --v5;
          CFStringAppend(a1, @"\t");
        }
        while (v5);
      }
    }
  }
}

uint64_t mapPageToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange <= 0)
  {
    if (OverlappingRange < 0) {
      return 0;
    }
    CFRange v6 = *(__CFString **)(a3 + 56);
    uint64_t v7 = *(void *)a3;
    if (*(void *)a3)
    {
      uint64_t v7 = *(void *)(v7 + 16);
      if (v7) {
        uint64_t v7 = *(unsigned int *)(*(void *)(v7 + 40) + 8);
      }
    }
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"Page %u", v7);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, @"div", 0, v9, v10, v11, v12, v13, @"class", @"page");
    CFRelease(v8);
    uint64_t v14 = *(int **)(a3 + 72);
    if (v14 == (int *)a2)
    {
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    }
    else
    {
      if (v14) {
        int v15 = *v14;
      }
      else {
        int v15 = 0;
      }
      uint64_t v17 = 1;
      while (kCGPDFNodeTypeOrder[v17] != v15)
      {
        if (++v17 == 12)
        {
          uint64_t v18 = 0;
          goto LABEL_17;
        }
      }
      uint64_t v18 = v17;
LABEL_17:
      ((void (*)(void))htmlFuncArray[v18])(0);
    }
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, @"</%@>", @"div");
  }
  return 1;
}

uint64_t findOverlappingRange(uint64_t a1, uint64_t *a2)
{
  uint64_t TextRange = CGPDFNodeGetTextRange(a1);
  uint64_t v5 = v4;
  uint64_t v6 = a2[1];
  if (v6)
  {
    if (*(unsigned char *)(v6 + 40)) {
      CPIndexSetNormalize(a2[1]);
    }
    uint64_t v6 = *(void *)(v6 + 16);
  }
  uint64_t v7 = a2[3];
  uint64_t v8 = a2[4];
  uint64_t v9 = v7 + v8;
  BOOL v10 = v8 <= 0;
  if (v8 <= 0) {
    uint64_t v11 = v7 + v8;
  }
  else {
    uint64_t v11 = a2[3];
  }
  if (!v10) {
    uint64_t v7 = v9;
  }
  uint64_t v12 = TextRange + v5;
  BOOL v13 = v5 <= 0;
  if (v5 <= 0) {
    uint64_t v14 = TextRange + v5;
  }
  else {
    uint64_t v14 = TextRange;
  }
  if (!v13) {
    uint64_t TextRange = v12;
  }
  BOOL v15 = TextRange <= v11;
  if (v7 <= v14) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = v15;
  }
  if (v7 <= v14)
  {
    uint64_t v17 = a2[2] + 1;
    if (v17 < v6)
    {
      while (1)
      {
        uint64_t v18 = a2[1];
        a2[2] = v17;
        uint64_t Range = CPIndexSetGetRange(v18, v17);
        a2[3] = Range;
        a2[4] = v20;
        uint64_t v21 = Range + v20;
        uint64_t v22 = v20 <= 0 ? Range : Range + v20;
        if (v22 > v14) {
          break;
        }
        uint64_t v17 = a2[2] + 1;
        if (v17 >= v6) {
          return 0xFFFFFFFFLL;
        }
      }
      if (v20 > 0) {
        uint64_t v21 = Range;
      }
      return TextRange <= v21;
    }
  }
  return result;
}

uint64_t mapSectionToHTML(int a1, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (*(void *)(a3 + 72))
    {
LABEL_20:
      unint64_t v21 = 0;
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  if ((*(unsigned char *)(a2 + 1) & 4) != 0)
  {
    uint64_t v5 = *(int **)(a2 + 104);
    if (v5)
    {
      int v6 = *v5;
      if (v6 == 3)
      {
        int OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
        if (OverlappingRange <= 0)
        {
          if ((OverlappingRange & 0x80000000) == 0)
          {
            uint64_t v8 = *(__CFString **)(a3 + 56);
            CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
            CFStringAppend(Mutable, @"border-collapse: collapse");
            if (*(void *)(a3 + 72) == a2)
            {
              unint64_t BackgroundColor = CGPDFNodeGetBackgroundColor(a2);
            }
            else
            {
              uint64_t v17 = a2;
              while (1)
              {
                if (*(_DWORD *)v17 == 1538)
                {
                  uint64_t v18 = *(void *)(v17 + 104);
                  if (v18)
                  {
                    if (*(_DWORD *)v18 == 3) {
                      break;
                    }
                  }
                }
                uint64_t v17 = *(void *)(v17 + 8);
                if (!v17)
                {
                  unint64_t BackgroundColor = 0;
                  goto LABEL_120;
                }
              }
              unint64_t BackgroundColor = *(void *)(v18 + 48);
            }
LABEL_120:
            uint64_t v111 = CGPDFCreateColorValueCSS(BackgroundColor, 1, v11, v12, v13, v14, v15, v16);
            if (v111)
            {
              CFStringRef v112 = v111;
              CFStringAppend(Mutable, @"; background-color: ");
              CFStringAppend(Mutable, v112);
              CFRelease(v112);
            }
            startIndent(v8, (int *)(a3 + 64));
            startTagWithAttributes(v8, @"table", 0, v113, v114, v115, v116, v117, @"style", (uint64_t)Mutable);
            CFRelease(Mutable);
            uint64_t v118 = a2;
            while (1)
            {
              if (*(_DWORD *)v118 == 1538)
              {
                unsigned int v119 = *(_DWORD **)(v118 + 104);
                if (v119)
                {
                  if (*v119 == 3) {
                    break;
                  }
                }
              }
              uint64_t v118 = *(void *)(v118 + 8);
              if (!v118) {
                goto LABEL_127;
              }
            }
            uint64_t v120 = v119[4];
            if (v120 >= 2)
            {
              uint64_t v134 = (double *)malloc_type_calloc((v120 + 1), 8uLL, 0x100004000313F17uLL);
              if (CGPDFNodeGetTableColumnDividerPositions(a2, v134))
              {
                double v121 = 100.0 / (v134[v120] - *v134);
                unsigned int v122 = v134 + 1;
                do
                {
                  CFStringRef v123 = CFStringCreateWithFormat(v9, 0, @"width: %f%%", v121 * (*v122 - *(v122 - 1)));
                  startTagWithAttributes(v8, @"col", 1, v124, v125, v126, v127, v128, @"style", (uint64_t)v123);
                  CFRelease(v123);
                  ++v122;
                  --v120;
                }
                while (v120);
              }
              free(v134);
            }
LABEL_127:
            CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
            endIndent(v8, (int *)(a3 + 64));
            CFStringAppendFormat(v8, 0, @"</%@>", @"table");
            return 1;
          }
          return 0;
        }
        return 1;
      }
      if (*(void *)(a3 + 72) != a2)
      {
        if (v6 == 2)
        {
          uint64_t TableCellRowSpan = CGPDFNodeGetTableCellRowSpan(a2);
          uint64_t v25 = v24;
          uint64_t TableCellColumnSpan = CGPDFNodeGetTableCellColumnSpan(a2);
          uint64_t v130 = v26;
          uint64_t v27 = *(void *)(a2 + 8);
          if (v27 && (*(unsigned char *)(v27 + 1) & 2) != 0) {
            unsigned int v28 = *(_DWORD *)(v27 + 44);
          }
          else {
            unsigned int v28 = 0;
          }
          unsigned int v52 = a1 + 1;
          if (a1)
          {
            if (TableCellRowSpan != 0x7FFFFFFFFFFFFFFFLL || v25)
            {
              if (v27 && (*(unsigned char *)(v27 + 1) & 2) != 0 && *(_DWORD *)(v27 + 44) > (a1 - 1)) {
                uint64_t v54 = *(void *)(*(void *)(v27 + 56) + 8 * (a1 - 1));
              }
              else {
                uint64_t v54 = 0;
              }
              uint64_t v55 = CGPDFNodeGetTableCellRowSpan(v54);
              BOOL v53 = (v55 != 0x7FFFFFFFFFFFFFFFLL || v56 != 0) && v55 < TableCellRowSpan;
            }
            else
            {
              BOOL v53 = 0;
            }
          }
          else
          {
            BOOL v53 = 1;
          }
          if (v52 >= v28)
          {
            BOOL v59 = 1;
          }
          else
          {
            if (TableCellRowSpan == 0x7FFFFFFFFFFFFFFFLL && !v25)
            {
              BOOL v131 = 0;
              goto LABEL_83;
            }
            if (v27 && (*(unsigned char *)(v27 + 1) & 2) != 0 && *(_DWORD *)(v27 + 44) > v52) {
              uint64_t v60 = *(void *)(*(void *)(v27 + 56) + 8 * v52);
            }
            else {
              uint64_t v60 = 0;
            }
            uint64_t v61 = CGPDFNodeGetTableCellRowSpan(v60);
            BOOL v59 = (v61 != 0x7FFFFFFFFFFFFFFFLL || v62 != 0) && TableCellRowSpan < v61;
          }
          BOOL v131 = v59;
LABEL_83:
          uint64_t v132 = TableCellRowSpan;
          unsigned int v65 = *(__CFString **)(a3 + 56);
          if (v53)
          {
            startIndent(*(__CFString **)(a3 + 56), (int *)(a3 + 64));
            startTag(v65, @"tr", 0);
          }
          CFAllocatorRef v66 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          unsigned int v67 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
          CFStringAppend(v67, @"border-style: solid");
          uint64_t v74 = a2;
          while (1)
          {
            if (*(_DWORD *)v74 == 1538)
            {
              uint64_t v75 = *(void *)(v74 + 104);
              if (v75)
              {
                if (*(_DWORD *)v75 == 2) {
                  break;
                }
              }
            }
            uint64_t v74 = *(void *)(v74 + 8);
            if (!v74)
            {
              unint64_t v76 = 0;
              goto LABEL_92;
            }
          }
          unint64_t v76 = *(void *)(v75 + 48);
LABEL_92:
          uint64_t v133 = v25;
          int v77 = CGPDFCreateColorValueCSS(v76, 1, v68, v69, v70, v71, v72, v73);
          if (v77)
          {
            CFStringRef v78 = v77;
            CFStringAppend(v67, @"; background-color: ");
            CFStringAppend(v67, v78);
            CFRelease(v78);
          }
          for (uint64_t i = 0; i != 4; ++i)
          {
            double TableCellBorderBounds = CGPDFNodeGetTableCellBorderBounds(a2, i);
            double v82 = v81;
            uint64_t v84 = v83;
            uint64_t v86 = v85;
            unint64_t TableCellBorderColor = CGPDFNodeGetTableCellBorderColor(a2, i);
            CFStringRef v88 = CFStringCreateWithFormat(v66, 0, @"border-%s-", kCGPDFNodeSideCSSMap[i]);
            CFStringRef v95 = v88;
            if (TableCellBorderBounds != INFINITY && v82 != INFINITY)
            {
              switch((int)i)
              {
                case 0:
                case 2:
                  uint64_t v84 = v86;
                  break;
                case 1:
                case 3:
                  break;
                default:
                  uint64_t v84 = 0;
                  break;
              }
              CFStringAppendFormat(v67, 0, @"; %@width: %fpt", v88, v84);
            }
            if (TableCellBorderColor)
            {
              int v97 = CGPDFCreateColorValueCSS(TableCellBorderColor, 1, v89, v90, v91, v92, v93, v94);
              if (v97)
              {
                unsigned int v98 = v97;
                CFStringAppendFormat(v67, 0, @"; %@color: %@", v95, v97);
                CFRelease(v98);
              }
            }
            CFRelease(v95);
          }
          startIndent(v65, (int *)(a3 + 64));
          if (v132 == 0x7FFFFFFFFFFFFFFFLL && !v133
            || TableCellColumnSpan == 0x7FFFFFFFFFFFFFFFLL && !v130
            || v133 == (void *)1 && v130 == 1)
          {
            startTagWithAttributes(v65, @"td", 0, v99, v100, v101, v102, v103, @"style", (uint64_t)v67);
          }
          else
          {
            uint64_t v104 = CFStringCreateMutable(v66, 0);
            CFStringAppendFormat(v104, 0, @"%i", v133);
            uint64_t v105 = CFStringCreateMutable(v66, 0);
            CFStringAppendFormat(v105, 0, @"%i", v130);
            startTagWithAttributes(v65, @"td", 0, v106, v107, v108, v109, v110, @"rowspan", (uint64_t)v104);
            CFRelease(v105);
            CFRelease(v104);
          }
          CFRelease(v67);
          if (!findOverlappingRange(a2, (uint64_t *)a3)) {
            CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
          }
          endIndent(v65, (int *)(a3 + 64));
          CFStringAppendFormat(v65, 0, @"</%@>", @"td");
          if (v131)
          {
            endIndent(v65, (int *)(a3 + 64));
            CFStringAppendFormat(v65, 0, @"</%@>", @"tr");
          }
          return 1;
        }
        goto LABEL_15;
      }
LABEL_27:
      unint64_t v21 = CGPDFNodeGetBackgroundColor(a2);
      goto LABEL_28;
    }
  }
  if (*(void *)(a3 + 72) == a2) {
    goto LABEL_27;
  }
LABEL_15:
  uint64_t v20 = a2;
  while (*(_DWORD *)v20 != 1538)
  {
    uint64_t v20 = *(void *)(v20 + 8);
    if (!v20) {
      goto LABEL_20;
    }
  }
  unint64_t v21 = *(void *)(v20 + 112);
LABEL_28:
  int v29 = findOverlappingRange(a2, (uint64_t *)a3);
  if (v29 <= 0)
  {
    if (v29 < 0) {
      return 0;
    }
    CGRect v30 = *(__CFString **)(a3 + 56);
    if (a2 && (uint64_t v31 = *(void *)(a2 + 8)) != 0 && (*(unsigned char *)(v31 + 1) & 2) != 0 && *(_DWORD *)(v31 + 44) == 1 && !v21)
    {
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    }
    else
    {
      startIndent(*(__CFString **)(a3 + 56), (int *)(a3 + 64));
      int v38 = CGPDFCreateColorValueCSS(v21, 0, v32, v33, v34, v35, v36, v37);
      if (v38)
      {
        CFStringRef v44 = v38;
        int v45 = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
        CFStringAppend(v45, @"background-color: ");
        CFStringAppend(v45, v44);
        CFRelease(v44);
        startTagWithAttributes(v30, @"div", 0, v46, v47, v48, v49, v50, @"class", @"section");
        CFRelease(v45);
      }
      else
      {
        startTagWithAttributes(v30, @"div", 0, v39, v40, v41, v42, v43, @"class", @"section");
      }
      CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
      endIndent(v30, (int *)(a3 + 64));
      CFStringAppendFormat(v30, 0, @"</%@>", @"div");
    }
  }
  return 1;
}

__CFString *CGPDFCreateColorValueCSS(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  char v8 = a2;
  if ((a1 & 0x8000000000000000) != 0)
  {
    CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(a1, a2, a3, a4, a5, a6, a7, a8);
    if (ColorSpace) {
      goto LABEL_4;
    }
LABEL_9:
    CGColorGetComponents((CGColorRef)a1);
    return 0;
  }
  CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(a1 + 24);
  if (!ColorSpace) {
    goto LABEL_9;
  }
LABEL_4:
  int v11 = *(_DWORD *)(*((void *)ColorSpace + 3) + 28);
  Components = (float64x2_t *)CGColorGetComponents((CGColorRef)a1);
  if (v11)
  {
    if (v11 == 2)
    {
      double v16 = 1.0 - Components[1].f64[1];
      __asm { FMOV            V4.2D, #1.0 }
      float64x2_t v13 = vmulq_f64(vmulq_n_f64(vsubq_f64(_Q4, *Components), v16), (float64x2_t)vdupq_n_s64(0x4059000000000000uLL));
      double v14 = v16 * (1.0 - Components[1].f64[0]);
    }
    else
    {
      if (v11 != 1) {
        return 0;
      }
      float64x2_t v13 = vmulq_f64(*Components, (float64x2_t)vdupq_n_s64(0x4059000000000000uLL));
      double v14 = Components[1].f64[0];
    }
    double v15 = v14 * 100.0;
  }
  else
  {
    double v15 = Components->f64[0] * 100.0;
    float64x2_t v13 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v15, 0);
  }
  float64_t v22 = v13.f64[1];
  if ((v8 & 1) != 0 || v13.f64[0] != 0.0 || v13.f64[1] != 0.0 || v15 != 0.0)
  {
    double v25 = v15;
    float64_t v26 = v13.f64[0];
    CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFStringAppendFormat(Mutable, 0, @"rgb(%f%%, %f%%, %f%%)", *(void *)&v26, *(void *)&v22, *(void *)&v25);
    return Mutable;
  }
  return 0;
}

uint64_t mapLayoutAreaToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange > 0) {
    return 1;
  }
  if ((OverlappingRange & 0x80000000) == 0)
  {
    int v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, @"div", 0, v7, v8, v9, v10, v11, @"class", @"layoutArea");
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, @"</%@>", @"div");
    return 1;
  }
  return 0;
}

uint64_t mapColumnToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  if (OverlappingRange > 0) {
    return 1;
  }
  if ((OverlappingRange & 0x80000000) == 0)
  {
    int v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    startTagWithAttributes(v6, @"div", 0, v7, v8, v9, v10, v11, @"class", @"column");
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    mapListToHTML(-1, 0, (uint64_t *)a3);
    endIndent(v6, (int *)(a3 + 64));
    CFStringAppendFormat(v6, 0, @"</%@>", @"div");
    return 1;
  }
  return 0;
}

void mapListToHTML(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a3[6];
  uint64_t v4 = (__CFString *)a3[7];
  int v6 = a3 + 6;
  if (v5)
  {
    uint64_t v7 = (int *)(a3 + 8);
    while (1)
    {
      unsigned int v8 = *(_DWORD *)(v5 + 8);
      unsigned int v9 = *(_DWORD *)(v5 + 12) + 1;
      *(_DWORD *)(v5 + 12) = v9;
      uint64_t v10 = *(void *)v5;
      ItemParagraphunint64_t Count = CGPDFNodeGetItemParagraphCount(*(void *)v5, v8);
      if (a1 < 0 || v9 >= ItemParagraphCount) {
        break;
      }
LABEL_5:
      uint64_t v12 = (uint64_t *)(v5 + 24);
LABEL_25:
      uint64_t v5 = *v12;
      if (!*v12) {
        goto LABEL_33;
      }
    }
    if (*(unsigned char *)(v5 + 17))
    {
      endIndent(v4, v7);
      CFStringAppendFormat(v4, 0, @"</%@>", @"li");
      *(unsigned char *)(v5 + 17) = 0;
      unsigned int v8 = *(_DWORD *)(v5 + 8);
      uint64_t v10 = *(void *)v5;
    }
    else if (*(unsigned char *)(v5 + 16))
    {
      *(unsigned char *)(v5 + 18) = 1;
    }
    *(void *)(v5 + 8) = v8 + 1;
    if (v10)
    {
      uint64_t v13 = v10;
      while (1)
      {
        if (*(_DWORD *)v13 == 1537)
        {
          double v14 = *(_DWORD **)(v13 + 104);
          if (v14)
          {
            if (*v14 == 1) {
              break;
            }
          }
        }
        uint64_t v13 = *(void *)(v13 + 8);
        if (!v13) {
          goto LABEL_16;
        }
      }
      if ((a1 & 0x80000000) == 0 && v8 + 1 < v14[5]) {
        goto LABEL_5;
      }
LABEL_16:
      if (!*(unsigned char *)(v5 + 16)) {
        goto LABEL_24;
      }
      while (1)
      {
        if (*(_DWORD *)v10 == 1537)
        {
          double v15 = *(_DWORD **)(v10 + 104);
          if (v15)
          {
            if (*v15 == 1) {
              break;
            }
          }
        }
        uint64_t v10 = *(void *)(v10 + 8);
        if (!v10)
        {
          double v16 = @"ol";
          goto LABEL_23;
        }
      }
      if (v15[1] == 257) {
        double v16 = @"ul";
      }
      else {
        double v16 = @"ol";
      }
    }
    else
    {
      double v16 = @"ol";
      if (!*(unsigned char *)(v5 + 16))
      {
LABEL_24:
        *int v6 = *(void *)(v5 + 24);
        free((void *)v5);
        uint64_t v12 = v6;
        goto LABEL_25;
      }
    }
LABEL_23:
    endIndent(v4, v7);
    CFStringAppendFormat(v4, 0, @"</%@>", v16);
    goto LABEL_24;
  }
LABEL_33:
  if ((a1 & 0x80000000) == 0)
  {
    uint64_t v17 = (void *)*v6;
    if (!a2) {
      goto LABEL_53;
    }
    if ((*(unsigned char *)(a2 + 1) & 4) == 0) {
      goto LABEL_53;
    }
    uint64_t v18 = *(_DWORD **)(a2 + 104);
    if (!v18 || *v18 != 1) {
      goto LABEL_53;
    }
    if (!v17) {
      goto LABEL_47;
    }
    uint64_t v19 = a2;
    while (1)
    {
      if (*(_DWORD *)v19 == 1537)
      {
        uint64_t v20 = *(void *)(v19 + 104);
        if (v20)
        {
          if (*(_DWORD *)v20 == 1) {
            break;
          }
        }
      }
      uint64_t v19 = *(void *)(v19 + 8);
      if (!v19) {
        goto LABEL_46;
      }
    }
    uint64_t v19 = *(void *)(v20 + 8);
LABEL_46:
    if (*v17 != v19)
    {
LABEL_47:
      unint64_t v21 = malloc_type_calloc(1uLL, 0x20uLL, 0x102004069DB6F06uLL);
      float64_t v22 = v21;
      *int v6 = (uint64_t)v21;
      v21[3] = v17;
      uint64_t v23 = a2;
      while (1)
      {
        if (*(_DWORD *)v23 == 1537)
        {
          uint64_t v24 = *(void *)(v23 + 104);
          if (v24)
          {
            if (*(_DWORD *)v24 == 1) {
              break;
            }
          }
        }
        uint64_t v23 = *(void *)(v23 + 8);
        if (!v23) {
          goto LABEL_84;
        }
      }
      uint64_t v23 = *(void *)(v24 + 8);
LABEL_84:
      *unint64_t v21 = v23;
      if (a1) {
        return;
      }
    }
    else
    {
LABEL_53:
      float64_t v22 = (void *)*v6;
      if (a1) {
        return;
      }
    }
    if (v22 && !*((unsigned char *)v22 + 17))
    {
      if (!*((unsigned char *)v22 + 16))
      {
        startIndent(v4, (int *)a3 + 16);
        if (a2)
        {
          uint64_t v25 = a2;
          while (1)
          {
            if (*(_DWORD *)v25 == 1537)
            {
              float64_t v26 = *(_DWORD **)(v25 + 104);
              if (v26)
              {
                if (*v26 == 1) {
                  break;
                }
              }
            }
            uint64_t v25 = *(void *)(v25 + 8);
            if (!v25) {
              goto LABEL_63;
            }
          }
          int v27 = v26[1];
        }
        else
        {
LABEL_63:
          int v27 = 0;
        }
        if (v27 == 257) {
          CFStringRef v28 = @"ul";
        }
        else {
          CFStringRef v28 = @"ol";
        }
        CFAllocatorRef v29 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
        BOOL ItemMarker = CGPDFListCanGenerateItemMarker(a2);
        if (a2 && ItemMarker)
        {
          uint64_t v32 = a2;
          while (1)
          {
            if (*(_DWORD *)v32 == 1537)
            {
              uint64_t v33 = *(_DWORD **)(v32 + 104);
              if (v33)
              {
                if (*v33 == 1) {
                  break;
                }
              }
            }
            uint64_t v32 = *(void *)(v32 + 8);
            if (!v32) {
              goto LABEL_74;
            }
          }
          uint64_t v34 = @"decimal";
          switch(v33[1])
          {
            case 0x201:
              break;
            case 0x202:
              uint64_t v34 = @"decimal-leading-zero";
              break;
            case 0x203:
              uint64_t v34 = @"lower-roman";
              break;
            case 0x204:
              uint64_t v34 = @"upper-roman";
              break;
            case 0x205:
              uint64_t v34 = @"lower-latin";
              break;
            case 0x206:
              uint64_t v34 = @"upper-latin";
              break;
            case 0x207:
              uint64_t v34 = @"lower-greek";
              break;
            default:
              if (@"decimal" != 257) {
                goto LABEL_74;
              }
              ItemMarkeruint64_t Range = CGPDFNodeGetItemMarkerRange(a2);
              uint64_t v67 = a2;
              while (*(_DWORD *)v67 != 517)
              {
                uint64_t v67 = *(void *)(v67 + 8);
                if (!v67)
                {
                  uint64_t v68 = 0;
                  goto LABEL_131;
                }
              }
              uint64_t v68 = *(void *)(v67 + 104);
LABEL_131:
              int CharacterUnicode = CGPDFLayoutGetCharacterUnicode(v68, ItemMarkerRange);
              uint64_t v34 = @"disc";
              if (CharacterUnicode == 9632) {
                uint64_t v34 = @"square";
              }
              if (CharacterUnicode == 9702) {
                uint64_t v34 = @"circle";
              }
              break;
          }
        }
        else
        {
LABEL_74:
          uint64_t v34 = @"none";
        }
        CFStringAppendFormat(Mutable, 0, @"list-style-type: %@", v34);
        if (a2)
        {
          uint64_t v40 = a2;
          while (1)
          {
            if (*(_DWORD *)v40 == 1537)
            {
              uint64_t v41 = *(_DWORD **)(v40 + 104);
              if (v41)
              {
                if (*v41 == 1) {
                  break;
                }
              }
            }
            uint64_t v40 = *(void *)(v40 + 8);
            if (!v40) {
              goto LABEL_88;
            }
          }
          uint64_t v40 = v41[4];
        }
        else
        {
          uint64_t v40 = 0;
        }
LABEL_88:
        if (v40 == 1 || v27 == 257)
        {
          startTagWithAttributes(v4, v28, 0, v35, v36, v37, v38, v39, @"style", (uint64_t)Mutable);
        }
        else
        {
          CFStringRef v42 = CFStringCreateWithFormat(v29, 0, @"%i", v40);
          startTagWithAttributes(v4, v28, 0, v43, v44, v45, v46, v47, @"start", (uint64_t)v42);
          CFRelease(v42);
        }
        CFRelease(Mutable);
        *((unsigned char *)v22 + 16) = 1;
      }
      startIndent(v4, (int *)a3 + 16);
      if (!CGPDFListCanGenerateItemMarker(a2)) {
        goto LABEL_115;
      }
      if (!a2) {
        goto LABEL_107;
      }
      uint64_t v53 = a2;
      while (*(_DWORD *)v53 != 1537)
      {
        uint64_t v53 = *(void *)(v53 + 8);
        if (!v53) {
          goto LABEL_101;
        }
      }
      if (*(double *)(v53 + 112) != 0.0)
      {
        startTagWithAttributes(v4, @"li", 0, v48, v49, v50, v51, v52, @"style", @"list-style-type: none");
        goto LABEL_116;
      }
LABEL_101:
      if ((*(unsigned char *)(a2 + 1) & 2) != 0
        && *(_DWORD *)(a2 + 44)
        && (uint64_t v54 = **(void **)(a2 + 56)) != 0
        && (*(unsigned char *)(v54 + 1) & 2) != 0
        && *(_DWORD *)(v54 + 44))
      {
        uint64_t v55 = **(void **)(v54 + 56);
      }
      else
      {
LABEL_107:
        uint64_t v55 = 0;
      }
      uint64_t TextRange = CGPDFNodeGetTextRange(v55);
      if (v57)
      {
        uint64_t v58 = 0;
        uint64_t v59 = *a3;
        if (*a3 && (TextRange & 0x8000000000000000) == 0)
        {
          if (*(void *)(v59 + 48) <= TextRange)
          {
            uint64_t v58 = 0;
          }
          else
          {
            uint64_t v58 = *(double **)(v59 + 24);
            if (v58) {
              uint64_t v58 = *(double **)&v58[3 * TextRange + 1];
            }
          }
        }
        CSS = CGPDFTextStyleCreateCSS(v58);
        startTagWithAttributes(v4, @"li", 0, v61, v62, v63, v64, v65, @"style", (uint64_t)CSS);
        CFRelease(CSS);
      }
      else
      {
LABEL_115:
        startTag(v4, @"li", 0);
      }
LABEL_116:
      *((unsigned char *)v22 + 17) = 1;
    }
  }
}

BOOL CGPDFListCanGenerateItemMarker(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result;
    while (1)
    {
      if (*(_DWORD *)v2 == 1537)
      {
        uint64_t v3 = *(_DWORD **)(v2 + 104);
        if (v3)
        {
          if (*v3 == 1) {
            break;
          }
        }
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return 0;
      }
    }
    uint64_t result = 0;
    int v4 = v3[1];
    if (v4)
    {
      if (v4 != 520)
      {
        if (v4 != 257)
        {
          CGPDFNodeGetItemMarkerPrefixRange(v1);
          if (v7 <= 0)
          {
            ItemMarkerSuffixuint64_t Range = CGPDFNodeGetItemMarkerSuffixRange(v1);
            if (v9 == 1)
            {
              uint64_t v10 = ItemMarkerSuffixRange;
              while (*(_DWORD *)v1 != 517)
              {
                uint64_t result = 0;
                uint64_t v1 = *(void *)(v1 + 8);
                if (!v1) {
                  return result;
                }
              }
              uint64_t result = 0;
              uint64_t v17 = *(void *)(v1 + 104);
              if (!v17 || v10 < 0) {
                return result;
              }
              if (*(void *)(v17 + 48) > v10)
              {
                uint64_t v18 = *(void *)(v17 + 24);
                if (v18)
                {
                  uint64_t v19 = *(void *)(v18 + 24 * v10);
                  if (v19) {
                    return *(unsigned __int16 *)(v19 + 8) == 46;
                  }
                }
              }
            }
          }
          return 0;
        }
        ItemMarkeruint64_t Range = CGPDFNodeGetItemMarkerRange(v1);
        if (v6 != 1) {
          return 0;
        }
        while (*(_DWORD *)v1 != 517)
        {
          uint64_t v1 = *(void *)(v1 + 8);
          if (!v1) {
            return 0;
          }
        }
        uint64_t v11 = *(void *)(v1 + 104);
        if (!v11) {
          return 0;
        }
        if (ItemMarkerRange < 0) {
          return 0;
        }
        if (*(void *)(v11 + 48) <= ItemMarkerRange) {
          return 0;
        }
        uint64_t v12 = *(void *)(v11 + 24);
        if (!v12) {
          return 0;
        }
        uint64_t v13 = *(void *)(v12 + 24 * ItemMarkerRange);
        if (!v13) {
          return 0;
        }
        int v14 = *(unsigned __int16 *)(v13 + 8);
        BOOL v15 = v14 == 8226 || v14 == 9632;
        return v15 || v14 == 9702;
      }
    }
  }
  return result;
}

__CFString *CGPDFTextStyleCreateCSS(double *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  int v4 = Mutable;
  if (a1)
  {
    CFStringAppendFormat(Mutable, 0, @"font-size: %fpt", *((void *)a1 + 2));
    uint64_t v11 = *((void *)a1 + 1);
    if (!v11) {
      goto LABEL_47;
    }
    uint64_t v12 = *(const char **)(v11 + 32);
    if (!v12) {
      goto LABEL_47;
    }
    CFStringRef v13 = CFStringCreateWithCString(v2, v12, 0x8000100u);
    if (!v13) {
      goto LABEL_47;
    }
    CFStringRef v14 = v13;
    CFIndex Length = CFStringGetLength(v13);
    if (Length)
    {
      CFIndex location = Length;
      if (Length >= 8 && CFStringGetCharacterAtIndex(v14, 6) == 43)
      {
        CFIndex v17 = 0;
        CFIndex v18 = 7;
        while (CFStringGetCharacterAtIndex(v14, v17) - 91 > 0xFFFFFFE5)
        {
          if (++v17 == 6) {
            goto LABEL_13;
          }
        }
      }
      CFIndex v18 = 0;
LABEL_13:
      CFRange v19 = CFStringFind(v14, @"-", 4uLL);
      if (v19.length == 1 && v19.location == CFStringFind(v14, @"-", 0).location) {
        CFIndex location = v19.location;
      }
      v48.length = location - v18;
      v48.CFIndex location = v18;
      CFStringRef v20 = CFStringCreateWithSubstring(v2, v14, v48);
    }
    else
    {
      CFStringRef v20 = CFStringCreateMutable(v2, 0);
    }
    CFStringRef v21 = v20;
    if (v20)
    {
      if (CFStringFind(v20, @"&", 0).location == -1
        && CFStringFind(v21, @"<", 0).location == -1
        && CFStringFind(v21, @">", 0).location == -1
        && CFStringFind(v21, @"\"", 0).location == -1
        && CFStringFind(v21, @"'", 0).location == -1)
      {
        CFMutableStringRef MutableCopy = (__CFString *)CFRetain(v21);
      }
      else
      {
        CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v2, 0, v21);
        v51.length = CFStringGetLength(MutableCopy);
        v51.CFIndex location = 0;
        CFStringFindAndReplace(MutableCopy, @"&", @"&amp;", v51, 0);
        v52.length = CFStringGetLength(MutableCopy);
        v52.CFIndex location = 0;
        CFStringFindAndReplace(MutableCopy, @"<", @"&lt;", v52, 0);
        v53.length = CFStringGetLength(MutableCopy);
        v53.CFIndex location = 0;
        CFStringFindAndReplace(MutableCopy, @">", @"&gt;", v53, 0);
        v54.length = CFStringGetLength(MutableCopy);
        v54.CFIndex location = 0;
        CFStringFindAndReplace(MutableCopy, @"\"", @"&quot;", v54, 0);
        v55.length = CFStringGetLength(MutableCopy);
        v55.CFIndex location = 0;
        CFStringFindAndReplace(MutableCopy, @"'", @"&apos;", v55, 0);
      }
      CFRelease(v21);
      if (MutableCopy)
      {
        CFStringAppendFormat(v4, 0, @"; font-family: '%@'", MutableCopy);
        CFRelease(MutableCopy);
      }
    }
    CFRange v23 = CFStringFind(v14, @"-", 4uLL);
    if (v23.length == 1 && v23.location == CFStringFind(v14, @"-", 0).location)
    {
      uint64_t v24 = 0;
      CFIndex v25 = CFStringGetLength(v14) - (v23.location + 1);
      while (1)
      {
        CFStringCompareFlags v26 = (*((unsigned char *)&kCGPDFFontWeightCSSMap + 8 * v24 + 12) & 1) == 0;
        CFStringRef v27 = CFStringCreateWithCString(v2, (&kCGPDFFontWeightCSSMap)[v24], 0x8000100u);
        v49.CFIndex location = v23.location + 1;
        v49.length = v25;
        LODWORD(v26) = CFStringFindWithOptions(v14, v27, v49, v26, 0);
        CFRelease(v27);
        if (v26) {
          break;
        }
        v24 += 2;
        if (v24 == 42) {
          goto LABEL_35;
        }
      }
      if (LODWORD((&kCGPDFFontWeightCSSMap)[v24 + 1]) != 400) {
        CFStringAppendFormat(v4, 0, @"; font-weight: %u", LODWORD((&kCGPDFFontWeightCSSMap)[v24 + 1]));
      }
    }
LABEL_35:
    CFRange v28 = CFStringFind(v14, @"-", 4uLL);
    if (v28.length == 1 && v28.location == CFStringFind(v14, @"-", 0).location)
    {
      uint64_t v29 = 0;
      CFIndex v30 = CFStringGetLength(v14) - (v28.location + 1);
      while (1)
      {
        CFStringCompareFlags v31 = (*((unsigned char *)&kCGPDFFontStyleCSSMap + 8 * v29 + 12) & 1) == 0;
        CFStringRef v32 = CFStringCreateWithCString(v2, (&kCGPDFFontStyleCSSMap)[v29], 0x8000100u);
        v50.CFIndex location = v28.location + 1;
        v50.length = v30;
        LODWORD(v31) = CFStringFindWithOptions(v14, v32, v50, v31, 0);
        CFRelease(v32);
        if (v31) {
          break;
        }
        v29 += 2;
        if (v29 == 18) {
          goto LABEL_46;
        }
      }
      int v33 = (int)(&kCGPDFFontStyleCSSMap)[v29 + 1];
      if (v33 == 1)
      {
        CFStringRef v34 = @"; font-style: italic";
        goto LABEL_45;
      }
      if (v33 == 2)
      {
        CFStringRef v34 = @"; font-style: oblique";
LABEL_45:
        CFStringAppend(v4, v34);
      }
    }
LABEL_46:
    CFRelease(v14);
LABEL_47:
    unint64_t v35 = *((void *)a1 + 3);
    goto LABEL_48;
  }
  CFStringAppendFormat(Mutable, 0, @"font-size: %fpt", 0);
  unint64_t v35 = 0;
LABEL_48:
  uint64_t v36 = CGPDFCreateColorValueCSS(v35, 0, v5, v6, v7, v8, v9, v10);
  if (v36)
  {
    CFStringRef v43 = v36;
    CFStringAppend(v4, @"; color: ");
    CFStringAppend(v4, v43);
    CFRelease(v43);
  }
  if (a1) {
    unint64_t v44 = *((void *)a1 + 4);
  }
  else {
    unint64_t v44 = 0;
  }
  uint64_t v45 = CGPDFCreateColorValueCSS(v44, 1, v37, v38, v39, v40, v41, v42);
  if (v45)
  {
    CFStringRef v46 = v45;
    CFStringAppend(v4, @"; background-color: ");
    CFStringAppend(v4, v46);
    CFRelease(v46);
  }
  if (a1 && a1[6] != 0.0) {
    CFStringAppendFormat(v4, 0, @"; vertical-align: %fpt", *((void *)a1 + 6));
  }
  return v4;
}

uint64_t mapParagraphToHTML(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int OverlappingRange = findOverlappingRange(a2, (uint64_t *)a3);
  mapListToHTML(OverlappingRange, a2, (uint64_t *)a3);
  if (OverlappingRange <= 0)
  {
    if (OverlappingRange < 0) {
      return 0;
    }
    uint64_t v6 = *(__CFString **)(a3 + 56);
    startIndent(v6, (int *)(a3 + 64));
    CFStringRef v7 = @"p";
    if (a2)
    {
      uint64_t v8 = a2;
      while (*(_DWORD *)v8 != 1537)
      {
        uint64_t v8 = *(void *)(v8 + 8);
        if (!v8) {
          goto LABEL_11;
        }
      }
      if (*(double *)(v8 + 112) != 0.0) {
        CFStringRef v7 = @"pre";
      }
    }
LABEL_11:
    startTag(v6, v7, 0);
    CGPDFNodeMapByType(a2, (uint64_t)htmlFuncArray);
    if (*(void *)(a3 + 40))
    {
      CFStringAppendFormat(v6, 0, @"</%@>", @"span");
      *(void *)(a3 + 40) = 0;
    }
    CFStringAppendFormat(v6, 0, @"</%@>", v7);
    --*(_DWORD *)(a3 + 64);
  }
  return 1;
}

uint64_t mapTextLineToHTML(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  int OverlappingRange = findOverlappingRange(a2, a3);
  if (OverlappingRange > 0) {
    return 1;
  }
  if (OverlappingRange < 0) {
    return 0;
  }
  uint64_t v6 = (__CFString *)a3[7];
  if (*(unsigned char *)(*a3 + 72))
  {
    uint64_t TextRange = CGPDFNodeGetTextRange(v4);
    if (v7)
    {
      uint64_t v8 = v7;
      CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      if (Mutable)
      {
        CFStringRef v11 = Mutable;
        CFStringRef v78 = 0;
        int v77 = 0;
        CPTextServicesAppendTextLine(Mutable, (void *)*a3, TextRange, v8, &v78, &v77);
        CFIndex Length = CFStringGetLength(v11);
        if (Length >= v77) {
          CFIndex v13 = v77;
        }
        else {
          CFIndex v13 = Length;
        }
        if (v13 >= 1)
        {
          CFStringRef v68 = v11;
          CFAllocatorRef v66 = v6;
          uint64_t v14 = a3[2];
          uint64_t v15 = CGPDFNodeGetTextRange(v4);
          uint64_t v17 = v16;
          uint64_t v18 = a3[1];
          if (v18)
          {
            if (*(unsigned char *)(v18 + 40)) {
              CPIndexSetNormalize(a3[1]);
            }
            uint64_t v19 = *(void *)(v18 + 16);
          }
          else
          {
            uint64_t v19 = 0;
          }
          uint64_t v20 = a3[2];
          uint64_t v21 = v20 + 1;
          if (v20 + 1 < v19)
          {
            uint64_t v22 = v15 + v17;
            BOOL v23 = v17 <= 0;
            if (v17 <= 0) {
              uint64_t v24 = v15 + v17;
            }
            else {
              uint64_t v24 = v15;
            }
            if (!v23) {
              uint64_t v15 = v22;
            }
            do
            {
              uint64_t Range = CPIndexSetGetRange(a3[1], v21);
              uint64_t v27 = Range + v26;
              if (v26 <= 0) {
                uint64_t v28 = Range + v26;
              }
              else {
                uint64_t v28 = Range;
              }
              if (v26 <= 0) {
                uint64_t v27 = Range;
              }
              if (v27 > v24 && v15 <= v28) {
                break;
              }
              if (v27 > v24 && v15 > v28)
              {
                a3[2] = v21;
                a3[3] = Range;
                a3[4] = v26;
              }
              ++v21;
            }
            while (v19 != v21);
            uint64_t v20 = a3[2];
          }
          unint64_t v71 = v20 - v14;
          uint64_t v31 = v20 - v14 + 1;
          uint64_t v67 = (char *)malloc_type_malloc(16 * v31, 0x1000040451B5BE8uLL);
          if (v31 >= 2)
          {
            CFStringRef v32 = v67 + 8;
            do
            {
              *(v32 - 1) = CPIndexSetGetRange(a3[1], v14);
              *CFStringRef v32 = v33;
              ++v14;
              v32 += 2;
            }
            while (v20 != v14);
          }
          *(_OWORD *)&v67[16 * v71] = *(_OWORD *)(a3 + 3);
          theString = (__CFString *)a3[7];
          CFMutableStringRef v34 = CFStringCreateMutable(v9, v13);
          CFIndex v35 = 0;
          uint64_t v74 = v34;
          uint64_t v75 = 0;
          char v70 = 0;
          uint64_t v36 = 0;
          if (v31 <= 1) {
            uint64_t v37 = 1;
          }
          else {
            uint64_t v37 = v31;
          }
          uint64_t v38 = (uint64_t)v34;
          uint64_t v73 = v37;
          unint64_t v39 = v71;
          while (1)
          {
            if (v35 < v13)
            {
              uint64_t v41 = 0;
              BOOL v40 = 0;
              uint64_t v42 = TextRange + v78[v35];
              uint64_t v43 = *a3;
              if (*a3 && (v42 & 0x8000000000000000) == 0)
              {
                if (*(void *)(v43 + 48) > v42 && (uint64_t v44 = *(void *)(v43 + 24)) != 0)
                {
                  uint64_t v41 = *(double **)(v44 + 24 * v42 + 8);
                  BOOL v40 = v41 != 0;
                  BOOL v45 = v41 == v75 || v41 == 0;
                  if (!v45)
                  {
                    BOOL v40 = 1;
                    if (!v38) {
                      goto LABEL_58;
                    }
LABEL_57:
                    uint64_t v38 = CFStringGetLength((CFStringRef)v38);
                    if (v38 <= 0 && !v36) {
                      goto LABEL_79;
                    }
LABEL_58:
                    if (!v75) {
                      goto LABEL_69;
                    }
                    uint64_t v46 = a3[5];
                    if (v46)
                    {
                      if (CGPDFTextStyleEqualToPDFTextStyle((uint64_t)v75, v46))
                      {
                        if ((v70 & 1) == 0)
                        {
                          char v70 = 0;
                          goto LABEL_69;
                        }
                      }
                      else
                      {
                        CFStringAppendFormat(theString, 0, @"</%@>", @"span");
                      }
                    }
                    a3[5] = (uint64_t)v75;
                    CSS = CGPDFTextStyleCreateCSS(v75);
                    startTagWithAttributes(theString, @"span", 0, v48, v49, v50, v51, v52, @"style", (uint64_t)CSS);
                    CFRange v53 = CSS;
                    unint64_t v39 = v71;
                    CFRelease(v53);
                    char v70 = 1;
LABEL_69:
                    if (v38 >= 1)
                    {
                      CFStringRef v54 = CGPDFCopyStringEscapingElementMarkup(v74);
                      if (v54)
                      {
                        CFStringRef v55 = v54;
                        CFStringAppend(theString, v54);
                        CFRelease(v55);
                      }
                      v79.CFIndex location = 0;
                      v79.length = v38;
                      CFStringDelete(v74, v79);
                      unint64_t v39 = v71;
                    }
                    if (v36)
                    {
                      uint64_t v56 = 1;
                      uint64_t v38 = (uint64_t)v74;
                      while (kCGPDFNodeTypeOrder[v56] != *v36)
                      {
                        if (++v56 == 12)
                        {
                          LODWORD(v56) = 0;
                          break;
                        }
                      }
                      ((void (*)(void, _DWORD *, uint64_t *))htmlFuncArray[v56])(0, v36, a3);
                    }
                    else
                    {
LABEL_79:
                      uint64_t v38 = (uint64_t)v74;
                    }
                    uint64_t v57 = v75;
                    if (v40) {
                      uint64_t v57 = v41;
                    }
                    uint64_t v75 = v57;
                    goto LABEL_83;
                  }
                }
                else
                {
                  BOOL v40 = 0;
                  uint64_t v41 = 0;
                }
              }
            }
            else
            {
              BOOL v40 = 0;
              uint64_t v41 = 0;
              uint64_t v42 = -1;
            }
            if (v35 == v13 || v36)
            {
              if (v38) {
                goto LABEL_57;
              }
              goto LABEL_58;
            }
LABEL_83:
            uint64_t v36 = 0;
            if (v39 <= 0x7FFFFFFFFFFFFFFELL)
            {
              uint64_t v59 = v67 + 8;
              uint64_t v58 = v73;
              if (v35 < v13)
              {
                while (1)
                {
                  uint64_t v60 = *(v59 - 1);
                  if (v60 <= v42 && v42 < *v59 + v60) {
                    break;
                  }
                  v59 += 2;
                  if (!--v58)
                  {
                    uint64_t v36 = 0;
                    goto LABEL_98;
                  }
                }
                UniChar chars = 0;
                CharacterAtIndedouble x = CFStringGetCharacterAtIndex(v68, v35);
                UniChar chars = CharacterAtIndex;
                if (CharacterAtIndex == 65532)
                {
                  NodeContaininguint64_t TextRange = CGPDFNodeGetNodeContainingTextRange(v4, v42, 1);
                  if (CGPDFNodeIsInlineContainer(NodeContainingTextRange))
                  {
                    char v70 = 0;
                    uint64_t v36 = *(_DWORD **)(NodeContainingTextRange + 64);
                  }
                  else
                  {
                    uint64_t v36 = 0;
                    char v70 = 0;
                  }
                }
                else
                {
                  if (v38) {
                    CFStringAppendCharacters((CFMutableStringRef)v38, &chars, 1);
                  }
                  uint64_t v36 = 0;
                }
              }
            }
LABEL_98:
            BOOL v45 = v35++ == v13;
            if (v45)
            {
              if (v38) {
                CFRelease((CFTypeRef)v38);
              }
              free(v67);
              uint64_t v6 = v66;
              CFStringRef v11 = v68;
              break;
            }
          }
        }
        free(v78);
        CFRelease(v11);
        if (!v4) {
          goto LABEL_120;
        }
        goto LABEL_105;
      }
    }
  }
  else
  {
    CGPDFNodeMapByType(v4, (uint64_t)htmlFuncArray);
  }
  if (v4)
  {
LABEL_105:
    uint64_t v65 = v4;
    while (*(_DWORD *)v65 != 514)
    {
      uint64_t v65 = *(void *)(v65 + 8);
      if (!v65) {
        goto LABEL_120;
      }
    }
    if (*(unsigned char *)(v65 + 104))
    {
      while (*(_DWORD *)v4 != 1537)
      {
        uint64_t v4 = *(void *)(v4 + 8);
        if (!v4) {
          goto LABEL_119;
        }
      }
      if (*(double *)(v4 + 112) != 0.0) {
        goto LABEL_120;
      }
LABEL_119:
      startTag(v6, @"br", 1);
    }
  }
LABEL_120:
  CFStringAppend(v6, @"\n");
  return 1;
}

uint64_t mapImageToHTML(uint64_t a1, __n64 *a2, uint64_t a3)
{
  int OverlappingRange = findOverlappingRange((uint64_t)a2, (uint64_t *)a3);
  if (OverlappingRange > 0) {
    return 1;
  }
  if (OverlappingRange < 0) {
    return 0;
  }
  if (CGPDFNodeIsUsedGraphic((uint64_t)a2)) {
    return 1;
  }
  v11.n64_u64[0] = CGPDFNodeGetBounds(a2).n64_u64[0];
  uint64_t v6 = 1;
  if (v11.n64_f64[0] != INFINITY)
  {
    CGFloat v12 = v8.n64_f64[0];
    if (v8.n64_f64[0] != INFINITY)
    {
      CGFloat width = v9.n64_f64[0];
      CGFloat height = v10.n64_f64[0];
      double PageRotation = CGPDFNodeGetPageRotation((uint64_t)a2);
      if (PageRotation != 0.0)
      {
        __double2 v16 = __sincos_stret(PageRotation);
        v29.a = v16.__cosval;
        v29.b = v16.__sinval;
        v29.c = -v16.__sinval;
        v29.d = v16.__cosval;
        v29.tdouble x = 0.0;
        v29.ty = 0.0;
        v30.origin.double x = v11.n64_f64[0];
        v30.origin.y = v12;
        v30.size.CGFloat width = width;
        v30.size.CGFloat height = height;
        CGRect v31 = CGRectApplyAffineTransform(v30, &v29);
        CGFloat width = v31.size.width;
        CGFloat height = v31.size.height;
      }
      ImageBOOL Name = CGPDFNodeCreateImageName((uint64_t)a2);
      if (ImageName)
      {
        CFStringRef v18 = ImageName;
        CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        CFStringRef v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%f", *(void *)&width);
        CFStringRef v21 = CFStringCreateWithFormat(v19, 0, @"%f", *(void *)&height);
        uint64_t v22 = *(__CFString **)(a3 + 56);
        startIndent(v22, (int *)(a3 + 64));
        uint64_t v6 = 1;
        startTagWithAttributes(v22, @"img", 1, v23, v24, v25, v26, v27, @"src", (uint64_t)v18);
        --*(_DWORD *)(a3 + 64);
        CFRelease(v21);
        CFRelease(v20);
        CFRelease(v18);
        uint64_t v28 = *(__CFArray **)(a3 + 80);
        if (v28) {
          CFArrayAppendValue(v28, a2);
        }
      }
    }
  }
  return v6;
}

uint64_t mapWordToHTML(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t WordRangeIncludingWhitespace = getWordRangeIncludingWhitespace(a1, a2, a3);
  uint64_t v8 = v7;
  uint64_t v9 = a3[1];
  if (v9)
  {
    if (*(unsigned char *)(v9 + 40)) {
      CPIndexSetNormalize(a3[1]);
    }
    uint64_t v10 = *(void *)(v9 + 16);
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = a3[3];
  uint64_t v12 = a3[4];
  uint64_t v13 = v11 + v12;
  BOOL v14 = v12 <= 0;
  if (v12 <= 0) {
    uint64_t v15 = v11 + v12;
  }
  else {
    uint64_t v15 = a3[3];
  }
  if (!v14) {
    uint64_t v11 = v13;
  }
  uint64_t v16 = WordRangeIncludingWhitespace + v8;
  BOOL v17 = v8 <= 0;
  if (v8 <= 0) {
    uint64_t v18 = WordRangeIncludingWhitespace + v8;
  }
  else {
    uint64_t v18 = WordRangeIncludingWhitespace;
  }
  if (!v17) {
    uint64_t WordRangeIncludingWhitespace = v16;
  }
  BOOL v19 = WordRangeIncludingWhitespace <= v15;
  BOOL v20 = v11 <= v18;
  if (v11 <= v18) {
    int v21 = -1;
  }
  else {
    int v21 = v19;
  }
  if (v20)
  {
    do
    {
      uint64_t v22 = a3[2] + 1;
      if (v22 >= v10) {
        return 0;
      }
      uint64_t v23 = a3[1];
      a3[2] = v22;
      uint64_t Range = CPIndexSetGetRange(v23, v22);
      a3[3] = Range;
      a3[4] = v25;
      uint64_t v26 = Range + v25;
      if (v25 <= 0) {
        uint64_t v27 = Range;
      }
      else {
        uint64_t v27 = Range + v25;
      }
    }
    while (v27 <= v18);
    if (v25 > 0) {
      uint64_t v26 = Range;
    }
    int v21 = WordRangeIncludingWhitespace <= v26;
  }
  if (v21) {
    return 1;
  }
  uint64_t v29 = a3[2];
  uint64_t v30 = getWordRangeIncludingWhitespace(a1, a2, a3);
  uint64_t v32 = v31;
  uint64_t v33 = a3[1];
  if (v33)
  {
    if (*(unsigned char *)(v33 + 40)) {
      CPIndexSetNormalize(a3[1]);
    }
    uint64_t v34 = *(void *)(v33 + 16);
  }
  else
  {
    uint64_t v34 = 0;
  }
  uint64_t v35 = a3[2];
  uint64_t v36 = v35 + 1;
  if (v35 + 1 < v34)
  {
    if (v32 <= 0) {
      uint64_t v37 = v30 + v32;
    }
    else {
      uint64_t v37 = v30;
    }
    if (v32 > 0) {
      v30 += v32;
    }
    do
    {
      uint64_t v38 = CPIndexSetGetRange(a3[1], v36);
      uint64_t v40 = v38 + v39;
      if (v39 <= 0) {
        uint64_t v41 = v38 + v39;
      }
      else {
        uint64_t v41 = v38;
      }
      if (v39 <= 0) {
        uint64_t v40 = v38;
      }
      if (v40 > v37 && v30 <= v41) {
        break;
      }
      if (v40 > v37 && v30 > v41)
      {
        a3[2] = v36;
        a3[3] = v38;
        a3[4] = v39;
      }
      ++v36;
    }
    while (v34 != v36);
    uint64_t v35 = a3[2];
  }
  uint64_t v44 = v35 - v29;
  if ((unint64_t)(v35 - v29) > 0x7FFFFFFFFFFFFFFELL) {
    return 0;
  }
  uint64_t result = getWordRangeIncludingWhitespace(a1, a2, a3);
  if (!v45) {
    return 1;
  }
  uint64_t v46 = result;
  uint64_t v47 = v45;
  LODWORD(result) = 0;
  if (a1 || !a2)
  {
LABEL_66:
    uint64_t v85 = v29;
    uint64_t v88 = a2;
    uint64_t v50 = 0;
    unint64_t v90 = v44 + 1;
    uint64_t v51 = *a3;
    int v83 = result;
    if (*a3 && (v46 & 0x8000000000000000) == 0)
    {
      if (*(void *)(v51 + 48) > v46 && (uint64_t v52 = *(void *)(v51 + 24)) != 0) {
        uint64_t v50 = *(double **)(v52 + 24 * v46 + 8);
      }
      else {
        uint64_t v50 = 0;
      }
    }
    uint64_t v89 = malloc_type_malloc(16 * v90, 0x1000040451B5BE8uLL);
    theString = (__CFString *)a3[7];
    if (v47 >= 1)
    {
      char v84 = 0;
      uint64_t v53 = v46 + v47;
      uint64_t v87 = &v89[2 * v44];
      uint64_t v54 = v46;
      while (1)
      {
        uint64_t v55 = v46;
        if (++v46 >= v53
          || ((uint64_t v56 = *a3) != 0 ? (v57 = v55 < -1) : (v57 = 1),
              v57 || *(void *)(v56 + 48) <= v46 || (uint64_t v58 = *(void *)(v56 + 24)) == 0))
        {
          uint64_t v59 = 0;
        }
        else
        {
          uint64_t v59 = *(double **)(v58 + 24 * v46 + 8);
        }
        BOOL v60 = !v59 || v59 == v50;
        if (!v60 || v46 == v53) {
          break;
        }
        uint64_t v59 = v50;
LABEL_114:
        uint64_t v50 = v59;
        if (v46 >= v53) {
          goto LABEL_115;
        }
      }
      if (v90 >= 2)
      {
        uint64_t v61 = v89 + 1;
        uint64_t v62 = v85;
        do
        {
          uint64_t v63 = CPIndexSetGetRange(a3[1], v62);
          *(v61 - 1) = CPRangeIntersection(v54, v46 - v54, v63, v64);
          *uint64_t v61 = v65;
          ++v62;
          v61 += 2;
        }
        while (v35 != v62);
      }
      *uint64_t v87 = CPRangeIntersection(v54, v46 - v54, a3[3], a3[4]);
      v87[1] = v66;
      StringForRanges = CGPDFLayoutCreateStringForRanges(*a3, (uint64_t)v89, v90);
      CFStringRef v68 = StringForRanges;
      if (v50 && StringForRanges && CFStringGetLength(StringForRanges) >= 1)
      {
        uint64_t v69 = a3[5];
        if (v69)
        {
          if (v84 & 1) == 0 && (CGPDFTextStyleEqualToPDFTextStyle((uint64_t)v50, v69))
          {
            char v84 = 0;
            goto LABEL_101;
          }
          CFStringAppendFormat(theString, 0, @"</%@>", @"span");
        }
        a3[5] = (uint64_t)v50;
        CSS = CGPDFTextStyleCreateCSS(v50);
        startTagWithAttributes(theString, @"span", 0, v71, v72, v73, v74, v75, @"style", (uint64_t)CSS);
        CFRelease(CSS);
        char v84 = 1;
      }
LABEL_101:
      if (CGPDFNodeIsInlineContainer(v88) && (unint64_t v76 = *(_DWORD **)(v88 + 64)) != 0)
      {
        uint64_t v77 = 1;
        while (kCGPDFNodeTypeOrder[v77] != *v76)
        {
          if (++v77 == 12)
          {
            LODWORD(v77) = 0;
            break;
          }
        }
        ((void (*)(void))htmlFuncArray[v77])(0);
        if (!v68) {
          goto LABEL_113;
        }
      }
      else
      {
        if (!v68)
        {
LABEL_113:
          uint64_t v54 = v46;
          goto LABEL_114;
        }
        CFStringRef v78 = CGPDFCopyStringEscapingElementMarkup(v68);
        if (v78)
        {
          CFStringRef v79 = v78;
          CFStringAppend(theString, v78);
          CFRelease(v79);
        }
      }
      CFRelease(v68);
      goto LABEL_113;
    }
LABEL_115:
    if (v83) {
      CFStringAppend(theString, @"&nbsp;");
    }
    free(v89);
    return 1;
  }
  uint64_t v48 = a2;
  while (1)
  {
    if (*(_DWORD *)v48 == 1537)
    {
      uint64_t v49 = *(_DWORD **)(v48 + 104);
      if (v49)
      {
        if (*v49 == 1) {
          break;
        }
      }
    }
    uint64_t v48 = *(void *)(v48 + 8);
    if (!v48) {
      goto LABEL_65;
    }
  }
  if (!v49[1]
    || (uint64_t v80 = *(void *)(a2 + 8)) != 0
    && ((uint64_t v81 = *(void *)(v80 + 8)) == 0
     || (*(unsigned char *)(v81 + 1) & 2) == 0
     || !*(_DWORD *)(v81 + 44)
     || v80 != **(void **)(v81 + 56)))
  {
LABEL_65:
    LODWORD(result) = 0;
    goto LABEL_66;
  }
  if (!CGPDFListCanGenerateItemMarker(a2))
  {
    LODWORD(result) = 1;
    goto LABEL_66;
  }
  uint64_t v82 = a2;
  uint64_t result = 1;
  while (*(_DWORD *)v82 != 1537)
  {
    uint64_t v82 = *(void *)(v82 + 8);
    if (!v82) {
      return result;
    }
  }
  uint64_t result = 1;
  if (*(double *)(v82 + 112) != 0.0) {
    goto LABEL_66;
  }
  return result;
}

uint64_t getWordRangeIncludingWhitespace(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t TextRange = CGPDFNodeGetTextRange(a2);
  uint64_t v8 = v7;
  uint64_t v18 = TextRange;
  uint64_t v19 = v7;
  if (a2)
  {
    uint64_t v9 = *(void *)(a2 + 8);
    if (v9)
    {
      uint64_t v10 = v9;
      while (*(_DWORD *)v10 != 1537)
      {
        uint64_t v10 = *(void *)(v10 + 8);
        if (!v10) {
          goto LABEL_17;
        }
      }
      if (*(double *)(v10 + 112) != 0.0)
      {
        if (a1)
        {
          if ((*(unsigned char *)(v9 + 1) & 2) != 0 && *(_DWORD *)(v9 + 44) > (a1 - 1)) {
            uint64_t v11 = *(void *)(*(void *)(v9 + 56) + 8 * (a1 - 1));
          }
          else {
            uint64_t v11 = 0;
          }
          uint64_t v12 = CGPDFNodeGetTextRange(v11);
          uint64_t v14 = v13 + v12 + 1;
        }
        else
        {
          uint64_t v14 = CGPDFNodeGetTextRange(v9);
        }
        if (TextRange > v14)
        {
          uint64_t v18 = v14;
          uint64_t v19 = TextRange - v14 + v8;
          uint64_t TextRange = v14;
        }
      }
LABEL_17:
      if ((*(unsigned char *)(v9 + 1) & 2) != 0 && (a1 + 1) < *(_DWORD *)(v9 + 44))
      {
        StringForRanges = CGPDFLayoutCreateStringForRanges(*a3, (uint64_t)&v18, 1);
        CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, StringForRanges);
        CFStringTrimWhitespace(MutableCopy);
        CFStringGetLength(MutableCopy);
        CFRelease(MutableCopy);
        CFRelease(StringForRanges);
        return v18;
      }
    }
  }
  return TextRange;
}

uint64_t mapNoneToHTML()
{
  return 1;
}

uint64_t computeATRRecord(uint64_t result, int *a2, int a3, int a4)
{
  uint64_t v4 = (float32x2_t *)*((void *)a2 + 1);
  int v5 = *a2;
  *(void *)uint64_t result = a2;
  *(void *)(result + 64) = 0;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  float64x2_t v6 = 0uLL;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  if (a4 >= 1)
  {
    int v7 = 0;
    double v8 = 0.0;
    float v9 = 0.0;
    float v10 = 0.0;
    uint64_t v11 = &v4[a3];
    float v12 = 0.0;
    float v13 = 0.0;
    float64x2_t v14 = 0uLL;
    while (1)
    {
      float32x2_t v15 = *v11;
      if (!v7)
      {
        *(_DWORD *)(result + 56) = v15.i32[0];
        *(float32x2_t *)(result + 64) = v15;
        uint64_t v18 = (__int32 *)(result + 60);
        __int32 v19 = v15.i32[1];
        float v20 = v15.f32[1];
        float v12 = v15.f32[1];
        float v10 = v15.f32[0];
        float v9 = v15.f32[0];
LABEL_12:
        *uint64_t v18 = v19;
        float v13 = v20;
        goto LABEL_13;
      }
      if (v15.f32[0] >= v9)
      {
        uint64_t v16 = (_DWORD *)(result + 64);
        LODWORD(v17) = *(float32x2_t *)v11->f32;
        if (v15.f32[0] <= v10) {
          goto LABEL_9;
        }
      }
      else
      {
        uint64_t v16 = (_DWORD *)(result + 56);
        float v17 = v10;
        LODWORD(v9) = *(float32x2_t *)v11->f32;
      }
      _DWORD *v16 = v15.i32[0];
      float v10 = v17;
LABEL_9:
      __int32 v19 = v15.i32[1];
      if (v15.f32[1] < v12)
      {
        uint64_t v18 = (__int32 *)(result + 60);
        float v20 = v13;
        float v12 = v15.f32[1];
        goto LABEL_12;
      }
      uint64_t v18 = (__int32 *)(result + 68);
      float v20 = v15.f32[1];
      if (v15.f32[1] > v13) {
        goto LABEL_12;
      }
LABEL_13:
      float64x2_t v6 = vaddq_f64(v6, vcvtq_f64_f32(v15));
      float64x2_t v14 = vaddq_f64(v14, vcvtq_f64_f32(vmul_f32(v15, v15)));
      double v8 = v8 + vmul_lane_f32(v15, v15, 1).f32[0];
      int v21 = a3 + 1;
      ++v11;
      if (a3 + 1 < v5) {
        ++a3;
      }
      else {
        a3 = 0;
      }
      if (v21 >= v5) {
        uint64_t v11 = v4;
      }
      if (a4 == ++v7)
      {
        *(float64x2_t *)(result + 16) = v6;
        *(float64x2_t *)(result + 32) = v14;
        *(double *)(result + 48) = v8;
        return result;
      }
    }
  }
  return result;
}

uint64_t ATRLinearRegression(uint64_t a1, BOOL *a2, float *a3, float *a4)
{
  double v4 = (float)(1.0 / (float)*(int *)(a1 + 12));
  double v6 = *(double *)(a1 + 16);
  double v5 = *(double *)(a1 + 24);
  double v7 = v5 * v4;
  float v8 = v5 * v4;
  double v9 = v6 * v4;
  float v10 = *(float *)(a1 + 64) - *(float *)(a1 + 56);
  float v11 = v9;
  float v12 = *(float *)(a1 + 68) - *(float *)(a1 + 60);
  if (v10 <= v12)
  {
    float v17 = *(double *)(a1 + 40) - v7 * v5;
    if (v17 != 0.0)
    {
      float v19 = *(double *)(a1 + 48) - v9 * v5;
      float v15 = v19 / v17;
      float v16 = v11 - (float)(v15 * v8);
      goto LABEL_7;
    }
    return 0;
  }
  float v13 = *(double *)(a1 + 32) - v9 * v6;
  if (v13 == 0.0) {
    return 0;
  }
  float v14 = *(double *)(a1 + 48) + -v9 * v5;
  float v15 = v14 / v13;
  float v16 = v8 - (float)(v15 * v11);
LABEL_7:
  *a2 = v10 > v12;
  *a3 = v16;
  *a4 = v15;
  return 1;
}

float ATRMaxDistanceFromLine(_DWORD *a1, int a2, float a3, float a4)
{
  int v4 = a1[3];
  if (v4 < 1) {
    return 0.0;
  }
  float v6 = 1.0 / sqrtf((float)(a4 * a4) + 1.0);
  int v7 = a1[2];
  float v8 = 0.0;
  do
  {
    uint64_t v5 = *(void *)(*(void *)a1 + 8);
    double v9 = (float *)(v5 + 8 * v7);
    if (a2) {
      float v10 = (float *)(v5 + 8 * v7);
    }
    else {
      float v10 = v9 + 1;
    }
    if (a2) {
      ++v9;
    }
    float v11 = v6 * vabds_f32(*v9, a3 + (float)(a4 * *v10));
    if (v11 > v8) {
      float v8 = v11;
    }
    if (v7 + 1 == **(_DWORD **)a1) {
      int v7 = 0;
    }
    else {
      ++v7;
    }
    --v4;
  }
  while (v4);
  return v8;
}

void ATRAngleOfLine(float a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  double v7 = atan(a1);
  if (!a6) {
    double v7 = 1.57079633 - v7;
  }
  float v8 = v7;
  __sincos_stret(v8);
}

uint64_t styleWithHighlight(uint64_t a1, void *a2)
{
  uint64_t v4 = [a2 style];
  uint64_t v5 = *(void **)(a1 + 160);
  if (v4 && CPPDFStyleEqual(v4, *(void *)(a1 + 160), 49151))
  {
    *(void *)(a1 + 160) = [a2 highlightedStyle];
  }
  else
  {
    uint64_t v6 = v5[13];
    uint64_t v7 = objc_msgSend(a2, "color", *v5, v5[1], v5[2], v5[3], v5[4], v5[5], v5[6], v5[7], v5[8], v5[9], v5[10], v5[11]);
    float v8 = malloc_type_malloc(0x70uLL, 0x10A00408C90C9C2uLL);
    double v9 = v8;
    if (v8)
    {
      v8[2] = v19;
      _OWORD v8[3] = v20;
      v8[4] = v21;
      v8[5] = v22;
      _OWORD *v8 = v17;
      v8[1] = v18;
      *((void *)v8 + 12) = v7;
      *((void *)v8 + 13) = v6;
      *((void *)v8 + 13) = v5[13];
      v5[13] = v8;
      float v10 = *(const void **)v8;
      if (*(void *)v9) {
        CFRetain(v10);
      }
      float v11 = (const void *)*((void *)v9 + 1);
      if (v11) {
        CFRetain(v11);
      }
      float v12 = (const void *)*((void *)v9 + 2);
      if (v12) {
        CFRetain(v12);
      }
      float v13 = (const void *)*((void *)v9 + 3);
      if (v13) {
        CFRetain(v13);
      }
      float v14 = (const void *)*((void *)v9 + 12);
      if (v14) {
        CFRetain(v14);
      }
      id v15 = *((id *)v9 + 8);
    }
    *(void *)(a1 + 160) = v9;
    [a2 setStyle:v5];
    [a2 setHighlightedStyle:*(void *)(a1 + 160)];
  }
  return 1;
}

BOOL canBeHighlighted(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 160) + 96) == 0;
}

double *CPPolygonBounds(double *result)
{
  uint64_t v1 = 0;
  double v2 = *result;
  double v3 = result[1];
  double v4 = v3;
  double v5 = *result;
  do
  {
    double v7 = result[v1 + 2];
    double v6 = result[v1 + 3];
    if (v7 > v2) {
      double v8 = result[v1 + 2];
    }
    else {
      double v8 = v2;
    }
    if (v7 >= v5) {
      double v2 = v8;
    }
    else {
      double v5 = result[v1 + 2];
    }
    if (v6 >= v4)
    {
      if (v6 > v3) {
        double v3 = result[v1 + 3];
      }
    }
    else
    {
      double v4 = result[v1 + 3];
    }
    v1 += 2;
  }
  while (v1 != 6);
  return result;
}

BOOL CPPointIsInsidePolygonWithBounds(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  if (a4 == INFINITY || a5 == INFINITY) {
    return 0;
  }
  v30.origin.double x = a4;
  v30.origin.y = a5;
  v30.size.CGFloat width = a6;
  v30.size.CGFloat height = a7;
  CGRect v31 = CGRectInset(v30, -0.00000011920929, -0.00000011920929);
  v29.double x = a2;
  v29.y = a3;
  BOOL result = CGRectContainsPoint(v31, v29);
  if (result)
  {
    uint64_t v12 = 0;
    double v13 = *(double *)(a1 + 48) - a2;
    double v14 = *(double *)(a1 + 56) - a3;
    double v15 = 0.0;
    double v16 = 1.0;
    *(double *)&unint64_t v17 = -1.57079633;
    double v18 = -1.0;
    double v28 = a2;
    while (1)
    {
      double v19 = *(double *)(a1 + v12) - a2;
      double v20 = *(double *)(a1 + v12 + 8) - a3;
      double v21 = sqrt(v14 * v14 + v13 * v13);
      double v22 = sqrt(v20 * v20 + v19 * v19);
      if (v21 < 0.00000011920929 || v22 < 0.00000011920929) {
        break;
      }
      double v24 = (v13 * v20 - v14 * v19) / v21 / v22;
      double v25 = 1.57079633;
      if (v24 < v16)
      {
        double v25 = *(double *)&v17;
        if (v24 > v18)
        {
          double v26 = a3;
          unint64_t v27 = v17;
          double v25 = asin(v24);
          double v18 = -1.0;
          unint64_t v17 = v27;
          a3 = v26;
          a2 = v28;
          double v16 = 1.0;
        }
      }
      if (v14 * v20 + v13 * v19 < 0.0)
      {
        if (fabs(v25) < 0.00000011920929) {
          return 1;
        }
        double v25 = dbl_1850CDC70[v25 > 0.0] - v25;
      }
      double v15 = v15 + v25;
      v12 += 16;
      double v14 = v20;
      double v13 = v19;
      if (v12 == 64) {
        return fabs(v15) >= 3.14159265;
      }
    }
    return 1;
  }
  return result;
}

uint64_t CPUprightRectilinearShapeWithVerticesContainingRect(double *a1, unsigned int a2, double a3, CGFloat a4, double a5, CGFloat a6)
{
  if (!a2) {
    return 0;
  }
  double width = a5;
  double x = a3;
  if (a5 < 0.0 || a6 < 0.0)
  {
    CGRect v68 = CGRectStandardize(*(CGRect *)&a3);
    double y = v68.origin.y;
    v68.origin.double x = x;
    v68.origin.double y = a4;
    v68.size.double width = width;
    v68.size.CGFloat height = a6;
    *(void *)&double v14 = (unint64_t)CGRectStandardize(v68);
    v69.origin.double x = x;
    v69.origin.double y = a4;
    v69.size.double width = width;
    v69.size.CGFloat height = a6;
    CGRect v70 = CGRectStandardize(v69);
    double v12 = v70.origin.y + v70.size.height;
    v70.origin.double x = x;
    v70.origin.double y = a4;
    v70.size.double width = width;
    v70.size.CGFloat height = a6;
    CGRect v71 = CGRectStandardize(v70);
    double x = v71.origin.x;
    double width = v71.size.width;
  }
  else
  {
    double v12 = a4 + a6;
    double y = a4;
    double v14 = a3;
  }
  int v16 = 0;
  int v17 = 0;
  int v18 = 0;
  int v19 = 0;
  int v20 = 0;
  char v21 = 0;
  char v22 = 0;
  char v23 = 0;
  char v24 = 0;
  double v25 = x + width;
  double v26 = *a1;
  double v27 = a1[1];
  if (y <= v12) {
    double v28 = y;
  }
  else {
    double v28 = v12;
  }
  if (y <= v12) {
    double v29 = v12;
  }
  else {
    double v29 = y;
  }
  if (v14 <= v25) {
    double v30 = v14;
  }
  else {
    double v30 = x + width;
  }
  if (v14 <= v25) {
    double v31 = x + width;
  }
  else {
    double v31 = v14;
  }
  unsigned int v32 = a2;
  do
  {
    double v33 = v26;
    double v34 = v27;
    if (v16 + 1 < a2) {
      ++v16;
    }
    else {
      int v16 = 0;
    }
    uint64_t v35 = &a1[2 * v16];
    double v26 = *v35;
    double v27 = v35[1];
    if (vabdd_f64(v33, *v35) <= vabdd_f64(v34, v27))
    {
      if (v34 <= v27) {
        double v46 = v34;
      }
      else {
        double v46 = v35[1];
      }
      if (v34 <= v27) {
        double v47 = v35[1];
      }
      else {
        double v47 = v34;
      }
      BOOL v48 = v46 > v28 || v28 > v47;
      if (!v48 || (v28 <= v46 ? (BOOL v49 = v46 > v29) : (BOOL v49 = 1), !v49))
      {
        if (v33 <= v14)
        {
          if (v27 - v34 >= 0.0) {
            int v61 = 0;
          }
          else {
            int v61 = -1;
          }
          if (v27 - v34 > 0.0) {
            int v61 = 1;
          }
          BOOL v62 = v20 == 2;
          BOOL v63 = v61 == v18;
          BOOL v64 = !v62 || !v63;
          if (v62 && v63) {
            char v65 = 0;
          }
          else {
            char v65 = v61;
          }
          v23 += v65;
          if (v64) {
            int v18 = v61;
          }
          int v20 = 2;
        }
        else
        {
          if (v33 < v25) {
            return 0;
          }
          if (v34 - v27 >= 0.0) {
            int v50 = 0;
          }
          else {
            int v50 = -1;
          }
          if (v34 - v27 > 0.0) {
            int v50 = 1;
          }
          BOOL v51 = v20 == 4;
          BOOL v52 = v50 == v18;
          BOOL v53 = !v51 || !v52;
          if (v51 && v52) {
            char v54 = 0;
          }
          else {
            char v54 = v50;
          }
          v21 += v54;
          if (v53) {
            int v18 = v50;
          }
          int v20 = 4;
        }
      }
    }
    else
    {
      if (v33 <= v26) {
        double v36 = v33;
      }
      else {
        double v36 = *v35;
      }
      if (v33 <= v26) {
        double v37 = *v35;
      }
      else {
        double v37 = v33;
      }
      BOOL v38 = v36 > v30 || v30 > v37;
      if (!v38 || (v30 <= v36 ? (BOOL v39 = v36 > v31) : (BOOL v39 = 1), !v39))
      {
        if (v34 <= y)
        {
          double v55 = v33 - v26;
          if (v55 >= 0.0) {
            int v56 = 0;
          }
          else {
            int v56 = -1;
          }
          if (v55 > 0.0) {
            int v56 = 1;
          }
          BOOL v57 = v20 == 1;
          BOOL v58 = v56 == v18;
          BOOL v59 = !v57 || !v58;
          if (v57 && v58) {
            char v60 = 0;
          }
          else {
            char v60 = v56;
          }
          v24 += v60;
          if (v59) {
            int v18 = v56;
          }
          int v20 = 1;
        }
        else
        {
          if (v34 < v12) {
            return 0;
          }
          double v40 = v26 - v33;
          if (v40 >= 0.0) {
            int v41 = 0;
          }
          else {
            int v41 = -1;
          }
          if (v40 > 0.0) {
            int v41 = 1;
          }
          BOOL v42 = v20 == 3;
          BOOL v43 = v41 == v18;
          BOOL v44 = !v42 || !v43;
          if (v42 && v43) {
            char v45 = 0;
          }
          else {
            char v45 = v41;
          }
          v22 += v45;
          if (v44) {
            int v18 = v41;
          }
          int v20 = 3;
        }
      }
    }
    if (v19 == 0 && v20 != 0)
    {
      int v19 = v20;
      int v17 = v18;
    }
    --v32;
  }
  while (v32);
  if (v19 == v20 && v17 == v18)
  {
    switch(v20)
    {
      case 1:
        v24 -= v18;
        break;
      case 2:
        v23 -= v18;
        break;
      case 3:
        v22 -= v18;
        break;
      case 4:
        v21 -= v18;
        break;
      default:
        break;
    }
  }
  int v66 = v23 & 1;
  unsigned int v67 = v21 & 1;
  if ((v22 & 1) == 0) {
    unsigned int v67 = 0;
  }
  if (!v66) {
    unsigned int v67 = 0;
  }
  if (v24) {
    return v67;
  }
  else {
    return 0;
  }
}

double CGIntervalIntersection(double a1, double a2, double a3, double a4)
{
  double v5 = fabs(a1);
  double v6 = fabs(a3);
  double result = INFINITY;
  BOOL v8 = v5 == INFINITY || v6 == INFINITY;
  if (!v8)
  {
    double v9 = -a2;
    if (a2 >= 0.0)
    {
      double v9 = a2;
      a2 = -0.0;
    }
    double v10 = a1 + a2;
    double v11 = -a4;
    if (a4 >= 0.0)
    {
      double v11 = a4;
      a4 = -0.0;
    }
    double v12 = a3 + a4;
    if (v10 < v12) {
      double v13 = v12;
    }
    else {
      double v13 = v10;
    }
    double v14 = v9 + v10;
    if (v14 > v11 + v12) {
      double v14 = v11 + v12;
    }
    BOOL v8 = v13 == v14;
    BOOL v15 = v13 < v14;
    double result = INFINITY;
    if (v15 || v8) {
      return v13;
    }
  }
  return result;
}

double CGIntervalExclusion(uint64_t a1, double result, double a3, double a4, double a5)
{
  double v5 = a3;
  *(_OWORD *)a1 = CGIntervalNull;
  double v6 = fabs(a4);
  if (fabs(result) != INFINITY && v6 != INFINITY)
  {
    double v8 = -a3;
    if (v5 >= 0.0)
    {
      double v8 = v5;
      double v5 = -0.0;
    }
    double result = result + v5;
    double v9 = -a5;
    if (a5 >= 0.0)
    {
      double v9 = a5;
      a5 = -0.0;
    }
    double v10 = a4 + a5;
    if (v10 <= result)
    {
      double v13 = v9 + v10;
      if (v13 > result)
      {
        BOOL v14 = v13 < v8 + result;
        double result = INFINITY;
        if (v14) {
          return v13;
        }
      }
    }
    else
    {
      double v11 = v8 + result;
      if (v10 < v8 + result)
      {
        double v12 = v9 + v10;
        if (v9 + v10 < v11)
        {
          *(double *)a1 = v12;
          *(double *)(a1 + 8) = v11 - v12;
        }
      }
    }
  }
  return result;
}

uint64_t CGPDFGetUnicharsForGlyphName(char *__s, int a2, _WORD *a3)
{
  if (!__s) {
    goto LABEL_20;
  }
  if (!strchr(__s, 46) && !strchr(__s, 95))
  {
    uint64_t v17 = component_to_unichars(__s, a2, a3);
    if (v17) {
      return v17;
    }
    goto LABEL_20;
  }
  size_t v6 = strlen(__s);
  if (!v6) {
    goto LABEL_20;
  }
  double v7 = (char *)malloc_type_malloc(v6 + 1, 0xD2128C92uLL);
  if (!v7) {
    goto LABEL_20;
  }
  double v8 = v7;
  double v9 = strcpy(v7, __s);
  double v10 = strchr(v9, 46);
  if (v10) {
    *double v10 = 0;
  }
  uint64_t v11 = 0;
  for (uint64_t i = v8; ; uint64_t i = v14)
  {
    double v13 = strchr(i, 95);
    if (!v13) {
      break;
    }
    *double v13 = 0;
    BOOL v14 = v13 + 1;
    if (a3) {
      BOOL v15 = &a3[v11];
    }
    else {
      BOOL v15 = 0;
    }
    v11 += component_to_unichars(i, a2, v15);
  }
  int v16 = a3 ? &a3[v11] : 0;
  uint64_t v17 = component_to_unichars(i, a2, v16) + v11;
  free(v8);
  if (!v17)
  {
LABEL_20:
    uint64_t v18 = CGPDFGetUnicharGuessForGlyphName(__s, a3);
    uint64_t v17 = v18;
    if (a3 && !v18) {
      pdf_log("%s: no mapping.\n", __s);
    }
  }
  return v17;
}

uint64_t component_to_unichars(const char *a1, int a2, _WORD *a3)
{
  size_t v6 = strlen(a1);
  if (a2)
  {
    double v7 = bsearch(a1, &ZapfDingbats, 0xC9uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
    if (v7)
    {
      if (a3)
      {
        LOWORD(v8) = v7[4];
LABEL_8:
        *a3 = v8;
      }
      return 1;
    }
  }
  double v9 = (unsigned __int16 *)bsearch(a1, &AGL, 0x1104uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
  if (v9)
  {
    int v8 = v9[4];
    if (v8 != 0xFFFF)
    {
      if (a3) {
        goto LABEL_8;
      }
      return 1;
    }
    uint64_t v11 = (char *)bsearch(a1, &AGLExtended, 0x51uLL, 0x18uLL, (int (__cdecl *)(const void *, const void *))unicode_entry_compare);
    if (!v11) {
      _CGHandleAssert("agl_to_unichars", 82, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Text/Unicode/CGPDFUnicodeTable.c", "extended_entry != NULL", "extended entry missing", v12, v13, v14, v39);
    }
    uint64_t v10 = *((void *)v11 + 1);
    if (a3)
    {
      if (!v10) {
        goto LABEL_16;
      }
      BOOL v15 = (__int16 *)(v11 + 16);
      uint64_t v16 = *((void *)v11 + 1);
      uint64_t v17 = a3;
      do
      {
        __int16 v18 = *v15++;
        *v17++ = v18;
        --v16;
      }
      while (v16);
    }
    if (v10) {
      return v10;
    }
  }
LABEL_16:
  if (v6 < 4) {
    return 0;
  }
  if (strncmp(a1, "uni", 3uLL) || (((_BYTE)v6 + 1) & 3) != 0)
  {
    if (v6 - 5 <= 2 && *a1 == 117)
    {
      unsigned int v19 = 0;
      size_t v20 = v6 - 1;
      char v21 = (char *)(a1 + 1);
      uint64_t v22 = MEMORY[0x1E4F14390];
      do
      {
        int v23 = *v21++;
        unsigned int v24 = v23;
        if (v23 < 0)
        {
          if (!__maskrune_l(v24, 0x10000uLL, 0) || __maskrune_l(v24, 0x1000uLL, 0)) {
            return 0;
          }
          uint64_t v26 = __maskrune_l(v24, 0x400uLL, 0);
        }
        else
        {
          int v25 = *(_DWORD *)(v22 + 4 * v24 + 60);
          if ((v25 & 0x11000) != 0x10000) {
            return 0;
          }
          uint64_t v26 = v25 & 0x400;
        }
        if (v26) {
          int v27 = -48;
        }
        else {
          int v27 = -55;
        }
        unsigned int v19 = v27 + 16 * v19 + v24;
        --v20;
      }
      while (v20);
      if (HIWORD(v19)) {
        BOOL v28 = 1;
      }
      else {
        BOOL v28 = (v19 & 0xFFFFF800) == 55296;
      }
      if (!v28)
      {
        if (a3) {
          *a3 = v19;
        }
        return 1;
      }
      if (!((v19 - 0x10000) >> 20))
      {
        if (a3)
        {
          *a3 = (v19 >> 10) - 10304;
          a3[1] = v19 & 0x3FF | 0xDC00;
        }
        return 2;
      }
    }
    return 0;
  }
  uint64_t v10 = 0;
  double v30 = a1 + 3;
  uint64_t v31 = 3;
  uint64_t v32 = MEMORY[0x1E4F14390];
  do
  {
    uint64_t v40 = v31;
    uint64_t v33 = 0;
    unsigned int v34 = 0;
    do
    {
      __darwin_ct_rune_t v35 = v30[v33];
      if (v30[v33] < 0)
      {
        if (!__maskrune_l(v30[v33], 0x10000uLL, 0) || __maskrune_l(v35, 0x1000uLL, 0)) {
          return v10;
        }
        uint64_t v37 = __maskrune_l(v35, 0x400uLL, 0);
      }
      else
      {
        int v36 = *(_DWORD *)(v32 + 4 * v30[v33] + 60);
        if ((v36 & 0x11000) != 0x10000) {
          return v10;
        }
        uint64_t v37 = v36 & 0x400;
      }
      if (v37) {
        int v38 = -48;
      }
      else {
        int v38 = -55;
      }
      unsigned int v34 = v38 + 16 * v34 + v35;
      ++v33;
    }
    while (v33 != 4);
    if (v34 >> 11 == 27) {
      break;
    }
    if (a3) {
      *a3++ = v34;
    }
    ++v10;
    uint64_t v31 = v40 + 4;
    v30 += 4;
  }
  while (v40 + 4 < v6);
  return v10;
}

uint64_t unicode_entry_compare(const char *a1, const char **a2)
{
  return strcmp(a1, *a2);
}

uint64_t FilterStream::setPos(FilterStream *this)
{
  return error(-1, "Internal: called setPos() on FilterStream");
}

uint64_t CGPDFSourceStream::getStart(CGPDFSourceStream *this)
{
  return 0;
}

uint64_t CGPDFSourceStream::lookChar(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (unsigned __int8 *)*((void *)this + 3);
  unint64_t v9 = *((void *)this + 4);
  if ((unint64_t)v8 >= v9
    && (uint64_t v11 = (char *)this + 40,
        *((void *)this + 517) += v9 - ((void)this + 40),
        *((void *)this + 3) = (char *)this + 40,
        *((void *)this + 4) = (char *)this + 40,
        uint64_t v12 = CGPDFSourceRead(*((void *)this + 2), (uint64_t)this + 40, 0x1000uLL, a4, a5, a6, a7, a8),
        *((void *)this + 4) = &v11[v12],
        int v8 = (unsigned __int8 *)*((void *)this + 3),
        v8 >= (unsigned __int8 *)&v11[v12]))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return *v8;
  }
}

uint64_t CGPDFSourceStream::isBinary(CGPDFSourceStream *this)
{
  return 1;
}

uint64_t CGPDFSourceStream::getPos(CGPDFSourceStream *this)
{
  return (*((_DWORD *)this + 1034) - this + *((_DWORD *)this + 6) - 40);
}

uint64_t CGPDFSourceStream::getChar(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = (unsigned __int8 *)*((void *)this + 3);
  unint64_t v10 = *((void *)this + 4);
  if ((unint64_t)v9 >= v10)
  {
    uint64_t v11 = (char *)this + 40;
    *((void *)this + 517) += v10 - ((void)this + 40);
    *((void *)this + 3) = (char *)this + 40;
    *((void *)this + 4) = (char *)this + 40;
    uint64_t v12 = CGPDFSourceRead(*((void *)this + 2), (uint64_t)this + 40, 0x1000uLL, a4, a5, a6, a7, a8);
    *((void *)this + 4) = &v11[v12];
    unint64_t v9 = (unsigned __int8 *)*((void *)this + 3);
    if (v9 >= (unsigned __int8 *)&v11[v12]) {
      return 0xFFFFFFFFLL;
    }
  }
  *((void *)this + 3) = v9 + 1;
  return *v9;
}

uint64_t CGPDFSourceStream::reset(CGPDFSourceStream *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = CGPDFSourceRewind(*((void *)this + 2), a2, a3, a4, a5, a6, a7, a8);
  *((void *)this + 3) = (char *)this + 40;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 517) = 0;
  return result;
}

void CGPDFSourceStream::~CGPDFSourceStream(CGPDFSourceStream *this)
{
  *(void *)this = &unk_1ED093888;
  JUMPOUT(0x18532A2A0);
}

{
  *(void *)this = &unk_1ED093888;
}

ssize_t file_provider_get_bytes_at_position(int a1, void *a2, off_t a3, size_t __nbyte)
{
  ssize_t v4 = pread(a1, a2, __nbyte, a3);
  return v4 & ~(v4 >> 63);
}

void free_data_10126(int a1, void *a2)
{
}

void unmap_file(int a1, void *a2, size_t a3)
{
  char v3 = (char)a2;
  if (munmap(a2, a3) < 0)
  {
    ssize_t v4 = __error();
    strerror(*v4);
    CGPostError((uint64_t)"Failed to unmap data (%p; 0x%lx): %s.\n", v5, v6, v7, v8, v9, v10, v11, v3);
  }
}

void PDFXRefTableCreate2()
{
}

void sub_184EEC76C(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x1020C404A1ECDA0);
  _Unwind_Resume(a1);
}

uint64_t PDFXRefTableRelease(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    double v2 = *(void **)(result + 16);
    if (v2)
    {
      *(void *)(v1 + 24) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

unsigned char *PDFXRefTableEmit(unsigned char *result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v10 = result;
    CGDataConsumerPrintf((unsigned char *)a2, "xref\n", (uint64_t)a3, a4, a5, a6, a7, a8, v26);
    uint64_t result = CGDataConsumerPrintf((unsigned char *)a2, "%lu %zu\n", v11, v12, v13, v14, v15, v16, v10[1]);
    if (a3)
    {
      if (a2) {
        uint64_t v23 = *(void *)(a2 + 48);
      }
      else {
        uint64_t v23 = 0;
      }
      *a3 = v23;
    }
    unsigned int v24 = (uint64_t *)v10[2];
    if (!v10[1])
    {
      uint64_t result = CGDataConsumerPrintf((unsigned char *)a2, "%010u 65535 f \n", v17, v18, v19, v20, v21, v22, 0);
      v24 += 2;
    }
    for (;
          (unint64_t)v24 < v10[3];
          uint64_t result = CGDataConsumerPrintf((unsigned char *)a2, "%010llu 00000 n \n", v17, v18, v19, v20, v21, v22, v25))
    {
      uint64_t v25 = *v24;
      v24 += 2;
    }
  }
  return result;
}

uint64_t PDFXRefTableAddObject(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = a1[2];
  double v2 = (void *)a1[3];
  uint64_t v4 = ((uint64_t)v2 - v3) >> 4;
  unint64_t v5 = a1[4];
  if ((unint64_t)v2 >= v5)
  {
    unint64_t v7 = v4 + 1;
    if ((unint64_t)(v4 + 1) >> 60) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v8 = v5 - v3;
    if (v8 >> 3 > v7) {
      unint64_t v7 = v8 >> 3;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v7;
    }
    uint64_t v10 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v9);
    uint64_t v11 = &v10[16 * v4];
    uint64_t v13 = &v10[16 * v12];
    uint64_t v6 = v11 + 16;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    uint64_t v15 = (char *)a1[2];
    uint64_t v14 = (char *)a1[3];
    if (v14 != v15)
    {
      do
      {
        *((_OWORD *)v11 - 1) = *((_OWORD *)v14 - 1);
        v11 -= 16;
        v14 -= 16;
      }
      while (v14 != v15);
      uint64_t v14 = (char *)a1[2];
    }
    a1[2] = v11;
    a1[3] = v6;
    a1[4] = v13;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    uint64_t v6 = v2 + 2;
    *double v2 = 0;
    v2[1] = 0;
  }
  a1[3] = v6;
  return v4;
}

BOOL CGPointEqualToPoint(CGPoint point1, CGPoint point2)
{
  return point1.y == point2.y && point1.x == point2.x;
}

BOOL CGRectIsIntegral(double a1, double a2, double a3, double a4)
{
  if (a1 == INFINITY || a2 == INFINITY) {
    return 1;
  }
  if (a1 == (double)(int)a1 && a2 == (double)(int)a2 && a3 == (double)(int)a3) {
    return a4 == (double)(int)a4;
  }
  return 0;
}

double __RIPStyleFocusRing_block_invoke()
{
  rips_f_cs = (uint64_t)CGColorSpaceCreateDeviceGray();
  if (rips_f_cs)
  {
    double result = *(double *)&_rips_class;
    *(void *)&RIPStyleFocusRing_rips_f_cls = rips_f_super;
    *((void *)&RIPStyleFocusRing_rips_f_cls + 1) = rips_f_size;
    unk_1E8F9D520 = off_1ED097580[0];
    qword_1E8F9D528 = (uint64_t)rips_f_release;
    qword_1E8F9D530 = (uint64_t)rips_f_Create;
    qword_1E8F9D538 = (uint64_t)rips_f_Growth;
    qword_1E8F9D540 = (uint64_t)rips_f_ColorSpace;
    qword_1E8F9D548 = (uint64_t)rips_f_BltShape;
    qword_1E8F9D550 = (uint64_t)rips_f_BltGlyph;
    qword_1E8F9D558 = (uint64_t)rips_f_BltImage;
    qword_1E8F9D560 = (uint64_t)rips_f_BltShade;
  }
  return result;
}

uint64_t (**rips_f_BltShade(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  uint64_t v8 = (int *)(a3 + 12);
  if (!a3) {
    uint64_t v8 = (int *)(a2 + 12);
  }
  if (a4) {
    uint64_t v8 = a4;
  }
  if (a5) {
    uint64_t v8 = (int *)a5;
  }
  return rips_f_DrawRing(a1, a2, a3, a4, v8, 0, 0, 0, a5, a6, a7, a8);
}

uint64_t (**rips_f_DrawRing(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10, _DWORD *a11, uint64_t a12))()
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  int64x2_t v124 = 0uLL;
  long long v12 = *(_OWORD *)(a12 + 48);
  v127[2] = *(_OWORD *)(a12 + 32);
  long long v128 = v12;
  uint64_t v129 = *(void *)(a12 + 64);
  long long v13 = *(_OWORD *)(a12 + 16);
  v127[0] = *(_OWORD *)a12;
  v127[1] = v13;
  int v14 = vcvtmd_s64_f64(*(double *)(a1 + 96) + 0.5);
  if (v14 < 1) {
    return 0;
  }
  uint64_t v15 = a8;
  uint64_t v16 = a6;
  uint64_t v17 = a4;
  double v121 = a11;
  uint64_t v122 = a10;
  uint64_t v118 = a9;
  unsigned int v119 = a7;
  int64x2_t v125 = 0uLL;
  uint64_t v120 = a6;
  if (!a4 || a4 == a5)
  {
    int64x2_t v125 = *(int64x2_t *)a5;
    if (!v125.i32[2] || !v125.i32[3]) {
      goto LABEL_37;
    }
  }
  else if (!CGSBoundsIntersection(a4, a5, &v125))
  {
    goto LABEL_37;
  }
  if (*(unsigned char *)(a1 + 136))
  {
    if (a3)
    {
      if (!CGSBoundsIntersection((int *)(a3 + 12), v125.i32, &v124)) {
        goto LABEL_37;
      }
    }
    else
    {
      int64x2_t v124 = v125;
    }
    v22.i64[0] = 0xFFFFFFFF00000000;
    v22.i64[1] = 0xFFFFFFFF00000000;
    int64x2_t v124 = vaddq_s64((int64x2_t)vbslq_s8(v22, (int8x16_t)v124, (int8x16_t)vaddq_s64(v124, (int64x2_t)xmmword_1850CDC80)), (int64x2_t)xmmword_1850CDC90);
  }
  else
  {
    *(_OWORD *)uint64_t v130 = 0uLL;
    uint64_t v21 = (int *)(a2 + 12);
    if (a3)
    {
      if ((CGSBoundsIntersection(v21, (int *)(a3 + 12), v130) & 1) == 0) {
        goto LABEL_37;
      }
    }
    else
    {
      *(_OWORD *)uint64_t v130 = *(_OWORD *)v21;
      if (!LODWORD(v130[2]) || !LODWORD(v130[3])) {
        goto LABEL_37;
      }
    }
    v125.i64[0] = (v125.i32[0] + ~v14) | ((unint64_t)(v125.i32[1] + ~v14) << 32);
    v125.i64[1] = (v125.i32[2] - 2 * ~v14) | ((unint64_t)(v125.i32[3] - 2 * ~v14) << 32);
    LODWORD(v130[0]) += ~v14;
    LODWORD(v130[1]) += ~v14;
    LODWORD(v130[2]) -= 2 * ~v14;
    LODWORD(v130[3]) -= 2 * ~v14;
    if (!CGSBoundsIntersection(v125.i32, (int *)v130, &v124))
    {
LABEL_37:
      int v27 = *(char **)(a1 + 144);
      *(void *)(a1 + 144) = 0;
      goto LABEL_38;
    }
  }
  uint64_t v23 = v15;
  unsigned int v24 = *(uint64_t **)(a1 + 144);
  if (v24)
  {
    v124.i64[0] = CGSBoundsUnion(v124.i64[0], v124.i64[1], *(uint64_t *)((char *)v24 + 12), *(uint64_t *)((char *)v24 + 20));
    v124.i64[1] = v25;
    char v26 = RIPLayerCreateWithLayer((uint64_t)RIPLayer_ripl_class, v124.i64, v24, *(unsigned int *)(a2 + 52));
    if (v26)
    {
      int v27 = v26;
      uint64_t v28 = *(void *)(a1 + 144);
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
      }
      *(void *)(a1 + 144) = 0;
      goto LABEL_23;
    }
    return 0;
  }
  int v27 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v124, 0, 0, *(unsigned int *)(a2 + 52), a6, (uint64_t)a7, a8);
  if (!v27) {
    return 0;
  }
LABEL_23:
  uint64_t v117 = a3;
  if (v119) {
    int v29 = 2;
  }
  else {
    int v29 = 1;
  }
  LODWORD(v127[0]) = v29;
  *(void *)&long long v128 = 0x3FF0000000000000;
  double v30 = (char *)v122;
  if (v122)
  {
    uint64_t v31 = *(uint64_t (***)())v122;
    if (*(void *)v122)
    {
      double v30 = (char *)v122;
      while (v31 != RIPLayer_ripl_class)
      {
        if (*v31)
        {
          uint64_t v31 = (uint64_t (**)())(*v31)();
          if (v31) {
            continue;
          }
        }
        goto LABEL_32;
      }
      if (*(_DWORD *)(v122 + 64))
      {
        double v30 = RIPLayerConvertLayer((uint64_t)RIPLayer_ripl_class, *(_DWORD *)(v122 + 28) & 8, v122, *(unsigned int *)(a2 + 52));
        if (!v30) {
          goto LABEL_178;
        }
      }
    }
  }
LABEL_32:
  if (v120)
  {
    unsigned __int8 v32 = RIPLayerBltShape((int *)v27, 0, 0, v120, (uint64_t)v30, v121, (uint64_t)v127, a8);
LABEL_172:
    char v107 = v32;
    goto LABEL_173;
  }
  if (v119)
  {
    unsigned __int8 v32 = RIPLayerBltGlyph(v27, 0, 0, v119, (uint64_t)v30, v121, 0, (uint64_t)v127);
    goto LABEL_172;
  }
  if (v23)
  {
    unsigned __int8 v32 = RIPLayerBltImage((uint64_t)v27, 0, 0, v23, (uint64_t)v127, a6, (uint64_t)a7, a8);
    goto LABEL_172;
  }
  if (v118)
  {
    unsigned __int8 v32 = RIPLayerBltShade((uint64_t)v27, 0, 0, v118, (uint64_t)v30, (uint64_t)v127, (uint64_t)a7, a8);
    goto LABEL_172;
  }
  char v107 = 1;
LABEL_173:
  if (v30 != (char *)v122 && v30) {
    (*(void (**)(char *))(*(void *)v30 + 24))(v30);
  }
  if ((v107 & 1) == 0) {
    goto LABEL_178;
  }
  a3 = v117;
  uint64_t v15 = v23;
  uint64_t v16 = v120;
LABEL_38:
  if (*(_DWORD *)(a1 + 112) == 2 && (*(unsigned char *)(a1 + 13) & 0x10) == 0)
  {
    if (v16)
    {
      uint64_t v33 = (uint64_t)RIPLayerBltShape((int *)a2, a3, v17, v16, v122, v121, a12, a8);
      goto LABEL_55;
    }
    if (v119)
    {
      uint64_t v33 = (uint64_t)RIPLayerBltGlyph((_DWORD *)a2, a3, v17, v119, v122, v121, 0, a12);
      goto LABEL_55;
    }
    if (v15)
    {
      uint64_t v33 = RIPLayerBltImage(a2, a3, (uint64_t)v17, v15, a12, a6, (uint64_t)a7, a8);
      goto LABEL_55;
    }
    if (v118)
    {
      uint64_t v33 = (uint64_t)RIPLayerBltShade(a2, a3, (uint64_t)v17, v118, v122, a12, (uint64_t)a7, a8);
LABEL_55:
      uint64_t v34 = v33;
      if (!v27) {
        goto LABEL_59;
      }
      goto LABEL_58;
    }
  }
  uint64_t v34 = 1;
  if (v27)
  {
LABEL_58:
    int64x2_t v124 = *(int64x2_t *)(v27 + 12);
    v124.i32[0] -= v14;
    v124.i32[1] -= v14;
    v124.i32[2] += 2 * v14;
    v124.i32[3] += 2 * v14;
  }
LABEL_59:
  if (!*(unsigned char *)(a1 + 136)
    || (int v35 = *(_DWORD *)(a1 + 132), v36 = __OFSUB__(v35, 1), --v35, *(_DWORD *)(a1 + 132) = v35, (v35 < 0) ^ v36))
  {
    if (v27) {
      int v37 = v34;
    }
    else {
      int v37 = 0;
    }
    if (v37 != 1)
    {
      if (!v27) {
        goto LABEL_117;
      }
      goto LABEL_116;
    }
    if (*(_DWORD *)(a1 + 124)
      && *(_DWORD *)(a1 + 128)
      && !CGSBoundsIntersection(v124.i32, (int *)(a1 + 116), &v124))
    {
      uint64_t v34 = 1;
LABEL_116:
      (*(void (**)(char *))(*(void *)v27 + 24))(v27);
      goto LABEL_117;
    }
    if (rips_f_DrawRing_onceToken != -1) {
      dispatch_once(&rips_f_DrawRing_onceToken, &__block_literal_global_3_10224);
    }
    if (rips_f_DrawRing_debug_focus_ring_masks) {
      RIPLayerSaveTGA((uint64_t)v27, "/tmp/original_mask");
    }
    int v123 = 0;
    if (!get_integer_property("CGFocusRingStyle", (const void *(*)(const char *))copy_local_domain_value, &v123)|| v123 == 1)
    {
      double v47 = rips_f_BlurRingRoundedDilation((uint64_t)v27, v14, *(double *)(a1 + 104));
      goto LABEL_81;
    }
    if (!v123)
    {
      uint64_t v115 = v15;
      uint64_t v116 = a2;
      uint64_t v117 = a3;
      double v41 = *(double *)(a1 + 104);
      long long v126 = *(_OWORD *)(v27 + 12);
      int v42 = *((_DWORD *)v27 + 5);
      int v43 = *((_DWORD *)v27 + 6);
      uint64_t v44 = *((unsigned int *)v27 + 12);
      uint64_t v45 = *((void *)v27 + 7);
      if (v44 < 0x401) {
        double v46 = v130;
      }
      else {
        double v46 = (float *)malloc_type_malloc(*((unsigned int *)v27 + 12), 0x195C97C4uLL);
      }
      if (v43)
      {
        unsigned int v80 = 0;
        unsigned int v81 = vcvtmd_s64_f64(v41 * 255.0);
        uint64_t v82 = v45 + v44;
        while (!v42)
        {
LABEL_155:
          v45 += v44;
          ++v80;
          v82 += v44;
          if (v80 == v43) {
            goto LABEL_156;
          }
        }
        uint64_t v83 = 0;
        while (1)
        {
          unsigned int v84 = *(unsigned __int8 *)(v45 + v83);
          if (v81 > v84) {
            break;
          }
          LOBYTE(v87) = 0;
LABEL_154:
          *(unsigned char *)(v45 + v83) = v87;
          *((unsigned char *)v46 + v83++) = v84;
          if (v42 == v83) {
            goto LABEL_155;
          }
        }
        if (v80)
        {
          unsigned int v85 = *((unsigned __int8 *)v46 + v83);
          if (v83)
          {
LABEL_134:
            unsigned int v86 = *((unsigned __int8 *)v46 + v83 - 1);
LABEL_138:
            if (v83 >= v42 - 1) {
              unsigned int v88 = 0;
            }
            else {
              unsigned int v88 = *(unsigned __int8 *)(v45 + v83 + 1);
            }
            if (v80 >= v43 - 1) {
              unsigned int v89 = 0;
            }
            else {
              unsigned int v89 = *(unsigned __int8 *)(v82 + v83);
            }
            BOOL v90 = v81 <= v89;
            int v91 = v81 <= v88 || v90;
            if (v81 > v86) {
              int v92 = v91;
            }
            else {
              int v92 = 1;
            }
            if (v81 > v85) {
              int v93 = v92;
            }
            else {
              int v93 = 1;
            }
            int v87 = v93 << 31 >> 31;
            goto LABEL_154;
          }
        }
        else
        {
          unsigned int v85 = 0;
          if (v83) {
            goto LABEL_134;
          }
        }
        unsigned int v86 = 0;
        goto LABEL_138;
      }
LABEL_156:
      if (v46 != v130) {
        free(v46);
      }
      *(void *)&long long v126 = (v126 - v14) | ((unint64_t)(DWORD1(v126) - v14) << 32);
      *((void *)&v126 + 1) = (DWORD2(v126) + 2 * v14) | ((unint64_t)(HIDWORD(v126) + 2 * v14) << 32);
      uint64_t v94 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v126, 0, 0, *((unsigned int *)v27 + 13), v38, v39, v40);
      a2 = v116;
      a3 = v117;
      uint64_t v15 = v115;
      double v47 = v94;
      if (!v94)
      {
LABEL_81:
        if (v47)
        {
          uint64_t v114 = v17;
          if (rips_f_DrawRing_debug_focus_ring_masks) {
            RIPLayerSaveTGA((uint64_t)v47, "/tmp/focus_ring_mask");
          }
          uint64_t v113 = v47;
          unint64_t v48 = *(void *)(a1 + 80);
          if (!v48)
          {
            if (default_focus_ring_color_predicate != -1) {
              dispatch_once(&default_focus_ring_color_predicate, &__block_literal_global_11_10228);
            }
            unint64_t v48 = default_focus_ring_color_focus_ring_color;
          }
          Cache = CGColorTransformGetCache(*(void **)(a12 + 16));
          uint64_t v117 = a3;
          uint64_t v115 = v15;
          if (Cache)
          {
            uint64_t v51 = Cache[2];
            if (v51)
            {
              unint64_t v52 = *(void *)(*(void *)(v51 + 24) + 48);
              if (v52 >> 61)
              {
                CFStringRef v112 = &v110;
                MEMORY[0x1F4188790](Cache, v50);
                char v60 = (double *)&v109;
                int v61 = 0;
LABEL_100:
                uint64_t v64 = *(void *)(a12 + 16);
                uint64_t v116 = a2;
                uint64_t v111 = v60;
                if (v48)
                {
                  if ((v48 & 0x8000000000000000) != 0) {
                    CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v48, v53, v54, v55, v56, v57, v58, v59);
                  }
                  else {
                    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(v48 + 24);
                  }
                }
                else
                {
                  CGColorSpaceRef ColorSpace = 0;
                }
                uint64_t v66 = *(unsigned int *)(a12 + 8);
                Components = (double *)CGColorGetComponents((CGColorRef)v48);
                if (CGColorTransformConvertColorComponents(v64, ColorSpace, v66, Components, v61))
                {
                  RIPColorCreateWithColor(*(_DWORD *)(a12 + 24), v61, v52, 1.0);
                  uint64_t v75 = v74;
                }
                else
                {
                  uint64_t v75 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
                  *uint64_t v75 = &ripc_class;
                  v75[1] = 0;
                  v75[2] = 0;
                  v75[3] = 0;
                  *((_DWORD *)v75 + 39) = 1065353216;
                }
                uint64_t v15 = v115;
                a2 = v116;
                if (v61 != v111) {
                  free(v61);
                }
                LODWORD(v127[0]) = 2;
                float v76 = *(double *)(a1 + 88);
                *(double *)&long long v128 = v76;
                if ((*(unsigned char *)(a1 + 13) & 0x10) != 0) {
                  RIPLayerDefine(a2, (__n128 *)&v124, v68, v69, v70, v71, v72, v73);
                }
                a3 = v117;
                if (*(unsigned char *)(a1 + 136)) {
                  uint64_t v77 = 0;
                }
                else {
                  uint64_t v77 = v117;
                }
                uint64_t v78 = (uint64_t)v113;
                uint64_t v34 = (uint64_t)RIPLayerBltShape((int *)a2, v77, v124.i32, (uint64_t)v113, (uint64_t)v75, 0, (uint64_t)v127, v73);
                free(v75);
                (*(void (**)(uint64_t))(*(void *)v78 + 24))(v78);
                uint64_t v17 = v114;
                goto LABEL_116;
              }
              Cache = (void *)(8 * v52);
            }
            else
            {
              unint64_t v52 = 0;
              Cache = 0;
            }
          }
          else
          {
            unint64_t v52 = 0;
          }
          CFStringRef v112 = &v110;
          size_t v62 = MEMORY[0x1F4188790](Cache, v50);
          char v60 = (double *)((char *)&v110 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0));
          if (v52 <= 0x1FFFFFFFFFFFFFFELL) {
            int v61 = (double *)((char *)&v110 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0));
          }
          else {
            int v61 = 0;
          }
          if (v52 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
            int v61 = (double *)malloc_type_malloc(v62, 0xE05F0D52uLL);
          }
          goto LABEL_100;
        }
        goto LABEL_178;
      }
      if (v14 >= 5)
      {
        uint64_t v101 = (v14 + 1);
        double v102 = 1.0;
        uint64_t v103 = (double *)malloc_type_malloc(8 * (int)v101, 0x100004000313F17uLL);
        uint64_t v104 = v103;
        *uint64_t v103 = 1.0;
        uint64_t v105 = 1;
        do
        {
          double v102 = v102 - 1.0 / (double)(int)v101;
          v103[v105++] = v102;
        }
        while (v101 != v105);
        char v106 = RIPLayerSymmetricConvolve((uint64_t)v47, (uint64_t)v27, v103, v14);
        free(v104);
        uint64_t v15 = v115;
        a2 = v116;
        if ((v106 & 1) == 0) {
          goto LABEL_161;
        }
      }
      else if ((RIPLayerSymmetricConvolve((uint64_t)v94, (uint64_t)v27, (double *)*(&off_1E52C7E90 + v14), v14) & 1) == 0)
      {
LABEL_161:
        (*(void (**)(char *))(*(void *)v47 + 24))(v47);
        double v47 = 0;
LABEL_166:
        a3 = v117;
        goto LABEL_81;
      }
      v130[0] = 0.0;
      v130[1] = (float)v14 + 1.0;
      RIPLayerResample((uint64_t)v47, v130, v95, v96, v97, v98, v99, v100);
      goto LABEL_166;
    }
LABEL_178:
    (*(void (**)(char *))(*(void *)v27 + 24))(v27);
    return 0;
  }
  *(void *)(a1 + 144) = v27;
LABEL_117:
  if (*(_DWORD *)(a1 + 112) == 1 && (*(unsigned char *)(a1 + 13) & 0x10) == 0)
  {
    if (v120) {
      return (uint64_t (**)())RIPLayerBltShape((int *)a2, a3, v17, v120, v122, v121, a12, a8);
    }
    if (v119) {
      return RIPLayerBltGlyph((_DWORD *)a2, a3, v17, v119, v122, v121, 0, a12);
    }
    if (v15) {
      return (uint64_t (**)())RIPLayerBltImage(a2, a3, (uint64_t)v17, v15, a12, a6, (uint64_t)a7, a8);
    }
    if (v118) {
      return (uint64_t (**)())RIPLayerBltShade(a2, a3, (uint64_t)v17, v118, v122, a12, (uint64_t)a7, a8);
    }
  }
  return (uint64_t (**)())v34;
}

char *rips_f_BlurRingRoundedDilation(uint64_t a1, int a2, double a3)
{
  long long v72 = *(_OWORD *)(a1 + 12);
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (!v3) {
    return 0;
  }
  unsigned int v6 = 0;
  int v7 = *(_DWORD *)(a1 + 20);
  uint64_t v8 = *(void *)(a1 + 56);
  unsigned int v9 = vcvtmd_s64_f64(a3 * 255.0);
  uint64_t v10 = *(unsigned int *)(a1 + 48);
  uint64_t v11 = v8 + v10;
  BOOL v12 = 1;
  while (!v7)
  {
LABEL_20:
    v8 += v10;
    ++v6;
    v11 += v10;
    BOOL v12 = v6 < v3;
    if (v6 == v3) {
      return 0;
    }
  }
  uint64_t v13 = 0;
  while (1)
  {
    unsigned int v14 = *(unsigned __int8 *)(v8 + v13);
    if (v13 < v7 - 1) {
      unsigned int v14 = *(unsigned __int8 *)(v8 + v13 + 1);
    }
    unsigned int v15 = *(unsigned __int8 *)(v8 + v13);
    if (v6 < v3 - 1) {
      unsigned int v15 = *(unsigned __int8 *)(v11 + v13);
    }
    if (v9 <= *(unsigned __int8 *)(v8 + v13)) {
      break;
    }
    if (v9 <= v14 || v9 <= v15) {
      goto LABEL_22;
    }
LABEL_19:
    if (v7 == ++v13) {
      goto LABEL_20;
    }
  }
  if (v9 <= v14 && v9 <= v15) {
    goto LABEL_19;
  }
LABEL_22:
  if (!v12) {
    return 0;
  }
  *(void *)&long long v72 = (v72 - a2) | ((unint64_t)(DWORD1(v72) - a2) << 32);
  *((void *)&v72 + 1) = (DWORD2(v72) + 2 * a2) | ((unint64_t)(HIDWORD(v72) + 2 * a2) << 32);
  uint64_t v18 = RIPLayerCreateWithLayer((uint64_t)RIPLayer_ripl_class, (uint64_t *)&v72, (uint64_t *)a1, *(unsigned int *)(a1 + 52));
  uint64_t v19 = v18;
  if (!v18) {
    return v19;
  }
  int v20 = *((_DWORD *)v18 + 12);
  if (!v20) {
    return 0;
  }
  bzero(*((void **)v18 + 7), (*((_DWORD *)v18 + 6) * v20));
  uint64_t v21 = *(unsigned int *)(a1 + 24);
  if (v21)
  {
    unsigned int v22 = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    unint64_t v25 = *(unsigned int *)(a1 + 20);
    int v26 = *(_DWORD *)(a1 + 48);
    uint8x16_t v27 = (uint8x16_t)vdupq_n_s8(v9);
    do
    {
      uint64_t v28 = *(void *)(a1 + 56);
      uint64_t v29 = v28 + (v26 * v24);
      unsigned int v30 = -(int)v29 & 0xF;
      if (v25 >= v30) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v25;
      }
      if (v31)
      {
        unint64_t v32 = (v23 - (_BYTE)v28) & 0xF;
        if (v25 < v32) {
          unint64_t v32 = v25;
        }
        uint64_t v33 = (unsigned char *)(v28 + v22);
        unint64_t v34 = v32;
        do
        {
          if (v9 > *v33) {
            *uint64_t v33 = 0;
          }
          ++v33;
          --v34;
        }
        while (v34);
      }
      else
      {
        uint64_t v31 = 0;
        LODWORD(v32) = 0;
      }
      int v35 = (int8x16_t *)(v29 + v31);
      uint64_t v36 = v32;
      unint64_t v37 = v32 + 64;
      if (v37 <= v25)
      {
        do
        {
          LODWORD(v32) = v37;
          int8x16_t v38 = vbicq_s8(v35[1], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[1]));
          int8x16_t v39 = vbicq_s8(v35[2], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[2]));
          int8x16_t v40 = vbicq_s8(v35[3], (int8x16_t)vcgtq_u8(v27, (uint8x16_t)v35[3]));
          *int v35 = vbicq_s8(*v35, (int8x16_t)vcgtq_u8(v27, *(uint8x16_t *)v35));
          v35[1] = v38;
          double v41 = v35 + 4;
          v35[2] = v39;
          v35[3] = v40;
          uint64_t v36 = v37;
          unint64_t v37 = v37 + 64;
          v35 += 4;
        }
        while (v37 <= v25);
        int v35 = v41;
      }
      for (unint64_t i = v36 + 16; i <= v25; unint64_t i = i + 16)
      {
        LODWORD(v32) = i;
        *int v35 = vbicq_s8(*v35, (int8x16_t)vcgtq_u8(v27, *(uint8x16_t *)v35));
        ++v35;
      }
      if (v32 < v25)
      {
        unint64_t v43 = v25 - v32;
        uint64_t v44 = (unsigned char *)(v28 + v22 + (unint64_t)v32);
        do
        {
          if (v9 > *v44) {
            *uint64_t v44 = 0;
          }
          ++v44;
          --v43;
        }
        while (v43);
      }
      ++v24;
      v23 -= v26;
      v22 += v26;
    }
    while (v24 != v21);
  }
  int v45 = 2 * a2;
  vImagePixelCount v47 = *((int *)v19 + 5);
  size_t v46 = *((int *)v19 + 6);
  unint64_t v48 = (char *)malloc_type_calloc(v46, *((unsigned int *)v19 + 12), 0x879E1AEFuLL);
  BOOL v49 = v48;
  size_t v50 = *((unsigned int *)v19 + 12);
  if (*(int *)(a1 + 24) > 0)
  {
    int v51 = 0;
    unint64_t v52 = &v48[(v50 * a2) + a2];
    uint64_t v53 = *(char **)(a1 + 56);
    do
    {
      memcpy(v52, v53, *(int *)(a1 + 20));
      v53 += *(unsigned int *)(a1 + 48);
      size_t v50 = *((unsigned int *)v19 + 12);
      v52 += v50;
      ++v51;
    }
    while (v51 < *(_DWORD *)(a1 + 24));
  }
  src.data = v49;
  src.CGFloat height = v46;
  src.double width = v47;
  src.rowBytes = v50;
  vImage_Buffer dest = src;
  dest.data = (void *)*((void *)v19 + 7);
  size_t v54 = v45 | 1u;
  uint64_t v55 = malloc_type_malloc((v54 * v54), 0xEAE60C46uLL);
  DeviceGradouble y = CGColorSpaceCreateDeviceGray();
  uint64_t v57 = CGBitmapContextCreateWithData(v55, v54, v54, 8uLL, v54, DeviceGray, 0, 0, 0);
  CGColorSpaceRelease(DeviceGray);
  v76.origin.double x = 0.0;
  v76.origin.double y = 0.0;
  v76.size.double width = (double)(int)v54;
  v76.size.CGFloat height = (double)(int)v54;
  uint64_t v58 = CGPathCreateWithEllipseInRect(v76, 0);
  CGContextSetGrayFillColor(v57, 1.0, 1.0);
  v77.origin.double x = 0.0;
  v77.origin.double y = 0.0;
  v77.size.double width = (double)(int)v54;
  v77.size.CGFloat height = (double)(int)v54;
  CGContextFillRect(v57, v77);
  CGContextSetGrayFillColor(v57, 0.0, 1.0);
  CGContextAddPath(v57, v58);
  if (v58) {
    CFRelease(v58);
  }
  CGContextDrawPath(v57, kCGPathFill);
  if (v57) {
    CFRelease(v57);
  }
  vImageDilate_Planar8(&src, &dest, 0, 0, (const unsigned __int8 *)v55, v54, v54, 0x18u);
  free(v55);
  free(v49);
  int v75 = 0;
  integer_propertdouble y = get_integer_property("CGFocusRingShrinkMask", (const void *(*)(const char *))copy_local_domain_value, &v75);
  int v60 = v75;
  if (!integer_property) {
    int v60 = 1;
  }
  if (v60 >= 1)
  {
    vImagePixelCount v62 = *(int *)(a1 + 20);
    vImagePixelCount v61 = *(int *)(a1 + 24);
    src.data = *(void **)(a1 + 56);
    src.CGFloat height = v61;
    size_t v63 = *(unsigned int *)(a1 + 48);
    src.double width = v62;
    src.rowBytes = v63;
    vImage_Buffer dest = src;
    vImageMin_Planar8(&src, &dest, 0, 0, 0, (2 * v60) | 1u, (2 * v60) | 1u, 0x18u);
  }
  int v64 = *(_DWORD *)(a1 + 24);
  if (v64 >= 1)
  {
    int v65 = 0;
    unsigned int v66 = *((_DWORD *)v19 + 12);
    uint64_t v67 = *((void *)v19 + 7)
        + (*(_DWORD *)(a1 + 16) - *((_DWORD *)v19 + 4)) * v66
        - *((int *)v19 + 3)
        + *(int *)(a1 + 12);
    uint64_t v68 = *(void *)(a1 + 56);
    LODWORD(v69) = *(_DWORD *)(a1 + 20);
    do
    {
      if ((int)v69 >= 1)
      {
        uint64_t v70 = 0;
        do
        {
          *(unsigned char *)(v67 + v70) = (*(unsigned char *)(v67 + v70) - *(unsigned char *)(v68 + v70)) & ~((*(unsigned __int8 *)(v67 + v70) - *(unsigned __int8 *)(v68 + v70)) >> 31);
          ++v70;
          uint64_t v69 = *(int *)(a1 + 20);
        }
        while (v70 < v69);
        unsigned int v66 = *((_DWORD *)v19 + 12);
        int v64 = *(_DWORD *)(a1 + 24);
      }
      v68 += *(unsigned int *)(a1 + 48);
      v67 += v66;
      ++v65;
    }
    while (v65 < v64);
  }
  return v19;
}

void __default_focus_ring_color_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  DeviceGradouble y = CGColorSpaceCreateDeviceGray();
  long long v1 = xmmword_1852108F0;
  default_focus_ring_color_focus_ring_color = (uint64_t)CGColorCreate(DeviceGray, (const CGFloat *)&v1);
  CGColorSpaceRelease(DeviceGray);
}

uint64_t (**rips_f_BltImage(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  uint64_t v8 = (uint64_t)a5;
  unsigned int v9 = (int *)(a3 + 12);
  if (!a3) {
    unsigned int v9 = (int *)(a2 + 12);
  }
  if (a4) {
    unsigned int v9 = a4;
  }
  if (!a5) {
    a5 = v9;
  }
  return rips_f_DrawRing(a1, a2, a3, a4, a5, 0, 0, v8, 0, a6, a7, a8);
}

uint64_t (**rips_f_BltGlyph(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10))()
{
  uint64_t v10 = a5;
  uint64_t v11 = (int *)(a3 + 12);
  if (!a3) {
    uint64_t v11 = (int *)(a2 + 12);
  }
  if (a4) {
    uint64_t v11 = a4;
  }
  if (!a5) {
    a5 = v11;
  }
  return rips_f_DrawRing(a1, a2, a3, a4, a5, 0, v10, 0, 0, a6, a7, a10);
}

uint64_t (**rips_f_BltShape(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8))()
{
  unsigned int v9 = (int *)(a3 + 12);
  if (!a3) {
    unsigned int v9 = (int *)(a2 + 12);
  }
  if (a4) {
    unsigned int v9 = a4;
  }
  if (a5) {
    uint64_t v10 = (int *)(a5 + 12);
  }
  else {
    uint64_t v10 = v9;
  }
  return rips_f_DrawRing(a1, a2, a3, a4, v10, a5, 0, 0, 0, a6, a7, a8);
}

CGColorSpaceRef rips_f_ColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 80);
  if (!v8) {
    return (CGColorSpaceRef)rips_f_cs;
  }
  if ((v8 & 0x8000000000000000) != 0) {
    return CGTaggedColorGetColorSpace(v8, a2, a3, a4, a5, a6, a7, a8);
  }
  return *(CGColorSpaceRef *)(v8 + 24);
}

uint64_t rips_f_Growth(uint64_t a1, unsigned int *a2)
{
  unsigned int v2 = vcvtmd_s64_f64(*(double *)(a1 + 96) + 0.5);
  *a2 = ~v2;
  a2[1] = ~v2;
  int v3 = 2 * v2 + 2;
  a2[2] = v3;
  a2[3] = v3;
  return 1;
}

void *rips_f_Create(uint64_t a1, uint64_t a2, double *a3, double a4)
{
  if (a2) {
    uint64_t v4 = a2 + 32;
  }
  else {
    uint64_t v4 = 0;
  }
  if (!a2) {
    return 0;
  }
  size_t v9 = (*(uint64_t (**)(void))(a1 + 8))();
  uint64_t v10 = malloc_type_calloc(1uLL, v9, 0x12FE9D4BuLL);
  uint64_t v11 = v10;
  if (v10)
  {
    *uint64_t v10 = a1;
    v10[1] = 0xF100000001;
    v10[18] = 0;
    if (a3) {
      double v12 = sqrt(fabs(*a3 * a3[3] - a3[1] * a3[2]));
    }
    else {
      double v12 = 1.0;
    }
    uint64_t v13 = *(void *)(a2 + 24);
    if (v13 && (v13 < 1 || !*(void *)(v13 + 32)))
    {
      CFRetain((CFTypeRef)v13);
      v11[10] = v13;
    }
    double v14 = v12 * *(double *)(v4 + 24);
    v11[11] = *(void *)(v4 + 16);
    *((double *)v11 + 12) = v14;
    v11[13] = *(void *)(v4 + 32);
    int v15 = *(_DWORD *)(v4 + 8);
    *((_DWORD *)v11 + 28) = v15;
    if (v15 == 1)
    {
      int v16 = *((_DWORD *)v11 + 3);
    }
    else
    {
      if (v15 != 2)
      {
        int v17 = *((_DWORD *)v11 + 3) | 0x400;
        goto LABEL_20;
      }
      int v16 = *((_DWORD *)v11 + 3) | 0x300;
    }
    int v17 = v16 | 0x600;
LABEL_20:
    *((_DWORD *)v11 + 3) = v17;
    int v18 = *(_DWORD *)(v4 + 72);
    *((_DWORD *)v11 + 33) = v18;
    if (v18 < 0)
    {
      char v24 = 0;
      *((_DWORD *)v11 + 31) = 0;
      *((_DWORD *)v11 + 32) = 0;
    }
    else
    {
      CGRect v34 = CGRectStandardize(*(CGRect *)(v4 + 40));
      if (a4 <= 1.0)
      {
        double width = v34.size.width;
      }
      else
      {
        v34.origin.double x = v34.origin.x * a4;
        v34.origin.double y = v34.origin.y * a4;
        double width = v34.size.width * a4;
      }
      if (a4 > 1.0) {
        double height = v34.size.height * a4;
      }
      else {
        double height = v34.size.height;
      }
      double v21 = v34.origin.x + width;
      double v22 = v34.origin.x + 0.0;
      if (v34.origin.x + 0.0 <= 1073741820.0)
      {
        unsigned int v25 = vcvtmd_s64_f64(v22);
        if (v22 >= -1073741820.0) {
          int v23 = v25;
        }
        else {
          int v23 = -1073741823;
        }
      }
      else
      {
        int v23 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 29) = v23;
      if (v21 <= 1073741820.0)
      {
        unsigned int v27 = vcvtpd_s64_f64(v21);
        if (v21 >= -1073741820.0) {
          int v26 = v27;
        }
        else {
          int v26 = -1073741823;
        }
      }
      else
      {
        int v26 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 31) = v26 - v23;
      double v28 = v34.origin.y + height;
      double v29 = v34.origin.y + 0.0;
      if (v29 <= 1073741820.0)
      {
        unsigned int v31 = vcvtmd_s64_f64(v29);
        if (v29 >= -1073741820.0) {
          int v30 = v31;
        }
        else {
          int v30 = -1073741823;
        }
      }
      else
      {
        int v30 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 30) = v30;
      if (v28 <= 1073741820.0)
      {
        if (v28 >= -1073741820.0) {
          unsigned int v32 = vcvtpd_s64_f64(v28);
        }
        else {
          unsigned int v32 = -1073741823;
        }
      }
      else
      {
        unsigned int v32 = 0x3FFFFFFF;
      }
      *((_DWORD *)v11 + 32) = v32 - v30;
      char v24 = 1;
    }
    *((unsigned char *)v11 + 136) = v24;
  }
  return v11;
}

void rips_f_release(_DWORD *a1)
{
  int v1 = a1[2] - 1;
  a1[2] = v1;
  if (!v1)
  {
    uint64_t v3 = *((void *)a1 + 18);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
    uint64_t v4 = (const void *)*((void *)a1 + 10);
    if (v4) {
      CFRelease(v4);
    }
    free(a1);
  }
}

uint64_t rips_f_size()
{
  return 152;
}

long long *rips_f_super()
{
  return &_rips_class;
}

CGContextRef CGPDFContextCreate(CGDataConsumerRef consumer, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  if (CGPDFContextCreate_once != -1) {
    dispatch_once_f(&CGPDFContextCreate_once, 0, (dispatch_function_t)load_pdf_context_creator);
  }
  if (!creator_10480) {
    return 0;
  }
  if (auxiliaryInfo)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(auxiliaryInfo, @"CGPDFContextCreatePDFA");
    if (Value)
    {
      CFBooleanRef v9 = Value;
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFBooleanGetTypeID()) {
        CFBooleanGetValue(v9);
      }
    }
    CFStringRef v11 = (const __CFString *)CFDictionaryGetValue(auxiliaryInfo, @"kCGPDFContextOwnerPassword");
    CFStringRef v12 = v11;
    if (v11 && !is_valid_password(v11)) {
      return 0;
    }
    CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(auxiliaryInfo, @"kCGPDFContextUserPassword");
    CFStringRef v14 = v13;
    if (v13)
    {
      if (!is_valid_password(v13)) {
        return 0;
      }
    }
    CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(auxiliaryInfo, @"kCGPDFContextEncryptionKeyLength");
    int valuePtr = 0;
    if (v15)
    {
      CFNumberGetValue(v15, kCFNumberIntType, &valuePtr);
      BOOL v16 = 1;
    }
    else
    {
      BOOL v16 = ((unint64_t)v12 | (unint64_t)v14) != 0;
      int valuePtr = 128;
    }
    int v17 = CFDictionaryGetValue(auxiliaryInfo, @"kCGPDFContextEncryptionCipher");
    if (valuePtr > 128) {
      return 0;
    }
    if (v17)
    {
      if (CFEqual(v17, @"kCGPDFContextEncryptionCipherAESv3")) {
        return 0;
      }
    }
    else if (v16)
    {
      if (valuePtr == 128) {
        int v18 = @"kCGPDFContextEncryptionCipherAESv2";
      }
      else {
        int v18 = @"kCGPDFContextEncryptionCipherRC4";
      }
      auxiliaryInfo = CFDictionaryCreateMutableCopy(0, 0, auxiliaryInfo);
      CFDictionarySetValue(auxiliaryInfo, @"kCGPDFContextEncryptionCipher", v18);
    }
  }
  uint64_t v19 = CGContextCreateWithDelegateAndInfo(0, 1, 0, 0, 0, 0, v3, v4);
  unsigned int v27 = (CGContext *)v19;
  if (!v19)
  {
    CGPostError((uint64_t)"%s: failed to create PDF context.", v20, v21, v22, v23, v24, v25, v26, (char)"CGPDFContextCreate");
    return v27;
  }
  *(int64x2_t *)(*(void *)(v19 + 112) + 8) = vdupq_n_s64(0x4062000000000000uLL);
  uint64_t v28 = creator_10480(consumer, mediaBox, auxiliaryInfo);
  *((void *)v27 + 5) = v28;
  if (!v28)
  {
    CGPostError((uint64_t)"%s: failed to create PDF context delegate.", v29, v30, v31, v32, v33, v34, v35, (char)"CGPDFContextCreate");
    CFRelease(v27);
    return 0;
  }
  return v27;
}

uint64_t is_valid_password(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID()) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (Length)
  {
    v13.CFIndex location = 0;
    v13.length = Length;
    if (CFStringGetBytes(a1, v13, 0x600u, 0, 0, 0, Length, 0) < Length)
    {
      CGPostError((uint64_t)"Specified password cannot be converted to ASCII.", v4, v5, v6, v7, v8, v9, v10, usedBufLen);
      return 0;
    }
  }
  return 1;
}

void load_pdf_context_creator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = 0;
  uint64_t v10 = (const char **)&links;
  do
  {
    if (!strcmp("__CGPDFContextDelegateCreate", *v10))
    {
      creator_10480 = (&links)[2 * v9 + 1];
      return;
    }
    ++v9;
    v10 += 2;
  }
  while (v9 != 7);

  CGPostError((uint64_t)"Failed to load PDF context.", v11, v12, v13, v14, v15, v16, v17, a9);
}

CGContextRef CGPDFContextCreateWithURL(CFURLRef url, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  uint64_t v5 = CGDataConsumerCreateWithURL(url);
  uint64_t v6 = CGPDFContextCreate(v5, mediaBox, auxiliaryInfo);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

CGContextRef CGPDFContextCreateWithFilename(char *cStr, const CGRect *a2, const __CFDictionary *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  if (!v5) {
    return 0;
  }
  CFStringRef v6 = v5;
  CFURLRef v7 = CFURLCreateWithFileSystemPath(0, v5, kCFURLPOSIXPathStyle, 0);
  CFRelease(v6);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = CGDataConsumerCreateWithURL(v7);
  CGContextRef v9 = CGPDFContextCreate(v8, a2, a3);
  if (v8) {
    CFRelease(v8);
  }
  CFRelease(v7);
  return v9;
}

void CGPDFContextClose(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1) {
    CGContextDelegateFinalize(*((void *)context + 5));
  }
  else {
    handle_invalid_context((char)"CGPDFContextClose", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  }
}

void CGPDFContextBeginPage(CGContextRef context, CFDictionaryRef pageInfo)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    int v9 = *((_DWORD *)context + 22);
    *((_DWORD *)context + 22) = v9 + 1;
    if (v9)
    {
      CGPostError((uint64_t)"%s: Don't nest calls to this function -- the results will not be what you expect.", (uint64_t)pageInfo, v2, v3, v4, v5, v6, v7, (char)"CGPDFContextBeginPage");
    }
    else
    {
      CGContextResetTopGState(context, (uint64_t)pageInfo, v2, v3, v4, v5, v6, v7);
      uint64_t v10 = *((void *)context + 5);
      if (v10)
      {
        uint64_t v11 = *(void (**)(void))(v10 + 152);
        if (v11)
        {
          v11();
        }
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginPage", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextEndPage(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    int v8 = *((_DWORD *)context + 22) - 1;
    *((_DWORD *)context + 22) = v8;
    if (v8)
    {
      CGPostError((uint64_t)"%s: Don't nest calls to this function -- the results will not be what you expect.", v1, v2, v3, v4, v5, v6, v7, (char)"CGPDFContextEndPage");
    }
    else
    {
      uint64_t v9 = *((void *)context + 5);
      if (v9)
      {
        uint64_t v10 = *(void (**)(void))(v9 + 160);
        if (v10)
        {
          v10();
        }
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndPage", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextSetURLForRect(CGContextRef context, CFURLRef url, CGRect rect)
{
  if (context)
  {
    if (*((_DWORD *)context + 4) == 1129601108)
    {
      if (*((_DWORD *)context + 6) == 1)
      {
        double height = rect.size.height;
        double width = rect.size.width;
        double y = rect.origin.y;
        double x = rect.origin.x;
        uint64_t v15 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        uint64_t v16 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        int v18 = CFDictionaryCreateMutable(0, 0, v15, v16);
        CFDictionarySetValue(v18, @"/Type", @"/Action");
        CFDictionarySetValue(v18, @"/S", @"/URI");
        CFDictionarySetValue(v18, @"/URI", url);
        CFDictionarySetValue(Mutable, @"/A", v18);
        CFDictionarySetValue(Mutable, @"/Type", @"/Annot");
        CFDictionarySetValue(Mutable, @"/Subtype", @"/Link");
        if (v18) {
          CFRelease(v18);
        }
        unsigned int v27 = CGContainerCreateWithRect(x, y, width, height, v19, v20, v21, v22, v23, v24, v25, v26);
        CFDictionarySetValue(Mutable, @"/Rect", v27);
        CFRelease(v27);
        uint64_t v28 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        CGCFArrayAppendInteger(v28, 0);
        CGCFArrayAppendInteger(v28, 0);
        CGCFArrayAppendInteger(v28, 0);
        CFDictionarySetValue(Mutable, @"/Border", v28);
        if (v28) {
          CFRelease(v28);
        }
        CGPDFContextAddAnnotation((uint64_t)context, Mutable, v29, v30, v31, v32, v33, v34);
        CFRelease(Mutable);
      }
      return;
    }
    CGContextRef v35 = context;
  }
  else
  {
    CGContextRef v35 = 0;
  }

  handle_invalid_context((char)"CGPDFContextSetURLForRect", (uint64_t)v35, v3, v4, v5, v6, v7, v8);
}

void CGPDFContextAddAnnotation(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      if (*(_DWORD *)(a1 + 24) == 1)
      {
        CGPDFStreamRef value = 0;
        if (CFDictionaryGetValueIfPresent(theDict, @"Subtype", (const void **)&value)
          && (CFTypeID v10 = CFGetTypeID(value), v10 == CFStringGetTypeID())
          && CFStringCompare((CFStringRef)value, @"Screen", 0)
          && CFDictionaryGetValueIfPresent(theDict, @"P", (const void **)&value)
          && (CFTypeID v11 = CFGetTypeID(value), v11 == CFDictionaryGetTypeID())
          && CFDictionaryGetValueIfPresent((CFDictionaryRef)value, @"Type", (const void **)&value)
          && (CFTypeID v12 = CFGetTypeID(value), v12 == CFStringGetTypeID())
          && CFEqual((CFStringRef)value, @"Page"))
        {
          CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
          CFDictionaryRemoveValue(MutableCopy, @"P");
        }
        else
        {
          CFMutableStringRef MutableCopy = (__CFDictionary *)CFRetain(theDict);
        }
        uint64_t v14 = *(void *)(a1 + 40);
        if (v14)
        {
          uint64_t v15 = *(void (**)(void))(v14 + 168);
          if (v15) {
            v15();
          }
        }
        CFRelease(MutableCopy);
      }
      return;
    }
    uint64_t v16 = a1;
  }
  else
  {
    uint64_t v16 = 0;
  }

  handle_invalid_context((char)"CGPDFContextAddAnnotation", v16, a3, a4, a5, a6, a7, a8);
}

void CGPDFContextAddDestinationAtPoint(CGContextRef context, CFStringRef name, CGPoint point)
{
  if (context)
  {
    if (*((_DWORD *)context + 4) == 1129601108)
    {
      if (*((_DWORD *)context + 6) == 1)
      {
        double y = point.y;
        double x = point.x;
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionarySetValue(Mutable, @"Label", name);
        CGCFDictionarySetPoint(Mutable, @"Point", x, y);
        uint64_t v14 = *((void *)context + 5);
        if (v14)
        {
          uint64_t v15 = *(void (**)(void))(v14 + 168);
          if (v15) {
            v15();
          }
        }
        if (Mutable)
        {
          CFRelease(Mutable);
        }
      }
      return;
    }
    CGContextRef v16 = context;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGPDFContextAddDestinationAtPoint", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
}

void CGPDFContextSetDestinationForRect(CGContextRef context, CFStringRef name, CGRect rect)
{
  if (context)
  {
    if (*((_DWORD *)context + 4) == 1129601108)
    {
      if (*((_DWORD *)context + 6) == 1)
      {
        double height = rect.size.height;
        double width = rect.size.width;
        double y = rect.origin.y;
        double x = rect.origin.x;
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionarySetValue(Mutable, @"/Type", @"/Annot");
        CFDictionarySetValue(Mutable, @"/Subtype", @"/Link");
        uint64_t v24 = CGContainerCreateWithRect(x, y, width, height, v16, v17, v18, v19, v20, v21, v22, v23);
        CFDictionarySetValue(Mutable, @"/Rect", v24);
        CFRelease(v24);
        uint64_t v25 = CFStringCreateMutable(0, 0);
        CFStringAppend(v25, @"/>");
        CFStringAppend(v25, name);
        CFDictionarySetValue(Mutable, @"/Dest", v25);
        CFRelease(v25);
        uint64_t v26 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        CGCFArrayAppendInteger(v26, 0);
        CGCFArrayAppendInteger(v26, 0);
        CGCFArrayAppendInteger(v26, 0);
        CFDictionarySetValue(Mutable, @"/Border", v26);
        if (v26) {
          CFRelease(v26);
        }
        CGPDFContextAddAnnotation((uint64_t)context, Mutable, v27, v28, v29, v30, v31, v32);
        CFRelease(Mutable);
      }
      return;
    }
    CGContextRef v33 = context;
  }
  else
  {
    CGContextRef v33 = 0;
  }

  handle_invalid_context((char)"CGPDFContextSetDestinationForRect", (uint64_t)v33, v3, v4, v5, v6, v7, v8);
}

void CGPDFContextAddCatalogEntry(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      if (*(_DWORD *)(a1 + 24) == 1 && a2 != 0 && a3 != 0)
      {
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFDictionarySetValue(Mutable, @"Key", a2);
        CFDictionarySetValue(Mutable, @"Value", a3);
        uint64_t v15 = *(void *)(a1 + 40);
        if (v15)
        {
          uint64_t v16 = *(void (**)(void))(v15 + 168);
          if (v16) {
            v16();
          }
        }
        if (Mutable)
        {
          CFRelease(Mutable);
        }
      }
      return;
    }
    uint64_t v13 = a1;
  }
  else
  {
    uint64_t v13 = 0;
  }

  handle_invalid_context((char)"CGPDFContextAddCatalogEntry", v13, (uint64_t)a3, a4, a5, a6, a7, a8);
}

void CGPDFContextAddDocumentMetadata(CGContextRef context, CFDataRef metadata)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    if (metadata)
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"/Type", @"/Metadata");
      CFDictionarySetValue(Mutable, @"/Subtype", @"/XML");
      CFDictionarySetValue(Mutable, @"/%Stream", metadata);
      CGPDFContextAddCatalogEntry((uint64_t)context, @"/Metadata", Mutable, v11, v12, v13, v14, v15);
      CFRelease(Mutable);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextAddDocumentMetadata", (uint64_t)context, v2, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextSetParentTree(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v11 = Mutable;
    if (a2) {
      CFDictionarySetValue(Mutable, @"ParentTree", a2);
    }
    uint64_t v12 = *(void *)(a1 + 40);
    if (v12)
    {
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
    }
    if (v11)
    {
      CFRelease(v11);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetParentTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetIDTree(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v11 = Mutable;
    if (a2) {
      CFDictionarySetValue(Mutable, @"IDTree", a2);
    }
    uint64_t v12 = *(void *)(a1 + 40);
    if (v12)
    {
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
    }
    if (v11)
    {
      CFRelease(v11);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetIDTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetPageTagStructureTree(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetPageTagStructureTree", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextAddPDFXInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextAddPDFXInfo", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetOutputIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetOutputIntent", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetShouldDeflate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v11 = Mutable;
    uint64_t v12 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!a2) {
      uint64_t v12 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    CFDictionarySetValue(Mutable, @"ShouldDeflate", *v12);
    uint64_t v13 = *(void *)(a1 + 40);
    if (v13)
    {
      uint64_t v14 = *(void (**)(void))(v13 + 168);
      if (v14) {
        v14();
      }
    }
    if (v11)
    {
      CFRelease(v11);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetShouldDeflate", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextBeginDrawingHiddenText(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginDrawingHiddenText", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextEndDrawingHiddenText(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndDrawingHiddenText", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetImageTag(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    if (a2 && a3)
    {
      CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(Mutable, @"Image", a2);
      CFDictionarySetValue(Mutable, @"Tag", a3);
      uint64_t v12 = *(void *)(a1 + 40);
      if (v12)
      {
        uint64_t v13 = *(void (**)(void))(v12 + 168);
        if (v13) {
          v13();
        }
      }
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetImageTag", a1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextSetOutline(CGContextRef context, CFDictionaryRef outline)
{
  if (outline)
  {
    if (!CFDictionaryContainsKey(outline, @"Title"))
    {
      CFTypeID v10 = convertOutlineTree(outline);
      if (v10)
      {
        uint64_t v16 = v10;
        CGPDFContextAddCatalogEntry((uint64_t)context, @"/Outlines", v10, v11, v12, v13, v14, v15);
        CFRelease(v16);
      }
    }
  }
  else
  {
    if (context)
    {
      if (*((_DWORD *)context + 4) == 1129601108) {
        return;
      }
      CGContextRef v17 = context;
    }
    else
    {
      CGContextRef v17 = 0;
    }
    handle_invalid_context((char)"CGPDFContextAddCatalogEntry", (uint64_t)v17, v2, v3, v4, v5, v6, v7);
  }
}

__CFDictionary *convertOutlineTree(const __CFDictionary *a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFBooleanRef Value = CFDictionaryGetValue(a1, @"Title");
  if (!Value) {
    goto LABEL_15;
  }
  CFDictionarySetValue(Mutable, @"/Title", Value);
  uint64_t v4 = CFDictionaryGetValue(a1, @"Destination");
  CFTypeID v5 = CFGetTypeID(v4);
  if (v5 == CFNumberGetTypeID())
  {
    CFDictionaryRef v6 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"DestinationRect");
    long long valuePtr = 0u;
    *(_OWORD *)size_t v46 = 0u;
    if (v6 && (CFDictionaryRef v7 = v6, get_point_from_dict(v6, (double *)&valuePtr), v8) && (get_size_from_dict(v7, v46), v9))
    {
      if (fabs(v46[0]) <= 2.22044605e-16 || fabs(v46[1]) <= 2.22044605e-16)
      {
        values = (void *)CFStringCreateWithFormat(0, 0, @"/#%@", v4);
        int8x16_t v40 = @"/XYZ";
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
        CFNumberRef v35 = CFNumberCreate(0, kCFNumberCGFloatType, (char *)&valuePtr + 8);
        CFNumberRef v36 = (const __CFNumber *)*MEMORY[0x1E4F1D260];
        CFNumberRef v42 = v35;
        CFNumberRef v43 = v36;
        CFArrayRef v10 = CFArrayCreate(0, (const void **)&values, 5, MEMORY[0x1E4F1D510]);
        CFRelease(values);
        CFRelease(v41);
        CFTypeRef v11 = v42;
      }
      else
      {
        double v37 = v46[1] + *((double *)&valuePtr + 1);
        double v38 = v46[0] + *(double *)&valuePtr;
        values = (void *)CFStringCreateWithFormat(0, 0, @"/#%@", v4);
        int8x16_t v40 = @"/FitR";
        CFNumberRef v41 = CFNumberCreate(0, kCFNumberCGFloatType, &valuePtr);
        CFNumberRef v42 = CFNumberCreate(0, kCFNumberCGFloatType, (char *)&valuePtr + 8);
        CFNumberRef v43 = CFNumberCreate(0, kCFNumberCGFloatType, &v38);
        CFNumberRef v44 = CFNumberCreate(0, kCFNumberCGFloatType, &v37);
        CFArrayRef v10 = CFArrayCreate(0, (const void **)&values, 6, MEMORY[0x1E4F1D510]);
        CFRelease(values);
        CFRelease(v41);
        CFRelease(v42);
        CFRelease(v43);
        CFTypeRef v11 = v44;
      }
    }
    else
    {
      values = (void *)CFStringCreateWithFormat(0, 0, @"/#%@", v4);
      int8x16_t v40 = @"/XYZ";
      CFNumberRef v41 = (CFNumberRef)*MEMORY[0x1E4F1D260];
      CFNumberRef v42 = v41;
      CFNumberRef v43 = v41;
      CFArrayRef v10 = CFArrayCreate(0, (const void **)&values, 5, MEMORY[0x1E4F1D510]);
      CFTypeRef v11 = values;
    }
    CFRelease(v11);
    uint64_t v13 = @"/Dest";
    goto LABEL_14;
  }
  CFTypeID v12 = CFGetTypeID(v4);
  if (v12 != CFURLGetTypeID())
  {
    CFRelease(Mutable);
    return 0;
  }
  values = @"/S";
  int8x16_t v40 = @"/URI";
  *(void *)&long long valuePtr = @"/URI";
  *((void *)&valuePtr + 1) = CFURLGetString((CFURLRef)v4);
  CFArrayRef v10 = CFDictionaryCreate(0, (const void **)&values, (const void **)&valuePtr, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v13 = @"/A";
LABEL_14:
  CFDictionarySetValue(Mutable, v13, v10);
  CFRelease(v10);
LABEL_15:
  CFArrayRef v14 = (const __CFArray *)CFDictionaryGetValue(a1, @"Children");
  if (v14)
  {
    CFArrayRef v15 = v14;
    CFIndex Count = CFArrayGetCount(v14);
    CFIndex v18 = Count;
    values = (void *)Count;
    if (Count < 1)
    {
      uint64_t v23 = Count;
      if (Value) {
        goto LABEL_30;
      }
    }
    else
    {
      unint64_t v19 = 8 * Count;
      MEMORY[0x1F4188790](Count, v17);
      uint64_t v20 = (char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
      if (v19 >= 0x200) {
        size_t v21 = 512;
      }
      else {
        size_t v21 = 8 * v18;
      }
      bzero((char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0), v21);
      bzero((char *)&v37 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0), 8 * v18);
      CFIndex v22 = 0;
      uint64_t v23 = 0;
      do
      {
        ValueAtIndedouble x = CFArrayGetValueAtIndex(v15, v22);
        uint64_t v25 = convertOutlineTree(ValueAtIndex);
        if (v25) {
          *(void *)&v20[8 * v23++] = v25;
        }
        ++v22;
      }
      while (v18 != v22);
      values = (void *)v23;
      uint64_t v26 = *(__CFDictionary **)v20;
      CFDictionarySetValue(Mutable, @"/First", *(const void **)v20);
      uint64_t v27 = &v20[8 * v23];
      uint64_t v28 = (void *)*((void *)v27 - 1);
      CFDictionarySetValue(Mutable, @"/Last", v28);
      if (v23 > 1)
      {
        uint64_t v29 = (void *)*((void *)v20 + 1);
        CFDictionarySetValue(v26, @"/Next", v29);
        CFDictionarySetValue((CFMutableDictionaryRef)v28, @"/Prev", *((const void **)v27 - 2));
        uint64_t v30 = v23 - 2;
        if (v23 != 2)
        {
          uint64_t v31 = (const void **)(v20 + 16);
          do
          {
            uint64_t v32 = (void *)*v31;
            CFDictionarySetValue((CFMutableDictionaryRef)v29, @"/Next", *v31);
            CFDictionarySetValue((CFMutableDictionaryRef)v29, @"/Prev", *(v31 - 2));
            ++v31;
            uint64_t v29 = v32;
            --v30;
          }
          while (v30);
        }
      }
      if (Value) {
        goto LABEL_30;
      }
    }
    values = (void *)-v23;
LABEL_30:
    CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt64Type, &values);
    CFDictionarySetValue(Mutable, @"/Count", v33);
    CFRelease(v33);
  }
  return Mutable;
}

const char *__cdecl CGPDFTagTypeGetName(CGPDFTagType tagType)
{
  if (tagType <= 399)
  {
    __int32 v2 = tagType - 100;
    if (tagType > 0x18F)
    {
      switch(tagType)
      {
        case CGPDFTagTypeParagraph:
          double result = "/P";
          break;
        case CGPDFTagTypeHeader:
          double result = "/H";
          break;
        case CGPDFTagTypeHeader1:
          double result = "/H1";
          break;
        case CGPDFTagTypeHeader2:
          double result = "/H2";
          break;
        case CGPDFTagTypeHeader3:
          double result = "/H3";
          break;
        case CGPDFTagTypeHeader4:
          double result = "/H4";
          break;
        case CGPDFTagTypeHeader5:
          double result = "/H5";
          break;
        case CGPDFTagTypeHeader6:
          double result = "/H6";
          break;
        default:
          switch(tagType)
          {
            case CGPDFTagTypeList:
              double result = "/L";
              break;
            case CGPDFTagTypeListItem:
              double result = "/LI";
              break;
            case CGPDFTagTypeLabel:
              double result = "/Lbl";
              break;
            case CGPDFTagTypeListBody:
              double result = "/LBody";
              break;
            default:
              return 0;
          }
          break;
      }
    }
    else
    {
      double result = "/Document";
      switch(v2)
      {
        case 0:
          return result;
        case 1:
          double result = "/Part";
          break;
        case 2:
          double result = "/Art";
          break;
        case 3:
          double result = "/Sect";
          break;
        case 4:
          double result = "/Div";
          break;
        case 5:
          double result = "/BlockQuote";
          break;
        case 6:
          double result = "/Caption";
          break;
        case 7:
          double result = "/TOC";
          break;
        case 8:
          double result = "/TOCI";
          break;
        case 9:
          double result = "/Index";
          break;
        case 10:
          double result = "/NonStruct";
          break;
        case 11:
          double result = "/Private";
          break;
        default:
          JUMPOUT(0);
      }
    }
  }
  else if (tagType > 599)
  {
    if (tagType > 699)
    {
      if (tagType > CGPDFTagTypeFormula)
      {
        if (tagType == CGPDFTagTypeForm)
        {
          return "/Form";
        }
        else if (tagType == 800)
        {
          return "/OBJR";
        }
        else
        {
          return 0;
        }
      }
      else if (tagType == CGPDFTagTypeFigure)
      {
        return "/Figure";
      }
      else
      {
        return "/Formula";
      }
    }
    else
    {
      switch(tagType)
      {
        case CGPDFTagTypeRuby:
          double result = "/Ruby";
          break;
        case CGPDFTagTypeRubyBaseText:
          double result = "/RB";
          break;
        case CGPDFTagTypeRubyAnnotationText:
          double result = "/RT";
          break;
        case CGPDFTagTypeRubyPunctuation:
          double result = "/RP";
          break;
        case CGPDFTagTypeWarichu:
          double result = "/Warichu";
          break;
        case CGPDFTagTypeWarichuText:
          double result = "/WT";
          break;
        case CGPDFTagTypeWarichuPunctiation:
          double result = "/WP";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    switch(tagType)
    {
      case CGPDFTagTypeSpan:
        double result = "/Span";
        break;
      case CGPDFTagTypeQuote:
        double result = "/Quote";
        break;
      case CGPDFTagTypeNote:
        double result = "/Note";
        break;
      case CGPDFTagTypeReference:
        double result = "/Reference";
        break;
      case CGPDFTagTypeBibliography:
        double result = "/BibEntry";
        break;
      case CGPDFTagTypeCode:
        double result = "/Code";
        break;
      case CGPDFTagTypeLink:
        double result = "/Link";
        break;
      case CGPDFTagTypeAnnotation:
        double result = "/Annot";
        break;
      default:
        switch(tagType)
        {
          case CGPDFTagTypeTable:
            double result = "/Table";
            break;
          case CGPDFTagTypeTableRow:
            double result = "/TR";
            break;
          case CGPDFTagTypeTableHeaderCell:
            double result = "/TH";
            break;
          case CGPDFTagTypeTableDataCell:
            double result = "/TD";
            break;
          case CGPDFTagTypeTableHeader:
            double result = "/THead";
            break;
          case CGPDFTagTypeTableBody:
            double result = "/TBody";
            break;
          case CGPDFTagTypeTableFooter:
            double result = "/TFoot";
            break;
          default:
            return 0;
        }
        break;
    }
  }
  return result;
}

void CGPDFContextBeginTag(CGContextRef context, CGPDFTagType tagType, CFDictionaryRef tagProperties)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CGCFDictionarySetInteger(Mutable, @"TagType", tagType);
    if (tagProperties) {
      CFDictionarySetValue(Mutable, @"TagProperties", tagProperties);
    }
    uint64_t v12 = *((void *)context + 5);
    if (v12)
    {
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
    }
    if (Mutable)
    {
      CFRelease(Mutable);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextBeginTag", (uint64_t)context, (uint64_t)tagProperties, v3, v4, v5, v6, v7);
  }
}

void CGPDFContextEndTag(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 1)
  {
    uint64_t v7 = *((void *)context + 5);
    if (v7)
    {
      int v8 = *(void (**)(void))(v7 + 168);
      if (v8) {
        v8();
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextEndTag", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  }
}

void CGPDFContextSetRedactionPath(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108 && *(_DWORD *)(a1 + 24) == 1)
  {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFTypeRef v11 = Mutable;
    if (a2) {
      CFDictionarySetValue(Mutable, @"RedactionPath", a2);
    }
    uint64_t v12 = *(void *)(a1 + 40);
    if (v12)
    {
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
    }
    if (v11)
    {
      CFRelease(v11);
    }
  }
  else
  {
    handle_invalid_context((char)"CGPDFContextSetRedactionPath", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGPDFContextBeginAccessibilitySpan(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGPDFContextBeginAccessibilitySpan", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v10 = a1;
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      int v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
}

void CGPDFContextEndAccessibilitySpan(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v10 = 0;
LABEL_8:
    handle_invalid_context((char)"CGPDFContextEndAccessibilitySpan", v10, a3, a4, a5, a6, a7, a8);
    return;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v10 = a1;
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      int v9 = *(void (**)(void))(v8 + 168);
      if (v9) {
        v9();
      }
    }
  }
}

CFStringRef CGPDFContextIsValidPassword(const __CFString *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    uint64_t Length = CFStringGetLength(result);
    if (Length <= 32)
    {
      v3.CFIndex location = 0;
      v3.length = Length;
      return (const __CFString *)(CFStringGetBytes(v1, v3, 0x600u, 0, 0, 0, 0, 0) == Length);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void Type1::create_subset()
{
}

void sub_184EF06F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  MEMORY[0x18532A2A0](v20, 0x10F3C4094E7248ELL);
  _Unwind_Resume(a1);
}

uint64_t Type1::get_format(Type1 *this)
{
  return 2;
}

void Type1::~Type1(Type1 *this)
{
  SimpleFont::~SimpleFont(this);

  JUMPOUT(0x18532A2A0);
}

void sub_184EF0944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10695(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10696(uint64_t a1)
{
}

void sub_184EF0AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184EF0E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184EF0F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_184EF10AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CGShadingRef CGShadingCreateAxial(CGColorSpaceRef space, CGPoint start, CGPoint end, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  BOOL v7 = extendEnd;
  if (function) {
    uint64_t v8 = (double *)*((void *)function + 5);
  }
  else {
    uint64_t v8 = 0;
  }
  return (CGShadingRef)CGShadingCreateAxialInternal(space, 0, 0, v8, function, extendStart, v7, v6, start.x, start.y, end.x, end.y);
}

uint64_t shading_hash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

BOOL shading_equal(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
}

CGShadingRef CGShadingCreateRadial(CGColorSpaceRef space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef function, BOOL extendStart, BOOL extendEnd)
{
  BOOL v9 = extendEnd;
  if (function) {
    uint64_t v10 = (double *)*((void *)function + 5);
  }
  else {
    uint64_t v10 = 0;
  }
  return (CGShadingRef)CGShadingCreateRadialInternal(space, 0, 0, v10, function, extendStart, v9, v8, start.x, start.y, startRadius, end.x, end.y, endRadius);
}

uint64_t CGShadingCreateRadialInternal(void *a1, uint64_t a2, uint64_t a3, double *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  Emptdouble y = 0;
  if (a1 && a5)
  {
    uint64_t v17 = *(void *)(a1[3] + 48);
    uint64_t v18 = a5[6];
    if (v18 == v17 || v18 == v17 + 1)
    {
      char v20 = a7;
      char v21 = a6;
      if (vabdd_f64(a11, a14) >= 0.000001) {
        double v27 = a14;
      }
      else {
        double v27 = a14 + 0.000001;
      }
      Emptdouble y = CGShadingCreateEmpty(2, a1, a2, a3, (uint64_t)a5, a6, a7, a8);
      *(double *)(Empty + 120) = a9;
      *(double *)(Empty + 128) = a10;
      *(double *)(Empty + 136) = fabs(a11);
      *(unsigned char *)(Empty + 144) = v21;
      *(double *)(Empty + 152) = a12;
      *(double *)(Empty + 160) = a13;
      *(double *)(Empty + 168) = fabs(v27);
      *(unsigned char *)(Empty + 176) = v20;
      CFRetain(a5);
      *(void *)(Empty + 200) = a5;
      if (a4)
      {
        *(double *)(Empty + 184) = *a4;
        double v28 = a4[1];
      }
      else
      {
        *(void *)(Empty + 184) = 0;
        double v28 = 1.0;
      }
      *(double *)(Empty + 192) = v28;
    }
    else
    {
      return 0;
    }
  }
  return Empty;
}

uint64_t CGShadingCreateConic(void *a1, void *a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (!a2 || !a1) {
    return 0;
  }
  uint64_t v12 = *(void *)(a1[3] + 48);
  uint64_t v13 = a2[6];
  if (v13 != v12 && v13 != v12 + 1) {
    return 0;
  }
  uint64_t v18 = (double *)a2[5];
  Emptdouble y = CGShadingCreateEmpty(3, a1, 0, 0, a8, a9, a10, a11);
  *(double *)(Empty + 120) = a3;
  *(double *)(Empty + 128) = a4;
  *(double *)(Empty + 136) = a5;
  CFRetain(a2);
  *(void *)(Empty + 160) = a2;
  if (v18)
  {
    *(double *)(Empty + 144) = *v18;
    double v20 = v18[1];
  }
  else
  {
    *(void *)(Empty + 144) = 0;
    double v20 = 1.0;
  }
  *(double *)(Empty + 152) = v20;
  return Empty;
}

uint64_t CGShadingCreateCustom(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, void *a6, uint64_t a7, uint64_t a8)
{
  Emptdouble y = 0;
  if (a1 && a6)
  {
    uint64_t v11 = *(void *)(a1[3] + 48);
    uint64_t v12 = a6[6];
    if (v12 == v11 || v12 == v11 + 1)
    {
      Emptdouble y = CGShadingCreateEmpty(4, a1, a2, a3, (uint64_t)a5, (uint64_t)a6, a7, a8);
      CFRetain(a6);
      uint64_t v15 = 0;
      *(void *)(Empty + 152) = a6;
      long long v17 = a5[1];
      long long v16 = a5[2];
      *(_OWORD *)(Empty + 160) = *a5;
      *(_OWORD *)(Empty + 176) = v17;
      *(_OWORD *)(Empty + 192) = v16;
      do
      {
        *(void *)(Empty + v15 + 120) = *(void *)(a4 + v15);
        v15 += 8;
      }
      while (v15 != 32);
    }
    else
    {
      return 0;
    }
  }
  return Empty;
}

CGShadingRef CGShadingRetain(CGShadingRef shading)
{
  if (shading) {
    CFRetain(shading);
  }
  return shading;
}

void CGShadingRelease(CGShadingRef shading)
{
  if (shading) {
    CFRelease(shading);
  }
}

uint64_t CGShadingGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t CGShadingGetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t CGShadingGetColorSpace(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t CGShadingGetBackground(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

CGFloat CGShadingGetBounds(uint64_t a1)
{
  CFStringRef v1 = &CGRectInfinite;
  if (*(unsigned char *)(a1 + 40)) {
    CFStringRef v1 = (const CGRect *)(a1 + 48);
  }
  return v1->origin.x;
}

uint64_t CGShadingGetDescriptor(uint64_t result)
{
  if (result)
  {
    if ((*(_DWORD *)(result + 20) - 1) >= 4) {
      return 0;
    }
    else {
      result += 120;
    }
  }
  return result;
}

uint64_t CGShadingSetAssociate(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v2 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(result + 88), (unint64_t *)&v2, a2, memory_order_relaxed, memory_order_relaxed);
    return *(void *)(result + 88);
  }
  return result;
}

uint64_t CGShadingGetAssociate(uint64_t result)
{
  if (result) {
    return *(void *)(result + 88);
  }
  return result;
}

CFTypeID CGShadingGetTypeID(void)
{
  if (_block_invoke_once_10723 != -1) {
    dispatch_once(&_block_invoke_once_10723, &__block_literal_global_5_10724);
  }
  return CGShadingGetTypeID_shading_type_id;
}

uint64_t CGShadingDelegateDrawShading(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

void CGShadingDrawInContextDelegate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      BOOL v9 = (const void *)CGContextCreateWithDelegateAndInfo(a2, 0, a3, a4, 0, 0, a7, a8);
      (*(void (**)(void, const void *))(a1 + 104))(*(void *)(a1 + 80), v9);
      if (v9)
      {
        CFRelease(v9);
      }
    }
  }
}

double cmap_yyensure_buffer_stack(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    uint64_t v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      uint64_t v4 = v3 + 8;
      uint64_t v5 = (char *)malloc_type_realloc(v2, 8 * (v3 + 8), 0xF93AD230uLL);
      a1[5] = v5;
      if (v5)
      {
        uint64_t v6 = &v5[8 * a1[4]];
        double result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)uint64_t v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4;
        return result;
      }
LABEL_8:
      fatal_scanner_error();
    }
  }
  else
  {
    uint64_t v8 = malloc_type_malloc(8uLL, 0x8B871889uLL);
    a1[5] = v8;
    if (!v8) {
      goto LABEL_8;
    }
    void *v8 = 0;
    double result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_1850CD8A0;
  }
  return result;
}

uint64_t cmap_yy_create_buffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = malloc_type_malloc(0x48uLL, 0x8B871889uLL);
  if (!v4
    || (uint64_t v5 = (uint64_t)v4,
        v4[3] = 0x4000,
        uint64_t v6 = malloc_type_malloc(0x4002uLL, 0x8B871889uLL),
        (*(void *)(v5 + 8) = v6) == 0))
  {
    fatal_scanner_error();
  }
  *(_DWORD *)(v5 + 40) = 1;
  cmap_yy_init_buffer(v5, a1, a2);
  return v5;
}

void fatal_scanner_error()
{
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 84);
  uint64_t v2 = *(unsigned char **)(a1 + 136);
  uint64_t v3 = *(unsigned char **)(a1 + 72);
  if (v2 < v3)
  {
    do
    {
      if (*v2) {
        uint64_t v4 = yy_ec[*v2];
      }
      else {
        uint64_t v4 = 2u;
      }
      if (yy_accept[(int)v1])
      {
        *(_DWORD *)(a1 + 112) = v1;
        *(void *)(a1 + 120) = v2;
      }
      uint64_t v5 = (int)v1;
      uint64_t v6 = yy_base[(int)v1] + v4;
      if (v1 != (__int16)yy_chk[v6])
      {
        do
        {
          uint64_t v5 = yy_def[v5];
          if (v5 >= 253) {
            uint64_t v4 = yy_meta[v4];
          }
          uint64_t v6 = yy_base[v5] + v4;
        }
        while (yy_chk[v6] != (unsigned __int16)v5);
      }
      uint64_t v1 = yy_nxt[v6];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

int *cmap_yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *__error();
  if (a1)
  {
    *(void *)(a1 + 32) = 0;
    **(unsigned char **)(a1 + 8) = 0;
    *(unsigned char *)(*(void *)(a1 + 8) + 1) = 0;
    *(void *)(a1 + 16) = *(void *)(a1 + 8);
    *(_DWORD *)(a1 + 48) = 1;
    *(_DWORD *)(a1 + 64) = 0;
    uint64_t v7 = *(void *)(a3 + 40);
    if (v7) {
      uint64_t v8 = *(void *)(v7 + 8 * *(void *)(a3 + 24));
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8 == a1)
    {
      uint64_t v9 = *(void *)(a3 + 24);
      uint64_t v10 = *(void *)(v7 + 8 * v9);
      *(void *)(a3 + 56) = *(void *)(v10 + 32);
      uint64_t v11 = *(unsigned char **)(v10 + 16);
      *(void *)(a3 + 72) = v11;
      *(void *)(a3 + 136) = v11;
      *(void *)(a3 + 8) = **(void **)(v7 + 8 * v9);
      *(unsigned char *)(a3 + 48) = *v11;
      *(void *)a1 = a2;
      *(_DWORD *)(a1 + 60) = 1;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a3 + 40);
  }
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  if (v7) {
LABEL_10:
  }
    uint64_t v7 = *(void *)(v7 + 8 * *(void *)(a3 + 24));
  if (v7 != a1) {
    *(void *)(a1 + 52) = 1;
  }
  *(_DWORD *)(a1 + 44) = 0;
  double result = __error();
  *double result = v6;
  return result;
}

void cmap_yy_delete_buffer(void **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3) {
    uint64_t v4 = *(void ***)(v3 + 8 * *(void *)(a2 + 24));
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1) {
    *(void *)(v3 + 8 * *(void *)(a2 + 24)) = 0;
  }
  if (*((_DWORD *)a1 + 10)) {
    free(a1[1]);
  }

  free(a1);
}

void CGPDFSecurityManagerRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2) {
      free(v2);
    }
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3) {
      free(v3);
    }
    free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

char *CGPDFSecurityManagerCreateCryptFilter(uint64_t a1, char *__s1)
{
  uint64_t v2 = __s1;
  if (!__s1) {
    return v2;
  }
  if (!strcmp(__s1, "Identity"))
  {
    uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v2)
    {
      *(void *)uint64_t v2 = a1;
      v2[12] = 1;
      *((_DWORD *)v2 + 2) = 0;
      *((void *)v2 + 2) = 0;
    }
    return v2;
  }
  CGPDFDictionaryRef value = 0;
  Dictionardouble y = CGPDFDictionaryGetDictionary(*(CGPDFDictionaryRef *)(a1 + 24), v2, &value);
  uint64_t v2 = 0;
  if (!Dictionary) {
    return v2;
  }
  uint64_t v2 = (char *)value;
  if (!value) {
    return v2;
  }
  uint64_t v12 = 0;
  __s1a = 0;
  CGPDFInteger v11 = 0;
  if (CGPDFDictionaryGetName(value, "CFM", (const char **)&__s1a))
  {
    uint64_t v5 = __s1a;
  }
  else
  {
    uint64_t v5 = "None";
    __s1a = "None";
  }
  if (!strcmp(v5, "V2"))
  {
    int v6 = 1;
  }
  else if (!strcmp(v5, "AESV2"))
  {
    int v6 = 2;
  }
  else
  {
    if (strcmp(v5, "AESV3"))
    {
      return 0;
    }
    int v6 = 3;
  }
  if (CGPDFDictionaryGetInteger((CGPDFDictionaryRef)v2, "Length", &v11))
  {
    CGPDFInteger v7 = v11;
    if ((unint64_t)(v11 - 5) > 0x1B) {
      goto LABEL_22;
    }
    CGPDFInteger v7 = 8 * v11;
  }
  else
  {
    CGPDFInteger v7 = 128;
  }
  CGPDFInteger v11 = v7;
LABEL_22:
  if ((unint64_t)(v7 - 40) > 0xD8 || (v7 & 7) != 0)
  {
    return 0;
  }
  if (CGPDFDictionaryGetName((CGPDFDictionaryRef)v2, "AuthEvent", (const char **)&v12))
  {
    uint64_t v8 = v12;
  }
  else
  {
    uint64_t v8 = "DocOpen";
    uint64_t v12 = "DocOpen";
  }
  if (strcmp(v8, "DocOpen"))
  {
    return 0;
  }
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v2)
  {
    *(void *)uint64_t v2 = a1;
    *((_DWORD *)v2 + 2) = v6;
    v2[12] = 0;
    *((void *)v2 + 2) = v11 / 8;
  }
  return v2;
}

BOOL CGPDFSecurityManagerUnlock(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || !a2 && a3) {
    return 0;
  }
  pthread_mutex_lock(&lock);
  if (CGPDFSecurityHandlerAuthenticateUserPassword(v3, a2, a3))
  {
    *(_WORD *)(v3 + 184) = 1;
    if ((*(_DWORD *)v3 - 3) >= 4)
    {
      if (*(_DWORD *)v3 != 2)
      {
        LOWORD(v15) = 0;
LABEL_32:
        int v15 = (unsigned __int16)v15;
        goto LABEL_33;
      }
      int v16 = *(_DWORD *)(v3 + 16);
      if ((v16 & 0x10) != 0) {
        int v12 = (v16 << 29 >> 31) & 7 | 0x38;
      }
      else {
        int v12 = (v16 << 29 >> 31) & 7;
      }
      if ((v16 & 8) != 0)
      {
        LOWORD(v12) = v12 | 0xC40;
        __int16 v17 = 960;
      }
      else
      {
        __int16 v17 = 832;
      }
      __int16 v13 = v12 | v17;
      BOOL v14 = (*(_DWORD *)(v3 + 16) & 0x20) == 0;
    }
    else
    {
      unsigned int v7 = *(_DWORD *)(v3 + 16);
      if ((v7 & 0x800) != 0) {
        int v8 = 7;
      }
      else {
        int v8 = 3;
      }
      int v9 = v8 & ((int)(v7 << 29) >> 31);
      if ((v7 & 0x10) != 0) {
        v9 |= 0x28u;
      }
      int v10 = v9 | (v7 >> 5) & 0x10;
      if ((v7 & 8) != 0)
      {
        v10 |= 0x840u;
        int v11 = 960;
      }
      else
      {
        int v11 = 832;
      }
      int v12 = v10 | v11 & ((int)(v7 << 26) >> 31);
      if ((v7 & 0x100) != 0) {
        LOWORD(v12) = v12 | 0x240;
      }
      __int16 v13 = v12 | 0x440;
      BOOL v14 = (*(_DWORD *)(v3 + 16) & 0x408) == 0;
    }
    if (v14) {
      LOWORD(v15) = v12;
    }
    else {
      LOWORD(v15) = v13;
    }
    goto LABEL_32;
  }
  if (CGPDFSecurityHandlerAuthenticateOwnerPassword(v3, a2, a3))
  {
    *(_WORD *)(v3 + 184) = 257;
    int v15 = 4095;
LABEL_33:
    *(_DWORD *)(v3 + 188) = v15;
    goto LABEL_34;
  }
  *(_WORD *)(v3 + 184) = 0;
  *(_DWORD *)(v3 + 188) = 0;
LABEL_34:
  pthread_mutex_unlock(&lock);
  return *(unsigned char *)(v3 + 184) != 0;
}

BOOL CGPDFSecurityManagerGetDecryptionKey(uint64_t a1, void *a2, void *a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 0;
  }
  pthread_mutex_lock(&lock);
  BOOL v6 = *(unsigned char *)(v3 + 184) != 0;
  if (*(unsigned char *)(v3 + 184))
  {
    if (a2) {
      memcpy(a2, (const void *)(v3 + 192), *(void *)(v3 + 8));
    }
    *a3 = *(void *)(v3 + 8);
  }
  pthread_mutex_unlock(&lock);
  return v6;
}

void *CGPDFSecurityManagerCreateDecryptor(uint64_t a1, uint64_t a2, char *__s1, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4 || !*(unsigned char *)(v4 + 184)) {
    return 0;
  }
  if (a2)
  {
    uint64_t v7 = *(void *)(a2 + 24);
    unint64_t v8 = *(void *)(a2 + 32);
    if (__s1)
    {
LABEL_5:
      CryptFilter = CGPDFSecurityManagerCreateCryptFilter(a1, __s1);
      if (CryptFilter)
      {
        int v10 = CryptFilter;
        Decryptor = CGPDFCryptFilterCreateDecryptor(CryptFilter, v7, v8, a4);
        free(v10);
        return Decryptor;
      }
      return 0;
    }
  }
  else
  {
    LODWORD(v7) = 0;
    unint64_t v8 = 0;
    if (__s1) {
      goto LABEL_5;
    }
  }
  __int16 v13 = *(void **)(a1 + 32);

  return CGPDFCryptFilterCreateDecryptor(v13, v7, v8, a4);
}

char *cg_function_type2_create(CGPDFDictionary *a1)
{
  double result = (char *)malloc_type_calloc(1uLL, 0x40uLL, 0x108004052750FCFuLL);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (const CGFloat *)(result + 8);
    if (!CGPDFDictionaryGetNumbers(a1, "Domain", (uint64_t)(result + 8), (CGPDFArray *)2))
    {
      goto LABEL_21;
    }
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    void *v3 = 1;
    uint64_t v5 = pdf_dictionary_copy_numbers(a1, "C0", &v12);
    v3[5] = v5;
    if (!v5)
    {
      uint64_t v12 = 1;
      BOOL v6 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
      v3[5] = v6;
      if (!v6) {
        goto LABEL_21;
      }
      *BOOL v6 = 0;
    }
    if (v12)
    {
      v3[3] = v12;
      uint64_t v7 = pdf_dictionary_copy_numbers(a1, "C1", &v12);
      v3[6] = v7;
      if (v7) {
        goto LABEL_10;
      }
      uint64_t v12 = 1;
      unint64_t v8 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
      v3[6] = v8;
      if (v8)
      {
        void *v8 = 0x3FF0000000000000;
LABEL_10:
        if (v12 == v3[3])
        {
          if (CGPDFDictionaryGetNumber(a1, "N", (CGPDFReal *)&v11))
          {
            v3[7] = v11;
            int v9 = pdf_dictionary_copy_numbers(a1, "Range", &v12);
            v3[4] = v9;
            size_t v10 = v3[3];
            if (v9 && v12 != 2 * v10)
            {
            }
            else
            {
              double result = (char *)CGFunctionCreate(v3, *v3, v4, v10, v9, &type2_callbacks);
              if (result) {
                return result;
              }
              pdf_error("unable to create Type 2 function.", v11);
            }
          }
          else
          {
          }
        }
        else
        {
        }
      }
    }
    else
    {
    }
LABEL_21:
    type2_release((void **)v3);
    return 0;
  }
  return result;
}

void type2_release(void **a1)
{
  if (a1)
  {
    free(a1[4]);
    free(a1[5]);
    free(a1[6]);
    free(a1);
  }
}

void type2_evaluate(uint64_t a1, long double *a2, double *a3)
{
  if (a1)
  {
    long double v5 = *(double *)(a1 + 56);
    double v6 = *a2;
    double v7 = pow(*a2, v5);
    if (v5 == 1.0) {
      double v7 = v6;
    }
    uint64_t v8 = *(void *)(a1 + 24);
    if (v8)
    {
      int v9 = *(double **)(a1 + 40);
      size_t v10 = *(double **)(a1 + 48);
      do
      {
        double v11 = *v9++;
        double v12 = v11;
        double v13 = *v10++;
        *a3++ = v12 + v7 * (v13 - v12);
        --v8;
      }
      while (v8);
    }
  }
}

uint64_t CGFontDefaultAllowsFontSmoothing()
{
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  return allows_font_smoothing;
}

uint64_t CGFontDefaultGetAntialiasingStyle()
{
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  return default_antialiasing_style;
}

uint64_t CGFontDefaultGetSmoothingStyle()
{
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  return default_smoothing_style;
}

double CGFontDefaultGetSmoothingContrast()
{
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  return 2.0;
}

double CGFontGetDilationParameters(double a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int16 v10 = a4;
  if (CGFontGetDilationParameters_defaultsOnce != -1) {
    dispatch_once_f(&CGFontGetDilationParameters_defaultsOnce, 0, (dispatch_function_t)get_glyph_debugging_defaults);
  }
  if ((v10 & 2) == 0)
  {
    double v12 = 0.00798599981;
    switch(((v10 & 0xD80u) - 128) >> 7)
    {
      case 0u:
        goto LABEL_13;
      case 1u:
        double v12 = 0.0100429999;
        goto LABEL_13;
      case 2u:
        goto LABEL_9;
      case 7u:
      case 8u:
        goto LABEL_8;
      default:
        goto LABEL_19;
    }
  }
  double v12 = 0.0;
  switch(((v10 & 0x70u) - 16) >> 4)
  {
    case 0u:
      break;
    case 1u:
      double v12 = 0.00798599981;
      break;
    case 2u:
LABEL_9:
      double v12 = 0.0120999999;
      break;
    case 3u:
      double v12 = 0.0169399995;
      break;
    case 4u:
      double v12 = 0.00124999997;
      break;
    case 5u:
      double v12 = 0.104999997;
      break;
    case 6u:
LABEL_8:
      double v12 = a1 * 0.300000012;
      break;
    default:
LABEL_19:
      abort();
  }
LABEL_13:
  double v13 = v12 * sqrt(fabs(a3[1] * a3[2] + *a3 * a3[3]));
  if (v13 <= 0.300000012) {
    double v14 = v13;
  }
  else {
    double v14 = 0.300000012;
  }
  if (default_glyph_debugging) {
    CGPostError((uint64_t)"%s Effective dilation parameters are: dilation double width = %f dilation height = %f", (uint64_t)a3, a4, a5, a6, a7, a8, a9, (char)"CGFontGetDilationParameters");
  }
  return v14;
}

const void *get_glyph_debugging_defaults()
{
  get_BOOLean_property("CGFontDebugGlyphBitmaps", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_bitmap_debugging);

  return get_BOOLean_property("CGFontDebugGlyphs", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&default_glyph_debugging);
}

uint64_t __cmyk_to_rgb_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
  cmyk_to_rgb_info_cmyk_to_rgb_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  CGColorSpaceRef v6 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedSRGB");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v7, 0, v8, v9, v10, (uint64_t)v6);
  cmyk_to_rgb_info_cmyk_to_rgb_extended = result;
  return result;
}

uint64_t __cmyk_to_gray_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  cmyk_to_gray_info_cmyk_to_gradouble y = result;
  return result;
}

uint64_t __rgb_to_cmyk_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  rgb_to_cmyk_info_rgb_to_cmyk = result;
  return result;
}

uint64_t __rgb_to_gray_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceLinearSRGB");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceLinearGray");
  rgb_to_gray_info_rgb_to_gray_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  CGColorSpaceRef v6 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedLinearGray");
  CGColorSpaceRef v7 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedLinearSRGB");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v7, v8, 0, v9, v10, v11, (uint64_t)v6);
  rgb_to_gray_info_rgb_to_gray_extended = result;
  return result;
}

uint64_t __gray_to_cmyk_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  gray_to_cmyk_info_gray_to_cmyk = result;
  return result;
}

uint64_t __gray_to_rgb_info_block_invoke()
{
  CGColorSpaceRef v0 = CGColorSpaceCreateWithName(@"kCGColorSpaceLinearGray");
  CGColorSpaceRef v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceLinearSRGB");
  gray_to_rgb_info_gray_to_rgb_standard = CGColorConversionInfoCreateFromListInternal(0, 0, v0, v2, 0, v3, v4, v5, (uint64_t)v1);
  CGColorSpaceRef v6 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedLinearGray");
  CGColorSpaceRef v7 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedLinearSRGB");
  uint64_t result = CGColorConversionInfoCreateFromListInternal(0, 0, v6, v8, 0, v9, v10, v11, (uint64_t)v7);
  gray_to_rgb_info_gray_to_rgb_extended = result;
  return result;
}

void rle_filter_finalize(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t rle_filter_refill(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2;
  while (result + 128 < a3 && !*(unsigned char *)(a1 + 8))
  {
    int v11 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
    if (v11 == -1) {
      goto LABEL_17;
    }
    int v12 = v11;
    if (v11 <= 127)
    {
      uint64_t v13 = (v11 + 1);
      while (1)
      {
        int v14 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
        if (v14 == -1) {
          break;
        }
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v15 = *(void *)(a1 + 24);
        *(void *)(a1 + 16) = v16 + 1;
        *(unsigned char *)(v15 + v16) = v14;
        if (!--v13) {
          goto LABEL_16;
        }
      }
LABEL_17:
      pdf_error("RunLengthDecode: encountered unexpected EOF.");
LABEL_18:
      *(unsigned char *)(a1 + 8) = 1;
      return *(void *)(a1 + 16);
    }
    if (v11 == 128) {
      goto LABEL_18;
    }
    int v17 = CGPDFSourceGetc(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
    if (v17 == -1) {
      goto LABEL_17;
    }
    LODWORD(v18) = 257 - v12;
    if ((257 - v12) <= 1) {
      uint64_t v18 = 1;
    }
    else {
      uint64_t v18 = v18;
    }
    do
    {
      uint64_t v20 = *(void *)(a1 + 16);
      uint64_t v19 = *(void *)(a1 + 24);
      *(void *)(a1 + 16) = v20 + 1;
      *(unsigned char *)(v19 + v20) = v17;
      --v18;
    }
    while (v18);
LABEL_16:
    uint64_t result = *(void *)(a1 + 16);
  }
  return result;
}

uint64_t rle_filter_rewind(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 8) = 0;
  return CGPDFSourceRewind(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
}

void *PDFImageSetCreate(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  *uint64_t v2 = a1;
  v2[1] = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, &image_key_callbacks, &image_callbacks);
  v2[2] = 0;
  *((_DWORD *)v2 + 8) = 0;
  return v2;
}

void image_release(uint64_t a1, uint64_t a2)
{
}

atomic_uint *image_retain(uint64_t a1, atomic_uint *a2)
{
  uint64_t result = a2;
  if (a2) {
    atomic_fetch_add_explicit(a2, 1u, memory_order_relaxed);
  }
  return result;
}

uint64_t image_key_hash(uint64_t a1)
{
  return *(void *)a1 ^ ((uint64_t)*(int *)(a1 + 8) << 24);
}

BOOL image_key_equal(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0;
  }
  BOOL result = CGColorEqualToColor(*(CGColorRef *)(a1 + 16), *(CGColorRef *)(a2 + 16));
  if (result) {
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
  }
  return result;
}

void image_key_release(int a1, void *a2)
{
  uint64_t v3 = (const void *)a2[2];
  if (v3) {
    CFRelease(v3);
  }

  free(a2);
}

_DWORD *image_key_retain(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = malloc_type_malloc(0x18uLL, 0x10200406E52F545uLL);
  uint64_t v4 = v3;
  if (v3)
  {
    *(void *)uint64_t v3 = *(void *)a2;
    v3[2] = *(_DWORD *)(a2 + 8);
    uint64_t v5 = *(const void **)(a2 + 16);
    if (v5) {
      CFRetain(v5);
    }
    *((void *)v4 + 2) = v5;
  }
  return v4;
}

void PDFImageSetRelease(uint64_t a1)
{
  if (a1)
  {
    CFRelease(*(CFTypeRef *)(a1 + 8));
    CGOrderedSetRelease(*(const void ***)(a1 + 16));
    uint64_t v2 = *(const void **)(a1 + 24);
    if (v2) {
      CFRelease(v2);
    }
    free((void *)a1);
  }
}

const void *add_image(uint64_t a1, uint64_t a2, const void *a3, int a4, unsigned int a5)
{
  CFBooleanRef Value = 0;
  if (a1 && a2)
  {
    if (add_image_predicate != -1) {
      dispatch_once(&add_image_predicate, &__block_literal_global_10870);
    }
    key[0] = add_image_f(a2);
    key[1] = a5;
    key[2] = a3;
    CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), key);
    if (!Value)
    {
      if (a4)
      {
        uint64_t v11 = *(void *)a1;
        int v12 = *(_DWORD *)(a1 + 32) + 1;
        *(_DWORD *)(a1 + 32) = v12;
        uint64_t v13 = (void *)a2;
        int v14 = a3;
        int v15 = a5;
        char v16 = 1;
      }
      else
      {
        CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 24);
        if (v17)
        {
          uint64_t v18 = CFDictionaryGetValue(v17, (const void *)*(unsigned int *)(a2 + 24));
          if (v18)
          {
            uint64_t v19 = v18;
            uint64_t v11 = *(void *)a1;
            int v12 = *(_DWORD *)(a1 + 32) + 1;
            *(_DWORD *)(a1 + 32) = v12;
            uint64_t v13 = 0;
            int v14 = 0;
            int v15 = 0;
            char v16 = 0;
LABEL_13:
            CFBooleanRef Value = create_image(v11, v13, v14, v15, v16, v19, v12);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), key, Value);
            uint64_t v20 = *(const void ***)(a1 + 16);
            if (!v20)
            {
              uint64_t v20 = CGOrderedSetCreate();
              *(void *)(a1 + 16) = v20;
            }
            CGOrderedSetAddValue((CFSetRef *)v20, Value);
            PDFImageRelease((uint64_t)Value);
            return Value;
          }
        }
        uint64_t v11 = *(void *)a1;
        int v12 = *(_DWORD *)(a1 + 32) + 1;
        *(_DWORD *)(a1 + 32) = v12;
        uint64_t v13 = (void *)a2;
        int v14 = 0;
        int v15 = a5;
        char v16 = 0;
      }
      uint64_t v19 = 0;
      goto LABEL_13;
    }
  }
  return Value;
}

void *__add_image_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGLibraryLoadImageIODYLD_once != -1) {
    dispatch_once(&CGLibraryLoadImageIODYLD_once, &__block_literal_global_5_21597);
  }
  if (!CGLibraryLoadImageIODYLD_handle) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 28, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "handle != NULL", "Handle for \"%s\" failed to load", a6, a7, a8, (char)"CGImageGetHash");
  }
  BOOL result = dlsym((void *)CGLibraryLoadImageIODYLD_handle, "CGImageGetHash");
  if (!result) {
    _CGHandleAssert("CGLibraryLoadImageIOFunction", 30, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageIO.h", "ptr != NULL", "Could not find symbol \"%s\" in library handle %p", v9, v10, v11, (char)"CGImageGetHash");
  }
  add_image_f = result;
  return result;
}

uint64_t PDFImageSetEmitDefinitions(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 16);
    if (v2)
    {
      do
      {
        *(void *)(v1 + 16) = 0;
        CFArrayRef v3 = *(const __CFArray **)(v2 + 8);
        v4.length = CFArrayGetCount(v3);
        v4.CFIndex location = 0;
        CFArrayApplyFunction(v3, v4, (CFArrayApplierFunction)emit_image_definition, 0);
        CGOrderedSetRelease((const void **)v2);
        uint64_t v2 = *(void *)(v1 + 16);
      }
      while (v2);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void emit_image_definition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v9 = *(void *)(a1 + 48);
  if (!v9) {
    goto LABEL_19;
  }
  EPSRep = CGImageGetEPSRep(*(void **)(a1 + 48));
  if (EPSRep)
  {
    uint64_t v11 = EPSRep;
    uint64_t v12 = *(void *)(v8 + 8);
    uint64_t v13 = PDFXRefTableAddObject(*(void **)(v12 + 464));
    int v14 = PDFStreamCreateWithObjectNumber(v12, v13);
    char v21 = v14;
    if (v14)
    {
      unint64_t v22 = v14[1];
      unint64_t v23 = v22;
    }
    else
    {
      unint64_t v23 = 0;
      unint64_t v22 = MEMORY[8];
    }
    *(void *)(v8 + 56) = v23;
    PDFDocumentBeginObject(*v14, v22, v15, v16, v17, v18, v19, v20);
    PDFDocumentPrintf(*v21, (uint64_t)"<<", v24, v25, v26, v27, v28, v29, (uint64_t)decode);
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Type /AAPL:EPSData", v30, v31, v32, v33, v34, v35, (uint64_t)decodec);
    PDFStreamBeginData((CGDataConsumerRef)v21);
    CFNumberRef v36 = (CGDataProvider *)v11[2];
    double v37 = (char *)malloc_type_malloc(0x5000uLL, 0x7E6E6EDBuLL);
    CFNumberRef v43 = CGAccessSessionCreate(v36);
    while (1)
    {
      uint64_t Bytes = CGAccessSessionGetBytes(v43, v37, 0x5000uLL, v38, v39, v40, v41, v42);
      if (!Bytes) {
        break;
      }
      CGDataConsumerPutBytes(v21[3], (uint64_t)v37, Bytes);
    }
    CGAccessSessionRelease(v43);
    free(v37);
    PDFStreamEndData(v21);
    PDFStreamEnd((CFDataRef *)v21);
    PDFStreamRelease((uint64_t)v21);
    uint64_t v9 = v11[3];
    if (!v9) {
      goto LABEL_19;
    }
  }
  int v45 = *(_DWORD *)(v9 + 36);
  if ((v45 & 0x2000000) != 0)
  {
    if (*(void *)(v9 + 56) < 2uLL)
    {
      uint64_t v105 = *(void *)(v8 + 16);
      PDFDocumentBeginObject(*(void *)v105, *(void *)(v105 + 8), a3, a4, a5, a6, a7, a8);
      PDFDocumentPrintf(*(void *)v105, (uint64_t)"<<", v106, v107, v108, v109, v110, v111, (uint64_t)decode);
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Type /XObject", v112, v113, v114, v115, v116, v117, (uint64_t)decodei);
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Subtype /Image", v118, v119, v120, v121, v122, v123, (uint64_t)decodej);
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Width %z", v124, v125, v126, v127, v128, v129, *(void *)(v9 + 40));
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Height %z", v130, v131, v132, v133, v134, v135, *(void *)(v9 + 48));
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/ImageMask true", v136, v137, v138, v139, v140, v141, (uint64_t)decodek);
      emit_interpolation(v8, v142, v143, v144, v145, v146, v147, v148, (uint64_t)decodel);
      uint64_t v149 = (uint64_t *)CGImageGetDecode((CGImageRef)v9);
      emit_decode(v8, v149, 2, v150, v151, v152, v153, v154, (uint64_t)decodem);
      if (*(void *)(v8 + 104) != -1) {
        PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/StructParent %d", v155, v156, v157, v158, v159, v160, *(void *)(v8 + 104));
      }
      if (*(unsigned char *)(v8 + 73)) {
        goto LABEL_47;
      }
      if (*(unsigned char *)(v8 + 74))
      {
LABEL_89:
        emit_jpeg2000_data(v8, v9, v155, v156, v157, v158, v159, v160);
        goto LABEL_90;
      }
LABEL_46:
      PDFImageEmitData(v8, (CGImage *)v9);
LABEL_90:
      PDFStreamEnd(*(CFDataRef **)(v8 + 16));
      goto LABEL_202;
    }
    pdf_error("unsupported image mask: bits/component > 1.");
LABEL_19:
    emit_empty_image(v8, a2, a3, a4, a5, a6, a7, a8);
    goto LABEL_202;
  }
  if (*(unsigned char *)(v8 + 72))
  {
    uint64_t v46 = *(void *)(v8 + 16);
    PDFDocumentBeginObject(*(void *)v46, *(void *)(v46 + 8), a3, a4, a5, a6, a7, a8);
    PDFDocumentPrintf(*(void *)v46, (uint64_t)"<<", v47, v48, v49, v50, v51, v52, (uint64_t)decode);
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Type /XObject", v53, v54, v55, v56, v57, v58, (uint64_t)decoded);
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Subtype /Image", v59, v60, v61, v62, v63, v64, (uint64_t)decodee);
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Width %z", v65, v66, v67, v68, v69, v70, *(void *)(v9 + 40));
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Height %z", v71, v72, v73, v74, v75, v76, *(void *)(v9 + 48));
    PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/ColorSpace /DeviceGray", v77, v78, v79, v80, v81, v82, (uint64_t)decodef);
    emit_interpolation(v8, v83, v84, v85, v86, v87, v88, v89, (uint64_t)decodeg);
    BOOL v90 = (uint64_t *)CGImageGetDecode((CGImageRef)v9);
    emit_decode(v8, v90, 2, v91, v92, v93, v94, v95, (uint64_t)decodeh);
    if (*(void *)(v8 + 104) != -1) {
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/StructParent %d", v97, v98, v99, v100, v101, v102, *(void *)(v8 + 104));
    }
    uint64_t v103 = *(void *)(v8 + 64);
    if (v103)
    {
      if (v103 < 0)
      {
        uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(v103, v96, v97, v98, v99, v100, v101, v102);
        uint64_t v103 = *(void *)(v8 + 64);
      }
      else
      {
        uint64_t NumberOfComponents = *(void *)(v103 + 56);
      }
      Components = CGColorGetComponents((CGColorRef)v103);
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/Matte [", v173, v174, v175, v176, v177, v178, (uint64_t)decodea);
      uint64_t v185 = NumberOfComponents - 1;
      if (NumberOfComponents != 1)
      {
        do
        {
          uint64_t v186 = *(void *)Components++;
          PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"%f", v179, v180, v181, v182, v183, v184, v186);
          --v185;
        }
        while (v185);
      }
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"]", v179, v180, v181, v182, v183, v184, (uint64_t)decodeb);
    }
    if (*(unsigned char *)(v8 + 73))
    {
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/BitsPerComponent %z", v97, v98, v99, v100, v101, v102, *(void *)(v9 + 56));
LABEL_47:
      emit_jpeg_data(v8);
      goto LABEL_90;
    }
    if (*(unsigned char *)(v8 + 74))
    {
      PDFDocumentPrintf(*(void *)(v8 + 8), (uint64_t)"/BitsPerComponent %z", v97, v98, v99, v100, v101, v102, *(void *)(v9 + 56));
      goto LABEL_89;
    }
    goto LABEL_46;
  }
  if (*(unsigned char *)(v8 + 74) || (v45 & 0x4000000) == 0)
  {
    uint64_t v187 = v8;
    unsigned int v188 = (uint64_t *)v9;
LABEL_201:
    emit_image(v187, v188, a3, a4, a5, a6, a7, a8);
    goto LABEL_202;
  }
  PixelComponentunsigned int Type = CGImageGetPixelComponentType(v9);
  if (PixelComponentType == 3 || !PixelComponentType) {
    PixelComponentunsigned int Type = CGImageGetUpscaledComponentType((CGImage *)v9);
  }
  if ((unint64_t)PixelComponentType - 6 >= 0xFFFFFFFFFFFFFFFCLL) {
    uint64_t v162 = 2;
  }
  else {
    uint64_t v162 = PixelComponentType;
  }
  image = (CGImage *)v9;
  if (!*(void *)(v9 + 176))
  {
    memset(__src, 0, 304);
    CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
    if ((unint64_t)(v162 - 6) >= 0xFFFFFFFFFFFFFFFDLL) {
      _CGHandleAssert("stream_create_from_image_without_softmask", 284, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "preblended ? CGPixelComponentLessThanOrEqual(pixel_component_type, kCGPixelComponent8BitInteger) : CGPixelComponentLessThanOrEqual(pixel_component_type, kCGPixelComponent16BitInteger)", "preblended %d", v193, v194, v195, 0);
    }
    *(_DWORD *)__vImage_Buffer src = v162;
    *(void *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v189, v190, v191, v192, v193, v194, v195);
    if (v162 == 2) {
      int v196 = 12288;
    }
    else {
      int v196 = 0;
    }
    if ((*(_DWORD *)(v9 + 36) & 0xC000000) != 0) {
      int v197 = 3;
    }
    else {
      int v197 = 0;
    }
    *(_DWORD *)&__src[28] = v196;
    *(_DWORD *)&__src[24] = v197;
    vImagePixelCount v198 = *(void *)(v9 + 40);
    uint64_t v199 = *(CGDataProvider **)(v9 + 48);
    memcpy(__dst, __src, 0x130uLL);
    unint64_t v207 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v200, v201, v202, v203, v204, v205, v206) * v198 + 7) >> 3;
    unint64_t v208 = (*(void *)&__src[8] * v198 + 7) >> 3;
    CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent((CGImageRef)v9);
    memcpy(__dst, __src, 0x130uLL);
    uint64_t v210 = CGDataProviderCreateForDestinationWithImage(0, __dst, v198, v199, (void *)v9, RenderingIntent, 0);
    int v211 = (CGDataProvider *)v210;
    if (v210 && (uint64_t v212 = *(uint64_t (**)(void))(v210 + 168)) != 0) {
      uint64_t v213 = v212(*(void *)(v210 + 24));
    }
    else {
      uint64_t v213 = 0;
    }
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)v9);
    if (*(_DWORD *)&__src[24]) {
      unint64_t v266 = v208;
    }
    else {
      unint64_t v266 = 0;
    }
    memcpy(__dst, __src, 0x130uLL);
    image_stream = create_image_stream(ColorSpace, (uint64_t)__dst, 0, v198, (uint64_t)v199, v207, v266, v207, v266, v213, 0, v211, 0, 0);
    goto LABEL_115;
  }
  Mask = CGImageGetMask((void *)v9);
  if (!Mask) {
    _CGHandleAssert("stream_create_from_image_with_softmask", 449, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "mask != NULL", "mask missing", v164, v165, v166, (char)decode);
  }
  uint64_t v167 = (uint64_t)Mask;
  int v168 = CGImageGetPixelComponentType(v9);
  int v169 = CGImageGetPixelComponentType(v9);
  int v170 = CGImageGetPixelComponentType(v167);
  BOOL v171 = *(void *)(v9 + 40) != *(void *)(v167 + 40) || *(void *)(v9 + 48) != *(void *)(v167 + 48);
  unsigned int v214 = *(_DWORD *)(v9 + 36);
  if ((v214 & 0x4000000) == 0)
  {
    int v215 = (v214 >> 27) & 1;
    if (v168 != v162) {
      int v215 = 1;
    }
    if (((v215 | v171) & 1) == 0 && v169 == v170)
    {
      uint64_t v216 = (CGColorSpace *)CGImageGetMask((void *)v9);
      memset(__src, 0, 304);
      CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
      memset(__dst, 0, 304);
      CGBitmapPixelInfoInitializeWithImage(__dst, __dst, v216);
      if ((unint64_t)CGImageGetPixelComponentType(v9) - 6 >= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v379 = CGImageGetPixelComponentType(v9);
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 329, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "CGPixelComponentLessThanOrEqual(CGImageGetPixelComponentType(image), kCGPixelComponent16BitInteger)", "type %d", v380, v381, v382, v379);
      }
      if ((unint64_t)CGImageGetPixelComponentType((uint64_t)v216) - 6 >= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v383 = CGImageGetPixelComponentType((uint64_t)v216);
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 330, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "CGPixelComponentLessThanOrEqual(CGImageGetPixelComponentType(smask), kCGPixelComponent16BitInteger)", "mask %d", v384, v385, v386, v383);
      }
      *(_DWORD *)__vImage_Buffer src = v162;
      *(void *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v217, v218, v219, v220, v221, v222, v223);
      if (CGImageGetPixelComponentType(v9) == 2) {
        int v231 = 12288;
      }
      else {
        int v231 = 0;
      }
      *(_DWORD *)&__src[28] = v231;
      if (*(_DWORD *)&__src[24]) {
        _CGHandleAssert("stream_create_from_image_and_softmask_providers", 340, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "image_info.alpha_info == kCGImageAlphaNone", "alpha %d", v228, v229, v230, __src[24]);
      }
      LODWORD(__dst[0]) = v162;
      *(void *)&__src[8] = CGPixelComponentGetBitsPerComponent(v162, v224, v225, v226, v227, v228, v229, v230);
      if (CGImageGetPixelComponentType((uint64_t)v216) == 2) {
        int v232 = 12288;
      }
      else {
        int v232 = 0;
      }
      HIDWORD(__dst[1]) = v232;
      vImagePixelCount v233 = *(void *)(v9 + 40);
      uint64_t v234 = *(CGDataProvider **)(v9 + 48);
      memcpy(v412, __src, 0x130uLL);
      CFIndex length = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v412, v235, v236, v237, v238, v239, v240, v241) * v233 + 7) >> 3;
      unint64_t v242 = *(void *)&__src[8] * v233 + 7;
      CGColorRenderingIntent v243 = CGImageGetRenderingIntent((CGImageRef)v9);
      memcpy(v412, __src, 0x130uLL);
      unsigned int v244 = (CGDataProvider *)CGDataProviderCreateForDestinationWithImage(0, v412, v233, v234, (void *)v9, v243, 0);
      CGColorRenderingIntent v245 = CGImageGetRenderingIntent(v216);
      memcpy(v412, __dst, 0x130uLL);
      int v246 = (CGDataProvider *)CGDataProviderCreateForDestinationWithImage(0, v412, v233, v234, v216, v245, 0);
      if (v244 && (unsigned int v247 = (uint64_t (*)(void))*((void *)v244 + 21)) != 0) {
        uint64_t v405 = v247(*((void *)v244 + 3));
      }
      else {
        uint64_t v405 = 0;
      }
      unint64_t v268 = v242 >> 3;
      if (v246 && (unsigned int v269 = (uint64_t (*)(void))*((void *)v246 + 21)) != 0) {
        uint64_t v270 = v269(*((void *)v246 + 3));
      }
      else {
        uint64_t v270 = 0;
      }
      CGColorSpaceRef v271 = CGImageGetColorSpace(image);
      Matte = CGImageGetMatte(image);
      memcpy(v412, __src, 0x130uLL);
      int v264 = create_image_stream(v271, (uint64_t)v412, 0, v233, (uint64_t)v234, length, v268, length, v268, v405, v270, v244, v246, Matte);
      CGDataProviderRelease(v244);
      int v273 = v246;
      goto LABEL_116;
    }
  }
  if ((unint64_t)(v162 - 3) >= 3) {
    int v248 = v162;
  }
  else {
    int v248 = 2;
  }
  if ((unint64_t)(v162 - 6) < 0xFFFFFFFFFFFFFFFBLL) {
    int v249 = 1;
  }
  else {
    int v249 = v248;
  }
  unsigned int v250 = CGImageGetMask((void *)v9);
  int v251 = CGImageGetMatte((void *)v9);
  memset(__src, 0, 304);
  CGBitmapPixelInfoInitializeWithImage(__src, __src, (CGColorSpace *)v9);
  *(_DWORD *)&__src[24] = 3;
  *(_DWORD *)__vImage_Buffer src = v249;
  *(void *)&__src[8] = CGPixelComponentGetBitsPerComponent(v249, v252, v253, v254, v255, v256, v257, v258);
  if (v249 == 2) {
    int v259 = 12288;
  }
  else {
    int v259 = 0;
  }
  *(_DWORD *)&__src[28] = v259;
  vImagePixelCount v260 = *(void *)(v9 + 40);
  uint64_t v261 = *(CGDataProvider **)(v9 + 48);
  if (!v250)
  {
LABEL_106:
    CGColorRenderingIntent v274 = CGImageGetRenderingIntent((CGImageRef)v9);
    memcpy(__dst, __src, 0x130uLL);
    int v211 = (CGDataProvider *)CGDataProviderCreateWithSoftMaskAndMatte(0, __dst, v260, v261, (CGImage *)v9, v274);
    memcpy(__dst, __src, 0x130uLL);
    unint64_t v282 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v275, v276, v277, v278, v279, v280, v281) * v260 + 7) >> 3;
    if (v211)
    {
      uint64_t v283 = (uint64_t (*)(void))*((void *)v211 + 21);
      if (v283) {
        uint64_t v284 = v283(*((void *)v211 + 3));
      }
      else {
        uint64_t v284 = 0;
      }
      unsigned int v285 = (uint64_t (*)(void))*((void *)v211 + 22);
      if (v285)
      {
        uint64_t v286 = v285(*((void *)v211 + 3));
LABEL_114:
        CGColorSpaceRef v287 = CGImageGetColorSpace(image);
        memcpy(__dst, __src, 0x130uLL);
        image_stream = create_image_stream(v287, (uint64_t)__dst, 1, v260, (uint64_t)v261, v282, v282, v282, v282, v284, v286, v211, 0, v251);
LABEL_115:
        int v264 = image_stream;
        int v273 = v211;
LABEL_116:
        CGDataProviderRelease(v273);
        goto LABEL_117;
      }
    }
    else
    {
      uint64_t v284 = 0;
    }
    uint64_t v286 = 0;
    goto LABEL_114;
  }
  vImagePixelCount v262 = v250[5];
  if (v262 - 0x4000000 >= 0xFFFFFFFFFC000001)
  {
    unint64_t v263 = v250[6];
    if (v263 - 0x4000000 >= 0xFFFFFFFFFC000001)
    {
      if (v262 > v260) {
        vImagePixelCount v260 = v250[5];
      }
      if (v263 > (unint64_t)v261) {
        uint64_t v261 = (CGDataProvider *)v250[6];
      }
      goto LABEL_106;
    }
  }
  int v264 = 0;
LABEL_117:
  if (!v264) {
    goto LABEL_200;
  }
  unint64_t v288 = (unint64_t)(*((void *)v264 + 2) * *((void *)v264 + 3) * *((void *)v264 + 39) + 7) >> 3;
  CFAllocatorRef v289 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v288 * *((void *)v264 + 40));
  if (!Mutable) {
    goto LABEL_200;
  }
  CFMutableDataRef v291 = Mutable;
  if (!*((void *)v264 + 42))
  {
    uint64_t v401 = v8;
    CFIndex lengtha = 0;
    uint64_t v293 = 0;
    goto LABEL_123;
  }
  CFIndex lengtha = (unint64_t)(*((void *)v264 + 39) * *((void *)v264 + 2) + 7) >> 3;
  CFMutableDataRef v292 = CFDataCreateMutable(v289, lengtha * *((void *)v264 + 40));
  if (!v292)
  {
    CFRelease(v291);
LABEL_200:
    uint64_t v187 = v8;
    unsigned int v188 = 0;
    goto LABEL_201;
  }
  uint64_t v293 = v292;
  uint64_t v401 = v8;
LABEL_123:
  unint64_t v294 = 0;
  uint64_t v295 = v264 + 8;
  while (1)
  {
    unint64_t v296 = *((void *)v264 + 40);
    BOOL v297 = v296 > v294;
    unint64_t v298 = v296 - v294;
    if (!v297) {
      break;
    }
    if (v298 >= *((void *)v264 + 43)) {
      uint64_t v299 = *((void *)v264 + 43);
    }
    else {
      uint64_t v299 = v298;
    }
    if (v264[521])
    {
      BOOL v300 = *((void *)v264 + 67) == 0;
      uint64_t v301 = (char **)(v264 + 384);
      if (*((void *)v264 + 67)) {
        uint64_t v301 = (char **)(v264 + 368);
      }
    }
    else
    {
      BOOL v300 = 0;
      uint64_t v301 = (char **)(v264 + 368);
    }
    uint64_t ChunksAtPosition = CGAccessSessionGetChunksAtPosition(*((uint64_t **)v264 + 84), *((void *)v264 + 44) * v294, *((void *)v264 + 41), *((void *)v264 + 44) - *((void *)v264 + 41), v299, *v301, 0, a8);
    unint64_t v303 = *((void *)v264 + 41);
    unint64_t v304 = ChunksAtPosition + v303 - 1;
    if (v303 <= 1) {
      unint64_t v305 = 1;
    }
    else {
      unint64_t v305 = *((void *)v264 + 41);
    }
    int v306 = (uint64_t *)*((void *)v264 + 85);
    unint64_t v307 = v304 / v305;
    if (v306)
    {
      uint64_t v308 = v299;
      uint64_t v309 = v304;
      uint64_t v310 = CGAccessSessionGetChunksAtPosition(v306, *((void *)v264 + 45) * v294, *((void *)v264 + 42), *((void *)v264 + 45) - *((void *)v264 + 42), v308, *((char **)v264 + 47), 0, v304);
      unint64_t v304 = v309;
      unint64_t v313 = (unint64_t)(v310 + *((void *)v264 + 42) - 1) / *((void *)v264 + 42);
      if (v313 != v307) {
        _CGHandleAssert("CGImageStreamRead", 576, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageStream.c", "smask_rows_read == rows_read", "%zu %zu", v311, v312, v309, v313);
      }
    }
    *(void *)uint64_t v406 = v294;
    uint64_t v295 = v264 + 8;
    if (!v300) {
      goto LABEL_182;
    }
    uint64_t v314 = *((void *)v264 + 48);
    uint64_t v315 = *((void *)v264 + 39);
    unint64_t v403 = v304;
    memcpy(&__src[40], v264 + 696, 0x130uLL);
    uint64_t v316 = *((void *)v264 + 41);
    uint64_t v317 = *((void *)v264 + 46);
    memcpy((char *)&__dst[2] + 8, v264 + 1000, 0x130uLL);
    int64_t v318 = (vImageConverter *)*((void *)v264 + 86);
    *(void *)__vImage_Buffer src = v314;
    *(void *)&__src[8] = v315;
    *(void *)&__src[16] = v307;
    *(void *)&__src[24] = v316;
    *(void *)&__src[32] = 0;
    *(void *)&__dst[0] = v317;
    *((void *)&__dst[0] + 1) = v315;
    uint64_t v295 = v264 + 8;
    *(void *)&__dst[1] = v307;
    *((void *)&__dst[1] + 1) = v316;
    *(void *)&__dst[2] = 0;
    vImageConverterConvert(v318, (uint64_t)__src, (uint64_t)__dst, 0);
    unint64_t v304 = v403;
    if (v305 > v403) {
      goto LABEL_182;
    }
    uint64_t v319 = 0;
    uint64_t v320 = *((void *)v264 + 89);
    unint64_t v321 = *((void *)v264 + 88);
    uint64_t v323 = (unsigned char *)*((void *)v264 + 47);
    unsigned int v322 = (unsigned __int8 *)*((void *)v264 + 48);
    char v324 = v321 - 24;
    do
    {
      unint64_t v325 = *((void *)v264 + 39);
      if (!v325) {
        goto LABEL_181;
      }
      unsigned int v326 = 0;
      unint64_t v327 = 0;
      unint64_t v328 = 0;
      LODWORD(v329) = 0;
      unint64_t v330 = 0;
      int v331 = v323;
      int v332 = v322;
      do
      {
        if (v320)
        {
          for (uint64_t i = 0; i != v320; ++i)
          {
            if (v321 < 0x19)
            {
              unint64_t v337 = v321;
            }
            else
            {
              if (v329 > 0x17)
              {
                int v335 = v329;
              }
              else
              {
                do
                {
                  unsigned int v334 = *v332++;
                  unint64_t v330 = v334 | (v330 << 8);
                  int v335 = v329 + 8;
                  BOOL v336 = v329 >= 0x10;
                  LODWORD(v329) = v329 + 8;
                }
                while (!v336);
              }
              LODWORD(v329) = v335 - 24;
              unint64_t v337 = v321 - 24;
            }
            if (v337 > v329)
            {
              do
              {
                unsigned int v338 = *v332++;
                unint64_t v330 = v338 | (v330 << 8);
                unint64_t v329 = (v329 + 8);
              }
              while (v337 > v329);
            }
            LODWORD(v329) = v329 - v337;
          }
        }
        if (v321 <= 0x18)
        {
          int v341 = 0;
          unint64_t v342 = v329;
          unint64_t v343 = v321;
        }
        else
        {
          if (v329 > 0x17)
          {
            int v340 = v329;
          }
          else
          {
            do
            {
              unsigned int v339 = *v332++;
              unint64_t v330 = v339 | (v330 << 8);
              int v340 = v329 + 8;
              BOOL v336 = v329 >= 0x10;
              LODWORD(v329) = v329 + 8;
            }
            while (!v336);
          }
          unint64_t v342 = (v340 - 24);
          int v341 = ((v330 >> (v340 - 24)) & 0xFFFFFF) << v324;
          LODWORD(v329) = v342;
          unint64_t v343 = v321 - 24;
        }
        if (v343 > v342)
        {
          do
          {
            unsigned int v344 = *v332++;
            unint64_t v330 = v344 | (v330 << 8);
            unint64_t v329 = (v329 + 8);
          }
          while (v343 > v329);
        }
        LODWORD(v329) = v329 - v343;
        unint64_t v345 = (v330 >> v329) & ~(-1 << v343) | v341;
        if (v321 < 0x19)
        {
          int v347 = v321;
          if (v326 < 8) {
            goto LABEL_175;
          }
        }
        else
        {
          uint64_t v346 = v326 - 8;
          if (v326 >= 8)
          {
            do
            {
              *v331++ = v328 >> v346;
              v346 -= 8;
              v326 -= 8;
            }
            while (v326 > 7);
          }
          v326 |= 0x18u;
          unint64_t v328 = (v345 >> v324) & 0xFFFFFF | (v328 << 24);
          int v347 = v321 - 24;
        }
        uint64_t v348 = v326 - 8;
        do
        {
          v326 -= 8;
          *v331++ = v328 >> v348;
          v348 -= 8;
        }
        while (v326 > 7);
        unint64_t v325 = *((void *)v264 + 39);
LABEL_175:
        unint64_t v328 = (v328 << v347) | v345 & ~(-1 << v347);
        v326 += v347;
        ++v327;
      }
      while (v327 < v325);
      if (v331 && v326)
      {
        do
        {
          unsigned int v349 = v326;
          uint64_t v350 = v326 - 8;
          if (v326 >= 8)
          {
            do
            {
              *v331++ = v328 >> v350;
              v350 -= 8;
              v349 -= 8;
            }
            while (v349 > 7);
          }
          int v351 = -v326 & 7;
          v328 <<= v351;
          unsigned int v326 = v349 + v351;
        }
        while (v326);
      }
LABEL_181:
      v322 += *((void *)v264 + 41);
      v323 += *((void *)v264 + 42);
      ++v319;
    }
    while (v319 != v307);
LABEL_182:
    if (v305 > v304) {
      break;
    }
    uint64_t v352 = 0;
    do
    {
      CFDataAppendBytes(v291, (const UInt8 *)(*((void *)v264 + 46) + *((void *)v264 + 41) * v352), v288);
      if (v293) {
        CFDataAppendBytes(v293, (const UInt8 *)(*((void *)v264 + 47) + *((void *)v264 + 42) * v352), lengtha);
      }
      ++v352;
    }
    while (v307 != v352);
    unint64_t v294 = v307 + *(void *)v406;
  }
  uint64_t v353 = CGDataProviderCreateWithCFData(v291);
  CFRelease(v291);
  BOOL shouldInterpolate = CGImageGetShouldInterpolate(image);
  CGColorRenderingIntent intent = CGImageGetRenderingIntent(image);
  CopyWithStandarduint64_t Range = CGColorSpaceCreateCopyWithStandardRange(*(CGColorSpaceRef *)v264);
  uint64_t v355 = v295;
  size_t v357 = *((void *)v264 + 39);
  size_t v356 = *((void *)v264 + 40);
  size_t v358 = *((void *)v264 + 2);
  size_t v359 = *((void *)v264 + 3) * v358;
  memcpy(__src, v355, 0x130uLL);
  int CGImageBitmapInfo = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__src);
  CGImageRef v361 = CGImageCreate(v357, v356, v358, v359, v288, CopyWithStandardRange, CGImageBitmapInfo & 0xFFFFFFE0, v353, *((const CGFloat **)v264 + 6), shouldInterpolate, intent);
  CGDataProviderRelease(v353);
  CGColorSpaceRelease(CopyWithStandardRange);
  if (v293)
  {
    unsigned int v362 = CGDataProviderCreateWithCFData(v293);
    CFRelease(v293);
    DeviceGradouble y = CGColorSpaceCreateDeviceGray();
    size_t v364 = *((void *)v264 + 39);
    size_t v365 = *((void *)v264 + 40);
    size_t v366 = *((void *)v264 + 2);
    memcpy(__src, v355, 0x130uLL);
    int v367 = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__src);
    CGImageRef v368 = CGImageCreate(v364, v365, v366, v366, lengtha, DeviceGray, v367 & 0xFFFFFFE0, v362, 0, 0, kCGRenderingIntentDefault);
    CGColorSpaceRelease(DeviceGray);
    CGDataProviderRelease(v362);
    if (v264[520]) {
      uint64_t v369 = (uint64_t *)(v264 + 392);
    }
    else {
      uint64_t v369 = 0;
    }
    uint64_t v370 = (uint64_t *)CGImageCreateWithMaskAndMatte((uint64_t)v361, (uint64_t)v368, v369);
    uint64_t v8 = v401;
    if (v361) {
      CFRelease(v361);
    }
    if (v368) {
      CFRelease(v368);
    }
  }
  else
  {
    uint64_t v370 = (uint64_t *)v361;
    uint64_t v8 = v401;
  }
  CGImageStreamRelease(v264);
  emit_image(v8, v370, v371, v372, v373, v374, v375, v376);
  if (v370) {
    CFRelease(v370);
  }
LABEL_202:
  unsigned int v377 = *(const void **)(v8 + 48);
  if (v377) {
    CFRelease(v377);
  }
  *(void *)(v8 + 48) = 0;
  unsigned int v378 = *(const void **)(v8 + 80);
  if (v378)
  {
    CFRelease(v378);
    *(void *)(v8 + 80) = 0;
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(v8 + 88));
  *(void *)(v8 + 88) = 0;
}

char *CGContextCopyTopGState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v8 = *(void *)(a1 + 96);
    return CGGStateCreateCopy(v8);
  }
  else
  {
    handle_invalid_context((char)"CGContextCopyTopGState", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
}

void CGContextReplaceTopGState(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (a2)
      {
        uint64_t v10 = (uint64_t *)*((void *)c + 13);
        uint64_t v11 = (uint64_t *)v10[1];
        if (v11 != v10)
        {
          uint64_t v13 = *v11;
          uint64_t v12 = (void *)v11[1];
          *(void *)(v13 + 8) = v12;
          *uint64_t v12 = v13;
          *uint64_t v11 = (uint64_t)v11;
          v11[1] = (uint64_t)v11;
          CGGStateRelease((uint64_t)v11);
        }
        Copdouble y = CGGStateCreateCopy(a2);
        uint64_t v15 = (char **)v10[1];
        v10[1] = (uint64_t)Copy;
        *(void *)Copdouble y = v10;
        *uint64_t v15 = Copy;
        *((void *)Copy + 1) = v15;
        *((void *)c + 12) = v10[1];
      }
      else
      {
        CGContextResetTopGState(c, 0, a3, a4, a5, a6, a7, a8);
      }
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextReplaceTopGState", (uint64_t)v16, a3, a4, a5, a6, a7, a8);
}

void CGContextResetTopGState(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      *(CGAffineTransform *)(*((void *)c + 12) + 24) = CGAffineTransformIdentity;
      CGContextResetClip(c);
      uint64_t v9 = *((void *)c + 12);
      CGGStateReset(v9);
      return;
    }
    CGContextRef v10 = c;
  }
  else
  {
    CGContextRef v10 = 0;
  }

  handle_invalid_context((char)"CGContextResetTopGState", (uint64_t)v10, a3, a4, a5, a6, a7, a8);
}

void CGContextResetCTM(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    *(CGAffineTransform *)(*(void *)(a1 + 96) + 24) = CGAffineTransformIdentity;
  }
  else {
    handle_invalid_context((char)"CGContextResetCTM", a1, a3, a4, a5, a6, a7, a8);
  }
}

double CGContextGetLineWidth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 128) + 8);
  }
  handle_invalid_context((char)"CGContextGetLineWidth", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetLineCap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(char *)(*(void *)(*(void *)(a1 + 96) + 128) + 2);
  }
  handle_invalid_context((char)"CGContextGetLineCap", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetLineJoin(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(char *)(*(void *)(*(void *)(a1 + 96) + 128) + 3);
  }
  handle_invalid_context((char)"CGContextGetLineJoin", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetMiterLimit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 128) + 16);
  }
  handle_invalid_context((char)"CGContextGetMiterLimit", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetLineDashCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 96) + 128) + 32);
    if (v8) {
      return *(void *)(v8 + 16);
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetLineDashCount", a1, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

double CGContextGetLineDashPattern(uint64_t a1, double *a2, double *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double result)
{
  if (!a1)
  {
    uint64_t v10 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextGetLineDashPattern", v10, (uint64_t)a3, a4, a5, a6, a7, a8);
    return result;
  }
  if (*(_DWORD *)(a1 + 16) != 1129601108)
  {
    uint64_t v10 = a1;
    goto LABEL_7;
  }
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 96) + 128) + 32);
  if (a2)
  {
    if (v9) {
      BOOL result = *(double *)(v9 + 8);
    }
    else {
      BOOL result = 0.0;
    }
    *a2 = result;
  }
  if (v9) {
    unint64_t v11 = *(void *)(v9 + 16);
  }
  else {
    unint64_t v11 = 0;
  }
  if (v9) {
    uint64_t v12 = (double *)(v9 + 24);
  }
  else {
    uint64_t v12 = 0;
  }
  if (v11 >= a4) {
    unint64_t v11 = a4;
  }
  for (; v11; --v11)
  {
    double v13 = *v12++;
    BOOL result = v13;
    *a3++ = v13;
  }
  return result;
}

uint64_t CGContextGetRenderingIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return ((int)(*(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 120) + 4) << 12) >> 28);
  }
  handle_invalid_context((char)"CGContextGetRenderingIntent", a1, a3, a4, a5, a6, a7, a8);
  return 2;
}

BOOL CGContextGetStrokeAdjust(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + 128) + 1) != 0;
  }
  handle_invalid_context((char)"CGContextGetStrokeAdjust", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetStrokeAdjust(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v9 = *(void *)(a1 + 96);
    if (*(unsigned __int8 *)(*(void *)(v9 + 128) + 1) != a2)
    {
      maybe_copy_stroke_state(*(void *)(a1 + 96));
      *(unsigned char *)(*(void *)(v9 + 128) + 1) = v8;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetStrokeAdjust", a1, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t CGContextGetFillColorAsColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v8 = *(void *)(a1 + 96);
    return CGGStateGetFillColor(v8);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetFillColorAsColor", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
}

uint64_t CGContextGetStrokeColorAsColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v8 = *(void *)(a1 + 96);
    return CGGStateGetStrokeColor(v8);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetStrokeColorAsColor", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
}

unint64_t CGContextGetFillColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    unint64_t result = CGGStateGetFillColor(*(void *)(a1 + 96));
    if (result)
    {
      if ((result & 0x8000000000000000) != 0)
      {
        return (unint64_t)CGTaggedColorGetColorSpace(result, v9, v10, v11, v12, v13, v14, v15);
      }
      else
      {
        return *(void *)(result + 24);
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetFillColorSpace", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  return result;
}

unint64_t CGContextGetStrokeColorSpace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    unint64_t result = CGGStateGetStrokeColor(*(void *)(a1 + 96));
    if (result)
    {
      if ((result & 0x8000000000000000) != 0)
      {
        return (unint64_t)CGTaggedColorGetColorSpace(result, v9, v10, v11, v12, v13, v14, v15);
      }
      else
      {
        return *(void *)(result + 24);
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextGetStrokeColorSpace", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  return result;
}

void CGContextGetFillColor(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t FillColor = CGGStateGetFillColor(*(void *)(a1 + 96));
    Components = CGColorGetComponents((CGColorRef)FillColor);
    if (!FillColor) {
      return;
    }
    uint64_t v18 = Components;
    if (FillColor < 0)
    {
      uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(FillColor, v11, v12, v13, v14, v15, v16, v17);
      if (!NumberOfComponents) {
        return;
      }
    }
    else
    {
      uint64_t NumberOfComponents = *(void *)(FillColor + 56);
      if (!NumberOfComponents) {
        return;
      }
    }
    do
    {
      uint64_t v20 = *(void *)v18++;
      *a2++ = v20;
      --NumberOfComponents;
    }
    while (NumberOfComponents);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetFillColor", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGContextGetStrokeColor(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t StrokeColor = CGGStateGetStrokeColor(*(void *)(a1 + 96));
    Components = CGColorGetComponents((CGColorRef)StrokeColor);
    if (!StrokeColor) {
      return;
    }
    uint64_t v18 = Components;
    if (StrokeColor < 0)
    {
      uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(StrokeColor, v11, v12, v13, v14, v15, v16, v17);
      if (!NumberOfComponents) {
        return;
      }
    }
    else
    {
      uint64_t NumberOfComponents = *(void *)(StrokeColor + 56);
      if (!NumberOfComponents) {
        return;
      }
    }
    do
    {
      uint64_t v20 = *(void *)v18++;
      *a2++ = v20;
      --NumberOfComponents;
    }
    while (NumberOfComponents);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetStrokeColor", a1, a3, a4, a5, a6, a7, a8);
  }
}

void CGContextSetFillPattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (!pattern || !components)
      {
        CGPostError((uint64_t)"%s: pattern and components may not be NULL.", (uint64_t)pattern, (uint64_t)components, v3, v4, v5, v6, v7, (char)"CGContextSetFillPattern");
        return;
      }
      unint64_t FillColor = CGGStateGetFillColor(*((void *)c + 12));
      if (FillColor)
      {
        unint64_t v19 = FillColor;
        if ((FillColor & 0x8000000000000000) != 0)
        {
          CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(FillColor, v12, v13, v14, v15, v16, v17, v18);
          if (ColorSpace) {
            goto LABEL_8;
          }
        }
        else
        {
          CGColorSpaceRef ColorSpace = *(CGColorSpace **)(FillColor + 24);
          if (ColorSpace)
          {
LABEL_8:
            if (CGColorSpaceGetType(ColorSpace) == 9)
            {
              if ((CGColorEqualToColorComponents(v19, (uint64_t)ColorSpace, (uint64_t)pattern, components, v24, v25, v26, v27) & 1) == 0)
              {
                uint64_t v28 = CGColorCreateWithPattern(ColorSpace, pattern, components);
                CGContextSetFillColorWithColor(c, v28);
                if (v28)
                {
                  CFRelease(v28);
                }
              }
            }
            else
            {
              CGPostError((uint64_t)"%s: pattern specified with non-pattern color space.", v21, v22, v23, v24, v25, v26, v27, (char)"CGContextSetFillPattern");
            }
            return;
          }
        }
      }
      CGPostError((uint64_t)"%s: no color space specified for fill pattern.", v12, v13, v14, v15, v16, v17, v18, (char)"CGContextSetFillPattern");
      return;
    }
    CGContextRef v29 = c;
  }
  else
  {
    CGContextRef v29 = 0;
  }

  handle_invalid_context((char)"CGContextSetFillPattern", (uint64_t)v29, (uint64_t)components, v3, v4, v5, v6, v7);
}

uint64_t CGContextGetFillPattern(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetFillPattern", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  uint64_t FillColor = CGGStateGetFillColor(*(void *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)FillColor);
  if (!FillColor) {
    return 0;
  }
  uint64_t v18 = Components;
  if (FillColor < 0)
  {
    uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(FillColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t NumberOfComponents = *(void *)(FillColor + 56);
    if (!NumberOfComponents) {
      goto LABEL_11;
    }
  }
  do
  {
    uint64_t v21 = *(void *)v18++;
    *a2++ = v21;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
LABEL_11:
  if (FillColor < 1) {
    return 0;
  }
  return *(void *)(FillColor + 32);
}

void CGContextSetStrokePattern(CGContextRef c, CGPatternRef pattern, const CGFloat *components)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (!pattern || !components)
      {
        CGPostError((uint64_t)"%s: pattern and components may not be NULL.", (uint64_t)pattern, (uint64_t)components, v3, v4, v5, v6, v7, (char)"CGContextSetStrokePattern");
        return;
      }
      unint64_t StrokeColor = CGGStateGetStrokeColor(*((void *)c + 12));
      if (StrokeColor)
      {
        unint64_t v19 = StrokeColor;
        if ((StrokeColor & 0x8000000000000000) != 0)
        {
          CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(StrokeColor, v12, v13, v14, v15, v16, v17, v18);
          if (ColorSpace) {
            goto LABEL_8;
          }
        }
        else
        {
          CGColorSpaceRef ColorSpace = *(CGColorSpace **)(StrokeColor + 24);
          if (ColorSpace)
          {
LABEL_8:
            if (CGColorSpaceGetType(ColorSpace) == 9)
            {
              if ((CGColorEqualToColorComponents(v19, (uint64_t)ColorSpace, (uint64_t)pattern, components, v24, v25, v26, v27) & 1) == 0)
              {
                uint64_t v28 = CGColorCreateWithPattern(ColorSpace, pattern, components);
                CGContextSetStrokeColorWithColor(c, v28);
                if (v28)
                {
                  CFRelease(v28);
                }
              }
            }
            else
            {
              CGPostError((uint64_t)"%s: pattern specified with non-pattern color space.", v21, v22, v23, v24, v25, v26, v27, (char)"CGContextSetStrokePattern");
            }
            return;
          }
        }
      }
      CGPostError((uint64_t)"%s: no color space specified for stroke pattern.", v12, v13, v14, v15, v16, v17, v18, (char)"CGContextSetStrokePattern");
      return;
    }
    CGContextRef v29 = c;
  }
  else
  {
    CGContextRef v29 = 0;
  }

  handle_invalid_context((char)"CGContextSetStrokePattern", (uint64_t)v29, (uint64_t)components, v3, v4, v5, v6, v7);
}

uint64_t CGContextGetStrokePattern(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextGetStrokePattern", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
  uint64_t StrokeColor = CGGStateGetStrokeColor(*(void *)(a1 + 96));
  Components = CGColorGetComponents((CGColorRef)StrokeColor);
  if (!StrokeColor) {
    return 0;
  }
  uint64_t v18 = Components;
  if (StrokeColor < 0)
  {
    uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(StrokeColor, v11, v12, v13, v14, v15, v16, v17);
    if (!NumberOfComponents) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t NumberOfComponents = *(void *)(StrokeColor + 56);
    if (!NumberOfComponents) {
      goto LABEL_11;
    }
  }
  do
  {
    uint64_t v21 = *(void *)v18++;
    *a2++ = v21;
    --NumberOfComponents;
  }
  while (NumberOfComponents);
LABEL_11:
  if (StrokeColor < 1) {
    return 0;
  }
  return *(void *)(StrokeColor + 32);
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  v18[2] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v18[0] = gray;
      v18[1] = alpha;
      DeviceGradouble y = CGColorSpaceCreateDeviceGray();
      set_fill_color_with_components((uint64_t *)c, DeviceGray, v18, v11, v12, v13, v14, v15, v17);
      CGColorSpaceRelease(DeviceGray);
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextSetGrayFillColor", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
}

void CGContextSetGrayStrokeColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  v18[2] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v18[0] = gray;
      v18[1] = alpha;
      DeviceGradouble y = CGColorSpaceCreateDeviceGray();
      set_stroke_color_with_components((uint64_t *)c, DeviceGray, v18, v11, v12, v13, v14, v15, v17);
      CGColorSpaceRelease(DeviceGray);
      return;
    }
    CGContextRef v16 = c;
  }
  else
  {
    CGContextRef v16 = 0;
  }

  handle_invalid_context((char)"CGContextSetGrayStrokeColor", (uint64_t)v16, v3, v4, v5, v6, v7, v8);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  v20[4] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      v20[0] = red;
      v20[1] = green;
      v20[2] = blue;
      v20[3] = alpha;
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      set_stroke_color_with_components((uint64_t *)c, DeviceRGB, v20, v13, v14, v15, v16, v17, v19);
      CGColorSpaceRelease(DeviceRGB);
      return;
    }
    CGContextRef v18 = c;
  }
  else
  {
    CGContextRef v18 = 0;
  }

  handle_invalid_context((char)"CGContextSetRGBStrokeColor", (uint64_t)v18, v5, v6, v7, v8, v9, v10);
}

void CGContextSetCMYKFillColor(CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)
{
  CGFloat v20[5] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      LOBYTE(v20[0]) = LOBYTE(cyan);
      v20[1] = magenta;
      v20[2] = yellow;
      v20[3] = black;
      v20[4] = alpha;
      DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      set_fill_color_with_components((uint64_t *)c, DeviceCMYK, v20, v14, v15, v16, v17, v18, SLOBYTE(v20[0]));
      CGColorSpaceRelease(DeviceCMYK);
      return;
    }
    CGContextRef v19 = c;
  }
  else
  {
    CGContextRef v19 = 0;
  }

  handle_invalid_context((char)"CGContextSetCMYKFillColor", (uint64_t)v19, v6, v7, v8, v9, v10, v11);
}

void CGContextSetCMYKStrokeColor(CGContextRef c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha)
{
  CGFloat v20[5] = *(CGFloat *)MEMORY[0x1E4F143B8];
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      LOBYTE(v20[0]) = LOBYTE(cyan);
      v20[1] = magenta;
      v20[2] = yellow;
      v20[3] = black;
      v20[4] = alpha;
      DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      set_stroke_color_with_components((uint64_t *)c, DeviceCMYK, v20, v14, v15, v16, v17, v18, SLOBYTE(v20[0]));
      CGColorSpaceRelease(DeviceCMYK);
      return;
    }
    CGContextRef v19 = c;
  }
  else
  {
    CGContextRef v19 = 0;
  }

  handle_invalid_context((char)"CGContextSetCMYKStrokeColor", (uint64_t)v19, v6, v7, v8, v9, v10, v11);
}

uint64_t CGContextGetFont(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 136) + 8);
  }
  handle_invalid_context((char)"CGContextGetFont", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetFontSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 136) + 16);
  }
  handle_invalid_context((char)"CGContextGetFontSize", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

double CGContextGetCharacterSpacing(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 136) + 24);
  }
  handle_invalid_context((char)"CGContextGetCharacterSpacing", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetTextDrawingMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(char *)(*(void *)(*(void *)(a1 + 96) + 136) + 1);
  }
  handle_invalid_context((char)"CGContextGetTextDrawingMode", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

double CGContextGetTextGreekingThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 136) + 32);
  }
  handle_invalid_context((char)"CGContextGetTextGreekingThreshold", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

void CGContextSetTextGreekingThreshold(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v10 = *(void *)(a1 + 96);
    if (*(double *)(*(void *)(v10 + 136) + 32) != a2)
    {
      maybe_copy_text_state(*(void *)(a1 + 96));
      *(double *)(*(void *)(v10 + 136) + 32) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetTextGreekingThreshold", a1, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CGContextGetShouldAntialiasFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 2) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldAntialiasFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldAntialiasFonts(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetShouldAntialiasFonts(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldAntialiasFonts", v8, a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextGetShouldSmoothFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 3) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldSmoothFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldSmoothFonts(CGContextRef c, BOOL shouldSmoothFonts)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetShouldSmoothFonts(*((void *)c + 12), shouldSmoothFonts);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldSmoothFonts", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t CGContextGetShouldSubpixelPositionFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 4) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldSubpixelPositionFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldSubpixelPositionFonts(CGContextRef c, BOOL shouldSubpixelPositionFonts)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetShouldSubpixelPositionFonts(*((void *)c + 12), shouldSubpixelPositionFonts);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldSubpixelPositionFonts", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t CGContextGetShouldSubpixelQuantizeFonts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 5) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldSubpixelQuantizeFonts", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldSubpixelQuantizeFonts(CGContextRef c, BOOL shouldSubpixelQuantizeFonts)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetShouldSubpixelQuantizeFonts(*((void *)c + 12), shouldSubpixelQuantizeFonts);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldSubpixelQuantizeFonts", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t CGContextGetShouldUsePlatformNativeGlyphs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (**(unsigned __int16 **)(*(void *)(a1 + 96) + 136) >> 6) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldUsePlatformNativeGlyphs", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

void CGContextSetShouldUsePlatformNativeGlyphs(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetShouldUsePlatformNativeGlyphs(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetShouldUsePlatformNativeGlyphs", v8, a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextGetFontAntialiasingStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned int *)(*(void *)(*(void *)(a1 + 96) + 136) + 48);
  }
  handle_invalid_context((char)"CGContextGetFontAntialiasingStyle", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontAntialiasingStyle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    HIDWORD(v10) = a2;
    LODWORD(v10) = a2;
    unsigned int v9 = v10 >> 7;
    if (v9 <= 9 && ((1 << v9) & 0x30F) != 0)
    {
      uint64_t v11 = *(void *)(a1 + 96);
      if (*(_DWORD *)(*(void *)(v11 + 136) + 48) != a2)
      {
        maybe_copy_text_state(*(void *)(a1 + 96));
        *(_DWORD *)(*(void *)(v11 + 136) + 48) = a2;
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontAntialiasingStyle", a1, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t CGContextGetFontSmoothingStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned int *)(*(void *)(*(void *)(a1 + 96) + 136) + 52);
  }
  handle_invalid_context((char)"CGContextGetFontSmoothingStyle", a1, a3, a4, a5, a6, a7, a8);
  return 48;
}

void CGContextSetFontSmoothingStyle(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    HIDWORD(v9) = a2;
    LODWORD(v9) = a2 - 16;
    if ((v9 >> 4) <= 6)
    {
      uint64_t v10 = *(void *)(a1 + 96);
      if (*(_DWORD *)(*(void *)(v10 + 136) + 52) != a2)
      {
        maybe_copy_text_state(*(void *)(a1 + 96));
        *(_DWORD *)(*(void *)(v10 + 136) + 52) = a2;
      }
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontSmoothingStyle", a1, a3, a4, a5, a6, a7, a8);
  }
}

double CGContextGetFontSmoothingContrast(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 136) + 40);
  }
  handle_invalid_context((char)"CGContextGetFontSmoothingContrast", a1, a3, a4, a5, a6, a7, a8);
  return 1.0;
}

void CGContextSetFontSmoothingContrast(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v10 = *(void *)(a1 + 96);
    if (*(double *)(*(void *)(v10 + 136) + 40) != a2)
    {
      maybe_copy_text_state(*(void *)(a1 + 96));
      *(double *)(*(void *)(v10 + 136) + 40) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontSmoothingContrast", a1, a4, a5, a6, a7, a8, a9);
  }
}

uint64_t CGContextGetFontSmoothingBackgroundColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 136) + 64);
  }
  handle_invalid_context((char)"CGContextGetFontSmoothingBackgroundColor", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontSmoothingBackgroundColor(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetFontSmoothingBackgroundColor(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFontSmoothingBackgroundColor", v8, a3, a4, a5, a6, a7, a8);
}

double CGContextGetDeviceClipBoundingBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return get_device_clip_bounding_box(a1);
  }
  handle_invalid_context((char)"CGContextGetDeviceClipBoundingBox", a1, a3, a4, a5, a6, a7, a8);
  return INFINITY;
}

double CGContextGetFlatness(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 144) + 8);
  }
  handle_invalid_context((char)"CGContextGetFlatness", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetFillOverprint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 96) + 144) + 24);
  }
  handle_invalid_context((char)"CGContextGetFillOverprint", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetStrokeOverprint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 96) + 144) + 25);
  }
  handle_invalid_context((char)"CGContextGetStrokeOverprint", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetOverprintMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned int *)(*(void *)(*(void *)(a1 + 96) + 144) + 28);
  }
  handle_invalid_context((char)"CGContextGetOverprintMode", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetBlackGeneration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 144) + 32);
  }
  handle_invalid_context((char)"CGContextGetBlackGeneration", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetUndercolorRemoval(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 144) + 40);
  }
  handle_invalid_context((char)"CGContextGetUndercolorRemoval", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t CGContextGetTransferFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108) {
    handle_invalid_context((char)"CGContextGetTransferFunctions", a1, a3, a4, a5, a6, a7, a8);
  }
  return 0;
}

void CGContextSetTransferFunctions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108) {
    handle_invalid_context((char)"CGContextSetTransferFunctions", a1, a3, a4, a5, a6, a7, a8);
  }
}

double CGContextGetSmoothness(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 144) + 16);
  }
  handle_invalid_context((char)"CGContextGetSmoothness", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetShouldAntialias(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(unsigned char *)(*(void *)(*(void *)(a1 + 96) + 120) + 7) & 1;
  }
  handle_invalid_context((char)"CGContextGetShouldAntialias", a1, a3, a4, a5, a6, a7, a8);
  return 1;
}

uint64_t CGContextGetImageRenderingIntent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    unsigned int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 120) + 4);
    if (((v8 >> 20) & 0xF) != 0) {
      int v9 = v8 << 8;
    }
    else {
      int v9 = v8 << 12;
    }
    return (v9 >> 28);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetImageRenderingIntent", a1, a3, a4, a5, a6, a7, a8);
    return 3;
  }
}

double CGContextGetLineWidthThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 128) + 24);
  }
  handle_invalid_context((char)"CGContextGetLineWidthThreshold", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

void CGContextSetLineWidthThreshold(uint64_t a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v10 = *(void *)(a1 + 96);
    if (*(double *)(*(void *)(v10 + 128) + 24) != a2)
    {
      maybe_copy_stroke_state(*(void *)(a1 + 96));
      *(double *)(*(void *)(v10 + 128) + 24) = a2;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetLineWidthThreshold", a1, a4, a5, a6, a7, a8, a9);
  }
}

double CGContextGetAdjustedLineWidth(CGContext *c, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v8 = *((void *)c + 12);
    CGContextGetUserSpaceToDeviceSpaceTransform(&v10, c);
    return CGGStateGetAdjustedLineWidth(v8, &v10.a);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetAdjustedLineWidth", (uint64_t)c, a3, a4, a5, a6, a7, a8);
    return 0.0;
  }
}

double CGContextGetPatternPhase(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 120) + 24);
  }
  handle_invalid_context((char)"CGContextGetPatternPhase", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetAlphaIsShape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return (*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 96) + 120) + 7) >> 1) & 1;
  }
  handle_invalid_context((char)"CGContextGetAlphaIsShape", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontDilation(uint64_t a1, double a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    CGGStateSetFontDilation(*(void *)(a1 + 96), a2, a3);
  }
  else {
    handle_invalid_context((char)"CGContextSetFontDilation", a1, a5, a6, a7, a8, a9, a10);
  }
}

double CGContextGetFontDilation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(double *)(*(void *)(*(void *)(a1 + 96) + 136) + 72);
  }
  handle_invalid_context((char)"CGContextGetFontDilation", a1, a3, a4, a5, a6, a7, a8);
  return 0.0;
}

uint64_t CGContextGetFontSubpixelQuantizationLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(*(void *)(*(void *)(a1 + 96) + 136) + 88);
  }
  handle_invalid_context((char)"CGContextGetFontSubpixelQuantizationLevel", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void CGContextSetFontSubpixelQuantizationLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 96);
      unint64_t v9 = HIDWORD(a2);
      unsigned int v10 = a2 & ~((int)a2 >> 31);
      if (SHIDWORD(a2) >= 128) {
        LODWORD(v9) = 128;
      }
      if (v10 >= 0x80) {
        uint64_t v11 = 128;
      }
      else {
        uint64_t v11 = v10;
      }
      if (a2 >= 0) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 0;
      }
      if (*(void *)(*(void *)(v8 + 136) + 88) != (v11 | (v12 << 32)))
      {
        maybe_copy_text_state(v8);
        uint64_t v13 = *(void *)(v8 + 136);
        *(_DWORD *)(v13 + 88) = v11;
        *(_DWORD *)(v13 + 92) = v12;
      }
      return;
    }
    uint64_t v14 = a1;
  }
  else
  {
    uint64_t v14 = 0;
  }

  handle_invalid_context((char)"CGContextSetFontSubpixelQuantizationLevel", v14, a3, a4, a5, a6, a7, a8);
}

void CGEnterLockdownModeForPDF()
{
  sInLockdownModeForPDF = 1;
}

void CGEnterLockdownModeForFonts()
{
  sInLockdownModeForFonts = 1;
}

void PDFAnnotationSetRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)a1[4];
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t __CGPDFTextStringGetTypeID_block_invoke()
{
  uint64_t result = pdf_register_cftype((uint64_t)&CGPDFTextStringGetTypeID_class);
  CGPDFTextStringGetTypeID_id = result;
  return result;
}

void *CGPDFTextStringFinalize(uint64_t a1)
{
  for (uint64_t result = *(void **)(a1 + 24); result; uint64_t result = *(void **)(a1 + 24))
  {
    *(void *)(a1 + 24) = *result;
    text_block_release(result);
  }
  return result;
}

void text_block_release(void *a1)
{
  uint64_t v2 = (const void *)a1[3];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[4];
  if (v3) {
    CFRelease(v3);
  }

  free(a1);
}

CFTypeRef CGPDFTextStringRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

void CGPDFTextStringRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGPDFTextStringGetLength(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

void *CGPDFTextStringGetCharacterAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t result = find_block(a1, a2);
  if (result) {
    return (void *)WORD1(result[4 * (a2 - result[1]) + 14]);
  }
  return result;
}

void *find_block(uint64_t a1, unint64_t a2)
{
  uint64_t result = *(void **)(a1 + 40);
  if (result && result[1] <= a2 || (uint64_t result = *(void **)(a1 + 24)) != 0)
  {
    while (result[2] + result[1] <= a2)
    {
      uint64_t result = (void *)*result;
      if (!result) {
        return result;
      }
    }
    *(void *)(a1 + 40) = result;
  }
  return result;
}

void *CGPDFTextStringGetGlyphAtIndex(uint64_t a1, unint64_t a2)
{
  uint64_t result = find_block(a1, a2);
  if (result) {
    return (void *)LOWORD(result[4 * (a2 - result[1]) + 14]);
  }
  return result;
}

CGFloat CGPDFTextStringGetPositionForIndex(uint64_t a1, unint64_t a2, void *a3)
{
  block = find_block(a1, a2);
  if (block)
  {
    unint64_t v6 = a2 - block[1];
    if (a3)
    {
      *a3 = block[4 * v6 + 13];
      a3[1] = 0;
    }
    uint64_t v7 = (const CGPoint *)&block[4 * v6 + 11];
  }
  else
  {
    if (a3)
    {
      *a3 = 0;
      a3[1] = 0;
    }
    uint64_t v7 = &CGPointZero;
  }
  return v7->x;
}

double CGPDFTextStringGetBBoxForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  block = find_block(a1, a2);
  if (block)
  {
    if (a3) {
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    }
    uint64_t v6 = block[3];
  }
  else
  {
    uint64_t v6 = 0;
    if (a3)
    {
      *(void *)a3 = a2;
      *(void *)(a3 + 8) = 0;
    }
  }
  uint64_t v7 = (const CGAffineTransform *)(v6 + 56);
  if (!v6) {
    uint64_t v7 = &CGAffineTransformIdentity;
  }
  long long v8 = *(_OWORD *)&v7->c;
  *(_OWORD *)&v10.a = *(_OWORD *)&v7->a;
  *(_OWORD *)&v10.c = v8;
  *(_OWORD *)&v10.tdouble x = *(_OWORD *)&v7->tx;
  v11.origin.double x = CGPDFFontGetFontBBox(v6);
  *(void *)&double result = (unint64_t)CGRectApplyAffineTransform(v11, &v10);
  return result;
}

uint64_t CGPDFTextStringGetFontForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  block = find_block(a1, a2);
  if (block)
  {
    if (a3) {
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    }
    return block[3];
  }
  else
  {
    uint64_t result = 0;
    if (a3)
    {
      *(void *)a3 = a2;
      *(void *)(a3 + 8) = 0;
    }
  }
  return result;
}

__n128 CGPDFTextStringGetTransformForIndex@<Q0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  block = find_block(a1, a2);
  if (block)
  {
    if (a3) {
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    }
    long long v8 = (const CGAffineTransform *)(block + 5);
  }
  else
  {
    if (a3)
    {
      *(void *)a3 = a2;
      *(void *)(a3 + 8) = 0;
    }
    long long v8 = &CGAffineTransformIdentity;
  }
  long long v9 = *(_OWORD *)&v8->c;
  *(_OWORD *)a4 = *(_OWORD *)&v8->a;
  *(_OWORD *)(a4 + 16) = v9;
  __n128 result = *(__n128 *)&v8->tx;
  *(__n128 *)(a4 + 32) = result;
  return result;
}

uint64_t CGPDFTextStringGetColorForIndex(uint64_t a1, unint64_t a2, uint64_t a3)
{
  block = find_block(a1, a2);
  if (block)
  {
    if (a3) {
      *(_OWORD *)a3 = *(_OWORD *)(block + 1);
    }
    return block[4];
  }
  else
  {
    uint64_t result = 0;
    if (a3)
    {
      *(void *)a3 = a2;
      *(void *)(a3 + 8) = 0;
    }
  }
  return result;
}

void *CGPDFTextStringAppendTextLayout(void *result, uint64_t a2, void *a3, __n128 a4)
{
  if (result && a2 && a3)
  {
    v18[0] = a2;
    v18[1] = result;
    if (*((unsigned char *)result + 16))
    {
      return CGPDFTextLayoutDrawGlyphs(a3, (void (*)(uint64_t, uint64_t, long long *, uint64_t, uint64_t, char *, char *, void, uint64_t))draw_glyphs, (uint64_t)v18, a4);
    }
    else
    {
      uint64_t v5 = (void *)*a3;
      if (*a3)
      {
        uint64_t v6 = 0;
        do
        {
          uint64_t v7 = v5;
          uint64_t v5 = (void *)*v5;
          *uint64_t v7 = v6;
          uint64_t v6 = v7;
        }
        while (v5);
        *a3 = v7;
        do
        {
          uint64_t v8 = v7[1];
          long long v9 = *(void **)(v8 + 40);
          CGAffineTransform v10 = (long long *)(v8 + 64);
          uint64_t v11 = *(void *)(v8 + 128);
          uint64_t v12 = *(void *)(v8 + 136);
          uint64_t v13 = *(void *)(v8 + 8);
          if (*(unsigned char *)(v8 + 17))
          {
            uint64_t v14 = *(void *)(v8 + 120);
            long long v15 = *(_OWORD *)(v8 + 80);
            long long v19 = *v10;
            long long v20 = v15;
            long long v21 = *(_OWORD *)(v8 + 96);
            draw_text((uint64_t)v18, v9, &v19, v11, v12, v14, 0, v13);
          }
          else
          {
            uint64_t v16 = *(void *)(v8 + 112);
            long long v17 = *(_OWORD *)(v8 + 80);
            long long v19 = *v10;
            long long v20 = v17;
            long long v21 = *(_OWORD *)(v8 + 96);
            append_standard_text((uint64_t)v18, v9, (double *)&v19, 0, v11, v12, v16, v13);
          }
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        *a3 = 0;
      }
      return text_layout_reset(a3);
    }
  }
  return result;
}

void draw_text(uint64_t a1, void *a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v8 = a3[1];
  v9[0] = *a3;
  v9[1] = v8;
  v9[2] = a3[2];
  if (a6) {
    append_cid_text(a1, a2, (double *)v9, 0, a6, a4, a5, a8);
  }
  else {
    append_standard_text(a1, a2, (double *)v9, 0, a4, a5, a7, a8);
  }
}

_WORD *append_standard_text(uint64_t a1, void *a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = *(void *)(a1 + 8);
  long long v17 = (double *)malloc_type_calloc(1uLL, 32 * a8 + 88, 0x33BCE901uLL);
  uint64_t result = (_WORD *)__CFSetLastAllocationEventName();
  if (v17)
  {
    uint64_t v51 = 0;
    uint64_t v19 = *(void *)(v16 + 48);
    double *v17 = 0.0;
    *((void *)v17 + 1) = v19;
    *((void *)v17 + 2) = a8;
    if (a2) {
      CFRetain(a2);
    }
    *((void *)v17 + 3) = a2;
    *((void *)v17 + 4) = copy_color();
    long long v20 = *(const CGAffineTransform **)a1;
    if (*(void *)a1) {
      long long v20 = *(const CGAffineTransform **)&v20->a;
    }
    uint64_t v50 = v16;
    if (!v20) {
      long long v20 = &CGAffineTransformIdentity;
    }
    double b = v20->b;
    double c = v20->c;
    double d = v20->d;
    double v24 = a3[1];
    double v25 = a3[2];
    double v26 = a3[3];
    double v27 = a3[4];
    double v28 = a3[5];
    double v29 = v24 * c + *a3 * v20->a;
    double v30 = v24 * d + *a3 * b;
    double v31 = v26 * c + v25 * v20->a;
    double v32 = v26 * d + v25 * b;
    CGFloat v33 = v20->tx + c * v28 + v27 * v20->a;
    double v34 = d * v28 + v27 * b + v20->ty;
    v17[5] = v29;
    v17[6] = v30;
    v17[7] = v31;
    v17[8] = v32;
    v17[9] = v33;
    v17[10] = v34;
    uint64_t result = CGPDFFontGetEncoding((atomic_ullong *)a2);
    if (a8)
    {
      uint64_t v35 = (uint64_t)result;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      while (1)
      {
        uint64_t result = (_WORD *)CGPDFEncodingGetUnicodesForIndex(v35, *(unsigned __int8 *)(a7 + v37), &v51);
        uint64_t v38 = result;
        uint64_t v39 = v51 - 1;
        if (v51 == 1)
        {
          __int16 v41 = *result;
          goto LABEL_25;
        }
        if (!v51)
        {
          WORD1(v17[4 * v36 + 14]) = 0;
          if (a4) {
            goto LABEL_26;
          }
          goto LABEL_13;
        }
        unint64_t v42 = v39 + *((void *)v17 + 2);
        *((void *)v17 + 2) = v42;
        if (v42 > 0x7FFFFFFFFFFFFFDLL) {
          break;
        }
        uint64_t result = malloc_type_realloc(v17, 32 * v42 + 88, 0x61043DE6uLL);
        long long v17 = (double *)result;
        uint64_t v39 = v51 - 1;
        if (v51 != 1) {
          goto LABEL_18;
        }
LABEL_24:
        __int16 v41 = v38[v39];
LABEL_25:
        WORD1(v17[4 * v36 + 14]) = v41;
        if (a4)
        {
LABEL_26:
          __int16 v40 = *(_WORD *)(a4 + 2 * v37);
          goto LABEL_27;
        }
LABEL_13:
        __int16 v40 = 0;
LABEL_27:
        uint64_t v47 = &v17[4 * v36];
        *((_WORD *)v47 + 56) = v40;
        *(_OWORD *)(v47 + 11) = *(_OWORD *)(a5 + 16 * v37);
        v47[13] = *(double *)(a6 + 8 * v37);
        ++v36;
        if (++v37 == a8) {
          goto LABEL_28;
        }
      }
      long long v17 = 0;
LABEL_18:
      uint64_t v43 = 0;
      uint64_t v44 = 4 * v36;
      do
      {
        int v45 = &v17[v44];
        WORD1(v17[v44 + 14]) = v38[v43];
        if (a4) {
          __int16 v46 = *(_WORD *)(a4 + 2 * v37);
        }
        else {
          __int16 v46 = 0;
        }
        *((_WORD *)v45 + 56) = v46;
        *(_OWORD *)(v45 + 11) = *(_OWORD *)(a5 + 16 * v37);
        v45[13] = 0.0;
        ++v43;
        v44 += 4;
      }
      while (v39 != v43);
      v36 += v43;
      goto LABEL_24;
    }
LABEL_28:
    uint64_t v48 = (double **)(v50 + 32);
    if (*(void *)(v50 + 24))
    {
      uint64_t v49 = (double **)*v48;
    }
    else
    {
      uint64_t v49 = (double **)(v50 + 32);
      uint64_t v48 = (double **)(v50 + 24);
    }
    *uint64_t v49 = v17;
    *uint64_t v48 = v17;
    *(void *)(v50 + 48) += *((void *)v17 + 2);
  }
  return result;
}

void append_cid_text(uint64_t a1, void *a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = a7;
  uint64_t v62 = a5;
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)(a1 + 8);
  long long v15 = (double *)malloc_type_calloc(1uLL, 32 * a8 + 88, 0x33BCE901uLL);
  __CFSetLastAllocationEventName();
  if (v15)
  {
    uint64_t v16 = *(void *)(v14 + 48);
    *long long v15 = 0.0;
    *((void *)v15 + 1) = v16;
    *((void *)v15 + 2) = a8;
    if (a2) {
      CFRetain(a2);
    }
    *((void *)v15 + 3) = a2;
    *((void *)v15 + 4) = copy_color();
    long long v17 = *(const CGAffineTransform **)a1;
    if (*(void *)a1) {
      long long v17 = *(const CGAffineTransform **)&v17->a;
    }
    if (!v17) {
      long long v17 = &CGAffineTransformIdentity;
    }
    double b = v17->b;
    double c = v17->c;
    double d = v17->d;
    double v21 = a3[1];
    double v22 = a3[2];
    double v23 = a3[3];
    double v24 = a3[4];
    double v25 = a3[5];
    double v26 = v21 * c + *a3 * v17->a;
    double v27 = v21 * d + *a3 * b;
    double v28 = v23 * c + v22 * v17->a;
    double v29 = v23 * d + v22 * b;
    CGFloat v30 = v17->tx + c * v25 + v24 * v17->a;
    double v31 = d * v25 + v24 * b + v17->ty;
    v15[5] = v26;
    v15[6] = v27;
    v15[7] = v28;
    v15[8] = v29;
    v15[9] = v30;
    v15[10] = v31;
    uint64_t ROSUnicodeCMap = CGPDFFontGetToUnicodeCMap((uint64_t)a2);
    if (ROSUnicodeCMap || (uint64_t ROSUnicodeCMap = (uint64_t)CGPDFFontGetROSUnicodeCMap((char *)a2)) != 0)
    {
      if (cmap_vtable && (double v34 = *(uint64_t (**)(void))(cmap_vtable + 56)) != 0) {
        uint64_t v35 = v34(*(void *)(ROSUnicodeCMap + 16));
      }
      else {
        uint64_t v35 = 0;
      }
      MEMORY[0x1F4188790](v35, v33);
      uint64_t v39 = (char *)v59 - v38;
      if (v37 <= 0x7FFFFFFFFFFFFFFELL) {
        __int16 v40 = (__int16 *)((char *)v59 - v38);
      }
      else {
        __int16 v40 = 0;
      }
      if (v37 - 0x7FFFFFFFFFFFFFFFLL >= 0x8000000000000022) {
        __int16 v40 = (__int16 *)malloc_type_malloc(2 * v36, 0x77887A56uLL);
      }
      if (v40)
      {
        v59[0] = v39;
        v59[1] = v59;
        uint64_t v60 = v14;
        if (a8)
        {
          uint64_t v41 = 0;
          for (uint64_t i = 0; i != a8; ++i)
          {
            uint64_t v43 = *(unsigned __int16 *)(v62 + 2 * i);
            if (cmap_vtable)
            {
              uint64_t v44 = *(uint64_t (**)(void, uint64_t, __int16 *))(cmap_vtable + 64);
              if (v44)
              {
                uint64_t v45 = v44(*(void *)(ROSUnicodeCMap + 16), v43, v40);
                if (v45) {
                  goto LABEL_28;
                }
                LODWORD(v43) = *(unsigned __int16 *)(v62 + 2 * i);
              }
            }
            uint64_t v45 = CGPDFGetUnicharGuessForCID(v43, v40);
LABEL_28:
            uint64_t v46 = v45 - 1;
            if (v45 == 1)
            {
              __int16 v48 = *v40;
            }
            else
            {
              if (!v45)
              {
                WORD1(v15[4 * v41 + 14]) = 0;
                if (a4) {
                  goto LABEL_43;
                }
                goto LABEL_31;
              }
              unint64_t v49 = *((void *)v15 + 2) + v46;
              *((void *)v15 + 2) = v49;
              if (v49 <= 0x7FFFFFFFFFFFFFDLL) {
                long long v15 = (double *)malloc_type_realloc(v15, 32 * v49 + 88, 0x61043DE6uLL);
              }
              else {
                long long v15 = 0;
              }
              uint64_t v50 = (_WORD *)&v15[4 * v41 + 14] + 1;
              uint64_t v41 = v45 + v41 - 1;
              uint64_t v51 = v40;
              uint64_t v52 = v45 - 1;
              do
              {
                __int16 v53 = *v51++;
                *uint64_t v50 = v53;
                if (a4) {
                  __int16 v54 = *(_WORD *)(a4 + 2 * i);
                }
                else {
                  __int16 v54 = 0;
                }
                *(v50 - 1) = v54;
                *(_OWORD *)(v50 - 13) = *(_OWORD *)(a6 + 16 * i);
                *(void *)(v50 - 5) = 0;
                v50 += 16;
                --v52;
              }
              while (v52);
              __int16 v48 = v40[v46];
            }
            WORD1(v15[4 * v41 + 14]) = v48;
            if (a4)
            {
LABEL_43:
              __int16 v47 = *(_WORD *)(a4 + 2 * i);
              goto LABEL_44;
            }
LABEL_31:
            __int16 v47 = 0;
LABEL_44:
            uint64_t v55 = &v15[4 * v41];
            *((_WORD *)v55 + 56) = v47;
            *(_OWORD *)(v55 + 11) = *(_OWORD *)(a6 + 16 * i);
            v55[13] = *(double *)(v61 + 8 * i);
            ++v41;
          }
        }
        if (v40 != (__int16 *)v59[0]) {
          free(v40);
        }
        uint64_t v56 = v60;
        uint64_t v57 = (double **)(v60 + 32);
        if (*(void *)(v60 + 24))
        {
          uint64_t v58 = (double **)*v57;
        }
        else
        {
          uint64_t v58 = (double **)(v60 + 32);
          uint64_t v57 = (double **)(v60 + 24);
        }
        const CGPath *v58 = v15;
        *uint64_t v57 = v15;
        *(void *)(v56 + 48) += *((void *)v15 + 2);
      }
      else
      {
        text_block_release(v15);
      }
    }
    else
    {
      text_block_release(v15);
    }
  }
}

const void *copy_color()
{
  CGColorSpaceRef v0 = (const void *)copy_color_color;
  if (copy_color_color
    || (DeviceRGB = CGColorSpaceCreateDeviceRGB(),
        copy_color_color = (uint64_t)CGColorCreate(DeviceRGB, copy_color_components),
        CGColorSpaceRelease(DeviceRGB),
        (CGColorSpaceRef v0 = (const void *)copy_color_color) != 0))
  {
    CFRetain(v0);
  }
  return v0;
}

void draw_glyphs(uint64_t a1, void *a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v9 = a3[1];
  v10[0] = *a3;
  v10[1] = v9;
  v10[2] = a3[2];
  if (a7) {
    append_cid_text(a1, a2, (double *)v10, a6, a7, a4, a5, a9);
  }
  else {
    append_standard_text(a1, a2, (double *)v10, a6, a4, a5, a8, a9);
  }
}

void std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 3;
        std::__destroy_at[abi:fe180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(*(v4 - 1));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:fe180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
}

void StructureElement::~StructureElement(StructureElement *this)
{
  uint64_t v2 = (StructureElement **)*((void *)this + 14);
  uint64_t v3 = (StructureElement **)*((void *)this + 15);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
      {
        StructureElement::~StructureElement(*v2);
        MEMORY[0x18532A2A0]();
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (StructureElement **)*((void *)this + 14);
  }
  *((void *)this + 15) = v2;
  uint64_t v4 = (_DWORD **)*((void *)this + 17);
  uint64_t v5 = (_DWORD **)*((void *)this + 18);
  if (v4 != v5)
  {
    do
    {
      uint64_t v6 = *v4++;
      CGPDFNodeRelease(v6);
    }
    while (v4 != v5);
    uint64_t v4 = (_DWORD **)*((void *)this + 17);
  }
  *((void *)this + 18) = v4;
  uint64_t v7 = (CFTypeRef *)*((void *)this + 22);
  long long v8 = (CFTypeRef *)*((void *)this + 23);
  if (v7 != v8)
  {
    do
      CFRelease(*v7++);
    while (v7 != v8);
    uint64_t v7 = (CFTypeRef *)*((void *)this + 22);
  }
  *((void *)this + 23) = v7;
  long long v9 = (const void *)*((void *)this + 20);
  if (v9) {
    CFRelease(v9);
  }
  CGAffineTransform v10 = (const void *)*((void *)this + 21);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = *((void *)this + 25);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 26);
    uint64_t v13 = (void *)*((void *)this + 25);
    if (v12 != v11)
    {
      do
      {
        uint64_t v14 = *(const void **)(v12 - 8);
        v12 -= 8;
        std::__destroy_at[abi:fe180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>(v14);
      }
      while (v12 != v11);
      uint64_t v13 = (void *)*((void *)this + 25);
    }
    *((void *)this + 26) = v11;
    operator delete(v13);
  }
  long long v15 = (void *)*((void *)this + 22);
  if (v15)
  {
    *((void *)this + 23) = v15;
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 17);
  if (v16)
  {
    *((void *)this + 18) = v16;
    operator delete(v16);
  }
  long long v17 = (void *)*((void *)this + 14);
  if (v17)
  {
    *((void *)this + 15) = v17;
    operator delete(v17);
  }
  if (*((char *)this + 63) < 0) {
    operator delete(*((void **)this + 5));
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void std::__destroy_at[abi:fe180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
}

void TaggedParser::AddPage(TaggedParser *this, CGPDFPage *a2)
{
  if (a2) {
    unint64_t v4 = *(void *)(*((void *)a2 + 5) + 8);
  }
  else {
    unint64_t v4 = 0;
  }
  unint64_t v5 = v4 - 1;
  uint64_t v6 = *(void *)this;
  uint64_t v7 = *(void *)(*(void *)this + 248);
  unint64_t v8 = (v4 - 1) >> 6;
  uint64_t v9 = 1 << (v4 - 1);
  uint64_t v10 = *(void *)(v7 + 8 * v8);
  if ((v9 & v10) == 0)
  {
    *(void *)(v7 + 8 * v8) = v10 | v9;
    if (*(void *)v6)
    {
      uint64_t v11 = (CGPDFContentStream *)CGPDFContentStreamCreate(*((void *)a2 + 5));
      uint64_t v12 = CGPDFOperatorTableCreate();
      if (v12)
      {
        for (uint64_t i = 0; i != 66; i += 2)
          CGPDFOperatorTableSetCallback(v12, (&off_1ED09A9F0)[i], (CGPDFOperatorCallback)(&off_1ED09A9F0)[i + 1]);
      }
      *(void *)&long long info = a2;
      uint64_t v100 = v12;
      uint64_t v101 = this;
      int v102 = 0;
      CGRect BoxRect = CGPDFPageGetBoxRect(a2, kCGPDFCropBox);
      CGFloat x = BoxRect.origin.x;
      CGFloat y = BoxRect.origin.y;
      CGFloat width = BoxRect.size.width;
      CGFloat height = BoxRect.size.height;
      *((void *)&info + 1) = *(void *)&BoxRect.origin.x;
      *(CGFloat *)&long long v98 = BoxRect.origin.y;
      *((void *)&v98 + 1) = *(void *)&BoxRect.size.width;
      CGFloat v99 = BoxRect.size.height;
      int RotationAngle = CGPDFPageGetRotationAngle(a2);
      if (RotationAngle == 270 || RotationAngle == 90)
      {
        *((CGFloat *)&v98 + 1) = height;
        CGFloat v99 = width;
        CGFloat v25 = width;
      }
      else
      {
        CGFloat v25 = height;
        CGFloat height = width;
      }
      CGPDFObjectRef v105 = *(CGPDFObjectRef *)&x;
      uint64_t v106 = *(CGPDFObject **)&y;
      CGFloat v107 = height;
      CGFloat v108 = v25;
      CFTypeRef CGDisplayList = (CFTypeRef)CG::DisplayList::createCGDisplayList(0, (const __CFDictionary *)&v105, v19, v20, v21, v22, v23, v24);
      CFTypeRef cf = (CFTypeRef)CGDisplayListContextCreate((uint64_t)CGDisplayList, v26, v27, v28, v29, v30, v31, v32);
      __n128 v33 = CGPDFScannerCreate(v11, v12, &info);
      CGPDFScannerScan(v33);
      if (v33) {
        CFRelease(v33);
      }
      if (v12) {
        CFRelease(v12);
      }
      if (v11) {
        CFRelease(v11);
      }
      if (cf) {
        CFRelease(cf);
      }
      if (CGDisplayList) {
        CFRelease(CGDisplayList);
      }
      uint64_t v6 = *(void *)this;
    }
    double v34 = (std::mutex *)(v6 + 32);
    std::mutex::lock((std::mutex *)(v6 + 32));
    uint64_t v35 = *(void *)this;
    uint64_t v36 = **(CGPDFDictionary ***)this;
    uint64_t v37 = *(void *)(*(void *)this + 24);
    if (v36)
    {
      uint64_t v95 = v34;
      if (v37)
      {
        uint64_t v39 = v35 + 200;
        uint64_t v38 = *(void *)(v35 + 200);
        unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v39 + 8) - v38) >> 3);
        if (v40 <= v5) {
          goto LABEL_109;
        }
        uint64_t v41 = (uint64_t *)(v38 + 24 * v5);
        CGPDFObjectRef v105 = 0;
        uint64_t v106 = 0;
        CGFloat v107 = 0.0;
        uint64_t v42 = *v41;
        uint64_t v43 = v41[1];
        *(void *)&long long info = &v105;
        BYTE8(info) = 0;
        if (v43 != v42)
        {
          unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((v43 - v42) >> 3);
          if (v44 >= 0xAAAAAAAAAAAAAABLL) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v45 = (CGPDFObject *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v44);
          CGPDFObjectRef v105 = v45;
          uint64_t v106 = v45;
          *(void *)&CGFloat v107 = (char *)v45 + 24 * v46;
          do
          {
            *(_OWORD *)uint64_t v45 = *(_OWORD *)v42;
            uint64_t v47 = *(void *)(v42 + 16);
            if (v47) {
              CFRetain(*(CFTypeRef *)(v42 + 16));
            }
            *((void *)v45 + 2) = v47;
            uint64_t v45 = (CGPDFObject *)((char *)v45 + 24);
            v42 += 24;
          }
          while (v42 != v43);
          uint64_t v106 = v45;
          uint64_t v38 = *(void *)(*(void *)this + 200);
          unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)this + 208) - v38) >> 3);
        }
        if (v40 <= v5) {
          goto LABEL_109;
        }
        uint64_t v48 = v38 + 24 * v5;
        uint64_t v51 = *(void *)(v48 + 8);
        uint64_t v50 = (void *)(v48 + 8);
        uint64_t v49 = v51;
        uint64_t v52 = *(void *)(v38 + 24 * v5);
        if (v51 != v52)
        {
          do
          {
            uint64_t v53 = v49 - 24;
            std::__destroy_at[abi:fe180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(*(const void **)(v49 - 8));
            uint64_t v49 = v53;
          }
          while (v53 != v52);
        }
        *uint64_t v50 = v52;
        CGPDFObjectRef v54 = v105;
        uint64_t v55 = v106;
        if (v105 != v106)
        {
          while (1)
          {
            long long info = 0u;
            long long v98 = 0u;
            LODWORD(v99) = 1065353216;
            CGPDFObjectRef v110 = 0;
            value[0] = 0;
            CFTypeRef v109 = 0;
            v96[0] = (unint64_t)value;
            v96[1] = (unint64_t)&v110;
            v96[2] = (unint64_t)&v109;
            std::__memberwise_copy_assign[abi:fe180100]<std::tuple<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *> &>,std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0ul,1ul,2ul>((uint64_t)v96, v54);
            uint64_t v56 = *((void *)value[0] + 14);
            if ((unint64_t)v110 >= (*((void *)value[0] + 15) - v56) >> 3) {
              break;
            }
            if (!*(void *)(v56 + 8 * (void)v110)) {
              TaggedParser::BuildStructureElementFromDictionary();
            }
            if (v109) {
              CFRelease(v109);
            }
            std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table((uint64_t)&info);
            CGPDFObjectRef v54 = (CGPDFObjectRef)((char *)v54 + 24);
            if (v54 == v55) {
              goto LABEL_44;
            }
          }
LABEL_109:
          __break(1u);
          __assert_rtn("CreateStructureRoot", "TaggedParser.mm", 1337, "pageIndex < pageCount");
        }
LABEL_44:
        uint64_t v57 = *(void *)(*(void *)this + 200);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)this + 208) - v57) >> 3) <= v5) {
          goto LABEL_109;
        }
        if (*(void *)(v57 + 24 * v5 + 8) != *(void *)(v57 + 24 * v5)) {
          __assert_rtn("AddPage", "TaggedParser.mm", 799, "_private->objectsToSearch[pageIndex].size() == 0");
        }
        *(void *)&long long info = &v105;
        std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__destroy_vector::operator()[abi:fe180100]((void ***)&info);
      }
      else
      {
        v96[0] = v4;
        if (TaggedParser::ValidatePageNumber(this, v36, v96))
        {
          value[0] = 0;
          if (CGPDFDictionaryGetDictionary(v36, "RoleMap", value)) {
            CGPDFDictionaryApplyFunction(value[0], (CGPDFDictionaryApplierFunction)RoleMapCallback, (void *)(*(void *)this + 152));
          }
          operator new();
        }
        *(void *)(*(void *)this + 24) = 0;
      }
      CGPDFPageCopyPageLayoutWithCTLD((uint64_t)a2, 1);
      uint64_t v59 = v58;
      CGPDFObjectRef v105 = (CGPDFObjectRef)v58;
      if (a2) {
        uint64_t v60 = *(void *)(*((void *)a2 + 5) + 8);
      }
      else {
        uint64_t v60 = 0;
      }
      uint64_t v61 = *(void *)(*(void *)this + 128);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)this + 136) - v61) >> 3) <= v60 - 1) {
        goto LABEL_109;
      }
      *(void *)&long long info = v61 + 24 * (v60 - 1);
      *((void *)&info + 1) = v60;
      *(void *)&long long v98 = v58 + 2;
      *((void *)&v98 + 1) = a2;
      uint64_t v62 = (char *)v58[36];
      uint64_t v63 = (char *)v58[37];
      if (v62 != v63 && (unint64_t)(v63 - v62) <= v58[13] - v58[12])
      {
        uint64_t v64 = (void *)v58[6];
        if ((void *)v58[7] == v64)
        {
          unint64_t v66 = 0;
          uint64_t v65 = -1;
        }
        else
        {
          uint64_t v65 = v64[1] + *v64;
          unint64_t v66 = 1;
        }
        unint64_t v67 = 0;
        unint64_t v68 = 0;
        int64_t v69 = 0;
        unint64_t v70 = 0;
        uint64_t v71 = *(void *)v62;
        while (1)
        {
          uint64_t v72 = v59[9];
          if (v67 >= (v59[10] - v72) >> 1) {
            break;
          }
          uint64_t v73 = *(void *)&v62[8 * v70];
          int v74 = *(unsigned __int16 *)(v72 + 2 * v67);
          if (v74 == 32 || v71 != v73 || v70 == v65)
          {
            if (v69 >= 1) {
              TaggedParser::addWords(CGPDFPage *)::$_0::operator()((uint64_t)&info, v71, v68, v69);
            }
            int64_t v69 = v74 != 32;
            if (v74 == 32) {
              unint64_t v68 = v70 + 1;
            }
            else {
              unint64_t v68 = v70;
            }
            if (v70 == v65)
            {
              uint64_t v77 = v59[6];
              if (v66 >= 0x8E38E38E38E38E39 * ((v59[7] - v77) >> 3))
              {
                uint64_t v65 = -1;
              }
              else
              {
                uint64_t v65 = *(void *)(v77 + 72 * v66 + 8) + *(void *)(v77 + 72 * v66);
                ++v66;
              }
            }
          }
          else
          {
            ++v69;
          }
          uint64_t v78 = v59[12];
          if (v70 >= (v59[13] - v78) >> 3) {
            goto LABEL_109;
          }
          v67 += *(void *)(v78 + 8 * v70++);
          uint64_t v62 = (char *)v59[36];
          uint64_t v71 = v73;
          if (v70 >= (uint64_t)(v59[37] - (void)v62) >> 3) {
            goto LABEL_86;
          }
        }
        LODWORD(v73) = v71;
LABEL_86:
        double v34 = v95;
        if (v69 >= 1) {
          TaggedParser::addWords(CGPDFPage *)::$_0::operator()((uint64_t)&info, v73, v68, v69);
        }
      }
      CFRelease(v59);
      if (!a2) {
        goto LABEL_109;
      }
      unint64_t v79 = *(void *)(*((void *)a2 + 5) + 8) - 1;
      uint64_t v80 = *(void *)this;
      uint64_t v81 = *(void *)(*(void *)this + 224);
      if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(*(void *)this + 232) - v81) >> 3) <= v79) {
        goto LABEL_109;
      }
      uint64_t v83 = v80 + 128;
      uint64_t v82 = *(void *)(v80 + 128);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v83 + 8) - v82) >> 3) <= v79) {
        goto LABEL_109;
      }
      uint64_t v84 = *(uint64_t **)(v81 + 40 * v79 + 16);
      if (v84)
      {
        uint64_t v85 = (void *)(v82 + 24 * v79 + 8);
        do
        {
          uint64_t v86 = (void *)*v85;
          if (*v85)
          {
            uint64_t v87 = v84[2];
            uint64_t v88 = v85;
            do
            {
              uint64_t v89 = v86[4];
              BOOL v90 = v89 < v87;
              if (v89 >= v87) {
                uint64_t v91 = v86;
              }
              else {
                uint64_t v91 = v86 + 1;
              }
              if (!v90) {
                uint64_t v88 = v86;
              }
              uint64_t v86 = (void *)*v91;
            }
            while (*v91);
            if (v88 != v85 && v87 >= v88[4])
            {
              uint64_t v92 = v88[5];
              long long v93 = *(_OWORD *)(v84 + 3);
              long long v94 = *(_OWORD *)(v84 + 5);
              *(unsigned char *)(v92 + 256) = *((unsigned char *)v84 + 56);
              *(_OWORD *)(v92 + 224) = v93;
              *(_OWORD *)(v92 + 240) = v94;
            }
          }
          uint64_t v84 = (uint64_t *)*v84;
        }
        while (v84);
      }
    }
    else if (!v37)
    {
      operator new();
    }
    std::mutex::unlock(v34);
  }
}

void sub_184EF7E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void std::__memberwise_copy_assign[abi:fe180100]<std::tuple<StructureElement *&,unsigned long &,applesauce::CF::ObjectRef<CGPDFDictionary *> &>,std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0ul,1ul,2ul>(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  **(void **)a1 = *a2;
  uint64_t v3 = *(const void ***)(a1 + 16);
  **(void **)(a1 + 8) = v2;
  unint64_t v4 = *v3;
  unint64_t v5 = (const void *)a2[2];
  const void *v3 = v5;
  if (v5) {
    CFRetain(v5);
  }
  if (v4) {
    CFRelease(v4);
  }
}

void TaggedParser::BuildStructureElementFromDictionary()
{
}

void sub_184EF85F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char *a23)
{
  operator delete(v23);
  std::__tree<std::__value_type<std::string,CGDisplayListEntryType>,std::__map_value_compare<std::string,std::__value_type<std::string,CGDisplayListEntryType>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CGDisplayListEntryType>>>::destroy(a23);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

const void **applesauce::CF::ObjectRef<CGPDFDictionary *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TaggedParser::addWords(CGPDFPage *)::$_0::operator()(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(void **)(*(void *)a1 + 8);
  if (v4)
  {
    int64_t v8 = a2 | ((unint64_t)*(void *)(a1 + 8) << 32);
    uint64_t v9 = *(void *)a1 + 8;
    do
    {
      int64_t v10 = v4[4];
      BOOL v11 = v10 < v8;
      if (v10 >= v8) {
        uint64_t v12 = v4;
      }
      else {
        uint64_t v12 = v4 + 1;
      }
      if (!v11) {
        uint64_t v9 = (uint64_t)v4;
      }
      unint64_t v4 = (void *)*v12;
    }
    while (*v12);
    if (v9 != *(void *)a1 + 8 && v8 >= *(void *)(v9 + 32))
    {
      uint64_t v13 = *(void **)(v9 + 40);
      uint64_t v14 = CGPDFTaggedNodeCreate(*(void *)(a1 + 24));
      uint64_t v15 = v14;
      uint64_t v16 = (uint64_t *)v13[26];
      unint64_t v17 = v13[27];
      if ((unint64_t)v16 >= v17)
      {
        uint64_t v18 = (void *)v13[25];
        uint64_t v19 = v16 - v18;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 61) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v21 = v17 - (void)v18;
        if (v21 >> 2 > v20) {
          unint64_t v20 = v21 >> 2;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        unint64_t v40 = v13 + 27;
        if (v22)
        {
          unint64_t v22 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v22);
          uint64_t v18 = (void *)v13[25];
          uint64_t v16 = (uint64_t *)v13[26];
        }
        else
        {
          uint64_t v23 = 0;
        }
        uint64_t v24 = (uint64_t *)(v22 + 8 * v19);
        unint64_t v25 = v22 + 8 * v23;
        unint64_t v39 = v25;
        *uint64_t v24 = v15;
        uint64_t v26 = v24 + 1;
        *((void *)&v38 + 1) = v24 + 1;
        if (v16 != v18)
        {
          do
          {
            uint64_t v27 = *--v16;
            *--uint64_t v24 = v27;
            uint64_t *v16 = 0;
          }
          while (v16 != v18);
          uint64_t v26 = (void *)*((void *)&v38 + 1);
          unint64_t v25 = v39;
        }
        long long v28 = *(_OWORD *)(v13 + 25);
        v13[25] = v24;
        v13[26] = v26;
        long long v38 = v28;
        unint64_t v29 = v13[27];
        v13[27] = v25;
        unint64_t v39 = v29;
        uint64_t v37 = v28;
        std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer((uint64_t)&v37);
        v13[26] = v26;
        uint64_t v16 = v26 - 1;
      }
      else
      {
        uint64_t *v16 = v14;
        v13[26] = v16 + 1;
      }
      uint64_t v30 = *v16;
      if (*v16) {
        *(unsigned char *)(v30 + 112) = 0;
      }
      CGPDFTaggedNodeSetType((CFStringRef)v30, 1);
      uint64_t v31 = *v16;
      if (*v16)
      {
        *(void *)(v31 + 160) = *(void *)(a1 + 8);
        PageLayout::GetBoundsForRangeWithinLine(*(void **)(a1 + 16), a3, a4, 0, 0);
        *(unsigned char *)(v31 + 48) = 1;
        *(void *)(v31 + 56) = v32;
        *(void *)(v31 + 64) = v33;
        *(void *)(v31 + 72) = v34;
        *(void *)(v31 + 80) = v35;
      }
      else
      {
        PageLayout::GetBoundsForRangeWithinLine(*(void **)(a1 + 16), a3, a4, 0, 0);
      }
      uint64_t v36 = *v16;
      if (*v16)
      {
        *(unsigned char *)(v36 + 168) = 1;
        *(void *)(v36 + 176) = a3;
        *(void *)(v36 + 184) = a4;
        *(unsigned char *)(v36 + 192) = 0;
      }
    }
  }
}

void sub_184EF8888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t std::__split_buffer<applesauce::CF::ObjectRef<CGPDFTaggedNode *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(const void **)(i - 8);
    *(void *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:fe180100]<applesauce::CF::ObjectRef<CGPDFTaggedNode *>,0>(v4);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

const void **applesauce::CF::ObjectRef<CGPDFTaggedNode *>::~ObjectRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TaggedParser::BuildStructureElement(TaggedParser *a1, uint64_t *a2, unint64_t a3, unint64_t a4, float *a5)
{
  unint64_t v101 = a4;
  unint64_t v11 = 0x9DDFEA08EB382D69 * (((8 * a3) + 8) ^ HIDWORD(a3));
  unint64_t v12 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v11 >> 47) ^ v11);
  unint64_t v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
  unint64_t v14 = *((void *)a5 + 1);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v16 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      if (v13 >= v14) {
        unint64_t v16 = v13 % v14;
      }
    }
    else
    {
      unint64_t v16 = v13 & (v14 - 1);
    }
    unint64_t v17 = *(void **)(*(void *)a5 + 8 * v16);
    if (v17)
    {
      for (uint64_t i = (void *)*v17; i; uint64_t i = (void *)*i)
      {
        unint64_t v19 = i[1];
        if (v19 == v13)
        {
          if (i[2] == a3)
          {
            uint64_t v53 = *(void *)a1;
            if (*(unsigned char *)(*(void *)a1 + 96))
            {
              printf("Hit tagged parsing error: \"%s\"\n", "Cycles detected in marked structure element graph");
              uint64_t v53 = *(void *)a1;
            }
            *(unsigned char *)(v53 + 97) = 1;
            return;
          }
        }
        else
        {
          if (v15.u32[0] > 1uLL)
          {
            if (v19 >= v14) {
              v19 %= v14;
            }
          }
          else
          {
            v19 &= v14 - 1;
          }
          if (v19 != v16) {
            break;
          }
        }
      }
    }
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v5 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      if (v13 >= v14) {
        unint64_t v5 = v13 % v14;
      }
    }
    else
    {
      unint64_t v5 = v13 & (v14 - 1);
    }
    unint64_t v20 = *(void **)(*(void *)a5 + 8 * v5);
    if (v20)
    {
      for (CFIndex j = (void *)*v20; j; CFIndex j = (void *)*j)
      {
        unint64_t v22 = j[1];
        if (v22 == v13)
        {
          if (j[2] == a3) {
            goto LABEL_89;
          }
        }
        else
        {
          if (v15.u32[0] > 1uLL)
          {
            if (v22 >= v14) {
              v22 %= v14;
            }
          }
          else
          {
            v22 &= v14 - 1;
          }
          if (v22 != v5) {
            break;
          }
        }
      }
    }
  }
  uint64_t v23 = operator new(0x18uLL);
  *uint64_t v23 = 0;
  v23[1] = v13;
  v23[2] = a3;
  float v24 = (float)(unint64_t)(*((void *)a5 + 3) + 1);
  float v25 = a5[8];
  if (!v14 || (float)(v25 * (float)v14) < v24)
  {
    BOOL v26 = 1;
    if (v14 >= 3) {
      BOOL v26 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v27 = v26 | (2 * v14);
    unint64_t v28 = vcvtps_u32_f32(v24 / v25);
    if (v27 <= v28) {
      int8x8_t prime = (int8x8_t)v28;
    }
    else {
      int8x8_t prime = (int8x8_t)v27;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v14 = *((void *)a5 + 1);
    }
    if (*(void *)&prime > v14) {
      goto LABEL_45;
    }
    if (*(void *)&prime < v14)
    {
      unint64_t v36 = vcvtps_u32_f32((float)*((unint64_t *)a5 + 3) / a5[8]);
      if (v14 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (*(void *)&prime <= v36) {
        int8x8_t prime = (int8x8_t)v36;
      }
      if (*(void *)&prime >= v14)
      {
        unint64_t v14 = *((void *)a5 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_45:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:fe180100]();
          }
          uint64_t v30 = operator new(8 * *(void *)&prime);
          uint64_t v31 = *(void **)a5;
          *(void *)a5 = v30;
          if (v31) {
            operator delete(v31);
          }
          uint64_t v32 = 0;
          *((int8x8_t *)a5 + 1) = prime;
          do
            *(void *)(*(void *)a5 + 8 * v32++) = 0;
          while (*(void *)&prime != v32);
          uint64_t v33 = (void *)*((void *)a5 + 2);
          if (v33)
          {
            unint64_t v34 = v33[1];
            uint8x8_t v35 = (uint8x8_t)vcnt_s8(prime);
            v35.i16[0] = vaddlv_u8(v35);
            if (v35.u32[0] > 1uLL)
            {
              if (v34 >= *(void *)&prime) {
                v34 %= *(void *)&prime;
              }
            }
            else
            {
              v34 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a5 + 8 * v34) = a5 + 4;
            unint64_t v39 = (void *)*v33;
            if (*v33)
            {
              do
              {
                unint64_t v40 = v39[1];
                if (v35.u32[0] > 1uLL)
                {
                  if (v40 >= *(void *)&prime) {
                    v40 %= *(void *)&prime;
                  }
                }
                else
                {
                  v40 &= *(void *)&prime - 1;
                }
                if (v40 != v34)
                {
                  if (!*(void *)(*(void *)a5 + 8 * v40))
                  {
                    *(void *)(*(void *)a5 + 8 * v40) = v33;
                    goto LABEL_70;
                  }
                  *uint64_t v33 = *v39;
                  void *v39 = **(void **)(*(void *)a5 + 8 * v40);
                  **(void **)(*(void *)a5 + 8 * v40) = v39;
                  unint64_t v39 = v33;
                }
                unint64_t v40 = v34;
LABEL_70:
                uint64_t v33 = v39;
                unint64_t v39 = (void *)*v39;
                unint64_t v34 = v40;
              }
              while (v39);
            }
          }
          unint64_t v14 = (unint64_t)prime;
          goto LABEL_74;
        }
        CGPDFObjectRef v54 = *(void **)a5;
        *(void *)a5 = 0;
        if (v54) {
          operator delete(v54);
        }
        unint64_t v14 = 0;
        *((void *)a5 + 1) = 0;
      }
    }
LABEL_74:
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14) {
        unint64_t v5 = v13 % v14;
      }
      else {
        unint64_t v5 = v13;
      }
    }
    else
    {
      unint64_t v5 = (v14 - 1) & v13;
    }
  }
  uint64_t v41 = *(void **)a5;
  uint64_t v42 = *(void **)(*(void *)a5 + 8 * v5);
  if (v42)
  {
    *uint64_t v23 = *v42;
LABEL_87:
    *uint64_t v42 = v23;
    goto LABEL_88;
  }
  *uint64_t v23 = *((void *)a5 + 2);
  *((void *)a5 + 2) = v23;
  v41[v5] = a5 + 4;
  if (*v23)
  {
    unint64_t v43 = *(void *)(*v23 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v43 >= v14) {
        v43 %= v14;
      }
    }
    else
    {
      v43 &= v14 - 1;
    }
    uint64_t v42 = (void *)(*(void *)a5 + 8 * v43);
    goto LABEL_87;
  }
LABEL_88:
  ++*((void *)a5 + 3);
LABEL_89:
  if (a3)
  {
    unint64_t v44 = a4 - 1;
    switch(*(_DWORD *)(a3 + 8))
    {
      case 3:
      case 0xC:
        uint64_t v45 = *(void *)(*(void *)a1 + 128);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)a1 + 136) - v45) >> 3) <= v44) {
          goto LABEL_189;
        }
        uint64_t v46 = (CGPDFObject *)(*(unsigned int *)(a3 + 32) | (a4 << 32));
        value[0] = v46;
        std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v45 + 24 * v44), (uint64_t)v46, (uint64_t **)value)[5] = a2;
        a2[10] = (uint64_t)v46;
        return;
      case 7:
        uint64_t v49 = *(CGPDFArray **)(a3 + 32);
        if (!v49) {
          return;
        }
        size_t v50 = *((void *)v49 + 2);
        if (!v50) {
          return;
        }
        size_t v51 = v50 - 1;
        if (v50 == 1)
        {
          value[0] = 0;
          if (CGPDFArrayGetObject(v49, 0, value)) {
            TaggedParser::BuildStructureElement(a1, a2);
          }
          return;
        }
        size_t v60 = 0;
        break;
      case 8:
        uint64_t v52 = *(CGPDFDictionary **)(a3 + 32);
        __s1 = 0;
        if (CGPDFDictionaryGetName(v52, "Type", (const char **)&__s1) && !strcmp(__s1, "OBJR"))
        {
          value[0] = (CGPDFObjectRef)a4;
          TaggedParser::ValidatePageNumber(a1, v52, (unint64_t *)value);
          CGPDFDictionaryRef dict = 0;
          if (CGPDFDictionaryGetDictionary(v52, "Obj", &dict)) {
            TaggedParser::BuildObjectElement((uint64_t)a2, value[0], dict, v69);
          }
          return;
        }
        if (TaggedParser::ValidatePageNumber(a1, v52, &v101))
        {
          TaggedParser::BuildStructureElementFromDictionary(a1, a2, v52, v101, a5, 0xFFFFFFFFLL);
          return;
        }
        uint64_t v55 = a2[14];
        uint64_t v56 = (void *)a2[15];
        uint64_t v57 = ((uint64_t)v56 - v55) >> 3;
        unint64_t v58 = a2[16];
        if ((unint64_t)v56 >= v58)
        {
          if ((unint64_t)(v57 + 1) >> 61) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          uint64_t v65 = v58 - v55;
          uint64_t v66 = v65 >> 2;
          if (v65 >> 2 <= (unint64_t)(v57 + 1)) {
            uint64_t v66 = v57 + 1;
          }
          if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v67 = v66;
          }
          if (v67) {
            unint64_t v67 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v67);
          }
          else {
            uint64_t v68 = 0;
          }
          uint64_t v76 = (void *)(v67 + 8 * v57);
          unint64_t v77 = v67 + 8 * v68;
          *uint64_t v76 = 0;
          uint64_t v59 = v76 + 1;
          unint64_t v79 = (char *)a2[14];
          uint64_t v78 = (char *)a2[15];
          if (v78 != v79)
          {
            do
            {
              uint64_t v80 = *((void *)v78 - 1);
              v78 -= 8;
              *--uint64_t v76 = v80;
            }
            while (v78 != v79);
            uint64_t v78 = (char *)a2[14];
          }
          a2[14] = (uint64_t)v76;
          a2[15] = (uint64_t)v59;
          a2[16] = v77;
          if (v78) {
            operator delete(v78);
          }
        }
        else
        {
          *uint64_t v56 = 0;
          uint64_t v59 = v56 + 1;
        }
        uint64_t v81 = a2;
        a2[15] = (uint64_t)v59;
        unint64_t v82 = v101 - 1;
        uint64_t v83 = *(void *)a1;
        uint64_t v84 = *(void *)(*(void *)a1 + 200);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v83 + 208) - v84) >> 3) > v101 - 1)
        {
          if (v52) {
            CFRetain(v52);
          }
          CGPDFDictionaryRef dict = v52;
          uint64_t v85 = v84 + 24 * v82;
          uint64_t v88 = *(uint64_t ***)(v85 + 8);
          uint64_t v87 = (void *)(v85 + 8);
          uint64_t v86 = v88;
          unint64_t v89 = v87[1];
          if ((unint64_t)v88 >= v89)
          {
            uint64_t v91 = (uint64_t *)(v84 + 24 * v82);
            unint64_t v92 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v86 - *v91) >> 3);
            unint64_t v93 = v92 + 1;
            if (v92 + 1 > 0xAAAAAAAAAAAAAAALL) {
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
            }
            unint64_t v94 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v89 - *v91) >> 3);
            if (2 * v94 > v93) {
              unint64_t v93 = 2 * v94;
            }
            if (v94 >= 0x555555555555555) {
              unint64_t v95 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v95 = v93;
            }
            value[4] = (CGPDFObjectRef)(v87 + 1);
            if (v95) {
              unint64_t v95 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v95);
            }
            else {
              uint64_t v96 = 0;
            }
            uint64_t v97 = (uint64_t **)(v95 + 24 * v92);
            value[0] = (CGPDFObjectRef)v95;
            value[1] = (CGPDFObjectRef)v97;
            value[3] = (CGPDFObjectRef)(v95 + 24 * v96);
            __CFString *v97 = v81;
            v97[1] = (uint64_t *)v57;
            v97[2] = (uint64_t *)v52;
            CGPDFDictionaryRef value[2] = (CGPDFObjectRef)(v97 + 3);
            std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__swap_out_circular_buffer(v91, value);
            BOOL v90 = (void *)*v87;
            std::__split_buffer<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::~__split_buffer((uint64_t)value);
          }
          else
          {
            *uint64_t v86 = v81;
            v86[1] = (uint64_t *)v57;
            BOOL v90 = v86 + 3;
            v86[2] = (uint64_t *)v52;
          }
          *uint64_t v87 = v90;
          return;
        }
        goto LABEL_189;
      default:
        goto LABEL_94;
    }
    while (1)
    {
      value[0] = 0;
      if (!CGPDFArrayGetObject(v49, v60, value) || !value[0]) {
        break;
      }
      int v61 = *((_DWORD *)value[0] + 2);
      if (v60) {
        int v62 = 8;
      }
      else {
        int v62 = 3;
      }
      BOOL v63 = v61 == v62;
      if (v61 == 12) {
        BOOL v64 = v60 == 0;
      }
      else {
        BOOL v64 = v63;
      }
      if (++v60 >= v50 || !v64) {
        goto LABEL_144;
      }
    }
    BOOL v64 = 0;
LABEL_144:
    size_t v70 = 0;
    unint64_t v98 = a4 << 32;
    while (1)
    {
      value[0] = 0;
      if (CGPDFArrayGetObject(v49, v70, value))
      {
        if (!value[0]) {
          goto LABEL_162;
        }
        int v71 = *((_DWORD *)value[0] + 2);
        if (v71 != 12)
        {
          if (v71 == 8)
          {
            if ((TaggedParser::BuildStructureElement(a1, a2) & 1) == 0) {
              return;
            }
            goto LABEL_156;
          }
          if (v71 != 3)
          {
LABEL_162:
            uint64_t v47 = *(void *)a1;
            if (!*(unsigned char *)(*(void *)a1 + 96)) {
              goto LABEL_97;
            }
            uint64_t v48 = "Found a non-integer and non-dictionary object in /K array";
LABEL_96:
            printf("Hit tagged parsing error: \"%s\"\n", v48);
            uint64_t v47 = *(void *)a1;
            goto LABEL_97;
          }
        }
        uint64_t v72 = *((void *)value[0] + 4);
        if (!v64) {
          TaggedParser::CreateStructureElement();
        }
        uint64_t v73 = *(void *)(*(void *)a1 + 128);
        if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)a1 + 136) - v73) >> 3) <= v44)
        {
LABEL_189:
          __break(1u);
          return;
        }
        __s1 = (char *)(*((void *)value[0] + 4) | v98);
        int v74 = __s1;
        std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>((uint64_t **)(v73 + 24 * v44), v72 | v98, (uint64_t **)&__s1)[5] = a2;
        a2[10] = (uint64_t)v74;
      }
LABEL_156:
      if (*(unsigned char *)(*(void *)a1 + 97)) {
        BOOL v75 = 1;
      }
      else {
        BOOL v75 = v51 == v70;
      }
      ++v70;
      if (v75) {
        return;
      }
    }
  }
LABEL_94:
  uint64_t v47 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 96))
  {
    uint64_t v48 = "Malformed marked content structure";
    goto LABEL_96;
  }
LABEL_97:
  *(unsigned char *)(v47 + 97) = 1;
}

void sub_184EF931C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  applesauce::CF::ObjectRef<CGPDFDictionary *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,StructureElement *>,std::__map_value_compare<long long,std::__value_type<long long,StructureElement *>,std::less<long long>,true>,std::allocator<std::__value_type<long long,StructureElement *>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long &&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    v7[5] = 0;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    int64_t v10 = (uint64_t *)**a1;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void TaggedParser::CreateStructureElement()
{
}

{
  operator new();
}

BOOL TaggedParser::ValidatePageNumber(TaggedParser *this, CGPDFDictionary *a2, unint64_t *a3)
{
  UnresolvedObject = CGPDFDictionaryGetUnresolvedObject((uint64_t)a2, "Pg");
  if (!UnresolvedObject) {
    return 1;
  }
  if (*((_DWORD *)UnresolvedObject + 2) != 10) {
    return 1;
  }
  unint64_t PageNumberForPageReference = CGPDFDocumentGetPageNumberForPageReference(*(void *)(*(void *)this + 16), *((void *)UnresolvedObject + 2), *((void *)UnresolvedObject + 3));
  if (PageNumberForPageReference == -1) {
    return 1;
  }
  int v7 = *(_DWORD *)a3;
  *a3 = PageNumberForPageReference;
  int v8 = v7 - PageNumberForPageReference;
  if (v8 < 0) {
    int v8 = -v8;
  }
  return v8 < 2;
}

uint64_t TaggedParser::BuildObjectElement(uint64_t this, StructureElement *a2, CGPDFDictionaryRef dict, CGPDFDictionary *a4)
{
  if (this)
  {
    if (dict)
    {
      uint64_t v6 = (TaggedParser *)this;
      CGPDFDictionaryRef value = 0;
      this = CGPDFDictionaryGetName(dict, "Type", (const char **)&value);
      if (this)
      {
        this = (uint64_t)value;
        if (value)
        {
          this = strcmp(value, "Annot");
          if (!this)
          {
            memset(v9, 0, sizeof(v9));
            this = CGPDFDictionaryGetRect(dict, "Rect", (double *)v9);
            if (this)
            {
              __s1 = 0;
              this = CGPDFDictionaryGetName(dict, "Subtype", (const char **)&__s1);
              if (this)
              {
                if (__s1)
                {
                  this = CGPDFAnnotationCreateWithCGPDFDictionary((uint64_t)dict);
                  if (this) {
                    TaggedParser::CreateStructureElement(v6, a2, this, v7);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t *std::vector<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    long long v5 = *(_OWORD *)(v2 - 24);
    v2 -= 24;
    *(_OWORD *)(v4 - 24) = v5;
    v4 -= 24;
    *(void *)(v4 + 16) = *(void *)(v2 + 16);
    *(void *)(v2 + 16) = 0;
  }
  a2[1] = v4;
  uint64_t v6 = *result;
  *uint64_t result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__destroy_at[abi:fe180100]<std::tuple<StructureElement *,unsigned long,applesauce::CF::ObjectRef<CGPDFDictionary *>>,0>(*(const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void TaggedParser::CreateStructureElement(TaggedParser *this, StructureElement *a2, uint64_t a3, CGPDFAnnotation *a4)
{
}

void std::vector<__CFDictionary const*>::push_back[abi:fe180100](char **a1, uint64_t a2)
{
  long long v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        std::__throw_bad_array_new_length[abi:fe180100]();
      }
      unint64_t v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    unint64_t v13 = &v12[8 * v8];
    *(void *)unint64_t v13 = a2;
    uint64_t v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      long long v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(void *)long long v5 = a2;
    uint64_t v6 = v5 + 8;
  }
  a1[1] = v6;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4 = strlen(__s);

  return std::string::__assign_external(this, __s, v4);
}

void TaggedParser::LoadTextProperty(uint64_t a1, CGPDFDictionary *a2, CFStringRef theString)
{
  CGPDFStringRef value = 0;
  CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  if (CStringPtr && CGPDFDictionaryGetString(a2, CStringPtr, &value))
  {
    if (!*(void *)(a1 + 160)) {
      *(void *)(a1 + 160) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    CFStringRef v7 = CGPDFStringCopyTextString(value);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 160), theString, v7);
      CFRelease(v8);
    }
  }
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    CFStringRef v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    CFStringRef v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      unint64_t v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

uint64_t std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(void *a1, void *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 1;
    do
    {
      if ((std::operator<=>[abi:fe180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v3 + 4) & 0x80) == 0)
      {
        if ((std::operator<=>[abi:fe180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2) & 0x80) == 0) {
          return v4;
        }
        ++v3;
      }
      uint64_t v3 = (void *)*v3;
    }
    while (v3);
  }
  return 0;
}

void *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  long long v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        CFStringRef v7 = v4;
        CFStringRef v8 = v4 + 4;
        if ((std::operator<=>[abi:fe180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        long long v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:fe180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0) {
        break;
      }
      long long v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    CFStringRef v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::operator<=>[abi:fe180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void ___ZN12TaggedParser21MapNodeNameToNodeTypeENSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_184EFA810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  while (1)
  {
    if (*((char *)v11 - 9) < 0) {
      operator delete(*(v11 - 4));
    }
    v11 -= 4;
    if (v11 == (void **)&a10)
    {
      MEMORY[0x18532A2A0](v10, 0x1020C4062D53EE8);
      _Unwind_Resume(a1);
    }
  }
}

void RoleMapCallback(char *__s, CGPDFObject *a2, uint64_t **a3)
{
  if (a2 && *((_DWORD *)a2 + 2) == 5)
  {
    size_t v4 = (char *)*((void *)a2 + 4);
    std::string::basic_string[abi:fe180100]<0>(__p, __s);
    if (!std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__count_unique<std::string>(a3[1], __p))
    {
      std::string::basic_string[abi:fe180100]<0>(&v10, v4);
      size_t v5 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a3, &v16, __p);
      size_t v6 = (char *)*v5;
      if (!*v5)
      {
        int v7 = (uint64_t **)v5;
        size_t v6 = (char *)operator new(0x50uLL);
        v14[0] = v6;
        v14[1] = a3 + 1;
        char v15 = 0;
        CFStringRef v8 = (std::string *)(v6 + 32);
        if (SHIBYTE(v13) < 0)
        {
          std::string::__init_copy_ctor_external(v8, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
        }
        else
        {
          *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
          *((void *)v6 + 6) = v13;
        }
        *((void *)v6 + 7) = 0;
        *((void *)v6 + 8) = 0;
        *((void *)v6 + 9) = 0;
        char v15 = 1;
        std::__tree<unsigned long>::__insert_node_at(a3, v16, v7, (uint64_t *)v6);
        v14[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:fe180100]((uint64_t)v14);
      }
      unint64_t v9 = (void **)(v6 + 56);
      if (v6[79] < 0) {
        operator delete(*v9);
      }
      *(_OWORD *)unint64_t v9 = v10;
      *((void *)v6 + 9) = v11;
    }
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_184EFAA98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void TaggedParser::BeginMarkedContentSequence(TaggedParser *this, CGPDFPage *a2, CGPDFDictionaryRef dict, CGPDFDictionary *a4)
{
  if (!a2) {
    puts("Critical error: null page");
  }
  if (!*(unsigned char *)(*(void *)this + 97))
  {
    CGPDFStringRef value = 0;
    BOOL v7 = CGPDFDictionaryGetName(dict, "Type", (const char **)&value) && strcmp(value, "OCMD") == 0;
    CGPDFInteger v38 = -1;
    BOOL Integer = CGPDFDictionaryGetInteger(dict, "MCID", &v38);
    BOOL v9 = v38 >= 0 && Integer;
    if (a2) {
      uint64_t v10 = *(void *)(*((void *)a2 + 5) + 8);
    }
    else {
      uint64_t v10 = 0;
    }
    unint64_t v11 = v10 - 1;
    uint64_t v12 = *(void *)(*(void *)this + 104);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)this + 112) - v12) >> 3) <= v11)
    {
      __break(1u);
    }
    else
    {
      uint64_t v13 = (void **)(v12 + 24 * v11);
      if (v9)
      {
        if (a2) {
          unint64_t v14 = *(void *)(*((void *)a2 + 5) + 8) << 32;
        }
        else {
          unint64_t v14 = 0;
        }
        uint64_t v17 = v38 | v14;
        uint64_t v16 = *(char **)(v12 + 24 * v11 + 8);
        int v15 = 1;
      }
      else
      {
        if (v7) {
          int v15 = 2;
        }
        else {
          int v15 = 0;
        }
        uint64_t v16 = *(char **)(v12 + 24 * v11 + 8);
        if (v16 == *v13) {
          uint64_t v17 = -1;
        }
        else {
          uint64_t v17 = *((void *)v16 - 1);
        }
      }
      uint64_t v18 = v12 + 24 * v11;
      unint64_t v21 = *(void *)(v18 + 16);
      unint64_t v20 = (char **)(v18 + 16);
      unint64_t v19 = v21;
      unint64_t v22 = v20 - 1;
      if ((unint64_t)v16 < v21)
      {
        *(_DWORD *)uint64_t v16 = v15;
        *((void *)v16 + 1) = v17;
        uint64_t v23 = v16 + 16;
LABEL_44:
        *unint64_t v22 = v23;
        if (*(unsigned char *)(*(void *)this + 96))
        {
          unint64_t v32 = (unint64_t)(v23 - (unsigned char *)*v13) >> 4;
          if ((int)v32 >= 2)
          {
            int v33 = v32 - 1;
            do
            {
              printf("    ");
              --v33;
            }
            while (v33);
          }
          unint64_t v34 = "marked";
          if (v7) {
            unint64_t v34 = "optional";
          }
          printf("Pushed %s content sequence.", v34);
          if (v9)
          {
            printf(" Page number %d, MCID: %d.");
          }
          else if (v7)
          {
            printf(" Optional content.");
          }
          printf(" Current depth: %d.\n", v32);
        }
        return;
      }
      BOOL v36 = v9;
      BOOL v37 = v7;
      uint8x8_t v35 = v13;
      float v24 = *v13;
      uint64_t v25 = (v16 - v24) >> 4;
      unint64_t v26 = v25 + 1;
      if (!((unint64_t)(v25 + 1) >> 60))
      {
        uint64_t v27 = v19 - (void)v24;
        if (v27 >> 3 > v26) {
          unint64_t v26 = v27 >> 3;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          if (v28 >> 60) {
            std::__throw_bad_array_new_length[abi:fe180100]();
          }
          unint64_t v29 = (char *)operator new(16 * v28);
        }
        else
        {
          unint64_t v29 = 0;
        }
        uint64_t v30 = &v29[16 * v25];
        uint64_t v31 = &v29[16 * v28];
        *(_DWORD *)uint64_t v30 = v15;
        *((void *)v30 + 1) = v17;
        uint64_t v23 = v30 + 16;
        if (v16 == v24)
        {
          LOBYTE(v9) = v36;
          BOOL v7 = v37;
          uint64_t v13 = v35;
        }
        else
        {
          LOBYTE(v9) = v36;
          BOOL v7 = v37;
          do
          {
            *((_OWORD *)v30 - 1) = *((_OWORD *)v16 - 1);
            v30 -= 16;
            v16 -= 16;
          }
          while (v16 != v24);
          uint64_t v13 = v35;
          uint64_t v16 = (char *)*v35;
        }
        *uint64_t v13 = v30;
        *unint64_t v22 = v23;
        void *v20 = v31;
        if (v16) {
          operator delete(v16);
        }
        goto LABEL_44;
      }
    }
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
}

void TaggedParser::BeginMarkedContentSequence(TaggedParser *this, CGPDFPage *a2, const char *a3, const char *a4)
{
  if (!a2)
  {
    puts("Critical error: null page");
    uint64_t v5 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 97)) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v5 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 97)) {
    return;
  }
  BOOL v7 = *(CGPDFDictionary **)(*((void *)a2 + 5) + 16);
  if (!v7)
  {
LABEL_9:
    if (!*(unsigned char *)(v5 + 96)) {
      return;
    }
    uint64_t v10 = "Missing dictionary that backs a given page";
    goto LABEL_17;
  }
  CGPDFDictionaryRef value = 0;
  if (!CGPDFDictionaryGetDictionary(v7, "Resources", &value))
  {
    if (!*(unsigned char *)(*(void *)this + 96)) {
      return;
    }
    uint64_t v10 = "Missing \"Resources\" dictionary from page dictionary";
    goto LABEL_17;
  }
  CGPDFDictionaryRef dict = 0;
  if (!CGPDFDictionaryGetDictionary(value, "Properties", &dict))
  {
    if (!*(unsigned char *)(*(void *)this + 96)) {
      return;
    }
    uint64_t v10 = "Missing \"Properties\" dictionary from page resources dictionary";
    goto LABEL_17;
  }
  CGPDFDictionaryRef v11 = 0;
  if (CGPDFDictionaryGetDictionary(dict, a3, &v11))
  {
    TaggedParser::BeginMarkedContentSequence(this, a2, v11, v9);
    return;
  }
  if (*(unsigned char *)(*(void *)this + 96))
  {
    uint64_t v10 = "Missing given property name's dictionary from page resources's properties dictionary";
LABEL_17:
    printf("Hit tagged parsing error: \"%s\"\n", v10);
  }
}

uint64_t TaggedParser::EndMarkedContentSequence(uint64_t this, CGPDFPage *a2)
{
  if (!*(unsigned char *)(this + 97))
  {
    if (!a2
      || (unint64_t v2 = *(void *)(*((void *)a2 + 5) + 8) - 1,
          uint64_t v3 = *(void *)(this + 104),
          0xAAAAAAAAAAAAAAABLL * ((*(void *)(this + 112) - v3) >> 3) <= v2))
    {
LABEL_15:
      __break(1u);
      return this;
    }
    size_t v4 = (uint64_t *)(v3 + 24 * v2);
    size_t v6 = v4 + 1;
    uint64_t v5 = v4[1];
    uint64_t v7 = *v4;
    unint64_t v8 = v5 - *v4;
    if (v5 != *v4)
    {
      if (*(unsigned char *)(this + 96))
      {
        int v9 = (v8 >> 4) - 1;
        if ((int)(v8 >> 4) >= 2)
        {
          int v10 = (v8 >> 4) - 1;
          do
          {
            printf("    ");
            --v10;
          }
          while (v10);
        }
        this = printf("Popped content sequence. Was depth: %d\n", v9);
        uint64_t v7 = *v4;
        uint64_t v5 = *v6;
      }
      if (v7 != v5)
      {
        *size_t v6 = v5 - 16;
        return this;
      }
      goto LABEL_15;
    }
    if (*(unsigned char *)(this + 96)) {
      return printf("Hit tagged parsing error: \"%s\"\n", "Attempted to pop a marked content sequence from an empty stack");
    }
  }
  return this;
}

uint64_t TaggedParser::GetCurrentMCID(uint64_t this, CGPDFPage *a2)
{
  if (a2
    && (unint64_t v2 = *(void *)(*((void *)a2 + 5) + 8) - 1,
        uint64_t v3 = *(void *)(*(void *)this + 104),
        0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)this + 112) - v3) >> 3) > v2))
  {
    size_t v4 = &kCGPDFNodeIDNone;
    if (!*(unsigned char *)(*(void *)this + 97))
    {
      size_t v6 = (void *)(v3 + 24 * v2);
      uint64_t v5 = v6[1];
      if (v5 != *v6) {
        size_t v4 = (uint64_t *)(v5 - 8);
      }
    }
    return *v4;
  }
  else
  {
    __break(1u);
  }
  return this;
}

void TaggedParser::AddGraphicBounds(TaggedParser *this, CGPDFPage *a2, CGRect a3, char a4)
{
  if (!*(unsigned char *)(*(void *)this + 97))
  {
    CGFloat height = a3.size.height;
    CGFloat width = a3.size.width;
    CGFloat y = a3.origin.y;
    CGFloat x = a3.origin.x;
    unint64_t CurrentMCID = TaggedParser::GetCurrentMCID((uint64_t)this, a2);
    if (CurrentMCID != -1)
    {
      unint64_t v12 = CurrentMCID;
      unint64_t v13 = HIDWORD(CurrentMCID) - 1;
      uint64_t v14 = *(void *)(*(void *)this + 224);
      if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(*(void *)this + 232) - v14) >> 3) <= v13)
      {
        __break(1u);
        return;
      }
      int v15 = (float *)(v14 + 40 * v13);
      unint64_t v16 = *((void *)v15 + 1);
      if (v16)
      {
        uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
        v17.i16[0] = vaddlv_u8(v17);
        if (v17.u32[0] > 1uLL)
        {
          unint64_t v4 = CurrentMCID;
          if (CurrentMCID >= v16) {
            unint64_t v4 = CurrentMCID % v16;
          }
        }
        else
        {
          unint64_t v4 = (v16 - 1) & CurrentMCID;
        }
        uint64_t v18 = *(uint64_t ***)(*(void *)v15 + 8 * v4);
        if (v18)
        {
          for (uint64_t i = *v18; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v20 = i[1];
            if (v20 == CurrentMCID)
            {
              if (i[2] == CurrentMCID)
              {
                v43.origin.CGFloat x = x;
                v43.origin.CGFloat y = y;
                v43.size.CGFloat width = width;
                v43.size.CGFloat height = height;
                *(CGRect *)(i + 3) = CGRectUnion(*(CGRect *)(i + 3), v43);
                return;
              }
            }
            else
            {
              if (v17.u32[0] > 1uLL)
              {
                if (v20 >= v16) {
                  v20 %= v16;
                }
              }
              else
              {
                v20 &= v16 - 1;
              }
              if (v20 != v4) {
                break;
              }
            }
          }
        }
      }
      unint64_t v21 = (CGFloat *)operator new(0x40uLL);
      *unint64_t v21 = 0.0;
      *((void *)v21 + 1) = v12;
      *((void *)v21 + 2) = v12;
      v21[3] = x;
      v21[4] = y;
      v21[5] = width;
      v21[6] = height;
      *((unsigned char *)v21 + 56) = a4;
      float v22 = (float)(unint64_t)(*((void *)v15 + 3) + 1);
      float v23 = v15[8];
      if (v16 && (float)(v23 * (float)v16) >= v22)
      {
LABEL_67:
        unint64_t v39 = *(void **)v15;
        unint64_t v40 = *(CGFloat ***)(*(void *)v15 + 8 * v4);
        if (v40)
        {
          *(void *)unint64_t v21 = *v40;
        }
        else
        {
          *unint64_t v21 = *((CGFloat *)v15 + 2);
          *((void *)v15 + 2) = v21;
          v39[v4] = v15 + 4;
          if (!*(void *)v21)
          {
LABEL_76:
            ++*((void *)v15 + 3);
            return;
          }
          unint64_t v41 = *(void *)(*(void *)v21 + 8);
          if ((v16 & (v16 - 1)) != 0)
          {
            if (v41 >= v16) {
              v41 %= v16;
            }
          }
          else
          {
            v41 &= v16 - 1;
          }
          unint64_t v40 = (CGFloat **)(*(void *)v15 + 8 * v41);
        }
        void *v40 = v21;
        goto LABEL_76;
      }
      BOOL v24 = 1;
      if (v16 >= 3) {
        BOOL v24 = (v16 & (v16 - 1)) != 0;
      }
      unint64_t v25 = v24 | (2 * v16);
      unint64_t v26 = vcvtps_u32_f32(v22 / v23);
      if (v25 <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      else {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v16 = *((void *)v15 + 1);
      if (*(void *)&prime > v16) {
        goto LABEL_33;
      }
      if (*(void *)&prime < v16)
      {
        unint64_t v34 = vcvtps_u32_f32((float)*((unint64_t *)v15 + 3) / v15[8]);
        if (v16 < 3 || (uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v16), v35.i16[0] = vaddlv_u8(v35), v35.u32[0] > 1uLL))
        {
          unint64_t v34 = std::__next_prime(v34);
        }
        else
        {
          uint64_t v36 = 1 << -(char)__clz(v34 - 1);
          if (v34 >= 2) {
            unint64_t v34 = v36;
          }
        }
        if (*(void *)&prime <= v34) {
          int8x8_t prime = (int8x8_t)v34;
        }
        if (*(void *)&prime >= v16)
        {
          unint64_t v16 = *((void *)v15 + 1);
        }
        else
        {
          if (prime)
          {
LABEL_33:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:fe180100]();
            }
            unint64_t v28 = operator new(8 * *(void *)&prime);
            unint64_t v29 = *(void **)v15;
            *(void *)int v15 = v28;
            if (v29) {
              operator delete(v29);
            }
            uint64_t v30 = 0;
            *((int8x8_t *)v15 + 1) = prime;
            do
              *(void *)(*(void *)v15 + 8 * v30++) = 0;
            while (*(void *)&prime != v30);
            uint64_t v31 = (void *)*((void *)v15 + 2);
            if (v31)
            {
              unint64_t v32 = v31[1];
              uint8x8_t v33 = (uint8x8_t)vcnt_s8(prime);
              v33.i16[0] = vaddlv_u8(v33);
              if (v33.u32[0] > 1uLL)
              {
                if (v32 >= *(void *)&prime) {
                  v32 %= *(void *)&prime;
                }
              }
              else
              {
                v32 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)v15 + 8 * v32) = v15 + 4;
              BOOL v37 = (void *)*v31;
              if (*v31)
              {
                do
                {
                  unint64_t v38 = v37[1];
                  if (v33.u32[0] > 1uLL)
                  {
                    if (v38 >= *(void *)&prime) {
                      v38 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v38 &= *(void *)&prime - 1;
                  }
                  if (v38 != v32)
                  {
                    if (!*(void *)(*(void *)v15 + 8 * v38))
                    {
                      *(void *)(*(void *)v15 + 8 * v38) = v31;
                      goto LABEL_58;
                    }
                    *uint64_t v31 = *v37;
                    void *v37 = **(void **)(*(void *)v15 + 8 * v38);
                    **(void **)(*(void *)v15 + 8 * v38) = v37;
                    BOOL v37 = v31;
                  }
                  unint64_t v38 = v32;
LABEL_58:
                  uint64_t v31 = v37;
                  BOOL v37 = (void *)*v37;
                  unint64_t v32 = v38;
                }
                while (v37);
              }
            }
            unint64_t v16 = (unint64_t)prime;
            goto LABEL_62;
          }
          uint64_t v42 = *(void **)v15;
          *(void *)int v15 = 0;
          if (v42) {
            operator delete(v42);
          }
          unint64_t v16 = 0;
          *((void *)v15 + 1) = 0;
        }
      }
LABEL_62:
      if ((v16 & (v16 - 1)) != 0)
      {
        if (v12 >= v16) {
          unint64_t v4 = v12 % v16;
        }
        else {
          unint64_t v4 = v12;
        }
      }
      else
      {
        unint64_t v4 = (v16 - 1) & v12;
      }
      goto LABEL_67;
    }
  }
}

void sub_184EFB518(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CreateCGPDFTaggedNodeFromStructureElement(uint64_t result, CGPDFPage *a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  if (!IsStructureElementForPage(result, a2)) {
    return 0;
  }
  uint64_t v4 = CGPDFTaggedNodeCreate((uint64_t)a2);
  uint64_t v5 = (const char *)(v3 + 8);
  if (*(char *)(v3 + 31) < 0) {
    uint64_t v5 = *(const char **)v5;
  }
  CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, 0x8000100u);
  if (v6)
  {
    CFStringRef v7 = v6;
    CGPDFTaggedNodeSetTypeName(v4, v6);
    CFRelease(v7);
  }
  CGPDFTaggedNodeSetType((CFStringRef)v4, *(_DWORD *)(v3 + 32));
  if (*(unsigned char *)(v3 + 64))
  {
    if (!v4) {
      goto LABEL_13;
    }
    *(unsigned char *)(v4 + 112) = 0;
  }
  else if (!v4)
  {
    goto LABEL_13;
  }
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(v3 + 88);
LABEL_13:
  CFDictionaryRef v8 = *(const __CFDictionary **)(v3 + 160);
  if (v8)
  {
    CFBooleanRef Value = CFDictionaryGetValue(v8, @"Alt");
    if (Value) {
      CGPDFTaggedNodeSetAltText(v4, Value);
    }
    int v10 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), @"ActualText");
    if (v10) {
      CGPDFTaggedNodeSetActualText(v4, v10);
    }
    CGPDFDictionaryRef v11 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), @"T");
    if (v11) {
      CGPDFTaggedNodeSetTitleText(v4, v11);
    }
    unint64_t v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 160), @"Lang");
    if (v12) {
      CGPDFTaggedNodeSetLanguageText(v4, v12);
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  unint64_t v13 = *(void ***)(v3 + 176);
  uint64_t v14 = *(void ***)(v3 + 184);
  while (v13 != v14)
  {
    int v15 = *v13++;
    CGPDFTaggedNodeAddURL(v4, v15);
  }
  unint64_t v16 = *(const StructureElement ***)(v3 + 112);
  uint8x8_t v17 = *(const StructureElement ***)(v3 + 120);
  while (v16 != v17)
  {
    uint64_t CGPDFTaggedNodeFromStructureElement = CreateCGPDFTaggedNodeFromStructureElement(*v16, a2);
    if (CGPDFTaggedNodeFromStructureElement)
    {
      unint64_t v19 = (void *)CGPDFTaggedNodeFromStructureElement;
      if (v12)
      {
        if (!*(void *)(CGPDFTaggedNodeFromStructureElement + 144)) {
          CGPDFTaggedNodeSetLanguageText(CGPDFTaggedNodeFromStructureElement, v12);
        }
      }
      CGPDFTaggedNodeAddTaggedNode(v4, v19);
      CFRelease(v19);
    }
    ++v16;
  }
  unint64_t v20 = *(void *)(v3 + 80);
  if (v20 == -1) {
    unint64_t v21 = 0;
  }
  else {
    unint64_t v21 = HIDWORD(v20);
  }
  if (v4) {
    *(void *)(v4 + 160) = v21;
  }
  unint64_t v64 = v21;
  float v22 = *(__n64 ***)(v3 + 136);
  float v23 = *(__n64 ***)(v3 + 144);
  if (v22 != v23)
  {
    while (1)
    {
      BOOL v24 = *v22;
      if (!*v22) {
        goto LABEL_68;
      }
      unint64_t v25 = *v22;
      while (v25->n64_u32[0] != 517)
      {
        unint64_t v25 = (__n64 *)v25[1].n64_u64[0];
        if (!v25) {
          goto LABEL_68;
        }
      }
      if (!v25[13].n64_u64[0]) {
        goto LABEL_68;
      }
      int v26 = v24->n64_u32[0];
      if (v24->n64_u32[0] == 1) {
        break;
      }
      if ((v26 - 257) < 2)
      {
        uint64_t v27 = 0;
        uint64_t v65 = 0;
        int v28 = 700;
        goto LABEL_60;
      }
      if (v26 == 259)
      {
        uint64_t v29 = v24[13].n64_i64[0];
        if (v29)
        {
          uint64_t v30 = *(void *)(v29 + 16);
          if (v30)
          {
            uint64_t v27 = *(void *)(v30 + 40);
            uint64_t v65 = *(void *)(v30 + 32);
          }
          else
          {
            uint64_t v65 = 0;
            uint64_t v27 = 0;
          }
          if (CGPDFAnnotationGetType(v29) == 25) {
            int v28 = 702;
          }
          else {
            int v28 = 507;
          }
        }
        else
        {
          uint64_t v27 = 0;
          uint64_t v65 = 0;
          int v28 = 0;
        }
        int v26 = 259;
        goto LABEL_60;
      }
LABEL_68:
      if (++v22 == v23) {
        goto LABEL_69;
      }
    }
    uint64_t v27 = 0;
    uint64_t v65 = 0;
    int v28 = 1;
LABEL_60:
    uint64_t v31 = CGPDFTaggedNodeCreate(0);
    CGPDFTaggedNodeSetType((CFStringRef)v31, v28);
    if (v31)
    {
      unint64_t v32 = *(_DWORD **)(v31 + 104);
      if (v32) {
        CGPDFNodeRelease(v32);
      }
      *(void *)(v31 + 104) = v24;
      ++v24[5].n64_u32[0];
      *(void *)(v31 + 160) = v64;
    }
    v33.n64_u64[0] = CGPDFNodeGetBounds(v24).n64_u64[0];
    CGFloat v35 = v34;
    CGFloat v37 = v36;
    CGFloat v39 = v38;
    double Rotation = CGPDFNodeGetRotation((uint64_t)v24);
    __double2 v41 = __sincos_stret(Rotation);
    v67.tCGFloat x = 0.0;
    v67.tCGFloat y = 0.0;
    v67.a = v41.__cosval;
    v67.double b = v41.__sinval;
    v67.double c = -v41.__sinval;
    v67.double d = v41.__cosval;
    if (v31)
    {
      v68.origin.CGFloat x = v33.n64_f64[0];
      v68.origin.CGFloat y = v35;
      v68.size.CGFloat width = v37;
      v68.size.CGFloat height = v39;
      CGRect v69 = CGRectApplyAffineTransform(v68, &v67);
      *(unsigned char *)(v31 + 48) = 1;
      *(CGRect *)(v31 + 56) = v69;
      if (v26 == 257) {
        *(unsigned char *)(v31 + 113) = 1;
      }
      *(void *)(v31 + 32) = v65;
      *(void *)(v31 + 40) = v27;
      CGPDFTaggedNodeAddTaggedNode(v4, (void *)v31);
      CFRelease((CFTypeRef)v31);
    }
    goto LABEL_68;
  }
LABEL_69:
  uint64_t v42 = *(void ***)(v3 + 200);
  CGRect v43 = *(void ***)(v3 + 208);
  while (v42 != v43)
  {
    unint64_t v44 = *v42++;
    CGPDFTaggedNodeAddTaggedNode(v4, v44);
  }
  if (v4 && *(_DWORD *)(v4 + 16) == 700)
  {
    double Bounds = CGPDFTaggedNodeGetBounds(v4);
    int v49 = 1;
    goto LABEL_75;
  }
  if (*(void *)(v3 + 112) == *(void *)(v3 + 120) && *(void *)(v3 + 200) == *(void *)(v3 + 208))
  {
    double Bounds = CGPDFTaggedNodeGetBounds(v4);
    if (v4)
    {
      int v49 = 0;
LABEL_75:
      CGRect v70 = CGRectUnion(*(CGRect *)&Bounds, *(CGRect *)(v3 + 224));
      *(unsigned char *)(v4 + 48) = 1;
      *(CGRect *)(v4 + 56) = v70;
      if (v49) {
        *(unsigned char *)(v4 + 113) = *(unsigned char *)(v3 + 256);
      }
    }
  }
  uint64_t v50 = *(void *)(v3 + 168);
  if (v50)
  {
    CGFloat Rect = CGPDFAnnotationGetRect(v50);
    CGFloat y = v52;
    CGFloat width = v54;
    CGFloat height = v56;
    int RotationAngle = CGPDFPageGetRotationAngle(a2);
    if (RotationAngle)
    {
      __double2 v59 = __sincos_stret((double)RotationAngle * -3.14159265 / 180.0);
      v66.tCGFloat x = 0.0;
      v66.tCGFloat y = 0.0;
      v66.a = v59.__cosval;
      v66.double b = v59.__sinval;
      v66.double c = -v59.__sinval;
      v66.double d = v59.__cosval;
      v71.origin.CGFloat x = Rect;
      v71.origin.CGFloat y = y;
      v71.size.CGFloat width = width;
      v71.size.CGFloat height = height;
      CGRect v72 = CGRectApplyAffineTransform(v71, &v66);
      CGFloat Rect = v72.origin.x;
      CGFloat y = v72.origin.y;
      CGFloat width = v72.size.width;
      CGFloat height = v72.size.height;
    }
    if (v4)
    {
      *(unsigned char *)(v4 + 48) = 1;
      *(CGFloat *)(v4 + 56) = Rect;
      *(CGFloat *)(v4 + 64) = y;
      *(CGFloat *)(v4 + 72) = width;
      *(CGFloat *)(v4 + 80) = height;
    }
  }
  double v60 = *(double *)(v3 + 264);
  double v61 = *(double *)(v3 + 272);
  BOOL v62 = v60 == INFINITY;
  if (v61 == INFINITY) {
    BOOL v62 = 1;
  }
  if (v62) {
    uint64_t result = v4;
  }
  else {
    uint64_t result = 0;
  }
  if (!v62 && v4)
  {
    *(unsigned char *)(v4 + 48) = 1;
    long long v63 = *(_OWORD *)(v3 + 280);
    *(double *)(v4 + 56) = v60;
    *(double *)(v4 + 64) = v61;
    *(_OWORD *)(v4 + 72) = v63;
    return v4;
  }
  return result;
}

const void **applesauce::CF::ObjectRef<CGPDFLayout *>::~ObjectRef(const void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TaggedParser::BuildStructureElementFromGroupRegion(TaggedParser *this, StructureElement *a2, PDFCRGroupRegion *a3, CGPDFPage *a4, NSMutableSet *a5, PageLayout *a6)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v9 = a3;
  unint64_t v19 = a5;
  uint8x8_t v17 = v9;
  int v10 = [(NSMutableSet *)v19 member:v9];

  if (v10)
  {
    uint64_t v11 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 96))
    {
      printf("Hit tagged parsing error: \"%s\"\n", "Cycles detected in marked structure element graph");
      uint64_t v11 = *(void *)this;
    }
    *(unsigned char *)(v11 + 97) = 1;
  }
  else
  {
    [(NSMutableSet *)v19 addObject:v9];
    memset(v27, 0, sizeof(v27));
    obCFIndex j = [(PDFCRGroupRegion *)v9 children];
    unint64_t v20 = a2;
    if ([obj countByEnumeratingWithState:v27 objects:v29 count:16])
    {
      unint64_t v12 = (void *)**((void **)&v27[0] + 1);
      if ([**((id **)&v27[0] + 1) type] == 6)
      {
        *((_DWORD *)a2 + 8) = 400;
        if ([v12 rowIndex] >= (unint64_t)((uint64_t)(*((void *)a2 + 15) - *((void *)a2 + 14)) >> 3)) {
          TaggedParser::CreateStructureElement();
        }
        TaggedParser::CreateStructureElement();
      }
      TaggedParser::CreateStructureElement();
    }

    unint64_t v13 = a2;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    id v18 = [(PDFCRGroupRegion *)v9 subregions];
    uint64_t v14 = [v18 countByEnumeratingWithState:&v23 objects:v28 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v24;
LABEL_13:
      uint64_t v16 = 0;
      while (2)
      {
        if (*(void *)v24 != v15) {
          objc_enumerationMutation(v18);
        }
        id v21 = *(id *)(*((void *)&v23 + 1) + 8 * v16);
        switch([v21 type])
        {
          case 1u:
            TaggedParser::CreateStructureElement();
          case 2u:
            TaggedParser::CreateStructureElement();
          case 3u:
            TaggedParser::CreateStructureElement();
          case 4u:
            *((_DWORD *)v13 + 8) = 300;
            TaggedParser::CreateStructureElement();
          default:

            ++v16;
            unint64_t v13 = v20;
            if (v16 != v14) {
              continue;
            }
            uint64_t v14 = [v18 countByEnumeratingWithState:&v23 objects:v28 count:16];
            if (!v14) {
              goto LABEL_23;
            }
            goto LABEL_13;
        }
      }
    }
LABEL_23:
  }
}

void sub_184EFC54C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

BOOL IsStructureElementForPage(uint64_t a1, CGPDFPage *a2)
{
  if (a2) {
    uint64_t v3 = *(void *)(*((void *)a2 + 5) + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = *(void *)(a1 + 80);
  if (v4 == -1)
  {
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v5 = *(void *)(a1 + 72) + 1;
    }
    else {
      uint64_t v5 = -1;
    }
  }
  else
  {
    uint64_t v5 = HIDWORD(v4);
  }
  if (v5 == v3) {
    return 1;
  }
  if (*(void *)(a1 + 168)) {
    return *(unsigned int *)(a1 + 4) == v3;
  }
  if (v4 == -1)
  {
    CFStringRef v7 = *(const StructureElement ***)(a1 + 112);
    CFDictionaryRef v8 = *(const StructureElement ***)(a1 + 120);
    if (v7 != v8)
    {
      while (!*v7 || (IsStructureElementForPage(*v7, a2) & 1) == 0)
      {
        BOOL result = 0;
        if (++v7 == v8) {
          return result;
        }
      }
      return 1;
    }
  }
  return 0;
}

void RemovePageNodesFromStructureElement(StructureElement *a1, CGPDFPage *a2)
{
  if (a1)
  {
    unint64_t v4 = *((void *)a1 + 10);
    if (v4 == -1 || ((unint64_t v5 = HIDWORD(v4), !a2) ? (v6 = 0) : (v6 = *(void *)(*((void *)a2 + 5) + 8)), v5 == v6))
    {
      while (1)
      {
        uint64_t v8 = *((void *)a1 + 18);
        if (*((void *)a1 + 17) == v8) {
          break;
        }
        CFStringRef v7 = *(_DWORD **)(v8 - 8);
        *((void *)a1 + 18) = v8 - 8;
        CGPDFNodeRelease(v7);
      }
      uint64_t v10 = *((void *)a1 + 14);
      for (uint64_t i = *((void *)a1 + 15); v10 != i; *((void *)a1 + 15) = i)
      {
        RemovePageNodesFromStructureElement(*(StructureElement **)(i - 8), a2);
        uint64_t v10 = *((void *)a1 + 14);
        uint64_t v11 = *((void *)a1 + 15);
        if (v10 == v11)
        {
          __break(1u);
          return;
        }
        uint64_t i = v11 - 8;
      }
    }
  }
}

__CFDictionary *BuildStructureTree(unint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t valuePtr = -1;
  unint64_t v6 = *(void *)(a3 + 80);
  if (v6 != -1)
  {
    if (a1 != HIDWORD(v6)) {
      return 0;
    }
    uint64_t valuePtr = *(void *)(a3 + 80);
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableDataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CGCFDictionarySetNumber(Mutable, @"TagNodeMCID", kCFNumberSInt64Type, &valuePtr);
  CGCFDictionarySetNumber(Mutable, @"TagNodeStructureID", kCFNumberSInt64Type, (void *)a3);
  CGCFDictionarySetNumber(Mutable, @"TagNodeObjectRefID", kCFNumberSInt64Type, (void *)(a3 + 88));
  CGCFDictionarySetInteger(Mutable, @"TagNodeType", *(_DWORD *)(a3 + 32));
  int v9 = (char *)(a3 + 40);
  if ((*(char *)(a3 + 63) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a3 + 63)) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (*(void *)(a3 + 48))
  {
    int v9 = *(char **)v9;
LABEL_10:
    CGCFDictionarySetCString(Mutable, @"ID", v9);
  }
LABEL_11:
  uint64_t v10 = *(const void **)(a3 + 160);
  if (v10) {
    CFDictionarySetValue(Mutable, @"TagNodeProperties", v10);
  }
  unint64_t v12 = *(const StructureElement ***)(a3 + 112);
  uint64_t v11 = *(const StructureElement ***)(a3 + 120);
  while (v12 != v11)
  {
    if (*v12) {
      BuildStructureTree(a1, Mutable, *v12);
    }
    ++v12;
  }
  if (a2)
  {
    CFBooleanRef Value = (void *)CFDictionaryGetValue(a2, @"TagNodeChildren");
    if (!Value)
    {
      CFBooleanRef Value = CFArrayCreateMutable(v7, 0, MEMORY[0x1E4F1D510]);
      CFDictionarySetValue(a2, @"TagNodeChildren", Value);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, Mutable);
    CFRelease(Mutable);
  }
  return Mutable;
}

void sub_184EFCC4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184EFD178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184EFD390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_184EFD4A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184EFD6A4(_Unwind_Exception *a1)
{
  unint64_t v5 = v4;

  _Unwind_Resume(a1);
}

char *__assign_helper_atomic_property_(char *result, uint64_t a2)
{
  if (result != (char *)a2) {
    return std::vector<PageLayout::TextLine>::__assign_with_size[abi:fe180100]<PageLayout::TextLine*,PageLayout::TextLine*>(result, *(char **)a2, *(void *)(a2 + 8), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
  }
  return result;
}

char *std::vector<PageLayout::TextLine>::__assign_with_size[abi:fe180100]<PageLayout::TextLine*,PageLayout::TextLine*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  CFAllocatorRef v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (0x8E38E38E38E38E39 * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *CFAllocatorRef v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x38E38E38E38E38ELL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v10 = 0x8E38E38E38E38E39 * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x1C71C71C71C71C7) {
      unint64_t v12 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v12 = v11;
    }
    BOOL result = std::vector<PageLayout::TextLine>::__vallocate[abi:fe180100](v7, v12);
    uint64_t v14 = (char *)v7[1];
    unint64_t v13 = (void **)(v7 + 1);
    int v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      id v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v13 = (void **)(result + 8);
  uint64_t v15 = (unsigned char *)*((void *)result + 1);
  if (0x8E38E38E38E38E39 * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    BOOL result = (char *)memmove(*(void **)result, __src, v15 - v9);
    int v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    id v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    BOOL result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unint64_t v13 = &v9[v17];
  return result;
}

char *std::vector<PageLayout::TextLine>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

void *__copy_helper_atomic_property_(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return std::vector<PageLayout::TextLine>::__init_with_size[abi:fe180100]<PageLayout::TextLine*,PageLayout::TextLine*>(a1, *(const void **)a2, *(void *)(a2 + 8), 0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
}

void *std::vector<PageLayout::TextLine>::__init_with_size[abi:fe180100]<PageLayout::TextLine*,PageLayout::TextLine*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    BOOL result = std::vector<PageLayout::TextLine>::__vallocate[abi:fe180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_184EFD9D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_184EFDAA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184EFDBE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_184EFDC9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TextRecognitionLibraryCore(char **a1)
{
  if (!TextRecognitionLibraryCore(char **)::frameworkLibrary) {
    TextRecognitionLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
  }
  return TextRecognitionLibraryCore(char **)::frameworkLibrary;
}

void PageLayout::splitLines(void *a1, int a2, uint64_t **a3, __n128 a4, double a5, double a6, __n128 a7, __n128 a8)
{
  uint64_t v8 = a1[5] - a1[4];
  if (v8)
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0x8E38E38E38E38E39 * (v8 >> 3);
    uint64_t v11 = 1;
    if (!a2) {
      uint64_t v11 = 2;
    }
    unint64_t v119 = v10;
    unint64_t v120 = v11;
    uint64_t v116 = a3 + 1;
    do
    {
      uint64_t v12 = a1[4];
      if (0x8E38E38E38E38E39 * ((a1[5] - v12) >> 3) <= v9) {
        goto LABEL_105;
      }
      while (1)
      {
        uint64_t v122 = v12;
        unint64_t v124 = v9;
        uint64_t v121 = (uint64_t *)(v12 + 72 * v9);
        unint64_t v13 = v121[1];
        if (v13 < 2) {
          break;
        }
        int v14 = 0;
        uint64_t v15 = a1[10] + 8 * *v121;
        uint64_t v16 = 8 * v13;
        size_t v17 = (int *)v15;
        do
        {
          int v18 = *v17;
          v17 += 2;
          v14 += v18;
          v16 -= 8;
        }
        while (v16);
        if (v13 > v14) {
          break;
        }
        uint64_t v132 = a1[13] + 32 * *v121;
        unint64_t v19 = v14;
        uint64_t v20 = v12 + 72 * v124;
        uint64_t v134 = a1[7] + 2 * *(void *)(v20 + 16);
        unint64_t v129 = v14;
        uint64_t v118 = (uint64_t *)(v20 + 16);
        unint64_t v21 = 0;
        for (uint64_t i = 0; i != v120; v21 += *(void *)(v15 + 8 * i++))
          ;
        if (v120 >= v13 - v120 || v21 >= v19) {
          break;
        }
        unint64_t v23 = v120;
        if (v120 <= v13) {
          unint64_t v24 = v121[1];
        }
        else {
          unint64_t v24 = v120;
        }
        unint64_t v125 = v24;
        while (1)
        {
          if (*(_WORD *)(v134 + 2 * v21) != 32) {
            goto LABEL_41;
          }
          if (v13 <= v23) {
            goto LABEL_105;
          }
          long long v25 = (double *)(v132 + 32 * v23);
          double v26 = v25[2];
          if (v26 > NAN + NAN) {
            break;
          }
          int v28 = (double *)a1[57];
          uint64_t v27 = (double *)a1[58];
          if (v27 != v28)
          {
            unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (v27 - v28);
            do
            {
              unint64_t v30 = v29 >> 1;
              uint64_t v31 = &v28[3 * (v29 >> 1)];
              double v33 = *v31;
              unint64_t v32 = v31 + 3;
              v29 += ~(v29 >> 1);
              if (v33 < *v25) {
                int v28 = v32;
              }
              else {
                unint64_t v29 = v30;
              }
            }
            while (v29);
          }
          if (v28 != v27)
          {
            double v40 = *v25;
            double v42 = v25[3];
            BOOL v34 = v42 < 0.0 || v26 < 0.0;
            do
            {
              double v35 = *v28;
              if (v34)
              {
                v136.origin.CGFloat y = v25[1];
                v136.origin.CGFloat x = v40;
                v136.size.CGFloat width = v26;
                v136.size.CGFloat height = v42;
                *(CGRect *)a4.n128_u64 = CGRectStandardize(v136);
                if (v35 >= a4.n128_f64[0] + v36) {
                  break;
                }
                double v37 = v28[2];
                double v41 = v25[1];
                v137.origin.CGFloat x = v40;
                v137.origin.CGFloat y = v41;
                v137.size.CGFloat width = v26;
                v137.size.CGFloat height = v42;
                *(CGRect *)a4.n128_u64 = CGRectStandardize(v137);
                if (v37 >= v38 + a7.n128_f64[0])
                {
                  double v39 = v28[1];
                  v138.origin.CGFloat x = v40;
                  v138.origin.CGFloat y = v41;
                  v138.size.CGFloat width = v26;
                  v138.size.CGFloat height = v42;
                  *(CGRect *)a4.n128_u64 = CGRectStandardize(v138);
                  goto LABEL_39;
                }
              }
              else
              {
                if (v35 >= v40 + v26) {
                  break;
                }
                double v41 = v25[1];
                if (v28[2] >= v41 + v42)
                {
                  double v39 = v28[1];
                  v139.origin.CGFloat y = v25[1];
LABEL_39:
                  if (v39 <= v139.origin.y) {
                    goto LABEL_45;
                  }
                }
              }
              v28 += 3;
            }
            while (v28 != v27);
          }
LABEL_41:
          if (v23 == v125) {
            goto LABEL_105;
          }
          if (v23 + 1 < v13 - v120)
          {
            v21 += *(void *)(v15 + 8 * v23++);
            if (v21 < v129) {
              continue;
            }
          }
          goto LABEL_103;
        }
        double v40 = *v25;
        double v41 = v25[1];
        double v42 = v25[3];
LABEL_45:
        v25[2] = 0.0;
        uint64_t v43 = v122 + 72 * v124;
        double v45 = *(double *)(v43 + 40);
        uint64_t v44 = v43 + 40;
        double v46 = v45;
        double v47 = *(double *)(v44 - 16);
        a4.n128_u64[0] = *(void *)(v44 + 8);
        CGFloat v133 = *(double *)(v44 - 8);
        __n128 v135 = a4;
        uint64_t v48 = *v121;
        uint64_t v49 = v121[1];
        unint64_t v50 = v23 + 1;
        v121[1] = v23 + 1;
        BOOL v51 = v42 < 0.0 || v26 < 0.0;
        double v52 = v40;
        if (v51)
        {
          v140.origin.CGFloat x = v40;
          v140.origin.CGFloat y = v41;
          v140.size.CGFloat width = v26;
          v140.size.CGFloat height = v42;
          *(void *)&double v52 = (unint64_t)CGRectStandardize(v140);
        }
        *(double *)uint64_t v44 = v52 - v47;
        uint64_t v53 = *v118;
        if (v51)
        {
          v141.origin.CGFloat x = v40;
          v141.origin.CGFloat y = v41;
          v141.size.CGFloat width = v26;
          v141.size.CGFloat height = v42;
          *(CGRect *)((char *)&a7 - 24) = CGRectStandardize(v141);
          double v40 = v54;
          double v26 = v55;
        }
        if (v46 < 0.0 || v135.n128_f64[0] < 0.0)
        {
          v142.origin.CGFloat x = v47;
          v142.origin.CGFloat y = v133;
          *(void *)&v142.size.CGFloat height = v135.n128_u64[0];
          v142.size.CGFloat width = v46;
          *(CGRect *)((char *)&a7 - 24) = CGRectStandardize(v142);
          double v47 = v56;
          double v46 = v57;
        }
        unint64_t v58 = v50 + v48;
        unint64_t v59 = v49 - v50;
        uint64_t v60 = v21 + v53 + 1;
        a8.n128_f64[0] = v40 + v26;
        a7.n128_f64[0] = v47 + v46 - (v40 + v26);
        BOOL v62 = (unsigned char *)a1[4];
        double v61 = (char *)a1[5];
        long long v63 = (CGFloat *)&v62[72 * v124];
        unint64_t v64 = (char *)(v63 + 9);
        uint64_t v65 = (uint64_t *)(v122 + 72 * v124 + 56);
        uint64_t v66 = a1[2];
        a1[2] = v66 + 1;
        uint64_t v67 = 72 * v124 + 72;
        unint64_t v68 = 0x8E38E38E38E38E39 * (v67 >> 3);
        unint64_t v69 = a1[6];
        if ((unint64_t)v61 < v69)
        {
          uint64_t v70 = *v65;
          if (v64 == v61)
          {
            *((void *)v63 + 9) = v58;
            *((void *)v63 + 10) = v59;
            uint64_t v88 = (CGFloat *)&v62[8 * (v67 >> 3)];
            *((void *)v88 + 2) = v60;
            v88[3] = a8.n128_f64[0];
            v88[4] = v133;
            a4.n128_u64[1] = v135.n128_u64[1];
            v88[5] = a7.n128_f64[0];
            v88[6] = v135.n128_f64[0];
            *((void *)v88 + 7) = v70;
            *((void *)v88 + 8) = v66;
            a1[5] = v63 + 18;
            unint64_t v85 = v124;
          }
          else
          {
            size_t v71 = v61 - (char *)(v63 + 18);
            CGRect v72 = &v64[v71];
            uint64_t v73 = v61;
            while (v72 < v61)
            {
              *(_OWORD *)uint64_t v73 = *(_OWORD *)v72;
              long long v74 = *((_OWORD *)v72 + 1);
              long long v75 = *((_OWORD *)v72 + 2);
              long long v76 = *((_OWORD *)v72 + 3);
              *((void *)v73 + 8) = *((void *)v72 + 8);
              *((_OWORD *)v73 + 2) = v75;
              *((_OWORD *)v73 + 3) = v76;
              *((_OWORD *)v73 + 1) = v74;
              v72 += 72;
              v73 += 72;
            }
            a1[5] = v73;
            unint64_t v85 = v124;
            if (v61 != (char *)(v63 + 18))
            {
              __n128 v130 = a7;
              __n128 v126 = a8;
              uint64_t v86 = v60;
              unint64_t v87 = v59;
              memmove(v63 + 18, v63 + 9, v71);
              unint64_t v59 = v87;
              uint64_t v60 = v86;
              a8 = v126;
              a7 = v130;
            }
            *((void *)v63 + 9) = v58;
            *((void *)v63 + 10) = v59;
            *((void *)v63 + 11) = v60;
            v63[12] = a8.n128_f64[0];
            v63[13] = v133;
            a4.n128_u64[1] = v135.n128_u64[1];
            v63[14] = a7.n128_f64[0];
            v63[15] = v135.n128_f64[0];
            *((void *)v63 + 16) = v70;
            *((void *)v63 + 17) = v66;
          }
          goto LABEL_87;
        }
        unint64_t v77 = 0x8E38E38E38E38E39 * ((v61 - v62) >> 3) + 1;
        if (v77 > 0x38E38E38E38E38ELL) {
LABEL_106:
        }
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        unint64_t v78 = 0x8E38E38E38E38E39 * ((uint64_t)(v69 - (void)v62) >> 3);
        if (2 * v78 > v77) {
          unint64_t v77 = 2 * v78;
        }
        if (v78 >= 0x1C71C71C71C71C7) {
          unint64_t v79 = 0x38E38E38E38E38ELL;
        }
        else {
          unint64_t v79 = v77;
        }
        if (v79)
        {
          uint64_t v80 = v60;
          unint64_t v81 = v59;
          unint64_t v82 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v79);
          unint64_t v59 = v81;
          uint64_t v60 = v80;
          a8.n128_f64[0] = v40 + v26;
          a7.n128_f64[0] = v47 + v46 - (v40 + v26);
          uint64_t v84 = v82;
        }
        else
        {
          uint64_t v84 = 0;
          uint64_t v83 = 0;
        }
        unint64_t v89 = &v84[8 * (v67 >> 3)];
        BOOL v90 = &v84[72 * v83];
        if (v68 == v83)
        {
          if (v67 >= 1)
          {
            int64_t v91 = 0x8E38E38E38E38E39 * ((8 * (v67 >> 3)) >> 3);
            if (v91 >= -1) {
              uint64_t v92 = v91 + 1;
            }
            else {
              uint64_t v92 = v91 + 2;
            }
            v89 -= 72 * (v92 >> 1);
            goto LABEL_79;
          }
          unint64_t v123 = v59;
          uint64_t v110 = v60;
          unint64_t v127 = a8.n128_u64[0];
          unint64_t v131 = a7.n128_u64[0];
          if (v64 == v62) {
            unint64_t v111 = 1;
          }
          else {
            unint64_t v111 = 2 * v68;
          }
          uint64_t v112 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v111);
          unint64_t v89 = &v112[72 * (v111 >> 2)];
          BOOL v90 = &v112[72 * v113];
          unint64_t v85 = v124;
          if (v84)
          {
            uint64_t v114 = v84;
            uint64_t v115 = v90;
            operator delete(v114);
            BOOL v90 = v115;
          }
          a7.n128_u64[0] = v131;
          a8.n128_u64[0] = v127;
          uint64_t v60 = v110;
          unint64_t v59 = v123;
        }
        else
        {
LABEL_79:
          unint64_t v85 = v124;
        }
        a4.n128_u64[0] = v58;
        a4.n128_u64[1] = v59;
        a8.n128_f64[1] = v133;
        a7.n128_u64[1] = v135.n128_u64[0];
        uint64_t v93 = *v65;
        *(__n128 *)unint64_t v89 = a4;
        *((void *)v89 + 2) = v60;
        *(__n128 *)(v89 + 24) = a8;
        *(__n128 *)(v89 + 40) = a7;
        *((void *)v89 + 7) = v93;
        *((void *)v89 + 8) = v66;
        unint64_t v94 = (char *)a1[4];
        unint64_t v95 = v89;
        if (v94 != v64)
        {
          uint64_t v96 = v64;
          uint64_t v97 = v89;
          do
          {
            *(_OWORD *)(v97 - 72) = *(_OWORD *)(v96 - 72);
            a4 = *(__n128 *)(v96 - 56);
            long long v98 = *(_OWORD *)(v96 - 40);
            long long v99 = *(_OWORD *)(v96 - 24);
            unint64_t v95 = v97 - 72;
            *((void *)v97 - 1) = *((void *)v96 - 1);
            *(_OWORD *)(v97 - 24) = v99;
            *(_OWORD *)(v97 - 40) = v98;
            *(__n128 *)(v97 - 56) = a4;
            v96 -= 72;
            v97 -= 72;
          }
          while (v96 != v94);
        }
        uint64_t v100 = v89 + 72;
        unint64_t v101 = (unsigned char *)a1[5];
        uint64_t v102 = v101 - v64;
        if (v101 != v64)
        {
          uint64_t v103 = v90;
          memmove(v100, v64, v101 - v64);
          BOOL v90 = v103;
        }
        uint64_t v104 = (void *)a1[4];
        a1[4] = v95;
        a1[5] = &v100[v102];
        a1[6] = v90;
        if (v104) {
          operator delete(v104);
        }
LABEL_87:
        unint64_t v9 = v85 + 1;
        if (a3)
        {
          CGPDFObjectRef v105 = v116;
          while (1)
          {
            uint64_t v106 = *v105;
            CGFloat v107 = v105;
            if (!*v105) {
              break;
            }
            while (1)
            {
              CGPDFObjectRef v105 = (uint64_t **)v106;
              unint64_t v108 = v106[4];
              if (v9 < v108) {
                break;
              }
              if (v108 > v85) {
                goto LABEL_95;
              }
              uint64_t v106 = v105[1];
              if (!v106)
              {
                CGFloat v107 = v105 + 1;
                goto LABEL_94;
              }
            }
          }
LABEL_94:
          CFTypeRef v109 = (uint64_t *)operator new(0x28uLL);
          v109[4] = v9;
          std::__tree<unsigned long>::__insert_node_at(a3, (uint64_t)v105, v107, v109);
        }
LABEL_95:
        ++v119;
        uint64_t v12 = a1[4];
        if (0x8E38E38E38E38E39 * ((a1[5] - v12) >> 3) <= v9)
        {
LABEL_105:
          __break(1u);
          goto LABEL_106;
        }
      }
LABEL_103:
      unint64_t v9 = v124 + 1;
    }
    while (v124 + 1 < v119);
  }
}

void sub_184EFE780(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

id PageLayout::getOrderedLayout(PageLayout *this)
{
  uint64_t v1 = (void *)*((void *)this + 40);
  if (v1)
  {
    id v2 = v1;
  }
  else
  {
    CGRect BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(void *)this, kCGPDFCropBox);
    v8[0] = vmulq_n_f64((float64x2_t)xmmword_1850CD830, BoxRect.size.width);
    v8[1] = vmulq_n_f64((float64x2_t)xmmword_1850CD8C0, -BoxRect.size.height);
    CGFloat x = BoxRect.origin.x;
    double v10 = BoxRect.origin.y + BoxRect.size.height;
    uint64_t v4 = [[PDFCTLDDelegateForLines alloc] initWithPageLayout:this quadToPageTransform:v8];
    unint64_t v5 = PageLayout::createAtomicElements(this, &v7);
    PageLayout::getOrderedLayout((uint64_t)this, v5, v4, v7.origin.x, v7.origin.y, v7.size.width, v7.size.height);
    id v2 = (id)objc_claimAutoreleasedReturnValue();
  }

  return v2;
}

void sub_184EFE8A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<PageLayoutFactory::TextChunk>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  id v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 232;
        std::__destroy_at[abi:fe180100]<PageLayoutFactory::TextChunk,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::__unordered_map_hasher<applesauce::CF::ObjectRef<CGFont *>,std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::hash<applesauce::CF::ObjectRef<CGFont *>>,std::equal_to<applesauce::CF::ObjectRef<CGFont *>>,true>,std::__unordered_map_equal<applesauce::CF::ObjectRef<CGFont *>,std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>,std::equal_to<applesauce::CF::ObjectRef<CGFont *>>,std::hash<applesauce::CF::ObjectRef<CGFont *>>,true>,std::allocator<std::__hash_value_type<applesauce::CF::ObjectRef<CGFont *>,double>>>::~__hash_table(uint64_t a1)
{
  id v2 = *(const void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (const void **)*v2;
      std::__destroy_at[abi:fe180100]<std::pair<applesauce::CF::ObjectRef<CGFont *> const,double>,0>(v2[2]);
      operator delete(v2);
      id v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::~__hash_table(uint64_t a1)
{
  id v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (id *)*v2;

      operator delete(v2);
      id v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<std::pair<std::string,unsigned int>>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  id v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0) {
          operator delete(*(v4 - 4));
        }
        v4 -= 4;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<PageLayout::CharacterStyle>::__destroy_vector::operator()[abi:fe180100](void ***a1)
{
  uint64_t v1 = *a1;
  id v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 3;
        std::__destroy_at[abi:fe180100]<PageLayout::CharacterStyle,0>(*(v4 - 1));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

id PageLayout::createAtomicElements(PageLayout *this, CGRect *a2)
{
  uint64_t v4 = objc_opt_new();
  CGRect BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(void *)this, kCGPDFCropBox);
  CGFloat y = BoxRect.origin.y;
  double height = BoxRect.size.height;
  memset(&v92, 0, sizeof(v92));
  double width = BoxRect.size.width;
  *(float64x2_t *)&v91.double a = vmulq_n_f64((float64x2_t)xmmword_1850CD830, BoxRect.size.width);
  *(float64x2_t *)&v91.double c = vmulq_n_f64((float64x2_t)xmmword_1850CD8C0, -BoxRect.size.height);
  CGFloat x = BoxRect.origin.x;
  v91.tCGFloat x = BoxRect.origin.x;
  v91.tCGFloat y = BoxRect.origin.y + BoxRect.size.height;
  CGAffineTransformInvert(&v92, &v91);
  uint64_t v83 = 0;
  uint64_t v84 = &v83;
  uint64_t v85 = 0x5012000000;
  uint64_t v86 = __Block_byref_object_copy__92;
  unint64_t v87 = __Block_byref_object_dispose__93;
  uint64_t v88 = "";
  long long v89 = 0u;
  long long v90 = 0u;
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = *((void *)this + 5);
  if (v5 != v6)
  {
    double d = v92.d;
    double c = v92.c;
    double b = v92.b;
    double a = v92.a;
    double v56 = v92.d * 0.0 + v92.b * 0.0 + v92.ty;
    double v57 = v92.tx + v92.c * 0.0 + v92.a * 0.0;
    do
    {
      $5CFEE62CA76FAE445C6F9DBCEE669C70 v81 = *($5CFEE62CA76FAE445C6F9DBCEE669C70 *)v5;
      unint64_t v82 = *(void *)(v5 + 16);
      double v8 = *(double *)(v5 + 24);
      CGFloat v7 = *(double *)(v5 + 32);
      double v10 = *(double *)(v5 + 40);
      double v9 = *(double *)(v5 + 48);
      double v11 = *(double *)(v5 + 56);
      unint64_t v12 = *(void *)(v5 + 64);
      CGFloat v60 = v9;
      CGFloat v61 = v7;
      double v59 = v11;
      if (v11 == 0.0)
      {
        CGAffineTransform v79 = v92;
        v100.origin.CGFloat x = v8;
        v100.origin.CGFloat y = v7;
        v100.size.double width = v10;
        v100.size.double height = v9;
        CGRect v101 = CGRectApplyAffineTransform(v100, &v79);
        double v17 = v101.origin.x;
        double v18 = v101.origin.y;
        double v19 = v101.size.width;
        double v20 = v101.size.height;
        unint64_t v21 = v84;
        *(CGRect *)(v21 + 6) = CGRectUnion(*(CGRect *)(v84 + 6), v101);
        float v22 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", v17, v18, v19, v20, width, height);
      }
      else
      {
        __double2 v13 = __sincos_stret(v11);
        BOOL v14 = v9 < 0.0 || v10 < 0.0;
        double v58 = v8;
        CGFloat v15 = v7;
        double v16 = v9;
        if (v14)
        {
          v95.origin.CGFloat x = v8;
          v95.origin.CGFloat y = v7;
          v95.size.double width = v10;
          v95.size.double height = v9;
          *(void *)&double v58 = (unint64_t)CGRectStandardize(v95);
          v96.origin.CGFloat x = v8;
          v96.origin.CGFloat y = v7;
          v96.size.double width = v10;
          v96.size.double height = v9;
          *(CGRect *)(&v15 - 1) = CGRectStandardize(v96);
        }
        double v54 = v16;
        double v55 = v15;
        if (v14)
        {
          v97.origin.CGFloat x = v8;
          v97.origin.CGFloat y = v7;
          v97.size.double width = v10;
          v97.size.double height = v9;
          CGRect v98 = CGRectStandardize(v97);
          double v53 = v98.origin.x + v98.size.width;
          v98.origin.CGFloat x = v8;
          v98.origin.CGFloat y = v7;
          v98.size.double width = v10;
          v98.size.double height = v9;
          CGRect v99 = CGRectStandardize(v98);
          double v51 = v99.size.height;
          double v52 = v99.origin.y;
        }
        else
        {
          double v52 = v7;
          double v53 = v8 + v10;
          double v51 = v9;
        }
        if (v14)
        {
          v102.origin.CGFloat x = v8;
          v102.origin.CGFloat y = v7;
          v102.size.double width = v10;
          v102.size.double height = v9;
          CGRect v103 = CGRectStandardize(v102);
          double v50 = v103.origin.x + v103.size.width;
          v103.origin.CGFloat x = v8;
          v103.origin.CGFloat y = v7;
          v103.size.double width = v10;
          v103.size.double height = v9;
          CGRect v104 = CGRectStandardize(v103);
          double v49 = v104.origin.y;
        }
        else
        {
          double v49 = v7;
          double v50 = v8 + v10;
        }
        double v23 = v8;
        double v24 = v7;
        if (v14)
        {
          v105.origin.CGFloat x = v8;
          v105.origin.CGFloat y = v7;
          v105.size.double width = v10;
          v105.size.double height = v9;
          *(void *)&double v23 = (unint64_t)CGRectStandardize(v105);
          v106.origin.CGFloat x = v8;
          v106.origin.CGFloat y = v7;
          v106.size.double width = v10;
          v106.size.double height = v9;
          CGRect v107 = CGRectStandardize(v106);
          double v24 = v107.origin.y;
        }
        CGFloat v25 = v10;
        CGFloat v26 = v13.__sinval * c + v13.__cosval * a;
        CGFloat v27 = v13.__sinval * d + v13.__cosval * b;
        CGFloat v28 = v13.__cosval * c - v13.__sinval * a;
        CGFloat v29 = v13.__cosval * d - v13.__sinval * b;
        float v22 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedTopLeft:topRight:bottomRight:bottomLeft:size:", v57 + (v55 + v54) * v28 + v26 * v58, v56 + (v55 + v54) * v29 + v27 * v58, v57 + (v52 + v51) * v28 + v26 * v53, v56 + (v52 + v51) * v29 + v27 * v53, v57 + v49 * v28 + v26 * v50, v56 + v49 * v29 + v27 * v50, v57 + v24 * v28 + v26 * v23, v56 + v24 * v29 + v27 * v23, *(void *)&width, *(void *)&height);
        v80.double a = v26;
        v80.double b = v27;
        v80.double c = v28;
        v80.double d = v29;
        v80.tCGFloat x = v57;
        v80.tCGFloat y = v56;
        unint64_t v30 = v84;
        CGFloat v31 = *((double *)v84 + 6);
        CGFloat v32 = *((double *)v84 + 7);
        CGFloat v33 = *((double *)v84 + 8);
        CGFloat v34 = *((double *)v84 + 9);
        v108.origin.CGFloat x = v8;
        v108.size.double height = v60;
        v108.origin.CGFloat y = v61;
        double v10 = v25;
        v108.size.double width = v25;
        CGRect v110 = CGRectApplyAffineTransform(v108, &v80);
        v109.origin.CGFloat x = v31;
        v109.origin.CGFloat y = v32;
        v109.size.double width = v33;
        v109.size.double height = v34;
        *(CGRect *)(v30 + 6) = CGRectUnion(v109, v110);
      }
      double v35 = [PDFTextLineElement alloc];
      $5CFEE62CA76FAE445C6F9DBCEE669C70 v71 = v81;
      unint64_t v72 = v82;
      double v73 = v8;
      CGFloat v74 = v61;
      double v75 = v10;
      CGFloat v76 = v60;
      double v77 = v59;
      unint64_t v78 = v12;
      double v36 = [(PDFTextLineElement *)v35 initWithTextLine:&v71 boundingBox:v22];
      v70.textuint64_t Range = v81;
      v70.uniCharStart = v82;
      v70.bbox.origin.CGFloat x = v8;
      v70.bbox.origin.CGFloat y = v61;
      v70.bbox.size.double width = v10;
      v70.bbox.size.double height = v60;
      v70.rotation = v59;
      v70.identifier = v12;
      PageLayout::addCTLDMapping(this, &v70, v36);
      [v4 addObject:v36];

      v5 += 72;
    }
    while (v5 != v6);
  }
  uint64_t v37 = *(void *)this;
  v62[0] = MEMORY[0x1E4F143A8];
  v62[1] = 3221225472;
  v62[2] = ___ZN10PageLayout20createAtomicElementsEP6CGRect_block_invoke;
  v62[3] = &unk_1E52C8288;
  CGAffineTransform v65 = v92;
  unint64_t v64 = &v83;
  CGFloat v66 = x;
  CGFloat v67 = y;
  double v68 = width;
  double v69 = height;
  id v38 = v4;
  id v63 = v38;
  CGPDFPageEnumerateAnnotations(v37, (uint64_t)v62);
  if (a2)
  {
    CGSize v39 = (CGSize)*((_OWORD *)v84 + 4);
    a2->origin = (CGPoint)*((_OWORD *)v84 + 3);
    a2->std::string::size_type size = v39;
  }

  _Block_object_dispose(&v83, 8);

  return v38;
}

void sub_184EFF104(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x270], 8);

  _Unwind_Resume(a1);
}

id PageLayout::getOrderedLayout(uint64_t a1, void *a2, void *a3, double a4, double a5, double a6, double a7)
{
  uint64_t v463 = *MEMORY[0x1E4F143B8];
  id v334 = a2;
  id v335 = a3;
  CGRect BoxRect = CGPDFPageGetBoxRect((CGPDFPageRef)*(void *)a1, kCGPDFCropBox);
  double width = BoxRect.size.width;
  double height = BoxRect.size.height;
  unsigned int v339 = (void *)[objc_alloc((Class)getCRCTLDClass()) init];
  BOOL v336 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", a4, a5, a6, a7, width, height);
  CGFloat v15 = [[PDFCRGroupRegion alloc] initWithBoundingQuad:v336 layoutDirection:1 subregions:0 parent:0];
  double v16 = *(void **)(a1 + 320);
  *(void *)(a1 + 320) = v15;

  uint64_t v17 = objc_opt_new();
  double v18 = *(void **)(a1 + 328);
  *(void *)(a1 + 328) = v17;

  double v19 = (void *)[objc_alloc((Class)getCRCTLDConfigClass()) init];
  [v19 setAngleThresholdForRotationCorrection:0.0];
  [v19 setFlatMergeJumps:0];
  [v19 setMaxRegions:60];
  [v19 setMaxQueueCapacity:0xFFFFFFFFLL];
  [v19 setNumLookupElements:40];
  [v19 setNumPointsForSegmentsIntersection:9];
  LODWORD(v20) = 8.0;
  [v19 setMinSubRectangleSize:v20];
  LODWORD(v21) = 1035122882;
  [v19 setMinQuadrilateralRotation:v21];
  LODWORD(v22) = 1065185444;
  [v19 setMinWhitespaceHeightForReadingOrder:v22];
  LODWORD(v23) = 1063675494;
  [v19 setAllowedOverlap:v23];
  LODWORD(v24) = 1045220557;
  [v19 setMinWhitespaceWidth:v24];
  LODWORD(v25) = 1073993482;
  [v19 setMinWhitespaceHeight:v25];
  LODWORD(v26) = 1081333514;
  [v19 setQualityHeightFactor:v26];
  LODWORD(v27) = 1065688760;
  [v19 setQualityWidthFactor:v27];
  CGFloat v28 = [v339 groupAndOrderRegions:v334 config:v19 delegate:v335];

  long long v411 = 0u;
  long long v412 = 0u;
  long long v409 = 0u;
  long long v410 = 0u;
  obuint64_t j = v28;
  uint64_t v389 = [obj countByEnumeratingWithState:&v409 objects:v450 count:16];
  if (v389)
  {
    uint64_t v385 = *(void *)v410;
    do
    {
      for (uint64_t i = 0; i != v389; ++i)
      {
        if (*(void *)v410 != v385) {
          objc_enumerationMutation(obj);
        }
        id v397 = *(id *)(*((void *)&v409 + 1) + 8 * i);
        CGFloat v29 = [PDFCRGroupRegion alloc];
        unint64_t v30 = [v397 boundingQuad];
        CGFloat v31 = -[PDFCRGroupRegion initWithBoundingQuad:layoutDirection:subregions:parent:](v29, "initWithBoundingQuad:layoutDirection:subregions:parent:", v30, [v397 layoutDirection], 0, *(void *)(a1 + 320));

        [*(id *)(a1 + 320) addChild:v31];
        CGFloat v32 = [v397 subregions];
        CGFloat v33 = [v32 objectAtIndex:0];
        BOOL v34 = [v33 type] == 6;

        if (v34)
        {
          [(PDFCRGroupRegion *)v31 setType:7];
          long long v407 = 0u;
          long long v408 = 0u;
          long long v405 = 0u;
          long long v406 = 0u;
          id v35 = [v397 subregions];
          uint64_t v36 = [v35 countByEnumeratingWithState:&v405 objects:v449 count:16];
          if (v36)
          {
            uint64_t v37 = *(void *)v406;
            do
            {
              for (uint64_t j = 0; j != v36; ++j)
              {
                if (*(void *)v406 != v37) {
                  objc_enumerationMutation(v35);
                }
                uint64_t v39 = *(void *)(*((void *)&v405 + 1) + 8 * j);
                [(PDFCRGroupRegion *)v31 addChild:v39];
                [*(id *)(a1 + 328) addObject:v39];
              }
              uint64_t v36 = [v35 countByEnumeratingWithState:&v405 objects:v449 count:16];
            }
            while (v36);
          }
        }
        else
        {
          double v40 = [v397 subregions];
          double v41 = PageLayout::createFineCTLDConfig(v40);
          double v42 = [v339 groupAndOrderRegions:v40 config:v41 delegate:0];

          long long v403 = 0u;
          long long v404 = 0u;
          long long v401 = 0u;
          long long v402 = 0u;
          id v35 = v42;
          uint64_t v43 = [v35 countByEnumeratingWithState:&v401 objects:v448 count:16];
          if (v43)
          {
            uint64_t v44 = *(void *)v402;
            do
            {
              for (uint64_t k = 0; k != v43; ++k)
              {
                if (*(void *)v402 != v44) {
                  objc_enumerationMutation(v35);
                }
                double v46 = *(void **)(*((void *)&v401 + 1) + 8 * k);
                double v47 = [PDFCRGroupRegion alloc];
                uint64_t v48 = [v46 boundingQuad];
                uint64_t v49 = [v46 layoutDirection];
                double v50 = [v46 subregions];
                double v51 = [(PDFCRGroupRegion *)v47 initWithBoundingQuad:v48 layoutDirection:v49 subregions:v50 parent:v31];

                [(PDFCRGroupRegion *)v31 addChild:v51];
                [*(id *)(a1 + 328) addObject:v51];
              }
              uint64_t v43 = [v35 countByEnumeratingWithState:&v401 objects:v448 count:16];
            }
            while (v43);
          }
        }
      }
      uint64_t v389 = [obj countByEnumeratingWithState:&v409 objects:v450 count:16];
    }
    while (v389);
  }

  if (![*(id *)(a1 + 328) count]) {
    goto LABEL_362;
  }
  id v345 = objc_alloc_init(MEMORY[0x1E4F28E78]);
  __p[1] = 0;
  __p[0] = 0;
  *(void *)&long long v441 = 0;
  v436[1] = 0;
  v436[0] = 0;
  *(void *)&long long v437 = 0;
  CFIndex location = (id *)(a1 + 24);
  unint64_t v344 = [*(id *)(a1 + 24) length];
  unint64_t v337 = [*(id *)(a1 + 328) lastObject];
  long long v454 = 0u;
  long long v453 = 0u;
  long long v452 = 0u;
  long long v451 = 0u;
  id v332 = *(id *)(a1 + 328);
  uint64_t v52 = [v332 countByEnumeratingWithState:&v451 objects:v462 count:16];
  if (v52)
  {
    unint64_t v373 = 0;
    unint64_t v375 = 0;
    unint64_t v53 = 0;
    unint64_t v369 = 0;
    id v371 = 0;
    size_t v365 = 0;
    id v367 = 0;
    unint64_t v346 = 0;
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v331 = *(void *)v452;
    uint64_t v350 = (void *)(a1 + 336);
    int v351 = 0;
    long long v377 = 0u;
    long long v380 = 0u;
    long long v353 = 0u;
    long long v394 = 0u;
    long long v398 = 0u;
    long long v386 = 0u;
    *(_OWORD *)uint64_t v390 = 0u;
    *(_OWORD *)uint64_t v382 = 0u;
    while (1)
    {
      uint64_t v333 = 0;
      uint64_t v330 = v52;
      do
      {
        if (*(void *)v452 != v331) {
          objc_enumerationMutation(v332);
        }
        unsigned int v338 = *(void **)(*((void *)&v451 + 1) + 8 * v333);
        double v56 = [v338 subregions];
        long long v417 = 0u;
        long long v418 = 0u;
        long long v415 = 0u;
        long long v416 = 0u;
        id v342 = v56;
        uint64_t v57 = [v342 countByEnumeratingWithState:&v415 objects:v461 count:16];
        if (v57)
        {
          uint64_t v58 = v57;
          uint64_t v347 = *(void *)v416;
          do
          {
            uint64_t v360 = 0;
            uint64_t v348 = v58;
            do
            {
              if (*(void *)v416 != v347) {
                objc_enumerationMutation(v342);
              }
              id v358 = *(id *)(*((void *)&v415 + 1) + 8 * v360);
              if ([v358 type] == 1)
              {
                if (v358)
                {
                  [v358 textLine];
                  unint64_t v355 = (unint64_t)v459[0];
                  unsigned int v349 = v459[1];
                  unint64_t v59 = *(void *)&v460[0];
                  v459[0] = v351;
                  *(void *)&v460[0] = v55;
                  [v358 textLine];
                  unint64_t v362 = (unint64_t)v349 + v355;
                  unsigned int v60 = v460[3];
                  unsigned int v61 = v458;
                }
                else
                {
                  unsigned int v61 = 0;
                  unsigned int v60 = 0;
                  unint64_t v59 = 0;
                  unint64_t v362 = 0;
                  unsigned int v349 = 0;
                  unint64_t v355 = 0;
                  v459[1] = 0;
                  memset((char *)v460 + 8, 0, 48);
                  v459[0] = v351;
                  *(void *)&v460[0] = v55;
                  memset(v457, 0, sizeof(v457));
                  uint64_t v458 = 0;
                }
                BOOL v62 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v350, v61);
                if (v62)
                {
                  id v63 = v62;
                  id v64 = (id)v62[3];
                  CGAffineTransform v65 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v350, *((_DWORD *)v63 + 4));
                  if (v65)
                  {
                    CGFloat v66 = v65;
                    int8x8_t v67 = *(int8x8_t *)(a1 + 344);
                    unint64_t v68 = v65[1];
                    uint8x8_t v69 = (uint8x8_t)vcnt_s8(v67);
                    v69.i16[0] = vaddlv_u8(v69);
                    if (v69.u32[0] > 1uLL)
                    {
                      if (v68 >= *(void *)&v67) {
                        v68 %= *(void *)&v67;
                      }
                    }
                    else
                    {
                      v68 &= *(void *)&v67 - 1;
                    }
                    TextLine v70 = *(uint64_t **)(*v350 + 8 * v68);
                    do
                    {
                      $5CFEE62CA76FAE445C6F9DBCEE669C70 v71 = v70;
                      TextLine v70 = (uint64_t *)*v70;
                    }
                    while (v70 != v65);
                    if (v71 == (uint64_t *)(a1 + 352)) {
                      goto LABEL_59;
                    }
                    unint64_t v72 = v71[1];
                    if (v69.u32[0] > 1uLL)
                    {
                      if (v72 >= *(void *)&v67) {
                        v72 %= *(void *)&v67;
                      }
                    }
                    else
                    {
                      v72 &= *(void *)&v67 - 1;
                    }
                    if (v72 != v68)
                    {
LABEL_59:
                      if (!*v65) {
                        goto LABEL_60;
                      }
                      unint64_t v73 = *(void *)(*v65 + 8);
                      if (v69.u32[0] > 1uLL)
                      {
                        if (v73 >= *(void *)&v67) {
                          v73 %= *(void *)&v67;
                        }
                      }
                      else
                      {
                        v73 &= *(void *)&v67 - 1;
                      }
                      if (v73 != v68) {
LABEL_60:
                      }
                        *(void *)(*v350 + 8 * v68) = 0;
                    }
                    uint64_t v74 = *v65;
                    if (*v65)
                    {
                      unint64_t v75 = *(void *)(v74 + 8);
                      if (v69.u32[0] > 1uLL)
                      {
                        if (v75 >= *(void *)&v67) {
                          v75 %= *(void *)&v67;
                        }
                      }
                      else
                      {
                        v75 &= *(void *)&v67 - 1;
                      }
                      if (v75 != v68)
                      {
                        *(void *)(*v350 + 8 * v75) = v71;
                        uint64_t v74 = *v65;
                      }
                    }
                    *$5CFEE62CA76FAE445C6F9DBCEE669C70 v71 = v74;
                    uint64_t *v65 = 0;
                    --*(void *)(a1 + 360);

                    operator delete(v66);
                  }
                  LODWORD(v432) = v60;
                  id v76 = v64;
                  *((void *)&v432 + 1) = v76;
                  std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>((uint64_t)v350, v60, (uint64_t)&v432);
                }
                uint64_t v77 = *((void *)&v353 + 1);
                if (*((void *)&v353 + 1) >= v346)
                {
                  uint64_t v83 = (void *)v353;
                  unint64_t v84 = 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)&v353 + 1) - v353) >> 3) + 1;
                  if (v84 > 0x38E38E38E38E38ELL) {
                    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                  }
                  if (0x1C71C71C71C71C72 * ((uint64_t)(v346 - v353) >> 3) > v84) {
                    unint64_t v84 = 0x1C71C71C71C71C72 * ((uint64_t)(v346 - v353) >> 3);
                  }
                  if (0x8E38E38E38E38E39 * ((uint64_t)(v346 - v353) >> 3) >= 0x1C71C71C71C71C7) {
                    unint64_t v85 = 0x38E38E38E38E38ELL;
                  }
                  else {
                    unint64_t v85 = v84;
                  }
                  if (v85) {
                    unint64_t v85 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v85);
                  }
                  else {
                    uint64_t v86 = 0;
                  }
                  unint64_t v82 = v362;
                  unint64_t v87 = v85 + 8 * ((uint64_t)(*((void *)&v353 + 1) - v353) >> 3);
                  *(_OWORD *)unint64_t v87 = *(_OWORD *)v459;
                  long long v88 = v460[0];
                  long long v89 = v460[1];
                  long long v90 = v460[2];
                  *(void *)(v87 + 64) = *(void *)&v460[3];
                  *(_OWORD *)(v87 + 32) = v89;
                  *(_OWORD *)(v87 + 48) = v90;
                  *(_OWORD *)(v87 + 16) = v88;
                  if (*((void *)&v353 + 1) == (void)v353)
                  {
                    unint64_t v95 = v85 + 8 * ((uint64_t)(*((void *)&v353 + 1) - v353) >> 3);
                  }
                  else
                  {
                    unint64_t v91 = v85 + 8 * ((uint64_t)(*((void *)&v353 + 1) - v353) >> 3);
                    do
                    {
                      *(_OWORD *)(v91 - 72) = *(_OWORD *)(v77 - 72);
                      long long v92 = *(_OWORD *)(v77 - 56);
                      long long v93 = *(_OWORD *)(v77 - 40);
                      long long v94 = *(_OWORD *)(v77 - 24);
                      unint64_t v95 = v91 - 72;
                      *(void *)(v91 - 8) = *(void *)(v77 - 8);
                      *(_OWORD *)(v91 - 24) = v94;
                      *(_OWORD *)(v91 - 40) = v93;
                      *(_OWORD *)(v91 - 56) = v92;
                      v77 -= 72;
                      v91 -= 72;
                    }
                    while (v77 != (void)v353);
                  }
                  unint64_t v346 = v85 + 72 * v86;
                  uint64_t v81 = v87 + 72;
                  *(void *)&long long v353 = v95;
                  if (v83) {
                    operator delete(v83);
                  }
                }
                else
                {
                  **((_OWORD **)&v353 + 1) = *(_OWORD *)v459;
                  long long v78 = v460[0];
                  long long v79 = v460[1];
                  long long v80 = v460[2];
                  *(void *)(*((void *)&v353 + 1) + 64) = *(void *)&v460[3];
                  *(_OWORD *)(*((void *)&v353 + 1) + 32) = v79;
                  *(_OWORD *)(*((void *)&v353 + 1) + 48) = v80;
                  *(_OWORD *)(*((void *)&v353 + 1) + 16) = v78;
                  uint64_t v81 = *((void *)&v353 + 1) + 72;
                  unint64_t v82 = v362;
                }
                *(void *)&long long v96 = v353;
                *((void *)&v96 + 1) = v81;
                long long v353 = v96;
                v455[2] = v460[1];
                v455[3] = v460[2];
                uint64_t v456 = *(void *)&v460[3];
                v455[1] = v460[0];
                v455[0] = *(_OWORD *)v459;
                [v358 setTextLine:v455];
                unint64_t v97 = v355;
                if (v355 < v82)
                {
                  uint64_t v99 = *(void *)(a1 + 80);
                  uint64_t v98 = *(void *)(a1 + 88);
                  while (1)
                  {
                    if (v97 >= (v98 - v99) >> 3) {
                      goto LABEL_347;
                    }
                    CGRect v100 = (char *)v390[1];
                    if (v390[1] >= v371)
                    {
                      id v102 = v390[0];
                      uint64_t v103 = ((char *)v390[1] - (char *)v390[0]) >> 3;
                      unint64_t v104 = v103 + 1;
                      if ((unint64_t)(v103 + 1) >> 61) {
                        goto LABEL_348;
                      }
                      if ((int64_t)((uint64_t)v371 - (unint64_t)v390[0]) >> 2 > v104) {
                        unint64_t v104 = (int64_t)((uint64_t)v371 - (unint64_t)v390[0]) >> 2;
                      }
                      if ((unint64_t)v371 - (unint64_t)v390[0] >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v105 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v105 = v104;
                      }
                      if (v105) {
                        unint64_t v105 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v105);
                      }
                      else {
                        uint64_t v106 = 0;
                      }
                      CGRect v107 = (void *)(v105 + 8 * v103);
                      *CGRect v107 = *(void *)(v99 + 8 * v97);
                      uint64_t v101 = (uint64_t)(v107 + 1);
                      while (v100 != v390[0])
                      {
                        uint64_t v108 = *((void *)v100 - 1);
                        v100 -= 8;
                        *--CGRect v107 = v108;
                      }
                      id v371 = (id)(v105 + 8 * v106);
                      v390[0] = v107;
                      if (v102) {
                        operator delete(v102);
                      }
                    }
                    else
                    {
                      *(void *)v390[1] = *(void *)(v99 + 8 * v97);
                      uint64_t v101 = (uint64_t)v390[1] + 8;
                    }
                    *(id *)&long long v109 = v390[0];
                    *((void *)&v109 + 1) = v101;
                    *(_OWORD *)uint64_t v390 = v109;
                    uint64_t v110 = *(void *)(a1 + 104);
                    if (v97 >= (*(void *)(a1 + 112) - v110) >> 5) {
                      goto LABEL_346;
                    }
                    unint64_t v111 = (_OWORD *)(v110 + 32 * v97);
                    uint64_t v112 = *((void *)&v386 + 1);
                    if (*((void *)&v386 + 1) >= v369)
                    {
                      uint64_t v115 = (void *)v386;
                      uint64_t v116 = (uint64_t)(*((void *)&v386 + 1) - v386) >> 5;
                      unint64_t v117 = v116 + 1;
                      if ((unint64_t)(v116 + 1) >> 59) {
                        goto LABEL_349;
                      }
                      if ((uint64_t)(v369 - v386) >> 4 > v117) {
                        unint64_t v117 = (uint64_t)(v369 - v386) >> 4;
                      }
                      if (v369 - (unint64_t)v386 >= 0x7FFFFFFFFFFFFFE0) {
                        unint64_t v118 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v118 = v117;
                      }
                      if (v118) {
                        unint64_t v118 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v118);
                      }
                      else {
                        uint64_t v119 = 0;
                      }
                      long long v120 = v111[1];
                      uint64_t v121 = (_OWORD *)(v118 + 32 * v116);
                      _OWORD *v121 = *v111;
                      v121[1] = v120;
                      if (*((void *)&v386 + 1) == (void)v386)
                      {
                        unint64_t v124 = v118 + 32 * v116;
                      }
                      else
                      {
                        unint64_t v122 = v118 + 32 * v116;
                        do
                        {
                          long long v123 = *(_OWORD *)(v112 - 16);
                          unint64_t v124 = v122 - 32;
                          *(_OWORD *)(v122 - 32) = *(_OWORD *)(v112 - 32);
                          *(_OWORD *)(v122 - 16) = v123;
                          v112 -= 32;
                          v122 -= 32;
                        }
                        while (v112 != (void)v386);
                      }
                      unint64_t v369 = v118 + 32 * v119;
                      uint64_t v114 = (uint64_t)(v121 + 2);
                      *(void *)&long long v386 = v124;
                      if (v115) {
                        operator delete(v115);
                      }
                    }
                    else
                    {
                      long long v113 = v111[1];
                      **((_OWORD **)&v386 + 1) = *v111;
                      *(_OWORD *)(*((void *)&v386 + 1) + 16) = v113;
                      uint64_t v114 = *((void *)&v386 + 1) + 32;
                    }
                    *(void *)&long long v125 = v386;
                    *((void *)&v125 + 1) = v114;
                    long long v386 = v125;
                    uint64_t v126 = *(void *)(a1 + 128);
                    if (v97 >= (*(void *)(a1 + 136) - v126) >> 5) {
LABEL_346:
                    }
                      std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
                    unint64_t v127 = (_OWORD *)(v126 + 32 * v97);
                    uint64_t v128 = (char *)v382[1];
                    if (v382[1] >= v367)
                    {
                      id v131 = v382[0];
                      uint64_t v132 = ((char *)v382[1] - (char *)v382[0]) >> 5;
                      unint64_t v133 = v132 + 1;
                      if ((unint64_t)(v132 + 1) >> 59) {
LABEL_349:
                      }
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                      if ((int64_t)((uint64_t)v367 - (unint64_t)v382[0]) >> 4 > v133) {
                        unint64_t v133 = (int64_t)((uint64_t)v367 - (unint64_t)v382[0]) >> 4;
                      }
                      if ((unint64_t)v367 - (unint64_t)v382[0] >= 0x7FFFFFFFFFFFFFE0) {
                        unint64_t v134 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v134 = v133;
                      }
                      if (v134) {
                        unint64_t v134 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(v134);
                      }
                      else {
                        uint64_t v135 = 0;
                      }
                      long long v136 = v127[1];
                      CGRect v137 = (_OWORD *)(v134 + 32 * v132);
                      _OWORD *v137 = *v127;
                      v137[1] = v136;
                      if (v382[1] == v382[0])
                      {
                        CGRect v140 = (void *)(v134 + 32 * v132);
                      }
                      else
                      {
                        unint64_t v138 = v134 + 32 * v132;
                        do
                        {
                          long long v139 = *((_OWORD *)v128 - 1);
                          CGRect v140 = (void *)(v138 - 32);
                          *(_OWORD *)(v138 - 32) = *((_OWORD *)v128 - 2);
                          *(_OWORD *)(v138 - 16) = v139;
                          v128 -= 32;
                          v138 -= 32;
                        }
                        while (v128 != v382[0]);
                      }
                      id v367 = (id)(v134 + 32 * v135);
                      uint64_t v130 = (uint64_t)(v137 + 2);
                      v382[0] = v140;
                      if (v131) {
                        operator delete(v131);
                      }
                    }
                    else
                    {
                      long long v129 = v127[1];
                      *(_OWORD *)v382[1] = *v127;
                      *((_OWORD *)v382[1] + 1) = v129;
                      uint64_t v130 = (uint64_t)v382[1] + 32;
                    }
                    *(id *)&long long v141 = v382[0];
                    *((void *)&v141 + 1) = v130;
                    *(_OWORD *)uint64_t v382 = v141;
                    uint64_t v142 = *(void *)(a1 + 272);
                    if (v97 >= (*(void *)(a1 + 280) - v142) >> 3) {
LABEL_347:
                    }
                      std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
                    uint64_t v143 = *((void *)&v380 + 1);
                    if (*((void *)&v380 + 1) >= (unint64_t)v365)
                    {
                      uint64_t v145 = (void *)v380;
                      uint64_t v146 = (uint64_t)(*((void *)&v380 + 1) - v380) >> 3;
                      unint64_t v147 = v146 + 1;
                      if ((unint64_t)(v146 + 1) >> 61) {
                        goto LABEL_348;
                      }
                      if ((uint64_t)&v365[-v380] >> 2 > v147) {
                        unint64_t v147 = (uint64_t)&v365[-v380] >> 2;
                      }
                      if ((unint64_t)&v365[-v380] >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v148 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v148 = v147;
                      }
                      if (v148) {
                        unint64_t v148 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v148);
                      }
                      else {
                        uint64_t v149 = 0;
                      }
                      uint64_t v150 = (void *)(v148 + 8 * v146);
                      void *v150 = *(void *)(v142 + 8 * v97);
                      uint64_t v144 = (uint64_t)(v150 + 1);
                      while (v143 != (void)v380)
                      {
                        uint64_t v151 = *(void *)(v143 - 8);
                        v143 -= 8;
                        *--uint64_t v150 = v151;
                      }
                      size_t v365 = (char *)(v148 + 8 * v149);
                      *(void *)&long long v380 = v150;
                      if (v145) {
                        operator delete(v145);
                      }
                    }
                    else
                    {
                      **((void **)&v380 + 1) = *(void *)(v142 + 8 * v97);
                      uint64_t v144 = *((void *)&v380 + 1) + 8;
                    }
                    *(void *)&long long v152 = v380;
                    *((void *)&v152 + 1) = v144;
                    long long v380 = v152;
                    uint64_t v153 = *((void *)&v394 + 1);
                    if (*((void *)&v394 + 1) >= v373)
                    {
                      uint64_t v155 = (void *)v394;
                      uint64_t v156 = (uint64_t)(*((void *)&v394 + 1) - v394) >> 3;
                      unint64_t v157 = v156 + 1;
                      if ((unint64_t)(v156 + 1) >> 61) {
LABEL_348:
                      }
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                      if ((uint64_t)(v373 - v394) >> 2 > v157) {
                        unint64_t v157 = (uint64_t)(v373 - v394) >> 2;
                      }
                      if (v373 - (unint64_t)v394 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v158 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v158 = v157;
                      }
                      if (v158) {
                        unint64_t v158 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v158);
                      }
                      else {
                        uint64_t v159 = 0;
                      }
                      uint64_t v160 = (void *)(v158 + 8 * v156);
                      *uint64_t v160 = v54;
                      uint64_t v154 = (uint64_t)(v160 + 1);
                      while (v153 != (void)v394)
                      {
                        uint64_t v161 = *(void *)(v153 - 8);
                        v153 -= 8;
                        *--uint64_t v160 = v161;
                      }
                      unint64_t v373 = v158 + 8 * v159;
                      *(void *)&long long v394 = v160;
                      if (v155) {
                        operator delete(v155);
                      }
                    }
                    else
                    {
                      **((void **)&v394 + 1) = v54;
                      uint64_t v154 = *((void *)&v394 + 1) + 8;
                    }
                    *(void *)&long long v162 = v394;
                    *((void *)&v162 + 1) = v154;
                    long long v394 = v162;
                    uint64_t v99 = *(void *)(a1 + 80);
                    uint64_t v98 = *(void *)(a1 + 88);
                    if (v97 >= (v98 - v99) >> 3) {
                      goto LABEL_316;
                    }
                    if (*(void *)(v99 + 8 * v97)) {
                      break;
                    }
LABEL_201:
                    if (++v97 == v362) {
                      goto LABEL_202;
                    }
                  }
                  unint64_t v163 = 0;
                  while (1)
                  {
                    uint64_t v164 = *(void *)(a1 + 56);
                    if (v59 >= (*(void *)(a1 + 64) - v164) >> 1) {
                      std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
                    }
                    uint64_t v165 = *((void *)&v398 + 1);
                    if (*((void *)&v398 + 1) >= v53)
                    {
                      uint64_t v167 = (void *)v398;
                      uint64_t v168 = *((void *)&v398 + 1) - v398;
                      if ((uint64_t)(*((void *)&v398 + 1) - v398) <= -3) {
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                      }
                      unint64_t v169 = v53;
                      uint64_t v170 = v168 >> 1;
                      unint64_t v171 = v169 - v398;
                      if (v171 <= (v168 >> 1) + 1) {
                        unint64_t v172 = v170 + 1;
                      }
                      else {
                        unint64_t v172 = v171;
                      }
                      if (v171 >= 0x7FFFFFFFFFFFFFFELL) {
                        uint64_t v173 = 0x7FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        uint64_t v173 = v172;
                      }
                      if (v173) {
                        uint64_t v173 = (uint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<unsigned short>>(v173);
                      }
                      else {
                        uint64_t v174 = 0;
                      }
                      uint64_t v175 = (_WORD *)(v173 + 2 * v170);
                      *uint64_t v175 = *(_WORD *)(v164 + 2 * v59);
                      uint64_t v166 = (uint64_t)(v175 + 1);
                      while (v165 != (void)v398)
                      {
                        __int16 v176 = *(_WORD *)(v165 - 2);
                        v165 -= 2;
                        *--uint64_t v175 = v176;
                      }
                      unint64_t v53 = v173 + 2 * v174;
                      *(void *)&long long v398 = v175;
                      if (v167) {
                        operator delete(v167);
                      }
                    }
                    else
                    {
                      **((_WORD **)&v398 + 1) = *(_WORD *)(v164 + 2 * v59);
                      uint64_t v166 = *((void *)&v398 + 1) + 2;
                    }
                    *(void *)&long long v177 = v398;
                    *((void *)&v177 + 1) = v166;
                    long long v398 = v177;
                    uint64_t v99 = *(void *)(a1 + 80);
                    uint64_t v98 = *(void *)(a1 + 88);
                    if (v97 >= (v98 - v99) >> 3) {
                      break;
                    }
                    ++v59;
                    ++v54;
                    ++v163;
                    ++v55;
                    if (v163 >= *(void *)(v99 + 8 * v97)) {
                      goto LABEL_201;
                    }
                  }
LABEL_316:
                  std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
                }
LABEL_202:
                uint64_t v178 = *(void *)(a1 + 152);
                unint64_t v179 = (*(void *)(a1 + 160) - v178) >> 3;
                if (v179 <= v355 || v179 <= v362) {
                  std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
                }
                unint64_t v180 = *(void *)(v178 + 8 * v355);
                uint64_t v181 = *(void *)(v178 + 8 * v362);
                if (v344 < v181 - v180 || v180 > v344 - (v181 - v180))
                {
                  exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                  std::logic_error::logic_error(exception, "lineStringRange");
                  exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
                  __cxa_throw(exception, (struct type_info *)off_1E529EE70, MEMORY[0x1E4FBA1D0]);
                }
                id v363 = [*location substringWithRange:v180];
                uint64_t v183 = [v345 length];
                [v345 appendString:v363];
                uint64_t v343 = v183;
                uint64_t v356 = v181;
                if (v181 == v180)
                {
                  long long v184 = v377;
                }
                else
                {
                  uint64_t v185 = *(void *)(a1 + 200);
                  uint64_t v186 = (void *)(v185 + 8 * v181);
                  uint64_t v187 = (void *)(v185 + 8 * v180);
                  long long v184 = v377;
                  do
                  {
                    unsigned int v188 = (char *)*((void *)&v184 + 1);
                    unsigned int v378 = (void *)v184;
                    if (*((void *)&v184 + 1) >= v375)
                    {
                      uint64_t v190 = (char *)v184;
                      uint64_t v191 = (uint64_t)(*((void *)&v184 + 1) - v184) >> 3;
                      unint64_t v192 = v191 + 1;
                      if ((unint64_t)(v191 + 1) >> 61) {
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                      }
                      if ((uint64_t)(v375 - v184) >> 2 > v192) {
                        unint64_t v192 = (uint64_t)(v375 - v184) >> 2;
                      }
                      if (v375 - (unint64_t)v184 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v193 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v193 = v192;
                      }
                      if (v193) {
                        unint64_t v193 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v193);
                      }
                      else {
                        uint64_t v194 = 0;
                      }
                      uint64_t v195 = (void *)(v193 + 8 * v191);
                      *uint64_t v195 = *v187;
                      uint64_t v189 = (uint64_t)(v195 + 1);
                      while (v188 != v190)
                      {
                        uint64_t v196 = *((void *)v188 - 1);
                        v188 -= 8;
                        *--uint64_t v195 = v196;
                      }
                      unint64_t v375 = v193 + 8 * v194;
                      unsigned int v378 = v195;
                      if (v190) {
                        operator delete(v190);
                      }
                    }
                    else
                    {
                      **((void **)&v184 + 1) = *v187;
                      uint64_t v189 = *((void *)&v184 + 1) + 8;
                    }
                    *(void *)&long long v184 = v378;
                    *((void *)&v184 + 1) = v189;
                    ++v187;
                  }
                  while (v187 != v186);
                }
                long long v377 = v184;
                std::__unwrap_and_dispatch[abi:fe180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>((void *)(*(void *)(a1 + 224) + 8 * v180), (void *)(*(void *)(a1 + 224) + 8 * v356), (uint64_t)__p);
                if (*(unsigned char *)(a1 + 8))
                {
                  uint64_t v197 = *(void *)(a1 + 296);
                  unsigned int v414 = v436;
                  if (v356 != v180)
                  {
                    vImagePixelCount v198 = (void *)(v197 + 8 * v180);
                    unint64_t v199 = v343 - v180;
                    uint64_t v200 = 8 * v356 - 8 * v180;
                    do
                    {
                      unint64_t v413 = v199 + *v198;
                      std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:fe180100]((uint64_t *)&v414, &v413);
                      ++v198;
                      v200 -= 8;
                    }
                    while (v200);
                  }
                }
                if ([v363 length]) {
                  BOOL v201 = objc_msgSend(v363, "characterAtIndex:", objc_msgSend(v363, "length") - 1) == 10;
                }
                else {
                  BOOL v201 = 0;
                }
                if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3) >= 2
                  && [v345 length]
                  && v356 == v344
                  && v338 != v337)
                {
                  [v345 appendString:@"\n"];
                  uint64_t v203 = *((void *)&v377 + 1);
                  uint64_t v202 = (void *)v377;
                  if ((void)v377 == *((void *)&v377 + 1)) {
                    goto LABEL_471;
                  }
                  if (*((void *)&v377 + 1) >= v375)
                  {
                    uint64_t v205 = (uint64_t)(*((void *)&v377 + 1) - v377) >> 3;
                    unint64_t v206 = v205 + 1;
                    if ((unint64_t)(v205 + 1) >> 61) {
                      goto LABEL_354;
                    }
                    if ((uint64_t)(v375 - v377) >> 2 > v206) {
                      unint64_t v206 = (uint64_t)(v375 - v377) >> 2;
                    }
                    if (v375 - (unint64_t)v377 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v207 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v207 = v206;
                    }
                    if (v207) {
                      unint64_t v207 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v207);
                    }
                    else {
                      uint64_t v208 = 0;
                    }
                    unsigned int v209 = (void *)(v207 + 8 * v205);
                    unint64_t v375 = v207 + 8 * v208;
                    *unsigned int v209 = *(void *)(*((void *)&v377 + 1) - 8);
                    uint64_t v204 = (uint64_t)(v209 + 1);
                    do
                    {
                      uint64_t v210 = *(void *)(v203 - 8);
                      v203 -= 8;
                      *--unsigned int v209 = v210;
                    }
                    while (v203 != (void)v377);
                    *(void *)&long long v377 = v209;
                    if (v202) {
                      operator delete(v202);
                    }
                  }
                  else
                  {
                    **((void **)&v377 + 1) = *(void *)(*((void *)&v377 + 1) - 8);
                    uint64_t v204 = *((void *)&v377 + 1) + 8;
                  }
                  int v211 = (char *)__p[0];
                  uint64_t v212 = __p[1];
                  if (__p[0] == __p[1]) {
                    goto LABEL_471;
                  }
                  *(void *)&long long v213 = v377;
                  *((void *)&v213 + 1) = v204;
                  long long v377 = v213;
                  if (__p[1] >= (void *)v441)
                  {
                    int64_t v215 = ((char *)__p[1] - (char *)__p[0]) >> 3;
                    unint64_t v216 = v215 + 1;
                    if ((unint64_t)(v215 + 1) >> 61) {
                      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                    }
                    uint64_t v217 = v441 - (unint64_t)__p[0];
                    if ((uint64_t)(v441 - (unint64_t)__p[0]) >> 2 > v216) {
                      unint64_t v216 = v217 >> 2;
                    }
                    BOOL v218 = (unint64_t)v217 >= 0x7FFFFFFFFFFFFFF8;
                    unint64_t v219 = 0x1FFFFFFFFFFFFFFFLL;
                    if (!v218) {
                      unint64_t v219 = v216;
                    }
                    if (v219)
                    {
                      unint64_t v219 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v219);
                      uint64_t v221 = (char *)__p[1];
                      int v211 = (char *)__p[0];
                    }
                    else
                    {
                      uint64_t v220 = 0;
                      uint64_t v221 = (char *)__p[1];
                    }
                    uint64_t v222 = (void *)(v219 + 8 * v215);
                    *uint64_t v222 = *(v212 - 1);
                    unsigned int v214 = v222 + 1;
                    while (v221 != v211)
                    {
                      uint64_t v223 = *((void *)v221 - 1);
                      v221 -= 8;
                      *--uint64_t v222 = v223;
                    }
                    __p[0] = v222;
                    __p[1] = v214;
                    *(void *)&long long v441 = v219 + 8 * v220;
                    if (v211) {
                      operator delete(v211);
                    }
                  }
                  else
                  {
                    *(void *)__p[1] = *((void *)__p[1] - 1);
                    unsigned int v214 = v212 + 1;
                  }
                  __p[1] = v214;
                  if (*(unsigned char *)(a1 + 8))
                  {
                    uint64_t v224 = (char *)v436[0];
                    uint64_t v225 = v436[1];
                    if (v436[0] == v436[1]) {
                      goto LABEL_471;
                    }
                    if (v436[1] >= (void *)v437)
                    {
                      int64_t v227 = ((char *)v436[1] - (char *)v436[0]) >> 3;
                      unint64_t v228 = v227 + 1;
                      if ((unint64_t)(v227 + 1) >> 61) {
LABEL_354:
                      }
                        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                      uint64_t v229 = v437 - (unint64_t)v436[0];
                      if ((uint64_t)(v437 - (unint64_t)v436[0]) >> 2 > v228) {
                        unint64_t v228 = v229 >> 2;
                      }
                      BOOL v218 = (unint64_t)v229 >= 0x7FFFFFFFFFFFFFF8;
                      unint64_t v230 = 0x1FFFFFFFFFFFFFFFLL;
                      if (!v218) {
                        unint64_t v230 = v228;
                      }
                      if (v230)
                      {
                        unint64_t v230 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v230);
                        int v232 = (char *)v436[1];
                        uint64_t v224 = (char *)v436[0];
                      }
                      else
                      {
                        uint64_t v231 = 0;
                        int v232 = (char *)v436[1];
                      }
                      vImagePixelCount v233 = (void *)(v230 + 8 * v227);
                      *vImagePixelCount v233 = *(v225 - 1);
                      uint64_t v226 = v233 + 1;
                      while (v232 != v224)
                      {
                        uint64_t v234 = *((void *)v232 - 1);
                        v232 -= 8;
                        *--vImagePixelCount v233 = v234;
                      }
                      v436[0] = v233;
                      v436[1] = v226;
                      *(void *)&long long v437 = v230 + 8 * v231;
                      if (v224) {
                        operator delete(v224);
                      }
                    }
                    else
                    {
                      *(void *)v436[1] = *((void *)v436[1] - 1);
                      uint64_t v226 = v225 + 1;
                    }
                    v436[1] = v226;
                  }
LABEL_291:
                  ++v54;
                }
                else if (v201)
                {
                  goto LABEL_291;
                }

                int v351 = &v351[(void)v349];
              }

              ++v360;
            }
            while (v360 != v348);
            uint64_t v58 = [v342 countByEnumeratingWithState:&v415 objects:v461 count:16];
          }
          while (v58);
        }

        ++v333;
      }
      while (v333 != v330);
      uint64_t v52 = [v332 countByEnumeratingWithState:&v451 objects:v462 count:16];
      if (!v52) {
        goto LABEL_299;
      }
    }
  }
  unint64_t v373 = 0;
  unint64_t v375 = 0;
  unint64_t v53 = 0;
  unint64_t v369 = 0;
  id v371 = 0;
  size_t v365 = 0;
  id v367 = 0;
  unint64_t v346 = 0;
  long long v377 = 0u;
  long long v380 = 0u;
  long long v353 = 0u;
  long long v394 = 0u;
  long long v398 = 0u;
  long long v386 = 0u;
  *(_OWORD *)uint64_t v390 = 0u;
  *(_OWORD *)uint64_t v382 = 0u;
LABEL_299:

  uint64_t v235 = [v345 length];
  if ([v345 length])
  {
    uint64_t v236 = v235 - 1;
    if ([v345 characterAtIndex:v236] == 10)
    {
      objc_msgSend(v345, "deleteCharactersInRange:", v236, 1);
      if ((void)v377 == *((void *)&v377 + 1) || __p[0] == __p[1]) {
        goto LABEL_471;
      }
      *(void *)&long long v237 = v377;
      *((void *)&v237 + 1) = *((void *)&v377 + 1) - 8;
      long long v377 = v237;
      __p[1] = (char *)__p[1] - 8;
      if (*(unsigned char *)(a1 + 8))
      {
        if (v436[0] != v436[1])
        {
          v436[1] = (char *)v436[1] - 8;
          goto LABEL_306;
        }
LABEL_471:
        __break(1u);
      }
    }
  }
LABEL_306:
  uint64_t v238 = [v345 length];
  uint64_t v239 = v238;
  uint64_t v240 = *((void *)&v394 + 1);
  if (*((void *)&v394 + 1) >= v373)
  {
    unint64_t v242 = (void *)v394;
    uint64_t v243 = (uint64_t)(*((void *)&v394 + 1) - v394) >> 3;
    unint64_t v244 = v243 + 1;
    if ((unint64_t)(v243 + 1) >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    if ((uint64_t)(v373 - v394) >> 2 > v244) {
      unint64_t v244 = (uint64_t)(v373 - v394) >> 2;
    }
    if (v373 - (unint64_t)v394 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v245 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v245 = v244;
    }
    if (v245) {
      unint64_t v245 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v245);
    }
    else {
      uint64_t v246 = 0;
    }
    unsigned int v247 = (uint64_t *)(v245 + 8 * v243);
    unint64_t v373 = v245 + 8 * v246;
    *unsigned int v247 = v239;
    uint64_t v241 = (uint64_t)(v247 + 1);
    while (v240 != (void)v394)
    {
      uint64_t v248 = *(void *)(v240 - 8);
      v240 -= 8;
      *--unsigned int v247 = v248;
    }
    *(void *)&long long v394 = v247;
    if (v242) {
      operator delete(v242);
    }
  }
  else
  {
    **((void **)&v394 + 1) = v238;
    uint64_t v241 = *((void *)&v394 + 1) + 8;
  }
  int v249 = *(void **)(a1 + 56);
  if (v249)
  {
    *(void *)(a1 + 64) = v249;
    operator delete(v249);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
  unsigned int v250 = *(void **)(a1 + 80);
  *(_OWORD *)(a1 + 56) = v398;
  *(void *)(a1 + 72) = v53;
  if (v250)
  {
    *(void *)(a1 + 88) = v250;
    operator delete(v250);
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 96) = 0;
  }
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v390;
  *(void *)(a1 + 96) = v371;
  objc_storeStrong(location, v345);
  int v251 = *(void **)(a1 + 128);
  if (v251)
  {
    *(void *)(a1 + 136) = v251;
    operator delete(v251);
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v252 = *(void **)(a1 + 104);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)v382;
  *(void *)(a1 + 144) = v367;
  if (v252)
  {
    *(void *)(a1 + 112) = v252;
    operator delete(v252);
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 120) = 0;
  }
  *(_OWORD *)(a1 + 104) = v386;
  *(void *)(a1 + 120) = v369;
  uint64_t v253 = *(void **)(a1 + 272);
  if (v253)
  {
    *(void *)(a1 + 280) = v253;
    operator delete(v253);
    *(void *)(a1 + 272) = 0;
    *(void *)(a1 + 280) = 0;
    *(void *)(a1 + 288) = 0;
  }
  *(void *)&long long v254 = v394;
  *((void *)&v254 + 1) = v241;
  long long v395 = v254;
  uint64_t v255 = *(void **)(a1 + 152);
  *(_OWORD *)(a1 + 272) = v380;
  *(void *)(a1 + 288) = v365;
  if (v255)
  {
    *(void *)(a1 + 160) = v255;
    operator delete(v255);
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v256 = *(void **)(a1 + 200);
  *(_OWORD *)(a1 + 152) = v395;
  *(void *)(a1 + 168) = v373;
  if (v256)
  {
    *(void *)(a1 + 208) = v256;
    operator delete(v256);
    *(void *)(a1 + 200) = 0;
    *(void *)(a1 + 208) = 0;
    *(void *)(a1 + 216) = 0;
  }
  uint64_t v257 = *(void **)(a1 + 224);
  *(_OWORD *)(a1 + 200) = v377;
  *(void *)(a1 + 216) = v375;
  if (v257)
  {
    *(void *)(a1 + 232) = v257;
    operator delete(v257);
    *(void *)(a1 + 224) = 0;
    *(void *)(a1 + 232) = 0;
    *(void *)(a1 + 240) = 0;
  }
  *(_OWORD *)(a1 + 224) = *(_OWORD *)__p;
  *(void *)(a1 + 240) = v441;
  *(void *)&long long v441 = 0;
  __p[1] = 0;
  __p[0] = 0;
  uint64_t v258 = (void *)(a1 + 296);
  int v259 = *(void **)(a1 + 296);
  if (v259)
  {
    *(void *)(a1 + 304) = v259;
    operator delete(v259);
    *uint64_t v258 = 0;
    *(void *)(a1 + 304) = 0;
    *(void *)(a1 + 312) = 0;
  }
  *(_OWORD *)uint64_t v258 = *(_OWORD *)v436;
  vImagePixelCount v260 = *(void **)(a1 + 32);
  *(void *)(a1 + 312) = v437;
  *(void *)&long long v437 = 0;
  v436[1] = 0;
  v436[0] = 0;
  if (v260)
  {
    *(void *)(a1 + 40) = v260;
    operator delete(v260);
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
  *(_OWORD *)(a1 + 32) = v353;
  *(void *)(a1 + 48) = v346;

  if (v436[0])
  {
    v436[1] = v436[0];
    operator delete(v436[0]);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

LABEL_362:
  if (*(unsigned char *)(a1 + 8)) {
    goto LABEL_363;
  }
  uint64_t v264 = [*(id *)(a1 + 24) length];
  uint64_t v381 = objc_opt_new();
  unsigned int v396 = objc_opt_new();
  long long v443 = 0u;
  long long v442 = 0u;
  long long v441 = 0u;
  *(_OWORD *)__p = 0u;
  id v383 = *(id *)(a1 + 328);
  uint64_t v391 = [v383 countByEnumeratingWithState:__p objects:v462 count:16];
  if (!v391) {
    goto LABEL_407;
  }
  uint64_t v387 = *(void *)v441;
  do
  {
    for (uint64_t m = 0; m != v391; ++m)
    {
      if (*(void *)v441 != v387) {
        objc_enumerationMutation(v383);
      }
      id v265 = *((id *)__p[1] + m);
      if ([v265 type] == 6)
      {
        if (![v396 count]) {
          goto LABEL_405;
        }
        [v381 addObject:v396];
        unint64_t v266 = v396;
        unsigned int v396 = objc_opt_new();
      }
      else
      {
        long long v438 = 0u;
        long long v439 = 0u;
        *(_OWORD *)unsigned int v436 = 0u;
        long long v437 = 0u;
        unint64_t v266 = [v265 subregions];
        uint64_t v267 = [v266 countByEnumeratingWithState:v436 objects:v461 count:16];
        if (v267)
        {
          uint64_t v268 = *(void *)v437;
          do
          {
            for (uint64_t n = 0; n != v267; ++n)
            {
              if (*(void *)v437 != v268) {
                objc_enumerationMutation(v266);
              }
              uint64_t v270 = (void *)*((void *)v436[1] + n);
              if ([v270 type] == 1)
              {
                [v270 setParent:v265];
                v457[0] = 0uLL;
                if (v270)
                {
                  [v270 textLine];
                }
                else
                {
                  memset(v460, 0, 56);
                  *(_OWORD *)uint64_t v459 = 0u;
                }
                v457[0] = *(_OWORD *)v459;
                v459[1] = 0;
                v459[0] = 0;
                *(void *)&v460[0] = 0;
                *(void *)&v455[0] = v457;
                *((void *)&v455[0] + 1) = 1;
                *(void *)&long long v451 = v459;
                PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v455, (void ***)&v451);
                CGColorSpaceRef v271 = v459[0];
                unsigned int v272 = (uint64_t *)v459[1];
                int v273 = (uint64_t *)v459[0];
                if (v459[0] == v459[1])
                {
LABEL_399:
                  uint64_t v279 = [TextGrouping alloc];
                  *(void **)&v455[0] = v459[0];
                  *((void *)&v455[0] + 1) = ((char *)v459[1] - (char *)v459[0]) >> 4;
                  StringForStringRanges = (void *)PageLayout::CreateStringForStringRanges(a1, (uint64_t)v455);
                  uint64_t v281 = [(TextGrouping *)v279 initWithTextElement:v270 text:StringForStringRanges];
                  [v396 addObject:v281];

                  CGColorSpaceRef v271 = v459[0];
                }
                else
                {
                  while (1)
                  {
                    uint64_t v275 = *v273;
                    uint64_t v274 = v273[1];
                    uint64_t v276 = v274 + *v273;
                    if (*v273 < 0 || v276 > v264)
                    {
                      uint64_t v277 = v264 >= v276 ? v274 + *v273 : v264;
                      if (v275 > 0 || v276 < 1)
                      {
                        if (v275 < 0)
                        {
                          uint64_t v275 = 0;
                          uint64_t v277 = 0;
                        }
                        else
                        {
                          v277 -= v275;
                          if (v275 >= v264)
                          {
                            uint64_t v275 = 0;
                            uint64_t v277 = 0;
                          }
                        }
                      }
                      else
                      {
                        uint64_t v275 = 0;
                      }
                      *int v273 = v275;
                      v273[1] = v277;
                      if (!v277) {
                        break;
                      }
                    }
                    v273 += 2;
                    if (v273 == v272) {
                      goto LABEL_399;
                    }
                  }
                }
                if (v271)
                {
                  v459[1] = v271;
                  operator delete(v271);
                }
              }
            }
            uint64_t v267 = [v266 countByEnumeratingWithState:v436 objects:v461 count:16];
          }
          while (v267);
        }
      }

LABEL_405:
    }
    uint64_t v391 = [v383 countByEnumeratingWithState:__p objects:v462 count:16];
  }
  while (v391);
LABEL_407:

  if ([v396 count]) {
    [v381 addObject:v396];
  }
  long long v434 = 0u;
  long long v435 = 0u;
  long long v432 = 0u;
  long long v433 = 0u;
  id v364 = v381;
  uint64_t v282 = [v364 countByEnumeratingWithState:&v432 objects:v459 count:16];
  if (v282)
  {
    uint64_t v359 = *(void *)v433;
    do
    {
      uint64_t v370 = 0;
      uint64_t v352 = v282;
      do
      {
        if (*(void *)v433 != v359) {
          objc_enumerationMutation(v364);
        }
        id v368 = *(id *)(*((void *)&v432 + 1) + 8 * v370);
        uint64_t v444 = 0;
        uint64_t v445 = (char *)&v444;
        unint64_t v446 = 0x2050000000;
        uint64_t v283 = (void *)getCRLayoutUtilitiesClass(void)::softClass;
        uint64_t v447 = getCRLayoutUtilitiesClass(void)::softClass;
        if (!getCRLayoutUtilitiesClass(void)::softClass)
        {
          *(void *)&long long v415 = MEMORY[0x1E4F143A8];
          *((void *)&v415 + 1) = 3221225472;
          *(void *)&long long v416 = ___ZL25getCRLayoutUtilitiesClassv_block_invoke;
          *((void *)&v416 + 1) = &unk_1E52CD918;
          *(void *)&long long v417 = &v444;
          ___ZL25getCRLayoutUtilitiesClassv_block_invoke((uint64_t)&v415);
          uint64_t v283 = (void *)*((void *)v445 + 3);
        }
        id v284 = v283;
        _Block_object_dispose(&v444, 8);
        unsigned int v285 = [v284 listsWithRegionGroups:v368];
        long long v430 = 0u;
        long long v431 = 0u;
        long long v428 = 0u;
        long long v429 = 0u;
        id v366 = v285;
        uint64_t v286 = [v366 countByEnumeratingWithState:&v428 objects:v457 count:16];
        if (v286)
        {
          uint64_t v287 = *(void *)v429;
          uint64_t v354 = *(void *)v429;
          do
          {
            uint64_t v288 = 0;
            uint64_t v357 = v286;
            do
            {
              if (*(void *)v429 != v287) {
                objc_enumerationMutation(v366);
              }
              CFAllocatorRef v289 = *(void **)(*((void *)&v428 + 1) + 8 * v288);
              uint64_t v376 = objc_opt_new();
              long long v426 = 0u;
              long long v427 = 0u;
              long long v424 = 0u;
              long long v425 = 0u;
              id v372 = [v289 items];
              uint64_t v290 = [v372 countByEnumeratingWithState:&v424 objects:v455 count:16];
              uint64_t v361 = v288;
              if (v290)
              {
                uint64_t v379 = v290;
                CFMutableDataRef v291 = 0;
                CFMutableDataRef v292 = 0;
                uint64_t v374 = *(void *)v425;
                unint64_t v388 = -1;
                do
                {
                  for (iuint64_t i = 0; ii != v379; ++ii)
                  {
                    if (*(void *)v425 != v374) {
                      objc_enumerationMutation(v372);
                    }
                    uint64_t v293 = *(void **)(*((void *)&v424 + 1) + 8 * ii);
                    uint64_t v445 = 0;
                    uint64_t v444 = 0;
                    unint64_t v446 = 0;
                    long long v420 = 0u;
                    long long v421 = 0u;
                    long long v422 = 0u;
                    long long v423 = 0u;
                    unint64_t v294 = [v293 groups];
                    uint64_t v392 = v294;
                    uint64_t v295 = 0;
                    uint64_t v296 = [v294 countByEnumeratingWithState:&v420 objects:&v451 count:16];
                    if (v296)
                    {
                      uint64_t v400 = *(void *)v421;
                      do
                      {
                        uint64_t v297 = 0;
                        unint64_t v298 = v295;
                        do
                        {
                          if (*(void *)v421 != v400) {
                            objc_enumerationMutation(v392);
                          }
                          uint64_t v299 = [*(id *)(*((void *)&v420 + 1) + 8 * v297) subregions];
                          BOOL v300 = [v299 firstObject];

                          uint64_t v295 = [v300 parent];

                          if (v300)
                          {
                            [v300 textLine];
                          }
                          else
                          {
                            uint64_t v419 = 0;
                            long long v417 = 0u;
                            long long v418 = 0u;
                            long long v415 = 0u;
                            long long v416 = 0u;
                          }
                          uint64_t v301 = v445;
                          if ((unint64_t)v445 >= v446)
                          {
                            int v306 = (char *)v444;
                            unint64_t v307 = 0x8E38E38E38E38E39 * ((v445 - (unsigned char *)v444) >> 3);
                            unint64_t v308 = v307 + 1;
                            if (v307 + 1 > 0x38E38E38E38E38ELL) {
                              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
                            }
                            if (0x1C71C71C71C71C72 * ((uint64_t)(v446 - (void)v444) >> 3) > v308) {
                              unint64_t v308 = 0x1C71C71C71C71C72 * ((uint64_t)(v446 - (void)v444) >> 3);
                            }
                            if (0x8E38E38E38E38E39 * ((uint64_t)(v446 - (void)v444) >> 3) >= 0x1C71C71C71C71C7) {
                              unint64_t v309 = 0x38E38E38E38E38ELL;
                            }
                            else {
                              unint64_t v309 = v308;
                            }
                            if (v309)
                            {
                              unint64_t v309 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::TextLine>>(v309);
                              uint64_t v301 = v445;
                              int v306 = (char *)v444;
                            }
                            else
                            {
                              uint64_t v310 = 0;
                            }
                            unint64_t v311 = v309 + 72 * v307;
                            *(_OWORD *)unint64_t v311 = v415;
                            long long v312 = v416;
                            long long v313 = v417;
                            long long v314 = v418;
                            *(void *)(v311 + 64) = v419;
                            *(_OWORD *)(v311 + 32) = v313;
                            *(_OWORD *)(v311 + 48) = v314;
                            *(_OWORD *)(v311 + 16) = v312;
                            if (v301 == v306)
                            {
                              uint64_t v319 = (void *)(v309 + 72 * v307);
                            }
                            else
                            {
                              unint64_t v315 = v309 + 72 * v307;
                              do
                              {
                                *(_OWORD *)(v315 - 72) = *(_OWORD *)(v301 - 72);
                                long long v316 = *(_OWORD *)(v301 - 56);
                                long long v317 = *(_OWORD *)(v301 - 40);
                                long long v318 = *(_OWORD *)(v301 - 24);
                                uint64_t v319 = (void *)(v315 - 72);
                                *(void *)(v315 - 8) = *((void *)v301 - 1);
                                *(_OWORD *)(v315 - 24) = v318;
                                *(_OWORD *)(v315 - 40) = v317;
                                *(_OWORD *)(v315 - 56) = v316;
                                v301 -= 72;
                                v315 -= 72;
                              }
                              while (v301 != v306);
                            }
                            unint64_t v305 = (char *)(v311 + 72);
                            uint64_t v444 = v319;
                            uint64_t v445 = (char *)(v311 + 72);
                            unint64_t v446 = v309 + 72 * v310;
                            if (v306) {
                              operator delete(v306);
                            }
                          }
                          else
                          {
                            *(_OWORD *)uint64_t v445 = v415;
                            long long v302 = v416;
                            long long v303 = v417;
                            long long v304 = v418;
                            *((void *)v301 + 8) = v419;
                            *((_OWORD *)v301 + 2) = v303;
                            *((_OWORD *)v301 + 3) = v304;
                            *((_OWORD *)v301 + 1) = v302;
                            unint64_t v305 = v301 + 72;
                          }
                          uint64_t v445 = v305;
                          if (!v291)
                          {
                            id v320 = v295;

                            unint64_t v321 = [v320 parent];
                            unsigned int v322 = [v321 children];
                            unint64_t v388 = [v322 indexOfObject:v320];

                            CFMutableDataRef v291 = v321;
                            CFMutableDataRef v292 = v320;
                          }
                          [v295 removeSubregion:v300];

                          ++v297;
                          unint64_t v298 = v295;
                        }
                        while (v297 != v296);
                        unint64_t v294 = v392;
                        uint64_t v296 = [v392 countByEnumeratingWithState:&v420 objects:&v451 count:16];
                      }
                      while (v296);
                    }

                    uint64_t v323 = [[PDFListItemElement alloc] initWithTextLines:&v444 boundingBox:0];
                    [v376 addObject:v323];

                    if (v444)
                    {
                      uint64_t v445 = (char *)v444;
                      operator delete(v444);
                    }
                  }
                  uint64_t v379 = [v372 countByEnumeratingWithState:&v424 objects:v455 count:16];
                }
                while (v379);
              }
              else
              {
                CFMutableDataRef v291 = 0;
                CFMutableDataRef v292 = 0;
                unint64_t v388 = -1;
              }

              char v324 = [[PDFCRGroupRegion alloc] initWithBoundingQuad:0 layoutDirection:0 subregions:v376 parent:v291];
              unint64_t v325 = [v291 children];
              if ([v325 count] <= v388)
              {

                unint64_t v329 = v388;
              }
              else
              {
                unsigned int v326 = [v291 children];
                unint64_t v327 = [v326 objectAtIndex:v388];
                unsigned int v328 = [v327 isEqual:v292];

                unint64_t v329 = v388 + v328;
              }
              [v291 insertChildren:v324 atIndex:v329];
              [*(id *)(a1 + 328) addObject:v324];

              uint64_t v288 = v361 + 1;
              uint64_t v287 = v354;
            }
            while (v361 + 1 != v357);
            uint64_t v286 = [v366 countByEnumeratingWithState:&v428 objects:v457 count:16];
          }
          while (v286);
        }

        ++v370;
      }
      while (v370 != v352);
      uint64_t v282 = [v364 countByEnumeratingWithState:&v432 objects:v459 count:16];
    }
    while (v282);
  }

LABEL_363:
  id v262 = *(id *)(a1 + 320);

  return v262;
}

void sub_184F01998(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57)
{
  JUMPOUT(0x184F00DCCLL);
}

void sub_184F019F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,void *a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46)
{
  JUMPOUT(0x184F01BBCLL);
}

void sub_184F019FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44)
{
  JUMPOUT(0x184F01B74);
}

void sub_184F01A0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,void *a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46)
{
  JUMPOUT(0x184F01BBCLL);
}

void sub_184F01A40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57)
{
  JUMPOUT(0x184F00DCCLL);
}

void sub_184F01A48()
{
}

void sub_184F01AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  double v56 = (void *)STACK[0x440];
  if (STACK[0x440])
  {
    STACK[0x448] = (unint64_t)v56;
    operator delete(v56);
  }

  JUMPOUT(0x184F01B74);
}

void sub_184F01AC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  uint64_t v58 = (void *)STACK[0x440];
  if (STACK[0x440])
  {
    STACK[0x448] = (unint64_t)v58;
    operator delete(v58);
  }
  JUMPOUT(0x184F01B6CLL);
}

void sub_184F01BA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  JUMPOUT(0x184F01BBCLL);
}

id getCRCTLDClass(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getCRCTLDClass(void)::softClass;
  uint64_t v7 = getCRCTLDClass(void)::softClass;
  if (!getCRCTLDClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL14getCRCTLDClassv_block_invoke;
    v3[3] = &unk_1E52CD918;
    v3[4] = &v4;
    ___ZL14getCRCTLDClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_184F01CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getCRNormalizedQuadClass(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getCRNormalizedQuadClass(void)::softClass;
  uint64_t v7 = getCRNormalizedQuadClass(void)::softClass;
  if (!getCRNormalizedQuadClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL24getCRNormalizedQuadClassv_block_invoke;
    v3[3] = &unk_1E52CD918;
    v3[4] = &v4;
    ___ZL24getCRNormalizedQuadClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_184F01D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id PageLayout::createFineCTLDConfig(PageLayout *this)
{
  id v1 = (void *)[objc_alloc((Class)getCRCTLDConfigClass()) init];
  [v1 setAngleThresholdForRotationCorrection:0.0];
  [v1 setFlatMergeJumps:1];
  [v1 setMaxRegions:169];
  [v1 setMaxQueueCapacity:0xFFFFFFFFLL];
  [v1 setNumLookupElements:57];
  [v1 setNumPointsForSegmentsIntersection:4];
  LODWORD(v2) = 8.0;
  [v1 setMinSubRectangleSize:v2];
  LODWORD(v3) = 1035122882;
  [v1 setMinQuadrilateralRotation:v3];
  LODWORD(v4) = 1060320051;
  [v1 setMinWhitespaceHeightForReadingOrder:v4];
  LODWORD(v5) = 1050589266;
  [v1 setAllowedOverlap:v5];
  LODWORD(v6) = 1047233823;
  [v1 setMinWhitespaceWidth:v6];
  LODWORD(v7) = 1063843267;
  [v1 setMinWhitespaceHeight:v7];
  LODWORD(v8) = 1078523331;
  [v1 setQualityHeightFactor:v8];
  LODWORD(v9) = 1066863165;
  [v1 setQualityWidthFactor:v9];

  return v1;
}

void sub_184F01EA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(uint64_t a1, uint64_t a2, void ***a3)
{
  if (*(unsigned char *)(a1 + 8))
  {
    id v6 = objc_alloc_init(MEMORY[0x1E4F28E60]);
    uint64_t v7 = *(void *)(a2 + 8);
    if (v7)
    {
      double v8 = *(unint64_t **)a2;
      double v9 = &v8[2 * v7];
      do
      {
        uint64_t v10 = v8[1];
        if (v10 >= 1)
        {
          unint64_t v11 = *v8;
          uint64_t v12 = v10 + *v8;
          uint64_t v14 = *(void *)(a1 + 80);
          uint64_t v13 = *(void *)(a1 + 88);
          while (1)
          {
            if (v11 >= (v13 - v14) >> 3) {
              goto LABEL_29;
            }
            if (*(void *)(v14 + 8 * v11)) {
              break;
            }
LABEL_18:
            if ((uint64_t)++v11 >= v12) {
              goto LABEL_19;
            }
          }
          uint64_t v15 = 0;
          while (1)
          {
            uint64_t v16 = *(void *)(a1 + 152);
            if (v11 >= (*(void *)(a1 + 160) - v16) >> 3) {
              std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
            }
            uint64_t v17 = *(void **)(a1 + 296);
            double v18 = *(void **)(a1 + 304);
            if (v17 == v18)
            {
              double v20 = *(void **)(a1 + 296);
            }
            else
            {
              uint64_t v19 = *(void *)(v16 + 8 * v11) + v15;
              double v20 = *(void **)(a1 + 296);
              while (*v20 != v19)
              {
                if (++v20 == v18)
                {
                  double v20 = *(void **)(a1 + 304);
                  break;
                }
              }
            }
            [v6 addIndex:v20 - v17];
            uint64_t v14 = *(void *)(a1 + 80);
            uint64_t v13 = *(void *)(a1 + 88);
            if (v11 >= (v13 - v14) >> 3) {
              break;
            }
            if ((unint64_t)++v15 >= *(void *)(v14 + 8 * v11)) {
              goto LABEL_18;
            }
          }
LABEL_29:
          std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
        }
LABEL_19:
        v8 += 2;
      }
      while (v8 != v9);
    }
    *(void *)&long long v31 = 0;
    *((void *)&v31 + 1) = &v31;
    uint64_t v32 = 0x4012000000;
    CGFloat v33 = __Block_byref_object_copy__364;
    BOOL v34 = __Block_byref_object_dispose__365;
    id v35 = "";
    long long v36 = xmmword_1850CD8B0;
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 3221225472;
    v30[2] = ___ZNK10PageLayout31ConvertTextRangesToStringRangesINSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke;
    v30[3] = &unk_1E52CC288;
    v30[4] = &v31;
    v30[5] = a1;
    v30[6] = a3;
    [v6 enumerateRangesUsingBlock:v30];
    if (*(void *)(*((void *)&v31 + 1) + 48) != -1) {
      std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](a3, (_OWORD *)(*((void *)&v31 + 1) + 48));
    }
    _Block_object_dispose(&v31, 8);
  }
  else
  {
    uint64_t v21 = *(void *)(a2 + 8);
    if (v21)
    {
      double v22 = *(unint64_t **)a2;
      uint64_t v23 = *(void *)a2 + 16 * v21;
      do
      {
        unint64_t v24 = *v22;
        uint64_t v25 = *(void *)(a1 + 152);
        unint64_t v26 = (*(void *)(a1 + 160) - v25) >> 3;
        if (v26 <= *v22) {
          std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
        }
        unint64_t v27 = v22[1] + v24;
        if (v26 <= v27) {
          std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
        }
        uint64_t v28 = *(void *)(v25 + 8 * v24);
        uint64_t v29 = *(void *)(v25 + 8 * v27) - v28;
        *(void *)&long long v31 = v28;
        *((void *)&v31 + 1) = v29;
        std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](a3, &v31);
        v22 += 2;
      }
      while (v22 != (unint64_t *)v23);
    }
  }
}

void sub_184F0213C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_184F02158(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  if (a2 != 1) {
    JUMPOUT(0x184F02150);
  }
  long long v36 = __cxa_begin_catch(a1);
  uint64_t v37 = (const char *)(*(uint64_t (**)(void *))(*(void *)v36 + 16))(v36);
  pdf_error("%s caught exception: %s", "void PageLayout::ConvertTextRangesToStringRanges(I &&, O &&) const [I = std::span<CFRange>, O = std::back_insert_iterator<std::vector<CFRange>>]", v37);
  __cxa_end_catch();
}

#error "184F02228: call analysis failed (funcsize=21)"

uint64_t PageLayout::CreateStringForStringRanges(uint64_t a1, uint64_t a2)
{
  id v4 = objc_alloc_init(MEMORY[0x1E4F28E78]);
  uint64_t v5 = [*(id *)(a1 + 24) length];
  uint64_t v6 = *(void *)(a2 + 8);
  if (v6)
  {
    NSUInteger v7 = v5;
    double v8 = *(NSRange **)a2;
    uint64_t v9 = *(void *)a2 + 16 * v6;
    do
    {
      v15.CFIndex location = 0;
      v15.CFIndex length = v7;
      NSRange v10 = NSIntersectionRange(*v8, v15);
      if (v10.length)
      {
        unint64_t v11 = objc_msgSend(*(id *)(a1 + 24), "substringWithRange:", v10.location, v10.length);
        [v4 appendString:v11];
      }
      ++v8;
    }
    while (v8 != (NSRange *)v9);
  }
  uint64_t v12 = [MEMORY[0x1E4F28B88] newlineCharacterSet];
  uint64_t v13 = [v4 stringByTrimmingCharactersInSet:v12];

  return v13;
}

void sub_184F02318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL25getCRLayoutUtilitiesClassv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("CRLayoutUtilities");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCRLayoutUtilitiesClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    TextRecognitionLibrary();
  }
}

void TextRecognitionLibrary(void)
{
  double v2 = 0;
  uint64_t v0 = TextRecognitionLibraryCore(&v2);
  id v1 = v2;
  if (!v0)
  {
    id v1 = (void *)abort_report_np();
    goto LABEL_5;
  }
  if (v2) {
LABEL_5:
  }
    free(v1);
}

__n128 __Block_byref_object_copy__364(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void ***___ZNK10PageLayout31ConvertTextRangesToStringRangesINSt3__14spanI7CFRangeLm18446744073709551615EEENS1_20back_insert_iteratorINS1_6vectorIS3_NS1_9allocatorIS3_EEEEEEEEvOT_OT0__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *(void *)(a1 + 40);
  unint64_t v7 = a2 + a3;
  __n128 result = (void ***)[*(id *)(v6 + 24) length];
  if (v7 < (unint64_t)result)
  {
    __n128 result = (void ***)[*(id *)(v6 + 24) characterAtIndex:v7];
    if (result == 10) {
      ++v3;
    }
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v10 = *(void *)(v9 + 48);
  if (v10 != -1)
  {
    uint64_t v11 = *(void *)(v9 + 56);
    if (v11 + v10 == a2)
    {
      *(void *)(v9 + 56) = v11 + v3;
      return result;
    }
    __n128 result = std::back_insert_iterator<std::vector<CFRange>>::operator=[abi:fe180100](*(void ****)(a1 + 48), (_OWORD *)(v9 + 48));
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  }
  *(void *)(v9 + 48) = a2;
  *(void *)(v9 + 56) = v3;
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  uint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (__n128 result = *v5; result; __n128 result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = operator new(0x20uLL);
  *uint64_t v12 = 0;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = *(_DWORD *)a3;
  uint64_t v13 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  v12[3] = v13;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(a1, v19);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t v12 = *v21;
LABEL_38:
    *uint64_t v21 = v12;
    goto LABEL_39;
  }
  *uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v22 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v22 >= v7) {
        v22 %= v7;
      }
    }
    else
    {
      v22 &= v7 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
}

void sub_184F02780(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:fe180100](1, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:fe180100](char a1, id *a2)
{
  if (a1)
  {
  }
  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

id getCRCTLDConfigClass(void)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)getCRCTLDConfigClass(void)::softClass;
  uint64_t v7 = getCRCTLDConfigClass(void)::softClass;
  if (!getCRCTLDConfigClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL20getCRCTLDConfigClassv_block_invoke;
    v3[3] = &unk_1E52CD918;
    v3[4] = &v4;
    ___ZL20getCRCTLDConfigClassv_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_184F028BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL20getCRCTLDConfigClassv_block_invoke(uint64_t a1)
{
  TextRecognitionLibrary();
  Class result = objc_getClass("CRCTLDConfig");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCRCTLDConfigClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return ___ZL24getCRNormalizedQuadClassv_block_invoke(v3);
  }
  return result;
}

Class ___ZL24getCRNormalizedQuadClassv_block_invoke(uint64_t a1)
{
  TextRecognitionLibrary();
  Class result = objc_getClass("CRNormalizedQuad");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCRNormalizedQuadClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)___ZL14getCRCTLDClassv_block_invoke(v3);
  }
  return result;
}

double ___ZL14getCRCTLDClassv_block_invoke(uint64_t a1)
{
  TextRecognitionLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("CRCTLD");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCRCTLDClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    *(void *)&double result = __Block_byref_object_copy__92(v3, v4).n128_u64[0];
  }
  return result;
}

__n128 __Block_byref_object_copy__92(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void ___ZN10PageLayout20createAtomicElementsEP6CGRect_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v17.origin.double x = CGPDFAnnotationGetRect(a3);
  long long v5 = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&v16.double a = *(_OWORD *)(a1 + 48);
  *(_OWORD *)&v16.double c = v5;
  *(_OWORD *)&v16.tdouble x = *(_OWORD *)(a1 + 80);
  CGRect v18 = CGRectApplyAffineTransform(v17, &v16);
  double x = v18.origin.x;
  double y = v18.origin.y;
  double width = v18.size.width;
  double height = v18.size.height;
  if (CGPDFAnnotationGetType(a3) != 8)
  {
    uint64_t v10 = *(CGPDFDictionary **)(a3 + 16);
    CGPDFBoolean value = 0;
    if (!CGPDFDictionaryGetBoolean(v10, "AAPL:SFF", &value) || value == 0)
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
      v19.origin.double x = x;
      v19.origin.double y = y;
      v19.size.double width = width;
      v19.size.double height = height;
      *(CGRect *)(v12 + 48) = CGRectUnion(*(CGRect *)(v12 + 48), v19);
      uint64_t v13 = objc_msgSend(objc_alloc((Class)getCRNormalizedQuadClass()), "initWithNormalizedBoundingBox:size:", x, y, width, height, *(double *)(a1 + 112), *(double *)(a1 + 120));
      float v14 = [[PDFAnnotationElement alloc] initWithAnnotation:a3 boundingBox:v13];
      [*(id *)(a1 + 32) addObject:v14];
    }
  }
}

void sub_184F02B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void PageLayout::addCTLDMapping(PageLayout *this, TextLine *a2, PDFAtomicElement *a3)
{
  uint64_t v9 = a3;
  uint64_t v6 = (void *)((char *)this + 336);
  unsigned int identifier = a2->identifier;
  uint8x8_t v8 = std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::find<unsigned int>(v6, identifier);
  if (v8)
  {
    objc_storeStrong((id *)v8 + 3, a3);
  }
  else
  {
    unsigned int v10 = identifier;
    unint64_t v11 = v9;
    std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,PDFAtomicElement * {__strong}>>((uint64_t)v6, identifier, (uint64_t)&v10);
  }
}

void sub_184F02C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL26TextRecognitionLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  TextRecognitionLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void std::vector<unsigned long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    long long v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v7 = &v4[8 * v6];
    uint8x8_t v8 = (char *)*a1;
    uint64_t v9 = (char *)a1[1];
    unsigned int v10 = v5;
    if (v9 != *a1)
    {
      unsigned int v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v9 != v8);
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void std::vector<CGRect>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    int64_t v3 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGRect>>(a2);
    long long v5 = &v4[v3 & 0xFFFFFFFFFFFFFFE0];
    uint64_t v7 = &v4[32 * v6];
    uint64_t v9 = (char *)*a1;
    uint8x8_t v8 = (char *)a1[1];
    unsigned int v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        long long v11 = *((_OWORD *)v8 - 1);
        *((_OWORD *)v10 - 2) = *((_OWORD *)v8 - 2);
        *((_OWORD *)v10 - 1) = v11;
        v10 -= 32;
        v8 -= 32;
      }
      while (v8 != v9);
      uint8x8_t v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void PageLayout::getTextRangeIndex(uint64_t a1, int a2, unsigned int a3, double a4, double a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  if (v5 != v6)
  {
    double v7 = a4;
    unint64_t v8 = 0;
    int v148 = 0;
    unint64_t v9 = (v6 - v5) / 72;
    uint64_t v10 = v9 <= 1 ? 1 : (v6 - v5) / 72;
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = (double *)(v5 + 56);
    unint64_t v13 = -1;
    rect1.origin.double x = 1.79769313e308;
    double v147 = 1.79769313e308;
    do
    {
      double v14 = v7;
      double v15 = a5;
      if (*v12 != 0.0)
      {
        __double2 v16 = __sincos_stret(*v12);
        double v14 = a5 * v16.__sinval + v16.__cosval * v7 + 0.0;
        double v15 = a5 * v16.__cosval - v16.__sinval * v7 + 0.0;
      }
      double v18 = *(v12 - 4);
      double y = *(v12 - 3);
      double v20 = *(v12 - 2);
      double height = *(v12 - 1);
      if (v20 < 0.0 || height < 0.0)
      {
        double v27 = COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(v12 - 4))) - v14;
        v156.origin.double x = v18;
        v156.origin.double y = y;
        v156.size.CGFloat width = v20;
        v156.size.double height = height;
        CGRect v157 = CGRectStandardize(v156);
        double v28 = v14 - (v157.origin.x + v157.size.width);
        BOOL v23 = v27 < 0.0;
        if (v27 >= 0.0) {
          double v29 = v27;
        }
        else {
          double v29 = 0.0;
        }
        BOOL v24 = v29 < v28;
        if (v29 >= v28) {
          double v25 = v29;
        }
        else {
          double v25 = v28;
        }
        v158.origin.double x = v18;
        v158.origin.double y = y;
        v158.size.CGFloat width = v20;
        v158.size.double height = height;
        CGRect v159 = CGRectStandardize(v158);
        double v26 = v159.origin.y - v15;
        v159.origin.double x = v18;
        v159.origin.double y = y;
        v159.size.CGFloat width = v20;
        v159.size.double height = height;
        CGRect v160 = CGRectStandardize(v159);
        double y = v160.origin.y;
        double height = v160.size.height;
      }
      else
      {
        double v21 = v18 - v14;
        double v22 = v14 - (v18 + v20);
        BOOL v23 = v18 - v14 < 0.0;
        if (v18 - v14 < 0.0) {
          double v21 = 0.0;
        }
        BOOL v24 = v21 < v22;
        if (v21 >= v22) {
          double v25 = v21;
        }
        else {
          double v25 = v14 - (v18 + v20);
        }
        double v26 = y - v15;
      }
      double v30 = v15 - (y + height);
      if (v26 >= 0.0) {
        double v31 = v26;
      }
      else {
        double v31 = 0.0;
      }
      if (v31 >= v30) {
        double v30 = v31;
      }
      if (v30 * v30 + v25 * v25 < rect1.origin.x)
      {
        if (v24) {
          int v32 = 2;
        }
        else {
          int v32 = v23;
        }
        int v148 = v32;
        unint64_t v13 = v8;
        double v147 = v30;
        rect1.origin.double x = v30 * v30 + v25 * v25;
      }
      ++v8;
      v12 += 9;
      double v7 = a4;
    }
    while (v10 != v8);
    if (v13 != -1)
    {
      if (v9 <= v13) {
        goto LABEL_190;
      }
      uint64_t v33 = v11;
      BOOL v34 = (CGFloat *)(v11 + 72 * v13);
      CGFloat v35 = v34[3];
      CGFloat v36 = v34[4];
      CGFloat v37 = v34[5];
      CGFloat v38 = v34[6];
      __double2 v39 = __sincos_stret(v34[7]);
      v155.double a = v39.__cosval;
      v155.double b = v39.__sinval;
      v155.double c = -v39.__sinval;
      v155.double d = v39.__cosval;
      v155.tdouble x = 0.0;
      v155.tdouble y = 0.0;
      v161.origin.double x = v35;
      v161.origin.double y = v36;
      v161.size.CGFloat width = v37;
      v161.size.double height = v38;
      CGRect v162 = CGRectApplyAffineTransform(v161, &v155);
      rect1.origin.double x = v162.origin.x;
      CGFloat v40 = v162.origin.y;
      CGFloat width = v162.size.width;
      CGFloat v42 = v162.size.height;
      unint64_t v43 = 0;
      uint64_t v44 = 0;
      double v45 = 0;
      unint64_t v46 = 0;
      do
      {
        double v47 = (CGFloat *)(v33 + 72 * v46);
        CGFloat v48 = v47[3];
        CGFloat v49 = v47[4];
        CGFloat v50 = v47[5];
        CGFloat v51 = v47[6];
        __double2 v52 = __sincos_stret(v47[7]);
        v154.double a = v52.__cosval;
        v154.double b = v52.__sinval;
        v154.double c = -v52.__sinval;
        v154.double d = v52.__cosval;
        v154.tdouble x = 0.0;
        v154.tdouble y = 0.0;
        v163.origin.double x = v48;
        v163.origin.double y = v49;
        v163.size.CGFloat width = v50;
        v163.size.double height = v51;
        CGRect v174 = CGRectApplyAffineTransform(v163, &v154);
        v164.origin.double x = rect1.origin.x;
        v164.origin.double y = v40;
        v164.size.CGFloat width = width;
        v164.size.double height = v42;
        if (CGRectIntersectsRect(v164, v174))
        {
          if ((unint64_t)v44 >= v43)
          {
            uint64_t v54 = (v44 - v45) >> 3;
            unint64_t v55 = v54 + 1;
            if ((unint64_t)(v54 + 1) >> 61) {
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
            }
            if ((uint64_t)(v43 - (void)v45) >> 2 > v55) {
              unint64_t v55 = (uint64_t)(v43 - (void)v45) >> 2;
            }
            if (v43 - (unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v56 = v55;
            }
            if (v56) {
              unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v56);
            }
            else {
              uint64_t v57 = 0;
            }
            uint64_t v58 = (unint64_t *)(v56 + 8 * v54);
            unint64_t *v58 = v46;
            unint64_t v53 = (char *)(v58 + 1);
            while (v44 != v45)
            {
              unint64_t v59 = *((void *)v44 - 1);
              v44 -= 8;
              *--uint64_t v58 = v59;
            }
            unint64_t v43 = v56 + 8 * v57;
            if (v45) {
              operator delete(v45);
            }
            double v45 = (char *)v58;
          }
          else
          {
            *(void *)uint64_t v44 = v46;
            unint64_t v53 = v44 + 8;
          }
          uint64_t v33 = *(void *)(a1 + 32);
          uint64_t v6 = *(void *)(a1 + 40);
          uint64_t v44 = v53;
        }
        ++v46;
        unint64_t v60 = 0x8E38E38E38E38E39 * ((v6 - v33) >> 3);
      }
      while (v46 < v60);
      uint64_t v145 = v33;
      double v61 = a5;
      if ((unint64_t)(v44 - v45) < 9)
      {
        unsigned int v98 = a3;
        int v106 = v148;
      }
      else
      {
        if (v45 != v44)
        {
          double v62 = 1.79769313e308;
          id v63 = (unint64_t *)v45;
          do
          {
            unint64_t v64 = *v63;
            if (v60 <= *v63) {
              goto LABEL_190;
            }
            uint64_t v149 = v45;
            CGAffineTransform v65 = (unint64_t *)(v145 + 72 * v64);
            uint64_t v66 = v65[1];
            if (v66 >= 1)
            {
              unint64_t v67 = *v65;
              uint64_t v68 = v66 + *v65;
              double v69 = *(double *)(v145 + 72 * v64 + 56);
              __double2 v70 = __sincos_stret(v69);
              uint64_t v71 = *(void *)(a1 + 128);
              unint64_t v72 = (*(void *)(a1 + 136) - v71) >> 5;
              BOOL v73 = v72 >= v67;
              unint64_t v74 = v72 - v67;
              if (v73) {
                unint64_t v75 = v74;
              }
              else {
                unint64_t v75 = 0;
              }
              if (v68 <= (uint64_t)(v67 + 1)) {
                uint64_t v76 = v67 + 1;
              }
              else {
                uint64_t v76 = v68;
              }
              unint64_t v77 = v76 + ~v67;
              if (v69 == 0.0) {
                double v78 = v7;
              }
              else {
                double v78 = a5 * v70.__sinval + v70.__cosval * v7 + 0.0;
              }
              rect1.origin.double x = v78;
              if (v69 == 0.0) {
                double v79 = a5;
              }
              else {
                double v79 = a5 * v70.__cosval - v70.__sinval * v7 + 0.0;
              }
              long long v80 = (CGFloat *)(v71 + 32 * v67 + 16);
              unint64_t v81 = v76 - v67;
              while (v75 > v77)
              {
                CGFloat v83 = *(v80 - 2);
                double v82 = *(v80 - 1);
                double v85 = *v80;
                double v84 = v80[1];
                BOOL v86 = v84 < 0.0 || *v80 < 0.0;
                if (v86)
                {
                  *(void *)&double v87 = (unint64_t)CGRectStandardize(*(CGRect *)(v80 - 2));
                  v165.origin.double x = v83;
                  v165.origin.double y = v82;
                  v165.size.CGFloat width = v85;
                  v165.size.double height = v84;
                  CGRect v166 = CGRectStandardize(v165);
                }
                else
                {
                  double v87 = *(v80 - 2);
                  v166.origin.double x = v87;
                  v166.size.CGFloat width = *v80;
                }
                double v88 = v87 - rect1.origin.x;
                double v89 = rect1.origin.x - (v166.origin.x + v166.size.width);
                if (v87 - rect1.origin.x < 0.0) {
                  double v88 = 0.0;
                }
                if (v88 >= v89) {
                  double v90 = v88;
                }
                else {
                  double v90 = v89;
                }
                if (v86)
                {
                  v167.origin.double x = v83;
                  v167.origin.double y = v82;
                  v167.size.CGFloat width = v85;
                  v167.size.double height = v84;
                  CGRect v168 = CGRectStandardize(v167);
                  CGFloat v91 = v168.origin.y;
                  v168.origin.double x = v83;
                  v168.origin.double y = v82;
                  v168.size.CGFloat width = v85;
                  v168.size.double height = v84;
                  CGRect v169 = CGRectStandardize(v168);
                  double v84 = v169.size.height;
                  double v82 = v91;
                }
                else
                {
                  v169.origin.double y = v82;
                }
                CGFloat v92 = v169.origin.y + v84;
                double v93 = v82 - v79;
                double v94 = v79 - v92;
                if (v82 - v79 < 0.0) {
                  double v93 = 0.0;
                }
                if (v93 >= v94) {
                  double v94 = v93;
                }
                double v95 = v94 * v94 + v90 * v90;
                if (v95 < v62)
                {
                  unint64_t v13 = v64;
                  double v62 = v95;
                }
                v80 += 4;
                if (!--v81) {
                  goto LABEL_97;
                }
              }
              goto LABEL_190;
            }
LABEL_97:
            ++v63;
            double v45 = v149;
            double v7 = a4;
          }
          while (v63 != (unint64_t *)v44);
        }
        if (v60 <= v13) {
          goto LABEL_190;
        }
        double v96 = *(double *)(v145 + 72 * v13 + 56);
        double v97 = v7;
        unsigned int v98 = a3;
        double v61 = a5;
        if (v96 != 0.0)
        {
          __double2 v99 = __sincos_stret(v96);
          double v97 = a5 * v99.__sinval + v99.__cosval * v7 + 0.0;
        }
        uint64_t v100 = v145 + 72 * v13;
        double x = *(double *)(v100 + 24);
        CGFloat v102 = *(double *)(v100 + 32);
        double v103 = *(double *)(v100 + 40);
        double v104 = *(double *)(v100 + 48);
        if (v103 < 0.0 || v104 < 0.0)
        {
          *(void *)&double v105 = (unint64_t)CGRectStandardize(*(CGRect *)(v100 + 24));
          v170.origin.double x = x;
          v170.origin.double y = v102;
          v170.size.CGFloat width = v103;
          v170.size.double height = v104;
          CGRect v171 = CGRectStandardize(v170);
          double x = v171.origin.x;
          double v103 = v171.size.width;
        }
        else
        {
          double v105 = *(double *)(v100 + 24);
        }
        double v107 = v105 - v97;
        if (v105 - v97 < 0.0) {
          double v107 = 0.0;
        }
        if (v107 >= v97 - (x + v103)) {
          int v106 = v105 - v97 < 0.0;
        }
        else {
          int v106 = 2;
        }
      }
      if (v98 != 2) {
        goto LABEL_157;
      }
      if (v106 != 1)
      {
        if (!v45) {
          return;
        }
        goto LABEL_184;
      }
      if (v147 == 0.0)
      {
LABEL_157:
        if (v60 <= v13) {
          goto LABEL_190;
        }
        uint64_t v108 = (unint64_t *)(v145 + 72 * v13);
        unint64_t v109 = *v108;
        unint64_t v153 = v109;
        uint64_t v110 = v108[1];
        int64_t v111 = v110 + v109;
        *(void *)&rect1.size.double height = v110 + v109;
        if (v106 == 2 || !v106)
        {
          PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()(a1, &v153, &rect1.size.height, 0);
          goto LABEL_124;
        }
        int v112 = a2;
        if (a2 == 2)
        {
          if (v98 - 2 < 2 || v98 <= 1) {
            goto LABEL_123;
          }
LABEL_124:
          if (!v45) {
            return;
          }
LABEL_184:
          operator delete(v45);
          return;
        }
        double v113 = *(double *)(v145 + 72 * v13 + 56);
        if (v113 != 0.0)
        {
          __double2 v114 = __sincos_stret(v113);
          double v7 = v61 * v114.__sinval + v114.__cosval * v7 + 0.0;
        }
        if (v110 >= 1)
        {
          uint64_t v115 = *(void *)(a1 + 128);
          uint64_t v116 = *(void *)(a1 + 136) - v115;
          if (v111 <= (uint64_t)(v109 + 1)) {
            unint64_t v117 = v109 + 1;
          }
          else {
            unint64_t v117 = v110 + v109;
          }
          if (v109 <= v116 >> 5) {
            uint64_t v118 = v116 >> 5;
          }
          else {
            uint64_t v118 = v109;
          }
          uint64_t v119 = (double *)(v115 + 32 * v109 + 16);
          while (1)
          {
            if (v118 == v109) {
              goto LABEL_190;
            }
            double v120 = v7;
            double v121 = *(v119 - 2);
            double v122 = *v119;
            double v123 = v119[1];
            if (*v119 < 0.0 || v123 < 0.0)
            {
              if (COERCE_DOUBLE(CGRectStandardize(*(CGRect *)(v119 - 2))) > v120) {
                goto LABEL_146;
              }
              v172.origin.double y = *(v119 - 1);
              v172.origin.double x = v121;
              v172.size.CGFloat width = v122;
              v172.size.double height = v123;
              CGRect v173 = CGRectStandardize(v172);
              double v121 = v173.origin.x;
              double v122 = v173.size.width;
            }
            else if (v121 > v120)
            {
              goto LABEL_146;
            }
            if (v120 <= v121 + v122)
            {
              double v7 = v120;
              goto LABEL_149;
            }
LABEL_146:
            ++v109;
            v119 += 4;
            double v7 = v120;
            if ((uint64_t)v109 >= v111)
            {
              unint64_t v109 = v117;
LABEL_149:
              int v112 = a2;
              break;
            }
          }
        }
        BOOL v124 = v109 == -1 || v109 == v111;
        BOOL v125 = v124;
        if (a3 != 2 && !v125)
        {
          uint64_t v126 = *(void *)(a1 + 128);
          if (v109 >= (*(void *)(a1 + 136) - v126) >> 5) {
            goto LABEL_190;
          }
          uint64_t v127 = v126 + 32 * v109;
          double v128 = *(double *)v127;
          double v129 = *(double *)(v127 + 16);
          double v130 = *(double *)(v127 + 24);
          if (v129 < 0.0 || v130 < 0.0)
          {
            uint64_t v131 = *(void *)(v127 + 8);
            *(CGRect *)&double v128 = CGRectStandardize(*(CGRect *)&v128);
          }
          if (v112)
          {
            Worduint64_t Range = PageLayout::getWordRange((void *)a1, v13, v109);
            *(void *)&rect1.origin.double y = (char *)WordRange + v133;
            *(void *)&rect1.size.CGFloat width = WordRange;
            PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()(a1, (unint64_t *)&rect1.size, &rect1.origin.y, 1);
            goto LABEL_124;
          }
          double v134 = v128 + v129 * 0.5;
          if (*(unsigned char *)(a1 + 8))
          {
            unint64_t v135 = (unint64_t)PageLayout::convertRTLTextRangeIndexToStringRangeIndex((void *)a1, v109);
            if (v135 >= ((uint64_t)(*(void *)(a1 + 304) - *(void *)(a1 + 296)) >> 3) - 1) {
              goto LABEL_193;
            }
            unint64_t v136 = v135 + 1;
            if ([*(id *)(a1 + 24) characterAtIndex:v135 + 1] == 10) {
              goto LABEL_193;
            }
            uint64_t v137 = *(void *)(a1 + 296);
            unint64_t v138 = (*(void *)(a1 + 304) - v137) >> 3;
            if (v138 <= v135 || v138 <= v136) {
              goto LABEL_190;
            }
            if (*(void *)(v137 + 8 * v135) > *(void *)(v137 + 8 * v136)) {
LABEL_193:
            }
              BOOL v140 = !v135
                  || [*(id *)(a1 + 24) characterAtIndex:v135 - 1] == 10
                  || (uint64_t v139 = *(void *)(a1 + 296), v135 >= (*(void *)(a1 + 304) - v139) >> 3)
                  || *(void *)(v139 + 8 * (v135 - 1)) > *(void *)(v139 + 8 * v135);
            else {
              BOOL v140 = 0;
            }
            if (v140 != v7 >= v134)
            {
              if (v135 < ((uint64_t)(*(void *)(a1 + 304) - *(void *)(a1 + 296)) >> 3) - 1)
              {
                unint64_t v141 = v135 + 1;
                if ([*(id *)(a1 + 24) characterAtIndex:v141] == 10)
                {
LABEL_123:
                  PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()(a1, &v153, &rect1.size.height, 1);
                  goto LABEL_124;
                }
                uint64_t v142 = *(void *)(a1 + 296);
                if (v141 < (*(void *)(a1 + 304) - v142) >> 3)
                {
                  PageLayout::convertStringRangeIndexToTextRangeIndex(*(void **)(a1 + 152), *(void **)(a1 + 160), *(void *)(v142 + 8 * v141));
                  goto LABEL_124;
                }
LABEL_190:
                __break(1u);
                return;
              }
              goto LABEL_183;
            }
          }
          else if (v7 >= v134)
          {
            goto LABEL_183;
          }
          if (!v45) {
            return;
          }
          goto LABEL_184;
        }
      }
LABEL_183:
      if (!v45) {
        return;
      }
      goto LABEL_184;
    }
  }
}

void sub_184F038BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *PageLayout::convertRTLTextRangeIndexToStringRangeIndex(void *this, unint64_t a2)
{
  uint64_t v2 = this[19];
  if (a2 >= (this[20] - v2) >> 3 || (uint64_t v3 = this[10], a2 >= (this[11] - v3) >> 3))
  {
    __break(1u);
  }
  else
  {
    unint64_t v4 = *(void *)(v3 + 8 * a2);
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    uint64_t v6 = (void *)this[37];
    double v7 = (void *)this[38];
    if (v6 == v7)
    {
      unint64_t v9 = (void *)this[37];
    }
    else
    {
      uint64_t v8 = *(void *)(v2 + 8 * a2);
      unint64_t v9 = (void *)this[37];
LABEL_8:
      uint64_t v10 = 0;
      while (*v9 != v10 + v8)
      {
        uint64_t v10 = (v10 + 1);
        if (v10 == v5)
        {
          if (++v9 != v7) {
            goto LABEL_8;
          }
          unint64_t v9 = (void *)this[38];
          break;
        }
      }
    }
    unint64_t v11 = v9 - v6;
    if (v11 < v7 - v6 - 1 && v4 == 0) {
      return (void *)(v11 + 1);
    }
    else {
      return (void *)(v9 - v6);
    }
  }
  return this;
}

void *PageLayout::CreateSelectionForStringRange(id *this, CFRange a2)
{
  uint64_t v2 = 0;
  if (a2.location < 0 || a2.length < 1) {
    return (void *)v2;
  }
  unint64_t location = a2.location;
  uint64_t v5 = (void *)(a2.location + a2.length);
  uint64_t result = (void *)[this[3] length];
  if ((uint64_t)v5 > (uint64_t)result) {
    return 0;
  }
  if (*((unsigned char *)this + 8))
  {
    uint64_t v2 = CGPDFSelectionCreateWithPage(*this);
    id v7 = objc_alloc_init(MEMORY[0x1E4F28E60]);
    do
    {
      uint64_t result = (void *)[this[3] characterAtIndex:location];
      if (result != 10)
      {
        uint64_t v8 = this[37];
        if (location >= ((unsigned char *)this[38] - v8) >> 3) {
          goto LABEL_32;
        }
        objc_msgSend(v7, "addIndex:", PageLayout::convertStringRangeIndexToTextRangeIndex(this[19], this[20], *(void *)&v8[8 * location]));
      }
      ++location;
    }
    while ((uint64_t)location < (uint64_t)v5);
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = ___ZNK10PageLayout29CreateSelectionForStringRangeE7CFRange_block_invoke;
    _OWORD v24[3] = &__block_descriptor_48_e24_v32__0__NSRange_QQ_8_B24l;
    v24[4] = this;
    v24[5] = v2 + 168;
    [v7 enumerateRangesUsingBlock:v24];
    Selection::Normalize((Selection *)(v2 + 168));

    return (void *)v2;
  }
  unint64_t v9 = this[19];
  uint64_t v10 = this[20];
  unint64_t v11 = (v10 - v9) >> 3;
  if (v10 == v9)
  {
    uint64_t v12 = this[19];
  }
  else
  {
    uint64_t v12 = this[19];
    unint64_t v13 = (v10 - v9) >> 3;
    do
    {
      unint64_t v14 = v13 >> 1;
      double v15 = (unint64_t *)&v12[8 * (v13 >> 1)];
      unint64_t v17 = *v15;
      __double2 v16 = v15 + 1;
      v13 += ~(v13 >> 1);
      if (v17 < location) {
        uint64_t v12 = v16;
      }
      else {
        unint64_t v13 = v14;
      }
    }
    while (v13);
  }
  if (v11 <= (v12 - v9) >> 3)
  {
LABEL_32:
    __break(1u);
  }
  else
  {
    v18.unint64_t location = ((v12 - v9) >> 3) - (*(void *)&v9[8 * ((v12 - v9) >> 3)] != location);
    if (v10 != v12)
    {
      unint64_t v19 = (v10 - v12) >> 3;
      do
      {
        unint64_t v20 = v19 >> 1;
        double v21 = (unint64_t *)&v12[8 * (v19 >> 1)];
        unint64_t v23 = *v21;
        double v22 = v21 + 1;
        v19 += ~(v19 >> 1);
        if (v23 < (unint64_t)v5) {
          uint64_t v12 = v22;
        }
        else {
          unint64_t v19 = v20;
        }
      }
      while (v19);
      unint64_t v11 = (v12 - v9) >> 3;
    }
    v18.CFIndex length = v11 - v18.location;
    return PageLayout::CreateSelectionForTextRange((PageLayout *)this, v18);
  }
  return result;
}

void sub_184F03BA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *PageLayout::CreateSelectionForTextRange(PageLayout *this, CFRange a2)
{
  uint64_t v2 = 0;
  if ((a2.location & 0x8000000000000000) == 0)
  {
    CFIndex length = a2.length;
    if (a2.length >= 1)
    {
      CFIndex location = a2.location;
      if (a2.location + a2.length <= (uint64_t)(*((void *)this + 14) - *((void *)this + 13)) >> 5)
      {
        uint64_t v2 = (void *)CGPDFSelectionCreateWithPage(*(const void **)this);
        LineIndedouble x = PageLayout::getLineIndex(*((PageLayout **)this + 4), *((PageLayout **)this + 5), location);
        unint64_t v7 = LineIndex;
        unint64_t v9 = (unint64_t *)v2[24];
        unint64_t v8 = v2[25];
        if ((unint64_t)v9 >= v8)
        {
          uint64_t v11 = v2[23];
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v11) >> 3);
          unint64_t v13 = v12 + 1;
          if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v11) >> 3);
          if (2 * v14 > v13) {
            unint64_t v13 = 2 * v14;
          }
          if (v14 >= 0x555555555555555) {
            unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v15 = v13;
          }
          __double2 v16 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v15);
          unint64_t v17 = (unint64_t *)&v16[24 * v12];
          unint64_t v19 = &v16[24 * v18];
          unint64_t *v17 = v7;
          v17[1] = location;
          _OWORD v17[2] = length;
          uint64_t v10 = v17 + 3;
          double v21 = (char *)v2[23];
          unint64_t v20 = (char *)v2[24];
          if (v20 != v21)
          {
            do
            {
              long long v22 = *(_OWORD *)(v20 - 24);
              *(v17 - 1) = *((void *)v20 - 1);
              *(_OWORD *)(v17 - 3) = v22;
              v17 -= 3;
              v20 -= 24;
            }
            while (v20 != v21);
            unint64_t v20 = (char *)v2[23];
          }
          v2[23] = v17;
          v2[24] = v10;
          v2[25] = v19;
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          *unint64_t v9 = LineIndex;
          v9[1] = location;
          uint64_t v10 = v9 + 3;
          _OWORD v9[2] = length;
        }
        v2[24] = v10;
        Selection::Normalize((Selection *)(v2 + 21));
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

void ___ZNK10PageLayout29CreateSelectionForStringRangeE7CFRange_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3)
{
  LineIndedouble x = PageLayout::getLineIndex(*(PageLayout **)(*(void *)(a1 + 32) + 32), *(PageLayout **)(*(void *)(a1 + 32) + 40), a2);
  unint64_t v7 = LineIndex;
  unint64_t v8 = *(void **)(a1 + 40);
  uint64_t v10 = (unint64_t *)v8[3];
  unint64_t v9 = v8[4];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = v8[2];
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v10 - v12) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v12) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    unint64_t v17 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v16);
    uint64_t v18 = (unint64_t *)&v17[24 * v13];
    unint64_t v20 = &v17[24 * v19];
    *uint64_t v18 = v7;
    v18[1] = a2;
    void v18[2] = a3;
    uint64_t v11 = v18 + 3;
    long long v22 = (char *)v8[2];
    double v21 = (char *)v8[3];
    if (v21 != v22)
    {
      do
      {
        long long v23 = *(_OWORD *)(v21 - 24);
        *(v18 - 1) = *((void *)v21 - 1);
        *(_OWORD *)(v18 - 3) = v23;
        v18 -= 3;
        v21 -= 24;
      }
      while (v21 != v22);
      double v21 = (char *)v8[2];
    }
    _OWORD v8[2] = v18;
    _OWORD v8[3] = v11;
    v8[4] = v20;
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *uint64_t v10 = LineIndex;
    v10[1] = a2;
    uint64_t v11 = v10 + 3;
    v10[2] = a3;
  }
  _OWORD v8[3] = v11;
}

void *PageLayout::convertStringRangeIndexToTextRangeIndex(void *this, void *a2, unint64_t a3)
{
  uint64_t v3 = this;
  unint64_t v4 = a2 - this;
  if (a2 != this)
  {
    uint64_t v3 = this;
    unint64_t v5 = a2 - this;
    do
    {
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = &v3[v5 >> 1];
      unint64_t v9 = *v7;
      unint64_t v8 = v7 + 1;
      v5 += ~(v5 >> 1);
      if (v9 < a3) {
        uint64_t v3 = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
  }
  if (*v3 == a3) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = -1;
  }
  uint64_t v11 = (char *)&v3[v10] - (char *)this;
  unint64_t v12 = v11 >> 3;
  uint64_t v13 = v4 - 1;
  if (v11 >> 3 > v4 - 1) {
    uint64_t v13 = v11 >> 3;
  }
  if (v12 <= v4) {
    uint64_t v14 = a2 - this;
  }
  else {
    uint64_t v14 = v11 >> 3;
  }
  for (uint64_t i = (void *)((char *)this + (v11 & 0xFFFFFFFFFFFFFFF8) + 8); ; ++i)
  {
    if (v13 == v12) {
      return (void *)v13;
    }
    if (v14 == v12) {
      break;
    }
    if (v4 <= ++v12) {
      break;
    }
    uint64_t v16 = *(i - 1);
    uint64_t v17 = *i;
    if (v16 != v17) {
      return (void *)(v12 - 1);
    }
  }
  __break(1u);
  return this;
}

unint64_t PageLayout::getLineIndex(PageLayout *this, PageLayout *a2, uint64_t a3)
{
  uint64_t v3 = this;
  if (a2 != this)
  {
    unint64_t v4 = 0x8E38E38E38E38E39 * ((a2 - this) >> 3);
    uint64_t v3 = this;
    do
    {
      unint64_t v5 = v4 >> 1;
      unint64_t v6 = (uint64_t *)((char *)v3 + 72 * (v4 >> 1));
      uint64_t v8 = *v6;
      unint64_t v7 = (PageLayout *)(v6 + 9);
      v4 += ~(v4 >> 1);
      if (v8 < a3) {
        uint64_t v3 = v7;
      }
      else {
        unint64_t v4 = v5;
      }
    }
    while (v4);
  }
  if (v3 == a2 || *(void *)v3 != a3) {
    uint64_t v3 = (PageLayout *)((char *)v3 - 72);
  }
  return 0x8E38E38E38E38E39 * ((v3 - this) >> 3);
}

void PageLayout::getTextRangeIndex(CGPoint,CGPDFSelectionType,SelectionPrecision)const::$_1::operator()(uint64_t a1, unint64_t *a2, void *a3, char a4)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v8 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex((void *)a1, *a3 - 1);
    unint64_t v9 = PageLayout::convertRTLTextRangeIndexToStringRangeIndex((void *)a1, *a2);
    unint64_t v10 = *a3 - *a2;
    v24[0] = *a2;
    v24[1] = v10;
    __p = 0;
    long long v22 = 0;
    uint64_t v23 = 0;
    v20[0] = v24;
    v20[1] = 1;
    p_p = &__p;
    PageLayout::ConvertTextRangesToStringRanges<std::span<CFRange,18446744073709551615ul>,std::back_insert_iterator<std::vector<CFRange>>>(a1, (uint64_t)v20, &p_p);
    uint64_t v11 = __p;
    if (__p != v22)
    {
      unint64_t v12 = *(void *)__p;
      uint64_t v13 = *(void *)(a1 + 296);
      unint64_t v14 = (*(void *)(a1 + 304) - v13) >> 3;
      if ((int64_t)(v14 - 1) < *(void *)__p) {
        unint64_t v12 = v14 - 1;
      }
      if ((uint64_t)(v14 - 1) >= (uint64_t)(v12 + *((void *)__p + 1))) {
        unint64_t v15 = v12 + *((void *)__p + 1);
      }
      else {
        unint64_t v15 = v14 - 1;
      }
      if (v12 != v15)
      {
        if (v14 <= v12
          || (*a2 = (unint64_t)PageLayout::convertStringRangeIndexToTextRangeIndex(*(void **)(a1 + 152), *(void **)(a1 + 160), *(void *)(v13 + 8 * v12)), uint64_t v16 = *(void *)(a1 + 296), v15 >= (*(void *)(a1 + 304) - v16) >> 3))
        {
          __break(1u);
          return;
        }
        uint64_t v17 = PageLayout::convertStringRangeIndexToTextRangeIndex(*(void **)(a1 + 152), *(void **)(a1 + 160), *(void *)(v16 + 8 * v15));
        *a3 = v17;
        if ((a4 & 1) == 0 && (uint64_t)v8 < (uint64_t)v9)
        {
          unint64_t v18 = *a2;
          *a2 = (unint64_t)v17;
          *a3 = v18;
        }
      }
      uint64_t v11 = __p;
    }
    if (v11)
    {
      long long v22 = v11;
      operator delete(v11);
    }
  }
}

void sub_184F040DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *PageLayout::getWordRange(void *this, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = this[4];
  if (0x8E38E38E38E38E39 * ((this[5] - v3) >> 3) > a2)
  {
    unint64_t v5 = this;
    unint64_t v6 = (int64_t *)(v3 + 72 * a2);
    int64_t v7 = *v6;
    int64_t v8 = v6[1];
    unint64_t v9 = v6[2];
    BOOL v10 = __OFSUB__(a3, *v6);
    uint64_t v11 = a3 - *v6;
    if (!((v11 < 0) ^ v10 | (v11 == 0)))
    {
      uint64_t v12 = this[10];
      unint64_t v13 = (this[11] - v12) >> 3;
      BOOL v14 = v13 >= v7;
      unint64_t v15 = v13 - v7;
      if (!v14) {
        unint64_t v15 = 0;
      }
      uint64_t v16 = (uint64_t *)(v12 + 8 * v7);
      while (v15 > ~v7 + a3)
      {
        uint64_t v17 = *v16++;
        v9 += v17;
        if (!--v11) {
          goto LABEL_8;
        }
      }
      goto LABEL_100;
    }
LABEL_8:
    uint64_t v18 = this[7];
    if (v9 >= (this[8] - v18) >> 1) {
      return 0;
    }
    int v19 = MEMORY[0x18532B8C0](*(unsigned __int16 *)(v18 + 2 * v9));
    unint64_t v20 = [MEMORY[0x1E4F28E58] punctuationCharacterSet];
    double v21 = [MEMORY[0x1E4F28B88] whitespaceCharacterSet];
    [v20 formUnionWithCharacterSet:v21];

    this = v20;
    uint64_t v22 = v5[7];
    if (v9 < (v5[8] - v22) >> 1)
    {
      uint64_t v23 = this;
      this = (void *)MEMORY[0x18532B8C0](*(unsigned __int16 *)(v22 + 2 * v9));
      BOOL v25 = this != 10 && this != 17;
      if (v19 == this) {
        BOOL v25 = 0;
      }
      BOOL v26 = v19 == 10 || v19 == 17;
      int v27 = v26 ? (int)this : v19;
      BOOL v28 = !v26 && v25;
      uint64_t v29 = v5[10];
      if (a3 < (v5[11] - v29) >> 3)
      {
        if (*(void *)(v29 + 8 * a3) != 1)
        {
          if (!v28)
          {
LABEL_31:
            if ((uint64_t)a3 > v7)
            {
              unint64_t v31 = a3 - 1;
              unint64_t v32 = v9;
              while (1)
              {
                uint64_t v33 = v5[7];
                if (v32 >= (v5[8] - v33) >> 1) {
                  goto LABEL_100;
                }
                this = (void *)MEMORY[0x18532B8C0](*(unsigned __int16 *)(v33 + 2 * v32));
                BOOL v35 = this != 10 && this != 17;
                if (v27 == this) {
                  BOOL v35 = 0;
                }
                if (v27 == 17) {
                  int v36 = (int)this;
                }
                else {
                  int v36 = v27;
                }
                if (v27 == 17) {
                  BOOL v35 = 0;
                }
                BOOL v37 = v27 == 10;
                int v27 = v27 == 10 ? (int)this : v36;
                BOOL v38 = !v37 && v35;
                uint64_t v39 = v5[10];
                unint64_t v40 = (v5[11] - v39) >> 3;
                if (v40 <= a3) {
                  goto LABEL_100;
                }
                if (*(void *)(v39 + 8 * a3) == 1)
                {
                  uint64_t v41 = v5[7];
                  if (v32 >= (v5[8] - v41) >> 1) {
                    goto LABEL_100;
                  }
                  this = (void *)[v23 characterIsMember:*(unsigned __int16 *)(v41 + 2 * v32)];
                  if ((this | v38))
                  {
LABEL_67:
                    unint64_t v43 = v31 + 2;
                    goto LABEL_68;
                  }
                  uint64_t v39 = v5[10];
                  unint64_t v40 = (v5[11] - v39) >> 3;
                }
                else if (v38)
                {
                  goto LABEL_67;
                }
                if (v40 <= v31) {
                  goto LABEL_100;
                }
                v32 -= *(void *)(v39 + 8 * v31);
                if ((uint64_t)v31-- <= v7)
                {
                  unint64_t v43 = v7;
                  goto LABEL_68;
                }
              }
            }
            unint64_t v43 = a3;
LABEL_68:
            int64_t v44 = v8 + v7;
            if (v44 > (uint64_t)a3)
            {
              unint64_t v45 = a3;
              while (1)
              {
                uint64_t v46 = v5[7];
                if (v9 >= (v5[8] - v46) >> 1) {
                  goto LABEL_100;
                }
                this = (void *)MEMORY[0x18532B8C0](*(unsigned __int16 *)(v46 + 2 * v9));
                BOOL v48 = this != 10 && this != 17;
                if (v27 == this) {
                  BOOL v48 = 0;
                }
                if (v27 == 17) {
                  int v49 = (int)this;
                }
                else {
                  int v49 = v27;
                }
                if (v27 == 17) {
                  BOOL v48 = 0;
                }
                BOOL v50 = v27 == 10;
                int v27 = v27 == 10 ? (int)this : v49;
                BOOL v51 = !v50 && v48;
                uint64_t v52 = v5[10];
                unint64_t v53 = (v5[11] - v52) >> 3;
                if (v53 <= a3) {
                  goto LABEL_100;
                }
                if (*(void *)(v52 + 8 * a3) == 1)
                {
                  uint64_t v54 = v5[7];
                  if (v9 >= (v5[8] - v54) >> 1) {
                    goto LABEL_100;
                  }
                  this = (void *)[v23 characterIsMember:*(unsigned __int16 *)(v54 + 2 * v9)];
                  if ((this | v51)) {
                    goto LABEL_98;
                  }
                  uint64_t v52 = v5[10];
                  unint64_t v53 = (v5[11] - v52) >> 3;
                }
                else if (v51)
                {
                  goto LABEL_98;
                }
                if (v53 <= v45) {
                  goto LABEL_100;
                }
                v9 += *(void *)(v52 + 8 * v45++);
                if (v44 == v45) {
                  goto LABEL_98;
                }
              }
            }
            goto LABEL_98;
          }
LABEL_65:
          unint64_t v43 = a3;
LABEL_98:

          return (void *)v43;
        }
        uint64_t v30 = v5[7];
        if (v9 < (v5[8] - v30) >> 1)
        {
          this = (void *)[v23 characterIsMember:*(unsigned __int16 *)(v30 + 2 * v9)];
          if (((this | v28) & 1) == 0) {
            goto LABEL_31;
          }
          goto LABEL_65;
        }
      }
    }
  }
LABEL_100:
  __break(1u);
  return this;
}

void sub_184F04488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id PageLayout::CreateAttributedStringForStringRanges(uint64_t a1, uint64_t a2)
{
  v52[3] = *MEMORY[0x1E4F143B8];
  uint64_t v47 = 0;
  BOOL v48 = &v47;
  uint64_t v49 = 0x2020000000;
  unint64_t v4 = (id *)getkCTFontAttributeNameSymbolLoc(void)::ptr;
  uint64_t v50 = getkCTFontAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTFontAttributeNameSymbolLoc(void)::ptr)
  {
    v44.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
    v44.__r_.__value_.__l.__size_ = 3221225472;
    v44.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL32getkCTFontAttributeNameSymbolLocv_block_invoke;
    unint64_t v45 = (NSString *)&unk_1E52CD918;
    uint64_t v46 = &v47;
    unint64_t v5 = (void *)CoreTextLibrary();
    v48[3] = (uint64_t)dlsym(v5, "kCTFontAttributeName");
    getkCTFontAttributeNameSymbolLoc(void)::ptr = *(void *)(v46[1] + 24);
    unint64_t v4 = (id *)v48[3];
  }
  _Block_object_dispose(&v47, 8);
  if (!v4) {
    goto LABEL_32;
  }
  id v41 = *v4;
  id v42 = (id)kCGPDFSelectionForegroundColorAttributeName;
  uint64_t v47 = 0;
  BOOL v48 = &v47;
  uint64_t v49 = 0x2020000000;
  unint64_t v6 = (id *)getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  uint64_t v50 = getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr;
  if (!getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr)
  {
    v44.__r_.__value_.__r.__words[0] = MEMORY[0x1E4F143A8];
    v44.__r_.__value_.__l.__size_ = 3221225472;
    v44.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZL42getkCTBaselineOffsetAttributeNameSymbolLocv_block_invoke;
    unint64_t v45 = (NSString *)&unk_1E52CD918;
    uint64_t v46 = &v47;
    int64_t v7 = (void *)CoreTextLibrary();
    v48[3] = (uint64_t)dlsym(v7, "kCTBaselineOffsetAttributeName");
    getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = *(void *)(v46[1] + 24);
    unint64_t v6 = (id *)v48[3];
  }
  _Block_object_dispose(&v47, 8);
  if (!v6)
  {
LABEL_32:
    dlerror();
    abort_report_np();
    goto LABEL_33;
  }
  id v40 = *v6;
  id v36 = objc_alloc_init(MEMORY[0x1E4F28E48]);
  NSUInteger range2 = [*(id *)(a1 + 24) length];
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8)
  {
    unint64_t v9 = *(NSRange **)a2;
    uint64_t v37 = *(void *)a2 + 16 * v8;
    do
    {
      uint64_t v39 = v9;
      v53.CFIndex location = 0;
      v53.CFIndex length = range2;
      NSRange v10 = NSIntersectionRange(*v9, v53);
      if (v10.length)
      {
        id v11 = objc_alloc(MEMORY[0x1E4F28E48]);
        uint64_t v12 = objc_msgSend(*(id *)(a1 + 24), "substringWithRange:", v10.location, v10.length);
        unint64_t v43 = (void *)[v11 initWithString:v12];

        if ((uint64_t)v10.length >= 1)
        {
          uint64_t v13 = 0;
          NSUInteger v14 = 8 * v10.location;
          while (1)
          {
            uint64_t v15 = *(void *)(a1 + 200);
            if (v10.location + v13 >= (*(void *)(a1 + 208) - v15) >> 3) {
              break;
            }
            unint64_t v16 = *(void *)(v15 + v14 + 8 * v13);
            uint64_t v17 = *(void *)(a1 + 176);
            if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 184) - v17) >> 3) <= v16) {
              break;
            }
            unint64_t v18 = *(void *)(v17 + 24 * v16);
            uint64_t v19 = *(void *)(a1 + 248);
            if (v18 >= (*(void *)(a1 + 256) - v19) >> 5) {
              break;
            }
            unint64_t v20 = (long long *)(v19 + 32 * v18);
            if (*((char *)v20 + 23) < 0)
            {
              std::string::__init_copy_ctor_external(&v44, *(const std::string::value_type **)v20, *((void *)v20 + 1));
            }
            else
            {
              long long v21 = *v20;
              v44.__r_.__value_.__r.__words[2] = *((void *)v20 + 2);
              *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v21;
            }
            LODWORD(v45) = *(_DWORD *)(v19 + 32 * v18 + 24);
            double v22 = *(double *)(v17 + 24 * v16 + 8);
            uint64_t v23 = (v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &v44
                : (std::string *)v44.__r_.__value_.__r.__words[0];
            BOOL v24 = [NSString stringWithUTF8String:v23];
            uint64_t v25 = *(void *)(a1 + 224);
            if (v10.location + v13 >= (*(void *)(a1 + 232) - v25) >> 3) {
              break;
            }
            BOOL v26 = v24;
            double v27 = *(double *)(v25 + v14 + 8 * v13);
            CTFont = (void *)PageLayout::CreateCTFont(v24, (NSString *)v45, v22);
            v52[0] = CTFont;
            v51[0] = v41;
            v51[1] = v42;
            uint64_t v29 = v17 + 24 * v16;
            uint64_t v30 = *(void **)(v29 + 16);
            if (v30) {
              CFRetain(*(CFTypeRef *)(v29 + 16));
            }
            v52[1] = v30;
            v51[2] = v40;
            unint64_t v31 = [NSNumber numberWithDouble:v27];
            v52[2] = v31;
            unint64_t v32 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v52 forKeys:v51 count:3];
            objc_msgSend(v43, "setAttributes:range:", v32, v13, 1);

            if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v44.__r_.__value_.__l.__data_);
            }
            if (v10.length == ++v13) {
              goto LABEL_27;
            }
          }
LABEL_33:
          __break(1u);
        }
LABEL_27:
        [v36 appendAttributedString:v43];
      }
      unint64_t v9 = v39 + 1;
    }
    while (&v39[1] != (NSRange *)v37);
  }
  uint64_t v33 = [v36 string];
  BOOL v34 = objc_msgSend(v33, "characterAtIndex:", objc_msgSend(v36, "length") - 1) == 10;

  if (v34) {
    objc_msgSend(v36, "deleteCharactersInRange:", objc_msgSend(v36, "length") - 1, 1);
  }

  return v36;
}

void sub_184F049C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Unwind_Resume(a1);
}

void *___ZL32getkCTFontAttributeNameSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreTextLibrary();
  uint64_t result = dlsym(v2, "kCTFontAttributeName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCTFontAttributeNameSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreTextLibrary(void)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!CoreTextLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = ___ZL19CoreTextLibraryCorePPc_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E52C82C0;
    uint64_t v5 = 0;
    CoreTextLibraryCore(char **)::frameworkLibrardouble y = _sl_dlopen();
    id v1 = (void *)v3[0];
    uint64_t v0 = CoreTextLibraryCore(char **)::frameworkLibrary;
    if (CoreTextLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      id v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return CoreTextLibraryCore(char **)::frameworkLibrary;
}

void *___ZL42getkCTBaselineOffsetAttributeNameSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreTextLibrary();
  uint64_t result = dlsym(v2, "kCTBaselineOffsetAttributeName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkCTBaselineOffsetAttributeNameSymbolLoc(void)::ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t PageLayout::CreateCTFont(PageLayout *this, NSString *a2, double a3)
{
  char v3 = (char)a2;
  uint64_t v5 = this;
  if ((unint64_t)[(PageLayout *)v5 length] >= 8
    && [(PageLayout *)v5 characterAtIndex:6] == 43)
  {
    uint64_t v7 = [(PageLayout *)v5 substringFromIndex:7];

    uint64_t v5 = (PageLayout *)v7;
  }
  uint64_t v8 = CTFontCreateWithName((const __CFString *)v5, a3, v6);
  if (!v8)
  {
    uint64_t v9 = [&unk_1ED0AD950 objectForKey:v5];
    id v11 = @"Monaco";
    if (v3)
    {
      uint64_t v12 = @"Courier";
    }
    else
    {
      id v11 = @"Helvetica";
      uint64_t v12 = @"Times";
    }
    if ((v3 & 2) != 0) {
      id v11 = v12;
    }
    if (v9) {
      uint64_t v13 = (__CFString *)v9;
    }
    else {
      uint64_t v13 = v11;
    }
    uint64_t v8 = CTFontCreateWithName(v13, a3, v10);
  }
  return v8;
}

void sub_184F04D60(_Unwind_Exception *a1)
{
  char v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t CTFontCreateWithName(const __CFString *a1, double a2, const CGAffineTransform *a3)
{
  uint64_t v9 = 0;
  NSRange v10 = &v9;
  uint64_t v11 = 0x2020000000;
  uint64_t v5 = (uint64_t (*)(const __CFString *, void, double))getCTFontCreateWithNameSymbolLoc(void)::ptr;
  uint64_t v12 = getCTFontCreateWithNameSymbolLoc(void)::ptr;
  if (!getCTFontCreateWithNameSymbolLoc(void)::ptr)
  {
    uint64_t v6 = (void *)CoreTextLibrary();
    _OWORD v10[3] = (uint64_t)dlsym(v6, "CTFontCreateWithName");
    getCTFontCreateWithNameSymbolLoc(void)::ptr = (_UNKNOWN *)v10[3];
    uint64_t v5 = (uint64_t (*)(const __CFString *, void, double))v10[3];
  }
  _Block_object_dispose(&v9, 8);
  if (!v5)
  {
    dlerror();
    uint64_t v8 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v9, 8);
    _Unwind_Resume(v8);
  }
  return v5(a1, 0, a2);
}

void *___ZL32getCTFontCreateWithNameSymbolLocv_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreTextLibrary();
  uint64_t result = dlsym(v2, "CTFontCreateWithName");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCTFontCreateWithNameSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL19CoreTextLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreTextLibraryCore(char **)::frameworkLibrardouble y = result;
  return result;
}

void PageLayout::GetBoundsForRangeWithinLine(void *a1, unint64_t a2, unint64_t a3, unint64_t LineIndex, char a5)
{
  uint64_t v5 = a1[13];
  unint64_t v6 = (a1[14] - v5) >> 5;
  BOOL v7 = v6 >= a2;
  unint64_t v8 = v6 - a2;
  if (!v7) {
    goto LABEL_16;
  }
  if (a3 == -1)
  {
    a3 = v8;
    if (v8)
    {
LABEL_6:
      uint64_t v13 = (CGRect *)(v5 + 32 * a2);
      NSUInteger v14 = &v13[a3];
      CGFloat width = 0.0;
      CGFloat x = INFINITY;
      CGFloat y = INFINITY;
      CGFloat height = 0.0;
      do
      {
        v23.origin.CGFloat x = x;
        v23.origin.CGFloat y = y;
        v23.size.CGFloat width = width;
        v23.size.CGFloat height = height;
        CGRect v24 = CGRectUnion(v23, *v13);
        CGFloat x = v24.origin.x;
        CGFloat y = v24.origin.y;
        CGFloat width = v24.size.width;
        CGFloat height = v24.size.height;
        ++v13;
      }
      while (v13 != v14);
      goto LABEL_11;
    }
  }
  else
  {
    if (v8 < a3) {
      goto LABEL_16;
    }
    if (a3) {
      goto LABEL_6;
    }
  }
  CGFloat height = 0.0;
  CGFloat y = INFINITY;
  CGFloat width = 0.0;
  CGFloat x = INFINITY;
LABEL_11:
  if (a5)
  {
    uint64_t v19 = (PageLayout *)a1[4];
    unint64_t v20 = (PageLayout *)a1[5];
  }
  else
  {
    uint64_t v19 = (PageLayout *)a1[4];
    unint64_t v20 = (PageLayout *)a1[5];
    LineIndeCGFloat x = PageLayout::getLineIndex(v19, v20, a2);
  }
  if (0x8E38E38E38E38E39 * ((v20 - v19) >> 3) > LineIndex)
  {
    __double2 v21 = __sincos_stret(*((double *)v19 + 9 * LineIndex + 7));
    v22.double a = v21.__cosval;
    v22.double b = v21.__sinval;
    v22.double c = -v21.__sinval;
    v22.double d = v21.__cosval;
    v22.tCGFloat x = 0.0;
    v22.tCGFloat y = 0.0;
    v25.origin.CGFloat x = x;
    v25.origin.CGFloat y = y;
    v25.size.CGFloat width = width;
    v25.size.CGFloat height = height;
    CGRectApplyAffineTransform(v25, &v22);
    return;
  }
LABEL_16:
  __break(1u);
}

void PageLayout::GetBoundsForTextRange(PageLayout *this, CFRange a2)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  uint64_t v5 = (PageLayout *)*((void *)this + 4);
  unint64_t v6 = (PageLayout *)*((void *)this + 5);
  LineIndeCGFloat x = PageLayout::getLineIndex(v5, v6, a2.location);
  if (0x8E38E38E38E38E39 * ((v6 - v5) >> 3) <= LineIndex)
  {
LABEL_11:
    __break(1u);
    return;
  }
  unint64_t v8 = LineIndex;
  uint64_t v9 = (void *)((char *)v5 + 72 * LineIndex);
  CFIndex v10 = length + location;
  CFIndex v11 = v9[1] + *v9;
  if (length + location > v11)
  {
    uint64_t v12 = 72 * LineIndex;
    CGFloat height = 0.0;
    CGFloat y = INFINITY;
    CGFloat width = 0.0;
    CGFloat x = INFINITY;
    while (1)
    {
      CFIndex v17 = v11;
      PageLayout::GetBoundsForRangeWithinLine(this, location, v11 - location, v8++, 1);
      uint64_t v22 = *((void *)this + 4);
      if (0x8E38E38E38E38E39 * ((*((void *)this + 5) - v22) >> 3) <= v8) {
        goto LABEL_11;
      }
      v38.origin.CGFloat x = v18;
      v38.origin.CGFloat y = v19;
      v38.size.CGFloat width = v20;
      v38.size.CGFloat height = v21;
      v36.origin.CGFloat x = x;
      v36.origin.CGFloat y = y;
      v36.size.CGFloat width = width;
      v36.size.CGFloat height = height;
      CGRect v37 = CGRectUnion(v36, v38);
      CGFloat x = v37.origin.x;
      CGFloat y = v37.origin.y;
      CGFloat width = v37.size.width;
      CGFloat height = v37.size.height;
      CFIndex v11 = *(void *)(v22 + v12 + 80) + *(void *)(v22 + v12 + 72);
      v12 += 72;
      CFIndex location = v17;
      if (v10 <= v11)
      {
        CFIndex length = v10 - v17;
        CFIndex location = v17;
        goto LABEL_8;
      }
    }
  }
  CGFloat height = 0.0;
  CGFloat y = INFINITY;
  CGFloat width = 0.0;
  CGFloat x = INFINITY;
LABEL_8:
  PageLayout::GetBoundsForRangeWithinLine(this, location, length, v8, 1);
  uint64_t v24 = v23;
  uint64_t v26 = v25;
  uint64_t v28 = v27;
  uint64_t v30 = v29;
  CGFloat v31 = x;
  CGFloat v32 = y;
  CGFloat v33 = width;
  CGFloat v34 = height;

  CGRectUnion(*(CGRect *)&v31, *(CGRect *)&v24);
}

void ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke(double *a1)
{
  uint64_t v2 = *((void *)a1 + 5);
  char v3 = (os_unfair_lock_s *)(v2 + 376);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 376));
  *(unsigned char *)(v2 + 380) = 1;
  uint64_t v15 = v2;
  long long v4 = CGPDFLayoutCreateWithPage(*(void *)v2);
  uint64_t v5 = v4;
  if (v4) {
    unint64_t v6 = (__n64 *)*((void *)v4 + 13);
  }
  else {
    unint64_t v6 = 0;
  }
  _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(&v15, v6, (uint64_t)&v15);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v7 = *((void *)a1 + 4);
  uint64_t v8 = *((void *)a1 + 6);
  uint64_t v9 = *(void *)(v8 + 384);
  uint64_t v10 = *(void *)(v8 + 392);
  if (v9 == v10)
  {
    NSUInteger v14 = &CGRectNull;
  }
  else
  {
    uint64_t v11 = 0;
    CGFloat v12 = a1[7];
    CGFloat v13 = a1[8];
    do
    {
      v17.CGFloat x = v12;
      v17.CGFloat y = v13;
      if (CGRectContainsPoint(*(CGRect *)v9, v17) && (!v11 || *(void *)(v9 + 32) >= *(void *)(v11 + 32))) {
        uint64_t v11 = v9;
      }
      v9 += 40;
    }
    while (v9 != v10);
    NSUInteger v14 = &CGRectNull;
    if (v11) {
      NSUInteger v14 = (const CGRect *)v11;
    }
  }
  (*(void (**)(uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(v7 + 16))(v7, v14->origin.x, v14->origin.y, v14->size.width, v14->size.height);

  os_unfair_lock_unlock(v3);
}

void sub_184F053E8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(void *a1, __n64 *a2, uint64_t a3)
{
  if (a2)
  {
    char v3 = a2;
    if (a2->n64_u32[0] == 515)
    {
      long long v4 = (void *)*a1;
      v5.n64_u64[0] = CGPDFNodeGetBounds(a2).n64_u64[0];
      unint64_t v9 = v5.n64_u64[0];
      unint64_t v10 = v6.n64_u64[0];
      unint64_t v11 = v7.n64_u64[0];
      unint64_t v12 = v8.n64_u64[0];
      while ((v3->n64_u8[1] & 3) == 0)
      {
        char v3 = (__n64 *)v3[1].n64_u64[0];
        if (!v3) {
          goto LABEL_17;
        }
      }
      char v3 = (__n64 *)v3[12].n64_u64[0];
LABEL_17:
      CGPoint v17 = (__n64 *)v4[49];
      unint64_t v18 = v4[50];
      if ((unint64_t)v17 >= v18)
      {
        unint64_t v20 = 0x666666666666666;
        CGFloat v21 = (__n64 *)v4[48];
        unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * (v17 - v21);
        unint64_t v23 = v22 + 1;
        if (v22 + 1 > 0x666666666666666) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v24 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v18 - (void)v21) >> 3);
        if (2 * v24 > v23) {
          unint64_t v23 = 2 * v24;
        }
        if (v24 < 0x333333333333333) {
          unint64_t v20 = v23;
        }
        if (v20)
        {
          unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::Column>>(v20);
          CGFloat v21 = (__n64 *)v4[48];
          CGPoint v17 = (__n64 *)v4[49];
        }
        else
        {
          uint64_t v25 = 0;
        }
        uint64_t v26 = (unint64_t *)(v20 + 40 * v22);
        *uint64_t v26 = v9;
        v26[1] = v10;
        unint64_t v27 = v20 + 40 * v25;
        v26[2] = v11;
        v26[3] = v12;
        v26[4] = (unint64_t)v3;
        CGFloat v19 = (__n64 *)(v26 + 5);
        if (v17 != v21)
        {
          do
          {
            long long v28 = *(_OWORD *)v17[-5].n64_u64;
            long long v29 = *(_OWORD *)v17[-3].n64_u64;
            *(v26 - 1) = v17[-1].n64_u64[0];
            *(_OWORD *)(v26 - 3) = v29;
            *(_OWORD *)(v26 - 5) = v28;
            v26 -= 5;
            v17 -= 5;
          }
          while (v17 != v21);
          CGFloat v21 = (__n64 *)v4[48];
        }
        v4[48] = v26;
        v4[49] = v19;
        v4[50] = v27;
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        v17->n64_u64[0] = v5.n64_u64[0];
        v17[1].n64_u64[0] = v6.n64_u64[0];
        v17[2].n64_u64[0] = v7.n64_u64[0];
        v17[3].n64_u64[0] = v8.n64_u64[0];
        CGFloat v19 = v17 + 5;
        v17[4].n64_u64[0] = (unint64_t)v3;
      }
      v4[49] = v19;
    }
    else if ((a2->n64_u32[0] & 0x200) != 0)
    {
      uint64_t v13 = a2[5].n64_u32[1];
      if (v13)
      {
        for (unint64_t i = 0; i != v13; ++i)
        {
          if ((v3->n64_u8[1] & 2) != 0 && i < v3[5].n64_u32[1]) {
            uint64_t v16 = *(void *)(v3[7].n64_u64[0] + 8 * i);
          }
          else {
            uint64_t v16 = 0;
          }
          _ZZZN10PageLayout36GetColumnBoundsAtPointWithCompletionE7CGPointPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFv6CGRectEEUb_ENK3__4clIRS7_EEDaP9CGPDFNodeOT_(a3, v16, a3);
        }
      }
    }
  }
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<PageLayout::Column>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(40 * a1);
}

BOOL std::__equal_to::operator()[abi:fe180100]<CGRect,CGRect>(CGRect *a1, CGRect *a2)
{
  return CGRectEqualToRect(*a1, *a2);
}

void PageLayout::getWordsInLine(PageLayout *this, const TextLine *a2, unint64_t *a3)
{
  uint64_t v43 = 0;
  std::string v44 = &v43;
  uint64_t v45 = 0x4812000000;
  uint64_t v46 = __Block_byref_object_copy__11682;
  uint64_t v47 = __Block_byref_object_dispose__11683;
  BOOL v48 = "";
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  __p = 0;
  unint64_t v6 = *a3;
  int64_t v5 = a3[1];
  uint64_t v7 = a3[2];
  memset(v42, 0, sizeof(v42));
  if (v5 < 1)
  {
LABEL_9:
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)&a2->rotation + 2 * v7;
  }
  else
  {
    int64_t v8 = v5 + v6;
    int64_t length = a2[1].textRange.length;
    uint64_t v10 = a2[1].uniCharStart - length;
    if (v6 <= v10 >> 3) {
      uint64_t v11 = v10 >> 3;
    }
    else {
      uint64_t v11 = v6;
    }
    unint64_t v12 = v6;
    while (1)
    {
      if (v11 == v12) {
        std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
      }
      if (*(void *)(length + 8 * v12) != 1) {
        break;
      }
      if ((uint64_t)++v12 >= v8) {
        goto LABEL_9;
      }
    }
    std::vector<unsigned short>::resize(v42, v5);
    uint64_t v13 = v42[0];
    rotatiouint64_t n = a2->rotation;
    uint64_t v16 = a2->identifier - *(void *)&rotation;
    if (v7 < v16 >> 1)
    {
      uint64_t v17 = 0;
      unint64_t v18 = v16 >> 1;
      int64_t v19 = a2[1].textRange.length;
      unint64_t v20 = (int64_t)(a2[1].uniCharStart - v19) >> 3;
      BOOL v21 = v20 >= v6;
      unint64_t v22 = v20 - v6;
      if (!v21) {
        unint64_t v22 = 0;
      }
      while (1)
      {
        if (v22 == v17) {
          std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
        }
        uint64_t v23 = *(void *)(v19 + 8 * v6 + 8 * v17);
        int64_t v24 = v6 + 1 + v17;
        if (v23 != 2 || v24 >= v8)
        {
          if (v18 <= v7) {
            goto LABEL_40;
          }
          __int16 v26 = *(_WORD *)(*(void *)&rotation + 2 * v7);
          goto LABEL_20;
        }
        if (v18 <= v7) {
          goto LABEL_40;
        }
        if (*(_WORD *)(*(void *)&rotation + 2 * v7) != 102) {
          goto LABEL_27;
        }
        if (v18 <= v7 + 1) {
LABEL_40:
        }
          std::vector<unsigned long>::__throw_out_of_range[abi:fe180100]();
        int v27 = *(unsigned __int16 *)(*(void *)&rotation + 2 * (v7 + 1));
        if (v27 == 105) {
          break;
        }
        if (v27 == 108)
        {
          __int16 v26 = -1278;
LABEL_20:
          *(_WORD *)&v13[2 * v17] = v26;
        }
LABEL_27:
        if (v24 < v8)
        {
          v7 += v23;
          ++v17;
          if (v7 < (uint64_t)v18) {
            continue;
          }
        }
        goto LABEL_31;
      }
      __int16 v26 = -1279;
      goto LABEL_20;
    }
LABEL_31:
    uint64_t v14 = (uint64_t)v13;
  }
  long long v28 = (void *)[[NSString alloc] initWithCharacters:v14 length:v5];
  long long v29 = [MEMORY[0x1E4F28B88] whitespaceCharacterSet];
  uint64_t v30 = [v28 length];
  v38[0] = MEMORY[0x1E4F143A8];
  v38[1] = 3221225472;
  v38[2] = ___ZNK10PageLayout14getWordsInLineERKNS_8TextLineE_block_invoke;
  v38[3] = &unk_1E52C8260;
  id v31 = v28;
  id v39 = v31;
  id v32 = v29;
  id v40 = v32;
  id v41 = &v43;
  objc_msgSend(v31, "enumerateSubstringsInRange:options:usingBlock:", 0, v30, 515, v38);

  if (v13) {
    operator delete(v13);
  }
  CGFloat v33 = v44;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  BOOL v35 = (unsigned char *)v33[6];
  CGFloat v34 = (unsigned char *)v33[7];
  int64_t v36 = v34 - v35;
  if (v34 != v35)
  {
    std::vector<CFRange>::__vallocate[abi:fe180100](this, v36 >> 4);
    CGRect v37 = (char *)*((void *)this + 1);
    memmove(v37, v35, v36);
    *((void *)this + 1) = &v37[16 * (v36 >> 4)];
  }
  _Block_object_dispose(&v43, 8);
  if (__p)
  {
    uint64_t v50 = __p;
    operator delete(__p);
  }
}

void sub_184F05958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (a17) {
    operator delete(a17);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x184F058C4);
  }
  _Block_object_dispose(&a20, 8);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_184F05A1C()
{
}

__n128 __Block_byref_object_copy__11682(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__11683(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZNK10PageLayout14getWordsInLineERKNS_8TextLineE_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  id v28 = a2;
  uint64_t v9 = objc_msgSend(*(id *)(a1 + 32), "rangeOfCharacterFromSet:options:range:", *(void *)(a1 + 40), 4, a5, a6);
  uint64_t v11 = v10;
  if (v10)
  {
    uint64_t v12 = v9;
    uint64_t v13 = objc_msgSend(MEMORY[0x1E4F28E60], "indexSetWithIndexesInRange:", a5, a6);
    objc_msgSend(v13, "removeIndexesInRange:", v12, v11);
    if ([v13 rangeCount])
    {
      a5 = [v13 rangeAtIndex:0];
      a6 = v14;
    }
  }
  if (a6)
  {
    uint64_t v15 = *(void **)(*(void *)(a1 + 48) + 8);
    uint64_t v17 = (uint64_t *)v15[7];
    unint64_t v16 = v15[8];
    if ((unint64_t)v17 >= v16)
    {
      int64_t v19 = (uint64_t *)v15[6];
      uint64_t v20 = ((char *)v17 - (char *)v19) >> 4;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 60) {
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
      }
      uint64_t v22 = v16 - (void)v19;
      if (v22 >> 3 > v21) {
        unint64_t v21 = v22 >> 3;
      }
      BOOL v23 = (unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
      if (!v23) {
        unint64_t v24 = v21;
      }
      if (v24)
      {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v24);
        int64_t v19 = (uint64_t *)v15[6];
        uint64_t v17 = (uint64_t *)v15[7];
      }
      else
      {
        uint64_t v25 = 0;
      }
      __int16 v26 = (uint64_t *)(v24 + 16 * v20);
      unint64_t v27 = v24 + 16 * v25;
      *__int16 v26 = a5;
      v26[1] = a6;
      unint64_t v18 = v26 + 2;
      if (v17 != v19)
      {
        do
        {
          *((_OWORD *)v26 - 1) = *((_OWORD *)v17 - 1);
          v26 -= 2;
          v17 -= 2;
        }
        while (v17 != v19);
        int64_t v19 = (uint64_t *)v15[6];
      }
      v15[6] = v26;
      v15[7] = v18;
      v15[8] = v27;
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      uint64_t *v17 = a5;
      v17[1] = a6;
      unint64_t v18 = v17 + 2;
    }
    v15[7] = v18;
  }
}

void sub_184F05BF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

char *std::vector<CFRange>::__vallocate[abi:fe180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::string::basic_string[abi:fe180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:fe180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    unint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<float>>(__n);
    int64_t v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    size_t v7 = (unsigned int *)&v4[4 * v6];
    begiuint64_t n = this->__begin_;
    endouble d = this->__end_;
    uint64_t v10 = v5;
    if (end != this->__begin_)
    {
      uint64_t v10 = v5;
      do
      {
        unsigned int v11 = *--end;
        *--uint64_t v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void *std::vector<std::unique_ptr<PBPageLayoutPkg::PBRect>>::reserve(void *result, unint64_t a2)
{
  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 8 * v4;
    std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(v2, v5);
    return (void *)std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

void PB::PtrVector<PBPageLayoutPkg::PBRect>::emplace_back<PBPageLayoutPkg::PBRect>()
{
}

void sub_184F05F64(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void ***std::unique_ptr<PB::Data>::reset[abi:fe180100](void ***result, void **a2)
{
  uint64_t v2 = *result;
  *__n128 result = a2;
  if (v2)
  {
    free(*v2);
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:fe180100]<unsigned long const*,unsigned long const*,std::back_insert_iterator<std::vector<unsigned long long>>>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    int64_t v5 = a1;
    uint64_t v6 = *(void **)(a3 + 8);
    do
    {
      uint64_t v7 = *v5;
      unint64_t v8 = *(void *)(a3 + 16);
      if ((unint64_t)v6 >= v8)
      {
        uint64_t v10 = *(void **)a3;
        uint64_t v11 = ((uint64_t)v6 - *(void *)a3) >> 3;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        uint64_t v13 = v8 - (void)v10;
        if (v13 >> 2 > v12) {
          unint64_t v12 = v13 >> 2;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CG::DisplayListResource const*>>(v14);
          uint64_t v10 = *(void **)a3;
          uint64_t v6 = *(void **)(a3 + 8);
        }
        else
        {
          uint64_t v15 = 0;
        }
        unint64_t v16 = (void *)(v14 + 8 * v11);
        void *v16 = v7;
        uint64_t v9 = v16 + 1;
        while (v6 != v10)
        {
          uint64_t v17 = *--v6;
          *--unint64_t v16 = v17;
        }
        *(void *)a3 = v16;
        *(void *)(a3 + 8) = v9;
        *(void *)(a3 + 16) = v14 + 8 * v15;
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *uint64_t v6 = v7;
        uint64_t v9 = v6 + 1;
      }
      *(void *)(a3 + 8) = v9;
      ++v5;
      uint64_t v6 = v9;
    }
    while (v5 != a2);
  }
}

void *std::vector<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *--v2;
    *uint64_t v2 = 0;
    *(void *)(v4 - 8) = v5;
    v4 -= 8;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *__n128 result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<PBPageLayoutPkg::PBFontNameAndDescriptorFlagsPair>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::default_delete<std::string>::operator()[abi:fe180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }

  JUMPOUT(0x18532A2A0);
}

void *std::__allocate_at_least[abi:fe180100]<std::allocator<float>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:fe180100]();
  }
  return operator new(4 * a1);
}

uint64_t *std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:fe180100](uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  uint64_t v6 = *(_DWORD **)(*a1 + 8);
  unint64_t v5 = *(void *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v6 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<float>>(v13);
      uint64_t v8 = *(_DWORD **)v4;
      uint64_t v6 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = (_DWORD *)(v13 + 4 * v9);
    unint64_t v16 = v13 + 4 * v14;
    *uint64_t v15 = *a2;
    uint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      int v17 = *--v6;
      *--uint64_t v15 = v17;
    }
    *(void *)uint64_t v4 = v15;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v16;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *uint64_t v6 = *a2;
    uint64_t v7 = v6 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  _OWORD v10[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<CGPDFFont *,unsigned long>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,unsigned long>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,unsigned long>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  int64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    int64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_184F0654C(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,PDFAtomicElement * {__strong}>,void *>>>::operator()[abi:fe180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t cmyk64_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 40);
  uint64_t v15 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v90 = *(void *)(result + 88);
  uint64_t v100 = *(void *)(result + 120);
  uint64_t v101 = *(void *)(result + 112);
  uint64_t v16 = *(void *)(result + 152) - 16;
  uint64_t v91 = *(void *)(result + 144) - 1;
  int v17 = *(_DWORD *)(result + 260) - 1;
  int v98 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  int v18 = *(_DWORD *)(result + 256);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  int v86 = *(_DWORD *)(result + 188);
  unint64_t v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v96 = v14;
  uint64_t v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      uint64_t v23 = v90;
      if (a3 <= v90)
      {
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        int v22 = a4;
        uint64_t v24 = v89;
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = *(void *)(result + 224) + v90;
        uint64_t v28 = v27 - a3 + (v26 >> 1);
        int v22 = a4;
        uint64_t v24 = v89;
        if (v28 < 1) {
          goto LABEL_37;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v31 = v86 | v29;
        uint64_t v32 = v27 - 0x1000000;
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v88 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      uint64_t v24 = v89;
      uint64_t v23 = v90;
      if (v21 < 1) {
        goto LABEL_37;
      }
      if (v21 >= v19) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v31 = v86 | v25;
      uint64_t v32 = v20 + 0x1000000;
      uint64_t v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v36 = a2;
      }
      else
      {
        uint64_t v38 = *(void *)(result + 192);
        uint64_t v39 = *(void *)(result + 200) + v87;
        uint64_t v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1) {
          goto LABEL_37;
        }
        if (v40 < v38) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v86;
        }
        uint64_t v36 = v39 - 0x1000000;
        uint64_t v37 = 28;
      }
    }
    else
    {
      uint64_t v33 = *(void *)(result + 192);
      uint64_t v34 = v24 - *(void *)(result + 200);
      uint64_t v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1) {
        goto LABEL_37;
      }
      if (v35 < v33) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v86;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
    }
    if (v31 >= 0x400000) {
      break;
    }
LABEL_37:
    int v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    v16 += 16;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50) {
      return result;
    }
  }
  uint64_t v41 = v32 >> 32;
  unint64_t v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  std::string v44 = *(float32x4_t **)(result + 32);
  uint64_t v45 = (float32x4_t *)v99;
  if (v99 >= v43) {
    uint64_t v45 = (float32x4_t *)v43;
  }
  if (v45 < v44) {
    uint64_t v45 = *(float32x4_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    uint64_t v47 = *(float **)(result + 40);
    BOOL v48 = (float *)v94;
    unint64_t v92 = v46;
    if (v94 >= v46) {
      BOOL v48 = (float *)v46;
    }
    if (v48 >= v47) {
      uint64_t v47 = v48;
    }
    float v49 = *v47;
  }
  else
  {
    unint64_t v92 = 0;
    float v49 = 1.0;
  }
  float32x4_t v51 = *v45;
  if (v15)
  {
    unsigned int v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    int v53 = v52 & 0xF;
    int v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      uint64_t v68 = (float32x4_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68) {
        uint64_t v68 = (float32x4_t *)v99;
      }
      if (v68 >= v44) {
        std::string v44 = v68;
      }
      float32x4_t v69 = *v44;
      float v70 = 1.0;
      if (v14)
      {
        uint64_t v71 = (float *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71) {
          uint64_t v71 = (float *)v94;
        }
        if ((unint64_t)v71 < *(void *)(result + 40)) {
          uint64_t v71 = *(float **)(result + 40);
        }
        float v70 = *v71;
      }
      unint64_t v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          int64_t v55 = (unint64_t)HIWORD(v52) << 56;
          unint64_t v56 = (float32x4_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56) {
            uint64_t v57 = v56;
          }
          else {
            uint64_t v57 = (float32x4_t *)v99;
          }
          if (v57 < v44) {
            uint64_t v57 = v44;
          }
          uint64_t v58 = (float32x4_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58) {
            uint64_t v58 = (float32x4_t *)v99;
          }
          if (v58 >= v44) {
            std::string v44 = v58;
          }
          float32x4_t v59 = *v57;
          float32x4_t v60 = *v44;
          float v61 = 1.0;
          float v62 = 1.0;
          if (v14)
          {
            unint64_t v63 = v92 + (v55 >> 54);
            unint64_t v64 = *(void *)(result + 40);
            if (v94 >= v63) {
              CGAffineTransform v65 = (float *)(v92 + (v55 >> 54));
            }
            else {
              CGAffineTransform v65 = (float *)v94;
            }
            if ((unint64_t)v65 < v64) {
              CGAffineTransform v65 = *(float **)(result + 40);
            }
            float v61 = *v65;
            uint64_t v66 = (float *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66) {
              uint64_t v66 = (float *)v94;
            }
            if ((unint64_t)v66 < v64) {
              uint64_t v66 = *(float **)(result + 40);
            }
            float v62 = *v66;
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          float32x4_t v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          float v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      int64_t v73 = (unint64_t)HIWORD(v52) << 56;
      unint64_t v74 = (float32x4_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74) {
        unint64_t v74 = (float32x4_t *)v99;
      }
      if (v74 >= v44) {
        std::string v44 = v74;
      }
      float32x4_t v69 = *v44;
      float v70 = 1.0;
      if (v14)
      {
        unint64_t v75 = (float *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75) {
          unint64_t v75 = (float *)v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          unint64_t v75 = *(float **)(result + 40);
        }
        float v70 = *v75;
      }
      unint64_t v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    float v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  uint64_t v76 = 0;
  v16 += 16;
  int v85 = v22;
  int v77 = v22 - 1;
  a3 += v100;
  uint64_t v78 = v23 - a3;
  a2 += v101;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    float32x4_t v102 = v51;
    float v103 = v49;
    CMYKF_11703(v16, v102.f32);
    *(unsigned char *)(v91 + 1 + v76) = v31 >> 22;
    uint64_t v14 = v96;
    __n128 result = v97;
    if (v77 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      int v50 = ~v76 + v85;
      goto LABEL_38;
    }
    long long v80 = (float32x4_t *)v99;
    unint64_t v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    std::string v44 = *(float32x4_t **)(v97 + 32);
    if (v99 >= v43) {
      long long v80 = (float32x4_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    }
    if (v80 < v44) {
      long long v80 = *(float32x4_t **)(v97 + 32);
    }
    if (v96)
    {
      unint64_t v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      CGFloat v83 = *(float **)(v97 + 40);
      double v84 = (float *)v94;
      unint64_t v92 = v82;
      if (v94 >= v82) {
        double v84 = (float *)v82;
      }
      if (v84 >= v83) {
        CGFloat v83 = v84;
      }
      float v49 = *v83;
    }
    else
    {
      float v49 = 1.0;
    }
    float32x4_t v51 = *v80;
    if (v15)
    {
      unsigned int v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        uint64_t v23 = v90;
        v91 += v76 + 1;
        int v22 = ~v76 + v85;
        unsigned int v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    v16 += 16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    unsigned int v31 = -1;
  }
}

uint64_t CMYKF_11703(uint64_t result, float *a2)
{
  float v2 = a2[4];
  if (v2 <= 0.0)
  {
    LOWORD(v5) = 0;
    *(void *)__n128 result = 0;
  }
  else
  {
    float v4 = *a2;
    float v3 = a2[1];
    LODWORD(v5) = (int)(float)((float)(v2 * 65535.0) + 0.5);
    if (v2 <= 1.0) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = 0xFFFFLL;
    }
    if (v2 > 1.0) {
      float v2 = 1.0;
    }
    LOWORD(v6) = v5;
    if (v4 <= v2)
    {
      if (v4 >= 0.0) {
        int v6 = (int)(float)((float)(v4 * 65535.0) + 0.5);
      }
      else {
        LOWORD(v6) = 0;
      }
    }
    float v7 = a2[2];
    int v8 = v5;
    if (v3 <= v2)
    {
      if (v3 >= 0.0) {
        int v8 = (int)(float)((float)(v3 * 65535.0) + 0.5);
      }
      else {
        int v8 = 0;
      }
    }
    float v9 = a2[3];
    LOWORD(v10) = v5;
    if (v7 <= v2)
    {
      if (v7 >= 0.0) {
        int v10 = (int)(float)((float)(v7 * 65535.0) + 0.5);
      }
      else {
        LOWORD(v10) = 0;
      }
    }
    uint64_t v11 = v5;
    if (v9 <= v2)
    {
      if (v9 >= 0.0) {
        uint64_t v11 = (int)(float)((float)(v9 * 65535.0) + 0.5);
      }
      else {
        uint64_t v11 = 0;
      }
    }
    *(void *)__n128 result = ((unint64_t)(unsigned __int16)v10 << 32) | (v11 << 48) | (v8 << 16) | (unint64_t)(unsigned __int16)v6;
  }
  *(_WORD *)(result + 8) = v5;
  return result;
}

uint64_t cmyk64_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14 = *(void *)(result + 40);
  uint64_t v15 = *(void *)(result + 176);
  uint64_t v87 = *(void *)(result + 80);
  uint64_t v90 = *(void *)(result + 88);
  uint64_t v100 = *(void *)(result + 120);
  uint64_t v101 = *(void *)(result + 112);
  uint64_t v16 = *(void *)(result + 152) - 16;
  uint64_t v91 = *(void *)(result + 144) - 1;
  int v17 = *(_DWORD *)(result + 260) - 1;
  int v98 = *(_DWORD *)(result + 24);
  uint64_t v95 = *(void *)(result + 32);
  int v18 = *(_DWORD *)(result + 256);
  int v93 = *(_DWORD *)(result + 28);
  unint64_t v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  int v86 = *(_DWORD *)(result + 188);
  unint64_t v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  uint64_t v88 = *(void *)(result + 72);
  uint64_t v89 = *(void *)(result + 64);
  uint64_t v96 = v14;
  uint64_t v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      uint64_t v23 = v90;
      if (a3 <= v90)
      {
        uint64_t v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v31 = 0x3FFFFFFF;
        uint64_t v32 = a3;
        int v22 = a4;
        uint64_t v24 = v89;
      }
      else
      {
        uint64_t v26 = *(void *)(result + 216);
        uint64_t v27 = *(void *)(result + 224) + v90;
        uint64_t v28 = v27 - a3 + (v26 >> 1);
        int v22 = a4;
        uint64_t v24 = v89;
        if (v28 < 1) {
          goto LABEL_37;
        }
        if (v28 >= v26) {
          LODWORD(v29) = 0x3FFFFFFF;
        }
        else {
          unint64_t v29 = (unint64_t)(*(void *)(result + 232) * v28) >> 32;
        }
        unsigned int v31 = v86 | v29;
        uint64_t v32 = v27 - 0x1000000;
        uint64_t v30 = 448;
      }
    }
    else
    {
      uint64_t v19 = *(void *)(result + 216);
      uint64_t v20 = v88 - *(void *)(result + 224);
      uint64_t v21 = a3 - v20 + (v19 >> 1);
      int v22 = a4;
      uint64_t v24 = v89;
      uint64_t v23 = v90;
      if (v21 < 1) {
        goto LABEL_37;
      }
      if (v21 >= v19) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
      }
      unsigned int v31 = v86 | v25;
      uint64_t v32 = v20 + 0x1000000;
      uint64_t v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v36 = a2;
      }
      else
      {
        uint64_t v38 = *(void *)(result + 192);
        uint64_t v39 = *(void *)(result + 200) + v87;
        uint64_t v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1) {
          goto LABEL_37;
        }
        if (v40 < v38) {
          unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v86;
        }
        uint64_t v36 = v39 - 0x1000000;
        uint64_t v37 = 28;
      }
    }
    else
    {
      uint64_t v33 = *(void *)(result + 192);
      uint64_t v34 = v24 - *(void *)(result + 200);
      uint64_t v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1) {
        goto LABEL_37;
      }
      if (v35 < v33) {
        unsigned int v31 = ((v31 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v86;
      }
      uint64_t v36 = v34 + 0x1000000;
      uint64_t v37 = 32;
    }
    if (v31 >= 0x400000) {
      break;
    }
LABEL_37:
    int v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    v16 += 16;
    *(unsigned char *)++uint64_t v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50) {
      return result;
    }
  }
  uint64_t v41 = v32 >> 32;
  unint64_t v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  std::string v44 = *(int8x16_t **)(result + 32);
  uint64_t v45 = (int8x16_t *)v99;
  if (v99 >= v43) {
    uint64_t v45 = (int8x16_t *)v43;
  }
  if (v45 < v44) {
    uint64_t v45 = *(int8x16_t **)(result + 32);
  }
  if (v14)
  {
    unint64_t v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    uint64_t v47 = *(unsigned int **)(result + 40);
    BOOL v48 = (unsigned int *)v94;
    unint64_t v92 = v46;
    if (v94 >= v46) {
      BOOL v48 = (unsigned int *)v46;
    }
    if (v48 >= v47) {
      uint64_t v47 = v48;
    }
    float v49 = COERCE_FLOAT(bswap32(*v47));
  }
  else
  {
    unint64_t v92 = 0;
    float v49 = 1.0;
  }
  float32x4_t v51 = (float32x4_t)vrev32q_s8(*v45);
  if (v15)
  {
    unsigned int v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    int v53 = v52 & 0xF;
    int v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      uint64_t v68 = (int8x16_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68) {
        uint64_t v68 = (int8x16_t *)v99;
      }
      if (v68 >= v44) {
        std::string v44 = v68;
      }
      float32x4_t v69 = (float32x4_t)vrev32q_s8(*v44);
      float v70 = 1.0;
      if (v14)
      {
        uint64_t v71 = (unsigned int *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71) {
          uint64_t v71 = (unsigned int *)v94;
        }
        if ((unint64_t)v71 < *(void *)(result + 40)) {
          uint64_t v71 = *(unsigned int **)(result + 40);
        }
        float v70 = COERCE_FLOAT(bswap32(*v71));
      }
      unint64_t v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          int64_t v55 = (unint64_t)HIWORD(v52) << 56;
          unint64_t v56 = (int8x16_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56) {
            uint64_t v57 = v56;
          }
          else {
            uint64_t v57 = (int8x16_t *)v99;
          }
          if (v57 < v44) {
            uint64_t v57 = v44;
          }
          uint64_t v58 = (int8x16_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58) {
            uint64_t v58 = (int8x16_t *)v99;
          }
          if (v58 >= v44) {
            std::string v44 = v58;
          }
          float32x4_t v59 = (float32x4_t)vrev32q_s8(*v57);
          float32x4_t v60 = (float32x4_t)vrev32q_s8(*v44);
          float v61 = 1.0;
          float v62 = 1.0;
          if (v14)
          {
            unint64_t v63 = v92 + (v55 >> 54);
            unint64_t v64 = *(void *)(result + 40);
            if (v94 >= v63) {
              CGAffineTransform v65 = (unsigned int *)(v92 + (v55 >> 54));
            }
            else {
              CGAffineTransform v65 = (unsigned int *)v94;
            }
            if ((unint64_t)v65 < v64) {
              CGAffineTransform v65 = *(unsigned int **)(result + 40);
            }
            float v61 = COERCE_FLOAT(bswap32(*v65));
            uint64_t v66 = (unsigned int *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66) {
              uint64_t v66 = (unsigned int *)v94;
            }
            if ((unint64_t)v66 < v64) {
              uint64_t v66 = *(unsigned int **)(result + 40);
            }
            float v62 = COERCE_FLOAT(bswap32(*v66));
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          float32x4_t v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          float v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      int64_t v73 = (unint64_t)HIWORD(v52) << 56;
      unint64_t v74 = (int8x16_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74) {
        unint64_t v74 = (int8x16_t *)v99;
      }
      if (v74 >= v44) {
        std::string v44 = v74;
      }
      float32x4_t v69 = (float32x4_t)vrev32q_s8(*v44);
      float v70 = 1.0;
      if (v14)
      {
        unint64_t v75 = (unsigned int *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75) {
          unint64_t v75 = (unsigned int *)v94;
        }
        if ((unint64_t)v75 < *(void *)(result + 40)) {
          unint64_t v75 = *(unsigned int **)(result + 40);
        }
        float v70 = COERCE_FLOAT(bswap32(*v75));
      }
      unint64_t v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    float32x4_t v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    float v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  uint64_t v76 = 0;
  v16 += 16;
  int v85 = v22;
  int v77 = v22 - 1;
  a3 += v100;
  uint64_t v78 = v23 - a3;
  a2 += v101;
  uint64_t v79 = v87 - a2;
  while (1)
  {
    float32x4_t v102 = v51;
    float v103 = v49;
    CMYKF_11703(v16, v102.f32);
    *(unsigned char *)(v91 + 1 + v76) = v31 >> 22;
    uint64_t v14 = v96;
    __n128 result = v97;
    if (v77 == v76) {
      return result;
    }
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      int v50 = ~v76 + v85;
      goto LABEL_38;
    }
    long long v80 = (int8x16_t *)v99;
    unint64_t v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    std::string v44 = *(int8x16_t **)(v97 + 32);
    if (v99 >= v43) {
      long long v80 = (int8x16_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    }
    if (v80 < v44) {
      long long v80 = *(int8x16_t **)(v97 + 32);
    }
    if (v96)
    {
      unint64_t v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      CGFloat v83 = *(unsigned int **)(v97 + 40);
      double v84 = (unsigned int *)v94;
      unint64_t v92 = v82;
      if (v94 >= v82) {
        double v84 = (unsigned int *)v82;
      }
      if (v84 >= v83) {
        CGFloat v83 = v84;
      }
      float v49 = COERCE_FLOAT(bswap32(*v83));
    }
    else
    {
      float v49 = 1.0;
    }
    float32x4_t v51 = (float32x4_t)vrev32q_s8(*v80);
    if (v15)
    {
      unsigned int v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        uint64_t v23 = v90;
        v91 += v76 + 1;
        int v22 = ~v76 + v85;
        unsigned int v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    v16 += 16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    unsigned int v31 = -1;
  }
}

uint64_t cmyk64_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v5 = *(_DWORD *)(result + 24);
  int v154 = *(_DWORD *)(result + 28);
  uint64_t v6 = *(void *)(result + 112);
  uint64_t v7 = *(void *)(result + 48);
  uint64_t v8 = *(void *)(result + 56);
  if (v7)
  {
    uint64_t v153 = *(void *)(result + 112);
    if (v6 > v7) {
      uint64_t v153 = v6 % v7;
    }
  }
  else
  {
    uint64_t v153 = 0;
  }
  uint64_t v9 = *(void *)(result + 176);
  uint64_t v11 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 40);
  uint64_t v12 = *(void *)(result + 120);
  if (v8)
  {
    uint64_t v13 = v12 % v8;
    if (v12 <= v8) {
      uint64_t v13 = *(void *)(result + 120);
    }
    uint64_t v152 = v13;
  }
  else
  {
    uint64_t v152 = 0;
  }
  uint64_t v151 = *(void *)(result + 80);
  uint64_t v148 = *(void *)(result + 64);
  uint64_t v149 = *(void *)(result + 88);
  uint64_t v14 = *(void *)(result + 152) - 16;
  uint64_t v15 = *(void *)(result + 144) - 1;
  int v16 = *(_DWORD *)(result + 260) - 1;
  uint64_t v17 = *(unsigned int *)(result + 256);
  unint64_t v18 = v10 + (v16 * v154) + 2 * (v17 - 1);
  int v147 = *(_DWORD *)(result + 188);
  unint64_t v19 = v11 + (v16 * v5) + 8 * v17 - 16;
  uint64_t v150 = *(void *)(result + 72);
  while (1)
  {
    if (a3 < v150)
    {
      uint64_t v20 = *(void *)(result + 216);
      uint64_t v21 = v150 - *(void *)(result + 224);
      uint64_t v22 = a3 - v21 + (v20 >> 1);
      if (v22 < 1) {
        goto LABEL_57;
      }
      if (v22 >= v20) {
        LODWORD(v23) = 0x3FFFFFFF;
      }
      else {
        unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
      }
      unsigned int v30 = v147 | v23;
      uint64_t v31 = v21 + 0x1000000;
      uint64_t v28 = a3 - (v21 + 0x1000000);
      uint64_t v29 = 512;
      goto LABEL_22;
    }
    if (a3 <= v149)
    {
      uint64_t v28 = 0;
      uint64_t v29 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v30 = 0x3FFFFFFF;
      uint64_t v31 = a3;
LABEL_22:
      uint64_t v32 = v148;
      uint64_t v33 = v151;
      goto LABEL_25;
    }
    uint64_t v24 = *(void *)(result + 216);
    uint64_t v25 = *(void *)(result + 224) + v149;
    uint64_t v26 = v25 - a3 + (v24 >> 1);
    if (v26 < 1) {
      goto LABEL_57;
    }
    if (v26 >= v24) {
      LODWORD(v27) = 0x3FFFFFFF;
    }
    else {
      unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
    }
    uint64_t v32 = v148;
    uint64_t v33 = v151;
    unsigned int v30 = v147 | v27;
    uint64_t v31 = v25 - 0x1000000;
    uint64_t v28 = a3 - (v25 - 0x1000000);
    uint64_t v29 = 448;
LABEL_25:
    if (a2 >= v32) {
      break;
    }
    uint64_t v34 = *(void *)(result + 192);
    uint64_t v35 = v32 - *(void *)(result + 200);
    uint64_t v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34) {
        unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v36) >> 32) >> 15)) | v147;
      }
      uint64_t v37 = v35 + 0x1000000;
      uint64_t v38 = a2 - (v35 + 0x1000000);
      uint64_t v39 = 32;
      goto LABEL_36;
    }
LABEL_57:
    int v57 = a4 - 1;
    a2 += v6;
    a3 += v12;
    v14 += 16;
    *(unsigned char *)++uint64_t v15 = 0;
LABEL_58:
    a4 = v57;
    if (!v57) {
      return result;
    }
  }
  if (a2 <= v33)
  {
    uint64_t v38 = 0;
    uint64_t v39 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v37 = a2;
    goto LABEL_36;
  }
  uint64_t v40 = *(void *)(result + 192);
  uint64_t v41 = *(void *)(result + 200) + v33;
  uint64_t v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1) {
    goto LABEL_57;
  }
  if (v42 < v40) {
    unsigned int v30 = ((v30 >> 15) * (((unint64_t)(*(void *)(result + 208) * v42) >> 32) >> 15)) | v147;
  }
  uint64_t v37 = v41 - 0x1000000;
  uint64_t v38 = a2 - (v41 - 0x1000000);
  uint64_t v39 = 28;
LABEL_36:
  if (v30 < 0x400000) {
    goto LABEL_57;
  }
  if (v7)
  {
    uint64_t v43 = (v8 & ((v31 % v8) >> 63)) + v31 % v8;
    uint64_t v44 = (v7 & ((v37 % v7) >> 63)) + v37 % v7;
    if (v43 >= v8) {
      uint64_t v45 = v8;
    }
    else {
      uint64_t v45 = 0;
    }
    uint64_t v31 = v43 - v45;
    if (v44 >= v7) {
      uint64_t v46 = v7;
    }
    else {
      uint64_t v46 = 0;
    }
    uint64_t v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  uint64_t v47 = v31 >> 32;
  uint64_t v48 = v37 >> 32;
  uint64_t v49 = v11 + (int)v47 * (uint64_t)v5;
  unint64_t v50 = v49 + 8 * v48;
  float32x4_t v51 = *(uint64_t **)(result + 32);
  if (v19 >= v50) {
    unsigned int v52 = (uint64_t *)(v49 + 8 * v48);
  }
  else {
    unsigned int v52 = (uint64_t *)v19;
  }
  if (v52 < v51) {
    unsigned int v52 = *(uint64_t **)(result + 32);
  }
  if (v10)
  {
    unint64_t v53 = v10 + (int)v47 * (uint64_t)v154 + 2 * v48;
    int v54 = *(unsigned __int16 **)(result + 40);
    if (v18 >= v53) {
      int64_t v55 = (unsigned __int16 *)v53;
    }
    else {
      int64_t v55 = (unsigned __int16 *)v18;
    }
    if (v55 >= v54) {
      int v54 = v55;
    }
    uint64_t v56 = *v54;
  }
  else
  {
    unint64_t v53 = 0;
    uint64_t v56 = 0xFFFFLL;
  }
  uint64_t v58 = *v52;
  if (!v9) {
    goto LABEL_63;
  }
  unsigned int v59 = *(_DWORD *)(v9 + (v39 | v29));
LABEL_65:
  int v61 = v59 & 0xF;
  uint64_t v62 = v59 >> 8;
  unsigned int v63 = HIBYTE(v59) & 3;
  unsigned int v146 = v30;
  if (v61 == 1)
  {
    LODWORD(v95) = SBYTE1(v59);
    if (v7)
    {
      uint64_t v96 = v62 << 56;
      uint64_t v97 = v28 + (v96 >> 24);
      uint64_t v98 = v8 & (v97 >> 63);
      if (v98 + v97 >= v8) {
        uint64_t v99 = v8;
      }
      else {
        uint64_t v99 = 0;
      }
      uint64_t v95 = (v98 + (v96 >> 24) - v99) >> 32;
    }
    uint64_t v100 = (unint64_t *)(v50 + (int)v95 * (uint64_t)v5);
    if (v19 < (unint64_t)v100) {
      uint64_t v100 = (unint64_t *)v19;
    }
    if (v100 < (unint64_t *)v51) {
      uint64_t v100 = (unint64_t *)v51;
    }
    unint64_t v101 = *v100;
    int v102 = 0xFFFF;
    if (v10)
    {
      float v103 = (unsigned __int16 *)(v53 + (int)v95 * (uint64_t)v154);
      if (v18 < (unint64_t)v103) {
        float v103 = (unsigned __int16 *)v18;
      }
      if ((unint64_t)v103 < *(void *)(result + 40)) {
        float v103 = *(unsigned __int16 **)(result + 40);
      }
      int v102 = *v103;
    }
    double v104 = (char *)&interpolate_cmyk64 + 16 * v63;
    uint64_t v105 = *(void *)v104;
    char v106 = v63 + 1;
    unint64_t v107 = v58 - ((*(void *)v104 & (unint64_t)v58) >> v106);
    LODWORD(v104) = *((unsigned __int16 *)v104 + 4);
    int v108 = v56 - ((v104 & v56) >> v106);
    unint64_t v94 = (v105 & v101) >> v106;
    unsigned int v109 = (v104 & v102) >> v106;
    goto LABEL_137;
  }
  if (v61 == 2)
  {
    uint64_t v110 = SBYTE2(v59);
    if (v7)
    {
      int64_t v111 = (unint64_t)HIWORD(v59) << 56;
      uint64_t v112 = v38 + (v111 >> 24);
      uint64_t v113 = v7 & (v112 >> 63);
      if (v113 + v112 >= v7) {
        uint64_t v114 = v7;
      }
      else {
        uint64_t v114 = 0;
      }
      uint64_t v110 = (v113 + (v111 >> 24) - v114) >> 32;
    }
    uint64_t v115 = (unint64_t *)(v50 + 8 * v110);
    if (v19 < (unint64_t)v115) {
      uint64_t v115 = (unint64_t *)v19;
    }
    if (v115 < (unint64_t *)v51) {
      uint64_t v115 = (unint64_t *)v51;
    }
    unint64_t v116 = *v115;
    int v117 = 0xFFFF;
    if (v10)
    {
      uint64_t v118 = (unsigned __int16 *)(v53 + 2 * v110);
      if (v18 < (unint64_t)v118) {
        uint64_t v118 = (unsigned __int16 *)v18;
      }
      if ((unint64_t)v118 < *(void *)(result + 40)) {
        uint64_t v118 = *(unsigned __int16 **)(result + 40);
      }
      int v117 = *v118;
    }
    unsigned int v119 = (v59 >> 28) & 3;
    double v120 = (char *)&interpolate_cmyk64 + 16 * v119;
    uint64_t v121 = *(void *)v120;
    LOBYTE(v119) = v119 + 1;
    unint64_t v107 = v58 - ((*(void *)v120 & (unint64_t)v58) >> v119);
    LODWORD(v120) = *((unsigned __int16 *)v120 + 4);
    int v108 = v56 - ((v120 & v56) >> v119);
    unint64_t v94 = (v121 & v116) >> v119;
    unsigned int v109 = (v120 & v117) >> v119;
LABEL_137:
    uint64_t v58 = v107 + v94;
    LOWORD(v94) = v108 + v109;
    goto LABEL_138;
  }
  if (v61 != 3)
  {
LABEL_63:
    int v60 = a4;
    goto LABEL_139;
  }
  unsigned int v145 = HIBYTE(v59) & 3;
  LODWORD(v64) = SBYTE1(v59);
  uint64_t v65 = SBYTE2(v59);
  if (v7)
  {
    uint64_t v66 = v62 << 56;
    int64_t v143 = (unint64_t)HIWORD(v59) << 56;
    uint64_t v67 = v28 + ((uint64_t)SBYTE1(v59) << 32);
    uint64_t v68 = v38 + (v143 >> 24);
    uint64_t v69 = v8 & (v67 >> 63);
    uint64_t v70 = v7 & (v68 >> 63);
    uint64_t v71 = v70 + v68;
    if (v69 + v67 >= v8) {
      uint64_t v72 = v8;
    }
    else {
      uint64_t v72 = 0;
    }
    if (v71 >= v7) {
      uint64_t v73 = v7;
    }
    else {
      uint64_t v73 = 0;
    }
    uint64_t v64 = (v69 + (v66 >> 24) - v72) >> 32;
    uint64_t v65 = (v70 + (v143 >> 24) - v73) >> 32;
  }
  unint64_t v74 = (unint64_t *)(v50 + 8 * v65);
  if (v19 < (unint64_t)v74) {
    unint64_t v74 = (unint64_t *)v19;
  }
  if (v74 < (unint64_t *)v51) {
    unint64_t v74 = (unint64_t *)v51;
  }
  unint64_t v144 = *v74;
  int v75 = v64;
  unint64_t v76 = v50 + (int)v64 * (uint64_t)v5;
  if (v19 >= v76) {
    int v77 = (unint64_t *)(v50 + (int)v64 * (uint64_t)v5);
  }
  else {
    int v77 = (unint64_t *)v19;
  }
  if (v77 < (unint64_t *)v51) {
    int v77 = (unint64_t *)v51;
  }
  uint64_t v78 = (unint64_t *)(v76 + 8 * v65);
  if (v19 < (unint64_t)v78) {
    uint64_t v78 = (unint64_t *)v19;
  }
  if (v78 < (unint64_t *)v51) {
    uint64_t v78 = (unint64_t *)v51;
  }
  unint64_t v141 = *v78;
  unint64_t v142 = *v77;
  int v79 = 0xFFFF;
  int v80 = 0xFFFF;
  int v81 = 0xFFFF;
  if (v10)
  {
    unint64_t v82 = (unsigned __int16 *)(v53 + 2 * v65);
    unint64_t v83 = *(void *)(result + 40);
    if (v18 < (unint64_t)v82) {
      unint64_t v82 = (unsigned __int16 *)v18;
    }
    if ((unint64_t)v82 < v83) {
      unint64_t v82 = *(unsigned __int16 **)(result + 40);
    }
    int v79 = *v82;
    unint64_t v84 = v53 + v75 * (uint64_t)v154;
    if (v18 >= v84) {
      int v85 = (unsigned __int16 *)(v53 + v75 * (uint64_t)v154);
    }
    else {
      int v85 = (unsigned __int16 *)v18;
    }
    if ((unint64_t)v85 < v83) {
      int v85 = *(unsigned __int16 **)(result + 40);
    }
    int v80 = *v85;
    int v86 = (unsigned __int16 *)(v84 + 2 * v65);
    if (v18 < (unint64_t)v86) {
      int v86 = (unsigned __int16 *)v18;
    }
    if ((unint64_t)v86 < v83) {
      int v86 = *(unsigned __int16 **)(result + 40);
    }
    int v81 = *v86;
  }
  int v140 = v81;
  uint64_t v87 = (char *)&interpolate_cmyk64 + 16 * v145;
  uint64_t v88 = *(void *)v87;
  unint64_t v89 = v58 - ((*(void *)v87 & (unint64_t)v58) >> (v145 + 1));
  LODWORD(v87) = *((unsigned __int16 *)v87 + 4);
  unsigned int v90 = v79 - ((v87 & v79) >> (v145 + 1));
  int v91 = v56 - ((v87 & v56) >> (v145 + 1)) + ((v87 & v80) >> (v145 + 1));
  unsigned int v92 = v90 + ((v87 & v140) >> (v145 + 1));
  LODWORD(v87) = (v59 >> 28) & 3;
  int v93 = (char *)&interpolate_cmyk64 + 16 * v87;
  LOBYTE(v87) = (_BYTE)v87 + 1;
  uint64_t v58 = v89
      + ((v88 & v142) >> (v145 + 1))
      - (((v89 + ((v88 & v142) >> (v145 + 1))) & *(void *)v93) >> (char)v87)
      + (((v144 - ((v88 & v144) >> (v145 + 1)) + ((v88 & v141) >> (v145 + 1))) & *(void *)v93) >> (char)v87);
  LODWORD(v94) = v91
               - ((unsigned __int16)(v91 & *((_WORD *)v93 + 4)) >> (char)v87)
               + ((unsigned __int16)(v92 & *((_WORD *)v93 + 4)) >> (char)v87);
LABEL_138:
  uint64_t v56 = (unsigned __int16)v94;
  int v60 = a4;
  unsigned int v30 = v146;
LABEL_139:
  *(void *)(v14 + 16) = v58;
  *(void *)(v14 + 24) = v56;
  *(unsigned char *)(v15 + 1) = v30 >> 22;
  if (v60 != 1)
  {
    int v122 = v60;
    uint64_t v123 = 0;
    BOOL v124 = (uint64_t *)(v14 + 40);
    int v125 = v60 - 1;
    a2 += v6;
    uint64_t v126 = v151 - a2;
    a3 += v12;
    uint64_t v127 = v149 - a3;
    while (((v127 | v126 | (a3 - v150) | (a2 - v148)) & 0x8000000000000000) == 0)
    {
      if (v7)
      {
        uint64_t v128 = (v8 & ((v28 + v152) >> 63)) + v28 + v152;
        uint64_t v129 = (v7 & ((v38 + v153) >> 63)) + v38 + v153;
        if (v128 >= v8) {
          uint64_t v130 = v8;
        }
        else {
          uint64_t v130 = 0;
        }
        uint64_t v131 = v128 - v130;
        if (v129 >= v7) {
          uint64_t v132 = v7;
        }
        else {
          uint64_t v132 = 0;
        }
        uint64_t v133 = v129 - v132;
        uint64_t v38 = v133;
        uint64_t v28 = v131;
      }
      else
      {
        uint64_t v133 = a2;
        uint64_t v131 = a3;
      }
      uint64_t v134 = v131 >> 32;
      uint64_t v135 = v133 >> 32;
      unint64_t v50 = v11 + SHIDWORD(v131) * (uint64_t)v5 + 8 * (v133 >> 32);
      float32x4_t v51 = *(uint64_t **)(result + 32);
      if (v19 >= v50) {
        unint64_t v136 = (uint64_t *)v50;
      }
      else {
        unint64_t v136 = (uint64_t *)v19;
      }
      if (v136 < v51) {
        unint64_t v136 = *(uint64_t **)(result + 32);
      }
      if (v10)
      {
        unint64_t v53 = v10 + (int)v134 * (uint64_t)v154 + 2 * v135;
        uint64_t v137 = *(unsigned __int16 **)(result + 40);
        if (v18 >= v53) {
          unint64_t v138 = (unsigned __int16 *)v53;
        }
        else {
          unint64_t v138 = (unsigned __int16 *)v18;
        }
        if (v138 >= v137) {
          uint64_t v137 = v138;
        }
        uint64_t v56 = *v137;
      }
      else
      {
        uint64_t v56 = 0xFFFFLL;
      }
      uint64_t v58 = *v136;
      if (v9)
      {
        unsigned int v59 = *(_DWORD *)(v9 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v59 & 0xF) != 0)
        {
          v15 += v123 + 1;
          uint64_t v14 = (uint64_t)(v124 - 3);
          a4 = ~v123 + v122;
          unsigned int v30 = -1;
          goto LABEL_65;
        }
      }
      *(v124 - 1) = v58;
      uint64_t *v124 = v56;
      uint64_t v139 = v15 + v123++;
      v124 += 2;
      a2 += v6;
      *(unsigned char *)(v139 + 2) = -1;
      v126 -= v6;
      a3 += v12;
      v127 -= v12;
      if (v125 == v123) {
        return result;
      }
    }
    v15 += v123 + 1;
    uint64_t v14 = (uint64_t)(v124 - 3);
    int v57 = ~v123 + v122;
    goto LABEL_58;
  }
  return result;
}

uint64_t cmyk64_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  int v138 = *(_DWORD *)(result + 28);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v137 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v137 = v5 % v6;
    }
  }
  else
  {
    uint64_t v137 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 40);
  uint64_t v139 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v136 = v11;
  }
  else
  {
    uint64_t v136 = 0;
  }
  uint64_t v132 = *(void *)(result + 80);
  uint64_t v133 = *(void *)(result + 64);
  uint64_t v134 = *(void *)(result + 88);
  uint64_t v12 = *(void *)(result + 152) - 16;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  unint64_t v16 = v9 + (v14 * v138) + 2 * (v15 - 1);
  int v131 = *(_DWORD *)(result + 188);
  unint64_t v17 = v139 + (v14 * v4) + 8 * v15 - 16;
  uint64_t v135 = *(void *)(result + 72);
  while (1)
  {
    if (a3 < v135)
    {
      uint64_t v18 = *(void *)(result + 216);
      uint64_t v19 = v135 - *(void *)(result + 224);
      uint64_t v20 = a3 - v19 + (v18 >> 1);
      int v21 = a4;
      if (v20 < 1) {
        goto LABEL_57;
      }
      if (v20 >= v18) {
        LODWORD(v22) = 0x3FFFFFFF;
      }
      else {
        unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
      }
      unsigned int v29 = v131 | v22;
      uint64_t v30 = v19 + 0x1000000;
      uint64_t v27 = a3 - v30;
      uint64_t v28 = 512;
      goto LABEL_22;
    }
    if (a3 <= v134)
    {
      uint64_t v27 = 0;
      uint64_t v28 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v29 = 0x3FFFFFFF;
      uint64_t v30 = a3;
      int v21 = a4;
LABEL_22:
      uint64_t v31 = v133;
      goto LABEL_25;
    }
    uint64_t v23 = *(void *)(result + 216);
    uint64_t v24 = *(void *)(result + 224) + v134;
    uint64_t v25 = v24 - a3 + (v23 >> 1);
    int v21 = a4;
    if (v25 < 1) {
      goto LABEL_57;
    }
    if (v25 >= v23) {
      LODWORD(v26) = 0x3FFFFFFF;
    }
    else {
      unint64_t v26 = (unint64_t)(*(void *)(result + 232) * v25) >> 32;
    }
    uint64_t v31 = v133;
    unsigned int v29 = v131 | v26;
    uint64_t v30 = v24 - 0x1000000;
    uint64_t v27 = a3 - v30;
    uint64_t v28 = 448;
LABEL_25:
    if (a2 >= v31) {
      break;
    }
    uint64_t v32 = *(void *)(result + 192);
    uint64_t v33 = v31 - *(void *)(result + 200);
    uint64_t v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32) {
        unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v131;
      }
      uint64_t v35 = v33 + 0x1000000;
      uint64_t v36 = a2 - (v33 + 0x1000000);
      uint64_t v37 = 32;
      goto LABEL_36;
    }
LABEL_57:
    int v55 = v21 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 16;
    *(unsigned char *)++uint64_t v13 = 0;
LABEL_58:
    a4 = v55;
    if (!v55) {
      return result;
    }
  }
  if (a2 <= v132)
  {
    uint64_t v36 = 0;
    uint64_t v37 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v35 = a2;
    goto LABEL_36;
  }
  uint64_t v38 = *(void *)(result + 192);
  uint64_t v39 = *(void *)(result + 200) + v132;
  uint64_t v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1) {
    goto LABEL_57;
  }
  if (v40 < v38) {
    unsigned int v29 = ((v29 >> 15) * (((unint64_t)(*(void *)(result + 208) * v40) >> 32) >> 15)) | v131;
  }
  uint64_t v35 = v39 - 0x1000000;
  uint64_t v36 = a2 - (v39 - 0x1000000);
  uint64_t v37 = 28;
LABEL_36:
  if (v29 < 0x400000) {
    goto LABEL_57;
  }
  unsigned int v130 = v29;
  if (v6)
  {
    uint64_t v41 = (v7 & ((v30 % v7) >> 63)) + v30 % v7;
    uint64_t v42 = (v6 & ((v35 % v6) >> 63)) + v35 % v6;
    if (v41 >= v7) {
      uint64_t v43 = v7;
    }
    else {
      uint64_t v43 = 0;
    }
    uint64_t v30 = v41 - v43;
    if (v42 >= v6) {
      uint64_t v44 = v6;
    }
    else {
      uint64_t v44 = 0;
    }
    uint64_t v35 = v42 - v44;
    v27 += v30;
    v36 += v35;
  }
  uint64_t v45 = v30 >> 32;
  uint64_t v46 = v35 >> 32;
  uint64_t v47 = v139 + SHIDWORD(v30) * (uint64_t)v4;
  unint64_t v48 = v47 + 8 * v46;
  uint64_t v49 = *(unsigned __int16 **)(result + 32);
  if (v17 >= v48) {
    unint64_t v50 = (unsigned __int16 *)(v47 + 8 * v46);
  }
  else {
    unint64_t v50 = (unsigned __int16 *)v17;
  }
  if (v50 < v49) {
    unint64_t v50 = *(unsigned __int16 **)(result + 32);
  }
  if (v9)
  {
    unint64_t v51 = v9 + (int)v45 * (uint64_t)v138 + 2 * v46;
    unsigned int v52 = *(unsigned __int16 **)(result + 40);
    if (v16 >= v51) {
      unint64_t v53 = (unsigned __int16 *)v51;
    }
    else {
      unint64_t v53 = (unsigned __int16 *)v16;
    }
    if (v53 >= v52) {
      unsigned int v52 = v53;
    }
    uint64_t v54 = bswap32(*v52) >> 16;
  }
  else
  {
    unint64_t v51 = 0;
    uint64_t v54 = 0xFFFFLL;
  }
  unint64_t v56 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
  if (v8)
  {
    unsigned int v57 = *(_DWORD *)(v8 + (v37 | v28));
LABEL_64:
    int v58 = v57 & 0xF;
    unsigned int v59 = HIBYTE(v57) & 3;
    if (v58 == 1)
    {
      LODWORD(v89) = SBYTE1(v57);
      if (v6)
      {
        uint64_t v90 = v27 + ((uint64_t)SBYTE1(v57) << 32);
        uint64_t v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v89 = (v91 + ((uint64_t)SBYTE1(v57) << 32) - v92) >> 32;
      }
      int v93 = (unsigned __int16 *)(v48 + (int)v89 * (uint64_t)v4);
      if (v17 < (unint64_t)v93) {
        int v93 = (unsigned __int16 *)v17;
      }
      if (v93 < v49) {
        int v93 = v49;
      }
      unint64_t v94 = ((unint64_t)(bswap32(v93[2]) >> 16) << 32) | ((unint64_t)(bswap32(v93[3]) >> 16) << 48) | bswap32(v93[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v93) >> 16);
      LOWORD(v95) = -1;
      if (v9)
      {
        uint64_t v96 = (unsigned __int16 *)(v51 + (int)v89 * (uint64_t)v138);
        if (v16 < (unint64_t)v96) {
          uint64_t v96 = (unsigned __int16 *)v16;
        }
        if ((unint64_t)v96 < *(void *)(result + 40)) {
          uint64_t v96 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v95 = bswap32(*v96) >> 16;
      }
      uint64_t v97 = (char *)&interpolate_cmyk64 + 16 * v59;
      char v98 = v59 + 1;
      unint64_t v56 = v56 - ((*(void *)v97 & v56) >> v98) + ((*(void *)v97 & v94) >> v98);
      int v99 = v54
          - ((unsigned __int16)(*((_WORD *)v97 + 4) & v54) >> v98)
          + ((unsigned __int16)(*((_WORD *)v97 + 4) & v95) >> v98);
    }
    else
    {
      if (v58 != 2)
      {
        if (v58 == 3)
        {
          unsigned int v128 = HIBYTE(v57) & 3;
          uint64_t v129 = v12;
          LODWORD(v60) = SBYTE1(v57);
          uint64_t v61 = SBYTE2(v57);
          if (v6)
          {
            int64_t v62 = (unint64_t)HIWORD(v57) << 56;
            uint64_t v63 = v27 + ((uint64_t)SBYTE1(v57) << 32);
            uint64_t v64 = v36 + (v62 >> 24);
            uint64_t v65 = v7 & (v63 >> 63);
            uint64_t v66 = v6 & (v64 >> 63);
            uint64_t v67 = v66 + v64;
            if (v65 + v63 >= v7) {
              uint64_t v68 = v7;
            }
            else {
              uint64_t v68 = 0;
            }
            if (v67 >= v6) {
              uint64_t v69 = v6;
            }
            else {
              uint64_t v69 = 0;
            }
            uint64_t v60 = (v65 + ((uint64_t)((unint64_t)(v57 >> 8) << 56) >> 24) - v68) >> 32;
            uint64_t v61 = (v66 + (v62 >> 24) - v69) >> 32;
          }
          uint64_t v70 = (unsigned __int16 *)(v48 + 8 * v61);
          if (v17 < (unint64_t)v70) {
            uint64_t v70 = (unsigned __int16 *)v17;
          }
          if (v70 < v49) {
            uint64_t v70 = v49;
          }
          unint64_t v71 = ((unint64_t)(bswap32(v70[2]) >> 16) << 32) | ((unint64_t)(bswap32(v70[3]) >> 16) << 48) | bswap32(v70[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v70) >> 16);
          unint64_t v72 = v48 + (int)v60 * (uint64_t)v4;
          if (v17 >= v72) {
            uint64_t v73 = (unsigned __int16 *)(v48 + (int)v60 * (uint64_t)v4);
          }
          else {
            uint64_t v73 = (unsigned __int16 *)v17;
          }
          if (v73 < v49) {
            uint64_t v73 = v49;
          }
          unint64_t v127 = ((unint64_t)(bswap32(v73[2]) >> 16) << 32) | ((unint64_t)(bswap32(v73[3]) >> 16) << 48) | bswap32(v73[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v73) >> 16);
          unint64_t v74 = (unsigned __int16 *)(v72 + 8 * v61);
          if (v17 < (unint64_t)v74) {
            unint64_t v74 = (unsigned __int16 *)v17;
          }
          if (v74 < v49) {
            unint64_t v74 = v49;
          }
          unint64_t v126 = ((unint64_t)(bswap32(v74[2]) >> 16) << 32) | ((unint64_t)(bswap32(v74[3]) >> 16) << 48) | bswap32(v74[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v74) >> 16);
          unsigned int v75 = 0xFFFF;
          unsigned int v76 = 0xFFFF;
          unsigned int v77 = 0xFFFF;
          if (v9)
          {
            uint64_t v78 = (unsigned __int16 *)(v51 + 2 * v61);
            unint64_t v79 = *(void *)(result + 40);
            if (v16 < (unint64_t)v78) {
              uint64_t v78 = (unsigned __int16 *)v16;
            }
            if ((unint64_t)v78 < v79) {
              uint64_t v78 = *(unsigned __int16 **)(result + 40);
            }
            unsigned int v75 = bswap32(*v78) >> 16;
            unint64_t v80 = v51 + (int)v60 * (uint64_t)v138;
            if (v16 >= v80) {
              int v81 = (unsigned __int16 *)(v51 + (int)v60 * (uint64_t)v138);
            }
            else {
              int v81 = (unsigned __int16 *)v16;
            }
            if ((unint64_t)v81 < v79) {
              int v81 = *(unsigned __int16 **)(result + 40);
            }
            unsigned int v76 = bswap32(*v81) >> 16;
            unint64_t v82 = (unsigned __int16 *)(v80 + 2 * v61);
            if (v16 < (unint64_t)v82) {
              unint64_t v82 = (unsigned __int16 *)v16;
            }
            if ((unint64_t)v82 < v79) {
              unint64_t v82 = *(unsigned __int16 **)(result + 40);
            }
            unsigned int v77 = bswap32(*v82) >> 16;
          }
          unint64_t v83 = (char *)&interpolate_cmyk64 + 16 * v128;
          uint64_t v84 = *(void *)v83;
          unint64_t v85 = v56 - ((*(void *)v83 & v56) >> (v128 + 1));
          LODWORD(v83) = *((unsigned __int16 *)v83 + 4);
          int v86 = v54
              - ((v83 & v54) >> (v128 + 1))
              + ((v83 & v76) >> (v128 + 1));
          LODWORD(v83) = v75 - ((v83 & v75) >> (v128 + 1)) + ((v83 & v77) >> (v128 + 1));
          unsigned int v87 = (v57 >> 28) & 3;
          uint64_t v88 = (char *)&interpolate_cmyk64 + 16 * v87;
          LOBYTE(v87) = v87 + 1;
          unint64_t v56 = v85
              + ((v84 & v127) >> (v128 + 1))
              - (((v85 + ((v84 & v127) >> (v128 + 1))) & *(void *)v88) >> v87)
              + (((v71 - ((v84 & v71) >> (v128 + 1)) + ((v84 & v126) >> (v128 + 1))) & *(void *)v88) >> v87);
          uint64_t v54 = (unsigned __int16)(v86
                                 - ((unsigned __int16)(v86 & *((_WORD *)v88 + 4)) >> v87)
                                 + ((unsigned __int16)((unsigned __int16)v83 & *((_WORD *)v88 + 4)) >> v87));
          uint64_t v12 = v129;
        }
        goto LABEL_137;
      }
      uint64_t v100 = SBYTE2(v57);
      if (v6)
      {
        uint64_t v101 = v36 + ((uint64_t)SBYTE2(v57) << 32);
        uint64_t v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6) {
          uint64_t v103 = v6;
        }
        else {
          uint64_t v103 = 0;
        }
        uint64_t v100 = (v102 + ((uint64_t)((unint64_t)HIWORD(v57) << 56) >> 24) - v103) >> 32;
      }
      double v104 = (unsigned __int16 *)(v48 + 8 * v100);
      if (v17 < (unint64_t)v104) {
        double v104 = (unsigned __int16 *)v17;
      }
      if (v104 < v49) {
        double v104 = v49;
      }
      unint64_t v105 = ((unint64_t)(bswap32(v104[2]) >> 16) << 32) | ((unint64_t)(bswap32(v104[3]) >> 16) << 48) | bswap32(v104[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v104) >> 16);
      LOWORD(v106) = -1;
      if (v9)
      {
        unint64_t v107 = (unsigned __int16 *)(v51 + 2 * v100);
        if (v16 < (unint64_t)v107) {
          unint64_t v107 = (unsigned __int16 *)v16;
        }
        if ((unint64_t)v107 < *(void *)(result + 40)) {
          unint64_t v107 = *(unsigned __int16 **)(result + 40);
        }
        unsigned int v106 = bswap32(*v107) >> 16;
      }
      unsigned int v108 = (v57 >> 28) & 3;
      unsigned int v109 = (char *)&interpolate_cmyk64 + 16 * v108;
      LOBYTE(v108) = v108 + 1;
      unint64_t v56 = v56 - ((*(void *)v109 & v56) >> v108) + ((*(void *)v109 & v105) >> v108);
      int v99 = v54 - ((unsigned __int16)(*((_WORD *)v109 + 4) & v54) >> v108) + ((*((_WORD *)v109 + 4) & v106) >> v108);
    }
    uint64_t v54 = (unsigned __int16)v99;
  }
LABEL_137:
  *(void *)(v12 + 16) = v56;
  *(void *)(v12 + 24) = v54;
  *(unsigned char *)(v13 + 1) = v130 >> 22;
  if (v21 != 1)
  {
    uint64_t v110 = 0;
    int64_t v111 = (uint64_t *)(v12 + 40);
    a2 += v5;
    uint64_t v112 = v132 - a2;
    a3 += v10;
    uint64_t v113 = v134 - a3;
    while (((v113 | v112 | (a3 - v135) | (a2 - v133)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v114 = (v7 & ((v27 + v136) >> 63)) + v27 + v136;
        uint64_t v115 = (v6 & ((v36 + v137) >> 63)) + v36 + v137;
        if (v114 >= v7) {
          uint64_t v116 = v7;
        }
        else {
          uint64_t v116 = 0;
        }
        uint64_t v27 = v114 - v116;
        if (v115 >= v6) {
          uint64_t v117 = v6;
        }
        else {
          uint64_t v117 = 0;
        }
        uint64_t v36 = v115 - v117;
        uint64_t v118 = v27;
        uint64_t v119 = v36;
      }
      else
      {
        uint64_t v118 = a3;
        uint64_t v119 = a2;
      }
      uint64_t v120 = v119 >> 32;
      uint64_t v121 = v118 >> 32;
      unint64_t v48 = v139 + SHIDWORD(v118) * (uint64_t)v4 + 8 * (v119 >> 32);
      uint64_t v49 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v48) {
        int v122 = (unsigned __int16 *)v48;
      }
      else {
        int v122 = (unsigned __int16 *)v17;
      }
      if (v122 < v49) {
        int v122 = *(unsigned __int16 **)(result + 32);
      }
      if (v9)
      {
        unint64_t v51 = v9 + (int)v121 * (uint64_t)v138 + 2 * v120;
        uint64_t v123 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v51) {
          unint64_t v124 = v9 + (int)v121 * (uint64_t)v138 + 2 * v120;
        }
        else {
          unint64_t v124 = v16;
        }
        if (v124 >= (unint64_t)v123) {
          uint64_t v123 = (unsigned __int16 *)v124;
        }
        uint64_t v54 = bswap32(*v123) >> 16;
      }
      else
      {
        uint64_t v54 = 0xFFFFLL;
      }
      unint64_t v56 = ((unint64_t)(bswap32(v122[2]) >> 16) << 32) | ((unint64_t)(bswap32(v122[3]) >> 16) << 48) | bswap32(v122[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v122) >> 16);
      if (v8)
      {
        unsigned int v57 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v57 & 0xF) != 0)
        {
          v13 += v110 + 1;
          uint64_t v12 = (uint64_t)(v111 - 3);
          v21 += ~v110;
          unsigned int v130 = -1;
          goto LABEL_64;
        }
      }
      *(v111 - 1) = v56;
      uint64_t *v111 = v54;
      uint64_t v125 = v13 + v110++;
      v111 += 2;
      a2 += v5;
      *(unsigned char *)(v125 + 2) = -1;
      v112 -= v5;
      a3 += v10;
      v113 -= v10;
      if (v21 - 1 == v110) {
        return result;
      }
    }
    v13 += v110 + 1;
    uint64_t v12 = (uint64_t)(v111 - 3);
    int v55 = ~v110 + v21;
    goto LABEL_58;
  }
  return result;
}

uint64_t cmyk64_sample_rgba64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v75 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v76 = *(_DWORD *)(result + 188);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v12 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = 0xFFFF000000000000;
  }
  unint64_t v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v77 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v24 = (a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        HIDWORD(v26) = HIDWORD(a3);
        uint64_t v18 = v77;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v7;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        uint64_t v18 = v77;
        if (v22 < 1) {
          goto LABEL_37;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        unsigned int v25 = v76 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      uint64_t v18 = v77;
      if (v17 < 1) {
        goto LABEL_37;
      }
      if (v17 >= v15) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v25 = v76 | v19;
      uint64_t v26 = v16 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v18) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v18 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v76;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v75)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v75;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v76;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_37;
  }
  unint64_t v35 = v12 + SHIDWORD(v26) * (uint64_t)v4 + 8 * (v30 >> 32);
  uint64_t v36 = *(unint64_t **)(result + 32);
  if (v14 >= v35) {
    uint64_t v37 = (unint64_t *)v35;
  }
  else {
    uint64_t v37 = (unint64_t *)v14;
  }
  if (v37 < v36) {
    uint64_t v37 = *(unint64_t **)(result + 32);
  }
  unint64_t v38 = *v37;
  if (!v5)
  {
    uint64_t v40 = v75;
    goto LABEL_70;
  }
  unsigned int v39 = *(_DWORD *)(v5 + (v31 | v24));
LABEL_41:
  int v41 = v39 & 0xF;
  int v42 = HIBYTE(v39) & 3;
  uint64_t v40 = v75;
  switch(v41)
  {
    case 1:
      unsigned int v59 = (unint64_t *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v14 < (unint64_t)v59) {
        unsigned int v59 = (unint64_t *)v14;
      }
      if (v59 < v36) {
        unsigned int v59 = v36;
      }
      unint64_t v60 = interpolate_16161616_21355[v42];
      char v61 = v42 + 1;
      unint64_t v57 = v38 - ((v60 & v38) >> v61);
      unint64_t v62 = (v60 & *v59) >> v61;
LABEL_69:
      unint64_t v38 = v57 + v62;
      break;
    case 2:
      uint64_t v63 = (unint64_t *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 53));
      if (v14 < (unint64_t)v63) {
        uint64_t v63 = (unint64_t *)v14;
      }
      if (v63 < v36) {
        uint64_t v63 = v36;
      }
      int v64 = (v39 >> 28) & 3;
      uint64_t v65 = interpolate_16161616_21355[v64];
      char v56 = v64 + 1;
      unint64_t v57 = v38 - ((v65 & v38) >> v56);
      unint64_t v58 = v65 & *v63;
LABEL_68:
      unint64_t v62 = v58 >> v56;
      goto LABEL_69;
    case 3:
      int64_t v43 = (unint64_t)HIWORD(v39) << 56;
      uint64_t v44 = (unint64_t *)(v35 + (v43 >> 53));
      if (v14 < (unint64_t)v44) {
        uint64_t v44 = (unint64_t *)v14;
      }
      if (v44 < v36) {
        uint64_t v44 = v36;
      }
      unint64_t v45 = *v44;
      uint64_t v46 = (unint64_t *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v14 >= (unint64_t)v46) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = (unint64_t *)v14;
      }
      if (v47 < v36) {
        uint64_t v47 = v36;
      }
      unint64_t v48 = *v47;
      uint64_t v49 = (unint64_t *)((char *)v46 + (v43 >> 53));
      if (v14 < (unint64_t)v49) {
        uint64_t v49 = (unint64_t *)v14;
      }
      if (v49 < v36) {
        uint64_t v49 = v36;
      }
      unint64_t v50 = interpolate_16161616_21355[v42];
      char v51 = v42 + 1;
      unint64_t v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      unint64_t v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      int v54 = (v39 >> 28) & 3;
      unint64_t v55 = interpolate_16161616_21355[v54];
      char v56 = v54 + 1;
      unint64_t v57 = v52 - ((v52 & v55) >> v56);
      unint64_t v58 = v53 & v55;
      goto LABEL_68;
  }
LABEL_70:
  uint64_t v66 = 0;
  uint64_t v67 = (_WORD *)(v10 + 24);
  a3 += v9;
  uint64_t v68 = v7 - a3;
  a2 += v8;
  uint64_t v69 = v40 - a2;
  while (1)
  {
    unsigned int v70 = (unsigned __int16)v38;
    unsigned int v71 = (unsigned __int16)((v38 | v13) >> 32);
    if ((unsigned __int16)v38 <= WORD1(v38)) {
      unsigned int v70 = WORD1(v38);
    }
    if (v71 <= v70) {
      unsigned int v71 = v70;
    }
    unint64_t v72 = (v38 | v13) >> 48;
    *((void *)v67 - 1) = ((unint64_t)(unsigned __int16)(v71 - ((v38 | v13) >> 32)) << 32) | ((unint64_t)(v72 - v71) << 48) | ((v71 - WORD1(v38)) << 16) | (unsigned __int16)(v71 - v38);
    *uint64_t v67 = v72;
    *(unsigned char *)(v11 + 1 + v66) = v25 >> 22;
    if (a4 - 1 == v66) {
      return result;
    }
    if (((v68 | v69 | (a3 - v6) | (a2 - v77)) & 0x8000000000000000) != 0)
    {
      uint64_t v10 = (uint64_t)(v67 - 4);
      v11 += v66 + 1;
      a4 += ~v66;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v73 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v35 = v73 + 8 * (a2 >> 32);
    uint64_t v36 = *(unint64_t **)(result + 32);
    if (v14 >= v35) {
      unint64_t v74 = (unint64_t *)(v73 + 8 * (a2 >> 32));
    }
    else {
      unint64_t v74 = (unint64_t *)v14;
    }
    if (v74 < v36) {
      unint64_t v74 = *(unint64_t **)(result + 32);
    }
    unint64_t v38 = *v74;
    if (v5)
    {
      unsigned int v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        uint64_t v10 = (uint64_t)(v67 - 4);
        v11 += v66 + 1;
        a4 += ~v66;
        unsigned int v25 = -1;
        goto LABEL_41;
      }
    }
    v67 += 8;
    ++v66;
    a3 += v9;
    v68 -= v9;
    a2 += v8;
    v69 -= v8;
    unsigned int v25 = -1;
  }
}

uint64_t cmyk64_sample_RGBA64(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 176);
  uint64_t v6 = *(void *)(result + 72);
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v72 = *(void *)(result + 80);
  uint64_t v8 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  int v70 = *(_DWORD *)(result + 188);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v11 = *(void *)(result + 144) - 1;
  uint64_t v12 = *(void *)(result + 32);
  if (*(void *)(result + 40)) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = 0xFFFF000000000000;
  }
  unint64_t v14 = v12 + ((*(_DWORD *)(result + 260) - 1) * v4) + 8 * *(unsigned int *)(result + 256) - 8;
  uint64_t v71 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if ((uint64_t)a3 >= v6)
    {
      if ((uint64_t)a3 <= v7)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
        uint64_t v26 = v71;
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v7;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_37;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        uint64_t v26 = v71;
        unsigned int v24 = v70 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v6 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_37;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      uint64_t v26 = v71;
      unsigned int v24 = v70 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v26) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v26 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v70;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = 32;
      goto LABEL_29;
    }
LABEL_37:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 16;
    *(unsigned char *)++uint64_t v11 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v72)
  {
    uint64_t v31 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_29;
  }
  uint64_t v32 = *(void *)(result + 192);
  uint64_t v33 = *(void *)(result + 200) + v72;
  uint64_t v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1) {
    goto LABEL_37;
  }
  if (v34 < v32) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v34) >> 32) >> 15)) | v70;
  }
  uint64_t v30 = v33 - 0x1000000;
  uint64_t v31 = 28;
LABEL_29:
  if (v24 < 0x400000) {
    goto LABEL_37;
  }
  uint64_t v35 = v12 + SHIDWORD(v25) * (uint64_t)v4;
  uint64_t v36 = v30 >> 32;
  unint64_t v37 = v35 + 8 * v36;
  unint64_t v38 = *(unsigned __int16 **)(result + 32);
  if (v14 >= v37) {
    unsigned int v39 = (unsigned __int16 *)(v35 + 8 * v36);
  }
  else {
    unsigned int v39 = (unsigned __int16 *)v14;
  }
  if (v39 < v38) {
    unsigned int v39 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v40 = ((unint64_t)(bswap32(v39[2]) >> 16) << 32) | ((unint64_t)(bswap32(v39[3]) >> 16) << 48) | bswap32(v39[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v39) >> 16);
  if (v5)
  {
    unsigned int v41 = *(_DWORD *)(v5 + (v31 | v23));
LABEL_40:
    int v42 = v41 & 0xF;
    int v43 = HIBYTE(v41) & 3;
    if (v42 == 1)
    {
      int v54 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
      if (v14 < (unint64_t)v54) {
        int v54 = (unsigned __int16 *)v14;
      }
      if (v54 < v38) {
        int v54 = v38;
      }
      uint64_t v55 = interpolate_16161616_21355[v43];
      char v56 = v43 + 1;
      unint64_t v57 = v40 - ((v55 & v40) >> v56);
      unint64_t v58 = ((((unint64_t)(bswap32(v54[2]) >> 16) << 32) | ((unint64_t)(bswap32(v54[3]) >> 16) << 48) | bswap32(v54[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v54) >> 16)) & v55) >> v56;
    }
    else
    {
      if (v42 != 2)
      {
        if (v42 == 3)
        {
          int64_t v44 = (unint64_t)HIWORD(v41) << 56;
          unint64_t v45 = (unsigned __int16 *)(v37 + (v44 >> 53));
          if (v14 < (unint64_t)v45) {
            unint64_t v45 = (unsigned __int16 *)v14;
          }
          if (v45 < v38) {
            unint64_t v45 = v38;
          }
          unint64_t v46 = ((unint64_t)(bswap32(v45[2]) >> 16) << 32) | ((unint64_t)(bswap32(v45[3]) >> 16) << 48) | bswap32(v45[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v45) >> 16);
          unint64_t v47 = v37 + SBYTE1(v41) * (uint64_t)v4;
          if (v14 >= v47) {
            unint64_t v48 = (unsigned __int16 *)(v37 + SBYTE1(v41) * (uint64_t)v4);
          }
          else {
            unint64_t v48 = (unsigned __int16 *)v14;
          }
          if (v48 < v38) {
            unint64_t v48 = v38;
          }
          unint64_t v49 = ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | ((unint64_t)(bswap32(v48[3]) >> 16) << 48) | bswap32(v48[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v48) >> 16);
          unint64_t v50 = (unsigned __int16 *)(v47 + (v44 >> 53));
          if (v14 < (unint64_t)v50) {
            unint64_t v50 = (unsigned __int16 *)v14;
          }
          if (v50 < v38) {
            unint64_t v50 = v38;
          }
          uint64_t v51 = interpolate_16161616_21355[v43];
          char v52 = v43 + 1;
          unint64_t v53 = v40 - ((v51 & v40) >> v52) + ((v49 & v51) >> v52);
          unint64_t v40 = v53
              - ((v53 & interpolate_16161616_21355[(v41 >> 28) & 3]) >> (((v41 >> 28) & 3) + 1))
              + (((v46
                 - ((v51 & v46) >> v52)
                 + (((((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16)) & v51) >> v52)) & interpolate_16161616_21355[(v41 >> 28) & 3]) >> (((v41 >> 28) & 3) + 1));
        }
        goto LABEL_68;
      }
      unsigned int v59 = (unsigned __int16 *)(v37 + ((uint64_t)((unint64_t)HIWORD(v41) << 56) >> 53));
      if (v14 < (unint64_t)v59) {
        unsigned int v59 = (unsigned __int16 *)v14;
      }
      if (v59 < v38) {
        unsigned int v59 = v38;
      }
      int v60 = (v41 >> 28) & 3;
      uint64_t v61 = interpolate_16161616_21355[v60];
      LOBYTE(v60) = v60 + 1;
      unint64_t v57 = v40 - ((v61 & v40) >> v60);
      unint64_t v58 = ((((unint64_t)(bswap32(v59[2]) >> 16) << 32) | ((unint64_t)(bswap32(v59[3]) >> 16) << 48) | bswap32(v59[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v59) >> 16)) & v61) >> v60;
    }
    unint64_t v40 = v57 + v58;
  }
LABEL_68:
  uint64_t v62 = 0;
  uint64_t v63 = (_WORD *)(v10 + 24);
  a3 += v9;
  uint64_t v64 = v7 - a3;
  a2 += v8;
  uint64_t v65 = v72 - a2;
  while (1)
  {
    unsigned int v66 = (unsigned __int16)v40;
    if ((unsigned __int16)v40 <= WORD1(v40)) {
      unsigned int v66 = WORD1(v40);
    }
    if ((unsigned __int16)((v40 | v13) >> 32) > v66) {
      unsigned int v66 = (unsigned __int16)((v40 | v13) >> 32);
    }
    unint64_t v67 = (v40 | v13) >> 48;
    *((void *)v63 - 1) = ((unint64_t)(unsigned __int16)(v66 - ((v40 | v13) >> 32)) << 32) | ((unint64_t)(v67 - v66) << 48) | ((v66 - WORD1(v40)) << 16) | (unsigned __int16)(v66 - v40);
    *uint64_t v63 = v67;
    *(unsigned char *)(v11 + 1 + v62) = v24 >> 22;
    if (a4 - 1 == v62) {
      return result;
    }
    if (((v64 | v65 | (a3 - v6) | (a2 - v71)) & 0x8000000000000000) != 0)
    {
      v11 += v62 + 1;
      uint64_t v10 = (uint64_t)(v63 - 4);
      a4 += ~v62;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    uint64_t v68 = v12 + SHIDWORD(a3) * (uint64_t)v4;
    unint64_t v37 = v68 + 8 * (a2 >> 32);
    unint64_t v38 = *(unsigned __int16 **)(result + 32);
    if (v14 >= v37) {
      uint64_t v69 = (unsigned __int16 *)(v68 + 8 * (a2 >> 32));
    }
    else {
      uint64_t v69 = (unsigned __int16 *)v14;
    }
    if (v69 < v38) {
      uint64_t v69 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v40 = ((unint64_t)(bswap32(v69[2]) >> 16) << 32) | ((unint64_t)(bswap32(v69[3]) >> 16) << 48) | bswap32(v69[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v69) >> 16);
    if (v5)
    {
      unsigned int v41 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v41 & 0xF) != 0)
      {
        v11 += v62 + 1;
        uint64_t v10 = (uint64_t)(v63 - 4);
        a4 += ~v62;
        unsigned int v24 = -1;
        goto LABEL_40;
      }
    }
    ++v62;
    v63 += 8;
    a3 += v9;
    v64 -= v9;
    a2 += v8;
    v65 -= v8;
    unsigned int v24 = -1;
  }
}

uint64_t cmyk64_sample_rgb48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 64);
  uint64_t v8 = *(void *)(result + 72);
  uint64_t v9 = *(void *)(result + 88);
  uint64_t v71 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  uint64_t v12 = *(void *)(result + 152) - 16;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v70 = *(_DWORD *)(result + 188);
  unint64_t v14 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v9;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_34;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v70 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v8 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_34;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v70 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v7) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v7 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v70;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(unsigned char *)++uint64_t v13 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v71)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v71;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v70;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned int **)(result + 32);
  if (v14 >= v36) {
    unint64_t v38 = (unsigned int *)(v35 + 6 * (int)v34);
  }
  else {
    unint64_t v38 = (unsigned int *)v14;
  }
  if (v38 < v37) {
    unint64_t v38 = *(unsigned int **)(result + 32);
  }
  unint64_t v39 = *v38 | ((unint64_t)*((unsigned __int16 *)v38 + 2) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      uint64_t v55 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v55) {
        uint64_t v55 = (unsigned int *)v14;
      }
      if (v55 < v37) {
        uint64_t v55 = v37;
      }
      uint64_t v56 = interpolate_16161616_21355[v42];
      char v57 = v42 + 1;
      unint64_t v58 = v39 - ((v56 & v39) >> v57);
      unint64_t v59 = ((*v55 | ((unint64_t)*((unsigned __int16 *)v55 + 2) << 32) | 0xFFFF000000000000) & v56) >> v57;
LABEL_65:
      unint64_t v39 = v58 + v59;
      break;
    case 2:
      int v60 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v60) {
        int v60 = (unsigned int *)v14;
      }
      if (v60 < v37) {
        int v60 = v37;
      }
      unint64_t v51 = *v60 | ((unint64_t)*((unsigned __int16 *)v60 + 2) << 32) | 0xFFFF000000000000;
      int v52 = (v40 >> 28) & 3;
      uint64_t v53 = interpolate_16161616_21355[v52];
      unint64_t v54 = v53 & v39;
LABEL_64:
      char v61 = v52 + 1;
      unint64_t v58 = v39 - (v54 >> v61);
      unint64_t v59 = (v51 & v53) >> v61;
      goto LABEL_65;
    case 3:
      int v43 = (unsigned int *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v43) {
        int v43 = (unsigned int *)v14;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = *v43 | ((unint64_t)*((unsigned __int16 *)v43 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v45) {
        unint64_t v46 = (unsigned int *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned int *)v14;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = *v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned int *)(v45 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v48) {
        unint64_t v48 = (unsigned int *)v14;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v39 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v51 = v44
          - ((v49 & v44) >> v50)
          + (((*v48 | ((unint64_t)*((unsigned __int16 *)v48 + 2) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v52 = (v40 >> 28) & 3;
      uint64_t v53 = interpolate_16161616_21355[v52];
      unint64_t v54 = v39 & v53;
      goto LABEL_64;
  }
LABEL_66:
  uint64_t v62 = 0;
  uint64_t v63 = (_WORD *)(v12 + 24);
  a3 += v11;
  uint64_t v64 = v9 - a3;
  a2 += v10;
  uint64_t v65 = v71 - a2;
  while (1)
  {
    unsigned int v66 = (unsigned __int16)v39;
    unsigned int v67 = WORD2(v39);
    if ((unsigned __int16)v39 <= WORD1(v39)) {
      unsigned int v66 = WORD1(v39);
    }
    if (WORD2(v39) <= v66) {
      unsigned int v67 = v66;
    }
    *((void *)v63 - 1) = ((unint64_t)(unsigned __int16)(v67 - WORD2(v39)) << 32) | ((HIWORD(v39) - v67) << 48) | ((v67 - WORD1(v39)) << 16) | (unsigned __int16)(v67 - v39);
    *uint64_t v63 = HIWORD(v39);
    *(unsigned char *)(v13 + 1 + v62) = v24 >> 22;
    if (a4 - 1 == v62) {
      return result;
    }
    if (((v64 | v65 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v62 + 1;
      uint64_t v12 = (uint64_t)(v63 - 4);
      a4 += ~v62;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v68 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v36 = v68 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned int **)(result + 32);
    if (v14 >= v36) {
      uint64_t v69 = (unsigned int *)(v68 + 6 * SHIDWORD(a2));
    }
    else {
      uint64_t v69 = (unsigned int *)v14;
    }
    if (v69 < v37) {
      uint64_t v69 = *(unsigned int **)(result + 32);
    }
    unint64_t v39 = *v69 | ((unint64_t)*((unsigned __int16 *)v69 + 2) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v62 + 1;
        uint64_t v12 = (uint64_t)(v63 - 4);
        a4 += ~v62;
        unsigned int v24 = -1;
        goto LABEL_37;
      }
    }
    ++v62;
    v63 += 8;
    a3 += v11;
    v64 -= v11;
    a2 += v10;
    v65 -= v10;
    unsigned int v24 = -1;
  }
}

uint64_t cmyk64_sample_RGB48(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = *(void *)(result + 176);
  uint64_t v7 = *(void *)(result + 64);
  uint64_t v8 = *(void *)(result + 72);
  uint64_t v9 = *(void *)(result + 88);
  uint64_t v67 = *(void *)(result + 80);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v11 = *(void *)(result + 120);
  uint64_t v12 = *(void *)(result + 152) - 16;
  uint64_t v13 = *(void *)(result + 144) - 1;
  int v66 = *(_DWORD *)(result + 188);
  unint64_t v14 = v4
      + ((*(_DWORD *)(result + 260) - 1) * v5)
      + 2 * (3 * *(_DWORD *)(result + 256))
      - 6;
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v8)
    {
      if ((uint64_t)a3 <= v9)
      {
        uint64_t v23 = (a3 >> 22) & 0x3C0;
        unsigned int v24 = 0x3FFFFFFF;
        HIDWORD(v25) = HIDWORD(a3);
      }
      else
      {
        uint64_t v19 = *(void *)(result + 216);
        uint64_t v20 = *(void *)(result + 224) + v9;
        uint64_t v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1) {
          goto LABEL_34;
        }
        if (v21 >= v19) {
          LODWORD(v22) = 0x3FFFFFFF;
        }
        else {
          unint64_t v22 = (unint64_t)(*(void *)(result + 232) * v21) >> 32;
        }
        unsigned int v24 = v66 | v22;
        uint64_t v25 = v20 - 0x1000000;
        uint64_t v23 = 448;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(result + 216);
      uint64_t v16 = v8 - *(void *)(result + 224);
      uint64_t v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1) {
        goto LABEL_34;
      }
      if (v17 >= v15) {
        LODWORD(v18) = 0x3FFFFFFF;
      }
      else {
        unint64_t v18 = (unint64_t)(*(void *)(result + 232) * v17) >> 32;
      }
      unsigned int v24 = v66 | v18;
      uint64_t v25 = v16 + 0x1000000;
      uint64_t v23 = 512;
    }
    if (a2 >= v7) {
      break;
    }
    uint64_t v26 = *(void *)(result + 192);
    uint64_t v27 = v7 - *(void *)(result + 200);
    uint64_t v28 = a2 - v27 + (v26 >> 1);
    if (v28 >= 1)
    {
      if (v28 < v26) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v28) >> 32) >> 15)) | v66;
      }
      uint64_t v29 = v27 + 0x1000000;
      uint64_t v30 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v10;
    a3 += v11;
    v12 += 16;
    *(unsigned char *)++uint64_t v13 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v67)
  {
    uint64_t v30 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v29 = a2;
    goto LABEL_26;
  }
  uint64_t v31 = *(void *)(result + 192);
  uint64_t v32 = *(void *)(result + 200) + v67;
  uint64_t v33 = v32 - a2 + (v31 >> 1);
  if (v33 < 1) {
    goto LABEL_34;
  }
  if (v33 < v31) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v66;
  }
  uint64_t v29 = v32 - 0x1000000;
  uint64_t v30 = 28;
LABEL_26:
  if (v24 < 0x400000) {
    goto LABEL_34;
  }
  uint64_t v34 = v29 >> 32;
  uint64_t v35 = v4 + SHIDWORD(v25) * (uint64_t)v5;
  unint64_t v36 = v35 + 6 * (int)v34;
  unint64_t v37 = *(unsigned __int16 **)(result + 32);
  if (v14 >= v36) {
    unint64_t v38 = (unsigned __int16 *)(v35 + 6 * (int)v34);
  }
  else {
    unint64_t v38 = (unsigned __int16 *)v14;
  }
  if (v38 < v37) {
    unint64_t v38 = *(unsigned __int16 **)(result + 32);
  }
  unint64_t v39 = (bswap32(*v38) >> 16) | ((unint64_t)(bswap32(v38[1]) >> 16) << 16) | ((unint64_t)(bswap32(v38[2]) >> 16) << 32) | 0xFFFF000000000000;
  if (!v6) {
    goto LABEL_66;
  }
  unsigned int v40 = *(_DWORD *)(v6 + (v30 | v23));
LABEL_37:
  int v41 = v40 & 0xF;
  int v42 = HIBYTE(v40) & 3;
  switch(v41)
  {
    case 1:
      char v57 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      if (v14 < (unint64_t)v57) {
        char v57 = (unsigned __int16 *)v14;
      }
      if (v57 < v37) {
        char v57 = v37;
      }
      unint64_t v52 = (bswap32(*v57) >> 16) | ((unint64_t)(bswap32(v57[1]) >> 16) << 16) | ((unint64_t)(bswap32(v57[2]) >> 16) << 32) | 0xFFFF000000000000;
      goto LABEL_64;
    case 2:
      unint64_t v58 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v58) {
        unint64_t v58 = (unsigned __int16 *)v14;
      }
      if (v58 < v37) {
        unint64_t v58 = v37;
      }
      unint64_t v52 = (bswap32(*v58) >> 16) | ((unint64_t)(bswap32(v58[1]) >> 16) << 16) | ((unint64_t)(bswap32(v58[2]) >> 16) << 32) | 0xFFFF000000000000;
      int v42 = (v40 >> 28) & 3;
LABEL_64:
      uint64_t v54 = interpolate_16161616_21355[v42];
      char v55 = v42 + 1;
      unint64_t v56 = v39 - ((v54 & v39) >> v55);
      goto LABEL_65;
    case 3:
      int v43 = (unsigned __int16 *)(v36 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v43) {
        int v43 = (unsigned __int16 *)v14;
      }
      if (v43 < v37) {
        int v43 = v37;
      }
      unint64_t v44 = (bswap32(*v43) >> 16) | ((unint64_t)(bswap32(v43[1]) >> 16) << 16) | ((unint64_t)(bswap32(v43[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v45 = v36 + SBYTE1(v40) * (uint64_t)v5;
      if (v14 >= v45) {
        unint64_t v46 = (unsigned __int16 *)(v36 + SBYTE1(v40) * (uint64_t)v5);
      }
      else {
        unint64_t v46 = (unsigned __int16 *)v14;
      }
      if (v46 < v37) {
        unint64_t v46 = v37;
      }
      unint64_t v47 = (bswap32(*v46) >> 16) | ((unint64_t)(bswap32(v46[1]) >> 16) << 16) | ((unint64_t)(bswap32(v46[2]) >> 16) << 32) | 0xFFFF000000000000;
      unint64_t v48 = (unsigned __int16 *)(v45 + 6 * SBYTE2(v40));
      if (v14 < (unint64_t)v48) {
        unint64_t v48 = (unsigned __int16 *)v14;
      }
      if (v48 < v37) {
        unint64_t v48 = v37;
      }
      uint64_t v49 = interpolate_16161616_21355[v42];
      char v50 = v42 + 1;
      unint64_t v51 = v39 - ((v49 & v39) >> v50) + ((v47 & v49) >> v50);
      unint64_t v52 = v44
          - ((v49 & v44) >> v50)
          + ((((bswap32(*v48) >> 16) | ((unint64_t)(bswap32(v48[1]) >> 16) << 16) | ((unint64_t)(bswap32(v48[2]) >> 16) << 32) | 0xFFFF000000000000) & v49) >> v50);
      int v53 = (v40 >> 28) & 3;
      uint64_t v54 = interpolate_16161616_21355[v53];
      char v55 = v53 + 1;
      unint64_t v56 = v51 - ((v51 & v54) >> v55);
LABEL_65:
      unint64_t v39 = v56 + ((v52 & v54) >> v55);
      break;
  }
LABEL_66:
  uint64_t v59 = 0;
  int v60 = (_WORD *)(v12 + 24);
  a3 += v11;
  uint64_t v61 = v9 - a3;
  a2 += v10;
  uint64_t v62 = v67 - a2;
  while (1)
  {
    unsigned int v63 = (unsigned __int16)v39;
    if ((unsigned __int16)v39 <= WORD1(v39)) {
      unsigned int v63 = WORD1(v39);
    }
    if (WORD2(v39) > v63) {
      unsigned int v63 = WORD2(v39);
    }
    *((void *)v60 - 1) = ((unint64_t)(unsigned __int16)(v63 - WORD2(v39)) << 32) | ((HIWORD(v39) - v63) << 48) | ((v63 - WORD1(v39)) << 16) | (unsigned __int16)(v63 - v39);
    _WORD *v60 = HIWORD(v39);
    *(unsigned char *)(v13 + 1 + v59) = v24 >> 22;
    if (a4 - 1 == v59) {
      return result;
    }
    if (((v61 | v62 | (a3 - v8) | (a2 - v7)) & 0x8000000000000000) != 0)
    {
      v13 += v59 + 1;
      uint64_t v12 = (uint64_t)(v60 - 4);
      a4 += ~v59;
      if (a4) {
        goto LABEL_2;
      }
      return result;
    }
    uint64_t v64 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    unint64_t v36 = v64 + 6 * SHIDWORD(a2);
    unint64_t v37 = *(unsigned __int16 **)(result + 32);
    if (v14 >= v36) {
      uint64_t v65 = (unsigned __int16 *)(v64 + 6 * SHIDWORD(a2));
    }
    else {
      uint64_t v65 = (unsigned __int16 *)v14;
    }
    if (v65 < v37) {
      uint64_t v65 = *(unsigned __int16 **)(result + 32);
    }
    unint64_t v39 = (bswap32(*v65) >> 16) | ((unint64_t)(bswap32(v65[1]) >> 16) << 16) | ((unint64_t)(bswap32(v65[2]) >> 16) << 32) | 0xFFFF000000000000;
    if (v6)
    {
      unsigned int v40 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v40 & 0xF) != 0)
      {
        v13 += v59 + 1;
        uint64_t v12 = (uint64_t)(v60 - 4);
        a4 += ~v59;
        unsigned int v24 = -1;
        goto LABEL_37;
      }
    }
    ++v59;
    v60 += 8;
    a3 += v11;
    v61 -= v11;
    a2 += v10;
    v62 -= v10;
    unsigned int v24 = -1;
  }
}

uint64_t cmyk64_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v95 = *(void *)(result + 80);
  uint64_t v97 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 16;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    int v13 = 0;
  }
  else {
    int v13 = -65536;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  unint64_t v16 = v5 + (v14 * v7) + 2 * (v15 - 1);
  int v94 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + (v14 * v6) + 2 * v15 - 2;
  uint64_t v96 = *(void *)(result + 64);
  uint64_t v98 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v98)
      {
        if (a3 <= v97)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v96;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v97;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v96;
          unsigned int v27 = v94 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v98 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v96;
        unsigned int v27 = v94 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v94;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 16;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v95)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_29;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v95;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_43;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v94;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v4 + (int)v38 * (uint64_t)v6;
    unint64_t v40 = (v33 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v41 = v39 + v40;
    int v42 = *(unsigned __int16 **)(result + 32);
    if (v17 >= v39 + v40) {
      int v43 = (unsigned __int16 *)(v39 + v40);
    }
    else {
      int v43 = (unsigned __int16 *)v17;
    }
    if (v43 < v42) {
      int v43 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v44 = *v43;
    if (v5)
    {
      unint64_t v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      unint64_t v46 = *(unsigned __int16 **)(result + 40);
      if (v16 >= v45) {
        unint64_t v47 = (unsigned __int16 *)v45;
      }
      else {
        unint64_t v47 = (unsigned __int16 *)v16;
      }
      if (v47 >= v46) {
        unint64_t v46 = v47;
      }
      v44 |= *v46 << 16;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v45 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v48 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    int v49 = v48 & 0xF;
    int v50 = HIBYTE(v48) & 3;
    switch(v49)
    {
      case 1:
        uint64_t v71 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 < (unint64_t)v71) {
          uint64_t v71 = (unsigned __int16 *)v17;
        }
        if (v71 < v42) {
          uint64_t v71 = v42;
        }
        unsigned int v72 = *v71;
        if (v5)
        {
          uint64_t v73 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          if (v16 < (unint64_t)v73) {
            uint64_t v73 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v73 < *(void *)(result + 40)) {
            uint64_t v73 = *(unsigned __int16 **)(result + 40);
          }
          v72 |= *v73 << 16;
        }
        int v74 = interpolate_1616[v50];
        char v75 = v50 + 1;
        unsigned int v69 = v44 - ((v74 & v44) >> v75);
        unsigned int v76 = (v74 & v72) >> v75;
        goto LABEL_103;
      case 2:
        uint64_t v77 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v77) {
          uint64_t v77 = (unsigned __int16 *)v17;
        }
        if (v77 < v42) {
          uint64_t v77 = v42;
        }
        int v78 = *v77;
        if (v5)
        {
          unint64_t v79 = (unsigned __int16 *)(v45 + 2 * SBYTE2(v48));
          if (v16 < (unint64_t)v79) {
            unint64_t v79 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v79 < *(void *)(result + 40)) {
            unint64_t v79 = *(unsigned __int16 **)(result + 40);
          }
          v78 |= *v79 << 16;
        }
        int v80 = (v48 >> 28) & 3;
        int v81 = interpolate_1616[v80];
        char v68 = v80 + 1;
        unsigned int v69 = v44 - ((v81 & v44) >> v68);
        unsigned int v70 = v81 & v78;
        goto LABEL_102;
      case 3:
        unint64_t v51 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v51) {
          unint64_t v51 = (unsigned __int16 *)v17;
        }
        if (v51 < v42) {
          unint64_t v51 = v42;
        }
        unsigned int v52 = *v51;
        int v53 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 >= (unint64_t)v53) {
          uint64_t v54 = v53;
        }
        else {
          uint64_t v54 = (unsigned __int16 *)v17;
        }
        if (v54 < v42) {
          uint64_t v54 = v42;
        }
        unsigned int v93 = *v54;
        char v55 = &v53[SBYTE2(v48)];
        if (v17 < (unint64_t)v55) {
          char v55 = (unsigned __int16 *)v17;
        }
        if (v55 < v42) {
          char v55 = v42;
        }
        unsigned int v56 = *v55;
        if (v5)
        {
          uint64_t v92 = 2 * SBYTE2(v48);
          char v57 = (unsigned __int16 *)(v45 + v92);
          unint64_t v58 = *(void *)(result + 40);
          if (v16 < v45 + v92) {
            char v57 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v57 < v58) {
            char v57 = *(unsigned __int16 **)(result + 40);
          }
          v52 |= *v57 << 16;
          unint64_t v59 = v45 + SBYTE1(v48) * (uint64_t)v7;
          if (v16 >= v59) {
            int v60 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          }
          else {
            int v60 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v60 < v58) {
            int v60 = *(unsigned __int16 **)(result + 40);
          }
          v93 |= *v60 << 16;
          uint64_t v61 = (unsigned __int16 *)(v59 + v92);
          if (v16 < v59 + v92) {
            uint64_t v61 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v61 < v58) {
            uint64_t v61 = *(unsigned __int16 **)(result + 40);
          }
          v56 |= *v61 << 16;
        }
        int v62 = interpolate_1616[v50];
        char v63 = v50 + 1;
        unsigned int v64 = v44 - ((v62 & v44) >> v63) + ((v62 & v93) >> v63);
        unsigned int v65 = v52 - ((v62 & v52) >> v63) + ((v62 & v56) >> v63);
        int v66 = (v48 >> 28) & 3;
        int v67 = interpolate_1616[v66];
        char v68 = v66 + 1;
        unsigned int v69 = v64 - ((v64 & v67) >> v68);
        unsigned int v70 = v65 & v67;
LABEL_102:
        unsigned int v76 = v70 >> v68;
LABEL_103:
        unsigned int v44 = v69 + v76;
        break;
    }
LABEL_104:
    unsigned int v82 = (v44 | v13) >> 16;
    *(void *)(v11 + 16) = (unint64_t)(v82 - v44) << 48;
    *(_WORD *)(v11 + 24) = v82;
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v83 = 0;
    uint64_t v84 = (_WORD *)(v11 + 40);
    a2 += v10;
    uint64_t v85 = v95 - a2;
    a3 += v9;
    uint64_t v86 = v97 - a3;
    while (((v86 | v85 | (a3 - v98) | (a2 - v96)) & 0x8000000000000000) == 0)
    {
      unint64_t v87 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v41 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v87;
      int v42 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v41) {
        uint64_t v88 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v87);
      }
      else {
        uint64_t v88 = (unsigned __int16 *)v17;
      }
      if (v88 < v42) {
        uint64_t v88 = *(unsigned __int16 **)(result + 32);
      }
      unsigned int v44 = *v88;
      if (v5)
      {
        unint64_t v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v87;
        uint64_t v89 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v45) {
          uint64_t v90 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v87);
        }
        else {
          uint64_t v90 = (unsigned __int16 *)v16;
        }
        if (v90 >= v89) {
          uint64_t v89 = v90;
        }
        v44 |= *v89 << 16;
      }
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v48 & 0xF) != 0)
        {
          v12 += v83 + 1;
          uint64_t v11 = (uint64_t)(v84 - 12);
          a4 += ~v83;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      unsigned int v91 = (v44 | v13) >> 16;
      *((void *)v84 - 1) = (unint64_t)(v91 - v44) << 48;
      _WORD *v84 = v91;
      v84 += 8;
      *(unsigned char *)(v12 + v83++ + 2) = -1;
      a2 += v10;
      v85 -= v10;
      a3 += v9;
      v86 -= v9;
      if (a4 - 1 == v83) {
        return result;
      }
    }
    v12 += v83 + 1;
    uint64_t v11 = (uint64_t)(v84 - 12);
    a4 += ~v83;
  }
  while (a4);
  return result;
}

uint64_t cmyk64_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  int v7 = *(_DWORD *)(result + 28);
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v95 = *(void *)(result + 80);
  uint64_t v97 = *(void *)(result + 88);
  uint64_t v10 = *(void *)(result + 112);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v11 = *(void *)(result + 152) - 16;
  uint64_t v12 = *(void *)(result + 144) - 1;
  if (v5) {
    int v13 = 0;
  }
  else {
    int v13 = -65536;
  }
  int v14 = *(_DWORD *)(result + 260) - 1;
  uint64_t v15 = *(unsigned int *)(result + 256);
  unint64_t v16 = v5 + (v14 * v7) + 2 * (v15 - 1);
  int v94 = *(_DWORD *)(result + 188);
  unint64_t v17 = v4 + (v14 * v6) + 2 * v15 - 2;
  uint64_t v96 = *(void *)(result + 64);
  uint64_t v98 = *(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v98)
      {
        if (a3 <= v97)
        {
          uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v27 = 0x3FFFFFFF;
          uint64_t v28 = a3;
          uint64_t v29 = v96;
        }
        else
        {
          uint64_t v22 = *(void *)(result + 216);
          uint64_t v23 = *(void *)(result + 224) + v97;
          uint64_t v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1) {
            goto LABEL_43;
          }
          if (v24 >= v22) {
            LODWORD(v25) = 0x3FFFFFFF;
          }
          else {
            unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
          }
          uint64_t v29 = v96;
          unsigned int v27 = v94 | v25;
          uint64_t v28 = v23 - 0x1000000;
          uint64_t v26 = 448;
        }
      }
      else
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v98 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_43;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        uint64_t v29 = v96;
        unsigned int v27 = v94 | v21;
        uint64_t v28 = v19 + 0x1000000;
        uint64_t v26 = 512;
      }
      if (a2 >= v29) {
        break;
      }
      uint64_t v30 = *(void *)(result + 192);
      uint64_t v31 = v29 - *(void *)(result + 200);
      uint64_t v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v32) >> 32) >> 15)) | v94;
        }
        uint64_t v33 = v31 + 0x1000000;
        uint64_t v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 16;
      *(unsigned char *)++uint64_t v12 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v95)
    {
      uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v33 = a2;
      goto LABEL_29;
    }
    uint64_t v35 = *(void *)(result + 192);
    uint64_t v36 = *(void *)(result + 200) + v95;
    uint64_t v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1) {
      goto LABEL_43;
    }
    if (v37 < v35) {
      unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v94;
    }
    uint64_t v33 = v36 - 0x1000000;
    uint64_t v34 = 28;
LABEL_29:
    if (v27 < 0x400000) {
      goto LABEL_43;
    }
    uint64_t v38 = v28 >> 32;
    uint64_t v39 = v4 + (int)v38 * (uint64_t)v6;
    unint64_t v40 = (v33 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v41 = v39 + v40;
    int v42 = *(unsigned __int16 **)(result + 32);
    if (v17 >= v39 + v40) {
      int v43 = (unsigned __int16 *)(v39 + v40);
    }
    else {
      int v43 = (unsigned __int16 *)v17;
    }
    if (v43 < v42) {
      int v43 = *(unsigned __int16 **)(result + 32);
    }
    unsigned int v44 = bswap32(*v43) >> 16;
    if (v5)
    {
      unint64_t v45 = v5 + (int)v38 * (uint64_t)v7 + v40;
      unint64_t v46 = *(unsigned __int16 **)(result + 40);
      if (v16 >= v45) {
        unint64_t v47 = (unsigned __int16 *)v45;
      }
      else {
        unint64_t v47 = (unsigned __int16 *)v16;
      }
      if (v47 >= v46) {
        unint64_t v46 = v47;
      }
      v44 |= bswap32(*v46) & 0xFFFF0000;
      if (!v8) {
        goto LABEL_104;
      }
    }
    else
    {
      unint64_t v45 = 0;
      if (!v8) {
        goto LABEL_104;
      }
    }
    unsigned int v48 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    int v49 = v48 & 0xF;
    int v50 = HIBYTE(v48) & 3;
    switch(v49)
    {
      case 1:
        uint64_t v71 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 < (unint64_t)v71) {
          uint64_t v71 = (unsigned __int16 *)v17;
        }
        if (v71 < v42) {
          uint64_t v71 = v42;
        }
        unsigned int v72 = bswap32(*v71) >> 16;
        if (v5)
        {
          uint64_t v73 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          if (v16 < (unint64_t)v73) {
            uint64_t v73 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v73 < *(void *)(result + 40)) {
            uint64_t v73 = *(unsigned __int16 **)(result + 40);
          }
          v72 |= bswap32(*v73) & 0xFFFF0000;
        }
        int v74 = interpolate_1616[v50];
        char v75 = v50 + 1;
        unsigned int v69 = v44 - ((v74 & v44) >> v75);
        unsigned int v76 = (v74 & v72) >> v75;
        goto LABEL_103;
      case 2:
        uint64_t v77 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v77) {
          uint64_t v77 = (unsigned __int16 *)v17;
        }
        if (v77 < v42) {
          uint64_t v77 = v42;
        }
        unsigned int v78 = bswap32(*v77) >> 16;
        if (v5)
        {
          unint64_t v79 = (unsigned __int16 *)(v45 + 2 * SBYTE2(v48));
          if (v16 < (unint64_t)v79) {
            unint64_t v79 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v79 < *(void *)(result + 40)) {
            unint64_t v79 = *(unsigned __int16 **)(result + 40);
          }
          v78 |= bswap32(*v79) & 0xFFFF0000;
        }
        int v80 = (v48 >> 28) & 3;
        int v81 = interpolate_1616[v80];
        char v68 = v80 + 1;
        unsigned int v69 = v44 - ((v81 & v44) >> v68);
        unsigned int v70 = v81 & v78;
        goto LABEL_102;
      case 3:
        int v92 = HIBYTE(v48) & 3;
        unint64_t v51 = (unsigned __int16 *)(v41 + 2 * SBYTE2(v48));
        if (v17 < (unint64_t)v51) {
          unint64_t v51 = (unsigned __int16 *)v17;
        }
        if (v51 < v42) {
          unint64_t v51 = v42;
        }
        unsigned int v52 = bswap32(*v51) >> 16;
        int v53 = (unsigned __int16 *)(v41 + SBYTE1(v48) * (uint64_t)v6);
        if (v17 >= (unint64_t)v53) {
          uint64_t v54 = v53;
        }
        else {
          uint64_t v54 = (unsigned __int16 *)v17;
        }
        if (v54 < v42) {
          uint64_t v54 = v42;
        }
        unsigned int v93 = bswap32(*v54) >> 16;
        char v55 = &v53[SBYTE2(v48)];
        if (v17 < (unint64_t)v55) {
          char v55 = (unsigned __int16 *)v17;
        }
        if (v55 < v42) {
          char v55 = v42;
        }
        unsigned int v56 = bswap32(*v55) >> 16;
        if (v5)
        {
          uint64_t v57 = 2 * SBYTE2(v48);
          unint64_t v58 = (unsigned __int16 *)(v45 + v57);
          unint64_t v59 = *(void *)(result + 40);
          if (v16 < v45 + v57) {
            unint64_t v58 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v58 < v59) {
            unint64_t v58 = *(unsigned __int16 **)(result + 40);
          }
          v52 |= bswap32(*v58) & 0xFFFF0000;
          unint64_t v60 = v45 + SBYTE1(v48) * (uint64_t)v7;
          if (v16 >= v60) {
            uint64_t v61 = (unsigned __int16 *)(v45 + SBYTE1(v48) * (uint64_t)v7);
          }
          else {
            uint64_t v61 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v61 < v59) {
            uint64_t v61 = *(unsigned __int16 **)(result + 40);
          }
          v93 |= bswap32(*v61) & 0xFFFF0000;
          int v62 = (unsigned __int16 *)(v60 + v57);
          if (v16 < (unint64_t)v62) {
            int v62 = (unsigned __int16 *)v16;
          }
          if ((unint64_t)v62 < v59) {
            int v62 = *(unsigned __int16 **)(result + 40);
          }
          v56 |= bswap32(*v62) & 0xFFFF0000;
        }
        int v63 = interpolate_1616[v92];
        unsigned int v64 = v44 - ((v63 & v44) >> (v92 + 1)) + ((v63 & v93) >> (v92 + 1));
        unsigned int v65 = v52 - ((v63 & v52) >> (v92 + 1)) + ((v63 & v56) >> (v92 + 1));
        int v66 = (v48 >> 28) & 3;
        int v67 = interpolate_1616[v66];
        char v68 = v66 + 1;
        unsigned int v69 = v64 - ((v64 & v67) >> v68);
        unsigned int v70 = v65 & v67;
LABEL_102:
        unsigned int v76 = v70 >> v68;
LABEL_103:
        unsigned int v44 = v69 + v76;
        break;
    }
LABEL_104:
    unsigned int v82 = (v44 | v13) >> 16;
    *(void *)(v11 + 16) = (unint64_t)(v82 - v44) << 48;
    *(_WORD *)(v11 + 24) = v82;
    *(unsigned char *)(v12 + 1) = v27 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v83 = 0;
    uint64_t v84 = (_WORD *)(v11 + 40);
    a2 += v10;
    uint64_t v85 = v95 - a2;
    a3 += v9;
    uint64_t v86 = v97 - a3;
    while (((v86 | v85 | (a3 - v98) | (a2 - v96)) & 0x8000000000000000) == 0)
    {
      unint64_t v87 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v41 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v87;
      int v42 = *(unsigned __int16 **)(result + 32);
      if (v17 >= v41) {
        uint64_t v88 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v87);
      }
      else {
        uint64_t v88 = (unsigned __int16 *)v17;
      }
      if (v88 < v42) {
        uint64_t v88 = *(unsigned __int16 **)(result + 32);
      }
      unsigned int v44 = bswap32(*v88) >> 16;
      if (v5)
      {
        unint64_t v45 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v87;
        uint64_t v89 = *(unsigned __int16 **)(result + 40);
        if (v16 >= v45) {
          uint64_t v90 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v87);
        }
        else {
          uint64_t v90 = (unsigned __int16 *)v16;
        }
        if (v90 >= v89) {
          uint64_t v89 = v90;
        }
        v44 |= bswap32(*v89) & 0xFFFF0000;
      }
      if (v8)
      {
        unsigned int v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v48 & 0xF) != 0)
        {
          v12 += v83 + 1;
          uint64_t v11 = (uint64_t)(v84 - 12);
          a4 += ~v83;
          unsigned int v27 = -1;
          goto LABEL_48;
        }
      }
      unsigned int v91 = (v44 | v13) >> 16;
      *((void *)v84 - 1) = (unint64_t)(v91 - v44) << 48;
      _WORD *v84 = v91;
      v84 += 8;
      *(unsigned char *)(v12 + v83++ + 2) = -1;
      a2 += v10;
      v85 -= v10;
      a3 += v9;
      v86 -= v9;
      if (a4 - 1 == v83) {
        return result;
      }
    }
    v12 += v83 + 1;
    uint64_t v11 = (uint64_t)(v84 - 12);
    a4 += ~v83;
  }
  while (a4);
  return result;
}

uint64_t cmyk64_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v91 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v93 = *(void *)(result + 88);
  uint64_t v94 = *(void *)(result + 144) - 1;
  if (v5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 0xFF00000000;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v95 = *(_DWORD *)(result + 28);
  int v89 = *(_DWORD *)(result + 188);
  int v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v95));
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  uint64_t v92 = *(void *)(result + 72);
  uint64_t v90 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v92)
    {
      if (a3 <= v93)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v90;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v93;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v90;
        unsigned int v25 = v89 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v92 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v90;
      unsigned int v25 = v89 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v89;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v9;
    a3 += v8;
    v10 += 16;
    *(unsigned char *)++uint64_t v94 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v91)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v91;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v89;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  unint64_t v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  uint64_t v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38) {
    unint64_t v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  }
  else {
    unint64_t v40 = (unsigned int *)v15;
  }
  if (v40 < v39) {
    unint64_t v40 = *(unsigned int **)(result + 32);
  }
  unint64_t v41 = *v40;
  if (v5)
  {
    unint64_t v42 = v5 + (int)v36 * (uint64_t)v95 + v37;
    int v43 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v14 >= v42) {
      unsigned int v44 = (unsigned __int8 *)v42;
    }
    else {
      unsigned int v44 = v14;
    }
    if (v44 >= v43) {
      int v43 = v44;
    }
    v41 |= (unint64_t)*v43 << 32;
    if (!v7) {
      goto LABEL_104;
    }
  }
  else
  {
    unint64_t v42 = 0;
    if (!v7) {
      goto LABEL_104;
    }
  }
  unsigned int v45 = *(_DWORD *)(v7 + (v32 | v24));
LABEL_48:
  int v46 = v45 & 0xF;
  int v47 = HIBYTE(v45) & 3;
  if (v46 == 1)
  {
    unsigned int v70 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
    if (v15 < (unint64_t)v70) {
      unsigned int v70 = (unsigned int *)v15;
    }
    if (v70 < v39) {
      unsigned int v70 = v39;
    }
    unint64_t v71 = *v70;
    if (v5)
    {
      unsigned int v72 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
      if (v14 < v72) {
        unsigned int v72 = v14;
      }
      if ((unint64_t)v72 < *(void *)(result + 40)) {
        unsigned int v72 = *(unsigned __int8 **)(result + 40);
      }
      v71 |= (unint64_t)*v72 << 32;
    }
    uint64_t v73 = interpolate_cif10a[v47];
    char v74 = v47 + 1;
    unint64_t v68 = v41 - ((v73 & v41) >> v74);
    unint64_t v75 = (v73 & v71) >> v74;
  }
  else
  {
    if (v46 == 2)
    {
      unsigned int v76 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v76) {
        unsigned int v76 = (unsigned int *)v15;
      }
      if (v76 < v39) {
        unsigned int v76 = v39;
      }
      uint64_t v77 = *v76;
      if (v5)
      {
        unsigned int v78 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v78) {
          unsigned int v78 = v14;
        }
        if ((unint64_t)v78 < *(void *)(result + 40)) {
          unsigned int v78 = *(unsigned __int8 **)(result + 40);
        }
        v77 |= (unint64_t)*v78 << 32;
      }
      int v79 = (v45 >> 28) & 3;
      uint64_t v80 = interpolate_cif10a[v79];
      char v67 = v79 + 1;
      unint64_t v68 = v41 - ((v80 & v41) >> v67);
      unint64_t v69 = v80 & v77;
    }
    else
    {
      if (v46 != 3) {
        goto LABEL_104;
      }
      int64_t v48 = (unint64_t)HIWORD(v45) << 56;
      int v49 = (unsigned int *)(v38 + (v48 >> 54));
      if (v15 < (unint64_t)v49) {
        int v49 = (unsigned int *)v15;
      }
      if (v49 < v39) {
        int v49 = v39;
      }
      unint64_t v50 = *v49;
      unint64_t v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
      if (v15 >= v51) {
        unsigned int v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      }
      else {
        unsigned int v52 = (unsigned int *)v15;
      }
      if (v52 < v39) {
        unsigned int v52 = v39;
      }
      unint64_t v53 = *v52;
      uint64_t v54 = (unsigned int *)(v51 + (v48 >> 54));
      if (v15 < (unint64_t)v54) {
        uint64_t v54 = (unsigned int *)v15;
      }
      if (v54 < v39) {
        uint64_t v54 = v39;
      }
      unint64_t v55 = *v54;
      if (v5)
      {
        unsigned int v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        unint64_t v57 = *(void *)(result + 40);
        if (v14 < v56) {
          unsigned int v56 = v14;
        }
        if ((unint64_t)v56 < v57) {
          unsigned int v56 = *(unsigned __int8 **)(result + 40);
        }
        v50 |= (unint64_t)*v56 << 32;
        unint64_t v58 = v42 + SBYTE1(v45) * (uint64_t)v95;
        if ((unint64_t)v14 >= v58) {
          unint64_t v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
        }
        else {
          unint64_t v59 = v14;
        }
        if ((unint64_t)v59 < v57) {
          unint64_t v59 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= (unint64_t)*v59 << 32;
        unint64_t v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
        if (v14 < v60) {
          unint64_t v60 = v14;
        }
        if ((unint64_t)v60 < v57) {
          unint64_t v60 = *(unsigned __int8 **)(result + 40);
        }
        v55 |= (unint64_t)*v60 << 32;
      }
      uint64_t v61 = interpolate_cif10a[v47];
      char v62 = v47 + 1;
      unint64_t v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
      unint64_t v64 = v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62);
      int v65 = (v45 >> 28) & 3;
      unint64_t v66 = interpolate_cif10a[v65];
      char v67 = v65 + 1;
      unint64_t v68 = v63 - ((v63 & v66) >> v67);
      unint64_t v69 = v64 & v66;
    }
    unint64_t v75 = v69 >> v67;
  }
  unint64_t v41 = v68 + v75;
LABEL_104:
  uint64_t v81 = 0;
  unsigned int v82 = (_WORD *)(v10 + 24);
  a3 += v8;
  uint64_t v83 = v93 - a3;
  a2 += v9;
  uint64_t v84 = v91 - a2;
  while (1)
  {
    HIDWORD(v85) = BYTE3(v41);
    LODWORD(v85) = v41;
    *((void *)v82 - 1) = ((unint64_t)(v41 | (v41 << 8)) << 48) | ((unint64_t)(BYTE1(v41) | (BYTE1(v41) << 8)) << 32) | v41 & 0xFF0000 | ((unint64_t)BYTE2(v41) << 24) | (v85 >> 24);
    *unsigned int v82 = ((v41 | v11) >> 32) | (unsigned __int16)((unsigned __int16)((v41 | v11) >> 32) << 8);
    *(unsigned char *)(v94 + 1 + v81) = v25 >> 22;
    if (a4 - 1 == v81) {
      return result;
    }
    if ((v83 | v84 | (a3 - v92) | (a2 - v90)) < 0)
    {
      uint64_t v10 = (uint64_t)(v82 - 4);
      v94 += v81 + 1;
      a4 += ~v81;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    uint64_t v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38) {
      uint64_t v86 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v86 = (unsigned int *)v15;
    }
    if (v86 < v39) {
      uint64_t v86 = *(unsigned int **)(result + 32);
    }
    unint64_t v41 = *v86;
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      unint64_t v87 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42) {
        unint64_t v88 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      }
      else {
        unint64_t v88 = (unint64_t)v14;
      }
      if (v88 >= (unint64_t)v87) {
        unint64_t v87 = (unsigned __int8 *)v88;
      }
      v41 |= (unint64_t)*v87 << 32;
    }
    if (v7)
    {
      unsigned int v45 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        uint64_t v10 = (uint64_t)(v82 - 4);
        v94 += v81 + 1;
        a4 += ~v81;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v82 += 8;
    ++v81;
    a3 += v8;
    v83 -= v8;
    a2 += v9;
    v84 -= v9;
    unsigned int v25 = -1;
  }
}

uint64_t cmyk64_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 32);
  uint64_t v5 = *(void *)(result + 40);
  int v6 = *(_DWORD *)(result + 24);
  uint64_t v7 = *(void *)(result + 176);
  uint64_t v91 = *(void *)(result + 80);
  uint64_t v9 = *(void *)(result + 112);
  uint64_t v8 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 152) - 16;
  uint64_t v93 = *(void *)(result + 88);
  uint64_t v94 = *(void *)(result + 144) - 1;
  if (v5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 0xFF00000000;
  }
  int v12 = *(_DWORD *)(result + 260) - 1;
  uint64_t v13 = *(unsigned int *)(result + 256);
  int v95 = *(_DWORD *)(result + 28);
  int v89 = *(_DWORD *)(result + 188);
  int v14 = (unsigned __int8 *)(v5 + (v13 - 1) + (v12 * v95));
  unint64_t v15 = v4 + (v12 * v6) + 4 * v13 - 8;
  uint64_t v92 = *(void *)(result + 72);
  uint64_t v90 = *(void *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v92)
    {
      if (a3 <= v93)
      {
        uint64_t v24 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v25 = 0x3FFFFFFF;
        uint64_t v26 = a3;
        uint64_t v27 = v90;
      }
      else
      {
        uint64_t v20 = *(void *)(result + 216);
        uint64_t v21 = *(void *)(result + 224) + v93;
        uint64_t v22 = v21 - a3 + (v20 >> 1);
        if (v22 < 1) {
          goto LABEL_43;
        }
        if (v22 >= v20) {
          LODWORD(v23) = 0x3FFFFFFF;
        }
        else {
          unint64_t v23 = (unint64_t)(*(void *)(result + 232) * v22) >> 32;
        }
        uint64_t v27 = v90;
        unsigned int v25 = v89 | v23;
        uint64_t v26 = v21 - 0x1000000;
        uint64_t v24 = 448;
      }
    }
    else
    {
      uint64_t v16 = *(void *)(result + 216);
      uint64_t v17 = v92 - *(void *)(result + 224);
      uint64_t v18 = a3 - v17 + (v16 >> 1);
      if (v18 < 1) {
        goto LABEL_43;
      }
      if (v18 >= v16) {
        LODWORD(v19) = 0x3FFFFFFF;
      }
      else {
        unint64_t v19 = (unint64_t)(*(void *)(result + 232) * v18) >> 32;
      }
      uint64_t v27 = v90;
      unsigned int v25 = v89 | v19;
      uint64_t v26 = v17 + 0x1000000;
      uint64_t v24 = 512;
    }
    if (a2 >= v27) {
      break;
    }
    uint64_t v28 = *(void *)(result + 192);
    uint64_t v29 = v27 - *(void *)(result + 200);
    uint64_t v30 = a2 - v29 + (v28 >> 1);
    if (v30 >= 1)
    {
      if (v30 < v28) {
        unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v30) >> 32) >> 15)) | v89;
      }
      uint64_t v31 = v29 + 0x1000000;
      uint64_t v32 = 32;
      goto LABEL_29;
    }
LABEL_43:
    --a4;
    a2 += v9;
    a3 += v8;
    v10 += 16;
    *(unsigned char *)++uint64_t v94 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v91)
  {
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v31 = a2;
    goto LABEL_29;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v91;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_43;
  }
  if (v35 < v33) {
    unsigned int v25 = ((v25 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v89;
  }
  uint64_t v31 = v34 - 0x1000000;
  uint64_t v32 = 28;
LABEL_29:
  if (v25 < 0x400000) {
    goto LABEL_43;
  }
  uint64_t v36 = v26 >> 32;
  uint64_t v37 = v31 >> 32;
  unint64_t v38 = v4 + (int)v36 * (uint64_t)v6 + 4 * v37;
  uint64_t v39 = *(unsigned int **)(result + 32);
  if (v15 >= v38) {
    unint64_t v40 = (unsigned int *)(v4 + (int)v36 * (uint64_t)v6 + 4 * v37);
  }
  else {
    unint64_t v40 = (unsigned int *)v15;
  }
  if (v40 < v39) {
    unint64_t v40 = *(unsigned int **)(result + 32);
  }
  unint64_t v41 = bswap32(*v40);
  if (v5)
  {
    unint64_t v42 = v5 + (int)v36 * (uint64_t)v95 + v37;
    int v43 = *(unsigned __int8 **)(result + 40);
    if ((unint64_t)v14 >= v42) {
      unsigned int v44 = (unsigned __int8 *)v42;
    }
    else {
      unsigned int v44 = v14;
    }
    if (v44 >= v43) {
      int v43 = v44;
    }
    v41 |= (unint64_t)*v43 << 32;
    if (!v7) {
      goto LABEL_104;
    }
  }
  else
  {
    unint64_t v42 = 0;
    if (!v7) {
      goto LABEL_104;
    }
  }
  unsigned int v45 = *(_DWORD *)(v7 + (v32 | v24));
LABEL_48:
  int v46 = v45 & 0xF;
  int v47 = HIBYTE(v45) & 3;
  if (v46 == 1)
  {
    unsigned int v70 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
    if (v15 < (unint64_t)v70) {
      unsigned int v70 = (unsigned int *)v15;
    }
    if (v70 < v39) {
      unsigned int v70 = v39;
    }
    unint64_t v71 = bswap32(*v70);
    if (v5)
    {
      unsigned int v72 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
      if (v14 < v72) {
        unsigned int v72 = v14;
      }
      if ((unint64_t)v72 < *(void *)(result + 40)) {
        unsigned int v72 = *(unsigned __int8 **)(result + 40);
      }
      v71 |= (unint64_t)*v72 << 32;
    }
    uint64_t v73 = interpolate_cif10a[v47];
    char v74 = v47 + 1;
    unint64_t v68 = v41 - ((v73 & v41) >> v74);
    unint64_t v75 = (v73 & v71) >> v74;
  }
  else
  {
    if (v46 == 2)
    {
      unsigned int v76 = (unsigned int *)(v38 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 54));
      if (v15 < (unint64_t)v76) {
        unsigned int v76 = (unsigned int *)v15;
      }
      if (v76 < v39) {
        unsigned int v76 = v39;
      }
      uint64_t v77 = bswap32(*v76);
      if (v5)
      {
        unsigned int v78 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        if (v14 < v78) {
          unsigned int v78 = v14;
        }
        if ((unint64_t)v78 < *(void *)(result + 40)) {
          unsigned int v78 = *(unsigned __int8 **)(result + 40);
        }
        v77 |= (unint64_t)*v78 << 32;
      }
      int v79 = (v45 >> 28) & 3;
      uint64_t v80 = interpolate_cif10a[v79];
      char v67 = v79 + 1;
      unint64_t v68 = v41 - ((v80 & v41) >> v67);
      unint64_t v69 = v80 & v77;
    }
    else
    {
      if (v46 != 3) {
        goto LABEL_104;
      }
      int64_t v48 = (unint64_t)HIWORD(v45) << 56;
      int v49 = (unsigned int *)(v38 + (v48 >> 54));
      if (v15 < (unint64_t)v49) {
        int v49 = (unsigned int *)v15;
      }
      if (v49 < v39) {
        int v49 = v39;
      }
      unint64_t v50 = bswap32(*v49);
      unint64_t v51 = v38 + SBYTE1(v45) * (uint64_t)v6;
      if (v15 >= v51) {
        unsigned int v52 = (unsigned int *)(v38 + SBYTE1(v45) * (uint64_t)v6);
      }
      else {
        unsigned int v52 = (unsigned int *)v15;
      }
      if (v52 < v39) {
        unsigned int v52 = v39;
      }
      unint64_t v53 = bswap32(*v52);
      uint64_t v54 = (unsigned int *)(v51 + (v48 >> 54));
      if (v15 < (unint64_t)v54) {
        uint64_t v54 = (unsigned int *)v15;
      }
      if (v54 < v39) {
        uint64_t v54 = v39;
      }
      unint64_t v55 = bswap32(*v54);
      if (v5)
      {
        unsigned int v56 = (unsigned __int8 *)(v42 + SBYTE2(v45));
        unint64_t v57 = *(void *)(result + 40);
        if (v14 < v56) {
          unsigned int v56 = v14;
        }
        if ((unint64_t)v56 < v57) {
          unsigned int v56 = *(unsigned __int8 **)(result + 40);
        }
        v50 |= (unint64_t)*v56 << 32;
        unint64_t v58 = v42 + SBYTE1(v45) * (uint64_t)v95;
        if ((unint64_t)v14 >= v58) {
          unint64_t v59 = (unsigned __int8 *)(v42 + SBYTE1(v45) * (uint64_t)v95);
        }
        else {
          unint64_t v59 = v14;
        }
        if ((unint64_t)v59 < v57) {
          unint64_t v59 = *(unsigned __int8 **)(result + 40);
        }
        v53 |= (unint64_t)*v59 << 32;
        unint64_t v60 = (unsigned __int8 *)(v58 + SBYTE2(v45));
        if (v14 < v60) {
          unint64_t v60 = v14;
        }
        if ((unint64_t)v60 < v57) {
          unint64_t v60 = *(unsigned __int8 **)(result + 40);
        }
        v55 |= (unint64_t)*v60 << 32;
      }
      uint64_t v61 = interpolate_cif10a[v47];
      char v62 = v47 + 1;
      unint64_t v63 = v41 - ((v61 & v41) >> v62) + ((v61 & v53) >> v62);
      unint64_t v64 = v50 - ((v61 & v50) >> v62) + ((v61 & v55) >> v62);
      int v65 = (v45 >> 28) & 3;
      unint64_t v66 = interpolate_cif10a[v65];
      char v67 = v65 + 1;
      unint64_t v68 = v63 - ((v63 & v66) >> v67);
      unint64_t v69 = v64 & v66;
    }
    unint64_t v75 = v69 >> v67;
  }
  unint64_t v41 = v68 + v75;
LABEL_104:
  uint64_t v81 = 0;
  unsigned int v82 = (_WORD *)(v10 + 24);
  a3 += v8;
  uint64_t v83 = v93 - a3;
  a2 += v9;
  uint64_t v84 = v91 - a2;
  while (1)
  {
    HIDWORD(v85) = BYTE3(v41);
    LODWORD(v85) = v41;
    *((void *)v82 - 1) = ((unint64_t)(v41 | (v41 << 8)) << 48) | ((unint64_t)(BYTE1(v41) | (BYTE1(v41) << 8)) << 32) | v41 & 0xFF0000 | ((unint64_t)BYTE2(v41) << 24) | (v85 >> 24);
    *unsigned int v82 = ((v41 | v11) >> 32) | (unsigned __int16)((unsigned __int16)((v41 | v11) >> 32) << 8);
    *(unsigned char *)(v94 + 1 + v81) = v25 >> 22;
    if (a4 - 1 == v81) {
      return result;
    }
    if ((v83 | v84 | (a3 - v92) | (a2 - v90)) < 0)
    {
      uint64_t v10 = (uint64_t)(v82 - 4);
      v94 += v81 + 1;
      a4 += ~v81;
      if (a4) {
        goto LABEL_5;
      }
      return result;
    }
    unint64_t v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32);
    uint64_t v39 = *(unsigned int **)(result + 32);
    if (v15 >= v38) {
      uint64_t v86 = (unsigned int *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 4 * (a2 >> 32));
    }
    else {
      uint64_t v86 = (unsigned int *)v15;
    }
    if (v86 < v39) {
      uint64_t v86 = *(unsigned int **)(result + 32);
    }
    unint64_t v41 = bswap32(*v86);
    if (v5)
    {
      unint64_t v42 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      unint64_t v87 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v14 >= v42) {
        unint64_t v88 = v5 + SHIDWORD(a3) * (uint64_t)v95 + (a2 >> 32);
      }
      else {
        unint64_t v88 = (unint64_t)v14;
      }
      if (v88 >= (unint64_t)v87) {
        unint64_t v87 = (unsigned __int8 *)v88;
      }
      v41 |= (unint64_t)*v87 << 32;
    }
    if (v7)
    {
      unsigned int v45 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v45 & 0xF) != 0)
      {
        uint64_t v10 = (uint64_t)(v82 - 4);
        v94 += v81 + 1;
        a4 += ~v81;
        unsigned int v25 = -1;
        goto LABEL_48;
      }
    }
    v82 += 8;
    ++v81;
    a3 += v8;
    v83 -= v8;
    a2 += v9;
    v84 -= v9;
    unsigned int v25 = -1;
  }
}

uint64_t cmyk64_shade(uint64_t a1, __n128 a2)
{
  float v2 = (uint64_t *)MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  BOOL v7 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *v2;
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  *(_OWORD *)unint64_t v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  uint64_t v9 = *(void *)(v8 + 56);
  uint64_t v10 = *v3;
  if (!*((void *)v3 + 12))
  {
    if (*(void *)(v4 + 72)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = *(float *)(v4 + 4) >= 1.0;
    }
  }
  int v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((void *)v3 + 6) == 0));
  if (v11 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(void *)(v5 + 16))
    {
      int v14 = cmyk64_shade_radial_CMYK;
    }
    else if (*(void *)(v5 + 24))
    {
      int v14 = cmyk64_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      int v14 = cmyk64_shade_axial_CMYK;
    }
    else
    {
      int v14 = cmyk64_shade_custom_CMYK;
    }
    *(void *)&v17[0] = v14;
    if ((void)v40)
    {
      *((void *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 3, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    unint64_t v15 = *((void *)&v19 + 1) * v19;
    if ((uint64_t)(*((void *)&v19 + 1) * v19) <= 384)
    {
      uint64_t v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 3, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(unsigned char *)(v5 + 1)) {
        *(void *)&long long v39 = &_blt_shade_samples_noise;
      }
      goto LABEL_29;
    }
    uint64_t v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      unint64_t v15 = *((void *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(void *)&v17[0]) {
    return 0xFFFFFFFFLL;
  }
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk64_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1])) {
    free(v38[1]);
  }
  return 1;
}

void cmyk64_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v503 = *MEMORY[0x1E4F143B8];
  uint64_t v501 = *(unsigned int *)(a1 + 4);
  uint64_t v488 = (int)v501;
  unint64_t v4 = ((int)v501 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 <= 0x1FFFFFF)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v502 = *(void *)(a1 + 48);
    float v8 = *(float *)(a2 + 184);
    uint64_t v9 = *(int **)(a1 + 136);
    uint64_t v10 = *(void *)(a2 + 104);
    uint64_t v499 = *(void *)(a2 + 96);
    uint64_t v500 = v10;
    uint64_t v11 = *(int *)(a1 + 24);
    unint64_t v12 = *(int *)(a1 + 28);
    uint64_t v14 = *(int *)(a1 + 16);
    __n128 v13 = (void *)*(int *)(a1 + 20);
    uint64_t v496 = v9;
    uint64_t v497 = v13;
    uint64_t v15 = *(int *)(a1 + 12);
    int v498 = *(_DWORD *)(a1 + 8);
    uint64_t v495 = (void *)a2;
    uint64_t v16 = *(int *)(a2 + 16);
    uint64_t v17 = (v16 + 18) * v4;
    if (v17 > 65439)
    {
      long long v20 = (char *)malloc_type_calloc(1uLL, v17 + 96, 0x3023562EuLL);
      long long v19 = v20;
      long long v22 = v20;
      long long v23 = v495;
      if (!v20) {
        return;
      }
    }
    else
    {
      MEMORY[0x1F4188790](a1, a4);
      long long v19 = (char *)&v481 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v19, v18);
      long long v22 = 0;
      long long v23 = v495;
    }
    uint64_t v484 = v22;
    uint64_t v489 = a1;
    int v492 = a3;
    unint64_t v24 = (unint64_t)(v19 + 15) & 0xFFFFFFFFFFFFFFF0;
    unint64_t v25 = v24 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
    v23[20] = v25;
    if (v16) {
      uint64_t v26 = 16 * v4;
    }
    else {
      uint64_t v26 = 0;
    }
    unint64_t v27 = v25 + v26;
    unint64_t v28 = v12 >> 3;
    v23[18] = v24;
    v23[19] = v25 + v26;
    if (v502)
    {
      uint64_t v29 = v489;
      unint64_t v30 = (unint64_t)*(int *)(v489 + 32) >> 1;
      long long v31 = (__int16 *)(v502 + 2 * (v15 + v30 * v14));
      uint64_t v493 = v30 - v488;
      uint64_t v32 = v488;
      uint64_t v33 = 1;
    }
    else
    {
      long long v31 = 0;
      uint64_t v493 = 0;
      uint64_t v33 = 0;
      uint64_t v32 = v488;
      uint64_t v29 = v489;
    }
    int v494 = (int)(float)((float)(v8 * 65535.0) + 0.5);
    uint64_t v34 = v7 + (v11 - 1) * v12 + 8 * (void)v497;
    long long v35 = (int8x8_t *)(v7 + 8 * (v15 + v28 * v14));
    uint64_t v491 = v28 - v32;
    uint64_t v36 = *(int *)(v29 + 104);
    int v37 = *(_DWORD *)(v29 + 108);
    int v38 = *(unsigned __int8 *)(v29 + 2);
    if (v38 == 6 || v38 == 1)
    {
      long long v39 = v495;
      uint64_t v40 = v499;
      if (!v496) {
        goto LABEL_545;
      }
      unint64_t v481 = v28;
      uint64_t v41 = 0;
      int v42 = 0;
      uint64_t v43 = *(int *)(v489 + 124);
      uint64_t v44 = (uint64_t)v496 + v36 + (int)v43 * (uint64_t)v37;
      uint64_t v32 = v488;
      uint64_t v490 = v43 - v488;
      goto LABEL_21;
    }
    unint64_t v481 = v28;
    uint64_t v40 = v499;
    if (!v496)
    {
      uint64_t v44 = 0;
      uint64_t v41 = 0;
      uint64_t v490 = 0;
      int v42 = 0;
      long long v39 = v495;
LABEL_21:
      int v50 = v501;
      while (1)
      {
        unint64_t v51 = v41;
        int v52 = v494 ^ 0xFFFF;
        uint64_t v486 = (v50 - 1) + 1;
        uint64_t v485 = -v32;
        uint64_t v482 = v34;
        unint64_t v487 = v34 - 8;
        uint64_t v483 = v33;
        uint64_t v53 = 2 * v33;
        uint64_t v54 = v51;
        uint64_t v55 = v500;
        while (2)
        {
          LODWORD(v496) = v42;
          uint64_t v497 = v54;
          unsigned int v56 = (void (*)(void *, uint64_t))*v39;
          uint64_t v499 = v40;
          uint64_t v500 = v55;
          v56(v39, v40);
          uint64_t v57 = v39[20];
          unint64_t v58 = (unsigned char *)v39[18];
          unsigned int v59 = *((_DWORD *)v39 + 2);
          if (v59 == *((_DWORD *)v39 + 3))
          {
            if (v494 != 0xFFFF)
            {
              int v60 = v50;
              uint64_t v61 = (unsigned char *)v39[18];
              do
              {
                if (*v61)
                {
                  int v62 = *(unsigned __int16 *)(v57 + 8);
                  unsigned int v63 = (unsigned __int16)WORD2(*(void *)v57) * v52;
                  *(void *)uint64_t v57 = ((HIWORD(*(void *)v57)
                                   - ((HIWORD(*(void *)v57) * v52
                                     + ((HIWORD(*(void *)v57) * v52) >> 16)
                                     + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v57)
                                                                                               - ((v63 + HIWORD(v63) + 1) >> 16)) << 32) | ((WORD1(*(void *)v57) - ((WORD1(*(void *)v57) * v52 + ((WORD1(*(void *)v57) * v52) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v57 - (((unsigned __int16)*(void *)v57 * v52 + (((unsigned __int16)*(void *)v57 * v52) >> 16) + 1) >> 16));
                  *(_WORD *)(v57 + 8) = v62 - ((v62 * v52 + ((v62 * v52) >> 16) + 1) >> 16);
                }
                ++v61;
                v57 += 16;
                --v60;
              }
              while (v60);
              v57 += 16 * v485;
              v58 += v486 + v485;
            }
          }
          else
          {
            uint64_t v64 = v39[19];
            int v65 = HIWORD(v59) & 0x3F;
            if (v65 == 16)
            {
              if (v494 == 0xFFFF)
              {
                uint64_t v109 = 0;
                uint64_t v110 = 0;
                do
                {
                  if (v58[v109]) {
                    *(_OWORD *)(v57 + v110) = *(_OWORD *)(v64 + v110);
                  }
                  v110 += 16;
                  ++v109;
                }
                while (v50 != v109);
              }
              else
              {
                uint64_t v80 = 0;
                uint64_t v81 = 0;
                do
                {
                  if (v58[v80])
                  {
                    int v82 = *(unsigned __int16 *)(v64 + v81 + 8);
                    unint64_t v83 = *(void *)(v64 + v81);
                    uint64_t v84 = v57 + v81;
                    *(void *)uint64_t v84 = ((HIWORD(v83)
                                     - ((HIWORD(v83) * v52 + ((HIWORD(v83) * v52) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v83) - ((WORD2(v83) * v52 + ((WORD2(v83) * v52) >> 16) + 1) >> 16)) << 32) | ((WORD1(v83) - ((WORD1(v83) * v52 + ((WORD1(v83) * v52) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v83 - (((unsigned __int16)v83 * v52 + (((unsigned __int16)v83 * v52) >> 16) + 1) >> 16));
                    *(_WORD *)(v84 + 8) = v82 - ((v82 * v52 + ((v82 * v52) >> 16) + 1) >> 16);
                  }
                  v81 += 16;
                  ++v80;
                }
                while (v50 != v80);
              }
            }
            else if (v65 == 32)
            {
              if (v494 == 0xFFFF)
              {
                uint64_t v96 = 0;
                uint64_t v97 = 0;
                uint64_t v98 = (float *)(v64 + 8);
                do
                {
                  if (v58[v96])
                  {
                    float v99 = v98[2];
                    if (v99 <= 0.0)
                    {
                      LOWORD(v100) = 0;
                      *(void *)(v57 + v97) = 0;
                    }
                    else
                    {
                      LODWORD(v100) = (int)(float)((float)(v99 * 65535.0) + 0.5);
                      float v101 = *(v98 - 2);
                      if (v99 <= 1.0) {
                        uint64_t v100 = v100;
                      }
                      else {
                        uint64_t v100 = 0xFFFFLL;
                      }
                      if (v99 > 1.0) {
                        float v99 = 1.0;
                      }
                      LOWORD(v102) = v100;
                      if (v101 <= v99)
                      {
                        if (v101 >= 0.0) {
                          int v102 = (int)(float)((float)(v101 * 65535.0) + 0.5);
                        }
                        else {
                          LOWORD(v102) = 0;
                        }
                      }
                      float v103 = *(v98 - 1);
                      int v104 = v100;
                      if (v103 <= v99)
                      {
                        if (v103 >= 0.0) {
                          int v104 = (int)(float)((float)(v103 * 65535.0) + 0.5);
                        }
                        else {
                          int v104 = 0;
                        }
                      }
                      float v105 = *v98;
                      LOWORD(v106) = v100;
                      if (*v98 <= v99)
                      {
                        if (v105 >= 0.0) {
                          int v106 = (int)(float)((float)(v105 * 65535.0) + 0.5);
                        }
                        else {
                          LOWORD(v106) = 0;
                        }
                      }
                      float v107 = v98[1];
                      uint64_t v108 = v100;
                      if (v107 <= v99)
                      {
                        if (v107 >= 0.0) {
                          uint64_t v108 = (int)(float)((float)(v107 * 65535.0) + 0.5);
                        }
                        else {
                          uint64_t v108 = 0;
                        }
                      }
                      *(void *)(v57 + v97) = ((unint64_t)(unsigned __int16)v106 << 32) | (v108 << 48) | (v104 << 16) | (unint64_t)(unsigned __int16)v102;
                    }
                    *(_WORD *)(v57 + v97 + 8) = v100;
                  }
                  v97 += 16;
                  v98 += 5;
                  ++v96;
                }
                while (v50 != v96);
              }
              else
              {
                uint64_t v66 = 0;
                uint64_t v67 = 0;
                unint64_t v68 = (float *)(v64 + 8);
                do
                {
                  if (v58[v66])
                  {
                    float v69 = v68[2];
                    if (v69 <= 0.0)
                    {
                      LOWORD(v74) = 0;
                      *(void *)(v57 + v67) = 0;
                    }
                    else
                    {
                      float v70 = *(v68 - 2);
                      int v71 = (int)(float)((float)(v69 * 65535.0) + 0.5);
                      if (v69 > 1.0) {
                        int v71 = 0xFFFF;
                      }
                      int v72 = v71;
                      if (v69 > 1.0) {
                        float v69 = 1.0;
                      }
                      int v73 = v71;
                      if (v70 <= v69)
                      {
                        if (v70 >= 0.0) {
                          int v73 = (int)(float)((float)(v70 * 65535.0) + 0.5);
                        }
                        else {
                          int v73 = 0;
                        }
                      }
                      float v75 = *(v68 - 1);
                      int v76 = v71;
                      if (v75 <= v69)
                      {
                        if (v75 >= 0.0) {
                          int v76 = (int)(float)((float)(v75 * 65535.0) + 0.5);
                        }
                        else {
                          int v76 = 0;
                        }
                      }
                      float v77 = *v68;
                      int v78 = v71;
                      if (*v68 <= v69)
                      {
                        if (v77 >= 0.0) {
                          int v78 = (int)(float)((float)(v77 * 65535.0) + 0.5);
                        }
                        else {
                          int v78 = 0;
                        }
                      }
                      float v79 = v68[1];
                      if (v79 <= v69)
                      {
                        if (v79 >= 0.0) {
                          int v72 = (int)(float)((float)(v79 * 65535.0) + 0.5);
                        }
                        else {
                          int v72 = 0;
                        }
                      }
                      unsigned int v74 = v71 - ((v71 * v52 + ((v71 * v52) >> 16) + 1) >> 16);
                      *(void *)(v57 + v67) = ((unint64_t)(unsigned __int16)(v78
                                                                                   - ((v78 * v52
                                                                                     + ((v78 * v52) >> 16)
                                                                                     + 1) >> 16)) << 32) | ((unint64_t)(v72 - ((v72 * v52 + ((v72 * v52) >> 16) + 1) >> 16)) << 48) | ((v76 - ((v76 * v52 + ((v76 * v52) >> 16) + 1) >> 16)) << 16) | (unint64_t)(unsigned __int16)(v73 - ((v73 * v52 + ((v73 * v52) >> 16) + 1) >> 16));
                    }
                    *(_WORD *)(v57 + v67 + 8) = v74;
                  }
                  v67 += 16;
                  v68 += 5;
                  ++v66;
                }
                while (v50 != v66);
              }
            }
            else if (v494 == 0xFFFF)
            {
              uint64_t v111 = 0;
              uint64_t v112 = (_WORD *)(v57 + 8);
              do
              {
                if (v58[v111])
                {
                  uint64_t v113 = *(void *)(v64 + 8 * v111);
                  HIDWORD(v114) = BYTE3(v113);
                  LODWORD(v114) = v113;
                  *((void *)v112 - 1) = ((unint64_t)(v113 | (v113 << 8)) << 48) | ((unint64_t)(BYTE1(v113) | (BYTE1(v113) << 8)) << 32) | v113 & 0xFF0000 | ((unint64_t)BYTE2(v113) << 24) | (v114 >> 24);
                  *uint64_t v112 = BYTE4(v113) | (unsigned __int16)(WORD2(v113) << 8);
                }
                ++v111;
                v112 += 8;
              }
              while (v50 != v111);
            }
            else
            {
              uint64_t v85 = 0;
              uint64_t v86 = (_WORD *)(v57 + 8);
              do
              {
                if (v58[v85])
                {
                  uint64_t v87 = v64 + 8 * v85;
                  int v88 = *(unsigned __int8 *)(v87 + 4);
                  LODWORD(v87) = *(_DWORD *)v87;
                  int v89 = BYTE2(v87);
                  int v90 = BYTE1(v87);
                  int v91 = v87;
                  HIDWORD(v92) = BYTE3(v87);
                  LODWORD(v92) = v87;
                  LODWORD(v87) = v92 >> 24;
                  int v93 = v89 | (v89 << 8);
                  int v94 = v90 | (v90 << 8);
                  int v95 = v91 | (v91 << 8);
                  *((void *)v86 - 1) = ((unint64_t)(v95
                                                           - ((v95 * v52 + ((v95 * v52) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(v94 - ((v94 * v52 + ((v94 * v52) >> 16) + 1) >> 16)) << 32) | ((v93 - ((v93 * v52 + ((v93 * v52) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v87 - ((v87 * v52 + ((v87 * v52) >> 16) + 1) >> 16));
                  *uint64_t v86 = (v88 | ((_WORD)v88 << 8))
                       - (((v88 | (v88 << 8)) * v52 + (((v88 | (v88 << 8)) * v52) >> 16) + 1) >> 16);
                }
                ++v85;
                v86 += 8;
              }
              while (v50 != v85);
            }
          }
          switch(v492)
          {
            case 0:
              uint64_t v115 = v44 != 0;
              if (v502)
              {
                int v116 = v50;
                uint64_t v117 = (unsigned __int8 *)v44;
                uint64_t v118 = v499;
                do
                {
                  int v119 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v119 = ((unsigned __int16)(*v117 * (_WORD)v119
                    }
                                                                + ((*v117 * v119) >> 8)
                                                                + 1) >> 8);
                    if (v119)
                    {
                      if (v119 == 255)
                      {
                        LOWORD(v120) = 0;
                        *long long v35 = 0;
                      }
                      else
                      {
                        int v121 = (unsigned __int16)*v31;
                        unsigned int v122 = v119 | (v119 << 8);
                        int32x2_t v123 = vdup_n_s32(v122);
                        uint32x2_t v124 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v123);
                        v125.i32[0] = HIWORD(v35->u32[0]);
                        v125.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v126 = (uint32x2_t)vmul_s32(v125, v123);
                        *long long v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v124, v124, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v125, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v126, v126, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                        int v120 = v121 - ((v122 * v121 + ((v122 * v121) >> 16) + 1) >> 16);
                      }
                      *long long v31 = v120;
                    }
                  }
                  ++v58;
                  v117 += v115;
                  ++v35;
                  ++v31;
                  --v116;
                }
                while (v116);
              }
              else
              {
                int v381 = v50;
                uint64_t v117 = (unsigned __int8 *)v44;
                uint64_t v118 = v499;
                do
                {
                  int v382 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v382 = ((unsigned __int16)(*v117 * (_WORD)v382
                    }
                                                                + ((*v117 * v382) >> 8)
                                                                + 1) >> 8);
                    if (v382)
                    {
                      if (v382 == 255)
                      {
                        *long long v35 = 0;
                      }
                      else
                      {
                        int32x2_t v383 = (int32x2_t)*v35;
                        v384.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                        v385.i32[0] = v384.i32[0];
                        v385.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                        int32x2_t v386 = vdup_n_s32(v382 | (v382 << 8));
                        uint32x2_t v387 = (uint32x2_t)vmul_s32(v385, v386);
                        v388.i32[0] = v35->u16[0];
                        v388.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v389 = (uint32x2_t)vmul_s32(v388, v386);
                        v384.i32[1] = HIDWORD(*(unint64_t *)v35);
                        uint32x2_t v390 = (uint32x2_t)vsub_s32(v384, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v387, v387, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        v383.i32[1] = v388.i32[1];
                        int8x8_t v391 = (int8x8_t)vsub_s32(v383, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v389, v389, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        int32x2_t v392 = vshl_n_s32((int32x2_t)v391, 0x10uLL);
                        v391.i16[1] = 0;
                        v391.i32[1] = v392.i32[1];
                        v393.i32[0] = vshl_u32(v390, (uint32x2_t)0xFFFF00000010).u32[0];
                        v393.i32[1] = v390.u16[2];
                        *long long v35 = vorr_s8(v393, v391);
                      }
                    }
                  }
                  ++v58;
                  v117 += v115;
                  ++v35;
                  --v381;
                }
                while (v381);
              }
              uint64_t v44 = (uint64_t)&v117[v490];
              v35 += v491;
              v31 += v493;
              goto LABEL_541;
            case 1:
              int v127 = *v58;
              if (!v502)
              {
                long long v394 = v58 + 1;
                if (v44)
                {
                  do
                  {
                    if (v127)
                    {
                      unsigned int v395 = *(unsigned __int8 *)v44 * v127 + ((*(unsigned __int8 *)v44 * v127) >> 8) + 1;
                      unsigned int v396 = (int8x8_t *)v487;
                      if (v487 >= (unint64_t)v35) {
                        unsigned int v396 = v35;
                      }
                      if ((unint64_t)v396 >= *(void *)(v489 + 40)) {
                        id v397 = (unsigned int *)v396;
                      }
                      else {
                        id v397 = *(unsigned int **)(v489 + 40);
                      }
                      if (BYTE1(v395))
                      {
                        if (BYTE1(v395) == 255) {
                          *(void *)id v397 = *(void *)v57;
                        }
                        else {
                          cmyk64_DMplusDM(v397, *(void *)v57, (unsigned __int16)(257 * (v395 >> 8)), *(void *)v397, (unsigned __int16)~(257 * (v395 >> 8)));
                        }
                      }
                    }
                    else
                    {
                      id v397 = (unsigned int *)v35;
                    }
                    int v398 = *v394++;
                    int v127 = v398;
                    v57 += 16;
                    ++v44;
                    long long v35 = (int8x8_t *)(v397 + 2);
                    --v50;
                  }
                  while (v50);
                  v44 += v490;
                }
                else
                {
                  do
                  {
                    unsigned int v399 = (int8x8_t *)v487;
                    if (v487 >= (unint64_t)v35) {
                      unsigned int v399 = v35;
                    }
                    if ((unint64_t)v399 >= *(void *)(v489 + 40)) {
                      id v397 = (unsigned int *)v399;
                    }
                    else {
                      id v397 = *(unsigned int **)(v489 + 40);
                    }
                    if (v127)
                    {
                      if (v127 == 255) {
                        *(void *)id v397 = *(void *)v57;
                      }
                      else {
                        cmyk64_DMplusDM(v397, *(void *)v57, v127 | (v127 << 8), *(void *)v397, (v127 | (v127 << 8)) ^ 0xFFFF);
                      }
                    }
                    int v400 = *v394++;
                    int v127 = v400;
                    v57 += 16;
                    long long v35 = (int8x8_t *)(v397 + 2);
                    --v50;
                  }
                  while (v50);
                  uint64_t v44 = 0;
                }
                goto LABEL_538;
              }
              uint64_t v128 = 0;
              if (v44)
              {
                unint64_t v129 = 0;
                uint64_t v130 = 0;
                int v131 = v58 + 1;
                do
                {
                  if (v127)
                  {
                    unsigned int v132 = *(unsigned __int8 *)(v44 + v130) * v127
                         + ((*(unsigned __int8 *)(v44 + v130) * v127) >> 8)
                         + 1;
                    if (BYTE1(v132))
                    {
                      if (BYTE1(v132) == 255)
                      {
                        v35[v130] = *(int8x8_t *)(v57 + 4 * v128);
                        v31[v130] = *(_WORD *)(v57 + 2 * v129 + 8);
                      }
                      else
                      {
                        cmyk64_DAMplusDAM((unsigned int *)&v35[v129 / 8], &v31[v128], *(void *)(v57 + 4 * v128), *(unsigned __int16 *)(v57 + 2 * v129 + 8), (unsigned __int16)(257 * (v132 >> 8)), *(void *)&v35[v130], (unsigned __int16)v31[v130], (unsigned __int16)~(257 * (v132 >> 8)));
                      }
                    }
                  }
                  int v127 = v131[v130++];
                  v129 += 8;
                  ++v128;
                }
                while (v501 != v130);
                uint64_t v133 = (uint64_t)&v35[v129 / 8 - 1];
                uint64_t v134 = (uint64_t)&v31[v128 - 1];
                uint64_t v135 = v44 + v130;
                goto LABEL_149;
              }
              unint64_t v454 = 0;
              int v455 = v58 + 1;
              do
              {
                if (v127)
                {
                  if (v127 == 255)
                  {
                    v35[v44] = *(int8x8_t *)(v57 + 4 * v128);
                    v31[v44] = *(_WORD *)(v57 + 2 * v454 + 8);
                  }
                  else
                  {
                    cmyk64_DAMplusDAM((unsigned int *)&v35[v454 / 8], &v31[v128], *(void *)(v57 + 4 * v128), *(unsigned __int16 *)(v57 + 2 * v454 + 8), v127 | (v127 << 8), *(void *)&v35[v44], (unsigned __int16)v31[v44], (v127 | (v127 << 8)) ^ 0xFFFF);
                  }
                }
                int v127 = v455[v44++];
                v454 += 8;
                ++v128;
              }
              while (v501 != v44);
              goto LABEL_524;
            case 2:
              int v136 = *v58;
              if (v502)
              {
                if (v44)
                {
                  unint64_t v137 = 0;
                  uint64_t v138 = 0;
                  uint64_t v139 = 0;
                  int v140 = v58 + 1;
                  while (1)
                  {
                    if (!v136) {
                      goto LABEL_147;
                    }
                    unsigned int v141 = *(unsigned __int8 *)(v44 + v139) * v136
                         + ((*(unsigned __int8 *)(v44 + v139) * v136) >> 8)
                         + 1;
                    if (!BYTE1(v141)) {
                      goto LABEL_147;
                    }
                    if (BYTE1(v141) == 255)
                    {
                      uint64_t v142 = v57 + 2 * v137;
                      int v143 = *(unsigned __int16 *)(v142 + 8);
                      if (*(_WORD *)(v142 + 8))
                      {
                        if (v143 != 0xFFFF)
                        {
                          unint64_t v149 = *(void *)(v57 + 4 * v138);
                          unint64_t v148 = (unint64_t)v35[v139];
                          int v150 = (unsigned __int16)v31[v139];
                          int v151 = v143 ^ 0xFFFF;
                          goto LABEL_146;
                        }
                        v35[v139] = *(int8x8_t *)(v57 + 4 * v138);
                        v31[v139] = -1;
                      }
                    }
                    else
                    {
                      int v144 = *(unsigned __int16 *)(v57 + 2 * v137 + 8);
                      int v145 = (257 * (v141 >> 8)) ^ 0xFFFF;
                      int v146 = v144 - ((v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16);
                      if (v144 != (v145 * v144 + ((v145 * v144) >> 16) + 1) >> 16)
                      {
                        unint64_t v147 = *(void *)(v57 + 4 * v138);
                        unint64_t v148 = (unint64_t)v35[v139];
                        unint64_t v149 = ((HIWORD(v147)
                               - ((v145 * HIWORD(v147) + ((v145 * HIWORD(v147)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v147) - ((WORD2(v147) * v145 + ((WORD2(v147) * v145) >> 16) + 1) >> 16)) << 32) | ((WORD1(v147) - ((WORD1(v147) * v145 + ((WORD1(v147) * v145) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v147 - (((unsigned __int16)v147 * v145 + (((unsigned __int16)v147 * v145) >> 16) + 1) >> 16));
                        int v150 = (unsigned __int16)v31[v139];
                        int v151 = (unsigned __int16)~(_WORD)v146;
                        LOWORD(v143) = v146;
LABEL_146:
                        cmyk64_DAplusDAM(&v35[v137 / 8], &v31[v138], v149, v143, v148, v150, v151);
                      }
                    }
LABEL_147:
                    int v136 = v140[v139++];
                    ++v138;
                    v137 += 8;
                    if (v501 == v139)
                    {
                      uint64_t v133 = (uint64_t)&v35[v137 / 8 - 1];
                      uint64_t v134 = (uint64_t)&v31[v138 - 1];
                      uint64_t v135 = v44 + v139;
LABEL_149:
                      uint64_t v44 = v135 + v490;
                      goto LABEL_525;
                    }
                  }
                }
                unint64_t v454 = 0;
                uint64_t v128 = 0;
                uint64_t v456 = v58 + 1;
                while (1)
                {
                  if (v136)
                  {
                    if (v136 == 255)
                    {
                      uint64_t v457 = v57 + 2 * v454;
                      int v458 = *(unsigned __int16 *)(v457 + 8);
                      if (*(_WORD *)(v457 + 8))
                      {
                        if (v458 != 0xFFFF)
                        {
                          unint64_t v464 = *(void *)(v57 + 4 * v128);
                          unint64_t v463 = (unint64_t)v35[v44];
                          int v465 = (unsigned __int16)v31[v44];
                          int v466 = v458 ^ 0xFFFF;
                          goto LABEL_522;
                        }
                        v35[v44] = *(int8x8_t *)(v57 + 4 * v128);
                        v31[v44] = -1;
                      }
                    }
                    else
                    {
                      int v459 = *(unsigned __int16 *)(v57 + 2 * v454 + 8);
                      int v460 = (257 * v136) ^ 0xFFFF;
                      int v461 = v459 - ((v460 * v459 + ((v460 * v459) >> 16) + 1) >> 16);
                      if (v459 != (v460 * v459 + ((v460 * v459) >> 16) + 1) >> 16)
                      {
                        unint64_t v462 = *(void *)(v57 + 4 * v128);
                        unint64_t v463 = (unint64_t)v35[v44];
                        unint64_t v464 = ((HIWORD(v462)
                               - ((v460 * HIWORD(v462) + ((v460 * HIWORD(v462)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v462) - ((WORD2(v462) * v460 + ((WORD2(v462) * v460) >> 16) + 1) >> 16)) << 32) | ((WORD1(v462) - ((WORD1(v462) * v460 + ((WORD1(v462) * v460) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v462 - (((unsigned __int16)v462 * v460 + (((unsigned __int16)v462 * v460) >> 16) + 1) >> 16));
                        int v465 = (unsigned __int16)v31[v44];
                        int v466 = (unsigned __int16)~(_WORD)v461;
                        LOWORD(v458) = v461;
LABEL_522:
                        cmyk64_DAplusDAM(&v35[v454 / 8], &v31[v128], v464, v458, v463, v465, v466);
                      }
                    }
                  }
                  int v136 = v456[v44++];
                  ++v128;
                  v454 += 8;
                  if (v501 == v44)
                  {
LABEL_524:
                    uint64_t v44 = 0;
                    uint64_t v134 = (uint64_t)&v31[v128 - 1];
                    uint64_t v133 = (uint64_t)&v35[v454 / 8 - 1];
LABEL_525:
                    long long v35 = (int8x8_t *)(v133 + 8 * v491 + 8);
                    long long v31 = (__int16 *)(v134 + 2 * v493 + 2);
                    goto LABEL_539;
                  }
                }
              }
              if (!v44)
              {
                unsigned int v467 = v58 + 1;
                while (1)
                {
                  if (v136)
                  {
                    if (v136 == 255)
                    {
                      int v468 = *(unsigned __int16 *)(v57 + 8);
                      if (*(_WORD *)(v57 + 8))
                      {
                        if (v468 != 0xFFFF)
                        {
                          uint64_t v473 = *(void *)v57;
                          unint64_t v474 = (unint64_t)*v35;
                          int v475 = v468 ^ 0xFFFF;
                          goto LABEL_535;
                        }
                        *long long v35 = *(int8x8_t *)v57;
                      }
                    }
                    else
                    {
                      int v469 = *(unsigned __int16 *)(v57 + 8);
                      int v470 = (257 * v136) ^ 0xFFFF;
                      unsigned int v471 = v470 * v469 + ((v470 * v469) >> 16) + 1;
                      if (v469 != HIWORD(v471))
                      {
                        unsigned int v472 = (unsigned __int16)WORD2(*(void *)v57) * v470;
                        uint64_t v473 = ((HIWORD(*(void *)v57)
                               - ((v470 * HIWORD(*(void *)v57)
                                 + ((v470 * HIWORD(*(void *)v57)) >> 16)
                                 + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v57)
                                                                                           - ((v472 + HIWORD(v472) + 1) >> 16)) << 32) | ((WORD1(*(void *)v57) - ((WORD1(*(void *)v57) * v470 + ((WORD1(*(void *)v57) * v470) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v57 - (((unsigned __int16)*(void *)v57 * v470 + (((unsigned __int16)*(void *)v57 * v470) >> 16) + 1) >> 16));
                        unint64_t v474 = (unint64_t)*v35;
                        int v475 = (unsigned __int16)(~(_WORD)v469 + HIWORD(v471));
LABEL_535:
                        cmyk64_DplusDM(v35, v473, v474, v475);
                      }
                    }
                  }
                  int v476 = *v467++;
                  int v136 = v476;
                  v57 += 16;
                  ++v35;
                  if (!--v50)
                  {
                    uint64_t v44 = 0;
                    id v397 = (unsigned int *)&v35[-1];
                    goto LABEL_538;
                  }
                }
              }
              uint64_t v401 = 0;
              long long v402 = v58 + 1;
              long long v403 = v35;
              do
              {
                id v397 = (unsigned int *)v403;
                if (v136)
                {
                  unsigned int v404 = *(unsigned __int8 *)(v44 + v401) * v136
                       + ((*(unsigned __int8 *)(v44 + v401) * v136) >> 8)
                       + 1;
                  if (BYTE1(v404))
                  {
                    if (BYTE1(v404) == 255)
                    {
                      int v405 = *(unsigned __int16 *)(v57 + 8);
                      if (!*(_WORD *)(v57 + 8)) {
                        goto LABEL_466;
                      }
                      if (v405 == 0xFFFF)
                      {
                        v35[v401] = *(int8x8_t *)v57;
                        goto LABEL_466;
                      }
                      uint64_t v411 = *(void *)v57;
                      unint64_t v412 = (unint64_t)v35[v401];
                      int v413 = v405 ^ 0xFFFF;
                    }
                    else
                    {
                      unsigned int v406 = v404 >> 8;
                      int v407 = *(unsigned __int16 *)(v57 + 8);
                      int v408 = (257 * v406) ^ 0xFFFF;
                      unsigned int v409 = v408 * v407 + ((v408 * v407) >> 16) + 1;
                      if (v407 == HIWORD(v409)) {
                        goto LABEL_466;
                      }
                      unsigned int v410 = (unsigned __int16)WORD2(*(void *)v57) * v408;
                      uint64_t v411 = ((HIWORD(*(void *)v57)
                             - ((v408 * HIWORD(*(void *)v57)
                               + ((v408 * HIWORD(*(void *)v57)) >> 16)
                               + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v57)
                                                                                         - ((v410 + HIWORD(v410) + 1) >> 16)) << 32) | ((WORD1(*(void *)v57) - ((WORD1(*(void *)v57) * v408 + ((WORD1(*(void *)v57) * v408) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v57 - (((unsigned __int16)*(void *)v57 * v408 + (((unsigned __int16)*(void *)v57 * v408) >> 16) + 1) >> 16));
                      unint64_t v412 = (unint64_t)v35[v401];
                      int v413 = (unsigned __int16)(~(_WORD)v407 + HIWORD(v409));
                    }
                    cmyk64_DplusDM(v397, v411, v412, v413);
                  }
                }
LABEL_466:
                int v136 = v402[v401];
                v57 += 16;
                long long v403 = (int8x8_t *)(v397 + 2);
                ++v401;
              }
              while (v501 != v401);
              v44 += v401 + v490;
LABEL_538:
              long long v35 = (int8x8_t *)&v397[2 * v491 + 2];
              v31 += v493;
LABEL_539:
              long long v39 = v495;
              int v50 = v501;
LABEL_540:
              uint64_t v118 = v499;
LABEL_541:
              int v453 = (int)v496;
LABEL_503:
              if (!--v498)
              {
                uint64_t v41 = v497;
LABEL_543:
                if (v41) {
                  free(v41);
                }
                goto LABEL_545;
              }
              uint64_t v54 = 0;
              int v42 = v453 + 1;
              uint64_t v40 = v39[16] + v118;
              uint64_t v55 = v39[17] + v500;
              int v46 = v497;
              if (!v497) {
                continue;
              }
              int v47 = v42;
              v500 += v39[17];
              uint64_t v49 = v488;
LABEL_548:
              uint64_t v41 = v46;
              uint64_t v477 = v493 + v49;
              while (1)
              {
                while (1)
                {
                  int v478 = *(_DWORD *)(v44 - 16);
                  int v479 = v478 - v47;
                  if (v478 <= v47) {
                    break;
                  }
                  v498 -= v479;
                  if (v498 < 1) {
                    goto LABEL_543;
                  }
                  v40 += v39[16] * v479;
                  v500 += v39[17] * v479;
                  v35 += v481 * v479;
                  uint64_t v480 = v477 * v479;
                  if (!v502) {
                    uint64_t v480 = 0;
                  }
                  v31 += v480;
                  int v47 = v478;
                }
                if (v47 < *(_DWORD *)(v44 - 12) + v478) {
                  break;
                }
                if (!shape_enum_clip_scan((uint64_t)v41, (_DWORD *)(v44 - 16))) {
                  goto LABEL_543;
                }
              }
              uint64_t v32 = v488;
              uint64_t v33 = v483;
              uint64_t v34 = v482;
              int v42 = v47;
              break;
            case 3:
              int v152 = v50;
              uint64_t v153 = (unsigned __int16 *)(v57 + 8);
              int v154 = v152;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v156 = *v58;
                if (*v58)
                {
                  if (v44) {
                    int v156 = ((unsigned __int16)(*v155 * (_WORD)v156
                  }
                                                              + ((*v155 * v156) >> 8)
                                                              + 1) >> 8);
                  if (v156)
                  {
                    if (v156 == 255)
                    {
                      int8x8_t v157 = *(int8x8_t *)(v153 - 4);
                      int v158 = *v153;
                      unsigned int v159 = (unsigned __int16)*v31 ^ 0xFFFF;
                      int32x2_t v160 = vdup_n_s32(v159);
                      uint32x2_t v161 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v157, (int8x8_t)0xFFFF0000FFFFLL), v160);
                      int32x2_t v162 = vsub_s32((int32x2_t)v157, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v161, v161, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                      v157.i32[0] = HIWORD(v157.i32[0]);
                      v157.i32[1] = HIWORD(*((void *)v153 - 1));
                      uint32x2_t v163 = (uint32x2_t)vmul_s32((int32x2_t)v157, v160);
                      *long long v35 = (int8x8_t)vsli_n_s32(v162, vsub_s32((int32x2_t)v157, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v163, v163, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                      *long long v31 = v158 - ((v159 * v158 + ((v159 * v158) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      cmyk64_DAMplusDAM((unsigned int *)v35, v31, *((void *)v153 - 1), *v153, ((unsigned __int16)*v31 * (v156 | (v156 << 8))+ (((unsigned __int16)*v31 * (v156 | (v156 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v156 | (v156 << 8)) ^ 0xFFFF);
                    }
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v153 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v154;
              }
              while (v154);
              goto LABEL_222;
            case 4:
              int v164 = v50;
              CGRect v165 = (unsigned __int16 *)(v57 + 8);
              int v166 = v164;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v167 = *v58;
                if (*v58)
                {
                  if (v44) {
                    int v167 = ((unsigned __int16)(*v155 * (_WORD)v167
                  }
                                                              + ((*v155 * v167) >> 8)
                                                              + 1) >> 8);
                  if (v167)
                  {
                    if (v167 == 255)
                    {
                      int8x8_t v168 = *(int8x8_t *)(v165 - 4);
                      int v169 = *v165;
                      unsigned int v170 = (unsigned __int16)*v31;
                      int32x2_t v171 = vdup_n_s32(v170);
                      uint32x2_t v172 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v168, (int8x8_t)0xFFFF0000FFFFLL), v171);
                      int32x2_t v173 = vsub_s32((int32x2_t)v168, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v172, v172, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                      v168.i32[0] = HIWORD(v168.i32[0]);
                      v168.i32[1] = HIWORD(*((void *)v165 - 1));
                      uint32x2_t v174 = (uint32x2_t)vmul_s32((int32x2_t)v168, v171);
                      *long long v35 = (int8x8_t)vsli_n_s32(v173, vsub_s32((int32x2_t)v168, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v174, v174, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                      *long long v31 = v169 - ((v170 * v169 + ((v170 * v169) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      cmyk64_DAMplusDAM((unsigned int *)v35, v31, *((void *)v165 - 1), *v165, (((unsigned __int16)*v31 ^ 0xFFFF) * (v167 | (v167 << 8))+ ((((unsigned __int16)*v31 ^ 0xFFFF) * (v167 | (v167 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v167 | (v167 << 8)) ^ 0xFFFF);
                    }
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v165 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v166;
              }
              while (v166);
              goto LABEL_222;
            case 5:
              int v175 = v50;
              __int16 v176 = (unsigned __int16 *)(v57 + 8);
              int v177 = v175;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v178 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v178 = ((unsigned __int16)(*v155 * (_WORD)v178
                                                                  + ((*v155 * v178) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unint64_t v179 = *((void *)v176 - 1);
                    int v180 = (v178 | (v178 << 8)) ^ 0xFFFF;
                    unint64_t v181 = ((HIWORD(v179)
                           - ((v180 * HIWORD(v179) + ((v180 * HIWORD(v179)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v179) - ((WORD2(v179) * v180 + ((WORD2(v179) * v180) >> 16) + 1) >> 16)) << 32) | ((WORD1(v179) - ((WORD1(v179) * v180 + ((WORD1(v179) * v180) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v179 - (((unsigned __int16)v179 * v180 + (((unsigned __int16)v179 * v180) >> 16) + 1) >> 16));
                    unsigned int v182 = *v176 - ((v180 * *v176 + ((v180 * *v176) >> 16) + 1) >> 16);
                    cmyk64_DAMplusDAM((unsigned int *)v35, v31, v181, (unsigned __int16)v182, (unsigned __int16)*v31, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)~(_WORD)v182);
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v176 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v177;
              }
              while (v177);
              goto LABEL_222;
            case 6:
              int v183 = v50;
              long long v184 = (unsigned __int16 *)(v57 + 8);
              int v185 = v183;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v186 = *v58;
                if (*v58)
                {
                  if ((!v44
                     || (int v186 = ((unsigned __int16)(*v155 * (_WORD)v186
                                                                   + ((*v155 * v186) >> 8)
                                                                   + 1) >> 8)) != 0)
                    && *v31 != -1)
                  {
                    if ((unsigned __int16)~*v31 == 0xFFFF)
                    {
                      int8x8_t v187 = *(int8x8_t *)(v184 - 4);
                      int v188 = *v184;
                      unsigned int v189 = (v186 | (v186 << 8)) ^ 0xFFFF;
                      int32x2_t v190 = vdup_n_s32(v189);
                      uint32x2_t v191 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(v187, (int8x8_t)0xFFFF0000FFFFLL), v190);
                      int32x2_t v192 = vsub_s32((int32x2_t)v187, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v191, v191, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                      v187.i32[0] = HIWORD(v187.i32[0]);
                      v187.i32[1] = HIWORD(*((void *)v184 - 1));
                      uint32x2_t v193 = (uint32x2_t)vmul_s32((int32x2_t)v187, v190);
                      *long long v35 = (int8x8_t)vsli_n_s32(v192, vsub_s32((int32x2_t)v187, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v193, v193, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                      *long long v31 = v188 - ((v189 * v188 + ((v189 * v188) >> 16) + 1) >> 16);
                    }
                    else
                    {
                      cmyk64_DAplusDAM(v35, v31, (uint64_t)*v35, *v31, *((void *)v184 - 1), *v184, (257 * v186 * (unsigned __int16)~*v31+ ((257 * v186 * (unsigned __int16)~*v31) >> 16)+ 1) >> 16);
                    }
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v184 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v185;
              }
              while (v185);
              goto LABEL_222;
            case 7:
              uint64_t v194 = v44 != 0;
              if (v502)
              {
                uint64_t v195 = (unsigned __int16 *)(v57 + 8);
                int v196 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v198 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v198 = ((unsigned __int16)(*v197 * (_WORD)v198
                    }
                                                                + ((*v197 * v198) >> 8)
                                                                + 1) >> 8);
                    if (v198)
                    {
                      if (v198 == 255)
                      {
                        int v199 = (unsigned __int16)*v31;
                        unsigned int v200 = *v195 ^ 0xFFFF;
                        int32x2_t v201 = vdup_n_s32(v200);
                        uint32x2_t v202 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v201);
                        v203.i32[0] = HIWORD(v35->u32[0]);
                        v203.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v204 = (uint32x2_t)vmul_s32(v203, v201);
                        *long long v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v202, v202, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v203, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v204, v204, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                        *long long v31 = v199 - ((v200 * v199 + ((v200 * v199) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        cmyk64_DAMplusDAM((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, (*v195 * (v198 | (v198 << 8)) + ((*v195 * (v198 | (v198 << 8))) >> 16) + 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v198 | (v198 << 8)) ^ 0xFFFF);
                      }
                    }
                  }
                  ++v58;
                  v197 += v194;
                  ++v35;
                  ++v31;
                  v195 += 8;
                  --v196;
                }
                while (v196);
              }
              else
              {
                unsigned int v414 = (unsigned __int16 *)(v57 + 8);
                int v415 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v416 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v416 = ((unsigned __int16)(*v197 * (_WORD)v416
                    }
                                                                + ((*v197 * v416) >> 8)
                                                                + 1) >> 8);
                    if (v416)
                    {
                      if (v416 == 255)
                      {
                        int32x2_t v417 = (int32x2_t)*v35;
                        v418.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                        v419.i32[0] = v418.i32[0];
                        v419.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                        int32x2_t v420 = vdup_n_s32(*v414 ^ 0xFFFFu);
                        uint32x2_t v421 = (uint32x2_t)vmul_s32(v419, v420);
                        v422.i32[0] = v35->u16[0];
                        v422.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v423 = (uint32x2_t)vmul_s32(v422, v420);
                        v418.i32[1] = HIDWORD(*(unint64_t *)v35);
                        uint32x2_t v424 = (uint32x2_t)vsub_s32(v418, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v421, v421, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        v417.i32[1] = v422.i32[1];
                        int8x8_t v425 = (int8x8_t)vsub_s32(v417, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v423, v423, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        int32x2_t v426 = vshl_n_s32((int32x2_t)v425, 0x10uLL);
                        v425.i16[1] = 0;
                        v425.i32[1] = v426.i32[1];
                        v427.i32[0] = vshl_u32(v424, (uint32x2_t)0xFFFF00000010).u32[0];
                        v427.i32[1] = v424.u16[2];
                        *long long v35 = vorr_s8(v427, v425);
                      }
                      else
                      {
                        cmyk64_DMplusDM((unsigned int *)v35, (unint64_t)*v35, (*v414 * (v416 | (v416 << 8)) + ((*v414 * (v416 | (v416 << 8))) >> 16) + 1) >> 16, (unint64_t)*v35, (v416 | (v416 << 8)) ^ 0xFFFF);
                      }
                    }
                  }
                  ++v58;
                  v197 += v194;
                  ++v35;
                  v414 += 8;
                  --v415;
                }
                while (v415);
              }
              goto LABEL_501;
            case 8:
              uint64_t v205 = v44 != 0;
              if (v502)
              {
                unint64_t v206 = (unsigned __int16 *)(v57 + 8);
                int v207 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v208 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v208 = ((unsigned __int16)(*v197 * (_WORD)v208
                    }
                                                                + ((*v197 * v208) >> 8)
                                                                + 1) >> 8);
                    if (v208)
                    {
                      if (v208 == 255)
                      {
                        int v209 = (unsigned __int16)*v31;
                        unsigned int v210 = *v206;
                        int32x2_t v211 = vdup_n_s32(v210);
                        uint32x2_t v212 = (uint32x2_t)vmul_s32((int32x2_t)vand_s8(*v35, (int8x8_t)0xFFFF0000FFFFLL), v211);
                        v213.i32[0] = HIWORD(v35->u32[0]);
                        v213.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v214 = (uint32x2_t)vmul_s32(v213, v211);
                        *long long v35 = (int8x8_t)vsli_n_s32(vsub_s32((int32x2_t)*v35, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v212, v212, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), vsub_s32(v213, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v214, v214, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL)), 0x10uLL);
                        *long long v31 = v209 - ((v210 * v209 + ((v210 * v209) >> 16) + 1) >> 16);
                      }
                      else
                      {
                        cmyk64_DAMplusDAM((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((*v206 ^ 0xFFFF) * (v208 | (v208 << 8))+ (((*v206 ^ 0xFFFF) * (v208 | (v208 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (unsigned __int16)*v31, (v208 | (v208 << 8)) ^ 0xFFFF);
                      }
                    }
                  }
                  ++v58;
                  v197 += v205;
                  ++v35;
                  ++v31;
                  v206 += 8;
                  --v207;
                }
                while (v207);
              }
              else
              {
                long long v428 = (unsigned __int16 *)(v57 + 8);
                int v429 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v430 = *v58;
                  if (*v58)
                  {
                    if (v44) {
                      int v430 = ((unsigned __int16)(*v197 * (_WORD)v430
                    }
                                                                + ((*v197 * v430) >> 8)
                                                                + 1) >> 8);
                    if (v430)
                    {
                      if (v430 == 255)
                      {
                        int32x2_t v431 = (int32x2_t)*v35;
                        v432.i32[0] = vshl_u32((uint32x2_t)*v35, (uint32x2_t)0xFFFF0001FFFFFFF0).u32[0];
                        v433.i32[0] = v432.i32[0];
                        v433.i32[1] = (unsigned __int16)WORD2(*(unint64_t *)v35);
                        int32x2_t v434 = vdup_n_s32(*v428);
                        uint32x2_t v435 = (uint32x2_t)vmul_s32(v433, v434);
                        v436.i32[0] = v35->u16[0];
                        v436.i32[1] = HIWORD(*(unint64_t *)v35);
                        uint32x2_t v437 = (uint32x2_t)vmul_s32(v436, v434);
                        v432.i32[1] = HIDWORD(*(unint64_t *)v35);
                        uint32x2_t v438 = (uint32x2_t)vsub_s32(v432, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v435, v435, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        v431.i32[1] = v436.i32[1];
                        int8x8_t v439 = (int8x8_t)vsub_s32(v431, (int32x2_t)vshr_n_u32((uint32x2_t)vadd_s32((int32x2_t)vsra_n_u32(v437, v437, 0x10uLL), (int32x2_t)0x100000001), 0x10uLL));
                        int32x2_t v440 = vshl_n_s32((int32x2_t)v439, 0x10uLL);
                        v439.i16[1] = 0;
                        v439.i32[1] = v440.i32[1];
                        v441.i32[0] = vshl_u32(v438, (uint32x2_t)0xFFFF00000010).u32[0];
                        v441.i32[1] = v438.u16[2];
                        *long long v35 = vorr_s8(v441, v439);
                      }
                      else
                      {
                        cmyk64_DMplusDM((unsigned int *)v35, (unint64_t)*v35, ((*v428 ^ 0xFFFF) * (v430 | (v430 << 8))+ (((*v428 ^ 0xFFFF) * (v430 | (v430 << 8))) >> 16)+ 1) >> 16, (unint64_t)*v35, (v430 | (v430 << 8)) ^ 0xFFFF);
                      }
                    }
                  }
                  ++v58;
                  v197 += v205;
                  ++v35;
                  v428 += 8;
                  --v429;
                }
                while (v429);
              }
              goto LABEL_501;
            case 9:
              int v215 = v50;
              unint64_t v216 = (unsigned __int16 *)(v57 + 8);
              int v217 = v215;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v218 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v218 = ((unsigned __int16)(*v155 * (_WORD)v218
                                                                  + ((*v155 * v218) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unint64_t v219 = *((void *)v216 - 1);
                    unsigned __int16 v220 = ~(v218 | ((_WORD)v218 << 8));
                    int v221 = v220;
                    unint64_t v222 = ((HIWORD(v219)
                           - ((HIWORD(v219) * v220 + ((HIWORD(v219) * v220) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v219) - ((WORD2(v219) * v221 + ((WORD2(v219) * v221) >> 16) + 1) >> 16)) << 32) | ((WORD1(v219) - ((WORD1(v219) * v221 + ((WORD1(v219) * v221) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v219 - (((unsigned __int16)v219 * v220 + (((unsigned __int16)v219 * v220) >> 16) + 1) >> 16));
                    unsigned int v223 = *v216 - ((*v216 * v221 + ((*v216 * v221) >> 16) + 1) >> 16);
                    cmyk64_DAMplusDAM((unsigned int *)v35, v31, v222, (unsigned __int16)v223, (unsigned __int16)*v31 ^ 0xFFFF, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)(v223 + v220));
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v216 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v217;
              }
              while (v217);
              goto LABEL_222;
            case 10:
              int v224 = v50;
              uint64_t v225 = (unsigned __int16 *)(v57 + 8);
              int v226 = v224;
              CGAffineTransform v155 = (unsigned __int8 *)v44;
              do
              {
                int v227 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v227 = ((unsigned __int16)(*v155 * (_WORD)v227
                                                                  + ((*v155 * v227) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    unint64_t v228 = *((void *)v225 - 1);
                    int v229 = (v227 | (v227 << 8)) ^ 0xFFFF;
                    unint64_t v230 = ((HIWORD(v228)
                           - ((v229 * HIWORD(v228) + ((v229 * HIWORD(v228)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v228) - ((WORD2(v228) * v229 + ((WORD2(v228) * v229) >> 16) + 1) >> 16)) << 32) | ((WORD1(v228) - ((WORD1(v228) * v229 + ((WORD1(v228) * v229) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v228 - (((unsigned __int16)v228 * v229 + (((unsigned __int16)v228 * v229) >> 16) + 1) >> 16));
                    unsigned int v231 = *v225 - ((v229 * *v225 + ((v229 * *v225) >> 16) + 1) >> 16);
                    cmyk64_DAMplusDAM((unsigned int *)v35, v31, v230, (unsigned __int16)v231, (unsigned __int16)*v31 ^ 0xFFFF, (unint64_t)*v35, (unsigned __int16)*v31, (unsigned __int16)~(_WORD)v231);
                  }
                }
                ++v58;
                v155 += v44 != 0;
                ++v35;
                v225 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v226;
              }
              while (v226);
LABEL_222:
              uint64_t v44 = (uint64_t)&v155[v490];
              goto LABEL_502;
            case 11:
              uint64_t v232 = v44 != 0;
              if (v502)
              {
                vImagePixelCount v233 = (_WORD *)(v57 + 8);
                int v234 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v235 = *v58;
                  if (*v58)
                  {
                    if (!v44
                      || (int v235 = ((unsigned __int16)(*v197 * (_WORD)v235
                                                                    + ((*v197 * v235) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unint64_t v236 = *((void *)v233 - 1);
                      int v237 = (v235 | (v235 << 8)) ^ 0xFFFF;
                      unsigned int v238 = (unsigned __int16)v236 * v237;
                      cmyk64_DAplusdDA((int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((HIWORD(v236) - ((v237 * HIWORD(v236) + ((v237 * HIWORD(v236)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v236) - ((WORD2(v236) * v237 + ((WORD2(v236) * v237) >> 16) + 1) >> 16)) << 32) | ((WORD1(v236) - ((WORD1(v236) * v237 + ((WORD1(v236) * v237) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v236 - ((v238 + HIWORD(v238) + 1) >> 16)), (unsigned __int16)(*v233- ((v237 * (unsigned __int16)*v233+ ((v237 * (unsigned __int16)*v233) >> 16)+ 1) >> 16)));
                    }
                  }
                  ++v58;
                  v197 += v232;
                  ++v35;
                  ++v31;
                  v233 += 8;
                  --v234;
                }
                while (v234);
              }
              else
              {
                long long v442 = (_WORD *)(v57 + 8);
                int v443 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v444 = *v58;
                  if (*v58)
                  {
                    if (!v44
                      || (int v444 = ((unsigned __int16)(*v197 * (_WORD)v444
                                                                    + ((*v197 * v444) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unint64_t v445 = *((void *)v442 - 1);
                      int v446 = (v444 | (v444 << 8)) ^ 0xFFFF;
                      unsigned int v447 = (unsigned __int16)v445 * v446;
                      cmyk64_DplusdDA((int *)v35, (unint64_t)*v35, ((HIWORD(v445) - ((v446 * HIWORD(v445) + ((v446 * HIWORD(v445)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v445) - ((WORD2(v445) * v446 + ((WORD2(v445) * v446) >> 16) + 1) >> 16)) << 32) | ((WORD1(v445) - ((WORD1(v445) * v446 + ((WORD1(v445) * v446) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v445 - ((v447 + HIWORD(v447) + 1) >> 16)), (unsigned __int16)(*v442- ((v446 * (unsigned __int16)*v442+ ((v446 * (unsigned __int16)*v442) >> 16)+ 1) >> 16)));
                    }
                  }
                  ++v58;
                  v197 += v232;
                  ++v35;
                  v442 += 8;
                  --v443;
                }
                while (v443);
              }
              goto LABEL_501;
            case 12:
              uint64_t v239 = v44 != 0;
              if (v502)
              {
                uint64_t v240 = (_WORD *)(v57 + 8);
                int v241 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v242 = *v58;
                  if (*v58)
                  {
                    if (!v44
                      || (int v242 = ((unsigned __int16)(*v197 * (_WORD)v242
                                                                    + ((*v197 * v242) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      unint64_t v243 = *((void *)v240 - 1);
                      int v244 = (v242 | (v242 << 8)) ^ 0xFFFF;
                      unsigned int v245 = (unsigned __int16)v243 * v244;
                      cmyk64_DApluslDA((unsigned int *)v35, v31, (unint64_t)*v35, (unsigned __int16)*v31, ((HIWORD(v243) - ((v244 * HIWORD(v243) + ((v244 * HIWORD(v243)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v243) - ((WORD2(v243) * v244 + ((WORD2(v243) * v244) >> 16) + 1) >> 16)) << 32) | ((WORD1(v243) - ((WORD1(v243) * v244 + ((WORD1(v243) * v244) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v243 - ((v245 + HIWORD(v245) + 1) >> 16)), (unsigned __int16)(*v240- ((v244 * (unsigned __int16)*v240+ ((v244 * (unsigned __int16)*v240) >> 16)+ 1) >> 16)));
                    }
                  }
                  ++v58;
                  v197 += v239;
                  ++v35;
                  ++v31;
                  v240 += 8;
                  --v241;
                }
                while (v241);
              }
              else
              {
                int v448 = v50;
                uint64_t v197 = (unsigned __int8 *)v44;
                do
                {
                  int v449 = *v58;
                  if (*v58)
                  {
                    if (!v44
                      || (int v449 = ((unsigned __int16)(*v197 * (_WORD)v449
                                                                    + ((*v197 * v449) >> 8)
                                                                    + 1) >> 8)) != 0)
                    {
                      uint64_t v450 = HIWORD(*(void *)v57);
                      int v451 = (v449 | (v449 << 8)) ^ 0xFFFF;
                      unsigned int v452 = (unsigned __int16)WORD2(*(void *)v57) * v451;
                      cmyk64_DpluslD((unsigned int *)v35, (unint64_t)*v35, ((unint64_t)(v450- ((v451 * v450 + ((v451 * v450) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(HIDWORD(*(void *)v57) - ((v452 + HIWORD(v452) + 1) >> 16)) << 32) | ((WORD1(*(void *)v57) - ((WORD1(*(void *)v57) * v451 + ((WORD1(*(void *)v57) * v451) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(*(void *)v57 - (((unsigned __int16)*(void *)v57 * v451 + (((unsigned __int16)*(void *)v57 * v451) >> 16) + 1) >> 16)));
                    }
                  }
                  ++v58;
                  v57 += 16;
                  v197 += v239;
                  ++v35;
                  --v448;
                }
                while (v448);
              }
LABEL_501:
              uint64_t v44 = (uint64_t)&v197[v490];
              goto LABEL_502;
            case 13:
              uint64_t v246 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v248 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v248 = ((unsigned __int16)(*v247 * (_WORD)v248
                                                                  + ((*v247 * v248) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v249 = *v246;
                    int v250 = (v248 | (v248 << 8)) ^ 0xFFFF;
                    int v251 = v249 - ((v250 * v249 + ((v250 * v249) >> 16) + 1) >> 16);
                    if (v249 != (v250 * v249 + ((v250 * v249) >> 16) + 1) >> 16)
                    {
                      unint64_t v252 = *((void *)v246 - 1);
                      unint64_t v253 = ((HIWORD(v252)
                             - ((v250 * HIWORD(v252) + ((v250 * HIWORD(v252)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v252) - ((WORD2(v252) * v250 + ((WORD2(v252) * v250) >> 16) + 1) >> 16)) << 32) | ((WORD1(v252) - ((WORD1(v252) * v250 + ((WORD1(v252) * v250) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v252 - (((unsigned __int16)v252 * v250 + (((unsigned __int16)v252 * v250) >> 16) + 1) >> 16));
                      __int16 v254 = v251;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v253 = PDAmultiplyPDA_11710((unint64_t)*v35, (unsigned __int16)*v31, v253, (unsigned __int16)v251);
                          __int16 v254 = v255;
                        }
                        *long long v35 = (int8x8_t)v253;
                        *long long v31 = v254;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAmultiplyPDA_11710((unint64_t)*v35, 0xFFFFu, v253, (unsigned __int16)v251);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v246 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 14:
              uint64_t v256 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v257 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v257 = ((unsigned __int16)(*v247 * (_WORD)v257
                                                                  + ((*v247 * v257) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v258 = *v256;
                    int v259 = (v257 | (v257 << 8)) ^ 0xFFFF;
                    int v260 = v258 - ((v259 * v258 + ((v259 * v258) >> 16) + 1) >> 16);
                    if (v258 != (v259 * v258 + ((v259 * v258) >> 16) + 1) >> 16)
                    {
                      unint64_t v261 = *((void *)v256 - 1);
                      unint64_t v262 = ((HIWORD(v261)
                             - ((v259 * HIWORD(v261) + ((v259 * HIWORD(v261)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v261) - ((WORD2(v261) * v259 + ((WORD2(v261) * v259) >> 16) + 1) >> 16)) << 32) | ((WORD1(v261) - ((WORD1(v261) * v259 + ((WORD1(v261) * v259) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v261 - (((unsigned __int16)v261 * v259 + (((unsigned __int16)v261 * v259) >> 16) + 1) >> 16));
                      __int16 v263 = v260;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v262 = PDAscreenPDA_11711((unint64_t)*v35, (unsigned __int16)*v31, v262, (unsigned __int16)v260);
                          __int16 v263 = v264;
                        }
                        *long long v35 = (int8x8_t)v262;
                        *long long v31 = v263;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAscreenPDA_11711((unint64_t)*v35, 0xFFFFu, v262, (unsigned __int16)v260);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v256 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 15:
              id v265 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v266 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v266 = ((unsigned __int16)(*v247 * (_WORD)v266
                                                                  + ((*v247 * v266) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v267 = *v265;
                    int v268 = (v266 | (v266 << 8)) ^ 0xFFFF;
                    int v269 = v267 - ((v268 * v267 + ((v268 * v267) >> 16) + 1) >> 16);
                    if (v267 != (v268 * v267 + ((v268 * v267) >> 16) + 1) >> 16)
                    {
                      unint64_t v270 = *((void *)v265 - 1);
                      unint64_t v271 = ((HIWORD(v270)
                             - ((v268 * HIWORD(v270) + ((v268 * HIWORD(v270)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v270) - ((WORD2(v270) * v268 + ((WORD2(v270) * v268) >> 16) + 1) >> 16)) << 32) | ((WORD1(v270) - ((WORD1(v270) * v268 + ((WORD1(v270) * v268) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v270 - (((unsigned __int16)v270 * v268 + (((unsigned __int16)v270 * v268) >> 16) + 1) >> 16));
                      __int16 v272 = v269;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v271 = PDAoverlayPDA_11712((unint64_t)*v35, (unsigned __int16)*v31, v271, (unsigned __int16)v269);
                          __int16 v272 = v273;
                        }
                        *long long v35 = (int8x8_t)v271;
                        *long long v31 = v272;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAoverlayPDA_11712((unint64_t)*v35, 0xFFFFu, v271, (unsigned __int16)v269);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v265 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 16:
              uint64_t v274 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v275 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v275 = ((unsigned __int16)(*v247 * (_WORD)v275
                                                                  + ((*v247 * v275) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v276 = *v274;
                    int v277 = (v275 | (v275 << 8)) ^ 0xFFFF;
                    int v278 = v276 - ((v277 * v276 + ((v277 * v276) >> 16) + 1) >> 16);
                    if (v276 != (v277 * v276 + ((v277 * v276) >> 16) + 1) >> 16)
                    {
                      unint64_t v279 = *((void *)v274 - 1);
                      unint64_t v280 = ((HIWORD(v279)
                             - ((v277 * HIWORD(v279) + ((v277 * HIWORD(v279)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v279) - ((WORD2(v279) * v277 + ((WORD2(v279) * v277) >> 16) + 1) >> 16)) << 32) | ((WORD1(v279) - ((WORD1(v279) * v277 + ((WORD1(v279) * v277) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v279 - (((unsigned __int16)v279 * v277 + (((unsigned __int16)v279 * v277) >> 16) + 1) >> 16));
                      __int16 v281 = v278;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v280 = PDAdarkenPDA_11714((unint64_t)*v35, (unsigned __int16)*v31, v280, (unsigned __int16)v278);
                          __int16 v281 = v282;
                        }
                        *long long v35 = (int8x8_t)v280;
                        *long long v31 = v281;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAdarkenPDA_11714((unint64_t)*v35, 0xFFFFu, v280, (unsigned __int16)v278);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v274 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 17:
              uint64_t v283 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v284 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v284 = ((unsigned __int16)(*v247 * (_WORD)v284
                                                                  + ((*v247 * v284) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v285 = *v283;
                    int v286 = (v284 | (v284 << 8)) ^ 0xFFFF;
                    int v287 = v285 - ((v286 * v285 + ((v286 * v285) >> 16) + 1) >> 16);
                    if (v285 != (v286 * v285 + ((v286 * v285) >> 16) + 1) >> 16)
                    {
                      unint64_t v288 = *((void *)v283 - 1);
                      unint64_t v289 = ((HIWORD(v288)
                             - ((v286 * HIWORD(v288) + ((v286 * HIWORD(v288)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v288) - ((WORD2(v288) * v286 + ((WORD2(v288) * v286) >> 16) + 1) >> 16)) << 32) | ((WORD1(v288) - ((WORD1(v288) * v286 + ((WORD1(v288) * v286) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v288 - (((unsigned __int16)v288 * v286 + (((unsigned __int16)v288 * v286) >> 16) + 1) >> 16));
                      __int16 v290 = v287;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v289 = PDAlightenPDA_11713((unint64_t)*v35, (unsigned __int16)*v31, v289, (unsigned __int16)v287);
                          __int16 v290 = v291;
                        }
                        *long long v35 = (int8x8_t)v289;
                        *long long v31 = v290;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAlightenPDA_11713((unint64_t)*v35, 0xFFFFu, v289, (unsigned __int16)v287);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v283 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 18:
              CFMutableDataRef v292 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v293 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v293 = ((unsigned __int16)(*v247 * (_WORD)v293
                                                                  + ((*v247 * v293) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v294 = *v292;
                    int v295 = (v293 | (v293 << 8)) ^ 0xFFFF;
                    int v296 = v294 - ((v295 * v294 + ((v295 * v294) >> 16) + 1) >> 16);
                    if (v294 != (v295 * v294 + ((v295 * v294) >> 16) + 1) >> 16)
                    {
                      unint64_t v297 = *((void *)v292 - 1);
                      unint64_t v298 = ((HIWORD(v297)
                             - ((v295 * HIWORD(v297) + ((v295 * HIWORD(v297)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v297) - ((WORD2(v297) * v295 + ((WORD2(v297) * v295) >> 16) + 1) >> 16)) << 32) | ((WORD1(v297) - ((WORD1(v297) * v295 + ((WORD1(v297) * v295) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v297 - (((unsigned __int16)v297 * v295 + (((unsigned __int16)v297 * v295) >> 16) + 1) >> 16));
                      __int16 v299 = v296;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v298 = PDAcolordodgePDA_11715((unint64_t)*v35, (unsigned __int16)*v31, v298, (unsigned __int16)v296);
                          __int16 v299 = v300;
                        }
                        *long long v35 = (int8x8_t)v298;
                        *long long v31 = v299;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAcolordodgePDA_11715((unint64_t)*v35, 0xFFFFu, v298, (unsigned __int16)v296);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v292 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 19:
              uint64_t v301 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v302 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v302 = ((unsigned __int16)(*v247 * (_WORD)v302
                                                                  + ((*v247 * v302) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v303 = *v301;
                    int v304 = (v302 | (v302 << 8)) ^ 0xFFFF;
                    int v305 = v303 - ((v304 * v303 + ((v304 * v303) >> 16) + 1) >> 16);
                    if (v303 != (v304 * v303 + ((v304 * v303) >> 16) + 1) >> 16)
                    {
                      unint64_t v306 = *((void *)v301 - 1);
                      unint64_t v307 = ((HIWORD(v306)
                             - ((v304 * HIWORD(v306) + ((v304 * HIWORD(v306)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v306) - ((WORD2(v306) * v304 + ((WORD2(v306) * v304) >> 16) + 1) >> 16)) << 32) | ((WORD1(v306) - ((WORD1(v306) * v304 + ((WORD1(v306) * v304) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v306 - (((unsigned __int16)v306 * v304 + (((unsigned __int16)v306 * v304) >> 16) + 1) >> 16));
                      __int16 v308 = v305;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v307 = PDAcolorburnPDA_11716((unint64_t)*v35, (unsigned __int16)*v31, v307, (unsigned __int16)v305);
                          __int16 v308 = v309;
                        }
                        *long long v35 = (int8x8_t)v307;
                        *long long v31 = v308;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAcolorburnPDA_11716((unint64_t)*v35, 0xFFFFu, v307, (unsigned __int16)v305);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v301 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 20:
              uint64_t v310 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v311 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v311 = ((unsigned __int16)(*v247 * (_WORD)v311
                                                                  + ((*v247 * v311) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v312 = *v310;
                    int v313 = (v311 | (v311 << 8)) ^ 0xFFFF;
                    int v314 = v312 - ((v313 * v312 + ((v313 * v312) >> 16) + 1) >> 16);
                    if (v312 != (v313 * v312 + ((v313 * v312) >> 16) + 1) >> 16)
                    {
                      unint64_t v315 = *((void *)v310 - 1);
                      unint64_t v316 = ((HIWORD(v315)
                             - ((v313 * HIWORD(v315) + ((v313 * HIWORD(v315)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v315) - ((WORD2(v315) * v313 + ((WORD2(v315) * v313) >> 16) + 1) >> 16)) << 32) | ((WORD1(v315) - ((WORD1(v315) * v313 + ((WORD1(v315) * v313) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v315 - (((unsigned __int16)v315 * v313 + (((unsigned __int16)v315 * v313) >> 16) + 1) >> 16));
                      __int16 v317 = v314;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v316 = PDAsoftlightPDA_11718((unint64_t)*v35, (unsigned __int16)*v31, v316, (unsigned __int16)v314);
                          __int16 v317 = v318;
                        }
                        *long long v35 = (int8x8_t)v316;
                        *long long v31 = v317;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAsoftlightPDA_11718((unint64_t)*v35, 0xFFFFu, v316, (unsigned __int16)v314);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v310 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 21:
              uint64_t v319 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v320 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v320 = ((unsigned __int16)(*v247 * (_WORD)v320
                                                                  + ((*v247 * v320) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v321 = *v319;
                    int v322 = (v320 | (v320 << 8)) ^ 0xFFFF;
                    int v323 = v321 - ((v322 * v321 + ((v322 * v321) >> 16) + 1) >> 16);
                    if (v321 != (v322 * v321 + ((v322 * v321) >> 16) + 1) >> 16)
                    {
                      unint64_t v324 = *((void *)v319 - 1);
                      unint64_t v325 = ((HIWORD(v324)
                             - ((v322 * HIWORD(v324) + ((v322 * HIWORD(v324)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v324) - ((WORD2(v324) * v322 + ((WORD2(v324) * v322) >> 16) + 1) >> 16)) << 32) | ((WORD1(v324) - ((WORD1(v324) * v322 + ((WORD1(v324) * v322) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v324 - (((unsigned __int16)v324 * v322 + (((unsigned __int16)v324 * v322) >> 16) + 1) >> 16));
                      __int16 v326 = v323;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v325 = PDAhardlightPDA_11717((unint64_t)*v35, (unsigned __int16)*v31, v325, (unsigned __int16)v323);
                          __int16 v326 = v327;
                        }
                        *long long v35 = (int8x8_t)v325;
                        *long long v31 = v326;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAhardlightPDA_11717((unint64_t)*v35, 0xFFFFu, v325, (unsigned __int16)v323);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v319 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 22:
              unsigned int v328 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v329 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v329 = ((unsigned __int16)(*v247 * (_WORD)v329
                                                                  + ((*v247 * v329) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v330 = *v328;
                    int v331 = (v329 | (v329 << 8)) ^ 0xFFFF;
                    int v332 = v330 - ((v331 * v330 + ((v331 * v330) >> 16) + 1) >> 16);
                    if (v330 != (v331 * v330 + ((v331 * v330) >> 16) + 1) >> 16)
                    {
                      unint64_t v333 = *((void *)v328 - 1);
                      unint64_t v334 = ((HIWORD(v333)
                             - ((v331 * HIWORD(v333) + ((v331 * HIWORD(v333)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v333) - ((WORD2(v333) * v331 + ((WORD2(v333) * v331) >> 16) + 1) >> 16)) << 32) | ((WORD1(v333) - ((WORD1(v333) * v331 + ((WORD1(v333) * v331) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v333 - (((unsigned __int16)v333 * v331 + (((unsigned __int16)v333 * v331) >> 16) + 1) >> 16));
                      __int16 v335 = v332;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v334 = PDAdifferencePDA_11719((unint64_t)*v35, (unsigned __int16)*v31, v334, (unsigned __int16)v332);
                          __int16 v335 = v336;
                        }
                        *long long v35 = (int8x8_t)v334;
                        *long long v31 = v335;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAdifferencePDA_11719((unint64_t)*v35, 0xFFFFu, v334, (unsigned __int16)v332);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v328 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 23:
              unint64_t v337 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v338 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v338 = ((unsigned __int16)(*v247 * (_WORD)v338
                                                                  + ((*v247 * v338) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v339 = *v337;
                    int v340 = (v338 | (v338 << 8)) ^ 0xFFFF;
                    int v341 = v339 - ((v340 * v339 + ((v340 * v339) >> 16) + 1) >> 16);
                    if (v339 != (v340 * v339 + ((v340 * v339) >> 16) + 1) >> 16)
                    {
                      unint64_t v342 = *((void *)v337 - 1);
                      unint64_t v343 = ((HIWORD(v342)
                             - ((v340 * HIWORD(v342) + ((v340 * HIWORD(v342)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v342) - ((WORD2(v342) * v340 + ((WORD2(v342) * v340) >> 16) + 1) >> 16)) << 32) | ((WORD1(v342) - ((WORD1(v342) * v340 + ((WORD1(v342) * v340) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v342 - (((unsigned __int16)v342 * v340 + (((unsigned __int16)v342 * v340) >> 16) + 1) >> 16));
                      __int16 v344 = v341;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v343 = PDAexclusionPDA_11720((unint64_t)*v35, (unsigned __int16)*v31, v343, (unsigned __int16)v341);
                          __int16 v344 = v345;
                        }
                        *long long v35 = (int8x8_t)v343;
                        *long long v31 = v344;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAexclusionPDA_11720((unint64_t)*v35, 0xFFFFu, v343, (unsigned __int16)v341);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v337 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 24:
              unint64_t v346 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v347 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v347 = ((unsigned __int16)(*v247 * (_WORD)v347
                                                                  + ((*v247 * v347) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v348 = *v346;
                    int v349 = (v347 | (v347 << 8)) ^ 0xFFFF;
                    int v350 = v348 - ((v349 * v348 + ((v349 * v348) >> 16) + 1) >> 16);
                    if (v348 != (v349 * v348 + ((v349 * v348) >> 16) + 1) >> 16)
                    {
                      unint64_t v351 = *((void *)v346 - 1);
                      unint64_t v352 = ((HIWORD(v351)
                             - ((v349 * HIWORD(v351) + ((v349 * HIWORD(v351)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v351) - ((WORD2(v351) * v349 + ((WORD2(v351) * v349) >> 16) + 1) >> 16)) << 32) | ((WORD1(v351) - ((WORD1(v351) * v349 + ((WORD1(v351) * v349) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v351 - (((unsigned __int16)v351 * v349 + (((unsigned __int16)v351 * v349) >> 16) + 1) >> 16));
                      __int16 v353 = v350;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v352 = PDAhuePDA_11721((unint64_t)*v35, (unsigned __int16)*v31, v352, (unsigned __int16)v350);
                          __int16 v353 = v354;
                        }
                        *long long v35 = (int8x8_t)v352;
                        *long long v31 = v353;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAhuePDA_11721((unint64_t)*v35, 0xFFFFu, v352, (unsigned __int16)v350);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v346 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 25:
              unint64_t v355 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v356 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v356 = ((unsigned __int16)(*v247 * (_WORD)v356
                                                                  + ((*v247 * v356) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v357 = *v355;
                    int v358 = (v356 | (v356 << 8)) ^ 0xFFFF;
                    int v359 = v357 - ((v358 * v357 + ((v358 * v357) >> 16) + 1) >> 16);
                    if (v357 != (v358 * v357 + ((v358 * v357) >> 16) + 1) >> 16)
                    {
                      unint64_t v360 = *((void *)v355 - 1);
                      unint64_t v361 = ((HIWORD(v360)
                             - ((v358 * HIWORD(v360) + ((v358 * HIWORD(v360)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v360) - ((WORD2(v360) * v358 + ((WORD2(v360) * v358) >> 16) + 1) >> 16)) << 32) | ((WORD1(v360) - ((WORD1(v360) * v358 + ((WORD1(v360) * v358) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v360 - (((unsigned __int16)v360 * v358 + (((unsigned __int16)v360 * v358) >> 16) + 1) >> 16));
                      __int16 v362 = v359;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v361 = PDAsaturationPDA_11722((unint64_t)*v35, (unsigned __int16)*v31, v361, (unsigned __int16)v359);
                          __int16 v362 = v363;
                        }
                        *long long v35 = (int8x8_t)v361;
                        *long long v31 = v362;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAsaturationPDA_11722((unint64_t)*v35, 0xFFFFu, v361, (unsigned __int16)v359);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v355 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 26:
              id v364 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v365 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v365 = ((unsigned __int16)(*v247 * (_WORD)v365
                                                                  + ((*v247 * v365) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v366 = *v364;
                    int v367 = (v365 | (v365 << 8)) ^ 0xFFFF;
                    int v368 = v366 - ((v367 * v366 + ((v367 * v366) >> 16) + 1) >> 16);
                    if (v366 != (v367 * v366 + ((v367 * v366) >> 16) + 1) >> 16)
                    {
                      unint64_t v369 = *((void *)v364 - 1);
                      unint64_t v370 = ((HIWORD(v369)
                             - ((v367 * HIWORD(v369) + ((v367 * HIWORD(v369)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v369) - ((WORD2(v369) * v367 + ((WORD2(v369) * v367) >> 16) + 1) >> 16)) << 32) | ((WORD1(v369) - ((WORD1(v369) * v367 + ((WORD1(v369) * v367) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v369 - (((unsigned __int16)v369 * v367 + (((unsigned __int16)v369 * v367) >> 16) + 1) >> 16));
                      __int16 v371 = v368;
                      if (v502)
                      {
                        if (*v31) {
                          unint64_t v370 = PDAluminosityPDA_11723(v370, (unsigned __int16)v368, (unint64_t)*v35, (unsigned __int16)*v31);
                        }
                        *long long v35 = (int8x8_t)v370;
                        *long long v31 = v371;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAluminosityPDA_11723(v370, (unsigned __int16)v368, (unint64_t)*v35, 0xFFFFu);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v364 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
              goto LABEL_418;
            case 27:
              id v372 = (unsigned __int16 *)(v57 + 8);
              unsigned int v247 = (unsigned __int8 *)v44;
              do
              {
                int v373 = *v58;
                if (*v58)
                {
                  if (!v44
                    || (int v373 = ((unsigned __int16)(*v247 * (_WORD)v373
                                                                  + ((*v247 * v373) >> 8)
                                                                  + 1) >> 8)) != 0)
                  {
                    int v374 = *v372;
                    int v375 = (v373 | (v373 << 8)) ^ 0xFFFF;
                    int v376 = v374 - ((v375 * v374 + ((v375 * v374) >> 16) + 1) >> 16);
                    if (v374 != (v375 * v374 + ((v375 * v374) >> 16) + 1) >> 16)
                    {
                      unint64_t v377 = *((void *)v372 - 1);
                      unint64_t v378 = ((HIWORD(v377)
                             - ((v375 * HIWORD(v377) + ((v375 * HIWORD(v377)) >> 16) + 1) >> 16)) << 48) | ((unint64_t)(unsigned __int16)(WORD2(v377) - ((WORD2(v377) * v375 + ((WORD2(v377) * v375) >> 16) + 1) >> 16)) << 32) | ((WORD1(v377) - ((WORD1(v377) * v375 + ((WORD1(v377) * v375) >> 16) + 1) >> 16)) << 16) | (unsigned __int16)(v377 - (((unsigned __int16)v377 * v375 + (((unsigned __int16)v377 * v375) >> 16) + 1) >> 16));
                      __int16 v379 = v376;
                      if (v502)
                      {
                        if (*v31)
                        {
                          unint64_t v378 = PDAluminosityPDA_11723((unint64_t)*v35, (unsigned __int16)*v31, v378, (unsigned __int16)v376);
                          __int16 v379 = v380;
                        }
                        *long long v35 = (int8x8_t)v378;
                        *long long v31 = v379;
                      }
                      else
                      {
                        *long long v35 = (int8x8_t)PDAluminosityPDA_11723((unint64_t)*v35, 0xFFFFu, v378, (unsigned __int16)v376);
                      }
                    }
                  }
                }
                ++v58;
                v247 += v44 != 0;
                ++v35;
                v372 += 8;
                long long v31 = (__int16 *)((char *)v31 + v53);
                --v50;
              }
              while (v50);
LABEL_418:
              uint64_t v44 = (uint64_t)&v247[v490];
LABEL_502:
              v35 += v491;
              v31 += v493;
              long long v39 = v495;
              int v50 = v501;
              uint64_t v118 = v499;
              int v453 = (int)v496;
              goto LABEL_503;
            default:
              goto LABEL_540;
          }
          break;
        }
      }
    }
    uint64_t v482 = v34;
    uint64_t v483 = v33;
    shape_enum_clip_alloc((uint64_t)v20, v21, v496, 1, 1, 1, v36, v37, v501, v498);
    if (v45)
    {
      int v46 = v45;
      int v47 = 0;
      uint64_t v48 = (int)((v16 * v4 + 15) & 0xFFFFFFF0);
      if (!v16) {
        uint64_t v48 = 16 * v4;
      }
      uint64_t v49 = v488;
      uint64_t v490 = -v488;
      uint64_t v44 = v27 + v48 + 16;
      long long v39 = v495;
      int v50 = v501;
      goto LABEL_548;
    }
LABEL_545:
    if (v484) {
      free(v484);
    }
  }
}

unsigned int *cmyk64_DAMplusDAM(unsigned int *result, _WORD *a2, unint64_t a3, int a4, int a5, unint64_t a6, int a7, int a8)
{
  unsigned int v8 = WORD1(a3) * a5 + WORD1(a6) * a8;
  unsigned int v9 = WORD2(a3) * a5 + WORD2(a6) * a8;
  unsigned int v10 = a5 * HIWORD(a3) + a8 * HIWORD(a6);
  *__n128 result = (v8 + HIWORD(v8) + 1) & 0xFFFF0000 | (((unsigned __int16)a3 * a5
                                                 + (unsigned __int16)a6 * a8
                                                 + (((unsigned __int16)a3 * a5 + (unsigned __int16)a6 * a8) >> 16)
                                                 + 1) >> 16);
  result[1] = (v10 + HIWORD(v10) + 1) & 0xFFFF0000 | ((v9 + HIWORD(v9) + 1) >> 16);
  *a2 = (a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 16) + 1) >> 16;
  return result;
}

unsigned int *cmyk64_DMplusDM(unsigned int *result, unint64_t a2, int a3, unint64_t a4, int a5)
{
  unsigned int v5 = WORD1(a2) * a3 + WORD1(a4) * a5;
  unsigned int v6 = WORD2(a2) * a3 + WORD2(a4) * a5;
  unsigned int v7 = HIWORD(a2) * a3 + HIWORD(a4) * a5;
  *__n128 result = (v5 + HIWORD(v5) + 1) & 0xFFFF0000 | (((unsigned __int16)a2 * a3
                                                 + (unsigned __int16)a4 * a5
                                                 + (((unsigned __int16)a2 * a3 + (unsigned __int16)a4 * a5) >> 16)
                                                 + 1) >> 16);
  result[1] = (v7 + HIWORD(v7) + 1) & 0xFFFF0000 | ((v6 + HIWORD(v6) + 1) >> 16);
  return result;
}

void *cmyk64_DAplusDAM(void *result, _WORD *a2, uint64_t a3, __int16 a4, unint64_t a5, int a6, int a7)
{
  *__n128 result = ((WORD1(a5) * a7 + ((WORD1(a5) * a7) >> 16) + 1) & 0xFFFF0000)
          + a3
          + (((unsigned __int16)a5 * a7 + (((unsigned __int16)a5 * a7) >> 16) + 1) >> 16)
          + ((unint64_t)((WORD2(a5) * a7 + ((WORD2(a5) * a7) >> 16) + 1) >> 16) << 32)
          + ((a7 * HIWORD(a5) + ((a7 * HIWORD(a5)) >> 16) + 1) >> 16 << 48);
  *a2 = a4 + ((a7 * a6 + ((a7 * a6) >> 16) + 1) >> 16);
  return result;
}

void *cmyk64_DplusDM(void *result, uint64_t a2, unint64_t a3, int a4)
{
  *__n128 result = ((WORD1(a3) * a4 + ((WORD1(a3) * a4) >> 16) + 1) & 0xFFFF0000)
          + a2
          + (((unsigned __int16)a3 * a4 + (((unsigned __int16)a3 * a4) >> 16) + 1) >> 16)
          + ((HIWORD(a3) * a4 + ((HIWORD(a3) * a4) >> 16) + 1) >> 16 << 48)
          + ((unint64_t)((WORD2(a3) * a4 + ((WORD2(a3) * a4) >> 16) + 1) >> 16) << 32);
  return result;
}

int *cmyk64_DAplusdDA(int *result, __int16 *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  int v6 = a4 - (WORD1(a3) + WORD1(a5)) + a6;
  int v7 = a4 + a6 - (WORD2(a3) + WORD2(a5));
  int v8 = a4 - (HIWORD(a3) + HIWORD(a5)) + a6;
  if (v6 >= 0xFFFF) {
    LOWORD(v6) = -1;
  }
  if (v7 >= 0xFFFF) {
    LOWORD(v7) = -1;
  }
  if (v8 >= 0xFFFF) {
    LOWORD(v8) = -1;
  }
  if ((a4 + a6) >= 0xFFFF) {
    __int16 v9 = -1;
  }
  else {
    __int16 v9 = a4 + a6;
  }
  *__n128 result = (unsigned __int16)(v9 - v6) | ((unsigned __int16)(v9 - v6) << 16);
  result[1] = (unsigned __int16)(v9 - v7) | ((unsigned __int16)(v9 - v8) << 16);
  *a2 = v9;
  return result;
}

int *cmyk64_DplusdDA(int *result, unint64_t a2, unint64_t a3, int a4)
{
  int v4 = a4 - WORD2(a3) + (unsigned __int16)~WORD2(a2);
  int v5 = a4 - HIWORD(a3) + (HIWORD(a2) ^ 0xFFFF);
  if ((int)(a4 - WORD1(a3) + (~a2 >> 16)) >= 0xFFFF) {
    LOWORD(v6) = -1;
  }
  else {
    unsigned int v6 = a4 - WORD1(a3) + (~a2 >> 16);
  }
  unsigned __int16 v7 = ~(_WORD)v6;
  if (v4 >= 0xFFFF) {
    LOWORD(v4) = -1;
  }
  if (v5 >= 0xFFFF) {
    LOWORD(v5) = -1;
  }
  *__n128 result = v7 | (v7 << 16);
  result[1] = ((unsigned __int16)v4 | ((unsigned __int16)~(_WORD)v5 << 16)) ^ 0xFFFF;
  return result;
}

unsigned int *cmyk64_DApluslDA(unsigned int *result, _WORD *a2, unint64_t a3, int a4, unint64_t a5, int a6)
{
  unsigned int v6 = (unsigned __int16)a5 + (unsigned __int16)a3;
  unsigned int v7 = WORD1(a5) + WORD1(a3);
  unsigned int v8 = WORD2(a5) + WORD2(a3);
  unsigned int v9 = HIWORD(a5) + HIWORD(a3);
  unsigned int v10 = a6 + a4;
  if (v6 >= 0xFFFF) {
    unsigned int v6 = 0xFFFF;
  }
  if (v7 >= 0xFFFF) {
    unsigned int v7 = 0xFFFF;
  }
  if (v8 >= 0xFFFF) {
    unsigned int v8 = 0xFFFF;
  }
  if (v9 >= 0xFFFF) {
    unsigned int v9 = 0xFFFF;
  }
  if (v10 >= 0xFFFF) {
    LOWORD(v10) = -1;
  }
  *__n128 result = v6 | (v7 << 16);
  result[1] = v8 | (v9 << 16);
  *a2 = v10;
  return result;
}

unsigned int *cmyk64_DpluslD(unsigned int *result, unint64_t a2, unint64_t a3)
{
  unsigned int v3 = (unsigned __int16)a3 + (unsigned __int16)a2;
  unsigned int v4 = WORD1(a3) + WORD1(a2);
  unsigned int v5 = WORD2(a3) + WORD2(a2);
  unsigned int v6 = HIWORD(a3) + HIWORD(a2);
  if (v3 >= 0xFFFF) {
    unsigned int v3 = 0xFFFF;
  }
  if (v4 >= 0xFFFF) {
    unsigned int v4 = 0xFFFF;
  }
  if (v5 >= 0xFFFF) {
    unsigned int v5 = 0xFFFF;
  }
  if (v6 >= 0xFFFF) {
    unsigned int v6 = 0xFFFF;
  }
  *__n128 result = v3 | (v4 << 16);
  result[1] = v5 | (v6 << 16);
  return result;
}

unint64_t PDAmultiplyPDA_11710(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = a4;
  unsigned int v5 = a4 - (unsigned __int16)a3;
  unsigned int v6 = a4 - WORD1(a3);
  unsigned int v7 = a4 - WORD2(a3);
  unint64_t v8 = a4 - HIWORD(a3);
  BOOL v9 = a4 == 0xFFFF;
  int v10 = a4 ^ 0xFFFF;
  unsigned int v11 = v5 + (a4 ^ 0xFFFF);
  unsigned int v12 = v6 + v10;
  unsigned int v13 = v7 + v10;
  int v14 = v8 + v10;
  if (v9)
  {
    unsigned int v11 = v5;
    unsigned int v12 = v6;
    unsigned int v13 = v7;
    int v14 = v8;
  }
  uint64_t v15 = v14 * (uint64_t)(int)(a2 - HIWORD(a1));
  uint64_t v16 = (int)v13 * (uint64_t)(int)(a2 - WORD2(a1));
  uint64_t v17 = (int)v12 * (uint64_t)(int)(a2 - WORD1(a1));
  uint64_t v18 = (int)v11 * (uint64_t)(int)(a2 - (unsigned __int16)a1);
  uint64_t v19 = v18 + (int)v5 * (uint64_t)(int)(a2 ^ 0xFFFF);
  uint64_t v20 = v17 + (int)v6 * (uint64_t)(int)(a2 ^ 0xFFFF);
  uint64_t v21 = v16 + (int)v7 * (uint64_t)(int)(a2 ^ 0xFFFF);
  uint64_t v22 = v15 + (int)v8 * (uint64_t)(int)(a2 ^ 0xFFFF);
  if (a2 != 0xFFFF)
  {
    uint64_t v18 = v19;
    uint64_t v17 = v20;
    uint64_t v16 = v21;
    uint64_t v15 = v22;
  }
  int64_t v23 = 0xFFFF * (v4 + a2) - v4 * (unint64_t)a2;
  if (v18 <= 4294868992) {
    unint64_t v24 = v18 + 0x8000;
  }
  else {
    unint64_t v24 = 4294868992;
  }
  int v25 = (v24 >> 16) + v24;
  if (v17 <= 4294868992) {
    unint64_t v26 = v17 + 0x8000;
  }
  else {
    unint64_t v26 = 4294868992;
  }
  unsigned int v27 = (v26 >> 16) + v26;
  if (v16 <= 4294868992) {
    unint64_t v28 = v16 + 0x8000;
  }
  else {
    unint64_t v28 = 4294868992;
  }
  int v29 = (v28 >> 16) + v28;
  if (v15 <= 4294868992) {
    unint64_t v30 = v15 + 0x8000;
  }
  else {
    unint64_t v30 = 4294868992;
  }
  unsigned int v31 = (v30 >> 16) + v30;
  if (v23 <= 4294868992) {
    uint64_t v32 = v23 + 0x8000;
  }
  else {
    uint64_t v32 = 4294868992;
  }
  return ((unint64_t)(unsigned __int16)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v29)) << 32) | ((unint64_t)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v31)) << 48) | ((((v32 + (v32 >> 16)) >> 16) - HIWORD(v27)) << 16) | (unsigned __int16)(((v32 + (v32 >> 16)) >> 16) - HIWORD(v25));
}

unint64_t PDAscreenPDA_11711(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4 = (int)(a4 - (unsigned __int16)a3) * (uint64_t)(int)(0xFFFF - (a2 - (unsigned __int16)a1))
     - (a2
      - (unint64_t)(unsigned __int16)a1)
     + ((a2 - (unint64_t)(unsigned __int16)a1) << 16);
  int64_t v5 = (int)(a4 - WORD1(a3)) * (uint64_t)(int)(0xFFFF - (a2 - WORD1(a1)))
     - (a2
      - (unint64_t)WORD1(a1))
     + ((a2 - (unint64_t)WORD1(a1)) << 16);
  int64_t v6 = (int)(a4 - WORD2(a3)) * (uint64_t)(int)(0xFFFF - (a2 - WORD2(a1)))
     - (a2
      - (unint64_t)WORD2(a1))
     + ((a2 - (unint64_t)WORD2(a1)) << 16);
  uint64_t v7 = (int)(a4 - HIWORD(a3)) * (uint64_t)(int)(0xFFFF - (a2 - HIWORD(a1)))
     - (a2
      - HIWORD(a1))
     + ((a2 - HIWORD(a1)) << 16);
  int64_t v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v4 <= 4294868992) {
    unint64_t v9 = v4 + 0x8000;
  }
  else {
    unint64_t v9 = 4294868992;
  }
  int v10 = (v9 >> 16) + v9;
  if (v5 <= 4294868992) {
    unint64_t v11 = v5 + 0x8000;
  }
  else {
    unint64_t v11 = 4294868992;
  }
  unsigned int v12 = (v11 >> 16) + v11;
  if (v6 <= 4294868992) {
    unint64_t v13 = v6 + 0x8000;
  }
  else {
    unint64_t v13 = 4294868992;
  }
  int v14 = (v13 >> 16) + v13;
  if (v7 <= 4294868992) {
    unint64_t v15 = v7 + 0x8000;
  }
  else {
    unint64_t v15 = 4294868992;
  }
  unsigned int v16 = (v15 >> 16) + v15;
  if (v8 <= 4294868992) {
    uint64_t v17 = v8 + 0x8000;
  }
  else {
    uint64_t v17 = 4294868992;
  }
  return ((unint64_t)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v16)) << 48) | ((unint64_t)(unsigned __int16)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v14)) << 32) | ((((v17 + (v17 >> 16)) >> 16) - HIWORD(v12)) << 16) | (unsigned __int16)(((v17 + (v17 >> 16)) >> 16) - HIWORD(v10));
}

unint64_t PDAoverlayPDA_11712(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = a2;
  int64_t v5 = a2 - (unint64_t)WORD2(a1);
  uint64_t v6 = a2 - HIWORD(a1);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    unint64_t v7 = a4;
  }
  else {
    unint64_t v7 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    int64_t v8 = a2;
  }
  else {
    int64_t v8 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  uint64_t v9 = 2 * v8 * v7;
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4) {
    unint64_t v10 = a4;
  }
  else {
    unint64_t v10 = a4 - (unint64_t)WORD1(a3);
  }
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2) {
    int64_t v11 = a2;
  }
  else {
    int64_t v11 = a2 - (unint64_t)WORD1(a1);
  }
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4) {
    unint64_t v12 = a4;
  }
  else {
    unint64_t v12 = a4 - (unint64_t)WORD2(a3);
  }
  if (v5 >= a2) {
    int64_t v13 = a2;
  }
  else {
    int64_t v13 = v5;
  }
  if ((uint64_t)(a4 - HIWORD(a3)) >= a4) {
    unint64_t v14 = a4;
  }
  else {
    unint64_t v14 = a4 - HIWORD(a3);
  }
  if (v6 >= a2) {
    int64_t v15 = a2;
  }
  else {
    int64_t v15 = v6;
  }
  unint64_t v16 = a4 * (unint64_t)a2;
  int64_t v17 = ((unint64_t)a2 + 1) >> 1;
  if (v8 >= v17) {
    uint64_t v18 = v7 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v8 - (v16 + v9);
  }
  else {
    uint64_t v18 = (a4 ^ 0xFFFFLL) * v8 + v7 * (a2 ^ 0xFFFFLL) + v9;
  }
  uint64_t v19 = 2 * v11 * v10;
  if (v11 >= v17) {
    uint64_t v20 = v10 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v11 - (v16 + v19);
  }
  else {
    uint64_t v20 = (a4 ^ 0xFFFFLL) * v11 + v10 * (a2 ^ 0xFFFFLL) + v19;
  }
  uint64_t v21 = 2 * v13 * v12;
  if (v13 >= v17) {
    uint64_t v22 = v12 * (v4 + 0xFFFF) + (a4 + 0xFFFFLL) * v13 - (v16 + v21);
  }
  else {
    uint64_t v22 = (a4 ^ 0xFFFFLL) * v13 + v12 * (v4 ^ 0xFFFF) + v21;
  }
  uint64_t v23 = 2 * v15 * v14;
  if (v15 >= v17) {
    uint64_t v24 = v14 * (v4 + 0xFFFF) + (a4 + 0xFFFFLL) * v15 - (v16 + v23);
  }
  else {
    uint64_t v24 = (a4 ^ 0xFFFFLL) * v15 + v14 * (v4 ^ 0xFFFF) + v23;
  }
  uint64_t v25 = 0xFFFF * (a4 + v4) - v16;
  unint64_t v26 = v18 + 0x8000;
  if (v18 > 4294868992) {
    unint64_t v26 = 4294868992;
  }
  v27.i64[0] = v22;
  v27.i64[1] = v20;
  int v28 = (v26 >> 16) + v26;
  int64x2_t v29 = vdupq_n_s64(0xFFFE8000uLL);
  int8x16_t v30 = (int8x16_t)vcgtq_s64(v27, v29);
  int8x16_t v31 = (int8x16_t)vaddq_s64(v27, vdupq_n_s64(0x8000uLL));
  if (v24 <= 4294868992) {
    unint64_t v32 = v24 + 0x8000;
  }
  else {
    unint64_t v32 = 4294868992;
  }
  unsigned int v33 = (v32 >> 16) + v32;
  if (v25 <= 4294868992) {
    uint64_t v34 = v25 + 0x8000;
  }
  else {
    uint64_t v34 = 4294868992;
  }
  unint64_t v35 = (v34 + (v34 >> 16)) >> 16;
  uint64x2_t v36 = (uint64x2_t)vbslq_s8(v30, (int8x16_t)v29, v31);
  int8x16_t v37 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v35), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v36, v36, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_1850CDCA0), (int8x16_t)xmmword_1850CDCB0);
  return v37.i64[0] | ((unint64_t)(v35 - HIWORD(v33)) << 48) | (unsigned __int16)(v35 - HIWORD(v28)) | v37.i64[1];
}

unint64_t PDAlightenPDA_11713(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4 = a2 - (unint64_t)(unsigned __int16)a1;
  int64_t v5 = a2 - (unint64_t)WORD1(a1);
  int64_t v6 = a2 - (unint64_t)WORD2(a1);
  uint64_t v7 = a2 - HIWORD(a1);
  int64_t v8 = a4 - (unint64_t)(unsigned __int16)a3;
  int64_t v9 = a4 - (unint64_t)WORD1(a3);
  int64_t v10 = a4 - (unint64_t)WORD2(a3);
  uint64_t v11 = a4 - HIWORD(a3);
  if (v8 >= a4) {
    int64_t v8 = a4;
  }
  if (v4 >= a2) {
    int64_t v4 = a2;
  }
  int64_t v12 = v4 * a4;
  if (v8 * a2 > v12) {
    int64_t v12 = v8 * a2;
  }
  if (v9 >= a4) {
    int64_t v9 = a4;
  }
  if (v5 >= a2) {
    int64_t v5 = a2;
  }
  int64_t v13 = v5 * a4;
  if (v9 * a2 > v13) {
    int64_t v13 = v9 * a2;
  }
  if (v10 >= a4) {
    int64_t v10 = a4;
  }
  if (v6 >= a2) {
    int64_t v6 = a2;
  }
  int64_t v14 = v6 * a4;
  if (v10 * a2 > v14) {
    int64_t v14 = v10 * a2;
  }
  if (v11 >= a4) {
    uint64_t v11 = a4;
  }
  if (v7 >= a2) {
    uint64_t v7 = a2;
  }
  int64_t v15 = v7 * a4;
  if (v11 * a2 > v15) {
    int64_t v15 = v11 * a2;
  }
  uint64_t v16 = v12 + (a4 ^ 0xFFFFLL) * v4;
  uint64_t v17 = v13 + (a4 ^ 0xFFFFLL) * v5;
  uint64_t v18 = v14 + (a4 ^ 0xFFFFLL) * v6;
  uint64_t v19 = v15 + (a4 ^ 0xFFFFLL) * v7;
  if (a4 == 0xFFFF)
  {
    uint64_t v19 = v15;
    uint64_t v18 = v14;
    uint64_t v17 = v13;
    uint64_t v16 = v12;
  }
  uint64_t v20 = v16 + v8 * (a2 ^ 0xFFFFLL);
  uint64_t v21 = v17 + v9 * (a2 ^ 0xFFFFLL);
  uint64_t v22 = v18 + v10 * (a2 ^ 0xFFFFLL);
  uint64_t v23 = v19 + v11 * (a2 ^ 0xFFFFLL);
  if (a2 != 0xFFFF)
  {
    uint64_t v19 = v23;
    uint64_t v18 = v22;
    uint64_t v17 = v21;
    uint64_t v16 = v20;
  }
  int64_t v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  unint64_t v25 = v16 + 0x8000;
  if (v16 > 4294868992) {
    unint64_t v25 = 4294868992;
  }
  int v26 = (v25 >> 16) + v25;
  unint64_t v27 = v17 + 0x8000;
  if (v17 > 4294868992) {
    unint64_t v27 = 4294868992;
  }
  unsigned int v28 = (v27 >> 16) + v27;
  if (v18 <= 4294868992) {
    unint64_t v29 = v18 + 0x8000;
  }
  else {
    unint64_t v29 = 4294868992;
  }
  int v30 = (v29 >> 16) + v29;
  unint64_t v31 = v19 + 0x8000;
  if (v19 > 4294868992) {
    unint64_t v31 = 4294868992;
  }
  unsigned int v32 = (v31 >> 16) + v31;
  if (v24 <= 4294868992) {
    uint64_t v33 = v24 + 0x8000;
  }
  else {
    uint64_t v33 = 4294868992;
  }
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26));
}

unint64_t PDAdarkenPDA_11714(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4 = a2 - (unint64_t)(unsigned __int16)a1;
  int64_t v5 = a2 - (unint64_t)WORD1(a1);
  int64_t v6 = a2 - (unint64_t)WORD2(a1);
  uint64_t v7 = a2 - HIWORD(a1);
  int64_t v8 = a4 - (unint64_t)(unsigned __int16)a3;
  int64_t v9 = a4 - (unint64_t)WORD1(a3);
  int64_t v10 = a4 - (unint64_t)WORD2(a3);
  uint64_t v11 = a4 - HIWORD(a3);
  if (v8 >= a4) {
    int64_t v8 = a4;
  }
  if (v4 >= a2) {
    int64_t v4 = a2;
  }
  int64_t v12 = v4 * a4;
  if (v8 * a2 < v12) {
    int64_t v12 = v8 * a2;
  }
  if (v9 >= a4) {
    int64_t v9 = a4;
  }
  if (v5 >= a2) {
    int64_t v5 = a2;
  }
  int64_t v13 = v5 * a4;
  if (v9 * a2 < v13) {
    int64_t v13 = v9 * a2;
  }
  if (v10 >= a4) {
    int64_t v10 = a4;
  }
  if (v6 >= a2) {
    int64_t v6 = a2;
  }
  int64_t v14 = v6 * a4;
  if (v10 * a2 < v14) {
    int64_t v14 = v10 * a2;
  }
  if (v11 >= a4) {
    uint64_t v11 = a4;
  }
  if (v7 >= a2) {
    uint64_t v7 = a2;
  }
  int64_t v15 = v7 * a4;
  if (v11 * a2 < v15) {
    int64_t v15 = v11 * a2;
  }
  uint64_t v16 = v12 + (a4 ^ 0xFFFFLL) * v4;
  uint64_t v17 = v13 + (a4 ^ 0xFFFFLL) * v5;
  uint64_t v18 = v14 + (a4 ^ 0xFFFFLL) * v6;
  uint64_t v19 = v15 + (a4 ^ 0xFFFFLL) * v7;
  if (a4 == 0xFFFF)
  {
    uint64_t v19 = v15;
    uint64_t v18 = v14;
    uint64_t v17 = v13;
    uint64_t v16 = v12;
  }
  uint64_t v20 = v16 + v8 * (a2 ^ 0xFFFFLL);
  uint64_t v21 = v17 + v9 * (a2 ^ 0xFFFFLL);
  uint64_t v22 = v18 + v10 * (a2 ^ 0xFFFFLL);
  uint64_t v23 = v19 + v11 * (a2 ^ 0xFFFFLL);
  if (a2 != 0xFFFF)
  {
    uint64_t v19 = v23;
    uint64_t v18 = v22;
    uint64_t v17 = v21;
    uint64_t v16 = v20;
  }
  int64_t v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  unint64_t v25 = v16 + 0x8000;
  if (v16 > 4294868992) {
    unint64_t v25 = 4294868992;
  }
  int v26 = (v25 >> 16) + v25;
  unint64_t v27 = v17 + 0x8000;
  if (v17 > 4294868992) {
    unint64_t v27 = 4294868992;
  }
  unsigned int v28 = (v27 >> 16) + v27;
  if (v18 <= 4294868992) {
    unint64_t v29 = v18 + 0x8000;
  }
  else {
    unint64_t v29 = 4294868992;
  }
  int v30 = (v29 >> 16) + v29;
  unint64_t v31 = v19 + 0x8000;
  if (v19 > 4294868992) {
    unint64_t v31 = 4294868992;
  }
  unsigned int v32 = (v31 >> 16) + v31;
  if (v24 <= 4294868992) {
    uint64_t v33 = v24 + 0x8000;
  }
  else {
    uint64_t v33 = 4294868992;
  }
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26));
}

unint64_t PDAcolordodgePDA_11715(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = 4294836225;
  int64_t v5 = a2 - (unint64_t)WORD1(a1);
  unint64_t v6 = a4 * (unint64_t)a4;
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  if (v7)
  {
    uint64_t v8 = 4294836225;
    if ((_WORD)a3) {
      uint64_t v8 = (uint64_t)(v6 * v7) / (unsigned __int16)a3;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  unint64_t v9 = a3 >> 16;
  unint64_t v10 = HIDWORD(a3);
  if (v5 >= a2) {
    int64_t v5 = a2;
  }
  int64_t v11 = a2 - (unint64_t)WORD2(a1);
  if (v5)
  {
    uint64_t v12 = 4294836225;
    if (WORD1(a3)) {
      uint64_t v12 = (uint64_t)(v6 * v5) / WORD1(a3);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v13 = a2 - HIWORD(a1);
  uint64_t v14 = HIWORD(a3);
  if (v11 >= a2) {
    int64_t v15 = a2;
  }
  else {
    int64_t v15 = v11;
  }
  if (v15)
  {
    uint64_t v16 = 4294836225;
    if (WORD2(a3)) {
      uint64_t v16 = (uint64_t)(v6 * v15) / WORD2(a3);
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  unsigned int v17 = a4 - (unsigned __int16)a3;
  unsigned int v18 = a4 - (unsigned __int16)v9;
  if (v13 >= a2) {
    uint64_t v19 = a2;
  }
  else {
    uint64_t v19 = v13;
  }
  unsigned int v20 = a4 - (unsigned __int16)v10;
  if (v19)
  {
    if (v14) {
      uint64_t v4 = (uint64_t)(v6 * v19) / v14;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (a4 != 0xFFFF)
  {
    v8 += (a4 ^ 0xFFFFLL) * v7;
    v12 += (a4 ^ 0xFFFFLL) * v5;
    v16 += (a4 ^ 0xFFFFLL) * v15;
    v4 += (a4 ^ 0xFFFFLL) * v19;
  }
  if (a2 == 0xFFFF)
  {
    uint64_t v21 = v16;
  }
  else
  {
    v4 += (int)(a4 - v14) * (uint64_t)(int)(a2 ^ 0xFFFF);
    uint64_t v21 = v16 + (int)v20 * (uint64_t)(int)(a2 ^ 0xFFFF);
  }
  if (a2 != 0xFFFF)
  {
    v12 += (int)v18 * (uint64_t)(int)(a2 ^ 0xFFFF);
    v8 += (int)v17 * (uint64_t)(int)(a2 ^ 0xFFFF);
  }
  int64_t v22 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v8 >= v22) {
    uint64_t v8 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  }
  if (v12 >= v22) {
    int64_t v23 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  }
  else {
    int64_t v23 = v12;
  }
  if (v21 >= v22) {
    int64_t v24 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  }
  else {
    int64_t v24 = v21;
  }
  if (v4 >= v22) {
    uint64_t v4 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  }
  if (v24 <= 4294868992) {
    unint64_t v25 = v24 + 0x8000;
  }
  else {
    unint64_t v25 = 4294868992;
  }
  int v26 = (v25 >> 16) + v25;
  if (v23 <= 4294868992) {
    unint64_t v27 = v23 + 0x8000;
  }
  else {
    unint64_t v27 = 4294868992;
  }
  unsigned int v28 = (v27 >> 16) + v27;
  if (v8 <= 4294868992) {
    unint64_t v29 = v8 + 0x8000;
  }
  else {
    unint64_t v29 = 4294868992;
  }
  int v30 = (v29 >> 16) + v29;
  if (v4 <= 4294868992) {
    unint64_t v31 = v4 + 0x8000;
  }
  else {
    unint64_t v31 = 4294868992;
  }
  unsigned int v32 = (v31 >> 16) + v31;
  if (v22 <= 4294868992) {
    uint64_t v33 = v22 + 0x8000;
  }
  else {
    uint64_t v33 = 4294868992;
  }
  return ((unint64_t)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v32)) << 48) | ((unint64_t)(unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v26)) << 32) | ((((v33 + (v33 >> 16)) >> 16) - HIWORD(v28)) << 16) | (unsigned __int16)(((v33 + (v33 >> 16)) >> 16) - HIWORD(v30));
}

unint64_t PDAcolorburnPDA_11716(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = a2 - HIWORD(a1);
  uint64_t v6 = a4;
  int64_t v7 = a4 - (unint64_t)WORD1(a3);
  uint64_t v8 = a4 - HIWORD(a3);
  unint64_t v9 = a4 * (unint64_t)a2;
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    int64_t v10 = a4;
  }
  else {
    int64_t v10 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    unint64_t v11 = a2;
  }
  else {
    unint64_t v11 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  if (v7 >= a4) {
    int64_t v7 = a4;
  }
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2) {
    unint64_t v12 = a2;
  }
  else {
    unint64_t v12 = a2 - (unint64_t)WORD1(a1);
  }
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4) {
    int64_t v13 = a4;
  }
  else {
    int64_t v13 = a4 - (unint64_t)WORD2(a3);
  }
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2) {
    unint64_t v14 = a2;
  }
  else {
    unint64_t v14 = a2 - (unint64_t)WORD2(a1);
  }
  if (v8 >= a4) {
    uint64_t v15 = a4;
  }
  else {
    uint64_t v15 = v8;
  }
  if (v5 >= a2) {
    uint64_t v5 = a2;
  }
  BOOL v20 = a4 == 0xFFFF;
  unint64_t v16 = v9 + (a4 ^ 0xFFFFLL) * v12;
  unint64_t v17 = v9 + (v6 ^ 0xFFFF) * v14;
  unint64_t v18 = v9 + (v6 ^ 0xFFFF) * v5;
  if (v20)
  {
    unint64_t v18 = v9;
    unint64_t v17 = v9;
    unint64_t v16 = v9;
    unint64_t v19 = v9;
  }
  else
  {
    unint64_t v19 = v9 + (v6 ^ 0xFFFF) * v11;
  }
  BOOL v20 = a2 == 0xFFFF;
  uint64_t v21 = v19 + v10 * (a2 ^ 0xFFFFLL);
  if (v20) {
    uint64_t v22 = v18;
  }
  else {
    uint64_t v22 = v18 + v15 * (v4 ^ 0xFFFF);
  }
  if (v20) {
    uint64_t v23 = v17;
  }
  else {
    uint64_t v23 = v17 + v13 * (v4 ^ 0xFFFF);
  }
  if (v20) {
    uint64_t v24 = v16;
  }
  else {
    uint64_t v24 = v16 + v7 * (v4 ^ 0xFFFF);
  }
  if (v20) {
    uint64_t v21 = v19;
  }
  uint64_t v25 = (v21 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v11)) / v10) & ~((v21 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v11)) / v10) >> 63);
  if (!v10) {
    uint64_t v25 = 0;
  }
  if ((_WORD)a1) {
    uint64_t v21 = v25;
  }
  if (!WORD1(a1))
  {
LABEL_44:
    if (WORD2(a1)) {
      goto LABEL_45;
    }
    goto LABEL_50;
  }
  if (v7)
  {
    uint64_t v26 = (uint64_t)(v6 * (unint64_t)v6 * (v4 - v12)) / v7;
    uint64_t v24 = (v24 - v26) & ~((v24 - v26) >> 63);
    goto LABEL_44;
  }
  uint64_t v24 = 0;
  if (WORD2(a1))
  {
LABEL_45:
    if (v13)
    {
      uint64_t v27 = v23 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v14)) / v13;
      uint64_t v23 = v27 & ~(v27 >> 63);
    }
    else
    {
      uint64_t v23 = 0;
    }
  }
LABEL_50:
  if (v15) {
    uint64_t v28 = (v22 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v5)) / v15) & ~((v22 - (uint64_t)(v6 * (unint64_t)v6 * (v4 - v5)) / v15) >> 63);
  }
  else {
    uint64_t v28 = 0;
  }
  if (!HIWORD(a1)) {
    uint64_t v28 = v22;
  }
  uint64_t v29 = 0xFFFF * (v6 + v4) - v9;
  unint64_t v30 = v21 + 0x8000;
  if (v21 > 4294868992) {
    unint64_t v30 = 4294868992;
  }
  v31.i64[0] = v23;
  v31.i64[1] = v24;
  int v32 = (v30 >> 16) + v30;
  int64x2_t v33 = vdupq_n_s64(0xFFFE8000uLL);
  int8x16_t v34 = (int8x16_t)vcgtq_s64(v31, v33);
  int8x16_t v35 = (int8x16_t)vaddq_s64(v31, vdupq_n_s64(0x8000uLL));
  if (v28 <= 4294868992) {
    unint64_t v36 = v28 + 0x8000;
  }
  else {
    unint64_t v36 = 4294868992;
  }
  unsigned int v37 = (v36 >> 16) + v36;
  if (v29 <= 4294868992) {
    uint64_t v38 = v29 + 0x8000;
  }
  else {
    uint64_t v38 = 4294868992;
  }
  unint64_t v39 = (v38 + (v38 >> 16)) >> 16;
  uint64x2_t v40 = (uint64x2_t)vbslq_s8(v34, (int8x16_t)v33, v35);
  int8x16_t v41 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v39), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v40, v40, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_1850CDCA0), (int8x16_t)xmmword_1850CDCB0);
  return v41.i64[0] | ((unint64_t)(v39 - HIWORD(v37)) << 48) | (unsigned __int16)(v39 - HIWORD(v32)) | v41.i64[1];
}

unint64_t PDAhardlightPDA_11717(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = a2;
  int64_t v5 = a2 - (unint64_t)WORD1(a1);
  int64_t v6 = a2 - (unint64_t)WORD2(a1);
  uint64_t v7 = a2 - HIWORD(a1);
  uint64_t v8 = a4;
  int64_t v9 = a4 - (unint64_t)WORD2(a3);
  uint64_t v10 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    int64_t v11 = a4;
  }
  else {
    int64_t v11 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    unint64_t v12 = a2;
  }
  else {
    unint64_t v12 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  uint64_t v13 = 2 * v12 * v11;
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4) {
    int64_t v14 = a4;
  }
  else {
    int64_t v14 = a4 - (unint64_t)WORD1(a3);
  }
  if (v5 >= a2) {
    int64_t v15 = a2;
  }
  else {
    int64_t v15 = v5;
  }
  uint64_t v16 = 2 * v15 * v14;
  if (v9 >= a4) {
    int64_t v17 = a4;
  }
  else {
    int64_t v17 = v9;
  }
  if (v6 >= a2) {
    int64_t v18 = a2;
  }
  else {
    int64_t v18 = v6;
  }
  uint64_t v19 = 2 * v18 * v17;
  if (v10 >= a4) {
    int64_t v20 = a4;
  }
  else {
    int64_t v20 = v10;
  }
  if (v7 >= a2) {
    uint64_t v21 = a2;
  }
  else {
    uint64_t v21 = v7;
  }
  uint64_t v22 = 2 * v21 * v20;
  unint64_t v23 = a4 * (unint64_t)a2;
  int64_t v24 = ((unint64_t)a4 + 1) >> 1;
  if (v11 <= v24) {
    uint64_t v25 = (a4 ^ 0xFFFFLL) * v12 + v11 * (a2 ^ 0xFFFFLL) + v13;
  }
  else {
    uint64_t v25 = v11 * (a2 + 0xFFFFLL) + (a4 + 0xFFFFLL) * v12 - (v23 + v13);
  }
  uint64_t v26 = a4 ^ 0xFFFFLL;
  uint64_t v27 = v4 ^ 0xFFFF;
  uint64_t v28 = (v8 ^ 0xFFFF) * v15 + v14 * (v4 ^ 0xFFFF) + v16;
  uint64_t v29 = v14 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v15 - (v23 + v16);
  if (v14 > v24) {
    uint64_t v30 = v29;
  }
  else {
    uint64_t v30 = v28;
  }
  uint64_t v31 = v26 * v18 + v17 * v27 + v19;
  uint64_t v32 = v17 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v18 - (v23 + v19);
  if (v17 > v24) {
    uint64_t v33 = v32;
  }
  else {
    uint64_t v33 = v31;
  }
  uint64_t v34 = v26 * v21 + v20 * v27 + v22;
  uint64_t v35 = v20 * (v4 + 0xFFFF) + (v8 + 0xFFFF) * v21 - (v23 + v22);
  if (v20 > v24) {
    uint64_t v36 = v35;
  }
  else {
    uint64_t v36 = v34;
  }
  uint64_t v37 = 0xFFFF * (v8 + v4) - v23;
  unint64_t v38 = v25 + 0x8000;
  if (v25 > 4294868992) {
    unint64_t v38 = 4294868992;
  }
  v39.i64[0] = v33;
  v39.i64[1] = v30;
  int v40 = (v38 >> 16) + v38;
  int64x2_t v41 = vdupq_n_s64(0xFFFE8000uLL);
  int8x16_t v42 = (int8x16_t)vcgtq_s64(v39, v41);
  int8x16_t v43 = (int8x16_t)vaddq_s64(v39, vdupq_n_s64(0x8000uLL));
  if (v36 <= 4294868992) {
    unint64_t v44 = v36 + 0x8000;
  }
  else {
    unint64_t v44 = 4294868992;
  }
  unsigned int v45 = (v44 >> 16) + v44;
  if (v37 <= 4294868992) {
    uint64_t v46 = v37 + 0x8000;
  }
  else {
    uint64_t v46 = 4294868992;
  }
  unint64_t v47 = (v46 + (v46 >> 16)) >> 16;
  uint64x2_t v48 = (uint64x2_t)vbslq_s8(v42, (int8x16_t)v41, v43);
  int8x16_t v49 = vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vsubq_s64(vdupq_n_s64(v47), (int64x2_t)vshrq_n_u64(vsraq_n_u64(v48, v48, 0x10uLL), 0x10uLL)), (uint64x2_t)xmmword_1850CDCA0), (int8x16_t)xmmword_1850CDCB0);
  return v49.i64[0] | ((unint64_t)(v47 - HIWORD(v45)) << 48) | (unsigned __int16)(v47 - HIWORD(v40)) | v49.i64[1];
}

unint64_t PDAsoftlightPDA_11718(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4 = a2 - (unint64_t)WORD1(a1);
  int64_t v5 = a2 - (unint64_t)WORD2(a1);
  uint64_t v6 = a2 - HIWORD(a1);
  int64_t v7 = a4 - (unint64_t)WORD1(a3);
  int64_t v8 = a4 - (unint64_t)WORD2(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    unint64_t v9 = a4;
  }
  else {
    unint64_t v9 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    unint64_t v10 = a2;
  }
  else {
    unint64_t v10 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  uint64_t v11 = a4 - HIWORD(a3);
  if (a2)
  {
    uint64_t v12 = (uint64_t)(v10 * v10 * (2 * v9 - a4)) / a2;
    uint64_t v13 = (2 * v10 * v9 - v12) & ~((uint64_t)(2 * v10 * v9 - v12) >> 63);
    if (v7 >= a4) {
      int64_t v7 = a4;
    }
    if (v4 >= a2) {
      unint64_t v14 = a2;
    }
    else {
      unint64_t v14 = a2 - (unint64_t)WORD1(a1);
    }
    uint64_t v15 = (uint64_t)(v14 * v14 * (2 * v7 - a4)) / a2;
    uint64_t v16 = (2 * v14 * v7 - v15) & ~((uint64_t)(2 * v14 * v7 - v15) >> 63);
    if (v8 >= a4) {
      int64_t v8 = a4;
    }
    if (v5 >= a2) {
      int64_t v5 = a2;
    }
    uint64_t v17 = v5 * v5 * (2 * v8 - a4) / a2;
    uint64_t v18 = (2 * v5 * v8 - v17) & ~((2 * v5 * v8 - v17) >> 63);
    if (v11 >= a4) {
      uint64_t v11 = a4;
    }
    if (v6 >= a2) {
      uint64_t v6 = a2;
    }
    uint64_t v19 = v6 * v6 * (2 * v11 - a4) / a2;
    uint64_t v20 = (2 * v6 * v11 - v19) & ~((2 * v6 * v11 - v19) >> 63);
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v13 = 0;
    uint64_t v16 = 0;
    uint64_t v20 = 0;
    if (v7 >= a4) {
      int64_t v7 = a4;
    }
    if (v4 >= 0) {
      unint64_t v14 = 0;
    }
    else {
      unint64_t v14 = -(uint64_t)WORD1(a1);
    }
    if (v8 >= a4) {
      int64_t v8 = a4;
    }
    if (v5 >= 0) {
      int64_t v5 = 0;
    }
    if (v11 >= a4) {
      uint64_t v11 = a4;
    }
    if (v6 >= 0) {
      uint64_t v6 = 0;
    }
  }
  if (a4 != 0xFFFF)
  {
    v13 += (a4 ^ 0xFFFFLL) * v10;
    v16 += v14 * (a4 ^ 0xFFFFLL);
    v18 += v5 * (a4 ^ 0xFFFFLL);
    v20 += v6 * (a4 ^ 0xFFFFLL);
  }
  if (a2 != 0xFFFF)
  {
    v13 += v9 * (a2 ^ 0xFFFFLL);
    v16 += v7 * (a2 ^ 0xFFFFLL);
    v18 += v8 * (a2 ^ 0xFFFFLL);
    v20 += v11 * (a2 ^ 0xFFFFLL);
  }
  int64_t v21 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  unint64_t v22 = v13 + 0x8000;
  if (v13 > 4294868992) {
    unint64_t v22 = 4294868992;
  }
  int v23 = (v22 >> 16) + v22;
  unint64_t v24 = v16 + 0x8000;
  if (v16 > 4294868992) {
    unint64_t v24 = 4294868992;
  }
  unsigned int v25 = (v24 >> 16) + v24;
  unint64_t v26 = v18 + 0x8000;
  if (v18 > 4294868992) {
    unint64_t v26 = 4294868992;
  }
  int v27 = (v26 >> 16) + v26;
  unint64_t v28 = v20 + 0x8000;
  if (v20 > 4294868992) {
    unint64_t v28 = 4294868992;
  }
  unsigned int v29 = (v28 >> 16) + v28;
  if (v21 <= 4294868992) {
    uint64_t v30 = v21 + 0x8000;
  }
  else {
    uint64_t v30 = 4294868992;
  }
  return ((unint64_t)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v29)) << 48) | ((unint64_t)(unsigned __int16)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v27)) << 32) | ((((v30 + (v30 >> 16)) >> 16) - HIWORD(v25)) << 16) | (unsigned __int16)(((v30 + (v30 >> 16)) >> 16) - HIWORD(v23));
}

unint64_t PDAdifferencePDA_11719(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  int64_t v4 = a2 - (unint64_t)(unsigned __int16)a1;
  int64_t v5 = a2 - (unint64_t)WORD1(a1);
  int64_t v6 = a2 - (unint64_t)WORD2(a1);
  uint64_t v7 = a2 - HIWORD(a1);
  int64_t v8 = a4 - (unint64_t)(unsigned __int16)a3;
  int64_t v9 = a4 - (unint64_t)WORD1(a3);
  int64_t v10 = a4 - (unint64_t)WORD2(a3);
  uint64_t v11 = a4 - HIWORD(a3);
  if (v8 >= a4) {
    int64_t v8 = a4;
  }
  if (v4 >= a2) {
    int64_t v4 = a2;
  }
  int64_t v12 = v8 + v4;
  int64_t v13 = v4 * a4;
  int64_t v14 = v8 * a2;
  int64_t v16 = v13 - v14;
  BOOL v15 = v13 - v14 < 0;
  int64_t v17 = 0xFFFF * v12 - v14 - v13;
  if (v15) {
    int64_t v18 = -v16;
  }
  else {
    int64_t v18 = v16;
  }
  uint64_t v19 = v17 + v18;
  if (v9 >= a4) {
    int64_t v9 = a4;
  }
  if (v5 >= a2) {
    int64_t v5 = a2;
  }
  int64_t v20 = v9 + v5;
  int64_t v21 = v5 * a4;
  int64_t v22 = v9 * a2;
  int64_t v23 = v21 - v22;
  BOOL v15 = v21 - v22 < 0;
  int64_t v24 = 0xFFFF * v20 - v22 - v21;
  if (v15) {
    int64_t v25 = -v23;
  }
  else {
    int64_t v25 = v23;
  }
  uint64_t v26 = v24 + v25;
  if (v10 >= a4) {
    int64_t v27 = a4;
  }
  else {
    int64_t v27 = v10;
  }
  if (v6 >= a2) {
    int64_t v6 = a2;
  }
  int64_t v28 = v27 + v6;
  int64_t v29 = v6 * a4;
  int64_t v30 = v27 * a2;
  int64_t v31 = v29 - v30;
  BOOL v15 = v29 - v30 < 0;
  uint64_t v32 = 0xFFFF * v28 - v30 - v29;
  if (v15) {
    uint64_t v33 = -v31;
  }
  else {
    uint64_t v33 = v31;
  }
  uint64_t v34 = v32 + v33;
  if (v11 >= a4) {
    uint64_t v35 = a4;
  }
  else {
    uint64_t v35 = v11;
  }
  if (v7 >= a2) {
    uint64_t v7 = a2;
  }
  uint64_t v36 = v35 + v7;
  uint64_t v37 = v7 * a4;
  uint64_t v38 = v35 * a2;
  uint64_t v39 = v37 - v38;
  BOOL v15 = v37 - v38 < 0;
  uint64_t v40 = 0xFFFF * v36 - v38 - v37;
  if (v15) {
    uint64_t v41 = -v39;
  }
  else {
    uint64_t v41 = v39;
  }
  uint64_t v42 = v40 + v41;
  int64_t v43 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v19 <= 4294868992) {
    unint64_t v44 = v19 + 0x8000;
  }
  else {
    unint64_t v44 = 4294868992;
  }
  int v45 = (v44 >> 16) + v44;
  if (v26 <= 4294868992) {
    unint64_t v46 = v26 + 0x8000;
  }
  else {
    unint64_t v46 = 4294868992;
  }
  unsigned int v47 = (v46 >> 16) + v46;
  if (v34 <= 4294868992) {
    unint64_t v48 = v34 + 0x8000;
  }
  else {
    unint64_t v48 = 4294868992;
  }
  int v49 = (v48 >> 16) + v48;
  if (v42 <= 4294868992) {
    unint64_t v50 = v42 + 0x8000;
  }
  else {
    unint64_t v50 = 4294868992;
  }
  unsigned int v51 = (v50 >> 16) + v50;
  if (v43 <= 4294868992) {
    uint64_t v52 = v43 + 0x8000;
  }
  else {
    uint64_t v52 = 4294868992;
  }
  return ((unint64_t)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v51)) << 48) | ((unint64_t)(unsigned __int16)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v49)) << 32) | ((((v52 + (v52 >> 16)) >> 16) - HIWORD(v47)) << 16) | (unsigned __int16)(((v52 + (v52 >> 16)) >> 16) - HIWORD(v45));
}

unint64_t PDAexclusionPDA_11720(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  unint64_t v4 = a2;
  int64_t v5 = a2 - (unint64_t)(unsigned __int16)a1;
  int64_t v6 = a2 - (unint64_t)WORD1(a1);
  int64_t v7 = a2 - (unint64_t)WORD2(a1);
  int64_t v8 = a4 - (unint64_t)(unsigned __int16)a3;
  int64_t v9 = a4 - (unint64_t)WORD1(a3);
  if (v8 >= a4) {
    int64_t v8 = a4;
  }
  if (v5 >= a2) {
    int64_t v5 = a2;
  }
  uint64_t v10 = 0xFFFF * (v8 + v5) - 2 * v5 * v8;
  if (v9 >= a4) {
    int64_t v9 = a4;
  }
  if (v6 >= a2) {
    int64_t v6 = a2;
  }
  uint64_t v11 = 0xFFFF * (v9 + v6) - 2 * v6 * v9;
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4) {
    unint64_t v12 = a4;
  }
  else {
    unint64_t v12 = a4 - (unint64_t)WORD2(a3);
  }
  if (v7 >= a2) {
    int64_t v7 = a2;
  }
  uint64_t v13 = 0xFFFF * (v12 + v7) - 2 * v7 * v12;
  if ((uint64_t)(a4 - HIWORD(a3)) >= a4) {
    unint64_t v14 = a4;
  }
  else {
    unint64_t v14 = a4 - HIWORD(a3);
  }
  if ((uint64_t)(a2 - HIWORD(a1)) < a2) {
    unint64_t v4 = a2 - HIWORD(a1);
  }
  uint64_t v15 = 0xFFFF * (v14 + v4) - 2 * v4 * v14;
  int64_t v16 = 0xFFFF * (a4 + (unint64_t)a2) - a4 * (unint64_t)a2;
  if (v10 <= 4294868992) {
    unint64_t v17 = v10 + 0x8000;
  }
  else {
    unint64_t v17 = 4294868992;
  }
  int v18 = (v17 >> 16) + v17;
  if (v11 <= 4294868992) {
    unint64_t v19 = v11 + 0x8000;
  }
  else {
    unint64_t v19 = 4294868992;
  }
  unsigned int v20 = (v19 >> 16) + v19;
  if (v13 <= 4294868992) {
    unint64_t v21 = v13 + 0x8000;
  }
  else {
    unint64_t v21 = 4294868992;
  }
  int v22 = (v21 >> 16) + v21;
  if (v15 <= 4294868992) {
    unint64_t v23 = v15 + 0x8000;
  }
  else {
    unint64_t v23 = 4294868992;
  }
  unsigned int v24 = (v23 >> 16) + v23;
  if (v16 <= 4294868992) {
    uint64_t v25 = v16 + 0x8000;
  }
  else {
    uint64_t v25 = 4294868992;
  }
  return ((unint64_t)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v24)) << 48) | ((unint64_t)(unsigned __int16)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v22)) << 32) | ((((v25 + (v25 >> 16)) >> 16) - HIWORD(v20)) << 16) | (unsigned __int16)(((v25 + (v25 >> 16)) >> 16) - HIWORD(v18));
}

unint64_t PDAhuePDA_11721(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  int64_t v6 = a4 - (unint64_t)WORD1(a3);
  int64_t v7 = a4 - (unint64_t)WORD2(a3);
  uint64_t v8 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  if (v6 >= a4) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = v6;
  }
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = a2 - (unint64_t)WORD1(a1);
  }
  if (v7 >= a4) {
    uint64_t v13 = a4;
  }
  else {
    uint64_t v13 = v7;
  }
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = a2 - (unint64_t)WORD2(a1);
  }
  if (v8 >= a4) {
    uint64_t v8 = a4;
  }
  uint64_t v15 = a2 - HIWORD(a1);
  if (v15 >= a2) {
    uint64_t v15 = a2;
  }
  if (a4 == 0xFFFF)
  {
    uint64_t v19 = 0;
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = (a4 ^ 0xFFFFLL) * v10;
    uint64_t v10 = (v10 * a4 + 0x8000 + ((v10 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v17 = (a4 ^ 0xFFFFLL) * v12;
    uint64_t v12 = (v12 * a4 + 0x8000 + ((v12 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v18 = (a4 ^ 0xFFFFLL) * v14;
    uint64_t v14 = (v14 * a4 + 0x8000 + ((v14 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v19 = (a4 ^ 0xFFFFLL) * v15;
    uint64_t v15 = (v15 * a4 + 0x8000 + ((v15 * a4 + 0x8000) >> 16)) >> 16;
  }
  if (a2 != 0xFFFF)
  {
    v16 += v9 * (a2 ^ 0xFFFFLL);
    uint64_t v9 = (v9 * a2 + 0x8000 + ((v9 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v11 * (a2 ^ 0xFFFFLL);
    uint64_t v11 = (v11 * a2 + 0x8000 + ((v11 * a2 + 0x8000) >> 16)) >> 16;
    v18 += v13 * (a2 ^ 0xFFFFLL);
    uint64_t v13 = (v13 * a2 + 0x8000 + ((v13 * a2 + 0x8000) >> 16)) >> 16;
    v19 += (a2 ^ 0xFFFFLL) * v8;
  }
  uint64_t v51 = v9;
  uint64_t v52 = v11;
  uint64_t v53 = v13;
  uint64_t v20 = v9 < v11;
  uint64_t v21 = v9 >= v11;
  if (v13 >= *(&v51 + v21))
  {
    BOOL v23 = v13 <= *(&v51 + v20);
    uint64_t v22 = v9 >= v11;
    if (v23) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v9 < v11;
    }
    if (!v23) {
      uint64_t v20 = 2;
    }
  }
  else
  {
    uint64_t v22 = 2;
  }
  uint64_t v24 = *(&v51 + v20);
  uint64_t v25 = *(&v51 + v22);
  BOOL v26 = __OFSUB__(v24, v25);
  uint64_t v27 = v24 - v25;
  if ((v27 < 0) ^ v26 | (v27 == 0))
  {
    *(&v51 + v20) = 0;
    *(&v51 + v21) = 0;
  }
  else
  {
    if (v10 >= v12) {
      uint64_t v28 = v12;
    }
    else {
      uint64_t v28 = v10;
    }
    if (v10 <= v12) {
      uint64_t v29 = v12;
    }
    else {
      uint64_t v29 = v10;
    }
    if (v14 <= v29) {
      uint64_t v30 = v29;
    }
    else {
      uint64_t v30 = v14;
    }
    if (v14 >= v28) {
      uint64_t v29 = v30;
    }
    else {
      uint64_t v28 = v14;
    }
    uint64_t v31 = v29 - v28;
    *(&v51 + v20) = v31;
    *(&v51 + v21) = ((*(&v51 + v21) - *(&v51 + v22)) * ((v31 << 16) / v27) + 0x8000) >> 16;
  }
  *(&v51 + v22) = 0;
  uint64_t v32 = 77 * (v10 - v51) + 151 * (v12 - v52) + 28 * (v14 - v53);
  uint64_t v33 = v51 + ((v32 + 128) >> 8);
  uint64_t v34 = v52 + ((v32 + 128) >> 8);
  int64_t v35 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  uint64_t v36 = v53 + ((v32 + 128) >> 8);
  if (v32 != (char)v32)
  {
    if (v51 >= v52) {
      uint64_t v37 = v52 + ((v32 + 128) >> 8);
    }
    else {
      uint64_t v37 = v51 + ((v32 + 128) >> 8);
    }
    if (v51 >= v52) {
      int64_t v38 = v51 + ((v32 + 128) >> 8);
    }
    else {
      int64_t v38 = v52 + ((v32 + 128) >> 8);
    }
    if (v36 <= v38) {
      uint64_t v39 = v38;
    }
    else {
      uint64_t v39 = v53 + ((v32 + 128) >> 8);
    }
    if (v36 >= v37) {
      uint64_t v40 = v37;
    }
    else {
      uint64_t v40 = v53 + ((v32 + 128) >> 8);
    }
    if (v36 >= v37) {
      int64_t v38 = v39;
    }
    if (v38 > v35 || v40 < 0)
    {
      uint64_t v41 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      if (v32 > -129)
      {
        uint64_t v42 = v38 - v41;
        if (v38 == v41) {
          goto LABEL_73;
        }
        uint64_t v43 = v35 - v41;
      }
      else
      {
        uint64_t v42 = v41 - v40;
        if (v41 == v40) {
          goto LABEL_73;
        }
        uint64_t v43 = (77 * v33 + 151 * v34 + 28 * v36 + 128) >> 8;
      }
      uint64_t v44 = (v43 << 16) / v42;
      uint64_t v33 = v41 + ((v44 * (v33 - v41) + 0x8000) >> 16);
      uint64_t v34 = v41 + ((v44 * (v34 - v41) + 0x8000) >> 16);
      uint64_t v36 = v41 + ((v44 * (v36 - v41) + 0x8000) >> 16);
    }
  }
LABEL_73:
  unint64_t v45 = v19 + 0x8000;
  if (v19 > 4294868992) {
    unint64_t v45 = 4294868992;
  }
  if (v18 <= 4294868992) {
    unint64_t v46 = v18 + 0x8000;
  }
  else {
    unint64_t v46 = 4294868992;
  }
  if (v17 <= 4294868992) {
    unint64_t v47 = v17 + 0x8000;
  }
  else {
    unint64_t v47 = 4294868992;
  }
  if (v16 <= 4294868992) {
    unint64_t v48 = v16 + 0x8000;
  }
  else {
    unint64_t v48 = 4294868992;
  }
  int v49 = a4 + a2 - v35;
  return ((unint64_t)(v49 - (v15 + (((v45 >> 16) + v45) >> 16))) << 48) | ((unint64_t)(unsigned __int16)(v49 - (v36 + (((v46 >> 16) + v46) >> 16))) << 32) | ((v49 - (v34 + (((v47 >> 16) + v47) >> 16))) << 16) | (unsigned __int16)(v49 - (v33 + (((v48 >> 16) + v48) >> 16)));
}

unint64_t PDAsaturationPDA_11722(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  int64_t v6 = a4 - (unint64_t)WORD1(a3);
  int64_t v7 = a4 - (unint64_t)WORD2(a3);
  uint64_t v8 = a4 - HIWORD(a3);
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  if (v6 >= a4) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = v6;
  }
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = a2 - (unint64_t)WORD1(a1);
  }
  if (v7 >= a4) {
    uint64_t v13 = a4;
  }
  else {
    uint64_t v13 = v7;
  }
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = a2 - (unint64_t)WORD2(a1);
  }
  if (v8 >= a4) {
    uint64_t v8 = a4;
  }
  uint64_t v15 = a2 - HIWORD(a1);
  if (v15 >= a2) {
    uint64_t v15 = a2;
  }
  if (a4 == 0xFFFF)
  {
    uint64_t v19 = 0;
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v16 = (a4 ^ 0xFFFFLL) * v10;
    uint64_t v10 = (v10 * a4 + 0x8000 + ((v10 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v17 = (a4 ^ 0xFFFFLL) * v12;
    uint64_t v12 = (v12 * a4 + 0x8000 + ((v12 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v18 = (a4 ^ 0xFFFFLL) * v14;
    uint64_t v14 = (v14 * a4 + 0x8000 + ((v14 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v19 = (a4 ^ 0xFFFFLL) * v15;
    uint64_t v15 = (v15 * a4 + 0x8000 + ((v15 * a4 + 0x8000) >> 16)) >> 16;
  }
  if (a2 != 0xFFFF)
  {
    v16 += v9 * (a2 ^ 0xFFFFLL);
    uint64_t v9 = (v9 * a2 + 0x8000 + ((v9 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v11 * (a2 ^ 0xFFFFLL);
    uint64_t v11 = (v11 * a2 + 0x8000 + ((v11 * a2 + 0x8000) >> 16)) >> 16;
    v18 += v13 * (a2 ^ 0xFFFFLL);
    uint64_t v13 = (v13 * a2 + 0x8000 + ((v13 * a2 + 0x8000) >> 16)) >> 16;
    v19 += (a2 ^ 0xFFFFLL) * v8;
  }
  uint64_t v49 = v10;
  uint64_t v50 = v12;
  uint64_t v51 = v14;
  uint64_t v20 = v10 < v12;
  uint64_t v21 = v10 >= v12;
  if (v14 >= *(&v49 + v21))
  {
    uint64_t v22 = v10 >= v12;
    if (v14 <= *(&v49 + v20)) {
      uint64_t v21 = 2;
    }
    else {
      uint64_t v21 = v10 < v12;
    }
    if (v14 > *(&v49 + v20)) {
      uint64_t v20 = 2;
    }
  }
  else
  {
    uint64_t v22 = 2;
  }
  uint64_t v23 = *(&v49 + v20);
  uint64_t v24 = *(&v49 + v22);
  BOOL v25 = __OFSUB__(v23, v24);
  uint64_t v26 = v23 - v24;
  if ((v26 < 0) ^ v25 | (v26 == 0))
  {
    *(&v49 + v20) = 0;
    *(&v49 + v21) = 0;
  }
  else
  {
    if (v9 >= v11) {
      uint64_t v27 = v11;
    }
    else {
      uint64_t v27 = v9;
    }
    if (v9 <= v11) {
      uint64_t v9 = v11;
    }
    if (v13 <= v9) {
      uint64_t v28 = v9;
    }
    else {
      uint64_t v28 = v13;
    }
    if (v13 >= v27)
    {
      uint64_t v13 = v27;
      uint64_t v9 = v28;
    }
    uint64_t v29 = v9 - v13;
    *(&v49 + v20) = v29;
    *(&v49 + v21) = ((*(&v49 + v21) - *(&v49 + v22)) * ((v29 << 16) / v26) + 0x8000) >> 16;
  }
  *(&v49 + v22) = 0;
  uint64_t v30 = 77 * (v10 - v49) + 151 * (v12 - v50) + 28 * (v14 - v51);
  uint64_t v31 = v49 + ((v30 + 128) >> 8);
  uint64_t v32 = v50 + ((v30 + 128) >> 8);
  int64_t v33 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  uint64_t v34 = v51 + ((v30 + 128) >> 8);
  if (v30 != (char)v30)
  {
    if (v49 >= v50) {
      uint64_t v35 = v50 + ((v30 + 128) >> 8);
    }
    else {
      uint64_t v35 = v49 + ((v30 + 128) >> 8);
    }
    if (v49 >= v50) {
      int64_t v36 = v49 + ((v30 + 128) >> 8);
    }
    else {
      int64_t v36 = v50 + ((v30 + 128) >> 8);
    }
    if (v34 <= v36) {
      uint64_t v37 = v36;
    }
    else {
      uint64_t v37 = v51 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      uint64_t v38 = v35;
    }
    else {
      uint64_t v38 = v51 + ((v30 + 128) >> 8);
    }
    if (v34 >= v35) {
      int64_t v36 = v37;
    }
    if (v36 > v33 || v38 < 0)
    {
      uint64_t v39 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      if (v30 > -129)
      {
        uint64_t v40 = v36 - v39;
        if (v36 == v39) {
          goto LABEL_71;
        }
        uint64_t v41 = v33 - v39;
      }
      else
      {
        uint64_t v40 = v39 - v38;
        if (v39 == v38) {
          goto LABEL_71;
        }
        uint64_t v41 = (77 * v31 + 151 * v32 + 28 * v34 + 128) >> 8;
      }
      uint64_t v42 = (v41 << 16) / v40;
      uint64_t v31 = v39 + ((v42 * (v31 - v39) + 0x8000) >> 16);
      uint64_t v32 = v39 + ((v42 * (v32 - v39) + 0x8000) >> 16);
      uint64_t v34 = v39 + ((v42 * (v34 - v39) + 0x8000) >> 16);
    }
  }
LABEL_71:
  unint64_t v43 = v19 + 0x8000;
  if (v19 > 4294868992) {
    unint64_t v43 = 4294868992;
  }
  if (v18 <= 4294868992) {
    unint64_t v44 = v18 + 0x8000;
  }
  else {
    unint64_t v44 = 4294868992;
  }
  if (v17 <= 4294868992) {
    unint64_t v45 = v17 + 0x8000;
  }
  else {
    unint64_t v45 = 4294868992;
  }
  if (v16 <= 4294868992) {
    unint64_t v46 = v16 + 0x8000;
  }
  else {
    unint64_t v46 = 4294868992;
  }
  int v47 = a4 + a2 - v33;
  return ((unint64_t)(v47 - (v15 + (((v43 >> 16) + v43) >> 16))) << 48) | ((unint64_t)(unsigned __int16)(v47 - (v34 + (((v44 >> 16) + v44) >> 16))) << 32) | ((v47 - (v32 + (((v45 >> 16) + v45) >> 16))) << 16) | (unsigned __int16)(v47 - (v31 + (((v46 >> 16) + v46) >> 16)));
}

unint64_t PDAluminosityPDA_11723(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4)
{
  if ((uint64_t)(a4 - (unint64_t)(unsigned __int16)a3) >= a4) {
    uint64_t v6 = a4;
  }
  else {
    uint64_t v6 = a4 - (unint64_t)(unsigned __int16)a3;
  }
  if ((uint64_t)(a2 - (unint64_t)(unsigned __int16)a1) >= a2) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = a2 - (unint64_t)(unsigned __int16)a1;
  }
  if ((uint64_t)(a4 - (unint64_t)WORD1(a3)) >= a4) {
    uint64_t v8 = a4;
  }
  else {
    uint64_t v8 = a4 - (unint64_t)WORD1(a3);
  }
  if ((uint64_t)(a2 - (unint64_t)WORD1(a1)) >= a2) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = a2 - (unint64_t)WORD1(a1);
  }
  if ((uint64_t)(a4 - (unint64_t)WORD2(a3)) >= a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a4 - (unint64_t)WORD2(a3);
  }
  if ((uint64_t)(a2 - (unint64_t)WORD2(a1)) >= a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = a2 - (unint64_t)WORD2(a1);
  }
  uint64_t v12 = a4 - HIWORD(a3);
  if (v12 >= a4) {
    uint64_t v12 = a4;
  }
  if (a4 == 0xFFFF)
  {
    uint64_t v17 = 0;
    uint64_t v16 = 0;
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  else
  {
    if ((uint64_t)(a2 - HIWORD(a1)) >= a2) {
      unint64_t v13 = a2;
    }
    else {
      unint64_t v13 = a2 - HIWORD(a1);
    }
    uint64_t v14 = (a4 ^ 0xFFFFLL) * v7;
    uint64_t v7 = (v7 * a4 + 0x8000 + ((v7 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v15 = (a4 ^ 0xFFFFLL) * v9;
    uint64_t v9 = (v9 * a4 + 0x8000 + ((v9 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v16 = (a4 ^ 0xFFFFLL) * v11;
    uint64_t v11 = (v11 * a4 + 0x8000 + ((v11 * a4 + 0x8000) >> 16)) >> 16;
    uint64_t v17 = (a4 ^ 0xFFFFLL) * v13;
  }
  if (a2 != 0xFFFF)
  {
    v14 += v6 * (a2 ^ 0xFFFFLL);
    uint64_t v6 = (v6 * a2 + 0x8000 + ((v6 * a2 + 0x8000) >> 16)) >> 16;
    v15 += v8 * (a2 ^ 0xFFFFLL);
    uint64_t v8 = (v8 * a2 + 0x8000 + ((v8 * a2 + 0x8000) >> 16)) >> 16;
    v16 += v10 * (a2 ^ 0xFFFFLL);
    uint64_t v10 = (v10 * a2 + 0x8000 + ((v10 * a2 + 0x8000) >> 16)) >> 16;
    v17 += v12 * (a2 ^ 0xFFFFLL);
    uint64_t v12 = (v12 * a2 + 0x8000 + ((v12 * a2 + 0x8000) >> 16)) >> 16;
  }
  uint64_t v18 = 28 * (v10 - v11) + 151 * (v8 - v9) + 77 * (v6 - v7);
  uint64_t v19 = v7 + ((v18 + 128) >> 8);
  uint64_t v20 = v9 + ((v18 + 128) >> 8);
  int64_t v21 = (a4 * (unint64_t)a2 + 0x8000 + ((a4 * (unint64_t)a2 + 0x8000) >> 16)) >> 16;
  uint64_t v22 = v11 + ((v18 + 128) >> 8);
  if (v18 != (char)v18)
  {
    BOOL v23 = v7 < v9;
    if (v7 >= v9) {
      uint64_t v24 = v9 + ((v18 + 128) >> 8);
    }
    else {
      uint64_t v24 = v7 + ((v18 + 128) >> 8);
    }
    if (v23) {
      int64_t v25 = v9 + ((v18 + 128) >> 8);
    }
    else {
      int64_t v25 = v19;
    }
    if (v22 <= v25) {
      int64_t v26 = v25;
    }
    else {
      int64_t v26 = v22;
    }
    if (v22 >= v24) {
      uint64_t v27 = v24;
    }
    else {
      uint64_t v27 = v22;
    }
    if (v22 >= v24) {
      int64_t v25 = v26;
    }
    if (v25 > v21 || v27 < 0)
    {
      uint64_t v28 = (77 * v19 + 151 * v20 + 28 * v22 + 128) >> 8;
      if (v18 > -129)
      {
        uint64_t v29 = v25 - v28;
        if (v25 == v28) {
          goto LABEL_52;
        }
        uint64_t v30 = v21 - v28;
      }
      else
      {
        uint64_t v29 = v28 - v27;
        if (!v29) {
          goto LABEL_52;
        }
        uint64_t v30 = (77 * v19 + 151 * v20 + 28 * v22 + 128) >> 8;
      }
      uint64_t v31 = (v30 << 16) / v29;
      uint64_t v19 = v28 + ((v31 * (v19 - v28) + 0x8000) >> 16);
      uint64_t v20 = v28 + ((v31 * (v20 - v28) + 0x8000) >> 16);
      uint64_t v22 = v28 + ((v31 * (v22 - v28) + 0x8000) >> 16);
    }
  }
LABEL_52:
  int v32 = a4 + a2 - v21;
  unint64_t v33 = v17 + 0x8000;
  if (v17 > 4294868992) {
    unint64_t v33 = 4294868992;
  }
  unsigned int v34 = (v33 >> 16) + v33;
  if (v16 <= 4294868992) {
    unint64_t v35 = v16 + 0x8000;
  }
  else {
    unint64_t v35 = 4294868992;
  }
  int v36 = (v35 >> 16) + v35;
  if (v15 <= 4294868992) {
    unint64_t v37 = v15 + 0x8000;
  }
  else {
    unint64_t v37 = 4294868992;
  }
  unsigned int v38 = (v37 >> 16) + v37;
  if (v14 <= 4294868992) {
    unint64_t v39 = v14 + 0x8000;
  }
  else {
    unint64_t v39 = 4294868992;
  }
  return ((unint64_t)(v32 - (v12 + HIWORD(v34))) << 48) | ((unint64_t)(unsigned __int16)(v32 - (v22 + HIWORD(v36))) << 32) | ((v32 - (v20 + HIWORD(v38))) << 16) | (unsigned __int16)(v32 - (v19 + (((v39 >> 16) + v39) >> 16)));
}

void cmyk64_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4 = *(float *)(a1 + 280);
  float v5 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v4 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  float v7 = *(float *)(a1 + 336);
  float v8 = *(float *)(a1 + 344);
  float v9 = *(float *)(a1 + 304);
  float v10 = *(float *)(a1 + 308);
  int v11 = *(_DWORD *)(a1 + 320);
  int v12 = *(_DWORD *)(a1 + 324);
  uint64_t v15 = a1 + 144;
  unint64_t v13 = *(_DWORD **)(a1 + 144);
  uint64_t v14 = *(void *)(v15 + 8);
  uint64_t v16 = *(uint64_t **)(a1 + 376);
  uint64_t v17 = *(void *)(a1 + 360);
  if (v4 != 0.0)
  {
    for (uint64_t i = (_WORD *)(v14 + 8); ; i += 8)
    {
      int v20 = v11;
      if (v5 >= v9)
      {
        int v20 = v12;
        if (v5 <= v10) {
          int v20 = (int)(float)(v8 * (float)(v5 - v7));
        }
      }
      if ((v20 & 0x80000000) == 0) {
        break;
      }
      int64_t v21 = v16;
      if (v16) {
        goto LABEL_18;
      }
LABEL_19:
      float v5 = v4 + v5;
      *(unsigned char *)unint64_t v13 = (_BYTE)v21;
      unint64_t v13 = (_DWORD *)((char *)v13 + 1);
      if (!--a4) {
        return;
      }
    }
    int64_t v21 = (uint64_t *)(v17 + 10 * v20);
LABEL_18:
    uint64_t v22 = *v21;
    LOWORD(v21) = *((_WORD *)v21 + 4);
    *((void *)i - 1) = v22;
    _WORD *i = (_WORD)v21;
    LOBYTE(v21) = -1;
    goto LABEL_19;
  }
  if (v5 >= v9)
  {
    int v11 = v12;
    if (v5 <= v10) {
      int v11 = (int)(float)(v8 * (float)(v5 - v7));
    }
  }
  if ((v11 & 0x80000000) == 0 || v16)
  {
    BOOL v23 = (uint64_t *)(v17 + 10 * v11);
    if (v11 < 0) {
      uint64_t v24 = v16;
    }
    else {
      uint64_t v24 = v23;
    }
    __int16 v25 = *((_WORD *)v24 + 4);
    uint64_t v26 = *v24;
    int v27 = a4 + 4;
    do
    {
      *(void *)uint64_t v14 = v26;
      *(_WORD *)(v14 + 8) = v25;
      *(void *)(v14 + 16) = v26;
      *(_WORD *)(v14 + 24) = v25;
      *(void *)(v14 + 32) = v26;
      *(_WORD *)(v14 + 40) = v25;
      *(void *)(v14 + 48) = v26;
      v27 -= 4;
      *(_WORD *)(v14 + 56) = v25;
      v14 += 64;
      *v13++ = -1;
    }
    while (v27 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v18 = 4;
    }
    else {
      int v18 = a4;
    }
    bzero(v13, ((a4 - v18 + 3) & 0xFFFFFFFC) + 4);
  }
}