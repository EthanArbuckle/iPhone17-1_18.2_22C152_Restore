BOOL CGColorSpaceUsesITUR_2100TF(CGColorSpaceRef a1)
{
  uint64_t v1;

  if (a1)
  {
    v1 = *((void *)a1 + 3);
    if (*(unsigned char *)(v1 + 16)) {
      LOBYTE(a1) = 1;
    }
    else {
      LOBYTE(a1) = *(unsigned char *)(v1 + 17) != 0;
    }
  }
  return (char)a1;
}

uint64_t CGColorSpaceEqualToColorSpaceIgnoringRange(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (!a1 || !a2) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a2 + 24);
  if (v4 == v5) {
    return 1;
  }
  uint64_t result = 0;
  if (v4 && v5)
  {
    if (*(_DWORD *)(v4 + 24) == *(_DWORD *)(v5 + 24)
      && (v6 = *(uint64_t (**)(uint64_t))(*(void *)(v4 + 112) + 32)) != 0)
    {
      return v6(v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.origin.y + rect.size.height;
}

size_t CGColorSpaceGetNumberOfComponents(size_t space)
{
  if (space) {
    return *(void *)(*(void *)(space + 24) + 48);
  }
  return space;
}

BOOL CGRectIsNull(CGRect rect)
{
  return rect.origin.y == INFINITY || rect.origin.x == INFINITY;
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  if (space) {
    return *(_DWORD *)(*((void *)space + 3) + 28);
  }
  else {
    return -1;
  }
}

BOOL CGColorSpaceIsUncalibrated(BOOL result)
{
  if (result) {
    return *(unsigned char *)(*(void *)(result + 24) + 9) != 0;
  }
  return result;
}

BOOL CGColorSpaceUsesExtendedRange(CGColorSpaceRef space)
{
  if (space) {
    LOBYTE(space) = *(unsigned char *)(*((void *)space + 3) + 13) != 0;
  }
  return (char)space;
}

BOOL CGColorSpaceIsHLGBased(CGColorSpaceRef s)
{
  if (s) {
    LOBYTE(s) = *(unsigned char *)(*((void *)s + 3) + 17) != 0;
  }
  return (char)s;
}

BOOL CGColorSpaceIsPQBased(CGColorSpaceRef s)
{
  if (s) {
    LOBYTE(s) = *(unsigned char *)(*((void *)s + 3) + 16) != 0;
  }
  return (char)s;
}

CGFloat CGRectGetHeight(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.size.height;
}

size_t CGImageGetWidth(size_t image)
{
  if (image) {
    return *(void *)(image + 40);
  }
  return image;
}

void CGColorRelease(CGColorRef color)
{
  if (color) {
    CFRelease(color);
  }
}

void path_finalize(void **a1)
{
}

size_t CGImageGetHeight(size_t image)
{
  if (image) {
    return *(void *)(image + 48);
  }
  return image;
}

BOOL icc_md5_equal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 != 6 || (int v8 = *(_DWORD *)(a2 + 24), v8 != 6)) {
    _CGHandleAssert("icc_get_icc_md5", 69, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "state->type == kCGColorSpaceICCBased", "Colorspace not ICC based. type = %d", a6, a7, a8, v8);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t v10 = *(void *)(a2 + 96);
  if (v9 == v10) {
    return 1;
  }
  uint64_t v12 = *(void *)(v9 + 24);
  uint64_t v11 = *(void *)(v9 + 32);
  uint64_t v14 = *(void *)(v10 + 24);
  uint64_t v13 = *(void *)(v10 + 32);
  return v12 == v14 && v11 == v13;
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  retstr->a = sx;
  retstr->b = 0.0;
  retstr->c = 0.0;
  retstr->d = sy;
  retstr->tx = 0.0;
  retstr->ty = 0.0;
  return result;
}

void CGPathRelease(CGPathRef path)
{
  if (path) {
    CFRelease(path);
  }
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  retstr->a = 1.0;
  retstr->b = 0.0;
  retstr->c = 0.0;
  retstr->d = 1.0;
  retstr->tx = tx;
  retstr->ty = ty;
  return result;
}

void CGImageRelease(CGImageRef image)
{
  if (image) {
    CFRelease(image);
  }
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return rect.origin.x == -8.98846567e307
      && rect.origin.y == -8.98846567e307
      && rect.size.width == 1.79769313e308
      && rect.size.height == 1.79769313e308;
}

CGColorSpaceRef CGColorGetColorSpace(CGColorSpaceRef color)
{
  if (color)
  {
    if (((unint64_t)color & 0x8000000000000000) != 0) {
      return CGTaggedColorGetColorSpace((unint64_t)color, v1, v2, v3, v4, v5, v6, v7);
    }
    else {
      return (CGColorSpaceRef)*((void *)color + 3);
    }
  }
  return color;
}

uint64_t get_parser_font(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void CGContextRelease(CGContextRef c)
{
  if (c) {
    CFRelease(c);
  }
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  double b = t1->b;
  double c = t1->c;
  double d = t1->d;
  double a = t2->a;
  double v7 = t2->b;
  double v8 = t2->c;
  double v9 = t2->d;
  CGFloat v10 = b * v9 + t1->a * v7;
  retstr->double a = b * v8 + t1->a * t2->a;
  retstr->double b = v10;
  retstr->double c = d * v8 + c * a;
  retstr->double d = d * v9 + c * v7;
  double tx = t1->tx;
  double ty = t1->ty;
  double v13 = v8 * ty + tx * a;
  CGFloat v14 = v9 * ty + tx * v7 + t2->ty;
  retstr->double tx = t2->tx + v13;
  retstr->double ty = v14;
  return t1;
}

CGPatternRef CGColorGetPattern(CGColorRef color)
{
  if ((uint64_t)color < 1) {
    return 0;
  }
  else {
    return (CGPatternRef)*((void *)color + 4);
  }
}

uint64_t CGContextDelegateGetInfo(uint64_t result)
{
  if (result) {
    return *(void *)(result + 288);
  }
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.origin.y + rect.size.height * 0.5;
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  if (!color) {
    return 0.0;
  }
  if (((unint64_t)color & 0x8000000000000000) != 0) {
    return CGTaggedColorGetAlpha((unint64_t)color, v1, v2, v3, v4, v5, v6, v7);
  }
  return *((double *)color + *((void *)color + 7) + 7);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  if (rect.origin.x == INFINITY || rect.origin.y == INFINITY) {
    return 1;
  }
  if (rect.size.height == 0.0) {
    return 1;
  }
  return rect.size.width == 0.0;
}

uint64_t CGContextDelegateGetCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t result = get_callback_address(result, a2, (uint64_t)"CGContextDelegateGetCallback", a4, a5, a6, a7, a8);
    if (result) {
      return *(void *)result;
    }
  }
  return result;
}

void *CGContextDelegateSetCallback(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t result = (void *)get_callback_address((uint64_t)result, a2, (uint64_t)"CGContextDelegateSetCallback", a4, a5, a6, a7, a8);
    if (result) {
      *uint64_t result = a3;
    }
  }
  return result;
}

void *CGContextDelegateSetCallbacks(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = a3;
    if (a3)
    {
      uint64_t v9 = (uint64_t)result;
      CGFloat v10 = (uint64_t *)(a2 + 8);
      do
      {
        uint64_t v11 = *v10;
        uint64_t result = (void *)get_callback_address(v9, *((unsigned int *)v10 - 2), (uint64_t)"CGContextDelegateSetCallback", a4, a5, a6, a7, a8);
        if (result) {
          *uint64_t result = v11;
        }
        v10 += 2;
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

uint64_t get_callback_address(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch((int)a2)
  {
    case 0:
      uint64_t result = a1 + 24;
      break;
    case 1:
      uint64_t result = a1 + 32;
      break;
    case 2:
      uint64_t result = a1 + 40;
      break;
    case 3:
      uint64_t result = a1 + 48;
      break;
    case 4:
      uint64_t result = a1 + 56;
      break;
    case 5:
      uint64_t result = a1 + 64;
      break;
    case 6:
      uint64_t result = a1 + 72;
      break;
    case 7:
      uint64_t result = a1 + 80;
      break;
    case 8:
      uint64_t result = a1 + 88;
      break;
    case 9:
      uint64_t result = a1 + 96;
      break;
    case 10:
      uint64_t result = a1 + 128;
      break;
    case 11:
      uint64_t result = a1 + 136;
      break;
    case 12:
      uint64_t result = a1 + 152;
      break;
    case 13:
      uint64_t result = a1 + 160;
      break;
    case 14:
      uint64_t result = a1 + 168;
      break;
    case 15:
      uint64_t result = a1 + 176;
      break;
    case 17:
      uint64_t result = a1 + 192;
      break;
    case 18:
      uint64_t result = a1 + 200;
      break;
    case 19:
      uint64_t result = a1 + 208;
      break;
    case 20:
      uint64_t result = a1 + 216;
      break;
    case 21:
      uint64_t result = a1 + 104;
      break;
    case 22:
      uint64_t result = a1 + 112;
      break;
    case 23:
      uint64_t result = a1 + 144;
      break;
    case 24:
      uint64_t result = a1 + 224;
      break;
    case 25:
      uint64_t result = a1 + 232;
      break;
    case 26:
      uint64_t result = a1 + 240;
      break;
    case 27:
      uint64_t result = a1 + 120;
      break;
    case 28:
      uint64_t result = a1 + 248;
      break;
    case 29:
      uint64_t result = a1 + 256;
      break;
    case 30:
      uint64_t result = a1 + 264;
      break;
    case 31:
      uint64_t result = a1 + 272;
      break;
    default:
      CGPostError((uint64_t)"%s: Unsupported delegate callback: %d.", a2, a3, a4, a5, a6, a7, a8, a3);
      uint64_t result = 0;
      break;
  }
  return result;
}

CGFloat CGRectGetMidX(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.origin.x + rect.size.width * 0.5;
}

uint64_t compare_names(void *a1, void *a2)
{
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL CGImageIsSubimage(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v3 = *(void *)(a1 + 240);
  if (v3)
  {
    if (a2) {
      *a2 = v3;
    }
    if (a3) {
      *a3 = *(_OWORD *)(a1 + 248);
    }
  }
  return v3 != 0;
}

uint64_t CGGStateGetCompositeOperation(uint64_t a1)
{
  return ((__int16)*(_DWORD *)(*(void *)(a1 + 120) + 4) >> 8);
}

uint64_t CGGStateGetStyle(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 120) + 16);
}

CFTypeID CGImageGetTypeID(void)
{
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
  }
  return CGImageGetTypeID_image_type_id;
}

uint64_t strike_key_hash(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t CGFontGetParserFont(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 16) + 96))(*(void *)(result + 112));
  }
  return result;
}

void CGContextFillPath(CGContextRef c)
{
}

double sub_184C0085C(void *a1)
{
  __swift_project_boxed_opaque_existential_1(a1, a1[3]);
  sub_1850C3EF8();
  if (!v1)
  {
    type metadata accessor for CGPoint(0);
    __swift_mutable_project_boxed_opaque_existential_1((uint64_t)v6, v7);
    sub_184C00A5C(&qword_1E8F8B4E0, type metadata accessor for CGPoint);
    sub_1850C3D78();
    double v2 = v5;
    type metadata accessor for CGSize(0);
    __swift_mutable_project_boxed_opaque_existential_1((uint64_t)v6, v7);
    sub_184C00A5C(&qword_1E8F8B4D8, type metadata accessor for CGSize);
    sub_1850C3D78();
    __swift_destroy_boxed_opaque_existential_1((uint64_t)v6);
  }
  __swift_destroy_boxed_opaque_existential_1((uint64_t)a1);
  return v2;
}

void sub_184C00A14(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    ForeignTypeMetadatdouble a = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

uint64_t sub_184C00A5C(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t CGSReleaseRegion(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
  return 0;
}

CGImageRef CGImageRetain(CGImageRef image)
{
  if (image) {
    CFRetain(image);
  }
  return image;
}

void ripc_ContextRestore(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  long long v4 = *(_OWORD *)(a2 + 120);
  long long v5 = *(_OWORD *)(a2 + 136);
  long long v6 = *(_OWORD *)(a2 + 152);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(_OWORD *)(a1 + 152) = v6;
  *(_OWORD *)(a1 + 136) = v5;
  *(_OWORD *)(a1 + 120) = v4;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  uint64_t v7 = *(_DWORD **)(a1 + 56);
  if (v7) {
    ripr_release(v7);
  }
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  uint64_t v8 = *(_DWORD **)(a1 + 64);
  if (v8) {
    ripr_release(v8);
  }
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  uint64_t v9 = *(void *)(a1 + 80);
  if (v9 && *(void *)v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  ripc_ReleaseClipState((void **)(a1 + 72));
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(a2 + 216);
}

void ripr_release(_DWORD *a1)
{
  int v1 = a1[2] - 1;
  a1[2] = v1;
  if (!v1)
  {
    if (*((void *)a1 + 2)) {
      ripr_Finish((uint64_t)a1);
    }
    uint64_t v3 = *((void *)a1 + 3);
    if (v3) {
      (*(void (**)(char *))(v3 + 24))((char *)a1 + 24);
    }
    free(a1);
  }
}

BOOL CGvImage_converter_data_key_is_equal(long long *a1, long long *a2)
{
  long long v40 = *a2;
  long long v41 = *a1;
  long long v38 = a2[1];
  long long v39 = a1[1];
  unint64_t v2 = *((void *)a1 + 14);
  if (v2 != *((void *)a2 + 14)) {
    return 0;
  }
  unint64_t v5 = *((void *)a1 + 15);
  if (v5 != *((void *)a2 + 15)) {
    return 0;
  }
  if ((void)v41 != (void)v40 || *((void *)&v41 + 1) != *((void *)&v40 + 1)) {
    return 0;
  }
  if ((void)v39 != (void)v38 || *((void *)&v39 + 1) != *((void *)&v38 + 1)) {
    return 0;
  }
  BOOL result = 0;
  if (*((_DWORD *)a1 + 8) == *((_DWORD *)a2 + 8)
    && *((_DWORD *)a1 + 9) == *((_DWORD *)a2 + 9)
    && *((_DWORD *)a1 + 16) == *((_DWORD *)a2 + 16)
    && *((_DWORD *)a1 + 12) == *((_DWORD *)a2 + 12))
  {
    int v9 = *((_DWORD *)a1 + 18);
    int v10 = *((_DWORD *)a1 + 19);
    int v11 = *((_DWORD *)a1 + 26);
    int v13 = *((_DWORD *)a2 + 18);
    int v12 = *((_DWORD *)a2 + 19);
    uint64_t v34 = *((void *)a2 + 10);
    uint64_t v35 = *((void *)a1 + 10);
    int v36 = *((_DWORD *)a2 + 22);
    int v37 = *((_DWORD *)a1 + 22);
    int v14 = *((_DWORD *)a2 + 26);
    int v32 = *((unsigned __int8 *)a1 + 641);
    int v33 = *((unsigned __int8 *)a1 + 640);
    int v30 = *((unsigned __int8 *)a2 + 641);
    int v31 = *((unsigned __int8 *)a2 + 640);
    BOOL result = CGColorSpaceEqualToColorSpace(*((void *)a1 + 5), *((void *)a2 + 5));
    if (result)
    {
      BOOL result = 0;
      if (v9 == v13 && v10 == v12 && v11 == v14 && v37 == v36)
      {
        BOOL result = CGColorSpaceEqualToColorSpace(v35, v34);
        if (result)
        {
          if (v2)
          {
            uint64_t v15 = 16;
            do
            {
              double v16 = *((double *)a1 + v15);
              double v17 = *((double *)a2 + v15);
              unint64_t v18 = v15 - 15;
              ++v15;
            }
            while (v16 == v17 && v18 < v2);
            if (v16 != v17) {
              return 0;
            }
          }
          if (v5)
          {
            uint64_t v20 = 48;
            int v22 = v32;
            int v21 = v33;
            int v24 = v30;
            int v23 = v31;
            do
            {
              double v25 = *((double *)a1 + v20);
              double v26 = *((double *)a2 + v20);
              unint64_t v27 = v20 - 47;
              BOOL v28 = v25 == v26;
              ++v20;
            }
            while (v25 == v26 && v27 < v5);
          }
          else
          {
            BOOL v28 = 1;
            int v22 = v32;
            int v21 = v33;
            int v24 = v30;
            int v23 = v31;
          }
          if (v21 != v23) {
            BOOL v28 = 0;
          }
          return v22 == v24 && v28;
        }
      }
    }
  }
  return result;
}

uint64_t color_transform_retain_count(uint64_t a1, atomic_uint *a2)
{
  switch(a1)
  {
    case -1:
      log_refcount((char)a2);
      if (atomic_fetch_add_explicit(a2 + 5, 0xFFFFFFFF, memory_order_relaxed) == 1)
      {
        color_transform_finalize((uint64_t)a2);
        CFAllocatorRef v4 = CFGetAllocator(a2);
        CFAllocatorDeallocate(v4, a2);
      }
      break;
    case 0:
      return a2[5];
    case 1:
      log_refcount((char)a2);
      return atomic_fetch_add_explicit(a2 + 5, 1u, memory_order_relaxed) + 1;
  }
  return 0;
}

void log_refcount(char a1)
{
  if (show_log_predicate != -1) {
    dispatch_once(&show_log_predicate, &__block_literal_global_61);
  }
  if (show_log_show_log)
  {
    int v9 = CGBacktraceCreate(10);
    CGPostError((uint64_t)"CGColorTransform %p. Refcount = %d operation = %ld Backtrace:\n%s\n", v2, v3, v4, v5, v6, v7, v8, a1);
    free(v9);
  }
}

double CGContextDelegateFinalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(const void **)(a1 + 16);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(void (**)(uint64_t))(a1 + 24);
    *(void *)(a1 + 16) = 0;
    if (v3) {
      v3(a1);
    }
    long long v4 = unk_1ED097FC8;
    *(_OWORD *)(a1 + 216) = xmmword_1ED097FB8;
    *(_OWORD *)(a1 + 232) = v4;
    long long v5 = unk_1ED097FE8;
    *(_OWORD *)(a1 + 248) = xmmword_1ED097FD8;
    *(_OWORD *)(a1 + 264) = v5;
    long long v6 = *(_OWORD *)&off_1ED097F88;
    *(_OWORD *)(a1 + 152) = xmmword_1ED097F78;
    *(_OWORD *)(a1 + 168) = v6;
    long long v7 = *(_OWORD *)&off_1ED097FA8;
    *(_OWORD *)(a1 + 184) = xmmword_1ED097F98;
    *(_OWORD *)(a1 + 200) = v7;
    long long v8 = *(_OWORD *)&off_1ED097F48;
    *(_OWORD *)(a1 + 88) = xmmword_1ED097F38;
    *(_OWORD *)(a1 + 104) = v8;
    long long v9 = *(_OWORD *)&off_1ED097F68;
    *(_OWORD *)(a1 + 120) = xmmword_1ED097F58;
    *(_OWORD *)(a1 + 136) = v9;
    long long v10 = *(_OWORD *)&off_1ED097F08;
    *(_OWORD *)(a1 + 24) = gZombieVTable;
    *(_OWORD *)(a1 + 40) = v10;
    double result = *(double *)&xmmword_1ED097F18;
    long long v12 = *(_OWORD *)&off_1ED097F28;
    *(_OWORD *)(a1 + 56) = xmmword_1ED097F18;
    *(_OWORD *)(a1 + 72) = v12;
    *(void *)(a1 + 288) = 0;
  }
  return result;
}

void CG::DisplayListRecorder::~DisplayListRecorder(CG::DisplayListRecorder *this)
{
  CG::DisplayListRecorder::~DisplayListRecorder(this);

  JUMPOUT(0x18532A2A0);
}

{
  const void *v2;
  const void *v3;

  *(void *)this = &unk_1ED0948A8;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
}

void dlRecorder_Finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v8 = *(void *)(a1 + 288)) != 0)
  {
    long long v9 = *(void (**)(void))(*(void *)v8 + 8);
    v9();
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_Finalize");
  }
}

void rip_auto_context_finalize(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 288);
    if (v1)
    {
      uint64_t v2 = *(const void **)(v1 + 88);
      if (v2) {
        CFRelease(v2);
      }
      uint64_t v3 = *(const void **)(v1 + 72);
      if (v3) {
        CFRelease(v3);
      }
      long long v4 = *(const void **)(v1 + 80);
      if (v4) {
        CFRelease(v4);
      }
      CGColorSpaceRelease(*(CGColorSpaceRef *)(v1 + 240));
      *(void *)(v1 + 248) = 0;
      *(_OWORD *)(v1 + 232) = 0u;
      *(_OWORD *)(v1 + 216) = 0u;
      *(_OWORD *)(v1 + 200) = 0u;
      *(_OWORD *)(v1 + 184) = 0u;
      long long v5 = *(const void **)(v1 + 176);
      if (v5) {
        CFRelease(v5);
      }
      pthread_mutex_destroy((pthread_mutex_t *)(v1 + 112));
      rip_auto_context_release_buffer_provider(v1, v6, v7, v8, v9, v10, v11, v12);
      int v13 = *(const void **)(v1 + 264);
      if (v13) {
        CFRelease(v13);
      }
      int v14 = *(const void **)(v1 + 288);
      if (v14) {
        CFRelease(v14);
      }
      free((void *)v1);
    }
  }
}

void rip_auto_context_release_buffer_provider(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(const void **)(a1 + 256);
  if (v8)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (v10)
    {
      uint64_t v11 = *(void (**)(uint64_t, const void *, unint64_t, unint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(v10 + 16);
      unint64_t v12 = *(unsigned int *)(a1 + 108) | ((unint64_t)*(unsigned __int8 *)(a1 + 104) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 105) << 40);
      unint64_t v13 = (unint64_t)*(unsigned int *)(a1 + 100) << 32;
      long long v14 = *(_OWORD *)(a1 + 200);
      long long v15 = *(_OWORD *)(a1 + 232);
      v16[2] = *(_OWORD *)(a1 + 216);
      v16[3] = v15;
      uint64_t v17 = *(void *)(a1 + 248);
      v16[0] = *(_OWORD *)(a1 + 184);
      v16[1] = v14;
      v11(v10, v8, v13, v12, v16, a6, a7, a8);
    }
    else
    {
      CFRelease(v8);
    }
    *(void *)(a1 + 256) = 0;
  }
}

void context_reclaim(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v9 = *(const void **)(a1 + 40);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(a1 + 40) = 0;
      }
      uint64_t v10 = *(void (**)(uint64_t))(a1 + 48);
      if (v10)
      {
        v10(a1);
        *(void *)(a1 + 48) = 0;
      }
      return;
    }
    uint64_t v11 = a1;
  }
  else
  {
    uint64_t v11 = 0;
  }

  handle_invalid_context((char)"context_reclaim", v11, a3, a4, a5, a6, a7, a8);
}

void bitmap_context_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108) {
      CGBitmapContextInfoRelease(*(void *)(a1 + 32));
    }
    else {
      handle_invalid_context((char)"bitmap_context_finalize", a1, a3, a4, a5, a6, a7, a8);
    }
  }
}

void automatic_bitmap_context_info_release(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("automatic_bitmap_context_info_release", 22, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/API/CGAutomaticBitmapContext.c", "info", "info is NULL", a6, a7, a8, v10);
  }
  _Block_release(*(const void **)(a1 + 32));
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));
  _Block_release(*(const void **)(a1 + 56));
  uint64_t v9 = *(const void **)(a1 + 64);
  if (v9) {
    CFRelease(v9);
  }

  free((void *)a1);
}

void automatic_bitmap_context_context_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108) {
      automatic_bitmap_context_info_release(*(void *)(a1 + 32), a1, a3, a4, a5, a6, a7, a8);
    }
    else {
      handle_invalid_context((char)"automatic_bitmap_context_context_finalize", a1, a3, a4, a5, a6, a7, a8);
    }
  }
}

void font_finalize(uint64_t a1)
{
  if (*(void *)(a1 + 112))
  {
    if (CGFontCacheGetLocalCache_predicate != -1) {
      dispatch_once(&CGFontCacheGetLocalCache_predicate, &__block_literal_global_6537);
    }
    CGFontCacheRemoveFont(CGFontCacheGetLocalCache_local_font_cache, a1);
    (*(void (**)(void))(*(void *)(a1 + 16) + 88))(*(void *)(a1 + 112));
  }
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
  CGFontAutohinterRelease(*(char **)(a1 + 64));
  CGFontUnimapRelease(*(char ***)(a1 + 72));
  CGFontNameTableRelease(*(void *)(a1 + 80));
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 88));
  uint64_t v2 = *(void *)(a1 + 96);

  CGCIDInfoRelease(v2);
}

void CGFontNameTableRelease(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)v2[1];
        free(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      do
      {
        free(*(void **)v4);
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4);
      long long v5 = *(void **)(a1 + 16);
      if (v5)
      {
        do
        {
          uint64_t v6 = (void *)v5[1];
          free(v5);
          long long v5 = v6;
        }
        while (v6);
      }
    }
    uint64_t v7 = *(const void **)(a1 + 56);
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v8 = *(const void **)(a1 + 72);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = *(const void **)(a1 + 40);
    if (v9) {
      CFRelease(v9);
    }
    free(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

void xt_font_release(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_ullong *volatile)a1, 0xFFFFFFFFFFFFFFFFLL, memory_order_release) == 1)
  {
    __dmb(9u);
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2)
    {
      uint64_t v3 = *(const void **)(v2 + 80);
      if (v3) {
        CFRelease(v3);
      }
      pthread_mutex_destroy((pthread_mutex_t *)(v2 + 8));
      free((void *)v2);
    }
    CGFontIndexMapRelease(*(char **)(a1 + 16));
    FPFontRelease();
    free((void *)a1);
  }
}

void CGFontUnimapRelease(char **a1)
{
  if (a1)
  {
    CGFontIndexMapRelease(a1[2]);
    free(a1);
  }
}

void CGFontIndexMapRelease(char *a1)
{
  if ((unint64_t)(a1 + 1) >= 2)
  {
    for (uint64_t i = 8; i != 520; i += 8)
      free((void *)atomic_load_explicit((atomic_ullong *volatile)&a1[i], memory_order_acquire));
    free(a1);
  }
}

void CGFontCacheRemoveFont(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  uint64_t v6 = (void *)(a1 + 40);
  for (uint64_t i = *(void **)(a1 + 40); i; uint64_t i = (void *)i[1])
  {
    while (1)
    {
      uint64_t v7 = (void *)*i;
      uint64_t v8 = *i ? (_DWORD *)(*i + 8) : 0;
      if (a2)
      {
        int v9 = *(_DWORD *)(a2 + 24);
        if (!v9)
        {
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a2 + 24), (unsigned int *)&v9, ~atomic_fetch_add_explicit(get_identifier_identifier, 1u, memory_order_relaxed), memory_order_relaxed, memory_order_relaxed);
          int v9 = *(_DWORD *)(a2 + 24);
        }
      }
      else
      {
        int v9 = 0;
      }
      if (v9 != *v8) {
        break;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v8);
      CGFontStrikeRelease(v7);
      *uint64_t v6 = i[1];
      free(i);
      uint64_t i = (void *)*v6;
      if (!*v6) {
        goto LABEL_13;
      }
    }
    uint64_t v6 = i + 1;
  }
LABEL_13:

  os_unfair_lock_unlock(v4);
}

void CGFontAutohinterRelease(char *a1)
{
  if (a1)
  {
    for (uint64_t i = 0; i != 96; i += 8)
    {
      uint64_t v3 = *(void **)&a1[i + 8];
      if (v3 && atomic_fetch_add_explicit((atomic_uint *volatile)v3, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        free(v3);
      }
      uint64_t v4 = *(void **)&a1[i + 104];
      if (v4 && atomic_fetch_add_explicit((atomic_uint *volatile)v4, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        free(v4);
      }
    }
    free(a1);
  }
}

uint64_t __send_analytics_event_block_invoke_2()
{
  v0 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "bundleIdentifier");
  _block_invoke_appIdentifier = (uint64_t)v0;
  if (v0)
  {
    uint64_t v1 = v0;
    id v2 = v0;
    if (([v1 hasPrefix:@"com.apple"] & 1) == 0)
    {
      unsigned int v3 = time(0);
      srandom(v3);
      if ((float)((float)rand() * 4.6566e-10) > 0.005) {
        send_analytics_event_sSendAnalytics = 1;
      }
    }
  }
  else
  {
    _block_invoke_appIdentifier = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28F80], "processInfo"), "processName");
    id v4 = (id)_block_invoke_appIdentifier;
  }
  int v5 = 0;
  for (uint32_t i = 0; ; ++i)
  {
    uint64_t result = _dyld_image_count();
    if (i >= result || v5 >= 3) {
      break;
    }
    image_header = _dyld_get_image_header(i);
    image_name = _dyld_get_image_name(i);
    BOOL v10 = string_ends_with(image_name, "PDFKit");
    uint64_t v11 = &_block_invoke_pdfKit_uuid;
    if (!v10)
    {
      BOOL v12 = string_ends_with(image_name, "AppKit");
      uint64_t v11 = &_block_invoke_appKit_uuid;
      if (!v12)
      {
        BOOL v13 = string_ends_with(image_name, "CoreUI");
        uint64_t v11 = &_block_invoke_coreUI_uuid;
        if (!v13) {
          continue;
        }
      }
    }
    uint32_t ncmds = image_header->ncmds;
    if (ncmds)
    {
      if (image_header->magic == -805638658 || image_header->magic == -17958193) {
        uint64_t v16 = 32;
      }
      else {
        uint64_t v16 = 28;
      }
      uint64_t v17 = (char *)image_header + v16;
      while (*(_DWORD *)v17 != 27)
      {
        v17 += *((unsigned int *)v17 + 1);
        if (!--ncmds) {
          goto LABEL_24;
        }
      }
      *uint64_t v11 = *(_OWORD *)(v17 + 8);
    }
LABEL_24:
    ++v5;
  }
  return result;
}

BOOL string_ends_with(const char *a1, char *__s)
{
  BOOL result = 0;
  if (a1)
  {
    if (__s)
    {
      size_t v5 = strlen(__s);
      size_t v6 = strlen(a1);
      return strncmp(&a1[v6 - v5], __s, v5) == 0;
    }
  }
  return result;
}

const char **__img_globals_block_invoke()
{
  for (uint64_t i = 0; i != 39; ++i)
  {
    BOOL result = (const char **)&_block_invoke_matte_additive;
    switch((int)i)
    {
      case 0:
        id v2 = "AAAAAAAA";
        goto LABEL_42;
      case 1:
        id v2 = "WWWWWWWW";
        goto LABEL_42;
      case 2:
        id v2 = "-RRRRRGGGGGBBBBB";
        goto LABEL_42;
      case 3:
        id v2 = "-rrrrrgggggbbbbb";
        goto LABEL_42;
      case 4:
        id v2 = "RRRRRRRRGGGGGGGGBBBBBBBB";
        goto LABEL_42;
      case 5:
        id v2 = "RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA";
        goto LABEL_42;
      case 6:
        id v2 = "rrrrrrrrggggggggbbbbbbbbaaaaaaaa";
        goto LABEL_42;
      case 7:
        id v2 = "AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB";
        goto LABEL_42;
      case 8:
        id v2 = "aaaaaaaarrrrrrrrggggggggbbbbbbbb";
        goto LABEL_42;
      case 9:
        id v2 = "CCCCCCCCMMMMMMMMYYYYYYYYKKKKKKKK";
        goto LABEL_42;
      case 10:
        id v2 = "ccccccccmmmmmmmmyyyyyyyykkkkkkkk";
        goto LABEL_42;
      case 11:
        id v2 = "WWWWWWWWWWWWWWWW";
        goto LABEL_42;
      case 12:
        id v2 = "wwwwwwwwwwwwwwww";
        goto LABEL_42;
      case 13:
        id v2 = "RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBB";
        goto LABEL_42;
      case 14:
        id v2 = "rrrrrrrrrrrrrrrrggggggggggggggggbbbbbbbbbbbbbbbb";
        goto LABEL_42;
      case 15:
        id v2 = "RRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAA";
        goto LABEL_42;
      case 16:
        id v2 = "rrrrrrrrrrrrrrrrggggggggggggggggbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaa";
        goto LABEL_42;
      case 17:
        id v2 = "CCCCCCCCCCCCCCCCMMMMMMMMMMMMMMMMYYYYYYYYYYYYYYYYKKKKKKKKKKKKKKKK";
        goto LABEL_42;
      case 18:
        id v2 = "ccccccccccccccccmmmmmmmmmmmmmmmmyyyyyyyyyyyyyyyykkkkkkkkkkkkkkkk";
        goto LABEL_42;
      case 19:
        id v2 = "RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB";
        goto LABEL_42;
      case 20:
        id v2 = "rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrggggggggggggggggggggggggggggggggbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
        goto LABEL_42;
      case 21:
        id v2 = "RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAA"
             "AAAAAAAAAAAAAAAAAAAAA";
        goto LABEL_42;
      case 22:
        id v2 = "rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrggggggggggggggggggggggggggggggggbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaa"
             "aaaaaaaaaaaaaaaaaaaaa";
        goto LABEL_42;
      case 23:
        id v2 = "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW";
        goto LABEL_42;
      case 24:
        id v2 = "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww";
        goto LABEL_42;
      case 25:
        id v2 = "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYKKKKKKKKKKK"
             "KKKKKKKKKKKKKKKKKKKKK";
        goto LABEL_42;
      case 26:
        id v2 = "ccccccccccccccccccccccccccccccccmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyykkkkkkkkkkk"
             "kkkkkkkkkkkkkkkkkkkkk";
        goto LABEL_42;
      case 27:
        break;
      case 28:
        BOOL result = (const char **)&_block_invoke_matte_lab;
        break;
      case 29:
        id v2 = "_Wf16_";
        goto LABEL_42;
      case 30:
        id v2 = "_WF16_";
        goto LABEL_42;
      case 31:
        id v2 = "_RGBf16_";
        goto LABEL_42;
      case 32:
        id v2 = "_RGBF16_";
        goto LABEL_42;
      case 33:
        id v2 = "_RGBAf16_";
        goto LABEL_42;
      case 34:
        id v2 = "_RGBAF16_";
        goto LABEL_42;
      case 35:
        id v2 = "_CMYKf16_";
        goto LABEL_42;
      case 36:
        id v2 = "_CMYKF16_";
        goto LABEL_42;
      case 37:
        id v2 = "_GRAYA8_";
        goto LABEL_42;
      case 38:
        id v2 = "_CIF10_";
LABEL_42:
        BOOL result = CGBlt_depth(v2);
        break;
      default:
        BOOL result = 0;
        break;
    }
    img_globals_globals[i] = (uint64_t)result;
  }
  return result;
}

const char **CGBlt_depth(char *__s2)
{
  if (!__s2) {
    return 0;
  }
  uint64_t v2 = 0;
  while (1)
  {
    unsigned int v3 = *(const char ***)((char *)&blt_depth + v2);
    if (has_matching_encoding(v3[1], __s2)) {
      break;
    }
    v2 += 8;
    if (v2 == 216)
    {
      uint64_t v4 = 0;
      while (1)
      {
        unsigned int v3 = (const char **)((char *)&blt_image_depth + v4);
        if (has_matching_encoding(*(const char **)((char *)&blt_image_depth + v4 + 8), __s2)) {
          break;
        }
        v4 += 72;
        if (v4 == 864) {
          return 0;
        }
      }
      return v3;
    }
  }
  return v3;
}

const char *has_matching_encoding(const char *result, char *__s2)
{
  if (result)
  {
    uint64_t v2 = result;
    BOOL result = *(const char **)result;
    if (result)
    {
      uint64_t v4 = (const char **)(v2 + 8);
      do
      {
        int v5 = strcmp(result, __s2);
        BOOL result = (const char *)(v5 == 0);
        if (!v5) {
          break;
        }
        size_t v6 = *v4++;
        BOOL result = v6;
      }
      while (v6);
    }
  }
  return result;
}

CFTypeRef CGFontNameTableCopyLocales(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFArrayRef explicit = (CFArrayRef)atomic_load_explicit((atomic_ullong *volatile)(a1 + 40), memory_order_acquire);
  if (!explicit)
  {
    for (uint64_t i = *(unsigned __int16 **)(a1 + 24); i; uint64_t i = (unsigned __int16 *)*((void *)i + 1))
    {
      CFTypeRef locale = create_locale(a1, **(unsigned __int16 **)i, *(unsigned __int16 *)(*(void *)i + 4));
      while (1)
      {
        size_t v6 = locale;
        if (!get_dictionary_for_locale(a1, locale)) {
          break;
        }
        CFTypeRef locale = CGCreateContainingLocaleForLocale(locale);
        if (v6) {
          CFRelease(v6);
        }
      }
      if (locale) {
        CFRelease(locale);
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 56));
    uint64_t v8 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 56), v8, 0);
    CFArrayRef explicit = CFArrayCreate(0, v8, Count, MEMORY[0x1E4F1D510]);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
    free(v8);
    if (explicit)
    {
      CFArrayRef v9 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 40), (unint64_t *)&v9, (unint64_t)explicit);
      if (v9)
      {
        CFRelease(explicit);
        CFArrayRef explicit = v9;
      }
      goto LABEL_3;
    }
    return 0;
  }
LABEL_3:

  return CFRetain(explicit);
}

const void *get_dictionary_for_locale(uint64_t a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  Value = 0;
  if (a2 && *(void *)(a1 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
    if (!Value)
    {
      Value = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E4F1D540]);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), a2, Value);
      CFRelease(Value);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 48));
  }
  return Value;
}

CFTypeRef CGCreateContainingLocaleForLocale(const void *a1)
{
  if (!a1) {
    return 0;
  }
  if (get_locale_mapping_predicate != -1) {
    dispatch_once(&get_locale_mapping_predicate, &__block_literal_global_479);
  }
  CFDictionaryRef v2 = (const __CFDictionary *)get_locale_mapping_locale_mapping;
  pthread_mutex_lock(&CGCreateContainingLocaleForLocale_mutex);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v2, a1);
  if (!Value)
  {
    CFStringRef v5 = (const __CFString *)CFLocaleGetValue((CFLocaleRef)a1, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
    CFStringRef Value = v5;
    if (v5)
    {
      CFTypeID v6 = CFGetTypeID(v5);
      if (v6 == CFStringGetTypeID())
      {
        CFLocaleRef v7 = CFLocaleCreate(0, Value);
        CFStringRef Value = (const __CFString *)v7;
        if (v7)
        {
          if (CFEqual(v7, a1))
          {
            CFRelease(Value);
            CFLocaleRef System = CFLocaleGetSystem();
            CFStringRef Value = (const __CFString *)CFRetain(System);
          }
          CFDictionarySetValue(v2, a1, Value);
          CFRelease(Value);
        }
      }
      else
      {
        CFStringRef Value = 0;
      }
    }
  }
  pthread_mutex_unlock(&CGCreateContainingLocaleForLocale_mutex);
  if (!Value || Value == (const __CFString *)*MEMORY[0x1E4F1D260]) {
    return 0;
  }

  return CFRetain(Value);
}

CFTypeRef create_locale(uint64_t a1, unsigned int a2, uint32_t a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  CFTypeID v6 = (const void *)(a2 | ((unint64_t)a3 << 16));
  CFLocaleRef v7 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), v6);
  if (!Value)
  {
    if (a2)
    {
      if (a2 == 1)
      {
        uint64_t v14 = 0;
        long long v15 = &byte_1850CED60;
        while (*(v15 - 4) != a3)
        {
          ++v14;
          v15 += 10;
          if (v14 == 119) {
            goto LABEL_42;
          }
        }
        cStr[0] = 0;
        if (*((unsigned char *)&locale_to_language + 10 * v14 + 1))
        {
          uint64_t v17 = 0;
          unint64_t v18 = v15 - 3;
          while (cStr[v17++])
            ;
          uint64_t v20 = -1;
          while (1)
          {
            int v21 = *v18++;
            cStr[v17 + v20] = v21;
            if (!v21) {
              break;
            }
            if (++v20 == 2)
            {
              cStr[v17 + 2] = 0;
              break;
            }
          }
        }
        if (*((unsigned char *)&locale_to_language + 10 * v14 + 4))
        {
          uint64_t v22 = 0;
          do
            uint64_t v23 = v22;
          while (cStr[v22++]);
          uint64_t v25 = 0;
          cStr[v23] = 95;
          while (1)
          {
            int v26 = *v15++;
            cStr[v25 + v22] = v26;
            if (!v26) {
              break;
            }
            if (++v25 == 4)
            {
              cStr[v22 + 4] = 0;
              break;
            }
          }
        }
        unint64_t v27 = (char *)&locale_to_language + 10 * v14;
        int v29 = v27[8];
        BOOL v28 = v27 + 8;
        if (v29)
        {
          uint64_t v30 = 0;
          do
            uint64_t v31 = v30;
          while (cStr[v30++]);
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          cStr[v31] = 95;
          while (1)
          {
            int v35 = v28[v34];
            cStr[v33 + v30] = v35;
            if (!v35) {
              break;
            }
            ++v33;
            uint64_t v34 = 1;
            if (v33 == 2)
            {
              cStr[v30 + v33] = 0;
              break;
            }
          }
        }
        CFStringRef v36 = CFStringCreateWithCStringNoCopy(0, cStr, 0x600u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
        if (!v36) {
          goto LABEL_42;
        }
        CFLocaleRef v12 = (CFLocaleRef)v36;
        BOOL v13 = CFLocaleCreate(0, v36);
      }
      else
      {
        if (a2 != 3) {
          goto LABEL_42;
        }
        CFStringRef LocaleIdentifierFromWindowsLocaleCode = CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(0, a3);
        if (!LocaleIdentifierFromWindowsLocaleCode) {
          goto LABEL_42;
        }
        CFStringRef v11 = LocaleIdentifierFromWindowsLocaleCode;
        CFLocaleRef v12 = CFLocaleCreate(0, LocaleIdentifierFromWindowsLocaleCode);
        CFRelease(v11);
        if (!v12) {
          goto LABEL_42;
        }
        BOOL v13 = (void *)CGCreateCanonicalLanguageLocale();
      }
      CFStringRef Value = v13;
      CFRelease(v12);
      if (Value) {
        goto LABEL_41;
      }
    }
    else
    {
      CFLocaleRef System = CFLocaleGetSystem();
      CFStringRef Value = CFRetain(System);
      if (Value)
      {
LABEL_41:
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), v6, Value);
        CFRelease(Value);
        goto LABEL_2;
      }
    }
LABEL_42:
    os_unfair_lock_unlock(v7);
    return 0;
  }
LABEL_2:
  os_unfair_lock_unlock(v7);

  return CFRetain(Value);
}

uint64_t get_chunks_direct(void *a1, int64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6)
{
  check_same_thread();
  uint64_t v16 = (void *)*a1;
  if (!*(void *)(*a1 + 96) && !v16[14] && !v16[10]) {
    _CGHandleAssert("get_chunks_direct", 173, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGAccessSession.c", "CGDataProviderCanGetBytesAtPosition(provider)", "data provider provides no callback to read data at a position", v13, v14, v15, v24);
  }
  unint64_t v17 = v16[4];
  if (v17 == -1) {
    _CGHandleAssert("get_chunks_direct", 177, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGAccessSession.c", "provider_size != (-1UL)", "invalid provider size", v13, v14, v15, v24);
  }
  uint64_t v18 = 0;
  if ((a2 & 0x8000000000000000) == 0)
  {
    uint64_t v25 = a1[2];
    if ((v25 & 0x8000000000000000) == 0)
    {
      if (a4)
      {
        uint64_t v18 = 0;
        uint64_t v19 = a1[2];
        int64_t v20 = a2;
        do
        {
          if (v19 + v20 > (uint64_t)v17)
          {
            int64_t v20 = v17 - v19;
            if ((uint64_t)(v17 - v19) < 1) {
              break;
            }
          }
          if (v20 >= a2) {
            int64_t v20 = a2;
          }
          uint64_t v21 = a1[1];
          if (v21)
          {
            memmove(a5, (const void *)(v21 + v19), v20);
            size_t BytesAtPositionInternal = v20;
          }
          else
          {
            size_t BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v16, a5, v19, v20, v12, v13, v14, v15);
            if (!BytesAtPositionInternal) {
              return v18;
            }
          }
          v18 += BytesAtPositionInternal;
          uint64_t v19 = v20 + a3 + a1[2];
          a1[2] = v19;
          if (v19 < 0 || v19 > v17)
          {
            a1[2] = v17;
            if (v18 + v25 > v17) {
              return v17 - v25;
            }
            return v18;
          }
          a5 += a2 + a6;
          --a4;
        }
        while (a4);
      }
    }
  }
  return v18;
}

size_t CGDataProviderDirectGetBytesAtPositionInternal(void *a1, char *a2, uint64_t a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 0) {
    _CGHandleAssert("CGDataProviderDirectGetBytesAtPositionInternal", 684, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "pos >= 0", "position (%lld) may not be negative", a6, a7, a8, a3);
  }
  size_t v9 = a4;
  if (a4)
  {
    if (!a1 || (int64_t v11 = a1[4], v11 == -1)) {
      _CGHandleAssert("CGDataProviderDirectGetBytesAtPositionInternal", 688, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "size != (-1)", "size overflow", a6, a7, a8, v27);
    }
    uint64_t v13 = CGDataProviderRetainBytePtr((uint64_t)a1);
    if (v13)
    {
      if ((uint64_t)(v9 + a3) > v11) {
        size_t v9 = (v11 - a3) & ~((v11 - a3) >> 63);
      }
      if (v9)
      {
        unint64_t v17 = (const UInt8 *(__cdecl *)(CFDataRef))a1[10];
        uint64_t v18 = "CGDataProviderDirectGetBytesAtPositionInternal calling provider created with getBytePtr callback";
        if (v17 == getCFDataBytePointer) {
          uint64_t v18 = "CGDataProviderDirectGetBytesAtPositionInternal calling provider created with CFData";
        }
        if ((char *)v17 == (char *)data_get_byte_pointer) {
          uint64_t v19 = "CGDataProviderDirectGetBytesAtPositionInternal calling provider created with data";
        }
        else {
          uint64_t v19 = v18;
        }
        qword_1EB288DD0 = (uint64_t)v19;
        memcpy(a2, (const void *)(v13 + a3), v9);
        qword_1EB288DD0 = 0;
      }
    }
    else
    {
      if (!a1[12] && !a1[14]) {
        goto LABEL_31;
      }
      int64_t v20 = a1[4];
      if (v20 == -1) {
        _CGHandleAssert("provider_get_bytes_at_position", 642, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider->size != (off_t)(-1)", "provider size too large", v14, v15, v16, v27);
      }
      uint64_t v21 = (uint64_t)(v9 + a3) <= v20 ? v9 : v20 - a3;
      if (v21 >= 1)
      {
        size_t v22 = 0;
        do
        {
          size_t v9 = v22;
          if (!v21) {
            break;
          }
          uint64_t v23 = (uint64_t (*)(void, char *, size_t, uint64_t))a1[12];
          if (!v23)
          {
            uint64_t v23 = (uint64_t (*)(void, char *, size_t, uint64_t))a1[14];
            if (!v23) {
              break;
            }
          }
          unint64_t v24 = v23(a1[3], &a2[v9], v9 + a3, v21);
          unint64_t v25 = v24 >= v21 ? v21 : v24;
          v21 -= v25;
          size_t v22 = v25 + v9;
        }
        while (v24);
      }
      else
      {
LABEL_31:
        size_t v9 = 0;
      }
    }
    CGDataProviderReleaseBytePtr((uint64_t)a1);
  }
  return v9;
}

uint64_t CGDataProviderRetainBytePtr(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 80) && (CGDataProviderIsZombie((_DWORD *)result) & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 184));
      if (!atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 248), 1u, memory_order_relaxed))
      {
        uint64_t v2 = (*(uint64_t (**)(void))(v1 + 80))(*(void *)(v1 + 24));
        *(void *)(v1 + 264) = v2;
        if (v2)
        {
          uint64_t v4 = 0;
          DebugString = CGDataProviderGetDebugString(v1);
          if (DebugString)
          {
            asprintf(&v4, "CGDataProvider: %p\n%s\n", (const void *)v1, DebugString);
            qword_1EB288DD0 = (uint64_t)v4;
            ERROR_CGDataProvider_BufferIsNotReadable();
            ERROR_CGDataProvider_BufferIsNotBigEnough();
            qword_1EB288DD0 = 0;
            free(v4);
          }
          else
          {
            ERROR_CGDataProvider_BufferIsNotReadable();
            ERROR_CGDataProvider_BufferIsNotBigEnough();
          }
        }
        else
        {
          atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 248), 0xFFFFFFFF, memory_order_relaxed);
        }
      }
      if (*(void *)(v1 + 264)) {
        CFRetain((CFTypeRef)v1);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 184));
      return *(void *)(v1 + 264);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CGDataProviderReleaseBytePtr(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 80) && *(void *)(a1 + 264))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 184));
    if (atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 248), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      uint64_t v2 = *(void (**)(void, void))(a1 + 88);
      if (v2) {
        v2(*(void *)(a1 + 24), *(void *)(a1 + 264));
      }
      *(void *)(a1 + 264) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 184));
    CFRelease((CFTypeRef)a1);
  }
}

unint64_t provider_for_destination_get_bytes_at_position(uint64_t a1, char *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 724)) {
    _CGHandleAssert("provider_for_destination_get_bytes_at_position", 611, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "info->src_provider_uses_random_access == true", "", a6, a7, a8, vars0);
  }

  return provider_for_destination_get_bytes_at_position_inner(a1, a2, a3, a4, 0, a6, a7, a8);
}

unint64_t provider_for_destination_get_bytes_at_position_inner(uint64_t a1, char *a2, unint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  if ((a3 & 0x8000000000000000) != 0) {
    _CGHandleAssert("provider_for_destination_get_bytes_at_position_inner", 573, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "pos >= 0", "position = %lld", a6, a7, a8, a3);
  }
  int64_t v11 = *(char **)(a1 + 728);
  unint64_t v108 = *(void *)(a1 + 736);
  uint64_t v12 = (const void *)(a1 + 32);
  uint64_t v104 = *(void *)(a1 + 752);
  v105 = *(void **)(a1 + 744);
  memcpy(__dst, (const void *)(a1 + 32), 0x130uLL);
  unint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v13, v14, v15, v16, v17, v18, v19);
  memcpy(__dst, (const void *)(a1 + 360), 0x130uLL);
  unint64_t v28 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v21, v22, v23, v24, v25, v26, v27);
  __dst[1] = 0;
  *(_OWORD *)&__dst[3] = 0u;
  __dst[0] = v11;
  __dst[2] = 1;
  unsigned int v29 = *(_DWORD *)(a1 + 720);
  LODWORD(__dst[4]) = v29;
  memcpy(&__dst[5], v12, 0x130uLL);
  if (*(void *)(a1 + 72)) {
    __dst[10] = &__dst[11];
  }
  __src[0] = 0u;
  __src[1] = 1uLL;
  *(void *)&__src[2] = v29;
  memcpy((char *)&__src[2] + 8, (const void *)(a1 + 360), 0x130uLL);
  if (*(void *)(a1 + 400)) {
    *(void *)&__src[5] = (char *)&__src[5] + 8;
  }
  unint64_t v32 = a4;
  if (*(void *)(a1 + 8) >= 8 * a4 / v28) {
    unint64_t v33 = 8 * a4 / v28;
  }
  else {
    unint64_t v33 = *(void *)(a1 + 8);
  }
  int64_t v37 = destination_position_to_source_position(v28, *(void *)(a1 + 664), *(void *)(a1 + 672), BitsPerPixel, *(void *)(a1 + 336), a3, v30, v31);
  if (v37 < 0) {
    _CGHandleAssert("provider_for_destination_get_bytes_with_work_buffer", 456, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "src_pos >= 0", "source position (%lld) may not be negative", v34, v35, v36, v37);
  }
  if (*(void *)(a1 + 696))
  {
    unint64_t v38 = v108;
  }
  else
  {
    unint64_t v38 = v108;
    if (!*(void *)(a1 + 688) && !*(void *)(a1 + 712))
    {
      int64_t v11 = a2;
      __dst[0] = a2;
    }
  }
  long long v39 = *(void **)a1;
  unint64_t v47 = byte_count_to_byte_count(v28, *(void *)(a1 + 664), *(void *)(a1 + 672), *(void *)(a1 + 680), BitsPerPixel, *(void *)(a1 + 336), v32, v36);
  if (v47 > v38)
  {
    CGPostError((uint64_t)"%s: bytes_to_read %zd > interim_buffer_size %zd", v40, v41, v42, v43, v44, v45, v46, (char)"provider_for_destination_get_bytes_with_work_buffer");
    _CGHandleAssert("provider_for_destination_get_bytes_with_work_buffer", 474, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "bytes_to_read <= interim_buffer_size", "read size (%lu) exceeds interim space to store the data (%lu)", v100, v101, v102, v47);
  }
  if (v37 >= 1)
  {
    unint64_t v48 = *(void *)(a1 + 336);
    if (v48)
    {
      if (v37 / v48 == *(void *)(a1 + 16) - 1) {
        unint64_t v47 = (v33 * BitsPerPixel + 7) >> 3;
      }
    }
  }
  if (*(unsigned char *)(a1 + 724)) {
    size_t BytesAtPositionInternal = CGDataProviderDirectGetBytesAtPositionInternal(v39, v11, v37, v47, v43, v44, v45, v46);
  }
  else {
    size_t BytesAtPositionInternal = CGDataProviderSequentialGetBytesInternal((uint64_t)v39, (uint64_t)v11, v47);
  }
  size_t v53 = BytesAtPositionInternal;
  if (BytesAtPositionInternal > v47) {
    _CGHandleAssert("provider_for_destination_get_bytes_with_work_buffer", 487, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "bytes_read <= bytes_to_read", "read size (%lu) exceeds space to store the data (%lu)", v50, v51, v52, BytesAtPositionInternal);
  }
  unint64_t v54 = 8 * BytesAtPositionInternal / BitsPerPixel;
  if (v33 < v54) {
    unint64_t v54 = v33;
  }
  if (v47 == BytesAtPositionInternal) {
    unint64_t v55 = v33;
  }
  else {
    unint64_t v55 = v54;
  }
  if (!v55) {
    goto LABEL_124;
  }
  *((void *)&__src[0] + 1) = v55;
  __dst[1] = v55;
  if (*(unsigned char *)(a1 + 725))
  {
    int v56 = *(_DWORD *)(a1 + 56);
    if (v56 == 9)
    {
      int v57 = 3;
    }
    else
    {
      if (v56 != 8)
      {
        int v58 = v56 - 1;
        if ((v56 - 1) > 8)
        {
          uint64_t v59 = 0;
LABEL_37:
          int v60 = *(_DWORD *)(a1 + 60);
          uint64_t v61 = v59 + *(void *)(a1 + 48);
          switch(*(_DWORD *)(a1 + 32))
          {
            case 1:
              switch(v61)
              {
                case 5:
                  v72 = (unsigned char *)(__dst[0] + 4 * (v56 == 5));
                  unint64_t v73 = v55;
                  do
                  {
                    unsigned char *v72 = -1;
                    v72 += 5;
                    --v73;
                  }
                  while (v73);
                  break;
                case 4:
                  BOOL v75 = (v60 & 0xFFFFBFFF) == 0 && v56 == 5;
                  *(void *)srdouble c = __dst[0];
                  *(void *)&src[8] = 1;
                  BOOL v76 = v60 == 0x2000 && v56 == 6;
                  *(void *)&src[16] = v55;
                  *(void *)&src[24] = 4 * v55;
                  if (v76) {
                    BOOL v75 = 1;
                  }
                  *(void *)dest = __dst[0];
                  *(void *)&dest[8] = 1;
                  *(void *)&dest[16] = v55;
                  *(void *)&dest[24] = 4 * v55;
                  if (v75) {
                    uint8_t v77 = 1;
                  }
                  else {
                    uint8_t v77 = 8;
                  }
                  vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, (const vImage_Buffer *)src, (const vImage_Buffer *)dest, v77, 0x10u);
                  break;
                case 2:
                  if (v56 == 5) {
                    v62 = (unsigned char *)(__dst[0] + 1);
                  }
                  else {
                    v62 = (unsigned char *)__dst[0];
                  }
                  unint64_t v63 = v55;
                  do
                  {
                    unsigned char *v62 = -1;
                    v62 += 2;
                    --v63;
                  }
                  while (v63);
                  break;
                default:
                  _CGHandleAssert("overwrite_alpha_8bit", 146, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "", "Unimplemented", v50, v51, v52, v103);
              }
              goto LABEL_119;
            case 2:
              if (v61 == 5)
              {
                v78 = (_WORD *)(__dst[0] + 8 * (v56 == 5));
                unint64_t v79 = v55;
                do
                {
                  _WORD *v78 = -1;
                  v78 += 5;
                  --v79;
                }
                while (v79);
                goto LABEL_119;
              }
              if (v61 == 4)
              {
                *(void *)&long long backgroundColor = -1;
                *(_DWORD *)permuteMap = 50462976;
                *(void *)srdouble c = __dst[0];
                *(void *)&src[8] = 1;
                *(void *)&src[16] = v55;
                *(void *)&src[24] = 4 * v55;
                *(void *)dest = __dst[0];
                *(void *)&dest[8] = 1;
                if (v56 == 5) {
                  uint8_t v80 = 1;
                }
                else {
                  uint8_t v80 = 8;
                }
                *(void *)&dest[16] = v55;
                *(void *)&dest[24] = 4 * v55;
                goto LABEL_118;
              }
              if (v61 != 2) {
                _CGHandleAssert("overwrite_alpha_16bitInteger", 215, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "", "Unimplemented", v50, v51, v52, v103);
              }
              v64 = (_WORD *)(__dst[0] + 2 * (v56 == 5));
              unint64_t v65 = v55;
              do
              {
                _WORD *v64 = -1;
                v64 += 2;
                --v65;
              }
              while (v65);
              break;
            case 4:
              switch(v61)
              {
                case 5:
                  float v81 = 256.0;
                  if (v60 != 0x4000) {
                    float v81 = 1.0;
                  }
                  v82 = (float *)(__dst[0] + 16 * (v56 == 5));
                  unint64_t v83 = v55;
                  do
                  {
                    float *v82 = v81;
                    v82 += 5;
                    --v83;
                  }
                  while (v83);
                  break;
                case 4:
                  float v84 = 256.0;
                  *(void *)srdouble c = __dst[0];
                  *(void *)&src[8] = 1;
                  if (v60 != 0x4000) {
                    float v84 = 1.0;
                  }
                  *(void *)&src[16] = v55;
                  *(void *)&src[24] = 4 * v55;
                  *(void *)dest = __dst[0];
                  *(void *)&dest[8] = 1;
                  *(void *)&dest[16] = v55;
                  *(void *)&dest[24] = 4 * v55;
                  if (v56 == 5) {
                    uint8_t v85 = 1;
                  }
                  else {
                    uint8_t v85 = 8;
                  }
                  vImageOverwriteChannelsWithScalar_ARGBFFFF(v84, (const vImage_Buffer *)src, (const vImage_Buffer *)dest, v85, 0x10u);
                  break;
                case 2:
                  float v66 = 256.0;
                  if (v60 != 0x4000) {
                    float v66 = 1.0;
                  }
                  v67 = (float *)(__dst[0] + 4 * (v56 == 5));
                  unint64_t v68 = v55;
                  do
                  {
                    float *v67 = v66;
                    v67 += 2;
                    --v68;
                  }
                  while (v68);
                  break;
                default:
                  _CGHandleAssert("overwrite_alpha_32bitFloat", 385, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "", "Unimplemented", v50, v51, v52, v103);
              }
              goto LABEL_119;
            case 5:
              switch(v61)
              {
                case 5:
                  __int16 v86 = 23552;
                  if (v60 != 12288) {
                    __int16 v86 = COERCE_UNSIGNED_INT(1.0);
                  }
                  v87 = (__int16 *)(__dst[0] + 8 * (v56 == 5));
                  unint64_t v88 = v55;
                  do
                  {
                    __int16 *v87 = v86;
                    v87 += 5;
                    --v88;
                  }
                  while (v88);
                  break;
                case 4:
                  *(void *)&long long backgroundColor = -1;
                  __int16 v89 = 23552;
                  if (v60 != 12288) {
                    __int16 v89 = COERCE_UNSIGNED_INT(1.0);
                  }
                  LOWORD(backgroundColor) = v89;
                  WORD3(backgroundColor) = v89;
                  *(_DWORD *)permuteMap = 50462976;
                  *(void *)srdouble c = __dst[0];
                  *(void *)&src[8] = 1;
                  *(void *)&src[16] = v55;
                  *(void *)&src[24] = 4 * v55;
                  *(void *)dest = __dst[0];
                  *(void *)&dest[8] = 1;
                  *(void *)&dest[16] = v55;
                  *(void *)&dest[24] = 4 * v55;
                  if (v56 == 5) {
                    uint8_t v80 = 1;
                  }
                  else {
                    uint8_t v80 = 8;
                  }
LABEL_118:
                  vImagePermuteChannelsWithMaskedInsert_ARGB16U((const vImage_Buffer *)src, (const vImage_Buffer *)dest, permuteMap, v80, (const uint16_t *)&backgroundColor, 0x10u);
                  break;
                case 2:
                  __int16 v69 = 23552;
                  if (v60 != 12288) {
                    __int16 v69 = COERCE_UNSIGNED_INT(1.0);
                  }
                  v70 = (__int16 *)(__dst[0] + 2 * (v56 == 5));
                  unint64_t v71 = v55;
                  do
                  {
                    __int16 *v70 = v69;
                    v70 += 2;
                    --v71;
                  }
                  while (v71);
                  break;
                default:
                  _CGHandleAssert("overwrite_alpha_16bitFloat", 302, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "", "Unimplemented", v50, v51, v52, v103);
              }
              break;
            default:
              _CGHandleAssert("overwrite_alpha", 409, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "", "Unimplemented", v50, v51, v52, v103);
          }
          goto LABEL_119;
        }
LABEL_36:
        uint64_t v59 = qword_185211998[v58];
        goto LABEL_37;
      }
      int v57 = 1;
    }
    int v58 = v56 - 1;
    int v56 = v57;
    goto LABEL_36;
  }
LABEL_119:
  *(void *)&__src[0] = a2;
  v90 = *(void **)(a1 + 688);
  if (v90)
  {
    long long v91 = *(_OWORD *)(a1 + 792);
    long long v118 = *(_OWORD *)(a1 + 776);
    uint64_t v92 = *(void *)(a1 + 704);
    uint64_t v93 = *(void *)(a1 + 760);
    unsigned int v94 = *(_DWORD *)(a1 + 768);
    long long v119 = v91;
    long long v120 = *(_OWORD *)(a1 + 808);
    v95 = *(void **)(a1 + 24);
    uint64_t v96 = *(unsigned int *)(a1 + 720);
    v97 = *(void **)(a1 + 696);
    *(void *)&long long backgroundColor = v92;
    *((void *)&backgroundColor + 1) = v105;
    uint64_t v115 = v104;
    uint64_t v116 = v93;
    uint64_t v117 = v94;
    memcpy(src, __dst, sizeof(src));
    memcpy(dest, __src, sizeof(dest));
    if ((CGColorTransformConvertUsingCMSConverter(v90, v95, v96, v97, &backgroundColor, (uint64_t)src, (uint64_t)dest) & 1) == 0) {
      return 0;
    }
  }
  else
  {
    v98 = *(vImageConverter **)(a1 + 712);
    if (v98)
    {
      memcpy(src, __dst, sizeof(src));
      memcpy(dest, __src, sizeof(dest));
      if (!vImageConverterConvert(v98, (uint64_t)src, (uint64_t)dest, v105)) {
        return 0;
      }
    }
  }
LABEL_124:
  if (v47 == v53) {
    unint64_t result = v32;
  }
  else {
    unint64_t result = (v55 * v28 + 7) >> 3;
  }
  if (a5)
  {
    *(void *)(a1 + 352) += v53;
    *(void *)(a1 + 680) += result;
  }
  return result;
}

uint64_t CGBitmapPixelInfoGetBitsPerPixel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  HIDWORD(v9) = *(_DWORD *)(a1 + 32);
  LODWORD(v9) = HIDWORD(v9);
  int v8 = v9 >> 16;
  if ((v8 - 1) < 2) {
    return 16;
  }
  if ((v8 - 3) < 2) {
    return 32;
  }
  if (v8) {
    _CGHandleAssert("CGBitmapPixelInfoGetBitsPerPixel", 142, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "", "Unimplemented", a6, a7, a8, vars0);
  }
  unsigned int v11 = *(_DWORD *)(a1 + 24) - 1;
  if (v11 > 8) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = qword_185211998[v11];
  }
  return (v12 + *(void *)(a1 + 16)) * *(void *)(a1 + 8);
}

unint64_t byte_count_to_byte_count(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  if (!a2) {
    _CGHandleAssert("byte_count_to_byte_count", 23, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestinationUtils.c", "input_bytes_per_row != 0", "0 rowBytes", a6, a7, a8, v8);
  }
  if (a7)
  {
    if (a6)
    {
      if (a7 >= a2) {
        unint64_t v9 = a7 / a2;
      }
      else {
        unint64_t v9 = 0;
      }
      unint64_t v10 = a7 - v9 * a2;
      unint64_t v11 = a3 - a4 % a2;
      if (a3 <= a4 % a2)
      {
        unint64_t v12 = 0;
        unint64_t v11 = 0;
      }
      else
      {
        unint64_t v12 = (8 * v11 / a1 * a5 + 7) >> 3;
      }
      if (v10 < v11)
      {
        unint64_t v11 = 0;
        unint64_t v12 = 0;
      }
      return v10 + v9 * a6 + v12 - v11;
    }
    else if (a5 != a1)
    {
      return (8 * a5 * a7 / a1 + 7) >> 3;
    }
  }
  return a7;
}

BOOL vImageConverterConvert(vImageConverter *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  vImagePixelCount v4 = *(void *)(a2 + 8);
  vImagePixelCount v5 = *(void *)(a2 + 16);
  if (!(v4 * v5)) {
    return 0;
  }
  unint64_t v9 = *(void **)a2;
  size_t v10 = *(void *)(a2 + 24);
  memcpy(v52, (const void *)(a2 + 32), sizeof(v52));
  v53.datdouble a = v9;
  v53.height = v5;
  v53.width = v4;
  if (!v10)
  {
    memcpy(v54, &v52[8], sizeof(v54));
    size_t v10 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v54, v11, v12, v13, v14, v15, v16, v17) >> 3)
        * v4;
  }
  v53.rowBytes = v10;
  uint64_t v18 = *(void **)a3;
  size_t v19 = *(void *)(a3 + 24);
  memcpy(v52, (const void *)(a3 + 32), sizeof(v52));
  v51.datdouble a = v18;
  int8x16_t v20 = *(int8x16_t *)(a3 + 8);
  *(int8x16_t *)&v51.height = vextq_s8(v20, v20, 8uLL);
  if (!v19)
  {
    int8x16_t v50 = v20;
    memcpy(v54, &v52[8], sizeof(v54));
    size_t v19 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v54, v21, v22, v23, v24, v25, v26, v27) >> 3)
        * v50.i64[0];
  }
  v51.rowBytes = v19;
  if (a4) {
    return vImageConverter_convert_internal(a1, &v53, &v51, a4);
  }
  vImage_Error v29 = vImageConvert_AnyToAny(a1, &v53, &v51, 0, 0x80u);
  if (v29 < 0)
  {
    CGPostError((uint64_t)"vImageConvert_AnyToAny failed to return valid buffer size", v30, v31, v32, v33, v34, v35, v36, v50.i8[0]);
    return 0;
  }
  if (!v29)
  {
    vImageConverter_convert_internal(a1, &v53, &v51, 0);
    return 0;
  }
  size_t v37 = MEMORY[0x1F4188790]();
  long long v39 = &v50.i8[-v38];
  if (v37 <= 0x400) {
    return vImageConverter_convert_internal(a1, &v53, &v51, (char *)&v50 - v38);
  }
  uint64_t v40 = (char *)malloc_type_malloc(v37, 0xE3B5A78DuLL);
  if (!v40)
  {
    CGPostError((uint64_t)"vImageConverter could not allocate buffer %s", v41, v42, v43, v44, v45, v46, v47, (char)"vImageConverterConvert");
    return 0;
  }
  unint64_t v48 = v40;
  BOOL v28 = vImageConverter_convert_internal(a1, &v53, &v51, v40);
  if (v48 != v39) {
    free(v48);
  }
  return v28;
}

BOOL vImageConverter_convert_internal(vImageConverter *a1, const vImage_Buffer *a2, const vImage_Buffer *a3, void *a4)
{
  vImage_Error v11 = vImageConvert_AnyToAny(a1, a2, a3, a4, 0x10u);
  if (v11) {
    CGPostError((uint64_t)"vImageConvert_AnyToAny failed in %s", v4, v5, v6, v7, v8, v9, v10, (char)"vImageConverter_convert_internal");
  }
  return v11 == 0;
}

unint64_t destination_position_to_source_position(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a6 & 0x8000000000000000) != 0) {
    _CGHandleAssert("destination_position_to_source_position", 107, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestinationUtils.c", "destination_position >= 0", "position %lld", a6, a6, a8, a6);
  }
  return byte_count_to_byte_count(a1, a2, a3, 0, a4, a5, a6, a8);
}

uint64_t CGDataProviderIsZombie(_DWORD *a1)
{
  if (!a1) {
    return 1;
  }
  CFTypeID v8 = CFGetTypeID(a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  if (v8 != CGDataProviderGetTypeID_id) {
    return 1;
  }
  int v9 = a1[4];
  if (v9 != 48879)
  {
    if (v9 == 57005) {
      uint64_t v10 = "Data Provider %p is over released";
    }
    else {
      uint64_t v10 = "Object %p is not a CGDataProvider";
    }
    CGLog(3, (uint64_t)v10, v2, v3, v4, v5, v6, v7, (char)a1);
    if (CGOSAppleInternalBuild_predicate != -1) {
      dispatch_once(&CGOSAppleInternalBuild_predicate, &__block_literal_global_18177);
    }
    if (CGOSAppleInternalBuild_is_internal) {
      _CGHandleAssert("CGDataProviderIsZombie", 996, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "0", "", v11, v12, v13, v15);
    }
    return 1;
  }
  return 0;
}

uint64_t imageProvider_getBytesAtPosition(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("imageProvider_getBytesAtPosition", 120, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderImageProvider.c", "imageProvider != NULL", "provider missing", a6, a7, a8, v43);
  }
  CFTypeID v8 = a2;
  if (!a2)
  {
    CGPostError((uint64_t)"%s: cannot write to a NULL buffer", 0, a3, a4, a5, a6, a7, a8, (char)"imageProvider_getBytesAtPosition");
    return 0;
  }
  size_t v9 = a4;
  ERROR_CGBlt_copyBytes_BufferIsNotReadable();
  ERROR_CGBlt_copyBytes_BufferIsNotBigEnough();
  if (a3 < 0) {
    return 0;
  }
  uint64_t v11 = a1;
  if (*(void *)(a1 + 64) <= (unint64_t)a3) {
    return 0;
  }
  uint64_t v12 = *(void *)(a1 + 8);
  if (!v12)
  {
    bzero(v8, v9);
    return 0;
  }
  unint64_t v13 = *(void *)(v12 + 120);
  if (!v13) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v52 = &v8[v9];
  uint64_t v16 = *(void *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v17 = a3 / v15;
  double v18 = (double)v16;
  uint64_t v50 = v15;
  unint64_t v51 = (unint64_t)&v8[v9 - 1];
  uint64_t v19 = a3 % v15;
  v49 = &v8[v9];
  uint64_t v44 = v16;
  uint64_t v45 = *(void *)(v12 + 120);
  do
  {
    if (!v9) {
      break;
    }
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    do
    {
      uint64_t v22 = *(void *)(v11 + 8);
      if (v22)
      {
        if (*(void *)(v22 + 120) > v21)
        {
          uint64_t v23 = *(double **)(v22 + 8 * v21 + 128);
          if (v23)
          {
            double v25 = v23[2];
            double v26 = v23[3];
            double v27 = v23[4];
            uint64_t v28 = v17 - (uint64_t)v25;
            BOOL v29 = v17 >= (uint64_t)v25 && v17 < (uint64_t)v25 + (uint64_t)v27;
            double v24 = v23[1];
            uint64_t v30 = v16 * (uint64_t)v24;
            BOOL v31 = !v29 || v19 < v30;
            uint64_t v32 = v16 * (uint64_t)v26;
            if (!v31 && v19 < v30 + v32)
            {
              uint64_t v56 = v16 * (uint64_t)v24;
              uint64_t v46 = v17;
              uint64_t v34 = result;
              uint64_t v54 = v30 + v32;
              uint64_t v55 = v16 * (uint64_t)v26;
              uint64_t v53 = (uint64_t)v25 + (uint64_t)v27;
              uint64_t v35 = *(char **)v23;
              unint64_t v36 = *((void *)v23 + 5);
              unint64_t v47 = (unint64_t)(v26 * v18 + (v27 + -1.0) * (double)v36);
              int v57 = 0;
              DebugString = CGDataProviderGetDebugString(*(void *)(v11 + 72));
              if (DebugString)
              {
                asprintf(&v57, "CGDataProviderForImageProvider: image provider: %p block set count: %zu block: %p block index %zu block data: %p block bpr: %zu block size: %zu\n%s\n", *(const void **)a1, v45, v23, v21, v35, v36, v47, DebugString);
                qword_1EB288DD0 = (uint64_t)v57;
                ERROR_CGDataProvider_BufferIsNotReadable();
                ERROR_CGDataProvider_BufferIsNotBigEnough();
                qword_1EB288DD0 = 0;
                free(v57);
              }
              else
              {
                ERROR_CGDataProvider_BufferIsNotReadable();
                ERROR_CGDataProvider_BufferIsNotBigEnough();
              }
              uint64_t v38 = v56;
              long long v39 = &v35[v36 * v28 - v56];
              uint64_t v17 = v46;
              do
              {
                unint64_t v40 = v55 + v38 - v19;
                if (v40 >= v9) {
                  unint64_t v40 = v9;
                }
                if ((unint64_t)v8 > v51) {
                  CFTypeID v8 = (char *)v51;
                }
                if (&v8[v40] <= v52) {
                  size_t v41 = v40;
                }
                else {
                  size_t v41 = v49 - v8;
                }
                memcpy(v8, &v39[v19], v41);
                v8 += v41;
                v9 -= v41;
                v34 += v41;
                v20 += v41;
                v19 += v41;
                if (v19 != v50) {
                  break;
                }
                uint64_t v19 = 0;
                ++v17;
                if (v50 > v54) {
                  break;
                }
                uint64_t v38 = v56;
                if (v56) {
                  break;
                }
                v39 += v36;
              }
              while (v9 && v17 < v53);
              uint64_t v11 = a1;
              uint64_t v16 = v44;
              unint64_t v13 = v45;
              uint64_t result = v34;
            }
          }
        }
      }
      ++v21;
    }
    while (v21 < v13 && v9);
  }
  while (v9 && v20);
  return result;
}

const char *CGDataProviderGetDebugString(uint64_t a1)
{
  if (data_provider_debug_info_enabled_predicate != -1)
  {
    dispatch_once(&data_provider_debug_info_enabled_predicate, &__block_literal_global_42);
    if (a1) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!a1) {
    return 0;
  }
LABEL_3:
  if (!data_provider_debug_info_enabled_enabled) {
    return 0;
  }
  CFStringRef v2 = *(const __CFString **)(a1 + 280);
  if (!v2) {
    return 0;
  }

  return CFStringGetCStringPtr(v2, 0x8000100u);
}

void check_same_thread()
{
  if (get_session_key_pred != -1) {
    dispatch_once(&get_session_key_pred, &__block_literal_global_20420);
  }
  v0 = (_opaque_pthread_t *)pthread_getspecific(get_session_key_session_key);
  if (v0 != pthread_self()) {
    CGPostError((uint64_t)"CGAccessSession cannot be shared between threads.Session created on thread %p used by %p", v1, v2, v3, v4, v5, v6, v7, (char)v0);
  }
}

uint64_t CGColorTransformConvertUsingCMSConverter(void *a1, void *a2, uint64_t a3, void *CGCMSConverter, long long *a5, uint64_t a6, uint64_t a7)
{
  CFTypeID v14 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v14 != CGColorTransformGetTypeID_type_id) {
    return 0;
  }
  if (!CGCMSConverter)
  {
    CGCMSConverter = CGColorTransformCreateCGCMSConverter(a1, a2, a3);
    long long v22 = a5[2];
    long long v23 = a5[3];
    long long v24 = a5[4];
    uint64_t v25 = *((void *)a5 + 10);
    long long v20 = *a5;
    long long v21 = a5[1];
    if (CGCMSConverter) {
      goto LABEL_7;
    }
    return 0;
  }
  CFRetain(CGCMSConverter);
  long long v22 = a5[2];
  long long v23 = a5[3];
  long long v24 = a5[4];
  uint64_t v25 = *((void *)a5 + 10);
  long long v20 = *a5;
  long long v21 = a5[1];
LABEL_7:
  CFTypeID v15 = CFGetTypeID(CGCMSConverter);
  uint64_t v16 = kCGCMSConverterID;
  if (!kCGCMSConverterID)
  {
    pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
    uint64_t v16 = kCGCMSConverterID;
  }
  if (v15 == v16)
  {
    uint64_t v17 = (uint64_t (*)(void *, uint64_t, uint64_t, _OWORD *))CGCMSConverter[7];
    v26[2] = v22;
    v26[3] = v23;
    v26[4] = v24;
    uint64_t v27 = v25;
    v26[0] = v20;
    v26[1] = v21;
    uint64_t v18 = v17(CGCMSConverter, a6, a7, v26);
  }
  else
  {
    uint64_t v18 = 0;
  }
  CFRelease(CGCMSConverter);
  return v18;
}

uint64_t convert_icc(uint64_t a1, uint64_t a2, const std::__fs::filesystem::path *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 224))
  {
    long long v17 = *(_OWORD *)(a4 + 48);
    *(_OWORD *)&__dst[1].datdouble a = *(_OWORD *)(a4 + 32);
    *(_OWORD *)&__dst[1].width = v17;
    *(_OWORD *)&__dst[2].datdouble a = *(_OWORD *)(a4 + 64);
    __dst[2].width = *(void *)(a4 + 80);
    long long v18 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)&__dst[0].datdouble a = *(_OWORD *)a4;
    *(_OWORD *)&__dst[0].width = v18;
    return convert_using_vImageConverter(a1, (const std::__fs::filesystem::path *)a2, a3, (vImageConverter ***)__dst, a5, a6, a7, a8);
  }
  if (!a2
    || !a3
    || *(void *)(a2 + 8) != a3->__pn_.__r_.__value_.__l.__size_
    || *(void *)(a2 + 16) != a3->__pn_.__r_.__value_.__r.__words[2]
    || !*(void *)(a1 + 88))
  {
    goto LABEL_19;
  }
  uint64_t v12 = *(vImageConverter **)(a4 + 40);
  uint64_t v11 = *(vImageConverter **)(a4 + 48);
  unint64_t v13 = *(void **)(a4 + 64);
  tempBuffer = *(void **)(a4 + 56);
  CFTypeID v15 = *(void **)(a4 + 72);
  CFTypeID v14 = *(void **)(a4 + 80);
  if ((converter_does_tone_mapping(a1) & 1) == 0
    && (*(_DWORD *)(a1 + 16) == 3 || CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a1 + 24)))
    && conversion_formats_are_equal(a2, (uint64_t)a3))
  {
    copy((const std::__fs::filesystem::path *)a2, a3, (std::__fs::filesystem::copy_options)a3, (std::error_code *)a4);
    return 1;
  }
  unsigned int v19 = *(_DWORD *)(a2 + 40);
  if (v19 > 5 || ((1 << v19) & 0x36) == 0)
  {
LABEL_19:
    CGPostError((uint64_t)"%s : Unable to complete color conversion", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"convert_using_colorsync_transform");
    return 0;
  }
  std::string::size_type size = *(void *)(a2 + 56);
  if (a3[2].__pn_.__r_.__value_.__l.__size_ > size) {
    std::string::size_type size = a3[2].__pn_.__r_.__value_.__l.__size_;
  }
  std::string::size_type v21 = (*(void *)(a2 + 8) + *(void *)(a2 + 8) * size) * *(void *)(a2 + 16);
  size_t v22 = 4 * v21;
  if (v15)
  {
    long long v23 = 0;
  }
  else
  {
    long long v23 = malloc_type_calloc(1uLL, 4 * v21, 0x63ACA35DuLL);
    CFTypeID v15 = v23;
  }
  if (v14)
  {
    uint64_t v25 = 0;
  }
  else
  {
    uint64_t v25 = malloc_type_calloc(1uLL, v22, 0x1A3F285CuLL);
    CFTypeID v14 = v25;
  }
  if (!v15) {
    _CGHandleAssert("convert_using_colorsync_transform", 3622, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "colorsync_transform_info.buffer_in != NULL", "%s has no source buffer", a6, a7, a8, (char)"convert_using_colorsync_transform");
  }
  if (!v14) {
    _CGHandleAssert("convert_using_colorsync_transform", 3623, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "colorsync_transform_info.buffer_out != NULL", "%s has no destination buffer", a6, a7, a8, (char)"convert_using_colorsync_transform");
  }
  if (v12)
  {
    int v60 = v25;
    int v57 = v13;
    int v58 = v11;
    BOOL v59 = (*(_DWORD *)(a2 + 64) & 0xFFFFFFFE) != 8 && *(_DWORD *)(a2 + 64) == 0;
    if (v59) {
      uint64_t v26 = 96;
    }
    else {
      uint64_t v26 = 128;
    }
    uint64_t v27 = *(void **)a2;
    int8x16_t v61 = *(int8x16_t *)(a2 + 8);
    size_t v28 = *(void *)(a2 + 24);
    memcpy(__dst, (const void *)(a2 + 32), 0x138uLL);
    int8x16_t v29 = v61;
    srcs.datdouble a = v27;
    int8x16_t v30 = vextq_s8(v29, v29, 8uLL);
    *(int8x16_t *)&srcs.height = v30;
    if (!v28)
    {
      memcpy(v67, &__dst[0].height, 0x130uLL);
      size_t v28 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v67, v31, v32, v33, v34, v35, v36, v37) >> 3)
          * v61.i64[0];
      int8x16_t v29 = *(int8x16_t *)(a2 + 8);
      int8x16_t v30 = vextq_s8(v29, v29, 8uLL);
    }
    srcs.rowBytes = v28;
    __dst[0].datdouble a = v15;
    *(int8x16_t *)&__dst[0].height = v30;
    __dst[0].rowBytes = (unint64_t)(v29.i64[0] * v26) >> 3;
    if (tempBuffer)
    {
      uint64_t v38 = v59 ? 0 : 3;
      if (!vImageConvert_AnyToAny(v12, &srcs, __dst, tempBuffer, 0x10u))
      {
        if (convert_using_colorsync_transform_cglibrarypredicate != -1) {
          dispatch_once(&convert_using_colorsync_transform_cglibrarypredicate, &__block_literal_global_74_2136);
        }
        if (convert_using_colorsync_transform_f(*(void *)(a1 + 88), *(void *)(a2 + 8), *(void *)(a2 + 16), v14, 7, v38, 0, v15))
        {
          if (v58)
          {
            int8x16_t v45 = *(int8x16_t *)&a3->__pn_.__r_.__value_.__r.__words[1];
            *(int8x16_t *)tempBufferdouble a = vextq_s8(v45, v45, 8uLL);
            *(_OWORD *)&srcs.height = *(_OWORD *)tempBuffera;
            uint64_t v46 = 16;
            if (v59) {
              uint64_t v46 = 12;
            }
            uint64_t v47 = v45.i64[0];
            srcs.datdouble a = v14;
            srcs.rowBytes = v45.i64[0] * v46;
            unint64_t v48 = (void *)a3->__pn_.__r_.__value_.__r.__words[0];
            size_t v49 = a3[1].__pn_.__r_.__value_.__r.__words[0];
            memcpy(__dst, &a3[1].__pn_.__r_.__value_.__r.__words[1], 0x138uLL);
            dests.datdouble a = v48;
            *(_OWORD *)&dests.height = *(_OWORD *)tempBuffera;
            if (!v49)
            {
              memcpy(v67, &__dst[0].height, 0x130uLL);
              size_t v49 = ((unint64_t)CGBitmapPixelInfoGetBitsPerPixel((uint64_t)v67, v50, v51, v52, v53, v54, v55, v56) >> 3)
                  * v47;
            }
            dests.rowBytes = v49;
            if (v57)
            {
              BOOL v16 = vImageConvert_AnyToAny(v58, &srcs, &dests, v57, 0x10u) == 0;
LABEL_51:
              uint64_t v25 = v60;
              goto LABEL_52;
            }
          }
        }
        else
        {
          CGLog(3, (uint64_t)"ColorSyncTransformConvert failed", v39, v40, v41, v42, v43, v44, 7);
        }
      }
    }
    BOOL v16 = 0;
    goto LABEL_51;
  }
  BOOL v16 = 0;
LABEL_52:
  if (v23) {
    free(v23);
  }
  if (v25) {
    free(v25);
  }
  return v16;
}

uint64_t convert_using_vImageConverter(uint64_t a1, const std::__fs::filesystem::path *a2, const std::__fs::filesystem::path *a3, vImageConverter ***a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2
    || !a3
    || a2->__pn_.__r_.__value_.__l.__size_ != a3->__pn_.__r_.__value_.__l.__size_
    || a2->__pn_.__r_.__value_.__r.__words[2] != a3->__pn_.__r_.__value_.__r.__words[2])
  {
    CGPostError((uint64_t)"%s : Unable to complete color conversion", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (char)"convert_using_vImageConverter");
    return 0;
  }
  if ((converter_does_tone_mapping(a1) & 1) == 0
    && (*(_DWORD *)(a1 + 16) == 3 || CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a1 + 24)))
    && conversion_formats_are_equal((uint64_t)a2, (uint64_t)a3))
  {
    copy(a2, a3, v12, v13);
    return 1;
  }
  CFTypeID v15 = *a4;
  if (*a4)
  {
    BOOL v16 = 0;
LABEL_16:
    long long v17 = a4[1];
    memcpy(__dst, a2, sizeof(__dst));
    memcpy(v24, a3, sizeof(v24));
    BOOL v23 = vImageConverterConvert(*v15, (uint64_t)__dst, (uint64_t)v24, v17);
    if (v16) {
      CGvImageConverterCacheRelease(v16);
    }
    if (v23) {
      return 1;
    }
    post_conversion_error((uint64_t)a2, (uint64_t)a3, (uint64_t)"vImageConvert_AnyToAny", v18, v19, v20, v21, v22);
    return 0;
  }
  uint64_t result = (uint64_t)CGCMSConverterCreateCachedCGvImageConverter((void *)a1, a2, a3);
  BOOL v16 = (char *)result;
  CFTypeID v15 = (vImageConverter **)result;
  if (result) {
    goto LABEL_16;
  }
  return result;
}

BOOL cs_equal(uint64_t a1, uint64_t a2)
{
  return CGColorSpaceEqualToColorSpace(a1, a2);
}

BOOL CGColorSpaceEqualToColorSpace(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  BOOL result = 0;
  if (!a1 || !a2) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(a2 + 24);
  if (v4 == v5) {
    return 1;
  }
  BOOL result = 0;
  if (v4 && v5)
  {
    if (*(_DWORD *)(v4 + 24) == *(_DWORD *)(v5 + 24))
    {
      uint64_t v7 = *(void *)(v4 + 64);
      uint64_t v6 = *(void *)(v4 + 72);
      uint64_t v9 = *(void *)(v5 + 64);
      uint64_t v8 = *(void *)(v5 + 72);
      return v7 == v9 && v6 == v8;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDictionaryRef converter_does_tone_mapping(uint64_t a1)
{
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 72);
  if (result)
  {
    if (CFDictionaryContainsKey(result, @"kCGColorConversionInfoOptions")) {
      return (const __CFDictionary *)1;
    }
    else {
      return (const __CFDictionary *)(CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 72), @"kCGImageExtendedRangeToneMappingInfo") != 0);
    }
  }
  return result;
}

void CGvImageConverterCacheRelease(char *value)
{
  if (get_cache_predicate_17839 != -1) {
    dispatch_once(&get_cache_predicate_17839, &__block_literal_global_7_17840);
  }
  if (cache_release_value(*(cache_t **)(get_cache_converter_cache + 64), value))
  {
    CGvImageConverterDeallocate(value);
  }
}

void _CGHandleAssert(const char *a1, int a2, const char *a3, const char *a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  os_unfair_lock_lock(&_CGHandleAssert_assert_lock);
  unsigned int v14 = snprintf(_CGHandleAssert_assertStr, 0x800uLL, "CoreGraphics assert(%s) failed in %s:\n\t", a4, a1);
  unsigned int v15 = v14;
  if (v14 >= 0x800) {
    uint64_t v16 = 2048;
  }
  else {
    uint64_t v16 = v14;
  }
  long long v17 = &_CGHandleAssert_assertStr[v16];
  int v18 = vsnprintf(&_CGHandleAssert_assertStr[v16], 2048 - v16, a5, &a9);
  if (v15 <= 0x7FF && !v18) {
    *long long v17 = 0;
  }
  CGPostError((uint64_t)"%s", v19, v20, v21, v22, v23, v24, v25, (char)_CGHandleAssert_assertStr);
  qword_1EB288DD0 = (uint64_t)_CGHandleAssert_assertStr;
  __assert_rtn((const char *)0xFFFFFFFFFFFFFFFFLL, a3, a2, a4);
}

uint64_t data_get_byte_pointer(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

CFStringRef CGCreateCanonicalLanguageLocale()
{
  CFStringRef v0 = (const __CFString *)MEMORY[0x1853291B0]();
  CFStringRef result = CFLocaleCreateCanonicalLanguageIdentifierFromString(0, v0);
  if (result)
  {
    CFStringRef v2 = result;
    CFLocaleRef v3 = CFLocaleCreate(0, result);
    CFRelease(v2);
    return (const __CFString *)v3;
  }
  return result;
}

void copy(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::__fs::filesystem::copy_options __opt, std::error_code *__ec)
{
  memcpy(__dst, &__from[1].__pn_.__r_.__value_.__r.__words[2], sizeof(__dst));
  uint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v6, v7, v8, v9, v10, v11, v12);
  memcpy(__dst, &__to[1].__pn_.__r_.__value_.__r.__words[2], sizeof(__dst));
  if (BitsPerPixel != CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v14, v15, v16, v17, v18, v19, v20))
  {
    memcpy(__dst, &__to[1].__pn_.__r_.__value_.__r.__words[2], sizeof(__dst));
    CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v25, v26, v27, v28, v29, v30, v31);
    _CGHandleAssert("copy", 552, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "src_bits_per_pixel == CGBitmapPixelInfoGetBitsPerPixel(dst->pixel_info)", "src bpp: %zu dest bpp: %zu", v32, v33, v34, BitsPerPixel);
  }
  if (__from->__pn_.__r_.__value_.__r.__words[2])
  {
    std::string::size_type v21 = 0;
    uint64_t v22 = (char *)__from->__pn_.__r_.__value_.__r.__words[0];
    size_t v23 = (__from->__pn_.__r_.__value_.__l.__size_ * BitsPerPixel + 7) >> 3;
    uint64_t v24 = (char *)__to->__pn_.__r_.__value_.__r.__words[0];
    do
    {
      memcpy(v24, v22, v23);
      v24 += (unint64_t)__to[1].__pn_.__r_.__value_.__l.__data_;
      v22 += (unint64_t)__from[1].__pn_.__r_.__value_.__l.__data_;
      ++v21;
    }
    while (v21 < __from->__pn_.__r_.__value_.__r.__words[2]);
  }
}

BOOL conversion_formats_are_equal(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8) != *(void *)(a2 + 8)
    || *(void *)(a1 + 16) != *(void *)(a2 + 16)
    || *(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32))
  {
    return 0;
  }
  CFStringRef v2 = (const void *)(a2 + 40);
  memcpy(__dst, (const void *)(a1 + 40), sizeof(__dst));
  memcpy(v4, v2, sizeof(v4));
  return CGBitmapPixelInfoIsEqualToBitmapPixelInfo((uint64_t)__dst, (uint64_t)v4);
}

uint64_t partial_get_byte_pointer(uint64_t *a1)
{
  uint64_t result = CGDataProviderRetainBytePtr(*a1);
  if (result) {
    result += a1[1];
  }
  return result;
}

void partial_release_byte_pointer(uint64_t *a1)
{
}

BOOL CGFloatIsValid(double a1)
{
  double v1 = fabs(a1);
  return v1 > INFINITY || v1 < INFINITY;
}

void CGDisplayListRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  float64x2_t v4 = *(float64x2_t *)&t->c;
  long long v5 = *(_OWORD *)&t->a;
  *(float64x2_t *)&t->double tx = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)&t->tx, *(float64x2_t *)&t->a, tx), v4, ty);
  *(_OWORD *)&retstr->double a = v5;
  *(float64x2_t *)&retstr->double c = v4;
  *(_OWORD *)&retstr->double tx = *(_OWORD *)&t->tx;
  return t;
}

BOOL CGColorSpaceSupportsOutput(CGColorSpaceRef space)
{
  if (space) {
    LOBYTE(space) = *(unsigned char *)(*((void *)space + 3) + 10) != 0;
  }
  return (char)space;
}

const void *CGImageGetProperty(uint64_t a1, const void *a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 216)) != 0) {
    return CGPropertiesGetProperty(v2, a2);
  }
  else {
    return 0;
  }
}

size_t CGImageGetBitsPerPixel(size_t image)
{
  if (image) {
    return *(void *)(image + 64);
  }
  return image;
}

unint64_t CGBitmapGetAlignedBytesPerRow(uint64_t a1)
{
  return (a1 + 31) & 0xFFFFFFFFFFFFFFE0;
}

void CGColorTransformRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  if (space) {
    CFRetain(space);
  }
  return space;
}

uint64_t CGStyleGetColor(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t compare_key(const char *a1, uint64_t a2)
{
  return strcmp(a1, *(const char **)(*(void *)a2 + 32));
}

size_t CGImageGetBitsPerComponent(size_t image)
{
  if (image) {
    return *(void *)(image + 56);
  }
  return image;
}

CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform *t)
{
  CGFloat v2 = size.height * t->c + t->a * size.width;
  double v3 = size.height * t->d + t->b * size.width;
  double v4 = v2;
  result.height = v3;
  result.width = v4;
  return result;
}

Swift::Void __swiftcall CGMutablePathRef.addLine(to:transform:)(CGPoint to, CGAffineTransform *transform)
{
  long long v3 = *(_OWORD *)&transform->c;
  *(_OWORD *)&v4.double a = *(_OWORD *)&transform->a;
  *(_OWORD *)&v4.double c = v3;
  *(_OWORD *)&v4.double tx = *(_OWORD *)&transform->tx;
  CGPathAddLineToPoint(v2, &v4, to.x, to.y);
}

Swift::Void __swiftcall CGMutablePathRef.move(to:transform:)(CGPoint to, CGAffineTransform *transform)
{
  long long v3 = *(_OWORD *)&transform->c;
  *(_OWORD *)&v4.double a = *(_OWORD *)&transform->a;
  *(_OWORD *)&v4.double c = v3;
  *(_OWORD *)&v4.double tx = *(_OWORD *)&transform->tx;
  CGPathMoveToPoint(v2, &v4, to.x, to.y);
}

uint64_t sub_184C04A2C(_OWORD *a1, uint64_t (*a2)(uint64_t, _OWORD *))
{
  long long v3 = a1[1];
  v5[0] = *a1;
  v5[1] = v3;
  v5[2] = a1[2];
  return a2(v2, v5);
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.origin.x + rect.size.width;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    *(void *)&rect.origin.x = (unint64_t)CGRectStandardize(rect);
  }
  return rect.origin.x;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.origin.y;
}

void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      Mutable = (CGPath *)*((void *)c + 21);
      if (!Mutable)
      {
        Mutable = CGPathCreateMutable();
        *((void *)c + 21) = Mutable;
      }
      std::string::size_type v21 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
      CGPathAddArc(Mutable, v21, x, y, radius, startAngle, endAngle, clockwise != 0);
      return;
    }
    CGContextRef v22 = c;
  }
  else
  {
    CGContextRef v22 = 0;
  }

  handle_invalid_context((char)"CGContextAddArc", (uint64_t)v22, v7, v8, v9, v10, v11, v12);
}

void CGPathAddEllipseInRect(CGMutablePathRef path, const CGAffineTransform *m, CGRect rect)
{
  if (path)
  {
    CGFloat height = rect.size.height;
    CGFloat width = rect.size.width;
    CGFloat y = rect.origin.y;
    CGFloat x = rect.origin.x;
    if (CGPathDisableTypeValidation || (CFTypeID v15 = CFGetTypeID(path), v15 == CGPathGetTypeID()))
    {
      {
        v17.origin.CGFloat x = x;
        v17.origin.CGFloat y = y;
        v17.size.CGFloat width = width;
        v17.size.CGFloat height = height;
        CGRect v16 = CGRectStandardize(v17);
        CG::Path::append_ellipse((CGMutablePathRef)((char *)path + 16), &v16, 1, 0, m);
      }
    }
  }
}

CGColorRef CGColorCreateCopyWithAlpha(CGColorRef color, CGFloat alpha)
{
  CGColorRef v10 = color;
  v41[1] = *MEMORY[0x1E4F143B8];
  if (((unint64_t)color & 0x8000000000000000) != 0)
  {
    if (CGTaggedColorGetAlpha((unint64_t)color, v2, v3, v4, v5, v6, v7, v8) != alpha)
    {
      uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
      MEMORY[0x1F4188790](NumberOfComponents, v19);
      std::string::size_type v21 = (char *)v41 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v21, v20);
      CGTaggedColorGetComponents((unint64_t)v10, (uint64_t)v21, v22, v23, v24, v25, v26, v27);
      *(CGFloat *)&v21[8 * NumberOfComponents - 8] = alpha;
      ColorSpace = CGTaggedColorGetColorSpace((unint64_t)v10, v28, v29, v30, v31, v32, v33, v34);
      return CGColorCreate(ColorSpace, (const CGFloat *)v21);
    }
LABEL_6:
    CFRetain(v10);
    return v10;
  }
  if (!color) {
    return v10;
  }
  uint64_t v36 = (const CGFloat *)((char *)color + 64);
  if (*((double *)color + *((void *)color + 7) + 7) == alpha) {
    goto LABEL_6;
  }
  uint64_t v38 = (CGColorSpace *)*((void *)color + 3);
  uint64_t v39 = (CGPattern *)*((void *)v10 + 4);
  if (v39) {
    CGColorRef v40 = CGColorCreateWithPattern(v38, v39, v36);
  }
  else {
    CGColorRef v40 = CGColorCreate(v38, (const CGFloat *)v10 + 8);
  }
  CGColorRef v10 = v40;
  if (v40) {
    *((CGFloat *)v40 + *((void *)v40 + 7) + 7) = alpha;
  }
  return v10;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  return rect.size.width;
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
    return 0;
  CFTypeID TypeID = CGPathGetTypeID();
  Instance = (const CGPath *)CGTypeCreateInstance(TypeID, 88, v15, v16, v17, v18, v19, v20);
  if (Instance)
  {
    v24.origin.CGFloat x = x;
    v24.origin.CGFloat y = y;
    v24.size.CGFloat width = width;
    v24.size.CGFloat height = height;
    CGRect v23 = CGRectStandardize(v24);
    CG::Path::append_rect((uint64_t)Instance + 16, &v23, (float64x2_t *)transform);
  }
  return Instance;
}

uint64_t CG::Path::append_rect(uint64_t this, const CGRect *a2, float64x2_t *a3)
{
  uint64_t v5 = (int *)this;
  if (*(_DWORD *)this)
  {
    CG::Path::reserve_space((CG::Path *)this, 5uLL, 5uLL);
    CG::Path::move_to_point(v5, a3, v6, (__n128)a2->origin);
    CG::Path::add_line_to_point((CG::Path *)v5, (const CGPoint *)a3, v7);
    CG::Path::add_line_to_point((CG::Path *)v5, (const CGPoint *)a3, v8);
    CG::Path::add_line_to_point((CG::Path *)v5, (const CGPoint *)a3, v9);
    return CG::Path::close_subpath((uint64_t)v5);
  }
  else
  {
    CGPoint origin = a2->origin;
    _D2 = a2->size.width;
    _D1 = a2->size.height;
    *(_DWORD *)this = 1;
    if (a3)
    {
      _Q5 = *a3;
      float64x2_t v14 = a3[1];
      _D16 = 0;
      __asm { FMLA            D4, D2, V5.D[1] }
      double v21 = vmlad_n_f64(_D1 * v14.f64[0], 0.0, a3->f64[0]);
      __asm { FMLA            D1, D16, V5.D[1] }
      CGPoint origin = (CGPoint)vaddq_f64(a3[2], vmlaq_n_f64(vmulq_laneq_f64(v14, (float64x2_t)origin, 1), *a3, origin.x));
      _D2 = vmlad_n_f64(0.0 * v14.f64[0], _D2, a3->f64[0]);
    }
    else
    {
      double v21 = 0.0;
      _D4 = 0;
    }
    *(double *)(this + 8) = _D2;
    *(void *)(this + 16) = _D4;
    *(double *)(this + 24) = v21;
    *(double *)(this + 32) = _D1;
    *(CGPoint *)(this + 40) = origin;
  }
  return this;
}

char *subImageProviderCopyImageBlockSet(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, const __CFDictionary *a7)
{
  valuePtr[1] = *MEMORY[0x1E4F143B8];
  valuePtr[0] = 0;
  CGRect v65 = CGRectStandardize(*(CGRect *)&a2);
  CGRect v71 = *(CGRect *)(a1 + 152);
  v65.origin.CGFloat x = v71.origin.x + v65.origin.x;
  v65.origin.CGFloat y = v65.origin.y + v71.origin.y;
  CGRect v66 = CGRectIntersection(v65, v71);
  CGFloat y = v66.origin.y;
  CGFloat x = v66.origin.x;
  CGFloat height = v66.size.height;
  CGFloat width = v66.size.width;
  uint64_t v9 = *(void *)(a1 + 48);
  CGColorRef v10 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
  if (a7)
  {
    CFStringRef Value = CFDictionaryGetValue(a7, @"kCGImageBlockFormatRequest");
    if (Value && CFEqual(Value, @"kCGImageBlockFormatBGRx8")) {
      uint64_t v9 = 4;
    }
    CFNumberRef v12 = (const __CFNumber *)CFDictionaryGetValue(a7, @"kCGImageBlockBaseAddressAlignmentRequest");
    if (v12) {
      CFNumberGetValue(v12, kCFNumberCFIndexType, valuePtr);
    }
    CFAllocatorRef v13 = *v10;
    MutableCopCGFloat y = CFDictionaryCreateMutableCopy(v13, 0, a7);
  }
  else
  {
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    MutableCopCGFloat y = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  uint64_t v15 = MutableCopy;
  uint64_t v63 = 0;
  CFNumberRef v16 = CFNumberCreate(v13, kCFNumberLongType, &v63);
  CFDictionarySetValue(v15, @"kCGImageBlockTileRequest", v16);
  if (v16) {
    CFRelease(v16);
  }
  uint64_t v17 = CGImageProviderCopyImageBlockSetWithOptions(*(void *)(a1 + 144), (uint64_t)v15);
  uint64_t v19 = v17;
  if (v15) {
    CFRelease(v15);
  }
  if (!v19)
  {
    uint64_t v17 = CGImageProviderCopyImageBlockSetWithOptions(*(void *)(a1 + 144), (uint64_t)a7);
    uint64_t v19 = v17;
    if (!v17) {
      return 0;
    }
  }
  uint64_t v20 = *(void *)(v19 + 120);
  MEMORY[0x1F4188790](v17, v18);
  CGRect v23 = (char *)&v58 - v22;
  if (v21 <= 0x1FFFFFFFFFFFFFFELL) {
    CGRect v24 = (char *)&v58 - v22;
  }
  else {
    CGRect v24 = 0;
  }
  if (v21 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
    CGRect v24 = (char *)malloc_type_malloc(8 * v20, 0x4B848ADEuLL);
  }
  if (v20)
  {
    uint64_t v58 = (uint64_t)&v58;
    unint64_t v25 = 0;
    uint64_t v26 = 0;
    do
    {
      if (v19)
      {
        if (*(void *)(v19 + 120) > v25)
        {
          uint64_t v27 = *(void *)(v19 + 8 * v25 + 128);
          if (v27)
          {
            double v29 = *(double *)(v27 + 8);
            double v28 = *(double *)(v27 + 16);
            double v30 = *(double *)(v27 + 24);
            double v31 = *(double *)(a1 + 152);
            double v32 = *(double *)(a1 + 160);
            v72.size.CGFloat width = *(CGFloat *)(a1 + 168);
            v72.size.CGFloat height = *(CGFloat *)(a1 + 176);
            v67.origin.CGFloat x = v29;
            v67.origin.CGFloat y = v28;
            v67.size.CGFloat width = v30;
            v67.size.CGFloat height = *(CGFloat *)(v27 + 32);
            v72.origin.CGFloat x = v31;
            v72.origin.CGFloat y = v32;
            CGRect v68 = CGRectIntersection(v67, v72);
            CGFloat v39 = v68.size.width;
            BOOL v40 = v68.origin.x == INFINITY || v68.origin.y == INFINITY;
            if (!v40 && *(void *)v27)
            {
              unint64_t v41 = *(void *)(v27 + 40);
              if (v41 >= v9 * (uint64_t)v30)
              {
                CGFloat v42 = v68.size.height;
                unint64_t v43 = *(void *)v27 + v9 * (uint64_t)(v68.origin.x - v29) + v41 * (uint64_t)(v68.origin.y - v28);
                if (valuePtr[0] && v43 % valuePtr[0])
                {
                  if (v26)
                  {
                    uint64_t v55 = v24;
                    do
                    {
                      uint64_t v56 = (void *)*v55;
                      if (*v55)
                      {
                        int v57 = (void (*)(void, void))v56[9];
                        if (v57) {
                          v57(v56[7], *v55);
                        }
                        free(v56);
                      }
                      ++v55;
                      --v26;
                    }
                    while (v26);
                  }
                  goto LABEL_52;
                }
                double v44 = v68.origin.x - v31;
                double v45 = v68.origin.y - v32;
                uint64_t v46 = CGImageBlockCreate((void *)v43, v41, 0, 0, v68.origin.x - v31, v68.origin.y - v32, v68.size.width, v68.size.height);
                if (v46)
                {
                  uint64_t v47 = v46;
                  if (v26)
                  {
                    v69.origin.CGFloat y = y;
                    v69.origin.CGFloat x = x;
                    v69.size.CGFloat height = height;
                    v69.size.CGFloat width = width;
                    v73.origin.CGFloat x = v44;
                    v73.origin.CGFloat y = v45;
                    v73.size.CGFloat width = v39;
                    v73.size.CGFloat height = v42;
                    CGRect v70 = CGRectUnion(v69, v73);
                    CGFloat y = v70.origin.y;
                    CGFloat x = v70.origin.x;
                    CGFloat v39 = v70.size.width;
                    CGFloat v42 = v70.size.height;
                  }
                  else
                  {
                    CGFloat y = v45;
                    CGFloat x = v44;
                  }
                  *(void *)&v24[8 * v26++] = v47;
                  CGFloat height = v42;
                  CGFloat width = v39;
                }
              }
              else
              {
                CGPostError((uint64_t)"CGImageProviderCopyImageBlockSet: invalid bytes/row.\nCGImageProviderCopyImageBlockSet(<CGImageProvider %p>):\n\t<CGImageBlockSet %p> (count = %ld) [%ld]:\n\t\t<CGImageBlock %p> (size = %ld x %ld, pixel-size = %ld, datdouble a = %p, bytes-per-row = %ld)", v41, v33, v34, v35, v36, v37, v38, *(void *)(a1 + 144));
              }
            }
          }
        }
      }
      ++v25;
    }
    while (v20 != v25);
    if (!v26) {
      goto LABEL_52;
    }
    uint64_t v48 = *(void *)(a1 + 144);
    if (v48) {
      int v49 = *(_DWORD *)(v48 + 36);
    }
    else {
      int v49 = 0;
    }
    uint64_t v50 = CGImageBlockSetCreateWithBitmapInfo(v48, 0, v49, 0, 0, v26, (uint64_t)v24, v19, *(double *)(a1 + 168), *(double *)(a1 + 176), x, y, width, height, subImageBlockSetCallbacks);
    if (!v50)
    {
      uint64_t v51 = v24;
      do
      {
        uint64_t v52 = (void *)*v51;
        if (*v51)
        {
          uint64_t v53 = (void (*)(void, void))v52[9];
          if (v53) {
            v53(v52[7], *v51);
          }
          free(v52);
        }
        ++v51;
        --v26;
      }
      while (v26);
      goto LABEL_52;
    }
  }
  else
  {
LABEL_52:
    CGImageBlockSetRelease(v19);
    uint64_t v50 = 0;
  }
  if (v24 != v23) {
    free(v24);
  }
  return v50;
}

void *CGImageBlockCreate(void *result, uint64_t a2, uint64_t a3, _DWORD *a4, double a5, double a6, double a7, double a8)
{
  if (result)
  {
    uint64_t v11 = result;
    if (a4 && *a4) {
      return 0;
    }
    CGRect v17 = CGRectStandardize(*(CGRect *)&a5);
    CGFloat x = v17.origin.x;
    CGFloat y = v17.origin.y;
    CGFloat width = v17.size.width;
    CGFloat height = v17.size.height;
    if (v17.size.width < 0.0 || v17.size.height < 0.0)
    {
      CGRect v18 = CGRectStandardize(v17);
      if (v18.size.width == 0.0) {
        return 0;
      }
      v19.origin.CGFloat x = x;
      v19.origin.CGFloat y = y;
      v19.size.CGFloat width = width;
      v19.size.CGFloat height = height;
      CGRect v17 = CGRectStandardize(v19);
    }
    else if (v17.size.width == 0.0)
    {
      return 0;
    }
    if (v17.size.height != 0.0)
    {
      v20.origin.CGFloat x = x;
      v20.origin.CGFloat y = y;
      v20.size.CGFloat width = width;
      v20.size.CGFloat height = height;
      CGRect v22 = CGRectIntegral(v20);
      v21.origin.CGFloat x = x;
      v21.origin.CGFloat y = y;
      v21.size.CGFloat width = width;
      v21.size.CGFloat height = height;
      if (CGRectEqualToRect(v21, v22))
      {
        CGSize result = malloc_type_malloc(0x50uLL, 0x2062DE7BuLL);
        *CGSize result = v11;
        *((CGFloat *)result + 1) = x;
        *((CGFloat *)result + 2) = y;
        *((CGFloat *)result + 3) = width;
        *((CGFloat *)result + 4) = height;
        result[5] = a2;
        CFNumberRef v16 = result + 8;
        result[7] = a3;
        if (a4)
        {
          *CFNumberRef v16 = *(_OWORD *)a4;
        }
        else
        {
          *(void *)CFNumberRef v16 = 0;
          result[9] = 0;
        }
        return result;
      }
    }
    return 0;
  }
  return result;
}

CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform *transform)
{
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
    return 0;
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 88, v15, v16, v17, v18, v19, v20);
  if (Instance)
  {
    v24.origin.CGFloat x = x;
    v24.origin.CGFloat y = y;
    v24.size.CGFloat width = width;
    v24.size.CGFloat height = height;
    CGRect v23 = CGRectStandardize(v24);
    CG::Path::append_ellipse((CG::Path *)(Instance + 16), &v23, 1, 0, transform);
  }
  return (CGPathRef)Instance;
}

CGRect CGRectStandardize(CGRect rect)
{
  double width = rect.size.width;
  double y = rect.origin.y;
  double v3 = INFINITY;
  if (rect.origin.x == INFINITY || y == INFINITY)
  {
    double v5 = 0.0;
    rect.size.double width = 0.0;
    double v6 = INFINITY;
  }
  else
  {
    if (rect.size.width < 0.0) {
      rect.size.double width = -rect.size.width;
    }
    double height = -0.0;
    if (width >= 0.0) {
      double width = -0.0;
    }
    double v6 = rect.origin.x + width;
    double v5 = -rect.size.height;
    if (rect.size.height < 0.0) {
      double height = rect.size.height;
    }
    else {
      double v5 = rect.size.height;
    }
    double v3 = y + height;
  }
  double v8 = v5;
  rect.size.double height = v8;
  rect.origin.double y = v3;
  rect.origin.CGFloat x = v6;
  return rect;
}

void imageProvider_release_data(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    CGImageBlockSetRelease(v2);
    *(void *)(a1 + 8) = 0;
  }
}

void CGImageBlockSetRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CGPropertiesRelease(*(CFTypeRef **)(a1 + 88));
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 80));
    unint64_t v2 = *(void *)(a1 + 120);
    if (v2)
    {
      for (unint64_t i = 0; i < v2; ++i)
      {
        uint64_t v4 = *(void **)(a1 + 128 + 8 * i);
        if (v4)
        {
          double v5 = (void (*)(void, void))v4[9];
          if (v5) {
            v5(v4[7], *(void *)(a1 + 128 + 8 * i));
          }
          free(v4);
          unint64_t v2 = *(void *)(a1 + 120);
        }
      }
    }
    double v6 = *(void (**)(void))(a1 + 112);
    if (v6) {
      v6(*(void *)(a1 + 96));
    }
    uint64_t v7 = *(const void **)(a1 + 8);
    if (v7) {
      CFRelease(v7);
    }
    free((void *)a1);
  }
}

uint64_t imageProvider_retain_data(uint64_t result)
{
  if (!*(void *)(result + 8))
  {
    double v1 = (uint64_t *)result;
    if (*(unsigned char *)(result + 80))
    {
      uint64_t v2 = 0;
    }
    else
    {
      if (get_provider_options_predicate != -1) {
        dispatch_once(&get_provider_options_predicate, &__block_literal_global_21285);
      }
      uint64_t v2 = get_provider_options_options_singleton;
    }
    CGSize result = CGImageProviderCopyImageBlockSetWithOptions(*v1, v2);
    v1[1] = result;
    if (!result)
    {
      CGSize result = CGImageProviderCopyImageBlockSetWithOptions(*v1, 0);
      v1[1] = result;
    }
  }
  return result;
}

uint64_t CGImageProviderCopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  switch(*(_DWORD *)(a1 + 64))
  {
    case 0:
      if (a2) {
        return 0;
      }
      break;
    case 1:
    case 2:
    case 3:
      return (*(uint64_t (**)(void))(a1 + 72))(*(void *)(a1 + 56));
    default:
      return 0;
  }
  return (*(uint64_t (**)(void))(a1 + 72))(*(void *)(a1 + 56));
}

void CGContextAddPath(CGContextRef c, CGPathRef path)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      if (path)
      {
        if (CGPathDisableTypeValidation || (CFTypeID v10 = CFGetTypeID(path), v10 == CGPathGetTypeID()))
        {
          uint64_t v11 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
          CFNumberRef v12 = (CGPath *)*((void *)c + 21);
          if (v12)
          {
            CGPathAddPath(v12, v11, path);
          }
          else
          {
            *((void *)c + 21) = CGPathCreateMutableCopyByTransformingPath(path, v11);
          }
        }
      }
      return;
    }
    CGContextRef v13 = c;
  }
  else
  {
    CGContextRef v13 = 0;
  }

  handle_invalid_context((char)"CGContextAddPath", (uint64_t)v13, v2, v3, v4, v5, v6, v7);
}

void CGPathAddArcToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius)
{
  if (path)
  {
    CGMutablePathRef v19 = path;
    if (CGPathDisableTypeValidation
      || (uint64_t v20 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v20 == path))
    {
      BOOL v21 = CGFloatValidateWithLog(x1, (uint64_t)path, (uint64_t)m, v7, v8, v9, v10, v11, v12);
      if (v21)
      {
        BOOL v29 = CGFloatValidateWithLog(y1, v21, v22, v23, v24, v25, v26, v27, v28);
        if (v29)
        {
          BOOL v37 = CGFloatValidateWithLog(x2, v29, v30, v31, v32, v33, v34, v35, v36);
          if (v37 {
            && CGFloatValidateWithLog(y2, v37, v38, v39, v40, v41, v42, v43, v44)
          }
          {
            int v60 = *((_DWORD *)v19 + 4);
            BOOL v59 = (CGMutablePathRef)((char *)v19 + 16);
            if ((v60 - 10) > 0xFFFFFFF6)
            {
              v62.CGFloat x = x1;
              v62.double y = y1;
              v61.CGFloat x = x2;
              v61.double y = y2;
              CG::Path::add_arc_to_point(v59, &v62, &v61, radius, (CGAffineTransform *)m, v55, v56, v57, v58);
            }
            else
            {
              CGPostError((uint64_t)"%s: no current point.", v52, v53, v54, v55, v56, v57, v58, (char)"CGPathAddArcToPoint");
            }
          }
        }
      }
    }
  }
}

void CG::Path::add_arc_to_point(CG::Path *this, const CGPoint *a2, const CGPoint *a3, double a4, CGAffineTransform *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)&double v21 = *(_OWORD *)&CG::Path::current_point(this, (uint64_t)a2, (uint64_t)a3, (uint64_t)a5, a6, a7, a8, a9);
  if (a5)
  {
    long long v23 = *(_OWORD *)&a5->c;
    v53[0] = *(_OWORD *)&a5->a;
    v53[1] = v23;
    v53[2] = *(_OWORD *)&a5->tx;
    double v21 = CGPointApplyInverseAffineTransform((double *)v53, v14, v15, v16, v17, v18, v19, v20, v21, v22);
  }
  CGFloat v24 = a2->x - v21;
  CGFloat v25 = a2->y - v22;
  double v50 = v21;
  double v51 = v22;
  double v26 = a3->x - v21;
  double v27 = a3->y - v22;
  if (v24 != 0.0 || (double v28 = 0.0, v29 = 0.0, v25 != 0.0))
  {
    double v28 = atan2(v25, v24);
    double v29 = a4;
  }
  double v48 = v29;
  double v49 = v28;
  __double2 v30 = __sincos_stret(v28);
  double v31 = 0.0;
  double v32 = v25 * v30.__sinval + v30.__cosval * v24 + 0.0;
  double v33 = v25 * v30.__cosval - v30.__sinval * v24 + 0.0;
  double v34 = v27 * v30.__sinval + v30.__cosval * v26 + 0.0;
  double v35 = v27 * v30.__cosval - v30.__sinval * v26 + 0.0;
  BOOL v36 = v32 == v34 && v33 == v35;
  double v37 = 0.0;
  if (!v36) {
    double v37 = 3.14159265 - fabs(atan2(v35 - v33, v34 - v32));
  }
  double v42 = sin(v37 * 0.5);
  if (v42 == 0.0)
  {
    double v43 = v33;
    double v44 = 0.0;
    float64_t v45 = 0.0;
    double v46 = v35;
  }
  else
  {
    double v47 = fabs(cos(v37 * 0.5) / v42);
    float64_t v45 = v48;
    double v32 = v32 - v48 * v47;
    double v46 = v35;
    if (v35 <= v33)
    {
      double v43 = -v48;
      double v44 = v37 + -1.57079633;
      double v31 = 1.57079633;
    }
    else
    {
      double v44 = 1.57079633 - v37;
      double v31 = -1.57079633;
      double v43 = v48;
    }
  }
  v52.CGFloat x = v50 + v43 * -v30.__sinval + v30.__cosval * v32 + 0.0;
  v52.double y = v51 + v43 * v30.__cosval + v30.__sinval * v32 + 0.0;
  CG::Path::add_arc(this, (float64x2_t *)&v52, v45, v49 + v31, v49 + v44, v46 <= v33, a5, v38, v39, v40, v41);
}

CGPoint CGPathGetCurrentPoint(CGPathRef path)
{
  if (path
    && (CGPathDisableTypeValidation || (CFTypeID v9 = CFGetTypeID(path), v9 == CGPathGetTypeID()))
    && (v11 = *((_DWORD *)path + 4), uint64_t v10 = (CGPathRef)((char *)path + 16), (v11 - 10) > 0xFFFFFFF6))
  {
    *(void *)&double v12 = *(_OWORD *)&CG::Path::current_point(v10, v1, v2, v3, v4, v5, v6, v7);
  }
  else
  {
    CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGPathGetCurrentPoint");
    double v12 = 0.0;
    double v13 = 0.0;
  }
  result.double y = v13;
  result.CGFloat x = v12;
  return result;
}

float64x2_t CG::Path::current_point(CG::Path *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float64x2_t result = 0uLL;
  switch(*(_DWORD *)this)
  {
    case 0:
      return result;
    case 1:
      return *(float64x2_t *)((char *)this + 40);
    case 2:
    case 4:
      __asm { FMOV            V3.2D, #0.5 }
      return vaddq_f64(*(float64x2_t *)((char *)this + 40), vaddq_f64(*(float64x2_t *)((char *)this + 8), vmulq_f64(*(float64x2_t *)((char *)this + 24), _Q3)));
    case 3:
      return vaddq_f64(*(float64x2_t *)((char *)this + 40), vaddq_f64(*(float64x2_t *)((char *)this + 8), vmulq_n_f64(*(float64x2_t *)((char *)this + 24), (1.0 - *((double *)this + 10) + *((double *)this + 12)) * 0.5)));
    case 5:
      return *(float64x2_t *)((char *)this + 24);
    case 6:
      return vaddq_f64(*(float64x2_t *)((char *)this + 40), vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)((char *)this + 24), *((double *)this + 9)), *(float64x2_t *)((char *)this + 8), *((double *)this + 8)));
    case 7:
      uint64_t v14 = (const void *)CGSRegionPathEnumerator(*((void **)this + 1));
      for (unsigned int i = 0; ; i |= v17)
      {
        int v16 = CGSNextPoint((uint64_t)v14, (double *)v25.i64);
        if (!v16) {
          break;
        }
        unsigned int v17 = v16 < 0;
        int32x2_t v18 = vdup_n_s32(v17);
        v19.i64[0] = v18.u32[0];
        v19.i64[1] = v18.u32[1];
        int8x16_t v24 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v19, 0x3FuLL)), v25, v24);
      }
      CGSReleaseRegionEnumerator(v14);
      int32x2_t v22 = vdup_n_s32(i);
      v23.i64[0] = v22.u32[0];
      v23.i64[1] = v22.u32[1];
      return (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v23, 0x3FuLL)), v24, v25);
    case 8:
      if (*((_WORD *)this + 4)) {
        uint64_t v20 = (const CGPoint *)((char *)this + 16 * *((unsigned __int16 *)this + 4));
      }
      else {
        uint64_t v20 = &CGPointZero;
      }
      return *(float64x2_t *)v20;
    case 9:
      uint64_t v21 = *((void *)this + 1);
      if (v21) {
        uint64_t v20 = (const CGPoint *)(*((void *)this + 4) + 16 * v21 - 16);
      }
      else {
        uint64_t v20 = &CGPointZero;
      }
      return *(float64x2_t *)v20;
    default:
      _CGHandleAssert("current_point", 1593, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path.cc", "0", "unhandled type %u", a6, a7, a8, *(_DWORD *)this);
  }
}

void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, BOOL clockwise)
{
  if (path)
  {
    BOOL v13 = clockwise;
    CGMutablePathRef v20 = path;
    if (CGPathDisableTypeValidation
      || (uint64_t v21 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v21 == path))
    {
      BOOL v22 = CGFloatValidateWithLog(x, (uint64_t)path, (uint64_t)m, clockwise, v8, v9, v10, v11, v12);
      if (v22 {
        && CGFloatValidateWithLog(y, v22, v23, v24, v25, v26, v27, v28, v29)
      }
      {
        if (fabs(startAngle) > 6283.18531 || fabs(endAngle) > 6283.18531)
        {
          CGPostError((uint64_t)"%s: invalid value for start or end angle.", v37, v38, v39, v40, v41, v42, v43, (char)"CGPathAddArc");
        }
        else
        {
          v44.CGFloat x = x;
          v44.double y = y;
          CG::Path::add_arc((CGMutablePathRef)((char *)v20 + 16), (float64x2_t *)&v44, radius, startAngle, endAngle, v13, (CGAffineTransform *)m, v40, v41, v42, v43);
        }
      }
    }
  }
}

void CG::Path::add_arc(CG::Path *this, float64x2_t *a2, float64_t a3, double a4, double a5, int a6, CGAffineTransform *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if ((*(_DWORD *)this - 10) <= 0xFFFFFFF6)
  {
    double v12 = a5 + -6.28318531;
    if (a4 == 0.0 && a5 >= 6.28318531 && v12 < 0.000001 && a6 != 0)
    {
      v17.CGPoint origin = (CGPoint)vsubq_f64(*a2, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a3, 0));
      v17.size.double width = a3 + a3;
      v17.size.double height = a3 + a3;
      int v14 = 1;
LABEL_16:
      CG::Path::append_ellipse(this, &v17, 0, v14, a7);
      return;
    }
    if (a4 == 0.0 && fabs(v12) < 0.000001 && a6 == 0)
    {
      v17.CGPoint origin = (CGPoint)vsubq_f64(*a2, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a3, 0));
      v17.size.double width = a3 + a3;
      v17.size.double height = a3 + a3;
      int v14 = 0;
      goto LABEL_16;
    }
  }
  if (a6)
  {
    if (a4 < a5)
    {
      a4 = a4 + ceil((a4 - a5) / -6.28318531) * 6.28318531;
      if (a4 < a5) {
        _CGHandleAssert("add_arc", 35, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path-subpath-arc.cc", "start >= end", "clockwise: start angle %f not less than end angle %f", a9, a10, a11, SLOBYTE(a4));
      }
    }
  }
  else if (a5 < a4)
  {
    a5 = a5 + ceil((a5 - a4) / -6.28318531) * 6.28318531;
    if (a5 < a4) {
      _CGHandleAssert("add_arc", 41, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Paths/path-subpath-arc.cc", "end >= start", "widdershins: end angle %f not less than start angle %f", a9, a10, a11, SLOBYTE(a5));
    }
  }
  double v16 = a5 - a4;

  CG::Path::add_arc_relative(this, a2, a3, a4, v16, (CGPoint *)a7, 0);
}

CGPoint CGContextConvertPointToUserSpace(CGContextRef c, CGPoint point)
{
  double y = point.y;
  double x = point.x;
  memset(&v21, 0, sizeof(v21));
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    CGContextGetUserSpaceToDeviceSpaceTransform(&v21, c);
    CGAffineTransform v20 = v21;
    double x = CGPointApplyInverseAffineTransform(&v20.a, v10, v11, v12, v13, v14, v15, v16, x, y);
    double y = v17;
  }
  else
  {
    handle_invalid_context((char)"CGContextConvertPointToUserSpace", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
  double v18 = x;
  double v19 = y;
  result.double y = v19;
  result.double x = v18;
  return result;
}

double CGPointApplyInverseAffineTransform(double *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  double v11 = a9;
  double v12 = a1[2];
  double v13 = a1[3];
  double v14 = *a1 * v13 - a1[1] * v12;
  if (v14 != 0.0) {
    return (v13 * (a9 - a1[4]) - v12 * (a10 - a1[5])) / v14;
  }
  CGPostError((uint64_t)"%s: singular matrix.", a2, a3, a4, a5, a6, a7, a8, (char)"CGPointApplyInverseAffineTransform");
  return v11;
}

CGPoint CGContextConvertPointToDeviceSpace(CGContextRef c, CGPoint point)
{
  double y = point.y;
  double x = point.x;
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    CGContextGetUserSpaceToDeviceSpaceTransform(&v13, c);
    double v10 = y * v13.d + v13.b * x;
    double x = v13.tx + y * v13.c + v13.a * x;
    double y = v13.ty + v10;
  }
  else
  {
    handle_invalid_context((char)"CGContextConvertPointToDeviceSpace", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
  double v11 = x;
  double v12 = y;
  result.double y = v12;
  result.double x = v11;
  return result;
}

CGAffineTransform *__cdecl CGContextGetUserSpaceToDeviceSpaceTransform(CGAffineTransform *__return_ptr retstr, CGContextRef c)
{
  memset(&v26, 0, sizeof(v26));
  if (!c)
  {
    CGContextRef v19 = 0;
LABEL_8:
    handle_invalid_context((char)"CGContextGetUserSpaceToDeviceSpaceTransform", (uint64_t)v19, v2, v3, v4, v5, v6, v7);
    *retstr = CGAffineTransformIdentity;
    return result;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v19 = c;
    goto LABEL_8;
  }
  CGPoint result = (CGAffineTransform *)*((void *)c + 5);
  double v11 = (double *)*((void *)c + 12);
  if (!result || (CGFloat v12 = result->ty, v12 == 0.0))
  {
    CGAffineTransform v26 = CGAffineTransformIdentity;
    double d = 1.0;
    double ty = 0.0;
    double tx = 0.0;
    double v16 = 0.0;
    double b = 0.0;
    double a = 1.0;
  }
  else
  {
    CGPoint result = (CGAffineTransform *)(*(void *(**)(CGAffineTransform *__return_ptr))&v12)(&v26);
    double v11 = (double *)*((void *)c + 12);
    double b = v26.b;
    double a = v26.a;
    double d = v26.d;
    double v16 = v26.c;
    double ty = v26.ty;
    double tx = v26.tx;
  }
  double v20 = v11[3];
  double v21 = v11[4];
  double v22 = v11[5];
  double v23 = v11[6];
  double v24 = v11[7];
  double v25 = v11[8];
  retstr->double a = v21 * v16 + v20 * a;
  retstr->double b = v21 * d + v20 * b;
  retstr->double c = v23 * v16 + v22 * a;
  retstr->double d = v23 * d + v22 * b;
  retstr->double tx = tx + v16 * v25 + v24 * a;
  retstr->double ty = d * v25 + v24 * b + ty;
  return result;
}

CGFloat ripc_GetTransform@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (a1) {
    uint64_t v3 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 48);
  if (v4
    && (v7 = 0, uint64_t v8 = 0, ((*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v4 + 72))(v4, &v7) & 1) != 0))
  {
    (*(void (**)(void, uint64_t))(**(void **)(v3 + 48) + 88))(*(void *)(v3 + 48), v3 + 40);
    CGFloat result = *(double *)(v3 + 40);
    double v6 = (double)SHIDWORD(v8);
    *(CGFloat *)a2 = result;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(CGFloat *)(a2 + 24) = -result;
    *(void *)(a2 + 32) = 0;
    *(double *)(a2 + 40) = v6;
  }
  else
  {
    *(CGAffineTransform *)a2 = CGAffineTransformIdentity;
    return CGAffineTransformIdentity.tx;
  }
  return result;
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  if (path)
  {
    CGMutablePathRef v11 = path;
    if (CGPathDisableTypeValidation
      || (CGFloat v12 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v12 == path))
    {
      BOOL v13 = CGFloatValidateWithLog(x, (uint64_t)path, (uint64_t)m, v4, v5, v6, v7, v8, v9);
      if (v13 {
        && CGFloatValidateWithLog(y, v13, v14, v15, v16, v17, v18, v19, v20)
      }
      {
        v29.n128_f64[0] = x;
        v29.n128_f64[1] = y;
        CG::Path::move_to_point((int *)v11 + 4, (float64x2_t *)m, v28, v29);
      }
    }
  }
}

void CG::Path::add_arc_relative(CG::Path *this, float64x2_t *a2, float64_t a3, double a4, double a5, CGPoint *a6, int a7)
{
  double v9 = a5;
  int v13 = *(_DWORD *)this;
  if (*(_DWORD *)this || (double v14 = fabs(a5), v14 > 7.85398163))
  {
    double v15 = fabs(a5);
    __double2 v17 = __sincos_stret(a4);
    double v18 = v17.__cosval * a3;
    double v19 = v17.__sinval * a3;
    v20.n128_f64[0] = v17.__cosval * a3 + a2->f64[0];
    v20.n128_f64[1] = v17.__sinval * a3 + a2->f64[1];
    BOOL v21 = (v13 - 10) >= 0xFFFFFFF7 && a7 == 0;
    CGPoint v56 = (CGPoint)v20;
    if (v21) {
      CG::Path::add_line_to_point(this, a6, v16);
    }
    else {
      CG::Path::move_to_point((int *)this, (float64x2_t *)a6, v16, v20);
    }
    double v23 = 1.57079633;
    if (v15 >= 1.57079633)
    {
      double v62 = dbl_1850CDFB0[v9 >= 0.0];
      double v61 = dbl_1850CDFC0[v9 >= 0.0];
      double v58 = v9;
      double v59 = -v61;
      double v28 = v9;
      double v26 = a4;
      CGPoint v27 = v56;
      do
      {
        double v29 = v23;
        if (v58 < 0.0) {
          double v24 = v19;
        }
        else {
          double v24 = -v19;
        }
        if (v58 < 0.0) {
          double v25 = -v18;
        }
        else {
          double v25 = v18;
        }
        v30.f64[0] = v27.x + v59 * v19;
        v30.f64[1] = v27.y + v61 * v18;
        CGFloat v31 = v25 + a2->f64[1];
        v65.double x = v24 + a2->f64[0];
        v65.double y = v31;
        v64.double x = v65.x + v61 * v25;
        v64.double y = v31 + v59 * v24;
        CG::Path::add_curve_to_point(this, (float64x2_t *)&v64, (float64x2_t *)&v65, (float64x2_t *)a6, v22, v30);
        double v23 = v29;
        double v26 = v62 + v26;
        double v9 = v28 - v62;
        CGPoint v27 = v65;
        double v15 = vabdd_f64(v28, v62);
        double v28 = v28 - v62;
        double v19 = v25;
        double v18 = v24;
      }
      while (v15 >= v23);
    }
    else
    {
      double v24 = v17.__cosval * a3;
      double v25 = v17.__sinval * a3;
      double v26 = a4;
      CGPoint v27 = v56;
    }
    if (v15 > 0.00000001)
    {
      double v32 = v26;
      CGPoint v57 = v27;
      __double2 v33 = __sincos_stret(v9 * 0.5);
      double v34 = (1.0 - v33.__cosval) * 4.0 / (v33.__sinval * 3.0);
      __double2 v35 = __sincos_stret(v9 + v32);
      v36.f64[0] = v57.x - v34 * v25;
      v36.f64[1] = v57.y + v34 * v24;
      CGFloat v37 = v35.__sinval * a3 + a2->f64[1];
      v65.double x = v35.__cosval * a3 + a2->f64[0];
      v65.double y = v37;
      v64.double x = v65.x + v34 * (v35.__sinval * a3);
      v64.double y = v37 - v34 * (v35.__cosval * a3);
      CG::Path::add_curve_to_point(this, (float64x2_t *)&v64, (float64x2_t *)&v65, (float64x2_t *)a6, v38, v36);
    }
  }
  else
  {
    double v39 = v14;
    if (v14 >= 1.57079633)
    {
      double v39 = v14;
      do
        double v39 = v39 + -1.57079633;
      while (v39 >= 1.57079633);
    }
    double v40 = v39 * 0.25;
    v41.f64[0] = 0.0;
    v41.f64[1] = a3;
    float64x2_t v60 = v41;
    float64x2_t v63 = *a2;
    __double2 v42 = __sincos_stret(a4);
    float64x2_t v43 = vmlaq_n_f64(vmulq_n_f64(v60, v42.__sinval), (float64x2_t)*(unint64_t *)&a3, v42.__cosval);
    float64x2_t v44 = vmlsq_lane_f64(vmulq_n_f64(v60, v42.__cosval), (float64x2_t)*(unint64_t *)&a3, v42.__sinval, 0);
    float64x2_t v45 = vaddq_f64(v63, vmlaq_f64(vmulq_f64(v60, (float64x2_t)0), (float64x2_t)0, (float64x2_t)*(unint64_t *)&a3));
    double v46 = v43.f64[1];
    double v47 = v45.f64[1];
    float64x2_t v48 = vnegq_f64(v44);
    if (v9 < 0.0)
    {
      double v49 = v48.f64[1];
    }
    else
    {
      v48.f64[0] = v44.f64[0];
      double v49 = v44.f64[1];
    }
    *(_DWORD *)this = 6;
    *((double *)this + 7) = v14;
    if (a6)
    {
      double y = a6->y;
      double x = a6[1].x;
      double v52 = a6[1].y;
      double v46 = v43.f64[1] * v52 + v43.f64[0] * y;
      v43.f64[0] = v43.f64[1] * x + v43.f64[0] * a6->x;
      double v53 = v49 * x;
      double v49 = v49 * v52 + v48.f64[0] * y;
      v48.f64[0] = v53 + v48.f64[0] * a6->x;
      double v47 = v52 * v45.f64[1] + v45.f64[0] * y + a6[2].y;
      v45.f64[0] = a6[2].x + x * v45.f64[1] + v45.f64[0] * a6->x;
    }
    *((void *)this + 1) = *(void *)&v43.f64[0];
    *((double *)this + 2) = v46;
    *((void *)this + 3) = *(void *)&v48.f64[0];
    *((double *)this + 4) = v49;
    *((void *)this + 5) = *(void *)&v45.f64[0];
    *((double *)this + 6) = v47;
    *((long double *)this + 8) = cos(v9);
    *((long double *)this + 9) = sin(v14);
    *((long double *)this + 10) = tan(v40) * 1.33333333;
  }
}

float64x2_t CG::Path::add_line_to_point(CG::Path *this, float64x2_t *a2, const CGAffineTransform *a3, float64x2_t result)
{
  if (a2) {
    CGFloat result = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_laneq_f64(a2[1], result, 1), *a2, result.f64[0]));
  }
  int v5 = *(_DWORD *)this;
  float64x2_t v12 = result;
  if (*(_DWORD *)this == 9) {
    goto LABEL_10;
  }
  if (v5 == 8) {
    goto LABEL_7;
  }
  if (!v5)
  {
    *(_DWORD *)this = 8;
LABEL_7:
    uint64_t v6 = *((unsigned __int16 *)this + 4);
    if (v6 <= 6)
    {
      *((_WORD *)this + 4) = v6 + 1;
      *((float64x2_t *)this + v6 + 1) = result;
      __int16 v7 = *((_WORD *)this + 5);
      *((_DWORD *)this + 3) |= 1 << (3 * v7);
      *((_WORD *)this + 5) = v7 + 1;
      return result;
    }
  }
  CG::Path::convert_to_huge_(this);
  CGFloat result = v12;
LABEL_10:
  *(int8x16_t *)((char *)this + 40) = vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)((char *)this + 40), result), (int8x16_t)result, *(int8x16_t *)((char *)this + 40));
  *(int8x16_t *)((char *)this + 56) = vbslq_s8((int8x16_t)vcgtq_f64(result, *(float64x2_t *)((char *)this + 56)), (int8x16_t)result, *(int8x16_t *)((char *)this + 56));
  CG::Path::reserve_space(this, 1, 1);
  uint64_t v8 = *((void *)this + 1);
  uint64_t v9 = *((void *)this + 2);
  uint64_t v11 = *((void *)this + 3);
  uint64_t v10 = *((void *)this + 4);
  CGFloat result = v12;
  *(float64x2_t *)(v10 + 16 * v8) = v12;
  *((void *)this + 1) = v8 + 1;
  *((void *)this + 2) = v9 + 1;
  *(unsigned char *)(v10 + v11 - (v9 + 1)) = 1;
  return result;
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  if (path)
  {
    CGMutablePathRef v19 = path;
    if (CGPathDisableTypeValidation
      || (__n128 v20 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v20 == path))
    {
      BOOL v21 = CGFloatValidateWithLog(x, (uint64_t)path, (uint64_t)m, v8, v9, v10, v11, v12, v13);
      if (v21 {
        && CGFloatValidateWithLog(y, v21, v22, v23, v24, v25, v26, v27, v28)
      }
      {
        int v44 = *((_DWORD *)v19 + 4);
        float64x2_t v43 = (CGMutablePathRef)((char *)v19 + 16);
        if ((v44 - 10) > 0xFFFFFFF6)
        {
          v45.f64[0] = cp1x;
          v45.f64[1] = cp1y;
          v49.double x = cp2x;
          v49.double y = cp2y;
          v48.double x = x;
          v48.double y = y;
          CG::Path::add_curve_to_point(v43, (float64x2_t *)&v49, (float64x2_t *)&v48, (float64x2_t *)m, v39, v45);
        }
        else
        {
          CGPostError((uint64_t)"%s: no current point.", v36, v37, v38, (uint64_t)v39, v40, v41, v42, (char)"CGPathAddCurveToPoint");
        }
      }
    }
  }
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  if (path)
  {
    CGMutablePathRef v11 = path;
    if (CGPathDisableTypeValidation
      || (uint64_t v12 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v12 == path))
    {
      BOOL v13 = CGFloatValidateWithLog(x, (uint64_t)path, (uint64_t)m, v4, v5, v6, v7, v8, v9);
      if (v13 {
        && CGFloatValidateWithLog(y, v13, v14, v15, v16, v17, v18, v19, v20)
      }
      {
        int v36 = *((_DWORD *)v11 + 4);
        uint64_t v35 = (CGMutablePathRef)((char *)v11 + 16);
        if ((v36 - 10) > 0xFFFFFFF6)
        {
          v37.f64[0] = x;
          v37.f64[1] = y;
          CG::Path::add_line_to_point(v35, (float64x2_t *)m, v29, v37);
        }
        else
        {
          CGPostError((uint64_t)"%s: no current point.", v28, (uint64_t)v29, v30, v31, v32, v33, v34, (char)"CGPathAddLineToPoint");
        }
      }
    }
  }
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  if (path)
  {
    CGMutablePathRef v15 = path;
    if (CGPathDisableTypeValidation
      || (uint64_t v16 = (CGPath *)CFGetTypeID(path), path = (CGMutablePathRef)CGPathGetTypeID(), v16 == path))
    {
      BOOL v17 = CGFloatValidateWithLog(x, (uint64_t)path, (uint64_t)m, v6, v7, v8, v9, v10, v11);
      if (v17 {
        && CGFloatValidateWithLog(y, v17, v18, v19, v20, v21, v22, v23, v24)
      }
      {
        int v40 = *((_DWORD *)v15 + 4);
        double v39 = (CGMutablePathRef)((char *)v15 + 16);
        if ((v40 - 10) > 0xFFFFFFF6)
        {
          v41.f64[0] = cpx;
          v41.f64[1] = cpy;
          v44.double x = x;
          v44.double y = y;
          CG::Path::add_quad_curve_to_point(v39, (float64x2_t *)&v44, (float64x2_t *)m, v34, v41);
        }
        else
        {
          CGPostError((uint64_t)"%s: no current point.", v32, v33, (uint64_t)v34, v35, v36, v37, v38, (char)"CGPathAddQuadCurveToPoint");
        }
      }
    }
  }
}

BOOL CGFloatValidateWithLog(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  double v9 = fabs(a1);
  if (v9 >= INFINITY && v9 <= INFINITY)
  {
    CGPostError((uint64_t)"Error: this application, or a library it uses, has passed an invalid numeric value (NaN, or not-a-number) to CoreGraphics API and this value is being ignored. Please fix this problem.", a3, a4, a5, a6, a7, a8, a9, v26);
    if (handle_invalid_numerics_predicate != -1) {
      dispatch_once(&handle_invalid_numerics_predicate, &__block_literal_global_6_19647);
    }
    if (handle_invalid_numerics_show_log)
    {
      BOOL v17 = CGBacktraceCreate(0);
      CGPostError((uint64_t)"Backtrace:\n%s\n", v18, v19, v20, v21, v22, v23, v24, (char)v17);
      free(v17);
    }
    else
    {
      CGPostError((uint64_t)"If you want to see the backtrace, please set CG_NUMERICS_SHOW_BACKTRACE environmental variable.\n", v10, v11, v12, v13, v14, v15, v16, v27);
    }
  }
  return v9 > INFINITY || v9 < INFINITY;
}

BOOL anonymous namespace'::transform_is_valid(_anonymous_namespace_ *this, const CGAffineTransform *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!this) {
    return 1;
  }
  BOOL result = CGFloatValidateWithLog(*(double *)this, (uint64_t)this, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    BOOL result = CGFloatValidateWithLog(*((double *)this + 1), result, v10, v11, v12, v13, v14, v15, v16);
    if (result)
    {
      BOOL result = CGFloatValidateWithLog(*((double *)this + 2), result, v17, v18, v19, v20, v21, v22, v23);
      if (result)
      {
        BOOL result = CGFloatValidateWithLog(*((double *)this + 3), result, v24, v25, v26, v27, v28, v29, v30);
        if (result)
        {
          BOOL result = CGFloatValidateWithLog(*((double *)this + 4), result, v31, v32, v33, v34, v35, v36, v37);
          if (result)
          {
            double v45 = *((double *)this + 5);
            return CGFloatValidateWithLog(v45, result, v38, v39, v40, v41, v42, v43, v44);
          }
        }
      }
    }
  }
  return result;
}

float64x2_t CG::Path::add_quad_curve_to_point(CG::Path *this, float64x2_t *a2, float64x2_t *a3, const CGAffineTransform *a4, float64x2_t result)
{
  if (a3)
  {
    float64x2_t v6 = a3[1];
    float64x2_t v7 = a3[2];
    BOOL result = vaddq_f64(v7, vmlaq_n_f64(vmulq_laneq_f64(v6, result, 1), *a3, result.f64[0]));
    float64x2_t v8 = vaddq_f64(v7, vmlaq_n_f64(vmulq_n_f64(v6, a2->f64[1]), *a3, a2->f64[0]));
  }
  else
  {
    float64x2_t v8 = *a2;
  }
  int v9 = *(_DWORD *)this;
  float64x2_t v19 = v8;
  float64x2_t v20 = result;
  if (*(_DWORD *)this == 9) {
    goto LABEL_11;
  }
  if (v9 == 8) {
    goto LABEL_8;
  }
  if (!v9)
  {
    *(_DWORD *)this = 8;
LABEL_8:
    uint64_t v10 = *((unsigned __int16 *)this + 4);
    if (v10 <= 5)
    {
      *((float64x2_t *)this + v10 + 1) = result;
      *((_WORD *)this + 4) = v10 + 2;
      *((float64x2_t *)this + v10 + 2) = v8;
      __int16 v11 = *((_WORD *)this + 5);
      *((_DWORD *)this + 3) |= 2 << (3 * v11);
      *((_WORD *)this + 5) = v11 + 1;
      return result;
    }
  }
  CG::Path::convert_to_huge_(this);
  float64x2_t v8 = v19;
  BOOL result = v20;
LABEL_11:
  float64x2_t v12 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)((char *)this + 40), result), (int8x16_t)result, *(int8x16_t *)((char *)this + 40));
  *(int8x16_t *)((char *)this + 40) = vbslq_s8((int8x16_t)vcgtq_f64(v12, v8), (int8x16_t)v8, (int8x16_t)v12);
  float64x2_t v13 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result, *(float64x2_t *)((char *)this + 56)), (int8x16_t)result, *(int8x16_t *)((char *)this + 56));
  *(int8x16_t *)((char *)this + 56) = vbslq_s8((int8x16_t)vcgtq_f64(v8, v13), (int8x16_t)v8, (int8x16_t)v13);
  CG::Path::reserve_space(this, 2, 1);
  uint64_t v15 = *((void *)this + 3);
  uint64_t v14 = *((void *)this + 4);
  uint64_t v16 = *((void *)this + 1);
  uint64_t v17 = *((void *)this + 2);
  uint64_t v18 = (float64x2_t *)(v14 + 16 * v16);
  BOOL result = v19;
  *uint64_t v18 = v20;
  v18[1] = v19;
  ++v17;
  *((void *)this + 1) = v16 + 2;
  *((void *)this + 2) = v17;
  *(unsigned char *)(v14 + v15 - v17) = 2;
  return result;
}

void CG::Path::reserve_space(CG::Path *this, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)this != 9) {
    CG::Path::convert_to_huge_(this);
  }
  uint64_t v6 = *((void *)this + 1);
  BOOL v7 = __CFADD__(a2, v6);
  unint64_t v8 = a2 + v6;
  if (v7
    || (uint64_t v9 = *((void *)this + 2), v7 = __CFADD__(a3, v9), v10 = a3 + v9, v7)
    || v8 >> 60
    || (v7 = __CFADD__(v10, 16 * v8), unint64_t v11 = v10 + 16 * v8, v7)
    || (unint64_t v12 = *((void *)this + 3), v12 >= 0x7FFFFFFFFFFFFFFFLL))
  {
    abort();
  }
  if (v11 > v12)
  {
    if (v11 <= 2 * v12) {
      unint64_t v11 = 2 * v12;
    }
    if (v11 <= 0x110) {
      size_t v13 = 272;
    }
    else {
      size_t v13 = v11;
    }
    uint64_t v14 = (char *)malloc_type_malloc(v13, 0x6AE0B856uLL);
    memcpy(v14, *((const void **)this + 4), 16 * *((void *)this + 1));
    memcpy(&v14[v13 - *((void *)this + 2)], (const void *)(*((void *)this + 4) + *((void *)this + 3) - *((void *)this + 2)), *((void *)this + 2));
    free(*((void **)this + 4));
    *((void *)this + 3) = v13;
    *((void *)this + 4) = v14;
  }
}

float64x2_t CG::Path::add_curve_to_point(CG::Path *this, float64x2_t *a2, float64x2_t *a3, float64x2_t *a4, const CGAffineTransform *a5, float64x2_t result)
{
  if (a4)
  {
    float64x2_t v7 = a4[1];
    float64x2_t v8 = a4[2];
    BOOL result = vaddq_f64(v8, vmlaq_n_f64(vmulq_laneq_f64(v7, result, 1), *a4, result.f64[0]));
    float64x2_t v9 = vaddq_f64(v8, vmlaq_n_f64(vmulq_n_f64(v7, a2->f64[1]), *a4, a2->f64[0]));
    float64x2_t v10 = vaddq_f64(v8, vmlaq_n_f64(vmulq_n_f64(v7, a3->f64[1]), *a4, a3->f64[0]));
  }
  else
  {
    float64x2_t v9 = *a2;
    float64x2_t v10 = *a3;
  }
  int v11 = *(_DWORD *)this;
  float64x2_t v25 = v9;
  float64x2_t v26 = result;
  float64x2_t v24 = v10;
  if (*(_DWORD *)this == 9) {
    goto LABEL_11;
  }
  if (v11 == 8) {
    goto LABEL_8;
  }
  if (!v11)
  {
    *(_DWORD *)this = 8;
LABEL_8:
    uint64_t v12 = *((unsigned __int16 *)this + 4);
    if (v12 <= 4)
    {
      *((float64x2_t *)this + v12 + 1) = result;
      size_t v13 = (float64x2_t *)((char *)this + 16 * v12 + 16);
      *((_WORD *)this + 4) = v12 + 3;
      v13[1] = v9;
      v13[2] = v10;
      __int16 v14 = *((_WORD *)this + 5);
      *((_DWORD *)this + 3) |= 3 << (3 * v14);
      *((_WORD *)this + 5) = v14 + 1;
      return result;
    }
  }
  CG::Path::convert_to_huge_(this);
  float64x2_t v10 = v24;
  float64x2_t v9 = v25;
  BOOL result = v26;
LABEL_11:
  float64x2_t v15 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)((char *)this + 40), result), (int8x16_t)result, *(int8x16_t *)((char *)this + 40));
  float64x2_t v16 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v15, v9), (int8x16_t)v9, (int8x16_t)v15);
  *(int8x16_t *)((char *)this + 40) = vbslq_s8((int8x16_t)vcgtq_f64(v16, v10), (int8x16_t)v10, (int8x16_t)v16);
  float64x2_t v17 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(result, *(float64x2_t *)((char *)this + 56)), (int8x16_t)result, *(int8x16_t *)((char *)this + 56));
  float64x2_t v18 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v9, v17), (int8x16_t)v9, (int8x16_t)v17);
  *(int8x16_t *)((char *)this + 56) = vbslq_s8((int8x16_t)vcgtq_f64(v10, v18), (int8x16_t)v10, (int8x16_t)v18);
  CG::Path::reserve_space(this, 3uLL, 1uLL);
  uint64_t v20 = *((void *)this + 3);
  uint64_t v19 = *((void *)this + 4);
  uint64_t v21 = *((void *)this + 1);
  uint64_t v22 = *((void *)this + 2);
  uint64_t v23 = (float64x2_t *)(v19 + 16 * v21);
  *uint64_t v23 = v26;
  v23[1] = v25;
  BOOL result = v24;
  v23[2] = v24;
  ++v22;
  *((void *)this + 1) = v21 + 3;
  *((void *)this + 2) = v22;
  *(unsigned char *)(v19 + v20 - v22) = 3;
  return result;
}

void CG::Path::convert_to_huge_(CG::Path *this)
{
  CG::Path::Path((CG::Path *)&v8, this);
  if (*(_DWORD *)this == 7)
  {
    uint64_t v2 = (const void *)*((void *)this + 1);
    if (v2) {
      CFRelease(v2);
    }
  }
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *(int64x2_t *)((char *)this + 40) = vdupq_n_s64(0x7FF0000000000000uLL);
  *(int64x2_t *)((char *)this + 56) = vdupq_n_s64(0xFFF0000000000000);
  *(_DWORD *)this = 9;
  CG::Path::reserve_space(this, 0x18uLL, 0xCuLL);
  switch((int)v8)
  {
    case 1:
      CG::Path::append_rect((uint64_t)this, &unit_rect, (float64x2_t *)&cf);
      break;
    case 2:
      CG::Path::append_rounded_rect((uint64_t)this, &unit_rect, v10, &cf);
      break;
    case 3:
      CG::Path::append_uneven_rounded_rect((uint64_t)this, &unit_rect, &v10, (float64x2_t *)&cf);
      break;
    case 4:
      CG::Path::append_ellipse(this, &unit_rect, BYTE1(v10.width), LOBYTE(v10.width), &cf);
      break;
    case 5:
      CG::Path::append_line_segment((uint64_t)this, (__n128 *)&cf, (const CGPoint *)&cf.c, 0);
      break;
    case 6:
      CG::Path::add_arc_relative(this, (float64x2_t *)&CGPointZero, 1.0, 0.0, v10.width, (CGPoint *)&cf, 1);
      break;
    case 7:
      CG::Path::append_region(this, *(void **)&cf.a, 0, v3, v4, v5, v6, v7);
      break;
    case 8:
      CG::Path::append_tiny(this, (const CGPoint *)&cf.b, LOWORD(cf.a), HIDWORD(cf.a), WORD1(cf.a));
      break;
    default:
      break;
  }
  CG::Path::recalculate_subpath_start(this);
  CG::Path::~Path(&v8);
}

void sub_184C0752C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void CG::Path::~Path(void **this)
{
  if (*(_DWORD *)this == 9)
  {
    free(this[4]);
  }
  else if (*(_DWORD *)this == 7)
  {
    uint64_t v1 = this[1];
    if (v1) {
      CFRelease(v1);
    }
  }
}

void *CG::Path::recalculate_subpath_start(void *this)
{
  unint64_t v2 = this[2];
  unint64_t v1 = this[3];
  if (v1 >= v2)
  {
    uint64_t v3 = this[1];
    unint64_t v4 = this[4] + v1;
    uint64_t v5 = -(uint64_t)v2;
    while (1)
    {
      v3 -= point_counts[*(unsigned __int8 *)(v4 + v5)];
      if (!*(unsigned char *)(v4 + v5)) {
        break;
      }
      if (!++v5) {
        return this;
      }
    }
    this[9] = v3;
  }
  return this;
}

int8x16_t CG::Path::append_tiny(CG::Path *this, const CGPoint *a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  unsigned int v5 = a5;
  CG::Path::reserve_space(this, a3, a5);
  if (v5)
  {
    uint64_t v10 = 0;
    unint64_t v11 = *((void *)this + 1);
    do
    {
      uint64_t v12 = *((void *)this + 3);
      uint64_t v13 = *((void *)this + 4);
      uint64_t v14 = *((void *)this + 2) + 1;
      *((void *)this + 2) = v14;
      *(unsigned char *)(v13 + v12 - v14) = a4 & 7;
      switch(a4 & 7)
      {
        case 0u:
        case 1u:
        case 4u:
          int8x16_t result = (int8x16_t)a2[v10++];
          uint64_t v15 = *((void *)this + 4);
          uint64_t v16 = *((void *)this + 1);
          *((void *)this + 1) = v16 + 1;
          *(int8x16_t *)(v15 + 16 * v16) = result;
          goto LABEL_5;
        case 2u:
          float64x2_t v17 = &a2[v10];
          uint64_t v18 = *((void *)this + 1);
          uint64_t v19 = *((void *)this + 4) + 16 * v18;
          *(CGPoint *)uint64_t v19 = *v17;
          v10 += 2;
          *((void *)this + 1) = v18 + 2;
          int8x16_t result = (int8x16_t)v17[1];
          *(int8x16_t *)(v19 + 16) = result;
          break;
        case 3u:
          uint64_t v20 = &a2[v10];
          uint64_t v21 = *((void *)this + 1);
          uint64_t v22 = *((void *)this + 4) + 16 * v21;
          *(CGPoint *)uint64_t v22 = *v20;
          *(CGPoint *)(v22 + 16) = v20[1];
          v10 += 3;
          *((void *)this + 1) = v21 + 3;
          int8x16_t result = (int8x16_t)v20[2];
          *(int8x16_t *)(v22 + 32) = result;
          break;
        default:
LABEL_5:
          if ((a4 & 7) == 4) {
            ++*((void *)this + 10);
          }
          break;
      }
      a4 >>= 3;
      --v5;
    }
    while (v5);
    unint64_t v23 = *((void *)this + 1);
    BOOL v24 = v23 > v11;
    unint64_t v25 = v23 - v11;
    if (v24)
    {
      int8x16_t result = *(int8x16_t *)((char *)this + 40);
      float64x2_t v26 = *(float64x2_t *)((char *)this + 56);
      uint64_t v27 = (float64x2_t *)(*((void *)this + 4) + 16 * v11);
      do
      {
        float64x2_t v28 = *v27++;
        int8x16_t result = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)result, v28), (int8x16_t)v28, result);
        *(int8x16_t *)((char *)this + 40) = result;
        float64x2_t v26 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v28, v26), (int8x16_t)v28, (int8x16_t)v26);
        *(float64x2_t *)((char *)this + 56) = v26;
        --v25;
      }
      while (v25);
    }
  }
  return result;
}

CGMutablePathRef CGPathCreateMutableCopy(CGPathRef path)
{
  if (!path) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v2 = CFGetTypeID(path);
    if (v2 != CGPathGetTypeID()) {
      return 0;
    }
  }
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 128, v4, v5, v6, v7, v8, v9);
  unint64_t v11 = (CGPath *)Instance;
  if (Instance) {
    CG::Path::Path((CG::Path *)(Instance + 16), (CGPathRef)((char *)path + 16));
  }
  return v11;
}

CGMutablePathRef CGPathCreateMutableCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  if (!path) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v10 = CFGetTypeID(path);
    if (v10 != CGPathGetTypeID()) {
      return 0;
    }
  }
    return 0;
  CFTypeID TypeID = CGPathGetTypeID();
  uint64_t Instance = CGTypeCreateInstance(TypeID, 128, v12, v13, v14, v15, v16, v17);
  uint64_t v19 = (CGPath *)Instance;
  if (Instance)
  {
    uint64_t v20 = CG::Path::Path((CG::Path *)(Instance + 16), (CGPathRef)((char *)path + 16));
    if (transform)
    {
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&transform->a, (float64x2_t)xmmword_1850CD830), (int32x4_t)vceqq_f64(*(float64x2_t *)&transform->c, (float64x2_t)xmmword_1850CD8C0))))) & 1) != 0|| transform->tx != 0.0|| transform->ty != 0.0)
      {
        CG::Path::apply_transform(v20, transform, v21, v22, v23, v24, v25, v26);
      }
    }
  }
  return v19;
}

CG::Path *CG::Path::Path(CG::Path *this, const CG::Path *a2)
{
  int v3 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  switch(v3)
  {
    case 1:
      long long v5 = *(_OWORD *)((char *)a2 + 8);
      long long v6 = *(_OWORD *)((char *)a2 + 24);
      long long v7 = *(_OWORD *)((char *)a2 + 40);
      goto LABEL_6;
    case 2:
      long long v5 = *(_OWORD *)((char *)a2 + 8);
      long long v6 = *(_OWORD *)((char *)a2 + 24);
      long long v7 = *(_OWORD *)((char *)a2 + 40);
      *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
      goto LABEL_6;
    case 3:
      long long v8 = *(_OWORD *)((char *)a2 + 8);
      long long v9 = *(_OWORD *)((char *)a2 + 24);
      *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
      *(_OWORD *)((char *)this + 24) = v9;
      *(_OWORD *)((char *)this + 8) = v8;
      long long v10 = *(_OWORD *)((char *)a2 + 56);
      long long v11 = *(_OWORD *)((char *)a2 + 72);
      long long v12 = *(_OWORD *)((char *)a2 + 88);
      *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
      *(_OWORD *)((char *)this + 88) = v12;
      *(_OWORD *)((char *)this + 72) = v11;
      goto LABEL_15;
    case 4:
      long long v5 = *(_OWORD *)((char *)a2 + 8);
      long long v6 = *(_OWORD *)((char *)a2 + 24);
      long long v7 = *(_OWORD *)((char *)a2 + 40);
      *((void *)this + 7) = *((void *)a2 + 7);
LABEL_6:
      *(_OWORD *)((char *)this + 40) = v7;
      goto LABEL_8;
    case 5:
      long long v5 = *(_OWORD *)((char *)a2 + 8);
      long long v6 = *(_OWORD *)((char *)a2 + 24);
LABEL_8:
      *(_OWORD *)((char *)this + 24) = v6;
      *(_OWORD *)((char *)this + 8) = v5;
      break;
    case 6:
      *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
      long long v13 = *(_OWORD *)((char *)a2 + 24);
      long long v14 = *(_OWORD *)((char *)a2 + 40);
      long long v15 = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
      *(_OWORD *)((char *)this + 56) = v15;
      *(_OWORD *)((char *)this + 40) = v14;
      *(_OWORD *)((char *)this + 24) = v13;
      break;
    case 7:
      CFTypeRef v16 = (CFTypeRef)*((void *)a2 + 1);
      if (v16) {
        CFTypeRef v16 = CFRetain(v16);
      }
      *((void *)this + 1) = v16;
      break;
    case 8:
      long long v17 = *(_OWORD *)((char *)a2 + 8);
      long long v18 = *(_OWORD *)((char *)a2 + 24);
      long long v19 = *(_OWORD *)((char *)a2 + 40);
      *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
      *(_OWORD *)((char *)this + 40) = v19;
      *(_OWORD *)((char *)this + 24) = v18;
      *(_OWORD *)((char *)this + 8) = v17;
      long long v20 = *(_OWORD *)((char *)a2 + 72);
      long long v21 = *(_OWORD *)((char *)a2 + 88);
      long long v22 = *(_OWORD *)((char *)a2 + 104);
      *((void *)this + 15) = *((void *)a2 + 15);
      *(_OWORD *)((char *)this + 104) = v22;
      *(_OWORD *)((char *)this + 88) = v21;
      *(_OWORD *)((char *)this + 72) = v20;
      break;
    case 9:
      *((void *)this + 9) = *((void *)a2 + 9);
      *((void *)this + 10) = *((void *)a2 + 10);
      size_t v23 = *((void *)a2 + 3);
      *((void *)this + 3) = v23;
      *((void *)this + 1) = *((void *)a2 + 1);
      *((void *)this + 2) = *((void *)a2 + 2);
      uint64_t v24 = malloc_type_malloc(v23, 0xA6C2B256uLL);
      *((void *)this + 4) = v24;
      memcpy(v24, *((const void **)a2 + 4), 16 * *((void *)this + 1));
      memcpy((void *)(*((void *)this + 4) + *((void *)this + 3) - *((void *)this + 2)), (const void *)(*((void *)a2 + 4) + *((void *)this + 3) - *((void *)this + 2)), *((void *)this + 2));
      *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
      long long v10 = *(_OWORD *)((char *)a2 + 56);
LABEL_15:
      *(_OWORD *)((char *)this + 56) = v10;
      break;
    default:
      return this;
  }
  return this;
}

double *create_color(void *a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v10 = CFGetTypeID(a1);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  long long v11 = 0;
  if (a2 && v10 == CGColorSpaceGetTypeID_type_id)
  {
    uint64_t v12 = *(void *)(a1[3] + 48) + 1;
    if (kCGColorComponents_block_invoke_once != -1) {
      dispatch_once(&kCGColorComponents_block_invoke_once, &__block_literal_global_31);
    }
    uint64_t Instance = CGTypeCreateInstance(CGColorGetTypeID_color_type_id, 8 * v12 + 48, v4, v5, v6, v7, v8, v9);
    long long v11 = (double *)Instance;
    if (Instance)
    {
      *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(create_color_identifier, 1u, memory_order_relaxed) + 1;
      CFRetain(a1);
      *((void *)v11 + 3) = a1;
      v11[4] = 0.0;
      *((void *)v11 + 7) = v12;
      memcpy(v11 + 8, a2, 8 * v12);
      CGColorSpaceAdjustColor((uint64_t)a1, (uint64_t)a2, v11 + 8, v14, v15, v16, v17, v18);
    }
  }
  return v11;
}

uint64_t CGTypeCreateInstance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 > 0xFFFFFFFFLL || (uint64_t result = _CFRuntimeCreateInstance()) == 0)
  {
    CGPostError((uint64_t)"%s: failed to create instance of type %jd.", a2, a3, a4, a5, a6, a7, a8, (char)"CGTypeCreateInstance");
    return 0;
  }
  return result;
}

uint64_t CGColorSpaceAdjustColor(uint64_t result, uint64_t a2, double *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v8 = a3;
    uint64_t v9 = (double *)a2;
    uint64_t v10 = *(void *)(result + 24);
    if (!a2) {
      uint64_t v9 = *(double **)(v10 + 40);
    }
    uint64_t v11 = *(void *)(v10 + 48);
    double v12 = v9[v11];
    double v13 = 0.0;
    if (v12 >= 0.0)
    {
      double v13 = v9[v11];
      if (v12 > 1.0) {
        double v13 = 1.0;
      }
    }
    if (v13 != a3[v11]) {
      a3[v11] = v13;
    }
    switch(*(_DWORD *)(v10 + 24))
    {
      case 5:
        uint64_t v17 = *(double **)(v10 + 96);
        double v18 = 0.0;
        if (*v9 >= 0.0)
        {
          double v18 = *v9;
          if (*v9 > 100.0) {
            double v18 = 100.0;
          }
        }
        if (v18 != *a3) {
          *a3 = v18;
        }
        double v19 = v9[1];
        double v20 = v17[6];
        if (v19 >= v20)
        {
          double v20 = v9[1];
          if (v19 > v17[7]) {
            double v20 = v17[7];
          }
        }
        if (v20 != a3[1]) {
          a3[1] = v20;
        }
        double v21 = v9[2];
        double v22 = v17[8];
        if (v21 >= v22)
        {
          double v22 = v9[2];
          if (v21 > v17[9]) {
            double v22 = v17[9];
          }
        }
        if (v22 != a3[2]) {
          a3[2] = v22;
        }
        return result;
      case 6:
      case 0xA:
      case 0xB:
        uint64_t result = CGColorSpaceICCGetRange(result, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
        if (!v11) {
          return result;
        }
        uint64_t v14 = (double *)(result + 8);
        break;
      case 7:
        int v23 = (int)(*v9 + 0.5);
        if (v23 < 0)
        {
          double v24 = 0.0;
        }
        else
        {
          double v24 = (double)v23;
          if ((double)v23 > (double)*(unint64_t *)(*(void *)(v10 + 96) + 8)) {
            double v24 = (double)*(unint64_t *)(*(void *)(v10 + 96) + 8);
          }
        }
        if (v24 != *a3) {
          *a3 = v24;
        }
        return result;
      case 9:
        if (**(void **)(v10 + 96)) {
          BOOL v16 = v11 == 0;
        }
        else {
          BOOL v16 = 1;
        }
        if (!v16) {
          goto LABEL_48;
        }
        return result;
      default:
        for (; v11; --v11)
        {
LABEL_48:
          double v25 = 0.0;
          if (*v9 >= 0.0)
          {
            double v25 = *v9;
            if (*v9 > 1.0) {
              double v25 = 1.0;
            }
          }
          if (v25 != *v8) {
            *uint64_t v8 = v25;
          }
          ++v8;
          ++v9;
        }
        return result;
    }
    do
    {
      double v15 = *(v14 - 1);
      if (fabs(v15) == INFINITY || fabs(*v14) == INFINITY)
      {
        double v15 = *v9;
      }
      else
      {
        if (*v9 >= v15)
        {
          double v15 = *v9;
          if (*v9 > *v14) {
            double v15 = *v14;
          }
        }
        if (v15 == *v8) {
          goto LABEL_21;
        }
      }
      *uint64_t v8 = v15;
LABEL_21:
      ++v8;
      ++v9;
      v14 += 2;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t CGColorSpaceICCGetRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  int v9 = *(_DWORD *)(v8 + 24);
  if (v9 == 6 || v9 == 10)
  {
    uint64_t v10 = *(void *)(v8 + 96) + 64;
  }
  else
  {
    if (v9 != 11) {
      _CGHandleAssert("CGColorSpaceICCGetRange", 578, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased || s->state->type == kCGColorSpaceProfileSets || s->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not ICC. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
    }
    uint64_t v10 = *(void *)(v8 + 96) + 88;
  }
  return *(void *)v10;
}

CGMutablePathRef CGPathCreateMutable(void)
{
  CFTypeID TypeID = CGPathGetTypeID();

  return (CGMutablePathRef)CGTypeCreateInstance(TypeID, 128, v1, v2, v3, v4, v5, v6);
}

CFTypeID CGPathGetTypeID(void)
{
  if (CGPathGetTypeID::once != -1) {
    dispatch_once(&CGPathGetTypeID::once, &__block_literal_global_17659);
  }
  if (_ZZZ15CGPathGetTypeIDEUb_E4once != -1) {
    dispatch_once(&_ZZZ15CGPathGetTypeIDEUb_E4once, &__block_literal_global_23_17660);
  }
  return CGPathGetTypeID::path_type_id;
}

void CG::Path::apply_transform(CG::Path *this, const CGAffineTransform *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (*(_DWORD *)this == 7)
  {
    if (fabs(a2->a) == 1.0 && fabs(a2->d) == 1.0 && a2->b == 0.0 && a2->c == 0.0)
    {
      double ty = a2->ty;
      double v11 = floor(ty);
      if (floor(a2->tx) == a2->tx && v11 == ty)
      {
        uint64_t v41 = (void *)*((void *)this + 1);
        long long v42 = *(_OWORD *)&a2->c;
        v45[0] = *(_OWORD *)&a2->a;
        v45[1] = v42;
        v45[2] = *(_OWORD *)&a2->tx;
        uint64_t v43 = CGRegionCreateByTransformingRegion(v41, (uint64_t)v45, 1, a4, a5, a6, a7, a8);
        uint64_t v44 = (const void *)*((void *)this + 1);
        if (v44) {
          CFRelease(v44);
        }
        *((void *)this + 1) = v43;
        return;
      }
    }
    CG::Path::convert_to_huge_(this);
  }
  switch(*(_DWORD *)this)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
      double v13 = *((double *)this + 1);
      double v14 = *((double *)this + 2);
      double v15 = *((double *)this + 3);
      double v16 = *((double *)this + 4);
      double v17 = *((double *)this + 5);
      double v18 = *((double *)this + 6);
      double b = a2->b;
      double c = a2->c;
      double d = a2->d;
      double v22 = v14 * c + v13 * a2->a;
      double v23 = v14 * d + v13 * b;
      double v24 = v16 * c + v15 * a2->a;
      double v25 = v16 * d + v15 * b;
      CGFloat v26 = a2->tx + c * v18 + v17 * a2->a;
      double v27 = d * v18 + v17 * b + a2->ty;
      *((double *)this + 1) = v22;
      *((double *)this + 2) = v23;
      *((double *)this + 3) = v24;
      *((double *)this + 4) = v25;
      *((CGFloat *)this + 5) = v26;
      *((double *)this + 6) = v27;
      break;
    case 5:
      *(float64x2_t *)((char *)this + 8) = vaddq_f64(*(float64x2_t *)&a2->tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&a2->c, *((double *)this + 2)), *(float64x2_t *)&a2->a, *((double *)this + 1)));
      *(float64x2_t *)((char *)this + 24) = vaddq_f64(*(float64x2_t *)&a2->tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&a2->c, *((double *)this + 4)), *(float64x2_t *)&a2->a, *((double *)this + 3)));
      break;
    case 8:
      uint64_t v28 = *((unsigned __int16 *)this + 4);
      if (*((_WORD *)this + 4))
      {
        float64x2_t v29 = *(float64x2_t *)&a2->a;
        float64x2_t v30 = *(float64x2_t *)&a2->c;
        uint64_t v31 = (double *)((char *)this + 16);
        float64x2_t v32 = *(float64x2_t *)&a2->tx;
        do
        {
          *(float64x2_t *)uint64_t v31 = vaddq_f64(v32, vmlaq_n_f64(vmulq_n_f64(v30, v31[1]), v29, *v31));
          v31 += 2;
          --v28;
        }
        while (v28);
      }
      break;
    case 9:
      uint64_t v33 = *((void *)this + 1);
      if (v33)
      {
        uint64_t v34 = (double *)*((void *)this + 4);
        float64x2_t v35 = *(float64x2_t *)&a2->a;
        float64x2_t v36 = *(float64x2_t *)&a2->c;
        float64x2_t v37 = *(float64x2_t *)&a2->tx;
        float64x2_t v38 = (float64x2_t)vdupq_n_s64(0xFFF0000000000000);
        float64x2_t v39 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
        do
        {
          float64x2_t v40 = vaddq_f64(v37, vmlaq_n_f64(vmulq_n_f64(v36, v34[1]), v35, *v34));
          *(float64x2_t *)uint64_t v34 = v40;
          v34 += 2;
          float64x2_t v39 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v39, v40), (int8x16_t)v40, (int8x16_t)v39);
          float64x2_t v38 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v40, v38), (int8x16_t)v40, (int8x16_t)v38);
          --v33;
        }
        while (v33);
      }
      else
      {
        float64x2_t v38 = (float64x2_t)vdupq_n_s64(0xFFF0000000000000);
        float64x2_t v39 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
      }
      *(float64x2_t *)((char *)this + 40) = v39;
      *(float64x2_t *)((char *)this + 56) = v38;
      break;
    default:
      return;
  }
}

void CG::Path::append_ellipse(CG::Path *this, const CGRect *a2, int a3, int a4, const CGAffineTransform *a5)
{
  if (*(_DWORD *)this)
  {
    CG::Path::reserve_space(this, 0xEuLL, 6uLL);
    double width = a2->size.width;
    double height = a2->size.height;
    double v13 = width * 0.5;
    v44.double x = width * 0.5;
    v44.double y = 0.0;
    double v45 = 0.0;
    double v14 = -0.5;
    if (!a4) {
      double v14 = 0.5;
    }
    double v15 = v14 * height;
    double v46 = v14 * height;
    double x = a2->origin.x;
    double y = a2->origin.y;
    if (width < 0.0 || height < 0.0)
    {
      v49.origin.double x = a2->origin.x;
      v49.origin.double y = a2->origin.y;
      v49.size.double width = width;
      v49.size.double height = height;
      CGRect v50 = CGRectStandardize(v49);
      double v18 = v50.origin.x + v50.size.width * 0.5;
      double v47 = v18;
      v50.origin.double x = x;
      v50.origin.double y = y;
      v50.size.double width = width;
      v50.size.double height = height;
      CGRect v51 = CGRectStandardize(v50);
      double y = v51.origin.y;
      double height = v51.size.height;
    }
    else
    {
      double v18 = x + v13;
      double v47 = x + v13;
    }
    double v31 = y + height * 0.5;
    double v48 = v31;
    if (a5)
    {
      double a = a5->a;
      double b = a5->b;
      double c = a5->c;
      double d = a5->d;
      double tx = a5->tx;
      double ty = a5->ty;
      v44.double x = c * 0.0 + v13 * a5->a;
      v44.double y = d * 0.0 + v13 * b;
      double v45 = v15 * c + a * 0.0;
      double v46 = v15 * d + b * 0.0;
      double v47 = tx + c * v31 + v18 * a;
      double v48 = d * v31 + v18 * b + ty;
    }
    CG::Path::move_to_point((int *)this, (float64x2_t *)&v44, v10, (__n128)xmmword_1850CD830);
    CGPoint v42 = (CGPoint)xmmword_1850CD8C0;
    CGPoint v43 = (CGPoint)xmmword_1850CDD30;
    CG::Path::add_curve_to_point(this, (float64x2_t *)&v43, (float64x2_t *)&v42, (float64x2_t *)&v44, v38, (float64x2_t)xmmword_1850CDD40);
    CGPoint v42 = (CGPoint)xmmword_1850CDAF0;
    CGPoint v43 = (CGPoint)xmmword_1850CDD50;
    CG::Path::add_curve_to_point(this, (float64x2_t *)&v43, (float64x2_t *)&v42, (float64x2_t *)&v44, v39, (float64x2_t)xmmword_1850CDD60);
    CGPoint v42 = (CGPoint)xmmword_1850CDAE0;
    CGPoint v43 = (CGPoint)xmmword_1850CDD70;
    CG::Path::add_curve_to_point(this, (float64x2_t *)&v43, (float64x2_t *)&v42, (float64x2_t *)&v44, v40, (float64x2_t)xmmword_1850CDD80);
    CGPoint v42 = (CGPoint)xmmword_1850CD830;
    CGPoint v43 = (CGPoint)xmmword_1850CDD90;
    CG::Path::add_curve_to_point(this, (float64x2_t *)&v43, (float64x2_t *)&v42, (float64x2_t *)&v44, v41, (float64x2_t)xmmword_1850CDDA0);
    if (a3) {
      CG::Path::close_subpath((uint64_t)this);
    }
  }
  else
  {
    CGPoint origin = a2->origin;
    _D2 = a2->size.width;
    _D1 = a2->size.height;
    *(_DWORD *)this = 4;
    if (a5)
    {
      _Q5 = *(_OWORD *)&a5->a;
      float64x2_t v23 = *(float64x2_t *)&a5->c;
      _D16 = 0;
      __asm { FMLA            D4, D2, V5.D[1] }
      double v30 = vmlad_n_f64(_D1 * v23.f64[0], 0.0, a5->a);
      __asm { FMLA            D1, D16, V5.D[1] }
      CGPoint origin = (CGPoint)vaddq_f64(*(float64x2_t *)&a5->tx, vmlaq_n_f64(vmulq_laneq_f64(v23, (float64x2_t)origin, 1), *(float64x2_t *)&a5->a, origin.x));
      _D2 = vmlad_n_f64(0.0 * v23.f64[0], _D2, a5->a);
    }
    else
    {
      double v30 = 0.0;
      _D4 = 0;
    }
    *((double *)this + 1) = _D2;
    *((void *)this + 2) = _D4;
    *((double *)this + 3) = v30;
    *((double *)this + 4) = _D1;
    *(CGPoint *)((char *)this + 40) = origin;
    *((unsigned char *)this + 56) = a4;
    *((unsigned char *)this + 57) = a3;
  }
}

int *CG::Path::move_to_point(int *this, float64x2_t *a2, const CGAffineTransform *a3, __n128 a4)
{
  uint64_t v4 = (uint64_t)this;
  if (a2) {
    a4 = (__n128)vaddq_f64(a2[2], vmlaq_n_f64(vmulq_laneq_f64(a2[1], (float64x2_t)a4, 1), *a2, a4.n128_f64[0]));
  }
  int v5 = *this;
  __n128 v20 = a4;
  if (*this == 9) {
    goto LABEL_13;
  }
  if (v5 == 8) {
    goto LABEL_7;
  }
  if (!v5)
  {
    *this = 8;
LABEL_7:
    uint64_t v6 = *((unsigned __int16 *)this + 4);
    if (v6 <= 6)
    {
      __int16 v7 = *((_WORD *)this + 5);
      if (*((_WORD *)this + 4) && *((_WORD *)this + 5) && !(this[3] >> (3 * v7 - 3)))
      {
        *(__n128 *)&this[4 * (v6 - 1) + 4] = a4;
      }
      else
      {
        *((_WORD *)this + 4) = v6 + 1;
        *(__n128 *)&this[4 * v6 + 4] = a4;
        *((_WORD *)this + 5) = v7 + 1;
      }
      return this;
    }
  }
  this = (int *)CG::Path::convert_to_huge_((CG::Path *)this);
  a4 = v20;
LABEL_13:
  uint64_t v8 = *(void *)(v4 + 8);
  uint64_t v9 = *(void *)(v4 + 16);
  if (v9) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10 || (double v11 = *(float64x2_t **)(v4 + 32), *((unsigned char *)v11->f64 + *(void *)(v4 + 24) - v9)))
  {
    *(void *)(v4 + 72) = v8;
    *(int8x16_t *)(v4 + 40) = vbslq_s8((int8x16_t)vcgtq_f64(*(float64x2_t *)(v4 + 40), (float64x2_t)a4), (int8x16_t)a4, *(int8x16_t *)(v4 + 40));
    *(int8x16_t *)(v4 + 56) = vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)a4, *(float64x2_t *)(v4 + 56)), (int8x16_t)a4, *(int8x16_t *)(v4 + 56));
    this = (int *)CG::Path::reserve_space((CG::Path *)v4, 1uLL, 1uLL);
    uint64_t v12 = *(void *)(v4 + 8);
    uint64_t v13 = *(void *)(v4 + 16);
    uint64_t v15 = *(void *)(v4 + 24);
    uint64_t v14 = *(void *)(v4 + 32);
    *(__n128 *)(v14 + 16 * v12) = v20;
    *(void *)(v4 + 8) = v12 + 1;
    *(void *)(v4 + 16) = v13 + 1;
    *(unsigned char *)(v14 + v15 - (v13 + 1)) = 0;
  }
  else
  {
    v11[v8 - 1] = (float64x2_t)a4;
    float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
    *(float64x2_t *)(v4 + 40) = v16;
    float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xFFF0000000000000);
    *(float64x2_t *)(v4 + 56) = v17;
    for (uint64_t i = *(void *)(v4 + 8); i; --i)
    {
      float64x2_t v19 = *v11++;
      float64x2_t v16 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v16, v19), (int8x16_t)v19, (int8x16_t)v16);
      *(float64x2_t *)(v4 + 40) = v16;
      float64x2_t v17 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v19, v17), (int8x16_t)v19, (int8x16_t)v17);
      *(float64x2_t *)(v4 + 56) = v17;
    }
  }
  return this;
}

uint64_t CG::Path::close_subpath(uint64_t this)
{
  uint64_t v1 = (CG::Path *)this;
  switch(*(_DWORD *)this)
  {
    case 0:
      *(_DWORD *)this = 8;
      goto LABEL_4;
    case 1:
    case 2:
    case 3:
    case 7:
      return this;
    case 4:
      *(unsigned char *)(this + 57) = 1;
      return this;
    case 8:
LABEL_4:
      __int16 v2 = *(_WORD *)(this + 10);
      if (!v2) {
        return this;
      }
      unsigned int v3 = *(_DWORD *)(this + 12);
      if ((v3 >> (3 * v2 - 3)) == 4) {
        return this;
      }
      uint64_t v4 = *(unsigned __int16 *)(this + 8);
      if (v4 > 6)
      {
LABEL_12:
        this = CG::Path::convert_to_huge_((CG::Path *)this);
LABEL_13:
        uint64_t v9 = *((void *)v1 + 2);
        if (v9 && *(unsigned char *)(*((void *)v1 + 4) + *((void *)v1 + 3) - v9) != 4)
        {
          this = CG::Path::reserve_space(v1, 1uLL, 1uLL);
          uint64_t v11 = *((void *)v1 + 3);
          uint64_t v10 = *((void *)v1 + 4);
          uint64_t v12 = *((void *)v1 + 1);
          uint64_t v13 = *((void *)v1 + 2);
          *(_OWORD *)(v10 + 16 * v12) = *(_OWORD *)(v10 + 16 * *((void *)v1 + 9));
          ++v13;
          *((void *)v1 + 1) = v12 + 1;
          *((void *)v1 + 2) = v13;
          *(unsigned char *)(v10 + v11 - v13) = 4;
          ++*((void *)v1 + 10);
        }
      }
      else
      {
        int v5 = v4 - 1;
        char v6 = 3 * v2 - 3;
        int v7 = *(unsigned __int16 *)(this + 10);
        do
        {
          if (((v3 >> v6) & 7) == 0) {
            break;
          }
          v5 -= point_counts[(v3 >> v6) & 7];
          v6 -= 3;
          BOOL v8 = __OFSUB__(v7--, 1);
        }
        while (!((v7 < 0) ^ v8 | (v7 == 0)));
        *(_WORD *)(this + 8) = v4 + 1;
        *(_OWORD *)(this + 16 + 16 * v4) = *(_OWORD *)(this + 16 + 16 * v5);
        *(_DWORD *)(this + 12) = v3 | (4 << (3 * v2));
        *(_WORD *)(this + 10) = v2 + 1;
      }
      return this;
    case 9:
      goto LABEL_13;
    default:
      goto LABEL_12;
  }
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      Mutable = (CGPath *)*((void *)c + 21);
      if (!Mutable)
      {
        Mutable = CGPathCreateMutable();
        *((void *)c + 21) = Mutable;
      }
      uint64_t v13 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
      CGPathMoveToPoint(Mutable, v13, x, y);
      return;
    }
    CGContextRef v14 = c;
  }
  else
  {
    CGContextRef v14 = 0;
  }

  handle_invalid_context((char)"CGContextMoveToPoint", (uint64_t)v14, v3, v4, v5, v6, v7, v8);
}

CGPathRef copy_clip_path(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 48))
    {
      *a2 = 0;
      *(unsigned char *)(v2 + 48) = 0;
      return CGContextCopyPath(*(CGContextRef *)(a1 + 88));
    }
    if (*(unsigned char *)(v2 + 49))
    {
      *a2 = 1;
      *(unsigned char *)(v2 + 49) = 0;
      return CGContextCopyPath(*(CGContextRef *)(a1 + 88));
    }
  }
  return 0;
}

void CGContextBeginPath(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v8 = (const void *)*((void *)c + 21);
      if (v8)
      {
        CFRelease(v8);
        *((void *)c + 21) = 0;
      }
      return;
    }
    CGContextRef v9 = c;
  }
  else
  {
    CGContextRef v9 = 0;
  }

  handle_invalid_context((char)"CGContextBeginPath", (uint64_t)v9, v1, v2, v3, v4, v5, v6);
}

uint64_t CGGStateGetTextDrawingMode(uint64_t a1)
{
  return *(char *)(*(void *)(a1 + 136) + 1);
}

uint64_t CGGStateGetFontSmoothingBackgroundColor(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 136) + 64);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  if (color) {
    CFRetain(color);
  }
  return color;
}

uint64_t CGvImage_converter_data_make_nonpurgeable()
{
  return 1;
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)CGImageGetDataProviderInternal((char *)image, 0);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  if (c && *((_DWORD *)c + 4) == 1129601108) {
    *(float64x2_t *)(*((void *)c + 12) + 56) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(*((void *)c + 12) + 56), *(float64x2_t *)(*((void *)c + 12) + 24), tx), *(float64x2_t *)(*((void *)c + 12) + 40), ty);
  }
  else {
    handle_invalid_context((char)"CGContextTranslateCTM", (uint64_t)c, v3, v4, v5, v6, v7, v8);
  }
}

size_t CGImageGetBytesPerRow(size_t image)
{
  if (image) {
    return *(void *)(image + 72);
  }
  return image;
}

BOOL sub_184C089E0(double *a1, double *a2)
{
  return a1[1] == a2[1] && *a1 == *a2;
}

uint64_t CGContextCreateWithDelegate(const void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGContextCreateWithDelegateAndInfo(a1, a2, a3, a4, 0, 0, a7, a8);
}

void CGContextDelegateRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

CFDataRef CGFontCopyTableForTag(CFDataRef font, uint32_t tag)
{
  if (font) {
    return (CFDataRef)(*(uint64_t (**)(void, void))(*((void *)font + 2) + 424))(*((void *)font + 14), *(void *)&tag);
  }
  return font;
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return t1->a == t2->a && t1->b == t2->b && t1->c == t2->c && t1->d == t2->d && t1->tx == t2->tx && t1->ty == t2->ty;
}

void argb32_sample_rectilinear_argb32(_DWORD *a1, uint64_t a2, int a3, __n128 a4)
{
  v117[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v109 = (int)a1[7];
  uint64_t v6 = a1[1];
  int v5 = a1[2];
  int v115 = v5;
  unsigned int v116 = v6;
  if ((int)v6 < 1 || v5 < 1) {
    return;
  }
  uint64_t v8 = a1;
  if ((int)a1[5] < 1) {
    return;
  }
  if ((int)a1[6] < 1) {
    return;
  }
  if ((int)a1[17] < 1) {
    return;
  }
  if ((int)a1[16] < 1) {
    return;
  }
  uint64_t v10 = a2;
  MEMORY[0x1F4188790](a1, a4);
  float64x2_t v17 = (char *)&v97 - v16;
  double v18 = (char *)&v97 - v16;
  if (v6 >= 0x401)
  {
    double v18 = (char *)malloc_type_malloc(4 * v6, 0x776ED063uLL);
    if (!v18) {
      return;
    }
  }
  v98 = v17;
  v99 = &v97;
  unint64_t v19 = *((void *)v8 + 5) + ((int)v8[6] - 1) * v109 + 4 * (int)v8[5] - 4;
  __n128 v20 = (int *)*((void *)v8 + 17);
  double v21 = v18;
  uint64_t v105 = v10;
  uint64_t v100 = v8;
  uint64_t v104 = v18;
  if (v20)
  {
    int v22 = v8[26];
    LODWORD(v117[0]) = v8[27];
    HIDWORD(v117[0]) = v22;
    shape_enum_clip_alloc((uint64_t)v18, v11, v20, 1, 1, 1, v22, v117[0], v6, v5);
    double v24 = v23;
    if (v23) {
      goto LABEL_75;
    }
  }
  int v25 = 0;
  int v26 = 0;
  double v24 = 0;
  v117[0] = 0;
  while (2)
  {
    uint64_t v27 = v26;
    uint64_t v28 = (unsigned int *)(*((void *)v8 + 5) + ((int)v8[4] + (uint64_t)v26) * v109 + 4 * (v25 + v8[3]));
    unint64_t v29 = *(unsigned int *)(v10 + 20);
    unint64_t v110 = v29 >> 24;
    uint64_t v30 = *(void *)(v10 + 104);
    uint64_t v106 = *(void *)(v10 + 136);
    uint64_t v31 = v30 + v106 * v27;
    uint64_t v108 = *(void *)(v10 + 32);
    float64x2_t v32 = rectilinear_weights;
    if (v6)
    {
      uint64_t v33 = *(void *)(v10 + 112);
      uint64_t v34 = *(void *)(v10 + 96) + v33 * v25;
      uint64_t v35 = v6;
      uint64_t v36 = -*(void *)(v10 + 64);
      uint64_t v37 = *(void *)(v10 + 80) - v34;
      float64x2_t v38 = v21;
      do
      {
        uint64_t v39 = v34 >> SBYTE2(v29);
        if ((v37 | (v36 + v34)) < 0)
        {
          uint64_t v41 = 0;
        }
        else
        {
          unint64_t v40 = rectilinear_weights[((v34 & (unint64_t)~(-1 << SBYTE2(v29))) >> (BYTE2(v29) - 4)) & 0xF];
          v39 -= v40 >> 4;
          uint64_t v41 = v40 & 0xF;
        }
        uint64_t v42 = *(unsigned int *)(v10 + 256);
        __n128 v20 = (int *)(v42 - (v41 != 0));
        uint64_t v43 = v42 - 1;
        if (v39 >= (uint64_t)v20)
        {
          LODWORD(v41) = 0;
          uint64_t v39 = v43;
        }
        if (v39 < 0)
        {
          LODWORD(v41) = 0;
          LODWORD(v39) = 0;
        }
        *v38++ = v41 | (v39 << 16);
        v34 += v33;
        v37 -= v33;
        --v35;
      }
      while (v35);
    }
    uint64_t v103 = ~(-1 << v110);
    uint64_t v101 = v24;
    uint64_t v102 = (v110 - 4);
    int v44 = v115;
    int16x8_t v45 = 0uLL;
    uint64_t v107 = v6;
    do
    {
      uint64_t v46 = *(unsigned int *)(v10 + 260);
      uint64_t v47 = v31 >> v110;
      if (((*(void *)(v10 + 88) - v31) | (v31 - *(void *)(v10 + 72))) < 0)
      {
        uint64_t v49 = 0;
      }
      else
      {
        unint64_t v48 = rectilinear_weights[((v31 & (unint64_t)v103) >> v102) & 0xF];
        v47 -= v48 >> 4;
        uint64_t v49 = v48 & 0xF;
      }
      uint64_t v50 = v46 - (v49 != 0);
      uint64_t v51 = v46 - 1;
      if (v47 >= v50) {
        uint64_t v52 = 0;
      }
      else {
        uint64_t v52 = v49;
      }
      if (v47 >= v50) {
        uint64_t v53 = v51;
      }
      else {
        uint64_t v53 = v47;
      }
      int v112 = v44;
      if (v53 < 0)
      {
        LODWORD(v52) = 0;
        uint64_t v55 = v108;
LABEL_38:
        uint64_t v56 = v55;
        goto LABEL_39;
      }
      uint64_t v54 = *(int *)(v10 + 24);
      uint64_t v55 = v108 + (int)v54 * (uint64_t)(int)v53;
      if (!v52) {
        goto LABEL_38;
      }
      uint64_t v56 = v55 + v54;
LABEL_39:
      int16x8_t v57 = vdupq_n_s16(v52);
      int16x8_t v58 = vdupq_n_s16(16 - (int)v52);
      uint8x8_t v59 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v52), (int32x2_t)vdup_n_s8(16 - (int)v52));
      v111 = v28;
      int16x8_t v113 = v58;
      int16x8_t v114 = v57;
      while ((unint64_t)v28 <= v19)
      {
        unint64_t v60 = ((unint64_t)*v21 >> 14) & 0x3FFFC;
        unsigned int v61 = *v21 & 0xF;
        if (a3 != 2)
        {
          if (!v4)
          {
            if (v56 == v55)
            {
              if (v61)
              {
                uint8x8_t v90 = *(uint8x8_t *)(v55 + v60);
                uint8x8_t v91 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
                int8x16_t v92 = (int8x16_t)vmull_u8(v90, v91);
                unsigned __int32 v79 = vrshrn_n_s16((int16x8_t)vmlal_u8((uint16x8_t)vextq_s8(v92, v92, 8uLL), v90, v91), 4uLL).u32[0];
                goto LABEL_64;
              }
              unsigned __int32 v95 = *(_DWORD *)(v55 + v60);
            }
            else
            {
              if (v61)
              {
                uint8x8_t v77 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
                int16x8_t v78 = vmlaq_s16(vmulq_s16((int16x8_t)vmull_u8(*(uint8x8_t *)(v55 + v60), v77), v57), (int16x8_t)vmull_u8(*(uint8x8_t *)(v56 + v60), v77), v58);
                *(int16x4_t *)v78.i8 = vadd_s16(*(int16x4_t *)v78.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v78, (int8x16_t)v78, 8uLL));
                unsigned __int32 v79 = vraddhn_s16(v78, v45).u32[0];
              }
              else
              {
                v93.i32[0] = *(_DWORD *)(v55 + v60);
                v93.i32[1] = *(_DWORD *)(v56 + v60);
                int8x16_t v94 = (int8x16_t)vmull_u8(v93, v59);
                unsigned __int32 v79 = vrshrn_n_s16((int16x8_t)vmlal_u8((uint16x8_t)vextq_s8(v94, v94, 8uLL), v93, v59), 4uLL).u32[0];
              }
LABEL_64:
              unsigned __int32 v95 = v79;
            }
            unsigned int v96 = v95 | 0xFF000000;
LABEL_66:
            *uint64_t v28 = v96;
            goto LABEL_67;
          }
          if (v56 == v55)
          {
            if (!v61)
            {
              unsigned int v96 = *(_DWORD *)(v55 + v60);
              goto LABEL_66;
            }
            uint8x8_t v85 = *(uint8x8_t *)(v55 + v60);
            uint8x8_t v86 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
            int8x16_t v87 = (int8x16_t)vmull_u8(v85, v86);
            unsigned __int32 v68 = vrshrn_n_s16((int16x8_t)vmlal_u8((uint16x8_t)vextq_s8(v87, v87, 8uLL), v85, v86), 4uLL).u32[0];
          }
          else if (v61)
          {
            uint8x8_t v69 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
            int16x8_t v70 = vmlaq_s16(vmulq_s16((int16x8_t)vmull_u8(*(uint8x8_t *)(v55 + v60), v69), v57), (int16x8_t)vmull_u8(*(uint8x8_t *)(v56 + v60), v69), v58);
            *(int16x4_t *)v70.i8 = vadd_s16(*(int16x4_t *)v70.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v70, (int8x16_t)v70, 8uLL));
            unsigned __int32 v68 = vraddhn_s16(v70, v45).u32[0];
          }
          else
          {
            v88.i32[0] = *(_DWORD *)(v55 + v60);
            v88.i32[1] = *(_DWORD *)(v56 + v60);
            int8x16_t v89 = (int8x16_t)vmull_u8(v88, v59);
            unsigned __int32 v68 = vrshrn_n_s16((int16x8_t)vmlal_u8((uint16x8_t)vextq_s8(v89, v89, 8uLL), v88, v59), 4uLL).u32[0];
          }
          goto LABEL_59;
        }
        if (v56 == v55)
        {
          if (!v61)
          {
            DplusDM_14623(v28, *(_DWORD *)(v55 + v60), *v28, ~*(_DWORD *)(v55 + v60) >> 24);
            int16x8_t v58 = v113;
            int16x8_t v57 = v114;
            int16x8_t v45 = 0uLL;
            goto LABEL_67;
          }
          uint8x8_t v71 = *(uint8x8_t *)(v55 + v60);
          uint8x8_t v72 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
          int8x16_t v73 = (int8x16_t)vmull_u8(v71, v72);
          uint16x8_t v74 = (uint16x8_t)vextq_s8(v73, v73, 8uLL);
          v75.i64[0] = vmlal_u8(v74, v71, v72).u64[0];
          v75.i64[1] = v74.i64[0];
          int8x8_t v76 = vrshrn_n_s16(v75, 4uLL);
          goto LABEL_55;
        }
        if (!v61)
        {
          v71.i32[0] = *(_DWORD *)(v55 + v60);
          v71.i32[1] = *(_DWORD *)(v56 + v60);
          int8x16_t v80 = (int8x16_t)vmull_u8(v71, v59);
          uint16x8_t v81 = (uint16x8_t)vextq_s8(v80, v80, 8uLL);
          v82.i64[0] = vmlal_u8(v81, v71, v59).u64[0];
          v82.i64[1] = v81.i64[0];
          int8x8_t v76 = vrshrn_n_s16(v82, 4uLL);
LABEL_55:
          v71.i32[0] = *v28;
          v83.i64[0] = 0x1000100010001;
          v83.i64[1] = 0x1000100010001;
          int16x8_t v84 = (int16x8_t)vmlal_u8(v83, (uint8x8_t)vdup_lane_s8(vmvn_s8(v76), 3), v71);
          unsigned __int32 v68 = vadd_s8(v76, vaddhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v84, 8uLL), v84)).u32[0];
          goto LABEL_59;
        }
        uint8x8_t v62 = (uint8x8_t)vzip1_s32((int32x2_t)vdup_n_s8(v61), (int32x2_t)vdup_n_s8(16 - v61));
        int16x8_t v63 = vmlaq_s16(vmulq_s16((int16x8_t)vmull_u8(*(uint8x8_t *)(v55 + v60), v62), v57), (int16x8_t)vmull_u8(*(uint8x8_t *)(v56 + v60), v62), v58);
        *(int16x4_t *)v64.i8 = vadd_s16(*(int16x4_t *)v63.i8, (int16x4_t)*(_OWORD *)&vextq_s8((int8x16_t)v63, (int8x16_t)v63, 8uLL));
        v63.i64[0] = v64.i64[0];
        v63.i64[1] = *(void *)(v55 + v60);
        int8x8_t v65 = vraddhn_s16(v63, v45);
        *(int8x8_t *)v63.i8 = vdup_lane_s8(vmvn_s8(v65), 3);
        v65.i32[0] = *v28;
        v66.i64[0] = 0x1000100010001;
        v66.i64[1] = 0x1000100010001;
        uint16x8_t v67 = vmlal_u8(v66, *(uint8x8_t *)v63.i8, (uint8x8_t)v65);
        v64.u64[1] = (unint64_t)v65;
        unsigned __int32 v68 = vaddhn_s16((int16x8_t)vsraq_n_u16(v67, v67, 8uLL), v64).u32[0];
LABEL_59:
        *uint64_t v28 = v68;
LABEL_67:
        ++v28;
        ++v21;
        LODWORD(v6) = v6 - 1;
        if (!v6) {
          break;
        }
      }
      int v44 = v112 - 1;
      int v115 = v112 - 1;
      double v21 = v104;
      uint64_t v10 = v105;
      if (v112 == 1) {
        goto LABEL_74;
      }
      LODWORD(v6) = v107;
      v31 += v106;
      uint64_t v28 = (unsigned int *)((char *)v111 + v109);
    }
    while (v19 >= (unint64_t)v111 + v109);
    CGLog(3, (uint64_t)"%s destination ptr is out-of-buffer", (uint64_t)v20, (uint64_t)v32, v12, v13, v14, v15, (char)"argb32_sample_rectilinear_argb32");
LABEL_74:
    uint64_t v8 = v100;
    double v24 = v101;
    if (v101)
    {
LABEL_75:
      if (shape_enum_clip_next((uint64_t)v24, (int *)v117 + 1, v117, &v116, &v115))
      {
        int v26 = v117[0];
        int v25 = HIDWORD(v117[0]);
        uint64_t v6 = v116;
        continue;
      }
      free(v24);
    }
    break;
  }
  if (v21 != v98) {
    free(v21);
  }
}

uint64_t argb32_mark(uint64_t *a1, uint64_t a2, __n128 a3, double a4, double a5, int16x8_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unint64_t v12 = a2;
  uint64_t v13 = *a1;
  if (*(_DWORD *)(a2 + 132))
  {
    if (CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken != -1) {
      dispatch_once(&CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::onceToken, &__block_literal_global_15_13639);
    }
    BOOL v14 = CGPreferencesCheck<CGImageMarkAllowTemplateMethodInteger>(void)::result != 0;
  }
  else
  {
    BOOL v14 = 0;
  }
  int v15 = *(_DWORD *)v12;
  uint64_t v16 = *(void *)(v12 + 96);
  uint64_t v17 = *(void *)(v12 + 48);
  uint64_t v18 = *(unsigned int *)(*(void *)(v13 + 56)
                        + 16 * *(_DWORD *)v12
                        + 8 * (v16 == 0)
                        + 4 * (v17 == 0));
  if ((int)v18 > 27) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v20 = *(unsigned int *)(v12 + 4);
  unsigned int v21 = v20 - 1;
  if ((int)v20 < 1) {
    return 0;
  }
  int v22 = *(_DWORD *)(v12 + 8);
  if (v22 < 1) {
    return 0;
  }
  if ((int)v18 >= 24)
  {
    if (*(_DWORD *)v13 == 134755208) {
      uint64_t v18 = (v18 + 4);
    }
    else {
      uint64_t v18 = v18;
    }
  }
  float64x2_t v23 = *(int **)(v12 + 136);
  if ((v15 & 0xFF0000) != 0x50000 && v23)
  {
    int v24 = *(_DWORD *)(v12 + 128);
    if ((v24 | 8) == 8)
    {
      if ((*(_DWORD *)v12 & 0xFF00) == 0x400)
      {
        if (v18 == 1) {
          argb32_mark_constcolormask(v12, a3.n128_f64[0], a4, a5, a6);
        }
        else {
          argb32_mark_constmask(v12, v18);
        }
      }
      else if (v14 && ((1 << v18) & 0xFFFFFE) != 0)
      {
        argb32_mark_pixelmask_template(v12, v18);
      }
      else
      {
        argb32_mark_pixelmask(v12, v18);
      }
    }
    else
    {
      unsigned int v28 = v18 - 1;
      if ((*(_DWORD *)v12 & 0xFF00) == 0x400 && v24 == 16 && v28 <= 1)
      {
        argb32_mark_constdeep(v13, v12, (uint64_t)v23, a8, a9, a10, a11, a12);
      }
      else if (v24 != 16 || (*(_DWORD *)v12 & 0xFF00) == 0x400 || v28 > 1)
      {
        argb32_mark_bits(v12, a3);
      }
      else
      {
        argb32_mark_pixeldeep(v13, v12, (uint64_t)v23, a8, a9, a10, a11, a12);
      }
    }
    return 1;
  }
  unint64_t v560 = v12;
  int v570 = v18;
  if (BYTE1(v15) == 1)
  {
    if (v14 && ((1 << v18) & 0xFFFFFE) != 0)
    {
      argb32_mark_pixelshape_template(v12, v18);
      return 1;
    }
LABEL_36:
    int v582 = *(_DWORD *)(v12 + 8);
    v583[0] = v20;
    uint64_t v29 = *(void *)(v12 + 88);
    unint64_t v30 = (unint64_t)*(int *)(v12 + 28) >> 2;
    unint64_t v31 = *(void *)(v12 + 40) + 4 * (*(int *)(v12 + 12) + v30 * *(int *)(v12 + 16));
    int v32 = *(_DWORD *)(v12 + 56);
    int v33 = *(_DWORD *)(v12 + 60);
    unint64_t v34 = (unint64_t)*(int *)(v12 + 76) >> 2;
    if ((v15 & 0xFF00) != 0x100)
    {
      LODWORD(v569) = *(_DWORD *)(v12 + 64);
      int v564 = *(_DWORD *)(v12 + 68);
      unint64_t v573 = v29 + 4 * v34 * v564;
      BOOL v37 = v16 != 0;
      if (v23)
      {
        unint64_t v577 = (unint64_t)*(int *)(v12 + 76) >> 2;
        int v561 = *(_DWORD *)(v12 + 60);
        int v562 = *(_DWORD *)(v12 + 56);
        int v36 = 1;
        unint64_t v580 = *(void *)(v12 + 88);
        unint64_t v38 = v580;
        goto LABEL_61;
      }
      unint64_t v576 = v30 - v20;
      if (v29)
      {
        uint64_t v568 = 0;
        unint64_t v577 = (unint64_t)*(int *)(v12 + 76) >> 2;
        unint64_t v39 = v29 + 4 * v34 * (v33 % v564);
        int v562 = v32 % (int)v569;
        uint64_t v40 = v39 + 4 * (v32 % (int)v569);
        unint64_t v38 = v39 + 4 * (int)v569;
        int v563 = 1;
        unint64_t v580 = v40;
        uint64_t v41 = (uint32x2_t *)(*(void *)(v12 + 40) + 4 * (*(int *)(v12 + 12) + v30 * *(int *)(v12 + 16)));
        int v561 = v33 % v564;
        goto LABEL_65;
      }
      int v561 = *(_DWORD *)(v12 + 60);
      int v562 = *(_DWORD *)(v12 + 56);
      unint64_t v38 = 0;
      int v563 = 1;
      unint64_t v42 = v20;
      goto LABEL_64;
    }
    v29 += 4 * (v32 + v34 * v33);
    if (v34 == v30)
    {
      if ((uint64_t)(v31 - v29) < 1) {
        goto LABEL_41;
      }
      if (v20 < (v31 - v29) >> 2)
      {
        unint64_t v35 = v30 * (v22 - 1);
        if (v31 <= v29 + 4 * v35 + 4 * v21)
        {
          v31 += 4 * v35;
          unint64_t v30 = -(uint64_t)v30;
          int v36 = 1;
          v29 += 4 * v35;
          goto LABEL_58;
        }
LABEL_41:
        int v36 = 1;
LABEL_58:
        unint64_t v569 = v30;
        goto LABEL_59;
      }
      v31 += 4 * v21;
      int v36 = -1;
      unint64_t v569 = (unint64_t)*(int *)(v12 + 28) >> 2;
      v29 += 4 * v21;
    }
    else
    {
      int v36 = 1;
      unint64_t v569 = (unint64_t)*(int *)(v12 + 76) >> 2;
    }
LABEL_59:
    int v561 = *(_DWORD *)(v12 + 60);
    int v562 = *(_DWORD *)(v12 + 56);
    BOOL v37 = v16 != 0;
    if (v23)
    {
      int v564 = 0;
      unint64_t v580 = 0;
      unint64_t v573 = 0;
      unint64_t v38 = -1;
      unint64_t v577 = v569;
LABEL_61:
      int v563 = v36;
      shape_enum_clip_alloc((uint64_t)a1, a2, v23, v36, v30, 1, *(_DWORD *)(v12 + 104), *(_DWORD *)(v12 + 108), v20, v22);
      uint64_t v44 = v43;
      if (!v43) {
        return 1;
      }
      goto LABEL_767;
    }
    int v563 = v36;
    int v564 = 0;
    unint64_t v42 = v36 * (int)v20;
    unint64_t v576 = v30 - v42;
    unint64_t v38 = -1;
    unint64_t v34 = v569;
LABEL_64:
    uint64_t v568 = 0;
    unint64_t v573 = 0;
    unint64_t v577 = v34 - v42;
    unint64_t v580 = 0;
    uint64_t v40 = v29;
    uint64_t v41 = (uint32x2_t *)v31;
LABEL_65:
    while (2)
    {
      int v572 = v20;
      switch((int)v18)
      {
        case 0:
          int16x8_t v45 = (uint32x2_t *)((char *)v41 - 4 * (int)v20 + 4);
          uint64_t v46 = v576 + (int)v20;
          if (v563 < 0) {
            uint64_t v46 = v576 - (int)v20;
          }
          else {
            int16x8_t v45 = v41;
          }
          uint64_t v47 = (char *)v45 + 4 * ((v46 * (v582 - 1)) & (v46 >> 63));
          if (v46 < 0) {
            uint64_t v46 = -v46;
          }
          CGBlt_fillBytes(4 * v20, v582, 0, v47, 4 * v46);
          goto LABEL_765;
        case 1:
          if (BYTE1(*(_DWORD *)v12) == 2)
          {
            if ((int)v20 >= 8 && (4 * v569) <= 0x40)
            {
              a3.n128_u32[0] = 4 * v569;
              uint8x8_t v410 = (uint8x8_t)vcnt_s8((int8x8_t)a3.n128_u64[0]);
              v410.i16[0] = vaddlv_u8(v410);
              if (v410.i32[0] <= 1u)
              {
                CGSFillDRAM64((unint64_t)v41, 4 * (v20 + v576), 4 * v20, v582, v29, 4 * v577, 4 * v569, v564, 4 * v562, v561);
                goto LABEL_765;
              }
            }
          }
          else if (BYTE1(*(_DWORD *)v12) == 1)
          {
            if (v17 == 0 || v37)
            {
              if (v563 < 0)
              {
                uint64_t v48 = v577 - (int)v20;
                v40 -= 4 * ((int)v20 - 1);
                uint64_t v49 = v576 - (int)v20;
                uint64_t v41 = (uint32x2_t *)((char *)v41 - 4 * (int)v20 + 4);
              }
              else
              {
                uint64_t v48 = v577 + (int)v20;
                uint64_t v49 = v576 + (int)v20;
              }
              v436 = (char *)(v40 + 4 * ((v48 * (v582 - 1)) & (v48 >> 63)));
              if (v48 >= 0) {
                unint64_t v437 = v48;
              }
              else {
                unint64_t v437 = -v48;
              }
              if (v49 >= 0) {
                LODWORD(v438) = v49;
              }
              else {
                uint64_t v438 = -v49;
              }
              unint64_t v577 = v437;
              CGBlt_copyBytes(4 * v20, v582, v436, (char *)v41 + 4 * ((v49 * (v582 - 1)) & (v49 >> 63)), 4 * v437, 4 * v438);
            }
            else
            {
              do
              {
                int v420 = v583[0];
                do
                {
                  v41->i32[0] = *(_DWORD *)v40 | 0xFF000000;
                  unint64_t v421 = v40 + 4 * v563;
                  if (v421 >= v38) {
                    uint64_t v422 = -(uint64_t)(int)v569;
                  }
                  else {
                    uint64_t v422 = 0;
                  }
                  uint64_t v40 = v421 + 4 * v422;
                  uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
                  --v420;
                }
                while (v420);
                uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
                unint64_t v423 = v580;
                unint64_t v424 = v580 + 4 * v577;
                if (v424 >= v573) {
                  uint64_t v425 = -(uint64_t)(v577 * v564);
                }
                else {
                  uint64_t v425 = 0;
                }
                uint64_t v426 = v424 + 4 * v425;
                uint64_t v427 = v38 + 4 * v425 + 4 * v577;
                if (v573)
                {
                  unint64_t v38 = v427;
                  unint64_t v423 = v426;
                }
                unint64_t v580 = v423;
                if (v573) {
                  uint64_t v40 = v426;
                }
                else {
                  v40 += 4 * v577;
                }
                --v582;
              }
              while (v582);
            }
            goto LABEL_765;
          }
          if ((*(_DWORD *)v12 & 0xFF00) == 0x200)
          {
            blt_bitmap_copy_XXXX32((int)v20, v582, v41, v576 + (int)v20, (int)v569, v564, v29, v577, v562, v561);
          }
          else
          {
            uint64_t v411 = 4 * v563;
            if (v17 == 0 || v37)
            {
              do
              {
                int v412 = v583[0];
                do
                {
                  v41->i32[0] = *(_DWORD *)v40;
                  unint64_t v413 = v40 + 4 * v563;
                  if (v413 >= v38) {
                    uint64_t v414 = -(uint64_t)(int)v569;
                  }
                  else {
                    uint64_t v414 = 0;
                  }
                  uint64_t v40 = v413 + 4 * v414;
                  uint64_t v41 = (uint32x2_t *)((char *)v41 + v411);
                  --v412;
                }
                while (v412);
                uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
                unint64_t v415 = v580;
                unint64_t v416 = v580 + 4 * v577;
                if (v416 >= v573) {
                  uint64_t v417 = -(uint64_t)(v577 * v564);
                }
                else {
                  uint64_t v417 = 0;
                }
                uint64_t v418 = v416 + 4 * v417;
                uint64_t v419 = v38 + 4 * v417 + 4 * v577;
                if (v573)
                {
                  unint64_t v38 = v419;
                  unint64_t v415 = v418;
                }
                unint64_t v580 = v415;
                if (v573) {
                  uint64_t v40 = v418;
                }
                else {
                  v40 += 4 * v577;
                }
                --v582;
              }
              while (v582);
            }
            else
            {
              do
              {
                int v428 = v583[0];
                do
                {
                  v41->i32[0] = *(_DWORD *)v40 | 0xFF000000;
                  unint64_t v429 = v40 + 4 * v563;
                  if (v429 >= v38) {
                    uint64_t v430 = -(uint64_t)(int)v569;
                  }
                  else {
                    uint64_t v430 = 0;
                  }
                  uint64_t v40 = v429 + 4 * v430;
                  uint64_t v41 = (uint32x2_t *)((char *)v41 + v411);
                  --v428;
                }
                while (v428);
                uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
                unint64_t v431 = v580;
                unint64_t v432 = v580 + 4 * v577;
                if (v432 >= v573) {
                  uint64_t v433 = -(uint64_t)(v577 * v564);
                }
                else {
                  uint64_t v433 = 0;
                }
                uint64_t v434 = v432 + 4 * v433;
                uint64_t v435 = v38 + 4 * v433 + 4 * v577;
                if (v573)
                {
                  unint64_t v38 = v435;
                  unint64_t v431 = v434;
                }
                unint64_t v580 = v431;
                if (v573) {
                  uint64_t v40 = v434;
                }
                else {
                  v40 += 4 * v577;
                }
                --v582;
              }
              while (v582);
            }
          }
          goto LABEL_765;
        case 2:
          if (*(unsigned __int8 *)(v12 + 1) << 8 != 512)
          {
            uint64_t v565 = v29;
            unint64_t v566 = v30;
            unint64_t v567 = v31;
            do
            {
              int v397 = v583[0];
              do
              {
                unsigned int v398 = *(_DWORD *)v40;
                int v399 = HIBYTE(*(_DWORD *)v40);
                if (v399)
                {
                  if (v399 == 255) {
                    v41->i32[0] = v398;
                  }
                  else {
                    DplusDM_14623(v41, v398, v41->i32[0], ~v398 >> 24);
                  }
                }
                unint64_t v400 = v40 + 4 * v563;
                if (v400 >= v38) {
                  uint64_t v401 = -(uint64_t)(int)v569;
                }
                else {
                  uint64_t v401 = 0;
                }
                uint64_t v40 = v400 + 4 * v401;
                uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
                --v397;
              }
              while (v397);
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
              unint64_t v402 = v580;
              unint64_t v403 = v580 + 4 * v577;
              if (v403 >= v573) {
                uint64_t v404 = -(uint64_t)(v577 * v564);
              }
              else {
                uint64_t v404 = 0;
              }
              uint64_t v405 = v403 + 4 * v404;
              uint64_t v406 = v38 + 4 * v404 + 4 * v577;
              if (v573)
              {
                unint64_t v38 = v406;
                unint64_t v402 = v405;
              }
              unint64_t v580 = v402;
              if (v573) {
                uint64_t v40 = v405;
              }
              else {
                v40 += 4 * v577;
              }
              --v582;
            }
            while (v582);
            goto LABEL_763;
          }
          blt_bitmap_blend_AXXX32((int)v20, v582, v41, v576 + (int)v20, (int)v569, v564, v29, v577, v562, v561);
          goto LABEL_765;
        case 3:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          do
          {
            int v50 = v583[0];
            do
            {
              int v51 = HIBYTE(v41->i32[0]);
              if (v51 == 255)
              {
                unsigned int v52 = *(_DWORD *)v40 & 0xFF000000;
                if (!v37) {
                  unsigned int v52 = -16777216;
                }
                v41->i32[0] = v52 & 0xFF000000 | *(_DWORD *)v40 & 0xFFFFFF;
              }
              else if (v51)
              {
                int v53 = HIBYTE(*(_DWORD *)v40);
                if (!v37) {
                  LOBYTE(v53) = -1;
                }
                DAM(v41, *(_DWORD *)v40, v53, v51);
              }
              else
              {
                v41->i32[0] = 0;
              }
              unint64_t v54 = v40 + 4 * v563;
              if (v54 >= v38) {
                uint64_t v55 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v55 = 0;
              }
              uint64_t v40 = v54 + 4 * v55;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v50;
            }
            while (v50);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v56 = v580;
            unint64_t v57 = v580 + 4 * v577;
            uint64_t v58 = -(uint64_t)(v577 * v564);
            if (v57 < v573) {
              uint64_t v58 = 0;
            }
            uint64_t v59 = v57 + 4 * v58;
            uint64_t v60 = v38 + 4 * v58 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v60;
              unint64_t v56 = v59;
            }
            unint64_t v580 = v56;
            if (v573) {
              uint64_t v40 = v59;
            }
            else {
              v40 += 4 * v577;
            }
            --v582;
          }
          while (v582);
          goto LABEL_763;
        case 4:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          do
          {
            int v61 = v583[0];
            do
            {
              __int8 v62 = v41->i8[3];
              if (~v62 == 255)
              {
                unsigned int v63 = *(_DWORD *)v40 & 0xFF000000;
                if (!v37) {
                  unsigned int v63 = -16777216;
                }
                v41->i32[0] = v63 & 0xFF000000 | *(_DWORD *)v40 & 0xFFFFFF;
              }
              else if (v62 == -1)
              {
                v41->i32[0] = 0;
              }
              else
              {
                unsigned __int8 v64 = ~v62;
                int v65 = HIBYTE(*(_DWORD *)v40);
                if (!v37) {
                  LOBYTE(v65) = -1;
                }
                DAM(v41, *(_DWORD *)v40, v65, v64);
              }
              unint64_t v66 = v40 + 4 * v563;
              if (v66 >= v38) {
                uint64_t v67 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v67 = 0;
              }
              uint64_t v40 = v66 + 4 * v67;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v61;
            }
            while (v61);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v68 = v580;
            unint64_t v69 = v580 + 4 * v577;
            uint64_t v70 = -(uint64_t)(v577 * v564);
            if (v69 < v573) {
              uint64_t v70 = 0;
            }
            uint64_t v71 = v69 + 4 * v70;
            uint64_t v72 = v38 + 4 * v70 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v72;
              unint64_t v68 = v71;
            }
            unint64_t v580 = v68;
            if (v573) {
              uint64_t v40 = v71;
            }
            else {
              v40 += 4 * v577;
            }
            --v582;
          }
          while (v582);
          goto LABEL_763;
        case 5:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          int v73 = v582;
          do
          {
            int v74 = v20;
            do
            {
              DMplusDM_14622((unsigned int *)v41, *(_DWORD *)v40, HIBYTE(v41->i32[0]), v41->i32[0], ~*(_DWORD *)v40 >> 24);
              unint64_t v75 = v40 + 4 * v563;
              if (v75 >= v38) {
                uint64_t v76 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v76 = 0;
              }
              uint64_t v40 = v75 + 4 * v76;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v74;
            }
            while (v74);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v77 = v580;
            unint64_t v78 = v580 + 4 * v577;
            uint64_t v79 = -(uint64_t)(v577 * v564);
            if (v78 < v573) {
              uint64_t v79 = 0;
            }
            uint64_t v80 = v78 + 4 * v79;
            uint64_t v81 = v38 + 4 * v79 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v81;
              unint64_t v77 = v80;
            }
            unint64_t v580 = v77;
            if (v573) {
              uint64_t v40 = v80;
            }
            else {
              v40 += 4 * v577;
            }
            int v582 = --v73;
            LODWORD(v20) = v572;
          }
          while (v73);
          goto LABEL_763;
        case 6:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          do
          {
            int v82 = v583[0];
            do
            {
              if (~HIBYTE(v41->i32[0]))
              {
                if (~HIBYTE(v41->i32[0]) == 255)
                {
                  unsigned int v83 = *(_DWORD *)v40 & 0xFF000000;
                  if (!v37) {
                    unsigned int v83 = -16777216;
                  }
                  v41->i32[0] = v83 & 0xFF000000 | *(_DWORD *)v40 & 0xFFFFFF;
                }
                else
                {
                  int v84 = HIBYTE(*(_DWORD *)v40);
                  if (!v37) {
                    LOBYTE(v84) = -1;
                  }
                  DplusDAM(v41, v41->i32[0], *(_DWORD *)v40, v84, ~HIBYTE(v41->i32[0]));
                }
              }
              unint64_t v85 = v40 + 4 * v563;
              if (v85 >= v38) {
                uint64_t v86 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v86 = 0;
              }
              uint64_t v40 = v85 + 4 * v86;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v82;
            }
            while (v82);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v87 = v580;
            unint64_t v88 = v580 + 4 * v577;
            uint64_t v89 = -(uint64_t)(v577 * v564);
            if (v88 < v573) {
              uint64_t v89 = 0;
            }
            uint64_t v90 = v88 + 4 * v89;
            uint64_t v91 = v38 + 4 * v89 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v91;
              unint64_t v87 = v90;
            }
            unint64_t v580 = v87;
            if (v573) {
              uint64_t v40 = v90;
            }
            else {
              v40 += 4 * v577;
            }
            --v582;
          }
          while (v582);
          goto LABEL_763;
        case 7:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v92 = v583[0];
            do
            {
              int v93 = HIBYTE(*(_DWORD *)v40);
              if (v93)
              {
                if (v93 == 255) {
                  goto LABEL_171;
                }
                int v93 = PDM_14621(v41->i32[0], v93);
              }
              v41->i32[0] = v93;
LABEL_171:
              unint64_t v94 = v40 + 4 * v563;
              if (v94 >= v38) {
                uint64_t v95 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v95 = 0;
              }
              uint64_t v40 = v94 + 4 * v95;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v92;
            }
            while (v92);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v96 = v580;
            unint64_t v97 = v580 + 4 * v577;
            if (v97 >= v573) {
              uint64_t v98 = -(uint64_t)(v577 * v564);
            }
            else {
              uint64_t v98 = 0;
            }
            uint64_t v99 = v97 + 4 * v98;
            uint64_t v100 = v38 + 4 * v98 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v100;
              unint64_t v96 = v99;
            }
            unint64_t v580 = v96;
            if (v573) {
              uint64_t v40 = v99;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_763;
            }
          }
        case 8:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          do
          {
            int v101 = v583[0];
            do
            {
              int v102 = *(unsigned __int8 *)(v40 + 3) ^ 0xFF;
              if (v102)
              {
                if (v102 == 255) {
                  goto LABEL_191;
                }
                int v102 = PDM_14621(v41->i32[0], v102);
              }
              v41->i32[0] = v102;
LABEL_191:
              unint64_t v103 = v40 + 4 * v563;
              if (v103 >= v38) {
                uint64_t v104 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v104 = 0;
              }
              uint64_t v40 = v103 + 4 * v104;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v101;
            }
            while (v101);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v105 = v580;
            unint64_t v106 = v580 + 4 * v577;
            if (v106 >= v573) {
              uint64_t v107 = -(uint64_t)(v577 * v564);
            }
            else {
              uint64_t v107 = 0;
            }
            uint64_t v108 = v106 + 4 * v107;
            uint64_t v109 = v38 + 4 * v107 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v109;
              unint64_t v105 = v108;
            }
            unint64_t v580 = v105;
            if (v573) {
              uint64_t v40 = v108;
            }
            else {
              v40 += 4 * v577;
            }
            --v582;
          }
          while (v582);
LABEL_763:
          unint64_t v12 = v560;
LABEL_764:
          LODWORD(v18) = v570;
          unint64_t v30 = v566;
          unint64_t v31 = v567;
          uint64_t v29 = v565;
LABEL_765:
          uint64_t v44 = v568;
          if (!v568) {
            return 1;
          }
          uint64_t v581 = 0;
LABEL_767:
          if (!shape_enum_clip_next(v44, (int *)&v581 + 1, &v581, v583, &v582))
          {
            v409 = (void *)v44;
            goto LABEL_1104;
          }
          uint64_t v568 = v44;
          if (v573)
          {
            uint64_t v41 = (uint32x2_t *)(v31 + 4 * v30 * (int)v581 + 4 * SHIDWORD(v581));
            LODWORD(v20) = v583[0];
            unint64_t v407 = v29 + 4 * v577 * (((int)v581 + *(_DWORD *)(v12 + 60)) % v564);
            int v562 = (HIDWORD(v581) + *(_DWORD *)(v12 + 56)) % (int)v569;
            uint64_t v40 = v407 + 4 * v562;
            unint64_t v38 = v407 + 4 * (int)v569;
            unint64_t v580 = v40;
            int v408 = v583[0];
            int v561 = ((int)v581 + *(_DWORD *)(v12 + 60)) % v564;
          }
          else
          {
            LODWORD(v20) = v583[0];
            int v408 = v583[0] * v563;
            uint64_t v41 = (uint32x2_t *)(v31 + 4 * v30 * (int)v581 + 4 * HIDWORD(v581) * v563);
            uint64_t v40 = v29 + 4 * (int)v581 * (int)v569 + 4 * HIDWORD(v581) * v563;
            unint64_t v577 = (int)v569 - v583[0] * v563;
          }
          unint64_t v576 = v30 - v408;
          continue;
        case 9:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          int v110 = v582;
          do
          {
            int v111 = v20;
            do
            {
              DMplusDM_14622((unsigned int *)v41, *(_DWORD *)v40, ~v41->i32[0] >> 24, v41->i32[0], HIBYTE(*(_DWORD *)v40));
              unint64_t v112 = v40 + 4 * v563;
              if (v112 >= v38) {
                uint64_t v113 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v113 = 0;
              }
              uint64_t v40 = v112 + 4 * v113;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v111;
            }
            while (v111);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v114 = v580;
            unint64_t v115 = v580 + 4 * v577;
            uint64_t v116 = -(uint64_t)(v577 * v564);
            if (v115 < v573) {
              uint64_t v116 = 0;
            }
            uint64_t v117 = v115 + 4 * v116;
            uint64_t v118 = v38 + 4 * v116 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v118;
              unint64_t v114 = v117;
            }
            unint64_t v580 = v114;
            if (v573) {
              uint64_t v40 = v117;
            }
            else {
              v40 += 4 * v577;
            }
            int v582 = --v110;
            LODWORD(v20) = v572;
          }
          while (v110);
          goto LABEL_763;
        case 10:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          int v119 = v582;
          do
          {
            int v120 = v20;
            do
            {
              DMplusDM_14622((unsigned int *)v41, *(_DWORD *)v40, ~v41->i32[0] >> 24, v41->i32[0], ~*(_DWORD *)v40 >> 24);
              unint64_t v121 = v40 + 4 * v563;
              if (v121 >= v38) {
                uint64_t v122 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v122 = 0;
              }
              uint64_t v40 = v121 + 4 * v122;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v120;
            }
            while (v120);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v123 = v580;
            unint64_t v124 = v580 + 4 * v577;
            uint64_t v125 = -(uint64_t)(v577 * v564);
            if (v124 < v573) {
              uint64_t v125 = 0;
            }
            uint64_t v126 = v124 + 4 * v125;
            uint64_t v127 = v38 + 4 * v125 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v127;
              unint64_t v123 = v126;
            }
            unint64_t v580 = v123;
            if (v573) {
              uint64_t v40 = v126;
            }
            else {
              v40 += 4 * v577;
            }
            int v582 = --v119;
            LODWORD(v20) = v572;
          }
          while (v119);
          goto LABEL_763;
        case 11:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          int v128 = v582;
          do
          {
            int v129 = v20;
            do
            {
              unsigned __int32 v130 = HIBYTE(v41->i32[0]);
              if (!v17) {
                LOBYTE(v130) = -1;
              }
              int v131 = HIBYTE(*(_DWORD *)v40);
              if (!v37) {
                LOBYTE(v131) = -1;
              }
              DAplusdDA_14624(v41, v41->i32[0], v130, *(_DWORD *)v40, v131);
              unint64_t v132 = v40 + 4 * v563;
              if (v132 >= v38) {
                uint64_t v133 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v133 = 0;
              }
              uint64_t v40 = v132 + 4 * v133;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v129;
            }
            while (v129);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v134 = v580;
            unint64_t v135 = v580 + 4 * v577;
            uint64_t v136 = -(uint64_t)(v577 * v564);
            if (v135 < v573) {
              uint64_t v136 = 0;
            }
            uint64_t v137 = v135 + 4 * v136;
            uint64_t v138 = v38 + 4 * v136 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v138;
              unint64_t v134 = v137;
            }
            unint64_t v580 = v134;
            if (v573) {
              uint64_t v40 = v137;
            }
            else {
              v40 += 4 * v577;
            }
            int v582 = --v128;
            LODWORD(v20) = v572;
          }
          while (v128);
          goto LABEL_763;
        case 12:
          do
          {
            int v139 = v583[0];
            do
            {
              int v141 = *(_DWORD *)v40 >> 8;
              int v142 = v141 & 0xFF0000;
              if (!v37) {
                int v142 = 16711680;
              }
              int v140 = ((unsigned __int32)v41->i32[0] >> 8) & 0xFF00FF;
              v41->i32[0] = ((v140 + v141 + v142) << 8) & 0xFF00FF00 | ((*(_DWORD *)v40 & 0xFF00FF)
                                                                                       + (v41->i32[0] & 0xFF00FF)) & 0xFF00FF | (15 * ((v140 + v141 + v142) & 0x1000100 | (((*(_DWORD *)v40 & 0xFF00FF) + (v41->i32[0] & 0xFF00FFu)) >> 8) & 0x10001)) | (240 * ((v140 + v141 + v142) & 0x1000100 | (((*(_DWORD *)v40 & 0xFF00FF) + (v41->i32[0] & 0xFF00FFu)) >> 8) & 0x10001));
              unint64_t v143 = v40 + 4 * v563;
              if (v143 >= v38) {
                uint64_t v144 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v144 = 0;
              }
              uint64_t v40 = v143 + 4 * v144;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v139;
            }
            while (v139);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v145 = v580;
            unint64_t v146 = v580 + 4 * v577;
            if (v146 >= v573) {
              uint64_t v147 = -(uint64_t)(v577 * v564);
            }
            else {
              uint64_t v147 = 0;
            }
            uint64_t v148 = v146 + 4 * v147;
            uint64_t v149 = v38 + 4 * v147 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v149;
              unint64_t v145 = v148;
            }
            unint64_t v580 = v145;
            if (v573) {
              uint64_t v40 = v148;
            }
            else {
              v40 += 4 * v577;
            }
            --v582;
          }
          while (v582);
          goto LABEL_765;
        case 13:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v150 = v583[0];
            do
            {
              if (!v37)
              {
                int v151 = 255;
LABEL_277:
                unsigned int v152 = v41->i32[0];
                if (v17)
                {
                  int v153 = HIBYTE(v152);
                  int v154 = *(_DWORD *)v40;
                  if (!HIBYTE(v152))
                  {
                    __int32 v155 = v154 & 0xFFFFFF | (v151 << 24);
LABEL_282:
                    v41->i32[0] = v155;
                    goto LABEL_283;
                  }
                }
                else
                {
                  int v154 = *(_DWORD *)v40;
                  int v153 = 255;
                }
                __int32 v155 = PDAmultiplyPDA_14625(v152, v153, v154, v151);
                goto LABEL_282;
              }
              int v151 = HIBYTE(*(_DWORD *)v40);
              if (v151) {
                goto LABEL_277;
              }
LABEL_283:
              unint64_t v156 = v40 + 4 * v563;
              if (v156 >= v38) {
                uint64_t v157 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v157 = 0;
              }
              uint64_t v40 = v156 + 4 * v157;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v150;
            }
            while (v150);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v158 = v580;
            unint64_t v159 = v580 + 4 * v577;
            uint64_t v160 = -(uint64_t)(v577 * v564);
            if (v159 < v573) {
              uint64_t v160 = 0;
            }
            uint64_t v161 = v159 + 4 * v160;
            uint64_t v162 = v38 + 4 * v160 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v162;
              unint64_t v158 = v161;
            }
            unint64_t v580 = v158;
            if (v573) {
              uint64_t v40 = v161;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 14:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v163 = v583[0];
            do
            {
              if (!v37)
              {
                int v164 = 255;
LABEL_302:
                unsigned int v165 = v41->i32[0];
                if (v17)
                {
                  int v166 = HIBYTE(v165);
                  int v167 = *(_DWORD *)v40;
                  if (!HIBYTE(v165))
                  {
                    __int32 v168 = v167 & 0xFFFFFF | (v164 << 24);
LABEL_307:
                    v41->i32[0] = v168;
                    goto LABEL_308;
                  }
                }
                else
                {
                  int v167 = *(_DWORD *)v40;
                  int v166 = 255;
                }
                __int32 v168 = PDAscreenPDA_14626(v165, v166, v167, v164);
                goto LABEL_307;
              }
              int v164 = HIBYTE(*(_DWORD *)v40);
              if (v164) {
                goto LABEL_302;
              }
LABEL_308:
              unint64_t v169 = v40 + 4 * v563;
              if (v169 >= v38) {
                uint64_t v170 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v170 = 0;
              }
              uint64_t v40 = v169 + 4 * v170;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v163;
            }
            while (v163);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v171 = v580;
            unint64_t v172 = v580 + 4 * v577;
            uint64_t v173 = -(uint64_t)(v577 * v564);
            if (v172 < v573) {
              uint64_t v173 = 0;
            }
            uint64_t v174 = v172 + 4 * v173;
            uint64_t v175 = v38 + 4 * v173 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v175;
              unint64_t v171 = v174;
            }
            unint64_t v580 = v171;
            if (v573) {
              uint64_t v40 = v174;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 15:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v176 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v177 = 255;
LABEL_327:
                unsigned int v178 = v41->i32[0];
                if (v17)
                {
                  unsigned int v179 = HIBYTE(v178);
                  int v180 = *(_DWORD *)v40;
                  if (!HIBYTE(v178))
                  {
                    __int32 v181 = v180 & 0xFFFFFF | (v177 << 24);
LABEL_332:
                    v41->i32[0] = v181;
                    goto LABEL_333;
                  }
                }
                else
                {
                  int v180 = *(_DWORD *)v40;
                  unsigned int v179 = 255;
                }
                __int32 v181 = PDAoverlayPDA_14627(v178, v179, v180, v177);
                goto LABEL_332;
              }
              unsigned int v177 = HIBYTE(*(_DWORD *)v40);
              if (v177) {
                goto LABEL_327;
              }
LABEL_333:
              unint64_t v182 = v40 + 4 * v563;
              if (v182 >= v38) {
                uint64_t v183 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v183 = 0;
              }
              uint64_t v40 = v182 + 4 * v183;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v176;
            }
            while (v176);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v184 = v580;
            unint64_t v185 = v580 + 4 * v577;
            uint64_t v186 = -(uint64_t)(v577 * v564);
            if (v185 < v573) {
              uint64_t v186 = 0;
            }
            uint64_t v187 = v185 + 4 * v186;
            uint64_t v188 = v38 + 4 * v186 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v188;
              unint64_t v184 = v187;
            }
            unint64_t v580 = v184;
            if (v573) {
              uint64_t v40 = v187;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 16:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v189 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v190 = 255;
LABEL_352:
                unsigned int v191 = v41->i32[0];
                if (v17)
                {
                  unsigned int v192 = HIBYTE(v191);
                  unsigned int v193 = *(_DWORD *)v40;
                  if (!HIBYTE(v191))
                  {
                    __int32 v194 = v193 & 0xFFFFFF | (v190 << 24);
LABEL_357:
                    v41->i32[0] = v194;
                    goto LABEL_358;
                  }
                }
                else
                {
                  unsigned int v193 = *(_DWORD *)v40;
                  unsigned int v192 = 255;
                }
                __int32 v194 = PDAdarkenPDA_14629(v191, v192, v193, v190);
                goto LABEL_357;
              }
              unsigned int v190 = HIBYTE(*(_DWORD *)v40);
              if (v190) {
                goto LABEL_352;
              }
LABEL_358:
              unint64_t v195 = v40 + 4 * v563;
              if (v195 >= v38) {
                uint64_t v196 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v196 = 0;
              }
              uint64_t v40 = v195 + 4 * v196;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v189;
            }
            while (v189);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v197 = v580;
            unint64_t v198 = v580 + 4 * v577;
            uint64_t v199 = -(uint64_t)(v577 * v564);
            if (v198 < v573) {
              uint64_t v199 = 0;
            }
            uint64_t v200 = v198 + 4 * v199;
            uint64_t v201 = v38 + 4 * v199 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v201;
              unint64_t v197 = v200;
            }
            unint64_t v580 = v197;
            if (v573) {
              uint64_t v40 = v200;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 17:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v202 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v203 = 255;
LABEL_377:
                unsigned int v204 = v41->i32[0];
                if (v17)
                {
                  unsigned int v205 = HIBYTE(v204);
                  unsigned int v206 = *(_DWORD *)v40;
                  if (!HIBYTE(v204))
                  {
                    __int32 v207 = v206 & 0xFFFFFF | (v203 << 24);
LABEL_382:
                    v41->i32[0] = v207;
                    goto LABEL_383;
                  }
                }
                else
                {
                  unsigned int v206 = *(_DWORD *)v40;
                  unsigned int v205 = 255;
                }
                __int32 v207 = PDAlightenPDA_14628(v204, v205, v206, v203);
                goto LABEL_382;
              }
              unsigned int v203 = HIBYTE(*(_DWORD *)v40);
              if (v203) {
                goto LABEL_377;
              }
LABEL_383:
              unint64_t v208 = v40 + 4 * v563;
              if (v208 >= v38) {
                uint64_t v209 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v209 = 0;
              }
              uint64_t v40 = v208 + 4 * v209;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v202;
            }
            while (v202);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v210 = v580;
            unint64_t v211 = v580 + 4 * v577;
            uint64_t v212 = -(uint64_t)(v577 * v564);
            if (v211 < v573) {
              uint64_t v212 = 0;
            }
            uint64_t v213 = v211 + 4 * v212;
            uint64_t v214 = v38 + 4 * v212 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v214;
              unint64_t v210 = v213;
            }
            unint64_t v580 = v210;
            if (v573) {
              uint64_t v40 = v213;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 18:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v215 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v216 = 255;
LABEL_402:
                unsigned int v217 = v41->i32[0];
                if (v17)
                {
                  unsigned int v218 = HIBYTE(v217);
                  int v219 = *(_DWORD *)v40;
                  if (!HIBYTE(v217))
                  {
                    __int32 v220 = v219 & 0xFFFFFF | (v216 << 24);
LABEL_407:
                    v41->i32[0] = v220;
                    goto LABEL_408;
                  }
                }
                else
                {
                  int v219 = *(_DWORD *)v40;
                  unsigned int v218 = 255;
                }
                __int32 v220 = PDAcolordodgePDA_14630(v217, v218, v219, v216);
                goto LABEL_407;
              }
              unsigned int v216 = HIBYTE(*(_DWORD *)v40);
              if (v216) {
                goto LABEL_402;
              }
LABEL_408:
              unint64_t v221 = v40 + 4 * v563;
              if (v221 >= v38) {
                uint64_t v222 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v222 = 0;
              }
              uint64_t v40 = v221 + 4 * v222;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v215;
            }
            while (v215);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v223 = v580;
            unint64_t v224 = v580 + 4 * v577;
            uint64_t v225 = -(uint64_t)(v577 * v564);
            if (v224 < v573) {
              uint64_t v225 = 0;
            }
            uint64_t v226 = v224 + 4 * v225;
            uint64_t v227 = v38 + 4 * v225 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v227;
              unint64_t v223 = v226;
            }
            unint64_t v580 = v223;
            if (v573) {
              uint64_t v40 = v226;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 19:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v228 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v229 = 255;
LABEL_427:
                unsigned int v230 = v41->i32[0];
                if (v17)
                {
                  unsigned int v231 = HIBYTE(v230);
                  int v232 = *(_DWORD *)v40;
                  if (!HIBYTE(v230))
                  {
                    __int32 v233 = v232 & 0xFFFFFF | (v229 << 24);
LABEL_432:
                    v41->i32[0] = v233;
                    goto LABEL_433;
                  }
                }
                else
                {
                  int v232 = *(_DWORD *)v40;
                  unsigned int v231 = 255;
                }
                __int32 v233 = PDAcolorburnPDA_14631(v230, v231, v232, v229);
                goto LABEL_432;
              }
              unsigned int v229 = HIBYTE(*(_DWORD *)v40);
              if (v229) {
                goto LABEL_427;
              }
LABEL_433:
              unint64_t v234 = v40 + 4 * v563;
              if (v234 >= v38) {
                uint64_t v235 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v235 = 0;
              }
              uint64_t v40 = v234 + 4 * v235;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v228;
            }
            while (v228);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v236 = v580;
            unint64_t v237 = v580 + 4 * v577;
            uint64_t v238 = -(uint64_t)(v577 * v564);
            if (v237 < v573) {
              uint64_t v238 = 0;
            }
            uint64_t v239 = v237 + 4 * v238;
            uint64_t v240 = v38 + 4 * v238 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v240;
              unint64_t v236 = v239;
            }
            unint64_t v580 = v236;
            if (v573) {
              uint64_t v40 = v239;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 20:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v241 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v242 = 255;
LABEL_452:
                unsigned int v243 = v41->i32[0];
                if (v17)
                {
                  unsigned int v244 = HIBYTE(v243);
                  int v245 = *(_DWORD *)v40;
                  if (!HIBYTE(v243))
                  {
                    __int32 v246 = v245 & 0xFFFFFF | (v242 << 24);
LABEL_457:
                    v41->i32[0] = v246;
                    goto LABEL_458;
                  }
                }
                else
                {
                  int v245 = *(_DWORD *)v40;
                  unsigned int v244 = 255;
                }
                __int32 v246 = PDAsoftlightPDA_14633(v243, v244, v245, v242);
                goto LABEL_457;
              }
              unsigned int v242 = HIBYTE(*(_DWORD *)v40);
              if (v242) {
                goto LABEL_452;
              }
LABEL_458:
              unint64_t v247 = v40 + 4 * v563;
              if (v247 >= v38) {
                uint64_t v248 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v248 = 0;
              }
              uint64_t v40 = v247 + 4 * v248;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v241;
            }
            while (v241);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v249 = v580;
            unint64_t v250 = v580 + 4 * v577;
            uint64_t v251 = -(uint64_t)(v577 * v564);
            if (v250 < v573) {
              uint64_t v251 = 0;
            }
            uint64_t v252 = v250 + 4 * v251;
            uint64_t v253 = v38 + 4 * v251 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v253;
              unint64_t v249 = v252;
            }
            unint64_t v580 = v249;
            if (v573) {
              uint64_t v40 = v252;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 21:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v254 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v255 = 255;
LABEL_477:
                unsigned int v256 = v41->i32[0];
                if (v17)
                {
                  unsigned int v257 = HIBYTE(v256);
                  int v258 = *(_DWORD *)v40;
                  if (!HIBYTE(v256))
                  {
                    __int32 v259 = v258 & 0xFFFFFF | (v255 << 24);
LABEL_482:
                    v41->i32[0] = v259;
                    goto LABEL_483;
                  }
                }
                else
                {
                  int v258 = *(_DWORD *)v40;
                  unsigned int v257 = 255;
                }
                __int32 v259 = PDAhardlightPDA_14632(v256, v257, v258, v255);
                goto LABEL_482;
              }
              unsigned int v255 = HIBYTE(*(_DWORD *)v40);
              if (v255) {
                goto LABEL_477;
              }
LABEL_483:
              unint64_t v260 = v40 + 4 * v563;
              if (v260 >= v38) {
                uint64_t v261 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v261 = 0;
              }
              uint64_t v40 = v260 + 4 * v261;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v254;
            }
            while (v254);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v262 = v580;
            unint64_t v263 = v580 + 4 * v577;
            uint64_t v264 = -(uint64_t)(v577 * v564);
            if (v263 < v573) {
              uint64_t v264 = 0;
            }
            uint64_t v265 = v263 + 4 * v264;
            uint64_t v266 = v38 + 4 * v264 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v266;
              unint64_t v262 = v265;
            }
            unint64_t v580 = v262;
            if (v573) {
              uint64_t v40 = v265;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 22:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v267 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v268 = 255;
LABEL_502:
                unsigned __int32 v269 = v41->i32[0];
                if (v17)
                {
                  unsigned int v270 = HIBYTE(v269);
                  unsigned __int32 v271 = *(_DWORD *)v40;
                  if (!HIBYTE(v269))
                  {
                    __int32 v272 = v271 & 0xFFFFFF | (v268 << 24);
LABEL_507:
                    v41->i32[0] = v272;
                    goto LABEL_508;
                  }
                }
                else
                {
                  unsigned __int32 v271 = *(_DWORD *)v40;
                  unsigned int v270 = 255;
                }
                __int32 v272 = PDAdifferencePDA_14634(v269, v270, v271, v268);
                goto LABEL_507;
              }
              unsigned int v268 = HIBYTE(*(_DWORD *)v40);
              if (v268) {
                goto LABEL_502;
              }
LABEL_508:
              unint64_t v273 = v40 + 4 * v563;
              if (v273 >= v38) {
                uint64_t v274 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v274 = 0;
              }
              uint64_t v40 = v273 + 4 * v274;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v267;
            }
            while (v267);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v275 = v580;
            unint64_t v276 = v580 + 4 * v577;
            uint64_t v277 = -(uint64_t)(v577 * v564);
            if (v276 < v573) {
              uint64_t v277 = 0;
            }
            uint64_t v278 = v276 + 4 * v277;
            uint64_t v279 = v38 + 4 * v277 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v279;
              unint64_t v275 = v278;
            }
            unint64_t v580 = v275;
            if (v573) {
              uint64_t v40 = v278;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 23:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v280 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v281 = 255;
LABEL_527:
                unsigned int v282 = v41->i32[0];
                if (v17)
                {
                  unsigned int v283 = HIBYTE(v282);
                  int v284 = *(_DWORD *)v40;
                  if (!HIBYTE(v282))
                  {
                    __int32 v285 = v284 & 0xFFFFFF | (v281 << 24);
LABEL_532:
                    v41->i32[0] = v285;
                    goto LABEL_533;
                  }
                }
                else
                {
                  int v284 = *(_DWORD *)v40;
                  unsigned int v283 = 255;
                }
                __int32 v285 = PDAexclusionPDA_14635(v282, v283, v284, v281);
                goto LABEL_532;
              }
              unsigned int v281 = HIBYTE(*(_DWORD *)v40);
              if (v281) {
                goto LABEL_527;
              }
LABEL_533:
              unint64_t v286 = v40 + 4 * v563;
              if (v286 >= v38) {
                uint64_t v287 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v287 = 0;
              }
              uint64_t v40 = v286 + 4 * v287;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v280;
            }
            while (v280);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v288 = v580;
            unint64_t v289 = v580 + 4 * v577;
            uint64_t v290 = -(uint64_t)(v577 * v564);
            if (v289 < v573) {
              uint64_t v290 = 0;
            }
            uint64_t v291 = v289 + 4 * v290;
            uint64_t v292 = v38 + 4 * v290 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v292;
              unint64_t v288 = v291;
            }
            unint64_t v580 = v288;
            if (v573) {
              uint64_t v40 = v291;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 24:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v293 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v294 = 255;
LABEL_552:
                unsigned __int32 v295 = v41->i32[0];
                if (v17)
                {
                  unsigned int v296 = HIBYTE(v295);
                  int v297 = *(_DWORD *)v40;
                  if (!HIBYTE(v295))
                  {
                    __int32 v298 = v297 & 0xFFFFFF | (v294 << 24);
LABEL_557:
                    v41->i32[0] = v298;
                    goto LABEL_558;
                  }
                }
                else
                {
                  int v297 = *(_DWORD *)v40;
                  unsigned int v296 = 255;
                }
                __int32 v298 = PDAhuePDA_14636(v295, v296, v297, v294);
                goto LABEL_557;
              }
              unsigned int v294 = HIBYTE(*(_DWORD *)v40);
              if (v294) {
                goto LABEL_552;
              }
LABEL_558:
              unint64_t v299 = v40 + 4 * v563;
              if (v299 >= v38) {
                uint64_t v300 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v300 = 0;
              }
              uint64_t v40 = v299 + 4 * v300;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v293;
            }
            while (v293);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v301 = v580;
            unint64_t v302 = v580 + 4 * v577;
            uint64_t v303 = -(uint64_t)(v577 * v564);
            if (v302 < v573) {
              uint64_t v303 = 0;
            }
            uint64_t v304 = v302 + 4 * v303;
            uint64_t v305 = v38 + 4 * v303 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v305;
              unint64_t v301 = v304;
            }
            unint64_t v580 = v301;
            if (v573) {
              uint64_t v40 = v304;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 25:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v306 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v307 = 255;
LABEL_577:
                unsigned __int32 v308 = v41->i32[0];
                if (v17)
                {
                  unsigned int v309 = HIBYTE(v308);
                  int v310 = *(_DWORD *)v40;
                  if (!HIBYTE(v308))
                  {
                    __int32 v311 = v310 & 0xFFFFFF | (v307 << 24);
LABEL_582:
                    v41->i32[0] = v311;
                    goto LABEL_583;
                  }
                }
                else
                {
                  int v310 = *(_DWORD *)v40;
                  unsigned int v309 = 255;
                }
                __int32 v311 = PDAsaturationPDA_14637(v308, v309, v310, v307);
                goto LABEL_582;
              }
              unsigned int v307 = HIBYTE(*(_DWORD *)v40);
              if (v307) {
                goto LABEL_577;
              }
LABEL_583:
              unint64_t v312 = v40 + 4 * v563;
              if (v312 >= v38) {
                uint64_t v313 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v313 = 0;
              }
              uint64_t v40 = v312 + 4 * v313;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v306;
            }
            while (v306);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v314 = v580;
            unint64_t v315 = v580 + 4 * v577;
            uint64_t v316 = -(uint64_t)(v577 * v564);
            if (v315 < v573) {
              uint64_t v316 = 0;
            }
            uint64_t v317 = v315 + 4 * v316;
            uint64_t v318 = v38 + 4 * v316 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v318;
              unint64_t v314 = v317;
            }
            unint64_t v580 = v314;
            if (v573) {
              uint64_t v40 = v317;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 26:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v319 = v583[0];
            do
            {
              if (v37)
              {
                unsigned int v320 = HIBYTE(*(_DWORD *)v40);
                if (!v320) {
                  goto LABEL_607;
                }
                if (!v17)
                {
LABEL_604:
                  int v323 = *(_DWORD *)v40;
                  unsigned int v321 = v41->i32[0];
                  unsigned int v322 = 255;
LABEL_605:
                  __int32 v324 = PDAluminosityPDA_14638(v323, v320, v321, v322);
                  goto LABEL_606;
                }
              }
              else
              {
                unsigned int v320 = 255;
                if (!v17) {
                  goto LABEL_604;
                }
              }
              unsigned int v321 = v41->i32[0];
              unsigned int v322 = HIBYTE(v41->i32[0]);
              int v323 = *(_DWORD *)v40;
              if (v322) {
                goto LABEL_605;
              }
              __int32 v324 = v323 & 0xFFFFFF | (v320 << 24);
LABEL_606:
              v41->i32[0] = v324;
LABEL_607:
              unint64_t v325 = v40 + 4 * v563;
              if (v325 >= v38) {
                uint64_t v326 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v326 = 0;
              }
              uint64_t v40 = v325 + 4 * v326;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v319;
            }
            while (v319);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v327 = v580;
            unint64_t v328 = v580 + 4 * v577;
            uint64_t v329 = -(uint64_t)(v577 * v564);
            if (v328 < v573) {
              uint64_t v329 = 0;
            }
            uint64_t v330 = v328 + 4 * v329;
            uint64_t v331 = v38 + 4 * v329 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v331;
              unint64_t v327 = v330;
            }
            unint64_t v580 = v327;
            if (v573) {
              uint64_t v40 = v330;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 27:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v332 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v333 = 255;
LABEL_626:
                unsigned __int32 v334 = v41->i32[0];
                if (v17)
                {
                  unsigned int v335 = HIBYTE(v334);
                  unsigned int v336 = *(_DWORD *)v40;
                  if (!HIBYTE(v334))
                  {
                    __int32 v337 = v336 & 0xFFFFFF | (v333 << 24);
LABEL_631:
                    v41->i32[0] = v337;
                    goto LABEL_632;
                  }
                }
                else
                {
                  unsigned int v336 = *(_DWORD *)v40;
                  unsigned int v335 = 255;
                }
                __int32 v337 = PDAluminosityPDA_14638(v334, v335, v336, v333);
                goto LABEL_631;
              }
              unsigned int v333 = HIBYTE(*(_DWORD *)v40);
              if (v333) {
                goto LABEL_626;
              }
LABEL_632:
              unint64_t v338 = v40 + 4 * v563;
              if (v338 >= v38) {
                uint64_t v339 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v339 = 0;
              }
              uint64_t v40 = v338 + 4 * v339;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v332;
            }
            while (v332);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v340 = v580;
            unint64_t v341 = v580 + 4 * v577;
            uint64_t v342 = -(uint64_t)(v577 * v564);
            if (v341 < v573) {
              uint64_t v342 = 0;
            }
            uint64_t v343 = v341 + 4 * v342;
            uint64_t v344 = v38 + 4 * v342 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v344;
              unint64_t v340 = v343;
            }
            unint64_t v580 = v340;
            if (v573) {
              uint64_t v40 = v343;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 28:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v345 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v346 = 255;
LABEL_651:
                unsigned __int32 v347 = v41->i32[0];
                if (v17)
                {
                  unsigned int v348 = HIBYTE(v347);
                  int v349 = *(_DWORD *)v40;
                  if (!HIBYTE(v347))
                  {
                    __int32 v350 = v349 & 0xFFFFFF | (v346 << 24);
LABEL_656:
                    v41->i32[0] = v350;
                    goto LABEL_657;
                  }
                }
                else
                {
                  int v349 = *(_DWORD *)v40;
                  unsigned int v348 = 255;
                }
                __int32 v350 = PDAtranspose_huePDA_14639(v347, v348, v349, v346);
                goto LABEL_656;
              }
              unsigned int v346 = HIBYTE(*(_DWORD *)v40);
              if (v346) {
                goto LABEL_651;
              }
LABEL_657:
              unint64_t v351 = v40 + 4 * v563;
              if (v351 >= v38) {
                uint64_t v352 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v352 = 0;
              }
              uint64_t v40 = v351 + 4 * v352;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v345;
            }
            while (v345);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v353 = v580;
            unint64_t v354 = v580 + 4 * v577;
            uint64_t v355 = -(uint64_t)(v577 * v564);
            if (v354 < v573) {
              uint64_t v355 = 0;
            }
            uint64_t v356 = v354 + 4 * v355;
            uint64_t v357 = v38 + 4 * v355 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v357;
              unint64_t v353 = v356;
            }
            unint64_t v580 = v353;
            if (v573) {
              uint64_t v40 = v356;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 29:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v358 = v583[0];
            do
            {
              if (!v37)
              {
                unsigned int v359 = 255;
LABEL_676:
                unsigned __int32 v360 = v41->i32[0];
                if (v17)
                {
                  unsigned int v361 = HIBYTE(v360);
                  int v362 = *(_DWORD *)v40;
                  if (!HIBYTE(v360))
                  {
                    __int32 v363 = v362 & 0xFFFFFF | (v359 << 24);
LABEL_681:
                    v41->i32[0] = v363;
                    goto LABEL_682;
                  }
                }
                else
                {
                  int v362 = *(_DWORD *)v40;
                  unsigned int v361 = 255;
                }
                __int32 v363 = PDAtranspose_saturationPDA_14640(v360, v361, v362, v359);
                goto LABEL_681;
              }
              unsigned int v359 = HIBYTE(*(_DWORD *)v40);
              if (v359) {
                goto LABEL_676;
              }
LABEL_682:
              unint64_t v364 = v40 + 4 * v563;
              if (v364 >= v38) {
                uint64_t v365 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v365 = 0;
              }
              uint64_t v40 = v364 + 4 * v365;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v358;
            }
            while (v358);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v366 = v580;
            unint64_t v367 = v580 + 4 * v577;
            uint64_t v368 = -(uint64_t)(v577 * v564);
            if (v367 < v573) {
              uint64_t v368 = 0;
            }
            uint64_t v369 = v367 + 4 * v368;
            uint64_t v370 = v38 + 4 * v368 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v370;
              unint64_t v366 = v369;
            }
            unint64_t v580 = v366;
            if (v573) {
              uint64_t v40 = v369;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 30:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          while (1)
          {
            int v371 = v583[0];
            do
            {
              if (v37)
              {
                unsigned int v372 = HIBYTE(*(_DWORD *)v40);
                if (!v372) {
                  goto LABEL_706;
                }
                if (!v17)
                {
LABEL_703:
                  int v375 = *(_DWORD *)v40;
                  unsigned int v373 = v41->i32[0];
                  unsigned int v374 = 255;
LABEL_704:
                  __int32 v376 = PDAtranspose_luminosityPDA_14641(v375, v372, v373, v374);
                  goto LABEL_705;
                }
              }
              else
              {
                unsigned int v372 = 255;
                if (!v17) {
                  goto LABEL_703;
                }
              }
              unsigned int v373 = v41->i32[0];
              unsigned int v374 = HIBYTE(v41->i32[0]);
              int v375 = *(_DWORD *)v40;
              if (v374) {
                goto LABEL_704;
              }
              __int32 v376 = v375 & 0xFFFFFF | (v372 << 24);
LABEL_705:
              v41->i32[0] = v376;
LABEL_706:
              unint64_t v377 = v40 + 4 * v563;
              if (v377 >= v38) {
                uint64_t v378 = -(uint64_t)(int)v569;
              }
              else {
                uint64_t v378 = 0;
              }
              uint64_t v40 = v377 + 4 * v378;
              uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
              --v371;
            }
            while (v371);
            uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
            unint64_t v379 = v580;
            unint64_t v380 = v580 + 4 * v577;
            uint64_t v381 = -(uint64_t)(v577 * v564);
            if (v380 < v573) {
              uint64_t v381 = 0;
            }
            uint64_t v382 = v380 + 4 * v381;
            uint64_t v383 = v38 + 4 * v381 + 4 * v577;
            if (v573)
            {
              unint64_t v38 = v383;
              unint64_t v379 = v382;
            }
            unint64_t v580 = v379;
            if (v573) {
              uint64_t v40 = v382;
            }
            else {
              v40 += 4 * v577;
            }
            if (!--v582) {
              goto LABEL_764;
            }
          }
        case 31:
          uint64_t v565 = v29;
          unint64_t v566 = v30;
          unint64_t v567 = v31;
          break;
        default:
          goto LABEL_765;
      }
      break;
    }
LABEL_720:
    int v384 = v583[0];
    while (1)
    {
      if (v37)
      {
        unsigned int v385 = HIBYTE(*(_DWORD *)v40);
        if (!v385) {
          goto LABEL_731;
        }
      }
      else
      {
        unsigned int v385 = 255;
      }
      unsigned __int32 v386 = v41->i32[0];
      if (!v17) {
        break;
      }
      unsigned int v387 = HIBYTE(v386);
      unsigned int v388 = *(_DWORD *)v40;
      if (HIBYTE(v386)) {
        goto LABEL_729;
      }
      __int32 v389 = v388 & 0xFFFFFF | (v385 << 24);
LABEL_730:
      v41->i32[0] = v389;
LABEL_731:
      unint64_t v390 = v40 + 4 * v563;
      if (v390 >= v38) {
        uint64_t v391 = -(uint64_t)(int)v569;
      }
      else {
        uint64_t v391 = 0;
      }
      uint64_t v40 = v390 + 4 * v391;
      uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v563);
      if (!--v384)
      {
        uint64_t v41 = (uint32x2_t *)((char *)v41 + 4 * v576);
        unint64_t v392 = v580;
        unint64_t v393 = v580 + 4 * v577;
        uint64_t v394 = -(uint64_t)(v577 * v564);
        if (v393 < v573) {
          uint64_t v394 = 0;
        }
        uint64_t v395 = v393 + 4 * v394;
        uint64_t v396 = v38 + 4 * v394 + 4 * v577;
        if (v573)
        {
          unint64_t v38 = v396;
          unint64_t v392 = v395;
        }
        unint64_t v580 = v392;
        if (v573) {
          uint64_t v40 = v395;
        }
        else {
          v40 += 4 * v577;
        }
        if (!--v582) {
          goto LABEL_764;
        }
        goto LABEL_720;
      }
    }
    unsigned int v388 = *(_DWORD *)v40;
    unsigned int v387 = 255;
LABEL_729:
    __int32 v389 = PDAtranspose_luminosityPDA_14641(v386, v387, v388, v385);
    goto LABEL_730;
  }
  if (BYTE1(v15) != 4) {
    goto LABEL_36;
  }
  int v582 = *(_DWORD *)(v12 + 8);
  v583[0] = v20;
  unsigned int v25 = **(_DWORD **)(v12 + 88);
  unint64_t v571 = *(int *)(v12 + 28);
  unint64_t v579 = v571 >> 2;
  int v26 = (unsigned int *)(*(void *)(v12 + 40) + 4 * (*(int *)(v12 + 12) + (v571 >> 2) * *(int *)(v12 + 16)));
  v575 = v26;
  if (v23)
  {
    shape_enum_clip_alloc((uint64_t)a1, a2, v23, 1, 1, 1, *(_DWORD *)(v12 + 104), *(_DWORD *)(v12 + 108), v20, v22);
    uint64_t v18 = v27;
    if (v27) {
      goto LABEL_1101;
    }
    return 1;
  }
  uint64_t v578 = 0;
  while (2)
  {
    unint64_t v439 = v579 - (int)v20;
    int v440 = v20;
    switch((int)v18)
    {
      case 0:
        unsigned int v441 = v582;
        int v442 = 4 * v20;
        int v443 = v571 & 0xFFFFFFFC;
        int v444 = 0;
        goto LABEL_858;
      case 1:
        int v444 = 0;
        v452 = *(int **)(v560 + 88);
        if (v452) {
          int v444 = *v452;
        }
        int v442 = 4 * v20;
        unsigned int v441 = v582;
        int v443 = v571 & 0xFFFFFFFC;
LABEL_858:
        CGBlt_fillBytes(v442, v441, v444, (char *)v26, v443);
        goto LABEL_1099;
      case 2:
        int v574 = v20 & 3;
        int v453 = v582;
        unsigned int v454 = (v20 >> 2) + 1;
        do
        {
          if ((int)v20 < 4)
          {
            int v458 = v20;
          }
          else
          {
            unsigned int v455 = v454;
            do
            {
              DplusDM_14623(v26, v25, *v26, ~HIBYTE(v25));
              DplusDM_14623(v26 + 1, v25, v26[1], ~HIBYTE(v25));
              DplusDM_14623(v26 + 2, v25, v26[2], ~HIBYTE(v25));
              unsigned int v457 = v26[3];
              v456 = v26 + 3;
              DplusDM_14623(v456, v25, v457, ~HIBYTE(v25));
              int v26 = v456 + 1;
              --v455;
            }
            while (v455 > 1);
            int v458 = v574;
          }
          if (v458 < 1)
          {
            v460 = v26;
          }
          else
          {
            unsigned int v459 = v458 + 1;
            v460 = v26;
            do
            {
              unsigned int v461 = *v460++;
              DplusDM_14623(v26, v25, v461, ~HIBYTE(v25));
              --v459;
              int v26 = v460;
            }
            while (v459 > 1);
          }
          int v26 = &v460[v439];
          int v582 = --v453;
          LODWORD(v20) = v440;
        }
        while (v453);
        goto LABEL_1099;
      case 3:
        do
        {
          int v445 = v583[0];
          do
          {
            int v446 = HIBYTE(*v26);
            if (v446)
            {
              unsigned int v447 = v25;
              if (v446 != 255) {
                unsigned int v447 = PDM_14621(v25, v446);
              }
            }
            else
            {
              unsigned int v447 = 0;
            }
            *v26++ = v447;
            --v445;
          }
          while (v445);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 4:
        do
        {
          int v448 = v583[0];
          do
          {
            int v449 = *((unsigned __int8 *)v26 + 3) ^ 0xFF;
            if (v449)
            {
              unsigned int v450 = v25;
              if (v449 != 255) {
                unsigned int v450 = PDM_14621(v25, v449);
              }
            }
            else
            {
              unsigned int v450 = 0;
            }
            *v26++ = v450;
            --v448;
          }
          while (v448);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 5:
        int v462 = v582;
        do
        {
          int v463 = v20;
          v464 = v26;
          do
          {
            unsigned int v465 = *v464++;
            DMplusDM_14622(v26, v25, HIBYTE(v465), v465, ~HIBYTE(v25));
            int v26 = v464;
            --v463;
          }
          while (v463);
          int v26 = &v464[v439];
          int v582 = --v462;
          LODWORD(v20) = v440;
        }
        while (v462);
        goto LABEL_1099;
      case 6:
        do
        {
          int v466 = v583[0];
          do
          {
            if (~HIBYTE(*v26))
            {
              if (~HIBYTE(*v26) == 255) {
                *int v26 = v25;
              }
              else {
                DplusDM_14623(v26, *v26, v25, ~HIBYTE(*v26));
              }
            }
            ++v26;
            --v466;
          }
          while (v466);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 7:
        do
        {
          int v467 = v583[0];
          do
          {
            *int v26 = PDM_14621(*v26, HIBYTE(v25));
            ++v26;
            --v467;
          }
          while (v467);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 8:
        do
        {
          int v451 = v583[0];
          do
          {
            *int v26 = PDM_14621(*v26, ~HIBYTE(v25));
            ++v26;
            --v451;
          }
          while (v451);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 9:
        int v468 = v582;
        do
        {
          int v469 = v20;
          v470 = v26;
          do
          {
            unsigned int v471 = *v470++;
            DMplusDM_14622(v26, v25, ~v471 >> 24, v471, HIBYTE(v25));
            int v26 = v470;
            --v469;
          }
          while (v469);
          int v26 = &v470[v439];
          int v582 = --v468;
          LODWORD(v20) = v440;
        }
        while (v468);
        goto LABEL_1099;
      case 10:
        int v472 = v582;
        do
        {
          int v473 = v20;
          v474 = v26;
          do
          {
            unsigned int v475 = *v474++;
            DMplusDM_14622(v26, v25, ~v475 >> 24, v475, ~HIBYTE(v25));
            int v26 = v474;
            --v473;
          }
          while (v473);
          int v26 = &v474[v439];
          int v582 = --v472;
          LODWORD(v20) = v440;
        }
        while (v472);
        goto LABEL_1099;
      case 11:
        int v476 = v582;
        do
        {
          int v477 = v20;
          v478 = v26;
          do
          {
            unsigned int v480 = *v478++;
            int v479 = v480;
            unsigned int v481 = HIBYTE(v480);
            if (!v17) {
              LOBYTE(v481) = -1;
            }
            DAplusdDA_14624(v26, v479, v481, v25, HIBYTE(v25));
            int v26 = v478;
            --v477;
          }
          while (v477);
          int v26 = &v478[v439];
          int v582 = --v476;
          LODWORD(v20) = v440;
        }
        while (v476);
        goto LABEL_1099;
      case 12:
        do
        {
          int v483 = v583[0];
          do
          {
            int v482 = (v25 >> 8) & 0xFF00FF;
            *int v26 = ((((*v26 >> 8) & 0xFF00FF) + v482) << 8) & 0xFF00FF00 | ((*v26 & 0xFF00FF) + (v25 & 0xFF00FF)) & 0xFF00FF | (15 * ((((*v26 >> 8) & 0xFF00FF) + v482) & 0x1000100 | (((*v26 & 0xFF00FF) + (v25 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * ((((*v26 >> 8) & 0xFF00FF) + v482) & 0x1000100 | (((*v26 & 0xFF00FF) + (v25 & 0xFF00FF)) >> 8) & 0x10001));
            ++v26;
            --v483;
          }
          while (v483);
          v26 += v439;
          --v582;
        }
        while (v582);
        goto LABEL_1099;
      case 13:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v484 = v583[0];
          do
          {
            unsigned int v485 = *v26;
            if (!v17)
            {
              int v486 = 255;
LABEL_916:
              unsigned int v487 = PDAmultiplyPDA_14625(v485, v486, v25, HIBYTE(v25));
              goto LABEL_917;
            }
            int v486 = HIBYTE(v485);
            unsigned int v487 = v25;
            if (HIBYTE(v485)) {
              goto LABEL_916;
            }
LABEL_917:
            *v26++ = v487;
            --v484;
          }
          while (v484);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 14:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v488 = v583[0];
          do
          {
            unsigned int v489 = *v26;
            if (!v17)
            {
              int v490 = 255;
LABEL_926:
              unsigned int v491 = PDAscreenPDA_14626(v489, v490, v25, HIBYTE(v25));
              goto LABEL_927;
            }
            int v490 = HIBYTE(v489);
            unsigned int v491 = v25;
            if (HIBYTE(v489)) {
              goto LABEL_926;
            }
LABEL_927:
            *v26++ = v491;
            --v488;
          }
          while (v488);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 15:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v492 = v583[0];
          do
          {
            unsigned int v493 = *v26;
            if (!v17)
            {
              unsigned int v494 = 255;
LABEL_936:
              unsigned int v495 = PDAoverlayPDA_14627(v493, v494, v25, HIBYTE(v25));
              goto LABEL_937;
            }
            unsigned int v494 = HIBYTE(v493);
            unsigned int v495 = v25;
            if (HIBYTE(v493)) {
              goto LABEL_936;
            }
LABEL_937:
            *v26++ = v495;
            --v492;
          }
          while (v492);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 16:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v496 = v583[0];
          do
          {
            unsigned int v497 = *v26;
            if (!v17)
            {
              unsigned int v498 = 255;
LABEL_946:
              unsigned int v499 = PDAdarkenPDA_14629(v497, v498, v25, HIBYTE(v25));
              goto LABEL_947;
            }
            unsigned int v498 = HIBYTE(v497);
            unsigned int v499 = v25;
            if (HIBYTE(v497)) {
              goto LABEL_946;
            }
LABEL_947:
            *v26++ = v499;
            --v496;
          }
          while (v496);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 17:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v500 = v583[0];
          do
          {
            unsigned int v501 = *v26;
            if (!v17)
            {
              unsigned int v502 = 255;
LABEL_956:
              unsigned int v503 = PDAlightenPDA_14628(v501, v502, v25, HIBYTE(v25));
              goto LABEL_957;
            }
            unsigned int v502 = HIBYTE(v501);
            unsigned int v503 = v25;
            if (HIBYTE(v501)) {
              goto LABEL_956;
            }
LABEL_957:
            *v26++ = v503;
            --v500;
          }
          while (v500);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 18:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v504 = v583[0];
          do
          {
            unsigned int v505 = *v26;
            if (!v17)
            {
              unsigned int v506 = 255;
LABEL_966:
              unsigned int v507 = PDAcolordodgePDA_14630(v505, v506, v25, HIBYTE(v25));
              goto LABEL_967;
            }
            unsigned int v506 = HIBYTE(v505);
            unsigned int v507 = v25;
            if (HIBYTE(v505)) {
              goto LABEL_966;
            }
LABEL_967:
            *v26++ = v507;
            --v504;
          }
          while (v504);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 19:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v508 = v583[0];
          do
          {
            unsigned int v509 = *v26;
            if (!v17)
            {
              unsigned int v510 = 255;
LABEL_976:
              unsigned int v511 = PDAcolorburnPDA_14631(v509, v510, v25, HIBYTE(v25));
              goto LABEL_977;
            }
            unsigned int v510 = HIBYTE(v509);
            unsigned int v511 = v25;
            if (HIBYTE(v509)) {
              goto LABEL_976;
            }
LABEL_977:
            *v26++ = v511;
            --v508;
          }
          while (v508);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 20:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v512 = v583[0];
          do
          {
            unsigned int v513 = *v26;
            if (!v17)
            {
              unsigned int v514 = 255;
LABEL_986:
              unsigned int v515 = PDAsoftlightPDA_14633(v513, v514, v25, HIBYTE(v25));
              goto LABEL_987;
            }
            unsigned int v514 = HIBYTE(v513);
            unsigned int v515 = v25;
            if (HIBYTE(v513)) {
              goto LABEL_986;
            }
LABEL_987:
            *v26++ = v515;
            --v512;
          }
          while (v512);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 21:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v516 = v583[0];
          do
          {
            unsigned int v517 = *v26;
            if (!v17)
            {
              unsigned int v518 = 255;
LABEL_996:
              unsigned int v519 = PDAhardlightPDA_14632(v517, v518, v25, HIBYTE(v25));
              goto LABEL_997;
            }
            unsigned int v518 = HIBYTE(v517);
            unsigned int v519 = v25;
            if (HIBYTE(v517)) {
              goto LABEL_996;
            }
LABEL_997:
            *v26++ = v519;
            --v516;
          }
          while (v516);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 22:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v520 = v583[0];
          do
          {
            unsigned __int32 v521 = *v26;
            if (!v17)
            {
              unsigned int v522 = 255;
LABEL_1006:
              unsigned int v523 = PDAdifferencePDA_14634(v521, v522, v25, HIBYTE(v25));
              goto LABEL_1007;
            }
            unsigned int v522 = HIBYTE(v521);
            unsigned int v523 = v25;
            if (HIBYTE(v521)) {
              goto LABEL_1006;
            }
LABEL_1007:
            *v26++ = v523;
            --v520;
          }
          while (v520);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 23:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v524 = v583[0];
          do
          {
            unsigned int v525 = *v26;
            if (!v17)
            {
              unsigned int v526 = 255;
LABEL_1016:
              unsigned int v527 = PDAexclusionPDA_14635(v525, v526, v25, HIBYTE(v25));
              goto LABEL_1017;
            }
            unsigned int v526 = HIBYTE(v525);
            unsigned int v527 = v25;
            if (HIBYTE(v525)) {
              goto LABEL_1016;
            }
LABEL_1017:
            *v26++ = v527;
            --v524;
          }
          while (v524);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 24:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v528 = v583[0];
          do
          {
            unsigned int v529 = *v26;
            if (!v17)
            {
              unsigned int v530 = 255;
LABEL_1026:
              unsigned int v531 = PDAhuePDA_14636(v529, v530, v25, HIBYTE(v25));
              goto LABEL_1027;
            }
            unsigned int v530 = HIBYTE(v529);
            unsigned int v531 = v25;
            if (HIBYTE(v529)) {
              goto LABEL_1026;
            }
LABEL_1027:
            *v26++ = v531;
            --v528;
          }
          while (v528);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 25:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v532 = v583[0];
          do
          {
            unsigned int v533 = *v26;
            if (!v17)
            {
              unsigned int v534 = 255;
LABEL_1036:
              unsigned int v535 = PDAsaturationPDA_14637(v533, v534, v25, HIBYTE(v25));
              goto LABEL_1037;
            }
            unsigned int v534 = HIBYTE(v533);
            unsigned int v535 = v25;
            if (HIBYTE(v533)) {
              goto LABEL_1036;
            }
LABEL_1037:
            *v26++ = v535;
            --v532;
          }
          while (v532);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 26:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v536 = v583[0];
          do
          {
            unsigned int v537 = *v26;
            if (!v17)
            {
              unsigned int v538 = 255;
LABEL_1046:
              unsigned int v539 = PDAluminosityPDA_14638(v25, HIBYTE(v25), v537, v538);
              goto LABEL_1047;
            }
            unsigned int v538 = HIBYTE(v537);
            unsigned int v539 = v25;
            if (HIBYTE(v537)) {
              goto LABEL_1046;
            }
LABEL_1047:
            *v26++ = v539;
            --v536;
          }
          while (v536);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 27:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v540 = v583[0];
          do
          {
            unsigned int v541 = *v26;
            if (!v17)
            {
              unsigned int v542 = 255;
LABEL_1056:
              unsigned int v543 = PDAluminosityPDA_14638(v541, v542, v25, HIBYTE(v25));
              goto LABEL_1057;
            }
            unsigned int v542 = HIBYTE(v541);
            unsigned int v543 = v25;
            if (HIBYTE(v541)) {
              goto LABEL_1056;
            }
LABEL_1057:
            *v26++ = v543;
            --v540;
          }
          while (v540);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 28:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v544 = v583[0];
          do
          {
            unsigned int v545 = *v26;
            if (!v17)
            {
              unsigned int v546 = 255;
LABEL_1066:
              unsigned int v547 = PDAtranspose_huePDA_14639(v545, v546, v25, HIBYTE(v25));
              goto LABEL_1067;
            }
            unsigned int v546 = HIBYTE(v545);
            unsigned int v547 = v25;
            if (HIBYTE(v545)) {
              goto LABEL_1066;
            }
LABEL_1067:
            *v26++ = v547;
            --v544;
          }
          while (v544);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 29:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        while (1)
        {
          int v548 = v583[0];
          do
          {
            unsigned int v549 = *v26;
            if (!v17)
            {
              unsigned int v550 = 255;
LABEL_1076:
              unsigned int v551 = PDAtranspose_saturationPDA_14640(v549, v550, v25, HIBYTE(v25));
              goto LABEL_1077;
            }
            unsigned int v550 = HIBYTE(v549);
            unsigned int v551 = v25;
            if (HIBYTE(v549)) {
              goto LABEL_1076;
            }
LABEL_1077:
            *v26++ = v551;
            --v548;
          }
          while (v548);
          v26 += v439;
          if (!--v582) {
            goto LABEL_1099;
          }
        }
      case 30:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        do
        {
          int v552 = v583[0];
          do
          {
            unsigned int v553 = *v26;
            if (!v17)
            {
              unsigned int v554 = 255;
LABEL_1086:
              unsigned int v555 = PDAtranspose_luminosityPDA_14641(v25, HIBYTE(v25), v553, v554);
              goto LABEL_1087;
            }
            unsigned int v554 = HIBYTE(v553);
            unsigned int v555 = v25;
            if (HIBYTE(v553)) {
              goto LABEL_1086;
            }
LABEL_1087:
            *v26++ = v555;
            --v552;
          }
          while (v552);
          v26 += v439;
          --v582;
        }
        while (v582);
LABEL_1099:
        int v26 = v575;
        uint64_t v18 = v578;
        if (!v578) {
          return 1;
        }
        uint64_t v581 = 0;
LABEL_1101:
        if (shape_enum_clip_next(v18, (int *)&v581 + 1, &v581, v583, &v582))
        {
          uint64_t v578 = v18;
          v26 += v579 * (int)v581 + SHIDWORD(v581);
          LODWORD(v20) = v583[0];
          LODWORD(v18) = v570;
          continue;
        }
        v409 = (void *)v18;
LABEL_1104:
        free(v409);
        return 1;
      case 31:
        if (!HIBYTE(v25)) {
          goto LABEL_1099;
        }
        break;
      default:
        goto LABEL_1099;
    }
    break;
  }
LABEL_1091:
  int v556 = v583[0];
  while (1)
  {
    unsigned int v557 = *v26;
    if (v17)
    {
      unsigned int v558 = HIBYTE(v557);
      unsigned int v559 = v25;
      if (!HIBYTE(v557)) {
        goto LABEL_1097;
      }
    }
    else
    {
      unsigned int v558 = 255;
    }
    unsigned int v559 = PDAtranspose_luminosityPDA_14641(v557, v558, v25, HIBYTE(v25));
LABEL_1097:
    *v26++ = v559;
    if (!--v556)
    {
      v26 += v439;
      if (!--v582) {
        goto LABEL_1099;
      }
      goto LABEL_1091;
    }
  }
}

uint64_t CGSColorMaskCopyARGB8888(uint64_t result, char *a2, int a3, unsigned __int8 *a4, int a5, int a6, int a7, double a8, double a9, double a10, int16x8_t a11)
{
  uint64_t v11 = a3 - 4 * a6;
  uint64_t v12 = a5 - (uint64_t)a6;
  *(int32x2_t *)v13.i8 = vdup_n_s32(result);
  uint8x8_t v14 = (uint8x8_t)vuzp1_s8(*(int8x8_t *)v13.i8, *(int8x8_t *)v13.i8);
  uint8x8_t v15 = (uint8x8_t)vuzp2_s8(*(int8x8_t *)v13.i8, *(int8x8_t *)v13.i8);
  if (result == -16777216)
  {
    if (a7 >= 1)
    {
      do
      {
        int v16 = a6;
        if (a6 >= 4)
        {
          do
          {
            __int32 v18 = *(_DWORD *)a4;
            a4 += 4;
            __int32 v17 = v18;
            if (v18)
            {
              if (v17 == -1)
              {
                vst2_s8(a2, *(int8x8x2_t *)v14.i8);
              }
              else
              {
                v13.i32[0] = v17;
                int8x8x2_t v48 = vld2_s8(a2);
                int8x8_t v19 = vzip1_s8(*(int8x8_t *)v13.i8, *(int8x8_t *)v13.i8);
                uint8x8_t v20 = (uint8x8_t)vmvn_s8(v19);
                int8x16_t v21 = (int8x16_t)vmull_u8((uint8x8_t)v48.val[0], v20);
                int8x8x2_t v48 = (int8x8x2_t)vmull_u8((uint8x8_t)v48.val[1], v20);
                *(int8x8_t *)v21.i8 = vsubhn_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v21, 8uLL), (int16x8_t)vmvnq_s8(v21));
                int16x8_t v13 = vsubq_s16((int16x8_t)v48, (int16x8_t)vmvnq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)v19), 0x18uLL)));
                int8x8_t v22 = vaddhn_s16(v13, (int16x8_t)vshrq_n_u16((uint16x8_t)v48, 8uLL));
                vst2_s8(a2, (int8x8x2_t)v21);
              }
            }
            a2 += 16;
            v16 -= 4;
          }
          while ((v16 + 4) > 7);
        }
        if (v16 >= 1)
        {
          unsigned int v23 = v16 + 1;
          do
          {
            int v25 = *a4++;
            int v24 = v25;
            if (v25)
            {
              if (v24 == 255)
              {
                int v26 = -16777216;
              }
              else
              {
                unsigned int v27 = ((*(_DWORD *)a2 >> 8) & 0xFF00FF) * (v24 ^ 0xFF);
                uint64_t result = (v27 >> 8) & 0xFF00FF;
                int v26 = (((v24 << 24) | 0x10001) + v27 + result) & 0xFF00FF00 | (((*(_DWORD *)a2 & 0xFF00FF)
                                                                              * (v24 ^ 0xFF)
                                                                              + 65537
                                                                              + ((((*(_DWORD *)a2 & 0xFF00FF)
                                                                                 * (v24 ^ 0xFFu)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
              }
              *(_DWORD *)a2 = v26;
            }
            a2 += 4;
            --v23;
          }
          while (v23 > 1);
        }
        a2 += (int)v11;
        a4 += (int)v12;
        BOOL v28 = a7-- <= 1;
      }
      while (!v28);
    }
  }
  else if (a7 >= 1)
  {
    int v29 = result & 0xFF00FF;
    unsigned int v30 = (result >> 8) & 0xFF00FF;
    v31.i64[0] = 0x2000200020002;
    v31.i64[1] = 0x2000200020002;
    do
    {
      int v32 = a6;
      if (a6 >= 4)
      {
        do
        {
          unsigned __int32 v34 = *(_DWORD *)a4;
          a4 += 4;
          unsigned __int32 v33 = v34;
          if (v34)
          {
            if (v33 == -1)
            {
              vst2_s8(a2, *(int8x8x2_t *)v14.i8);
            }
            else
            {
              a11.i32[0] = v33;
              int8x8x2_t v49 = vld2_s8(a2);
              int8x8_t v35 = vzip1_s8(*(int8x8_t *)a11.i8, *(int8x8_t *)a11.i8);
              uint8x8_t v36 = (uint8x8_t)vmvn_s8(v35);
              uint16x8_t v37 = vmull_u8(v14, (uint8x8_t)v35);
              uint16x8_t v38 = vmull_u8(v15, (uint8x8_t)v35);
              v50.val[0] = vaddhn_s16((int16x8_t)vmlal_u8((uint16x8_t)vaddq_s16((int16x8_t)vsraq_n_u16(v37, v37, 8uLL), v31), (uint8x8_t)v49.val[0], v36), (int16x8_t)vshrq_n_u16(vmull_u8((uint8x8_t)v49.val[0], v36), 8uLL));
              a11 = (int16x8_t)vmlal_u8((uint16x8_t)vaddq_s16((int16x8_t)vsraq_n_u16(v38, v38, 8uLL), v31), (uint8x8_t)v49.val[1], v36);
              v50.val[1] = vaddhn_s16(a11, (int16x8_t)vshrq_n_u16(vmull_u8((uint8x8_t)v49.val[1], v36), 8uLL));
              vst2_s8(a2, v50);
            }
          }
          a2 += 16;
          v32 -= 4;
        }
        while ((v32 + 4) > 7);
      }
      if (v32 >= 1)
      {
        unsigned int v39 = v32 + 1;
        do
        {
          int v41 = *a4++;
          int v40 = v41;
          if (v41)
          {
            unsigned int v42 = result;
            if (v40 != 255)
            {
              int v43 = v29 * v40;
              int v44 = v30 * v40;
              unsigned int v45 = ((v29 * v40) >> 8) & 0xFF00FF;
              unsigned int v46 = ((v30 * v40) >> 8) & 0xFF00FF;
              int v47 = v40 ^ 0xFF;
              unsigned int v42 = ((v43
                    + 131074
                    + (*(_DWORD *)a2 & 0xFF00FF) * v47
                    + v45
                    + ((((*(_DWORD *)a2 & 0xFF00FFu) * v47) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v44
                                                                                                 + 131074
                                                                                                 + v46
                                                                                                 + ((*(_DWORD *)a2 >> 8) & 0xFF00FF)
                                                                                                 * v47
                                                                                                 + (((((*(_DWORD *)a2 >> 8) & 0xFF00FFu) * v47) >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            *(_DWORD *)a2 = v42;
          }
          a2 += 4;
          --v39;
        }
        while (v39 > 1);
      }
      a2 += v11;
      a4 += v12;
      BOOL v28 = a7-- <= 1;
    }
    while (!v28);
  }
  return result;
}

uint64_t argb32_mark_constcolormask(uint64_t a1, double a2, double a3, double a4, int16x8_t a5)
{
  int v5 = *(unsigned int **)(a1 + 88);
  if (v5) {
    uint64_t v6 = *v5;
  }
  else {
    uint64_t v6 = 4278190080;
  }
  return CGSColorMaskCopyARGB8888(v6, (char *)(*(void *)(a1 + 40) + *(int *)(a1 + 28) * (uint64_t)*(int *)(a1 + 16) + 4 * *(int *)(a1 + 12)), *(_DWORD *)(a1 + 28), (unsigned __int8 *)(*(void *)(a1 + 136)+ *(int *)(a1 + 124) * (uint64_t)*(int *)(a1 + 108)+ *(int *)(a1 + 104)), *(_DWORD *)(a1 + 124), *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a3, a4, a5);
}

unint64_t argb32_mark_constmask(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 8);
  int v150 = *(_DWORD *)(a1 + 4);
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 136);
  unsigned int v9 = **(_DWORD **)(a1 + 88);
  pthread_mutex_lock(&argb32_cacheColorLock);
  uint64_t v10 = argb32_cacheColor;
  unint64_t v146 = v5;
  if (!argb32_cacheColor || *(_DWORD *)(argb32_cacheColor + 16) != v9)
  {
    uint64_t v13 = 0;
    while (1)
    {
      if (!v10) {
        goto LABEL_9;
      }
      uint8x8_t v14 = (void *)v13;
      uint64_t v13 = v10;
      if (*(_DWORD *)(v10 + 16) == v9) {
        break;
      }
      uint64_t v10 = *(void *)v10;
      if (!*(void *)v13)
      {
        if (argb32_cacheColorCount > 6)
        {
          *uint8x8_t v14 = 0;
        }
        else
        {
LABEL_9:
          uint8x8_t v15 = (char *)argb32_cacheColorBase;
          if (argb32_cacheColorBase)
          {
            unsigned int v16 = argb32_cacheColorCount;
          }
          else
          {
            uint8x8_t v15 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            unsigned int v16 = 0;
            argb32_cacheColorBase = (uint64_t)v15;
          }
          uint64_t v13 = (uint64_t)&v15[24 * v16];
          *(void *)(v13 + 8) = &v15[1024 * (unint64_t)v16 + 168];
          argb32_cacheColorCFIndex Count = v16 + 1;
        }
        uint64_t v17 = 0;
        *(void *)uint64_t v13 = argb32_cacheColor;
        argb32_cacheColor = v13;
        *(_DWORD *)(v13 + 16) = v9;
        uint64_t v19 = *(void *)(v13 + 8);
        uint64_t v12 = v13 + 8;
        uint64_t v18 = v19;
        do
        {
          *(_DWORD *)(v18 + 4 * v17) = PDM_14621(v9, v17);
          ++v17;
        }
        while (v17 != 256);
        unint64_t result = pthread_mutex_unlock(&argb32_cacheColorLock);
        goto LABEL_20;
      }
    }
    if (v14)
    {
      *uint8x8_t v14 = *(void *)v10;
      *(void *)uint64_t v10 = argb32_cacheColor;
      argb32_cacheColor = v10;
    }
  }
  unint64_t result = pthread_mutex_unlock(&argb32_cacheColorLock);
  uint64_t v12 = v10 + 8;
LABEL_20:
  if (!v8) {
    return result;
  }
  uint64_t v20 = *(void *)v12;
  unsigned int v21 = *(_DWORD *)(*(void *)v12 + 1020);
  unsigned int v22 = HIBYTE(v21);
  unint64_t v23 = v146 >> 2;
  int v24 = (unsigned int *)(v7 + 4 * (*(int *)(a1 + 12) + (v146 >> 2) * *(int *)(a1 + 16)));
  uint64_t v25 = *(int *)(a1 + 124);
  unint64_t v26 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v25;
  uint64_t v147 = v25 - v150;
  unint64_t v27 = v23 - v150;
  switch(a2)
  {
    case 0:
      do
      {
        int v28 = v150;
        do
        {
          int v29 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v29 == 255) {
              unint64_t result = 0;
            }
            else {
              unint64_t result = PDM_14621(*v24, v29 ^ 0xFFu);
            }
            *int v24 = result;
          }
          ++v26;
          ++v24;
          --v28;
        }
        while (v28);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 1:
      int v95 = -1;
      unsigned int v96 = v26 & 3;
      if ((v26 & 3) != 0)
      {
        int v97 = v96 + v150;
        int v95 = -1 << (8 * v96);
        unint64_t v98 = v26 & 3;
        v26 &= 0xFFFFFFFFFFFFFFFCLL;
        v24 -= v98;
      }
      else
      {
        int v97 = v150;
      }
      if ((((_BYTE)v97 + (_BYTE)v26) & 3) != 0)
      {
        int v118 = 4 - (((_BYTE)v97 + (_BYTE)v26) & 3);
        v96 += v118;
        unsigned int v119 = 0xFFFFFFFF >> (8 * v118);
        if (v97 >= 4) {
          unsigned int v120 = v119;
        }
        else {
          unsigned int v120 = 0;
        }
        if (v97 >= 4) {
          unsigned int v119 = -1;
        }
        v95 &= v119;
      }
      else
      {
        unsigned int v120 = 0;
      }
      uint64_t v148 = v147 - v96;
      int v142 = v97 >> 2;
      int32x4_t v151 = vdupq_n_s32(v21);
      unint64_t v141 = v27 - v96;
      int v145 = v95;
      do
      {
        unsigned int v125 = *(_DWORD *)v26 & v95;
        int v126 = v142;
        unsigned int v127 = v120;
        if (!v125) {
          goto LABEL_376;
        }
LABEL_358:
        if (v125 == -1)
        {
          *(int32x4_t *)int v24 = v151;
          goto LABEL_376;
        }
        while (1)
        {
          if ((_BYTE)v125)
          {
            if (v125 == 255) {
              *int v24 = v21;
            }
            else {
              DplusDM_14623(v24, *(_DWORD *)(v20 + 4 * v125), *v24, ~(_BYTE)v125);
            }
          }
          if (BYTE1(v125))
          {
            int v128 = v24 + 1;
            if (BYTE1(v125) == 255) {
              *int v128 = v21;
            }
            else {
              DplusDM_14623(v128, *(_DWORD *)(v20 + 4 * BYTE1(v125)), *v128, ~(v125 >> 8));
            }
          }
          if (BYTE2(v125))
          {
            int v129 = v24 + 2;
            if (BYTE2(v125) == 255) {
              *int v129 = v21;
            }
            else {
              DplusDM_14623(v129, *(_DWORD *)(v20 + 4 * BYTE2(v125)), *v129, ~HIWORD(v125));
            }
          }
          unint64_t result = (unint64_t)(v24 + 3);
          unsigned int v130 = HIBYTE(v125);
          if (HIBYTE(v125) == 255)
          {
            *(_DWORD *)unint64_t result = v21;
          }
          else if (v130)
          {
            unint64_t result = (unint64_t)DplusDM_14623((_DWORD *)result, *(_DWORD *)(v20 + 4 * v130), *(_DWORD *)result, ~v125 >> 24);
          }
LABEL_376:
          while (1)
          {
            int v131 = v126;
            v24 += 4;
            --v126;
            v26 += 4;
            if (v131 < 2) {
              break;
            }
            unsigned int v125 = *(_DWORD *)v26;
            if (*(_DWORD *)v26) {
              goto LABEL_358;
            }
          }
          if (!v127) {
            break;
          }
          unsigned int v127 = 0;
          unsigned int v125 = *(_DWORD *)v26 & v120;
        }
        v26 += v148;
        v24 += v141;
        --v4;
        int v95 = v145;
      }
      while (v4);
      return result;
    case 2:
      unsigned int v99 = v26 & 3;
      if ((v26 & 3) != 0)
      {
        int v100 = v99 + v150;
        int v144 = -1 << (8 * v99);
        unint64_t v101 = v26 & 3;
        v26 &= 0xFFFFFFFFFFFFFFFCLL;
        v24 -= v101;
      }
      else
      {
        int v144 = -1;
        int v100 = v150;
      }
      unint64_t v121 = v23 - v150;
      if ((((_BYTE)v100 + (_BYTE)v26) & 3) != 0)
      {
        int v122 = 4 - (((_BYTE)v100 + (_BYTE)v26) & 3);
        v99 += v122;
        unsigned int v123 = 0xFFFFFFFF >> (8 * v122);
        if (v100 >= 4) {
          unsigned int v124 = v123;
        }
        else {
          unsigned int v124 = 0;
        }
        if (v100 >= 4) {
          unsigned int v123 = -1;
        }
        v144 &= v123;
      }
      else
      {
        unsigned int v124 = 0;
      }
      uint64_t v152 = v147 - v99;
      int v149 = v100 >> 2;
      int v132 = ~HIBYTE(v21);
      unint64_t v143 = v121 - v99;
      while (1)
      {
        int v133 = v149;
        unsigned int v134 = *(_DWORD *)v26 & v144;
        unsigned int v135 = v124;
        if (!v134) {
          goto LABEL_397;
        }
LABEL_386:
        if (v134 == -1) {
          break;
        }
        while (1)
        {
          if ((_BYTE)v134) {
            unint64_t result = (unint64_t)DplusDM_14623(v24, *(_DWORD *)(v20 + 4 * v134), *v24, ~*(_DWORD *)(v20 + 4 * v134) >> 24);
          }
          if ((v134 & 0xFF00) != 0) {
            unint64_t result = (unint64_t)DplusDM_14623(v24 + 1, *(_DWORD *)(v20 + 4 * BYTE1(v134)), v24[1], ~*(_DWORD *)(v20 + 4 * BYTE1(v134)) >> 24);
          }
          if ((v134 & 0xFF0000) != 0) {
            unint64_t result = (unint64_t)DplusDM_14623(v24 + 2, *(_DWORD *)(v20 + 4 * BYTE2(v134)), v24[2], ~*(_DWORD *)(v20 + 4 * BYTE2(v134)) >> 24);
          }
          if (HIBYTE(v134))
          {
            unsigned int v138 = *(_DWORD *)(v20 + 4 * HIBYTE(v134));
            uint64_t v136 = v24 + 3;
            unsigned int v137 = v24[3];
            unsigned int v139 = ~v138 >> 24;
            goto LABEL_396;
          }
LABEL_397:
          while (1)
          {
            int v140 = v133;
            v24 += 4;
            --v133;
            v26 += 4;
            if (v140 < 2) {
              break;
            }
            unsigned int v134 = *(_DWORD *)v26;
            if (*(_DWORD *)v26) {
              goto LABEL_386;
            }
          }
          if (!v135) {
            break;
          }
          unsigned int v135 = 0;
          unsigned int v134 = *(_DWORD *)v26 & v124;
        }
        v26 += v152;
        v24 += v143;
        if (!--v4) {
          return result;
        }
      }
      DplusDM_14623(v24, v21, *v24, v132);
      DplusDM_14623(v24 + 1, v21, v24[1], v132);
      DplusDM_14623(v24 + 2, v21, v24[2], v132);
      uint64_t v136 = v24 + 3;
      unsigned int v137 = v24[3];
      unsigned int v138 = v21;
      unsigned int v139 = ~HIBYTE(v21);
LABEL_396:
      unint64_t result = (unint64_t)DplusDM_14623(v136, v138, v137, v139);
      goto LABEL_397;
    case 3:
      do
      {
        int v102 = v150;
        do
        {
          int v103 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v103 == 255) {
              *int v24 = *(_DWORD *)(v20 + (((unint64_t)*v24 >> 22) & 0x3FC));
            }
            else {
              unint64_t result = (unint64_t)DplusDM_14623(v24, *(_DWORD *)(v20+ 4* ((HIBYTE(*v24) * v103+ 128+ ((HIBYTE(*v24) * v103 + 128) >> 8)) >> 8)), *v24, v103 ^ 0xFFu);
            }
          }
          ++v26;
          ++v24;
          --v102;
        }
        while (v102);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 4:
      do
      {
        int v104 = v150;
        do
        {
          int v105 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v105 == 255) {
              *int v24 = *(_DWORD *)(v20 + 4 * (~*v24 >> 24));
            }
            else {
              unint64_t result = (unint64_t)DplusDM_14623(v24, *(_DWORD *)(v20+ 4* (((~*v24 >> 24) * v105 + 128 + (((~*v24 >> 24) * v105 + 128) >> 8)) >> 8)), *v24, v105 ^ 0xFFu);
            }
          }
          ++v26;
          ++v24;
          --v104;
        }
        while (v104);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 5:
      do
      {
        int v30 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v31 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            unint64_t result = (unint64_t)DMplusDM_14622(v24, v31, HIBYTE(*v24), *v24, ~v31 >> 24);
          }
          ++v26;
          ++v24;
          --v30;
        }
        while (v30);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 6:
      do
      {
        int v106 = v150;
        do
        {
          uint64_t v107 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26 && ~HIBYTE(*v24))
          {
            if (~HIBYTE(*v24) == 255) {
              *int v24 = *(_DWORD *)(v20 + 4 * v107);
            }
            else {
              unint64_t result = (unint64_t)DplusDM_14623(v24, *v24, *(_DWORD *)(v20 + 4 * v107), ~HIBYTE(*v24));
            }
          }
          ++v26;
          ++v24;
          --v106;
        }
        while (v106);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 7:
      do
      {
        int v108 = v150;
        do
        {
          int v109 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v109 == 255) {
              int v110 = HIBYTE(v21);
            }
            else {
              int v110 = (~(_BYTE)v109
            }
                                     + ((unsigned __int16)(v22 * v109 + 128 + ((v22 * v109 + 128) >> 8)) >> 8));
            unint64_t result = PDM_14621(*v24, v110);
            *int v24 = result;
          }
          ++v26;
          ++v24;
          --v108;
        }
        while (v108);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 8:
      int v111 = ~HIBYTE(v21);
      do
      {
        int v112 = v150;
        do
        {
          int v113 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v113 == 255) {
              int v114 = v111;
            }
            else {
              int v114 = ~((v22 * v113 + 128 + ((v22 * v113 + 128) >> 8)) >> 8);
            }
            unint64_t result = PDM_14621(*v24, v114);
            *int v24 = result;
          }
          ++v26;
          ++v24;
          --v112;
        }
        while (v112);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 9:
      do
      {
        int v32 = v150;
        do
        {
          if (*(unsigned char *)v26) {
            unint64_t result = (unint64_t)DMplusDM_14622(v24, *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26), ~*v24 >> 24, *v24, (~*(unsigned char *)v26+ HIBYTE(*(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26))));
          }
          ++v26;
          ++v24;
          --v32;
        }
        while (v32);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 10:
      do
      {
        int v33 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v34 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            unint64_t result = (unint64_t)DMplusDM_14622(v24, v34, ~*v24 >> 24, *v24, ~v34 >> 24);
          }
          ++v26;
          ++v24;
          --v33;
        }
        while (v33);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 11:
      do
      {
        int v35 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v37 = HIBYTE(*v24);
            if (!v6) {
              LOBYTE(v37) = -1;
            }
            unsigned int v36 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            unint64_t result = (unint64_t)DAplusdDA_14624(v24, *v24, v37, v36, HIBYTE(v36));
          }
          ++v26;
          ++v24;
          --v35;
        }
        while (v35);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 12:
      do
      {
        int v115 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v116 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            int v117 = ((*v24 >> 8) & 0xFF00FF) + ((v116 >> 8) & 0xFF00FF);
            *int v24 = (v117 << 8) & 0xFF00FF00 | ((*v24 & 0xFF00FF) + (v116 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                                  * (v117 & 0x1000100 | (((*v24 & 0xFF00FF) + (v116 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v117 & 0x1000100 | (((*v24 & 0xFF00FF) + (v116 & 0xFF00FF)) >> 8) & 0x10001));
          }
          ++v26;
          ++v24;
          --v115;
        }
        while (v115);
        v26 += v147;
        v24 += v27;
        --v4;
      }
      while (v4);
      return result;
    case 13:
      while (1)
      {
        int v38 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v39 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v39))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v40 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_65;
                }
              }
              else
              {
                unsigned int v40 = 255;
              }
              unint64_t result = PDAmultiplyPDA_14625(result, v40, v39, HIBYTE(v39));
              unsigned int v39 = result;
LABEL_65:
              *int v24 = v39;
            }
          }
          ++v26;
          ++v24;
          --v38;
        }
        while (v38);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 14:
      while (1)
      {
        int v41 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v42 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v42))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v43 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_77;
                }
              }
              else
              {
                unsigned int v43 = 255;
              }
              unint64_t result = PDAscreenPDA_14626(result, v43, v42, HIBYTE(v42));
              unsigned int v42 = result;
LABEL_77:
              *int v24 = v42;
            }
          }
          ++v26;
          ++v24;
          --v41;
        }
        while (v41);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 15:
      while (1)
      {
        int v44 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v45 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v45))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v46 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_89;
                }
              }
              else
              {
                unsigned int v46 = 255;
              }
              unint64_t result = PDAoverlayPDA_14627(result, v46, v45, HIBYTE(v45));
              unsigned int v45 = result;
LABEL_89:
              *int v24 = v45;
            }
          }
          ++v26;
          ++v24;
          --v44;
        }
        while (v44);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 16:
      while (1)
      {
        int v47 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v48 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v48))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v49 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_101;
                }
              }
              else
              {
                unsigned int v49 = 255;
              }
              unint64_t result = PDAdarkenPDA_14629(result, v49, v48, HIBYTE(v48));
              unsigned int v48 = result;
LABEL_101:
              *int v24 = v48;
            }
          }
          ++v26;
          ++v24;
          --v47;
        }
        while (v47);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 17:
      while (1)
      {
        int v50 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v51 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v51))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v52 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_113;
                }
              }
              else
              {
                unsigned int v52 = 255;
              }
              unint64_t result = PDAlightenPDA_14628(result, v52, v51, HIBYTE(v51));
              unsigned int v51 = result;
LABEL_113:
              *int v24 = v51;
            }
          }
          ++v26;
          ++v24;
          --v50;
        }
        while (v50);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 18:
      while (1)
      {
        int v53 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v54 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v54))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v55 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_125;
                }
              }
              else
              {
                unsigned int v55 = 255;
              }
              unint64_t result = PDAcolordodgePDA_14630(result, v55, v54, HIBYTE(v54));
              unsigned int v54 = result;
LABEL_125:
              *int v24 = v54;
            }
          }
          ++v26;
          ++v24;
          --v53;
        }
        while (v53);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 19:
      while (1)
      {
        int v56 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v57 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v57))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v58 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_137;
                }
              }
              else
              {
                unsigned int v58 = 255;
              }
              unint64_t result = PDAcolorburnPDA_14631(result, v58, v57, HIBYTE(v57));
              unsigned int v57 = result;
LABEL_137:
              *int v24 = v57;
            }
          }
          ++v26;
          ++v24;
          --v56;
        }
        while (v56);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 20:
      while (1)
      {
        int v59 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v60 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v60))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v61 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_149;
                }
              }
              else
              {
                unsigned int v61 = 255;
              }
              unint64_t result = PDAsoftlightPDA_14633(result, v61, v60, HIBYTE(v60));
              unsigned int v60 = result;
LABEL_149:
              *int v24 = v60;
            }
          }
          ++v26;
          ++v24;
          --v59;
        }
        while (v59);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 21:
      while (1)
      {
        int v62 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v63 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v63))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v64 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_161;
                }
              }
              else
              {
                unsigned int v64 = 255;
              }
              unint64_t result = PDAhardlightPDA_14632(result, v64, v63, HIBYTE(v63));
              unsigned int v63 = result;
LABEL_161:
              *int v24 = v63;
            }
          }
          ++v26;
          ++v24;
          --v62;
        }
        while (v62);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 22:
      while (1)
      {
        int v65 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned __int32 v66 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v66))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v67 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_173;
                }
              }
              else
              {
                unsigned int v67 = 255;
              }
              unint64_t result = PDAdifferencePDA_14634(result, v67, v66, HIBYTE(v66));
              unsigned __int32 v66 = result;
LABEL_173:
              *int v24 = v66;
            }
          }
          ++v26;
          ++v24;
          --v65;
        }
        while (v65);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 23:
      while (1)
      {
        int v68 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v69 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v69))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v70 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_185;
                }
              }
              else
              {
                unsigned int v70 = 255;
              }
              unint64_t result = PDAexclusionPDA_14635(result, v70, v69, HIBYTE(v69));
              unsigned int v69 = result;
LABEL_185:
              *int v24 = v69;
            }
          }
          ++v26;
          ++v24;
          --v68;
        }
        while (v68);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 24:
      while (1)
      {
        int v71 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v72 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v72))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v73 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_197;
                }
              }
              else
              {
                unsigned int v73 = 255;
              }
              unint64_t result = PDAhuePDA_14636(result, v73, v72, HIBYTE(v72));
              unsigned int v72 = result;
LABEL_197:
              *int v24 = v72;
            }
          }
          ++v26;
          ++v24;
          --v71;
        }
        while (v71);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 25:
      while (1)
      {
        int v74 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v75 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v75))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v76 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_209;
                }
              }
              else
              {
                unsigned int v76 = 255;
              }
              unint64_t result = PDAsaturationPDA_14637(result, v76, v75, HIBYTE(v75));
              unsigned int v75 = result;
LABEL_209:
              *int v24 = v75;
            }
          }
          ++v26;
          ++v24;
          --v74;
        }
        while (v74);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 26:
      while (1)
      {
        int v77 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unint64_t result = *(unsigned int *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (BYTE3(result))
            {
              unsigned int v78 = *v24;
              if (v6)
              {
                unsigned int v79 = HIBYTE(v78);
                if (!HIBYTE(v78)) {
                  goto LABEL_221;
                }
              }
              else
              {
                unsigned int v79 = 255;
              }
              unint64_t result = PDAluminosityPDA_14638(result, BYTE3(result), v78, v79);
LABEL_221:
              *int v24 = result;
            }
          }
          ++v26;
          ++v24;
          --v77;
        }
        while (v77);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 27:
      while (1)
      {
        int v80 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v81 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v81))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v82 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_233;
                }
              }
              else
              {
                unsigned int v82 = 255;
              }
              unint64_t result = PDAluminosityPDA_14638(result, v82, v81, HIBYTE(v81));
              unsigned int v81 = result;
LABEL_233:
              *int v24 = v81;
            }
          }
          ++v26;
          ++v24;
          --v80;
        }
        while (v80);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 28:
      while (1)
      {
        int v83 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v84 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v84))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v85 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_245;
                }
              }
              else
              {
                unsigned int v85 = 255;
              }
              unint64_t result = PDAtranspose_huePDA_14639(result, v85, v84, HIBYTE(v84));
              unsigned int v84 = result;
LABEL_245:
              *int v24 = v84;
            }
          }
          ++v26;
          ++v24;
          --v83;
        }
        while (v83);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 29:
      while (1)
      {
        int v86 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v87 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (HIBYTE(v87))
            {
              unint64_t result = *v24;
              if (v6)
              {
                unsigned int v88 = BYTE3(result);
                if (!BYTE3(result)) {
                  goto LABEL_257;
                }
              }
              else
              {
                unsigned int v88 = 255;
              }
              unint64_t result = PDAtranspose_saturationPDA_14640(result, v88, v87, HIBYTE(v87));
              unsigned int v87 = result;
LABEL_257:
              *int v24 = v87;
            }
          }
          ++v26;
          ++v24;
          --v86;
        }
        while (v86);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 30:
      while (1)
      {
        int v89 = v150;
        do
        {
          if (*(unsigned char *)v26)
          {
            unint64_t result = *(unsigned int *)(v20 + 4 * *(unsigned __int8 *)v26);
            if (BYTE3(result))
            {
              unsigned int v90 = *v24;
              if (v6)
              {
                unsigned int v91 = HIBYTE(v90);
                if (!HIBYTE(v90)) {
                  goto LABEL_269;
                }
              }
              else
              {
                unsigned int v91 = 255;
              }
              unint64_t result = PDAtranspose_luminosityPDA_14641(result, BYTE3(result), v90, v91);
LABEL_269:
              *int v24 = result;
            }
          }
          ++v26;
          ++v24;
          --v89;
        }
        while (v89);
        v26 += v147;
        v24 += v27;
        if (!--v4) {
          return result;
        }
      }
    case 31:
      goto LABEL_273;
    default:
      return result;
  }
  do
  {
LABEL_273:
    int v92 = v150;
    do
    {
      if (*(unsigned char *)v26)
      {
        unsigned int v93 = *(_DWORD *)(v20 + 4 * *(unsigned __int8 *)v26);
        if (HIBYTE(v93))
        {
          unint64_t result = *v24;
          if (v6)
          {
            unsigned int v94 = BYTE3(result);
            if (!BYTE3(result)) {
              goto LABEL_281;
            }
          }
          else
          {
            unsigned int v94 = 255;
          }
          unint64_t result = PDAtranspose_luminosityPDA_14641(result, v94, v93, HIBYTE(v93));
          unsigned int v93 = result;
LABEL_281:
          *int v24 = v93;
        }
      }
      ++v26;
      ++v24;
      --v92;
    }
    while (v92);
    v26 += v147;
    v24 += v27;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t aa_render(uint64_t result, unsigned int a2, char *a3, unint64_t a4, int a5, int a6, int a7, int a8, __n128 a9)
{
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    return 0;
  }
  uint64_t v9 = result;
  int v11 = *(_DWORD *)result;
  int v10 = *(_DWORD *)(result + 4);
  int v13 = *(_DWORD *)(result + 8);
  int v12 = *(_DWORD *)(result + 12);
  if (v13 - *(_DWORD *)result < 31 || v12 - v10 < 31) {
    return 0;
  }
  int v15 = *(_DWORD *)(result + 184);
  if (24 * v15 + 44 < 1) {
    return 0;
  }
  unsigned int v16 = a3;
  unsigned int v17 = a2;
  int v18 = v11 >> 12;
  int v19 = (v13 + 4095) >> 12;
  int v20 = v10 >> 12;
  int v21 = (v12 + 4095) >> 12;
  if ((a2 & 4) != 0)
  {
    unint64_t result = 0;
    if (a7 <= a5) {
      return result;
    }
    int v22 = a8 - a6 - 1;
    if (a8 - a6 < 1) {
      return result;
    }
    unint64_t result = 0;
    int v23 = v20 - a6;
    if (v20 >= a6) {
      uint64_t v24 = -(uint64_t)(v23 * (int)a4);
    }
    else {
      uint64_t v24 = 0;
    }
    if (v20 < a6) {
      int v20 = a6;
    }
    int v25 = v18 - a5;
    if (v18 < a5) {
      uint64_t v26 = a5;
    }
    else {
      uint64_t v26 = v18;
    }
    int v27 = v21 - a8;
    if (v21 - a8 >= 1) {
      int v21 = a8;
    }
    int v28 = v19 - a7;
    int v29 = v19 - a7 >= 1 ? a7 : v19;
    if (v21 <= v20) {
      return result;
    }
    uint64_t v188 = v26;
    int v187 = v29;
    if (v29 <= (int)v26) {
      return result;
    }
    int v30 = &a3[(v25 & ~(v25 >> 31)) + v24];
    if (v23 >= 0) {
      int v31 = 3;
    }
    else {
      int v31 = 4;
    }
    if (v31 + (~v25 >> 31) - (v27 < 1) == v28 < 1) {
      unsigned int v17 = a2 & 0xFFFFFFFB;
    }
    else {
      unsigned int v17 = a2;
    }
    if ((v27 | v28) < 0 || v30 != a3)
    {
      unint64_t v32 = a4;
      bzero(a3, (a8 - a6) * (int)a4);
      a4 = v32;
      v17 |= 0x40u;
      int v15 = *(_DWORD *)(v9 + 184);
    }
    unsigned int v16 = v30;
  }
  else
  {
    int v22 = v21 + ~v20;
    uint64_t v188 = (v11 >> 12);
    int v187 = (v13 + 4095) >> 12;
  }
  uint64_t v33 = (v22 * a4);
  unsigned int v191 = &v16[(int)v33];
  unint64_t v203 = a4;
  if (v15 == 2 && *(_WORD *)(v9 + 188) == 2)
  {
    int v34 = *(_DWORD *)v9;
    if (*(_DWORD *)v9 <= v188 << 12) {
      int v34 = v188 << 12;
    }
    if (*(_DWORD *)(v9 + 8) >= v187 << 12) {
      int v35 = v187 << 12;
    }
    else {
      int v35 = *(_DWORD *)(v9 + 8);
    }
    int v36 = v35 - 1;
    unsigned int v37 = (int **)(v34 >> 12);
    uint64_t v38 = (v36 >> 12);
    if (v37 == v36 >> 12)
    {
      size_t v39 = 0;
      uint64_t v40 = ((v36 - v34) >> 4);
      uint64_t v41 = v40;
    }
    else
    {
      uint64_t v41 = (v36 >> 4);
      uint64_t v40 = ~(v34 >> 4);
      size_t v39 = (int)v38 + ~v37;
    }
    if (*(_DWORD *)(v9 + 4) <= v20 << 12) {
      int v140 = v20 << 12;
    }
    else {
      int v140 = *(_DWORD *)(v9 + 4);
    }
    if (*(_DWORD *)(v9 + 12) >= v21 << 12) {
      int v141 = v21 << 12;
    }
    else {
      int v141 = *(_DWORD *)(v9 + 12);
    }
    int v142 = v141 - 1;
    int v143 = v140 >> 12;
    int v144 = v142 >> 12;
    if (v140 >> 12 == v142 >> 12)
    {
      unint64_t v145 = 0;
      uint64_t v146 = 0;
      v142 -= v140;
      int v147 = v140 >> 12;
    }
    else
    {
      int v147 = v143 + 1;
      unint64_t v145 = ~(v140 >> 4);
      uint64_t v146 = v144 - (v143 + 1);
    }
    unsigned int v148 = (v142 >> 4);
    if (v145 <= 0xFE)
    {
      unint64_t v149 = v145;
    }
    else
    {
      int v147 = v140 >> 12;
      unint64_t v149 = 0;
    }
    if (v145 <= 0xFE) {
      uint64_t v150 = v146;
    }
    else {
      uint64_t v150 = v146 + 1;
    }
    if (v148 == 255) {
      uint64_t v151 = 0;
    }
    else {
      uint64_t v151 = v148;
    }
    if (v148 == 255) {
      uint64_t v152 = v150 + 1;
    }
    else {
      uint64_t v152 = v150;
    }
    uint64_t v153 = (int)v37;
    uint64_t v154 = (int)v188;
    signed int v155 = v147 - v20;
    size_t v204 = v39;
    unint64_t v205 = (int)v37 - (uint64_t)(int)v188;
    LODWORD(v200) = v144;
    uint64_t v199 = v37;
    uint64_t v201 = v151;
    if ((v17 & 0x40) == 0 && v143 == v20 && v152 * v39 >= 0x21 && v37 == v188 && v144 == v21 - 1)
    {
      size_t v156 = v39;
      if (v38 == v187 - 1)
      {
        int v157 = a4;
        uint64_t v198 = v33;
        uint64_t v158 = v38;
        signed int v197 = v147 - v20;
        memset(&v191[(int)a4 - (int)a4 * (v152 + v155)], 255, v152 * (int)a4);
        uint64_t v154 = (int)v188;
        signed int v155 = v197;
        uint64_t v38 = v158;
        uint64_t v33 = v198;
        size_t v39 = v204;
        LODWORD(a4) = v157;
        size_t v156 = 0;
        BOOL v159 = v41 == 255 && v40 == 255;
        if (v159) {
          uint64_t v152 = 0;
        }
      }
    }
    else
    {
      size_t v156 = v39;
    }
    uint64_t v160 = (int)v38;
    uint64_t v202 = (int)v38 - v154;
    if (!v149)
    {
LABEL_257:
      if (v152)
      {
        int v168 = v203;
        uint64_t v169 = v155 * (int)v203;
        if (v156)
        {
          if (v156 >= 0x20)
          {
            uint64_t v175 = -(uint64_t)(int)v203;
            int v176 = &v16[(int)v33 - (uint64_t)(int)v188 - v169];
            do
            {
              memset(&v176[v153 + 1], 255, v156);
              v176[v153] = v40;
              v176[v160] = v41;
              v176 += v175;
              --v152;
            }
            while (v152);
          }
          else
          {
            uint64_t v170 = 0;
            uint64_t v171 = (int)v203;
            unint64_t v172 = &v16[(int)v33 + (uint64_t)(int)v38 - (int)v188 - v169];
            uint64_t v173 = &v16[(int)v33 + (uint64_t)(int)v199 - (int)v188 - v169];
            do
            {
              memset(&v173[v170 + 1], 255, v156);
              v173[v170] = v40;
              v172[v170] = v41;
              v170 -= v171;
              --v152;
            }
            while (v152);
          }
        }
        else
        {
          uint64_t v174 = &v16[(int)v33 - (uint64_t)(int)v188 - v169];
          do
          {
            v174[v153] = v40;
            v174[v160] = v41;
            v174 -= v168;
            --v152;
          }
          while (v152);
        }
      }
      if (!v201) {
        return 0xFFFFFFFFLL;
      }
      int v177 = (v200 - v20) * v203;
      unsigned int v178 = &v191[-v177];
      unint64_t v179 = ((v41 * (unint64_t)v201) >> 8)
           + v41 * (unint64_t)v201
           + 1;
      if (v204 < 0x21)
      {
        if (!v204)
        {
LABEL_274:
          v178[v205] = (unsigned __int16)(((v40 * v201) >> 8) + v40 * v201 + 1) >> 8;
          v178[v202] = BYTE1(v179);
          return 0xFFFFFFFFLL;
        }
        int v180 = &v191[-v177 - (uint64_t)(int)v188 + 1 + (int)v199];
      }
      else
      {
        int v180 = &v178[(int)v205 + 1];
      }
      memset(v180, v201, v204);
      goto LABEL_274;
    }
    int v161 = (v143 - v20) * a4;
    uint64_t v162 = &v191[-v161];
    unint64_t v163 = ((v149 * (unint64_t)v40) >> 8)
         + v149 * (unint64_t)v40
         + 1;
    unint64_t v164 = ((v149 * (unint64_t)v41) >> 8)
         + v149 * (unint64_t)v41
         + 1;
    if (v39 < 0x21)
    {
      if (!v39)
      {
LABEL_256:
        v162[v205] = BYTE1(v163);
        v162[v202] = BYTE1(v164);
        goto LABEL_257;
      }
      unint64_t v194 = ((v149 * (unint64_t)v41) >> 8)
           + v149 * (unint64_t)v41
           + 1;
      unint64_t v195 = ((v149 * (unint64_t)v40) >> 8)
           + v149 * (unint64_t)v40
           + 1;
      int v166 = &v191[-v161 - (uint64_t)(int)v188 + 1 + (int)v199];
      int v167 = v149;
      size_t v165 = v204;
      uint64_t v198 = v33;
      uint64_t v196 = v38;
      signed int v197 = v155;
    }
    else
    {
      size_t v165 = v204;
      int v166 = &v162[(int)v205 + 1];
      int v167 = v149;
      uint64_t v198 = v33;
      unint64_t v195 = ((v149 * (unint64_t)v40) >> 8)
           + v149 * (unint64_t)v40
           + 1;
      uint64_t v196 = v38;
      signed int v197 = v155;
      unint64_t v194 = ((v149 * (unint64_t)v41) >> 8)
           + v149 * (unint64_t)v41
           + 1;
    }
    memset(v166, v167, v165);
    BYTE1(v164) = BYTE1(v194);
    BYTE1(v163) = BYTE1(v195);
    signed int v155 = v197;
    LODWORD(v38) = v196;
    LODWORD(v33) = v198;
    goto LABEL_256;
  }
  uint64_t v42 = (v20 << 12);
  uint64_t v43 = (v21 << 12);
  if (v21 - v20 > 1015)
  {
    size_t v44 = 8 * (v21 - v20 + 16);
    unsigned int v46 = (char *)malloc_type_malloc(v44, 0x705560E0uLL);
    uint64_t v183 = v46;
  }
  else
  {
    size_t v44 = 8 * (v21 - v20 + 16);
    MEMORY[0x1F4188790](result, a9);
    unsigned int v46 = (char *)&v181 - v45;
    bzero((char *)&v181 - v45, v44);
    uint64_t v183 = 0;
  }
  bzero(v46, v44);
  int v47 = (uint64_t *)(v46 + 32);
  uint64_t v48 = (uint64_t)&v47[-v20];
  *(_DWORD *)(v9 + 176) = ((v17 << 21) & 0x400000 | ((v17 & 1) << 25) | *(_DWORD *)(v9 + 176) & 0xFC0FFFFF) ^ 0x600000;
  if ((v17 & 4) != 0)
  {
    uint64_t v49 = aa_distribute_clip_edges(v9, v48, (v20 << 12), v43);
    if (v49) {
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v49 = aa_distribute_edges(v9, v48);
    if (v49)
    {
LABEL_50:
      int v51 = v19 - v18;
      if (v19 - v18 > 1015)
      {
        size_t v52 = 4 * (v51 + 16);
        unsigned int v54 = (int32x4_t *)malloc_type_malloc(v52, 0x705560E0uLL);
        unint64_t v182 = v54;
      }
      else
      {
        size_t v52 = 4 * (v19 - v18 + 16);
        MEMORY[0x1F4188790](v49, v50);
        unsigned int v54 = (int32x4_t *)((char *)&v181 - v53);
        bzero((char *)&v181 - v53, v52);
        unint64_t v182 = 0;
      }
      bzero(v54, v52);
      *(void *)(v9 + 200) = 0;
      unsigned int v55 = (uint16x8_t *)&aa_mono_levels;
      if ((v17 & 0x20) == 0) {
        unsigned int v55 = (uint16x8_t *)&aa_gray_levels;
      }
      unint64_t v184 = v55;
      uint64_t v199 = (int **)(v9 + 200);
      *(void *)(v9 + 208) = 0;
      if ((int)v42 >= (int)v43)
      {
LABEL_211:
        if (v182) {
          free(v182);
        }
        if (v183) {
          free(v183);
        }
        return 0xFFFFFFFFLL;
      }
      int v56 = v54;
      LODWORD(v195) = 0;
      LODWORD(v194) = 0;
      LODWORD(v202) = v188 << 12;
      LODWORD(v201) = v187 << 12;
      size_t v204 = (size_t)v54[1].u64 + (-(v54 - 4 * v18 + 16 + 4 * v188) & 0x1FLL) + -4 * v18;
      unint64_t v205 = (unint64_t)&v54[3].u64[1] + 4 * v51 + 4;
      int v189 = ((v17 >> 6) & 1) - 1;
      uint16x8_t v57 = *v184;
      int v186 = v187 + 3;
      uint64_t v185 = -(uint64_t)(int)v203;
      int32x4_t v58 = 0uLL;
      unint64_t v203 = (unint64_t)v54;
      uint16x8_t v193 = v57;
      while (1)
      {
        uint64_t v59 = *v47;
        if (*v47)
        {
          *int v47 = *(void *)v59;
          *(void *)uint64_t v59 = 0;
        }
        uint64_t v200 = v47;
        LODWORD(v196) = 0;
        unsigned int v60 = v42 + 4096;
        int v190 = v42 + 4096;
        if ((int)v42 + 4096 >= (int)v43) {
          unsigned int v60 = v43;
        }
        unsigned int v192 = v60;
        if (!v59)
        {
LABEL_103:
          uint64_t v62 = v192;
          if (v192 == v42) {
            goto LABEL_188;
          }
          goto LABEL_104;
        }
        while (1)
        {
          uint64_t v62 = *(unsigned int *)(v59 + 20);
          if (v42 == v62)
          {
            uint64_t v62 = v42;
            unsigned int v61 = v200;
            do
            {
LABEL_72:
              switch(*(_DWORD *)(v59 + 16))
              {
                case 0:
                  aa_ael_insert((char *)v9, v48, v62, v43, *(uint64_t ***)(v59 + 8));
                  break;
                case 1:
                  aa_ael_remove((char *)v9, v48, v62, v43, *(uint64_t **)(v59 + 8));
                  uint64_t v63 = *(void *)(v59 + 8);
                  *(void *)(v63 + 72) = *(void *)(v9 + 216);
                  *(void *)(v63 + 48) = v63 + 72;
                  *(void *)(v9 + 216) = v63 + 48;
                  break;
                case 2:
                  break;
                case 3:
                  unsigned int v64 = *v199;
                  if (*v199)
                  {
                    int v65 = *v199;
                    do
                    {
                      unsigned __int32 v66 = v64;
                      int v68 = v64;
                      unsigned int v64 = *(int **)v64;
                      unsigned int v67 = (int *)*((void *)v68 + 1);
                      if (v67)
                      {
                        int v69 = v66[10];
                        unsigned int v70 = v64;
                        int v71 = v67;
                        do
                        {
                          int v72 = v71[10];
                          if (v69 > v72 || v69 == v72 && v66[9] >= v71[9]) {
                            break;
                          }
                          *((void *)v66 + 1) = *((void *)v71 + 1);
                          unsigned int v73 = (int **)*((void *)v71 + 1);
                          if (v73)
                          {
                            *unsigned int v73 = v66;
                            unsigned int v70 = *(int **)v66;
                          }
                          *(void *)int v71 = v70;
                          if (v70) {
                            *((void *)v70 + 1) = v71;
                          }
                          *((void *)v71 + 1) = v66;
                          *(void *)unsigned __int32 v66 = v71;
                          if (v65 == v71) {
                            int v65 = v66;
                          }
                          unsigned int v70 = v71;
                          int v71 = (int *)*((void *)v66 + 1);
                        }
                        while (v71);
                        if (v67 != v71 && (*(unsigned char *)(v9 + 178) & 0xC0) != 0)
                        {
                          int v74 = v64;
                          do
                          {
                            if (v74) {
                              aa_intersection_event((char *)v9, v48, v67, v74, v62, v43);
                            }
                            int v74 = v71;
                            BOOL v159 = v67 == v66;
                            unsigned int v67 = v66;
                          }
                          while (!v159);
                        }
                      }
                    }
                    while (v64);
                  }
                  else
                  {
                    int v65 = 0;
                  }
                  *(void *)(v9 + 200) = v65;
                  *(void *)uint64_t v59 = *(void *)(v9 + 216);
                  *(void *)(v9 + 216) = v59;
                  unsigned int v61 = v200;
                  int v56 = (int32x4_t *)v203;
                  break;
                default:
                  abort();
              }
              uint64_t v59 = *v61;
              if (!*v61) {
                break;
              }
              *unsigned int v61 = *(void *)v59;
              *(void *)uint64_t v59 = 0;
            }
            while (*(_DWORD *)(v59 + 20) == v62);
            goto LABEL_69;
          }
LABEL_104:
          unsigned int v75 = *v199;
          int v76 = v202;
          int v77 = v201;
          if (*v199)
          {
            int v78 = -2 * v42;
            signed int v197 = (v62 - v42) << 16;
            LODWORD(v198) = 16 * (v62 - v42);
            int32x4_t v79 = vdupq_n_s32(v197);
            int v76 = v202;
            int v80 = v202;
            int v77 = v201;
            do
            {
              unsigned int v81 = *((unsigned __int8 *)v75 + 46);
              int v82 = v75[4];
              if (*((unsigned char *)v75 + 47))
              {
                int v83 = v75[6];
                int v84 = v75[10];
                uint64_t v85 = v75[8];
                int v86 = v82 + ((unint64_t)(v75[9] * (uint64_t)((int)v62 - v83)) >> 12);
                v75[10] = v86;
                if (v81)
                {
                  unsigned int v87 = v81 - 1;
                  unsigned int v88 = 1 - v81;
                  int v89 = v85;
                  unsigned int v90 = (int32x4_t *)(v204 + 4 * (v84 >> 12));
                  unsigned int v91 = v81 - 2;
                  signed int v92 = v84 & 0xFFFFF000;
                  if ((int)v85 < 1)
                  {
                    int v94 = v86 & v91 | v84 & v88;
                    if (v92 <= v86)
                    {
                      signed int v92 = v84;
                      int v96 = v42;
                    }
                    else
                    {
                      unint64_t v99 = (unint64_t)((int)v85 * (uint64_t)(v92 - v82)) >> 12;
                      int v96 = v83 + v99;
                      if (v90 >= v56 && (unint64_t)v90 <= v205)
                      {
                        v90->i32[0] += (v88 ^ (8 * (v92 - v84) * (v96 - v42))) + v87;
                        unsigned int v90 = (int32x4_t *)((char *)v90 - 4);
                      }
                      if (v92 - 4096 > v86)
                      {
                        int v100 = (v78 + 2 * v83 + 2 * v99 - v85) << 15;
                        do
                        {
                          signed int v101 = v92;
                          if (v90 >= v56 && (unint64_t)v90 <= v205)
                          {
                            v90->i32[0] += v88 - (v100 ^ v88);
                            unsigned int v90 = (int32x4_t *)((char *)v90 - 4);
                          }
                          v96 -= v89;
                          v92 -= 4096;
                          v100 -= v89 << 16;
                        }
                        while (v101 - 0x2000 > v86);
                      }
                    }
                    goto LABEL_137;
                  }
                  int v93 = v92 + 4096;
                  int v94 = v86 & v88 | v84 & v91;
                  if (v92 + 4096 >= v86)
                  {
                    signed int v92 = v84;
                    int v96 = v42;
                  }
                  else
                  {
                    unint64_t v95 = (unint64_t)((v93 - v82) * v85) >> 12;
                    int v96 = v83 + v95;
                    if ((unint64_t)v90 >= v203 && (unint64_t)v90 <= v205)
                    {
                      v90->i32[0] += (v88 ^ (8 * (v93 - v84) * (v96 - v42))) + v87;
                      unsigned int v90 = (int32x4_t *)((char *)v90 + 4);
                    }
                    if (v92 + 0x2000 < v86)
                    {
                      int v97 = (v78 + v85 + 2 * v83 + 2 * v95) << 15;
                      int v56 = (int32x4_t *)v203;
                      do
                      {
                        int v98 = v93;
                        if (v90 >= v56 && (unint64_t)v90 <= v205)
                        {
                          v90->i32[0] += (v97 ^ v88) + v87;
                          unsigned int v90 = (int32x4_t *)((char *)v90 + 4);
                        }
                        v96 += v85;
                        v93 += 4096;
                        v97 += v85 << 16;
                      }
                      while (v98 + 0x2000 < v86);
                      signed int v92 = v98 + 4096;
                      goto LABEL_137;
                    }
                    v92 += 4096;
                  }
                  int v56 = (int32x4_t *)v203;
LABEL_137:
                  if (v90 >= v56 && (unint64_t)v90 <= v205) {
                    v90->i32[0] += (v88 ^ (8 * (v86 - v92) * (v62 - 2 * v42 + v96))) + v87;
                  }
LABEL_140:
                  if (v81 < 2)
                  {
                    if (v76 >= v94) {
                      int v76 = v94;
                    }
                    if (v86 <= (int)v202) {
                      int v80 = v202;
                    }
                    else {
                      int v80 = v86;
                    }
                  }
                  else
                  {
                    if (v77 <= v94) {
                      int v77 = v94;
                    }
                    if (v86 >= (int)v201) {
                      int v102 = v201;
                    }
                    else {
                      int v102 = v86;
                    }
                    if (v86 > v80)
                    {
                      int v103 = (int32x4_t *)(v204 + 4 * (v80 >> 12));
                      unsigned int v104 = ~(v80 >> 12) + (v102 >> 12);
                      if ((v104 & 0x80000000) != 0)
                      {
                        unsigned int v105 = v80;
                      }
                      else
                      {
                        if (v103 >= v56 && (unint64_t)v103 <= v205)
                        {
                          v103->i32[0] += (v62
                                         - v42
                                         - (((v80 & 0xFFFu) * (v62 - v42)) >> 12)) << 16;
                          int v103 = (int32x4_t *)((char *)v103 + 4);
                        }
                        if (v104 >= 4)
                        {
                          do
                          {
                            v104 -= 4;
                            *int v103 = vaddq_s32(*v103, v79);
                            ++v103;
                          }
                          while (v104 > 3);
                        }
                        if (v104 >= 2)
                        {
                          *(int32x2_t *)v103->i8 = vadd_s32(*(int32x2_t *)v103->i8, *(int32x2_t *)v79.i8);
                          int v103 = (int32x4_t *)((char *)v103 + 8);
                          v104 -= 2;
                        }
                        unsigned int v105 = v102 & 0xFFFFF000;
                        if (v104)
                        {
                          v103->i32[0] += v197;
                          int v103 = (int32x4_t *)((char *)v103 + 4);
                        }
                      }
                      if (v103 >= v56 && (unint64_t)v103 <= v205) {
                        v103->i32[0] += v198 * (v102 - v105);
                      }
                    }
                  }
                }
              }
              else
              {
                int v94 = v75[4];
                int v86 = v94;
                if (*((unsigned char *)v75 + 46)) {
                  goto LABEL_140;
                }
              }
              unsigned int v75 = *(int **)v75;
            }
            while (v75);
          }
          int v107 = v76 >> 12;
          int v108 = (v77 + 4095) >> 12;
          int v109 = v194;
          if (v76 >> 12 >= (int)v194) {
            int v110 = v194;
          }
          else {
            int v110 = v76 >> 12;
          }
          int v111 = v195;
          if (v108 <= (int)v195) {
            int v112 = v195;
          }
          else {
            int v112 = (v77 + 4095) >> 12;
          }
          int v113 = v196;
          if (v196) {
            int v114 = v196;
          }
          else {
            int v114 = 2;
          }
          if (v196)
          {
            int v107 = v110;
            int v108 = v112;
          }
          if (v76 <= v77) {
            int v113 = v114;
          }
          LODWORD(v196) = v113;
          if (v76 <= v77) {
            int v109 = v107;
          }
          LODWORD(v194) = v109;
          if (v76 <= v77) {
            int v111 = v108;
          }
          LODWORD(v195) = v111;
          if (!v59) {
            break;
          }
          unsigned int v61 = v200;
          if (*(_DWORD *)(v59 + 20) == v62) {
            goto LABEL_72;
          }
LABEL_69:
          aa_ael_mark(*(unsigned int *)(v9 + 176), *(uint64_t **)(v9 + 200));
          uint64_t v42 = v62;
          uint16x8_t v57 = v193;
          int32x4_t v58 = 0uLL;
          if (!v59) {
            goto LABEL_103;
          }
        }
LABEL_188:
        int v115 = v200;
        int v116 = v188;
        int v117 = v188;
        int v118 = v191;
        unsigned int v119 = v191;
        if (v196)
        {
          int v117 = v188;
          unsigned int v119 = v191;
          if ((int)v195 >= (int)v188)
          {
            int v117 = v188;
            unsigned int v119 = v191;
            if ((int)v194 <= v187)
            {
              int v120 = v194;
              if ((int)v194 <= (int)v188) {
                int v120 = v188;
              }
              if ((int)v195 >= v187) {
                int v121 = v187;
              }
              else {
                int v121 = v195;
              }
              int v122 = v120 - v188;
              int v123 = v189 & ((v120 - (int)v188) >> 2);
              unsigned int v119 = v191;
              int v124 = v123 - 1;
              if (v123 >= 1)
              {
                bzero(v191, 4 * (v189 & (v122 >> 2)));
                int32x4_t v58 = 0uLL;
                uint16x8_t v57 = v193;
                unsigned int v119 = &v118[4 * v124 + 4];
              }
              unsigned int v125 = (int32x4_t *)(v204 + 4 * (int)((v122 & 0xFFFFFFFC) + v116));
              unsigned int v126 = (v121 - v116 + 3) & 0xFFFFFFFC;
              int v127 = v126 - (v122 & 0xFFFFFFFC);
              if (v127 < 16)
              {
                unsigned int v130 = v184;
              }
              else
              {
                uint64_t v128 = 0;
                unsigned int v129 = v127 + 16;
                unsigned int v130 = v184;
                do
                {
                  int8x16_t v131 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vshrq_n_s32(*v125, 0x14uLL)), vshrq_n_s32(v125[1], 0x14uLL));
                  int8x16_t v132 = (int8x16_t)vqmovun_high_s32(vqmovun_s32(vshrq_n_s32(v125[2], 0x14uLL)), vshrq_n_s32(v125[3], 0x14uLL));
                  *(uint8x16_t *)&v119[v128] = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vorrq_s8(v131, (int8x16_t)vcgtq_u16((uint16x8_t)v131, v57))), (uint16x8_t)vorrq_s8(v132, (int8x16_t)vcgtq_u16((uint16x8_t)v132, v57)));
                  v125[2] = v58;
                  v125[3] = v58;
                  *unsigned int v125 = v58;
                  v125[1] = v58;
                  v125 += 4;
                  v129 -= 16;
                  v128 += 16;
                }
                while (v129 > 0x1F);
                v127 -= v128;
                v119 += v128;
              }
              if (v127 >= 4)
              {
                do
                {
                  unsigned int v133 = v127;
                  char v134 = v130[1].i8[(unint64_t)v125->u32[0] >> 20];
                  __int8 v135 = v130[1].i8[(unint64_t)v125->u32[1] >> 20];
                  v125->i64[0] = 0;
                  *unsigned int v119 = v134;
                  v119[1] = v135;
                  __int8 v136 = v130[1].i8[(unint64_t)v125->u32[2] >> 20];
                  __int8 v137 = v130[1].i8[(unint64_t)v125->u32[3] >> 20];
                  v125->i64[1] = 0;
                  v119[2] = v136;
                  v119[3] = v137;
                  int v127 = v133 - 4;
                  v119 += 4;
                  ++v125;
                }
                while (v133 > 7);
              }
              int v117 = v126 + v116;
              if (v127 >= 1)
              {
                unsigned int v138 = v127 + 1;
                do
                {
                  char v139 = v130[1].i8[(unint64_t)v125->u32[0] >> 20];
                  v125->i32[0] = 0;
                  unsigned int v125 = (int32x4_t *)((char *)v125 + 4);
                  *v119++ = v139;
                  --v138;
                }
                while (v138 > 1);
              }
            }
          }
        }
        if ((v189 & ((v186 - v117) >> 2)) >= 1)
        {
          bzero(v119, 4 * (v189 & ((v186 - v117) >> 2)));
          int32x4_t v58 = 0uLL;
          uint16x8_t v57 = v193;
        }
        unsigned int v191 = &v118[v185];
        int v47 = v115 + 1;
        uint64_t v42 = v190;
        if (v190 >= (int)v43) {
          goto LABEL_211;
        }
      }
    }
  }
  unint64_t result = (uint64_t)v183;
  if (v183)
  {
    free(v183);
    return 0;
  }
  return result;
}

char *aa_ael_insert(char *result, uint64_t a2, int a3, int a4, uint64_t **a5)
{
  unint64_t v5 = a5;
  uint64_t v9 = result;
  int v10 = (uint64_t *)*((void *)result + 25);
  if (!v10)
  {
    *a5 = 0;
    a5[1] = 0;
    *((void *)result + 25) = a5;
    goto LABEL_68;
  }
  int v11 = (*((_DWORD *)result + 44) >> 20) & 3;
  int v12 = v11 - 1;
  uint64_t v13 = *((void *)result + 26);
  int v15 = *((_DWORD *)a5 + 9);
  int v14 = *((_DWORD *)a5 + 10);
  int v16 = *((_DWORD *)v10 + 10) - v14;
  if (!v16)
  {
    int v17 = *((_DWORD *)v10 + 9);
    if (v17 == v15) {
      goto LABEL_48;
    }
    if (v17 <= v15) {
      int v16 = 1 - v11;
    }
    else {
      int v16 = v11 - 1;
    }
  }
  if (v16 >= 1)
  {
    *a5 = v10;
    a5[1] = 0;
    *((void *)result + 25) = a5;
    v10[1] = (uint64_t)a5;
    goto LABEL_68;
  }
  if (!v16) {
    goto LABEL_48;
  }
  if (!v13 || (uint64_t *)v13 == v10)
  {
LABEL_32:
    int v24 = 1 - v11;
    while (1)
    {
      int v19 = v10;
      int v10 = (uint64_t *)*v10;
      if (!v10) {
        goto LABEL_43;
      }
      int v18 = *((_DWORD *)v10 + 10) - v14;
      if (!v18)
      {
        int v25 = *((_DWORD *)v10 + 9);
        if (v25 == v15) {
          goto LABEL_46;
        }
        if (v25 <= v15) {
          int v18 = v24;
        }
        else {
          int v18 = v12;
        }
      }
      if ((v18 & 0x80000000) == 0) {
        goto LABEL_42;
      }
    }
  }
  int v18 = *(_DWORD *)(v13 + 40) - v14;
  if (!v18)
  {
    int v23 = *(_DWORD *)(v13 + 36);
    if (v23 == v15 || (v23 <= v15 ? (int v18 = 1 - v11) : (int v18 = v11 - 1), !v18))
    {
      int v10 = (uint64_t *)*((void *)result + 26);
      goto LABEL_48;
    }
  }
  if (v18 < 0)
  {
    int v10 = (uint64_t *)*((void *)result + 26);
    goto LABEL_32;
  }
  int v19 = *(uint64_t **)(v13 + 8);
  if (v19 == v10)
  {
    int v19 = (uint64_t *)*((void *)result + 25);
  }
  else if (v19)
  {
    int v20 = 1 - v11;
    while (1)
    {
      int v21 = *((_DWORD *)v19 + 10) - v14;
      if (!v21)
      {
        int v22 = *((_DWORD *)v19 + 9);
        if (v22 == v15) {
          break;
        }
        if (v22 <= v15) {
          int v21 = v20;
        }
        else {
          int v21 = v12;
        }
      }
      if (v21 <= 0) {
        break;
      }
      int v19 = (uint64_t *)v19[1];
      int v18 = v21;
    }
  }
LABEL_42:
  int v10 = (uint64_t *)*v19;
  if (v18)
  {
LABEL_43:
    *a5 = v10;
    a5[1] = v19;
    *int v19 = (uint64_t)a5;
    if (*a5) {
      (*a5)[1] = (uint64_t)a5;
    }
    *((void *)result + 26) = a5;
    goto LABEL_68;
  }
LABEL_46:
  if (!v10) {
    int v10 = v19;
  }
LABEL_48:
  if (*((_DWORD *)v10 + 22) == 2)
  {
    uint64_t v26 = (uint64_t *)v10[10];
    int v27 = (uint64_t *)v26[1];
    *a5 = v26;
    a5[1] = v27;
    if (v27)
    {
      *int v27 = (uint64_t)a5;
      int v28 = v10;
      int v10 = *a5;
    }
    else
    {
      int v28 = v10;
      int v10 = v26;
    }
  }
  else
  {
    int v28 = (void *)*((void *)result + 28);
    if (v28)
    {
      *((void *)result + 28) = *v28;
    }
    else
    {
      unint64_t result = aa_new_edge((uint64_t)result);
      int v28 = result;
      if (!result) {
        return result;
      }
    }
    unint64_t result = (char *)memmove(v28, v10, 0x60uLL);
    int v29 = (void *)v10[1];
    if (v29) {
      *int v29 = v28;
    }
    if (*v10) {
      *(void *)(*v10 + 8) = v28;
    }
    if (v10 == *((uint64_t **)v9 + 25)) {
      *((void *)v9 + 25) = v28;
    }
    *int v10 = 0;
    v10[1] = 0;
    *((_DWORD *)v28 + 16) = 0;
    v28[6] = 0;
    v28[7] = v28;
    *((_DWORD *)v28 + 22) = 2;
    v28[9] = 0;
    v28[10] = v10;
    *((_DWORD *)v10 + 16) = 2;
    v10[7] = (uint64_t)v28;
    *unint64_t v5 = v10;
    v5[1] = 0;
  }
  v10[1] = (uint64_t)v5;
  v28[10] = v5;
  *((_DWORD *)v5 + 16) = 2;
  v5[7] = v28;
  *((_WORD *)v28 + 22) += *((_WORD *)v5 + 22);
  int v30 = *((_DWORD *)v5 + 7);
  if (*((_DWORD *)v28 + 7) >= v30)
  {
    int v31 = *((_DWORD *)v5 + 6);
    if (*((_DWORD *)v28 + 6) <= v31)
    {
      *((void *)v9 + 26) = v28;
      return result;
    }
  }
  else
  {
    *((_DWORD *)v28 + 7) = v30;
    int v31 = *((_DWORD *)v5 + 6);
    *((_DWORD *)v28 + 5) = *((_DWORD *)v5 + 5);
    if (*((_DWORD *)v28 + 6) <= v31) {
      goto LABEL_67;
    }
  }
  *((_DWORD *)v28 + 6) = v31;
  *((_DWORD *)v28 + 4) = *((_DWORD *)v5 + 4);
LABEL_67:
  *((void *)v9 + 26) = v28;
  unint64_t v5 = (uint64_t **)v28;
LABEL_68:
  if ((v9[178] & 0xC0) != 0)
  {
    uint64_t v33 = (int *)*v5;
    unint64_t v32 = (int *)v5[1];
    do
    {
      if (v32) {
        unint64_t result = aa_intersection_event(v9, a2, v32, (int *)v5, a3, a4);
      }
      BOOL v34 = v32 == v33;
      unint64_t v32 = v33;
    }
    while (!v34);
  }
  return result;
}

char *aa_ael_remove(char *result, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  uint64_t v7 = (uint64_t *)*((void *)result + 25);
  uint64_t v6 = (uint64_t *)*((void *)result + 26);
  uint64_t v8 = *a5;
  if (v7 == a5)
  {
    *((void *)result + 25) = v8;
    if (v8) {
      *(void *)(v8 + 8) = 0;
    }
    if (v6 == a5) {
      *((void *)result + 26) = v8;
    }
  }
  else
  {
    int v10 = (int *)a5[1];
    if (v10) {
      *(void *)int v10 = v8;
    }
    if (v8) {
      *(void *)(v8 + 8) = v10;
    }
    if (*((_DWORD *)a5 + 16) == 2)
    {
      int v11 = (uint64_t *)a5[7];
      *((_WORD *)v11 + 22) -= *((_WORD *)a5 + 22);
      if (v8)
      {
        v11[10] = v8;
        return result;
      }
      if (v10)
      {
        v11[10] = (uint64_t)v10;
        return result;
      }
      v11[10] = 0;
      uint64_t v8 = *v11;
      int v10 = (int *)v11[1];
      if (v10) {
        *(void *)int v10 = v8;
      }
      if (v8) {
        *(void *)(v8 + 8) = v10;
      }
      *int v11 = *((void *)result + 28);
      *((void *)result + 28) = v11;
      if (v6 == v11) {
        *((void *)result + 26) = v8;
      }
      if (v7 == v11)
      {
        *((void *)result + 25) = v8;
        return result;
      }
    }
    else if (v6 == a5)
    {
      *((void *)result + 26) = v10;
    }
    if ((result[178] & 0xC0) != 0)
    {
      if (v8) {
        return aa_intersection_event(result, a2, v10, (int *)v8, a3, a4);
      }
    }
  }
  return result;
}

char *aa_intersection_event(char *result, uint64_t a2, int *a3, int *a4, int a5, int a6)
{
  int v6 = a3[9];
  int v7 = a4[9];
  if (v6 == v7) {
    return result;
  }
  uint64_t v8 = 4;
  if (v6 >= 0) {
    uint64_t v9 = 4;
  }
  else {
    uint64_t v9 = 5;
  }
  int v10 = a3[v9];
  if (v7 >= 0) {
    uint64_t v8 = 5;
  }
  if (v10 >= a4[v8]) {
    return result;
  }
  int v11 = a3 + 5;
  int v12 = a4 + 5;
  if (v7 >= 0) {
    int v12 = a4 + 4;
  }
  if (v6 < 0) {
    int v11 = a3 + 4;
  }
  if (*v12 >= *v11) {
    return result;
  }
  int v14 = a3[6];
  int v13 = a3[7];
  int v15 = a4[6];
  if (v13 >= a4[7]) {
    int v13 = a4[7];
  }
  int v16 = v14 <= v15 ? a4[6] : a3[6];
  if (v13 <= v16) {
    return result;
  }
  if (v13 >= a6) {
    int v13 = a6;
  }
  if (v16 <= a5) {
    int v16 = a5;
  }
  if (v13 <= v16) {
    return result;
  }
  uint64_t v17 = (uint64_t)result;
  double v18 = *((double *)result + 19);
  double v19 = (double)a3[4];
  double v20 = v18 * (double)v6;
  double v21 = (double)a4[4];
  double v22 = v18 * (double)v7;
  double v23 = v19 + v20 * (double)(v16 - v14);
  double v24 = v19 + v20 * (double)(v13 - v14);
  double v25 = v18 - v18;
  double v26 = v23 - (v21 + v22 * (double)(v16 - v15));
  double v27 = v24 - (v21 + v22 * (double)(v13 - v15));
  BOOL v28 = v27 == v25 || v26 == v25;
  if (v28 || v26 <= v25 != v27 > v25) {
    return result;
  }
  double v29 = fabs(v26);
  int v30 = v16 + vcvtmd_s64_f64(v29 / (fabs(v27) + v29) * (double)(v13 - v16));
  int v31 = v30 + 1;
  if (v30 >= v13 || v31 < v16) {
    return result;
  }
  uint64_t v33 = (char **)(a2 + 8 * (v31 >> 12));
  BOOL v34 = *v33;
  if (!*v33)
  {
LABEL_40:
    int v35 = 0;
    goto LABEL_41;
  }
  while (1)
  {
    int v35 = v34;
    int v36 = *((_DWORD *)v34 + 5) - v31;
    if (v36)
    {
      if (v36 * (((*((_DWORD *)result + 44) >> 20) & 3) - 1) > 0) {
        goto LABEL_41;
      }
      goto LABEL_38;
    }
    int v37 = *((_DWORD *)v35 + 4);
    if (v37 != 1) {
      break;
    }
LABEL_38:
    BOOL v34 = *(char **)v35;
    uint64_t v33 = (char **)v35;
    if (!*(void *)v35)
    {
      uint64_t v33 = (char **)v35;
      goto LABEL_40;
    }
  }
  if (v37 == 3) {
    return result;
  }
LABEL_41:
  unint64_t result = (char *)*((void *)result + 27);
  if (result)
  {
    uint64_t v38 = *(char **)result;
  }
  else
  {
    unint64_t result = *(char **)(v17 + 224);
    if (result)
    {
      *(void *)(v17 + 224) = *(void *)result;
    }
    else
    {
      unint64_t result = aa_new_edge(v17);
      if (!result) {
        return result;
      }
    }
    *(void *)unint64_t result = 0;
    *((void *)result + 1) = 0;
    *((void *)result + 2) = 0;
    *((_DWORD *)result + 6) = v30;
    *((_DWORD *)result + 7) = v31;
    *((void *)result + 4) = 0;
    result[47] = 0;
    *((_WORD *)result + 22) = 0;
    *((void *)result + 9) = 0;
    uint64_t v38 = result + 72;
    *((void *)result + 6) = result + 72;
    result += 48;
  }
  *(void *)(v17 + 216) = v38;
  *(void *)unint64_t result = v35;
  *((void *)result + 1) = 0;
  *((_DWORD *)result + 4) = 3;
  *((_DWORD *)result + 5) = v31;
  *uint64_t v33 = result;
  return result;
}

uint64_t aa_ael_mark(uint64_t result, uint64_t *a2)
{
  if (a2)
  {
    int v2 = 0;
    unsigned int v3 = (BYTE3(result) & 3) - 1;
    BOOL v4 = 1;
    do
    {
      v2 += *((__int16 *)a2 + 22);
      char v5 = v4;
      if (v4) {
        char v6 = 0;
      }
      else {
        char v6 = 2;
      }
      BOOL v4 = (v2 & v3) == 0;
      if ((v2 & v3) == 0) {
        char v5 = v6;
      }
      *((unsigned char *)a2 + 46) = v5;
      a2 = (uint64_t *)*a2;
    }
    while (a2);
  }
  return result;
}

uint64_t aa_distribute_edges(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 176);
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  unsigned int v3 = *(uint64_t **)(a1 + 192);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  char v6 = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  int v9 = (v2 >> 20) & 3;
  int v10 = v9 - 1;
  do
  {
    int v11 = *((_DWORD *)v3 + 3);
    if (v11)
    {
      int v12 = 0;
      int v13 = v3 + 3;
      do
      {
        if (*((_WORD *)v13 + 22))
        {
          if (v9)
          {
            int v15 = *((_DWORD *)v13 + 6);
            int v14 = *((_DWORD *)v13 + 7);
            int v16 = v13 + 2;
            uint64_t v17 = v15;
            uint64_t v18 = v14;
          }
          else
          {
            int v14 = *((_DWORD *)v13 + 6);
            int v15 = *((_DWORD *)v13 + 7);
            int v16 = (_DWORD *)v13 + 5;
            uint64_t v17 = (4095 - v15);
            uint64_t v18 = (4095 - v14);
          }
          *((_DWORD *)v13 + 10) = *v16;
          if (!v6 || (int)v17 < (int)v4 || (double v19 = v6, (v17 ^ v4) >= 0x1000))
          {
            if (!v7 || (int)v17 < (int)v5 || (double v19 = v7, (v17 ^ v5) >= 0x1000)) {
              double v19 = (void *)(a2 + 8 * (v15 >> 12));
            }
          }
          double v20 = (uint64_t *)*v19;
          if (*v19)
          {
            do
            {
              double v21 = v20;
              int v22 = *((_DWORD *)v20 + 5) - v15;
              if (v22)
              {
                if (v22 * v10 > 0) {
                  goto LABEL_25;
                }
              }
              else if (!*((_DWORD *)v21 + 4))
              {
                goto LABEL_25;
              }
              double v20 = (uint64_t *)*v21;
              double v19 = v21;
            }
            while (*v21);
            double v19 = v21;
          }
          double v21 = 0;
LABEL_25:
          v13[6] = (uint64_t)v21;
          v13[7] = (uint64_t)v13;
          *((_DWORD *)v13 + 16) = 0;
          *((_DWORD *)v13 + 17) = v15;
          *double v19 = v13 + 6;
          if (!v6 || (int)v18 < (int)v4 || (v18 ^ v4) >= 0x1000)
          {
            if ((int)v18 < (int)v17 || (char v6 = v19, (v18 ^ v17) >= 0x1000)) {
              char v6 = (void *)(a2 + 8 * (v14 >> 12));
            }
          }
          double v23 = (uint64_t *)*v6;
          if (*v6)
          {
            do
            {
              int v24 = *((_DWORD *)v23 + 5) - v14;
              if (!v24) {
                break;
              }
              if (v24 * v10 > 0) {
                break;
              }
              char v6 = v23;
              double v23 = (uint64_t *)*v23;
            }
            while (v23);
          }
          v13[9] = (uint64_t)v23;
          v13[10] = (uint64_t)v13;
          *((_DWORD *)v13 + 22) = 1;
          *((_DWORD *)v13 + 23) = v14;
          uint64_t v8 = (v8 + 1);
          uint64_t v4 = v18;
          uint64_t v5 = v17;
          int v7 = v19;
          *char v6 = v13 + 9;
        }
        else
        {
          *int v13 = *(void *)(a1 + 224);
          *(void *)(a1 + 224) = v13;
          double v19 = v7;
          uint64_t v17 = v5;
          uint64_t v18 = v4;
        }
        ++v12;
        v13 += 12;
      }
      while (v12 != v11);
    }
    else
    {
      double v19 = v7;
      uint64_t v17 = v5;
      uint64_t v18 = v4;
    }
    unsigned int v3 = (uint64_t *)*v3;
    uint64_t v4 = v18;
    uint64_t v5 = v17;
    int v7 = v19;
  }
  while (v3);
  return v8;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  double x = point.x;
  if (rect.origin.x == INFINITY || rect.origin.y == INFINITY) {
    return 0;
  }
  double y = point.y;
  if (rect.size.width < 0.0 || rect.size.height < 0.0) {
    rect = CGRectStandardize(rect);
  }
  BOOL result = 0;
  if (x >= rect.origin.x && x < rect.origin.x + rect.size.width && y >= rect.origin.y) {
    return y < rect.origin.y + rect.size.height;
  }
  return result;
}

uint64_t CGColorSpaceGetProcessColorModel(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(*(void *)(a1 + 24) + 32);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

float CGImageGetContentHeadroom(CGImage *a1)
{
  return CGImageGetHeadroomInfo(a1, 0);
}

uint64_t colorsync_transform_data_make_nonpurgeable()
{
  return 1;
}

CFTypeID CGColorGetTypeID(void)
{
  if (kCGColorComponents_block_invoke_once != -1) {
    dispatch_once(&kCGColorComponents_block_invoke_once, &__block_literal_global_31);
  }
  return CGColorGetTypeID_color_type_id;
}

CGPathRef CGPathRetain(CGPathRef path)
{
  if (path) {
    CFRetain(path);
  }
  return path;
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v9 = *((void *)c + 12);
    float64x2_t v10 = vmulq_n_f64(*(float64x2_t *)(v9 + 40), sy);
    *(float64x2_t *)(v9 + 24) = vmulq_n_f64(*(float64x2_t *)(v9 + 24), sx);
    *(float64x2_t *)(v9 + 40) = v10;
  }
  else
  {
    handle_invalid_context((char)"CGContextScaleCTM", (uint64_t)c, v3, v4, v5, v6, v7, v8);
  }
}

CGContextRef CGContextRetain(CGContextRef c)
{
  if (c) {
    CFRetain(c);
  }
  return c;
}

uint64_t CGImageBlockSetGetCount(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

BOOL CGAffineTransformIsIdentity(CGAffineTransform *t)
{
  return t->a == 1.0 && t->b == 0.0 && t->c == 0.0 && t->d == 1.0 && t->tx == 0.0 && t->ty == 0.0;
}

uint64_t CGImageBlockGetData(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

void CGImageProviderRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGGlyphBuilderLockBitmaps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  uint64_t v12 = *(void *)(a1 + 88);
  int v106 = (double *)(a1 + 32);
  if (v12)
  {
    uint64_t v13 = *(void *)a1;
    int v14 = *(_DWORD *)(a1 + 8);
    double v16 = *(double *)(a1 + 16);
    double v15 = *(double *)(a1 + 24);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 4));
    if (!*(void *)(v12 + 32)) {
      *(void *)(v12 + 32) = CFDictionaryCreateMutable(0, 0, &get_strike_strike_key_callbacks, 0);
    }
    long long v108 = 0u;
    long long v109 = 0u;
    memset(&key, 0, sizeof(key));
    CGFontStrikeKeyInit((uint64_t)&key, v13, v106, v14, v16, v15);
    CFStringRef Value = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 32), &key);
    if (!Value)
    {
      CFStringRef Value = (char *)malloc_type_calloc(1uLL, 0x870uLL, 0x10800401BCBC891uLL);
      __CFSetLastAllocationEventName();
      *(_DWORD *)CFStringRef Value = 1;
      CGFontStrikeKeyInit((uint64_t)(Value + 8), v13, v106, v14, v16, v15);
      *((void *)Value + 11) = 0;
      *((void *)Value + 12) = 0;
      *((_DWORD *)Value + 26) = 0;
      uint64_t v18 = *(void **)(v12 + 40);
      double v19 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      if (v19)
      {
        *double v19 = Value;
        v19[1] = v18;
        uint64_t v18 = v19;
      }
      *(void *)(v12 + 40) = v18;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v12 + 32), Value + 8, Value);
      uint64_t v9 = a3;
    }
    atomic_fetch_add_explicit((atomic_uint *volatile)Value, 1u, memory_order_relaxed);
    int v20 = *(_DWORD *)(v12 + 24);
    *(_DWORD *)(v12 + 24) = v20 + 1;
    *((_DWORD *)Value + 1) = v20;
    os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 4));
  }
  else
  {
    CFStringRef Value = 0;
  }
  *(void *)(a1 + 96) = Value;
  if (!v9) {
    return 1;
  }
  uint64_t v21 = 0;
  char v22 = 1;
  if (!Value) {
    goto LABEL_20;
  }
LABEL_12:
  int v23 = *(_DWORD *)(a2 + 4 * v21);
  int v24 = (os_unfair_lock_s *)(Value + 104);
  os_unfair_lock_lock((os_unfair_lock_t)Value + 26);
  uint64_t v25 = *(void *)&Value[8 * BYTE1(v23) + 112];
  if (v25 && (double v26 = *(char ***)(v25 + 8 * v23)) != 0)
  {
    while (1)
    {
      CFStringRef Value = *v26;
      if (*v26)
      {
        if (*((unsigned __int16 *)Value + 2) == (unsigned __int16)v23
          && __PAIR64__(HIBYTE(v23), BYTE2(v23)) == __PAIR64__(Value[7], Value[6]))
        {
          break;
        }
      }
      double v26 = (char **)v26[1];
      if (!v26) {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    CFStringRef Value = 0;
  }
  os_unfair_lock_unlock(v24);
LABEL_20:
  while (1)
  {
    *(void *)(a4 + 8 * v21) = Value;
    v22 &= Value != 0;
    if (++v21 == v9) {
      break;
    }
    CFStringRef Value = *(char **)(a1 + 96);
    if (Value) {
      goto LABEL_12;
    }
  }
  if (v22) {
    return 1;
  }
  uint64_t v27 = 0;
  unsigned int v104 = (void *)(a1 + 120);
  uint64_t v105 = a2;
  do
  {
    if (*(void *)(a4 + 8 * v27)) {
      goto LABEL_151;
    }
    BOOL v28 = (unsigned __int16 *)(a2 + 4 * v27);
    int8x8_t v29 = *(int8x8_t *)(a1 + 112);
    if (v29)
    {
      uint64_t v30 = *v28;
      uint64_t v31 = *((unsigned __int8 *)v28 + 2);
      uint64_t v32 = *((unsigned __int8 *)v28 + 3);
      unint64_t v33 = (v30 << 16) | (v31 << 8) | v32;
      uint8x8_t v34 = (uint8x8_t)vcnt_s8(v29);
      v34.i16[0] = vaddlv_u8(v34);
      if (v34.u32[0] > 1uLL)
      {
        unint64_t v35 = (v30 << 16) | (v31 << 8) | v32;
        if (v33 >= *(void *)&v29) {
          unint64_t v35 = v33 % *(void *)&v29;
        }
      }
      else
      {
        unint64_t v35 = v33 & (*(void *)&v29 + 0xFFFFFFFFLL);
      }
      int v36 = *(void ***)(*(void *)(a1 + 104) + 8 * v35);
      if (v36)
      {
        int v37 = *v36;
        if (*v36)
        {
          do
          {
            unint64_t v38 = v37[1];
            if (v38 == v33)
            {
              if (*((unsigned __int16 *)v37 + 8) == v30
                && __PAIR64__(*((unsigned __int8 *)v37 + 19), *((unsigned __int8 *)v37 + 18)) == __PAIR64__(v32, v31))
              {
                goto LABEL_150;
              }
            }
            else
            {
              if (v34.u32[0] > 1uLL)
              {
                if (v38 >= *(void *)&v29) {
                  v38 %= *(void *)&v29;
                }
              }
              else
              {
                v38 &= *(void *)&v29 - 1;
              }
              if (v38 != v35) {
                break;
              }
            }
            int v37 = (void *)*v37;
          }
          while (v37);
        }
      }
    }
    uint64_t v39 = *(void *)a1;
    if (!*(void *)a1) {
      goto LABEL_181;
    }
    uint64_t v40 = *(unsigned int *)(a1 + 8);
    uint64_t v41 = *(void *)(a1 + 80);
    uint64_t v42 = *(unsigned int *)v28;
    CFTypeID v43 = CFGetTypeID(*(CFTypeRef *)a1);
    if (_block_invoke_once_3318 != -1) {
      dispatch_once(&_block_invoke_once_3318, &__block_literal_global_8_3319);
    }
    if (v43 != CGFontGetTypeID_font_type_id) {
LABEL_181:
    }
      _CGHandleAssert("create_missing_bitmaps", 165, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Fonts/CGGlyphBuilder.cc", "bitmap != nullptr", "bitmap missing", a6, a7, a8, v100);
    font_info = get_font_info((void *)v39);
    if (font_info)
    {
      if (font_info[104]) {
        uint64_t v40 = v40 & 0xFFFFFFFE;
      }
      else {
        uint64_t v40 = v40;
      }
    }
    uint64_t v45 = (atomic_uint *)(*(uint64_t (**)(void, uint64_t, double *, uint64_t, uint64_t))(*(void *)(v39 + 16)
                                                                                                + 392))(*(void *)(v39 + 112), v40, v106, v41, v42);
    if (!v45)
    {
      unsigned int v46 = get_font_info((void *)v39);
      if (!v46) {
        goto LABEL_64;
      }
      int v47 = v46[2];
      if (!v47) {
        goto LABEL_64;
      }
      memset(&key, 0, sizeof(key));
      int v48 = *(_DWORD *)(v39 + 104);
      if (v48 < 0)
      {
        int v48 = (*(uint64_t (**)(void))(*(void *)(v39 + 16) + 136))(*(void *)(v39 + 112));
        *(_DWORD *)(v39 + 104) = v48;
      }
      double v50 = *(double *)(a1 + 32);
      double v49 = *(double *)(a1 + 40);
      double v52 = *(double *)(a1 + 48);
      double v51 = *(double *)(a1 + 56);
      if (v48 || (v49 != 0.0 || v52 != 0.0) && (v50 != 0.0 || v51 != 0.0))
      {
        double v53 = 1.0 / (double)v47;
        key.double a = v52 * 0.0 + v53 * v50;
        key.double b = v51 * 0.0 + v53 * v49;
        key.double c = v53 * v52 + v50 * 0.0;
        key.double d = v53 * v51 + v49 * 0.0;
        key.double tx = (double)BYTE2(v42) / (double)(int)v41;
        key.double ty = (double)BYTE3(v42) / (double)SHIDWORD(v41);
        GlyphPath = (UInt8 *)CGFontCreateGlyphPath(v39, (uint64_t)&key);
        goto LABEL_65;
      }
      double v101 = (double)(2 * (int)v41);
      double v102 = (double)(2 * HIDWORD(v41));
      float64x2_t v55 = vmulq_n_f64(*(float64x2_t *)(a1 + 48), v102);
      *(float64x2_t *)&key.double a = vmulq_n_f64(*(float64x2_t *)(a1 + 32), v101);
      *(float64x2_t *)&key.double c = v55;
      *(_OWORD *)&key.double tx = *(_OWORD *)(a1 + 64);
      int v56 = (const CGPath *)(*(uint64_t (**)(void, CGAffineTransform *, void))(*(void *)(v39 + 16)
                                                                                           + 400))(*(void *)(v39 + 112), &key, (unsigned __int16)v42);
      if (v56)
      {
        uint16x8_t v57 = v56;
        key.double b = 0.0;
        key.double c = 0.0;
        key.double a = 1.0 / v101;
        key.double d = 1.0 / v102;
        key.double tx = (double)(2 * (BYTE2(v42) & 0x7F)) / v101;
        key.double ty = (double)(2 * (BYTE3(v42) & 0x7F)) / v102;
        GlyphPath = (UInt8 *)CGPathCreateMutableCopyByTransformingPath(v56, &key);
        CFRelease(v57);
      }
      else
      {
LABEL_64:
        GlyphPath = 0;
      }
LABEL_65:
      uint64_t v45 = (atomic_uint *)CGGlyphBitmapCreateWithPathAndDilation(GlyphPath, v42, v39, v40, v106);
      if (v45)
      {
        if (!GlyphPath) {
          goto LABEL_68;
        }
      }
      else
      {
        uint64_t v45 = CGGlyphBitmapCreate(v42, v40, 0, 0, 0, 0, 0, 0);
        if (!GlyphPath)
        {
LABEL_68:
          if (!v45) {
            goto LABEL_181;
          }
          goto LABEL_69;
        }
      }
      CFRelease(GlyphPath);
      goto LABEL_68;
    }
LABEL_69:
    uint64_t v58 = *(void *)(a1 + 96);
    unint64_t v59 = *(unsigned int *)v28;
    if (v58)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v58 + 104));
      uint64_t v60 = v58 + 8 * BYTE1(v59);
      uint64_t v63 = *(void **)(v60 + 112);
      unsigned int v61 = (void *)(v60 + 112);
      uint64_t v62 = v63;
      if (!v63)
      {
        uint64_t v62 = malloc_type_calloc(0x100uLL, 8uLL, 0x2004093837F09uLL);
        *unsigned int v61 = v62;
      }
      unsigned int v64 = (void *)v62[v59];
      atomic_fetch_add_explicit(v45, 1u, memory_order_relaxed);
      int v65 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      if (v65)
      {
        *int v65 = v45;
        v65[1] = v64;
        unsigned int v64 = v65;
      }
      v62[v59] = v64;
      *(int64x2_t *)(v58 + 88) = vaddq_s64(*(int64x2_t *)(v58 + 88), vdupq_n_s64((unint64_t)(v45[8] * v45[6]) + 48));
      os_unfair_lock_unlock((os_unfair_lock_t)(v58 + 104));
      unint64_t v59 = *(unsigned int *)v28;
      uint64_t v9 = a3;
    }
    unint64_t v66 = (v59 >> 8) & 0xFF00 | (v59 << 16) | (v59 >> 24);
    unint64_t v67 = *(void *)(a1 + 112);
    if (v67)
    {
      uint8x8_t v68 = (uint8x8_t)vcnt_s8((int8x8_t)v67);
      v68.i16[0] = vaddlv_u8(v68);
      if (v68.u32[0] > 1uLL)
      {
        uint64_t v58 = (v59 >> 8) & 0xFF00 | (v59 << 16) | (v59 >> 24);
        if (v66 >= v67) {
          uint64_t v58 = v66 % v67;
        }
      }
      else
      {
        uint64_t v58 = v66 & (v67 + 0xFFFFFFFF);
      }
      int v69 = *(void ***)(*(void *)(a1 + 104) + 8 * v58);
      if (v69)
      {
        int v37 = *v69;
        if (*v69)
        {
          do
          {
            unint64_t v70 = v37[1];
            if (v70 == v66)
            {
              if (*((unsigned __int16 *)v37 + 8) == (unsigned __int16)v59
                && __PAIR64__(*((unsigned __int8 *)v37 + 19), *((unsigned __int8 *)v37 + 18)) == __PAIR64__(v59 >> 24, BYTE2(v59)))
              {
                a2 = v105;
                goto LABEL_150;
              }
            }
            else
            {
              if (v68.u32[0] > 1uLL)
              {
                if (v70 >= v67) {
                  v70 %= v67;
                }
              }
              else
              {
                v70 &= v67 - 1;
              }
              if (v70 != v58) {
                break;
              }
            }
            int v37 = (void *)*v37;
          }
          while (v37);
        }
      }
    }
    int v37 = operator new(0x20uLL);
    *int v37 = 0;
    v37[1] = v66;
    *((_DWORD *)v37 + 4) = v59;
    v37[3] = v45;
    float v71 = (float)(unint64_t)(*(void *)(a1 + 128) + 1);
    float v72 = *(float *)(a1 + 136);
    if (!v67 || (float)(v72 * (float)v67) < v71)
    {
      BOOL v73 = (v67 & (v67 - 1)) != 0;
      if (v67 < 3) {
        BOOL v73 = 1;
      }
      unint64_t v74 = v73 | (2 * v67);
      unint64_t v75 = vcvtps_u32_f32(v71 / v72);
      if (v74 <= v75) {
        int8x8_t prime = (int8x8_t)v75;
      }
      else {
        int8x8_t prime = (int8x8_t)v74;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v67 = *(void *)(a1 + 112);
      }
      if (*(void *)&prime > v67) {
        goto LABEL_104;
      }
      if (*(void *)&prime < v67)
      {
        unint64_t v83 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 128) / *(float *)(a1 + 136));
        if (v67 < 3 || (uint8x8_t v84 = (uint8x8_t)vcnt_s8((int8x8_t)v67), v84.i16[0] = vaddlv_u8(v84), v84.u32[0] > 1uLL))
        {
          unint64_t v83 = std::__next_prime(v83);
        }
        else
        {
          uint64_t v85 = 1 << -(char)__clz(v83 - 1);
          if (v83 >= 2) {
            unint64_t v83 = v85;
          }
        }
        if (*(void *)&prime <= v83) {
          int8x8_t prime = (int8x8_t)v83;
        }
        if (*(void *)&prime >= v67)
        {
          unint64_t v67 = *(void *)(a1 + 112);
        }
        else
        {
          if (prime)
          {
LABEL_104:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:fe180100]();
            }
            int v77 = operator new(8 * *(void *)&prime);
            int v78 = *(void **)(a1 + 104);
            *(void *)(a1 + 104) = v77;
            if (v78) {
              operator delete(v78);
            }
            uint64_t v79 = 0;
            *(int8x8_t *)(a1 + 112) = prime;
            do
              *(void *)(*(void *)(a1 + 104) + 8 * v79++) = 0;
            while (*(void *)&prime != v79);
            int v80 = (void *)*v104;
            if (*v104)
            {
              unint64_t v81 = v80[1];
              uint8x8_t v82 = (uint8x8_t)vcnt_s8(prime);
              v82.i16[0] = vaddlv_u8(v82);
              if (v82.u32[0] > 1uLL)
              {
                if (v81 >= *(void *)&prime) {
                  v81 %= *(void *)&prime;
                }
              }
              else
              {
                v81 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)(a1 + 104) + 8 * v81) = v104;
              int v86 = (void *)*v80;
              if (*v80)
              {
                do
                {
                  unint64_t v87 = v86[1];
                  if (v82.u32[0] > 1uLL)
                  {
                    if (v87 >= *(void *)&prime) {
                      v87 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v87 &= *(void *)&prime - 1;
                  }
                  if (v87 != v81)
                  {
                    uint64_t v88 = *(void *)(a1 + 104);
                    if (!*(void *)(v88 + 8 * v87))
                    {
                      *(void *)(v88 + 8 * v87) = v80;
                      goto LABEL_131;
                    }
                    *int v80 = *v86;
                    *int v86 = **(void **)(*(void *)(a1 + 104) + 8 * v87);
                    **(void **)(*(void *)(a1 + 104) + 8 * v87) = v86;
                    int v86 = v80;
                  }
                  unint64_t v87 = v81;
LABEL_131:
                  int v80 = v86;
                  int v86 = (void *)*v86;
                  unint64_t v81 = v87;
                }
                while (v86);
              }
            }
            unint64_t v67 = (unint64_t)prime;
            goto LABEL_135;
          }
          signed int v92 = *(void **)(a1 + 104);
          *(void *)(a1 + 104) = 0;
          if (v92) {
            operator delete(v92);
          }
          unint64_t v67 = 0;
          *(void *)(a1 + 112) = 0;
        }
      }
LABEL_135:
      if ((v67 & (v67 - 1)) != 0)
      {
        if (v66 >= v67) {
          uint64_t v58 = v66 % v67;
        }
        else {
          uint64_t v58 = v66;
        }
      }
      else
      {
        uint64_t v58 = (v67 - 1) & v66;
      }
    }
    uint64_t v89 = *(void *)(a1 + 104);
    unsigned int v90 = *(void **)(v89 + 8 * v58);
    if (v90)
    {
      *int v37 = *v90;
      a2 = v105;
    }
    else
    {
      *int v37 = *v104;
      *unsigned int v104 = v37;
      *(void *)(v89 + 8 * v58) = v104;
      a2 = v105;
      if (!*v37) {
        goto LABEL_149;
      }
      unint64_t v91 = *(void *)(*v37 + 8);
      if ((v67 & (v67 - 1)) != 0)
      {
        if (v91 >= v67) {
          v91 %= v67;
        }
      }
      else
      {
        v91 &= v67 - 1;
      }
      unsigned int v90 = (void *)(*(void *)(a1 + 104) + 8 * v91);
    }
    void *v90 = v37;
LABEL_149:
    ++*(void *)(a1 + 128);
LABEL_150:
    *(void *)(a4 + 8 * v27) = v37[3];
LABEL_151:
    ++v27;
  }
  while (v27 != v9);
  if (!print_statistics) {
    return 1;
  }
  int v93 = (FILE **)MEMORY[0x1E4F143C8];
  int v94 = (FILE *)*MEMORY[0x1E4F143C8];
  if (*(void *)a1) {
    unint64_t v95 = (const char *)(*(uint64_t (**)(void))(*(void *)(*(void *)a1 + 16) + 144))(*(void *)(*(void *)a1 + 112));
  }
  else {
    unint64_t v95 = 0;
  }
  fprintf(v94, "%s: %s (%g, %g, %g, %g; %g, %g)\n",
    "note_glyph_build",
    v95,
    *(double *)(a1 + 32),
    *(double *)(a1 + 40),
    *(double *)(a1 + 48),
    *(double *)(a1 + 56),
    *(double *)(a1 + 64),
    *(double *)(a1 + 72));
  int v96 = "s";
  if (*(void *)(a1 + 128) == 1) {
    int v96 = "";
  }
  fprintf(*v93, "  building %lu bitmap%s...\n", *(void *)(a1 + 128), v96);
  std::vector<char>::size_type v97 = 1;
  fwrite("    ", 4uLL, 1uLL, *v93);
  if (*(void *)a1) {
    std::vector<char>::size_type v97 = (*(uint64_t (**)(void))(*(void *)(*(void *)a1 + 16) + 288))(*(void *)(*(void *)a1 + 112))
  }
        + 1;
  uint64_t result = (uint64_t)std::vector<char>::vector((std::vector<char> *)&key, v97);
  unint64_t v99 = (void *)*v104;
  if (!*v104)
  {
LABEL_178:
    fputc(10, *v93);
    if (*(void *)&key.a)
    {
      key.double b = key.a;
      operator delete(*(void **)&key.a);
    }
    return 1;
  }
  while (*(void *)&key.b != *(void *)&key.a)
  {
    if (*(void *)a1
      && (uint64_t result = (*(uint64_t (**)(void, void))(*(void *)(*(void *)a1 + 16) + 296))(*(void *)(*(void *)a1 + 112), *((unsigned __int16 *)v99 + 8)), result))
    {
      if (*(void *)&key.b == *(void *)&key.a) {
        break;
      }
      uint64_t result = fprintf(*v93, "\"%s\"(%d,%d) ");
    }
    else
    {
      uint64_t result = fprintf(*v93, "%hu(%d,%d) ");
    }
    unint64_t v99 = (void *)*v99;
    if (!v99) {
      goto LABEL_178;
    }
  }
  __break(1u);
  return result;
}

void sub_184C0FF40(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *get_font_info(void *a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int v2 = a1 + 5;
  CFArrayRef explicit = (void *)atomic_load_explicit(a1 + 5, memory_order_acquire);
  if (!explicit)
  {
    CFArrayRef explicit = malloc_type_calloc(1uLL, 0x70uLL, 0x10000400AC616F7uLL);
    (*(void (**)(void, void *))(a1[2] + 104))(a1[14], explicit);
    uint64_t v4 = 0;
    atomic_compare_exchange_strong(v2, (unint64_t *)&v4, (unint64_t)explicit);
    if (v4)
    {
      free(explicit);
      return (void *)v4;
    }
  }
  return explicit;
}

CGMutablePathRef CGFontCreateGlyphPath(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v3 = (const CGPath *)(*(uint64_t (**)(void, void))(*(void *)(a1 + 16) + 400))(*(void *)(a1 + 112), 0);
  uint64_t v4 = v3;
  if (v3
    && a2
    && (*(double *)a2 != 1.0
     || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)(a2 + 8)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a2 + 24), (float64x2_t)xmmword_1850CD830))))) & 1) != 0|| *(double *)(a2 + 40) != 0.0))
  {
    CGMutablePathRef MutableCopyByTransformingPath = CGPathCreateMutableCopyByTransformingPath(v3, (const CGAffineTransform *)a2);
    CFRelease(v4);
    return MutableCopyByTransformingPath;
  }
  return v4;
}

uint64_t create_glyph_path(uint64_t a1)
{
  return MEMORY[0x1F4119BD0](*(void *)(a1 + 8));
}

UInt8 *CGGlyphBitmapCreateWithPathAndDilation(UInt8 *cf, int a2, uint64_t a3, int a4, double *a5)
{
  uint64_t v9 = cf;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if ((a4 & 0x982) != 0)
  {
    if (cf)
    {
      if (CGPathDisableTypeValidation || (CFTypeID v11 = CFGetTypeID(cf), v11 == CGPathGetTypeID()))
      {
        uint64_t v12 = (char *)malloc_type_malloc(0x60uLL, 0x1020040E03F46FBuLL);
        *(_OWORD *)(v12 + 8) = 0u;
        *(_OWORD *)(v12 + 24) = 0u;
        *(int64x2_t *)(v12 + 40) = vdupq_n_s64(0x47EFFFFFE0000000uLL);
        *(int64x2_t *)(v12 + 56) = vdupq_n_s64(0xC7EFFFFFE0000000);
        *((_DWORD *)v12 + 18) = 1032805417;
        *((_OWORD *)v12 + 5) = xmmword_1850CDFD0;
        *(void *)uint64_t v12 = malloc_type_malloc(0x780uLL, 0x1000040504FFAC1uLL);
        operator new();
      }
      return 0;
    }
  }
  else if (cf)
  {
    if (!CGPathDisableTypeValidation)
    {
      CFTypeID v13 = CFGetTypeID(cf);
      if (v13 != CGPathGetTypeID()) {
        return 0;
      }
    }
    font_float64x2_t info = get_font_info((void *)a3);
    if (!font_info) {
      return 0;
    }
    unsigned int v15 = font_info[2];
    if (!v15) {
      return 0;
    }
    int32x2_t v16 = vmul_s32(vdup_n_s32(v15), (int32x2_t)0x64FFFFFF9CLL);
    v17.i64[0] = v16.i32[0];
    v17.i64[1] = v16.i32[1];
    float64x2_t info = vcvtq_f64_s64(v17);
    CGAffineTransform v36 = CGAffineTransformIdentity;
    AutohintTransform = 0;
    aa_create();
    unint64_t v38 = v18;
    double v19 = aa_free_edges((uint64_t)v18);
    if ((a4 & 0xD80) == 0x400) {
      operator new();
    }
    if (a3)
    {
      int v21 = *(_DWORD *)(a3 + 104);
      if (v21 < 0)
      {
        int v21 = (*(uint64_t (**)(void, double))(*(void *)(a3 + 16) + 136))(*(void *)(a3 + 112), v19);
        *(_DWORD *)(a3 + 104) = v21;
      }
      if (v21 && (a2 & 0xFF000000) == 0)
      {
        Autohinter = CGFontGetAutohinter((atomic_ullong *)a3);
        AutohintTransform = (atomic_uint *)CGFontAutohinterCreateAutohintTransform(Autohinter, a5, 0, 0.0);
      }
    }
    CGPathApply((CGPathRef)v9, &info, (CGPathApplierFunction)process_path_element_14853);
    int v23 = v38;
    int v24 = v38->i32[0];
    __int32 v25 = v38->i32[2];
    if (v25 - v38->i32[0] < 31 || (int v26 = v38->i32[1], v27 = v38->i32[3], v27 - v26 <= 30))
    {
      uint64_t v9 = (UInt8 *)CGGlyphBitmapCreate(a2, a4, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      int v28 = (v27 + 4095) >> 12;
      size_t v29 = ((v25 + 4095) >> 12) - (v24 >> 12);
      unint64_t v30 = v28 - (v26 >> 12);
      uint64_t v9 = (UInt8 *)CGGlyphBitmapCreate(a2, a4 | 1u, v24 >> 12, v28, v29, v30, (v29 + 15) & 0xFFFFFFFFFFFFFFF0, 0);
      if (v9)
      {
        int v32 = (a4 & 1) != 0 ? 2 : 34;
        aa_cache_render(v23, v32, (uint64_t)(v9 + 40), (v29 + 15) & 0xFFFFFFFFFFFFFFF0, v31);
        if (default_glyph_bitmap_debugging)
        {
          bzero(v39, 0x400uLL);
          __sprintf_chk(v39, 0, 0x400uLL, "*/bitmap_image.%03d.tiff", ++create_bitmap_count);
          CGGlyph8BitBitmapSaveAsImage(v29, v30, (v29 + 15) & 0xFFFFFFFFFFFFFFF0, v9 + 40, v39);
        }
      }
    }
    unint64_t v33 = v38;
    if (v38)
    {
      aa_free_edges((uint64_t)v38);
      free(v33);
    }
    uint8x8_t v34 = AutohintTransform;
    if (AutohintTransform && atomic_fetch_add_explicit(AutohintTransform, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v34);
    }
  }
  return v9;
}

double aa_free_edges(uint64_t a1)
{
  if (a1)
  {
    unsigned int v2 = *(void **)(a1 + 192);
    uint64_t v3 = (void *)*v2;
    if (*v2)
    {
      do
      {
        uint64_t v4 = v3;
        free(v2);
        uint64_t v3 = (void *)*v4;
        unsigned int v2 = v4;
      }
      while (*v4);
    }
    else
    {
      uint64_t v4 = v2;
    }
    *(void *)(a1 + 192) = v4;
    *(_WORD *)(a1 + 188) = 0;
    *((_DWORD *)v4 + 3) = 0;
    unsigned int v5 = *(_DWORD *)(a1 + 176) & 0xFFF3FFFF;
    *(_DWORD *)(a1 + 180) = 0;
    *(_DWORD *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 176) = v5;
    double result = 1.99609494;
    *(_OWORD *)a1 = xmmword_1850CDE20;
  }
  return result;
}

double aa_create()
{
  CFStringRef v0 = (char *)malloc_type_malloc(0x1000uLL, 0x705560E0uLL);
  if (v0)
  {
    *((void *)v0 + 29) = 0;
    *((void *)v0 + 24) = v0 + 232;
    *((void *)v0 + 30) = 40;
    *(void *)(v0 + 180) = 0;
    *(_OWORD *)CFStringRef v0 = xmmword_1850CDE20;
    *((int64x2_t *)v0 + 6) = vdupq_n_s64(0x3FE47AE147AE147CuLL);
    *((int64x2_t *)v0 + 7) = vdupq_n_s64(0x3FB23456789ABCDFuLL);
    *((_DWORD *)v0 + 47) = 0;
    *((int64x2_t *)v0 + 8) = vdupq_n_s64(0x40B0000000000000uLL);
    *((int64x2_t *)v0 + 9) = vdupq_n_s64(0x3F30000000000000uLL);
    *((_OWORD *)v0 + 10) = xmmword_1850CDE30;
    int v2 = *((_DWORD *)v0 + 44);
    *((int64x2_t *)v0 + 4) = vdupq_n_s64(0xC10FFFF800000000);
    *((int64x2_t *)v0 + 5) = vdupq_n_s64(0x410FFFF800000000uLL);
    double result = 0.0;
    *((_OWORD *)v0 + 2) = 0u;
    *((_OWORD *)v0 + 3) = 0u;
    *((_DWORD *)v0 + 44) = v2 & 0xFC000000;
    *((void *)v0 + 2) = 0;
    *((void *)v0 + 3) = 0;
    *(_OWORD *)(v0 + 216) = 0u;
    *(_OWORD *)(v0 + 200) = 0u;
  }
  return result;
}

void CGPathApplyWithBlock(CGPathRef path, CGPathApplyBlock block)
{
  if (path)
  {
    if (CGPathDisableTypeValidation || (CFTypeID v4 = CFGetTypeID(path), v4 == CGPathGetTypeID()))
    {
      v5[0] = MEMORY[0x1E4F143A8];
      v5[1] = 0x40000000;
      v5[2] = __CGPathApplyWithBlock_block_invoke;
      _OWORD v5[3] = &unk_1E52CD270;
      v5[4] = block;
      CG::Path::apply((double *)path + 2, (uint64_t)v5);
    }
  }
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
  if (path)
  {
    if (CGPathDisableTypeValidation)
    {
      BOOL v6 = 1;
      if (!function) {
        return;
      }
    }
    else
    {
      CFTypeID v7 = CFGetTypeID(path);
      BOOL v6 = v7 == CGPathGetTypeID();
      if (!function) {
        return;
      }
    }
    if (v6)
    {
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 0x40000000;
      v8[2] = __CGPathApply_block_invoke;
      v8[3] = &__block_descriptor_tmp_10_17668;
      v8[4] = function;
      v8[5] = info;
      CG::Path::apply((double *)path + 2, (uint64_t)v8);
    }
  }
}

void CG::Path::apply(double *a1, uint64_t a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    char v44 = 0;
    switch(v2)
    {
      case 1:
        double v5 = a1[6];
        double v45 = a1[5];
        double v46 = v5;
        double v6 = a1[1];
        double v7 = a1[2];
        v43[0] = v45 + v6;
        v43[1] = v5 + v7;
        double v8 = a1[3];
        double v9 = a1[4];
        v42[0] = v45 + v6 + v8;
        v42[1] = v5 + v7 + v9;
        v41[0] = v45 + v8;
        v41[1] = v5 + v9;
        (*(void (**)(uint64_t, void, double *, char *))(a2 + 16))(a2, 0, &v45, &v44);
        if (!v44)
        {
          (*(void (**)(uint64_t, uint64_t, double *, char *))(a2 + 16))(a2, 1, v43, &v44);
          if (!v44)
          {
            (*(void (**)(uint64_t, uint64_t, double *, char *))(a2 + 16))(a2, 1, v42, &v44);
            if (!v44)
            {
              (*(void (**)(uint64_t, uint64_t, double *, char *))(a2 + 16))(a2, 1, v41, &v44);
              if (!v44) {
                (*(void (**)(uint64_t, uint64_t, void, char *))(a2 + 16))(a2, 4, 0, &v44);
              }
            }
          }
        }
        break;
      case 5:
        (*(void (**)(uint64_t, void, int *, char *))(a2 + 16))(a2, 0, (int *)a1 + 2, &v44);
        if (!v44) {
          (*(void (**)(uint64_t, uint64_t, int *, char *))(a2 + 16))(a2, 1, (int *)a1 + 6, &v44);
        }
        break;
      case 6:
        double v11 = a1[1];
        double v10 = a1[2];
        double v13 = a1[3];
        double v12 = a1[4];
        double v15 = a1[5];
        double v14 = a1[6];
        double v16 = a1[7];
        LOBYTE(v43[0]) = 0;
        double v39 = v11;
        double v40 = v10;
        double v45 = v15 + v11 + v13 * 0.0;
        double v46 = v14 + v10 + v12 * 0.0;
        (*(void (**)(uint64_t, void, double *, double *))(a2 + 16))(a2, 0, &v45, v43);
        if (!LOBYTE(v43[0]))
        {
          if (v16 >= 1.57079633)
          {
            double v27 = 0.0;
            double v17 = 1.0;
            while (1)
            {
              double v18 = v17;
              double v28 = v17 + v27 * -0.55228475;
              double v29 = v27 + v18 * 0.55228475;
              double v30 = -(v27 - v18 * 0.55228475);
              double v31 = v18 + v27 * 0.55228475;
              double v45 = v15 + v13 * v29 + v39 * v28;
              double v46 = v14 + v12 * v29 + v40 * v28;
              double v47 = v15 + v13 * v31 + v39 * v30;
              double v48 = v14 + v12 * v31 + v40 * v30;
              double v49 = v15 + v13 * v18 - v39 * v27;
              double v50 = v14 + v12 * v18 - v40 * v27;
              (*(void (**)(uint64_t, uint64_t, double *, double *))(a2 + 16))(a2, 3, &v45, v43);
              if (LOBYTE(v43[0])) {
                break;
              }
              double v17 = -v27;
              double v16 = v16 + -1.57079633;
              double v27 = v18;
              if (v16 < 1.57079633) {
                goto LABEL_29;
              }
            }
          }
          else
          {
            double v17 = 1.0;
            double v18 = 0.0;
LABEL_29:
            if (v16 > 0.00000001)
            {
              double v33 = a1[9];
              double v32 = a1[10];
              double v34 = a1[8];
              double v35 = v17 - v32 * v18;
              double v36 = v18 + v32 * v17;
              double v37 = v34 + v32 * v33;
              double v38 = v33 - v32 * v34;
              double v45 = v15 + v13 * v36 + v39 * v35;
              double v46 = v14 + v12 * v36 + v40 * v35;
              double v47 = v15 + v13 * v38 + v39 * v37;
              double v48 = v14 + v12 * v38 + v40 * v37;
              double v49 = v15 + v13 * v33 + v39 * v34;
              double v50 = v14 + v12 * v33 + v40 * v34;
              (*(void (**)(uint64_t, uint64_t, double *, double *))(a2 + 16))(a2, 3, &v45, v43);
            }
          }
        }
        break;
      case 8:
        if (*((_WORD *)a1 + 5))
        {
          uint64_t v19 = 0;
          unsigned int v20 = 0;
          unsigned int v21 = *((_DWORD *)a1 + 3);
          do
          {
            (*(void (**)(uint64_t, void, double *, char *))(a2 + 16))(a2, v21 & 7, &a1[2 * v19 + 2], &v44);
            if (v44) {
              break;
            }
            v19 += point_counts[v21 & 7];
            v21 >>= 3;
            ++v20;
          }
          while (v20 < *((unsigned __int16 *)a1 + 5));
        }
        break;
      case 9:
        if (*((void *)a1 + 2))
        {
          unint64_t v22 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = -1;
          do
          {
            uint64_t v25 = *((void *)a1 + 4);
            uint64_t v26 = *(unsigned __int8 *)(v25 + *((void *)a1 + 3) + v24);
            (*(void (**)(uint64_t, uint64_t, uint64_t, char *))(a2 + 16))(a2, v26, v25 + 16 * v23, &v44);
            if (v44) {
              break;
            }
            v23 += point_counts[v26];
            ++v22;
            --v24;
          }
          while (v22 < *((void *)a1 + 2));
        }
        break;
      default:
        CG::Path::Path((CG::Path *)&v45, (const CG::Path *)a1);
        if (LODWORD(v45) != 9) {
          CG::Path::convert_to_huge_((CG::Path *)&v45);
        }
        CG::Path::apply(&v45, a2);
        CG::Path::~Path((void **)&v45);
        break;
    }
  }
}

void sub_184C10F50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  CG::Path::~Path((void **)va);
  _Unwind_Resume(a1);
}

uint64_t __CGPathApply_block_invoke(uint64_t a1, int a2, void *a3)
{
  int v6 = a2;
  if (a3) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = a2 == 4;
  }
  CFTypeID v4 = &CGPathApply::for_dummies;
  if (!v3) {
    CFTypeID v4 = a3;
  }
  double v7 = v4;
  return (*(uint64_t (**)(void, int *))(a1 + 32))(*(void *)(a1 + 40), &v6);
}

uint64_t __CGPathApplyWithBlock_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  int v4 = a2;
  uint64_t v5 = a3;
  return (*(uint64_t (**)(void, int *))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), &v4);
}

uint64_t aa_quadto(uint64_t result, float a2, float a3, float a4, float a5)
{
  uint64_t v5 = result;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  double v6 = *(double *)(result + 168);
  unsigned int v7 = *(_DWORD *)(result + 176);
  double v8 = a2;
  double v9 = a4;
  double v10 = a3;
  double v11 = a5;
  int v12 = BYTE1(v7);
  if (v6 != 0.0)
  {
    double v8 = v6 * v8;
    double v10 = v6 * v10;
    double v9 = v6 * v9;
    double v11 = v6 * v11;
  }
  double v13 = *(double *)(result + 128);
  double v55 = *(double *)(result + 136);
  double v56 = v13;
  double v54 = *(double *)(result + 160);
  double v14 = *(double *)(result + 96);
  double v15 = *(double *)(result + 104);
  double v17 = *(double *)(result + 32);
  double v16 = *(double *)(result + 40);
  if ((v7 & 0x30000) == 0)
  {
    char v37 = 1;
    double v20 = v9;
    double v21 = v11;
    double v25 = v9;
    double v28 = v11;
    goto LABEL_38;
  }
  double v19 = *(double *)(result + 64);
  double v18 = *(double *)(result + 72);
  double v20 = *(double *)(result + 80);
  double v21 = *(double *)(result + 88);
  double v22 = fabs(v9);
  double v23 = -1.0e15;
  if (v9 <= 0.0) {
    double v24 = -1.0e15;
  }
  else {
    double v24 = 1.0e15;
  }
  if (v22 >= 1.0e15) {
    double v25 = v24;
  }
  else {
    double v25 = v9;
  }
  double v26 = fabs(v11);
  if (v11 <= 0.0) {
    double v27 = -1.0e15;
  }
  else {
    double v27 = 1.0e15;
  }
  if (v26 >= 1.0e15) {
    double v28 = v27;
  }
  else {
    double v28 = v11;
  }
  int v29 = (v25 > v20) | (4 * (v25 < v19));
  int v30 = (8 * (v28 < v18)) | (2 * (v28 > v21));
  if (v30) {
    BOOL v31 = v29 == 0;
  }
  else {
    BOOL v31 = 1;
  }
  if (v31) {
    int v32 = 0;
  }
  else {
    int v32 = 16;
  }
  int v33 = v29 | v30 | v32;
  double v34 = fabs(v8);
  if (v8 <= 0.0) {
    double v35 = -1.0e15;
  }
  else {
    double v35 = 1.0e15;
  }
  if (v34 >= 1.0e15) {
    double v8 = v35;
  }
  double v36 = fabs(v10);
  if (v10 > 0.0) {
    double v23 = 1.0e15;
  }
  if (v36 >= 1.0e15) {
    double v10 = v23;
  }
  if (BYTE1(v7) != v33 || ((v7 >> 8) & 0xF) != ((v8 > v20) | (4 * (v8 < v19)) | (8 * (v10 < v18)) | (2 * (v10 > v21))))
  {
    char v37 = 0;
    goto LABEL_36;
  }
  if (!BYTE1(v7))
  {
    char v37 = 1;
LABEL_36:
    double v9 = *(double *)(result + 64);
    double v11 = *(double *)(result + 72);
LABEL_38:
    int v38 = 0;
    double v39 = (double *)&v59;
    double v57 = *(double *)(result + 104);
    double v58 = v14;
    while (1)
    {
      double v40 = v8 + v8;
      double v41 = v10 + v10;
      double v42 = v17 + v25;
      double v43 = v16 + v28;
      if (v38 <= 22)
      {
        int v45 = (v42 - v40) * (v42 - v40) > v14;
        if ((v43 - v41) * (v43 - v41) > v15) {
          int v45 = 1;
        }
        int v44 = v45 << 31 >> 31;
        if (v37)
        {
          if ((v44 & 1) == 0) {
            goto LABEL_62;
          }
          goto LABEL_61;
        }
      }
      else
      {
        if (v37) {
          goto LABEL_62;
        }
        int v44 = 0;
      }
      int v46 = (v25 > v20) | (4 * (v25 < v9));
      int v47 = (2 * (v28 > v21)) | (8 * (v28 < v11));
      BOOL v48 = !v47 || v46 == 0;
      int v49 = v48 ? 0 : 16;
      int v50 = v46 | v47 | v49;
      if (!(v50 | v12)) {
        break;
      }
      if (v50 == v12)
      {
        if (!v44 || (v12 & 0xF) == ((v8 > v20) | (4 * (v8 < v9)) | (2 * (v10 > v21)) | (8 * (v10 < v11)))) {
          goto LABEL_64;
        }
LABEL_61:
        v39[4] = v25;
        v39[5] = v28;
        double v51 = v40 + v42;
        double v52 = v8 + v25;
        double v25 = v51 * 0.25;
        double v53 = v10 + v28;
        double v28 = (v41 + v43) * 0.25;
        *double v39 = v25;
        v39[1] = v28;
        v39[2] = v52 * 0.5;
        v39[3] = v53 * 0.5;
        v39 += 6;
        ++v38;
        double v8 = (v17 + v8) * 0.5;
        double v10 = (v16 + v10) * 0.5;
      }
      else
      {
        if (v44) {
          goto LABEL_61;
        }
        double result = aa_clip_edge(v60, v12, v50, v9, v11, v20, v21, v56, v55, v54, v17, v16, v25, v28);
        double v15 = v57;
        double v14 = v58;
        int v12 = v50;
        if (result) {
          goto LABEL_63;
        }
LABEL_64:
        if (!v38)
        {
          unsigned int v7 = *(_DWORD *)(v5 + 176);
          goto LABEL_69;
        }
        double v17 = *(v39 - 6);
        double v16 = *(v39 - 5);
        v39 -= 6;
        double v8 = v39[2];
        double v10 = v39[3];
        --v38;
        double v25 = v39[4];
        double v28 = v39[5];
      }
    }
    if (!v44)
    {
LABEL_62:
      v60[0] = (int)(v54 + v56 * v25);
      v60[1] = (int)(v54 + v55 * v28);
      LODWORD(result) = 1;
LABEL_63:
      double result = (uint64_t)aa_add_edges((char *)v5, (uint64_t)v60, (int)result);
      double v15 = v57;
      double v14 = v58;
      goto LABEL_64;
    }
    goto LABEL_61;
  }
LABEL_69:
  *(double *)(v5 + 32) = v25;
  *(double *)(v5 + 40) = v28;
  *(_DWORD *)(v5 + 176) = v7 & 0xFFFF00FF | (v12 << 8);
  return result;
}

uint64_t aa_lineto(uint64_t result, float a2, float a3)
{
  uint64_t v3 = result;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)(result + 168);
  double v5 = a2;
  double v6 = a3;
  if (v4 == 0.0) {
    double v4 = 1.0;
  }
  double v7 = v4 * v5;
  double v8 = v4 * v6;
  int v9 = *(_DWORD *)(result + 176);
  if ((v9 & 0x30000) == 0) {
    goto LABEL_23;
  }
  double v10 = *(double *)(result + 64);
  double v11 = *(double *)(result + 72);
  double v12 = *(double *)(result + 80);
  double v13 = *(double *)(result + 88);
  double v14 = fabs(v7);
  double v15 = -1.0e15;
  if (v7 <= 0.0) {
    double v16 = -1.0e15;
  }
  else {
    double v16 = 1.0e15;
  }
  if (v14 >= 1.0e15) {
    double v7 = v16;
  }
  double v17 = fabs(v8);
  if (v8 > 0.0) {
    double v15 = 1.0e15;
  }
  if (v17 >= 1.0e15) {
    double v8 = v15;
  }
  int v18 = (v7 > v12) | (4 * (v7 < v10));
  int v19 = (8 * (v8 < v11)) | (2 * (v8 > v13));
  BOOL v20 = !v19 || v18 == 0;
  int v21 = v20 ? 0 : 16;
  int v22 = v18 | v19 | v21;
  if (!(v22 | *(_DWORD *)(result + 176) & 0xFF00))
  {
LABEL_23:
    double v24 = *(double *)(result + 160);
    double v25 = v24 + *(double *)(result + 128) * v7;
    double v26 = v24 + *(double *)(result + 136) * v8;
    v27[0] = (int)v25;
    v27[1] = (int)v26;
    uint64_t v23 = 1;
    goto LABEL_24;
  }
  if (v22 != BYTE1(v9))
  {
    double result = aa_clip_edge(v27, BYTE1(v9), v22, v10, v11, v12, v13, *(double *)(result + 128), *(double *)(result + 136), *(double *)(result + 160), *(double *)(result + 32), *(double *)(result + 40), v7, v8);
    *(unsigned char *)(v3 + 177) = v22;
    if (result)
    {
      uint64_t v23 = result;
LABEL_24:
      double result = (uint64_t)aa_add_edges((char *)v3, (uint64_t)v27, v23);
    }
  }
  *(double *)(v3 + 32) = v7;
  *(double *)(v3 + 40) = v8;
  return result;
}

void ripr_path_fill(uint64_t a1, uint64_t a2)
{
  int v2 = *(double **)(a2 + 8);
  switch(*(_DWORD *)a2)
  {
    case 0:
      float v3 = *v2;
      float v4 = v2[1];
      aa_moveto(a1, v3, v4);
      break;
    case 1:
      float v5 = *v2;
      float v6 = v2[1];
      aa_lineto(a1, v5, v6);
      break;
    case 2:
      float v7 = *v2;
      float v8 = v2[1];
      float v9 = v2[2];
      float v10 = v2[3];
      aa_quadto(a1, v7, v8, v9, v10);
      break;
    case 3:
      float v11 = *v2;
      float v12 = v2[1];
      float v13 = v2[2];
      float v14 = v2[3];
      float v15 = v2[4];
      float v16 = v2[5];
      aa_cubeto(a1, v11, v12, v13, v14, v15, v16);
      break;
    case 4:
      aa_close(a1);
      break;
    default:
      return;
  }
}

uint64_t aa_cubeto(uint64_t result, float a2, float a3, float a4, float a5, float a6, float a7)
{
  uint64_t v7 = result;
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  double v8 = *(double *)(result + 168);
  unsigned int v9 = *(_DWORD *)(result + 176);
  double v10 = a2;
  double v11 = a4;
  double v12 = a6;
  double v13 = a3;
  double v14 = a5;
  double v15 = a7;
  int v16 = BYTE1(v9);
  if (v8 != 0.0)
  {
    double v10 = v8 * v10;
    double v13 = v8 * v13;
    double v11 = v8 * v11;
    double v14 = v8 * v14;
    double v12 = v8 * v12;
    double v15 = v8 * v15;
  }
  double v18 = *(double *)(result + 120);
  double v17 = *(double *)(result + 128);
  double v65 = *(double *)(result + 136);
  double v66 = v17;
  double v64 = *(double *)(result + 160);
  double v19 = *(double *)(result + 112);
  double v21 = *(double *)(result + 32);
  double v20 = *(double *)(result + 40);
  if ((v9 & 0x30000) == 0)
  {
    char v45 = 1;
    double v24 = v12;
    double v25 = v15;
    double v29 = v12;
    double v32 = v15;
LABEL_49:
    int v47 = 0;
    BOOL v48 = (double *)&v70;
    double v68 = v18;
    double v69 = v19;
    double v67 = v24;
    while (1)
    {
      double v49 = v10 + v10;
      double v50 = v13 + v13;
      double v51 = v11 + v11;
      double v52 = v14 + v14;
      double v53 = v21 + v11;
      double v54 = v20 + v14;
      double v55 = v10 + v29;
      double v56 = v13 + v32;
      if (v47 <= 22)
      {
        if ((v53 - v49) * (v53 - v49) <= v19)
        {
          int v58 = (v55 - v51) * (v55 - v51) > v19;
          if ((v56 - v52) * (v56 - v52) > v18) {
            int v58 = 1;
          }
          int v57 = v58 << 31 >> 31;
          if ((v54 - v50) * (v54 - v50) > v18) {
            int v57 = -1;
          }
        }
        else
        {
          int v57 = -1;
        }
        if (v45)
        {
LABEL_71:
          if (!v57)
          {
LABEL_75:
            v71[0] = (int)(v64 + v66 * v29);
            v71[1] = (int)(v64 + v65 * v32);
            LODWORD(result) = 1;
LABEL_76:
            double result = (uint64_t)aa_add_edges((char *)v7, (uint64_t)v71, (int)result);
            double v24 = v67;
            double v18 = v68;
            goto LABEL_77;
          }
          goto LABEL_74;
        }
      }
      else
      {
        if (v45) {
          goto LABEL_75;
        }
        int v57 = 0;
      }
      int v59 = (v29 > v24) | (4 * (v29 < v12));
      int v60 = (2 * (v32 > v25)) | (8 * (v32 < v15));
      if (v60) {
        BOOL v61 = v59 == 0;
      }
      else {
        BOOL v61 = 1;
      }
      if (v61) {
        int v62 = 0;
      }
      else {
        int v62 = 16;
      }
      int v63 = v59 | v60 | v62;
      if (!(v63 | v16)) {
        goto LABEL_71;
      }
      if (v63 == v16)
      {
        if (!v57
          || (v16 & 0xF) == (((v11 > v24) | (4 * (v11 < v12)) | (2 * (v14 > v25)) | (8 * (v14 < v15))) & ((v10 > v24) | (4 * (v10 < v12)) | (2 * (v13 > v25)) | (8 * (v13 < v15)))))
        {
          goto LABEL_77;
        }
LABEL_74:
        v48[6] = v29;
        v48[7] = v32;
        v48[4] = (v11 + v29) * 0.5;
        v48[5] = (v14 + v32) * 0.5;
        double v29 = (v51 + v49 + v53 + v55) * 0.125;
        double v32 = (v52 + v50 + v54 + v56) * 0.125;
        v48[2] = (v51 + v55) * 0.25;
        v48[3] = (v52 + v56) * 0.25;
        double v11 = (v49 + v53) * 0.25;
        double v14 = (v50 + v54) * 0.25;
        *BOOL v48 = v29;
        v48[1] = v32;
        v48 += 8;
        double v10 = (v21 + v10) * 0.5;
        double v13 = (v20 + v13) * 0.5;
        ++v47;
      }
      else
      {
        if (v57) {
          goto LABEL_74;
        }
        double result = aa_clip_edge(v71, v16, v63, v12, v15, v24, v25, v66, v65, v64, v21, v20, v29, v32);
        double v24 = v67;
        double v18 = v68;
        int v16 = v63;
        if (result) {
          goto LABEL_76;
        }
LABEL_77:
        if (!v47)
        {
          unsigned int v9 = *(_DWORD *)(v7 + 176);
          goto LABEL_82;
        }
        double v21 = *(v48 - 8);
        double v20 = *(v48 - 7);
        v48 -= 8;
        double v10 = v48[2];
        double v13 = v48[3];
        --v47;
        double v11 = v48[4];
        double v14 = v48[5];
        double v29 = v48[6];
        double v32 = v48[7];
        double v19 = v69;
      }
    }
  }
  double v23 = *(double *)(result + 64);
  double v22 = *(double *)(result + 72);
  double v24 = *(double *)(result + 80);
  double v25 = *(double *)(result + 88);
  double v26 = fabs(v12);
  double v27 = -1.0e15;
  if (v12 <= 0.0) {
    double v28 = -1.0e15;
  }
  else {
    double v28 = 1.0e15;
  }
  if (v26 >= 1.0e15) {
    double v29 = v28;
  }
  else {
    double v29 = v12;
  }
  double v30 = fabs(v15);
  if (v15 <= 0.0) {
    double v31 = -1.0e15;
  }
  else {
    double v31 = 1.0e15;
  }
  if (v30 >= 1.0e15) {
    double v32 = v31;
  }
  else {
    double v32 = v15;
  }
  int v33 = (v29 > v24) | (4 * (v29 < v23));
  int v34 = (8 * (v32 < v22)) | (2 * (v32 > v25));
  if (v34) {
    BOOL v35 = v33 == 0;
  }
  else {
    BOOL v35 = 1;
  }
  if (v35) {
    int v36 = 0;
  }
  else {
    int v36 = 16;
  }
  int v37 = v33 | v34 | v36;
  double v38 = fabs(v11);
  if (v11 <= 0.0) {
    double v39 = -1.0e15;
  }
  else {
    double v39 = 1.0e15;
  }
  if (v38 >= 1.0e15) {
    double v11 = v39;
  }
  double v40 = fabs(v14);
  if (v14 <= 0.0) {
    double v41 = -1.0e15;
  }
  else {
    double v41 = 1.0e15;
  }
  if (v40 >= 1.0e15) {
    double v14 = v41;
  }
  double v42 = fabs(v10);
  if (v10 <= 0.0) {
    double v43 = -1.0e15;
  }
  else {
    double v43 = 1.0e15;
  }
  if (v42 >= 1.0e15) {
    double v10 = v43;
  }
  double v44 = fabs(v13);
  if (v13 > 0.0) {
    double v27 = 1.0e15;
  }
  if (v44 >= 1.0e15) {
    double v13 = v27;
  }
  if (BYTE1(v9) != v37)
  {
    char v45 = 0;
    goto LABEL_48;
  }
  char v45 = 0;
  int v46 = (v9 >> 8) & 0xF;
  if (v46 != ((v11 > v24) | (4 * (v11 < v23)) | (8 * (v14 < v22)) | (2 * (v14 > v25)))
    || v46 != ((v10 > v24) | (4 * (v10 < v23)) | (8 * (v13 < v22)) | (2 * (v13 > v25))))
  {
    goto LABEL_48;
  }
  if (!BYTE1(v9))
  {
    char v45 = 1;
LABEL_48:
    double v12 = *(double *)(result + 64);
    double v15 = *(double *)(result + 72);
    goto LABEL_49;
  }
LABEL_82:
  *(double *)(v7 + 32) = v29;
  *(double *)(v7 + 40) = v32;
  *(_DWORD *)(v7 + 176) = v9 & 0xFFFF00FF | (v16 << 8);
  return result;
}

char *aa_add_edges(char *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (uint64_t)result;
  int v5 = *((_DWORD *)result + 4);
  int v4 = *((_DWORD *)result + 5);
  if (!a3) {
    goto LABEL_37;
  }
  uint64_t v6 = a3;
  int v7 = 0;
  double v8 = (int *)(a2 + 4);
  do
  {
    int v9 = v5;
    int v5 = *(v8 - 1);
    int v10 = *v8;
    int v11 = *v8 - v4;
    if (*v8 == v4)
    {
      v7 += ((4064 - (v4 & 0xFFF)) | ((v4 & 0xFFF) - 31)) >= 0;
      goto LABEL_32;
    }
    int v12 = v5 - v9;
    int v13 = *(_DWORD *)v3;
    if (v5 - v9 < 1)
    {
      if (v13 > v5) {
        *(_DWORD *)uint64_t v3 = v5;
      }
      int v14 = v9;
      if (*(_DWORD *)(v3 + 8) < v9) {
LABEL_9:
      }
        *(_DWORD *)(v3 + 8) = v14;
    }
    else
    {
      if (v13 > v9) {
        *(_DWORD *)uint64_t v3 = v9;
      }
      int v14 = v5;
      if (*(_DWORD *)(v3 + 8) < v5) {
        goto LABEL_9;
      }
    }
    if (v5 == v9) {
      goto LABEL_19;
    }
    uint64_t v15 = ((uint64_t)v12 << 12) / v11;
    if (!v15)
    {
      int v9 = (v5 + v9) >> 1;
LABEL_19:
      LODWORD(v15) = 0;
      LODWORD(v16) = 0;
      ++*(_WORD *)(v3 + 188);
      int v18 = v7 + (((4064 - (v9 & 0xFFF)) | ((v9 & 0xFFF) - 31)) >= 0);
      char v19 = 0;
LABEL_20:
      int v17 = v9;
      goto LABEL_21;
    }
    uint64_t v16 = ((uint64_t)v11 << 12) / v12;
    int v18 = v7;
    if (!v16)
    {
      char v19 = 0;
      int v9 = (v5 + v9) >> 1;
      goto LABEL_20;
    }
    char v19 = 1;
    int v17 = v5;
LABEL_21:
    double result = aa_new_edge(v3);
    if (!result) {
      return result;
    }
    *((_DWORD *)result + 8) = v16;
    *((_DWORD *)result + 9) = v15;
    result[47] = v19;
    if (v10 - v4 < 1)
    {
      *((_WORD *)result + 22) = -1;
      *((_DWORD *)result + 4) = v17;
      *((_DWORD *)result + 5) = v9;
      *((_DWORD *)result + 6) = v10;
      *((_DWORD *)result + 7) = v4;
      if (*(_DWORD *)(v3 + 4) > v10) {
        *(_DWORD *)(v3 + 4) = v10;
      }
      int v7 = v18;
      if (*(_DWORD *)(v3 + 12) < v4) {
        *(_DWORD *)(v3 + 12) = v4;
      }
    }
    else
    {
      *((_WORD *)result + 22) = 1;
      *((_DWORD *)result + 4) = v9;
      *((_DWORD *)result + 5) = v17;
      *((_DWORD *)result + 6) = v4;
      *((_DWORD *)result + 7) = v10;
      if (*(_DWORD *)(v3 + 4) > v4) {
        *(_DWORD *)(v3 + 4) = v4;
      }
      int v7 = v18;
      if (*(_DWORD *)(v3 + 12) < v10) {
        *(_DWORD *)(v3 + 12) = v10;
      }
    }
    int v4 = v10;
LABEL_32:
    v8 += 2;
    --v6;
  }
  while (v6);
  if (v7) {
    *(_DWORD *)(v3 + 176) |= 0xC0000u;
  }
LABEL_37:
  *(_DWORD *)(v3 + 16) = v5;
  *(_DWORD *)(v3 + 20) = v4;
  return result;
}

char *aa_new_edge(uint64_t a1)
{
  int v2 = *(_DWORD **)(a1 + 192);
  unsigned int v3 = v2[2];
  unsigned int v4 = v2[3] + 1;
  if (v4 > v3)
  {
    int v5 = 2 * v3;
    int v2 = malloc_type_malloc((192 * v3) | 0x18, 0x705560E0uLL);
    if (!v2) {
      return 0;
    }
    *(void *)int v2 = *(void *)(a1 + 192);
    *(void *)(a1 + 192) = v2;
    v2[2] = v5;
    unsigned int v4 = 1;
  }
  uint64_t v6 = (char *)&v2[24 * v4 - 24];
  ++*(_DWORD *)(a1 + 184);
  *((void *)v6 + 3) = 0;
  *((void *)v6 + 4) = 0;
  int v7 = v6 + 24;
  v2[3] = v4;
  return v7;
}

double aa_moveto(uint64_t a1, float a2, float a3)
{
  aa_close(a1);
  int v6 = *(_DWORD *)(a1 + 176);
  ++*(_DWORD *)(a1 + 180);
  double v7 = 1.0;
  if (*(double *)(a1 + 168) != 0.0) {
    double v7 = *(double *)(a1 + 168);
  }
  double v8 = v7 * a2;
  double v9 = v7 * a3;
  if ((v6 & 0x30000) != 0)
  {
    double v10 = *(double *)(a1 + 64);
    double v11 = *(double *)(a1 + 72);
    double v12 = *(double *)(a1 + 80);
    double v13 = *(double *)(a1 + 88);
    double v14 = fabs(v8);
    double v15 = -1.0e15;
    if (v8 <= 0.0) {
      double v16 = -1.0e15;
    }
    else {
      double v16 = 1.0e15;
    }
    if (v14 >= 1.0e15) {
      double v17 = v16;
    }
    else {
      double v17 = v8;
    }
    double v18 = fabs(v9);
    if (v9 > 0.0) {
      double v15 = 1.0e15;
    }
    if (v18 >= 1.0e15) {
      double v9 = v15;
    }
    if (v17 <= v12) {
      double v8 = v17;
    }
    else {
      double v8 = *(double *)(a1 + 80);
    }
    int v19 = (v17 > v12) | (4 * (v17 < v10));
    int v20 = (8 * (v9 < v11)) | (2 * (v9 > v13));
    if (v17 < v10) {
      double v8 = *(double *)(a1 + 64);
    }
    if (v20) {
      BOOL v21 = v19 == 0;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      int v22 = 0;
    }
    else {
      int v22 = 16;
    }
    if (v9 > v13) {
      double v23 = *(double *)(a1 + 88);
    }
    else {
      double v23 = v9;
    }
    int v24 = v19 | v20 | v22;
    *(double *)(a1 + 48) = v17;
    *(double *)(a1 + 56) = v9;
    *(double *)(a1 + 32) = v17;
    *(double *)(a1 + 40) = v9;
    if (v9 >= v11) {
      double v9 = v23;
    }
    else {
      double v9 = v11;
    }
  }
  else
  {
    int v24 = 0;
    *(double *)(a1 + 48) = v8;
    *(double *)(a1 + 56) = v9;
    *(double *)(a1 + 32) = v8;
    *(double *)(a1 + 40) = v9;
  }
  double v25 = *(double *)(a1 + 160);
  double v26 = *(double *)(a1 + 128);
  double v27 = *(double *)(a1 + 136);
  *(_DWORD *)(a1 + 176) = v6 & 0xFFFF0000 | (v24 << 8) | v24;
  int v28 = (int)(v25 + v26 * v8);
  double result = v25 + v27 * v9;
  *(_DWORD *)(a1 + 24) = v28;
  *(_DWORD *)(a1 + 28) = (int)result;
  *(_DWORD *)(a1 + 16) = v28;
  *(_DWORD *)(a1 + 20) = (int)result;
  return result;
}

uint64_t aa_close(uint64_t result)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(result + 180))
  {
    uint64_t v1 = result;
    double v2 = *(double *)(result + 32);
    double v3 = *(double *)(result + 40);
    double v4 = *(double *)(result + 48);
    double v5 = *(double *)(result + 56);
    int v6 = *(_DWORD *)(result + 28);
    int v7 = *(_DWORD *)(result + 20);
    BOOL v8 = v4 == v2 && v5 == v3;
    if (!v8
      && (*(double *)(result + 32) = v4,
          *(double *)(result + 40) = v5,
          int v9 = *(_DWORD *)(result + 176),
          (v9 & 0x30000) != 0)
      && (*(_DWORD *)(result + 176) = *(_DWORD *)(result + 176) & 0xFFFF00FF | (*(_DWORD *)(result + 176) << 8),
          BYTE1(v9) | v9))
    {
      double result = aa_clip_edge(v11, BYTE1(v9), v9, *(double *)(result + 64), *(double *)(result + 72), *(double *)(result + 80), *(double *)(result + 88), *(double *)(result + 128), *(double *)(result + 136), *(double *)(result + 160), v2, v3, v4, v5);
      if (result) {
        int v7 = HIDWORD(v11[(result - 1)]);
      }
    }
    else
    {
      double result = 0;
    }
    if (v6 != v7)
    {
      double v10 = &v11[result];
      *double v10 = *(_DWORD *)(v1 + 24);
      v10[1] = v6;
      double result = (result + 1);
    }
    if (result) {
      return (uint64_t)aa_add_edges((char *)v1, (uint64_t)v11, result);
    }
  }
  return result;
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  if (path)
  {
    if (CGPathDisableTypeValidation || (CFTypeID v9 = CFGetTypeID(path), v9 == CGPathGetTypeID()))
    {
      int v11 = *((_DWORD *)path + 4);
      double v10 = (char *)path + 16;
      if ((v11 - 10) > 0xFFFFFFF6)
      {
        CG::Path::close_subpath((uint64_t)v10);
      }
      else
      {
        CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGPathCloseSubpath");
      }
    }
  }
}

uint64_t __CGPathApplyWithBlock2_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  int v4 = a2;
  uint64_t v5 = a3;
  return (*(uint64_t (**)(void, int *))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), &v4);
}

_DWORD *create_glyph_bitmap(uint64_t a1, char a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = 0;
  if ((a2 & 1) == 0)
  {
    CFDataRef v7 = (const __CFData *)FPFontCopyGlyphBitmap();
    if (v7)
    {
      CFDataRef v8 = v7;
      BytePtr = CFDataGetBytePtr(v7);
      uint64_t v5 = CGGlyphBitmapCreate(a5, 1, (int)0.0, (int)(0.0 + 0.0), (unint64_t)0.0, (unint64_t)0.0, 0, BytePtr);
      CFRelease(v8);
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

_DWORD *CGGlyphBitmapCreate(int a1, int a2, int a3, int a4, uint64_t a5, unint64_t a6, unint64_t a7, const void *a8)
{
  int v9 = a5;
  if (a7)
  {
    double v14 = 0;
    if ((a6 | a5) >> 16) {
      return v14;
    }
    unint64_t v15 = a7;
    if (0xFFFFFFFFFFFFFFD7 / a7 < a6) {
      return v14;
    }
    uint64_t v16 = 2;
    uint64_t v17 = 1;
    if ((a2 & 0x980) != 0) {
      uint64_t v17 = 2;
    }
    if ((a2 & 2) == 0) {
      uint64_t v16 = v17;
    }
    uint64_t v18 = 1;
    if ((a2 & 0x401) != 0) {
      uint64_t v18 = v16;
    }
    if (v18 * a5 > a7) {
      return 0;
    }
  }
  else
  {
    if ((a6 | a5) >> 16) {
      return 0;
    }
    uint64_t v19 = 2;
    uint64_t v20 = 1;
    if ((a2 & 0x980) != 0) {
      uint64_t v20 = 2;
    }
    if ((a2 & 2) == 0) {
      uint64_t v19 = v20;
    }
    uint64_t v21 = 1;
    if ((a2 & 0x401) != 0) {
      uint64_t v21 = v19;
    }
    unint64_t v15 = (v21 * a5 + 15) & 0xFFFFFFFFFFFFFFF0;
  }
  int v22 = 1;
  double v23 = malloc_type_calloc(1uLL, v15 * a6 + 40, 0x805E2C1EuLL);
  double v14 = v23;
  if (v23)
  {
    *double v23 = 1;
    v23[1] = a1;
    v23[2] = a2;
    v23[3] = a3;
    v23[4] = a4;
    v23[5] = v9;
    v23[6] = a6;
    if ((a2 & 0x401) != 0)
    {
      int v22 = 16;
      int v24 = a8;
      if ((a2 & 2) == 0)
      {
        if ((a2 & 0x980) != 0) {
          int v22 = 16;
        }
        else {
          int v22 = 8;
        }
      }
    }
    else
    {
      int v24 = a8;
    }
    v23[7] = v22;
    v23[8] = v15;
    v23[9] = atomic_fetch_add_explicit(CGGlyphBitmapCreate_generation, 1u, memory_order_relaxed) + 1;
    if (v24) {
      memcpy(v23 + 10, v24, v15 * a6);
    }
  }
  return v14;
}

void aa_cache_render(int32x4_t *a1, int a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  uint64_t v170 = *MEMORY[0x1E4F143B8];
  if (a3 && a4)
  {
    int v7 = a1->i32[1];
    __int32 v8 = a1->i32[2];
    __int32 v9 = a1->i32[3];
    BOOL v10 = v8 - a1->i32[0] < 31 || v9 - v7 < 31;
    if (!v10 && 24 * a1[11].i32[2] + 44 >= 1)
    {
      uint64_t v13 = (a1->i32[0] >> 12);
      int v14 = v7 >> 12;
      LODWORD(v163) = v9 + 4095;
      int v15 = (v9 + 4095) >> 12;
      int v16 = v15 - (v7 >> 12);
      int v17 = ((v8 + 4095) >> 12) - v13;
      int v18 = v17 + 16;
      int v165 = v17;
      if (v17 > 1015)
      {
        uint64_t v21 = (char *)malloc_type_malloc(4 * (v17 + 16), 0x705560E0uLL);
        int v161 = v21;
        int v166 = v21;
      }
      else
      {
        MEMORY[0x1F4188790](a1, a5);
        int v166 = &v155[-v19];
        bzero(&v155[-v19], v20);
        int v161 = 0;
      }
      uint64_t v162 = a4;
      uint64_t v158 = a3;
      uint64_t v157 = v13;
      signed int v164 = v7;
      if (v16 > 1015)
      {
        size_t v23 = 8 * (v16 + 16);
        double v25 = malloc_type_malloc(v23, 0x705560E0uLL);
        uint64_t v160 = v25;
      }
      else
      {
        size_t v23 = 8 * (v16 + 16);
        MEMORY[0x1F4188790](v21, v22);
        double v25 = &v155[-v24];
        bzero(&v155[-v24], v23);
        uint64_t v160 = 0;
      }
      int v156 = v16;
      bzero(v166, 4 * v18);
      bzero(v25, v23);
      int v33 = (void **)(v25 + 32);
      int v34 = &v33[-v14];
      int v159 = a2;
      if ((a2 & 0x10) != 0 && v165 <= 23 && a1[11].i16[6])
      {
        int v167 = (uint64_t *)&v167;
        int v168 = (uint64_t *)&v167;
        BOOL v35 = (float *)v169;
        int32x4_t v36 = *a1;
        float32x2x2_t v37 = (float32x2x2_t)vaddq_s32(*a1, (int32x4_t)xmmword_1850CDE40);
        unint64_t v38 = vextq_s8((int8x16_t)v37, (int8x16_t)v37, 8uLL).u64[0];
        vst2_f32(v35, v37);
        uint64_t v39 = a1[12].i64[0];
        if (v39)
        {
          int v40 = v15 + 8;
          memset(&v169[16], 0, 64);
          do
          {
            for (unint64_t i = v39 + 24 + 96 * (*(_DWORD *)(v39 + 12) - 1); i >= v39 + 24; i -= 96)
            {
              if (!*(unsigned char *)(i + 47))
              {
                int v42 = *(_DWORD *)(i + 16);
                for (j = (unint64_t *)v168; ; j = (unint64_t *)j[1])
                {
                  int v44 = *((_DWORD *)j + 4);
                  if (v42 >= v44) {
                    break;
                  }
                }
                int v45 = *(_DWORD *)(i + 28) - *(_DWORD *)(i + 24);
                if (v42 <= v44)
                {
                  if (v45 <= *((_DWORD *)j + 17))
                  {
                    *(_DWORD *)(i + 68) = v45;
                    *(void *)(i + 56) = j[7];
                    j[7] = i;
                  }
                  else
                  {
                    unint64_t v47 = *j;
                    BOOL v48 = (unint64_t *)j[1];
                    unint64_t *j = 0;
                    j[1] = 0;
                    *(void *)unint64_t i = v47;
                    *(void *)(i + 8) = v48;
                    *(void *)(v47 + 8) = i;
                    *BOOL v48 = i;
                    *(_DWORD *)(i + 68) = v45;
                    *(void *)(i + 56) = j;
                  }
                }
                else
                {
                  unint64_t v46 = *j;
                  *(void *)unint64_t i = *j;
                  *(void *)(i + 8) = j;
                  *(void *)(v46 + 8) = i;
                  unint64_t *j = i;
                  *(_DWORD *)(i + 68) = v45;
                  *(void *)(i + 56) = 0;
                }
              }
            }
            uint64_t v39 = *(void *)v39;
          }
          while (v39);
          double v49 = v167;
          double v50 = v168;
          if (v167 == v168) {
            goto LABEL_66;
          }
          int v51 = *((_DWORD *)v167 + 4);
          int v52 = *((_DWORD *)v168 + 4);
          if (v51 < v52)
          {
            int v53 = 4096;
            int v54 = 4096;
            double v55 = v167;
            double v56 = v168;
            do
            {
              int v57 = *((_DWORD *)v56 + 4);
              if (v51 >= v57) {
                goto LABEL_41;
              }
              int v58 = v55;
              while (1)
              {
                int v59 = *((_DWORD *)v58 + 17);
                if (v59 >= v54) {
                  break;
                }
                int v58 = (uint64_t *)*v58;
                if (*((_DWORD *)v58 + 4) >= v57)
                {
                  double v55 = v58;
                  goto LABEL_41;
                }
              }
              int v54 = v59 + 4095;
              double v55 = (uint64_t *)*v58;
              double v49 = v58;
LABEL_41:
              while (v52 > *((_DWORD *)v49 + 4))
              {
                int v60 = *((_DWORD *)v50 + 17);
                if (v60 >= v53)
                {
                  int v53 = v60 + 4095;
                  double v56 = v50;
                  double v50 = (uint64_t *)v50[1];
                  int v52 = *((_DWORD *)v50 + 4);
                  break;
                }
                double v50 = (uint64_t *)v50[1];
                int v52 = *((_DWORD *)v50 + 4);
              }
              int v51 = *((_DWORD *)v55 + 4);
            }
            while (v51 < v52);
            int v51 = *((_DWORD *)v49 + 4);
          }
          if (*((int *)v49 + 17) < 0x2000)
          {
LABEL_66:
            unsigned int v65 = 0;
          }
          else
          {
            unsigned int v61 = v36.i16[0] & 0xFFF;
            unsigned int v62 = v51 & 0xFFF;
            BOOL v64 = v36.i32[0] > 0 || v51 > 4095;
            if (v62 <= v61 && v64)
            {
              unsigned int v65 = -v62;
            }
            else
            {
              int v153 = 2048 - (v36.i16[4] & 0xFFF);
              unsigned int v65 = 4096 - v62;
              if ((int)(4096 - v62) > v153)
              {
                char v154 = !v64;
                if ((int)(v62 - v61) >= (int)(4096 - v62 - v153)) {
                  char v154 = 1;
                }
                if (v154)
                {
                  if (v62 <= 0x800) {
                    unsigned int v65 = 0;
                  }
                  else {
                    unsigned int v65 = 2048 - (v36.i16[4] & 0xFFF);
                  }
                }
                else
                {
                  unsigned int v65 = -v61;
                }
              }
            }
          }
          uint64_t v69 = a1[12].i64[0];
          if (v69)
          {
            int32x2_t v70 = vdup_n_s32(v65);
            do
            {
              for (k = (int32x2_t *)(v69 + 24 + 96 * (*(_DWORD *)(v69 + 12) - 1));
                    (unint64_t)k >= v69 + 24;
                    k -= 12)
              {
                int v72 = k[3].i32[0] >> 12;
                if (v72 >= v40)
                {
                  CGPostError((uint64_t)"%s; index %d out of bounds; max_indedouble x = %d",
                    v26,
                    v27,
                    v28,
                    v29,
                    v30,
                    v31,
                    v32,
                    (char)"aa_cache_adjust_edges");
                }
                else
                {
                  int32x2_t *k = (int32x2_t)v34[v72];
                  v34[v72] = k;
                  k[2] = vadd_s32(k[2], v70);
                }
              }
              uint64_t v69 = *(void *)v69;
            }
            while (v69);
          }
        }
      }
      else
      {
        for (uint64_t m = a1[12].i64[0]; m; uint64_t m = *(void *)m)
        {
          for (unint64_t n = m + 24 + 96 * (*(_DWORD *)(m + 12) - 1); n >= m + 24; n -= 96)
          {
            int v68 = *(int *)(n + 24) >> 12;
            if (v68 >= v15 + 8)
            {
              CGPostError((uint64_t)"%s; index %d out of bounds; max_indedouble x = %d",
                v26,
                v27,
                v28,
                v29,
                v30,
                v31,
                v32,
                (char)"aa_cache_edges");
            }
            else
            {
              *(void *)unint64_t n = v34[v68];
              v34[v68] = (void *)n;
            }
          }
        }
      }
      a1[12].i64[1] = 0;
      a1[13].i64[0] = 0;
      BOOL v73 = &a1[12].i64[1];
      signed int v74 = v164 & 0xFFFFF000;
      signed int v164 = v163 & 0xFFFFF000;
      if (v74 < (v163 & 0xFFFFF000))
      {
        unint64_t v75 = (_DWORD *)(v158 + (v156 - 1) * v162);
        int v76 = &v166[(-(v166 - 2 * v157 + 8 + 2 * v157) & 0x1FLL) + 8 + -2 * (int)v157];
        if ((v159 & 0x20) != 0) {
          unsigned int v77 = 0;
        }
        else {
          unsigned int v77 = 255;
        }
        uint64_t v163 = -v162;
        int v166 = &v76[2 * (int)v157 - 2];
        LODWORD(v162) = v165 >> 2;
        int32x4_t v78 = vdupq_n_s32(v77);
        int v79 = v165 & 3;
        do
        {
          int v80 = 0;
          signed int v81 = v74;
          uint8x8_t v82 = *v33;
          v74 += 4096;
          for (iunint64_t i = (void *)*v73; ; iunint64_t i = 0)
          {
            uint8x8_t v84 = ii;
            if (v82)
            {
              while (1)
              {
                while (1)
                {
                  while (1)
                  {
                    uint64_t v85 = v82;
                    uint8x8_t v82 = (void *)*v82;
                    int v86 = *((unsigned __int16 *)v85 + 22);
                    BOOL v87 = v86 == 0xFFFF;
                    if (v86 == 0xFFFF) {
                      uint64_t v88 = 20;
                    }
                    else {
                      uint64_t v88 = 16;
                    }
                    if (v87) {
                      int v89 = *((_DWORD *)v85 + 7);
                    }
                    else {
                      int v89 = *((_DWORD *)v85 + 6);
                    }
                    if (v87) {
                      uint64_t v90 = 16;
                    }
                    else {
                      uint64_t v90 = 20;
                    }
                    if (v87) {
                      int v91 = *((_DWORD *)v85 + 6);
                    }
                    else {
                      int v91 = *((_DWORD *)v85 + 7);
                    }
                    if (*((_DWORD *)v85 + 7) > v74)
                    {
                      *uint64_t v85 = v80;
                      int v80 = v85;
                    }
                    if (v91 == v89) {
                      goto LABEL_138;
                    }
                    int v92 = *(_DWORD *)((char *)v85 + v90);
                    int v93 = *(_DWORD *)((char *)v85 + v88);
                    int v94 = v89 - v81;
                    int v95 = v91 - v81;
                    if (v92 != v93) {
                      break;
                    }
                    if (v94 >= 4095) {
                      int v94 = 4095;
                    }
                    int v96 = v94 & ~(v94 >> 31);
                    if (v95 >= 4095) {
                      int v95 = 4095;
                    }
                    int v97 = (v95 & ~(v95 >> 31)) - v96;
                    int v98 = &v76[2 * (v92 >> 12)];
                    int v99 = v97 * (4096 - (v92 & 0xFFF));
                    int v100 = *((unsigned __int16 *)v98 + 1) + v97 - (v99 >> 12);
                    *(_WORD *)v98 += v99 >> 12;
                    *((_WORD *)v98 + 1) = v100;
                    if (!v82) {
                      goto LABEL_161;
                    }
                  }
                  double v102 = v85 + 4;
                  int v101 = *((_DWORD *)v85 + 8);
                  uint64_t v103 = *((int *)v102 + 1);
                  if (v91 <= v89) {
                    break;
                  }
                  if ((v94 & 0x80000000) == 0)
                  {
                    if (v95 > 4096)
                    {
                      if (v94 > 0xFFF) {
                        goto LABEL_138;
                      }
LABEL_119:
                      v92 += (unint64_t)((int)v103 * (uint64_t)(4096 - v95)) >> 12;
                      int v95 = 4096;
                      goto LABEL_120;
                    }
                    goto LABEL_120;
                  }
                  if (v95 >= 1)
                  {
                    int v94 = 0;
                    v93 += (unint64_t)((int)v103 * (uint64_t)(v81 - v89)) >> 12;
                    if (v95 > 0x1000) {
                      goto LABEL_119;
                    }
                    goto LABEL_120;
                  }
LABEL_138:
                  if (!v82) {
                    goto LABEL_161;
                  }
                }
                if (v94 <= 4096)
                {
                  if ((v95 & 0x80000000) == 0) {
                    goto LABEL_120;
                  }
                  if (v94 >= 1)
                  {
LABEL_116:
                    int v95 = 0;
                    v92 += (v103 * (unint64_t)(v81 - v91)) >> 12;
                    goto LABEL_120;
                  }
                  goto LABEL_138;
                }
                if (v95 > 4095) {
                  goto LABEL_138;
                }
                v93 += (unint64_t)((int)v103 * (uint64_t)(4096 - v94)) >> 12;
                int v94 = 4096;
                if (v95 < 0) {
                  goto LABEL_116;
                }
LABEL_120:
                int v104 = v93 >> 12;
                if (v93 >> 12 == v92 >> 12)
                {
                  int v105 = v92 - v93;
                  if (v92 - v93 < 0) {
                    int v105 = v93 - v92;
                  }
                  if (v92 <= v93) {
                    __int16 v106 = v93;
                  }
                  else {
                    __int16 v106 = v92;
                  }
                  int v107 = &v76[2 * ((v93 + (uint64_t)v92) >> 13)];
                  unsigned int v108 = v95 - v94;
                  unint64_t v109 = ((v105 - 2 * (v106 & 0xFFFu) + 0x2000) * (unint64_t)v108) >> 13;
                  LOWORD(v108) = *((_WORD *)v107 + 1) + v108 - v109;
                  *(_WORD *)v107 += v109;
                  *((_WORD *)v107 + 1) = v108;
                  if (!v82) {
                    break;
                  }
                }
                else
                {
                  int v110 = v92 >> 12;
                  if ((v104 - v110) * (v104 - v110) == 1)
                  {
                    BOOL v111 = v92 < v93;
                    if (v92 >= v93) {
                      int v112 = v93;
                    }
                    else {
                      int v112 = v92;
                    }
                    if (v92 <= v93) {
                      LOWORD(v92) = v93;
                    }
                    if (v111) {
                      int v113 = -v101;
                    }
                    else {
                      int v113 = v101;
                    }
                    int v114 = v95 - v94;
                    int v115 = 4096 - (v112 & 0xFFF);
                    int v116 = v115 * v113;
                    int v117 = &v76[2 * (v112 >> 12)];
                    int v118 = (v116 >> 12) * v115;
                    int v119 = (v114 - (v116 >> 12)) * (v92 & 0xFFF);
                    __int16 v120 = *((_WORD *)v117 + 2);
                    int v121 = *((unsigned __int16 *)v117 + 1) + v114 - ((v118 >> 13) + (v119 >> 13));
                    *(_WORD *)v117 += v118 >> 13;
                    *((_WORD *)v117 + 1) = v121;
                    *((_WORD *)v117 + 2) = v120 + (v119 >> 13);
                    goto LABEL_138;
                  }
                  BOOL v122 = v92 < v93;
                  if (v92 < v93) {
                    __int16 v123 = v92;
                  }
                  else {
                    __int16 v123 = v93;
                  }
                  if (v92 >= v93) {
                    LOWORD(v93) = v92;
                  }
                  if (v122) {
                    int v124 = -v101;
                  }
                  else {
                    int v124 = v101;
                  }
                  if (v122) {
                    int v125 = v110;
                  }
                  else {
                    int v125 = v104;
                  }
                  if (v122) {
                    int v110 = v104;
                  }
                  int v126 = 4096 - (v123 & 0xFFF);
                  int v127 = (v126 * v124) >> 12;
                  uint64_t v128 = &v76[2 * v125];
                  int v129 = v127 * v126;
                  int v130 = v127 + (v124 >> 1);
                  __int16 v132 = *((_WORD *)v128 + 1);
                  int8x16_t v131 = v128 + 2;
                  *(_WORD *)v128 += v129 >> 13;
                  *((_WORD *)v128 + 1) = v132 + v130 - (v129 >> 13);
                  int v133 = v110 + ~v125;
                  if (v133 < 1)
                  {
                    int v136 = 0;
                    int8x16_t v131 = v128;
                  }
                  else
                  {
                    if (v133 != 1)
                    {
                      unsigned int v134 = v110 - v125;
                      do
                      {
                        __int16 v135 = *((_WORD *)v131 + 1);
                        v131 += 2;
                        LOWORD(v130) = v130 + v124;
                        *(_WORD *)int8x16_t v131 = v135 + v124;
                        --v134;
                      }
                      while (v134 > 2);
                    }
                    int v136 = v124;
                  }
                  int v137 = v136 - (((((4096 - (v93 & 0xFFF)) * v124) >> 12) * (4096 - (v93 & 0xFFF))) >> 13);
                  __int16 v138 = *((_WORD *)v131 + 2);
                  *((_WORD *)v131 + 1) += v137;
                  *((_WORD *)v131 + 2) = v138 + v95 - (v94 + v130) - v137;
                  if (!v82) {
                    break;
                  }
                }
              }
            }
LABEL_161:
            if (!v84) {
              break;
            }
            *BOOL v73 = 0;
            uint8x8_t v82 = v84;
          }
          *BOOL v73 = (uint64_t)v80;
          int32x4_t v139 = 0uLL;
          int v140 = v75;
          int v141 = v166;
          if (v165 >= 4)
          {
            int v142 = v162;
            int v141 = v166;
            int v140 = v75;
            do
            {
              int16x4_t v143 = *(int16x4_t *)(v141 + 2);
              *(void *)(v141 + 2) = 0;
              v141 += 8;
              int32x4_t v144 = vaddw_s16((int32x4_t)vshlq_n_s64((int64x2_t)vmovl_s16(v143), 0x20uLL), v143);
              v144.u64[1] = (unint64_t)vadd_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v144, (int8x16_t)v144, 8uLL), vdup_lane_s32(*(int32x2_t *)v144.i8, 1));
              int32x4_t v145 = vaddq_s32(v144, v139);
              int32x4_t v146 = vmaxq_s32(vshrq_n_s32(vabsq_s32(v145), 4uLL), (int32x4_t)0);
              int16x8_t v147 = (int16x8_t)vorrq_s8((int8x16_t)v146, (int8x16_t)vcgtq_s32(v146, v78));
              *(int16x4_t *)v147.i8 = vmovn_s32((int32x4_t)v147);
              *v140++ = vmovn_s16(v147).u32[0];
              int32x4_t v139 = vdupq_laneq_s32(v145, 3);
              --v142;
            }
            while (v142);
          }
          if (v79)
          {
            int v148 = v139.i32[0];
            unint64_t v149 = (__int16 *)(v141 + 2);
            int v150 = v79;
            do
            {
              v148 += *v149;
              *v149++ = 0;
              if (v148 >= 0) {
                unsigned int v151 = v148;
              }
              else {
                unsigned int v151 = -v148;
              }
              unsigned int v152 = v151 >> 4;
              if (v152 > v77) {
                LOBYTE(v152) = -1;
              }
              *(unsigned char *)int v140 = v152;
              int v140 = (_DWORD *)((char *)v140 + 1);
              --v150;
            }
            while (v150);
          }
          unint64_t v75 = (_DWORD *)((char *)v75 + v163);
          ++v33;
        }
        while (v74 < v164);
      }
      if (v161) {
        free(v161);
      }
      if (v160) {
        free(v160);
      }
    }
  }
}

atomic_ullong *CGFontGetAutohinter(atomic_ullong *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result + 8;
    double result = (atomic_ullong *)atomic_load_explicit(result + 8, memory_order_acquire);
    if (!result)
    {
      double result = (atomic_ullong *)malloc_type_calloc(1uLL, 0xC8uLL, 0x20040E6F86433uLL);
      uint64_t v3 = 0;
      *double result = (atomic_ullong)v1;
      atomic_compare_exchange_strong(v2, (unint64_t *)&v3, (unint64_t)result);
      if (v3)
      {
        CGFontAutohinterRelease((char *)result);
        return (atomic_ullong *)v3;
      }
    }
  }
  return result;
}

double *CGFontAutohinterCreateAutohintTransform(uint64_t *a1, double *a2, int a3, double a4)
{
  if (!a1) {
    return 0;
  }
  double v6 = *a2;
  if (*a2 <= 0.0 || v6 != a2[3] || a2[1] != 0.0 || a2[2] != 0.0) {
    return 0;
  }
  int v7 = (int)v6;
  if (v6 != (double)(int)v6) {
    int v7 = 0;
  }
  if ((v7 - 19) < 0xFFFFFFF4) {
    return 0;
  }
  uint64_t v12 = (v7 - 7);
  uint64_t v13 = 13;
  if (a3) {
    uint64_t v13 = 1;
  }
  int v14 = &a1[v13];
  unint64_t explicit = atomic_load_explicit(&a1[v13 + v12], memory_order_acquire);
  if (!explicit)
  {
    int v16 = CGFontAutohintTransformCreate(*a1, a2, a3, a4);
    if (!v16) {
      return 0;
    }
    unint64_t explicit = 0;
    atomic_compare_exchange_strong(&v14[v12], &explicit, (unint64_t)v16);
    if (explicit)
    {
      if (atomic_fetch_add_explicit((atomic_uint *volatile)v16, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        free(v16);
      }
    }
    else
    {
      unint64_t explicit = (unint64_t)v16;
    }
  }
  if (*(double *)(explicit + 16) == a4)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)explicit, 1u, memory_order_relaxed);
    return (double *)explicit;
  }
  uint64_t v15 = *a1;

  return CGFontAutohintTransformCreate(v15, a2, a3, a4);
}

double CGFontStrikeKeyInit(uint64_t a1, uint64_t a2, _OWORD *a3, int a4, double a5, double a6)
{
  if (a2)
  {
    int v6 = *(_DWORD *)(a2 + 24);
    if (!v6)
    {
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a2 + 24), (unsigned int *)&v6, ~atomic_fetch_add_explicit(get_identifier_identifier, 1u, memory_order_relaxed), memory_order_relaxed, memory_order_relaxed);
      int v6 = *(_DWORD *)(a2 + 24);
    }
  }
  else
  {
    int v6 = 0;
  }
  *(_DWORD *)a1 = v6;
  long long v8 = a3[1];
  long long v7 = a3[2];
  *(_OWORD *)(a1 + 8) = *a3;
  *(_OWORD *)(a1 + 24) = v8;
  double v9 = *(double *)(a1 + 32);
  *(double *)&long long v8 = *(double *)(a1 + 24) + (*(double *)(a1 + 8) + *(double *)(a1 + 16)) * 10000.0;
  *(_OWORD *)(a1 + 40) = v7;
  *(_DWORD *)(a1 + 4) = a4;
  *(double *)(a1 + 56) = a5;
  *(double *)(a1 + 64) = a6;
  double result = (a5 + a6) * 1000.0;
  *(void *)(a1 + 72) = (unint64_t)result
                       + (a4 << 8)
                       + (v6 << 12)
                       + ((unint64_t)(*(double *)&v8 + v9) << 20);
  return result;
}

uint64_t aa_clip_edge(_DWORD *a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  double v19 = a12;
  unsigned int v20 = a3 & 0xFFFFFFEF;
  double v21 = a14 - a12;
  double v22 = a13 - a11;
  uint64_t v23 = 0;
  unsigned int v24 = a2 & 0xFFFFFFEF;
  if ((a2 & 0xFFFFFFEF) == 0) {
    goto LABEL_13;
  }
  int v25 = 16 * (v20 == 0);
  while ((v20 & v24) == 0)
  {
    if (v24)
    {
      if ((v24 & 4) == 0) {
        goto LABEL_6;
      }
    }
    else
    {
      *a1 = (int)(a10 + a8 * a11);
      a1[1] = (int)(a10 + a9 * v19);
      a1 += 2;
      uint64_t v23 = (v23 + 1);
LABEL_13:
      int v25 = 0;
      double v22 = -v22;
      double v21 = -v21;
      double v19 = a14;
      a11 = a13;
      unsigned int v24 = v20;
      unsigned int v20 = 0;
      if ((v24 & 4) == 0)
      {
LABEL_6:
        if (v24)
        {
          if ((v25 & 5) != 0)
          {
            v24 &= ~1u;
          }
          else
          {
            double v19 = v19 + (a6 - a11) * v21 / v22;
            unsigned int v24 = (2 * (v19 > a7)) | (8 * (v19 < a5));
          }
          v25 |= 1u;
          a11 = a6;
        }
        else if ((v24 & 2) != 0)
        {
          if ((v25 & 0xA) != 0)
          {
            v24 &= ~2u;
          }
          else
          {
            a11 = a11 + (a7 - v19) * v22 / v21;
            unsigned int v24 = (a11 > a6) | (4 * (a11 < a4));
          }
          v25 |= 2u;
          double v19 = a7;
        }
        else if ((v24 & 8) != 0)
        {
          v24 &= ~8u;
          double v26 = a11 + (a5 - v19) * v22 / v21;
          if ((v25 & 0xA) == 0)
          {
            a11 = v26;
            unsigned int v24 = (v26 > a6) | (4 * (v26 < a4));
          }
          v25 |= 8u;
          double v19 = a5;
        }
        goto LABEL_26;
      }
    }
    if ((v25 & 5) != 0)
    {
      v24 &= ~4u;
    }
    else
    {
      double v19 = v19 + (a4 - a11) * v21 / v22;
      unsigned int v24 = (2 * (v19 > a7)) | (8 * (v19 < a5));
    }
    v25 |= 4u;
    a11 = a4;
LABEL_26:
    if (!(v25 & 0x10 | v20 | v24)) {
      goto LABEL_27;
    }
  }
  if (a2 == a3) {
    return v23;
  }
  if (((a3 | a2) & 0x10) == 0)
  {
    LOBYTE(a3) = a3 | a2 | 0x10;
    goto LABEL_28;
  }
  if ((v20 & v24 & 4) != 0)
  {
    if ((a2 & 4) == 0)
    {
      if ((a2 & 8) != 0) {
        double v19 = a5;
      }
      else {
        double v19 = a7;
      }
      a11 = a4;
      goto LABEL_27;
    }
  }
  else if (v20 & v24)
  {
    if ((a2 & 1) == 0)
    {
      if ((a2 & 8) != 0) {
        double v19 = a5;
      }
      else {
        double v19 = a7;
      }
      a11 = a6;
      goto LABEL_27;
    }
  }
  else if ((v20 & v24 & 2) != 0)
  {
    if ((a2 & 2) == 0)
    {
      if ((a2 & 4) != 0) {
        a11 = a4;
      }
      else {
        a11 = a6;
      }
      double v19 = a7;
      goto LABEL_27;
    }
  }
  else
  {
    if ((v20 & v24 & 8) == 0)
    {
LABEL_27:
      *a1 = (int)(a10 + a8 * a11);
      a1[1] = (int)(a10 + a9 * v19);
      a1 += 2;
      uint64_t v23 = (v23 + 1);
      goto LABEL_28;
    }
    if ((a2 & 8) == 0)
    {
      if ((a2 & 4) != 0) {
        a11 = a4;
      }
      else {
        a11 = a6;
      }
      double v19 = a5;
      goto LABEL_27;
    }
  }
LABEL_28:
  if ((a3 & 0x10) != 0)
  {
    if ((a3 & 4) == 0) {
      a4 = a6;
    }
    if ((a3 & 8) == 0) {
      a5 = a7;
    }
    *a1 = (int)(a10 + a8 * a4);
    a1[1] = (int)(a10 + a9 * a5);
    return (v23 + 1);
  }
  return v23;
}

uint64_t should_auto_hint(uint64_t a1)
{
  return MEMORY[0x1F4119DE0](*(void *)(a1 + 8));
}

void ___ZN18CGPathRandomAccess8add_pathEPK6CGPath17CGAffineTransformb_block_invoke_23(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      int v4 = *(char ***)(a1 + 56);
      uint64_t v5 = v4[1];
      if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v5 - *v4) >> 3)) <= *(void *)(a1 + 64) || !*(unsigned char *)(a1 + 120)) {
        goto LABEL_6;
      }
      if (*v4 == v5) {
        goto LABEL_183;
      }
      CGPathRandomAccessSubpath::close_if_needed((CGPathRandomAccessSubpath *)(v5 - 56));
      uint64_t v5 = v4[1];
LABEL_6:
      unint64_t v6 = (unint64_t)v4[2];
      if ((unint64_t)v5 >= v6)
      {
        signed int v74 = *v4;
        uint64_t v75 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *v4) >> 3);
        unint64_t v76 = v75 + 1;
        if ((unint64_t)(v75 + 1) > 0x492492492492492) {
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
        unint64_t v77 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - (void)v74) >> 3);
        if (2 * v77 > v76) {
          unint64_t v76 = 2 * v77;
        }
        if (v77 >= 0x249249249249249) {
          unint64_t v78 = 0x492492492492492;
        }
        else {
          unint64_t v78 = v76;
        }
        if (v78 > 0x492492492492492) {
          std::__throw_bad_array_new_length[abi:fe180100]();
        }
        uint64_t v79 = 56 * v78;
        int v80 = (char *)operator new(56 * v78);
        signed int v81 = &v80[56 * v75];
        uint8x8_t v82 = &v80[v79];
        *((void *)v81 + 6) = 0;
        *(_OWORD *)signed int v81 = 0u;
        *((_OWORD *)v81 + 1) = 0u;
        *((_OWORD *)v81 + 2) = 0u;
        v81[48] = 1;
        long long v7 = v81 + 56;
        if (v5 == v74)
        {
          *int v4 = v81;
          v4[1] = v7;
          v4[2] = v82;
        }
        else
        {
          uint64_t v83 = 0;
          do
          {
            uint8x8_t v84 = &v81[v83];
            uint64_t v85 = &v5[v83];
            *((void *)v84 - 7) = 0;
            *((void *)v84 - 6) = 0;
            *((void *)v84 - 5) = 0;
            *(_OWORD *)(v84 - 56) = *(_OWORD *)&v5[v83 - 56];
            *((void *)v84 - 5) = *(void *)&v5[v83 - 40];
            *((void *)v85 - 7) = 0;
            *((void *)v85 - 6) = 0;
            *((void *)v85 - 5) = 0;
            *((void *)v84 - 4) = 0;
            *((void *)v84 - 3) = 0;
            *((void *)v84 - 2) = 0;
            *((_OWORD *)v84 - 2) = *(_OWORD *)&v5[v83 - 32];
            *((void *)v84 - 2) = *(void *)&v5[v83 - 16];
            *((void *)v85 - 4) = 0;
            *((void *)v85 - 3) = 0;
            *((void *)v85 - 2) = 0;
            *(v84 - 8) = v5[v83 - 8];
            v83 -= 56;
          }
          while (&v5[v83] != v74);
          uint64_t v5 = *v4;
          uint64_t v86 = (uint64_t)v4[1];
          *int v4 = &v81[v83];
          v4[1] = v7;
          v4[2] = v82;
          while ((char *)v86 != v5)
          {
            v86 -= 56;
            std::allocator<CGPathRandomAccessSubpath>::destroy[abi:fe180100](v86);
          }
        }
        if (v5) {
          operator delete(v5);
        }
      }
      else
      {
        *((void *)v5 + 6) = 0;
        *((_OWORD *)v5 + 1) = 0u;
        *((_OWORD *)v5 + 2) = 0u;
        *(_OWORD *)uint64_t v5 = 0u;
        v5[48] = 1;
        long long v7 = v5 + 56;
      }
      v4[1] = v7;
      if (*v4 == v7) {
        goto LABEL_183;
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7 - 56;
      unint64_t v117 = ~*(void *)(a1 + 64) + 0x6DB6DB6DB6DB6DB7 * ((v4[1] - *v4) >> 3);
      uint64_t v118 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      if (v117 >= (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 48) - v118) >> 4) {
        goto LABEL_183;
      }
      int v119 = (unint64_t *)(v118 + 16 * v117);
      unint64_t v120 = *v119;
      unint64_t v121 = v119[1];
      BOOL v122 = *(char ***)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (*v119 <= (v122[2] - *v122) >> 4) {
        goto LABEL_116;
      }
      if (v120 >> 60) {
        goto LABEL_185;
      }
      uint64_t v123 = v122[1] - *v122;
      int v124 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v120);
      int v125 = &v124[v123];
      int v127 = &v124[16 * v126];
      int v129 = *v122;
      uint64_t v128 = v122[1];
      int v130 = v125;
      if (v128 != *v122)
      {
        do
        {
          uint64_t v131 = *((void *)v128 - 2);
          v128 -= 16;
          char v132 = v128[8];
          *((void *)v130 - 2) = v131;
          v130 -= 16;
          v130[8] = v132;
        }
        while (v128 != v129);
        uint64_t v128 = *v122;
      }
      *BOOL v122 = v130;
      v122[1] = v125;
      v122[2] = v127;
      if (v128) {
        operator delete(v128);
      }
LABEL_116:
      int v133 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      uint64_t v134 = v133[3];
      if (v121 <= (v133[5] - v134) >> 4) {
        goto LABEL_123;
      }
      if (v121 >> 60) {
        goto LABEL_184;
      }
      uint64_t v135 = v133[4] - v134;
      int v136 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v121);
      int v137 = &v136[v135 & 0xFFFFFFFFFFFFFFF0];
      int32x4_t v139 = &v136[16 * v138];
      int v141 = (char *)v133[3];
      int v140 = (char *)v133[4];
      int v142 = v137;
      if (v140 != v141)
      {
        do
        {
          *((_OWORD *)v142 - 1) = *((_OWORD *)v140 - 1);
          v142 -= 16;
          v140 -= 16;
        }
        while (v140 != v141);
        int v140 = (char *)v133[3];
      }
      v133[3] = v142;
      v133[4] = v137;
      v133[5] = v139;
      if (v140) {
        operator delete(v140);
      }
LABEL_123:
      *(_OWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = *(_OWORD *)*(void *)(a2 + 8);
      int16x4_t v143 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      int32x4_t v144 = (_OWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      int32x4_t v146 = (_OWORD *)v143[4];
      unint64_t v145 = v143[5];
      if ((unint64_t)v146 < v145)
      {
        *int32x4_t v146 = *v144;
        int16x8_t v147 = v146 + 1;
LABEL_174:
        v143[4] = v147;
        return;
      }
      uint64_t v148 = v143[3];
      uint64_t v149 = ((uint64_t)v146 - v148) >> 4;
      unint64_t v150 = v149 + 1;
      if (!((unint64_t)(v149 + 1) >> 60))
      {
        uint64_t v151 = v145 - v148;
        if (v151 >> 3 > v150) {
          unint64_t v150 = v151 >> 3;
        }
        if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v152 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v152 = v150;
        }
        if (v152) {
          unint64_t v152 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v152);
        }
        else {
          uint64_t v153 = 0;
        }
        unint64_t v182 = (_OWORD *)(v152 + 16 * v149);
        unint64_t v183 = v152 + 16 * v153;
        *unint64_t v182 = *v144;
        int16x8_t v147 = v182 + 1;
        uint64_t v185 = (char *)v143[3];
        unint64_t v184 = (char *)v143[4];
        if (v184 != v185)
        {
          do
          {
            *--unint64_t v182 = *((_OWORD *)v184 - 1);
            v184 -= 16;
          }
          while (v184 != v185);
          unint64_t v184 = (char *)v143[3];
        }
        v143[3] = v182;
        v143[4] = v147;
        v143[5] = v183;
        if (v184) {
          operator delete(v184);
        }
        goto LABEL_174;
      }
      goto LABEL_184;
    case 1:
      long long v8 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      double v9 = (unsigned char *)*v8;
      BOOL v10 = (unsigned char *)v8[1];
      uint64_t v11 = (uint64_t)&v10[-*v8];
      if ((unint64_t)v11 < 0x11) {
        goto LABEL_22;
      }
      if (v9 == v10) {
        goto LABEL_183;
      }
      if (*(v10 - 8)) {
        goto LABEL_22;
      }
      uint64_t v12 = v8[3];
      uint64_t v13 = v8[4];
      if ((unint64_t)(v13 - v12) <= 0x10 || v12 == v13) {
        goto LABEL_183;
      }
      CGPoint v192 = *(CGPoint *)(v13 - 32);
      CGPoint v193 = *(CGPoint *)(v13 - 16);
      int v14 = (CGPoint *)(v13 - 16);
      uint64_t v15 = *(CGPoint **)(a2 + 8);
      CGPoint v194 = *v15;
      long long v16 = *(_OWORD *)(a1 + 88);
      *(_OWORD *)&v189.double a = *(_OWORD *)(a1 + 72);
      *(_OWORD *)&v189.double c = v16;
      *(_OWORD *)&v189.double tx = *(_OWORD *)(a1 + 104);
      if (points_are_nearly_collinear(v192, v193, v194, &v189))
      {
        *int v14 = *v15;
        return;
      }
LABEL_22:
      unint64_t v28 = v8[2];
      uint64_t v29 = ((uint64_t)(v8[4] - v8[3]) >> 4) - 1;
      if ((unint64_t)v10 < v28)
      {
        *(void *)BOOL v10 = v29;
        v10[8] = 0;
        uint64_t v30 = v10 + 16;
        goto LABEL_90;
      }
      unint64_t v94 = (v11 >> 4) + 1;
      if (!(v94 >> 60))
      {
        uint64_t v95 = v28 - (void)v9;
        if (v95 >> 3 > v94) {
          unint64_t v94 = v95 >> 3;
        }
        if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v96 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v96 = v94;
        }
        int v97 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v96);
        int v98 = &v97[16 * (v11 >> 4)];
        int v100 = &v97[16 * v99];
        *(void *)int v98 = v29;
        v98[8] = 0;
        uint64_t v30 = v98 + 16;
        double v102 = (unsigned char *)*v8;
        int v101 = (unsigned char *)v8[1];
        if (v101 != (unsigned char *)*v8)
        {
          do
          {
            uint64_t v103 = *((void *)v101 - 2);
            v101 -= 16;
            char v104 = v101[8];
            *((void *)v98 - 2) = v103;
            v98 -= 16;
            v98[8] = v104;
          }
          while (v101 != v102);
          int v101 = (unsigned char *)*v8;
        }
        *long long v8 = v98;
        v8[1] = v30;
        v8[2] = v100;
        if (v101) {
          operator delete(v101);
        }
LABEL_90:
        v8[1] = v30;
        int v105 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        __int16 v106 = *(_OWORD **)(a2 + 8);
        unsigned int v108 = (_OWORD *)v105[4];
        unint64_t v107 = v105[5];
        if ((unint64_t)v108 >= v107)
        {
          uint64_t v109 = v105[3];
          uint64_t v110 = ((uint64_t)v108 - v109) >> 4;
          unint64_t v111 = v110 + 1;
          if (!((unint64_t)(v110 + 1) >> 60))
          {
            uint64_t v112 = v107 - v109;
            if (v112 >> 3 > v111) {
              unint64_t v111 = v112 >> 3;
            }
            if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v113 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v113 = v111;
            }
            if (v113) {
              unint64_t v113 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v113);
            }
            else {
              uint64_t v114 = 0;
            }
            unsigned int v178 = (_OWORD *)(v113 + 16 * v110);
            unint64_t v179 = v113 + 16 * v114;
            *unsigned int v178 = *v106;
            uint64_t v171 = v178 + 1;
            int v186 = (char *)v105[3];
            int v180 = (char *)v105[4];
            if (v180 == v186) {
              goto LABEL_179;
            }
            do
            {
              *--unsigned int v178 = *((_OWORD *)v180 - 1);
              v180 -= 16;
            }
            while (v180 != v186);
LABEL_178:
            int v180 = (char *)v105[3];
LABEL_179:
            v105[3] = v178;
            v105[4] = v171;
            v105[5] = v179;
            if (v180) {
              operator delete(v180);
            }
            goto LABEL_181;
          }
          goto LABEL_184;
        }
        goto LABEL_155;
      }
      goto LABEL_185;
    case 2:
      int v17 = *(char ***)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      uint64_t v18 = ((v17[4] - v17[3]) >> 4) - 1;
      unint64_t v20 = (unint64_t)v17[1];
      unint64_t v19 = (unint64_t)v17[2];
      if (v20 < v19)
      {
        *(void *)unint64_t v20 = v18;
        *(unsigned char *)(v20 + 8) = 1;
        double v21 = (char *)(v20 + 16);
        goto LABEL_35;
      }
      uint64_t v31 = (uint64_t)(v20 - (void)*v17) >> 4;
      unint64_t v32 = v31 + 1;
      if (!((unint64_t)(v31 + 1) >> 60))
      {
        uint64_t v33 = v19 - (void)*v17;
        if (v33 >> 3 > v32) {
          unint64_t v32 = v33 >> 3;
        }
        if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v34 = v32;
        }
        BOOL v35 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v34);
        int32x4_t v36 = &v35[16 * v31];
        unint64_t v38 = &v35[16 * v37];
        *(void *)int32x4_t v36 = v18;
        v36[8] = 1;
        double v21 = v36 + 16;
        int v40 = *v17;
        uint64_t v39 = v17[1];
        if (v39 != *v17)
        {
          do
          {
            uint64_t v41 = *((void *)v39 - 2);
            v39 -= 16;
            char v42 = v39[8];
            *((void *)v36 - 2) = v41;
            v36 -= 16;
            v36[8] = v42;
          }
          while (v39 != v40);
          uint64_t v39 = *v17;
        }
        *int v17 = v36;
        v17[1] = v21;
        v17[2] = v38;
        if (v39) {
          operator delete(v39);
        }
LABEL_35:
        v17[1] = v21;
        double v43 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        int v44 = (float64x2_t *)v43[3];
        int v45 = (float64x2_t *)v43[4];
        if (v44 == v45)
        {
LABEL_183:
          __break(1u);
          goto LABEL_184;
        }
        float64x2_t v46 = vmlaq_f64(v45[-1], (float64x2_t)vdupq_n_s64(0x3FE5555555555555uLL), vsubq_f64(*(float64x2_t *)*(void *)(a2 + 8), v45[-1]));
        unint64_t v47 = v43[5];
        if ((unint64_t)v45 >= v47)
        {
          uint64_t v87 = v45 - v44;
          unint64_t v88 = v87 + 1;
          if ((unint64_t)(v87 + 1) >> 60) {
            goto LABEL_184;
          }
          uint64_t v89 = v47 - (void)v44;
          if (v89 >> 3 > v88) {
            unint64_t v88 = v89 >> 3;
          }
          BOOL v90 = (unint64_t)v89 >= 0x7FFFFFFFFFFFFFF0;
          unint64_t v91 = 0xFFFFFFFFFFFFFFFLL;
          if (!v90) {
            unint64_t v91 = v88;
          }
          if (v91)
          {
            float64x2_t v187 = v46;
            int v92 = std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v91);
            float64x2_t v46 = v187;
            unint64_t v91 = (unint64_t)v92;
            int v44 = (float64x2_t *)v43[3];
            int v45 = (float64x2_t *)v43[4];
          }
          else
          {
            uint64_t v93 = 0;
          }
          char v154 = (float64x2_t *)(v91 + 16 * v87);
          unint64_t v155 = v91 + 16 * v93;
          *char v154 = v46;
          f64 = (_OWORD *)v154[1].f64;
          if (v45 != v44)
          {
            do
            {
              v154[-1] = v45[-1];
              --v154;
              --v45;
            }
            while (v45 != v44);
            int v44 = (float64x2_t *)v43[3];
          }
          v43[3] = v154;
          v43[4] = f64;
          v43[5] = v155;
          if (v44) {
            operator delete(v44);
          }
        }
        else
        {
          *int v45 = v46;
          f64 = (_OWORD *)v45[1].f64;
        }
        v43[4] = f64;
        int v156 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        float64x2_t v157 = vmlaq_f64(*(float64x2_t *)(*(void *)(a2 + 8) + 16), (float64x2_t)vdupq_n_s64(0x3FE5555555555555uLL), vsubq_f64(*(float64x2_t *)*(void *)(a2 + 8), *(float64x2_t *)(*(void *)(a2 + 8) + 16)));
        int v159 = (char *)v156[4];
        unint64_t v158 = v156[5];
        if ((unint64_t)v159 >= v158)
        {
          int v161 = (char *)v156[3];
          uint64_t v162 = (v159 - v161) >> 4;
          unint64_t v163 = v162 + 1;
          if ((unint64_t)(v162 + 1) >> 60) {
            goto LABEL_184;
          }
          uint64_t v164 = v158 - (void)v161;
          if (v164 >> 3 > v163) {
            unint64_t v163 = v164 >> 3;
          }
          BOOL v90 = (unint64_t)v164 >= 0x7FFFFFFFFFFFFFF0;
          unint64_t v165 = 0xFFFFFFFFFFFFFFFLL;
          if (!v90) {
            unint64_t v165 = v163;
          }
          if (v165)
          {
            float64x2_t v188 = v157;
            int v166 = std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v165);
            float64x2_t v157 = v188;
            unint64_t v165 = (unint64_t)v166;
            int v161 = (char *)v156[3];
            int v159 = (char *)v156[4];
          }
          else
          {
            uint64_t v167 = 0;
          }
          int v168 = (float64x2_t *)(v165 + 16 * v162);
          unint64_t v169 = v165 + 16 * v167;
          *int v168 = v157;
          uint64_t v160 = (_OWORD *)v168[1].f64;
          if (v159 != v161)
          {
            do
            {
              v168[-1] = *((float64x2_t *)v159 - 1);
              --v168;
              v159 -= 16;
            }
            while (v159 != v161);
            int v161 = (char *)v156[3];
          }
          v156[3] = v168;
          v156[4] = v160;
          v156[5] = v169;
          if (v161) {
            operator delete(v161);
          }
        }
        else
        {
          *(float64x2_t *)int v159 = v157;
          uint64_t v160 = v159 + 16;
        }
        v156[4] = v160;
        int v105 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        __int16 v106 = (_OWORD *)(*(void *)(a2 + 8) + 16);
        unsigned int v108 = (_OWORD *)v105[4];
        unint64_t v170 = v105[5];
        if ((unint64_t)v108 >= v170)
        {
          uint64_t v172 = v105[3];
          uint64_t v173 = ((uint64_t)v108 - v172) >> 4;
          unint64_t v174 = v173 + 1;
          if (!((unint64_t)(v173 + 1) >> 60))
          {
            uint64_t v175 = v170 - v172;
            if (v175 >> 3 > v174) {
              unint64_t v174 = v175 >> 3;
            }
            if ((unint64_t)v175 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v176 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v176 = v174;
            }
            if (v176) {
              unint64_t v176 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v176);
            }
            else {
              uint64_t v177 = 0;
            }
            unsigned int v178 = (_OWORD *)(v176 + 16 * v173);
            unint64_t v179 = v176 + 16 * v177;
            *unsigned int v178 = *v106;
            uint64_t v171 = v178 + 1;
            uint64_t v181 = (char *)v105[3];
            int v180 = (char *)v105[4];
            if (v180 == v181) {
              goto LABEL_179;
            }
            do
            {
              *--unsigned int v178 = *((_OWORD *)v180 - 1);
              v180 -= 16;
            }
            while (v180 != v181);
            goto LABEL_178;
          }
LABEL_184:
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        }
LABEL_155:
        *unsigned int v108 = *v106;
        uint64_t v171 = v108 + 1;
LABEL_181:
        v105[4] = v171;
        return;
      }
      goto LABEL_185;
    case 3:
      double v22 = *(char ***)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      uint64_t v23 = ((v22[4] - v22[3]) >> 4) - 1;
      unint64_t v25 = (unint64_t)v22[1];
      unint64_t v24 = (unint64_t)v22[2];
      if (v25 >= v24)
      {
        uint64_t v49 = (uint64_t)(v25 - (void)*v22) >> 4;
        unint64_t v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 60) {
LABEL_185:
        }
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
        uint64_t v51 = v24 - (void)*v22;
        if (v51 >> 3 > v50) {
          unint64_t v50 = v51 >> 3;
        }
        if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v52 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v52 = v50;
        }
        int v53 = (char *)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v52);
        int v54 = &v53[16 * v49];
        double v56 = &v53[16 * v55];
        *(void *)int v54 = v23;
        v54[8] = 1;
        double v26 = v54 + 16;
        int v58 = *v22;
        int v57 = v22[1];
        if (v57 != *v22)
        {
          do
          {
            uint64_t v59 = *((void *)v57 - 2);
            v57 -= 16;
            char v60 = v57[8];
            *((void *)v54 - 2) = v59;
            v54 -= 16;
            v54[8] = v60;
          }
          while (v57 != v58);
          int v57 = *v22;
        }
        *double v22 = v54;
        v22[1] = v26;
        v22[2] = v56;
        if (v57) {
          operator delete(v57);
        }
      }
      else
      {
        *(void *)unint64_t v25 = v23;
        *(unsigned char *)(v25 + 8) = 1;
        double v26 = (char *)(v25 + 16);
      }
      v22[1] = v26;
      uint64_t v61 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      unsigned int v62 = *(char **)(v61 + 32);
      int v63 = *(char **)(a2 + 8);
      BOOL v64 = (void *)(v61 + 40);
      uint64_t v65 = *(void *)(v61 + 40);
      if (v65 - (uint64_t)v62 >= 48)
      {
        memmove(*(void **)(v61 + 32), v63, 0x30uLL);
        *(void *)(v61 + 32) = v62 + 48;
        return;
      }
      uint64_t v68 = *(void *)(v61 + 24);
      double v67 = (void **)(v61 + 24);
      uint64_t v66 = v68;
      uint64_t v69 = (uint64_t)&v62[-v68] >> 4;
      if ((unint64_t)(v69 + 3) >> 60) {
        goto LABEL_184;
      }
      uint64_t v70 = v65 - v66;
      uint64_t v71 = v70 >> 3;
      if (v70 >> 3 <= (unint64_t)(v69 + 3)) {
        uint64_t v71 = v69 + 3;
      }
      if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v72 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v72 = v71;
      }
      __p[4] = v64;
      if (v72) {
        unint64_t v72 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v72);
      }
      else {
        uint64_t v73 = 0;
      }
      uint64_t v115 = 0;
      unint64_t v116 = v72 + 16 * v69;
      __p[0] = (void *)v72;
      __p[1] = (void *)v116;
      __p[3] = (void *)(v72 + 16 * v73);
      do
      {
        *(_OWORD *)(v116 + v115) = *(_OWORD *)&v63[v115];
        v115 += 16;
      }
      while (v115 != 48);
      __p[2] = (void *)(v116 + 48);
      std::vector<CGPoint>::__swap_out_circular_buffer(v67, (uint64_t)__p, v62);
      if (__p[0]) {
        operator delete(__p[0]);
      }
      return;
    case 4:
      *(unsigned char *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 48) = 0;
      uint64_t v27 = *(CGPathRandomAccessSubpath **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      CGPathRandomAccessSubpath::close_if_needed(v27);
      return;
    default:
      return;
  }
}

void ___ZN18CGPathRandomAccess8add_pathEPK6CGPath17CGAffineTransformb_block_invoke(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if ((*a2 - 2) < 2)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v9 = *(void *)(v7 + 40);
    uint64_t v8 = *(void *)(v7 + 48);
    if (v9 != v8)
    {
      ++*(void *)(v8 - 16);
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v12 = *(void *)(v10 + 40);
      uint64_t v11 = *(void *)(v10 + 48);
      if (v12 != v11)
      {
        uint64_t v13 = *(void *)(v11 - 8) + 3;
LABEL_12:
        *(void *)(v11 - 8) = v13;
        return;
      }
    }
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  if (v2 == 1)
  {
    uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v16 = *(void *)(v14 + 40);
    uint64_t v15 = *(void *)(v14 + 48);
    if (v16 != v15)
    {
      ++*(void *)(v15 - 16);
      uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v18 = *(void *)(v17 + 40);
      uint64_t v11 = *(void *)(v17 + 48);
      if (v18 != v11)
      {
        uint64_t v13 = *(void *)(v11 - 8) + 1;
        goto LABEL_12;
      }
    }
    goto LABEL_28;
  }
  if (v2) {
    return;
  }
  uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = (int64x2_t *)v3[6];
  unint64_t v4 = v3[7];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v19 = (int64x2_t *)v3[5];
    uint64_t v20 = v5 - v19;
    unint64_t v21 = v20 + 1;
    if (!((unint64_t)(v20 + 1) >> 60))
    {
      uint64_t v22 = v4 - (void)v19;
      if (v22 >> 3 > v21) {
        unint64_t v21 = v22 >> 3;
      }
      BOOL v23 = (unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
      if (!v23) {
        unint64_t v24 = v21;
      }
      if (v24)
      {
        unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(v24);
        unint64_t v19 = (int64x2_t *)v3[5];
        uint64_t v5 = (int64x2_t *)v3[6];
      }
      else
      {
        uint64_t v25 = 0;
      }
      double v26 = (int64x2_t *)(v24 + 16 * v20);
      unint64_t v27 = v24 + 16 * v25;
      *double v26 = vdupq_n_s64(1uLL);
      unint64_t v6 = v26 + 1;
      if (v5 != v19)
      {
        do
        {
          v26[-1] = v5[-1];
          --v26;
          --v5;
        }
        while (v5 != v19);
        unint64_t v19 = (int64x2_t *)v3[5];
      }
      v3[5] = v26;
      v3[6] = v6;
      v3[7] = v27;
      if (v19) {
        operator delete(v19);
      }
      goto LABEL_26;
    }
LABEL_29:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
  }
  *uint64_t v5 = vdupq_n_s64(1uLL);
  unint64_t v6 = v5 + 1;
LABEL_26:
  v3[6] = v6;
}

BOOL points_are_nearly_collinear(CGPoint a1, CGPoint a2, CGPoint a3, CGAffineTransform *a4)
{
  double b = a4->b;
  double c = a4->c;
  double d = a4->d;
  double tx = a4->tx;
  double ty = a4->ty;
  double v9 = tx + a1.y * c + a4->a * a1.x;
  double v10 = ty + a1.y * d + b * a1.x;
  double v11 = tx + a2.y * c + a4->a * a2.x;
  return ((uint64_t)v10 - (uint64_t)(ty + a2.y * d + b * a2.x)) * ((uint64_t)v11 - (uint64_t)(tx + a3.y * c + a4->a * a3.x)) == ((uint64_t)(ty + a2.y * d + b * a2.x) - (uint64_t)(ty + a3.y * d + b * a3.x)) * ((uint64_t)v9 - (uint64_t)v11);
}

uint64_t CGPatternGetShading(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 20) == 1) {
      return *(void *)(result + 80);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t GRAYA8_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v5 = v4;
  uint64_t v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int **)v2;
  BOOL v8 = !*((void *)v3 + 12) && !*(void *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  signed int v9 = *(_DWORD *)(*(void *)(*(void *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((void *)v3 + 6) == 0));
  if (v9 > 27) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1) {
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13) {
      goto LABEL_22;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(v5 + 16))
  {
    uint64_t v12 = GRAYA8_shade_radial_Gray;
  }
  else if (*(void *)(v5 + 24))
  {
    uint64_t v12 = GRAYA8_shade_conic_Gray;
  }
  else if (v16 < 2)
  {
    uint64_t v12 = GRAYA8_shade_axial_Gray;
  }
  else
  {
    uint64_t v12 = GRAYA8_shade_custom_Gray;
  }
  uint64_t v13 = v12;
LABEL_22:
  int v14 = *v7;
  int v15 = v14;
  GRAYa8_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17)) {
    free(v17);
  }
  return 1;
}

uint64_t GRAYA8_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (int *)*a1;
  memset(v26, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  signed int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v21, (uint64_t)v26) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  unsigned int v19 = *(_DWORD *)a3;
  unsigned int v22 = v19;
  int v23 = v18;
  if (v19 != 67637672)
  {
    unsigned int v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      unint64_t v21 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int))GRAYa8_image_sample[v20 + 1];
      if (v21) {
        goto LABEL_18;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!v25 && (~v24 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
    {
      if ((v24 & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      GRAYA8_mark_inner(*(void *)(*a1 + 56), v17);
      return 1;
    }
  }
  unint64_t v21 = GRAYA8_sample_W8_inner;
LABEL_18:
  GRAYa8_image_mark((uint64_t)a2, (uint64_t)&v21, v8, v17);
  return 1;
}

uint64_t ARGB32_image(int **a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  memset(v47, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v30, (uint64_t)v47) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v18 = *v6;
  BOOL v19 = *v6 != 134755144 || v8 <= 23;
  unsigned int v20 = *(_DWORD *)a3;
  if (v19) {
    uint64_t v21 = v8;
  }
  else {
    uint64_t v21 = (v8 + 4);
  }
  DWORD2(v30) = *(_DWORD *)a3;
  HIDWORD(v30) = v18;
  if (v20 != 134755144)
  {
    unsigned int v22 = SAMPLEINDEX(v20, v10, v11, v12, v13, v14, v15, v16);
    if (!v22) {
      return 0xFFFFFFFFLL;
    }
    if (v22 > 0xB)
    {
      if (v22 > 0x13)
      {
LABEL_35:
        int v27 = 0;
LABEL_37:
        *(void *)&long long v30 = *(void *)&RGB8_image_sample[2 * v22 + 2];
        if ((void)v30)
        {
          int v28 = 134755224;
          goto LABEL_45;
        }
        if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
        {
          *(void *)&long long v30 = *(void *)&RGB16_image_sample[2 * v22 + 2];
          if ((void)v30)
          {
            int v28 = 269497256;
            int v29 = 8;
LABEL_44:
            LODWORD(v31) = v29;
LABEL_45:
            DWORD2(v30) = v28;
            if ((void)v41) {
              int v27 = 0;
            }
            if (v27 == 1 && (BYTE4(v31) & 0x77) == 0x73 && (v21 - 1) <= 1 && (a2[2] == 5 || !a2[2]))
            {
              if (v22 > 0xB)
              {
                if (v22 <= 0x13)
                {
                  if (v22 == 12 && v21 == 1)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      rgba32_mark_image_W16((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                      return 1;
                    }
                  }
                  else if (v22 == 13 && v21 == 1)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      rgba32_mark_image_w16((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                      return 1;
                    }
                  }
                  else if (v22 == 14 && v21 == 1)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      ARGB32_mark_image_RGB48((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                      return 1;
                    }
                  }
                  else if (v22 == 15 && v21 == 1)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      ARGB32_mark_image_rgb48((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                      return 1;
                    }
                  }
                  else if (v22 == 17)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      ARGB32_mark_image_rgba64((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      return 1;
                    }
                  }
                  else if (v22 == 16)
                  {
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] == 1.0)
                    {
                      ARGB32_mark_image_RGBA64((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      return 1;
                    }
                  }
                }
              }
              else if (v22 == 2 && v21 == 1)
              {
                v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                if (v17.n128_f32[0] == 1.0)
                {
                  rgba32_mark_image_W8((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                  return 1;
                }
              }
              else
              {
                if (v22 != 5 || v21 != 1)
                {
                  switch(v22)
                  {
                    case 6u:
                      v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                      if (v17.n128_f32[0] != 1.0) {
                        goto LABEL_60;
                      }
                      rgba32_mark_image_xrgb32((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      break;
                    case 7u:
                      v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                      if (v17.n128_f32[0] != 1.0) {
                        goto LABEL_60;
                      }
                      rgba32_mark_image_XRGB32((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      break;
                    case 8u:
                      v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                      if (v17.n128_f32[0] != 1.0) {
                        goto LABEL_60;
                      }
                      rgba32_mark_image_rgbx32((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      break;
                    case 9u:
                      v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                      if (v17.n128_f32[0] != 1.0) {
                        goto LABEL_60;
                      }
                      rgba32_mark_image_RGBX32((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v24, v25, v26);
                      break;
                    default:
                      goto LABEL_60;
                  }
                  return 1;
                }
                v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                if (v17.n128_f32[0] == 1.0)
                {
                  ARGB32_mark_image_RGB24((uint64_t)a2, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v23, v24, v25, v26);
                  return 1;
                }
              }
            }
LABEL_60:
            rgba32_image_mark((uint64_t)a2, (uint64_t)&v30, v21, v17);
            return 1;
          }
        }
        *(void *)&long long v30 = *(void *)&RGBF_image_sample[2 * v22 + 2];
        if ((void)v30)
        {
          int v28 = 538981289;
          int v29 = 16;
          goto LABEL_44;
        }
        return 0xFFFFFFFFLL;
      }
      if (v22 - 14 < 4)
      {
LABEL_36:
        int v27 = 1;
        goto LABEL_37;
      }
      if (v22 != 13 && v22 != 12) {
        goto LABEL_35;
      }
    }
    else
    {
      if (v22 - 5 < 5) {
        goto LABEL_36;
      }
      if (v22 != 2) {
        goto LABEL_35;
      }
    }
    if (*((void *)a2 + 12)) {
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  if ((void)v41 || (~DWORD1(v31) & 0xC3) != 0) {
    goto LABEL_59;
  }
  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
  if ((BYTE4(v31) & 4) != 0 || (v21 - 1) > 1 || v17.n128_f32[0] != 1.0)
  {
    if (v17.n128_f32[0] >= 1.0) {
      goto LABEL_58;
    }
LABEL_59:
    *(void *)&long long v30 = rgba32_sample_rgba32;
    goto LABEL_60;
  }
  if (a2[2] != 5 && a2[2])
  {
LABEL_58:
    if (!*(void *)(a3 + 24))
    {
      if ((BYTE4(v31) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      rgba32_mark((uint64_t)a1, v17);
      return 1;
    }
    goto LABEL_59;
  }
  rgba32_mark_image((uint64_t)a2, v21, (uint64_t)v36 >> SBYTE6(v31), *((uint64_t *)&v36 + 1) >> SBYTE7(v31), *((uint64_t *)&v38 + 1) >> SBYTE7(v31), v14, v15, v16);
  return 1;
}

uint64_t SAMPLEINDEX(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1 >> 22;
  int v9 = HIWORD(a1) & 0x3F;
  int v10 = (a1 >> 4) & 3;
  unsigned int v11 = (a1 >> 2) & 3;
  switch((a1 >> 8) & 0xF)
  {
    case 0u:
      if (v8 == 8 && (a1 & 0xF000) == 0x1000 && v9 == 8) {
        return 1;
      }
      if (v8 != 16 || (a1 & 1) == 0) {
        return 0;
      }
      int v16 = 191;
      goto LABEL_35;
    case 1u:
      if (v8 == 8 && v9 == 8)
      {
        if (v11 < 2) {
          return 2;
        }
        return 0;
      }
      if (v8 != 16)
      {
        if (v8 != 32 || v9 != 32 || v11 > 1) {
          return 0;
        }
        BOOL v14 = v10 == 2;
        unsigned __int8 v15 = 20;
        goto LABEL_113;
      }
      if ((a1 & 1) == 0)
      {
        if (v9 == 8)
        {
          if (v11 != 2) {
            _CGHandleAssert("SAMPLEINDEX", 126, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/SAMPLEINDEX.c", "alpha == MESHED_ALPHA", "meshed alpha expected here (%u)", a6, a7, a8, v11);
          }
          return 32;
        }
        if (v9 != 16 || v11 > 1) {
          return 0;
        }
        BOOL v14 = v10 == 2;
        unsigned __int8 v15 = 12;
LABEL_113:
        if (v14) {
          return (v15 + 1);
        }
        else {
          return v15;
        }
      }
      if (v9 != 16) {
        return 0;
      }
      if (v11)
      {
        if (v11 != 1) {
          return 0;
        }
        if (v10 != 2)
        {
          int v16 = 111;
          goto LABEL_35;
        }
        return 28;
      }
      if (v10 == 2) {
        return 28;
      }
      int v16 = 118;
      goto LABEL_35;
    case 3u:
      int v13 = a1 >> 6;
      if ((HIWORD(a1) & 0x3F) > 9u)
      {
        if (v9 == 10) {
          return 33;
        }
        if (v9 == 16)
        {
          if ((a1 & 1) == 0)
          {
            if (v10 == 1) {
              return 0;
            }
            if (v8 != 48 || v11)
            {
              if (v13 != 2 || v8 != 64 || v11 != 2) {
                return 0;
              }
              BOOL v14 = v10 == 2;
              unsigned __int8 v15 = 16;
            }
            else
            {
              BOOL v14 = v10 == 2;
              unsigned __int8 v15 = 14;
            }
            goto LABEL_113;
          }
          if (v10)
          {
            if (v8 == 48 && !v11) {
              return 29;
            }
            int v16 = 79;
            if (v13 == 2 && v8 == 64 && v11 == 2) {
              return 30;
            }
          }
          else
          {
            int v16 = 72;
          }
LABEL_35:
          _CGHandleAssert("SAMPLEINDEX", v16, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/SAMPLEINDEX.c", "", "Unimplemented", a6, a7, a8, v21);
        }
LABEL_63:
        if (v9 != 32 || v10 == 1) {
          return 0;
        }
        if (v8 != 96 || v11)
        {
          if (v13 != 2 || v8 != 128 || v11 != 2) {
            return 0;
          }
          BOOL v14 = v10 == 2;
          unsigned __int8 v15 = 24;
        }
        else
        {
          BOOL v14 = v10 == 2;
          unsigned __int8 v15 = 22;
        }
        goto LABEL_113;
      }
      if (v9 != 5)
      {
        if (v9 == 8)
        {
          if (v10 != 2)
          {
            if (v10 == 1)
            {
              if (v8 != 32 || v11 != 2) {
                return 0;
              }
              if (v13 == 2) {
                unsigned __int8 v17 = 7;
              }
              else {
                unsigned __int8 v17 = 0;
              }
              BOOL v18 = v13 == 1;
              unsigned __int8 v19 = 9;
              goto LABEL_96;
            }
            if (v10) {
              return 0;
            }
          }
          if (v8 == 24) {
            return 5;
          }
          if (v8 == 32 && v11 == 2)
          {
            if (v13 == 2) {
              unsigned __int8 v17 = 6;
            }
            else {
              unsigned __int8 v17 = 0;
            }
            BOOL v18 = v13 == 1;
            unsigned __int8 v19 = 8;
LABEL_96:
            if (v18) {
              return v19;
            }
            else {
              return v17;
            }
          }
          return 0;
        }
        goto LABEL_63;
      }
      unsigned __int8 v12 = 0;
      if (v8 == 16 && v13 == 1)
      {
        if (v10 == 1)
        {
          if (v11 < 2) {
            return 4;
          }
        }
        else if (!v10 && v11 < 2)
        {
          return 3;
        }
        return 0;
      }
      return v12;
    case 4u:
      if (v8 == 32 && v9 == 8)
      {
        if (v10 != 2)
        {
          if (v10 == 1)
          {
            if (v11 < 2) {
              return 11;
            }
            return 0;
          }
          if (v10) {
            return 0;
          }
        }
        if (v11 < 2) {
          return 10;
        }
        return 0;
      }
      if (v8 != 64 || v9 != 16)
      {
        if (v10 == 1 || v8 != 128 || v9 != 32 || v11 > 1) {
          return 0;
        }
        BOOL v14 = v10 == 2;
        unsigned __int8 v15 = 26;
        goto LABEL_113;
      }
      if ((a1 & 1) == 0)
      {
        if (v10 == 1 || v11 > 1) {
          return 0;
        }
        BOOL v14 = v10 == 2;
        unsigned __int8 v15 = 18;
        goto LABEL_113;
      }
      if (v10 == 2) {
        return 31;
      }
      int v16 = 166;
      goto LABEL_35;
    default:
      return 0;
  }
}

void rgba32_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  if (a2 != 2 && !*(void *)(a1 + 96))
  {
    if (*(void *)(a1 + 48)) {
      int v11 = 0;
    }
    else {
      int v11 = a2;
    }
  }
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v25 = v15;
  int v26 = v14;
  int v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    unsigned __int8 v19 = v18;
    if (v18) {
      goto LABEL_14;
    }
  }
  int v20 = 0;
  int v21 = 0;
  unsigned __int8 v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    uint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    if (v11 == 1)
    {
      CGBlt_copyBytes(4 * v26, v25, v23, v24, v22 * a5, v13);
      if (!v19) {
        return;
      }
    }
    else if (v11)
    {
      CGSBlend8888toARGB8888(v23, v22 * a5, v24, v13, v26, v25, 0x1Bu, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertXRGB8888toARGB8888(v23, v22 * a5, v24, v13, v26, v25, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_14:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v26, &v25)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void CGBlt_copyBytes(int a1, int a2, char *a3, char *a4, int a5, int a6)
{
  if (a1 >= 1)
  {
    int v6 = a2;
    if (a2 >= 1)
    {
      int v7 = a6;
      int v8 = a5;
      int v9 = a4;
      int v10 = a3;
      if (a4 != a3 || a6 != a5)
      {
        qword_1EB288DD0 = (uint64_t)"CGBlt_copyBytes: buffer check:\n";
        ERROR_CGBlt_copyBytes_BufferIsNotReadable();
        ERROR_CGBlt_copyBytes_BufferIsNotReadable();
        uint64_t v12 = v6 - 1;
        ERROR_CGBlt_copyBytes_BufferIsNotBigEnough();
        ERROR_CGBlt_copyBytes_BufferIsNotBigEnough();
        qword_1EB288DD0 = 0;
        int v13 = v7 - v8;
        int v14 = &v10[v12 * v8];
        int v15 = &v9[(int)v12 * (uint64_t)v7];
        size_t v16 = a1;
        if (v9 < v10 || &v14[a1 - 1] < v9)
        {
          int v20 = 0;
          if (v9 < v10 && v13 >= 1 && &v15[v16 - 1] >= v10)
          {
            int v21 = ((int)v10 - (int)v9) / v13;
            BOOL v22 = __OFSUB__(v6, v21);
            int v23 = v6 - v21;
            if ((v23 < 0) ^ v22 | (v23 == 0)) {
              int v20 = 0;
            }
            else {
              int v20 = v23;
            }
          }
        }
        else if (v7 >= v8)
        {
          int v20 = 0;
          int v8 = -v8;
          int v7 = -v7;
          int v9 = v15;
          int v10 = v14;
        }
        else if (v9 == v10)
        {
          int v20 = 0;
          int v10 = v9;
        }
        else
        {
          int v17 = ((int)v10 - (int)v9) / v13;
          if (v17 >= v6)
          {
            int v20 = 0;
            unsigned __int8 v19 = v15;
            BOOL v18 = v14;
          }
          else
          {
            int v14 = &v10[v8 * (uint64_t)v17];
            int v15 = &v9[v7 * (uint64_t)v17];
            BOOL v18 = &v14[v8];
            unsigned __int8 v19 = &v15[v7];
            int v20 = ~v17 + v6;
          }
          int v8 = -v8;
          int v7 = -v7;
          int v9 = v15;
          int v10 = v14;
          int v15 = v19;
          int v14 = v18;
        }
        while (1)
        {
          if (v6 <= v20)
          {
            if (!v20) {
              return;
            }
            int v20 = 0;
            int v8 = -v8;
            int v7 = -v7;
            int v9 = v15;
            int v10 = v14;
          }
          memmove(v9, v10, v16);
          v10 += v8;
          --v6;
          v9 += v7;
        }
      }
    }
  }
}

void ARGB32_mark_image_RGB24(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  int v39 = a2;
  int v10 = *(_DWORD *)(a1 + 28);
  int v11 = *(_DWORD *)(a1 + 4);
  int v12 = *(_DWORD *)(a1 + 8);
  int v41 = v12;
  int v42 = v11;
  int v13 = *(int **)(a1 + 136);
  if (v13)
  {
    int v14 = *(_DWORD *)(a1 + 104);
    LODWORD(v43) = *(_DWORD *)(a1 + 108);
    HIDWORD(v43) = v14;
    shape_enum_clip_alloc(a1, a2, v13, 1, 1, 1, v14, v43, v11, v12);
    size_t v16 = v15;
    if (v15) {
      goto LABEL_28;
    }
  }
  int v17 = 0;
  int v18 = 0;
  size_t v16 = 0;
  uint64_t v43 = 0;
  if (v11 < 0) {
LABEL_4:
  }
    _CGHandleAssert("CGSConvertRGB888toARGB8888", 241, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "width >= 0", "width (%d) is negative", a6, a7, a8, v11);
  while (1)
  {
    if (v12 < 0) {
      _CGHandleAssert("CGSConvertRGB888toARGB8888", 241, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-argb8.c", "height >= 0", "height (%d) is negative", a6, a7, a8, v12);
    }
    int v19 = *(_DWORD *)(a1 + 76);
    uint64_t v20 = *(void *)(a1 + 88) + v19 * (uint64_t)(a3 + v18 * v8) + 3 * (v17 + v39);
    uint64_t v21 = *(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v18) * v10 + 4 * (*(_DWORD *)(a1 + 12) + v17);
    uint64_t v22 = v19 * (uint64_t)v8;
    uint64_t v23 = v12 - 1;
    uint64_t v24 = v20 + (int)v23 * v22;
    uint64_t v25 = v21 + v23 * v10;
    int v26 = (char *)(v10 < 0 ? v25 : v21);
    size_t v27 = v10 >= 0 ? v10 : -v10;
    size_t v28 = v10 >= 0 ? v22 : -(int)v22;
    int v29 = (char *)(v10 < 0 ? v24 : v20);
    if ((v28 & 0x80000000) != 0)
    {
      long long v30 = (char *)malloc_type_malloc((int)v27 * v12, 0x37322E0uLL);
      long long v31 = v30;
      if (v12 >= 1)
      {
        for (uint64_t i = 0; i != v12; ++i)
        {
          if (v11 >= 1)
          {
            long long v33 = &v30[i * v27];
            int v34 = v11;
            long long v35 = &v29[i * (int)v28];
            do
            {
              __int16 v36 = *(_WORD *)v35;
              char v37 = v35[2];
              *long long v33 = -1;
              *(_WORD *)(v33 + 1) = v36;
              v33[3] = v37;
              v35 += 3;
              v33 += 4;
              --v34;
            }
            while (v34);
          }
        }
      }
      CGBlt_copyBytes(4 * v11, v12, v30, v26, v27, v27);
      free(v31);
      int v8 = a4;
      if (!v16) {
        return;
      }
    }
    else
    {
      v45.datdouble a = v29;
      v45.double height = v12;
      v45.double width = v11;
      v45.rowBytes = v28;
      v44.datdouble a = v26;
      v44.double height = v12;
      v44.double width = v11;
      v44.rowBytes = v27;
      vImageConvert_RGB888toARGB8888(&v45, 0, 0xFFu, &v44, 0, 0);
      if (!v16) {
        return;
      }
    }
LABEL_28:
    if (!shape_enum_clip_next((uint64_t)v16, (int *)&v43 + 1, &v43, &v42, &v41)) {
      break;
    }
    int v18 = v43;
    int v17 = HIDWORD(v43);
    int v12 = v41;
    int v11 = v42;
    if (v42 < 0) {
      goto LABEL_4;
    }
  }
  free(v16);
}

void GRAYa8_image_mark(uint64_t a1, uint64_t a2, unsigned int a3, __n128 a4)
{
  unsigned int v341 = a3;
  uint64_t v350 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  unint64_t v7 = *(int *)(a1 + 28);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v349 = *(void *)(a1 + 48);
  float v9 = *(float *)(a2 + 184);
  int v10 = *(int **)(a1 + 136);
  uint64_t v346 = v8;
  unsigned __int32 v347 = v10;
  uint64_t v11 = *(void *)(a2 + 96);
  uint64_t v344 = *(void *)(a2 + 104);
  uint64_t v345 = v11;
  uint64_t v13 = *(int *)(a1 + 12);
  uint64_t v12 = *(int *)(a1 + 16);
  int v14 = *(_DWORD *)(a1 + 8);
  unint64_t v340 = (void *)a2;
  uint64_t v15 = *(int *)(a2 + 16);
  uint64_t v16 = (v15 + 4) * v5;
  if (v16 > 65439)
  {
    int v19 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0xC0C1E7D8uLL);
    int v18 = v19;
    uint64_t v22 = v19;
    uint64_t v23 = v340;
    if (!v19) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    int v18 = (char *)&v308 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v17);
    uint64_t v22 = 0;
    uint64_t v23 = v340;
  }
  int v310 = v22;
  int v348 = v14;
  v21.n128_f32[0] = (float)(v9 * 255.0) + 0.5;
  int v24 = (int)v21.n128_f32[0];
  unint64_t v25 = v7 >> 1;
  unint64_t v26 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v27 = v26 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v28 = 2 * v5 + 15;
  unint64_t v29 = v28 & 0xFFFFFFFFFFFFFFF0;
  if (v15) {
    unint64_t v30 = v28 & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    unint64_t v30 = 0;
  }
  unint64_t v31 = v27 + v30;
  v23[18] = v26;
  v23[19] = v27 + v30;
  v23[20] = v27;
  long long v32 = (unsigned __int8 *)(v346 + 2 * (v13 + v25 * v12));
  uint64_t v311 = (int)v4;
  unint64_t v309 = v25;
  unint64_t v343 = v25 - (int)v4;
  uint64_t v33 = *(int *)(a1 + 104);
  int v34 = *(_DWORD *)(a1 + 108);
  int v35 = *(unsigned __int8 *)(a1 + 2);
  if (v35 == 6 || v35 == 1)
  {
    if (!v347) {
      goto LABEL_386;
    }
    __int16 v36 = 0;
    int v37 = 0;
    uint64_t v38 = *(int *)(a1 + 124);
    int v39 = (unsigned __int8 *)v347 + v33 + (int)v38 * (uint64_t)v34;
    uint64_t v40 = v311;
    uint64_t v342 = v38 - v311;
    uint64_t v41 = v341;
    int v42 = v340;
    goto LABEL_25;
  }
  if (!v347)
  {
    uint64_t v342 = 0;
    __int16 v36 = 0;
    int v39 = 0;
    int v37 = 0;
    uint64_t v41 = v341;
    int v42 = v340;
    uint64_t v40 = v311;
LABEL_25:
    uint64_t v45 = v344;
    uint64_t v44 = v345;
    goto LABEL_26;
  }
  v21.n128_f64[0] = shape_enum_clip_alloc((uint64_t)v19, v20, v347, 1, 1, 1, v33, v34, v4, v348);
  uint64_t v45 = v344;
  uint64_t v44 = v345;
  if (!v43) {
    goto LABEL_386;
  }
  __int16 v36 = v43;
  unint64_t v46 = (int)((v15 * v5 + 15) & 0xFFFFFFF0);
  if (!v15) {
    unint64_t v46 = v29;
  }
  unint64_t v47 = v31 + v46;
  int v37 = 0;
  uint64_t v342 = -v311;
  int v39 = (unsigned __int8 *)(v47 + 16);
  int v42 = v340;
  while (1)
  {
    while (1)
    {
      int v48 = *((_DWORD *)v39 - 4);
      int v49 = v48 - v37;
      if (v48 > v37) {
        break;
      }
      if (v37 < *((_DWORD *)v39 - 3) + v48)
      {
        uint64_t v40 = v311;
        uint64_t v41 = v341;
LABEL_26:
        int v50 = v24 ^ 0xFF;
        uint64_t v313 = (v4 - 1) + 1;
        uint64_t v312 = -v40;
        uint64_t v51 = v36;
LABEL_27:
        uint64_t v52 = v41;
        LODWORD(v346) = v37;
        unsigned __int32 v347 = v51;
        ((void (*)(void *, uint64_t, uint64_t, uint64_t, __n128))*v42)(v42, v44, v45, v4, v21);
        double v56 = (unsigned __int8 *)v42[20];
        int v57 = (unsigned char *)v42[18];
        unsigned int v58 = *((_DWORD *)v42 + 2);
        if (v58 == *((_DWORD *)v42 + 3))
        {
          uint64_t v41 = v52;
          if (v24 != 255)
          {
            int v59 = v4;
            char v60 = (unsigned char *)v42[18];
            do
            {
              if (*v60)
              {
                *double v56 = (unsigned __int16)(*v56 * (_WORD)v24 + ((*v56 * v24) >> 8) + 1) >> 8;
                v56[1] = (unsigned __int16)(v56[1] * (_WORD)v24 + ((v56[1] * v24) >> 8) + 1) >> 8;
              }
              ++v60;
              v56 += 2;
              --v59;
            }
            while (v59);
            v56 += 2 * v312;
            v57 += v313 + v312;
          }
        }
        else
        {
          int v61 = HIWORD(v58) & 0x3F;
          if (v61 == 32 || v61 == 16) {
            _CGHandleAssert("GRAYa8_image_pixel", 6877, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "bitdepth != 16 && bitdepth != 32", "Invalid bitdepth (%u)", v53, v54, v55, v61);
          }
          uint64_t v63 = v42[19];
          uint64_t v41 = v52;
          uint64_t v64 = 0;
          uint64_t v65 = v56 + 1;
          if (v24 == 255)
          {
            do
            {
              if (v57[v64]) {
                *(_WORD *)(v65 - 1) = *(_WORD *)(v63 + 2 * v64);
              }
              ++v64;
              v65 += 2;
            }
            while (v4 != v64);
          }
          else
          {
            do
            {
              if (v57[v64])
              {
                unsigned int v66 = *(_WORD *)(v63 + 2 * v64) * v50;
                *(_WORD *)(v65 - 1) = *(_WORD *)(v63 + 2 * v64)
                                    - ((v66 + (v66 >> 8) + 1) & 0xFF00 | ((HIBYTE(*(unsigned __int16 *)(v63 + 2 * v64))
                                                                         * v50
                                                                         + ((HIBYTE(*(unsigned __int16 *)(v63 + 2 * v64))
                                                                                         * v50) >> 8)
                                                                         + 1) >> 8));
              }
              ++v64;
              v65 += 2;
            }
            while (v4 != v64);
          }
        }
        switch((int)v41)
        {
          case 0:
            int v67 = v4;
            uint64_t v68 = v39;
            do
            {
              int v69 = *v57;
              if (*v57)
              {
                if (v39) {
                  int v69 = ((unsigned __int16)(*v68 * (_WORD)v69 + ((*v68 * v69) >> 8) + 1) >> 8);
                }
                if (v69)
                {
                  if (v69 == 255)
                  {
                    *(_WORD *)long long v32 = 0;
                  }
                  else
                  {
                    int v70 = v69 ^ 0xFF;
                    *long long v32 = (unsigned __int16)(*v32 * (_WORD)v70 + ((*v32 * v70) >> 8) + 1) >> 8;
                    v32[1] = (unsigned __int16)(v32[1] * (_WORD)v70 + ((v32[1] * v70) >> 8) + 1) >> 8;
                  }
                }
              }
              ++v57;
              v68 += v39 != 0;
              v32 += 2;
              --v67;
            }
            while (v67);
            int v39 = &v68[v342];
            goto LABEL_308;
          case 1:
            int v71 = *v57;
            if (v39)
            {
              unint64_t v72 = v32 - 2;
              uint64_t v73 = v56 + 1;
              signed int v74 = v57 + 1;
              int v75 = v4;
              int v76 = v346;
              do
              {
                if (v71)
                {
                  unsigned int v77 = *v39 * v71 + ((*v39 * v71) >> 8) + 1;
                  if (BYTE1(v77))
                  {
                    if (BYTE1(v77) == 255)
                    {
                      *((_WORD *)v72 + 1) = *(_WORD *)(v73 - 1);
                    }
                    else
                    {
                      unsigned int v78 = v77 >> 8;
                      unsigned int v79 = v78 * *(v73 - 1) + (v78 ^ 0xFF) * v72[2];
                      v72[2] = (unsigned __int16)(v79 + (v79 >> 8) + 1) >> 8;
                      v72[3] = (unsigned __int16)(v78 * *v73
                                                + (v78 ^ 0xFF) * v72[3]
                                                + ((v78 * *v73 + (v78 ^ 0xFF) * v72[3]) >> 8)
                                                + 1) >> 8;
                    }
                  }
                }
                int v80 = *v74++;
                int v71 = v80;
                ++v39;
                v72 += 2;
                v73 += 2;
                --v75;
              }
              while (v75);
              goto LABEL_79;
            }
            unsigned int v296 = v56 + 1;
            int v297 = v57 + 1;
            unint64_t v72 = v32 - 2;
            int v298 = v4;
            int v76 = v346;
            do
            {
              if (v71)
              {
                if (v71 == 255)
                {
                  *((_WORD *)v72 + 1) = *(_WORD *)(v296 - 1);
                }
                else
                {
                  unsigned int v299 = *(v296 - 1) * v71 + v72[2] * (v71 ^ 0xFF);
                  v72[2] = (unsigned __int16)(v299 + (v299 >> 8) + 1) >> 8;
                  v72[3] = (unsigned __int16)(*v296 * (_WORD)v71
                                            + v72[3] * (v71 ^ 0xFF)
                                            + ((*v296 * v71 + v72[3] * (v71 ^ 0xFFu)) >> 8)
                                            + 1) >> 8;
                }
              }
              int v300 = *v297++;
              int v71 = v300;
              v296 += 2;
              v72 += 2;
              --v298;
            }
            while (v298);
            goto LABEL_381;
          case 2:
            int v81 = *v57;
            if (v39)
            {
              unint64_t v72 = v32 - 2;
              uint8x8_t v82 = v56 + 1;
              uint64_t v83 = v57 + 1;
              int v84 = v4;
              int v76 = v346;
              while (1)
              {
                if (!v81) {
                  goto LABEL_78;
                }
                unsigned int v85 = *v39 * v81 + ((*v39 * v81) >> 8) + 1;
                if (!BYTE1(v85)) {
                  goto LABEL_78;
                }
                if (BYTE1(v85) == 255)
                {
                  int v86 = *v82;
                  if (*v82)
                  {
                    if (v86 == 255)
                    {
                      v72[2] = *(v82 - 1);
                      LOBYTE(v87) = -1;
                    }
                    else
                    {
                      v72[2] = *(v82 - 1)
                             + ((unsigned __int16)(v72[2] * (v86 ^ 0xFF) + ((v72[2] * (v86 ^ 0xFFu)) >> 8) + 1) >> 8);
                      unsigned int v87 = v86 + ((v72[3] * (v86 ^ 0xFF) + ((v72[3] * (v86 ^ 0xFFu)) >> 8) + 1) >> 8);
                    }
                    goto LABEL_77;
                  }
                }
                else
                {
                  unsigned int v88 = v85 >> 8;
                  unsigned int v89 = v88 * *v82 + ((v88 * *v82) >> 8) + 1;
                  if (BYTE1(v89))
                  {
                    v72[2] = ((unsigned __int16)(((v89 >> 8) ^ 0xFF) * v72[2] + ((((v89 >> 8) ^ 0xFF) * v72[2]) >> 8) + 1) >> 8)
                           + ((unsigned __int16)(v88 * *(v82 - 1)
                                               + ((v88 * *(v82 - 1)) >> 8)
                                               + 1) >> 8);
                    unsigned int v87 = ((((v89 >> 8) ^ 0xFF) * v72[3] + ((((v89 >> 8) ^ 0xFF) * v72[3]) >> 8) + 1) >> 8) + (v89 >> 8);
LABEL_77:
                    v72[3] = v87;
                  }
                }
LABEL_78:
                int v90 = *v83++;
                int v81 = v90;
                ++v39;
                v72 += 2;
                v82 += 2;
                if (!--v84)
                {
LABEL_79:
                  v39 += v342;
                  goto LABEL_382;
                }
              }
            }
            unint64_t v301 = v56 + 1;
            unint64_t v302 = v57 + 1;
            unint64_t v72 = v32 - 2;
            int v303 = v4;
            int v76 = v346;
            do
            {
              if (!v81) {
                goto LABEL_380;
              }
              if (v81 != 255)
              {
                unsigned int v306 = *v301 * v81 + ((*v301 * v81) >> 8) + 1;
                if (!BYTE1(v306)) {
                  goto LABEL_380;
                }
                v72[2] = ((unsigned __int16)(((v306 >> 8) ^ 0xFF) * v72[2] + ((((v306 >> 8) ^ 0xFF) * v72[2]) >> 8) + 1) >> 8)
                       + ((unsigned __int16)(*(v301 - 1) * (_WORD)v81
                                           + ((*(v301 - 1) * v81) >> 8)
                                           + 1) >> 8);
                unsigned int v304 = (((v306 >> 8) ^ 0xFF) * v72[3] + ((((v306 >> 8) ^ 0xFF) * v72[3]) >> 8) + 1) >> 8;
                goto LABEL_378;
              }
              unsigned int v304 = *v301;
              if (!*v301) {
                goto LABEL_380;
              }
              if (v304 != 255)
              {
                v72[2] = *(v301 - 1)
                       + ((unsigned __int16)(v72[2] * (v304 ^ 0xFF) + ((v72[2] * (v304 ^ 0xFF)) >> 8) + 1) >> 8);
                unsigned int v306 = v72[3] * (v304 ^ 0xFF) + ((v72[3] * (v304 ^ 0xFF)) >> 8) + 1;
LABEL_378:
                unsigned int v305 = v304 + (v306 >> 8);
                goto LABEL_379;
              }
              v72[2] = *(v301 - 1);
              LOBYTE(v305) = -1;
LABEL_379:
              v72[3] = v305;
LABEL_380:
              int v307 = *v302++;
              int v81 = v307;
              v301 += 2;
              v72 += 2;
              --v303;
            }
            while (v303);
LABEL_381:
            int v39 = 0;
LABEL_382:
            long long v32 = &v72[2 * v343 + 2];
LABEL_359:
            if (!--v348)
            {
              __int16 v36 = v347;
              goto LABEL_384;
            }
            uint64_t v51 = 0;
            int v37 = v76 + 1;
            v44 += v42[16];
            v45 += v42[17];
            __int16 v36 = v347;
            if (v347) {
              continue;
            }
            goto LABEL_27;
          case 3:
            unint64_t v91 = v56 + 1;
            int v92 = v32 + 1;
            int v93 = v4;
            unint64_t v94 = v39;
            do
            {
              uint64_t v95 = v92;
              int v96 = *v57;
              if (*v57)
              {
                if (v39) {
                  int v96 = ((unsigned __int16)(*v94 * (_WORD)v96 + ((*v94 * v96) >> 8) + 1) >> 8);
                }
                if (v96)
                {
                  if (v96 == 255)
                  {
                    int v97 = v32 + 1;
                    int v98 = *v95;
                    *(v95 - 1) = (unsigned __int16)(v98 * *(v91 - 1) + ((v98 * *(v91 - 1)) >> 8) + 1) >> 8;
                    unsigned int v99 = *v91 * v98;
                  }
                  else
                  {
                    int v100 = *v95;
                    unsigned int v101 = (v100 * v96 + ((v100 * v96) >> 8) + 1) >> 8;
                    int v102 = v96 ^ 0xFF;
                    unsigned int v103 = *(v95 - 1) * v102 + v101 * *(v91 - 1);
                    *(v95 - 1) = (unsigned __int16)(v103 + (v103 >> 8) + 1) >> 8;
                    unsigned int v99 = v100 * v102 + v101 * *v91;
                    int v97 = v95;
                  }
                  unsigned __int8 *v97 = (unsigned __int16)(v99 + (v99 >> 8) + 1) >> 8;
                }
              }
              ++v57;
              v94 += v39 != 0;
              v32 += 2;
              v91 += 2;
              int v92 = v95 + 2;
              --v93;
            }
            while (v93);
            goto LABEL_101;
          case 4:
            char v104 = v56 + 1;
            int v105 = v32 + 1;
            int v106 = v4;
            unint64_t v94 = v39;
            do
            {
              uint64_t v95 = v105;
              int v107 = *v57;
              if (*v57)
              {
                if (v39) {
                  int v107 = ((unsigned __int16)(*v94 * (_WORD)v107 + ((*v94 * v107) >> 8) + 1) >> 8);
                }
                if (v107)
                {
                  if (v107 == 255)
                  {
                    unsigned int v108 = v32 + 1;
                    int v109 = *v95 ^ 0xFF;
                    *(v95 - 1) = (unsigned __int16)((*v95 ^ 0xFF) * *(v104 - 1)
                                                  + ((v109 * *(v104 - 1)) >> 8)
                                                  + 1) >> 8;
                    unsigned int v110 = *v104 * v109;
                  }
                  else
                  {
                    int v111 = *v95;
                    unsigned int v112 = ((v111 ^ 0xFF) * v107 + (((v111 ^ 0xFFu) * v107) >> 8) + 1) >> 8;
                    int v113 = v107 ^ 0xFF;
                    unsigned int v114 = *(v95 - 1) * v113 + v112 * *(v104 - 1);
                    *(v95 - 1) = (unsigned __int16)(v114 + (v114 >> 8) + 1) >> 8;
                    unsigned int v110 = v111 * v113 + v112 * *v104;
                    unsigned int v108 = v95;
                  }
                  *unsigned int v108 = (unsigned __int16)(v110 + (v110 >> 8) + 1) >> 8;
                }
              }
              ++v57;
              v94 += v39 != 0;
              v32 += 2;
              v104 += 2;
              int v105 = v95 + 2;
              --v106;
            }
            while (v106);
LABEL_101:
            int v39 = &v94[v342];
            long long v32 = &v95[2 * v343 + 1];
            goto LABEL_358;
          case 5:
            uint64_t v115 = v56 + 1;
            int v116 = v4;
            unint64_t v117 = v39;
            do
            {
              int v118 = *v57;
              if (*v57)
              {
                if (!v39
                  || (int v118 = ((unsigned __int16)(*v117 * (_WORD)v118
                                                                + ((*v117 * v118) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  unsigned int v119 = (*(v115 - 1) * v118 + ((*(v115 - 1) * v118) >> 8) + 1) >> 8;
                  unsigned int v120 = *v115 * v118 + ((*v115 * v118) >> 8) + 1;
                  int v121 = v32[1];
                  *long long v32 = (unsigned __int16)(v119 * v121
                                          + ((v120 >> 8) ^ 0xFF) * *v32
                                          + ((v119 * v121 + ((v120 >> 8) ^ 0xFF) * *v32) >> 8)
                                          + 1) >> 8;
                  v32[1] = (unsigned __int16)((((v120 >> 8) ^ 0xFF) + (v120 >> 8)) * v121
                                            + (((((v120 >> 8) ^ 0xFF) + (v120 >> 8)) * v121) >> 8)
                                            + 1) >> 8;
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v115 += 2;
              --v116;
            }
            while (v116);
            goto LABEL_307;
          case 6:
            BOOL v122 = v56 + 1;
            int v123 = v4;
            unint64_t v117 = v39;
            do
            {
              int v124 = *v57;
              if (*v57)
              {
                if (!v39
                  || (int v124 = ((unsigned __int16)(*v117 * (_WORD)v124
                                                                + ((*v117 * v124) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  int v125 = v32[1];
                  if ((_BYTE)v125 != 0xFF)
                  {
                    if (~(_BYTE)v125 == 255)
                    {
                      *long long v32 = (unsigned __int16)(*(v122 - 1) * (_WORD)v124 + ((*(v122 - 1) * v124) >> 8) + 1) >> 8;
                      unsigned int v126 = (*v122 * v124 + ((*v122 * v124) >> 8) + 1) >> 8;
                    }
                    else
                    {
                      unsigned int v127 = (~(_BYTE)v125 * v124
                            + ((~(_BYTE)v125 * v124) >> 8)
                            + 1) >> 8;
                      *v32 += (unsigned __int16)(v127 * *(v122 - 1) + ((v127 * *(v122 - 1)) >> 8) + 1) >> 8;
                      unsigned int v126 = v125 + ((v127 * *v122 + ((v127 * *v122) >> 8) + 1) >> 8);
                    }
                    v32[1] = v126;
                  }
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v122 += 2;
              --v123;
            }
            while (v123);
            goto LABEL_307;
          case 7:
            uint64_t v128 = v56 + 1;
            int v129 = v4;
            unint64_t v117 = v39;
            do
            {
              int v130 = *v57;
              if (*v57)
              {
                if (v39) {
                  int v130 = ((unsigned __int16)(*v117 * (_WORD)v130
                }
                                                            + ((*v117 * v130) >> 8)
                                                            + 1) >> 8);
                if (v130)
                {
                  if (v130 == 255)
                  {
                    int v131 = *v128;
                    *long long v32 = (unsigned __int16)(v131 * *v32 + ((v131 * *v32) >> 8) + 1) >> 8;
                    int v133 = v32 + 1;
                    unsigned int v132 = v32[1];
                  }
                  else
                  {
                    unsigned int v132 = (v130 ^ 0xFF) + ((*v128 * v130 + ((*v128 * v130) >> 8) + 1) >> 8);
                    *long long v32 = (unsigned __int16)(v132 * *v32 + ((v132 * *v32) >> 8) + 1) >> 8;
                    int v133 = v32 + 1;
                    int v131 = v32[1];
                  }
                  *int v133 = (unsigned __int16)(v132 * v131 + ((v132 * v131) >> 8) + 1) >> 8;
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v128 += 2;
              --v129;
            }
            while (v129);
            goto LABEL_307;
          case 8:
            uint64_t v134 = v56 + 1;
            int v135 = v4;
            unint64_t v117 = v39;
            do
            {
              int v136 = *v57;
              if (*v57)
              {
                if (v39) {
                  int v136 = ((unsigned __int16)(*v117 * (_WORD)v136
                }
                                                            + ((*v117 * v136) >> 8)
                                                            + 1) >> 8);
                if (v136)
                {
                  if (v136 == 255)
                  {
                    int v137 = *v134 ^ 0xFF;
                    *long long v32 = (unsigned __int16)((*v134 ^ 0xFF) * *v32 + ((v137 * *v32) >> 8) + 1) >> 8;
                    int32x4_t v139 = v32 + 1;
                    unsigned int v138 = v32[1];
                  }
                  else
                  {
                    unsigned int v138 = (v136 ^ 0xFF) + (((*v134 ^ 0xFF) * v136 + (((*v134 ^ 0xFFu) * v136) >> 8) + 1) >> 8);
                    *long long v32 = (unsigned __int16)(v138 * *v32 + ((v138 * *v32) >> 8) + 1) >> 8;
                    int32x4_t v139 = v32 + 1;
                    int v137 = v32[1];
                  }
                  *int32x4_t v139 = (unsigned __int16)(v138 * v137 + ((v138 * v137) >> 8) + 1) >> 8;
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v134 += 2;
              --v135;
            }
            while (v135);
            goto LABEL_307;
          case 9:
            int v140 = v56 + 1;
            int v141 = v4;
            unint64_t v117 = v39;
            while (1)
            {
              unsigned int v142 = *v57;
              if (*v57)
              {
                if (!v39) {
                  goto LABEL_147;
                }
                unsigned int v143 = *v117 * v142 + ((*v117 * v142) >> 8) + 1;
                if (BYTE1(v143)) {
                  break;
                }
              }
LABEL_148:
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v140 += 2;
              if (!--v141) {
                goto LABEL_307;
              }
            }
            unsigned int v142 = v143 >> 8;
LABEL_147:
            char v144 = *v140 * v142;
            unsigned __int8 v145 = v32[1];
            char v146 = *(v140 - 1) * v142 * ~v145;
            char v147 = v144 + ~(_BYTE)v142;
            *long long v32 = v146 + v147 * *v32;
            v32[1] = v144 * ~v145 + v147 * v145;
            goto LABEL_148;
          case 10:
            uint64_t v148 = v56 + 1;
            int v149 = v4;
            unint64_t v117 = v39;
            do
            {
              int v150 = *v57;
              if (*v57)
              {
                if (!v39
                  || (int v150 = ((unsigned __int16)(*v117 * (_WORD)v150
                                                                + ((*v117 * v150) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  unsigned int v151 = (*(v148 - 1) * v150 + ((*(v148 - 1) * v150) >> 8) + 1) >> 8;
                  unsigned int v152 = (*v148 * v150 + ((*v148 * v150) >> 8) + 1) >> 8;
                  int v153 = v32[1];
                  *long long v32 = (unsigned __int16)(v151 * (v153 ^ 0xFF)
                                          + (v152 ^ 0xFF) * *v32
                                          + ((v151 * (v153 ^ 0xFF) + (v152 ^ 0xFF) * *v32) >> 8)
                                          + 1) >> 8;
                  v32[1] = (unsigned __int16)(v152 * (v153 ^ 0xFF)
                                            + (v152 ^ 0xFF) * v153
                                            + ((v152 * (v153 ^ 0xFF) + (v152 ^ 0xFF) * v153) >> 8)
                                            + 1) >> 8;
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v148 += 2;
              --v149;
            }
            while (v149);
            goto LABEL_307;
          case 11:
            char v154 = v56 + 1;
            int v155 = v4;
            unint64_t v117 = v39;
            do
            {
              int v156 = *v57;
              if (*v57)
              {
                if (!v39
                  || (int v156 = ((unsigned __int16)(*v117 * (_WORD)v156
                                                                + ((*v117 * v156) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  if (v349) {
                    int v157 = v32[1];
                  }
                  else {
                    int v157 = 255;
                  }
                  unsigned int v158 = (*(v154 - 1) * v156 + ((*(v154 - 1) * v156) >> 8) + 1) >> 8;
                  unsigned int v159 = (*v154 * v156 + ((*v154 * v156) >> 8) + 1) >> 8;
                  unsigned int v160 = ((v159 - v158) | (v159 << 16))
                       + (v157 - *v32)
                       + (v157 << 16);
                  int v161 = (255 * ((v160 >> 8) & 0x10001)) | v160;
                  *long long v32 = BYTE2(v161) - v161;
                  v32[1] = BYTE2(v161);
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v154 += 2;
              --v155;
            }
            while (v155);
            goto LABEL_307;
          case 12:
            uint64_t v162 = v56 + 1;
            int v163 = v4;
            unint64_t v117 = v39;
            do
            {
              int v164 = *v57;
              if (*v57)
              {
                if (!v39
                  || (int v164 = ((unsigned __int16)(*v117 * (_WORD)v164
                                                                + ((*v117 * v164) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  unsigned int v165 = ((*(unsigned __int16 *)v32 | (*(unsigned __int16 *)v32 << 8)) & 0xFF00FF)
                       + ((*(v162 - 1) * v164 + ((*(v162 - 1) * v164) >> 8) + 1) >> 8)
                       + ((257 * *v162 * v164 + 256) & 0xFF0000);
                  int v166 = (255 * ((v165 >> 8) & 0x10001)) | v165;
                  *long long v32 = v166;
                  v32[1] = BYTE2(v166);
                }
              }
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v162 += 2;
              --v163;
            }
            while (v163);
            goto LABEL_307;
          case 13:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v167 = v56 + 1;
            int v168 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v170 = *v57;
              if (!*v57) {
                goto LABEL_184;
              }
              if (v39)
              {
                unsigned int v171 = *v169 * v170 + ((*v169 * v170) >> 8) + 1;
                int v170 = BYTE1(v171);
                if (!BYTE1(v171)) {
                  goto LABEL_184;
                }
              }
              unsigned int v172 = *v167 * v170 + ((*v167 * v170) >> 8) + 1;
              int v173 = BYTE1(v172);
              if (!BYTE1(v172)) {
                goto LABEL_184;
              }
              unsigned int v174 = (*(v167 - 1) * v170 + ((*(v167 - 1) * v170) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v175 = v32[1];
              if (v32[1]) {
                goto LABEL_183;
              }
              *long long v32 = v174;
              v32[1] = BYTE1(v172);
LABEL_184:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v167 += 2;
              if (!--v168) {
                goto LABEL_294;
              }
            }
            int v175 = 255;
LABEL_183:
            uint64_t v176 = v172 & 0xFF00 | v174;
            unint64_t v177 = v339 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v338 = v338 & 0xFFFFFFFFFFFF0000 | v176;
            unint64_t v339 = v177;
            *(_WORD *)long long v32 = PDAmultiplyPDA(v177, v175, v176, v173);
            goto LABEL_184;
          case 14:
            unsigned int v178 = v56 + 1;
            int v179 = v4;
            unint64_t v117 = v39;
            while (1)
            {
              int v180 = *v57;
              if (!*v57) {
                goto LABEL_197;
              }
              if (v39)
              {
                int v180 = ((unsigned __int16)(*v117 * (_WORD)v180 + ((*v117 * v180) >> 8) + 1) >> 8);
                if (!v180) {
                  goto LABEL_197;
                }
              }
              unsigned int v181 = *v178 * v180 + ((*v178 * v180) >> 8) + 1;
              if (!BYTE1(v181)) {
                goto LABEL_197;
              }
              unsigned int v182 = (*(v178 - 1) * v180 + ((*(v178 - 1) * v180) >> 8) + 1) >> 8;
              unsigned int v183 = v181 >> 8;
              if (v349)
              {
                int v184 = v32[1];
                if (!v32[1]) {
                  goto LABEL_196;
                }
              }
              else
              {
                int v184 = 255;
              }
              unsigned int v185 = (*v32 ^ 0xFF) * v182 - *v32 + (*v32 << 8);
              unsigned int v182 = (v185 + (v185 >> 8) + 1) >> 8;
              unsigned int v183 = (255 * (v183 + v184) - v183 * v184 + ((255 * (v183 + v184) - v183 * v184) >> 8) + 1) >> 8;
LABEL_196:
              *long long v32 = v182;
              v32[1] = v183;
LABEL_197:
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v178 += 2;
              if (!--v179) {
                goto LABEL_307;
              }
            }
          case 15:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            int v186 = v56 + 1;
            int v187 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v188 = *v57;
              if (!*v57) {
                goto LABEL_209;
              }
              if (v39)
              {
                unsigned int v189 = *v169 * v188 + ((*v169 * v188) >> 8) + 1;
                int v188 = BYTE1(v189);
                if (!BYTE1(v189)) {
                  goto LABEL_209;
                }
              }
              unsigned int v190 = *v186 * v188 + ((*v186 * v188) >> 8) + 1;
              int v191 = BYTE1(v190);
              if (!BYTE1(v190)) {
                goto LABEL_209;
              }
              unsigned int v192 = (*(v186 - 1) * v188 + ((*(v186 - 1) * v188) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v193 = v32[1];
              if (v32[1]) {
                goto LABEL_208;
              }
              *long long v32 = v192;
              v32[1] = BYTE1(v190);
LABEL_209:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v186 += 2;
              if (!--v187) {
                goto LABEL_294;
              }
            }
            int v193 = 255;
LABEL_208:
            uint64_t v194 = v190 & 0xFF00 | v192;
            unint64_t v195 = v337 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v336 = v336 & 0xFFFFFFFFFFFF0000 | v194;
            unint64_t v337 = v195;
            *(_WORD *)long long v32 = PDAoverlayPDA(v195, v193, v194, v191);
            goto LABEL_209;
          case 16:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v196 = v56 + 1;
            int v197 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v198 = *v57;
              if (!*v57) {
                goto LABEL_221;
              }
              if (v39)
              {
                unsigned int v199 = *v169 * v198 + ((*v169 * v198) >> 8) + 1;
                int v198 = BYTE1(v199);
                if (!BYTE1(v199)) {
                  goto LABEL_221;
                }
              }
              unsigned int v200 = *v196 * v198 + ((*v196 * v198) >> 8) + 1;
              int v201 = BYTE1(v200);
              if (!BYTE1(v200)) {
                goto LABEL_221;
              }
              unsigned int v202 = (*(v196 - 1) * v198 + ((*(v196 - 1) * v198) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v203 = v32[1];
              if (v32[1]) {
                goto LABEL_220;
              }
              *long long v32 = v202;
              v32[1] = BYTE1(v200);
LABEL_221:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v196 += 2;
              if (!--v197) {
                goto LABEL_294;
              }
            }
            int v203 = 255;
LABEL_220:
            uint64_t v204 = v200 & 0xFF00 | v202;
            unint64_t v205 = v333 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v332 = v332 & 0xFFFFFFFFFFFF0000 | v204;
            unint64_t v333 = v205;
            *(_WORD *)long long v32 = PDAdarkenPDA(v205, v203, v204, v201);
            goto LABEL_221;
          case 17:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v206 = v56 + 1;
            int v207 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v208 = *v57;
              if (!*v57) {
                goto LABEL_233;
              }
              if (v39)
              {
                unsigned int v209 = *v169 * v208 + ((*v169 * v208) >> 8) + 1;
                int v208 = BYTE1(v209);
                if (!BYTE1(v209)) {
                  goto LABEL_233;
                }
              }
              unsigned int v210 = *v206 * v208 + ((*v206 * v208) >> 8) + 1;
              int v211 = BYTE1(v210);
              if (!BYTE1(v210)) {
                goto LABEL_233;
              }
              unsigned int v212 = (*(v206 - 1) * v208 + ((*(v206 - 1) * v208) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v213 = v32[1];
              if (v32[1]) {
                goto LABEL_232;
              }
              *long long v32 = v212;
              v32[1] = BYTE1(v210);
LABEL_233:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v206 += 2;
              if (!--v207) {
                goto LABEL_294;
              }
            }
            int v213 = 255;
LABEL_232:
            uint64_t v214 = v210 & 0xFF00 | v212;
            unint64_t v215 = v335 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v334 = v334 & 0xFFFFFFFFFFFF0000 | v214;
            unint64_t v335 = v215;
            *(_WORD *)long long v32 = PDAlightenPDA(v215, v213, v214, v211);
            goto LABEL_233;
          case 18:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            unsigned int v216 = v56 + 1;
            int v217 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v218 = *v57;
              if (!*v57) {
                goto LABEL_245;
              }
              if (v39)
              {
                unsigned int v219 = *v169 * v218 + ((*v169 * v218) >> 8) + 1;
                int v218 = BYTE1(v219);
                if (!BYTE1(v219)) {
                  goto LABEL_245;
                }
              }
              unsigned int v220 = *v216 * v218 + ((*v216 * v218) >> 8) + 1;
              if (!BYTE1(v220)) {
                goto LABEL_245;
              }
              unsigned int v221 = (*(v216 - 1) * v218 + ((*(v216 - 1) * v218) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v222 = v32[1];
              if (v32[1]) {
                goto LABEL_244;
              }
              *long long v32 = v221;
              v32[1] = BYTE1(v220);
LABEL_245:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v216 += 2;
              if (!--v217) {
                goto LABEL_294;
              }
            }
            int v222 = 255;
LABEL_244:
            __int16 v223 = *(_WORD *)v32;
            unint64_t v331 = v331 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v330 = v330 & 0xFFFFFFFFFFFF0000 | v220 & 0xFF00 | v221;
            *(_WORD *)long long v32 = PDAcolordodgePDA(v223, v222, v330, BYTE1(v220));
            goto LABEL_245;
          case 19:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            unint64_t v224 = v56 + 1;
            int v225 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v226 = *v57;
              if (!*v57) {
                goto LABEL_257;
              }
              if (v39)
              {
                unsigned int v227 = *v169 * v226 + ((*v169 * v226) >> 8) + 1;
                int v226 = BYTE1(v227);
                if (!BYTE1(v227)) {
                  goto LABEL_257;
                }
              }
              unsigned int v228 = *v224 * v226 + ((*v224 * v226) >> 8) + 1;
              if (!BYTE1(v228)) {
                goto LABEL_257;
              }
              unsigned int v229 = (*(v224 - 1) * v226 + ((*(v224 - 1) * v226) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v230 = v32[1];
              if (v32[1]) {
                goto LABEL_256;
              }
              *long long v32 = v229;
              v32[1] = BYTE1(v228);
LABEL_257:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v224 += 2;
              if (!--v225) {
                goto LABEL_294;
              }
            }
            int v230 = 255;
LABEL_256:
            __int16 v231 = *(_WORD *)v32;
            unint64_t v329 = v329 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v328 = v328 & 0xFFFFFFFFFFFF0000 | v228 & 0xFF00 | v229;
            *(_WORD *)long long v32 = PDAcolorburnPDA(v231, v230, v328, BYTE1(v228));
            goto LABEL_257;
          case 20:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            int v232 = v56 + 1;
            int v233 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v234 = *v57;
              if (!*v57) {
                goto LABEL_269;
              }
              if (v39)
              {
                unsigned int v235 = *v169 * v234 + ((*v169 * v234) >> 8) + 1;
                int v234 = BYTE1(v235);
                if (!BYTE1(v235)) {
                  goto LABEL_269;
                }
              }
              unsigned int v236 = *v232 * v234 + ((*v232 * v234) >> 8) + 1;
              if (!BYTE1(v236)) {
                goto LABEL_269;
              }
              unsigned int v237 = (*(v232 - 1) * v234 + ((*(v232 - 1) * v234) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v238 = v32[1];
              if (v32[1]) {
                goto LABEL_268;
              }
              *long long v32 = v237;
              v32[1] = BYTE1(v236);
LABEL_269:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v232 += 2;
              if (!--v233) {
                goto LABEL_294;
              }
            }
            int v238 = 255;
LABEL_268:
            __int16 v239 = *(_WORD *)v32;
            unint64_t v325 = v325 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v324 = v324 & 0xFFFFFFFFFFFF0000 | v236 & 0xFF00 | v237;
            *(_WORD *)long long v32 = PDAsoftlightPDA(v239, v238, v324, BYTE1(v236));
            goto LABEL_269;
          case 21:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v240 = v56 + 1;
            int v241 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v242 = *v57;
              if (!*v57) {
                goto LABEL_281;
              }
              if (v39)
              {
                unsigned int v243 = *v169 * v242 + ((*v169 * v242) >> 8) + 1;
                int v242 = BYTE1(v243);
                if (!BYTE1(v243)) {
                  goto LABEL_281;
                }
              }
              unsigned int v244 = *v240 * v242 + ((*v240 * v242) >> 8) + 1;
              if (!BYTE1(v244)) {
                goto LABEL_281;
              }
              unsigned int v245 = (*(v240 - 1) * v242 + ((*(v240 - 1) * v242) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v246 = v32[1];
              if (v32[1]) {
                goto LABEL_280;
              }
              *long long v32 = v245;
              v32[1] = BYTE1(v244);
LABEL_281:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v240 += 2;
              if (!--v241) {
                goto LABEL_294;
              }
            }
            int v246 = 255;
LABEL_280:
            __int16 v247 = *(_WORD *)v32;
            unint64_t v327 = v327 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v326 = v326 & 0xFFFFFFFFFFFF0000 | v244 & 0xFF00 | v245;
            *(_WORD *)long long v32 = PDAhardlightPDA(v247, v246, v326, BYTE1(v244));
            goto LABEL_281;
          case 22:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v248 = v56 + 1;
            int v249 = v4;
            unint64_t v169 = v39;
            while (1)
            {
              int v250 = *v57;
              if (!*v57) {
                goto LABEL_293;
              }
              if (v39)
              {
                unsigned int v251 = *v169 * v250 + ((*v169 * v250) >> 8) + 1;
                int v250 = BYTE1(v251);
                if (!BYTE1(v251)) {
                  goto LABEL_293;
                }
              }
              unsigned int v252 = *v248 * v250 + ((*v248 * v250) >> 8) + 1;
              if (!BYTE1(v252)) {
                goto LABEL_293;
              }
              unsigned int v253 = (*(v248 - 1) * v250 + ((*(v248 - 1) * v250) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v254 = v32[1];
              if (v32[1]) {
                goto LABEL_292;
              }
              *long long v32 = v253;
              v32[1] = BYTE1(v252);
LABEL_293:
              ++v57;
              v169 += v39 != 0;
              v32 += 2;
              v248 += 2;
              if (!--v249)
              {
LABEL_294:
                int v39 = &v169[v342];
                goto LABEL_357;
              }
            }
            int v254 = 255;
LABEL_292:
            __int16 v255 = *(_WORD *)v32;
            unint64_t v323 = v323 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v322 = v322 & 0xFFFFFFFFFFFF0000 | v252 & 0xFF00 | v253;
            *(_WORD *)long long v32 = PDAdifferencePDA(v255, v254, v322, BYTE1(v252));
            goto LABEL_293;
          case 23:
            unsigned int v256 = v56 + 1;
            int v257 = v4;
            unint64_t v117 = v39;
            while (1)
            {
              int v258 = *v57;
              if (!*v57) {
                goto LABEL_306;
              }
              if (v39)
              {
                int v258 = ((unsigned __int16)(*v117 * (_WORD)v258 + ((*v117 * v258) >> 8) + 1) >> 8);
                if (!v258) {
                  goto LABEL_306;
                }
              }
              unsigned int v259 = *v256 * v258 + ((*v256 * v258) >> 8) + 1;
              if (!BYTE1(v259)) {
                goto LABEL_306;
              }
              unsigned int v260 = (*(v256 - 1) * v258 + ((*(v256 - 1) * v258) >> 8) + 1) >> 8;
              unsigned int v261 = v259 >> 8;
              if (v349)
              {
                int v262 = v32[1];
                if (!v32[1]) {
                  goto LABEL_305;
                }
              }
              else
              {
                int v262 = 255;
              }
              unsigned int v263 = 255 * (v260 + *v32) - 2 * v260 * *v32;
              unsigned int v260 = (v263 + (v263 >> 8) + 1) >> 8;
              unsigned int v261 = (255 * (v261 + v262) - v261 * v262 + ((255 * (v261 + v262) - v261 * v262) >> 8) + 1) >> 8;
LABEL_305:
              *long long v32 = v260;
              v32[1] = v261;
LABEL_306:
              ++v57;
              v117 += v39 != 0;
              v32 += 2;
              v256 += 2;
              if (!--v257)
              {
LABEL_307:
                int v39 = &v117[v342];
LABEL_308:
                v32 += 2 * v343;
                goto LABEL_358;
              }
            }
          case 24:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            uint64_t v264 = v56 + 1;
            int v265 = v4;
            uint64_t v266 = v39;
            while (1)
            {
              int v267 = *v57;
              if (!*v57) {
                goto LABEL_319;
              }
              if (v39)
              {
                unsigned int v268 = *v266 * v267 + ((*v266 * v267) >> 8) + 1;
                int v267 = BYTE1(v268);
                if (!BYTE1(v268)) {
                  goto LABEL_319;
                }
              }
              unsigned int v269 = *v264 * v267 + ((*v264 * v267) >> 8) + 1;
              if (!BYTE1(v269)) {
                goto LABEL_319;
              }
              unsigned int v270 = (*(v264 - 1) * v267 + ((*(v264 - 1) * v267) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v271 = v32[1];
              if (v32[1]) {
                goto LABEL_318;
              }
              *long long v32 = v270;
              v32[1] = BYTE1(v269);
LABEL_319:
              ++v57;
              v266 += v39 != 0;
              v32 += 2;
              v264 += 2;
              if (!--v265) {
                goto LABEL_356;
              }
            }
            int v271 = 255;
LABEL_318:
            __int16 v272 = *(_WORD *)v32;
            unint64_t v321 = v321 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v320 = v320 & 0xFFFFFFFFFFFF0000 | v269 & 0xFF00 | v270;
            *(_WORD *)long long v32 = PDAhuePDA(v272, v271, v320, BYTE1(v269));
            goto LABEL_319;
          case 25:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            unint64_t v273 = v56 + 1;
            uint64_t v266 = v39;
            int v274 = v4;
            while (1)
            {
              int v275 = *v57;
              if (!*v57) {
                goto LABEL_331;
              }
              if (v39)
              {
                unsigned int v276 = *v266 * v275 + ((*v266 * v275) >> 8) + 1;
                int v275 = BYTE1(v276);
                if (!BYTE1(v276)) {
                  goto LABEL_331;
                }
              }
              unsigned int v277 = *v273 * v275 + ((*v273 * v275) >> 8) + 1;
              if (!BYTE1(v277)) {
                goto LABEL_331;
              }
              unsigned int v278 = (*(v273 - 1) * v275 + ((*(v273 - 1) * v275) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v279 = v32[1];
              if (v32[1]) {
                goto LABEL_330;
              }
              *long long v32 = v278;
              v32[1] = BYTE1(v277);
LABEL_331:
              ++v57;
              v266 += v39 != 0;
              v32 += 2;
              v273 += 2;
              if (!--v274) {
                goto LABEL_356;
              }
            }
            int v279 = 255;
LABEL_330:
            __int16 v280 = *(_WORD *)v32;
            unint64_t v319 = v319 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v318 = v318 & 0xFFFFFFFFFFFF0000 | v277 & 0xFF00 | v278;
            *(_WORD *)long long v32 = PDAhuePDA(v280, v279, v318, BYTE1(v277));
            goto LABEL_331;
          case 26:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            unsigned int v281 = v56 + 1;
            uint64_t v266 = v39;
            int v282 = v4;
            while (1)
            {
              int v283 = *v57;
              if (!*v57) {
                goto LABEL_343;
              }
              if (v39)
              {
                unsigned int v284 = *v266 * v283 + ((*v266 * v283) >> 8) + 1;
                int v283 = BYTE1(v284);
                if (!BYTE1(v284)) {
                  goto LABEL_343;
                }
              }
              unsigned int v285 = *v281 * v283 + ((*v281 * v283) >> 8) + 1;
              if (!BYTE1(v285)) {
                goto LABEL_343;
              }
              unsigned int v286 = (*(v281 - 1) * v283 + ((*(v281 - 1) * v283) >> 8) + 1) >> 8;
              if (!v349) {
                break;
              }
              int v287 = v32[1];
              if (v32[1]) {
                goto LABEL_342;
              }
              *long long v32 = v286;
              v32[1] = BYTE1(v285);
LABEL_343:
              ++v57;
              v266 += v39 != 0;
              v32 += 2;
              v281 += 2;
              if (!--v282) {
                goto LABEL_356;
              }
            }
            int v287 = 255;
LABEL_342:
            unint64_t v288 = v316 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
            unint64_t v317 = v317 & 0xFFFFFFFFFFFF0000 | v285 & 0xFF00 | v286;
            unint64_t v316 = v288;
            *(_WORD *)long long v32 = PDAhuePDA(v286, BYTE1(v285), v288, v287);
            goto LABEL_343;
          case 27:
            uint64_t v344 = v45;
            uint64_t v345 = v44;
            unint64_t v289 = v56 + 1;
            uint64_t v266 = v39;
            int v290 = v4;
            break;
          default:
            goto LABEL_358;
        }
        while (1)
        {
          int v291 = *v57;
          if (!*v57) {
            goto LABEL_355;
          }
          if (v39)
          {
            unsigned int v292 = *v266 * v291 + ((*v266 * v291) >> 8) + 1;
            int v291 = BYTE1(v292);
            if (!BYTE1(v292)) {
              goto LABEL_355;
            }
          }
          unsigned int v293 = *v289 * v291 + ((*v289 * v291) >> 8) + 1;
          if (!BYTE1(v293)) {
            goto LABEL_355;
          }
          unsigned int v294 = (*(v289 - 1) * v291 + ((*(v289 - 1) * v291) >> 8) + 1) >> 8;
          if (!v349) {
            break;
          }
          int v295 = v32[1];
          if (v32[1]) {
            goto LABEL_354;
          }
          *long long v32 = v294;
          v32[1] = BYTE1(v293);
LABEL_355:
          ++v57;
          v266 += v39 != 0;
          v32 += 2;
          v289 += 2;
          if (!--v290)
          {
LABEL_356:
            int v39 = &v266[v342];
LABEL_357:
            uint64_t v45 = v344;
            v32 += 2 * v343;
            uint64_t v41 = v341;
            int v42 = v340;
            uint64_t v44 = v345;
LABEL_358:
            int v76 = v346;
            goto LABEL_359;
          }
        }
        int v295 = 255;
LABEL_354:
        unint64_t v315 = v315 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)v32;
        unint64_t v314 = v314 & 0xFFFFFFFFFFFF0000 | v293 & 0xFF00 | v294;
        *(_WORD *)long long v32 = PDAhuePDA(v315, v295, v314, BYTE1(v293));
        goto LABEL_355;
      }
      if (!shape_enum_clip_scan((uint64_t)v36, (_DWORD *)v39 - 4)) {
        goto LABEL_384;
      }
    }
    v348 -= v49;
    if (v348 < 1) {
      break;
    }
    v44 += v42[16] * v49;
    v45 += v42[17] * v49;
    v32 += 2 * v309 * v49;
    int v37 = v48;
  }
LABEL_384:
  if (v36) {
    free(v36);
  }
LABEL_386:
  if (v310) {
    free(v310);
  }
}

void GRAYA8_shade_axial_Gray(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = a4;
  float v5 = *(float *)(a1 + 280);
  float v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  float v7 = *(float *)(a1 + 336);
  float v8 = *(float *)(a1 + 344);
  float v9 = *(float *)(a1 + 304);
  float v10 = *(float *)(a1 + 308);
  unsigned int v11 = *(_DWORD *)(a1 + 320);
  unsigned int v12 = *(_DWORD *)(a1 + 324);
  uint64_t v13 = *(_DWORD **)(a1 + 144);
  int v14 = *(unsigned char **)(a1 + 152);
  uint64_t v15 = *(float **)(a1 + 384);
  if (*(void *)(a1 + 392)) {
    uint64_t v16 = *(float **)(a1 + 392);
  }
  else {
    uint64_t v16 = *(float **)(a1 + 272);
  }
  uint64_t v17 = *(void *)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 40);
  if (v18) {
    uint64_t v19 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v19 = *(void *)(a1 + 272);
  }
  if (v5 != 0.0)
  {
    while (1)
    {
      unsigned int v22 = v11;
      if (v6 >= v9)
      {
        unsigned int v22 = v12;
        if (v6 <= v10) {
          unsigned int v22 = (int)(float)(v8 * (float)(v6 - v7));
        }
      }
      if ((v22 & 0x80000000) != 0)
      {
        if (!v15)
        {
          char v27 = 0;
          goto LABEL_32;
        }
        float v24 = *v16;
        float v26 = *v16 * *v15;
      }
      else
      {
        uint64_t v23 = v22;
        if (!v18) {
          uint64_t v23 = 0;
        }
        float v24 = *(float *)(v19 + 4 * v23);
        if (v18) {
          float v25 = *(float *)(v19 + 4 * v23);
        }
        else {
          float v25 = 1.0;
        }
        float v26 = *(float *)(v17 + 4 * v22) * v25;
      }
      SHADE(v14, v26, v24);
      char v27 = -1;
LABEL_32:
      float v6 = v5 + v6;
      v14 += 2;
      *(unsigned char *)uint64_t v13 = v27;
      uint64_t v13 = (_DWORD *)((char *)v13 + 1);
      if (!--v4) {
        return;
      }
    }
  }
  if (v6 >= v9)
  {
    unsigned int v11 = *(_DWORD *)(a1 + 324);
    if (v6 <= v10) {
      unsigned int v11 = (int)(float)(v8 * (float)(v6 - v7));
    }
  }
  if ((v11 & 0x80000000) == 0 || v15)
  {
    if ((v11 & 0x80000000) != 0)
    {
      float v29 = *v16;
      float v31 = *v16 * *v15;
    }
    else
    {
      uint64_t v28 = v11;
      if (!v18) {
        uint64_t v28 = 0;
      }
      float v29 = *(float *)(v19 + 4 * v28);
      float v30 = 1.0;
      if (v18) {
        float v30 = *(float *)(v19 + 4 * v28);
      }
      float v31 = *(float *)(v17 + 4 * v11) * v30;
    }
    int v32 = a4 + 4;
    do
    {
      SHADE(v14, v31, v29);
      SHADE(v14 + 2, v31, v29);
      SHADE(v14 + 4, v31, v29);
      SHADE(v14 + 6, v31, v29);
      *v13++ = -1;
      v32 -= 4;
      v14 += 8;
    }
    while (v32 > 4);
  }
  else
  {
    if (a4 >= 4) {
      int v20 = 4;
    }
    else {
      int v20 = a4;
    }
    __n128 v21 = *(void **)(a1 + 144);
    bzero(v21, ((a4 - v20 + 3) & 0xFFFFFFFC) + 4);
  }
}

double SHADE(unsigned char *a1, float a2, float a3)
{
  double v3 = a2;
  if (v3 > 1.0) {
    double v3 = 1.0;
  }
  float v4 = v3;
  double v5 = v4;
  BOOL v6 = v3 < 0.0;
  double v7 = 0.0;
  if (v6) {
    double v5 = 0.0;
  }
  double v8 = a3;
  if (v8 > 1.0) {
    double v8 = 1.0;
  }
  BOOL v6 = v8 < 0.0;
  float v9 = v8;
  double v10 = v9;
  if (!v6) {
    double v7 = v10;
  }
  *a1 = (int)(v5 * 255.0 + 0.5);
  double result = v7 * 255.0 + 0.5;
  a1[1] = (int)result;
  return result;
}

uint64_t GRAYA8_sample_GRAYA8(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, int8x8_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unsigned int v12 = *(_DWORD *)(result + 8);
  if (v12 >> 6 != 2) {
    _CGHandleAssert("GRAYA8_sample_GRAYA8_inner", 10201, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "skip == LAST_SKIP", "skip = %d", a10, a11, a12, v12 >> 6);
  }
  if (((v12 >> 4) & 3) != 0) {
    _CGHandleAssert("GRAYA8_sample_GRAYA8_inner", 10202, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/blt_gray_with_alpha8.cc", "reverse == NO_REVERSE", "reverse = %d", a10, a11, a12, (v12 >> 4) & 3);
  }
  int v13 = *(_DWORD *)(result + 24);
  uint64_t v14 = *(void *)(result + 112);
  uint64_t v15 = *(void *)(result + 48);
  uint64_t v16 = *(void *)(result + 56);
  if (v15)
  {
    uint64_t v138 = *(void *)(result + 112);
    if (v14 > v15) {
      uint64_t v138 = v14 % v15;
    }
  }
  else
  {
    uint64_t v138 = 0;
  }
  uint64_t v17 = *(void *)(result + 176);
  uint64_t v18 = *(void *)(result + 120);
  uint64_t v19 = *(void *)(result + 32);
  if (v16)
  {
    uint64_t v137 = *(void *)(result + 120);
    if (v18 > v16) {
      uint64_t v137 = v18 % v16;
    }
  }
  else
  {
    uint64_t v137 = 0;
  }
  uint64_t v133 = *(void *)(result + 80);
  uint64_t v134 = *(void *)(result + 64);
  uint64_t v135 = *(void *)(result + 88);
  uint64_t v136 = *(void *)(result + 72);
  int v132 = *(_DWORD *)(result + 188);
  uint64_t v20 = *(void *)(result + 152) - 2;
  uint64_t v21 = *(void *)(result + 144) - 1;
  uint64_t v22 = *(void *)(result + 40);
  unint64_t v23 = v19 + (2 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v13) - 2;
  do
  {
    while (1)
    {
      if (a3 >= v136)
      {
        if (a3 <= v135)
        {
          uint64_t v32 = 0;
          uint64_t v33 = ((unint64_t)a3 >> 22) & 0x3C0;
          unsigned int v34 = 0x3FFFFFFF;
          uint64_t v35 = a3;
        }
        else
        {
          uint64_t v28 = *(void *)(result + 216);
          uint64_t v29 = *(void *)(result + 224) + v135;
          uint64_t v30 = v29 - a3 + (v28 >> 1);
          if (v30 < 1) {
            goto LABEL_52;
          }
          if (v30 >= v28) {
            LODWORD(v31) = 0x3FFFFFFF;
          }
          else {
            unint64_t v31 = (unint64_t)(*(void *)(result + 232) * v30) >> 32;
          }
          unsigned int v34 = v31 | v132;
          uint64_t v35 = v29 - 0x1000000;
          uint64_t v32 = a3 - (v29 - 0x1000000);
          uint64_t v33 = 448;
        }
      }
      else
      {
        uint64_t v24 = *(void *)(result + 216);
        uint64_t v25 = v136 - *(void *)(result + 224);
        uint64_t v26 = a3 - v25 + (v24 >> 1);
        if (v26 < 1) {
          goto LABEL_52;
        }
        if (v26 >= v24) {
          LODWORD(v27) = 0x3FFFFFFF;
        }
        else {
          unint64_t v27 = (unint64_t)(*(void *)(result + 232) * v26) >> 32;
        }
        unsigned int v34 = v27 | v132;
        uint64_t v35 = v25 + 0x1000000;
        uint64_t v32 = a3 - (v25 + 0x1000000);
        uint64_t v33 = 512;
      }
      if (a2 >= v134) {
        break;
      }
      uint64_t v36 = *(void *)(result + 192);
      uint64_t v37 = v134 - *(void *)(result + 200);
      uint64_t v38 = a2 - v37 + (v36 >> 1);
      if (v38 >= 1)
      {
        if (v38 < v36) {
          unsigned int v34 = ((v34 >> 15) * (((unint64_t)(*(void *)(result + 208) * v38) >> 32) >> 15)) | v132;
        }
        uint64_t v39 = v37 + 0x1000000;
        uint64_t v40 = a2 - (v37 + 0x1000000);
        uint64_t v41 = 32;
        goto LABEL_36;
      }
LABEL_52:
      --a4;
      a2 += v14;
      a3 += v18;
      v20 += 2;
      *(unsigned char *)++uint64_t v21 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v133)
    {
      uint64_t v40 = 0;
      uint64_t v41 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v39 = a2;
      goto LABEL_36;
    }
    uint64_t v42 = *(void *)(result + 192);
    uint64_t v43 = *(void *)(result + 200) + v133;
    uint64_t v44 = v43 - a2 + (v42 >> 1);
    if (v44 < 1) {
      goto LABEL_52;
    }
    if (v44 < v42) {
      unsigned int v34 = ((v34 >> 15) * (((unint64_t)(*(void *)(result + 208) * v44) >> 32) >> 15)) | v132;
    }
    uint64_t v39 = v43 - 0x1000000;
    uint64_t v40 = a2 - (v43 - 0x1000000);
    uint64_t v41 = 28;
LABEL_36:
    if (v34 < 0x400000) {
      goto LABEL_52;
    }
    if (v15)
    {
      uint64_t v45 = (v16 & ((v35 % v16) >> 63)) + v35 % v16;
      uint64_t v46 = (v15 & ((v39 % v15) >> 63)) + v39 % v15;
      if (v45 >= v16) {
        uint64_t v47 = v16;
      }
      else {
        uint64_t v47 = 0;
      }
      uint64_t v35 = v45 - v47;
      if (v46 >= v15) {
        uint64_t v48 = v15;
      }
      else {
        uint64_t v48 = 0;
      }
      uint64_t v39 = v46 - v48;
      v32 += v35;
      v40 += v39;
    }
    uint64_t v49 = v19 + SHIDWORD(v35) * (uint64_t)v13;
    uint64_t v50 = v39 >> 32;
    unint64_t v51 = v49 + 2 * v50;
    uint64_t v52 = *(__int8 **)(result + 32);
    if (v23 >= v51) {
      uint64_t v53 = (__int8 *)(v49 + 2 * v50);
    }
    else {
      uint64_t v53 = (__int8 *)v23;
    }
    if (v53 < v52) {
      uint64_t v53 = *(__int8 **)(result + 32);
    }
    if (v22) {
      int v54 = v53[1];
    }
    else {
      int v54 = 255;
    }
    v55.i32[0] = *v53;
    v55.i32[1] = v54;
    if (!v17) {
      goto LABEL_126;
    }
    unsigned int v56 = *(_DWORD *)(v17 + (v41 | v33));
LABEL_58:
    int v57 = v56 & 0xF;
    uint64_t v58 = v56 >> 8;
    int v59 = HIBYTE(v56) & 3;
    int8x8_t v60 = vand_s8((int8x8_t)v55, (int8x8_t)0xFF000000FFLL);
    switch(v57)
    {
      case 1:
        LODWORD(v82) = SBYTE1(v56);
        if (v15)
        {
          uint64_t v83 = v58 << 56;
          uint64_t v84 = v32 + (v83 >> 24);
          uint64_t v85 = v16 & (v84 >> 63);
          if (v85 + v84 >= v16) {
            uint64_t v86 = v16;
          }
          else {
            uint64_t v86 = 0;
          }
          uint64_t v82 = (v85 + (v83 >> 24) - v86) >> 32;
        }
        unsigned int v87 = (__int8 *)(v51 + (int)v82 * (uint64_t)v13);
        if (v23 < (unint64_t)v87) {
          unsigned int v87 = (__int8 *)v23;
        }
        if (v87 >= v52) {
          unsigned int v88 = (unsigned __int8 *)v87;
        }
        else {
          unsigned int v88 = (unsigned __int8 *)v52;
        }
        unsigned int v89 = *v88;
        int v90 = 255;
        if (v22) {
          int v90 = v88[1];
        }
        int v91 = interpolate_graya[2 * v59 + 1];
LABEL_112:
        a8 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v91 + 1]);
        uint32x2_t v98 = (uint32x2_t)vneg_s32(vdup_n_s32(v91 + 1));
        int32x2_t v99 = vsub_s32(v55, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a8, v60), v98));
        int32x2_t v100 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(a8, (int8x8_t)__PAIR64__(v90, v89)), v98);
LABEL_125:
        int32x2_t v55 = vadd_s32(v99, v100);
        break;
      case 2:
        uint64_t v92 = SBYTE2(v56);
        if (v15)
        {
          uint64_t v93 = v40 + ((uint64_t)SBYTE2(v56) << 32);
          uint64_t v94 = v15 & (v93 >> 63);
          if (v94 + v93 >= v15) {
            uint64_t v95 = v15;
          }
          else {
            uint64_t v95 = 0;
          }
          uint64_t v92 = (v94 + ((uint64_t)((unint64_t)HIWORD(v56) << 56) >> 24) - v95) >> 32;
        }
        int v96 = (__int8 *)(v51 + 2 * v92);
        if (v23 < (unint64_t)v96) {
          int v96 = (__int8 *)v23;
        }
        if (v96 >= v52) {
          int v97 = (unsigned __int8 *)v96;
        }
        else {
          int v97 = (unsigned __int8 *)v52;
        }
        unsigned int v89 = *v97;
        int v90 = 255;
        if (v22) {
          int v90 = v97[1];
        }
        int v91 = (v56 >> 28) & 3;
        goto LABEL_112;
      case 3:
        LODWORD(v61) = SBYTE1(v56);
        uint64_t v62 = SBYTE2(v56);
        if (v15)
        {
          uint64_t v63 = v58 << 56;
          uint64_t v64 = v32 + (v63 >> 24);
          uint64_t v65 = v40 + ((uint64_t)SBYTE2(v56) << 32);
          uint64_t v66 = v16 & (v64 >> 63);
          uint64_t v67 = v15 & (v65 >> 63);
          uint64_t v68 = v67 + v65;
          if (v66 + v64 >= v16) {
            uint64_t v69 = v16;
          }
          else {
            uint64_t v69 = 0;
          }
          if (v68 >= v15) {
            uint64_t v70 = v15;
          }
          else {
            uint64_t v70 = 0;
          }
          uint64_t v61 = (v66 + (v63 >> 24) - v69) >> 32;
          uint64_t v62 = (v67 + ((uint64_t)((unint64_t)HIWORD(v56) << 56) >> 24) - v70) >> 32;
        }
        uint64_t v71 = (int)v61 * (uint64_t)v13;
        uint64_t v72 = 2 * v62;
        uint64_t v73 = (__int8 *)(v51 + 2 * v62);
        if (v23 < (unint64_t)v73) {
          uint64_t v73 = (__int8 *)v23;
        }
        if (v73 >= v52) {
          signed int v74 = (unsigned __int8 *)v73;
        }
        else {
          signed int v74 = (unsigned __int8 *)v52;
        }
        __int32 v75 = *v74;
        if (v22)
        {
          int v76 = (__int8 *)(v74 + 1);
          unsigned int v77 = (__int8 *)(v51 + v71);
          if (v23 >= (unint64_t)v77) {
            unsigned int v78 = v77;
          }
          else {
            unsigned int v78 = (__int8 *)v23;
          }
          if (v78 < v52) {
            unsigned int v78 = v52;
          }
          int v79 = v78[1];
          int v80 = &v77[v72];
          if (v23 < (unint64_t)v80) {
            int v80 = (__int8 *)v23;
          }
          if (v80 >= v52) {
            int v81 = v80;
          }
          else {
            int v81 = v52;
          }
          a8.i8[0] = *v76;
          a8.i8[4] = v81[1];
        }
        else
        {
          unsigned int v101 = (__int8 *)(v51 + v71);
          if (v23 >= (unint64_t)v101) {
            unsigned int v78 = v101;
          }
          else {
            unsigned int v78 = (__int8 *)v23;
          }
          if (v78 < v52) {
            unsigned int v78 = v52;
          }
          int v102 = &v101[v72];
          if (v23 < (unint64_t)v102) {
            int v102 = (__int8 *)v23;
          }
          if (v102 >= v52) {
            int v81 = v102;
          }
          else {
            int v81 = v52;
          }
          a8 = (int8x8_t)0xFF000000FFLL;
          int v79 = 255;
        }
        int v103 = (v56 >> 28) & 3;
        int8x8_t v104 = (int8x8_t)vdup_n_s32(interpolate_graya[2 * v59 + 1]);
        uint32x2_t v105 = (uint32x2_t)vneg_s32(vdup_n_s32(v59 + 1));
        int32x2_t v106 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v104, v60), v105);
        int32x2_t v107 = vsub_s32(v55, v106);
        v106.i32[0] = v75;
        int32x2_t v108 = vzip1_s32(v106, (int32x2_t)a8);
        int8x8_t v109 = vand_s8(v104, (int8x8_t)0xFF000000FFLL);
        int32x2_t v110 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v109, (int8x8_t)v108), v105);
        int32x2_t v111 = vsub_s32(v108, v110);
        v110.i8[0] = *v78;
        v110.i32[1] = v79;
        int32x2_t v112 = vadd_s32(v107, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v109, (int8x8_t)v110), v105));
        a8.i8[0] = *v81;
        int8x8_t v113 = (int8x8_t)vadd_s32(v111, (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v109, a8), v105));
        a8 = vand_s8((int8x8_t)vdup_n_s32(interpolate_graya[2 * v103 + 1]), (int8x8_t)0xFF000000FFLL);
        uint32x2_t v114 = (uint32x2_t)vneg_s32(vdup_n_s32(v103 + 1));
        int32x2_t v99 = vsub_s32(v112, (int32x2_t)vshl_u32((uint32x2_t)vand_s8((int8x8_t)v112, a8), v114));
        int32x2_t v100 = (int32x2_t)vshl_u32((uint32x2_t)vand_s8(v113, a8), v114);
        goto LABEL_125;
    }
LABEL_126:
    *(unsigned char *)(v20 + 2) = v55.i8[0];
    v20 += 2;
    *(unsigned char *)(v20 + 1) = v55.i8[4];
    *(unsigned char *)(v21 + 1) = v34 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v115 = 0;
    int v116 = a4 - 1;
    a2 += v14;
    uint64_t v117 = v133 - a2;
    a3 += v18;
    uint64_t v118 = v135 - a3;
    --a4;
    while ((((a2 - v134) | v117 | (a3 - v136) | v118) & 0x8000000000000000) == 0)
    {
      if (v15)
      {
        uint64_t v119 = (v16 & ((v32 + v137) >> 63)) + v32 + v137;
        uint64_t v120 = (v15 & ((v40 + v138) >> 63)) + v40 + v138;
        if (v119 >= v16) {
          uint64_t v121 = v16;
        }
        else {
          uint64_t v121 = 0;
        }
        uint64_t v122 = v119 - v121;
        if (v120 >= v15) {
          uint64_t v123 = v15;
        }
        else {
          uint64_t v123 = 0;
        }
        uint64_t v124 = v120 - v123;
        uint64_t v40 = v124;
        uint64_t v32 = v122;
      }
      else
      {
        uint64_t v124 = a2;
        HIDWORD(v122) = HIDWORD(a3);
      }
      uint64_t v125 = v19 + SHIDWORD(v122) * (uint64_t)v13;
      uint64_t v126 = v124 >> 32;
      unint64_t v51 = v125 + 2 * v126;
      uint64_t v52 = *(__int8 **)(result + 32);
      if (v23 >= v51) {
        unsigned int v127 = (__int8 *)(v125 + 2 * v126);
      }
      else {
        unsigned int v127 = (__int8 *)v23;
      }
      if (v127 >= v52) {
        uint64_t v128 = (unsigned __int8 *)v127;
      }
      else {
        uint64_t v128 = *(unsigned __int8 **)(result + 32);
      }
      if (v22) {
        int v129 = v128[1];
      }
      else {
        int v129 = 255;
      }
      unsigned int v130 = *v128;
      if (v17)
      {
        unsigned int v56 = *(_DWORD *)(v17 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v56 & 0xF) != 0)
        {
          int32x2_t v55 = (int32x2_t)__PAIR64__(v129, v130);
          unsigned int v34 = -1;
          v21 += v115 + 1;
          goto LABEL_58;
        }
      }
      --a4;
      *(unsigned char *)(v20 + 2) = v130;
      v20 += 2;
      *(unsigned char *)(v20 + 1) = v129;
      uint64_t v131 = v21 + v115++;
      a2 += v14;
      *(unsigned char *)(v131 + 2) = -1;
      v117 -= v14;
      a3 += v18;
      v118 -= v18;
      if (v116 == v115) {
        return result;
      }
    }
    v21 += v115 + 1;
  }
  while (a4);
  return result;
}

CFStringRef CGColorSpaceGetName(CFStringRef space)
{
  if (space) {
    return *(CFStringRef *)(space->length + 80);
  }
  return space;
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    *((CGFloat *)c + 19) = x;
    *((CGFloat *)c + 20) = y;
  }
  else
  {
    handle_invalid_context((char)"CGContextSetTextPosition", (uint64_t)c, v3, v4, v5, v6, v7, v8);
  }
}

void rgba32_mark_constmask(uint64_t a1, int a2)
{
  int v5 = *(_DWORD *)(a1 + 4);
  int v4 = *(_DWORD *)(a1 + 8);
  unint64_t v6 = *(int *)(a1 + 28);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v152 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 136);
  unsigned int v9 = **(_DWORD **)(a1 + 88);
  pthread_mutex_lock(&rgba32_cacheColorLock);
  uint64_t v10 = rgba32_cacheColor;
  int v155 = v4;
  if (!rgba32_cacheColor || *(_DWORD *)(rgba32_cacheColor + 16) != v9)
  {
    uint64_t v13 = 0;
    while (1)
    {
      if (!v10) {
        goto LABEL_9;
      }
      uint64_t v14 = (void *)v13;
      uint64_t v13 = v10;
      if (*(_DWORD *)(v10 + 16) == v9) {
        break;
      }
      uint64_t v10 = *(void *)v10;
      if (!*(void *)v13)
      {
        if (rgba32_cacheColorCount > 6)
        {
          *uint64_t v14 = 0;
        }
        else
        {
LABEL_9:
          uint64_t v15 = (char *)rgba32_cacheColorBase;
          if (rgba32_cacheColorBase)
          {
            unsigned int v16 = rgba32_cacheColorCount;
          }
          else
          {
            uint64_t v15 = (char *)malloc_type_calloc(1uLL, 0x1CA8uLL, 0x10200408056D5EBuLL);
            unsigned int v16 = 0;
            rgba32_cacheColorBase = (uint64_t)v15;
          }
          uint64_t v13 = (uint64_t)&v15[24 * v16];
          *(void *)(v13 + 8) = &v15[1024 * (unint64_t)v16 + 168];
          rgba32_cacheColorCFIndex Count = v16 + 1;
        }
        uint64_t v17 = 0;
        *(void *)uint64_t v13 = rgba32_cacheColor;
        rgba32_cacheColor = v13;
        *(_DWORD *)(v13 + 16) = v9;
        uint64_t v19 = *(void *)(v13 + 8);
        uint64_t v12 = v13 + 8;
        uint64_t v18 = v19;
        do
        {
          *(_DWORD *)(v18 + 4 * v17) = PDM_21362(v9, v17);
          ++v17;
        }
        while (v17 != 256);
        pthread_mutex_unlock(&rgba32_cacheColorLock);
        goto LABEL_20;
      }
    }
    if (v14)
    {
      *uint64_t v14 = *(void *)v10;
      *(void *)uint64_t v10 = rgba32_cacheColor;
      rgba32_cacheColor = v10;
    }
  }
  pthread_mutex_unlock(&rgba32_cacheColorLock);
  uint64_t v12 = v10 + 8;
LABEL_20:
  if (!v8) {
    return;
  }
  int v20 = v5;
  uint64_t v21 = *(void *)v12;
  unsigned int v22 = *(_DWORD *)(*(void *)v12 + 1020);
  unint64_t v23 = v6 >> 2;
  uint64_t v24 = (unsigned int *)(v152 + 4 * (*(int *)(a1 + 12) + (v6 >> 2) * *(int *)(a1 + 16)));
  uint64_t v25 = *(int *)(a1 + 124);
  unint64_t v26 = v8 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v25;
  uint64_t v27 = v25 - v5;
  unint64_t v28 = v23 - v5;
  switch(a2)
  {
    case 0:
      do
      {
        int v29 = v5;
        do
        {
          int v30 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v30 == 255) {
              unsigned int v31 = 0;
            }
            else {
              unsigned int v31 = PDM_21362(*v24, v30 ^ 0xFFu);
            }
            *uint64_t v24 = v31;
          }
          ++v26;
          ++v24;
          --v29;
        }
        while (v29);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 1:
      int v91 = -1;
      unsigned int v92 = v26 & 3;
      if ((v26 & 3) != 0)
      {
        int v20 = v92 + v5;
        int v91 = -1 << (8 * v92);
        unint64_t v93 = v26 & 3;
        v26 &= 0xFFFFFFFFFFFFFFFCLL;
        v24 -= v93;
      }
      unint64_t v94 = v23 - v5;
      if ((((_BYTE)v20 + (_BYTE)v26) & 3) != 0)
      {
        int v95 = 4 - (((_BYTE)v20 + (_BYTE)v26) & 3);
        v92 += v95;
        unsigned int v96 = 0xFFFFFFFF >> (8 * v95);
        if (v20 >= 4) {
          unsigned int v97 = v96;
        }
        else {
          unsigned int v97 = 0;
        }
        if (v20 >= 4) {
          unsigned int v96 = -1;
        }
        v91 &= v96;
      }
      else
      {
        unsigned int v97 = 0;
      }
      uint64_t v150 = v27 - v92;
      int v148 = v20 >> 2;
      int32x4_t v153 = vdupq_n_s32(v22);
      unint64_t v146 = v94 - v92;
      do
      {
        unsigned int v127 = *(_DWORD *)v26 & v91;
        int v128 = v148;
        unsigned int v129 = v97;
        if (!v127) {
          goto LABEL_375;
        }
LABEL_357:
        if (v127 == -1)
        {
          *(int32x4_t *)uint64_t v24 = v153;
          goto LABEL_375;
        }
        while (1)
        {
          if ((_BYTE)v127)
          {
            if (v127 == 255) {
              *uint64_t v24 = v22;
            }
            else {
              DplusDM_21364(v24, *(_DWORD *)(v21 + 4 * v127), *v24, ~(_BYTE)v127);
            }
          }
          if (BYTE1(v127))
          {
            unsigned int v130 = v24 + 1;
            if (BYTE1(v127) == 255) {
              *unsigned int v130 = v22;
            }
            else {
              DplusDM_21364(v130, *(_DWORD *)(v21 + 4 * BYTE1(v127)), *v130, ~(v127 >> 8));
            }
          }
          if (BYTE2(v127))
          {
            uint64_t v131 = v24 + 2;
            if (BYTE2(v127) == 255) {
              *uint64_t v131 = v22;
            }
            else {
              DplusDM_21364(v131, *(_DWORD *)(v21 + 4 * BYTE2(v127)), *v131, ~HIWORD(v127));
            }
          }
          int v132 = v24 + 3;
          unsigned int v133 = HIBYTE(v127);
          if (HIBYTE(v127) == 255)
          {
            *int v132 = v22;
          }
          else if (v133)
          {
            DplusDM_21364(v132, *(_DWORD *)(v21 + 4 * v133), *v132, ~v127 >> 24);
          }
LABEL_375:
          while (1)
          {
            int v134 = v128;
            v24 += 4;
            --v128;
            v26 += 4;
            if (v134 < 2) {
              break;
            }
            unsigned int v127 = *(_DWORD *)v26;
            if (*(_DWORD *)v26) {
              goto LABEL_357;
            }
          }
          if (!v129) {
            break;
          }
          unsigned int v129 = 0;
          unsigned int v127 = *(_DWORD *)v26 & v97;
        }
        v26 += v150;
        v24 += v146;
        --v155;
      }
      while (v155);
      return;
    case 2:
      int v98 = -1;
      unsigned int v99 = v26 & 3;
      if ((v26 & 3) != 0)
      {
        int v20 = v99 + v5;
        int v98 = -1 << (8 * v99);
        unint64_t v100 = v26 & 3;
        v26 &= 0xFFFFFFFFFFFFFFFCLL;
        v24 -= v100;
      }
      if ((((_BYTE)v20 + (_BYTE)v26) & 3) != 0)
      {
        int v101 = 4 - (((_BYTE)v20 + (_BYTE)v26) & 3);
        v99 += v101;
        unsigned int v102 = 0xFFFFFFFF >> (8 * v101);
        if (v20 >= 4) {
          unsigned int v103 = v102;
        }
        else {
          unsigned int v103 = 0;
        }
        if (v20 >= 4) {
          unsigned int v102 = -1;
        }
        v98 &= v102;
      }
      else
      {
        unsigned int v103 = 0;
      }
      uint64_t v151 = v27 - v99;
      int v149 = v20 >> 2;
      int v135 = ~(_BYTE)v22;
      uint64_t v147 = v23 - v5 - v99;
      int v154 = v98;
      while (2)
      {
        unsigned int v136 = *(_DWORD *)v26 & v98;
        int v137 = v149;
        unsigned int v138 = v103;
        if (!v136) {
          goto LABEL_396;
        }
LABEL_385:
        if (v136 == -1)
        {
          DplusDM_21364(v24, v22, *v24, v135);
          DplusDM_21364(v24 + 1, v22, v24[1], v135);
          DplusDM_21364(v24 + 2, v22, v24[2], v135);
          int32x4_t v139 = v24 + 3;
          unsigned int v140 = v24[3];
          unsigned int v141 = v22;
          int v142 = ~(_BYTE)v22;
LABEL_395:
          DplusDM_21364(v139, v141, v140, v142);
          goto LABEL_396;
        }
        while (1)
        {
          if ((_BYTE)v136) {
            DplusDM_21364(v24, *(_DWORD *)(v21 + 4 * v136), *v24, ~*(unsigned char *)(v21 + 4 * v136));
          }
          if ((v136 & 0xFF00) != 0) {
            DplusDM_21364(v24 + 1, *(_DWORD *)(v21 + 4 * BYTE1(v136)), v24[1], ~*(unsigned char *)(v21 + 4 * BYTE1(v136)));
          }
          if ((v136 & 0xFF0000) != 0) {
            DplusDM_21364(v24 + 2, *(_DWORD *)(v21 + 4 * BYTE2(v136)), v24[2], ~*(unsigned char *)(v21 + 4 * BYTE2(v136)));
          }
          unsigned int v143 = HIBYTE(v136);
          if (HIBYTE(v136))
          {
            unsigned int v141 = *(_DWORD *)(v21 + 4 * v143);
            int32x4_t v139 = v24 + 3;
            unsigned int v140 = v24[3];
            int v142 = ~*(unsigned char *)(v21 + 4 * v143);
            goto LABEL_395;
          }
LABEL_396:
          while (1)
          {
            int v144 = v137;
            v24 += 4;
            --v137;
            v26 += 4;
            if (v144 < 2) {
              break;
            }
            unsigned int v136 = *(_DWORD *)v26;
            if (*(_DWORD *)v26) {
              goto LABEL_385;
            }
          }
          if (!v138) {
            break;
          }
          unsigned int v138 = 0;
          unsigned int v136 = *(_DWORD *)v26 & v103;
        }
        v26 += v151;
        v24 += v147;
        BOOL v145 = v155-- == 1;
        int v98 = v154;
        if (!v145) {
          continue;
        }
        return;
      }
    case 3:
      do
      {
        int v104 = v5;
        do
        {
          int v105 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v105 == 255)
            {
              *uint64_t v24 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v24);
            }
            else
            {
              unsigned int v106 = *v24 * v105 + 128;
              DplusDM_21364(v24, *(_DWORD *)(v21 + 4 * ((v106 + (v106 >> 8)) >> 8)), *v24, v105 ^ 0xFF);
            }
          }
          ++v26;
          ++v24;
          --v104;
        }
        while (v104);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 4:
      do
      {
        int v107 = v5;
        do
        {
          int v108 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v108 == 255) {
              *uint64_t v24 = *(_DWORD *)(v21 + 4 * ~*(unsigned char *)v24);
            }
            else {
              DplusDM_21364(v24, *(_DWORD *)(v21+ 4* ((~*(unsigned char *)v24 * v108+ 128+ ((~*(unsigned char *)v24 * v108 + 128) >> 8)) >> 8)), *v24, v108 ^ 0xFF);
            }
          }
          ++v26;
          ++v24;
          --v107;
        }
        while (v107);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 5:
      do
      {
        int v109 = v5;
        do
        {
          if (*(unsigned char *)v26) {
            DMplusDM_21363(v24, *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26), *v24, *v24, ~*(unsigned char *)(v21 + 4 * *(unsigned __int8 *)v26));
          }
          ++v26;
          ++v24;
          --v109;
        }
        while (v109);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 6:
      do
      {
        int v110 = v5;
        do
        {
          uint64_t v111 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26 && *v24 != 0xFF)
          {
            if (~*(unsigned char *)v24 == 255) {
              *uint64_t v24 = *(_DWORD *)(v21 + 4 * v111);
            }
            else {
              DplusDM_21364(v24, *v24, *(_DWORD *)(v21 + 4 * v111), ~*(unsigned char *)v24);
            }
          }
          ++v26;
          ++v24;
          --v110;
        }
        while (v110);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 7:
      do
      {
        int v112 = v5;
        do
        {
          int v113 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v113 == 255) {
              int v114 = v22;
            }
            else {
              int v114 = (~(_BYTE)v113
            }
                                     + ((unsigned __int16)(v22 * (_WORD)v113
                                                         + 128
                                                         + ((v22 * v113 + 128) >> 8)) >> 8));
            *uint64_t v24 = PDM_21362(*v24, v114);
          }
          ++v26;
          ++v24;
          --v112;
        }
        while (v112);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 8:
      int v115 = v22;
      int v116 = ~(_BYTE)v22;
      do
      {
        unint64_t v117 = v28;
        int v118 = v5;
        do
        {
          int v119 = *(unsigned __int8 *)v26;
          if (*(unsigned char *)v26)
          {
            if (v119 == 255) {
              int v120 = v116;
            }
            else {
              int v120 = ~((v115 * v119 + 128 + ((v115 * v119 + 128) >> 8)) >> 8);
            }
            *uint64_t v24 = PDM_21362(*v24, v120);
          }
          ++v26;
          ++v24;
          --v118;
        }
        while (v118);
        v26 += v27;
        unint64_t v28 = v117;
        v24 += v117;
        --v155;
      }
      while (v155);
      return;
    case 9:
      do
      {
        int v121 = v5;
        do
        {
          if (*(unsigned char *)v26) {
            DMplusDM_21363(v24, *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26), ~*(unsigned char *)v24, *v24, (*(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26) + ~*(unsigned char *)v26));
          }
          ++v26;
          ++v24;
          --v121;
        }
        while (v121);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 10:
      do
      {
        int v122 = v5;
        do
        {
          if (*(unsigned char *)v26) {
            DMplusDM_21363(v24, *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26), ~*(unsigned char *)v24, *v24, ~*(unsigned char *)(v21 + 4 * *(unsigned __int8 *)v26));
          }
          ++v26;
          ++v24;
          --v122;
        }
        while (v122);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 11:
      do
      {
        int v32 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            if (v7) {
              unsigned __int8 v33 = *v24;
            }
            else {
              unsigned __int8 v33 = -1;
            }
            *(int32x2_t *)v11.i8 = DAplusdDA_21365(v24, *v24, v33, *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26), *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26), v11);
          }
          ++v26;
          ++v24;
          --v32;
        }
        while (v32);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v155);
      return;
    case 12:
      do
      {
        int v123 = v5;
        int v124 = v155;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v125 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            int v126 = ((*v24 >> 8) & 0xFF00FF) + ((v125 >> 8) & 0xFF00FF);
            *uint64_t v24 = (v126 << 8) & 0xFF00FF00 | ((*v24 & 0xFF00FF) + (v125 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                                  * (v126 & 0x1000100 | (((*v24 & 0xFF00FF) + (v125 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v126 & 0x1000100 | (((*v24 & 0xFF00FF) + (v125 & 0xFF00FF)) >> 8) & 0x10001));
          }
          ++v26;
          ++v24;
          --v123;
        }
        while (v123);
        v26 += v27;
        v24 += v28;
        --v155;
      }
      while (v124 != 1);
      return;
    case 13:
      while (1)
      {
        int v34 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v35 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v35)
            {
              if (v7)
              {
                unsigned int v36 = *v24;
                if (!*v24) {
                  goto LABEL_48;
                }
              }
              else
              {
                LOBYTE(v36) = -1;
              }
              unsigned int v35 = PDAmultiplyPDA_21366(*v24, v36, v35, v35);
LABEL_48:
              *uint64_t v24 = v35;
            }
          }
          ++v26;
          ++v24;
          --v34;
        }
        while (v34);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 14:
      while (1)
      {
        int v37 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v38 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v38)
            {
              if (v7)
              {
                unsigned int v39 = *v24;
                if (!*v24) {
                  goto LABEL_60;
                }
              }
              else
              {
                LOBYTE(v39) = -1;
              }
              unsigned int v38 = PDAscreenPDA_21367(*v24, v39, v38, v38);
LABEL_60:
              *uint64_t v24 = v38;
            }
          }
          ++v26;
          ++v24;
          --v37;
        }
        while (v37);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 15:
      while (1)
      {
        int v40 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v41 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v41)
            {
              if (v7)
              {
                unsigned int v42 = *v24;
                if (!*v24) {
                  goto LABEL_72;
                }
              }
              else
              {
                LOBYTE(v42) = -1;
              }
              unsigned int v41 = PDAoverlayPDA_21368(*v24, v42, v41, v41);
LABEL_72:
              *uint64_t v24 = v41;
            }
          }
          ++v26;
          ++v24;
          --v40;
        }
        while (v40);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 16:
      while (1)
      {
        int v43 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v44 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v44)
            {
              if (v7)
              {
                unsigned int v45 = *v24;
                if (!*v24) {
                  goto LABEL_84;
                }
              }
              else
              {
                LOBYTE(v45) = -1;
              }
              unsigned int v44 = PDAdarkenPDA_21370(*v24, v45, v44, v44);
LABEL_84:
              *uint64_t v24 = v44;
            }
          }
          ++v26;
          ++v24;
          --v43;
        }
        while (v43);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 17:
      while (1)
      {
        int v46 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v47 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v47)
            {
              if (v7)
              {
                unsigned int v48 = *v24;
                if (!*v24) {
                  goto LABEL_96;
                }
              }
              else
              {
                LOBYTE(v48) = -1;
              }
              unsigned int v47 = PDAlightenPDA_21369(*v24, v48, v47, v47);
LABEL_96:
              *uint64_t v24 = v47;
            }
          }
          ++v26;
          ++v24;
          --v46;
        }
        while (v46);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 18:
      while (1)
      {
        int v49 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v50 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v50)
            {
              if (v7)
              {
                unsigned int v51 = *v24;
                if (!*v24) {
                  goto LABEL_108;
                }
              }
              else
              {
                LOBYTE(v51) = -1;
              }
              unsigned int v50 = PDAcolordodgePDA_21371(*v24, v51, v50, v50);
LABEL_108:
              *uint64_t v24 = v50;
            }
          }
          ++v26;
          ++v24;
          --v49;
        }
        while (v49);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 19:
      while (1)
      {
        int v52 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v53 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v53)
            {
              if (v7)
              {
                unsigned int v54 = *v24;
                if (!*v24) {
                  goto LABEL_120;
                }
              }
              else
              {
                LOBYTE(v54) = -1;
              }
              unsigned int v53 = PDAcolorburnPDA_21372(*v24, v54, v53, v53);
LABEL_120:
              *uint64_t v24 = v53;
            }
          }
          ++v26;
          ++v24;
          --v52;
        }
        while (v52);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 20:
      while (1)
      {
        int v55 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v56 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v56)
            {
              if (v7)
              {
                unsigned int v57 = *v24;
                if (!*v24) {
                  goto LABEL_132;
                }
              }
              else
              {
                LOBYTE(v57) = -1;
              }
              unsigned int v56 = PDAsoftlightPDA_21374(*v24, v57, v56, v56);
LABEL_132:
              *uint64_t v24 = v56;
            }
          }
          ++v26;
          ++v24;
          --v55;
        }
        while (v55);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 21:
      while (1)
      {
        int v58 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v59 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v59)
            {
              if (v7)
              {
                unsigned int v60 = *v24;
                if (!*v24) {
                  goto LABEL_144;
                }
              }
              else
              {
                LOBYTE(v60) = -1;
              }
              unsigned int v59 = PDAhardlightPDA_21373(*v24, v60, v59, v59);
LABEL_144:
              *uint64_t v24 = v59;
            }
          }
          ++v26;
          ++v24;
          --v58;
        }
        while (v58);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 22:
      while (1)
      {
        int v61 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v62 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v62)
            {
              if (v7)
              {
                unsigned int v63 = *v24;
                if (!*v24) {
                  goto LABEL_156;
                }
              }
              else
              {
                LOBYTE(v63) = -1;
              }
              unsigned int v62 = PDAdifferencePDA_21375(*v24, v63, v62, v62);
LABEL_156:
              *uint64_t v24 = v62;
            }
          }
          ++v26;
          ++v24;
          --v61;
        }
        while (v61);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 23:
      while (1)
      {
        int v64 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v65 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v65)
            {
              if (v7)
              {
                unsigned int v66 = *v24;
                if (!*v24) {
                  goto LABEL_168;
                }
              }
              else
              {
                LOBYTE(v66) = -1;
              }
              unsigned int v65 = PDAexclusionPDA_21376(*v24, v66, v65, v65);
LABEL_168:
              *uint64_t v24 = v65;
            }
          }
          ++v26;
          ++v24;
          --v64;
        }
        while (v64);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 24:
      while (1)
      {
        int v67 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v68 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v68)
            {
              if (v7)
              {
                unsigned int v69 = *v24;
                if (!*v24) {
                  goto LABEL_180;
                }
              }
              else
              {
                LOBYTE(v69) = -1;
              }
              unsigned int v68 = PDAhuePDA_21377(*v24, v69, v68, v68);
LABEL_180:
              *uint64_t v24 = v68;
            }
          }
          ++v26;
          ++v24;
          --v67;
        }
        while (v67);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 25:
      while (1)
      {
        int v70 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v71 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v71)
            {
              if (v7)
              {
                unsigned int v72 = *v24;
                if (!*v24) {
                  goto LABEL_192;
                }
              }
              else
              {
                LOBYTE(v72) = -1;
              }
              unsigned int v71 = PDAsaturationPDA_21378(*v24, v72, v71, v71);
LABEL_192:
              *uint64_t v24 = v71;
            }
          }
          ++v26;
          ++v24;
          --v70;
        }
        while (v70);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 26:
      while (1)
      {
        int v73 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v74 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v74)
            {
              if (v7)
              {
                unsigned int v75 = *v24;
                if (!*v24) {
                  goto LABEL_204;
                }
              }
              else
              {
                LOBYTE(v75) = -1;
              }
              unsigned int v74 = PDAluminosityPDA_21379(v74, v74, *v24, v75);
LABEL_204:
              *uint64_t v24 = v74;
            }
          }
          ++v26;
          ++v24;
          --v73;
        }
        while (v73);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 27:
      while (1)
      {
        int v76 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v77 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v77)
            {
              if (v7)
              {
                unsigned int v78 = *v24;
                if (!*v24) {
                  goto LABEL_216;
                }
              }
              else
              {
                LOBYTE(v78) = -1;
              }
              unsigned int v77 = PDAluminosityPDA_21379(*v24, v78, v77, v77);
LABEL_216:
              *uint64_t v24 = v77;
            }
          }
          ++v26;
          ++v24;
          --v76;
        }
        while (v76);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 28:
      while (1)
      {
        int v79 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v80 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v80)
            {
              if (v7)
              {
                unsigned int v81 = *v24;
                if (!*v24) {
                  goto LABEL_228;
                }
              }
              else
              {
                LOBYTE(v81) = -1;
              }
              unsigned int v80 = PDAtranspose_huePDA_21380(*v24, v81, v80, v80);
LABEL_228:
              *uint64_t v24 = v80;
            }
          }
          ++v26;
          ++v24;
          --v79;
        }
        while (v79);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 29:
      while (1)
      {
        int v82 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v83 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v83)
            {
              if (v7)
              {
                unsigned int v84 = *v24;
                if (!*v24) {
                  goto LABEL_240;
                }
              }
              else
              {
                LOBYTE(v84) = -1;
              }
              unsigned int v83 = PDAtranspose_saturationPDA_21381(*v24, v84, v83, v83);
LABEL_240:
              *uint64_t v24 = v83;
            }
          }
          ++v26;
          ++v24;
          --v82;
        }
        while (v82);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 30:
      while (1)
      {
        int v85 = v5;
        do
        {
          if (*(unsigned char *)v26)
          {
            unsigned int v86 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
            if ((_BYTE)v86)
            {
              if (v7)
              {
                unsigned int v87 = *v24;
                if (!*v24) {
                  goto LABEL_252;
                }
              }
              else
              {
                LOBYTE(v87) = -1;
              }
              unsigned int v86 = PDAtranspose_luminosityPDA_21382(v86, v86, *v24, v87);
LABEL_252:
              *uint64_t v24 = v86;
            }
          }
          ++v26;
          ++v24;
          --v85;
        }
        while (v85);
        v26 += v27;
        v24 += v28;
        if (!--v155) {
          return;
        }
      }
    case 31:
      break;
    default:
      return;
  }
LABEL_256:
  int v88 = v5;
  while (1)
  {
    if (!*(unsigned char *)v26) {
      goto LABEL_265;
    }
    unsigned int v89 = *(_DWORD *)(v21 + 4 * *(unsigned __int8 *)v26);
    if (!(_BYTE)v89) {
      goto LABEL_265;
    }
    if (v7)
    {
      unsigned int v90 = *v24;
      if (!*v24) {
        goto LABEL_264;
      }
    }
    else
    {
      LOBYTE(v90) = -1;
    }
    unsigned int v89 = PDAtranspose_luminosityPDA_21382(*v24, v90, v89, v89);
LABEL_264:
    *uint64_t v24 = v89;
LABEL_265:
    ++v26;
    ++v24;
    if (!--v88)
    {
      v26 += v27;
      v24 += v28;
      if (!--v155) {
        return;
      }
      goto LABEL_256;
    }
  }
}

uint64_t CGPatternGetImage(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)(result + 20) || !*(unsigned char *)(result + 184)) {
      return 0;
    }
    else {
      return *(void *)(result + 80);
    }
  }
  return result;
}

uint64_t CGImageBlockGetBytesPerRow(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

void argb32_mark_pixelshape_template(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0) {
    return;
  }
  unsigned int v50 = (uint64_t (*)(int, int, int, int, int, int, int, int, uint64_t))vec::template_mark_pixelshape_row<(CGCompositeOperation)0,_rgba8_t>;
  if (a2 <= 0x17) {
    unsigned int v50 = vec::MethodList<_rgba8_t>::shapeMethods[a2];
  }
  int v2 = *(_DWORD *)(a1 + 4);
  int v3 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = v2;
  int v56 = v3;
  int v57 = v2;
  unint64_t v5 = *(int *)(a1 + 28);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v54 = v9;
  uint64_t v10 = *(int **)(a1 + 136);
  int v11 = *(unsigned __int8 *)(a1 + 1) << 8;
  unint64_t v12 = v5 >> 2;
  BOOL v49 = v7 != 0;
  unint64_t v13 = v6 + 4 * (*(int *)(a1 + 12) + (v5 >> 2) * *(int *)(a1 + 16));
  unint64_t v55 = v13;
  int v14 = *(_DWORD *)(a1 + 104);
  int v15 = *(_DWORD *)(a1 + 108);
  uint64_t v16 = *(int *)(a1 + 56);
  uint64_t v17 = *(int *)(a1 + 60);
  unint64_t v18 = *(int *)(a1 + 76);
  if (v11 != 256)
  {
    unint64_t v51 = *(unsigned int *)(a1 + 64);
    unint64_t v23 = v18 >> 2;
    unint64_t v24 = (v18 >> 2) * *(int *)(a1 + 68);
    int v43 = *(_DWORD *)(a1 + 68);
    uint64_t v53 = v9;
    unint64_t v25 = v9 + 4 * v24;
    BOOL v26 = v8 != 0;
    if (v10)
    {
      uint64_t v22 = 1;
      uint64_t v20 = v9;
      goto LABEL_21;
    }
    unint64_t v46 = v13;
    if (v9)
    {
      unsigned int v44 = 0;
      uint64_t v45 = v9;
      uint64_t v27 = v9 + 4 * v23 * ((int)v17 % v43);
      uint64_t v20 = v27 + 4 * ((int)v16 % (int)v51);
      uint64_t v28 = v27 + 4 * (int)v51;
      uint64_t v53 = v28;
      uint64_t v54 = v20;
      uint64_t v22 = 1;
      uint64_t v9 = v20;
      goto LABEL_25;
    }
    uint64_t v28 = 0;
    uint64_t v20 = 0;
    uint64_t v22 = 1;
LABEL_24:
    unint64_t v25 = 0;
    unsigned int v44 = 0;
    uint64_t v45 = v20;
    uint64_t v9 = 0;
    v23 -= v4;
    goto LABEL_25;
  }
  unint64_t v19 = v18 >> 2;
  uint64_t v20 = v9 + 4 * (v16 + v19 * v17);
  uint64_t v53 = -1;
  uint64_t v54 = v20;
  unint64_t v51 = v19;
  if (v19 != v12)
  {
    uint64_t v22 = 1;
    goto LABEL_19;
  }
  if ((uint64_t)(v13 - v20) >= 1)
  {
    if (v2 >= (uint64_t)((v13 - v20) >> 2))
    {
      v13 += 4 * (v2 - 1);
      unint64_t v55 = v13;
      v20 += 4 * (v2 - 1);
      uint64_t v54 = v20;
      uint64_t v22 = 0xFFFFFFFFLL;
      goto LABEL_18;
    }
    uint64_t v21 = v12 * (v3 - 1);
    if (v13 <= v20 + 4 * v21 + 4 * (v2 - 1))
    {
      v13 += 4 * v21;
      unint64_t v55 = v13;
      unint64_t v12 = -(uint64_t)v12;
      uint64_t v54 = v20 + 4 * v21;
      uint64_t v22 = 1;
      uint64_t v20 = v54;
      goto LABEL_18;
    }
  }
  uint64_t v22 = 1;
LABEL_18:
  unint64_t v51 = v12;
LABEL_19:
  BOOL v26 = v8 != 0;
  if (!v10)
  {
    unint64_t v46 = v13;
    int v43 = 0;
    uint64_t v4 = (int)v22 * v2;
    uint64_t v28 = -1;
    unint64_t v23 = v51;
    goto LABEL_24;
  }
  unint64_t v25 = 0;
  uint64_t v9 = 0;
  int v43 = 0;
  unint64_t v23 = v51;
LABEL_21:
  shape_enum_clip_alloc(a1, a2, v10, v22, v12, 1, v14, v15, v2, v3);
  int v30 = v29;
  if (v29)
  {
    while (shape_enum_clip_next((uint64_t)v30, (int *)&v52 + 1, &v52, &v57, &v56))
    {
      uint64_t v45 = v20;
      unint64_t v46 = v13;
      unsigned int v44 = v30;
      if (v25)
      {
        uint64_t v40 = v13 + 4 * v12 * (int)v52 + 4 * SHIDWORD(v52);
        int v2 = v57;
        uint64_t v41 = v20 + 4 * v23 * (((int)v52 + *(_DWORD *)(a1 + 60)) % v43);
        uint64_t v20 = v41 + 4 * ((HIDWORD(v52) + *(_DWORD *)(a1 + 56)) % (int)v51);
        uint64_t v28 = v41 + 4 * (int)v51;
        uint64_t v53 = v28;
        LODWORD(v4) = v57;
        uint64_t v9 = v20;
      }
      else
      {
        int v2 = v57;
        LODWORD(v4) = v57 * v22;
        uint64_t v40 = v13 + 4 * v12 * (int)v52 + 4 * HIDWORD(v52) * (int)v22;
        v20 += 4 * (int)v52 * (int)v51 + 4 * HIDWORD(v52) * (int)v22;
        unint64_t v23 = (int)v51 - v57 * (int)v22;
        uint64_t v28 = v53;
      }
      unint64_t v55 = v40;
      uint64_t v54 = v20;
      uint64_t v4 = (int)v4;
      int v3 = v56;
LABEL_25:
      unint64_t v48 = v12;
      uint64_t v31 = v12 - v4;
      unint64_t v32 = v2 & ~(v2 >> 31);
      if ((unint64_t)(v28 - v20) >> 2 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = (unint64_t)(v28 - v20) >> 2;
      }
      unint64_t v34 = v32 - v33;
      if (v3 >= 1) {
        int v35 = 1;
      }
      else {
        int v35 = v3;
      }
      int v47 = v35;
      int v36 = v3 + 1;
      do
      {
        v50((int)&v54, (int)&v55, (int)&v53, v51, v22, v26, v49, v34, v33);
        v55 += 4 * v31;
        if (v25)
        {
          unint64_t v37 = v9 + 4 * v23;
          if (v37 >= v25) {
            uint64_t v38 = -(uint64_t)(v23 * v43);
          }
          else {
            uint64_t v38 = 0;
          }
          uint64_t v39 = v37 + 4 * v38;
          v53 += 4 * v38 + 4 * v23;
          uint64_t v9 = v39;
        }
        else
        {
          uint64_t v39 = v54 + 4 * v23;
        }
        uint64_t v54 = v39;
        --v36;
      }
      while (v36 > 1);
      int v56 = v47 - 1;
      unint64_t v12 = v48;
      uint64_t v20 = v45;
      unint64_t v13 = v46;
      int v30 = v44;
      if (!v44) {
        return;
      }
      uint64_t v52 = 0;
    }
    free(v30);
  }
}

_DWORD **vec::template_mark_pixelshape_row<(CGCompositeOperation)7,_rgba8_t>(_DWORD **result, unsigned __int32 **a2, unint64_t *a3, int a4, int a5, int8x16_t a6, double a7, uint16x8_t a8, uint64_t a9, uint64_t a10, uint64_t a11, unint64_t a12)
{
  unint64_t v12 = a12;
  unint64_t v13 = *result;
  unint64_t v14 = *a3;
  int v15 = *a2;
  if (a12 >= 4)
  {
    uint64_t v16 = 0;
    a6.i64[1] = 0xF0F0F0F0B0B0B0BLL;
    uint16x8_t v17 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      uint8x16_t v18 = *(uint8x16_t *)&v15[v16];
      uint8x16_t v19 = (uint8x16_t)vqtbl1q_s8(*(int8x16_t *)&v13[v16], (int8x16_t)xmmword_1850CD8D0);
      uint16x8_t v20 = vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v19.i8);
      uint16x8_t v21 = vmull_high_u8(v18, v19);
      uint16x8_t v22 = vminq_u16(v20, v17);
      uint16x8_t v23 = vminq_u16(v21, v17);
      a8 = vrsraq_n_u16(v23, v23, 8uLL);
      *(uint8x16_t *)&v15[v16] = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v22, v22, 8uLL), 8uLL), a8, 8uLL);
      v12 -= 4;
      v16 += 4 * a5;
    }
    while (v12 > 3);
    int v15 = (unsigned __int32 *)((char *)v15 + v16 * 4);
    unint64_t v13 = (_DWORD *)((char *)v13 + v16 * 4);
  }
  uint64_t v24 = v12 + a11;
  if (v24)
  {
    a6.i64[0] = -4244438269;
    uint16x8_t v25 = (uint16x8_t)vdupq_n_s16(0xFE01u);
    do
    {
      a8.i32[0] = *v15;
      int8x16_t v26 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a8.i8);
      LOBYTE(v27) = v26.i8[0];
      BYTE1(v27) = v26.i8[2];
      BYTE2(v27) = v26.i8[4];
      HIBYTE(v27) = v26.i8[6];
      v26.i32[0] = *v13;
      v26.i64[1] = v26.i64[0];
      uint16x8_t v28 = vminq_u16(vmull_u8((uint8x8_t)v27, (uint8x8_t)vqtbl1_s8(v26, (int8x8_t)-4244438269)), v25);
      a8 = vrsraq_n_u16(v28, v28, 8uLL);
      *(uint8x8_t *)a8.i8 = vqrshrn_n_u16(a8, 8uLL);
      *(int8x8_t *)a8.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a8, a6));
      *int v15 = a8.i32[0];
      int v29 = &v13[a5];
      if ((unint64_t)v29 >= v14) {
        uint64_t v30 = -(uint64_t)a4;
      }
      else {
        uint64_t v30 = 0;
      }
      unint64_t v13 = &v29[v30];
      v15 += a5;
      --v24;
    }
    while (v24);
  }
  *double result = v13;
  *a3 = v14;
  *a2 = v15;
  return result;
}

int CGFontGetUnitsPerEm(CGFontRef font)
{
  font_float64x2_t info = get_font_info(font);
  if (font_info) {
    LODWORD(font_info) = font_info[2];
  }
  return (int)font_info;
}

uint64_t CGDataProviderGetSizeOfData(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 32);
  }
  else {
    return -1;
  }
}

BOOL CGImageIsMask(CGImageRef image)
{
  if (image) {
    LODWORD(image) = (*((unsigned __int8 *)image + 39) >> 1) & 1;
  }
  return (char)image;
}

void CGContextSetBlendMode(CGContextRef c, CGBlendMode mode)
{
  if (!c)
  {
    CGContextRef v8 = 0;
LABEL_6:
    handle_invalid_context((char)"CGContextSetBlendMode", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v8 = c;
    goto LABEL_6;
  }
  if (mode <= kCGBlendModePlusLighter) {
    CGGStateSetCompositeOperation(*((void *)c + 12), CGContextSetBlendMode_op[mode]);
  }
}

CFTypeRef CGColorTransformRetain(CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  return cf;
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  __double2 v4 = __sincos_stret(angle);
  retstr->double a = v4.__cosval;
  retstr->double b = v4.__sinval;
  retstr->double c = -v4.__sinval;
  retstr->double d = v4.__cosval;
  retstr->double tx = 0.0;
  retstr->double ty = 0.0;
  return result;
}

CGAffineTransform *__cdecl CGAffineTransformScale(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat sx, CGFloat sy)
{
  float64x2_t v4 = vmulq_n_f64(*(float64x2_t *)&t->c, sy);
  *(float64x2_t *)&t->double a = vmulq_n_f64(*(float64x2_t *)&t->a, sx);
  *(float64x2_t *)&t->double c = v4;
  long long v5 = *(_OWORD *)&t->tx;
  *(_OWORD *)&retstr->double c = *(_OWORD *)&t->c;
  *(_OWORD *)&retstr->double tx = v5;
  *(_OWORD *)&retstr->double a = *(_OWORD *)&t->a;
  return t;
}

uint64_t CGImageProviderGetPixelSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

void CGContextStrokePath(CGContextRef c)
{
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGContextRef v8 = (double *)*((void *)c + 12);
      double b = transform->b;
      double v10 = transform->c;
      double d = transform->d;
      double tx = transform->tx;
      double ty = transform->ty;
      double v14 = v8[3];
      double v15 = v8[4];
      double v16 = v8[5];
      double v17 = v8[6];
      double v18 = b * v16 + transform->a * v14;
      double v19 = b * v17 + transform->a * v15;
      double v20 = d * v16 + v10 * v14;
      double v21 = d * v17 + v10 * v15;
      double v22 = v8[7] + v16 * ty + tx * v14;
      double v23 = v17 * ty + tx * v15 + v8[8];
      v8[3] = v18;
      v8[4] = v19;
      v8[5] = v20;
      void v8[6] = v21;
      v8[7] = v22;
      v8[8] = v23;
      return;
    }
    CGContextRef v24 = c;
  }
  else
  {
    CGContextRef v24 = 0;
  }
  handle_invalid_context((char)"CGContextConcatCTM", (uint64_t)v24, v2, v3, v4, v5, v6, v7);
}

void CGContextSetFont(CGContextRef c, CGFontRef font)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetFont(*((void *)c + 12), font);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFont", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

CGColorConversionInfoRef CGColorConversionInfoCreateFromList(CFDictionaryRef options, CGColorSpaceRef a2, CGColorConversionInfoTransformType a3, CGColorRenderingIntent a4, ...)
{
  va_start(va, a4);
  return CGColorConversionInfoCreateFromListWithArguments(options, a2, a3, a4, va);
}

CGColorConversionInfoRef CGColorConversionInfoCreateFromListWithArguments(CFDictionaryRef options, CGColorSpaceRef a2, CGColorConversionInfoTransformType a3, CGColorRenderingIntent a4, va_list a5)
{
  int v11 = options
     && (CFTypeID v10 = CFGetTypeID(options), v10 == CFDictionaryGetTypeID())
     && CFDictionaryGetValue(options, @"kCGColorTransformBlackPointCompensation") == (const void *)*MEMORY[0x1E4F1CFD0];

  return (CGColorConversionInfoRef)create_from_argument_list(options, v11, a2, a3, a4, (uint64_t)a5);
}

void cg_color_conversion_info_finalize(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
    if (CGColorConversionInfoGetTypeID_predicate != -1) {
      dispatch_once(&CGColorConversionInfoGetTypeID_predicate, &__block_literal_global_1194);
    }
    if (v2 == kCGColorConverterRuntimeID)
    {
      CGColorSyncTransformCacheRelease(*(void **)(a1 + 16));
      uint64_t v3 = *(const void **)(a1 + 24);
      if (v3)
      {
        CFRelease(v3);
      }
    }
  }
}

void converter_finalize(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = *(const void **)(a1 + 24);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(const void **)(a1 + 32);
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = *(const void **)(a1 + 72);
    if (v4) {
      CFRelease(v4);
    }
    CGColorSyncTransformCacheRelease(*(void **)(a1 + 88));
    uint64_t v5 = *(const void **)(a1 + 96);
    if (v5) {
      CFRelease(v5);
    }
    uint64_t v6 = *(const void **)(a1 + 200);
    if (v6) {
      CFRelease(v6);
    }
    uint64_t v7 = *(void **)(a1 + 216);
    if (v7)
    {
      free(v7);
    }
  }
}

uint64_t create_from_argument_list(const void *a1, int a2, void *a3, int a4, unsigned int a5, uint64_t a6)
{
  SceneReferredLinearDerivative = a3;
  unsigned int v12 = a4 == 1 || a4 == 4;
  if (a4 == 8)
  {
    if (CGColorSpaceGetType(a3) == 6 && *(unsigned char *)(SceneReferredLinearDerivative[3] + 18))
    {
      unint64_t v13 = 0;
    }
    else
    {
      SceneReferredLinearDerivative = CGColorSpaceCreateSceneReferredLinearDerivative(SceneReferredLinearDerivative);
      unint64_t v13 = SceneReferredLinearDerivative;
      if (!SceneReferredLinearDerivative) {
        return 0;
      }
    }
    goto LABEL_14;
  }
  unint64_t v13 = 0;
  if (a3)
  {
LABEL_14:
    uint64_t v14 = SceneReferredLinearDerivative[3];
    CFTypeRef cf = v13;
    if (*(unsigned char *)(v14 + 16)) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = *(unsigned __int8 *)(v14 + 17) != 0;
    }
    BOOL v63 = v15;
    unint64_t v13 = SceneReferredLinearDerivative;
    goto LABEL_18;
  }
  BOOL v63 = 0;
  CFTypeRef cf = 0;
LABEL_18:
  int v64 = a2;
  if (CGColorSpaceGetType(v13) == 6 && *(unsigned char *)(v13[3] + 18))
  {
    unsigned int v16 = a5;
    BOOL v17 = 1;
  }
  else
  {
    unsigned int v16 = a5;
    BOOL v17 = CGColorSpaceGetType(v13) == 6 && *(unsigned char *)(v13[3] + 19) != 0;
  }
  BOOL v18 = CGColorSpaceContainsFlexGTCInfo((BOOL)v13);
  unsigned int v19 = CGColorConversionInfoOptionsDisplayReferredToneMappingRequested(a1);
  unsigned int v20 = CGColorConversionInfoOptionsSceneReferredToneMappingRequested(a1);
  if (CGColorConversionInfoOptionsFlexTRCRequested((const __CFDictionary *)a1))
  {
    CFDictionaryRef v27 = (const __CFDictionary *)a1;
    if (!v18)
    {
LABEL_26:
      if (v13 && (uint16x8_t v28 = *(uint64_t (**)(void *))(*(void *)(v13[3] + 112) + 48)) != 0)
      {
        uint64_t v29 = v28(v13);
        CGLog(2, (uint64_t)"Use of FlexGTC requested but color space %@ doesn't contain FlexGTC info", v30, v31, v32, v33, v34, v35, v29);
        if (v29)
        {
          int v36 = (const void *)v29;
LABEL_78:
          CFRelease(v36);
        }
      }
      else
      {
        CGLog(2, (uint64_t)"Use of FlexGTC requested but color space %@ doesn't contain FlexGTC info", v21, v22, v23, v24, v25, v26, 0);
      }
      return 0;
    }
  }
  else
  {
    CFDictionaryRef v27 = (const __CFDictionary *)a1;
    if (((CGColorConversionInfoOptionsFlexLumaRequested((const __CFDictionary *)a1) ^ 1 | v18) & 1) == 0) {
      goto LABEL_26;
    }
  }
  int v37 = (v63 || v17) | v19 | v20;
  if (v13) {
    BOOL v38 = *(unsigned char *)(v13[3] + 13) != 0;
  }
  else {
    BOOL v38 = 0;
  }
  ColorsyncTransformType = CGColorSpaceGetColorsyncTransformType(v13, a4);
  CFArrayRef ProfileSetForColorSpace = CGCMSUtilsCreateProfileSetForColorSpace((CGColorSpace *)v13, ColorsyncTransformType, v16, v64, v38, v12);
  if (ProfileSetForColorSpace)
  {
    CFArrayRef v41 = ProfileSetForColorSpace;
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      v69.length = CFArrayGetCount(v41);
      v69.locatiounint64_t n = 0;
      CFArrayAppendArray(Mutable, v41, v69);
      CFRelease(v41);
      int v43 = (CGColorSpace **)a6;
      int v67 = (int *)(a6 + 8);
      unsigned int v44 = *v43;
      if (*v43)
      {
        while (1)
        {
          uint64_t v45 = v67;
          int v46 = *v67;
          unsigned int v47 = v67[2];
          v67 += 6;
          unint64_t v48 = (CGColorSpace *)*((void *)v45 + 2);
          int v49 = *(unsigned __int8 *)(*((void *)v44 + 3) + 13);
          unsigned int v50 = CGColorSpaceGetColorsyncTransformType(v44, v46);
          CFArrayRef v51 = CGCMSUtilsCreateProfileSetForColorSpace(v44, v50, v47, v64, v49, v48 == 0);
          if (!v51) {
            break;
          }
          CFArrayRef v52 = v51;
          v70.length = CFArrayGetCount(v51);
          v70.locatiounint64_t n = 0;
          CFArrayAppendArray(Mutable, v52, v70);
          CFRelease(v52);
          uint64_t v53 = *((void *)v44 + 3);
          if (*(unsigned char *)(v53 + 16)) {
            BOOL v54 = 1;
          }
          else {
            BOOL v54 = *(unsigned __int8 *)(v53 + 17) != 0;
          }
          if (CGColorSpaceGetType(v44) == 6 && *(unsigned char *)(*((void *)v44 + 3) + 18))
          {
            int v55 = 1;
          }
          else
          {
            BOOL v56 = CGColorSpaceGetType(v44) == 6 && *(unsigned char *)(*((void *)v44 + 3) + 19) != 0;
            if (v54 || v56) {
              int v55 = 1;
            }
            else {
              int v55 = v37;
            }
          }
          int v37 = v55 != 0;
          unsigned int v44 = v48;
          if (!v48) {
            goto LABEL_55;
          }
        }
        if (cf) {
          CFRelease(cf);
        }
        int v36 = Mutable;
        goto LABEL_78;
      }
    }
    else
    {
      CFRelease(v41);
    }
  }
  else
  {
    Mutable = 0;
  }
LABEL_55:
  if (cf) {
    CFRelease(cf);
  }
  if (!Mutable) {
    return 0;
  }
  if (v37)
  {
    if (create_3DLUT_for_PQEETF_predicate != -1) {
      dispatch_once(&create_3DLUT_for_PQEETF_predicate, &__block_literal_global_111);
    }
    if (create_3DLUT_for_PQEETF_status) {
      goto LABEL_65;
    }
    if (create_3DLUT_for_HLG_SceneReferredMapping_predicate[0] != -1) {
      dispatch_once(create_3DLUT_for_HLG_SceneReferredMapping_predicate, &__block_literal_global_115);
    }
    if (create_3DLUT_for_HLG_SceneReferredMapping_status)
    {
LABEL_65:
      CFDictionaryRef new_transform_options = create_new_transform_options(v27);
      goto LABEL_71;
    }
  }
  else if (!linked_on_golden_gate_or_later())
  {
    CFMutableArrayRef v58 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (v58)
    {
      CFMutableArrayRef v59 = v58;
      v68.length = CFArrayGetCount(Mutable);
      v68.locatiounint64_t n = 0;
      CFArrayApplyFunction(Mutable, v68, (CFArrayApplierFunction)modify, v59);
      CFRelease(Mutable);
      Mutable = v59;
    }
  }
  if (!v27)
  {
    CFDictionaryRef v60 = 0;
    goto LABEL_72;
  }
  CFDictionaryRef new_transform_options = (const __CFDictionary *)CFRetain(v27);
LABEL_71:
  CFDictionaryRef v60 = new_transform_options;
LABEL_72:
  Retainedouble d = CGColorSyncTransformCacheGetRetained(Mutable, v60);
  CFRelease(Mutable);
  if (v60) {
    CFRelease(v60);
  }
  return create_conversion_info(Retained, v27);
}

float CGColorSpaceSanitizeHeadroom(void *a1, float a2)
{
  if (a2 == 0.0)
  {
    float HeadroomInfo = CGColorSpaceGetHeadroomInfo(a1, 0);
  }
  else
  {
    float HeadroomInfo = 1.0;
    if (a1)
    {
      uint64_t v4 = (unsigned char *)a1[3];
      if (v4[13] || v4[16] || v4[17]) {
        float HeadroomInfo = a2;
      }
    }
  }
  float v5 = 1.0;
  if (HeadroomInfo >= 1.0) {
    float v5 = HeadroomInfo;
  }
  BOOL v6 = HeadroomInfo <= 0.0;
  float result = 0.0;
  if (!v6) {
    return v5;
  }
  return result;
}

float CGColorSpaceGetHeadroomInfo(void *a1, int *a2)
{
  float valuePtr = 0.0;
  if (!a1) {
    goto LABEL_6;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  if (v4 != CGColorSpaceGetTypeID_type_id || CGColorSpaceGetType(a1) - 7 < 3)
  {
LABEL_6:
    int v5 = 0;
    goto LABEL_7;
  }
  if (!CGColorSpaceContainsFlexGTCInfo((BOOL)a1)
    || (uint64_t v14 = (const void *)CGColorSpaceCopyFlexGTCInfo((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13)) == 0)
  {
LABEL_18:
    uint64_t v21 = (unsigned char *)a1[3];
    if (v21[13])
    {
      float valuePtr = 0.0;
    }
    else
    {
      if (!v21[16] && !v21[17])
      {
        float valuePtr = 1.0;
        goto LABEL_25;
      }
      float valuePtr = 4.9261;
    }
    int v5 = 2;
    goto LABEL_7;
  }
  BOOL v15 = v14;
  CFTypeID v16 = CFGetTypeID(v14);
  if (v16 != CFDictionaryGetTypeID()
    || (Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v15, @"com.apple.ColorSync.MonoGainMapParams")) == 0|| (CFDictionaryRef v18 = Value, v19 = CFGetTypeID(Value), v19 != CFDictionaryGetTypeID())|| (v20 = (const __CFNumber *)CFDictionaryGetValue(v18, @"com.apple.ColorSync.GainMapBaselineHeadroom")) == 0)
  {
    CFRelease(v15);
    goto LABEL_18;
  }
  CFNumberGetValue(v20, kCFNumberFloatType, &valuePtr);
  float valuePtr = exp2f(valuePtr);
  CFRelease(v15);
LABEL_25:
  int v5 = 1;
LABEL_7:
  if (a2) {
    *a2 = v5;
  }
  return valuePtr;
}

BOOL CGColorSpaceContainsFlexGTCInfo(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v9 = CFGetTypeID((CFTypeRef)result);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (v9 == CGColorSpaceGetTypeID_type_id)
    {
      int v10 = *(_DWORD *)(*(void *)(v1 + 24) + 24);
      if (v10 == 11) {
        return 1;
      }
      if (v10 == 6)
      {
        uint64_t v11 = (const void *)CGColorSpaceCopyFlexGTCInfo(v1, v2, v3, v4, v5, v6, v7, v8);
        float result = v11 != 0;
        if (!v11) {
          return result;
        }
        CFRelease(v11);
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t CGColorSpaceCopyFlexGTCInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef v8 = CGColorSpaceCopyColorSyncProfile(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v8) {
    return 0;
  }
  CFTypeID v9 = v8;
  CFTypeID v10 = CFGetTypeID(v8);
  if (CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate, &__block_literal_global_48_6703);
  }
  if (v10 == CGColorSpaceCopyFlexGTCInfo_f())
  {
    if (CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate_51 != -1) {
      dispatch_once(&CGColorSpaceCopyFlexGTCInfo_cglibrarypredicate_51, &__block_literal_global_54_6704);
    }
    uint64_t v11 = CGColorSpaceCopyFlexGTCInfo_f_50(v9);
  }
  else
  {
    uint64_t v11 = 0;
  }
  CFRelease(v9);
  return v11;
}

CFTypeRef CGColorSpaceCopyColorSyncProfile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 24);
    switch(*(_DWORD *)(v9 + 24))
    {
      case 3:
        CGColorSpaceGetCalibratedGrayData(a1, a6, a7, a8, (uint64_t)v16);
        return (CFTypeRef)CGCMSUtilsCreateProfileForCalGray((uint64_t)v16);
      case 4:
        CGColorSpaceGetCalibratedRGBData(a1, a6, a7, a8, (uint64_t)v15);
        return (CFTypeRef)CGCMSUtilsCreateProfileForCalRGB((uint64_t)v15);
      case 5:
        uint64_t v11 = *(char **)(v9 + 96);
        return (CFTypeRef)CGCMSUtilsCreateProfileForCalLab(v11, (uint64_t)(v11 + 24));
      case 6:
        FlexGTCProfile = *(const void **)(*(void *)(v9 + 96) + 16);
        if (!FlexGTCProfile) {
          return 0;
        }
        goto LABEL_10;
      case 0xA:
        CFDataRef v14 = CGColorSpaceICCCopyData(a1, a2, a3, a4, a5, a6, a7, a8);
        if (CGColorSpaceCopyColorSyncProfile_cglibrarypredicate != -1) {
          dispatch_once(&CGColorSpaceCopyColorSyncProfile_cglibrarypredicate, &__block_literal_global_22934);
        }
        uint64_t v8 = CGColorSpaceCopyColorSyncProfile_f(v14, 0);
        if (v14) {
          CFRelease(v14);
        }
        return (CFTypeRef)v8;
      case 0xB:
        FlexGTCProfile = (const void *)CGColorSpaceFlexGTCProxyGetFlexGTCProfile(a1);
        if (!FlexGTCProfile) {
          return 0;
        }
LABEL_10:
        CFTypeRef result = CFRetain(FlexGTCProfile);
        break;
      default:
        return (CFTypeRef)v8;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

__CFArray *create_colorsync_profile_sequence(CGColorSpace *a1, CGColorSpace *a2, unsigned int a3, int a4)
{
  if (a2) {
    BOOL v7 = *(unsigned char *)(*((void *)a2 + 3) + 13) != 0;
  }
  else {
    BOOL v7 = 0;
  }
  CFArrayRef ProfileSetForColorSpace = CGCMSUtilsCreateProfileSetForColorSpace(a2, @"ColorSyncTransformDeviceToPCS", a3, a4, v7, 0);
  if (CGColorSpaceGetType(a1) == 6)
  {
    uint64_t v9 = *((void *)a1 + 3);
    if (*(unsigned char *)(v9 + 18)) {
      CFTypeID v10 = @"ColorSyncTransformPCSToSceneLinear";
    }
    else {
      CFTypeID v10 = @"ColorSyncTransformPCSToDevice";
    }
  }
  else
  {
    if (!a1)
    {
      BOOL v11 = 0;
      CFTypeID v10 = @"ColorSyncTransformPCSToDevice";
      goto LABEL_12;
    }
    uint64_t v9 = *((void *)a1 + 3);
    CFTypeID v10 = @"ColorSyncTransformPCSToDevice";
  }
  BOOL v11 = *(unsigned __int8 *)(v9 + 13) != 0;
LABEL_12:
  CFArrayRef v12 = CGCMSUtilsCreateProfileSetForColorSpace(a1, v10, a3, a4, v11, 1u);
  if (v12 && ProfileSetForColorSpace)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      v16.length = CFArrayGetCount(ProfileSetForColorSpace);
      v16.locatiounint64_t n = 0;
      CFArrayAppendArray(Mutable, ProfileSetForColorSpace, v16);
      v17.length = CFArrayGetCount(v12);
      v17.locatiounint64_t n = 0;
      CFArrayAppendArray(Mutable, v12, v17);
    }
  }
  else
  {
    Mutable = 0;
    CFDataRef v14 = 0;
    if (!ProfileSetForColorSpace) {
      goto LABEL_18;
    }
  }
  CFRelease(ProfileSetForColorSpace);
  CFDataRef v14 = Mutable;
LABEL_18:
  if (v12) {
    CFRelease(v12);
  }
  return v14;
}

CFArrayRef CGCMSUtilsCreateProfileSetForColorSpace(CGColorSpace *a1, __CFString *a2, unsigned int a3, int a4, int a5, unsigned int a6)
{
  ProfileSet = 0;
  switch(CGColorSpaceGetType(a1))
  {
    case 3u:
    case 4u:
    case 5u:
      CFDataRef v13 = CGColorSpaceCopyICCData(a1);
      if (CGCMSUtilsCreateProfileSetForColorSpace_cglibrarypredicate != -1) {
        dispatch_once(&CGCMSUtilsCreateProfileSetForColorSpace_cglibrarypredicate, &__block_literal_global_473);
      }
      ProfileSetForColorSpace_f = (void *)CGCMSUtilsCreateProfileSetForColorSpace_f(v13, 0);
      ProfileSet = CGCMSUtilsCreateProfileSet(a1, ProfileSetForColorSpace_f, a2, a3, a4, a5);
      if (v13) {
        CFRelease(v13);
      }
      if (ProfileSetForColorSpace_f) {
        CFRelease(ProfileSetForColorSpace_f);
      }
      goto LABEL_8;
    case 6u:
      FlexGTCProfile = *(void **)(*(void *)(*((void *)a1 + 3) + 96) + 16);
      goto LABEL_36;
    case 0xAu:
      if (a3 > 4) {
        CFRange v17 = @"ColorSyncRenderingIntentPerceptual";
      }
      else {
        CFRange v17 = (__CFString *)*((void *)&off_1E52A0FF8 + a3);
      }
      if (a4) {
        CFDictionaryRef v18 = (void **)MEMORY[0x1E4F1CFD0];
      }
      else {
        CFDictionaryRef v18 = (void **)MEMORY[0x1E4F1CFC8];
      }
      uint64_t v19 = *(void *)(*((void *)a1 + 3) + 96) + 8 * a6;
      CFArrayRef v20 = *(const __CFArray **)(v19 + 8);
      if (v20)
      {
        uint64_t Count = CFArrayGetCount(*(CFArrayRef *)(v19 + 8));
        ProfileSet = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
        if (Count >= 1)
        {
          CFIndex v22 = 0;
          uint64_t v23 = *v18;
          do
          {
            ValueAtIndedouble x = CFArrayGetValueAtIndex(v20, v22);
            CFTypeID v25 = CFGetTypeID(ValueAtIndex);
            if (v25 != CFDictionaryGetTypeID()) {
              _CGHandleAssert("copy_set_with_parameters", 1540, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSUtils.c", "CFGetTypeID(oldDict) == CFDictionaryGetTypeID()", "expected dictionary", v26, v27, v28, v33);
            }
            if (!v22 && CFEqual(a2, @"ColorSyncTransformDeviceToPCS")
              || Count - 1 == v22 && CFEqual(a2, @"ColorSyncTransformPCSToDevice"))
            {
              CFDictionaryRef v29 = (const __CFDictionary *)ValueAtIndex;
              uint64_t v30 = a1;
              uint64_t v31 = a2;
            }
            else
            {
              CFDictionaryRef v29 = (const __CFDictionary *)ValueAtIndex;
              uint64_t v30 = a1;
              uint64_t v31 = @"ColorSyncTransformPCSToPCS";
            }
            CFDictionaryRef v32 = copy_profile_dictionary_with_parameters(v29, v30, v31, v17, v23);
            if (v32)
            {
              CFArrayAppendValue(ProfileSet, v32);
              CFRelease(v32);
            }
            ++v22;
          }
          while (Count != v22);
        }
      }
      else
      {
        ProfileSet = 0;
      }
      goto LABEL_8;
    case 0xBu:
      if (a6)
      {
        if (a6 == 1) {
          FlexGTCProfile = **(void ***)(*((void *)a1 + 3) + 96);
        }
        else {
          FlexGTCProfile = 0;
        }
      }
      else
      {
        FlexGTCProfile = (void *)CGColorSpaceFlexGTCProxyGetFlexGTCProfile((uint64_t)a1);
      }
LABEL_36:
      CFArrayRef result = CGCMSUtilsCreateProfileSet(a1, FlexGTCProfile, a2, a3, a4, a5);
      break;
    default:
LABEL_8:
      CFArrayRef result = ProfileSet;
      break;
  }
  return result;
}

CFArrayRef CGCMSUtilsCreateProfileSet(void *a1, void *a2, void *a3, unsigned int a4, int a5, int a6)
{
  keys[7] = *(void **)MEMORY[0x1E4F143B8];
  if (a4 > 4) {
    uint64_t v9 = @"ColorSyncRenderingIntentPerceptual";
  }
  else {
    uint64_t v9 = (__CFString *)*((void *)&off_1E52A0FF8 + a4);
  }
  if (a5) {
    CFTypeID v10 = (void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    CFTypeID v10 = (void *)*MEMORY[0x1E4F1CFC8];
  }
  if (a6) {
    BOOL v11 = (void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    BOOL v11 = (void *)*MEMORY[0x1E4F1CFC8];
  }
  if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 19))
  {
    CFArrayRef v12 = @"com.apple.cmm.PQDerivative";
  }
  else
  {
    CFArrayRef v12 = (__CFString *)*MEMORY[0x1E4F1D260];
    if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 18)) {
      CFArrayRef v12 = @"com.apple.cmm.HLGDerivative";
    }
  }
  CFArrayRef v13 = 0;
  if (a2 && a3 && v10 && v12 != 0)
  {
    keys[0] = @"ColorSyncProfile";
    keys[1] = @"ColorSyncRenderingIntent";
    keys[2] = @"ColorSyncTransformTag";
    keys[3] = @"ColorSyncBlackPointCompensation";
    keys[4] = @"com.apple.cmm.ExtendedRange";
    keys[5] = @"com.apple.cmm.HDRDerivative";
    keys[6] = @"kCGColorSpace";
    values[0] = a2;
    values[1] = v9;
    values[2] = a3;
    values[3] = v10;
    values[4] = v11;
    values[5] = v12;
    if (a1) {
      CFIndex v15 = 7;
    }
    else {
      CFIndex v15 = 6;
    }
    values[6] = a1;
    CFDictionaryRef v16 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v15, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v16)
    {
      CFDictionaryRef v17 = v16;
      keys[0] = v16;
      CFArrayRef v13 = CFArrayCreate(0, (const void **)keys, 1, MEMORY[0x1E4F1D510]);
      CFRelease(v17);
    }
    else
    {
      return 0;
    }
  }
  return v13;
}

uint64_t CGCMSConverterCreate(void *a1, void *a2, uint64_t a3, uint64_t a4, const __CFDictionary *a5, int *a6)
{
  switch(CGColorSpaceGetType(a2))
  {
    case 0u:
    case 1u:
    case 2u:
      unsigned int Type = CGColorSpaceGetType(a2);
      unsigned int v13 = CGColorSpaceGetType(a1);
      if (Type >= 3) {
        _CGHandleAssert("create_device", 350, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGCMSConverter.c", "srcType == kCGColorSpaceDeviceGray || srcType == kCGColorSpaceDeviceRGB || srcType == kCGColorSpaceDeviceCMYK", "incompatible colorspace type %d", v17, v18, v19, Type);
      }
      unsigned int v20 = v13;
      if (v13 > 2) {
        return 0;
      }
      uint64_t v21 = kCGCMSConverterID;
      if (!kCGCMSConverterID)
      {
        pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
        uint64_t v21 = kCGCMSConverterID;
      }
      uint64_t Instance = CGTypeCreateInstance(v21, 216, v14, v15, v16, v17, v18, v19);
      *(_DWORD *)(Instance + 84) = 0;
      *(void *)(Instance + 32) = CFRetain(a2);
      if (a1)
      {
        *(void *)(Instance + 24) = CFRetain(a1);
        if (a2) {
          uint64_t v23 = *(void *)(a2[3] + 48);
        }
        else {
          uint64_t v23 = 0;
        }
        *(void *)(Instance + 48) = v23;
        uint64_t v91 = *(void *)(a1[3] + 48);
      }
      else
      {
        *(void *)(Instance + 24) = 0;
        if (a2) {
          uint64_t v84 = *(void *)(a2[3] + 48);
        }
        else {
          uint64_t v84 = 0;
        }
        uint64_t v91 = 0;
        *(void *)(Instance + 48) = v84;
      }
      *(void *)(Instance + 40) = v91;
      if (v20 == Type) {
        int v95 = 3;
      }
      else {
        int v95 = 1;
      }
      *(_DWORD *)(Instance + 16) = v95;
      *(void *)(Instance + 56) = convert_device;
      goto LABEL_112;
    case 3u:
    case 4u:
    case 5u:
      if (CGColorSpaceGetType(a1) > 2 || CGColorSpaceGetType(a1) > 2) {
        goto LABEL_15;
      }
      uint64_t v30 = kCGCMSConverterID;
      if (!kCGCMSConverterID)
      {
        pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
        uint64_t v30 = kCGCMSConverterID;
      }
      uint64_t Instance = CGTypeCreateInstance(v30, 216, v24, v25, v26, v27, v28, v29);
      *(void *)(Instance + 56) = convert_Lab_to_device;
      if (a1)
      {
        CFTypeRef v31 = CFRetain(a1);
        uint64_t v32 = *(void *)(a1[3] + 48);
      }
      else
      {
        CFTypeRef v31 = 0;
        uint64_t v32 = 0;
      }
      *(void *)(Instance + 24) = v31;
      *(void *)(Instance + 40) = v32;
      *(void *)(Instance + 48) = 3;
      int v95 = 1;
      *(_DWORD *)(Instance + 16) = 1;
LABEL_112:
      *(void *)(Instance + 64) = null_buffer_converter_info;
      if (a6) {
        *a6 = v95;
      }
      goto LABEL_181;
    case 6u:
    case 0xAu:
    case 0xBu:
LABEL_15:
      colorsync_profile_sequence = create_colorsync_profile_sequence((CGColorSpace *)a1, (CGColorSpace *)a2, a3, a4);
      if (!colorsync_profile_sequence) {
        return 0;
      }
      uint64_t v34 = colorsync_profile_sequence;
      Retainedouble d = CGColorSyncTransformCacheGetRetained(colorsync_profile_sequence, a5);
      if (!Retained)
      {
        CGPostError((uint64_t)"%s: CGColorSyncTransformCacheGetRetained failed!", v35, v36, v37, v38, v39, v40, v41, (char)"create_icc");
        int v49 = v34;
        goto LABEL_26;
      }
      unsigned int v42 = CGColorConversionInfoOptionsDisplayReferredToneMappingRequested(a5);
      unsigned int v120 = CGColorConversionInfoOptionsSceneReferredToneMappingRequested(a5);
      unint64_t v117 = a6;
      CFTypeRef cf = v34;
      if (a5)
      {
        CFTypeID v43 = CFGetTypeID(a5);
        BOOL v116 = v43 == CFDictionaryGetTypeID()
            && ((CFDictionaryRef Value = a5, CFDictionaryContainsKey(a5, @"kCGColorConversionInfoOptions") != 1)
             || (CFDictionaryRef Value = CFDictionaryGetValue(a5, @"kCGColorConversionInfoOptions")) != 0)
            && (CFTypeID v45 = CFGetTypeID(Value), v45 == CFDictionaryGetTypeID())
            && (CFDictionaryRef v46 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)Value, @"kCGImageExtendedRangeToneMappingInfo")) != 0&& (v47 = v46, v48 = CFGetTypeID(v46), v48 == CFDictionaryGetTypeID())&& CFDictionaryContainsKey(v47, @"kCGApplyEXRToneMappingGamma") != 0;
        CFTypeID v50 = CFGetTypeID(a5);
        if (v50 == CFDictionaryGetTypeID())
        {
          CFArrayRef v51 = a5;
          if (CFDictionaryContainsKey(a5, @"kCGColorConversionInfoOptions") != 1
            || (CFArrayRef v51 = CFDictionaryGetValue(a5, @"kCGColorConversionInfoOptions")) != 0)
          {
            CFTypeID v52 = CFGetTypeID(v51);
            if (v52 == CFDictionaryGetTypeID())
            {
              uint64_t v53 = CFDictionaryGetValue((CFDictionaryRef)v51, @"kCGApplyReferenceWhiteToneMapping");
              if (v53)
              {
                BOOL v54 = v53;
                CFTypeID v55 = CFGetTypeID(v53);
                BOOL v57 = v55 == CFDictionaryGetTypeID() || v54 == (const void *)*MEMORY[0x1E4F1CFD0];
LABEL_53:
                unsigned int v65 = CGColorConversionInfoOptionsFlexTRCRequested(a5);
                unsigned int v66 = CGColorConversionInfoOptionsFlexLumaRequested(a5);
                unsigned int v73 = v66;
                if (!a2 || (uint64_t v74 = a2[3], !*(unsigned char *)(v74 + 16)) && !*(unsigned char *)(v74 + 17))
                {
                  if (a1)
                  {
                    uint64_t v75 = a1[3];
                    if (*(unsigned char *)(v75 + 16)) {
                      goto LABEL_74;
                    }
                    BOOL v76 = *(unsigned __int8 *)(v75 + 17) != 0;
                  }
                  else
                  {
                    BOOL v76 = 0;
                  }
                  if ((v76 | v42 | v120 | v57 | v65 | v66) != 1)
                  {
                    unsigned int v86 = v42;
                    BOOL v119 = 0;
                    if (a2)
                    {
LABEL_82:
                      int v90 = *(unsigned char *)(a2[3] + 13) != 0;
                      goto LABEL_87;
                    }
LABEL_86:
                    int v90 = 0;
LABEL_87:
                    if (!(v90 ^ 1 | v86)) {
                      int v90 = v120 | v116;
                    }
                    if ((v90 | v57 | v65 | v73) == 1)
                    {
                      if (a5
                        && CFDictionaryContainsKey(a5, @"kCGConvertColorDataUseColorSyncForToneMapping") == 1)
                      {
                        BOOL v123 = 0;
                        Booleaunint64_t n = CGCFDictionaryGetBoolean(a5, @"kCGConvertColorDataUseColorSyncForToneMapping", &v123);
                        if (v123) {
                          BOOL v93 = Boolean;
                        }
                        else {
                          BOOL v93 = 0;
                        }
                        goto LABEL_144;
                      }
                      if (v86)
                      {
                        if (use_colorsync_for_display_referred_tone_mapping_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_display_referred_tone_mapping_from_defaults_predicate, &__block_literal_global_32_2096);
                        }
                        unint64_t v94 = &use_colorsync_for_display_referred_tone_mapping_from_defaults_status;
                        goto LABEL_141;
                      }
                      if (v120)
                      {
                        if (use_colorsync_for_scene_referred_tone_mapping_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_scene_referred_tone_mapping_from_defaults_predicate, &__block_literal_global_36_2097);
                        }
                        unint64_t v94 = &use_colorsync_for_scene_referred_tone_mapping_from_defaults_status;
                        goto LABEL_141;
                      }
                      if (v116)
                      {
                        if (use_colorsync_for_exr_gamma_tone_mapping_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_exr_gamma_tone_mapping_from_defaults_predicate, &__block_literal_global_39_2098);
                        }
                        unint64_t v94 = &use_colorsync_for_exr_gamma_tone_mapping_from_defaults_status;
                        goto LABEL_141;
                      }
                      if (v57)
                      {
                        if (use_colorsync_for_reference_white_tone_mapping_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_reference_white_tone_mapping_from_defaults_predicate, &__block_literal_global_43);
                        }
                        unint64_t v94 = &use_colorsync_for_reference_white_tone_mapping_from_defaults_status;
                        goto LABEL_141;
                      }
                      if (v73)
                      {
                        if (use_colorsync_for_flexLuma_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_flexLuma_from_defaults_predicate, &__block_literal_global_47);
                        }
                        unint64_t v94 = &use_colorsync_for_flexLuma_from_defaults_status;
                        goto LABEL_141;
                      }
                      if (v65)
                      {
                        if (use_colorsync_for_flexTRC_from_defaults_predicate != -1) {
                          dispatch_once(&use_colorsync_for_flexTRC_from_defaults_predicate, &__block_literal_global_51);
                        }
                        unint64_t v94 = &use_colorsync_for_flexTRC_from_defaults_status;
LABEL_141:
                        BOOL v93 = *v94 != 0;
                        if (!a5)
                        {
LABEL_142:
                          int v99 = 0;
                          goto LABEL_153;
                        }
LABEL_144:
                        if (CFDictionaryContainsKey(a5, @"kCGApplyLuminanceScaling") == 1)
                        {
                          BOOL v124 = 0;
                          int v100 = CGCFDictionaryGetBoolean(a5, @"kCGApplyLuminanceScaling", &v124);
                          if (v124) {
                            int v99 = v100;
                          }
                          else {
                            int v99 = 0;
                          }
                        }
                        else
                        {
                          int v99 = 0;
                        }
                        if (CFDictionaryContainsKey(a5, @"kCGConvertColorDataUseColorSync") == 1)
                        {
                          BOOL v125 = 0;
                          int v101 = CGCFDictionaryGetBoolean(a5, @"kCGConvertColorDataUseColorSync", &v125);
                          if (v125) {
                            int v102 = v101;
                          }
                          else {
                            int v102 = 0;
                          }
LABEL_154:
                          uint64_t v103 = kCGCMSConverterID;
                          if (!kCGCMSConverterID)
                          {
                            pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
                            uint64_t v103 = kCGCMSConverterID;
                          }
                          uint64_t v104 = CGTypeCreateInstance(v103, 216, v67, v68, v69, v70, v71, v72);
                          uint64_t Instance = v104;
                          *(_DWORD *)(v104 + 84) = a3;
                          if (a2)
                          {
                            *(void *)(v104 + 32) = CFRetain(a2);
                            BOOL v105 = v119;
                            if (a1)
                            {
                              *(void *)(Instance + 24) = CFRetain(a1);
                              uint64_t v106 = *(void *)(a2[3] + 48);
LABEL_161:
                              *(void *)(Instance + 48) = v106;
                              uint64_t v108 = *(void *)(a1[3] + 48);
                              goto LABEL_165;
                            }
                            *(void *)(Instance + 24) = 0;
                            uint64_t v109 = *(void *)(a2[3] + 48);
                          }
                          else
                          {
                            *(void *)(v104 + 32) = 0;
                            BOOL v105 = v119;
                            if (a1)
                            {
                              CFTypeRef v107 = CFRetain(a1);
                              uint64_t v106 = 0;
                              *(void *)(Instance + 24) = v107;
                              goto LABEL_161;
                            }
                            uint64_t v109 = 0;
                            *(void *)(v104 + 24) = 0;
                          }
                          uint64_t v108 = 0;
                          *(void *)(Instance + 48) = v109;
LABEL_165:
                          *(void *)(Instance + 40) = v108;
                          if (transform_get_conv_type_cglibrarypredicate != -1) {
                            dispatch_once(&transform_get_conv_type_cglibrarypredicate, &__block_literal_global_54_2099);
                          }
                          CFStringRef conv_type_f = (const __CFString *)transform_get_conv_type_f(Retained, @"com.apple.cmm.TransformType", 0);
                          if (conv_type_f)
                          {
                            CFStringRef v111 = conv_type_f;
                            if (CFEqual(conv_type_f, @"NULLTransform"))
                            {
                              int v112 = 3;
                            }
                            else if (CFEqual(v111, @"DeviceTransform"))
                            {
                              int v112 = 1;
                            }
                            else
                            {
                              int v112 = 2 * (CFStringHasPrefix(v111, @"RegularTransform.") != 0);
                            }
                            CFRelease(v111);
                          }
                          else
                          {
                            int v112 = 0;
                          }
                          *(_DWORD *)(Instance + 16) = v112;
                          if ((v102 | v105))
                          {
                            *(unsigned char *)(Instance + 224) = 1;
                            int v113 = v117;
                          }
                          else
                          {
                            *(unsigned char *)(Instance + 224) = v93 | v99;
                            int v113 = v117;
                            if (((v93 | v99) & 1) == 0)
                            {
                              CGColorSyncTransformCacheRelease(Retained);
                              if (!v117) {
                                goto LABEL_180;
                              }
                              goto LABEL_179;
                            }
                          }
                          *(void *)(Instance + 88) = Retained;
                          if (!v113)
                          {
LABEL_180:
                            CFRelease(cf);
                            *(void *)(Instance + 56) = convert_icc;
                            *(void *)(Instance + 64) = icc_converter_info;
                            goto LABEL_181;
                          }
LABEL_179:
                          *int v113 = *(_DWORD *)(Instance + 16);
                          goto LABEL_180;
                        }
LABEL_153:
                        int v102 = 0;
                        goto LABEL_154;
                      }
                    }
                    BOOL v93 = 0;
                    if (!a5) {
                      goto LABEL_142;
                    }
                    goto LABEL_144;
                  }
                }
LABEL_74:
                unsigned int v86 = v42;
                if (use_colorsync_for_hdr_from_defaults_predicate != -1) {
                  dispatch_once(&use_colorsync_for_hdr_from_defaults_predicate, &__block_literal_global_28_2095);
                }
                char v87 = use_colorsync_for_hdr_from_defaults_status;
                BOOL v119 = use_colorsync_for_hdr_from_defaults_status != 0;
                if (a5 && CFDictionaryContainsKey(a5, @"kCGConvertColorDataUseColorSyncForHDR") == 1)
                {
                  BOOL v122 = 0;
                  int v88 = CGCFDictionaryGetBoolean(a5, @"kCGConvertColorDataUseColorSyncForHDR", &v122);
                  BOOL v89 = v122;
                  if (!v88) {
                    BOOL v89 = v87;
                  }
                  BOOL v119 = v89;
                }
                if (a2) {
                  goto LABEL_82;
                }
                goto LABEL_86;
              }
            }
          }
        }
      }
      else
      {
        BOOL v116 = 0;
      }
      BOOL v57 = 0;
      goto LABEL_53;
    case 7u:
      if (a2 && (uint64_t v58 = a2[3], (*(_DWORD *)(v58 + 28) - 5) <= 1)) {
        uint64_t v59 = **(void **)(v58 + 96);
      }
      else {
        uint64_t v59 = 0;
      }
      uint64_t Instance = CGCMSConverterCreate(a1, v59, a3, a4, a5, a6);
      if (!Instance) {
        return Instance;
      }
      lookup_table = create_lookup_table((uint64_t)a2, v59, Instance, 0, v77, v78, v79, v80);
      *(void *)(Instance + 216) = lookup_table;
      if (lookup_table)
      {
        if (a2)
        {
          uint64_t v82 = a2[3];
          *(void *)(Instance + 48) = *(void *)(v82 + 48);
          *(void *)(Instance + 56) = convert_indexed;
          *(void *)(Instance + 64) = indexed_converter_info;
          if (*(_DWORD *)(v82 + 28) == 5) {
            int v83 = *(_DWORD *)(*(void *)(v82 + 96) + 8) + 1;
          }
          else {
            int v83 = 0;
          }
          *(_DWORD *)(Instance + 208) = v83;
          CFRetain(a2);
        }
        else
        {
          *(void *)(Instance + 48) = 0;
          *(void *)(Instance + 56) = convert_indexed;
          *(void *)(Instance + 64) = indexed_converter_info;
          *(_DWORD *)(Instance + 208) = 0;
        }
        *(void *)(Instance + 200) = a2;
        goto LABEL_181;
      }
      int v49 = (const void *)Instance;
LABEL_26:
      CFRelease(v49);
      return 0;
    case 8u:
      if (!a2)
      {
        int v85 = (void *)CGCMSConverterCreate(a1, 0, a3, a4, a5, a6);
        uint64_t Instance = (uint64_t)v85;
        if (!v85) {
          return Instance;
        }
        v85[13] = v85[7];
        v85[6] = 0;
        v85[7] = convert_deviceN;
        v85[8] = deviceN_converter_info;
        goto LABEL_124;
      }
      uint64_t v60 = a2[3];
      int v61 = *(_DWORD *)(v60 + 24);
      switch(v61)
      {
        case 6:
          unsigned int v62 = (uint64_t *)(*(void *)(v60 + 96) + 56);
          goto LABEL_120;
        case 10:
          unsigned int v62 = (uint64_t *)(*(void *)(v60 + 96) + 48);
          goto LABEL_120;
        case 8:
          unsigned int v62 = (uint64_t *)(*(void *)(v60 + 96) + 8);
LABEL_120:
          uint64_t v96 = *v62;
          goto LABEL_122;
      }
      uint64_t v96 = 0;
LABEL_122:
      unsigned int v97 = (void *)CGCMSConverterCreate(a1, v96, a3, a4, a5, a6);
      uint64_t Instance = (uint64_t)v97;
      if (!v97) {
        return Instance;
      }
      uint64_t v98 = *(void *)(a2[3] + 48);
      v97[13] = v97[7];
      v97[6] = v98;
      v97[7] = convert_deviceN;
      v97[8] = deviceN_converter_info;
      CFRetain(a2);
LABEL_124:
      *(void *)(Instance + 96) = a2;
LABEL_181:
      *(unsigned char *)(Instance + 80) = a4;
      if (a5) {
        CFTypeRef v114 = CFRetain(a5);
      }
      else {
        CFTypeRef v114 = 0;
      }
      *(void *)(Instance + 72) = v114;
      return Instance;
    case 9u:
      if (a2 && (uint64_t v63 = a2[3], (*(_DWORD *)(v63 + 28) - 5) <= 1)) {
        uint64_t v64 = **(void **)(v63 + 96);
      }
      else {
        uint64_t v64 = 0;
      }
      uint64_t Instance = CGCMSConverterCreate(a1, v64, a3, a4, a5, a6);
      if (!Instance) {
        return Instance;
      }
      goto LABEL_181;
    default:
      return 0;
  }
}

void CGColorSyncTransformCacheRelease(void *a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (CGColorSyncTransformCacheRelease_cglibrarypredicate != -1) {
      dispatch_once(&CGColorSyncTransformCacheRelease_cglibrarypredicate, &__block_literal_global_13_12411);
    }
    if (v2 == CGColorSyncTransformCacheRelease_f())
    {
      if (get_cache_predicate_12371 != -1) {
        dispatch_once(&get_cache_predicate_12371, &__block_literal_global_29_12372);
      }
      if (cache_release_value(*(cache_t **)(get_cache_transform_cache + 64), a1)) {
        CGPostError((uint64_t)"%s: cache_release_value failed", v3, v4, v5, v6, v7, v8, v9, (char)"CGColorSyncTransformCacheRelease");
      }
    }
  }
}

const void *CGColorConversionInfoOptionsSceneReferredToneMappingRequested(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID()) {
      return 0;
    }
    if (CFDictionaryContainsKey((CFDictionaryRef)v1, @"kCGColorConversionInfoOptions") != 1
      || (CFArrayRef result = CFDictionaryGetValue((CFDictionaryRef)v1, @"kCGColorConversionInfoOptions"),
          (uint64_t v1 = result) != 0))
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFDictionaryGetTypeID())
      {
        CFArrayRef result = CFDictionaryGetValue((CFDictionaryRef)v1, @"kCGImageExtendedRangeToneMappingInfo");
        if (!result) {
          return result;
        }
        CFDictionaryRef v4 = (const __CFDictionary *)result;
        CFTypeID v5 = CFGetTypeID(result);
        if (v5 == CFDictionaryGetTypeID()) {
          return (const void *)(CFDictionaryContainsKey(v4, @"kCGApplySceneReferredExtendedRangeToneMapping") != 0);
        }
      }
      return 0;
    }
  }
  return result;
}

CFDictionaryRef CGColorConversionInfoOptionsFlexTRCRequested(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID()) {
      return 0;
    }
    if (CFDictionaryContainsKey(v1, @"kCGColorConversionInfoOptions") == 1)
    {
      CFArrayRef result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"kCGColorConversionInfoOptions");
      CFDictionaryRef v1 = result;
      if (!result) {
        return result;
      }
    }
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 != CFDictionaryGetTypeID()) {
      return 0;
    }
    CFArrayRef result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"kCGApplyFlexTRC");
    if (result)
    {
      CFDictionaryRef v4 = result;
      CFTypeID v5 = CFGetTypeID(result);
      return (const __CFDictionary *)(v5 == CFDictionaryGetTypeID() || v4 == (const __CFDictionary *)*MEMORY[0x1E4F1CFD0]);
    }
  }
  return result;
}

CFDictionaryRef CGColorConversionInfoOptionsFlexLumaRequested(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID()) {
      return 0;
    }
    if (CFDictionaryContainsKey(v1, @"kCGColorConversionInfoOptions") == 1)
    {
      CFArrayRef result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"kCGColorConversionInfoOptions");
      CFDictionaryRef v1 = result;
      if (!result) {
        return result;
      }
    }
    CFTypeID v3 = CFGetTypeID(v1);
    if (v3 != CFDictionaryGetTypeID()) {
      return 0;
    }
    CFArrayRef result = (const __CFDictionary *)CFDictionaryGetValue(v1, @"kCGApplyFlexLumaScaling");
    if (result)
    {
      CFDictionaryRef v4 = result;
      CFTypeID v5 = CFGetTypeID(result);
      return (const __CFDictionary *)(v5 == CFDictionaryGetTypeID() || v4 == (const __CFDictionary *)*MEMORY[0x1E4F1CFD0]);
    }
  }
  return result;
}

const void *CGColorConversionInfoOptionsDisplayReferredToneMappingRequested(const void *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 != CFDictionaryGetTypeID()) {
      return 0;
    }
    if (CFDictionaryContainsKey((CFDictionaryRef)v1, @"kCGColorConversionInfoOptions") != 1
      || (CFArrayRef result = CFDictionaryGetValue((CFDictionaryRef)v1, @"kCGColorConversionInfoOptions"),
          (CFDictionaryRef v1 = result) != 0))
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFDictionaryGetTypeID())
      {
        CFArrayRef result = CFDictionaryGetValue((CFDictionaryRef)v1, @"kCGImageExtendedRangeToneMappingInfo");
        if (!result) {
          return result;
        }
        CFDictionaryRef v4 = (const __CFDictionary *)result;
        CFTypeID v5 = CFGetTypeID(result);
        if (v5 == CFDictionaryGetTypeID()) {
          return (const void *)(CFDictionaryContainsKey(v4, @"kCGApplyDisplayReferredExtendedRangeToneMapping") != 0);
        }
      }
      return 0;
    }
  }
  return result;
}

CFArrayRef CGColorSyncTransformCacheGetRetained(const __CFArray *theArray, const __CFDictionary *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  value_out = 0;
  if (!theArray) {
    return theArray;
  }
  CFArrayRef v3 = theArray;
  if (CGOSAppleInternalBuild_predicate != -1) {
    dispatch_once(&CGOSAppleInternalBuild_predicate, &__block_literal_global_18177);
  }
  if (!CGOSAppleInternalBuild_is_internal) {
    goto LABEL_13;
  }
  if (CGColorSyncTransformCacheGetRetained_predicate != -1) {
    dispatch_once(&CGColorSyncTransformCacheGetRetained_predicate, &__block_literal_global_12369);
  }
  CFDictionaryRef v4 = (CFDictionaryRef)CGColorSyncTransformCacheGetRetained_bundle_options;
  if (CGColorSyncTransformCacheGetRetained_bundle_options)
  {
    if (a2)
    {
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)CGColorSyncTransformCacheGetRetained_bundle_options);
      CFIndex v6 = CFDictionaryGetCount(a2) + Count;
      MEMORY[0x1F4188790]();
      unint64_t v7 = (8 * v6 + 15) & 0xFFFFFFFFFFFFFFF0;
      if ((unint64_t)(8 * v6) >= 0x200) {
        size_t v8 = 512;
      }
      else {
        size_t v8 = 8 * v6;
      }
      bzero((char *)&v19 - v7, v8);
      MEMORY[0x1F4188790]();
      bzero((char *)&v19 - v7, v8);
      CFDictionaryGetKeysAndValues((CFDictionaryRef)CGColorSyncTransformCacheGetRetained_bundle_options, (const void **)((char *)&v19 - v7), (const void **)((char *)&v19 - v7));
      CFDictionaryGetKeysAndValues(a2, (const void **)((char *)&v19 + 8 * Count - v7), (const void **)((char *)&v19 + 8 * Count - v7));
      CFDictionaryRef v4 = CFDictionaryCreate(0, (const void **)((char *)&v19 - v7), (const void **)((char *)&v19 - v7), v6, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFDictionaryRef v9 = v4;
    }
    else
    {
      CFDictionaryRef v9 = 0;
    }
    a2 = v4;
  }
  else
  {
LABEL_13:
    CFDictionaryRef v9 = 0;
  }
  *(_OWORD *)mdouble d = 0u;
  long long v22 = 0u;
  CFIndex v10 = CFArrayGetCount(v3);
  BOOL v11 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v11);
  if (v10 >= 1)
  {
    for (CFIndex i = 0; i != v10; ++i)
    {
      ValueAtIndedouble x = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, i);
      CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)md5_creator_12392, v11);
    }
  }
  if (v11) {
    CC_MD5_Final(md, v11);
  }
  free(v11);
  if (a2)
  {
    CFTypeID v14 = CFGetTypeID(a2);
    if (v14 == CFDictionaryGetTypeID())
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a2, @"kCGColorSyncTransformCacheUUID");
      if (Value)
      {
        long long v22 = *(_OWORD *)CFDataGetBytePtr(Value);
      }
      else
      {
        *(void *)&long long v22 = CGCFDictionaryGetMD5Digest(a2, 0);
        *((void *)&v22 + 1) = v16;
      }
    }
  }
  if (get_cache_predicate_12371 != -1) {
    dispatch_once(&get_cache_predicate_12371, &__block_literal_global_29_12372);
  }
  pthread_mutex_lock((pthread_mutex_t *)get_cache_transform_cache);
  if (get_cache_predicate_12371 != -1) {
    dispatch_once(&get_cache_predicate_12371, &__block_literal_global_29_12372);
  }
  if (cache_get_and_retain(*(cache_t **)(get_cache_transform_cache + 64), md, &value_out))
  {
    if (a2)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CGColorTransformOptionsToColorSyncTransformOptions(Mutable, a2);
      if (CFDictionaryGetCount(Mutable))
      {
LABEL_35:
        if (CGColorSyncTransformCacheGetRetained_cglibrarypredicate != -1) {
          dispatch_once(&CGColorSyncTransformCacheGetRetained_cglibrarypredicate, &__block_literal_global_9_12373);
        }
        Retained_f = (void *)CGColorSyncTransformCacheGetRetained_f(v3, Mutable);
        value_out = Retained_f;
        if (Mutable)
        {
          CFRelease(Mutable);
          Retained_f = value_out;
        }
        if (Retained_f)
        {
          if (get_cache_predicate_12371 != -1) {
            dispatch_once(&get_cache_predicate_12371, &__block_literal_global_29_12372);
          }
          cache_set_and_retain(*(cache_t **)(get_cache_transform_cache + 64), md, value_out, 0);
        }
        goto LABEL_43;
      }
      CFRelease(Mutable);
    }
    Mutable = 0;
    goto LABEL_35;
  }
LABEL_43:
  if (get_cache_predicate_12371 != -1) {
    dispatch_once(&get_cache_predicate_12371, &__block_literal_global_29_12372);
  }
  pthread_mutex_unlock((pthread_mutex_t *)get_cache_transform_cache);
  if (v9) {
    CFRelease(v9);
  }
  return (const __CFArray *)value_out;
}

__CFString *CGColorSpaceGetColorsyncTransformType(void *a1, int a2)
{
  CFArrayRef result = @"ColorSyncTransformDeviceToPCS";
  switch(a2)
  {
    case 0:
    case 3:
      return result;
    case 1:
    case 4:
      int Type = CGColorSpaceGetType(a1);
      CFArrayRef result = @"ColorSyncTransformPCSToDevice";
      if (Type == 6)
      {
        if (*(unsigned char *)(a1[3] + 18)) {
          return @"ColorSyncTransformPCSToSceneLinear";
        }
      }
      return result;
    case 2:
      return @"ColorSyncTransformPCSToPCS";
    case 5:
      return @"ColorSyncTransformDeviceToSceneLinearPCS";
    case 6:
      return @"ColorSyncTransformSceneLinearPCSToDevice";
    case 7:
      if (CGColorSpaceGetType(a1) != 6 || !*(unsigned char *)(a1[3] + 18)) {
        goto LABEL_11;
      }
      CFArrayRef result = @"ColorSyncTransformPCSToSceneLinear";
      break;
    case 8:
      if (CGColorSpaceGetType(a1) == 6 && *(unsigned char *)(a1[3] + 18)) {
        return @"ColorSyncTransformSceneLinearToPCS";
      }
      else {
        return @"ColorSyncTransformDeviceToSceneLinearPCS";
      }
    default:
LABEL_11:
      CFArrayRef result = 0;
      break;
  }
  return result;
}

BOOL linked_on_golden_gate_or_later()
{
  if (linked_on_golden_gate_or_later_predicate != -1) {
    dispatch_once(&linked_on_golden_gate_or_later_predicate, &__block_literal_global_105);
  }
  if (linked_on_golden_gate_or_later_linked_on_golden_gate_or_later) {
    BOOL v0 = 0;
  }
  else {
    BOOL v0 = linked_on_golden_gate_or_later_linked_on_azul_or_later == 0;
  }
  return !v0
      || linked_on_golden_gate_or_later_linked_on_archer_or_later != 0
      || linked_on_golden_gate_or_later_linked_on_borealis_or_later != 0;
}

uint64_t create_conversion_info(const void *a1, const void *a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (create_conversion_info_cglibrarypredicate != -1) {
    dispatch_once(&create_conversion_info_cglibrarypredicate, &__block_literal_global_125);
  }
  if (v4 != create_conversion_info_f()) {
    return 0;
  }
  if (transform_is_null_cglibrarypredicate != -1) {
    dispatch_once(&transform_is_null_cglibrarypredicate, &__block_literal_global_129);
  }
  is_null_f = (const void *)transform_is_null_f(a1, @"com.apple.cmm.TransformType", 0);
  if (is_null_f)
  {
    CFIndex v6 = is_null_f;
    int v7 = CFEqual(is_null_f, @"NULLTransform");
    CFRelease(v6);
    if (v7) {
      return 0;
    }
  }
  if (CGColorConversionInfoGetTypeID_predicate != -1) {
    dispatch_once(&CGColorConversionInfoGetTypeID_predicate, &__block_literal_global_1194);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    *(void *)(Instance + 24) = 0;
    if (a2) {
      CFTypeRef v11 = CFRetain(a2);
    }
    else {
      CFTypeRef v11 = 0;
    }
    *(void *)(v8 + 24) = v11;
  }
  return v8;
}

uint64_t CGColorConversionInfoIterateFunctionsWithCallbacks(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v15 = CFGetTypeID(a1);
  if (CGColorConversionInfoGetTypeID_predicate != -1) {
    dispatch_once(&CGColorConversionInfoGetTypeID_predicate, &__block_literal_global_1194);
  }
  if (v15 != kCGColorConverterRuntimeID) {
    return 0;
  }
  uint64_t v16 = a6;
  ColorSyncTransforuint64_t m = CGColorConversionInfoGetColorSyncTransform(a1);
  CFTypeID v17 = CFGetTypeID(a1);
  if (CGColorConversionInfoGetTypeID_predicate != -1) {
    dispatch_once(&CGColorConversionInfoGetTypeID_predicate, &__block_literal_global_1194);
  }
  if (v17 == kCGColorConverterRuntimeID) {
    CFDictionaryRef v18 = (const __CFDictionary *)a1[3];
  }
  else {
    CFDictionaryRef v18 = 0;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (a2 >= 3) {
    _CGHandleAssert("colorsync_iterator_type", 217, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorConversionInfoIterator.c", "", "Unimplemented", v21, v22, v23, ColorSyncTransform);
  }
  uint64_t v24 = Mutable;
  if (!Mutable)
  {
    if (a7 < 7) {
      goto LABEL_16;
    }
LABEL_23:
    _CGHandleAssert("color_sync_nxm_format", 251, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorConversionInfoIterator.c", "", "Unimplemented", v21, v22, v23, ColorSyncTransform);
  }
  CFDictionarySetValue(Mutable, @"com.apple.cmm.TransformIterationType", off_1E52A0210[a2]);
  if (a7 >= 7) {
    goto LABEL_23;
  }
  CFDictionarySetValue(v24, @"com.apple.cmm.NxMLUTFormat", off_1E52A0228[a7]);
LABEL_16:
  CGCFDictionarySetInteger(v24, @"com.apple.cmm.GridPointCount", a8);
  CGColorTransformOptionsToColorSyncTransformOptions(v24, v18);
  v32[0] = 0;
  v32[1] = v32;
  v32[2] = 0x6800000000;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  memset(v36, 0, sizeof(v36));
  if (CGColorConversionInfoIterateFunctionsWithCallbacks_cglibrarypredicate != -1) {
    dispatch_once(&CGColorConversionInfoIterateFunctionsWithCallbacks_cglibrarypredicate, &__block_literal_global_39);
  }
  v31[0] = MEMORY[0x1E4F143A8];
  v31[1] = 0x40000000;
  v31[2] = __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_2;
  v31[3] = &unk_1E529FF98;
  v31[4] = a3;
  v31[5] = v32;
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 0x40000000;
  v30[2] = __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_3;
  v30[3] = &unk_1E529FFC0;
  v30[4] = a4;
  v30[5] = v32;
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 0x40000000;
  v29[2] = __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_4;
  v29[3] = &unk_1E529FFE8;
  v29[4] = a5;
  v29[5] = v32;
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 0x40000000;
  v28[2] = __CGColorConversionInfoIterateFunctionsWithCallbacks_block_invoke_5;
  v28[3] = &unk_1E52A0010;
  v28[4] = v16;
  v28[5] = v32;
  uint64_t v19 = CGColorConversionInfoIterateFunctionsWithCallbacks_f(ColorSyncTransform, v24, v31, v30, v29, v28);
  if (v24) {
    CFRelease(v24);
  }
  _Block_object_dispose(v32, 8);
  return v19;
}

void CGColorTransformOptionsToColorSyncTransformOptions(__CFDictionary *a1, const __CFDictionary *a2)
{
  if (a2)
  {
    cg_options_to_colorsync_options(a1, a2);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kCGColorConversionInfoOptions");
    cg_options_to_colorsync_options(a1, Value);
  }
}

uint64_t CGColorConversionInfoGetColorSyncTransform(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (CGColorConversionInfoGetTypeID_predicate != -1) {
    dispatch_once(&CGColorConversionInfoGetTypeID_predicate, &__block_literal_global_1194);
  }
  if (v2 == kCGColorConverterRuntimeID) {
    return a1[2];
  }
  else {
    return 0;
  }
}

void CGCFDictionarySetInteger(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  if (a1 && a2)
  {
    CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionarySetValue(a1, a2, v5);
      CFRelease(v6);
    }
  }
}

void cg_options_to_colorsync_options(__CFDictionary *a1, const __CFDictionary *a2)
{
  valuePtr[1] = *(const void **)MEMORY[0x1E4F143B8];
  if (!a1 || !a2) {
    return;
  }
  CFTypeID TypeID = CFBooleanGetTypeID();
  ValueWithint Type = CGCFDictionaryGetValueWithType(a2, @"kCGPQEOTFTable", TypeID);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQEOTFTable", ValueWithType, (CFNumberType)0);
  CFTypeID v6 = CFNumberGetTypeID();
  int v7 = CGCFDictionaryGetValueWithType(a2, @"kCGPQEOTFTableSize", v6);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQEOTFTableSize", v7, kCFNumberSInt32Type);
  CFTypeID v8 = CFBooleanGetTypeID();
  CFDictionaryRef v9 = CGCFDictionaryGetValueWithType(a2, @"kCGPQInvEOTFTable", v8);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQInvEOTFTable", v9, (CFNumberType)0);
  int v10 = CFDictionaryContainsKey(a2, @"kCGHLGEOTFTable");
  CFTypeID v11 = CFBooleanGetTypeID();
  if (v10 == 1) {
    CFArrayRef v12 = @"kCGHLGEOTFTable";
  }
  else {
    CFArrayRef v12 = @"kCGHLGInvOETFTable";
  }
  unsigned int v13 = CGCFDictionaryGetValueWithType(a2, v12, v11);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGInvOETFTable", v13, (CFNumberType)0);
  int v14 = CFDictionaryContainsKey(a2, @"kCGHLGEOTFTableSize");
  CFTypeID v15 = CFNumberGetTypeID();
  if (v14) {
    uint64_t v16 = @"kCGHLGEOTFTableSize";
  }
  else {
    uint64_t v16 = @"kCGHLGInvOETFTableSize";
  }
  CFTypeID v17 = CGCFDictionaryGetValueWithType(a2, v16, v15);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGInvOETFTableSize", v17, kCFNumberSInt32Type);
  CFTypeID v18 = CFBooleanGetTypeID();
  uint64_t v19 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGOETFTable", v18);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGOETFTable", v19, (CFNumberType)0);
  CFTypeID v20 = CFNumberGetTypeID();
  uint64_t v21 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGOOTFGainScale", v20);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGOOTFGainScale", v21, kCFNumberFloatType);
  CFTypeID v22 = CFNumberGetTypeID();
  uint64_t v23 = CGCFDictionaryGetValueWithType(a2, @"kCGPQEOTFOpticalScale", v22);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQEOTFOpticalScale", v23, kCFNumberFloatType);
  CFTypeID v24 = CFNumberGetTypeID();
  uint64_t v25 = CGCFDictionaryGetValueWithType(a2, @"kCGPQInvEOTFOpticalScale", v24);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQInvEOTFOpticalScale", v25, kCFNumberFloatType);
  CFTypeID v26 = CFNumberGetTypeID();
  uint64_t v27 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGInvOETFOpticalScale", v26);
  if (!v27)
  {
    CFTypeID v28 = CFNumberGetTypeID();
    uint64_t v27 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGEOTFOpticalScale", v28);
  }
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGInvOETFOpticalScale", v27, kCFNumberFloatType);
  CFTypeID v29 = CFNumberGetTypeID();
  uint64_t v30 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGOETFOpticalScale", v29);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGOETFOpticalScale", v30, kCFNumberFloatType);
  CFTypeID v31 = CFNumberGetTypeID();
  uint64_t v32 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGSurroundLuminance", v31);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGSurroundLuminance", v32, kCFNumberFloatType);
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"kCGHLGLuminanceCoefficients");
  CFArrayRef v34 = Value;
  if (Value)
  {
    CFTypeID v35 = CFGetTypeID(Value);
    if (v35 == CFArrayGetTypeID())
    {
      if (CFArrayGetCount(v34) > 3)
      {
        CFIndex v43 = 0;
        Mutable = 0;
        *(_OWORD *)keys = 0u;
        long long v135 = 0u;
        while (1)
        {
          ValueAtIndedouble x = (const __CFNumber *)CFArrayGetValueAtIndex(v34, v43);
          if (!ValueAtIndex) {
            break;
          }
          CFNumberRef v52 = ValueAtIndex;
          CFTypeID v53 = CFGetTypeID(ValueAtIndex);
          if (v53 != CFNumberGetTypeID()) {
            break;
          }
          LODWORD(valuePtr[0]) = 0;
          if (!CFNumberGetValue(v52, kCFNumberFloatType, valuePtr))
          {
            CFNumberGetType(v52);
            CGLog(2, (uint64_t)"kCGHLGLuminanceCoefficients has incorrect value type at index %ld type = %s instead of kCFNumberFloatType - rounding errors may occur", v54, v55, v56, v57, v58, v59, v43);
            if (!Mutable)
            {
              Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
              if (!Mutable) {
                goto LABEL_33;
              }
            }
            keys[v43] = CFNumberCreate(0, kCFNumberFloatType, valuePtr);
          }
          if (++v43 == 4)
          {
            if (Mutable)
            {
              for (CFIndex i = 0; i != 4; ++i)
              {
                int v61 = keys[i];
                if (!v61) {
                  int v61 = (void *)CFArrayGetValueAtIndex(v34, i);
                }
                CFArraySetValueAtIndex(Mutable, i, v61);
              }
              CFArrayRef v34 = (const __CFArray *)CFAutorelease(Mutable);
            }
            goto LABEL_33;
          }
        }
        CGLog(2, (uint64_t)"kCGHLGLuminanceCoefficients has a non number value at index %ld - coefficients ignored", v46, v47, v48, v49, v50, v51, v43);
        if (Mutable) {
          CFRelease(Mutable);
        }
LABEL_33:
        for (uint64_t j = 0; j != 4; ++j)
        {
          uint64_t v63 = keys[j];
          if (v63) {
            CFRelease(v63);
          }
        }
        goto LABEL_37;
      }
      unsigned int v42 = "Array count for kCGHLGLuminanceCoefficients is less than 4 - ignored";
    }
    else
    {
      unsigned int v42 = "Value for kCGHLGLuminanceCoefficients is not a CFArray - ignored";
    }
    CGLog(2, (uint64_t)v42, v36, v37, v38, v39, v40, v41, v130);
    CFArrayRef v34 = 0;
  }
LABEL_37:
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGLuminanceCoefficients", v34, (CFNumberType)0);
  uint64_t v64 = CFDictionaryGetValue(a2, @"kCGUseHLGReferenceLuminance");
  sanitize_and_set_options(a1, @"com.apple.cmm.kColorSyncUseHLGReferenceLuminance", v64, (CFNumberType)0);
  CFTypeID v65 = CFBooleanGetTypeID();
  unsigned int v66 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGSkipOOTF", v65);
  sanitize_and_set_options(a1, @"com.apple.cmm.SkipHLGOOTF", v66, (CFNumberType)0);
  CFTypeID v67 = CFBooleanGetTypeID();
  uint64_t v68 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGSkipInvOOTF", v67);
  sanitize_and_set_options(a1, @"com.apple.cmm.SkipInvHLGOOTF", v68, (CFNumberType)0);
  CFTypeID v69 = CFBooleanGetTypeID();
  uint64_t v70 = CGCFDictionaryGetValueWithType(a2, @"kCGPQSkipPQEETF", v69);
  sanitize_and_set_options(a1, @"com.apple.cmm.SkipPQEETF", v70, (CFNumberType)0);
  CFTypeID v71 = CFNumberGetTypeID();
  uint64_t v72 = CGCFDictionaryGetValueWithType(a2, @"kCGPQMasteringDisplayWhite", v71);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQMasteringDisplayWhite", v72, kCFNumberFloatType);
  CFTypeID v73 = CFNumberGetTypeID();
  uint64_t v74 = CGCFDictionaryGetValueWithType(a2, @"kCGPQMasteringDisplayBlack", v73);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQMasteringDisplayBlack", v74, kCFNumberFloatType);
  CFTypeID v75 = CFNumberGetTypeID();
  BOOL v76 = CGCFDictionaryGetValueWithType(a2, @"kCGTargetDisplayWhite", v75);
  sanitize_and_set_options(a1, @"com.apple.cmm.TargetDisplayWhite", v76, kCFNumberFloatType);
  CFTypeID v77 = CFNumberGetTypeID();
  uint64_t v78 = CGCFDictionaryGetValueWithType(a2, @"kCGTargetDisplayBlack", v77);
  sanitize_and_set_options(a1, @"com.apple.cmm.TargetDisplayBlack", v78, kCFNumberFloatType);
  CFTypeID v79 = CFBooleanGetTypeID();
  uint64_t v80 = CGCFDictionaryGetValueWithType(a2, @"kCGSkipToneMappingForBT2100", v79);
  sanitize_and_set_options(a1, @"com.apple.cmm.SkipToneMappingForBT2100", v80, (CFNumberType)0);
  CFTypeID v81 = CFBooleanGetTypeID();
  uint64_t v82 = CGCFDictionaryGetValueWithType(a2, @"kCGApplyToneMappingForBT2100", v81);
  sanitize_and_set_options(a1, @"com.apple.cmm.ApplyToneMappingForBT2100", v82, (CFNumberType)0);
  CFTypeID v83 = CFBooleanGetTypeID();
  uint64_t v84 = CGCFDictionaryGetValueWithType(a2, @"kCGPQEETF3DLut", v83);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQEETF3DLut", v84, (CFNumberType)0);
  CFTypeID v85 = CFNumberGetTypeID();
  unsigned int v86 = CGCFDictionaryGetValueWithType(a2, @"kCGPQEETF3DLutGridPoints", v85);
  sanitize_and_set_options(a1, @"com.apple.cmm.PQEETF3DLutGridPoints", v86, (CFNumberType)0);
  CFTypeID v87 = CFBooleanGetTypeID();
  int v88 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGSceneMapping3DLut", v87);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGSceneMapping3DLut", v88, (CFNumberType)0);
  CFTypeID v89 = CFNumberGetTypeID();
  int v90 = CGCFDictionaryGetValueWithType(a2, @"kCGHLGSceneMapping3DLutGridPoints", v89);
  sanitize_and_set_options(a1, @"com.apple.cmm.HLGSceneMapping3DLutGridPoints", v90, kCFNumberSInt32Type);
  CFTypeID v91 = CFNumberGetTypeID();
  unsigned int v92 = CGCFDictionaryGetValueWithType(a2, @"kCGColorConversionTRCSize", v91);
  sanitize_and_set_options(a1, @"com.apple.cmm.TRCSize", v92, kCFNumberSInt32Type);
  CFTypeID v93 = CFBooleanGetTypeID();
  unint64_t v94 = CGCFDictionaryGetValueWithType(a2, @"kCGApplyYCCGammaScaling", v93);
  sanitize_and_set_options(a1, @"com.apple.cmm.ApplyYCCGammaScaling", v94, kCFNumberFloatType);
  CFTypeID v95 = CFBooleanGetTypeID();
  uint64_t v96 = CGCFDictionaryGetValueWithType(a2, @"kCGApplyLuminanceScaling", v95);
  sanitize_and_set_options(a1, @"com.apple.cmm.ApplyLuminanceScaling", v96, kCFNumberFloatType);
  CFTypeID v97 = CFBooleanGetTypeID();
  uint64_t v98 = CGCFDictionaryGetValueWithType(a2, @"kCGUseBT1886ForCoreVideoGamma", v97);
  sanitize_and_set_options(a1, @"com.apple.ColorSync.BT1886ForCoreVideoGamma", v98, (CFNumberType)0);
  CFTypeID v99 = CFNumberGetTypeID();
  int v100 = CGCFDictionaryGetValueWithType(a2, @"kCGHDRMediaReferenceWhite", v99);
  sanitize_and_set_options(a1, @"com.apple.cmm.kColorSyncHDRMediaReferenceWhite", v100, kCFNumberFloatType);
  CFTypeID v101 = CFBooleanGetTypeID();
  int v102 = CGCFDictionaryGetValueWithType(a2, @"kCGUseLegacyHDREcosystem", v101);
  sanitize_and_set_options(a1, @"com.apple.cmm.UseLegacyHDREcosystem", v102, (CFNumberType)0);
  CFTypeID v103 = CFBooleanGetTypeID();
  uint64_t v104 = CGCFDictionaryGetValueWithType(a2, @"kCGSkipBoostToHDR", v103);
  sanitize_and_set_options(a1, @"com.apple.cmm.SkipBoostToHDR", v104, (CFNumberType)0);
  CFTypeID v105 = CFBooleanGetTypeID();
  uint64_t v106 = CGCFDictionaryGetValueWithType(a2, @"kCGUse100nitsHLGOOTF", v105);
  sanitize_and_set_options(a1, @"com.apple.cmm.Use100nitsHLGOOTF", v106, (CFNumberType)0);
  CFDictionaryRef v107 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kCGApplyReferenceWhiteToneMapping");
  uint64_t v108 = CFDictionaryGetValue(a2, @"kCGApplyFlexTRC");
  uint64_t v109 = CFDictionaryGetValue(a2, @"kCGApplyFlexLumaScaling");
  if (v107)
  {
    CFDictionaryRef ResolveReferenceWhiteToneMappingOptions = CGColorTransformCreateResolveReferenceWhiteToneMappingOptions(v107);
    if (!ResolveReferenceWhiteToneMappingOptions) {
      return;
    }
    CFDictionaryRef v111 = ResolveReferenceWhiteToneMappingOptions;
    CFDictionaryRef colorsync_reference_white_tone_mapping_options = (const __CFDictionary *)create_colorsync_reference_white_tone_mapping_options(ResolveReferenceWhiteToneMappingOptions);
    if (!colorsync_reference_white_tone_mapping_options) {
      goto LABEL_67;
    }
LABEL_40:
    CFDictionaryRef v113 = colorsync_reference_white_tone_mapping_options;
    CFDictionarySetValue(a1, @"com.apple.cmm.ApplyToneMaping", colorsync_reference_white_tone_mapping_options);
    CFDictionaryRef v114 = v113;
LABEL_41:
    CFRelease(v114);
LABEL_67:
    CFRelease(v111);
    return;
  }
  if (v109)
  {
    CFDictionaryRef ResolveFlexLumaOptions = CGColorTransformCreateResolveFlexLumaOptions(v109);
    if (!ResolveFlexLumaOptions) {
      return;
    }
    CFDictionaryRef v111 = ResolveFlexLumaOptions;
    CFTypeID v116 = CFGetTypeID(ResolveFlexLumaOptions);
    if (v116 != CFDictionaryGetTypeID()) {
      goto LABEL_67;
    }
    CFDictionaryRef v117 = (const __CFDictionary *)CFDictionaryGetValue(v111, @"kCGApplyFlexLumaScaling");
    if (!v117) {
      goto LABEL_67;
    }
    CFDictionaryRef v118 = v117;
    CFTypeID v119 = CFGetTypeID(v117);
    if (v119 != CFDictionaryGetTypeID()) {
      goto LABEL_67;
    }
    int v133 = 0;
    if ((get_float_from_dictionary(v118, @"kCGFlexGTCTargetHeadroom", &v133) & 1) == 0) {
      goto LABEL_67;
    }
    keys[0] = @"com.apple.cmm.FlexGTCTargetHeadroom";
    LODWORD(v132) = v133;
    valuePtr[0] = CFNumberCreate(0, kCFNumberFloatType, &v132);
    CFDictionaryRef v120 = CFDictionaryCreate(0, (const void **)keys, valuePtr, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (valuePtr[0]) {
      CFRelease(valuePtr[0]);
    }
    int v121 = @"com.apple.cmm.ApplyFlexLumaScaling";
    goto LABEL_60;
  }
  if (v108)
  {
    CFDictionaryRef ResolveFlexTRCOptions = CGColorTransformCreateResolveFlexTRCOptions(v108);
    if (!ResolveFlexTRCOptions) {
      return;
    }
    CFDictionaryRef v111 = ResolveFlexTRCOptions;
    CFTypeID v123 = CFGetTypeID(ResolveFlexTRCOptions);
    if (v123 != CFDictionaryGetTypeID()) {
      goto LABEL_67;
    }
    CFDictionaryRef v124 = (const __CFDictionary *)CFDictionaryGetValue(v111, @"kCGApplyFlexTRC");
    if (!v124) {
      goto LABEL_67;
    }
    CFDictionaryRef v125 = v124;
    CFTypeID v126 = CFGetTypeID(v124);
    if (v126 != CFDictionaryGetTypeID()) {
      goto LABEL_67;
    }
    int v133 = 0;
    if ((get_float_from_dictionary(v125, @"kCGFlexGTCTargetHeadroom", &v133) & 1) == 0) {
      goto LABEL_67;
    }
    keys[0] = @"com.apple.cmm.FlexGTCTargetHeadroom";
    LODWORD(v132) = v133;
    valuePtr[0] = CFNumberCreate(0, kCFNumberFloatType, &v132);
    CFDictionaryRef v120 = CFDictionaryCreate(0, (const void **)keys, valuePtr, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (valuePtr[0]) {
      CFRelease(valuePtr[0]);
    }
    int v121 = @"com.apple.cmm.ApplyFlexTRC";
LABEL_60:
    values = v120;
    int v132 = v121;
    CFDictionaryRef v127 = CFDictionaryCreate(0, (const void **)&v132, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v120) {
      CFRelease(v120);
    }
    if (!v127) {
      goto LABEL_67;
    }
    CFDictionarySetValue(a1, @"com.apple.cmm.ApplyToneMaping", v127);
    CFDictionaryRef v114 = v127;
    goto LABEL_41;
  }
  CFDictionaryRef v128 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"kCGImageExtendedRangeToneMappingInfo");
  if (v128)
  {
    CFDictionaryRef ResolveExtendedRangeToneMappingOptions = CGColorTransformCreateResolveExtendedRangeToneMappingOptions(v128);
    if (ResolveExtendedRangeToneMappingOptions)
    {
      CFDictionaryRef v111 = ResolveExtendedRangeToneMappingOptions;
      CFDictionaryRef colorsync_reference_white_tone_mapping_options = create_colorsync_extended_range_tone_mapping_options(ResolveExtendedRangeToneMappingOptions);
      if (!colorsync_reference_white_tone_mapping_options) {
        goto LABEL_67;
      }
      goto LABEL_40;
    }
  }
}

void sanitize_and_set_options(__CFDictionary *a1, const void *a2, const void *a3, CFNumberType a4)
{
  if (a3 && !CFDictionaryContainsKey(a1, a2))
  {
    if (a4)
    {
      if (a4 != kCFNumberSInt32Type && a4 != kCFNumberFloatType) {
        _CGHandleAssert("sanitize_and_set_options", 1384, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransform.c", "type == kCFNumberFloatType || type == kCFNumberSInt32Type || type == (CFNumberType)0", "Unexpected number type to verify", v8, v9, v10, v33);
      }
      CFTypeID v11 = CFGetTypeID(a3);
      if (v11 != CFNumberGetTypeID())
      {
        CGLog(2, (uint64_t)"Value for %@ is not a number - ignored", v12, v13, v14, v15, v16, v17, (char)a2);
        return;
      }
      int valuePtr = 0;
      int Value = CFNumberGetValue((CFNumberRef)a3, a4, &valuePtr);
      if (a4 == kCFNumberSInt32Type && valuePtr < 0)
      {
        CGLog(2, (uint64_t)"Value for %@ is negative - ignored", v19, v20, v21, v22, v23, v24, (char)a2);
        return;
      }
      if (!Value)
      {
        CFNumberGetType((CFNumberRef)a3);
        CGLog(2, (uint64_t)"%@ has unsupported value type = %s instead of %s - errors may occur", v25, v26, v27, v28, v29, v30, (char)a2);
        CFNumberRef v31 = CFNumberCreate(0, a4, &valuePtr);
        CFNumberRef v32 = v31;
        if (a1 && a2 && v31)
        {
          CFDictionarySetValue(a1, a2, v31);
        }
        else if (!v31)
        {
          return;
        }
        CFRelease(v32);
        return;
      }
      if (a1)
      {
        if (a2) {
          CFDictionarySetValue(a1, a2, a3);
        }
      }
    }
    else if (a1 && a2)
    {
      CFDictionarySetValue(a1, a2, a3);
    }
  }
}

const void *CGCFDictionaryGetValueWithType(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  CFArrayRef result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFNumberRef v5 = result;
    if (CFGetTypeID(result) == a3) {
      return v5;
    }
    else {
      return 0;
    }
  }
  return result;
}

double CGContextGetEDRTargetHeadroom(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    LODWORD(result) = *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 120) + 48);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetEDRTargetHeadroom", a1, a3, a4, a5, a6, a7, a8);
    return 0.0;
  }
  return result;
}

uint64_t copy_table_tags(uint64_t a1)
{
  return MEMORY[0x1F4119C10](*(void *)(a1 + 8));
}

BOOL color_equal(CGColor *a1, CGColor *a2)
{
  return CGColorEqualToColor(a1, a2);
}

CGContextRef CGBitmapContextCreateWithCallbacks(size_t a1, size_t a2, const void *a3, const void *a4, const void *a5, const void *a6, CFTypeRef cf, uint64_t a8)
{
  if (useDebugBitmap_predicate != -1) {
    dispatch_once(&useDebugBitmap_predicate, &__block_literal_global_8541);
  }
  if (useDebugBitmap_use_bitmap)
  {
    uint64_t v15 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
    return CGBitmapContextCreateWithData(0, a1, a2, 8uLL, 0, v15, 1u, 0, 0);
  }
  if (!cf || (CFTypeID v17 = CFGetTypeID(cf), v17 == CFDictionaryGetTypeID()))
  {
    if (a1 - 0x80000000 >= 0xFFFFFFFF80000001 && a2 - 0x80000000 >= 0xFFFFFFFF80000001)
    {
      CFTypeID v18 = (int64x2_t *)malloc_type_calloc(1uLL, 0x48uLL, 0x10E00409E4AD1ABuLL);
      if (v18)
      {
        uint64_t v19 = (uint64_t)v18;
        v18->i64[0] = a1;
        v18->i64[1] = a2;
        v18[1] = vdupq_n_s64(0x4052000000000000uLL);
        v18[2].i64[0] = (uint64_t)_Block_copy(a3);
        *(void *)(v19 + 40) = _Block_copy(a4);
        *(void *)(v19 + 48) = _Block_copy(a5);
        *(void *)(v19 + 56) = _Block_copy(a6);
        if (cf) {
          CFTypeRef v22 = CFRetain(cf);
        }
        else {
          CFTypeRef v22 = 0;
        }
        *(void *)(v19 + 64) = v22;
        uint64_t v23 = (void *)CGContextCreateWithDelegateAndInfo(0, 9, 0, 0, v19, (uint64_t)automatic_bitmap_context_context_finalize, v20, v21);
        if (!v23)
        {
          CGPostError((uint64_t)"%s: failed to create Automatic context.", v24, v25, v26, v27, v28, v29, v30, (char)"CGBitmapContextCreateWithCallbacks");
          automatic_bitmap_context_info_release(v19, v73, v74, v75, v76, v77, v78, v79);
          return (CGContextRef)v23;
        }
        long long v82 = *(_OWORD *)(v19 + 32);
        long long v83 = *(_OWORD *)(v19 + 48);
        CFDictionaryRef v31 = *(const __CFDictionary **)(v19 + 64);
        CFDictionaryRef v84 = v31;
        uint64x2_t v80 = *(uint64x2_t *)v19;
        long long v81 = *(_OWORD *)(v19 + 16);
        LODWORD(v85[0]) = 0;
        if (CGCFDictionaryGetInteger(v31, @"kCGAutoBitDepthMax", v85)) {
          int v32 = v85[0];
        }
        else {
          int v32 = 5;
        }
        CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        v85[0] = 0;
        v85[1] = 0;
        float64x2_t v86 = vcvtq_f64_u64(*(uint64x2_t *)v19);
        uint64_t CGDisplayList = CG::DisplayList::createCGDisplayList(0, (const __CFDictionary *)v85, v34, v35, v36, v37, v38, v39);
        if (CGDisplayList)
        {
          uint64_t v48 = (const void *)CGDisplayList;
          uint64_t v49 = CGDisplayListContextCreate(CGDisplayList, v41, v42, v43, v44, v45, v46, v47);
          if (v49)
          {
            uint64_t v57 = (const void *)v49;
            CGContextErase(v49, v50, v51, v52, v53, v54, v55, v56);
            uint64_t v58 = (char *)malloc_type_calloc(1uLL, 0x138uLL, 0x10E00403573DA66uLL);
            if (v58)
            {
              uint64_t v59 = (uint64_t)v58;
              *((_OWORD *)v58 + 2) = v82;
              *((_OWORD *)v58 + 3) = v83;
              *(uint64x2_t *)uint64_t v58 = v80;
              *((_OWORD *)v58 + 1) = v81;
              *((void *)v58 + 8) = v84;
              *((void *)v58 + 9) = v48;
              *((void *)v58 + 10) = v57;
              *((void *)v58 + 11) = 0;
              *((_DWORD *)v58 + 24) = v32;
              *(void *)(v58 + 100) = 0;
              *((_DWORD *)v58 + 27) = 1;
              *((void *)v58 + 14) = 850045863;
              *(_OWORD *)(v58 + 152) = 0u;
              *(_OWORD *)(v58 + 136) = 0u;
              *(_OWORD *)(v58 + 120) = 0u;
              *((void *)v58 + 21) = 0;
              *((void *)v58 + 22) = Mutable;
              *(_OWORD *)(v58 + 248) = 0u;
              *(_OWORD *)(v58 + 232) = 0u;
              *(_OWORD *)(v58 + 216) = 0u;
              *(_OWORD *)(v58 + 200) = 0u;
              *(_OWORD *)(v58 + 184) = 0u;
              *(_OWORD *)(v58 + 280) = 0u;
              *(_OWORD *)(v58 + 296) = 0u;
              *(_OWORD *)(v58 + 264) = 0u;
              pthread_mutex_init((pthread_mutex_t *)(v58 + 112), 0);
              CFTypeID v67 = (void *)CGContextDelegateCreate(v59, v60, v61, v62, v63, v64, v65, v66);
              CGContextDelegateSetCallbacks(v67, (uint64_t)&RIPAutomaticContextDelegateCreate_callbacks, 19, v68, v69, v70, v71, v72);
              v23[5] = v67;
              if (v67) {
                return (CGContextRef)v23;
              }
              goto LABEL_30;
            }
            CFRelease(v48);
          }
          else
          {
            uint64_t v57 = v48;
          }
          CFRelease(v57);
        }
        v23[5] = 0;
LABEL_30:
        CGPostError((uint64_t)"%s: failed to create delegate.", v41, v42, v43, v44, v45, v46, v47, (char)"CGBitmapContextCreateWithCallbacks");
        CFRelease(v23);
        return 0;
      }
    }
  }
  CGPostError((uint64_t)"%s: failed to create CGAutomaticBitmapContextInfo.", a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)cf, a8, (char)"CGBitmapContextCreateWithCallbacks");
  return 0;
}

uint64_t CGDisplayListContextCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (CGContextCreateWithDelegateAndInfo(0, 0, 0, 0, 0, 0, a7, a8)) {
      CG::DisplayList::createContextDelegate();
    }
    CGPostError((uint64_t)"Unable to create display list context", v8, v9, v10, v11, v12, v13, v14, v16);
  }
  return 0;
}

void CG::DisplayList::createContextDelegate()
{
}

void sub_184C1DD1C(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0xA1C409BE6959DLL);
  _Unwind_Resume(a1);
}

void *CG::DisplayListRecorder::initializeDelegateCallbacks(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CGContextDelegateSetCallbacks(a2, (uint64_t)&CG::DisplayListRecorder::initializeDelegateCallbacks(CGContextDelegate *)::callbacks, 23, a4, a5, a6, a7, a8);
}

void CGContextResetState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStackReset(*(uint64_t **)(a1 + 104));
      uint64_t v9 = *(void *)(a1 + 104);
      uint64_t v10 = *(void *)(v9 + 8);
      if (v10 == v9)
      {
        uint64_t v11 = CGGStateCreate();
        uint64_t v12 = *(char ***)(v9 + 8);
        *(void *)(v9 + 8) = v11;
        *(void *)uint64_t v11 = v9;
        *uint64_t v12 = v11;
        *((void *)v11 + 1) = v12;
        uint64_t v10 = *(void *)(v9 + 8);
      }
      *(void *)(a1 + 96) = v10;
      CGRenderingStateReset(*(void *)(a1 + 112));
      *(CGAffineTransform *)(a1 + 120) = CGAffineTransformIdentity;
      uint64_t v13 = *(const void **)(a1 + 168);
      if (v13) {
        CFRelease(v13);
      }
      *(void *)(a1 + 168) = 0;
      return;
    }
    uint64_t v14 = a1;
  }
  else
  {
    uint64_t v14 = 0;
  }

  handle_invalid_context((char)"CGContextResetState", v14, a3, a4, a5, a6, a7, a8);
}

void *bitmap_context_create(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = CGContextCreateWithDelegateAndInfo(0, 4, 0, 0, a1, (uint64_t)bitmap_context_finalize, a7, a8);
  uint64_t v19 = (void *)v11;
  if (v11)
  {
    uint64_t v20 = *(void *)(v11 + 112);
    double v21 = *(double *)(a1 + 48);
    double v22 = *(double *)(a1 + 56);
    double v23 = 432.0;
    if (v21 <= 432.0) {
      double v23 = *(double *)(a1 + 48);
    }
    if (v21 >= 72.0) {
      double v24 = v23;
    }
    else {
      double v24 = 72.0;
    }
    double v25 = 432.0;
    if (v22 <= 432.0) {
      double v25 = *(double *)(a1 + 56);
    }
    if (v22 >= 72.0) {
      double v26 = v25;
    }
    else {
      double v26 = 72.0;
    }
    *(double *)(v20 + 8) = v24;
    *(double *)(v20 + 16) = v26;
    unsigned int v27 = *(_DWORD *)(a1 + 96);
    int v28 = v27 | ~(-1 << -(char)__clz(v27));
    if (v27 >= 2) {
      LOBYTE(v27) = v28;
    }
    *(_DWORD *)(v20 + 4) = v27 & 3;
    uint64_t v29 = bitmap_context_delegate_create(a1, a2);
    v19[5] = v29;
    if (!v29)
    {
      CGPostError((uint64_t)"%s: failed to create delegate.", v30, v31, v32, v33, v34, v35, v36, a3);
      CFRelease(v19);
      return 0;
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: failed to create bitmap context.", v12, v13, v14, v15, v16, v17, v18, a3);
    CGBitmapContextInfoRelease(a1);
  }
  return v19;
}

uint64_t CGContextCreateWithDelegateAndInfo(const void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_block_invoke_once_15273 != -1) {
    dispatch_once(&_block_invoke_once_15273, &__block_literal_global_5_15274);
  }
  uint64_t Instance = CGTypeCreateInstance(CGContextGetTypeID_type_id, 168, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = 1129601108;
    *(_DWORD *)(Instance + 20) = atomic_fetch_add_explicit(CGContextCreateWithDelegateAndInfo_unique_identifier, 1u, memory_order_relaxed)+ 1;
    *(_DWORD *)(Instance + 24) = a2;
    *(_DWORD *)(Instance + 88) = 0;
    *(void *)(Instance + 64) = 0;
    *(void *)(Instance + 72) = 0;
    if (a3) {
      Copdouble y = CGRenderingStateCreateCopy(a3);
    }
    else {
      Copdouble y = CGRenderingStateCreate();
    }
    *(void *)(v15 + 112) = Copy;
    if (Copy)
    {
      uint64_t v17 = CGGStackCreateWithGState(a4);
      *(void *)(v15 + 104) = v17;
      double v24 = (void *)v17[1];
      if (v24 == v17)
      {
        double v25 = v17;
        double v26 = CGGStateCreate();
        unsigned int v27 = (char **)v25[1];
        v25[1] = v26;
        *(void *)double v26 = v25;
        *unsigned int v27 = v26;
        *((void *)v26 + 1) = v27;
        double v24 = (void *)v25[1];
      }
      *(void *)(v15 + 96) = v24;
      *(CGAffineTransform *)(v15 + 120) = CGAffineTransformIdentity;
      *(void *)(v15 + 168) = 0;
      if (a1) {
        CGContextSetDelegate(v15, a1, v18, v19, v20, v21, v22, v23);
      }
      *(void *)(v15 + 32) = a5;
      *(void *)(v15 + 48) = a6;
    }
    else
    {
      CFRelease((CFTypeRef)v15);
      return 0;
    }
  }
  return v15;
}

void *CGGStackCreateWithGState(uint64_t a1)
{
  CFTypeID v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xA3729uLL);
  *CFTypeID v2 = v2;
  v2[1] = v2;
  if (a1) {
    Copdouble y = CGGStateCreateCopy(a1);
  }
  else {
    Copdouble y = CGGStateCreate();
  }
  CFTypeID v4 = (char **)v2[1];
  *(void *)Copdouble y = v2;
  *CFTypeID v4 = Copy;
  v2[1] = Copy;
  *((void *)Copy + 1) = v4;
  return v2;
}

char *CGGStateCreate()
{
  BOOL v0 = (char *)malloc_type_calloc(1uLL, 0x98uLL, 0xA3729uLL);
  *(void *)BOOL v0 = v0;
  *((void *)v0 + 1) = v0;
  *((_DWORD *)v0 + 4) = 1;
  *(CGAffineTransform *)(v0 + 24) = CGAffineTransformIdentity;
  CGGStateClipReset((uint64_t)v0);
  CGGStateReset((uint64_t)v0);
  return v0;
}

CGFloat CGGStateClipReset(uint64_t a1)
{
  CGClipStackRelease(*(void **)(a1 + 112));
  CFTypeID v2 = (char *)malloc_type_malloc(0x98uLL, 0x2062DE7BuLL);
  *(_DWORD *)CFTypeID v2 = 1;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 2) = 0;
  CGFloat result = CGRectInfinite.origin.x;
  *(CGRect *)(v2 + 48) = CGRectInfinite;
  *(CGRect *)(v2 + 80) = CGRectInfinite;
  *(CGRect *)(v2 + 16) = CGRectInfinite;
  *((void *)v2 + 15) = 0;
  *((void *)v2 + 16) = 0;
  *((void *)v2 + 14) = 3;
  *(void *)(a1 + 112) = v2;
  *(CGRect *)(a1 + 80) = CGRectInfinite;
  *(unsigned char *)(a1 + 20) &= ~1u;
  return result;
}

_DWORD *CGRenderingStateCreate()
{
  BOOL v0 = malloc_type_malloc(0x58uLL, 0x2062DE7BuLL);
  uint64_t v1 = v0;
  if (v0)
  {
    _DWORD *v0 = 1;
    CGRenderingStateReset((uint64_t)v0);
  }
  return v1;
}

void CGRenderingStateReset(uint64_t a1)
{
  *(int64x2_t *)(a1 + 8) = vdupq_n_s64(0x4052000000000000uLL);
  *(CGAffineTransform *)(a1 + 24) = CGAffineTransformIdentity;
  *(void *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 85) = 257;
  *(_DWORD *)(a1 + 80) = 16843009;
  if (once != -1) {
    dispatch_once_f(&once, 0, (dispatch_function_t)get_font_rendering_defaults);
  }
  *(unsigned char *)(a1 + 84) = allows_font_smoothing;
  *(_DWORD *)(a1 + 4) = 3;
}

uint64_t bitmap_context_delegate_create(uint64_t a1, uint64_t a2)
{
  if (bitmap_context_delegate_create_once != -1) {
    dispatch_once_f(&bitmap_context_delegate_create_once, 0, (dispatch_function_t)load_bitmap_context_delegate_create);
  }
  CFTypeID v4 = (uint64_t (*)(uint64_t, uint64_t))creator;
  if (!creator) {
    return 0;
  }

  return v4(a1, a2);
}

void CGContextSetDelegate(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CFTypeRef v10 = *(CFTypeRef *)(a1 + 40);
      if (v10 != cf)
      {
        if (cf)
        {
          CFRetain(cf);
          CFTypeRef v10 = *(CFTypeRef *)(a1 + 40);
        }
        if (v10) {
          CFRelease(v10);
        }
        *(void *)(a1 + 40) = cf;
      }
      return;
    }
    uint64_t v11 = a1;
  }
  else
  {
    uint64_t v11 = 0;
  }

  handle_invalid_context((char)"CGContextSetDelegate", v11, a3, a4, a5, a6, a7, a8);
}

uint64_t __CGBitmapContextDelegateData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    uint64_t v9 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v9 = 0;
  }
  signed int v10 = *(_DWORD *)(a2 + 24);
  int v11 = *(_DWORD *)(a2 + 28);
  signed int v54 = v10;
  LODWORD(v55) = v11;
  unint64_t v12 = *(void *)(a2 + 8);
  unint64_t v13 = *(void *)(a2 + 16);
  if (v12 >> 31) {
    BOOL v14 = 0;
  }
  else {
    BOOL v14 = v13 >> 31 == 0;
  }
  if (!v14
    || ((HIDWORD(v55) = *(void *)(a2 + 8), int v56 = v13, v10 <= (int)(v12 ^ 0x7FFFFFFF))
      ? (BOOL v15 = v11 <= (int)(v13 ^ 0x7FFFFFFF))
      : (BOOL v15 = 0),
        !v15 || *(void *)(a2 + 88) >> 31))
  {
    char v53 = v10;
    uint64_t v37 = "Unsupported dimensions - %d x, %d y, %lu width, %lu height, %lu bytes-per-row";
LABEL_24:
    CGPostError((uint64_t)v37, a2, a3, a4, a5, a6, a7, a8, v53);
    return 0;
  }
  char v58 = 0;
  long long v57 = 0uLL;
  unsigned int v16 = RIPGetLayerFormat(a2, &v58);
  dispatch_once_t v24 = RIPGetDepthForLayerFormat(v16, v17, v18, v19, v20, v21, v22, v23);
  if (!v24)
  {
    uint64_t v40 = *(void *)(a2 + 32);
    if (v40) {
      uint64_t v40 = *(void *)(*(void *)(v40 + 24) + 48);
    }
    CGPostError((uint64_t)"Unsupported pixel description - %lu components, %lu bits-per-component, %lu bits-per-pixel", v25, v26, v27, v28, v29, v30, v31, v40);
    return 0;
  }
  if (v58) {
    uint64_t v32 = 1;
  }
  else {
    uint64_t v32 = 16;
  }
  uint64_t v33 = *(void *)(a2 + 64);
  if (v33 && (uint64_t v34 = *(void *)(a2 + 88)) != 0)
  {
    if (*(void *)(a2 + 128))
    {
      uint64_t v35 = *(unsigned int *)(a2 + 136);
      uint64_t v36 = *(void *)(a2 + 120);
    }
    else
    {
      uint64_t v35 = 0;
      uint64_t v36 = 0;
    }
    uint64_t v39 = RIPLayerCreateWithData((uint64_t *)&v54, v32 | 2, v24, v34, v33, v35, v36, *(unsigned int *)(a2 + 96));
  }
  else
  {
    uint64_t v39 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v54, v32, v24, *(unsigned int *)(a2 + 96), v29, v30, v31);
  }
  uint64_t v41 = v39;
  if (!v39)
  {
    uint64_t v37 = "Unable to create bitmap delegate device";
    goto LABEL_24;
  }
  uint64_t v42 = *(void **)(v9 + 88);
  if (v42)
  {
    do
    {
      uint64_t v43 = v42;
      uint64_t v42 = (void *)*v42;
    }
    while (v42);
    uint64_t v44 = (char **)(v43 + 4);
    if ((*(unsigned int (**)(void, long long *))(*(void *)v43[4] + 72))(v43[4], &v57)
      && v57 == v54
      && *(void *)((char *)&v57 + 4) == v55
      && HIDWORD(v57) == v56)
    {
      goto LABEL_48;
    }
    uint64_t v45 = (void **)(v43 + 5);
  }
  else
  {
    uint64_t v44 = (char **)(v9 + 48);
    if ((*(unsigned int (**)(void, long long *))(**(void **)(v9 + 48) + 72))(*(void *)(v9 + 48), &v57)&& v57 == v54&& *(void *)((char *)&v57 + 4) == v55&& HIDWORD(v57) == v56)
    {
      goto LABEL_48;
    }
    uint64_t v45 = (void **)(v9 + 72);
  }
  ripc_ReleaseClipState(v45);
LABEL_48:
  if (*v44) {
    (*(void (**)(char *))(*(void *)*v44 + 24))(*v44);
  }
  *uint64_t v44 = v41;
  if (a2) {
    atomic_fetch_add_explicit((atomic_uint *volatile)a2, 1u, memory_order_relaxed);
  }
  CGBitmapContextInfoRelease(*(void *)(v9 + 8));
  *(void *)(v9 + 8) = a2;
  *(_DWORD *)(v9 + 216) = ripc_component_type_from_info(a2, v46, v47, v48, v49, v50, v51, v52);
  return 1;
}

CFTypeRef __CGBitmapContextDelegateCreate(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v59 = 0;
  signed int v9 = *(_DWORD *)(a1 + 24);
  int v10 = *(_DWORD *)(a1 + 28);
  unint64_t v56 = __PAIR64__(v10, v9);
  unint64_t v11 = *(void *)(a1 + 8);
  unint64_t v12 = *(void *)(a1 + 16);
  if (v11 >> 31) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = v12 >> 31 == 0;
  }
  if (!v13
    || ((int v57 = *(void *)(a1 + 8), v58 = v12, v9 <= (int)(v11 ^ 0x7FFFFFFF))
      ? (BOOL v14 = v10 <= (int)(v12 ^ 0x7FFFFFFF))
      : (BOOL v14 = 0),
        !v14 || *(void *)(a1 + 88) >> 31))
  {
    char v54 = v9;
    uint64_t v40 = "Unsupported dimensions - %d x, %d y, %lu width, %lu height, %lu bytes-per-row";
LABEL_22:
    CGPostError((uint64_t)v40, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v54);
    return 0;
  }
  unsigned int v16 = RIPGetLayerFormat(a1, &v59);
  dispatch_once_t v24 = RIPGetDepthForLayerFormat(v16, v17, v18, v19, v20, v21, v22, v23);
  if (!v24)
  {
    uint64_t v42 = *(void *)(a1 + 32);
    if (v42) {
      uint64_t v42 = *(void *)(*(void *)(v42 + 24) + 48);
    }
    CGPostError((uint64_t)"Unsupported pixel description - %lu components, %lu bits-per-component, %lu bits-per-pixel", v25, v26, v27, v28, v29, v30, v31, v42);
    return 0;
  }
  uint64_t v32 = v24;
  uint64_t v33 = ripc_Initialize();
  if (!v33)
  {
    uint64_t v40 = "Failed to create bitmap context delegate";
    goto LABEL_22;
  }
  uint64_t v34 = v33;
  if (v59) {
    uint64_t v35 = 17;
  }
  else {
    uint64_t v35 = 16;
  }
  uint64_t v36 = *(void *)(a1 + 64);
  if (v36 && (uint64_t v37 = *(void *)(a1 + 88)) != 0)
  {
    if (*(void *)(a1 + 128))
    {
      uint64_t v38 = *(unsigned int *)(a1 + 136);
      uint64_t v39 = *(void *)(a1 + 120);
    }
    else
    {
      uint64_t v38 = 0;
      uint64_t v39 = 0;
    }
    uint64_t v43 = RIPLayerCreateWithData((uint64_t *)&v56, v35 | 2, v32, v37, v36, v38, v39, *(unsigned int *)(a1 + 96));
  }
  else
  {
    uint64_t v43 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v56, v35, v32, *(unsigned int *)(a1 + 96), a6, a7, a8);
  }
  *((void *)v34 + 6) = v43;
  if (!v43)
  {
    if (*(void *)v34) {
      CFRelease(*(CFTypeRef *)v34);
    }
    uint64_t v40 = "Unable to create bitmap delegate device";
    goto LABEL_22;
  }
  uint64_t v44 = *(CGColorSpace **)(a1 + 32);
  if (!v44)
  {
    uint64_t v46 = *((void *)v34 + 25);
    if (!v46)
    {
      *((void *)v34 + 2) = 0;
      goto LABEL_45;
    }
    CFRetain(*((CFTypeRef *)v34 + 25));
    *((void *)v34 + 2) = v46;
LABEL_41:
    uint64_t v55 = 0x3FF0000000000000;
    if (CGCFDictionaryGetFloat(a2, @"kCGContextDeviceScale", &v55)) {
      *((void *)v34 + 5) = v55;
    }
    *(_OWORD *)(v34 + 24) = *(_OWORD *)(a1 + 48);
    atomic_fetch_add_explicit((atomic_uint *volatile)a1, 1u, memory_order_relaxed);
    *((void *)v34 + 1) = a1;
    *((_DWORD *)v34 + 54) = ripc_component_type_from_info(a1, v47, v48, v49, v50, v51, v52, v53);
    return *(CFTypeRef *)v34;
  }
  uint64_t v45 = color_transform_create(v44, a2);
  *((void *)v34 + 2) = v45;
  if (v45) {
    goto LABEL_41;
  }
LABEL_45:
  CGPostError((uint64_t)"Failed to create bitmap context color transform", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v54);
  CFTypeRef result = *(CFTypeRef *)v34;
  if (*(void *)v34)
  {
    CFRelease(result);
    return 0;
  }
  return result;
}

char *RIPLayerCreateWithData(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a8;
  uint64_t v9 = a7;
  int v10 = a6;
  int v12 = a4;
  BOOL v13 = (int *)a3;
  char v14 = a2;
  if (a1)
  {
    int v15 = *((_DWORD *)a1 + 2);
    if (v15 < 0) {
      return 0;
    }
    int v16 = *((_DWORD *)a1 + 3);
    if (v16 < 0) {
      return 0;
    }
    uint64_t v17 = *a1;
  }
  else
  {
    int v15 = 0;
    int v16 = 0;
    uint64_t v17 = 0;
  }
  uint64_t v30 = v17;
  if (!a3) {
    BOOL v13 = (int *)RIPGetDepthForLayerFormat(0, a2, 0, a4, a5, a6, a7, a8);
  }
  if (v13 != (int *)RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8))
  {
    if (a5)
    {
      if (v10) {
        BOOL v18 = v9 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      char v19 = v18;
      int v29 = v12;
      if ((v14 & 1) != 0 || (v19 & 1) == 0)
      {
        int v20 = (*v13 >> 2) & 3;
        if (v20 != 1)
        {
          int v10 = v12;
          uint64_t v9 = a5;
          if (v20 != 2)
          {
            int v10 = 0;
            uint64_t v9 = 0;
          }
        }
      }
      int v21 = v8;
      int v22 = initialize_deep_mask(v13) | v14 & 0x3E;
      if (v13[4]) {
        int v23 = v22 | 0x200;
      }
      else {
        int v23 = v22;
      }
      goto LABEL_26;
    }
    return 0;
  }
  int v29 = v12;
  int v21 = v8;
  int v23 = v14 & 0x3E;
LABEL_26:
  if ((v23 & 0x10) != 0) {
    size_t v25 = 440;
  }
  else {
    size_t v25 = 144;
  }
  uint64_t v26 = (char *)malloc_type_calloc(1uLL, v25, 0x44405ADEuLL);
  dispatch_once_t v24 = v26;
  *(void *)uint64_t v26 = RIPLayer_ripl_class;
  *((_DWORD *)v26 + 2) = 1;
  *((_DWORD *)v26 + 6) = v16;
  *((_DWORD *)v26 + 7) = v23;
  *(void *)(v26 + 12) = v30;
  *((_DWORD *)v26 + 5) = v15;
  uint64_t v27 = v26 + 144;
  if ((v23 & 0x10) == 0) {
    uint64_t v27 = 0;
  }
  *((void *)v26 + 4) = v13;
  *((void *)v26 + 5) = v27;
  *((_DWORD *)v26 + 12) = v29;
  *((_DWORD *)v26 + 13) = v21;
  *((void *)v26 + 7) = a5;
  *((_DWORD *)v26 + 16) = v10;
  *((void *)v26 + 9) = v9;
  pthread_mutex_init((pthread_mutex_t *)(v26 + 80), 0);
  return v24;
}

uint64_t ripc_component_type_from_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8 <= 9)
  {
    if (v8 != 5 && v8 != 8) {
      goto LABEL_19;
    }
    return 1;
  }
  else if (v8 == 32)
  {
    if ((*(unsigned char *)(a1 + 41) & 1) == 0) {
      goto LABEL_19;
    }
    return 4;
  }
  else
  {
    if (v8 != 16)
    {
      if (v8 == 10 && *(void *)(a1 + 72) == 32) {
        return 5;
      }
LABEL_19:
      _CGHandleAssert("ripc_component_type_from_info", 47, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPBitmapContext.c", "", "Unimplemented", a6, a7, a8, vars0);
    }
    if (*(unsigned char *)(a1 + 41)) {
      return 5;
    }
    else {
      return 2;
    }
  }
}

uint64_t RIPGetLayerFormat(uint64_t a1, unsigned char *a2)
{
  int v3 = *(_DWORD *)(a1 + 40);
  *a2 = 0;
  int v4 = v3 & 0x7000;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    uint64_t result = 0xFFFFFFFFLL;
    switch(*(void *)(*(void *)(v5 + 24) + 48))
    {
      case 0:
        goto LABEL_3;
      case 1:
        uint64_t v11 = *(void *)(a1 + 128);
        uint64_t v12 = *(void *)(a1 + 80);
        if (!v11) {
          goto LABEL_27;
        }
        if (v11 != v12) {
          return result;
        }
        *a2 = 1;
        uint64_t v12 = v11;
LABEL_27:
        if (v12 == 32)
        {
          if ((v3 & 0x100) == 0) {
            return result;
          }
          uint64_t v16 = *(void *)(a1 + 72);
          if (v4 == 0x2000) {
            unsigned int v17 = 18;
          }
          else {
            unsigned int v17 = -1;
          }
          BOOL v18 = (v3 & 0x3000) == 0;
          int v19 = 17;
          goto LABEL_70;
        }
        if (v12 == 16)
        {
          if (*(void *)(a1 + 72) != 16) {
            return result;
          }
          if ((v3 & 0x100) != 0)
          {
            BOOL v26 = v4 == 4096;
            unsigned int v27 = 23;
            goto LABEL_136;
          }
          uint64_t result = 11;
          if ((v3 & 0x7000) != 0 && v4 != 12288)
          {
            if (v4 != 4096) {
              return 0xFFFFFFFFLL;
            }
            return 12;
          }
        }
        else if (v12 == 8 && (v3 & 0x7100) == 0)
        {
          uint64_t v13 = *(void *)(a1 + 72);
          if (v11 || v13 != 16)
          {
            if (v13 == 8) {
              return 1;
            }
            else {
              return 0xFFFFFFFFLL;
            }
          }
          else
          {
            if ((v3 & 0x1F) != 5)
            {
              if ((v3 & 0x1F) != 1) {
                return result;
              }
              *a2 = 1;
            }
            return 2;
          }
        }
        return result;
      case 3:
        int v9 = v3 & 0x1F;
        uint64_t v10 = *(void *)(a1 + 80);
        if (v10 <= 9)
        {
          if (v10 == 5)
          {
            uint64_t v29 = *(void *)(a1 + 128);
            if (v29)
            {
              if (v29 != 8) {
                return result;
              }
              *a2 = 1;
            }
            if ((v3 & 0x100) == 0 && *(void *)(a1 + 72) == 16 && v9 == 6)
            {
              uint64_t result = 3;
              if ((v3 & 0x7000) != 0 && v4 != 12288)
              {
                if (v4 != 4096) {
                  return 0xFFFFFFFFLL;
                }
                return 4;
              }
            }
          }
          else if (v10 == 8 && (v3 & 0x100) == 0 && *(void *)(a1 + 72) == 32 && !*(void *)(a1 + 128))
          {
            switch(v3 & 0x1F)
            {
              case 0:
              case 5:
                goto LABEL_55;
              case 1:
                *a2 = 1;
LABEL_55:
                if (v4 == 0x2000) {
                  unsigned int v20 = 8;
                }
                else {
                  unsigned int v20 = -1;
                }
                BOOL v21 = (v3 & 0x3000) == 0;
                unsigned int v22 = 7;
                goto LABEL_144;
              case 2:
                *a2 = 1;
                goto LABEL_140;
              case 6:
LABEL_140:
                if (v4 == 0x2000) {
                  unsigned int v20 = 6;
                }
                else {
                  unsigned int v20 = -1;
                }
                BOOL v21 = (v3 & 0x3000) == 0;
                unsigned int v22 = 5;
                goto LABEL_144;
              default:
                return result;
            }
          }
          return result;
        }
        if (v10 == 10)
        {
          if ((v3 & 0x100) != 0) {
            return result;
          }
          uint64_t v25 = *(void *)(a1 + 72);
          BOOL v26 = (v3 & 0xF5000) == 0x40000 && v25 == 32;
          unsigned int v27 = 26;
          goto LABEL_136;
        }
        if (v10 != 16)
        {
          if (v10 == 32 && (v3 & 0x100) != 0 && *(void *)(a1 + 72) == 128 && !*(void *)(a1 + 128))
          {
            if (v9 != 5)
            {
              if (v9 == 1)
              {
                *a2 = 1;
              }
              else if ((v3 & 0x1F) != 0)
              {
                return result;
              }
            }
            if (v4 == 0x2000) {
              unsigned int v20 = 20;
            }
            else {
              unsigned int v20 = -1;
            }
            BOOL v21 = (v3 & 0x3000) == 0;
            unsigned int v22 = 19;
LABEL_144:
            if (v21) {
              return v22;
            }
            else {
              return v20;
            }
          }
          return result;
        }
        uint64_t v28 = *(void *)(a1 + 72);
        if ((v3 & 0x100) == 0)
        {
          if (v28 == 64 && !*(void *)(a1 + 128))
          {
            if (v9 != 5)
            {
              if (v9 == 1)
              {
                *a2 = 1;
              }
              else if ((v3 & 0x1F) != 0)
              {
                return result;
              }
            }
            uint64_t result = 13;
            if ((v3 & 0x7000) != 0 && v4 != 12288)
            {
              if (v4 != 4096) {
                return 0xFFFFFFFFLL;
              }
              return 14;
            }
          }
          return result;
        }
        if (v28 != 64 || *(void *)(a1 + 128)) {
          return result;
        }
        if (v9 != 5)
        {
          if (v9 == 1)
          {
            *a2 = 1;
          }
          else if ((v3 & 0x1F) != 0)
          {
            return result;
          }
        }
        BOOL v26 = v4 == 4096;
        unsigned int v27 = 24;
        goto LABEL_136;
      case 4:
        uint64_t v14 = *(void *)(a1 + 128);
        uint64_t v15 = *(void *)(a1 + 80);
        if (!v14) {
          goto LABEL_40;
        }
        if (v14 != v15) {
          return result;
        }
        *a2 = 1;
        uint64_t v15 = v14;
LABEL_40:
        if (v15 == 32)
        {
          if ((v3 & 0x100) == 0) {
            return result;
          }
          uint64_t v24 = *(void *)(a1 + 72);
          if (v4 == 0x2000) {
            unsigned int v17 = 22;
          }
          else {
            unsigned int v17 = -1;
          }
          if ((v3 & 0x3000) == 0) {
            unsigned int v17 = 21;
          }
          BOOL v23 = v24 == 128;
          goto LABEL_80;
        }
        if (v15 == 16)
        {
          if (*(void *)(a1 + 72) != 64) {
            return result;
          }
          if ((v3 & 0x100) != 0)
          {
            BOOL v26 = v4 == 4096;
            unsigned int v27 = 25;
LABEL_136:
            if (v26) {
              uint64_t result = v27;
            }
            else {
              uint64_t result = 0xFFFFFFFFLL;
            }
          }
          else
          {
            uint64_t result = 15;
            if ((v3 & 0x7000) != 0 && v4 != 12288)
            {
              if (v4 != 4096) {
                return 0xFFFFFFFFLL;
              }
              uint64_t result = 16;
            }
          }
        }
        else if (v15 == 8 && (v3 & 0x100) == 0)
        {
          uint64_t v16 = *(void *)(a1 + 72);
          if (v4 == 0x2000) {
            unsigned int v17 = 10;
          }
          else {
            unsigned int v17 = -1;
          }
          BOOL v18 = (v3 & 0x3000) == 0;
          int v19 = 9;
LABEL_70:
          if (v18) {
            unsigned int v17 = v19;
          }
          BOOL v23 = v16 == 32;
LABEL_80:
          if (v23) {
            return v17;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }
        break;
      default:
        return result;
    }
  }
  else
  {
LABEL_3:
    if ((v3 & 0x100) == 0 && *(void *)(a1 + 72) == 8 && *(void *)(a1 + 80) == 8)
    {
      if (*(void *)(a1 + 128)) {
        BOOL v7 = 0;
      }
      else {
        BOOL v7 = v4 == 0;
      }
      int v8 = !v7;
      return (v8 << 31 >> 31);
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t CGCFDictionaryGetFloat(CFDictionaryRef theDict, const void *a2, void *a3)
{
  uint64_t result = 0;
  if (theDict)
  {
    if (a2)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, a2);
      if (result)
      {
        CFNumberRef v6 = (const __CFNumber *)result;
        CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
        if (v7 == CFNumberGetTypeID())
        {
          uint64_t valuePtr = 0;
          CFNumberGetValue(v6, kCFNumberDoubleType, &valuePtr);
          if (a3) {
            *a3 = valuePtr;
          }
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t initialize_deep_mask(int *a1)
{
  if (initialize_deep_mask_predicate != -1) {
    dispatch_once(&initialize_deep_mask_predicate, &__block_literal_global_18188);
  }
  int v2 = *a1;
  if (*a1 == 134755160 || v2 == 269497256) {
    return 256;
  }
  if (v2 == 269497257) {
    return initialize_deep_mask_fp16_deep_mask_on << 8;
  }
  return 0;
}

char *ripc_Initialize()
{
  BOOL v0 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0x10600404AF495FBuLL);
  *(void *)BOOL v0 = CGContextDelegateCreate((uint64_t)v0, v1, v2, v3, v4, v5, v6, v7);
  int v8 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
  *int v8 = &ripc_class;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = 0;
  *((_DWORD *)v8 + 39) = 1065353216;
  *((void *)v0 + 22) = v8;
  int v9 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
  *int v9 = &ripc_class;
  v9[1] = 0;
  v9[2] = 0;
  v9[3] = 0;
  *((_DWORD *)v9 + 39) = 1065353216;
  *((void *)v0 + 23) = v9;
  uint64_t v10 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
  *uint64_t v10 = &ripc_class;
  v10[1] = 0;
  v10[2] = 0;
  v10[3] = 0;
  *((_DWORD *)v10 + 39) = 1065353216;
  *((void *)v0 + 24) = v10;
  *((_DWORD *)v0 + 32) = -1;
  *((void *)v0 + 7) = 0;
  *((void *)v0 + 8) = 0;
  *(int64x2_t *)(v0 + 24) = vdupq_n_s64(0x4052000000000000uLL);
  *((void *)v0 + 5) = 0x3FF0000000000000;
  if (create_default_transform_predicate != -1) {
    dispatch_once(&create_default_transform_predicate, &__block_literal_global_7_13926);
  }
  uint64_t v11 = create_default_transform_transform;
  if (create_default_transform_transform) {
    CFRetain((CFTypeRef)create_default_transform_transform);
  }
  *((void *)v0 + 25) = v11;
  uint64_t v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
  *uint64_t v12 = v12;
  v12[1] = v12;
  *((void *)v0 + 26) = v12;
  CGContextDelegateSetCallbacks(*(void **)v0, (uint64_t)&ripc_Initialize_callbacks, 20, v13, v14, v15, v16, v17);
  pthread_mutex_lock(&contexts_mutex);
  uint64_t v18 = contexts;
  int v19 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
  if (v19)
  {
    *int v19 = v0;
    v19[1] = v18;
    uint64_t v18 = (uint64_t)v19;
  }
  contexts = v18;
  pthread_mutex_unlock(&contexts_mutex);
  return v0;
}

uint64_t CGContextDelegateCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_block_invoke_once_8554 != -1) {
    dispatch_once(&_block_invoke_once_8554, &__block_literal_global_5_8555);
  }
  uint64_t result = CGTypeCreateInstance(CGContextDelegateGetTypeID_context_delegate_id, 280, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    *(void *)(result + 288) = a1;
    *(_DWORD *)(result + 280) = 0;
  }
  return result;
}

uint64_t color_transform_create(CGColorSpaceRef a1, const void *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    int Type = CGColorSpaceGetType(a1);
    a1 = 0;
    CFStringRef v5 = @"kCGColorSpaceGenericGrayGamma2_2";
    switch(Type)
    {
      case 0:
        goto LABEL_6;
      case 1:
        CFStringRef v5 = @"kCGColorSpaceSRGB";
        goto LABEL_6;
      case 2:
        CFStringRef v5 = @"kCGColorSpaceGenericCMYK";
LABEL_6:
        a1 = CGColorSpaceCreateWithName(v5);
        uint64_t v3 = a1;
        if (a1) {
          goto LABEL_7;
        }
        goto LABEL_13;
      case 3:
      case 4:
      case 5:
      case 6:
      case 10:
      case 11:
        CFRetain(v3);
LABEL_7:
        if (!*(unsigned char *)(v3[3] + 10))
        {
          a1 = (CGColorSpaceRef)v3;
          goto LABEL_13;
        }
        if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
          dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
        }
        uint64_t Instance = CGTypeCreateInstance(CGColorTransformGetTypeID_type_id, 88, v6, v7, v8, v9, v10, v11);
        uint64_t v13 = Instance;
        *(_DWORD *)(Instance + 20) = 1;
        *(unsigned char *)(Instance + 96) = 1;
        if (a2)
        {
          CFRetain(a2);
          *(void *)(v13 + 32) = a2;
          uint64_t v14 = v3;
          unint64_t v15 = (unint64_t)a2;
        }
        else
        {
          *(void *)(Instance + 32) = 0;
          uint64_t v14 = v3;
          unint64_t v15 = 0;
        }
        *(void *)(v13 + 24) = CGColorTransformBaseAcquire(v14, v15);
        *(_DWORD *)(v13 + 16) = atomic_fetch_add_explicit(color_transform_create_identifier, 1u, memory_order_relaxed)
                              + 1;
        *(void *)(v13 + 88) = 0;
        unint64_t v16 = *(void *)(v3[3] + 48);
        if (v16 <= 4)
        {
          uint64_t v17 = (pthread_mutex_t *)malloc_type_calloc(1uLL, 0x58uLL, 0x1020040867A26DAuLL);
          *(void *)(v13 + 88) = v17;
          LODWORD(v17[1].__sig) = v16;
          *(void *)&v17[1].__opaque[8] = 0;
          pthread_mutex_init(v17, 0);
        }
        if (a2)
        {
          *(void *)(v13 + 40) = create_default_color_space((const __CFDictionary *)a2, @"DefaultGray", 0);
          *(void *)(v13 + 48) = create_default_color_space((const __CFDictionary *)a2, @"DefaultRGB", 1);
          *(void *)(v13 + 56) = create_default_color_space((const __CFDictionary *)a2, @"DefaultCMYK", 2);
        }
        if (!*(void *)(v13 + 40)) {
          *(void *)(v13 + 40) = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
        }
        if (!*(void *)(v13 + 48)) {
          *(void *)(v13 + 48) = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
        }
        if (!*(void *)(v13 + 56)) {
          *(void *)(v13 + 56) = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericCMYK");
        }
        if (!*(void *)(v13 + 64))
        {
          if (*(_DWORD *)(v3[3] + 28)) {
            uint64_t v18 = *(const void **)(v13 + 40);
          }
          else {
            uint64_t v18 = v3;
          }
          if (v18) {
            CFRetain(v18);
          }
          *(void *)(v13 + 64) = v18;
        }
        if (!*(void *)(v13 + 72))
        {
          if (*(_DWORD *)(v3[3] + 28) == 1) {
            int v19 = v3;
          }
          else {
            int v19 = *(const void **)(v13 + 48);
          }
          if (v19) {
            CFRetain(v19);
          }
          *(void *)(v13 + 72) = v19;
        }
        if (!*(void *)(v13 + 80))
        {
          if (*(_DWORD *)(v3[3] + 28) == 2) {
            unsigned int v20 = v3;
          }
          else {
            unsigned int v20 = *(const void **)(v13 + 56);
          }
          if (v20) {
            CFRetain(v20);
          }
          *(void *)(v13 + 80) = v20;
        }
        CGColorSpaceRelease((CGColorSpaceRef)v3);
        if (show_log_predicate != -1) {
          dispatch_once(&show_log_predicate, &__block_literal_global_61);
        }
        if (show_log_show_log)
        {
          uint64_t v29 = CGBacktraceCreate(10);
          CGPostError((uint64_t)"CGColorTransform %p created. Backtrace:\n%s\n", v21, v22, v23, v24, v25, v26, v27, v13);
          free(v29);
        }
        break;
      default:
        goto LABEL_13;
    }
  }
  else
  {
LABEL_13:
    CGColorSpaceRelease(a1);
    return 0;
  }
  return v13;
}

CGColorSpaceRef CGColorSpaceCreateWithName(CGColorSpaceRef name)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (name)
  {
    uint64_t v1 = (__CFString *)name;
    if (CFEqual(name, @"kCGColorSpaceITUR_2020_PQ_EOTF")) {
      uint64_t v1 = @"kCGColorSpaceITUR_2100_PQ";
    }
    if (CFEqual(v1, @"kCGColorSpaceITUR_2020_PQ")) {
      uint64_t v1 = @"kCGColorSpaceITUR_2100_PQ";
    }
    if (CFEqual(v1, @"kCGColorSpaceITUR_2020_HLG")) {
      uint64_t v1 = @"kCGColorSpaceITUR_2100_HLG";
    }
    if (CFEqual(v1, @"kCGColorSpaceDisplayP3_PQ_EOTF")) {
      uint64_t v1 = @"kCGColorSpaceDisplayP3_PQ";
    }
    if (CGColorSpaceCreateWithName_predicate != -1) {
      dispatch_once(&CGColorSpaceCreateWithName_predicate, &__block_literal_global_166);
    }
    uint64_t v2 = (__CFString **)CGColorSpaceCreateWithName_name_creator_pair_array;
    uint64_t v3 = 44;
    if (!CGColorSpaceCreateWithName_name_creator_pair_count) {
      uint64_t v3 = 0;
    }
    while (v3)
    {
      if (*v2 == v1)
      {
        uint64_t v3 = 0;
LABEL_27:
        int Value = (uint64_t (*)(void))v2[2 * v3 + 1];
        if (Value) {
          goto LABEL_29;
        }
        break;
      }
      unint64_t v4 = v3--;
      CFStringRef v5 = v2[2 * v3];
      if (v5 == v1) {
        goto LABEL_27;
      }
      uint64_t v3 = v4 >> 1;
      uint64_t v6 = v2[2 * (v4 >> 1)];
      if (v6 == v1) {
        goto LABEL_27;
      }
      if (*v2 >= v1 || v6 <= v1)
      {
        v2 += 2 * v3;
        uint64_t v3 = v4 - v3;
        if (v5 <= v1 || v6 >= v1) {
          break;
        }
      }
    }
    int Value = (uint64_t (*)(void))CFDictionaryGetValue((CFDictionaryRef)CGColorSpaceCreateWithName_name_creator_pair_dict, v1);
    if (!Value) {
      goto LABEL_30;
    }
LABEL_29:
    name = (CGColorSpaceRef)Value();
    if (name) {
      return name;
    }
LABEL_30:
    bzero(buffer, 0x401uLL);
    CFIndex Length = CFStringGetLength(v1);
    if (!CFStringGetCString(v1, buffer, 1024, 0x600u))
    {
      v19.locatiounint64_t n = 0;
      v19.length = Length;
      CFStringGetBytes(v1, v19, 0x600u, 0x3Fu, 0, (UInt8 *)buffer, 1024, 0);
    }
    CGPostError((uint64_t)"CGColorSpaceCreateWithName failed for %s", v10, v11, v12, v13, v14, v15, v16, (char)buffer);
    return 0;
  }
  return name;
}

uint64_t CGColorSpaceCreateSRGB()
{
  if (CGColorSpaceCreateSRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateSRGB_predicate, &__block_literal_global_232_6489);
  }
  uint64_t v0 = CGColorSpaceCreateSRGB_space;
  if (CGColorSpaceCreateSRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateSRGB_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateGenericGrayGamma22()
{
  if (CGColorSpaceCreateGenericGrayGamma22_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericGrayGamma22_predicate, &__block_literal_global_226_6495);
  }
  uint64_t v0 = CGColorSpaceCreateGenericGrayGamma22_space;
  if (CGColorSpaceCreateGenericGrayGamma22_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericGrayGamma22_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateGenericCMYK()
{
  if (CGColorSpaceCreateGenericCMYK_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericCMYK_predicate, &__block_literal_global_202);
  }
  uint64_t v0 = CGColorSpaceCreateGenericCMYK_space;
  if (CGColorSpaceCreateGenericCMYK_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericCMYK_space);
  }
  return v0;
}

uint64_t CGColorTransformBaseAcquire(void *a1, unint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  pthread_mutex_lock(&cacheMutex);
  uint64_t v10 = (uint64_t *)base_cache;
  if (base_cache)
  {
    while (1)
    {
      uint64_t Instance = *v10;
      unint64_t v12 = *(void *)(*v10 + 24);
      if ((!(a2 | v12) || a2 && v12 && CFEqual((CFTypeRef)a2, (CFTypeRef)v12))
        && matches_space(*(void *)(Instance + 16), (uint64_t)a1))
      {
        break;
      }
      uint64_t v10 = (uint64_t *)v10[1];
      if (!v10) {
        goto LABEL_8;
      }
    }
    ++*(void *)(Instance + 32);
  }
  else
  {
LABEL_8:
    if (_block_invoke_once_4610 != -1) {
      dispatch_once(&_block_invoke_once_4610, &__block_literal_global_5_4611);
    }
    uint64_t Instance = CGTypeCreateInstance(CGColorTransformBaseGetTypeID_type_id, 32, v4, v5, v6, v7, v8, v9);
    if (kCGMD5NULL_block_invoke_once != -1) {
      dispatch_once(&kCGMD5NULL_block_invoke_once, &__block_literal_global_8_16275);
    }
    uint64_t v19 = CGTypeCreateInstance(CGColorTransformCacheGetTypeID_type_id, 112, v13, v14, v15, v16, v17, v18);
    if (a1) {
      CFRetain(a1);
    }
    *(void *)(v19 + 16) = a1;
    if (a2) {
      CFTypeRef v20 = CFRetain((CFTypeRef)a2);
    }
    else {
      CFTypeRef v20 = 0;
    }
    *(void *)(v19 + 40) = v20;
    if (a1) {
      BOOL v21 = *(unsigned char *)(a1[3] + 12) != 0;
    }
    else {
      BOOL v21 = 1;
    }
    *(unsigned char *)(v19 + 49) = v21;
    v34.__sig = 0;
    *(void *)v34.__opaque = 0;
    pthread_mutexattr_init(&v34);
    pthread_mutexattr_settype(&v34, 2);
    pthread_mutex_init((pthread_mutex_t *)(v19 + 56), &v34);
    pthread_mutexattr_destroy(&v34);
    *(void *)(v19 + 120) = 0;
    uint64_t v22 = a1[3];
    if (v22) {
      uint64_t v23 = (_OWORD *)(v22 + 64);
    }
    else {
      uint64_t v23 = 0;
    }
    *(_OWORD *)(v19 + 24) = *v23;
    *(unsigned char *)(v19 + 48) = 0;
    if (a2)
    {
      *(unsigned char *)(v19 + 48) = CFDictionaryGetValue((CFDictionaryRef)a2, @"kCGColorTransformBlackPointCompensation") == (const void *)*MEMORY[0x1E4F1CFD0];
      uint64_t v24 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
      CC_MD5_Init(v24);
      if (v24)
      {
        CC_MD5_Update(v24, (const void *)(v19 + 24), 0x10u);
        datdouble a = CGCFDictionaryGetMD5Digest((const __CFDictionary *)a2, 1u);
        uint64_t v36 = v25;
        CC_MD5_Update(v24, &data, 0x10u);
        CC_MD5_Final((unsigned __int8 *)(v19 + 24), v24);
      }
      else
      {
        datdouble a = CGCFDictionaryGetMD5Digest((const __CFDictionary *)a2, 1u);
        uint64_t v36 = v27;
      }
      free(v24);
      *(void *)(Instance + 16) = v19;
      *(void *)(Instance + 32) = 1;
      *(unsigned char *)(Instance + 40) = 1;
      CFTypeRef v26 = CFRetain((CFTypeRef)a2);
    }
    else
    {
      CFTypeRef v26 = 0;
      *(void *)(Instance + 16) = v19;
      *(void *)(Instance + 32) = 1;
      *(unsigned char *)(Instance + 40) = 1;
    }
    *(void *)(Instance + 24) = v26;
    uint64_t v28 = base_cache;
    if (base_cache)
    {
      uint64_t v29 = base_cache;
      do
      {
        uint64_t v30 = v29;
        uint64_t v29 = *(void *)(v29 + 8);
      }
      while (v29);
      uint64_t v31 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      if (v31)
      {
        *uint64_t v31 = Instance;
        v31[1] = 0;
      }
      *(void *)(v30 + 8) = v31;
    }
    else
    {
      uint64_t v32 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      uint64_t v28 = (uint64_t)v32;
      if (v32)
      {
        *uint64_t v32 = Instance;
        v32[1] = 0;
      }
    }
    base_cache = v28;
  }
  pthread_mutex_unlock(&cacheMutex);
  return Instance;
}

void CGContextBeginTransparencyLayerWithRect(CGContextRef c, CGRect rect, CFDictionaryRef auxInfo)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      double height = rect.size.height;
      double width = rect.size.width;
      double y = rect.origin.y;
      double x = rect.origin.x;
      uint64_t v15 = *((void *)c + 5);
      if (v15)
      {
        uint64_t v16 = *(uint64_t (**)(__n128, __n128, __n128, __n128))(v15 + 192);
        if (v16)
        {
          uint64_t v17 = (const void *)v16((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
          if (v17) {
            goto LABEL_27;
          }
        }
      }
      DeviceClipBoundingBodouble x = CGContextGetDeviceClipBoundingBox((uint64_t)c, (uint64_t)auxInfo, v3, v4, v5, v6, v7, v8);
      CGFloat v22 = v21;
      CGFloat v23 = v18;
      CGFloat v24 = v19;
      uint64_t v25 = *((void *)c + 12);
      uint64_t v26 = *(void *)(*(void *)(v25 + 120) + 16);
      if (v26)
      {
        uint64_t v27 = *((void *)c + 14);
        long long v28 = *(_OWORD *)(v27 + 40);
        *(_OWORD *)&color.double a = *(_OWORD *)(v27 + 24);
        *(_OWORD *)&color.double c = v28;
        *(_OWORD *)&color.double tx = *(_OWORD *)(v27 + 56);
        DeviceClipBoundingBodouble x = CGStyleGetDrawBoundingBoxWithMatrix(v26, &color, DeviceClipBoundingBox, v22, v18, v19);
        CGFloat v22 = v29;
        CGFloat v23 = v30;
        CGFloat v24 = v31;
      }
      if (x != -8.98846567e307 || y != -8.98846567e307 || width != 1.79769313e308 || height != 1.79769313e308)
      {
        long long v32 = *(_OWORD *)(v25 + 40);
        *(_OWORD *)&color.double a = *(_OWORD *)(v25 + 24);
        *(_OWORD *)&color.double c = v32;
        *(_OWORD *)&color.double tx = *(_OWORD *)(v25 + 56);
        double v33 = x;
        *(double *)&long long v32 = y;
        double v34 = width;
        double v35 = height;
        CGRect v92 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v32 - 8), &color);
        DrawBoundingBoxWithMatridouble x = v92.origin.x;
        CGFloat v37 = v92.origin.y;
        CGFloat v38 = v92.size.width;
        CGFloat v39 = v92.size.height;
        if (v26)
        {
          uint64_t v40 = *((void *)c + 14);
          long long v41 = *(_OWORD *)(v40 + 40);
          *(_OWORD *)&color.double a = *(_OWORD *)(v40 + 24);
          *(_OWORD *)&color.double c = v41;
          *(_OWORD *)&color.double tx = *(_OWORD *)(v40 + 56);
          DrawBoundingBoxWithMatridouble x = CGStyleGetDrawBoundingBoxWithMatrix(v26, &color, v92.origin.x, v37, v92.size.width, v92.size.height);
          CGFloat v37 = v42;
          CGFloat v38 = v43;
          CGFloat v39 = v44;
        }
        v93.origin.double x = DeviceClipBoundingBox;
        v93.origin.double y = v22;
        v93.size.double width = v23;
        v93.size.double height = v24;
        CGRect v94 = CGRectIntersection(v93, *(CGRect *)&DrawBoundingBoxWithMatrix);
        DeviceClipBoundingBodouble x = v94.origin.x;
        CGFloat v22 = v94.origin.y;
        CGFloat v23 = v94.size.width;
        CGFloat v24 = v94.size.height;
      }
      v95.origin.double x = DeviceClipBoundingBox;
      v95.origin.double y = v22;
      v95.size.double width = v23;
      v95.size.double height = v24;
      CGRect v96 = CGRectIntegral(v95);
      uint64_t v51 = CGContextDelegateCreateForContext(auxInfo, (uint64_t)c, v45, v46, v47, v48, v49, v50, (__n128)v96.origin, *(__n128 *)&v96.origin.y, (__n128)v96.size, *(__n128 *)&v96.size.height);
      uint64_t v17 = (const void *)v51;
      if (!v51) {
        goto LABEL_27;
      }
      uint64_t v52 = *(uint64_t (**)(uint64_t, void, void, CFDictionaryRef, void, double, double, double, double))(v51 + 192);
      if (v52)
      {
        uint64_t v53 = v52(v51, *((void *)c + 14), *((void *)c + 12), auxInfo, *((void *)c + 5), x, y, width, height);
        char v54 = (const void *)v53;
        if (v53 && (const void *)v53 == v17) {
          goto LABEL_27;
        }
      }
      else
      {
        char v54 = 0;
      }
      CFRelease(v17);
      uint64_t v17 = v54;
LABEL_27:
      uint64_t v56 = *((void *)c + 13);
      uint64_t v57 = *(void *)(v56 + 8);
      if (v57 == v56)
      {
        int v58 = CGGStateCreate();
        char v59 = *(char ***)(v56 + 8);
        *(void *)(v56 + 8) = v58;
        *(void *)int v58 = v56;
        *char v59 = v58;
        *((void *)v58 + 1) = v59;
        uint64_t v57 = *(void *)(v56 + 8);
      }
      uint64_t v60 = (char *)malloc_type_calloc(1uLL, 0x98uLL, 0xA3729uLL);
      *(void *)uint64_t v60 = v60;
      *((void *)v60 + 1) = v60;
      *((_DWORD *)v60 + 4) = 1;
      long long v61 = *(_OWORD *)(v57 + 24);
      long long v62 = *(_OWORD *)(v57 + 40);
      *(_OWORD *)(v60 + 56) = *(_OWORD *)(v57 + 56);
      *(_OWORD *)(v60 + 40) = v62;
      *(_OWORD *)(v60 + 24) = v61;
      uint64_t v63 = *(void *)(v57 + 72);
      if (v63) {
        CFRetain(*(CFTypeRef *)(v57 + 72));
      }
      *((void *)v60 + 9) = v63;
      CGGStateClipReset((uint64_t)v60);
      uint64_t v64 = *(void *)(v57 + 120);
      uint64_t v65 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0xA3729uLL);
      *(_DWORD *)uint64_t v65 = 1;
      unsigned int v66 = *((_DWORD *)v65 + 1) & 0xFFFF00FF | 0x200;
      *((_DWORD *)v65 + 1) = v66;
      *((void *)v65 + 1) = 0x3FF0000000000000;
      *((void *)v65 + 2) = 0;
      *(_OWORD *)(v65 + 24) = *(_OWORD *)(v64 + 24);
      unsigned int v67 = *(_DWORD *)(v64 + 4) & 0xF0000 | v66 & 0xFFF002FF;
      *((_DWORD *)v65 + 1) = v67;
      unsigned int v68 = v67 & 0xFF0FFFFF | *(_DWORD *)(v64 + 4) & 0xF00000;
      *((_DWORD *)v65 + 1) = v68;
      unsigned int v69 = v68 & 0xFFFFFE00 | *(unsigned __int8 *)(v64 + 4);
      *((_DWORD *)v65 + 1) = v69;
      *((_DWORD *)v65 + 1) = v69 & 0xFCFFFFFF | *(_DWORD *)(v64 + 4) & 0x1000000;
      *((void *)v65 + 5) = 0;
      *((void *)v60 + 15) = v65;
      v60[20] &= ~2u;
      CGGStateStrokeCopy((uint64_t)v60, v57, v70, v71, v72, v73, v74, v75);
      CGGStateTextCopy((uint64_t)v60, v57, v76, v77, v78, v79, v80, v81);
      CGGStateDeviceCopy((uint64_t)v60, v57);
      CFTypeID v89 = *(void **)(v56 + 8);
      *(void *)(v56 + 8) = v60;
      *(void *)uint64_t v60 = v56;
      *CFTypeID v89 = v60;
      *((void *)v60 + 1) = v89;
      *((void *)c + 12) = *(void *)(v56 + 8);
      if (v17)
      {
        *((void *)c + 5) = v17;
      }
      else
      {
        CGPostError((uint64_t)"CGContextBeginTransparencyLayer: cannot create transparency layer.", v82, v83, v84, v85, v86, v87, v88, SLOBYTE(color.a));
        CGGStateClipToRect(*((void *)c + 12), 0.0, 0.0, 0.0, 0.0);
      }
      color.double a = 0.0;
      if (kCGColorComponents_block_invoke_once != -1) {
        dispatch_once(&kCGColorComponents_block_invoke_once, &__block_literal_global_31);
      }
      if (CGCFDictionaryGetCFTypeRef(auxInfo, @"kCGContextBackgroundColor", CGColorGetTypeID_color_type_id, (uint64_t *)&color))
      {
        CGContextSaveGState(c);
        CGContextSetBlendMode(c, kCGBlendModeCopy);
        CGContextSetFillColorWithColor(c, *(CGColorRef *)&color.a);
        v97.origin.double x = -8.98846567e307;
        v97.size.double width = 1.79769313e308;
        v97.origin.double y = -8.98846567e307;
        v97.size.double height = 1.79769313e308;
        CGContextFillRect(c, v97);
        CGContextRestoreGState(c);
      }
      return;
    }
    CGContextRef v55 = c;
  }
  else
  {
    CGContextRef v55 = 0;
  }

  handle_invalid_context((char)"CGContextBeginTransparencyLayerWithRect", (uint64_t)v55, v3, v4, v5, v6, v7, v8);
}

void CGContextSaveGState(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      *((void *)c + 12) = CGGStackSave(*((void *)c + 13));
      return;
    }
    CGContextRef v7 = c;
  }
  else
  {
    CGContextRef v7 = 0;
  }

  handle_invalid_context((char)"CGContextSaveGState", (uint64_t)v7, v1, v2, v3, v4, v5, v6);
}

uint64_t CGGStackSave(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == a1)
  {
    uint64_t v3 = CGGStateCreate();
    uint64_t v4 = *(char ***)(a1 + 8);
    *(void *)(a1 + 8) = v3;
    *(void *)uint64_t v3 = a1;
    *uint64_t v4 = v3;
    *((void *)v3 + 1) = v4;
    uint64_t v2 = *(void *)(a1 + 8);
  }
  Copdouble y = CGGStateCreateCopy(v2);
  uint64_t v6 = *(char ***)(a1 + 8);
  *(void *)(a1 + 8) = Copy;
  *(void *)Copdouble y = a1;
  *uint64_t v6 = Copy;
  *((void *)Copy + 1) = v6;
  return *(void *)(a1 + 8);
}

char *CGGStateCreateCopy(uint64_t a1)
{
  uint64_t v8 = (char *)malloc_type_malloc(0x98uLL, 0x2062DE7BuLL);
  *(void *)uint64_t v8 = v8;
  *((void *)v8 + 1) = v8;
  *((_DWORD *)v8 + 4) = 1;
  long long v9 = *(_OWORD *)(a1 + 24);
  long long v10 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v8 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v8 + 40) = v10;
  *(_OWORD *)(v8 + 24) = v9;
  uint64_t v11 = *(void *)(a1 + 72);
  if (v11) {
    CFRetain(*(CFTypeRef *)(a1 + 72));
  }
  *((void *)v8 + 9) = v11;
  unint64_t v12 = *(atomic_uint **)(a1 + 112);
  if (v12) {
    atomic_fetch_add_explicit(v12, 1u, memory_order_relaxed);
  }
  *((void *)v8 + 14) = v12;
  *(unsigned char *)(a1 + 20) |= 1u;
  char v13 = v8[20] | 1;
  v8[20] = v13;
  long long v14 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v8 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v8 + 6) = v14;
  uint64_t v15 = *(atomic_uint **)(a1 + 120);
  if (v15)
  {
    atomic_fetch_add_explicit(v15, 1u, memory_order_relaxed);
    char v13 = v8[20];
  }
  *((void *)v8 + 15) = v15;
  v8[20] = v13 | 2;
  *(unsigned char *)(a1 + 20) |= 2u;
  *((void *)v8 + 16) = 0;
  CGGStateStrokeCopy((uint64_t)v8, a1, v2, v3, v4, v5, v6, v7);
  *((void *)v8 + 17) = 0;
  CGGStateTextCopy((uint64_t)v8, a1, v16, v17, v18, v19, v20, v21);
  *((void *)v8 + 18) = 0;
  CGGStateDeviceCopy((uint64_t)v8, a1);
  return v8;
}

void CGGStateTextCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  text_state_release(*(void **)(a1 + 136), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a2 + 136);
  if (v10) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 136) = v10;
  *(unsigned char *)(a1 + 20) |= 8u;
  *(unsigned char *)(a2 + 20) |= 8u;
}

void CGGStateDeviceCopy(uint64_t a1, uint64_t a2)
{
  device_state_release(*(void **)(a1 + 144));
  uint64_t v4 = *(void *)(a2 + 144);
  if (v4) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = v4;
  *(unsigned char *)(a1 + 20) |= 0x10u;
  *(unsigned char *)(a2 + 20) |= 0x10u;
}

void CGGStateStrokeCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  stroke_state_release(*(void **)(a1 + 128), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a2 + 128);
  if (v10) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 128) = v10;
  *(unsigned char *)(a1 + 20) |= 4u;
  *(unsigned char *)(a2 + 20) |= 4u;
}

void CGGStateReset(uint64_t a1)
{
  CGGStateSetFillColor(a1, 0);
  device_state_release(*(void **)(a1 + 144));
  if (device_state_create_root_predicate != -1) {
    dispatch_once(&device_state_create_root_predicate, &__block_literal_global_16294);
  }
  uint64_t v9 = device_state_create_root_root;
  if (device_state_create_root_root) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(device_state_create_root_root + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 144) = v9;
  *(unsigned char *)(a1 + 20) |= 0x10u;
  text_state_release(*(void **)(a1 + 136), v2, v3, v4, v5, v6, v7, v8);
  if (text_state_create_root_predicate != -1) {
    dispatch_once(&text_state_create_root_predicate, &__block_literal_global_19847);
  }
  uint64_t v10 = text_state_create_root_root;
  if (text_state_create_root_root) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(text_state_create_root_root + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 136) = v10;
  *(unsigned char *)(a1 + 20) |= 8u;
  if (*(void *)(a1 + 120))
  {
    maybeCopyRenderingState(a1);
    renderingStateReset(*(void *)(a1 + 120));
  }
  else
  {
    uint64_t v18 = malloc_type_calloc(1uLL, 0x38uLL, 0xA3729uLL);
    *uint64_t v18 = 1;
    renderingStateReset((uint64_t)v18);
    *(void *)(a1 + 120) = v18;
    *(unsigned char *)(a1 + 20) &= ~2u;
  }
  stroke_state_release(*(void **)(a1 + 128), v11, v12, v13, v14, v15, v16, v17);
  if (stroke_state_create_root_predicate != -1) {
    dispatch_once(&stroke_state_create_root_predicate, &__block_literal_global_17794);
  }
  uint64_t v19 = stroke_state_create_root_root;
  if (stroke_state_create_root_root) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(stroke_state_create_root_root + 4), 1u, memory_order_relaxed);
  }
  *(void *)(a1 + 128) = v19;
  *(unsigned char *)(a1 + 20) |= 4u;
}

void CGGStateRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 16), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CGClipStackRelease(*(void **)(a1 + 112));
    device_state_release(*(void **)(a1 + 144));
    renderingStateRelease(*(void **)(a1 + 120));
    stroke_state_release(*(void **)(a1 + 128), v2, v3, v4, v5, v6, v7, v8);
    text_state_release(*(void **)(a1 + 136), v9, v10, v11, v12, v13, v14, v15);
    uint64_t v16 = *(const void **)(a1 + 72);
    if (v16) {
      CFRelease(v16);
    }
    free((void *)a1);
  }
}

void stroke_state_release(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1 + 1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*(unsigned char *)a1) {
      _CGHandleAssert("stroke_state_release", 86, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Context/CGGStateStroke.c", "!ss->is_root", "is root: %d", a6, a7, a8, 1);
    }
    uint64_t v9 = (void *)*((void *)a1 + 4);
    if (v9 && atomic_fetch_add_explicit((atomic_uint *volatile)v9, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v9);
    }
    uint64_t v10 = (const void *)*((void *)a1 + 5);
    if (v10) {
      CFRelease(v10);
    }
    free(a1);
  }
}

void text_state_release(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1 + 1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (*(_WORD *)a1) {
      _CGHandleAssert("text_state_release", 117, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Context/CGGStateText.c", "!ts->is_root", "is root %d", a6, a7, a8, 1);
    }
    uint64_t v9 = (const void *)*((void *)a1 + 1);
    if (v9) {
      CFRelease(v9);
    }
    uint64_t v10 = (const void *)*((void *)a1 + 8);
    if (v10) {
      CFRelease(v10);
    }
    free(a1);
  }
}

void device_state_release(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1 + 1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)*((void *)a1 + 4);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)*((void *)a1 + 5);
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void CGClipStackRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = *((void *)a1 + 15);
    if (*((void *)a1 + 14) == 3)
    {
      if (v2)
      {
        unint64_t v3 = 0;
        do
          CGClipRelease(*((char **)a1 + v3++ + 16));
        while (v3 < *((void *)a1 + 15));
      }
    }
    else
    {
      if (v2)
      {
        unint64_t v4 = 0;
        do
          CGClipRelease(*(char **)(*((void *)a1 + 16) + 8 * v4++));
        while (v4 < *((void *)a1 + 15));
      }
      free(*((void **)a1 + 16));
    }
    free(a1);
  }
}

void renderingStateRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = (const void *)a1[2];
    if (v2) {
      CFRelease(v2);
    }
    unint64_t v3 = (const void *)a1[5];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void CGGStateSetFillColor(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void **)(a1 + 72);
  if (!CGColorEqualToColor((CGColorRef)v4, (CGColorRef)a2))
  {
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(a1 + 72) = a2;
  }
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  if (color1 == color2)
  {
    LOBYTE(color1) = 1;
  }
  else
  {
    CGColorRef v2 = color1;
    LOBYTE(color1) = 0;
    if (((unint64_t)v2 & 0x8000000000000000) == 0 && ((unint64_t)color2 & 0x8000000000000000) == 0)
    {
      LOBYTE(color1) = 0;
      if (v2)
      {
        if (color2)
        {
          uint64_t v4 = *((void *)v2 + 7);
          if (v4 == *((void *)color2 + 7) && !memcmp((char *)v2 + 64, (char *)color2 + 64, 8 * v4))
          {
            LODWORD(color1) = CGPatternEqualToPattern(*((void *)v2 + 4), *((void *)color2 + 4));
            if (color1)
            {
              uint64_t v5 = *((void *)v2 + 3);
              uint64_t v6 = *((void *)color2 + 3);
              LOBYTE(color1) = CGColorSpaceEqualToColorSpace(v5, v6);
            }
          }
          else
          {
            LOBYTE(color1) = 0;
          }
        }
      }
    }
  }
  return (char)color1;
}

void renderingStateReset(uint64_t a1)
{
  *(void *)(a1 + 8) = 0x3FF0000000000000;
  int v2 = *(_DWORD *)(a1 + 4);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 4) = v2 & 0xFC000000 | 0x1320200;
  unint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 40) = 0;
  }
  *(_DWORD *)(a1 + 48) = 0;
}

uint64_t CGPatternEqualToPattern(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && a2)
  {
    int v5 = *(_DWORD *)(a1 + 20);
    if (v5 != *(_DWORD *)(a2 + 20) || *(double *)(a1 + 24) != *(double *)(a2 + 24)) {
      return 0;
    }
    uint64_t result = 0;
    if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)(a2 + 32)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a2 + 48)))), 0xFuLL))) & 1) != 0&& *(double *)(a1 + 64) == *(double *)(a2 + 64))
    {
      if (*(unsigned __int8 *)(a1 + 72) == *(unsigned __int8 *)(a2 + 72))
      {
        if (v5 == 1) {
          goto LABEL_12;
        }
        if (v5)
        {
LABEL_16:
          uint64_t result = CGRectEqualToRect(*(CGRect *)(a1 + 104), *(CGRect *)(a2 + 104));
          if (result)
          {
            uint64_t result = 0;
            if (*(double *)(a1 + 136) == *(double *)(a2 + 136) && *(double *)(a1 + 144) == *(double *)(a2 + 144))
            {
              if (*(_DWORD *)(a1 + 152) == *(_DWORD *)(a2 + 152)
                && *(unsigned __int8 *)(a1 + 184) == *(unsigned __int8 *)(a2 + 184)
                && (!*(unsigned char *)(a1 + 184) || *(void *)(a1 + 80) == *(void *)(a2 + 80))
                && *(unsigned __int8 *)(a1 + 185) == *(unsigned __int8 *)(a2 + 185))
              {
                return *(unsigned __int8 *)(a1 + 186) == *(unsigned __int8 *)(a2 + 186);
              }
              return 0;
            }
          }
          return result;
        }
        if (*(void *)(a1 + 168) == *(void *)(a2 + 168))
        {
LABEL_12:
          if (*(void *)(a1 + 80) != *(void *)(a2 + 80)) {
            return 0;
          }
          goto LABEL_16;
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t CGCFDictionaryGetCFTypeRef(CFDictionaryRef theDict, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = 0;
  if (theDict)
  {
    if (a2)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, a2);
      if (result)
      {
        uint64_t v8 = result;
        if (a3 && CFGetTypeID((CFTypeRef)result) != a3)
        {
          return 0;
        }
        else
        {
          if (a4) {
            *a4 = v8;
          }
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t ripc_BeginLayer(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, uint64_t a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  uint64_t v16 = a1;
  if (a1) {
    uint64_t v17 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v17 = 0;
  }
  unsigned int v67 = 0;
  if (!a5 || *(void *)(v17 + 96) || *(void *)(v17 + 88))
  {
    long long v69 = 0u;
    long long v70 = 0u;
    long long v68 = 0u;
    if ((ripc_GetRenderingState(v17, a2, a3, (uint64_t)&v68) & 1) == 0)
    {
      long long v69 = 0u;
      long long v70 = 0u;
      long long v68 = 0u;
      ripc_InitializeColorTransform(v17);
    }
    uint64_t v18 = malloc_type_malloc(0x30uLL, 0x10600404FCFB723uLL);
    if (v18)
    {
      CGFloat v24 = v18;
      *uint64_t v18 = *(void *)(v17 + 88);
      *(void *)(v17 + 88) = v18;
      v18[4] = *(void *)(v17 + 48);
      uint64_t v25 = *(void *)(v17 + 16);
      if (v25) {
        CFRetain(*(CFTypeRef *)(v17 + 16));
      }
      v24[1] = v25;
      *((_OWORD *)v24 + 1) = *(_OWORD *)(v17 + 24);
      v24[5] = *(void *)(v17 + 72);
      *(void *)(v17 + 72) = 0;
      if (a4)
      {
        memset(&v66, 0, 32);
        if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
          dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
        }
        CGCFDictionaryGetCFTypeRef(a4, @"kCGContextColorSpace", CGColorSpaceGetTypeID_type_id, (uint64_t *)&v67);
        if (CGCFDictionaryGetRect(a4, @"kCGContextBoundingBox", (UInt8 *)&v66))
        {
          v73.origin.double x = v66.a;
          v73.origin.double y = v66.b;
          v73.size.double width = v66.c;
          v73.size.double height = v66.d;
          v71.origin.double x = a6;
          v71.origin.double y = a7;
          v71.size.double width = a8;
          v71.size.double height = a9;
          *(CGRect *)((char *)&v22 - 24) = CGRectIntersection(v71, v73);
          a6 = v26;
          a7 = v27;
          a8 = v28;
          a9 = v22.f64[0];
        }
      }
      if (a6 != -8.98846567e307 || a7 != -8.98846567e307 || a8 != 1.79769313e308 || a9 != 1.79769313e308)
      {
        v22.f64[0] = *(float64_t *)(v17 + 40);
        v23.f64[0] = 1.0;
        __asm { FMOV            V5.2D, #1.0 }
        float64x2_t v34 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vceqq_f64(v22, v23).i64[0], 0), _Q5, (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v22.f64[0], 0));
        float64x2_t v35 = vmulq_f64(*(float64x2_t *)(a3 + 40), v34);
        float64x2_t v36 = vmulq_f64(*(float64x2_t *)(a3 + 56), v34);
        *(float64x2_t *)&v66.double a = vmulq_f64(*(float64x2_t *)(a3 + 24), v34);
        *(float64x2_t *)&v66.double c = v35;
        *(float64x2_t *)&v66.double tx = v36;
        CGFloat v37 = a6;
        v35.f64[0] = a7;
        v36.f64[0] = a8;
        v34.f64[0] = a9;
        CGRect v72 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v34 - 24), &v66);
        double v38 = v72.size.width + v72.origin.x;
        double v39 = v72.origin.x + 0.0;
        if (v72.origin.x + 0.0 <= 1073741820.0)
        {
          if (v39 >= -1073741820.0) {
            unsigned int v40 = vcvtmd_s64_f64(v39);
          }
          else {
            unsigned int v40 = -1073741823;
          }
        }
        else
        {
          unsigned int v40 = 0x3FFFFFFF;
        }
        LODWORD(v66.a) = v40;
        if (v38 <= 1073741820.0)
        {
          if (v38 >= -1073741820.0) {
            unsigned int v41 = vcvtpd_s64_f64(v38);
          }
          else {
            unsigned int v41 = -1073741823;
          }
        }
        else
        {
          unsigned int v41 = 0x3FFFFFFF;
        }
        unsigned int v42 = v41 - v40;
        LODWORD(v66.b) = v41 - v40;
        double v43 = v72.size.height + v72.origin.y;
        double v44 = v72.origin.y + 0.0;
        if (v44 <= 1073741820.0)
        {
          if (v44 >= -1073741820.0) {
            unsigned int v45 = vcvtmd_s64_f64(v44);
          }
          else {
            unsigned int v45 = -1073741823;
          }
        }
        else
        {
          unsigned int v45 = 0x3FFFFFFF;
        }
        HIDWORD(v66.a) = v45;
        if (v43 <= 1073741820.0)
        {
          if (v43 >= -1073741820.0) {
            unsigned int v46 = vcvtpd_s64_f64(v43);
          }
          else {
            unsigned int v46 = -1073741823;
          }
        }
        else
        {
          unsigned int v46 = 0x3FFFFFFF;
        }
        unsigned int v47 = v46 - v45;
        HIDWORD(v66.b) = v46 - v45;
        if (*((void *)&v70 + 1))
        {
          uint64_t v64 = 0;
          uint64_t v65 = 0;
          if ((*(unsigned int (**)(void, uint64_t *))(**((void **)&v70 + 1) + 40))(*((void *)&v70 + 1), &v64))
          {
            LODWORD(v66.a) = v40 + v64;
            HIDWORD(v66.a) = v45 + HIDWORD(v64);
            LODWORD(v66.b) = v42 + v65;
            HIDWORD(v66.b) = v47 + HIDWORD(v65);
          }
        }
        if ((CGSBoundsIntersection((int *)&v69 + 2, (int *)&v66, (_DWORD *)&v69 + 2) & 1) == 0) {
          *(void *)&long long v70 = 0;
        }
      }
      uint64_t v48 = *(void **)(v17 + 200);
      uint64_t v49 = *(void **)(v17 + 120);
      if (v48 == v49)
      {
        uint64_t v52 = *(void **)(v17 + 16);
        if (v52 != v48)
        {
          if (v52)
          {
            CFRelease(v52);
            uint64_t v48 = *(void **)(v17 + 120);
          }
          if (v48) {
            CFRetain(v48);
          }
          *(void *)(v17 + 16) = v48;
        }
        uint64_t v53 = *(void *)(v17 + 48);
        if (v53) {
          uint64_t v51 = *(unsigned int **)(v53 + 32);
        }
        else {
          uint64_t v51 = 0;
        }
      }
      else
      {
        uint64_t v50 = *(void *)(v17 + 48);
        if (v50) {
          uint64_t v51 = *(unsigned int **)(v50 + 32);
        }
        else {
          uint64_t v51 = 0;
        }
        if (v67 && CGColorTransformConvertNeedsCMS(v49, v67, 0))
        {
          if (v67) {
            unsigned int v57 = *(_DWORD *)(*((void *)v67 + 3) + 28);
          }
          else {
            unsigned int v57 = -1;
          }
          int v58 = *(const void **)(v17 + 16);
          if (v58) {
            CFRelease(v58);
          }
          *(void *)(v17 + 16) = 0;
          if (v57 <= 2)
          {
            dispatch_once_t v59 = RIPLayerDepthForModel(v57, *v51, v54, v55, v56, v19, v20, v21);
            if (v59)
            {
              uint64_t v60 = (unsigned int *)v59;
              uint64_t v61 = color_transform_create(v67, 0);
              if (v61)
              {
                *(void *)(v17 + 16) = v61;
                uint64_t v51 = v60;
              }
            }
          }
        }
      }
      if (a2) {
        uint64_t v62 = *(unsigned int *)(a2 + 4);
      }
      else {
        uint64_t v62 = 3;
      }
      *(void *)(v17 + 48) = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v69 + 8, 49, (uint64_t)v51, v62, v19, v20, v21);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(void *)(v17 + 96) = a5;
  }
  return v16;
}

char *RIPLayerCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v9 = (int *)a4;
  char v10 = a3;
  if (a2)
  {
    unsigned int v12 = *(_DWORD *)(a2 + 8);
    if ((v12 & 0x80000000) != 0) {
      return 0;
    }
    unsigned int v13 = *(_DWORD *)(a2 + 12);
    if ((v13 & 0x80000000) != 0) {
      return 0;
    }
    uint64_t v14 = *(void *)a2;
  }
  else
  {
    unsigned int v12 = 0;
    unsigned int v13 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v42 = v14;
  if (!a4) {
    uint64_t v9 = (int *)RIPGetDepthForLayerFormat(0, a2, a3, 0, a5, a6, a7, a8);
  }
  if (v9 != (int *)RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8))
  {
    if (v12 <= 0x7FFFFE)
    {
      unsigned int v15 = ((*v9 >> 25) * v12 + 3) & 0xFFFFFFFC;
      int v16 = (*v9 >> 2) & 3;
      unsigned int v17 = ((((HIWORD(*v9) & 0x3F) + 7) >> 3) * v12 + 3) & 0xFFFFFFFC;
      unsigned int v18 = v17 + v15;
      if (v16 != 1)
      {
        unsigned int v17 = 0;
        unsigned int v18 = ((*v9 >> 25) * v12 + 3) & 0xFFFFFFFC;
      }
      if (v16 == 2)
      {
        unsigned int v17 = ((*v9 >> 25) * v12 + 3) & 0xFFFFFFFC;
        unsigned int v19 = v17;
      }
      else
      {
        unsigned int v19 = v18;
      }
      unsigned int v20 = (v10 & 1) != 0 ? v17 : 0;
      unsigned int v21 = (v10 & 1) != 0 ? v19 : ((*v9 >> 25) * v12 + 3) & 0xFFFFFFFC;
      unint64_t v22 = v21 * (unint64_t)v13;
      size_t v23 = v22 > 0x7FFFFFFB ? 0xFFFFFFFFLL : (v22 + 19) & 0xFFFFFFF0;
      if ((v23 & 0x80000000) == 0)
      {
        CGFloat v24 = (char *)malloc_type_calloc(1uLL, v23, 0x2D8A5A23uLL);
        if (v24)
        {
          int v41 = v8;
          if (v20)
          {
            int v25 = (*v9 >> 2) & 3;
            double v26 = &v24[v15 * v13];
            if (v25 != 1) {
              double v26 = 0;
            }
            BOOL v27 = v25 == 2;
            double v28 = v24;
            if (v27) {
              double v29 = v24;
            }
            else {
              double v29 = v26;
            }
          }
          else
          {
            double v28 = v24;
            double v29 = 0;
          }
          unsigned int v40 = v28;
          int v33 = initialize_deep_mask(v9) | v10 & 0x3C;
          if (v9[4]) {
            int v31 = v33 | 0x200;
          }
          else {
            int v31 = v33;
          }
          int v39 = v20;
          goto LABEL_44;
        }
      }
    }
    return 0;
  }
  int v41 = v8;
  unsigned int v15 = 0;
  unsigned int v40 = 0;
  int v31 = v10 & 0x3C;
  if (v13 | v12) {
    int v32 = 12;
  }
  else {
    int v32 = 0;
  }
  int v39 = v32;
  if (v13 | v12) {
    double v29 = (char *)&the_empty_shape;
  }
  else {
    double v29 = 0;
  }
LABEL_44:
  if ((v31 & 0x10) != 0) {
    uint64_t v34 = 296;
  }
  else {
    uint64_t v34 = 0;
  }
  uint64_t v35 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
  float64x2_t v36 = (char *)malloc_type_calloc(1uLL, v35 + v34, 0x93A34CFFuLL);
  double v30 = v36;
  *(void *)float64x2_t v36 = a1;
  *((_DWORD *)v36 + 2) = 1;
  *(void *)(v36 + 12) = v42;
  *((_DWORD *)v36 + 5) = v12;
  *((_DWORD *)v36 + 6) = v13;
  *((_DWORD *)v36 + 7) = v31;
  CGFloat v37 = &v36[v35];
  if ((v31 & 0x10) == 0) {
    CGFloat v37 = 0;
  }
  *((void *)v36 + 4) = v9;
  *((void *)v36 + 5) = v37;
  *((_DWORD *)v36 + 12) = v15;
  *((_DWORD *)v36 + 13) = v41;
  *((void *)v36 + 7) = v40;
  *((_DWORD *)v36 + 16) = v39;
  *((void *)v36 + 9) = v29;
  pthread_mutex_init((pthread_mutex_t *)(v36 + 80), 0);
  return v30;
}

uint64_t ripl_size()
{
  return 144;
}

void *create_default_color_space(const __CFDictionary *a1, const void *a2, int a3)
{
  int Value = CFDictionaryGetValue(a1, a2);
  int v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (v6 == CGColorSpaceGetTypeID_type_id && *(_DWORD *)(v5[3] + 28) == a3) {
      CFRetain(v5);
    }
    else {
      return 0;
    }
  }
  return v5;
}

uint64_t CGColorSpaceCreateDisplayP3()
{
  if (CGColorSpaceCreateDisplayP3_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDisplayP3_predicate, &__block_literal_global_205_6499);
  }
  uint64_t v0 = CGColorSpaceCreateDisplayP3_space;
  if (CGColorSpaceCreateDisplayP3_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDisplayP3_space);
  }
  return v0;
}

uint64_t CG::DisplayListRecorder::recordAction(CFArrayRef *a1, char a2, const void *a3, const void *a4)
{
  uint64_t v7 = (char *)CG::DisplayListRecorder::currentDisplayList(a1);
  if (!v7) {
    return 1000;
  }
  if (*((double *)v7 + 5) == INFINITY || *((double *)v7 + 6) == INFINITY) {
    return 0;
  }
  uint64_t v16 = 0;
  if (*((double *)v7 + 7) != 0.0 && *((double *)v7 + 8) != 0.0)
  {
    unsigned int v17 = (CG::DisplayList *)(v7 + 16);
    switch(a2 & 0xF)
    {
      case 1:
      case 4:
        goto LABEL_13;
      case 2:
        if (v7[73]) {
          *(CGRect *)(v7 + 88) = CGRectNull;
        }
LABEL_13:
        uint64_t v16 = v7[74];
        if (v7[74]) {
          operator new();
        }
        return v16;
      case 3:
        uint64_t v16 = v7[74];
        if (!v7[74]) {
          return v16;
        }
        if (CG::DisplayList::cfTypeResourceForCFType((CG::DisplayList *)(v7 + 16), a4)) {
          operator new();
        }
        return result;
      case 5:
        CG::DisplayList::cfTypeResourceForCFType((CG::DisplayList *)(v7 + 16), a4);
        if (CG::DisplayList::cfTypeResourceForCFType(v17, a3)) {
          operator new();
        }
        return 1000;
      case 6:
        CGPostError((uint64_t)"Unimplemented", v8, v9, v10, v11, v12, v13, v14, v19);
        return 1006;
      default:
        return 0;
    }
    return 1000;
  }
  return v16;
}

uint64_t CGColorSpaceExtendedSRGB()
{
  if (CGColorSpaceExtendedSRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceExtendedSRGB_predicate, &__block_literal_global_286_6461);
  }
  uint64_t v0 = CGColorSpaceExtendedSRGB_space;
  if (CGColorSpaceExtendedSRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceExtendedSRGB_space);
  }
  return v0;
}

void CGClipRelease(char *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    int v2 = a1[8];
    switch(v2)
    {
      case 4:
        CGTextClippingRelease(*((void **)a1 + 3));
        break;
      case 3:
        CGClipMaskRelease(*((void **)a1 + 3));
        break;
      case 2:
        unint64_t v3 = (const void *)*((void *)a1 + 3);
        if (v3) {
          CFRelease(v3);
        }
        break;
    }
    uint64_t v4 = (void *)*((void *)a1 + 2);
    if (v4) {
      CGClipStrokeRelease(v4);
    }
    free(a1);
  }
}

uint64_t CGCFDictionaryGetInteger(CFDictionaryRef theDict, const void *a2, _DWORD *a3)
{
  uint64_t result = 0;
  if (theDict)
  {
    if (a2)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(theDict, a2);
      if (result)
      {
        CFNumberRef v6 = (const __CFNumber *)result;
        CFTypeID v7 = CFGetTypeID((CFTypeRef)result);
        if (v7 == CFNumberGetTypeID())
        {
          int valuePtr = 0;
          uint64_t result = CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
          if (result)
          {
            if (a3) {
              *a3 = valuePtr;
            }
            return 1;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t CGColorSpaceExtendedGray()
{
  if (CGColorSpaceExtendedGray_predicate != -1) {
    dispatch_once(&CGColorSpaceExtendedGray_predicate, &__block_literal_global_295);
  }
  uint64_t v0 = CGColorSpaceExtendedGray_space;
  if (CGColorSpaceExtendedGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceExtendedGray_space);
  }
  return v0;
}

uint64_t CGColorSpaceLinearSRGB()
{
  if (CGColorSpaceLinearSRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceLinearSRGB_predicate, &__block_literal_global_289);
  }
  uint64_t v0 = CGColorSpaceLinearSRGB_space;
  if (CGColorSpaceLinearSRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceLinearSRGB_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateGenericRGB()
{
  if (CGColorSpaceCreateGenericRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericRGB_predicate, &__block_literal_global_199);
  }
  uint64_t v0 = CGColorSpaceCreateGenericRGB_space;
  if (CGColorSpaceCreateGenericRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericRGB_space);
  }
  return v0;
}

uint64_t CGColorSpaceExtendedLinearSRGB()
{
  if (CGColorSpaceExtendedLinearSRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceExtendedLinearSRGB_predicate, &__block_literal_global_292);
  }
  uint64_t v0 = CGColorSpaceExtendedLinearSRGB_space;
  if (CGColorSpaceExtendedLinearSRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceExtendedLinearSRGB_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateGenericRGBLinear()
{
  if (CGColorSpaceCreateGenericRGBLinear_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericRGBLinear_predicate, &__block_literal_global_238);
  }
  uint64_t v0 = CGColorSpaceCreateGenericRGBLinear_space;
  if (CGColorSpaceCreateGenericRGBLinear_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericRGBLinear_space);
  }
  return v0;
}

uint64_t CGColorSpaceLinearGray()
{
  if (CGColorSpaceLinearGray_predicate != -1) {
    dispatch_once(&CGColorSpaceLinearGray_predicate, &__block_literal_global_298);
  }
  uint64_t v0 = CGColorSpaceLinearGray_space;
  if (CGColorSpaceLinearGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceLinearGray_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_709()
{
  if (CGColorSpaceCreateITUR_709_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_709_predicate, &__block_literal_global_250_6482);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_709_space;
  if (CGColorSpaceCreateITUR_709_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_709_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_2020()
{
  if (CGColorSpaceCreateITUR_2020_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_2020_predicate, &__block_literal_global_259_6476);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_2020_space;
  if (CGColorSpaceCreateITUR_2020_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_2020_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateROMMRGB()
{
  if (CGColorSpaceCreateROMMRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateROMMRGB_predicate, &__block_literal_global_280);
  }
  uint64_t v0 = CGColorSpaceCreateROMMRGB_space;
  if (CGColorSpaceCreateROMMRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateROMMRGB_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_2100_PQ()
{
  if (CGColorSpaceCreateITUR_2100_PQ_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_2100_PQ_predicate, &__block_literal_global_274);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_2100_PQ_space;
  if (CGColorSpaceCreateITUR_2100_PQ_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_2100_PQ_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_2100_HLG()
{
  if (CGColorSpaceCreateITUR_2100_HLG_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_2100_HLG_predicate, &__block_literal_global_277);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_2100_HLG_space;
  if (CGColorSpaceCreateITUR_2100_HLG_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_2100_HLG_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateITUR_2020_sRGBGamma()
{
  if (CGColorSpaceCreateITUR_2020_sRGBGamma_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateITUR_2020_sRGBGamma_predicate, &__block_literal_global_262_6473);
  }
  uint64_t v0 = CGColorSpaceCreateITUR_2020_sRGBGamma_space;
  if (CGColorSpaceCreateITUR_2020_sRGBGamma_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_2020_sRGBGamma_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateDisplayP3_PQ()
{
  if (CGColorSpaceCreateDisplayP3_PQ_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDisplayP3_PQ_predicate, &__block_literal_global_217);
  }
  uint64_t v0 = CGColorSpaceCreateDisplayP3_PQ_space;
  if (CGColorSpaceCreateDisplayP3_PQ_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDisplayP3_PQ_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateDisplayP3_HLG()
{
  if (CGColorSpaceCreateDisplayP3_HLG_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDisplayP3_HLG_predicate, &__block_literal_global_220);
  }
  uint64_t v0 = CGColorSpaceCreateDisplayP3_HLG_space;
  if (CGColorSpaceCreateDisplayP3_HLG_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDisplayP3_HLG_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateAdobeRGB1998()
{
  if (CGColorSpaceCreateAdobeRGB1998_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateAdobeRGB1998_predicate, &__block_literal_global_229_6492);
  }
  uint64_t v0 = CGColorSpaceCreateAdobeRGB1998_space;
  if (CGColorSpaceCreateAdobeRGB1998_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateAdobeRGB1998_space);
  }
  return v0;
}

uint64_t CGColorSpaceCoreMedia709()
{
  if (CGColorSpaceCoreMedia709_predicate != -1) {
    dispatch_once(&CGColorSpaceCoreMedia709_predicate, &__block_literal_global_151_6445);
  }
  uint64_t v0 = CGColorSpaceCoreMedia709_space;
  if (CGColorSpaceCoreMedia709_space) {
    CFRetain((CFTypeRef)CGColorSpaceCoreMedia709_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateLinearDisplayP3()
{
  if (CGColorSpaceCreateLinearDisplayP3_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateLinearDisplayP3_predicate, &__block_literal_global_211);
  }
  uint64_t v0 = CGColorSpaceCreateLinearDisplayP3_space;
  if (CGColorSpaceCreateLinearDisplayP3_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateLinearDisplayP3_space);
  }
  return v0;
}

uint64_t CGColorSpaceCreateGenericXYZ()
{
  if (CGColorSpaceCreateGenericXYZ_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateGenericXYZ_predicate, &__block_literal_global_244_6485);
  }
  uint64_t v0 = CGColorSpaceCreateGenericXYZ_space;
  if (CGColorSpaceCreateGenericXYZ_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericXYZ_space);
  }
  return v0;
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      long long v8 = *(_OWORD *)&t->a;
      long long v9 = *(_OWORD *)&t->c;
      *(_OWORD *)((char *)c + 152) = *(_OWORD *)&t->tx;
      *(_OWORD *)((char *)c + 136) = v9;
      *(_OWORD *)((char *)c + 120) = v8;
      return;
    }
    CGContextRef v10 = c;
  }
  else
  {
    CGContextRef v10 = 0;
  }
  handle_invalid_context((char)"CGContextSetTextMatrix", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
}

uint64_t CGMutablePathRef.addArc(tangent1End:tangent2End:radius:transform:)(_OWORD *a1)
{
  return sub_184C04A2C(a1, (uint64_t (*)(uint64_t, _OWORD *))CGPathAddArcToPoint);
}

uint64_t CGColorSpaceGetID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(*(void *)(result + 24) + 20);
  }
  return result;
}

uint64_t CGImageBlockSetGetImageBlock(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 120) <= a2) {
      return 0;
    }
    else {
      return *(void *)(result + 8 * a2 + 128);
    }
  }
  return result;
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  if (!dict) {
    return 0;
  }
  if (!rect) {
    return 0;
  }
  get_point_from_dict(dict, &rect->origin.x);
  if (!v4) {
    return 0;
  }

  get_size_from_dict(dict, &rect->size.width);
  return result;
}

double get_point_from_dict(const __CFDictionary *a1, double *a2)
{
  double result = get_number_from_dict(a1, @"X", a2);
  if (v5)
  {
    return get_number_from_dict(a1, @"Y", a2 + 1);
  }
  return result;
}

double get_size_from_dict(const __CFDictionary *a1, double *a2)
{
  double result = get_number_from_dict(a1, @"Width", a2);
  if (v5)
  {
    return get_number_from_dict(a1, @"Height", a2 + 1);
  }
  return result;
}

double get_number_from_dict(const __CFDictionary *a1, const void *a2, double *a3)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFNumberRef v6 = Value;
    double valuePtr = 0.0;
    if (CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
    {
      double result = valuePtr;
      *a3 = valuePtr;
    }
    else
    {
      float v7 = 0.0;
      if (CFNumberGetValue(v6, kCFNumberFloatType, &v7))
      {
        double result = v7;
        *a3 = v7;
      }
    }
  }
  return result;
}

void CGContextSetFontRenderingStyle(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGGStateSetFontRenderingStyle(*(void *)(a1 + 96), a2);
      return;
    }
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFontRenderingStyle", v8, a3, a4, a5, a6, a7, a8);
}

BOOL static CGAffineTransform.== infix(_:_:)(double *a1, double *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4] && a1[5] == a2[5];
}

void color_transform_base_finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  *(unsigned char *)(a1 + 40) = 0;
}

void CGImageTextureDataRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t CGImageTextureDataGetNumberOfMipmaps(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t CGImageBlockSetGetComponentType(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 64);
  }
  return result;
}

CGAffineTransform *__cdecl CGContextGetTextMatrix(CGAffineTransform *__return_ptr retstr, CGAffineTransform *c)
{
  if (c && LODWORD(c->c) == 1129601108)
  {
    long long v9 = (CGAffineTransform *)((char *)c + 120);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetTextMatrix", (uint64_t)c, v2, v3, v4, v5, v6, v7);
    long long v9 = &CGAffineTransformIdentity;
  }
  long long v10 = *(_OWORD *)&v9->c;
  *(_OWORD *)&retstr->double a = *(_OWORD *)&v9->a;
  *(_OWORD *)&retstr->double c = v10;
  *(_OWORD *)&retstr->double tx = *(_OWORD *)&v9->tx;
  return c;
}

void td_Finalize(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 96));
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 64));
  uint64_t v3 = *(void (**)(void))(a1 + 56);
  if (v3 && *(void *)(a1 + 24))
  {
    v3();
  }
}

void CGvImage_converter_data_key_release(CGColorSpaceRef *a1)
{
  if (a1)
  {
    CGColorSpaceRelease(a1[5]);
    CGColorSpaceRelease(a1[10]);
    free(a1);
  }
}

void __stroke_state_create_root_block_invoke()
{
  uint64_t v0 = (char *)malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
  *(_DWORD *)uint64_t v0 = 0;
  *((_DWORD *)v0 + 1) = 1;
  *(_OWORD *)(v0 + 8) = xmmword_1850CDF10;
  *((void *)v0 + 3) = 0;
  *((void *)v0 + 4) = 0;
  uint64_t v1 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  *((void *)v0 + 5) = CGColorSpaceCopyDefaultColor((uint64_t)v1);
  CGColorSpaceRelease(v1);
  stroke_state_create_root_root = (uint64_t)v0;
  char *v0 = 1;
}

void CGPDFGStateSetFillColor(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    CFTypeRef v4 = *(CFTypeRef *)(a1 + 56);
    if (v4 != cf)
    {
      if (v4) {
        CFRelease(v4);
      }
      if (cf) {
        CFRetain(cf);
      }
      *(void *)(a1 + 56) = cf;
    }
  }
}

BOOL CGPDFScannerPopName(CGPDFScannerRef scanner, const char **value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
    return 0;
  }
  uint64_t v3 = *((void *)scanner + 10);
  unsigned int v4 = v2 - 1;
  *((_DWORD *)scanner + 18) = v4;
  if (!v3 || *(_DWORD *)(v3 + 40 * v4 + 8) != 5) {
    return 0;
  }
  if (value) {
    *value = *(const char **)(v3 + 40 * v4 + 32);
  }
  return 1;
}

void *CGPDFContentStreamCreateResolvedColorSpace(uint64_t a1, void *cf)
{
  int v2 = cf;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = __CGColorSpaceCreateResolved_block_invoke;
    _OWORD v5[3] = &__block_descriptor_tmp_57_23013;
    long long v6 = *(_OWORD *)(a1 + 48);
    uint64_t v7 = v3;
    return (void *)CGColorSpaceCreateResolvedColorSpace(cf, (uint64_t)v5);
  }
  else if (cf)
  {
    CFRetain(cf);
  }
  return v2;
}

void CG::DisplayListExecutor::applyEntryStrokeState(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    CGGStateSetStrokeColor(a2, *(void **)(v4 + 16));
  }
  double v5 = *(double *)(a1 + 16);
  uint64_t v6 = *(void *)(a2 + 128);
  if (*(double *)(v6 + 8) != v5)
  {
    maybe_copy_stroke_state(a2);
    uint64_t v6 = *(void *)(a2 + 128);
    *(double *)(v6 + 8) = v5;
  }
  double v7 = *(double *)(a1 + 24);
  if (*(double *)(v6 + 24) != v7)
  {
    maybe_copy_stroke_state(a2);
    *(double *)(*(void *)(a2 + 128) + 24) = v7;
  }
  CGGStateSetLineCap(a2, *(char *)(a1 + 48));
  CGGStateSetLineJoin(a2, *(char *)(a1 + 49));
  double v8 = *(double *)(a1 + 32);
  uint64_t v9 = *(void *)(a2 + 128);
  if (*(double *)(v9 + 16) != v8)
  {
    maybe_copy_stroke_state(a2);
    uint64_t v9 = *(void *)(a2 + 128);
    *(double *)(v9 + 16) = v8;
  }
  int v10 = *(unsigned __int8 *)(a1 + 50);
  if (*(unsigned __int8 *)(v9 + 1) != v10)
  {
    maybe_copy_stroke_state(a2);
    *(unsigned char *)(*(void *)(a2 + 128) + 1) = v10;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (v11) {
    uint64_t v12 = *(atomic_uint **)(v11 + 16);
  }
  else {
    uint64_t v12 = 0;
  }

  CGGStateSetLineDash(a2, v12);
}

void CGGStateSetLineCap(uint64_t a1, int a2)
{
  if (*(char *)(*(void *)(a1 + 128) + 2) != a2)
  {
    char v2 = a2;
    maybe_copy_stroke_state(a1);
    *(unsigned char *)(*(void *)(a1 + 128) + 2) = v2;
  }
}

void CGGStateSetLineJoin(uint64_t a1, int a2)
{
  if (*(char *)(*(void *)(a1 + 128) + 3) != a2)
  {
    char v2 = a2;
    maybe_copy_stroke_state(a1);
    *(unsigned char *)(*(void *)(a1 + 128) + 3) = v2;
  }
}

void gradient_finalize(uint64_t a1)
{
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 24));
  char v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

void shading_finalize(uint64_t a1)
{
  char v2 = *(const void **)(a1 + 88);
  if (v2) {
    CFRelease(v2);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 24));
  switch(*(_DWORD *)(a1 + 20))
  {
    case 1:
      uint64_t v3 = *(const void **)(a1 + 184);
      if (v3) {
        goto LABEL_13;
      }
      break;
    case 2:
      uint64_t v3 = *(const void **)(a1 + 200);
      if (v3) {
        goto LABEL_13;
      }
      break;
    case 3:
      uint64_t v3 = *(const void **)(a1 + 160);
      if (v3) {
        goto LABEL_13;
      }
      break;
    case 4:
      uint64_t v3 = *(const void **)(a1 + 152);
      if (v3) {
LABEL_13:
      }
        CFRelease(v3);
      break;
    default:
      uint64_t v4 = *(void (**)(void))(a1 + 112);
      if (v4) {
        v4(*(void *)(a1 + 80));
      }
      break;
  }
  double v5 = *(void **)(a1 + 32);

  free(v5);
}

CGColorRef CGColorCreateSRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  components[0] = red;
  components[1] = green;
  CGFloat v15 = blue;
  CGFloat v16 = alpha;
  uint64_t v4 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
  double v5 = CGColorCreate(v4, components);
  CGColorSpaceRelease(v4);
  if (!v5) {
    CGPostError((uint64_t)"Color creation failed for SRGB colorspace %p, {%f, %f, %f %f}", v6, v7, v8, v9, v10, v11, v12, (char)v4);
  }
  return v5;
}

void CGContextStrokeRectWithWidth(CGContextRef c, CGRect rect, CGFloat width)
{
  CGFloat height = rect.size.height;
  CGFloat v5 = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
  CGContextSaveGState(c);
  CGContextSetLineWidth(c, width);
  v10.origin.CGFloat x = x;
  v10.origin.CGFloat y = y;
  v10.size.double width = v5;
  v10.size.CGFloat height = height;
  CGContextStrokeRect(c, v10);

  CGContextRestoreGState(c);
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    if (width >= 0.0 || width == -1.0905473e16)
    {
      uint64_t v9 = *((void *)c + 12);
      if (*(double *)(*(void *)(v9 + 128) + 8) != width)
      {
        maybe_copy_stroke_state(*((void *)c + 12));
        *(CGFloat *)(*(void *)(v9 + 128) + 8) = width;
      }
    }
    else
    {
      CGPostError((uint64_t)"%s: invalid line width: negative values are not allowed.", (uint64_t)c, v2, v3, v4, v5, v6, v7, (char)"CGContextSetLineWidth");
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetLineWidth", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
  if (!c)
  {
    CGContextRef v22 = 0;
LABEL_31:
    handle_invalid_context((char)"CGContextStrokeRect", (uint64_t)v22, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v22 = c;
    goto LABEL_31;
  }
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    unsigned int v18 = (const void *)*((void *)c + 21);
    if (v18)
    {
      CFRelease(v18);
      *((void *)c + 21) = 0;
    }
    double v19 = *(double *)(*(void *)(*((void *)c + 12) + 128) + 8);
    if (v19 > 0.0 || v19 == -1.0905473e16)
    {
      uint64_t v20 = *((void *)c + 5);
      if (v20)
      {
        unsigned int v21 = *(unsigned int (**)(void))(v20 + 64);
        if (v21)
        {
          if (v21() != 1006) {
            return;
          }
          CGFloat x = rect.origin.x;
          CGFloat y = rect.origin.y;
          CGFloat width = rect.size.width;
          CGFloat height = rect.size.height;
        }
        v25.origin.CGFloat x = x;
        v25.origin.CGFloat y = y;
        v25.size.CGFloat width = width;
        v25.size.CGFloat height = height;
        CGContextAddRect(c, v25);
        CGContextDrawPath(c, kCGPathStroke);
      }
    }
  }
}

uint64_t CGColorSpaceGetRenderingIntent(void *a1)
{
  if (!a1) {
    return 0;
  }
  int Type = CGColorSpaceGetType(a1);
  if (Type == 11)
  {
    CFArrayRef Value = **(const __CFArray ***)(a1[3] + 96);
    goto LABEL_14;
  }
  if (Type != 10)
  {
    if (Type == 6)
    {
      CFArrayRef Value = *(const __CFArray **)(*(void *)(a1[3] + 96) + 16);
      goto LABEL_14;
    }
    return 0;
  }
  uint64_t v7 = a1[3];
  if (*(_DWORD *)(v7 + 24) != 10) {
    _CGHandleAssert("CGColorSpaceProfileSetsGetSourceProfile", 434, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ProfileSets.c", "s->state->type == kCGColorSpaceProfileSets", "type = %d", v3, v4, v5, *(_DWORD *)(v7 + 24));
  }
  uint64_t v8 = *(void *)(v7 + 96);
  CFArrayRef Value = *(const __CFArray **)(v8 + 8);
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(*(CFTypeRef *)(v8 + 8));
    if (v9 != CFArrayGetTypeID()) {
      goto LABEL_13;
    }
    ValueAtIndeCGFloat x = (const __CFArray *)CFArrayGetValueAtIndex(Value, 0);
    CFArrayRef Value = ValueAtIndex;
    if (!ValueAtIndex) {
      goto LABEL_14;
    }
    CFTypeID v11 = CFGetTypeID(ValueAtIndex);
    if (v11 == CFDictionaryGetTypeID()) {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(Value, @"ColorSyncProfile");
    }
    else {
LABEL_13:
    }
      CFArrayRef Value = 0;
  }
LABEL_14:
  if (CGColorSpaceGetRenderingIntent_cglibrarypredicate != -1) {
    dispatch_once(&CGColorSpaceGetRenderingIntent_cglibrarypredicate, &__block_literal_global_29_22939);
  }
  CFDataRef RenderingIntent_f = (const __CFData *)CGColorSpaceGetRenderingIntent_f(Value);
  if (!RenderingIntent_f) {
    return 0;
  }
  CFDataRef v13 = RenderingIntent_f;
  unsigned int v14 = *((_DWORD *)CFDataGetBytePtr(RenderingIntent_f) + 16) - 1;
  if (v14 > 2) {
    uint64_t v15 = 3;
  }
  else {
    uint64_t v15 = dword_185296B90[v14];
  }
  CFRelease(v13);
  return v15;
}

void image_provider_finalize(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
    if (kCGImageProviderContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGImageProviderContentHeadroom_block_invoke_once, &__block_literal_global_89_3449);
    }
    if (v2 == CGImageProviderGetTypeID_image_provider_type_id)
    {
      switch(*(_DWORD *)(a1 + 64))
      {
        case 0:
        case 1:
          uint64_t v3 = *(void (**)(void))(a1 + 80);
          if (v3) {
            goto LABEL_7;
          }
          break;
        case 2:
          uint64_t v3 = *(void (**)(void))(a1 + 88);
          if (v3) {
            goto LABEL_7;
          }
          break;
        case 3:
          uint64_t v3 = *(void (**)(void))(a1 + 104);
          if (v3) {
LABEL_7:
          }
            v3(*(void *)(a1 + 56));
          break;
        default:
          break;
      }
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 40));
      uint64_t v4 = *(const void **)(a1 + 112);
      if (v4) {
        CFRelease(v4);
      }
      CGPropertiesRelease(*(CFTypeRef **)(a1 + 120));
      uint64_t v5 = *(const void **)(a1 + 136);
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void subImageProviderReleaseInfo(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 144);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t cache_finalize(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2)
  {
    do
    {
      cache_entry_release(*(char **)v2);
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2);
    uint64_t v3 = *(void **)(a1 + 120);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)v3[1];
        free(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 16));
  uint64_t v5 = *(const void **)(a1 + 40);
  if (v5) {
    CFRelease(v5);
  }

  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
}

void cache_entry_release(char *a1)
{
  if (a1)
  {
    for (uint64_t i = 24; i != 64; i += 8)
    {
      uint64_t v3 = *(const void **)&a1[i];
      if (v3) {
        CFRelease(v3);
      }
    }
    free(a1);
  }
}

void color_finalize(uint64_t a1)
{
  if ((a1 & 0x8000000000000000) == 0)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 24));
    uint64_t v2 = *(const void **)(a1 + 32);
    if (v2) {
      CFRelease(v2);
    }
    uint64_t v3 = *(const void **)(a1 + 40);
    if (v3)
    {
      CFRelease(v3);
    }
  }
}

void *CGColorTransformConvertNeedsCMS(void *result, void *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
      dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
    }
    if (v6 == CGColorTransformGetTypeID_type_id)
    {
      v11[0] = MEMORY[0x1E4F143A8];
      v11[1] = 0x40000000;
      v11[2] = __create_resolved_source_space_block_invoke;
      v11[3] = &__block_descriptor_tmp_36_17179;
      v11[4] = v5;
      ResolvedColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v11);
      Cache = CGColorTransformGetCache(v5);
      Conversionint Type = CGColorTransformCacheGetConversionType((uint64_t)Cache, ResolvedColorSpace, a3);
      CGColorSpaceRelease(ResolvedColorSpace);
      if (ConversionType) {
        BOOL v10 = (ConversionType & 0xFFFFFFFD) == 1;
      }
      else {
        BOOL v10 = 1;
      }
      return (void *)!v10;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *ripc_GetColor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6, double *a7, uint64_t a8)
{
  CFTypeID v9 = (int *)a6;
  uint64_t v11 = a3;
  uint64_t v12 = a2;
  uint64_t v246 = *MEMORY[0x1E4F143B8];
  if ((a4 & 2) != 0)
  {
    uint64_t FillColor = CGGStateGetFillColor(a3);
    if (FillColor)
    {
      unsigned int v14 = *(char **)(a1 + 176);
      if ((FillColor & 0x8000000000000000) == 0)
      {
LABEL_10:
        Alphdouble a = *(double *)(FillColor + 8 * *(void *)(FillColor + 56) + 56);
        goto LABEL_11;
      }
LABEL_7:
      uint64_t v23 = FillColor;
      Alphdouble a = CGTaggedColorGetAlpha(FillColor, v16, v17, v18, v19, v20, v21, v22);
      uint64_t FillColor = v23;
LABEL_11:
      double v25 = Alpha * *(double *)(*(void *)(v11 + 120) + 8);
      goto LABEL_12;
    }
LABEL_17:
    unsigned int v14 = 0;
    *a7 = *(double *)(*(void *)(v11 + 120) + 8) * 0.0;
    return v14;
  }
  if (a4)
  {
    uint64_t FillColor = CGGStateGetStrokeColor(a3);
    if (FillColor)
    {
      unsigned int v14 = *(char **)(a1 + 184);
      if ((FillColor & 0x8000000000000000) == 0) {
        goto LABEL_10;
      }
      goto LABEL_7;
    }
    goto LABEL_17;
  }
  if ((a4 & 8) == 0) {
    return 0;
  }
  uint64_t v52 = *(void *)(a3 + 136);
  uint64_t FillColor = *(void *)(v52 + 64);
  if (!FillColor)
  {
    unsigned int v14 = 0;
    *a7 = 0.0;
    return v14;
  }
  unsigned int v14 = *(char **)(a1 + 192);
  if (FillColor < 0)
  {
    uint64_t v53 = *(void *)(v52 + 64);
    double v54 = CGTaggedColorGetAlpha(FillColor, a2, a3, a4, (uint64_t)a5, a6, (uint64_t)a7, a8);
    uint64_t FillColor = v53;
    double v25 = v54;
  }
  else
  {
    double v25 = *(double *)(FillColor + 8 * *(void *)(FillColor + 56) + 56);
  }
LABEL_12:
  *a7 = v25;
  double v26 = 0.0;
  if (v25 < 0.0 || (double v26 = 1.0, v25 > 1.0))
  {
    *a7 = v26;
    double v25 = v26;
  }
  if (FillColor < 0) {
    int v27 = FillColor;
  }
  else {
    int v27 = *(_DWORD *)(FillColor + 16);
  }
  if (*((void *)v14 + 1) == FillColor && *((_DWORD *)v14 + 4) == v27) {
    goto LABEL_57;
  }
  unint64_t v233 = FillColor;
  if (FillColor < 1 || (uint64_t v28 = *(void *)(FillColor + 32)) == 0)
  {
    LODWORD(width) = v27;
    Cache = CGColorTransformGetCache(*(void **)(a1 + 120));
    __int16 v231 = v9;
    uint64_t v232 = v12;
    if (Cache)
    {
      uint64_t v41 = Cache[2];
      if (v41)
      {
        unint64_t v42 = *(void *)(*(void *)(v41 + 24) + 48);
        if (v42 >> 61)
        {
          *(void *)&double x = &v210;
          MEMORY[0x1F4188790](Cache, v40);
          uint64_t v50 = (double *)v209;
          uint64_t v51 = 0;
LABEL_45:
          int v58 = (CGColor *)v233;
          dispatch_once_t v59 = v14;
          uint64_t v60 = v11;
          uint64_t v61 = *(void *)(a1 + 120);
          uint64_t v62 = a1;
          if ((v233 & 0x8000000000000000) != 0)
          {
            CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v233, v43, v44, v45, v46, v47, v48, v49);
            int v58 = (CGColor *)v233;
          }
          else
          {
            CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(v233 + 24);
          }
          uint64_t v64 = ((int)(*(_DWORD *)(*(void *)(v60 + 120) + 4) << 12) >> 28);
          Components = (double *)CGColorGetComponents(v58);
          if (CGColorTransformConvertColorComponents(v61, ColorSpace, v64, Components, v51))
          {
            a1 = v62;
            unsigned int v14 = v59;
            if (v42)
            {
              CGAffineTransform v66 = (float *)(v59 + 28);
              unsigned int v67 = v51;
              do
              {
                double v68 = *v67++;
                float v69 = v68;
                *v66++ = v69;
                --v42;
              }
              while (v42);
            }
            int v70 = *(_DWORD *)(v62 + 128);
            uint64_t v11 = v60;
            unint64_t v71 = v233;
            int v72 = LODWORD(width);
          }
          else
          {
            int v70 = 0;
            unint64_t v71 = 0;
            int v72 = 0;
            unsigned int v14 = v59;
            *((_DWORD *)v59 + 7) = 0;
            a1 = v62;
            uint64_t v11 = v60;
          }
          CFTypeID v9 = v231;
          *((_DWORD *)v14 + 6) = v70;
          *((void *)v14 + 1) = v71;
          *((_DWORD *)v14 + 4) = v72;
          uint64_t v12 = v232;
          if (v51 != v50) {
            free(v51);
          }
          *((_DWORD *)v14 + 39) = 1065353216;
LABEL_57:
          if ((*(unsigned char *)(*(void *)(a1 + 48) + 29) & 2) != 0)
          {
            uint64_t v73 = *(void *)(v11 + 120);
            double v74 = *(double *)(v73 + 24);
            double v75 = *(double *)(v73 + 32);
            double v76 = *(double *)(a1 + 40);
            _ZF = v76 == 1.0;
            double v78 = *(double *)(v12 + 24) * v76;
            double v79 = *(double *)(v12 + 32) * v76;
            double v80 = *(double *)(v12 + 40) * v76;
            double v81 = *(double *)(v12 + 48) * v76;
            double v82 = *(double *)(v12 + 56) * v76;
            double v83 = *(double *)(v12 + 64) * v76;
            if (_ZF)
            {
              double v78 = *(double *)(v12 + 24);
              double v84 = *(double *)(v12 + 32);
            }
            else
            {
              double v84 = v79;
            }
            if (_ZF) {
              double v85 = *(double *)(v12 + 40);
            }
            else {
              double v85 = v80;
            }
            if (_ZF) {
              double v86 = *(double *)(v12 + 48);
            }
            else {
              double v86 = v81;
            }
            if (_ZF) {
              double v87 = *(double *)(v12 + 56);
            }
            else {
              double v87 = v82;
            }
            if (_ZF) {
              double v88 = *(double *)(v12 + 64);
            }
            else {
              double v88 = v83;
            }
            double v89 = v75 * v85 + v78 * v74 + v87;
            if (v89 <= 1073741820.0)
            {
              unsigned int v91 = vcvtmd_s64_f64(v89);
              if (v89 >= -1073741820.0) {
                int v90 = v91;
              }
              else {
                int v90 = -1073741823;
              }
            }
            else
            {
              int v90 = 0x3FFFFFFF;
            }
            *CFTypeID v9 = v90;
            double v92 = v75 * v86 + v84 * v74 + v88;
            if (v92 <= 1073741820.0)
            {
              if (v92 >= -1073741820.0) {
                unsigned int v93 = vcvtmd_s64_f64(v92);
              }
              else {
                unsigned int v93 = -1073741823;
              }
            }
            else
            {
              unsigned int v93 = 0x3FFFFFFF;
            }
            v9[1] = v93;
          }
          else
          {
            *(void *)CFTypeID v9 = 0;
          }
          return v14;
        }
        Cache = (void *)(8 * v42);
      }
      else
      {
        unint64_t v42 = 0;
        Cache = 0;
      }
    }
    else
    {
      unint64_t v42 = 0;
    }
    size_t v55 = MEMORY[0x1F4188790](Cache, v40);
    uint64_t v50 = (CGFloat *)((char *)&v210 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0));
    if (v42 <= 0x1FFFFFFFFFFFFFFELL) {
      uint64_t v51 = (CGFloat *)((char *)&v210 - ((v56 + 15) & 0xFFFFFFFFFFFFFFF0));
    }
    else {
      uint64_t v51 = 0;
    }
    double x = v57;
    if (v42 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
      uint64_t v51 = (double *)malloc_type_malloc(v55, 0x2BA212EuLL);
    }
    goto LABEL_45;
  }
  PatternBaseColor = CGColorGetPatternBaseColor(FillColor);
  if (v25 < 0.0 || v25 > 1.0) {
    _CGHandleAssert("ripc_GetPattern", 685, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPColor.c", "alpha >= 0 && alpha <= 1", "alpha (%f) must be [0,1]", v30, v31, v32, SLOBYTE(v25));
  }
  uint64_t v34 = PatternBaseColor;
  long long v236 = 0u;
  long long v237 = 0u;
  long long v235 = 0u;
  *(void *)CFTypeID v9 = 0;
  float64x2_t v35 = *(float64x2_t *)(v12 + 40);
  float64x2_t v238 = *(float64x2_t *)(v12 + 24);
  float64x2_t v239 = v35;
  float64x2_t v240 = *(float64x2_t *)(v12 + 56);
  double v36 = *(double *)(a1 + 40);
  if (v36 != 1.0)
  {
    float64x2_t v238 = vmulq_n_f64(v238, v36);
    float64x2_t v239 = vmulq_n_f64(v239, v36);
    float64x2_t v240 = vmulq_n_f64(v240, v36);
  }
  int v37 = *(unsigned __int8 *)(v12 + 81);
  uint64_t v227 = v11;
  CGFloat v228 = *(double *)&a1;
  if (v37) {
    int v38 = (*(_DWORD *)(*(void *)(v11 + 120) + 4) >> 8) & 0x10000;
  }
  else {
    int v38 = 0;
  }
  int v94 = *(unsigned __int8 *)(v12 + 82);
  unint64_t v241 = 0;
  uint64_t v242 = 0;
  _D12 = *(double *)(v28 + 24);
  double v95 = *(double *)(v28 + 32);
  double v97 = *(double *)(v28 + 48);
  _D14 = *(double *)(v28 + 56);
  double v99 = *(double *)(v28 + 64);
  _V0.D[1] = v238.f64[1];
  double v101 = vmlad_n_f64(v95 * v239.f64[0], _D12, v238.f64[0]);
  double v223 = *(double *)(v28 + 40);
  CGFloat v224 = v95;
  __asm { FMLA            D9, D12, V0.D[1] }
  v234.double a = v101;
  v234.double b = _D9;
  double v105 = vmlad_n_f64(v97 * v239.f64[0], v223, v238.f64[0]);
  __asm { FMLA            D11, D3, V0.D[1] }
  v234.double c = v105;
  v234.double d = _D11;
  __asm { FMLA            D1, D14, V0.D[1] }
  CGFloat v221 = vmlad_n_f64(v99 * v239.f64[0], _D14, v238.f64[0]) + 0.0;
  CGFloat v222 = v97;
  v234.double tx = v221;
  v234.double ty = _D1 + 0.0;
  double v220 = _D1 + 0.0;
  CGRect v247 = *(CGRect *)(v28 + 104);
  CGAffineTransform v243 = v234;
  CGFloat width = v247.size.width;
  double x = v247.origin.x;
  double height = v247.size.height;
  CGFloat y = v247.origin.y;
  CGRect v248 = CGRectApplyAffineTransform(v247, &v243);
  double v110 = v248.origin.x;
  uint64_t v111 = 0;
  int v112 = *(_DWORD *)(v28 + 20);
  if (v112 != 1)
  {
    unsigned int v14 = 0;
    if (v248.origin.x == INFINITY) {
      return v14;
    }
    if (v248.origin.y == INFINITY) {
      return v14;
    }
    unsigned int v14 = 0;
    if (v248.size.width == 0.0 || v248.size.height == 0.0) {
      return v14;
    }
    if (v112 || !*(unsigned char *)(v28 + 184)) {
      uint64_t v111 = 0;
    }
    else {
      uint64_t v111 = *(void *)(v28 + 80);
    }
  }
  CGFloat v217 = v248.origin.y;
  double v218 = v248.size.width;
  CGFloat v219 = v248.size.height;
  unsigned int v113 = vcvtpd_s64_f64(v25 * 255.0) | (v94 << 8);
  CFDictionaryRef v114 = &v234;
  if (!v111) {
    CFDictionaryRef v114 = (CGAffineTransform *)&v238;
  }
  long long v115 = *(_OWORD *)&v114->c;
  long long v235 = *(_OWORD *)&v114->a;
  long long v236 = v115;
  long long v237 = *(_OWORD *)&v114->tx;
  double v216 = _D12;
  if (RIPGetCacheState_predicate != -1)
  {
    CGFloat v194 = v248.origin.x;
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
    double v110 = v194;
  }
  int v116 = v113 | v38;
  if (*(unsigned char *)(RIPGetCacheState_cache_state + 33)
    && (CGFloat v117 = v110, v118 = CGColorGetPatternBaseColor(v233), v110 = v117, !v118))
  {
    uint64_t v133 = *(void *)(v233 + 32);
    if (v133)
    {
      if (!*(_DWORD *)(v133 + 20) && *(unsigned char *)(v133 + 184) && (uint64_t v140 = *(void *)(v133 + 80)) != 0)
      {
        int v134 = (uint64_t *)(v140 + 232);
        int v135 = 2;
      }
      else
      {
        int v134 = (uint64_t *)(v133 + 88);
        int v135 = 1;
      }
      uint64_t v119 = v12;
      uint64_t v136 = *v134;
    }
    else
    {
      uint64_t v119 = v12;
      uint64_t v136 = 0;
      int v135 = 1;
    }
    *(void *)&v243.double a = MEMORY[0x1E4F143A8];
    *(void *)&v243.double b = 0x40000000;
    *(void *)&v243.double c = __lookup_pattern_entry_block_invoke;
    *(void *)&v243.double d = &__block_descriptor_tmp_20120;
    *(void *)&v243.double tx = &v235;
    v243.double ty = v228;
    int v244 = v116;
    EntrCGFloat y = RIPDataGetEntry(*(uint64_t *)&v228, v136, v135, (uint64_t)&v243);
    double v110 = v117;
    if (Entry)
    {
      unsigned int v138 = Entry;
      if (v111)
      {
        double v139 = v217;
      }
      else
      {
        CGFloat v141 = *((double *)Entry + 18);
        CGFloat v142 = *((double *)Entry + 19);
        v249.origin.double x = v117;
        double v139 = v217;
        v249.origin.CGFloat y = v217;
        v249.size.CGFloat width = v218;
        v249.size.double height = v219;
        *(void *)&v258.origin.double x = Entry[16];
        *(void *)&v258.origin.CGFloat y = Entry[17];
        v258.size.CGFloat width = v141;
        v258.size.double height = v142;
        BOOL v143 = CGRectEqualToRect(v249, v258);
        double v110 = v117;
        if (!v143)
        {
          *(CGFloat *)unsigned int v209 = v141;
          *(CGFloat *)&v209[1] = v142;
          _CGHandleAssert("ripc_GetPattern", 725, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPColor.c", "CGRectEqualToRect(bbox, p->bounds)", "bbox{o:{%f,%f}, s:{%f,%f}} != bounds{o:{%f,%f}, s:{%f,%f}}", v144, v145, v146, SLOBYTE(v117));
        }
      }
      get_pattern_phase(v238.f64, v9, *(double *)(*(void *)(v227 + 120) + 24), *(double *)(*(void *)(v227 + 120) + 32), v110, v139);
      uint64_t v147 = v138[20];
      if (v147)
      {
        unsigned int v14 = (char *)v138[20];
        (*(void (**)(void))(*(void *)v147 + 16))();
        return v14;
      }
      return 0;
    }
  }
  else
  {
    uint64_t v119 = v12;
  }
  if (x == INFINITY
    || y == INFINITY
    || width == 0.0
    || height == 0.0
    || *(double *)(v28 + 136) != width
    || *(double *)(v28 + 144) != height
    || v218 * v219 > (double)(*(_DWORD *)(*(void *)(*(void *)&v228 + 48) + 24)
                            * *(_DWORD *)(*(void *)(*(void *)&v228 + 48) + 20)))
  {
    goto LABEL_112;
  }
  double v120 = fabs(width * v101);
  double v121 = fabs(width * _D9);
  double v122 = fabs(height * v105);
  double v123 = fabs(height * _D11);
  unsigned int v124 = vcvtd_n_s64_f64(v121, 8uLL);
  if (vcvtd_n_s64_f64(v122, 8uLL)) {
    BOOL v125 = 0;
  }
  else {
    BOOL v125 = v124 == 0;
  }
  if (v125)
  {
    CGFloat v128 = v216;
  }
  else
  {
    unsigned int v126 = vcvtd_n_s64_f64(v123, 8uLL);
    if (vcvtd_n_s64_f64(v120, 8uLL)) {
      BOOL v127 = 0;
    }
    else {
      BOOL v127 = v126 == 0;
    }
    CGFloat v128 = v216;
    if (v127)
    {
      double v120 = v122;
      double v123 = v121;
    }
    else
    {
      double v120 = v120 + v122;
      double v123 = v121 + v123;
      if (v120 > 1.0 || v123 > 1.0)
      {
LABEL_112:
        uint64_t v130 = *(void *)&v228;
        uint64_t v131 = v119;
        return create_pattern_tile_pattern(v130, v131, v227, v233, a5, &v238, v108, v109, v25);
      }
    }
  }
  uint64_t v232 = v119;
  double v148 = round(v120);
  if (v120 <= 1.0) {
    double v148 = 1.0;
  }
  double v149 = round(v123);
  if (v123 <= 1.0) {
    double v149 = 1.0;
  }
  int v150 = (int)v148;
  int v151 = (int)v149;
  LODWORD(v242) = (int)v148;
  HIDWORD(v242) = (int)v149;
  BOOL v152 = (int)v148 <= 1 && v151 < 2;
  if (!v152 && !*(_DWORD *)(v28 + 152))
  {
    unsigned int v179 = vcvtd_n_s64_f64(v149 - v123, 8uLL);
    if (vcvtd_n_s64_f64(v148 - v120, 8uLL) || v179 != 0)
    {
      uint64_t v130 = *(void *)&v228;
      uint64_t v131 = v232;
      return create_pattern_tile_pattern(v130, v131, v227, v233, a5, &v238, v108, v109, v25);
    }
  }
  double v212 = v110;
  __int16 v231 = v9;
  CGFloat v214 = (double)v151;
  CGFloat v215 = (double)v150;
  double v153 = v148 / v120;
  double v154 = v149 / v123;
  CGFloat v155 = v101 * v153;
  CGFloat v156 = _D9 * v153;
  v234.double a = v155;
  v234.double b = v156;
  CGFloat v157 = v105 * v154;
  CGFloat v158 = _D11 * v154;
  v234.double c = v157;
  v234.double d = v158;
  CGAffineTransform v243 = v234;
  v250.size.CGFloat width = width;
  v250.origin.double x = x;
  v250.size.double height = height;
  v250.origin.CGFloat y = y;
  CGRect v251 = CGRectApplyAffineTransform(v250, &v243);
  CGFloat v210 = v251.size.height;
  CGFloat v211 = v251.size.width;
  CGFloat y = v251.origin.x;
  LODWORD(x) = vcvtmd_s64_f64(v251.origin.x);
  CGFloat width = v251.origin.y;
  int v159 = vcvtmd_s64_f64(v251.origin.y);
  CGFloat v213 = floor(v251.origin.x);
  unint64_t v241 = __PAIR64__(v159, LODWORD(x));
  double height = floor(v251.origin.y);
  v245.double a = v128;
  v245.double b = v224;
  v245.double c = v223;
  v245.double d = v222;
  v245.double tx = _D14;
  v245.double ty = v99;
  CGAffineTransformInvert(&v243, &v245);
  v234.double a = v243.b * v157 + v243.a * v155;
  v234.double b = v243.b * v158 + v243.a * v156;
  v234.double c = v243.d * v157 + v243.c * v155;
  v234.double d = v243.d * v158 + v243.c * v156;
  v234.double tx = v221 + v157 * v243.ty + v243.tx * v155 + v213 - y;
  v234.double ty = v158 * v243.ty + v243.tx * v156 + v220 + height - width;
  if (*(unsigned char *)(v28 + 186)) {
    _NF = v25 < 1.0;
  }
  else {
    _NF = 1;
  }
  if (_NF) {
    int v161 = 33;
  }
  else {
    int v161 = 32;
  }
  unsigned __int8 v162 = RIPShouldCachePatterns();
  int v166 = v161 | 4;
  if ((v162 & (v34 == 0)) == 0) {
    int v166 = v161;
  }
  double v167 = *(double *)(*(void *)(*(void *)&v228 + 48) + 32);
  double v168 = (double)SLODWORD(x);
  unsigned int v169 = v150 | v151;
  if ((v169 & 0x80000000) != 0)
  {
    int v170 = v166;
    v252.origin.double x = v213;
    v252.origin.CGFloat y = height;
    double v171 = v214;
    v252.size.CGFloat width = v215;
    v252.size.double height = v214;
    if (COERCE_DOUBLE(CGRectStandardize(v252)) != v168) {
      return 0;
    }
    v253.origin.double x = v213;
    v253.origin.CGFloat y = height;
    v253.size.CGFloat width = v215;
    v253.size.double height = v214;
    CGRect v254 = CGRectStandardize(v253);
    if (v254.origin.y != (double)v159) {
      return 0;
    }
    double x = v167;
    v255.origin.double x = v213;
    v255.origin.CGFloat y = height;
    v255.size.CGFloat width = v215;
    v255.size.double height = v214;
    CGRect v256 = CGRectStandardize(v255);
    if (v256.size.width != v215) {
      return 0;
    }
    unsigned int v172 = v169 >> 31;
    double v173 = v214;
    unsigned int v174 = v231;
    uint64_t v175 = v232;
    int v166 = v170;
    if (v172)
    {
      v257.origin.double x = v213;
      v257.origin.CGFloat y = height;
      v257.size.CGFloat width = v215;
      v257.size.double height = v214;
      *(CGRect *)(&v173 - 3) = CGRectStandardize(v257);
      int v166 = v170;
    }
  }
  else
  {
    int v176 = v159;
    double v171 = v214;
    unsigned int v14 = 0;
    unsigned int v174 = v231;
    if (v213 != v168 || height != (double)v176) {
      return v14;
    }
    double x = *(double *)(*(void *)(*(void *)&v228 + 48) + 32);
    double v173 = v214;
    uint64_t v175 = v232;
  }
  if (v173 != v171) {
    return 0;
  }
  uint64_t v177 = *(void *)(*(void *)&v228 + 8);
  if (v177) {
    uint64_t v178 = *(unsigned int *)(v177 + 96);
  }
  else {
    uint64_t v178 = 3;
  }
  unsigned int v181 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)&v241, v166 | 8u, *(uint64_t *)&x, v178, v163, v164, v165);
  if (!v181)
  {
    uint64_t v130 = *(void *)&v228;
    uint64_t v131 = v175;
    return create_pattern_tile_pattern(v130, v131, v227, v233, a5, &v238, v108, v109, v25);
  }
  unsigned int v182 = v181;
  uint64_t v183 = v175;
  uint64_t v184 = v227;
  build_tile((uint64_t)v181, *(uint64_t *)&v228, v183, v227, v233, &CGSizeZero.width, &v234, v213, height, v211, v210, v25);
  *((_DWORD *)v182 + 3) = 0;
  *((_DWORD *)v182 + 4) = 0;
  unsigned int v14 = v182;
  get_pattern_phase(v238.f64, v174, *(double *)(*(void *)(v184 + 120) + 24), *(double *)(*(void *)(v184 + 120) + 32), v212, v217);
  if (RIPShouldCachePatterns()
    && !v34
    && ((*((_DWORD *)v182 + 12) * *((_DWORD *)v182 + 6)) & 0x80000000) == 0)
  {
    if (v111)
    {
      unsigned int v192 = *(void **)(v111 + 232);
      if (v192)
      {
        int v193 = 2;
        goto LABEL_194;
      }
      unint64_t v195 = RIPDataCreate(v111, v185, v186, v187, v188, v189, v190, v191);
      unsigned int v192 = v195;
      uint64_t v196 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v111 + 232), (unint64_t *)&v196, (unint64_t)v195, memory_order_relaxed, memory_order_relaxed);
      int v197 = *(void **)(v111 + 232);
      int v193 = 2;
    }
    else
    {
      unsigned int v192 = *(void **)(v28 + 88);
      if (v192)
      {
        int v193 = 1;
LABEL_194:
        unsigned int v199 = RIPCacheEntryCreate(v193, (uint64_t)v192);
        v199[8] = *(void *)&x;
        *((_DWORD *)v199 + 18) = v116;
        CGFloat v200 = v228;
        int v201 = *(_DWORD *)(*(void *)&v228 + 148);
        *(_OWORD *)((char *)v199 + 76) = *(_OWORD *)(*(void *)&v228 + 132);
        *((_DWORD *)v199 + 23) = v201;
        long long v202 = v236;
        *((_OWORD *)v199 + 6) = v235;
        *((_OWORD *)v199 + 7) = v202;
        (*(void (**)(char *))(*(void *)v182 + 16))(v182);
        v199[20] = v182;
        CGFloat v203 = v217;
        v199[16] = *(void *)&v212;
        *((CGFloat *)v199 + 17) = v203;
        CGFloat v204 = v219;
        *((double *)v199 + 18) = v218;
        *((CGFloat *)v199 + 19) = v204;
        RIPLockCacheState();
        unint64_t v205 = (void *)v192[3];
        uint64_t v206 = *v199;
        v192[3] = v199;
        *unsigned int v199 = v192 + 2;
        *unint64_t v205 = v206;
        *(void *)(v206 + 8) = v205;
        ++v192[5];
        ripc_AddEntry(*(void *)(*(void *)&v200 + 208), (uint64_t)v199);
        if (v192[5] <= 0x20uLL)
        {
          RIPUnlockCacheState();
        }
        else
        {
          int v207 = (uint64_t *)v192[2];
          RIPCacheEntryRemove(v207);
          v207[1] = 0;
          RIPUnlockCacheState();
          do
          {
            int v208 = (uint64_t *)v207[1];
            RIPCacheEntryRelease(v207);
            int v207 = v208;
          }
          while (v208);
        }
        return v14;
      }
      unint64_t v195 = RIPDataCreate(v28, v185, v186, v187, v188, v189, v190, v191);
      unsigned int v192 = v195;
      uint64_t v198 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v28 + 88), (unint64_t *)&v198, (unint64_t)v195, memory_order_relaxed, memory_order_relaxed);
      int v197 = *(void **)(v28 + 88);
      int v193 = 1;
    }
    if (v197 != v195)
    {
      CFRelease(v192);
      unsigned int v192 = v197;
    }
    if (v192) {
      goto LABEL_194;
    }
  }
  return v14;
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  BytePtr = (const CGFloat *)color;
  v20[1] = *MEMORY[0x1E4F143B8];
  if (color)
  {
    if (((unint64_t)color & 0x8000000000000000) != 0)
    {
      uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents((uint64_t)color, v1, v2, v3, v4, v5, v6, v7);
      uint64_t v10 = 8 * NumberOfComponents;
      MEMORY[0x1F4188790](NumberOfComponents, v11);
      bzero((char *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
      CGTaggedColorGetComponents((unint64_t)BytePtr, (uint64_t)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v12, v13, v14, v15, v16, v17);
      CFDataRef v18 = CFDataCreate(0, (const UInt8 *)v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
      BytePtr = (const CGFloat *)CFDataGetBytePtr(v18);
      CFAutorelease(v18);
    }
    else
    {
      return (const CGFloat *)((char *)color + 64);
    }
  }
  return BytePtr;
}

uint64_t CGGStateGetFillColor(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 72);
  if (!result)
  {
    uint64_t v3 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
    *(void *)(a1 + 72) = CGColorSpaceCopyDefaultColor((uint64_t)v3);
    CGColorSpaceRelease(v3);
    return *(void *)(a1 + 72);
  }
  return result;
}

uint64_t CGColorTransformConvertColorComponents(uint64_t result, void *a2, uint64_t a3, double *a4, double *a5)
{
  if (!result) {
    return result;
  }
  CFTypeID v9 = (void *)result;
  CFTypeID v17 = CFGetTypeID((CFTypeRef)result);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v17 != CGColorTransformGetTypeID_type_id) {
    return 0;
  }
  if (!a4 || !a5)
  {
    CGPostError((uint64_t)"%s: NULL components", v10, v11, v12, v13, v14, v15, v16, (char)"CGColorTransformConvertColorComponents");
    return 0;
  }
  v69[0] = MEMORY[0x1E4F143A8];
  v69[1] = 0x40000000;
  v69[2] = __create_resolved_source_space_block_invoke;
  v69[3] = &__block_descriptor_tmp_36_17179;
  v69[4] = v9;
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v69);
  if (!CGColorTransformGetAttributes(v9))
  {
    Cache = CGColorTransformGetCache(v9);
    if (Cache)
    {
      unint64_t v42 = (uint64_t *)Cache[2];
      if (v42)
      {
        uint64_t v43 = v42[3];
        if (v43) {
          unint64_t v42 = (uint64_t *)(v43 + 64);
        }
        else {
          unint64_t v42 = 0;
        }
      }
    }
    else
    {
      unint64_t v42 = 0;
    }
    if (ResolvedColorSpace)
    {
      uint64_t v46 = *((void *)ResolvedColorSpace + 3);
      uint64_t v47 = v46 ? (uint64_t *)(v46 + 64) : 0;
    }
    else
    {
      uint64_t v47 = 0;
    }
    if (v42 == v47
      || v42
      && v47
      && ((v49 = *v42, uint64_t v48 = v42[1], v51 = *v47, v50 = v47[1], v49 == v51) ? (v52 = v48 == v50) : (v52 = 0), v52))
    {
      if (ResolvedColorSpace)
      {
        for (uint64_t i = *(void *)(*((void *)ResolvedColorSpace + 3) + 48); i; --i)
        {
          double v54 = *a4++;
          *a5++ = v54;
        }
      }
      goto LABEL_106;
    }
  }
  uint64_t v19 = CGColorTransformGetCache(v9);
  uint64_t v20 = v9[11];
  pthread_mutex_lock((pthread_mutex_t *)v20);
  uint64_t v21 = *(void **)(v20 + 80);
  if (!v21)
  {
LABEL_44:
    pthread_mutex_unlock((pthread_mutex_t *)v20);
    if (CGColorSpaceGetType(ResolvedColorSpace) - 7 >= 3
      && CGColorTransformCacheGetConversionType((uint64_t)v19, ResolvedColorSpace, a3) == 3)
    {
      if (ResolvedColorSpace)
      {
        for (uint64_t j = *(void *)(*((void *)ResolvedColorSpace + 3) + 48); j; --j)
        {
          uint64_t v40 = *(void *)a4++;
          *(void *)a5++ = v40;
        }
      }
      goto LABEL_106;
    }
    Converter = CGColorTransformCacheCreateConverter((uint64_t)v19, ResolvedColorSpace, a3);
    if (CGCMSConverterConvertColorComponents(Converter, a4, a5))
    {
      if (ResolvedColorSpace)
      {
        unint64_t v45 = *(void *)(*((void *)ResolvedColorSpace + 3) + 48);
        if (v45 > 4)
        {
LABEL_104:
          if (Converter) {
            CFRelease(Converter);
          }
          goto LABEL_106;
        }
      }
      else
      {
        unint64_t v45 = 0;
      }
      uint64_t v55 = v9[11];
      pthread_mutex_lock((pthread_mutex_t *)v55);
      if (*(void *)(v55 + 72) > 0x3FuLL)
      {
        int v58 = *(void **)(v55 + 80);
        if (v58)
        {
          uint64_t v59 = *(void *)(v55 + 80);
          do
          {
            uint64_t v60 = (void **)v59;
            uint64_t v59 = *(void *)(v59 + 8);
          }
          while (v59);
          uint64_t v56 = (char *)*v60;
        }
        else
        {
          uint64_t v56 = 0;
        }
        double v57 = x_list_remove(v58, (uint64_t)v56);
        *(void *)(v55 + 80) = v57;
      }
      else
      {
        uint64_t v56 = (char *)malloc_type_malloc(0x58uLL, 0x100004038113C5CuLL);
        double v57 = *(void **)(v55 + 80);
        ++*(void *)(v55 + 72);
      }
      uint64_t v61 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
      if (v61)
      {
        *uint64_t v61 = v56;
        v61[1] = v57;
        double v57 = v61;
      }
      *(void *)(v55 + 80) = v57;
      uint64_t v62 = *((void *)ResolvedColorSpace + 3);
      if (v62) {
        uint64_t v63 = (_OWORD *)(v62 + 64);
      }
      else {
        uint64_t v63 = 0;
      }
      *(_OWORD *)uint64_t v56 = *v63;
      *((_DWORD *)v56 + 4) = a3;
      if (v45)
      {
        uint64_t v64 = v56 + 24;
        do
        {
          uint64_t v65 = *(void *)a4++;
          *v64++ = v65;
          --v45;
        }
        while (v45);
      }
      uint64_t v66 = *(unsigned int *)(v55 + 64);
      if (v66)
      {
        unsigned int v67 = v56 + 56;
        do
        {
          uint64_t v68 = *(void *)a5++;
          *v67++ = v68;
          --v66;
        }
        while (v66);
      }
      pthread_mutex_unlock((pthread_mutex_t *)v55);
      goto LABEL_104;
    }
    if (Converter) {
      CFRelease(Converter);
    }
    CGColorSpaceRelease(ResolvedColorSpace);
    return 0;
  }
  uint64_t v22 = *(uint64_t ***)(v20 + 80);
  while (1)
  {
    if (ResolvedColorSpace)
    {
      uint64_t v23 = *((void *)ResolvedColorSpace + 3);
      CGFloat v24 = (uint64_t *)(v23 + 64);
      if (!v23) {
        CGFloat v24 = 0;
      }
    }
    else
    {
      CGFloat v24 = 0;
    }
    double v25 = *v22;
    if (v24 == *v22
      || (v25 ? (BOOL v26 = v24 == 0) : (BOOL v26 = 1),
          !v26 && ((v28 = *v24, uint64_t v27 = v24[1], *v25 == v28) ? (v29 = v25[1] == v27) : (v29 = 0), v29)))
    {
      if (*((_DWORD *)v25 + 4) == a3)
      {
        if (!ResolvedColorSpace) {
          goto LABEL_34;
        }
        unint64_t v30 = *(void *)(*((void *)ResolvedColorSpace + 3) + 48);
        if (v30 <= 4) {
          break;
        }
      }
    }
LABEL_28:
    uint64_t v22 = (uint64_t **)v22[1];
    if (!v22) {
      goto LABEL_44;
    }
  }
  if (v30)
  {
    uint64_t v31 = (double *)(v25 + 3);
    uint64_t v32 = a4;
    while (*v31 == *v32)
    {
      ++v32;
      ++v31;
      if (!--v30) {
        goto LABEL_34;
      }
    }
    goto LABEL_28;
  }
LABEL_34:
  uint64_t v33 = *(unsigned int *)(v20 + 64);
  if (v33)
  {
    uint64_t v34 = v25 + 7;
    do
    {
      uint64_t v35 = *v34++;
      *(void *)a5++ = v35;
      --v33;
    }
    while (v33);
  }
  v69[0] = v21;
  if ((uint64_t *)*v21 == v25)
  {
    int v38 = v69;
LABEL_81:
    *int v38 = v21[1];
    v21[1] = v69[0];
  }
  else
  {
    double v36 = v21;
    while (1)
    {
      int v37 = v36;
      double v36 = (void *)v36[1];
      if (!v36) {
        break;
      }
      if ((uint64_t *)*v36 == v25)
      {
        int v38 = v37 + 1;
        uint64_t v21 = v36;
        goto LABEL_81;
      }
    }
  }
  *(void *)(v20 + 80) = v21;
  pthread_mutex_unlock((pthread_mutex_t *)v20);
LABEL_106:
  CGColorSpaceRelease(ResolvedColorSpace);
  return 1;
}

void *CGColorTransformGetCache(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
      dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
    }
    if (v2 == CGColorTransformGetTypeID_type_id) {
      return *(void **)(v1[3] + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

CGColorSpaceRef __create_resolved_source_space_block_invoke(uint64_t a1, void *a2)
{
  CFTypeID v2 = a2;
  switch(CGColorSpaceGetType(a2))
  {
    case 0u:
      if (!v2)
      {
        uint64_t v6 = *(void *)(a1 + 32);
        if (!v6) {
          return 0;
        }
LABEL_26:
        CFTypeID v2 = *(void **)(v6 + 40);
        goto LABEL_27;
      }
      uint64_t v6 = *(void *)(a1 + 32);
      if (!*(unsigned char *)(v2[3] + 9))
      {
        if (!v6) {
          return 0;
        }
        goto LABEL_26;
      }
      if (!v6) {
        return 0;
      }
      CFTypeID v2 = *(void **)(v6 + 64);
LABEL_27:
      if (v2) {
        CFRetain(v2);
      }
      return (CGColorSpaceRef)v2;
    case 1u:
      if (v2)
      {
        uint64_t v7 = *(void *)(a1 + 32);
        if (*(unsigned char *)(v2[3] + 9))
        {
          if (!v7) {
            return 0;
          }
          CFTypeID v2 = *(void **)(v7 + 72);
          goto LABEL_27;
        }
      }
      else
      {
        uint64_t v7 = *(void *)(a1 + 32);
      }
      if (!v7) {
        return 0;
      }
      CFTypeID v2 = *(void **)(v7 + 48);
      goto LABEL_27;
    case 2u:
      if (v2)
      {
        uint64_t v8 = *(void *)(a1 + 32);
        if (*(unsigned char *)(v2[3] + 9))
        {
          if (v8)
          {
            CFTypeID v2 = *(void **)(v8 + 80);
            goto LABEL_27;
          }
          return 0;
        }
      }
      else
      {
        uint64_t v8 = *(void *)(a1 + 32);
      }
      if (v8)
      {
        CFTypeID v2 = *(void **)(v8 + 56);
        goto LABEL_27;
      }
      return 0;
    case 3u:
    case 4u:
    case 6u:
    case 0xAu:
    case 0xBu:
      int v4 = *(unsigned __int8 *)(*(void *)(a1 + 32) + 96);
      return create_calibrated_space(v2, v4);
    default:
      goto LABEL_27;
  }
}

uint64_t CGColorSpaceCreateResolvedColorSpace(void *a1, uint64_t a2)
{
  if (!a1) {
    return (uint64_t)a1;
  }
  switch(CGColorSpaceGetType(a1))
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 6u:
    case 0xAu:
    case 0xBu:
      int v4 = *(uint64_t (**)(uint64_t, void *))(a2 + 16);
      return v4(a2, a1);
    case 7u:
      CFRetain(a1);
      uint64_t v6 = *(void *)(a1[3] + 96);
      ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(*(void *)v6, a2);
      uint64_t v8 = ResolvedColorSpace;
      if (*(CGColorSpace **)v6 == ResolvedColorSpace) {
        goto LABEL_14;
      }
      Indexedouble d = (uint64_t)CGColorSpaceCreateIndexed(ResolvedColorSpace, *(void *)(v6 + 8), *(const unsigned __int8 **)(v6 + 16));
      goto LABEL_13;
    case 8u:
      CFRetain(a1);
      uint64_t v10 = *(void *)(a1[3] + 96);
      uint64_t v8 = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(*(void *)(v10 + 8), a2);
      if (*(CGColorSpace **)(v10 + 8) == v8) {
        goto LABEL_14;
      }
      Indexedouble d = CGColorSpaceCreateDeviceN(*(void *)(a1[3] + 48), *(void *)v10, v8, *(void **)(v10 + 16), *(void *)(v10 + 24), v11, v12, v13);
      goto LABEL_13;
    case 9u:
      CFRetain(a1);
      uint64_t v14 = *(void **)(a1[3] + 96);
      uint64_t v15 = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(*v14, a2);
      uint64_t v8 = v15;
      if ((CGColorSpace *)*v14 == v15)
      {
LABEL_14:
        CGColorSpaceRelease(v8);
        return (uint64_t)a1;
      }
      Indexedouble d = (uint64_t)CGColorSpaceCreatePattern(v15);
LABEL_13:
      uint64_t v16 = Indexed;
      CGColorSpaceRelease(v8);
      CGColorSpaceRelease((CGColorSpaceRef)a1);
      uint64_t result = v16;
      break;
    default:
      CFRetain(a1);
      return (uint64_t)a1;
  }
  return result;
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  CGColorRef result = 0;
  if (!space || !components) {
    return result;
  }
  if (CGColorSpaceGetType(space) == 9) {
    return 0;
  }
  if (CGColorCreate_onceToken != -1) {
    dispatch_once(&CGColorCreate_onceToken, &__block_literal_global_2354);
  }
  if (!CGColorCreate_supportsTaggedPointers) {
    goto LABEL_91;
  }
  uint64_t v5 = *((void *)space + 3);
  uint64_t v6 = *(const void **)(v5 + 80);
  if (!v6) {
    goto LABEL_91;
  }
  uint64_t v7 = *(void *)(v5 + 48);
  unsigned int Type = CGColorSpaceGetType(space);
  if (Type < 5 && ((0x1Bu >> Type) & 1) != 0)
  {
    unsigned int v10 = dword_1852060F4[Type];
  }
  else
  {
    uint64_t v9 = *(void *)(*((void *)space + 3) + 48);
    if (v9 == 2)
    {
      if (CFEqual(v6, @"kCGColorSpaceSRGB"))
      {
        unsigned int v10 = 7;
      }
      else if (CFEqual(v6, @"kCGColorSpaceExtendedSRGB"))
      {
        unsigned int v10 = 14;
      }
      else if (CFEqual(v6, @"kCGColorSpaceDisplayP3"))
      {
        unsigned int v10 = 12;
      }
      else if (CFEqual(v6, @"kCGColorSpaceLinearSRGB"))
      {
        unsigned int v10 = 16;
      }
      else if (CFEqual(v6, @"kCGColorSpaceExtendedLinearSRGB"))
      {
        unsigned int v10 = 17;
      }
      else if (CFEqual(v6, @"kCGColorSpaceDCIP3"))
      {
        unsigned int v10 = 13;
      }
      else
      {
        if (!CFEqual(v6, @"kCGColorSpaceAdobeRGB1998")) {
          goto LABEL_91;
        }
        unsigned int v10 = 8;
      }
    }
    else
    {
      if (v9 != 1) {
        goto LABEL_91;
      }
      if (CFEqual(v6, @"kCGColorSpaceExtendedGray"))
      {
        unsigned int v10 = 15;
      }
      else
      {
        if (!CFEqual(v6, @"kCGColorSpaceGenericGrayGamma2_2")) {
          goto LABEL_91;
        }
        unsigned int v10 = 9;
      }
    }
  }
  if (v7 == 1)
  {
    double v18 = *components;
    double v17 = components[1];
    uint64_t v19 = (int)(*components * 65535.0);
    if ((double)v19 / 65535.0 == *components)
    {
      uint64_t v20 = (int)(v17 * 65535.0);
      if ((double)v20 / 65535.0 == v17)
      {
        if (CGTaggedColorCreate_predicate != -1)
        {
          unsigned int v39 = v10;
          dispatch_once(&CGTaggedColorCreate_predicate, &__block_literal_global_34);
          unsigned int v10 = v39;
        }
        uint64_t v21 = *MEMORY[0x1E4FBA8E0];
        CGColorRef result = (CGColorRef)((v19 << 39) | (v20 << 23) | (32 * v10) | 0x850000000000000FLL | 0x800);
        goto LABEL_54;
      }
    }
    if (v18 == 1.0 && (float v24 = v17 * 100.0, v24 / 100.0 == v17))
    {
      float v25 = v17 * 100.0;
      unsigned int v26 = 15;
    }
    else
    {
      if (v18 != 0.0 || (float v27 = v17 * 100.0, v27 / 100.0 != v17))
      {
        float v29 = v18 * 100.0;
        double v30 = v29;
        if (v17 == 1.0 && v30 / 100.0 == v18)
        {
          float v25 = v18 * 100.0;
          unsigned int v26 = 13;
          goto LABEL_89;
        }
        if (v17 == 0.0 && v30 / 100.0 == v18)
        {
          float v25 = v18 * 100.0;
          unsigned int v26 = 12;
          goto LABEL_89;
        }
        uint64_t v33 = (int)v29;
        float v34 = v17 * 100.0;
        uint64_t v35 = (int)v34;
        if ((double)v33 / 100.0 == v18 && (double)v35 / 100.0 == v17)
        {
          if (CGTaggedColorCreate_predicate != -1)
          {
            unsigned int v41 = v10;
            dispatch_once(&CGTaggedColorCreate_predicate, &__block_literal_global_34);
            unsigned int v10 = v41;
          }
          uint64_t v21 = *MEMORY[0x1E4FBA8E0];
          CGColorRef result = (CGColorRef)((v33 << 39) | (v35 << 23) | (32 * v10) | 0x850000000000180FLL);
          goto LABEL_54;
        }
        goto LABEL_91;
      }
      float v25 = v17 * 100.0;
      unsigned int v26 = 14;
    }
LABEL_89:
    CGColorRef result = (CGColorRef)CGTaggedColorCreate_Float32BPC(v26, v10, LODWORD(v25));
    goto LABEL_90;
  }
  if (v7 == 3)
  {
    double v11 = *components;
    double v12 = components[1];
    double v14 = components[2];
    double v13 = components[3];
    if ((double)(int)(*components * 255.0) / 255.0 == *components
      && (double)(int)(v12 * 255.0) / 255.0 == v12
      && (double)(int)(v14 * 255.0) / 255.0 == v14
      && (double)(int)(v13 * 255.0) / 255.0 == v13)
    {
      unint64_t v15 = ((unint64_t)(int)(*components * 255.0) << 24) | ((unint64_t)(int)(v12 * 255.0) << 16) | ((unint64_t)(int)(v14 * 255.0) << 8) | (int)(v13 * 255.0);
      if (CGTaggedColorCreate_predicate != -1)
      {
        unsigned int v38 = v10;
        dispatch_once(&CGTaggedColorCreate_predicate, &__block_literal_global_34);
        unsigned int v10 = v38;
      }
      CGColorRef result = (CGColorRef)((32 * v10) | (v15 << 23) | 0x850000000000000FLL);
      unint64_t v16 = *MEMORY[0x1E4FBA8E0] ^ (unint64_t)result;
      goto LABEL_55;
    }
    if (v11 == v12 && v12 == v14)
    {
      uint64_t v22 = (int)(v11 * 65535.0);
      if ((double)v22 / 65535.0 == v11)
      {
        uint64_t v23 = (int)(v13 * 65535.0);
        if ((double)v23 / 65535.0 == v13)
        {
          if (CGTaggedColorCreate_predicate != -1)
          {
            unsigned int v40 = v10;
            dispatch_once(&CGTaggedColorCreate_predicate, &__block_literal_global_34);
            unsigned int v10 = v40;
          }
          uint64_t v21 = *MEMORY[0x1E4FBA8E0];
          CGColorRef result = (CGColorRef)((v22 << 39) | (v23 << 23) | (32 * v10) | 0x850000000000000FLL | 0x1000);
LABEL_54:
          unint64_t v16 = v21 ^ (unint64_t)result;
LABEL_55:
          if ((~v16 & 0xC000000000000007) != 0) {
            CGColorRef result = (CGColorRef)(v16 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E4FBA8D0] + (v16 & 7)));
          }
LABEL_90:
          if (result) {
            return result;
          }
          goto LABEL_91;
        }
      }
      if (v11 == 1.0)
      {
        float v28 = v13 * 100.0;
        if (v28 / 100.0 == v13)
        {
          float v25 = v13 * 100.0;
          unsigned int v26 = 11;
          goto LABEL_89;
        }
      }
      if (v11 == 0.0)
      {
        float v31 = v13 * 100.0;
        if (v31 / 100.0 == v13)
        {
          float v25 = v13 * 100.0;
          unsigned int v26 = 10;
          goto LABEL_89;
        }
      }
      if (v13 == 1.0)
      {
        float v32 = v11 * 100.0;
        if (v32 / 100.0 == v11)
        {
          float v25 = v11 * 100.0;
          unsigned int v26 = 9;
          goto LABEL_89;
        }
      }
      if (v13 == 0.0)
      {
        float v37 = v11 * 100.0;
        if (v37 / 100.0 == v11)
        {
          float v25 = v11 * 100.0;
          unsigned int v26 = 8;
          goto LABEL_89;
        }
      }
    }
  }
LABEL_91:

  return (CGColorRef)create_color(space, components);
}

uint64_t CGColorSpaceGetType(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  if (v2 == CGColorSpaceGetTypeID_type_id) {
    return *(unsigned int *)(a1[3] + 24);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

CGColorSpaceRef create_calibrated_space(void *cf, int a2)
{
  if (a2)
  {
    if (cf) {
      CFRetain(cf);
    }
    return (CGColorSpaceRef)cf;
  }
  else
  {
    switch(CGColorSpaceGetType(cf))
    {
      case 3u:
        goto LABEL_10;
      case 4u:
        goto LABEL_13;
      case 6u:
      case 0xAu:
      case 0xBu:
        if (!cf) {
          goto LABEL_19;
        }
        int v7 = *(_DWORD *)(cf[3] + 28);
        if (v7 == 2)
        {
          CGColorSpaceRef result = CGColorSpaceCreateDeviceCMYK();
        }
        else if (v7 == 1)
        {
LABEL_13:
          CGColorSpaceRef result = CGColorSpaceCreateDeviceRGB();
        }
        else
        {
          if (v7) {
LABEL_19:
          }
            _CGHandleAssert("create_calibrated_space", 363, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransform.c", "", "Unimplemented", v4, v5, v6, v8);
LABEL_10:
          CGColorSpaceRef result = CGColorSpaceCreateDeviceGray();
        }
        break;
      default:
        goto LABEL_19;
    }
  }
  return result;
}

uint64_t CGColorTransformGetAttributes(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v2 == CGColorTransformGetTypeID_type_id) {
    return a1[4];
  }
  else {
    return 0;
  }
}

uint64_t CGColorTransformCacheGetConversionType(uint64_t a1, void *a2, uint64_t a3)
{
  unsigned int v22 = -1;
  if (!*(void *)(a1 + 40))
  {
    char v8 = *(uint64_t **)(a1 + 16);
    if (v8)
    {
      uint64_t v9 = v8[3];
      if (v9) {
        char v8 = (uint64_t *)(v9 + 64);
      }
      else {
        char v8 = 0;
      }
    }
    if (a2)
    {
      uint64_t v10 = a2[3];
      double v11 = v10 ? (uint64_t *)(v10 + 64) : 0;
    }
    else
    {
      double v11 = 0;
    }
    if (v8 == v11) {
      return 3;
    }
    if (v8 && v11)
    {
      uint64_t v18 = *v8;
      uint64_t v17 = v8[1];
      uint64_t v20 = *v11;
      uint64_t v19 = v11[1];
      if (v18 == v20 && v17 == v19) {
        return 3;
      }
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (a2)
  {
    uint64_t v6 = a2[3];
    if (v6) {
      int v7 = (void *)(v6 + 64);
    }
    else {
      int v7 = 0;
    }
  }
  else
  {
    int v7 = 0;
  }
  cache_entrCGFloat y = find_cache_entry(*(void *)(a1 + 120), v7);
  if (cache_entry)
  {
    unsigned int v22 = *((_DWORD *)cache_entry + 4);
  }
  else
  {
    double v14 = (const void *)CGCMSConverterCreate(*(void **)(a1 + 16), a2, a3, *(unsigned __int8 *)(a1 + 48), *(const __CFDictionary **)(a1 + 40), (int *)&v22);
    if (v14)
    {
      unint64_t v15 = v14;
      updatedouble d = (char *)update_cache(a1, v14, v22, (uint64_t)a2, a3);
      CFRelease(v15);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      if (updated) {
        cache_entry_release(updated);
      }
      return v22;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
  return v22;
}

void color_transform_finalize(uint64_t a1)
{
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 40));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 48));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 56));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 64));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 72));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 80));
  uint64_t v5 = *(const void **)(a1 + 32);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  if (!*(unsigned char *)(v6 + 40)) {
    _CGHandleAssert("CGColorTransformBaseCacheRelease", 174, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransformBase.c", "base->is_valid", "invalid", v2, v3, v4, v24);
  }
  pthread_mutex_lock(&cacheMutex);
  uint64_t v7 = *(void *)(v6 + 16);
  if (v7) {
    uint64_t v8 = *(void *)(v7 + 16);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (void *)base_cache;
  if (!base_cache) {
    goto LABEL_20;
  }
  unint64_t v10 = *(void *)(v6 + 24);
  while (1)
  {
    uint64_t v11 = *v9;
    unint64_t v12 = *(void *)(*v9 + 24);
    if ((!(v10 | v12) || v10 && v12 && CFEqual((CFTypeRef)v10, (CFTypeRef)v12))
      && matches_space(*(void *)(v11 + 16), v8))
    {
      break;
    }
    uint64_t v9 = (void *)v9[1];
    if (!v9) {
      goto LABEL_20;
    }
  }
  if (v11 != v6) {
    _CGHandleAssert("baseCacheRelease__", 154, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransformBase.c", "b == base", "b: %p  base: %p", v13, v14, v15, v11);
  }
  uint64_t v16 = *(void *)(v6 + 32);
  if (!v16) {
    _CGHandleAssert("baseCacheRelease__", 155, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransformBase.c", "b->use_count > 0", "count %zu", v13, v14, v15, 0);
  }
  if (!*(unsigned char *)(v6 + 40)) {
    _CGHandleAssert("baseCacheRelease__", 156, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransformBase.c", "b->is_valid", "dictionary not valid", v13, v14, v15, v24);
  }
  uint64_t v17 = v16 - 1;
  *(void *)(v6 + 32) = v17;
  if (!v17)
  {
    base_cache = (uint64_t)x_list_remove((void *)base_cache, v6);
    pthread_mutex_unlock(&cacheMutex);
    uint64_t v23 = *(const void **)(v11 + 24);
    if (v23) {
      CFRelease(v23);
    }
    CFRelease((CFTypeRef)v6);
  }
  else
  {
LABEL_20:
    pthread_mutex_unlock(&cacheMutex);
  }
  uint64_t v18 = *(void *)(a1 + 88);
  uint64_t v19 = *(void *)(v18 + 80);
  if (v19)
  {
    do
    {
      free(*(void **)v19);
      uint64_t v19 = *(void *)(v19 + 8);
    }
    while (v19);
    uint64_t v18 = *(void *)(a1 + 88);
    uint64_t v20 = *(void **)(v18 + 80);
    if (v20)
    {
      do
      {
        uint64_t v21 = (void *)v20[1];
        free(v20);
        uint64_t v20 = v21;
      }
      while (v21);
      uint64_t v18 = *(void *)(a1 + 88);
    }
  }
  pthread_mutex_destroy((pthread_mutex_t *)v18);
  unsigned int v22 = *(void **)(a1 + 88);

  free(v22);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  if (space)
  {
    CFTypeID v2 = CFGetTypeID(space);
    if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
      dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
    }
    if (v2 == CGColorSpaceGetTypeID_type_id)
    {
      CFRelease(space);
    }
  }
}

BOOL matches_space(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    CFTypeID v2 = *(uint64_t **)(a1 + 16);
    if (v2)
    {
      uint64_t v3 = v2[3];
      if (v3) {
        CFTypeID v2 = (uint64_t *)(v3 + 64);
      }
      else {
        CFTypeID v2 = 0;
      }
    }
    if (a2) {
      goto LABEL_7;
    }
LABEL_11:
    uint64_t v5 = 0;
    goto LABEL_12;
  }
  CFTypeID v2 = 0;
  if (!a2) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4) {
    uint64_t v5 = (uint64_t *)(v4 + 64);
  }
  else {
    uint64_t v5 = 0;
  }
LABEL_12:
  if (v2 == v5) {
    return 1;
  }
  BOOL result = 0;
  if (v2 && v5)
  {
    uint64_t v8 = *v2;
    uint64_t v7 = v2[1];
    uint64_t v10 = *v5;
    uint64_t v9 = v5[1];
    return v8 == v10 && v7 == v9;
  }
  return result;
}

const void *CGColorTransformCacheCreateConverter(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (a2)
  {
    uint64_t v7 = a2[3];
    if (v7) {
      uint64_t v8 = (void *)(v7 + 64);
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v20 = 0;
  uint64_t v9 = *(void **)(a1 + 120);
  cache_entrCGFloat y = find_cache_entry((uint64_t)v9, v8);
  if (cache_entry)
  {
    uint64_t v11 = &cache_entry[(int)a3];
    uint64_t v13 = v11[3];
    unint64_t v12 = (CFTypeRef *)(v11 + 3);
    if (v13)
    {
      uint64_t v21 = v9;
      if (v9)
      {
        if ((void *)*v9 == cache_entry)
        {
          uint64_t v16 = &v21;
LABEL_18:
          *uint64_t v16 = v9[1];
          v9[1] = v21;
        }
        else
        {
          uint64_t v14 = v9;
          while (1)
          {
            uint64_t v15 = v14;
            uint64_t v14 = (void *)v14[1];
            if (!v14) {
              break;
            }
            if ((void *)*v14 == cache_entry)
            {
              uint64_t v16 = v15 + 1;
              uint64_t v9 = v14;
              goto LABEL_18;
            }
          }
        }
      }
      *(void *)(a1 + 120) = v9;
      if (*v12) {
        uint64_t v17 = CFRetain(*v12);
      }
      else {
        uint64_t v17 = 0;
      }
      goto LABEL_22;
    }
  }
  int v20 = -1;
  uint64_t v17 = (const void *)CGCMSConverterCreate(*(void **)(a1 + 16), a2, a3, *(unsigned __int8 *)(a1 + 48), *(const __CFDictionary **)(a1 + 40), &v20);
  if (!v17)
  {
LABEL_22:
    pthread_mutex_unlock(v6);
    return v17;
  }
  updatedouble d = (char *)update_cache(a1, v17, v20, (uint64_t)a2, a3);
  pthread_mutex_unlock(v6);
  if (updated) {
    cache_entry_release(updated);
  }
  return v17;
}

void *find_cache_entry(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  while (1)
  {
    CFTypeID v2 = *(void **)a1;
    if (*(void **)a1 == a2) {
      break;
    }
    if (a2 && v2 && *v2 == *a2 && v2[1] == a2[1]) {
      return v2;
    }
    a1 = *(void *)(a1 + 8);
    if (!a1) {
      return 0;
    }
  }
  return a2;
}

void *CGCMSConverterConvertColorComponents(void *cf, double *a2, double *a3)
{
  uint64_t v3 = cf;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    uint64_t v8 = kCGCMSConverterID;
    if (!kCGCMSConverterID)
    {
      pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
      uint64_t v8 = kCGCMSConverterID;
    }
    if (v6 == v8)
    {
      uint64_t v35 = &v32;
      uint64_t v10 = v3[5];
      uint64_t v9 = v3[6];
      size_t v11 = MEMORY[0x1F4188790](4 * v9, v7);
      float v34 = (float *)((char *)&v32 - v13);
      if (v12 <= 0x3FFFFFFFFFFFFFFELL) {
        uint64_t v16 = (float *)((char *)&v32 - v13);
      }
      else {
        uint64_t v16 = 0;
      }
      size_t v17 = v11;
      if (v12 - 0x3FFFFFFFFFFFFFFFLL >= v14) {
        uint64_t v16 = (float *)malloc_type_malloc(v11, 0x6898BB75uLL);
      }
      size_t v18 = MEMORY[0x1F4188790](4 * v10, v15);
      uint64_t v33 = (float *)((char *)&v32 - v20);
      if (v19 <= 0x3FFFFFFFFFFFFFFELL) {
        unsigned int v22 = (float *)((char *)&v32 - v20);
      }
      else {
        unsigned int v22 = 0;
      }
      size_t v23 = v18;
      if (v19 - 0x3FFFFFFFFFFFFFFFLL >= v21) {
        unsigned int v22 = (float *)malloc_type_malloc(v18, 0xB30440D6uLL);
      }
      if (v9)
      {
        char v24 = v16;
        uint64_t v25 = v9;
        do
        {
          double v26 = *a2++;
          float v27 = v26;
          *v24++ = v27;
          --v25;
        }
        while (v25);
      }
      uint64_t v82 = 0;
      long long v80 = 0u;
      long long v81 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      long long v76 = 0u;
      long long v77 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      long long v70 = 0u;
      long long v71 = 0u;
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      uint64_t v58 = 0;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v48 = 0u;
      long long v49 = 0u;
      long long v46 = 0u;
      long long v47 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v39 = 0u;
      int64x2_t v60 = vdupq_n_s64(1uLL);
      uint64_t v59 = v16;
      size_t v61 = v17;
      DWORD1(v65) = 0x2000;
      uint64_t v63 = 32;
      uint64_t v64 = v9;
      int v28 = *((_DWORD *)v3 + 21);
      DWORD2(v62) = 4;
      LODWORD(v62) = v28;
      double v36 = v22;
      int64x2_t v37 = v60;
      size_t v38 = v23;
      DWORD1(v41) = 0x2000;
      *(void *)&long long v40 = 32;
      *((void *)&v40 + 1) = v10;
      DWORD2(v39) = 4;
      LODWORD(v39) = v28;
      uint64_t v3 = CGCMSConverterConvert(v3, (uint64_t)&v59, (uint64_t)&v36);
      if (v3 && v10)
      {
        float v29 = v22;
        do
        {
          float v30 = *v29++;
          *a3++ = v30;
          --v10;
        }
        while (v10);
      }
      if (v16 != v34) {
        free(v16);
      }
      if (v22 != v33) {
        free(v22);
      }
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void *CGCMSConverterConvert(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    uint64_t v7 = kCGCMSConverterID;
    if (!kCGCMSConverterID)
    {
      pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
      uint64_t v7 = kCGCMSConverterID;
    }
    if (v6 == v7)
    {
      uint64_t v8 = (uint64_t (*)(void *, uint64_t, uint64_t, _OWORD *))v5[7];
      uint64_t v10 = 0;
      memset(v9, 0, sizeof(v9));
      return (void *)v8(v5, a2, a3, v9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void set_stroke_color_with_components(uint64_t *a1, CGColorSpace *a2, const CGFloat *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2)
  {
    CGColorSpaceRef ColorSpace = a2;
    unint64_t v12 = 0;
    goto LABEL_3;
  }
  unint64_t StrokeColor = CGGStateGetStrokeColor(a1[12]);
  if (!StrokeColor) {
    goto LABEL_21;
  }
  unint64_t v12 = StrokeColor;
  if ((StrokeColor & 0x8000000000000000) == 0)
  {
    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(StrokeColor + 24);
    if (ColorSpace) {
      goto LABEL_3;
    }
LABEL_21:
    uint64_t v20 = "No color space specified for stroke color.";
    goto LABEL_22;
  }
  CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(StrokeColor, v13, v14, v15, v16, v17, v18, v19);
  if (!ColorSpace) {
    goto LABEL_21;
  }
LABEL_3:
  if (!a3)
  {
    unsigned int v22 = CGColorSpaceCopyDefaultColor((uint64_t)ColorSpace);
    goto LABEL_15;
  }
  if (CGColorSpaceGetType(ColorSpace) == 9)
  {
    uint64_t v20 = "No pattern specified with pattern color space.";
LABEL_22:
    CGPostError((uint64_t)v20, v13, v14, v15, v16, v17, v18, v19, a9);
    return;
  }
  if (!v12) {
    unint64_t v12 = CGGStateGetStrokeColor(a1[12]);
  }
  if ((CGColorEqualToColorComponents(v12, (uint64_t)ColorSpace, 0, a3, v16, v17, v18, v19) & 1) == 0)
  {
    unsigned int v22 = CGColorCreate(ColorSpace, a3);
LABEL_15:
    size_t v23 = v22;
    CGContextSetStrokeColorWithColor((CGContextRef)a1, v22);
    if (v23)
    {
      CFRelease(v23);
    }
  }
}

void CGGStateSetStrokeColor(uint64_t a1, void *a2)
{
  if (!CGColorEqualToColor(*(CGColorRef *)(*(void *)(a1 + 128) + 40), (CGColorRef)a2))
  {
    maybe_copy_stroke_state(a1);
    uint64_t v4 = *(const void **)(*(void *)(a1 + 128) + 40);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 128) + 40) = a2;
  }
}

void maybe_copy_stroke_state(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 20) & 4) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 128);
    uint64_t v3 = malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
    size_t v11 = v3;
    *(unsigned char *)uint64_t v3 = 0;
    v3[1] = 1;
    *((void *)v3 + 1) = *(void *)(v2 + 8);
    __int16 v12 = *(_WORD *)(v2 + 2);
    *((unsigned char *)v3 + 2) = v12;
    *((_WORD *)v3 + 1) = v12 | (*(unsigned __int8 *)(v2 + 3) << 8);
    *((_OWORD *)v3 + 1) = *(_OWORD *)(v2 + 16);
    *((unsigned char *)v3 + 1) = *(unsigned char *)(v2 + 1);
    uint64_t v13 = *(atomic_uint **)(v2 + 32);
    if (v13) {
      atomic_fetch_add_explicit(v13, 1u, memory_order_relaxed);
    }
    *((void *)v3 + 4) = v13;
    uint64_t v14 = *(void *)(v2 + 40);
    if (v14) {
      CFRetain(*(CFTypeRef *)(v2 + 40));
    }
    *((void *)v11 + 5) = v14;
    *(void *)(a1 + 128) = v11;
    stroke_state_release((void *)v2, v4, v5, v6, v7, v8, v9, v10);
    *(unsigned char *)(a1 + 20) &= ~4u;
  }
}

void CGContextSetStrokeColorWithColor(CGContextRef c, CGColorRef color)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetStrokeColor(*((void *)c + 12), color);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetStrokeColorWithColor", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

void set_fill_color_with_components(uint64_t *a1, CGColorSpace *a2, const CGFloat *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2)
  {
    CGColorSpaceRef ColorSpace = a2;
    unint64_t v12 = 0;
    goto LABEL_3;
  }
  unint64_t FillColor = CGGStateGetFillColor(a1[12]);
  if (!FillColor) {
    goto LABEL_21;
  }
  unint64_t v12 = FillColor;
  if ((FillColor & 0x8000000000000000) == 0)
  {
    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(FillColor + 24);
    if (ColorSpace) {
      goto LABEL_3;
    }
LABEL_21:
    uint64_t v20 = "No color space specified for fill color.";
    goto LABEL_22;
  }
  CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(FillColor, v13, v14, v15, v16, v17, v18, v19);
  if (!ColorSpace) {
    goto LABEL_21;
  }
LABEL_3:
  if (!a3)
  {
    unsigned int v22 = CGColorSpaceCopyDefaultColor((uint64_t)ColorSpace);
    goto LABEL_15;
  }
  if (CGColorSpaceGetType(ColorSpace) == 9)
  {
    uint64_t v20 = "No pattern specified for pattern color space.";
LABEL_22:
    CGPostError((uint64_t)v20, v13, v14, v15, v16, v17, v18, v19, a9);
    return;
  }
  if (!v12) {
    unint64_t v12 = CGGStateGetFillColor(a1[12]);
  }
  if ((CGColorEqualToColorComponents(v12, (uint64_t)ColorSpace, 0, a3, v16, v17, v18, v19) & 1) == 0)
  {
    unsigned int v22 = CGColorCreate(ColorSpace, a3);
LABEL_15:
    size_t v23 = v22;
    CGContextSetFillColorWithColor((CGContextRef)a1, v22);
    if (v23)
    {
      CFRelease(v23);
    }
  }
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGGStateSetFillColor(*((void *)c + 12), color);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFillColorWithColor", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

CGColorSpace *CGColorSpaceCopyDefaultColor(uint64_t a1)
{
  uint64_t v1 = (CGColorSpace *)a1;
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 32);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    uint64_t v3 = *((void *)v1 + 3);
    if (v3)
    {
      if (!*(void *)(v3 + 56))
      {
        uint64_t v4 = *(uint64_t (**)(CGColorSpace *))(*(void *)(v3 + 112) + 16);
        CGColorRef v5 = v4 ? (CGColorRef)v4(v1) : CGColorCreate(v1, *(const CGFloat **)(v3 + 40));
        uint64_t v6 = 0;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(*((void *)v1 + 3) + 56), (unint64_t *)&v6, (unint64_t)v5, memory_order_relaxed, memory_order_relaxed);
        if (v6)
        {
          if (v5) {
            CFRelease(v5);
          }
        }
      }
      uint64_t v7 = *((void *)v1 + 3);
      uint64_t v1 = *(CGColorSpace **)(v7 + 56);
      if (v1) {
        CFRetain(*(CFTypeRef *)(v7 + 56));
      }
    }
    else
    {
      uint64_t v1 = 0;
    }
    pthread_mutex_unlock(v2);
  }
  return v1;
}

uint64_t update_cache(uint64_t a1, const void *a2, int a3, uint64_t a4, int a5)
{
  if (a4)
  {
    uint64_t v10 = *(void *)(a4 + 24);
    if (v10) {
      size_t v11 = (void *)(v10 + 64);
    }
    else {
      size_t v11 = 0;
    }
  }
  else
  {
    size_t v11 = 0;
  }
  cache_entrCGFloat y = find_cache_entry(*(void *)(a1 + 120), v11);
  if (!cache_entry)
  {
    int v20 = *(unsigned __int8 *)(a1 + 49);
    unint64_t v21 = malloc_type_malloc(0x40uLL, 0x10C0040AF2BCAA4uLL);
    unsigned int v22 = v21;
    if (a4)
    {
      char v23 = 0;
      uint64_t v24 = *(void *)(a4 + 24);
      if (v24) {
        uint64_t v25 = (_OWORD *)(v24 + 64);
      }
      else {
        uint64_t v25 = 0;
      }
      *(_OWORD *)unint64_t v21 = *v25;
      v21[4] = a3;
      if (a5 == 1 || !v20) {
        goto LABEL_22;
      }
      BOOL v26 = *(unsigned char *)(*(void *)(a4 + 24) + 12) == 0;
    }
    else
    {
      *(_OWORD *)unint64_t v21 = MEMORY[0];
      v21[4] = a3;
      BOOL v26 = a5 == 1 || v20 == 0;
    }
    char v23 = !v26;
LABEL_22:
    for (uint64_t i = 6; i != 16; i += 2)
    {
      char v28 = v23 ^ 1;
      if (i == 8) {
        char v28 = 1;
      }
      if (v28) {
        CFTypeRef v29 = 0;
      }
      else {
        CFTypeRef v29 = CFRetain(a2);
      }
      *(void *)&v22[i] = v29;
    }
    if ((v23 & 1) == 0) {
      *(void *)&v22[2 * a5 + 6] = CFRetain(a2);
    }
    float v30 = *(void **)(a1 + 120);
    float v31 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
    if (v31)
    {
      *float v31 = v22;
      v31[1] = v30;
      float v30 = v31;
      *(void *)(a1 + 120) = v31;
    }
    else
    {
      *(void *)(a1 + 120) = v30;
      if (!v30) {
        return 0;
      }
    }
    uint64_t v32 = 0;
    uint64_t v33 = v30;
    do
    {
      ++v32;
      uint64_t v33 = (void *)v33[1];
    }
    while (v33);
    if (v32 == 16)
    {
      float v34 = v30;
      do
      {
        uint64_t v35 = v34;
        float v34 = (uint64_t *)v34[1];
      }
      while (v34);
      uint64_t v19 = *v35;
      x_list_remove(v30, *v35);
      return v19;
    }
    return 0;
  }
  uint64_t v16 = &cache_entry[a5];
  uint64_t v18 = v16[3];
  uint64_t v17 = (CFTypeRef *)(v16 + 3);
  if (v18) {
    _CGHandleAssert("update_cache", 150, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGColorTransformCache.c", "entry == NULL || entry->converters[intent] == NULL", "entry %p converters %p", v13, v14, v15, (char)cache_entry);
  }
  uint64_t v19 = 0;
  *uint64_t v17 = CFRetain(a2);
  return v19;
}

unint64_t CGColorEqualToColorComponents(unint64_t result, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v11 = result;
    CGColorSpaceRef v12 = (result & 0x8000000000000000) != 0
        ? CGTaggedColorGetColorSpace(result, a2, a3, (uint64_t)a4, a5, a6, a7, a8)
        : *(CGColorSpaceRef *)(result + 24);
    BOOL result = CGColorSpaceEqualToColorSpace((uint64_t)v12, a2);
    if (result)
    {
      if (v11 < 1) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = *(void *)(v11 + 32);
      }
      if (v13 == a3)
      {
        Components = CGColorGetComponents((CGColorRef)v11);
        if (v11 < 0) {
          uint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(v11, v14, v15, v16, v17, v18, v19, v20);
        }
        else {
          uint64_t NumberOfComponents = *(void *)(v11 + 56);
        }
        ERROR_CGColor_ComponentsArrayIsNotReadable((uint64_t)a4);
        ERROR_CGColor_ComponentsArrayNotLongEnough((uint64_t)a4, NumberOfComponents - 1);
        return memcmp(Components, a4, 8 * NumberOfComponents) == 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

double ERROR_CGColor_ComponentsArrayNotLongEnough(uint64_t a1, uint64_t a2)
{
  return *(double *)(a1 + 8 * a2);
}

double ERROR_CGColor_ComponentsArrayIsNotReadable(uint64_t a1)
{
  return *(double *)a1;
}

CGPoint CGContextGetTextPosition(CGContextRef c)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v7 = (const CGPoint *)((char *)c + 152);
    p_CGFloat y = (CGFloat *)((char *)c + 160);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetTextPosition", (uint64_t)c, v1, v2, v3, v4, v5, v6);
    uint64_t v7 = &CGPointZero;
    p_CGFloat y = &CGPointZero.y;
  }
  double v9 = *p_y;
  double x = v7->x;
  result.CGFloat y = v9;
  result.double x = x;
  return result;
}

CGFloat CGImageProviderGetSize(const CGSize *a1)
{
  uint64_t v1 = a1 + 1;
  if (!a1) {
    uint64_t v1 = &CGSizeZero;
  }
  return v1->width;
}

uint64_t CGImageProviderGetAlphaInfo(uint64_t result)
{
  if (result) {
    return *(_DWORD *)(result + 36) & 0x1F;
  }
  return result;
}

BOOL CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size)
{
  if (!dict || !size) {
    return 0;
  }
  get_size_from_dict(dict, &size->width);
  return result;
}

uint64_t CGImageBlockSetGetPixelSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

const void *CGImageProviderGetProperty(uint64_t a1, const void *a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 120)) != 0) {
    return CGPropertiesGetProperty(v2, a2);
  }
  else {
    return 0;
  }
}

CFTypeID CGColorSpaceGetTypeID(void)
{
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  return CGColorSpaceGetTypeID_type_id;
}

void *color_space_state_create_icc(const void *a1, const __CFData *a2, int *a3)
{
  if (a1)
  {
    uint64_t v4 = 0;
    switch(*a3)
    {
      case 0:
        uint64_t v7 = 1;
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
        goto LABEL_6;
      case 1:
      case 3:
      case 7:
        uint64_t v7 = 3;
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceRGB();
        goto LABEL_6;
      case 2:
        uint64_t v7 = 4;
        DeviceGraCGFloat y = CGColorSpaceCreateDeviceCMYK();
LABEL_6:
        CGColorSpaceRef v9 = DeviceGray;
        goto LABEL_7;
      case 4:
        CGColorSpaceRef v9 = 0;
        uint64_t v4 = 0;
        uint64_t v7 = *((void *)a3 + 36);
        if ((unint64_t)(v7 - 16) < 0xFFFFFFFFFFFFFFF1) {
          return v4;
        }
LABEL_7:
        uint64_t v10 = malloc_type_calloc(0x78uLL, 1uLL, 0xA92D5AAuLL);
        uint64_t v4 = v10;
        if (!v10) {
          return v4;
        }
        *(_DWORD *)uint64_t v10 = 1;
        v10[4] = 0;
        *((unsigned char *)v10 + 10) = *((unsigned char *)a3 + 280);
        *((unsigned char *)v10 + 12) = *((unsigned char *)a3 + 281);
        *((unsigned char *)v10 + 11) = 0;
        *((unsigned char *)v10 + 14) = *((unsigned char *)a3 + 282);
        *((unsigned char *)v10 + 15) = *((unsigned char *)a3 + 286);
        v10[8] = *(_WORD *)((char *)a3 + 283);
        *((unsigned char *)v10 + 13) = *((unsigned char *)a3 + 285);
        *((void *)v10 + 6) = v7;
        *((void *)v10 + 14) = icc_vtable;
        int v18 = *a3;
        *((_DWORD *)v10 + 6) = 6;
        *((_DWORD *)v10 + 7) = v18;
        *((_DWORD *)v10 + 8) = v18;
        *((void *)v10 + 10) = 0;
        *((void *)v10 + 11) = 0;
        *((void *)v10 + 5) = icc_get_default_color_components(v7, v11, v12, v13, v14, v15, v16, v17);
        uint64_t v19 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F20409491EBA0uLL);
        v4[12] = v19;
        if (!v19) {
          goto LABEL_23;
        }
        uint64_t v20 = v19;
        *(_DWORD *)uint64_t v19 = 0;
        v19[1] = CGDataProviderCreateWithCFData(a2);
        if (color_space_state_create_icc_cglibrarypredicate != -1) {
          dispatch_once(&color_space_state_create_icc_cglibrarypredicate, &__block_literal_global_7431);
        }
        if (color_space_state_create_icc_f() >> 17 < 0x781)
        {
          CFTypeRef icc_f_12 = CFRetain(a1);
        }
        else
        {
          if (color_space_state_create_icc_cglibrarypredicate_13 != -1) {
            dispatch_once(&color_space_state_create_icc_cglibrarypredicate_13, &__block_literal_global_16_7432);
          }
          CFTypeRef icc_f_12 = (CFTypeRef)color_space_state_create_icc_f_12(a1);
        }
        void v20[2] = icc_f_12;
        v20[7] = v9;
        unsigned int v22 = (char *)malloc_type_malloc(16 * v7, 0x100004000313F17uLL);
        v20[8] = v22;
        if (v22)
        {
          float v30 = v22 + 8;
          float v31 = (uint64_t *)(a3 + 8);
          do
          {
            *(v30 - 1) = *(v31 - 1);
            uint64_t v32 = *v31;
            v31 += 2;
            *float v30 = v32;
            v30 += 2;
            --v7;
          }
          while (v7);
          *(_OWORD *)(v20 + 3) = *(_OWORD *)(a3 + 1);
          v4[8] = icc_get_md5(v4, v23, v24, v25, v26, v27, v28, v29);
          v4[9] = v33;
          return v4;
        }
        free((void *)v4[12]);
LABEL_23:
        free(v4);
        break;
      default:
        return v4;
    }
  }
  return 0;
}

char *CGImageBlockSetCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, double a6, double a7, CGFloat a8, CGFloat a9, CGFloat a10, CGFloat a11)
{
  if (a1) {
    int v12 = *(_DWORD *)(a1 + 36);
  }
  else {
    int v12 = 0;
  }
  return CGImageBlockSetCreateWithBitmapInfo(a1, 0, v12, 0, 0, a2, a3, a4, a6, a7, a8, a9, a10, a11, a5);
}

char *CGImageBlockSetCreateWithBitmapInfo(uint64_t a1, int a2, int a3, uint64_t a4, void *ColorSpace, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, CGFloat a11, CGFloat a12, CGFloat a13, CGFloat a14, _DWORD *a15)
{
  uint64_t v15 = 0;
  if (a6 && a1 && a7)
  {
    if (a15 && *a15) {
      return 0;
    }
    uint64_t v15 = 0;
    if (a9 <= 0.0 || a10 <= 0.0) {
      return v15;
    }
    if (a9 != (double)(unint64_t)a9) {
      return 0;
    }
    if (a10 != (double)(unint64_t)a10) {
      return 0;
    }
    v34.origin.double x = a11;
    v34.origin.CGFloat y = a12;
    v34.size.CGFloat width = a13;
    v34.size.double height = a14;
    CGRect v36 = CGRectIntegral(v34);
    v35.origin.double x = a11;
    v35.origin.CGFloat y = a12;
    v35.size.CGFloat width = a13;
    v35.size.double height = a14;
    if (!CGRectEqualToRect(v35, v36)) {
      return 0;
    }
    uint64_t v15 = (char *)malloc_type_malloc(8 * a6 + 128, 0x705560E0uLL);
    *(_DWORD *)uint64_t v15 = 1;
    CFRetain((CFTypeRef)a1);
    *((void *)v15 + 1) = a1;
    *((double *)v15 + 2) = a9;
    *((double *)v15 + 3) = a10;
    *((CGFloat *)v15 + 4) = a11;
    *((CGFloat *)v15 + 5) = a12;
    *((CGFloat *)v15 + 6) = a13;
    *((CGFloat *)v15 + 7) = a14;
    if (!a2) {
      a2 = *(_DWORD *)(a1 + 32);
    }
    *((_DWORD *)v15 + 16) = a2;
    if (!a4) {
      a4 = *(void *)(a1 + 48);
    }
    *((void *)v15 + 9) = a4;
    if (ColorSpace || (CGColorSpaceRef ColorSpace = CGImageProviderGetColorSpace((void *)a1)) != 0) {
      CFRetain(ColorSpace);
    }
    *((void *)v15 + 10) = ColorSpace;
    *((void *)v15 + 11) = 0;
    float v30 = v15 + 104;
    *((void *)v15 + 12) = a8;
    if (a15)
    {
      *float v30 = *(_OWORD *)a15;
    }
    else
    {
      *(void *)float v30 = 0;
      *((void *)v15 + 14) = 0;
    }
    uint64_t v32 = 0;
    *((void *)v15 + 15) = a6;
    do
    {
      uint64_t v33 = *(void *)(a7 + 8 * v32);
      if (v33) {
        *(_DWORD *)(v33 + 48) = a3;
      }
      *(void *)&v15[8 * v32++ + 128] = v33;
    }
    while (a6 != v32);
  }
  return v15;
}

CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect)
{
  if (!image || *((void *)image + 24)) {
    return 0;
  }
  double v3 = (double)*((unint64_t *)image + 5);
  double v4 = (double)*((unint64_t *)image + 6);
  CGRect v118 = CGRectIntegral(rect);
  v135.origin.double x = 0.0;
  v135.origin.double y = 0.0;
  v135.size.double width = v3;
  v135.size.double height = v4;
  CGRect v119 = CGRectIntersection(v118, v135);
  double x = v119.origin.x;
  if (v119.origin.x == INFINITY || v119.origin.y == INFINITY) {
    return 0;
  }
  double y = v119.origin.y;
  double width = v119.size.width;
  double height = v119.size.height;
  v136.origin.double x = 0.0;
  v136.origin.double y = 0.0;
  v136.size.double width = v3;
  v136.size.double height = v4;
  if (CGRectEqualToRect(v119, v136))
  {
    CFRetain(image);
    return image;
  }
  if ((*((unsigned char *)image + 39) & 2) == 0)
  {
    BOOL v13 = height < 0.0 || width < 0.0;
    if (v13)
    {
      v120.origin.double x = x;
      v120.origin.double y = y;
      v120.size.double width = width;
      v120.size.double height = height;
      CGRect v121 = CGRectStandardize(v120);
      unint64_t v14 = (unint64_t)v121.size.width;
      v121.origin.double x = x;
      v121.origin.double y = y;
      v121.size.double width = width;
      v121.size.double height = height;
      CGRect v122 = CGRectStandardize(v121);
      unint64_t v15 = (unint64_t)v122.size.height;
      v122.origin.double x = x;
      v122.origin.double y = y;
      v122.size.double width = width;
      v122.size.double height = height;
      uint64_t v115 = (unint64_t)COERCE_DOUBLE(CGRectStandardize(v122));
      v123.origin.double x = x;
      v123.origin.double y = y;
      v123.size.double width = width;
      v123.size.double height = height;
      CGRect v124 = CGRectStandardize(v123);
      double v16 = v124.origin.y;
    }
    else
    {
      unint64_t v14 = (unint64_t)width;
      unint64_t v15 = (unint64_t)height;
      double v16 = y;
      uint64_t v115 = (unint64_t)x;
    }
    uint64_t v20 = *((void *)image + 26);
    if (v20)
    {
      uint64_t v21 = CGImageProviderCreateWithImageProviderInRect(v20, *((void *)image + 18), x, y, width, height);
      if (!v21) {
        return 0;
      }
      uint64_t v26 = (const void *)v21;
      uint64_t v7 = CGImageCreateWithImageProvider(v21, *((double **)image + 20), HIBYTE(*((_DWORD *)image + 9)) & 1, ((__int16)*((_DWORD *)image + 9) >> 8), v22, v23, v24, v25);
      CFRelease(v26);
    }
    else
    {
      *(void *)CGFloat v117 = *((void *)image + 9);
      if ((*((_DWORD *)image + 8) & 0x7000) == 0x2000)
      {
        uint64_t v38 = 4;
      }
      else if ((*((_DWORD *)image + 8) & 0x7000) == 0x1000)
      {
        uint64_t v38 = 2;
      }
      else
      {
        uint64_t v38 = 1;
      }
      size_t v116 = v38;
      if (v13)
      {
        v130.origin.double x = x;
        v130.origin.double y = y;
        v130.size.double width = width;
        v130.size.double height = height;
        CGRect v131 = CGRectStandardize(v130);
        unint64_t v39 = (unint64_t)v131.size.width;
        v131.origin.double x = x;
        v131.origin.double y = y;
        v131.size.double width = width;
        v131.size.double height = height;
        CGRect v132 = CGRectStandardize(v131);
        unint64_t v40 = (unint64_t)v132.size.height;
        v132.origin.double x = x;
        v132.origin.double y = y;
        v132.size.double width = width;
        v132.size.double height = height;
        uint64_t v41 = (unint64_t)COERCE_DOUBLE(CGRectStandardize(v132));
        v133.origin.double x = x;
        v133.origin.double y = y;
        v133.size.double width = width;
        v133.size.double height = height;
        CGRect v134 = CGRectStandardize(v133);
        double y = v134.origin.y;
      }
      else
      {
        unint64_t v39 = (unint64_t)width;
        unint64_t v40 = (unint64_t)height;
        uint64_t v41 = (unint64_t)x;
      }
      DataProviderInternal = CGImageGetDataProviderInternal((char *)image, 0);
      CGDataProviderRef Partial = CGDataProviderCreatePartial((uint64_t)DataProviderInternal, v41, (unint64_t)y, v39, v40, *((void *)image + 8), (unint64_t *)v117, (uint64_t *)&v116);
      if (!Partial) {
        return 0;
      }
      long long v44 = Partial;
      CGBitmapInfo v45 = CGImageGetBitmapInfo(image);
      if (v116 == 1) {
        unsigned int v46 = v45 & 0xFFFF8FFF;
      }
      else {
        unsigned int v46 = v45;
      }
      bitmapInfodouble a = v46;
      size_t v47 = *((void *)image + 8);
      size_t v109 = *(void *)v117;
      *(void *)uint64_t v111 = *((void *)image + 7);
      unint64_t v48 = v14;
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
      unint64_t v50 = v15;
      long long v51 = CGImageGetDecode(image);
      BOOL shouldInterpolate = CGImageGetShouldInterpolate(image);
      CGColorRenderingIntent intent = CGImageGetRenderingIntent(image);
      decode = (CGFloat *)v51;
      unint64_t v15 = v50;
      long long v54 = ColorSpace;
      unint64_t v14 = v48;
      uint64_t v7 = (uint64_t)CGImageCreate(v39, v40, *(size_t *)v111, v47, v109, v54, bitmapInfoa, v44, decode, shouldInterpolate, intent);
      CGDataProviderRelease(v44);
    }
    CGImageCopyHeadroomFromOriginal((uint64_t *)v7, image, v27, v28, v29, v30, v31, v32);
    if (!v7) {
      return (CGImageRef)v7;
    }
    uint64_t v55 = (unint64_t)v16;
    Mask = (char *)CGImageGetMask(image);
    if (!Mask)
    {
LABEL_80:
      if (!*((void *)image + 21))
      {
LABEL_88:
        *(_DWORD *)(v7 + 36) = *(_DWORD *)(v7 + 36) & 0xF7FFFFFF | (((*((_DWORD *)image + 9) >> 27) & 1) << 27);
        if (!*((void *)image + 23))
        {
LABEL_96:
          if (*((void *)image + 30)) {
            CGImageRef v105 = (CGImageRef)*((void *)image + 30);
          }
          else {
            CGImageRef v105 = image;
          }
          if (v105) {
            CFRetain(v105);
          }
          *(void *)(v7 + 240) = v105;
          double v106 = *((double *)image + 32) + (double)(unint64_t)v55;
          *(double *)(v7 + 248) = *((double *)image + 31) + (double)(unint64_t)v115;
          *(double *)(v7 + 256) = v106;
          *(unsigned char *)(v7 + 38) = *((_WORD *)image + 19);
          return (CGImageRef)v7;
        }
        uint64_t v100 = *(void *)(v7 + 144);
        if (v100) {
          uint64_t v101 = *(void *)(*(void *)(v100 + 24) + 48);
        }
        else {
          uint64_t v101 = 0;
        }
        int v102 = malloc_type_malloc(8 * v101, 0x705560E0uLL);
        *(void *)(v7 + 184) = v102;
        if (v102)
        {
          if (v101)
          {
            CFTypeID v103 = (uint64_t *)*((void *)image + 23);
            do
            {
              uint64_t v104 = *v103++;
              *v102++ = v104;
              --v101;
            }
            while (v101);
          }
          goto LABEL_96;
        }
        goto LABEL_102;
      }
      uint64_t v94 = *(void *)(v7 + 144);
      if (v94) {
        uint64_t v95 = *(void *)(*(void *)(v94 + 24) + 48);
      }
      else {
        uint64_t v95 = 0;
      }
      CGRect v96 = malloc_type_malloc(16 * v95, 0x705560E0uLL);
      *(void *)(v7 + 168) = v96;
      if (v96)
      {
        uint64_t v97 = 2 * v95;
        if (2 * v95)
        {
          uint64_t v98 = (uint64_t *)*((void *)image + 21);
          do
          {
            uint64_t v99 = *v98++;
            *v96++ = v99;
            --v97;
          }
          while (v97);
        }
        goto LABEL_88;
      }
LABEL_102:
      CFRelease((CFTypeRef)v7);
      return 0;
    }
    long long v57 = Mask;
    unint64_t v58 = *((void *)image + 5);
    unint64_t v59 = *((void *)Mask + 5);
    if (v58 == v59)
    {
      unint64_t v60 = *((void *)image + 6);
      unint64_t v61 = *((void *)Mask + 6);
      if (v60 == v61) {
        goto LABEL_60;
      }
    }
    else
    {
      unint64_t v61 = *((void *)Mask + 6);
      unint64_t v60 = *((void *)image + 6);
    }
    double v62 = (double)v59 / (double)v58;
    double v63 = (double)v61 / (double)v60;
    unint64_t v64 = vcvtpd_u64_f64(v62 * (double)(v115 + v14));
    if (v59 >= v64) {
      unint64_t v14 = v64;
    }
    else {
      unint64_t v14 = *((void *)Mask + 5);
    }
    unint64_t v65 = vcvtpd_u64_f64(v63 * (double)(v55 + v15));
    uint64_t v115 = vcvtmd_u64_f64(v62 * (double)(unint64_t)v115);
    if (v61 >= v65) {
      unint64_t v15 = v65;
    }
    else {
      unint64_t v15 = v61;
    }
    uint64_t v55 = vcvtmd_u64_f64(v63 * (double)(unint64_t)v55);
LABEL_60:
    *(void *)CGFloat v117 = 0;
    if ((Mask[39] & 2) != 0)
    {
      size_t v116 = *((void *)Mask + 9);
      *(void *)CGFloat v117 = 1;
      long long v74 = CGImageGetDataProviderInternal(Mask, 0);
      CGDataProviderRef v75 = CGDataProviderCreatePartial((uint64_t)v74, v115, v55, v14, v15, *((void *)v57 + 8), &v116, (uint64_t *)v117);
      if (!v75) {
        goto LABEL_102;
      }
      long long v76 = v75;
      *(void *)bitmapInfo = v55;
      unint64_t v77 = *((void *)v57 + 7);
      unint64_t v78 = *((void *)v57 + 8);
      unint64_t v79 = *((void *)v57 + 9);
      long long v80 = (double *)CGImageGetDecode((CGImageRef)v57);
      BOOL v81 = CGImageGetShouldInterpolate((CGImageRef)v57);
      uint64_t v82 = mask_create(v14, v15, v77, v78, v79, v76, v80, v81, 4);
    }
    else
    {
      uint64_t v66 = *((void *)Mask + 26);
      if (v66)
      {
        uint64_t v67 = CGImageProviderCreateWithImageProviderInRect(v66, *((void *)v57 + 18), (double)(unint64_t)v115, (double)(unint64_t)v55, (double)v14, (double)v15);
        if (!v67) {
          goto LABEL_102;
        }
        long long v72 = (const void *)v67;
        *(void *)bitmapInfo = v55;
        uint64_t v73 = CGImageCreateWithImageProvider(v67, *((double **)v57 + 20), HIBYTE(*((_DWORD *)v57 + 9)) & 1, ((__int16)*((_DWORD *)v57 + 9) >> 8), v68, v69, v70, v71);
        CFRelease(v72);
        goto LABEL_78;
      }
      unsigned int v83 = *((_DWORD *)v57 + 8);
      size_t v116 = *((void *)v57 + 9);
      if ((v83 & 0x7000) == 0x2000)
      {
        uint64_t v84 = 4;
      }
      else if ((v83 & 0x7000) == 0x1000)
      {
        uint64_t v84 = 2;
      }
      else
      {
        uint64_t v84 = 1;
      }
      *(void *)CGFloat v117 = v84;
      double v85 = CGImageGetDataProviderInternal(v57, 0);
      CGDataProviderRef v86 = CGDataProviderCreatePartial((uint64_t)v85, v115, v55, v14, v15, *((void *)v57 + 8), &v116, (uint64_t *)v117);
      if (!v86) {
        goto LABEL_102;
      }
      long long v76 = v86;
      *(void *)bitmapInfo = v55;
      size_t v87 = v116;
      if (*(void *)v117 >= 2uLL) {
        unsigned int v88 = v83;
      }
      else {
        unsigned int v88 = v83 & 0xFFFF8FFF;
      }
      CGBitmapInfo v112 = v88;
      size_t v108 = *((void *)v57 + 8);
      size_t v110 = *((void *)v57 + 7);
      double v89 = CGImageGetColorSpace((CGImageRef)v57);
      int v90 = CGImageGetDecode((CGImageRef)v57);
      size_t v91 = v14;
      BOOL v92 = CGImageGetShouldInterpolate((CGImageRef)v57);
      CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent((CGImageRef)v57);
      uint64_t v82 = CGImageCreate(v91, v15, v110, v108, v87, v89, v112, v76, v90, v92, RenderingIntent);
    }
    uint64_t v73 = (uint64_t)v82;
    CGDataProviderRelease(v76);
LABEL_78:
    if (!v73) {
      goto LABEL_102;
    }
    *(void *)(v7 + 176) = v73;
    uint64_t v55 = *(void *)bitmapInfo;
    goto LABEL_80;
  }
  if (width < 0.0 || height < 0.0)
  {
    v125.origin.double x = x;
    v125.origin.double y = y;
    v125.size.double width = width;
    v125.size.double height = height;
    CGRect v126 = CGRectStandardize(v125);
    unint64_t v17 = (unint64_t)v126.size.width;
    v126.origin.double x = x;
    v126.origin.double y = y;
    v126.size.double width = width;
    v126.size.double height = height;
    CGRect v127 = CGRectStandardize(v126);
    unint64_t v18 = (unint64_t)v127.size.height;
    v127.origin.double x = x;
    v127.origin.double y = y;
    v127.size.double width = width;
    v127.size.double height = height;
    uint64_t v19 = (unint64_t)COERCE_DOUBLE(CGRectStandardize(v127));
    v128.origin.double x = x;
    v128.origin.double y = y;
    v128.size.double width = width;
    v128.size.double height = height;
    CGRect v129 = CGRectStandardize(v128);
    double y = v129.origin.y;
  }
  else
  {
    unint64_t v17 = (unint64_t)width;
    unint64_t v18 = (unint64_t)height;
    uint64_t v19 = (unint64_t)x;
  }
  size_t v116 = 1;
  uint64_t v33 = *((void *)image + 8);
  *(void *)CGFloat v117 = *((void *)image + 9);
  CGRect v34 = CGDataProviderCreatePartial(*((void *)image + 19), v19, (unint64_t)y, v17, v18, v33, (unint64_t *)v117, (uint64_t *)&v116);
  if (!v34) {
    return 0;
  }
  CGRect v35 = v34;
  uint64_t v7 = (uint64_t)mask_create(v17, v18, *((void *)image + 7), *((void *)image + 8), *(unint64_t *)v117, v34, *((double **)image + 20), HIBYTE(*((_DWORD *)image + 9)) & 1, 4);
  CGDataProviderRelease(v35);
  if (v7)
  {
    if (*((void *)image + 30)) {
      CGImageRef v36 = (CGImageRef)*((void *)image + 30);
    }
    else {
      CGImageRef v36 = image;
    }
    if (v36) {
      CFRetain(v36);
    }
    *(void *)(v7 + 240) = v36;
    v37.i64[0] = v19;
    v37.i64[1] = (unint64_t)y;
    *(float64x2_t *)(v7 + 248) = vaddq_f64(*(float64x2_t *)((char *)image + 248), vcvtq_f64_u64(v37));
  }
  return (CGImageRef)v7;
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  double x = rect1.origin.x;
  BOOL v3 = rect1.origin.y == INFINITY || rect1.origin.x == INFINITY;
  BOOL v4 = rect2.origin.x == INFINITY;
  if (rect2.origin.y == INFINITY) {
    BOOL v4 = 1;
  }
  BOOL result = v3 && v4;
  if (!v3 && !v4)
  {
    double height = rect2.size.height;
    double width = rect2.size.width;
    double y = rect2.origin.y;
    double v9 = rect2.origin.x;
    double v10 = rect1.size.height;
    double v11 = rect1.size.width;
    double v12 = rect1.origin.y;
    if (rect1.size.width < 0.0 || rect1.size.height < 0.0)
    {
      CGRect v14 = CGRectStandardize(rect1);
      double x = v14.origin.x;
      double v12 = v14.origin.y;
      double v11 = v14.size.width;
      double v10 = v14.size.height;
    }
    if (width < 0.0 || height < 0.0)
    {
      v15.origin.double x = v9;
      v15.origin.double y = y;
      v15.size.double width = width;
      v15.size.double height = height;
      CGRect v16 = CGRectStandardize(v15);
      double v9 = v16.origin.x;
      double y = v16.origin.y;
      double width = v16.size.width;
      double height = v16.size.height;
    }
    BOOL v13 = v10 == height;
    if (v11 != width) {
      BOOL v13 = 0;
    }
    if (v12 != y) {
      BOOL v13 = 0;
    }
    return x == v9 && v13;
  }
  return result;
}

uint64_t CGDataProviderCreateForDestination(void *a1, vImagePixelCount a2, CGDataProvider *a3, uint64_t a4, size_t a5, CGDataProvider *a6, void *a7, void *__src, size_t a9, unsigned int a10)
{
  memcpy(__dst, __src, 0x130uLL);
  if (!CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v16, v17, v18, v19, v20, v21, v22))
  {
    memcpy(__dst, __src, 0x130uLL);
    char BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v123, v124, v125, v126, v127, v128, v129);
    _CGHandleAssert("CGDataProviderCreateForDestination", 824, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "CGBitmapPixelInfoGetBitsPerPixel(src_pixel_info) != 0", "bpp %zu", v131, v132, v133, BitsPerPixel);
  }
  if (*(_DWORD *)(a4 + 32)) {
    _CGHandleAssert("CGDataProviderCreateForDestination", 826, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "CGBitmapPixelInfoGetCGImagePixelFormatInfo(dst_pixel_info) == kCGImagePixelFormatPacked", "format = %u", v23, v24, v25, *(_DWORD *)(a4 + 32));
  }
  if (a1) {
    BOOL v26 = CGColorTransformConvertRequired((BOOL)a1, a7, a10);
  }
  else {
    BOOL v26 = 0;
  }
  int v137 = a6;
  if (*((unsigned char *)a6 + 260)) {
    BOOL v135 = 0;
  }
  else {
    BOOL v135 = (*((_DWORD *)__src + 6) - 5) < 2;
  }
  memcpy(__dst, (const void *)a4, 0x130uLL);
  memcpy(srcFormat, __src, 0x130uLL);
  BOOL IsEqualToBitmapPixelInfo = CGBitmapPixelInfoIsEqualToBitmapPixelInfo((uint64_t)__dst, (uint64_t)srcFormat);
  uint64_t v28 = (CGDataProviderRef *)malloc_type_calloc(1uLL, 0x338uLL, 0xA3729uLL);
  if (!v28) {
    return 0;
  }
  uint64_t v32 = v28;
  if (v26)
  {
    v28[87] = (CGDataProviderRef)CGColorTransformCreateCGCMSConverter(a1, a7, a10);
    size_t v33 = a9;
    if (!a9)
    {
      memcpy(__dst, __src, 0x130uLL);
      size_t v33 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v34, v35, v36, v37, v38, v39, v40) * a2 + 7) >> 3;
    }
    __dst[0].datdouble a = 0;
    __dst[0].double height = a2;
    __dst[0].double width = 1;
    __dst[0].rowBytes = v33;
    __dst[1].datdouble a = (void *)a10;
    memcpy(&__dst[1].height, __src, 0x130uLL);
    if (*((void *)__src + 5)) {
      __dst[2].double width = (vImagePixelCount)&__dst[2].rowBytes;
    }
    *(void *)srcFormat = 0;
    *(void *)&srcFormat[8] = a2;
    *(void *)&srcFormat[16] = 1;
    *(void *)&srcFormat[24] = a5;
    *(_DWORD *)&srcFormat[36] = 0;
    *(_DWORD *)&srcFormat[32] = a10;
    memcpy(&srcFormat[40], (const void *)a4, 0x130uLL);
    if (*(void *)(a4 + 40)) {
      *(void *)&srcFormat[80] = &srcFormat[88];
    }
    long long destFormat_16 = 0u;
    memset(destFormat_32, 0, 56);
    long long destFormat = 0u;
    CGCMSConverterConvertGetConverterInfo((uint64_t)&destFormat, (uint64_t (**)(CFTypeRef, uint64_t, uint64_t))v32[87], (uint64_t)__dst, (uint64_t)srcFormat);
    size_t v41 = destFormat_16;
    v32[88] = (CGDataProviderRef)destFormat;
    if (v41 >= 0x401)
    {
      v32[94] = (CGDataProviderRef)v41;
      v32[93] = (CGDataProviderRef)malloc_type_calloc(1uLL, v41, 0xA3729uLL);
    }
    if (*((void *)&destFormat_16 + 1)) {
      v32[95] = (CGDataProviderRef)*((void *)&destFormat_16 + 1);
    }
    if (CGColorSpaceGetType(a7) == 7) {
      *((_DWORD *)v32 + 192) = destFormat_32[0];
    }
    long long v42 = *(_OWORD *)((char *)&destFormat_32[1] + 8);
    *(_OWORD *)(v32 + 97) = *(_OWORD *)((char *)destFormat_32 + 8);
    *(_OWORD *)(v32 + 99) = v42;
    *(_OWORD *)(v32 + 101) = *(_OWORD *)((char *)&destFormat_32[2] + 8);
    goto LABEL_38;
  }
  if (IsEqualToBitmapPixelInfo) {
    goto LABEL_38;
  }
  if (a7 && *(void *)(a4 + 16) != *((void *)__src + 2)) {
    _CGHandleAssert("CGDataProviderCreateForDestination", 893, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestination.c", "src_space == NULL || CGBitmapPixelInfoGetColorantCount(dst_pixel_info) == CGBitmapPixelInfoGetColorantCount(src_pixel_info)", "colorSpace %p  dest colors %zu  src colors %zu", v29, v30, v31, (char)a7);
  }
  memset(srcFormat, 0, 40);
  memcpy(__dst, __src, 0x130uLL);
  CGBitmapPixelInfoGet_vImageFormat((uint64_t)srcFormat, (uint64_t)__dst, v43, v44, v45, v46, v47, v48);
  *(void *)&destFormat_32[0] = 0;
  long long destFormat = 0u;
  long long destFormat_16 = 0u;
  memcpy(__dst, (const void *)a4, 0x130uLL);
  CGBitmapPixelInfoGet_vImageFormat((uint64_t)&destFormat, (uint64_t)__dst, v49, v50, v51, v52, v53, v54);
  vImageConverterRef v55 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)srcFormat, (const vImage_CGImageFormat *)&destFormat, 0, 0x100u, 0);
  v32[89] = v55;
  if (!v55)
  {
    free(v32);
    return 0;
  }
  size_t v56 = a9;
  memcpy(__dst, __src, 0x130uLL);
  if (a9)
  {
    vImagePixelCount v64 = (8 * a9 / CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v57, v58, v59, v60, v61, v62, v63) + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else
  {
    size_t v56 = (CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v57, v58, v59, v60, v61, v62, v63) * a2 + 7) >> 3;
    vImagePixelCount v64 = a2;
  }
  unint64_t v65 = v32[89];
  if (!v65)
  {
LABEL_37:
    v32[94] = 0;
    goto LABEL_38;
  }
  __dst[0].datdouble a = v145;
  __dst[0].double height = 1;
  __dst[0].double width = v64;
  __dst[0].rowBytes = v56;
  dests.datdouble a = v145;
  dests.double height = 1;
  dests.double width = v64;
  dests.rowBytes = a5;
  unint64_t v66 = vImageConvert_AnyToAny(v65, __dst, &dests, 0, 0x80u);
  if ((v66 & 0x8000000000000000) != 0)
  {
    CGPostError((uint64_t)"vImageConvert_AnyToAny failed to return vImage buffer size", v67, v68, v69, v70, v71, v72, v73, v134);
    goto LABEL_37;
  }
  v32[94] = (CGDataProviderRef)v66;
  if (v66 >= 0x401) {
    v32[93] = (CGDataProviderRef)malloc_type_calloc(1uLL, v66, 0xA3729uLL);
  }
LABEL_38:
  memcpy(__dst, (const void *)a4, 0x130uLL);
  uint64_t v87 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v74, v75, v76, v77, v78, v79, v80);
  if ((*((_DWORD *)v137 + 5) | 2) == 2)
  {
    *((unsigned char *)v32 + 724) = 1;
    CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v32, a5 * (void)a3, (uint64_t)&direct_provider_for_destination_callbacks, v82, v83, v84, v85, v86);
    uint64_t v89 = v88;
    if (!v88) {
      goto LABEL_51;
    }
  }
  else
  {
    uint64_t SequentialWithInternalCallbacks = CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v32, (uint64_t)&sequential_provider_for_destination_callbacks, v81, v82, v83, v84, v85, v86);
    if (!SequentialWithInternalCallbacks)
    {
LABEL_51:
      CGDataProviderRef v101 = v32[93];
      if (v101) {
        free(v101);
      }
      int v102 = v32[89];
      if (v102) {
        vImageConverter_Release(v102);
      }
      CGDataProviderRef v103 = v32[95];
      if (v103) {
        free(v103);
      }
      free(v32);
      CGPostError((uint64_t)"%s failed to allocate", v104, v105, v106, v107, v108, v109, v110, (char)"CGDataProviderCreateForDestination");
      return 0;
    }
    uint64_t v89 = SequentialWithInternalCallbacks;
    CGDataProviderLock((uint64_t)v137);
  }
  unint64_t v91 = v87 * a2 + 7;
  *uint64_t v32 = CGDataProviderRetain(v137);
  v32[1] = (CGDataProviderRef)a2;
  v32[2] = a3;
  memcpy(v32 + 4, __src, 0x130uLL);
  if (*((void *)__src + 5)) {
    v32[9] = (CGDataProviderRef)(v32 + 10);
  }
  unint64_t v92 = v91 >> 3;
  v32[42] = (CGDataProviderRef)a9;
  memcpy(__dst, __src, 0x130uLL);
  v32[43] = (CGDataProviderRef)((CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v93, v94, v95, v96, v97, v98, v99)
                               * a2
                               + 7) >> 3);
  memcpy(v32 + 45, (const void *)a4, 0x130uLL);
  if (*(void *)(a4 + 40)) {
    v32[50] = (CGDataProviderRef)(v32 + 51);
  }
  v32[83] = (CGDataProviderRef)a5;
  v32[84] = (CGDataProviderRef)v92;
  char v100 = !v26;
  if (!a1) {
    char v100 = 1;
  }
  if (v100) {
    a1 = 0;
  }
  else {
    CFRetain(a1);
  }
  v32[86] = (CGDataProviderRef)a1;
  if (a7) {
    CFRetain(a7);
  }
  void v32[3] = (CGDataProviderRef)a7;
  *((_DWORD *)v32 + 180) = a10;
  *((unsigned char *)v32 + 725) = v135;
  CGDataProviderRef v111 = v32[83];
  CGDataProviderRef v112 = v32[42];
  if (!v112) {
    CGDataProviderRef v112 = v32[43];
  }
  if (v111 <= v112) {
    CGDataProviderRef v111 = v112;
  }
  size_t v113 = (((unint64_t)v111 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
  v32[92] = (CGDataProviderRef)v113;
  CFDictionaryRef v114 = (CGDataProvider *)malloc_type_calloc(1uLL, v113, 0xA3729uLL);
  v32[91] = v114;
  if (!v114)
  {
    provider_for_destination_release_info((uint64_t)v32);
    CGPostError((uint64_t)"%s failed", v115, v116, v117, v118, v119, v120, v121, (char)"CGDataProviderCreateForDestination");
    return 0;
  }
  return v89;
}

uint64_t CGBitmapPixelInfoGet_vImageFormat(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v10) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 16);
  unsigned int v12 = *(_DWORD *)(a2 + 24) - 1;
  if (v12 <= 8) {
    uint64_t v10 = qword_185211998[v12];
  }
  int v13 = v10 + v11;
  int BitsPerComponent = CGPixelComponentGetBitsPerComponent(*(_DWORD *)a2, a2, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)a1 = BitsPerComponent;
  *(_DWORD *)(a1 + 4) = BitsPerComponent * v13;
  switch(v11)
  {
    case 4:
      CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
      break;
    case 3:
      CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceRGB();
      break;
    case 1:
      CGColorSpaceRef DeviceCMYK = CGColorSpaceCreateDeviceGray();
      break;
    default:
      CGColorSpaceRef DeviceCMYK = 0;
      break;
  }
  *(void *)(a1 + 8) = DeviceCMYK;
  memcpy(v17, (const void *)a2, sizeof(v17));
  uint64_t result = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)v17);
  *(_DWORD *)(a1 + 16) = result;
  *(void *)(a1 + 24) = *(void *)(a2 + 40);
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

uint64_t CGPixelComponentGetBitsPerComponent(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a1 - 1;
  if ((a1 - 1) >= 9 || ((0x1DFu >> v8) & 1) == 0) {
    _CGHandleAssert("CGPixelComponentGetBitsPerComponent", 38, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "", "Unimplemented", a6, a7, a8, vars0);
  }
  return qword_185211950[v8];
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  if (CGColorSpaceCreateDeviceRGB_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDeviceRGB_predicate, &__block_literal_global_145_6440);
  }
  uint64_t v0 = (CGColorSpace *)CGColorSpaceCreateDeviceRGB_space;
  if (CGColorSpaceCreateDeviceRGB_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDeviceRGB_space);
  }
  return v0;
}

void *CGCMSConverterCreateCachedCGvImageConverter(void *a1, const void *a2, const void *a3)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  memcpy(__dst, a2, sizeof(__dst));
  uint64_t v109 = (uint64_t)a3;
  memcpy(__src, a3, sizeof(__src));
  value_out = 0;
  if (CGvImageConverterCacheGetRetained_cglibrarypredicate != -1) {
    dispatch_once(&CGvImageConverterCacheGetRetained_cglibrarypredicate, &__block_literal_global_17837);
  }
  uint64_t Retained_f = CGvImageConverterCacheGetRetained_f(0);
  uint64_t v112 = v6;
  uint64_t v113 = Retained_f;
  if (a1)
  {
    uint64_t v7 = a1[3];
    uint64_t v8 = a1[4];
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  uint64_t v123 = 0;
  long long v121 = 0u;
  long long v122 = 0u;
  memcpy(key, __dst, 0x158uLL);
  vImage_FormatFromConversionFormat((uint64_t)&v121, key, v8, v9, v10, v11, v12, v13);
  uint64_t v120 = 0;
  long long v118 = 0u;
  long long v119 = 0u;
  memcpy(key, __src, 0x158uLL);
  vImage_FormatFromConversionFormat((uint64_t)&v118, key, v7, v14, v15, v16, v17, v18);
  if (a1 && (CFDictionaryRef v19 = (const __CFDictionary *)a1[9]) != 0)
  {
    uint64_t MD5Digest = CGCFDictionaryGetMD5Digest(v19, 0);
    uint64_t v110 = v21;
    uint64_t v111 = MD5Digest;
    if (!v8)
    {
LABEL_9:
      BOOL v22 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v110 = 0;
    uint64_t v111 = 0;
    if (!v8) {
      goto LABEL_9;
    }
  }
  BOOL v22 = *(unsigned char *)(*(void *)(v8 + 24) + 13) != 0;
LABEL_12:
  BOOL v115 = v22;
  if (v7) {
    BOOL v114 = *(unsigned char *)(*(void *)(v7 + 24) + 13) != 0;
  }
  else {
    BOOL v114 = 0;
  }
  long long v23 = v121;
  uint64_t v24 = (long long *)*((void *)&v122 + 1);
  uint64_t v25 = v122;
  uint64_t v26 = v123;
  long long v27 = v118;
  uint64_t v29 = (long long *)*((void *)&v119 + 1);
  uint64_t v28 = v119;
  uint64_t v30 = v120;
  bzero(&key[8], 0x208uLL);
  *(void *)&key[0] = v113;
  *((void *)&key[0] + 1) = v112;
  *(void *)&key[1] = v111;
  *((void *)&key[1] + 1) = v110;
  key[2] = v23;
  *(void *)&key[3] = v25;
  *((void *)&key[3] + 1) = v24;
  *(void *)&key[4] = v26;
  *(_OWORD *)((char *)&key[4] + 8) = v27;
  *((void *)&key[5] + 1) = v28;
  *(void *)&key[6] = v29;
  *((void *)&key[6] + 1) = v30;
  if (*((void *)&v23 + 1)) {
    uint64_t v31 = *(void *)(*(void *)(*((void *)&v23 + 1) + 24) + 48);
  }
  else {
    uint64_t v31 = 0;
  }
  *(void *)&key[7] = v31;
  if (*((void *)&v27 + 1)) {
    uint64_t v32 = *(void *)(*(void *)(*((void *)&v27 + 1) + 24) + 48);
  }
  else {
    uint64_t v32 = 0;
  }
  *((void *)&key[7] + 1) = v32;
  if (v24)
  {
    if (v31)
    {
      size_t v33 = &key[8];
      do
      {
        long long v34 = *v24++;
        *v33++ = v34;
        --v31;
      }
      while (v31);
    }
    *((void *)&key[3] + 1) = 0;
  }
  if (v29)
  {
    if (v32)
    {
      uint64_t v35 = v129;
      do
      {
        long long v36 = *v29++;
        *v35++ = v36;
        --v32;
      }
      while (v32);
    }
    *(void *)&key[6] = 0;
  }
  v129[256] = v115;
  v129[257] = v114;
  cache_lock_17838();
  if (get_cache_predicate_17839 != -1) {
    dispatch_once(&get_cache_predicate_17839, &__block_literal_global_7_17840);
  }
  if (!cache_get_and_retain(*(cache_t **)(get_cache_converter_cache + 64), key, &value_out))
  {
    cache_unlock_17841();
    if (!value_out) {
      _CGHandleAssert("CGvImageConverterCacheGetRetained", 315, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGvImageConverterCache.c", "converter != NULL", "converter missing", v41, v42, v43, v107);
    }
    CGConditionalVarWait((uint64_t)value_out + 8, v37, v38, v39, v40, v41, v42, v43);
    uint64_t v44 = value_out;
    if (value_out && *(void *)value_out) {
      return v44;
    }
    release_and_remove_17845(key, value_out);
    value_out = 0;
    cache_lock_17838();
  }
  uint64_t v44 = value_out;
  if (value_out) {
    return v44;
  }
  uint64_t v45 = (char *)malloc_type_calloc(1uLL, 0x338uLL, 0x10B004081A944E8uLL);
  if (v45)
  {
    uint64_t v46 = v45;
    uint64_t v47 = v45 + 128;
    memcpy(v45 + 472, __src, 0x158uLL);
    memcpy(v47, __dst, 0x158uLL);
    v46[816] = v115;
    v46[817] = v114;
    CGConditionalVarInit((uint64_t)(v46 + 8), v48, v49, v50, v51, v52, v53, v54);
    value_out = v46;
    if (get_cache_predicate_17839 != -1) {
      dispatch_once(&get_cache_predicate_17839, &__block_literal_global_7_17840);
    }
    vImageConverterRef v55 = a1;
    cache_set_and_retain(*(cache_t **)(get_cache_converter_cache + 64), key, value_out, 0);
  }
  else
  {
    value_out = 0;
    vImageConverterRef v55 = a1;
  }
  cache_unlock_17841();
  uint64_t v63 = (vImageConverterRef *)value_out;
  if (!value_out) {
    goto LABEL_104;
  }
  if (!v55) {
    goto LABEL_100;
  }
  uint64_t v64 = v55[3];
  unint64_t v65 = (void *)v55[4];
  memset(&srcFormat, 0, sizeof(srcFormat));
  memcpy(v126, (char *)value_out + 128, sizeof(v126));
  vImage_FormatFromConversionFormat((uint64_t)&srcFormat, v126, (uint64_t)v65, v66, v67, v68, v69, v70);
  memset(&destFormat, 0, sizeof(destFormat));
  memcpy(v126, v63 + 59, sizeof(v126));
  vImage_FormatFromConversionFormat((uint64_t)&destFormat, v126, v64, v71, v72, v73, v74, v75);
  int v83 = *((_DWORD *)v55 + 4);
  if (v83 != 1)
  {
    if (v83 == 2)
    {
      unint64_t v91 = (const CGColorConversionInfo *)CGColorConversionInfoCreateFromListInternal((const void *)v55[9], *((unsigned __int8 *)v55 + 80), v65, v78, *((_DWORD *)v55 + 21), v80, v81, v82, v64);
      vImageConverterRef v92 = vImageConverter_CreateWithCGColorConversionInfo(v91, &srcFormat, &destFormat, 0, 0x100u, 0);
      *uint64_t v63 = v92;
      if (!v91) {
        goto LABEL_67;
      }
      CFRelease(v91);
    }
    else
    {
      if (v83 == 3)
      {
        vImageConverterRef v84 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0x100u, 0);
        goto LABEL_99;
      }
      CGPostError((uint64_t)"Unknown CGCMS converter type", v76, v77, v78, v79, v80, v81, v82, v107);
    }
    vImageConverterRef v92 = *v63;
LABEL_67:
    if (!v92)
    {
LABEL_100:
      CGPostError((uint64_t)"%s failed to create vImageConverter", v56, v57, v58, v59, v60, v61, v62, (char)"CGvImageConverterInitializeShared");
      if (value_out)
      {
        CGConditionalVarPost((uint64_t)value_out + 8, v98, v99, v100, v101, v102, v103, v104);
        uint64_t v105 = value_out;
      }
      else
      {
        uint64_t v105 = 0;
      }
      release_and_remove_17845(key, v105);
      goto LABEL_104;
    }
    goto LABEL_68;
  }
  if (!v65) {
    goto LABEL_107;
  }
  BOOL v85 = 0;
  uint64_t v86 = v65[3];
  if (*(unsigned char *)(v86 + 13) && v64) {
    BOOL v85 = *(unsigned char *)(*(void *)(v64 + 24) + 13) != 0;
  }
  int v87 = *(_DWORD *)(v86 + 32);
  if (v87 == 2)
  {
    if (!v64) {
      goto LABEL_107;
    }
    uint64_t v93 = *(void *)(v64 + 24);
    int v94 = *(_DWORD *)(v93 + 32);
    if (v94 == 1)
    {
      int v97 = *(unsigned __int8 *)(v93 + 13);
      if (cmyk_to_rgb_info_predicate != -1) {
        dispatch_once(&cmyk_to_rgb_info_predicate, &__block_literal_global_25_10833);
      }
      uint64_t v89 = &cmyk_to_rgb_info_cmyk_to_rgb_extended;
      if (!v97) {
        uint64_t v89 = &cmyk_to_rgb_info_cmyk_to_rgb_standard;
      }
      goto LABEL_93;
    }
    if (v94) {
      goto LABEL_107;
    }
    if (cmyk_to_gray_info_predicate != -1) {
      dispatch_once(&cmyk_to_gray_info_predicate, &__block_literal_global_22);
    }
    uint64_t v95 = (const CGColorConversionInfo *)cmyk_to_gray_info_cmyk_to_gray;
    goto LABEL_97;
  }
  if (v87 != 1)
  {
    if (!v87 && v64)
    {
      int v88 = *(_DWORD *)(*(void *)(v64 + 24) + 32);
      if (v88 != 2)
      {
        if (v88 != 1) {
          goto LABEL_107;
        }
        if (gray_to_rgb_info_predicate != -1) {
          dispatch_once(&gray_to_rgb_info_predicate, &__block_literal_global_10831);
        }
        uint64_t v89 = &gray_to_rgb_info_gray_to_rgb_extended;
        int v90 = &gray_to_rgb_info_gray_to_rgb_standard;
LABEL_83:
        if (!v85) {
          uint64_t v89 = v90;
        }
LABEL_93:
        uint64_t v95 = (const CGColorConversionInfo *)*v89;
        goto LABEL_97;
      }
      if (gray_to_cmyk_info_predicate != -1) {
        dispatch_once(&gray_to_cmyk_info_predicate, &__block_literal_global_13);
      }
      uint64_t v95 = (const CGColorConversionInfo *)gray_to_cmyk_info_gray_to_cmyk;
      goto LABEL_97;
    }
LABEL_107:
    _CGHandleAssert("conversion_info_for_device_conversion", 230, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGvImageConverter.c", "info != NULL", "conversion info missing", v80, v81, v82, v107);
  }
  if (!v64) {
    goto LABEL_107;
  }
  int v96 = *(_DWORD *)(*(void *)(v64 + 24) + 32);
  if (v96 != 2)
  {
    if (v96) {
      goto LABEL_107;
    }
    if (rgb_to_gray_info_predicate != -1) {
      dispatch_once(&rgb_to_gray_info_predicate, &__block_literal_global_16_10832);
    }
    uint64_t v89 = &rgb_to_gray_info_rgb_to_gray_extended;
    int v90 = &rgb_to_gray_info_rgb_to_gray_standard;
    goto LABEL_83;
  }
  if (rgb_to_cmyk_info_predicate != -1) {
    dispatch_once(&rgb_to_cmyk_info_predicate, &__block_literal_global_19);
  }
  uint64_t v95 = (const CGColorConversionInfo *)rgb_to_cmyk_info_rgb_to_cmyk;
LABEL_97:
  if (!v95) {
    goto LABEL_107;
  }
  vImageConverterRef v84 = vImageConverter_CreateWithCGColorConversionInfo(v95, &srcFormat, &destFormat, 0, 0x100u, 0);
LABEL_99:
  *uint64_t v63 = v84;
  if (!v84) {
    goto LABEL_100;
  }
LABEL_68:
  if (!value_out
    || (CGConditionalVarPost((uint64_t)value_out + 8, v56, v57, v58, v59, v60, v61, v62), (uint64_t v44 = value_out) == 0))
  {
LABEL_104:
    post_conversion_error((uint64_t)a2, v109, (uint64_t)"vImageConverter_Create", v58, v59, v60, v61, v62);
    return 0;
  }
  return v44;
}

uint64_t vImage_FormatFromConversionFormat(uint64_t a1, _DWORD *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 32) = 0;
  uint64_t v8 = (char *)(__src + 10);
  if (!__src[10]) {
    _CGHandleAssert("vImage_FormatFromConversionFormat", 439, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Color/CGvImageConverter.c", "type != kCGImageComponentUnknown", "unknown type %d", a6, a7, a8, 0);
  }
  *(_DWORD *)a1 = *((void *)__src + 6);
  memcpy(__dst, __src + 10, sizeof(__dst));
  *(_DWORD *)(a1 + 4) = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)__dst, v12, v13, v14, v15, v16, v17, v18);
  *(void *)(a1 + 8) = a3;
  memcpy(__dst, v8, sizeof(__dst));
  uint64_t result = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__dst);
  *(_DWORD *)(a1 + 32) = __src[8];
  *(void *)(a1 + 16) = result;
  *(void *)(a1 + 24) = *((void *)__src + 10);
  return result;
}

uint64_t CGBitmapPixelInfoGetCGImageBitmapInfo(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 == 8) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 24);
  }
  if (v2 == 9) {
    int v4 = 3;
  }
  else {
    int v4 = v3;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 28) | v4 | *(_DWORD *)(a1 + 32);
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 4) {
    uint64_t result = v5 | 0x100;
  }
  else {
    uint64_t result = v5;
  }
  if (*(void *)(a1 + 8) == 8)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    unsigned int v8 = v2 - 1;
    if (v8 > 8) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = qword_185211998[v8];
    }
    if (v9 + v7 == 4) {
      return result;
    }
    else {
      return result & 0xFFFF8FFF;
    }
  }
  return result;
}

BOOL CGConditionalVarWait(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGConditionalVarWait", 43, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Utilities/CGConditionalVar.c", "cvar != NULL", "Conditional variable is NULL", a6, a7, a8, v10);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)a1)) {
    return 0;
  }
  while (!*(unsigned char *)(a1 + 112))
  {
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 64), (pthread_mutex_t *)a1)) {
      return 0;
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)a1) == 0;
}

CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate)
{
  return mask_create(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, provider, (double *)decode, shouldInterpolate, 4);
}

__CFData *mask_create(unint64_t Length, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, CGDataProviderRef provider, double *a7, uint64_t a8, int a9)
{
  vImagePixelCount v10 = Length;
  if (!Length || !a2)
  {
    CGPostError((uint64_t)"%s: invalid image mask size: %lu x %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (a3 > 8 || ((1 << a3) & 0x116) == 0)
  {
    CGPostError((uint64_t)"%s: invalid image mask bits/component: %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (a3 > a4)
  {
    CGPostError((uint64_t)"%s: invalid image mask bits/pixel: %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (0xFFFFFFFFFFFFFFF8 / a4 < a2) {
    goto LABEL_9;
  }
  if (0xFFFFFFFFFFFFFFF8 / a4 < Length)
  {
    CGPostError((uint64_t)"%s: invalid image mask width.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (0x7FFFFFF8 / a4 < a2)
  {
LABEL_9:
    CGPostError((uint64_t)"%s: unsupported image mask height: %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (0x7FFFFFF8 / a4 < Length)
  {
    CGPostError((uint64_t)"%s: unsupported image mask width: %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  unint64_t v15 = a5;
  if (a5 >> 31)
  {
    CGPostError((uint64_t)"%s: unsupported image mask bytes/row: %lu.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (a5 < (a4 * Length + 7) >> 3)
  {
    CGPostError((uint64_t)"%s: invalid image mask bits/pixel or bytes/row.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  int v16 = a8;
  uint64_t v18 = provider;
  if (a3 != a4 && (a4 & 7) != 0)
  {
    CGPostError((uint64_t)"%s: invalid image mask bits/pixel.", a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (!provider)
  {
    CGPostError((uint64_t)"%s: invalid image mask provider: NULL.", a2, a3, a4, a5, 0, (uint64_t)a7, a8, (char)"mask_create");
    return 0;
  }
  if (a3 == a4)
  {
    CFDictionaryRef v19 = 0;
  }
  else
  {
    CFDataRef v23 = CGDataProviderCopyData(provider);
    if (!v23) {
      return 0;
    }
    CFDataRef v24 = v23;
    BytePtr = (char *)CFDataGetBytePtr(v23);
    if (!BytePtr)
    {
      CFRelease(v24);
      return 0;
    }
    uint64_t v13 = compress_data(BytePtr, v10, a2, a3, a4, v15, a9);
    CFRelease(v24);
    if (!v13) {
      return v13;
    }
    uint64_t v18 = CGDataProviderCreateWithCFData(v13);
    CFRelease(v13);
    unint64_t v15 = CFDataGetLength(v13) / a2;
    CFIndex Length = CFDataGetLength(v13);
    if (Length != v15 * a2)
    {
      CFDataGetLength(v13);
      _CGHandleAssert("mask_create", 1042, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "unsigned_cast(CFDataGetLength(new_data)) == bytes_per_row * height", "bytes per row (%lu) doesn't evenly divide in the data size (%lu)", v26, v27, v28, v15);
    }
    CFDictionaryRef v19 = v18;
    if (!v18) {
      return 0;
    }
  }
  uint64_t image_base = create_image_base(Length, a2, a3, a4, a5, (uint64_t)provider, (uint64_t)a7, a8);
  uint64_t v13 = (__CFData *)image_base;
  if (!image_base)
  {
    BOOL v22 = v18;
    goto LABEL_42;
  }
  *(void *)(image_base + 40) = v10;
  *(void *)(image_base + 48) = a2;
  *(void *)(image_base + 56) = a3;
  *(void *)(image_base + 64) = a3;
  *(void *)(image_base + 72) = v15;
  *(_DWORD *)(image_base + 32) = 0;
  *(void *)(image_base + 144) = 0;
  CGDataProviderRetain(v18);
  *((void *)v13 + 19) = v18;
  if (v16) {
    int v21 = 50331649;
  }
  else {
    int v21 = 33554433;
  }
  *((_DWORD *)v13 + 9) = v21 | *((_DWORD *)v13 + 9) & 0xF0FF0000;
  *((void *)v13 + 25) = 0;
  *((void *)v13 + 26) = 0;
  *(_OWORD *)((char *)v13 + 232) = 0u;
  *(_OWORD *)((char *)v13 + 248) = 0u;
  cgimage_set_decode_array((void **)v13, a7, 1uLL);
  if (v19)
  {
    BOOL v22 = v19;
LABEL_42:
    CFRelease(v22);
  }
  return v13;
}

uint64_t CGImageCreateWithImageProvider(uint64_t a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    CGPostError((uint64_t)"%s: invalid image provider: NULL.", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"CGImageCreateWithImageProvider");
    return 0;
  }
  double v10 = *(double *)(a1 + 16);
  double v9 = *(double *)(a1 + 24);
  if (v10 < 1.0 || v9 < 1.0 || v10 != (double)(unint64_t)v10 || v9 != (double)(unint64_t)v9)
  {
    CGPostError((uint64_t)"%s: invalid image size: %g x %g.", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"CGImageCreateWithImageProvider");
    return 0;
  }
  unsigned __int8 v16 = a4;
  int v17 = a3;
  uint64_t v19 = *(void *)(a1 + 120);
  if ((!v19 || (Properdouble ty = CGPropertiesGetProperty(v19, @"kCGImageProviderColorSpaceChangedOnImageCopy")) == 0)
    && (Properdouble ty = *(void **)(a1 + 40)) == 0
    || ((uint64_t v21 = Property[3], v22 = *(_DWORD *)(v21 + 28), v22 >= 6) ? (v23 = v22 == 7) : (v23 = 1), !v23))
  {
    CGPostError((uint64_t)"%s: invalid image colorspace.", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"CGImageCreateWithImageProvider");
    return 0;
  }
  int v25 = *(_DWORD *)(a1 + 32);
  unsigned int v24 = *(_DWORD *)(a1 + 36);
  int v44 = v24;
  unint64_t v26 = *(void *)(v21 + 48);
  if ((v24 & 0x1F) != 0) {
    ++v26;
  }
  unint64_t v27 = (unint64_t)v10;
  unint64_t v28 = 32;
  uint64_t v29 = 10;
  switch(v25)
  {
    case 1:
      unint64_t v28 = 8 * v26;
      uint64_t v29 = 8;
      break;
    case 2:
      goto LABEL_33;
    case 3:
      int v44 = v24 | 0x2000;
      goto LABEL_31;
    case 4:
LABEL_31:
      unint64_t v28 = 32 * v26;
      uint64_t v29 = 32;
      break;
    case 5:
      int v44 = v24 | 0x100;
LABEL_33:
      unint64_t v28 = 16 * v26;
      uint64_t v29 = 16;
      break;
    case 6:
      break;
    default:
      CGPostError((uint64_t)"%s: invalid image component type.", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"CGImageCreateWithImageProvider");
      return 0;
  }
  unint64_t v40 = v26;
  uint64_t v42 = 0;
  unsigned __int8 v41 = 0;
  uint64_t v30 = verify_image_parameters((uint64_t)Property, (unsigned int *)&v44, (unint64_t)v10, v29, v28, (v28 * v27) >> 3, (uint64_t)a2, &v43, &v41, &v42);
  uint64_t v14 = 0;
  if (v30)
  {
    uint64_t image_base = create_image_base(v30, v31, v32, v33, v34, v35, v36, v37);
    uint64_t v14 = image_base;
    if (image_base)
    {
      *(void *)(image_base + 40) = v27;
      *(void *)(image_base + 48) = (unint64_t)v9;
      *(void *)(image_base + 56) = v29;
      *(void *)(image_base + 64) = v28;
      *(void *)(image_base + 72) = (v28 * v27) >> 3;
      *(_DWORD *)(image_base + 32) = v44;
      CFRetain(Property);
      *(void *)(v14 + 144) = Property;
      *(void *)(v14 + 152) = 0;
      CFRetain((CFTypeRef)a1);
      if (v17) {
        int v39 = 0x1000000;
      }
      else {
        int v39 = 0;
      }
      *(_DWORD *)(v14 + 36) = v39 & 0xFFFF00FF | (v16 << 8) | *(_DWORD *)(v14 + 36) & 0xF0FF0000 | (v41 << 26) | 1;
      *(void *)(v14 + 200) = 0;
      *(void *)(v14 + 208) = a1;
      *(_OWORD *)(v14 + 232) = 0u;
      *(_OWORD *)(v14 + 248) = 0u;
      cgimage_set_decode_array((void **)v14, a2, v40);
      add_headroom_info_from_image_provider((void *)v14);
    }
  }
  return v14;
}

const void *CGPropertiesGetProperty(uint64_t a1, const void *a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  os_unfair_lock_unlock(v4);
  return Value;
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  CGBitmapInfo v49 = bitmapInfo;
  if (!width || !height)
  {
    CGPostError((uint64_t)"%s: invalid image size: %zu x %zu.", height, bitsPerComponent, bitsPerPixel, bytesPerRow, (uint64_t)space, *(uint64_t *)&bitmapInfo, (uint64_t)provider, (char)"CGImageCreate");
    return 0;
  }
  unint64_t v47 = 0;
  unint64_t v48 = 0;
  unsigned __int8 v46 = 0;
  uint64_t v18 = verify_image_parameters((uint64_t)space, &v49, width, bitsPerComponent, bitsPerPixel, bytesPerRow, (uint64_t)decode, &v48, &v46, (uint64_t *)&v47);
  uint64_t v26 = 0;
  if (!v18) {
    return (CGImageRef)v26;
  }
  if (!provider)
  {
    CGPostError((uint64_t)"%s: invalid data provider: NULL.", v19, v20, v21, v22, v23, v24, v25, (char)"CGImageCreate");
    return 0;
  }
  uint64_t v27 = *((void *)provider + 4);
  if (v27 != -1)
  {
    if (v27 >= 1 && is_mul_ok(height - 1, bytesPerRow))
    {
      size_t v29 = (height - 1) * bytesPerRow;
      unint64_t v30 = v48 + v29;
      BOOL v31 = __CFADD__(v48, v29);
      if (v27 >= v30 && !v31)
      {
        uint64_t v32 = (const UInt8 *(__cdecl *)(CFDataRef))*((void *)provider + 10);
        if (v32 == getCFDataBytePointer || (char *)v32 == (char *)data_get_byte_pointer)
        {
          CGDataProviderRetainBytePtr((uint64_t)provider);
          CGDataProviderReleaseBytePtr((uint64_t)provider);
        }
        goto LABEL_21;
      }
    }
    CGPostError((uint64_t)"%s: invalid image data size: %zu (height) x %zu (bytesPerRow) data provider size %lli", v19, v20, v21, v22, v23, v24, v25, (char)"CGImageCreate");
    return 0;
  }
LABEL_21:
  uint64_t image_base = create_image_base(v18, v19, v20, v21, v22, v23, v24, v25);
  uint64_t v26 = image_base;
  if (image_base)
  {
    *(void *)(image_base + 40) = width;
    *(void *)(image_base + 48) = height;
    *(void *)(image_base + 56) = bitsPerComponent;
    *(void *)(image_base + 64) = bitsPerPixel;
    *(void *)(image_base + 72) = bytesPerRow;
    unsigned int v34 = v49;
    if (space) {
      int v35 = *(_DWORD *)(*((void *)space + 3) + 28);
    }
    else {
      int v35 = -1;
    }
    unsigned int v36 = v49 | 0x4000;
    unsigned int v37 = v49 | 0x3000;
    if (bitsPerComponent != 16) {
      unsigned int v37 = v49;
    }
    if (bitsPerComponent != 32) {
      unsigned int v36 = v37;
    }
    if ((v49 & 0x7100) == 0x100) {
      unsigned int v34 = v36;
    }
    if ((v34 & 0xF0000) == 0 && v35 == 1 && bitsPerPixel == 16 && bitsPerComponent == 5) {
      v34 |= 0x10000u;
    }
    *(_DWORD *)(image_base + 32) = v34;
    if (space) {
      CFRetain(space);
    }
    *(void *)(v26 + 144) = space;
    CGDataProviderRetain(provider);
    *(void *)(v26 + 152) = provider;
    if (shouldInterpolate) {
      int v41 = 0x1000000;
    }
    else {
      int v41 = 0;
    }
    unsigned int v42 = v41 & 0xFFFF00FF | (intent << 8) | *(_DWORD *)(v26 + 36) & 0xF0000000 | (v46 << 26);
    *(void *)(v26 + 200) = 0;
    *(void *)(v26 + 208) = 0;
    *(_OWORD *)(v26 + 232) = 0u;
    *(_OWORD *)(v26 + 248) = 0u;
    *(_DWORD *)(v26 + 36) = v42 | 0x10001;
    cgimage_set_decode_array((void **)v26, (double *)decode, v47);
    CFTypeID v43 = CFGetTypeID((CFTypeRef)v26);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v43 == CGImageGetTypeID_image_type_id)
    {
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)v26);
      if (ColorSpace)
      {
        if (*(unsigned char *)(*((void *)ColorSpace + 3) + 13))
        {
          CGColorSpaceRef v45 = CGImageGetColorSpace((CGImageRef)v26);
          if (v45)
          {
            if (*(_DWORD *)(*((void *)v45 + 3) + 28) == 1) {
              CGImageSetHeadroom((uint64_t *)v26, 0, 0.0);
            }
          }
        }
      }
    }
  }
  return (CGImageRef)v26;
}

CGDataProviderRef CGDataProviderRetain(CGDataProviderRef provider)
{
  if (provider)
  {
    CFTypeID v2 = CFGetTypeID(provider);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v2 == CGDataProviderGetTypeID_id) {
      CFRetain(provider);
    }
  }
  return provider;
}

double cgimage_set_decode_array(void **image, double *a2, unint64_t a3)
{
  if (!a2) {
    goto LABEL_15;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
  uint64_t v14 = (uint64_t)ColorSpace;
  if (ColorSpace) {
    unint64_t v15 = *(void *)(*((void *)ColorSpace + 3) + 48);
  }
  else {
    unint64_t v15 = (unint64_t)image[8] / (unint64_t)image[7];
  }
  int v16 = 0;
  int v17 = 0;
  unint64_t v18 = v15;
  switch(image[4] & 0x1F)
  {
    case 0:
      break;
    case 1:
    case 3:
    case 5:
      int v16 = 0;
      unint64_t v18 = v15 + 1;
      int v17 = 1;
      break;
    case 2:
    case 4:
      int v17 = 0;
      unint64_t v18 = v15 + 1;
      int v16 = 1;
      break;
    case 6:
      int v16 = 0;
      int v17 = 0;
      unint64_t v18 = v15 + 1;
      break;
    default:
      CGPostError((uint64_t)"%s: invalid image alphaInfo: %d", v7, v8, v9, v10, v11, v12, v13, (char)"cgimage_set_decode_array");
      goto LABEL_15;
  }
  if (v15 > a3 || v18 < a3)
  {
    CGPostError((uint64_t)"%s: invalid number of decode components: %d", v7, v8, v9, v10, v11, v12, v13, (char)"cgimage_set_decode_array");
LABEL_15:
    free(image[20]);
    image[20] = 0;
    return result;
  }
  if (v18 == a3) {
    int v21 = 0;
  }
  else {
    int v21 = v16 | v17;
  }
  int v54 = v17;
  int v55 = v21;
  int v22 = v16 ^ 1 | v21;
  if (v22) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = 2;
  }
  uint64_t v24 = &a2[v23];
  int v53 = v16;
  if ((v22 & 1) != 0 || *a2 == 0.0 && a2[1] == 1.0)
  {
    int v25 = 1;
    if (ColorSpace) {
      goto LABEL_29;
    }
  }
  else
  {
    int v25 = 0;
    if (ColorSpace)
    {
LABEL_29:
      unint64_t v26 = (unint64_t)image[7];
      int v27 = v25;
      int Type = CGColorSpaceGetType(ColorSpace);
      int v25 = v27;
      switch(Type)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
          goto LABEL_30;
        case 5:
          long long v58 = 0u;
          long long v59 = 0u;
          long long v57 = 0u;
          memset(v56, 0, sizeof(v56));
          CGColorSpaceGetLabData(v14, v33, v34, v35, v56);
          if (*v24 != 0.0) {
            goto LABEL_45;
          }
          int v38 = v55;
          int v25 = v27;
          if (v24[1] != 100.0)
          {
            int v40 = 0;
            int v39 = v54;
            goto LABEL_61;
          }
          int v39 = v54;
          if (v24[2] != *(double *)&v57
            || v24[3] != *((double *)&v57 + 1)
            || v24[4] != *(double *)&v58
            || v24[5] != *((double *)&v58 + 1))
          {
            break;
          }
          goto LABEL_35;
        case 6:
        case 10:
        case 11:
          uint64_t v41 = CGColorSpaceICCGetRange(v14, v29, v30, v31, v32, v33, v34, v35);
          if (!v41)
          {
LABEL_45:
            int v40 = 0;
            int v25 = v27;
            goto LABEL_46;
          }
          int v25 = v27;
          if (!v15) {
            goto LABEL_43;
          }
          unsigned int v42 = (double *)(v41 + 8);
          CFTypeID v43 = &a2[v23 + 1];
          unint64_t v44 = v15;
          int v39 = v54;
          int v38 = v55;
          int v40 = 1;
          while (*(v43 - 1) == *(v42 - 1) && *v43 == *v42)
          {
            v42 += 2;
            v43 += 2;
            if (!--v44) {
              goto LABEL_61;
            }
          }
          break;
        case 7:
          if (v15 != 1) {
            _CGHandleAssert("colorspace_indexed_decode_array_is_identity", 159, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "decode_components == 1", "decode components %zu", v33, v34, v35, v15);
          }
          int v39 = v54;
          int v38 = v55;
          if (v26 >= 0x21) {
            _CGHandleAssert("colorspace_indexed_decode_array_is_identity", 160, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "bits_per_component <= 32", "bpc %zu", v33, v34, v35, v26);
          }
          if (*v24 == 0.0)
          {
            double v45 = (double)~(-1 << v26);
            if (v26 == 32) {
              double v45 = 4294967300.0;
            }
            if (v24[1] == v45) {
              goto LABEL_35;
            }
          }
          break;
        default:
          abort();
      }
LABEL_60:
      int v40 = 0;
      goto LABEL_61;
    }
  }
LABEL_30:
  if (v15)
  {
    unsigned int v36 = &a2[v23 + 1];
    unint64_t v37 = v15;
    int v39 = v54;
    int v38 = v55;
    while (*(v36 - 1) == 0.0 && *v36 == 1.0)
    {
      v36 += 2;
      if (!--v37)
      {
LABEL_35:
        int v40 = 1;
        goto LABEL_61;
      }
    }
    goto LABEL_60;
  }
LABEL_43:
  int v40 = 1;
LABEL_46:
  int v39 = v54;
  int v38 = v55;
LABEL_61:
  int v46 = v25 & v40;
  if ((v39 ^ 1 | v38))
  {
    if (v46) {
      goto LABEL_15;
    }
  }
  else if (a2[2 * v18 - 2] == 0.0)
  {
    if (a2[2 * v18 - 1] != 1.0) {
      LOBYTE(v46) = 0;
    }
    if (v46) {
      goto LABEL_15;
    }
  }
  free(image[20]);
  unint64_t v47 = (double *)malloc_type_malloc(16 * v18, 0x705560E0uLL);
  image[20] = v47;
  unint64_t v48 = v47;
  if (v53)
  {
    if (v38)
    {
      *unint64_t v47 = 0.0;
      double result = 1.0;
    }
    else
    {
      *unint64_t v47 = *a2;
      double result = a2[1];
    }
    v47[1] = result;
    unint64_t v48 = v47 + 2;
  }
  if (2 * v15)
  {
    uint64_t v49 = 2 * v15;
    do
    {
      double v50 = *v24++;
      double result = v50;
      *v48++ = v50;
      --v49;
    }
    while (v49);
  }
  if (v39)
  {
    if (v38)
    {
      uint64_t v51 = 2 * v18;
      v47[2 * v18 - 2] = 0.0;
      double result = 1.0;
    }
    else
    {
      uint64_t v52 = &a2[2 * a3];
      uint64_t v51 = 2 * v18;
      v47[2 * v18 - 2] = *(v52 - 2);
      double result = *(v52 - 1);
    }
    v47[v51 - 1] = result;
  }
  if ((image[4] & 0x1F) == 6)
  {
    double result = 0.0;
    *(_OWORD *)&v47[2 * v15] = xmmword_1850CD8C0;
  }
  return result;
}

uint64_t create_image_base(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
  }
  uint64_t Instance = CGTypeCreateInstance(CGImageGetTypeID_image_type_id, 248, a3, a4, a5, a6, a7, a8);
  uint64_t v9 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 24) = atomic_fetch_add_explicit(identifier, 1u, memory_order_relaxed) + 1;
    *(_DWORD *)(Instance + 28) = 48879;
    v11.__sig = 0;
    *(void *)v11.__opaque = 0;
    pthread_mutexattr_init(&v11);
    pthread_mutexattr_settype(&v11, 2);
    pthread_mutex_init((pthread_mutex_t *)(v9 + 80), &v11);
    pthread_mutexattr_destroy(&v11);
  }
  return v9;
}

uint64_t verify_image_parameters(uint64_t a1, unsigned int *a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, unint64_t *a8, unsigned char *a9, uint64_t *a10)
{
  uint64_t v18 = *a2;
  if ((v18 & 0x100) != 0)
  {
    if (a4 == 16)
    {
      if ((a5 & 0xF) == 0)
      {
        int v19 = v18 & 0x7000;
        BOOL v20 = a5 == 16;
        goto LABEL_17;
      }
    }
    else
    {
      if (a4 != 32)
      {
        CGPostError((uint64_t)"%s: invalid floating-point bits/component: %lu.", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
        return 0;
      }
      if ((a5 & 0x1F) == 0) {
        goto LABEL_7;
      }
    }
    CGPostError((uint64_t)"%s: invalid floating-point bits/pixel: %lu.", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
    return 0;
  }
  if ((unint64_t)(a4 - 33) <= 0xFFFFFFFFFFFFFFDFLL)
  {
    CGPostError((uint64_t)"%s: invalid integer bits/component: %lu.", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
    return 0;
  }
LABEL_7:
  int v19 = v18 & 0x7000;
  BOOL v20 = a5 == 16;
  if (a4 != 16 && a5 != 16)
  {
    if ((v18 & 0x5000) != 0x1000)
    {
      BOOL v20 = 0;
      goto LABEL_23;
    }
    CGPostError((uint64_t)"%s: invalid image byte order info for bitsPerPixel != 16 = %u", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
    BOOL v21 = linked_on_sydro_or_later();
    BOOL v20 = 0;
    uint64_t result = 0;
    if (v21) {
      return result;
    }
    goto LABEL_22;
  }
LABEL_17:
  if ((v18 & 0x5000) != 0x1000 && v19 != 0)
  {
    CGPostError((uint64_t)"%s: invalid image byte order info for bitsPerPixel == 16 = %u", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
    if (linked_on_sydro_or_later()) {
      return 0;
    }
LABEL_22:
    int v19 = 0;
    uint64_t v18 = *a2 & 0xFFFF8FFF;
    *a2 = v18;
  }
LABEL_23:
  BOOL v25 = a4 != 16 && a5 == 32;
  if (a4 == 32 || v25)
  {
    if (v19 == 0x4000 || (v19 & 0x5000) == 0) {
      goto LABEL_39;
    }
    CGPostError((uint64_t)"%s: invalid image byte order info for bitsPerPixel == 32 = %u", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
  }
  else
  {
    if (v19 != 0x4000 && v19 != 0x2000) {
      goto LABEL_39;
    }
    CGPostError((uint64_t)"%s: invalid image byte order info for bitsPerPixel != 32 = %u", v18, a3, a4, a5, a6, a7, (uint64_t)a8, (char)"verify_image_parameters");
  }
  if (linked_on_sydro_or_later()) {
    return 0;
  }
  int v19 = 0;
  LODWORD(v18) = *a2 & 0xFFFF8FFF;
  *a2 = v18;
LABEL_39:
  if ((valid_image_colorspace(a1, v18) & 1) == 0)
  {
    CGPostError((uint64_t)"%s: invalid image colorspace: NULL.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
    return 0;
  }
  uint64_t v33 = a10;
  if (!a1)
  {
    BOOL v37 = 0;
    *a10 = 0;
    unsigned int v35 = *a2;
    BOOL v38 = (*a2 & 0x1F) == 0;
    goto LABEL_57;
  }
  uint64_t v34 = *(void *)(a1 + 24);
  a1 = *(void *)(v34 + 48);
  *a10 = a1;
  unsigned int v35 = *a2;
  int v36 = *(_DWORD *)(v34 + 28);
  BOOL v37 = v36 == 1;
  BOOL v38 = (*a2 & 0x1F) == 0;
  if (a5 != 32 || a4 != 8 || v36 != 1 || (*a2 & 0x1F) != 0)
  {
LABEL_57:
    *a9 = 0;
    int v39 = v35 & 0x1F;
    if ((v39 - 1) >= 4)
    {
      if ((v39 - 5) >= 2)
      {
        if ((v35 & 0x1F) != 0)
        {
          CGPostError((uint64_t)"%s: invalid image alphaInfo: %d", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
          return 0;
        }
LABEL_61:
        int v40 = v35 & 0xF0000;
        BOOL v41 = a4 == 5 && v20;
        if (v41 && v37)
        {
          if (v40 == 0x20000 || v40 == 0x10000)
          {
LABEL_69:
            if (v40 == 0x20000)
            {
              if ((v35 & 0x1F) != 0)
              {
                CGPostError((uint64_t)"%s: invalid alpha info for kCGImagePixelFormatRGB565 = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
                return 0;
              }
            }
            else if (v40 == 0x10000 && (v35 & 0x1F) <= 2)
            {
              CGPostError((uint64_t)"%s: invalid alpha info for kCGImagePixelFormatRGB555 = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
LABEL_94:
            if (0xFFFFFFFFFFFFFFF8 / a5 >= a3)
            {
              if (0x7FFFFFF8 / a5 >= a3)
              {
                if (a6 >> 31)
                {
                  CGPostError((uint64_t)"%s: unsupported image bytes/row: %lu.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
                }
                else
                {
                  *a8 = a3 * a5;
                  if (is_mul_ok(a3, a5))
                  {
                    unint64_t v43 = (a3 * a5 + 7) >> 3;
                    *a8 = v43;
                    if (v43 <= a6) {
                      return 1;
                    }
                    CGPostError((uint64_t)"%s: invalid image bits/pixel or bytes/row.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
                  }
                  else
                  {
                    CGPostError((uint64_t)"%s: invalid image bits/pixel or width.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
                  }
                }
              }
              else
              {
                CGPostError((uint64_t)"%s: unsupported image width: %lu.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              }
            }
            else
            {
              CGPostError((uint64_t)"%s: invalid image width.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
            }
            return 0;
          }
          if (!v40)
          {
            v35 |= 0x10000u;
            *a2 = v35;
            int v40 = v35 & 0xF0000;
            goto LABEL_69;
          }
        }
        else
        {
          BOOL v42 = a4 == 10 && v37;
          if (a5 != 32 || !v42)
          {
            if (a1 * a4 != a5)
            {
              CGPostError((uint64_t)"%s: invalid image bits/component: %lu bits/pixel %lu alpha float64x2_t info = %s", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            if (v40)
            {
              CGPostError((uint64_t)"%s: invalid image pixel format float64x2_t info = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            goto LABEL_94;
          }
          if (v40 == 196608)
          {
            if (!v39)
            {
              CGPostError((uint64_t)"%s: invalid alpha info for kCGImagePixelFormatRGB101010 = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            goto LABEL_94;
          }
          if (v40 == 0x40000)
          {
            if (!v38)
            {
              CGPostError((uint64_t)"%s: invalid alpha info for kCGImagePixelFormatRGBCIF10 = %u. Use kCGImageAlphaNone instead.", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            if (v19 != 0x2000)
            {
              CGPostError((uint64_t)"%s: invalid image byte order info for kCGImagePixelFormatRGBCIF10 = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            if (a7)
            {
              CGPostError((uint64_t)"%s: kCGImagePixelFormatRGBCIF10 doesn't not allow decode", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
              return 0;
            }
            goto LABEL_94;
          }
        }
        CGPostError((uint64_t)"%s: invalid image bits/component: %lu bits/pixel %lu pixel format = %u", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
        return 0;
      }
    }
    else
    {
      *a9 = 1;
      ++*v33;
    }
    ++a1;
    goto LABEL_61;
  }
  CGPostError((uint64_t)"%s: invalid image alphaInfo: kCGImageAlphaNone. It should be kCGImageAlphaNoneSkipLast", v26, v27, v28, v29, v30, v31, v32, (char)"verify_image_parameters");
  if (linked_on_dawnburst_or_later_predicate != -1) {
    dispatch_once(&linked_on_dawnburst_or_later_predicate, &__block_literal_global_305);
  }
  uint64_t result = 0;
  if (!linked_on_dawnburst_or_later_linked_on_macOS14_or_later
    && !linked_on_dawnburst_or_later_linked_on_iOS17_or_later
    && !linked_on_dawnburst_or_later_linked_on_tvOS17_or_later
    && !linked_on_dawnburst_or_later_linked_on_watchOS10_or_later
    && !linked_on_dawnburst_or_later_linked_on_borealis_or_later)
  {
    unsigned int v35 = *a2 & 0xFFFFFFE0 | 5;
    *a2 = v35;
    BOOL v38 = 1;
    BOOL v37 = 1;
    uint64_t v33 = a10;
    goto LABEL_57;
  }
  return result;
}

uint64_t valid_image_colorspace(uint64_t result, int a2)
{
  if (!result) {
    return result;
  }
  int v3 = (void *)result;
  int Type = CGColorSpaceGetType((void *)result);
  switch(Type)
  {
    case 5:
LABEL_6:
      if ((a2 & 0x1Fu) - 1 >= 2) {
        break;
      }
      return 0;
    case 9:
      return 0;
    case 7:
      if ((a2 & 0xF00) != 0) {
        return 0;
      }
      goto LABEL_6;
  }
  if ((a2 & 0xF0000) == 0x40000)
  {
    CGColorSpaceRef v6 = CGColorSpaceCreateWithName(@"kCGColorSpaceExtendedSRGB");
    uint64_t result = CFEqual(v3, v6);
    if (!result) {
      return result;
    }
  }
  else if ((a2 & 0xF0000) == 0x30000)
  {
    uint64_t v5 = v3[3];
    if (*(unsigned char *)(v5 + 13) || *(_DWORD *)(v5 + 28) != 1) {
      return 0;
    }
  }
  return 1;
}

__n128 CGDataProviderCreateDirectWithInternalCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0)
  {
    CGPostError((uint64_t)"%s: Invalid std::string::size_type size = %lld", a2, a3, a4, a5, a6, a7, a8, (char)"CGDataProviderCreateDirectWithInternalCallbacks");
    if (!a3) {
      return result;
    }
  }
  else if (!a3)
  {
    return result;
  }
  if (a2 >= 1 && *(_DWORD *)a3 == 1)
  {
    if (*(void *)(a3 + 8))
    {
      if (*(void *)(a3 + 40)) {
        return result;
      }
    }
    else if (!*(void *)(a3 + 24))
    {
      return result;
    }
    uint64_t provider = create_provider(a1, 0, a3, a4, a5, a6, a7, a8);
    if (provider)
    {
      *(void *)(provider + 32) = a2;
      *(_OWORD *)(provider + 80) = *(_OWORD *)(a3 + 8);
      uint64_t v13 = *(void *)(a3 + 32);
      *(void *)(provider + 96) = *(void *)(a3 + 24);
      *(void *)(provider + 72) = v13;
      *(_OWORD *)(provider + 128) = *(_OWORD *)(a3 + 40);
      __n128 result = *(__n128 *)(a3 + 56);
      *(__n128 *)(provider + 160) = result;
    }
  }
  return result;
}

uint64_t CGCFDictionaryGetMD5Digest(const __CFDictionary *a1, unsigned __int8 a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(void *)mdouble d = 0;
  uint64_t v9 = 0;
  int v4 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v4);
  context[0] = v4;
  context[1] = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)md5_creator, context);
  if (v4)
  {
    CC_MD5_Final(md, v4);
    uint64_t v5 = *(void *)md;
  }
  else
  {
    uint64_t v5 = 0;
  }
  free(v4);
  return v5;
}

void object_md5_creator(CC_MD5_CTX *a1, const __CFString *propertyList)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (!propertyList) {
    goto LABEL_50;
  }
  CFTypeID v4 = CFGetTypeID(propertyList);
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  if (v4 == CGColorSpaceGetTypeID_type_id)
  {
    uint64_t length = propertyList->length;
    if (length) {
      CGColorSpaceRef v6 = (_OWORD *)(length + 64);
    }
    else {
      CGColorSpaceRef v6 = 0;
    }
    data[0] = *v6;
    if (!a1) {
      return;
    }
    goto LABEL_16;
  }
  CFTypeID v7 = CFGetTypeID(propertyList);
  if (object_md5_creator_cglibrarypredicate != -1) {
    dispatch_once(&object_md5_creator_cglibrarypredicate, &__block_literal_global_260);
  }
  if (v7 != object_md5_creator_f())
  {
    CFTypeID v11 = CFGetTypeID(propertyList);
    if (v11 == CFURLGetTypeID())
    {
      CFURLRef v12 = CFURLCopyAbsoluteURL((CFURLRef)propertyList);
      if (v12)
      {
        CFURLRef v19 = v12;
        CFStringRef v20 = CFURLCopyFileSystemPath(v12, kCFURLPOSIXPathStyle);
        if (v20)
        {
          CFStringRef v21 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            if (a1)
            {
              uint64_t v23 = (char *)CStringPtr;
              size_t v24 = strlen(CStringPtr);
              md5_update(a1, v23, v24);
            }
            CFRelease(v21);
LABEL_53:
            CFRelease(v19);
            return;
          }
          CFRelease(v21);
        }
        CFRelease(v19);
      }
      CGLog(3, (uint64_t)"md5_creator failed for CFURL %p", v13, v14, v15, v16, v17, v18, (char)propertyList);
      return;
    }
    CFTypeID v25 = CFGetTypeID(propertyList);
    if (v25 == CFStringGetTypeID())
    {
      uint64_t v26 = CFStringGetCStringPtr(propertyList, 0x8000100u);
      if (!v26)
      {
        bzero(data, 0x401uLL);
        CFIndex v35 = CFStringGetLength(propertyList);
        if (!CFStringGetCString(propertyList, (char *)data, 1024, 0x600u))
        {
          v62.locatiounint64_t n = 0;
          v62.uint64_t length = v35;
          CFStringGetBytes(propertyList, v62, 0x600u, 0x3Fu, 0, (UInt8 *)data, 1024, 0);
        }
        size_t v36 = strlen((const char *)data);
        if (v36)
        {
          if (a1) {
            md5_update(a1, (char *)data, v36);
          }
        }
        else
        {
          CGLog(3, (uint64_t)"md5_creator failed for CFString %p", v37, v38, v39, v40, v41, v42, (char)propertyList);
        }
        return;
      }
      if (!a1) {
        return;
      }
      uint64_t v27 = (char *)v26;
      size_t v28 = strlen(v26);
      uint64_t v29 = a1;
      uint64_t v30 = v27;
LABEL_32:
      md5_update(v29, v30, v28);
      return;
    }
    CFTypeID v31 = CFGetTypeID(propertyList);
    if (v31 == CFDataGetTypeID())
    {
      CFIndex v32 = CFDataGetLength((CFDataRef)propertyList);
      BytePtr = CFDataGetBytePtr((CFDataRef)propertyList);
      if (!a1) {
        return;
      }
      uint64_t v30 = (char *)BytePtr;
      uint64_t v29 = a1;
      size_t v28 = v32;
      goto LABEL_32;
    }
    CFTypeID v34 = CFGetTypeID(propertyList);
    if (v34 == CFBooleanGetTypeID())
    {
      LODWORD(data[0]) = *MEMORY[0x1E4F1CFD0] == (void)propertyList;
      if (!a1) {
        return;
      }
      uint64_t v9 = a1;
      CC_LONG v10 = 4;
LABEL_17:
      CC_MD5_Update(v9, data, v10);
      return;
    }
    CFTypeID v43 = CFGetTypeID(propertyList);
    if (v43 == CFNumberGetTypeID())
    {
      *(void *)&data[0] = 0;
      if (CFNumberGetValue((CFNumberRef)propertyList, kCFNumberDoubleType, data) != 1)
      {
        CGLog(3, (uint64_t)"md5_creator failed for CFNumber %p", v44, v45, v46, v47, v48, v49, (char)propertyList);
        return;
      }
      if (a1)
      {
        uint64_t v9 = a1;
        CC_LONG v10 = 8;
        goto LABEL_17;
      }
      return;
    }
LABEL_50:
    CFDataRef v50 = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (!v50)
    {
      CGLog(3, (uint64_t)"md5_creator failed for %p object", v51, v52, v53, v54, v55, v56, (char)propertyList);
      return;
    }
    CFURLRef v19 = v50;
    CFIndex v57 = CFDataGetLength(v50);
    long long v58 = (char *)CFDataGetBytePtr(v19);
    if (a1) {
      md5_update(a1, v58, v57);
    }
    goto LABEL_53;
  }
  if (object_md5_creator_cglibrarypredicate_3 != -1) {
    dispatch_once(&object_md5_creator_cglibrarypredicate_3, &__block_literal_global_6);
  }
  *(void *)&data[0] = object_md5_creator_f_2(propertyList);
  *((void *)&data[0] + 1) = v8;
  if (a1)
  {
LABEL_16:
    uint64_t v9 = a1;
    CC_LONG v10 = 16;
    goto LABEL_17;
  }
}

void md5_creator(const __CFString *propertyList, const __CFString *a2, uint64_t a3)
{
  if (!*(unsigned char *)(a3 + 8)) {
    object_md5_creator(*(CC_MD5_CTX **)a3, propertyList);
  }
  uint64_t v5 = *(CC_MD5_CTX **)a3;

  object_md5_creator(v5, a2);
}

CC_MD5_CTX *md5_update(CC_MD5_CTX *c, char *data, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v5 = c;
  if (HIDWORD(a3))
  {
    do
    {
      CC_MD5_Update(v5, data, 0xFFFFFFFF);
      data += 0xFFFFFFFFLL;
      v3 -= 0xFFFFFFFFLL;
    }
    while (HIDWORD(v3));
  }
  else if (!a3)
  {
    return c;
  }

  return (CC_MD5_CTX *)CC_MD5_Update(v5, data, v3);
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  if (CGColorSpaceCreateDeviceGray_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDeviceGray_predicate, &__block_literal_global_6434);
  }
  uint64_t v0 = (CGColorSpace *)CGColorSpaceCreateDeviceGray_space;
  if (CGColorSpaceCreateDeviceGray_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDeviceGray_space);
  }
  return v0;
}

void *CGImageProviderGetColorSpace(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[15];
    if (!v2) {
      return (void *)v1[5];
    }
    __n128 result = CGPropertiesGetProperty(v2, @"kCGImageProviderColorSpaceChangedOnImageCopy");
    if (!result) {
      return (void *)v1[5];
    }
  }
  return result;
}

BOOL CGColorTransformConvertRequired(BOOL result, void *a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = (void *)result;
    CFTypeID v6 = CFGetTypeID((CFTypeRef)result);
    if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
      dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
    }
    if (v6 == CGColorTransformGetTypeID_type_id)
    {
      if (CGColorSpaceGetType(a2) - 7 >= 3)
      {
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 0x40000000;
        v10[2] = __create_resolved_source_space_block_invoke;
        v10[3] = &__block_descriptor_tmp_36_17179;
        v10[4] = v5;
        ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(a2, (uint64_t)v10);
        Cache = CGColorTransformGetCache(v5);
        Conversionint Type = CGColorTransformCacheGetConversionType((uint64_t)Cache, ResolvedColorSpace, a3);
        CGColorSpaceRelease(ResolvedColorSpace);
        return ConversionType != 3;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t icc_get_md5(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *(void *)mdouble d = 0;
  uint64_t v20 = 0;
  uint64_t v9 = a1 + 3;
  int v8 = *((_DWORD *)a1 + 6);
  if (v8 != 6) {
    _CGHandleAssert("icc_get_md5", 43, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "state->type == kCGColorSpaceICCBased", "Colorspace not ICC based. type = %d", a6, a7, a8, v8);
  }
  uint64_t v11 = a1[12];
  CFURLRef v12 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v12);
  if (v12)
  {
    CC_MD5_Update(v12, v9, 4u);
    CC_MD5_Update(v12, (const void *)(v11 + 24), 0x10u);
    CC_MD5_Update(v12, (char *)a1 + 18, 1u);
    CC_MD5_Update(v12, (char *)a1 + 19, 1u);
  }
  uint64_t v13 = 2 * a1[6];
  if (v13)
  {
    for (uint64_t i = 0; i != v13; ++i)
    {
      float v15 = *(double *)(*(void *)(v11 + 64) + 8 * i);
      datdouble a = v15;
      if (v12) {
        CC_MD5_Update(v12, &data, 4u);
      }
    }
  }
  if (v12)
  {
    CC_MD5_Final(md, v12);
    uint64_t v16 = *(void *)md;
  }
  else
  {
    uint64_t v16 = 0;
  }
  free(v12);
  return v16;
}

uint64_t icc_get_default_color_components(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unint64_t)(a1 - 16) <= 0xFFFFFFFFFFFFFFF0) {
    _CGHandleAssert("icc_get_default_color_components", 127, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "component_count > 0 && component_count <= kCGColorSpaceICCMaxComponents", "Colorspace component count unhandled. count = %zu", a6, a7, a8, a1);
  }
  return (uint64_t)*(&icc_get_default_color_components_components + a1 - 1);
}

uint64_t CGConditionalVarInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGConditionalVarInit", 21, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Utilities/CGConditionalVar.c", "cvar != NULL", "Conditional variable is NULL", a6, a7, a8, v10);
  }
  *(unsigned char *)(a1 + 112) = 0;
  uint64_t result = pthread_mutex_init((pthread_mutex_t *)a1, 0);
  if (!result)
  {
    return pthread_cond_init((pthread_cond_t *)(a1 + 64), 0);
  }
  return result;
}

uint64_t CGColorConversionInfoCreateFromListInternal(const void *a1, int a2, void *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return create_from_argument_list(a1, a2, a3, 0, a5, (uint64_t)&a9);
}

uint64_t CGCMSConverterConvertGetConverterInfo(uint64_t result, uint64_t (**cf)(CFTypeRef, uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  *(void *)(result + 80) = 0;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  if (cf)
  {
    uint64_t result = CFGetTypeID(cf);
    uint64_t v7 = result;
    uint64_t v8 = kCGCMSConverterID;
    if (!kCGCMSConverterID)
    {
      uint64_t result = pthread_once(&CGCMSConverterGetTypeID_once, converter_initialize);
      uint64_t v8 = kCGCMSConverterID;
    }
    if (v7 == v8)
    {
      uint64_t v9 = cf[8];
      return v9(cf, a3, a4);
    }
  }
  return result;
}

CGColorSpaceRef CGColorSpaceCreateDeviceCMYK(void)
{
  if (CGColorSpaceCreateDeviceCMYK_predicate != -1) {
    dispatch_once(&CGColorSpaceCreateDeviceCMYK_predicate, &__block_literal_global_148);
  }
  uint64_t v0 = (CGColorSpace *)CGColorSpaceCreateDeviceCMYK_space;
  if (CGColorSpaceCreateDeviceCMYK_space) {
    CFRetain((CFTypeRef)CGColorSpaceCreateDeviceCMYK_space);
  }
  return v0;
}

uint64_t CGImageProviderGetBitmapInfo(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 36);
  }
  return result;
}

void CGContextSetFillColorSpace(CGContextRef c, CGColorSpaceRef space)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      set_fill_color_with_components((uint64_t *)c, space, 0, v3, v4, v5, v6, v7, v9);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetFillColorSpace", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

void CGContextSetStrokeColorSpace(CGContextRef c, CGColorSpaceRef space)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      set_stroke_color_with_components((uint64_t *)c, space, 0, v3, v4, v5, v6, v7, v9);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }
  handle_invalid_context((char)"CGContextSetStrokeColorSpace", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

int CGFontGetCapHeight(CGFontRef font)
{
  font_float64x2_t info = get_font_info(font);
  if (font_info) {
    LODWORD(font_info) = font_info[6];
  }
  return (int)font_info;
}

uint64_t strike_key_equal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v8 = 0;
  if (a1 && a2)
  {
    if (*(double *)(a1 + 8) != *(double *)(a2 + 8)
      || *(double *)(a1 + 16) != *(double *)(a2 + 16)
      || *(double *)(a1 + 24) != *(double *)(a2 + 24)
      || *(double *)(a1 + 32) != *(double *)(a2 + 32)
      || *(_DWORD *)a1 != *(_DWORD *)a2
      || *(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
    {
      return 0;
    }
    uint64_t v8 = 0;
    if (*(double *)(a1 + 56) == *(double *)(a2 + 56) && *(double *)(a1 + 64) == *(double *)(a2 + 64))
    {
      uint64_t v9 = *(void *)(a1 + 72);
      if (v9 != *(void *)(a2 + 72)) {
        _CGHandleAssert("CGFontStrikeKeyEqual", 72, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Fonts/CGFontStrike.c", "key1->hash == key2->hash", "hash 0x%zx 0x%zx", a6, a7, a8, v9);
      }
      return 1;
    }
  }
  return v8;
}

uint64_t data_provider_retain_count(uint64_t a1, atomic_uint *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case -1:
      if (atomic_fetch_add_explicit(a2 + 63, 0xFFFFFFFF, memory_order_relaxed) == 1)
      {
        data_provider_finalize((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
        CFAllocatorRef v10 = CFGetAllocator(a2);
        CFAllocatorDeallocate(v10, a2);
      }
      break;
    case 0:
      return a2[63];
    case 1:
      return atomic_fetch_add_explicit(a2 + 63, 1u, memory_order_relaxed) + 1;
  }
  return 0;
}

double data_provider_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 264);
  if (v8) {
    _CGHandleAssert("data_provider_finalize", 390, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider->byte_pointer == NULL", "byte pointer = %p", a6, a7, a8, v8);
  }
  if (*(_DWORD *)(a1 + 248)) {
    _CGHandleAssert("data_provider_finalize", 392, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "CGAtomicGet(&provider->byte_ptr_retain_count) == 0", "retain count %d", a6, a7, a8, *(_DWORD *)(a1 + 248));
  }
  if (*(_DWORD *)(a1 + 256)) {
    _CGHandleAssert("data_provider_finalize", 394, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "CGAtomicGet(&provider->data_retain_count) == 0", "data retain count %d", a6, a7, a8, *(_DWORD *)(a1 + 256));
  }
  CFAllocatorRef v10 = *(void (**)(void))(a1 + 72);
  if (v10) {
    v10(*(void *)(a1 + 24));
  }
  uint64_t v11 = *(CFTypeRef **)(a1 + 272);
  if (v11) {
    CGPropertiesRelease(v11);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 184));
  CFURLRef v12 = *(const void **)(a1 + 280);
  if (v12) {
    CFRelease(v12);
  }
  double result = 0.0;
  *(_OWORD *)(a1 + 20) = 0u;
  uint64_t v14 = (_OWORD *)(a1 + 20);
  *(_OWORD *)((char *)v14 + 252) = 0u;
  v14[14] = 0u;
  v14[15] = 0u;
  v14[12] = 0u;
  v14[13] = 0u;
  v14[10] = 0u;
  v14[11] = 0u;
  v14[8] = 0u;
  v14[9] = 0u;
  v14[6] = 0u;
  v14[7] = 0u;
  v14[4] = 0u;
  v14[5] = 0u;
  v14[2] = 0u;
  v14[3] = 0u;
  v14[1] = 0u;
  *((_DWORD *)v14 - 1) = 57005;
  return result;
}

void provider_for_destination_release_info(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 724)) {
    CGDataProviderUnlock(*(void *)a1);
  }
  CGDataProviderRelease(*(CGDataProviderRef *)a1);
  uint64_t v2 = *(const void **)(a1 + 688);
  if (v2) {
    CFRelease(v2);
  }
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 24));
  uint64_t v3 = *(vImageConverter **)(a1 + 712);
  if (v3) {
    vImageConverter_Release(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 696);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(char **)(a1 + 704);
  if (v5) {
    CGvImageConverterCacheRelease(v5);
  }
  uint64_t v6 = *(void **)(a1 + 728);
  if (v6) {
    free(v6);
  }
  uint64_t v7 = *(void **)(a1 + 744);
  if (v7) {
    free(v7);
  }
  uint64_t v8 = *(void **)(a1 + 760);
  if (v8) {
    free(v8);
  }
  uint64_t v9 = *(vImageConverter **)(a1 + 776);
  if (v9) {
    vImageConverter_Release(v9);
  }
  CFAllocatorRef v10 = *(vImageConverter **)(a1 + 784);
  if (v10) {
    vImageConverter_Release(v10);
  }
  uint64_t v11 = *(void **)(a1 + 792);
  if (v11) {
    free(v11);
  }
  CFURLRef v12 = *(void **)(a1 + 800);
  if (v12) {
    free(v12);
  }
  uint64_t v13 = *(void **)(a1 + 808);
  if (v13) {
    free(v13);
  }
  uint64_t v14 = *(void **)(a1 + 816);
  if (v14) {
    free(v14);
  }

  free((void *)a1);
}

void imageProvider_releaseInfo(CFTypeRef *a1)
{
  uint64_t v2 = (uint64_t)a1[1];
  if (v2)
  {
    CGImageBlockSetRelease(v2);
    a1[1] = 0;
  }
  if (*a1) {
    CFRelease(*a1);
  }

  free(a1);
}

void data_release_info(void *a1)
{
  uint64_t v2 = (void (*)(void, void, void))a1[3];
  if (v2) {
    v2(*a1, a1[2], a1[1]);
  }

  free(a1);
}

BOOL CGContextIsEmptyClipBoundingBox(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextIsEmptyClipBoundingBox", a1, a3, a4, a5, a6, a7, a8);
    return 1;
  }
  if (get_device_clip_bounding_box(a1) == INFINITY || v8 == INFINITY) {
    return 1;
  }
  return v10 == 0.0 || v9 == 0.0;
}

CGRect CGContextGetClipBoundingBox(CGContextRef c)
{
  if (!c)
  {
    CGContextRef v18 = 0;
LABEL_6:
    handle_invalid_context((char)"CGContextGetClipBoundingBox", (uint64_t)v18, v1, v2, v3, v4, v5, v6);
    v16.n64_f64[0] = 0.0;
    v14.n64_f64[0] = INFINITY;
    v15.n64_f64[0] = INFINITY;
    v17.n64_f64[0] = 0.0;
    goto LABEL_7;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v18 = c;
    goto LABEL_6;
  }
  v8.n64_f64[0] = get_device_clip_bounding_box((uint64_t)c);
  uint64_t v9 = *((void *)c + 12);
  long long v10 = *(_OWORD *)(v9 + 40);
  v19[0] = *(_OWORD *)(v9 + 24);
  v19[1] = v10;
  v19[2] = *(_OWORD *)(v9 + 56);
  v14.n64_u64[0] = CGRectApplyInverseAffineTransform((double *)v19, v8, v11, v12, v13).n64_u64[0];
LABEL_7:
  result.size.double height = v17.n64_f64[0];
  result.size.double width = v16.n64_f64[0];
  result.origin.double y = v15.n64_f64[0];
  result.origin.double x = v14.n64_f64[0];
  return result;
}

double get_device_clip_bounding_box(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 96);
  if (v2)
  {
    uint64_t v4 = *(double (**)(void))(v2 + 48);
    if (v4)
    {
      double v5 = v4();
      unint64_t v7 = v6;
      uint64_t v9 = v8;
      uint64_t v11 = v10;
      uint64_t v3 = *(void *)(a1 + 96);
    }
    else
    {
      uint64_t v9 = 0x7FEFFFFFFFFFFFFFLL;
      double v5 = -8.98846567e307;
      unint64_t v7 = 0xFFDFFFFFFFFFFFFFLL;
      uint64_t v11 = 0x7FEFFFFFFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v9 = 0;
    double v5 = INFINITY;
    unint64_t v7 = 0x7FF0000000000000;
    uint64_t v11 = 0;
  }
  double v12 = *(double **)(v3 + 112);
  if (v12)
  {
    double Bounds = CGClipStackGetBounds(v12);
    unint64_t v15 = v14;
    uint64_t v17 = v16;
    uint64_t v19 = v18;
  }
  else
  {
    unint64_t v15 = 0xFFDFFFFFFFFFFFFFLL;
    uint64_t v17 = 0x7FEFFFFFFFFFFFFFLL;
    double Bounds = -8.98846567e307;
    uint64_t v19 = 0x7FEFFFFFFFFFFFFFLL;
  }
  double v20 = v5;
  unint64_t v21 = v7;
  uint64_t v22 = v9;
  uint64_t v23 = v11;

  *(void *)&double result = (unint64_t)CGRectIntersection(*(CGRect *)&v20, *(CGRect *)&Bounds);
  return result;
}

uint64_t get_glyph_bboxes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t result = 0;
  if (a1 && a6)
  {
    uint64_t v9 = a5;
    uint64_t v10 = a4;
    if (a4 || !a5)
    {
      if (a5)
      {
        if (a3)
        {
          if (a2) {
            FPFontGetUnitsPerEm();
          }
          uint64_t v16 = a6 + 16;
          do
          {
            v10 += 2;
            FPFontGetGlyphIdealBounds();
            CGRect v18 = CGRectApplyAffineTransform(v17, (CGAffineTransform *)&CGAffineTransformIdentity);
            *(CGRect *)(v16 - 16) = CGRectIntegral(v18);
            v16 += 32;
            --v9;
          }
          while (v9);
        }
        else
        {
          uint64_t v11 = (void *)(a6 + 16);
          do
          {
            v10 += 2;
            FPFontGetGlyphDeviceBounds();
            *(v11 - 2) = v12;
            *(v11 - 1) = v13;
            *uint64_t v11 = v14;
            v11[1] = v15;
            v11 += 4;
            --v9;
          }
          while (v9);
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGRect CGFontGetFontBBox(CGFontRef font)
{
  if (font)
  {
    v1.origin.double x = (*(double (**)(void))(*((void *)font + 2) + 112))(*((void *)font + 14));
    return CGRectIntegral(v1);
  }
  else
  {
    result.size.double width = 0.0;
    result.origin.double x = INFINITY;
    result.origin.double y = INFINITY;
    result.size.double height = 0.0;
  }
  return result;
}

double CG::DisplayListResourceClip::setClipStack(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3 != (void *)a2)
  {
    CGClipStackRelease(v3);
    MutableCopdouble y = (double *)CGClipStackCreateMutableCopy(a2);
    *(void *)(a1 + 16) = MutableCopy;
    if (MutableCopy)
    {
      if ((_BYTE)MutableCopy[1]) {
        *(_DWORD *)(a1 + 8) |= 0x1000u;
      }
      double result = CGClipStackGetBounds(MutableCopy);
      *(double *)(a1 + 24) = result;
      *(void *)(a1 + 32) = v7;
      *(void *)(a1 + 40) = v8;
      *(void *)(a1 + 48) = v9;
    }
    else
    {
      *(_DWORD *)(a1 + 8) &= ~0x1000u;
      double result = CGRectInfinite.origin.x;
      *(CGRect *)(a1 + 24) = CGRectInfinite;
    }
  }
  return result;
}

void CGGStateClipToRect(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  maybeCopyClipState(a1);
  uint64_t v10 = (CGAffineTransform *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(*(void *)(a1 + 120) + 4);
  if (*(double *)(a1 + 32) == 0.0 && *(double *)(a1 + 40) == 0.0
    || *(double *)(a1 + 24) == 0.0 && *(double *)(a1 + 48) == 0.0)
  {
    int v12 = HIBYTE(v11) & 1;
    long long v13 = *(_OWORD *)(a1 + 40);
    *(_OWORD *)&v22.double a = *(_OWORD *)&v10->a;
    *(_OWORD *)&v22.double c = v13;
    *(_OWORD *)&v22.double tx = *(_OWORD *)(a1 + 56);
    CGFloat v14 = a2;
    *(CGFloat *)&long long v13 = a3;
    CGFloat v15 = a4;
    CGFloat v16 = a5;
    CGRect v24 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v13 - 8), &v22);
    CGFloat x = v24.origin.x;
    CGFloat y = v24.origin.y;
    CGFloat width = v24.size.width;
    CGFloat height = v24.size.height;
    CGClipStackAddRect(*(void *)(a1 + 112), v12, v24.origin.x, v24.origin.y, v24.size.width, v24.size.height);
    v25.origin.CGFloat x = x;
    v25.origin.CGFloat y = y;
    v25.size.CGFloat width = width;
    v25.size.CGFloat height = height;
    CGRect v26 = CGRectIntegral(v25);
    *(CGRect *)(a1 + 80) = CGRectIntersection(*(CGRect *)(a1 + 80), v26);
  }
  else
  {
    unint64_t v21 = (char *)CGClipCreateWithRect(v10, HIBYTE(v11) & 1, a2, a3, a4, a5);
    CGClipStackAddClip(*(void *)(a1 + 112), (uint64_t)v21);
    CGClipRelease(v21);
  }
}

CGRect CGRectIntegral(CGRect rect)
{
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    if (rect.size.width < 0.0 || rect.size.height < 0.0) {
      rect = CGRectStandardize(rect);
    }
    double v2 = rect.origin.x + rect.size.width;
    rect.origin.CGFloat x = floor(rect.origin.x);
    double v3 = rect.origin.y + rect.size.height;
    rect.origin.CGFloat y = floor(rect.origin.y);
    rect.size.CGFloat width = ceil(v2) - rect.origin.x;
    rect.size.CGFloat height = ceil(v3) - rect.origin.y;
  }
  return rect;
}

void maybeCopyClipState(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 20))
  {
    double v2 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = CGClipStackCreateMutableCopy((uint64_t)v2);
    CGClipStackRelease(v2);
    *(unsigned char *)(a1 + 20) &= ~1u;
  }
}

void *CGClipStackCreateMutableCopy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  double v2 = malloc_type_malloc(0x98uLL, 0x2062DE7BuLL);
  double v3 = v2;
  *(_DWORD *)double v2 = 1;
  *(void *)((char *)v2 + 4) = *(void *)(a1 + 4);
  long long v4 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 6) = v4;
  long long v5 = *(_OWORD *)(a1 + 64);
  *((_OWORD *)v2 + 3) = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v2 + 4) = v5;
  long long v6 = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v2 + 2) = v6;
  v2[14] = 3;
  v2[15] = 0;
  uint64_t v7 = v2 + 15;
  v2[16] = 0;
  unint64_t v8 = *(void *)(a1 + 120);
  if (!v8) {
    return v3;
  }
  if (*(void *)(a1 + 112) == 3)
  {
    *uint64_t v7 = v8;
    uint64_t v9 = 16;
    do
    {
      uint64_t v10 = *(atomic_uint **)(a1 + 8 * v9);
      if (v10) {
        atomic_fetch_add_explicit(v10, 1u, memory_order_relaxed);
      }
      v2[v9] = v10;
      unint64_t v11 = v9 - 15;
      ++v9;
    }
    while (v11 < v2[15]);
    return v3;
  }
  unint64_t v12 = v8 + 3;
  long long v13 = malloc_type_malloc(8 * (v8 + 3), 0x705560E0uLL);
  if (!v13)
  {
    CGClipStackRelease(v3);
    return 0;
  }
  v3[16] = v13;
  unint64_t v14 = *(void *)(a1 + 120);
  v3[14] = v12;
  v3[15] = v14;
  if (v14)
  {
    for (unint64_t i = 0; i < v14; ++i)
    {
      CGFloat v16 = *(atomic_uint **)(*(void *)(a1 + 128) + 8 * i);
      if (v16)
      {
        atomic_fetch_add_explicit(v16, 1u, memory_order_relaxed);
        unint64_t v14 = *v7;
      }
      *(void *)(v3[16] + 8 * i) = v16;
    }
  }
  return v3;
}

void CGClipStackAddRect(uint64_t a1, int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  if (a1)
  {
    unint64_t v12 = (_OWORD *)(a1 + 16);
    if (!CGRectContainsRect(*(CGRect *)&a3, *(CGRect *)(a1 + 16)))
    {
      if (a2)
      {
        v30.origin.CGFloat x = a3;
        v30.origin.CGFloat y = a4;
        v30.size.CGFloat width = a5;
        v30.size.CGFloat height = a6;
        CGRect v25 = CGRectIntersection(*(CGRect *)(a1 + 80), v30);
        *(CGRect *)(a1 + 80) = v25;
        int v13 = *(_DWORD *)(a1 + 8);
        if ((v13 & 2) != 0)
        {
          CGFloat x = v25.origin.x;
          CGFloat y = v25.origin.y;
          CGFloat width = v25.size.width;
          CGFloat height = v25.size.height;
          CGRect v32 = CGRectIntegral(*(CGRect *)(a1 + 48));
          v29.origin.CGFloat x = x;
          v29.origin.CGFloat y = y;
          v29.size.CGFloat width = width;
          v29.size.CGFloat height = height;
          *(CGRect *)(a1 + 16) = CGRectIntersection(v29, v32);
        }
        else
        {
          long long v14 = *(_OWORD *)(a1 + 96);
          *unint64_t v12 = *(_OWORD *)(a1 + 80);
          v12[1] = v14;
        }
        int v20 = v13 | 4;
      }
      else
      {
        v31.origin.CGFloat x = a3;
        v31.origin.CGFloat y = a4;
        v31.size.CGFloat width = a5;
        v31.size.CGFloat height = a6;
        CGRect v26 = CGRectIntersection(*(CGRect *)(a1 + 48), v31);
        *(CGRect *)(a1 + 48) = v26;
        CGRect v27 = CGRectIntegral(v26);
        CGFloat v15 = v27.origin.x;
        CGFloat v16 = v27.origin.y;
        CGFloat v17 = v27.size.width;
        CGFloat v18 = v27.size.height;
        int v19 = *(_DWORD *)(a1 + 8);
        if ((v19 & 4) != 0)
        {
          CGRect v28 = CGRectIntersection(*(CGRect *)(a1 + 80), *(CGRect *)&v15);
          CGFloat v15 = v28.origin.x;
          CGFloat v16 = v28.origin.y;
          CGFloat v17 = v28.size.width;
          CGFloat v18 = v28.size.height;
        }
        *(CGFloat *)(a1 + 16) = v15;
        *(CGFloat *)(a1 + 24) = v16;
        *(CGFloat *)(a1 + 32) = v17;
        *(CGFloat *)(a1 + 40) = v18;
        int v20 = v19 | 2;
      }
      *(_DWORD *)(a1 + 8) = v20;
      *(_DWORD *)(a1 + 4) = atomic_fetch_add_explicit(&identifier_22701, 1u, memory_order_relaxed) + 1;
    }
  }
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  double x = rect1.origin.x;
  if (rect2.origin.x == INFINITY || rect2.origin.y == INFINITY) {
    return 1;
  }
  double y = rect1.origin.y;
  if (rect1.origin.x == INFINITY || rect1.origin.y == INFINITY) {
    return 0;
  }
  double height = rect2.size.height;
  double width = rect2.size.width;
  double v9 = rect2.origin.y;
  double v10 = rect2.origin.x;
  double v11 = rect1.size.height;
  double v12 = rect1.size.width;
  if (rect1.size.width < 0.0 || rect1.size.height < 0.0)
  {
    CGRect v13 = CGRectStandardize(rect1);
    double x = v13.origin.x;
    double y = v13.origin.y;
    double v12 = v13.size.width;
    double v11 = v13.size.height;
  }
  if (width < 0.0 || height < 0.0)
  {
    v14.origin.double x = v10;
    v14.origin.double y = v9;
    v14.size.double width = width;
    v14.size.double height = height;
    CGRect v15 = CGRectStandardize(v14);
    double v10 = v15.origin.x;
    double v9 = v15.origin.y;
    double width = v15.size.width;
    double height = v15.size.height;
  }
  if (x > v10) {
    return 0;
  }
  BOOL result = 0;
  if (x + v12 >= v10 + width && y <= v9) {
    return y + v11 >= v9 + height;
  }
  return result;
}

uint64_t get_font_bbox(uint64_t a1)
{
  return MEMORY[0x1F4119C68](*(void *)(a1 + 8));
}

void CGDisplayListDrawInContextDelegate(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, const __CFDictionary *a5)
{
  if (a1 && *(void *)(a1 + 592) != *(void *)(a1 + 600))
  {
    double y = *(double *)(a1 + 96);
    double x = *(double *)(a1 + 88);
    if (x != INFINITY && y != INFINITY)
    {
      if (a4)
      {
        if (a2)
        {
          CGRect v13 = *(double (**)(uint64_t, _DWORD *, uint64_t))(a2 + 48);
          if (v13)
          {
            CGFloat v14 = v13(a2, a3, a4);
            CGFloat v16 = v15;
            CGFloat v18 = v17;
            CGFloat v20 = v19;
          }
          else
          {
            CGFloat v18 = 1.79769313e308;
            CGFloat v14 = -8.98846567e307;
            CGFloat v16 = -8.98846567e307;
            CGFloat v20 = 1.79769313e308;
          }
        }
        else
        {
          CGFloat v18 = 0.0;
          CGFloat v14 = INFINITY;
          CGFloat v16 = INFINITY;
          CGFloat v20 = 0.0;
        }
        CGRect v30 = *(double **)(a4 + 112);
        if (v30)
        {
          double Bounds = CGClipStackGetBounds(v30);
          unint64_t v33 = v32;
          uint64_t v35 = v34;
          uint64_t v37 = v36;
        }
        else
        {
          unint64_t v33 = 0xFFDFFFFFFFFFFFFFLL;
          uint64_t v35 = 0x7FEFFFFFFFFFFFFFLL;
          double Bounds = -8.98846567e307;
          uint64_t v37 = 0x7FEFFFFFFFFFFFFFLL;
        }
        v49.origin.double x = v14;
        v49.origin.double y = v16;
        v49.size.double width = v18;
        v49.size.double height = v20;
        CGRect v50 = CGRectIntersection(v49, *(CGRect *)&Bounds);
        if (v50.origin.x == INFINITY || v50.origin.y == INFINITY || v50.size.width == 0.0 || v50.size.height == 0.0) {
          return;
        }
        long long v38 = *(_OWORD *)(a4 + 40);
        v47[0] = *(_OWORD *)(a4 + 24);
        v47[1] = v38;
        v47[2] = *(_OWORD *)(a4 + 56);
        v39.n64_u64[0] = CGRectApplyInverseAffineTransform((double *)v47, *(__n64 *)&v50.origin.x, v50.origin.y, v50.size.width, v50.size.height).n64_u64[0];
        CFTypeID v43 = &CGRectNull;
        p_double y = &CGRectNull.origin.y;
        p_std::string::size_type size = (CGSize *)(a1 + 104);
        p_double height = (CGFloat *)(a1 + 112);
        if (*(void *)(a1 + 592) == *(void *)(a1 + 600)) {
          p_std::string::size_type size = &CGRectNull.size;
        }
        else {
          p_double y = (CGFloat *)(a1 + 96);
        }
        if (*(void *)(a1 + 592) == *(void *)(a1 + 600)) {
          p_double height = &CGRectNull.size.height;
        }
        else {
          CFTypeID v43 = (const CGRect *)(a1 + 88);
        }
        v52.size.double height = *p_height;
        v52.origin.double x = v43->origin.x;
        v52.origin.double y = *p_y;
        v52.size.double width = p_size->width;
        CGRect v51 = CGRectIntersection(*(CGRect *)v39.n64_u64, v52);
        double x = v51.origin.x;
        CGRect v48 = v51;
        if (v51.origin.x == INFINITY) {
          return;
        }
        double y = v51.origin.y;
        if (v51.origin.y == INFINITY) {
          return;
        }
        double width = v51.size.width;
        if (v51.size.width == 0.0) {
          return;
        }
        double height = v51.size.height;
        if (v51.size.height == 0.0) {
          return;
        }
      }
      else
      {
        double width = *(double *)(a1 + 104);
        double height = *(double *)(a1 + 112);
        v48.origin.double x = *(CGFloat *)(a1 + 88);
        v48.origin.double y = y;
        v48.size.double width = width;
        v48.size.double height = height;
      }
      uint64_t v23 = a3;
      if (a3 || (uint64_t v23 = CGRenderingStateCreate()) != 0)
      {
        uint64_t v24 = a1 + 16;
        CGRect v25 = CGGStackCreateWithGState(a4);
        if (height == 1.79769313e308 && width == 1.79769313e308 && y == -8.98846567e307 && x == -8.98846567e307) {
          CGRect v29 = 0;
        }
        else {
          CGRect v29 = &v48;
        }
        CG::DisplayList::execute(v24, a2, (uint64_t)v23, (uint64_t)v25, v29, a5);
        if (v25)
        {
          CGGStackReset(v25);
          free(v25);
        }
        if (v23 != a3 && atomic_fetch_add_explicit(v23, 0xFFFFFFFF, memory_order_relaxed) == 1) {
          free(v23);
        }
      }
    }
  }
}

void CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(double *a1, uint64_t a2, double *a3, uint64_t a4)
{
  if (!a3)
  {
    CGFloat v8 = -8.98846567e307;
    CGFloat v9 = 1.79769313e308;
    double Bounds = -8.98846567e307;
    CGFloat v10 = 1.79769313e308;
    if (a4) {
      goto LABEL_3;
    }
LABEL_5:
    double v24 = *a1;
    uint64_t v26 = *((void *)a1 + 1);
    uint64_t v28 = *((void *)a1 + 2);
    uint64_t v30 = *((void *)a1 + 3);
    goto LABEL_6;
  }
  double Bounds = CGClipStackGetBounds(a3);
  if (!a4) {
    goto LABEL_5;
  }
LABEL_3:
  long long v11 = *(_OWORD *)(a2 + 40);
  v32[0] = *(_OWORD *)(a2 + 24);
  v32[1] = v11;
  v32[2] = *(_OWORD *)(a2 + 56);
  DrawBoundingBoxWithMatridouble x = CGStyleGetDrawBoundingBoxWithMatrix(a4, v32, Bounds, v8, v9, v10);
  double v14 = v13;
  double v16 = v15;
  double v18 = v17;
  double v19 = *a1;
  CGFloat v20 = a1[1];
  CGFloat v21 = a1[2];
  CGFloat v22 = a1[3];
  long long v23 = *(_OWORD *)(a2 + 40);
  v31[0] = *(_OWORD *)(a2 + 24);
  v31[1] = v23;
  v31[2] = *(_OWORD *)(a2 + 56);
  double v24 = CGStyleGetDrawBoundingBoxWithMatrix(a4, v31, v19, v20, v21, v22);
  uint64_t v26 = v25;
  uint64_t v28 = v27;
  uint64_t v30 = v29;
  double Bounds = DrawBoundingBoxWithMatrix;
  CGFloat v8 = v14;
  CGFloat v9 = v16;
  CGFloat v10 = v18;
LABEL_6:
  CGRectIntersection(*(CGRect *)&Bounds, *(CGRect *)&v24);
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double y = r1.origin.y;
  double x = r1.origin.x;
  double v4 = 0.0;
  double v5 = INFINITY;
  if (x != INFINITY && r1.origin.y != INFINITY)
  {
    double v7 = r2.origin.y;
    double v8 = r2.origin.x;
    double v5 = INFINITY;
    if (r2.origin.x != INFINITY && r2.origin.y != INFINITY)
    {
      double width = r2.size.width;
      double height = r1.size.height;
      double v12 = r1.size.width;
      if (r1.size.width < 0.0 || r1.size.height < 0.0)
      {
        double v13 = x;
        CGFloat v14 = r2.size.height;
        CGRect v20 = CGRectStandardize(r1);
        r2.size.double height = v14;
        double x = v20.origin.x;
        double y = v20.origin.y;
        double v12 = v20.size.width;
        double height = v20.size.height;
      }
      if (width < 0.0 || r2.size.height < 0.0)
      {
        v21.origin.double x = v8;
        v21.origin.double y = v7;
        v21.size.double width = width;
        v21.size.double height = r2.size.height;
        CGRect v22 = CGRectStandardize(v21);
        double v8 = v22.origin.x;
        double v7 = v22.origin.y;
        double width = v22.size.width;
        r2.size.double height = v22.size.height;
      }
      double v5 = fmax(x, v8);
      double v15 = fmin(x + v12, v8 + width);
      if (v5 <= v15)
      {
        double v16 = fmax(y, v7);
        double v17 = fmin(y + height, v7 + r2.size.height);
        if (v16 <= v17)
        {
          double v4 = v15 - v5;
          double v18 = v17 - v16;
          goto LABEL_19;
        }
      }
      double v5 = INFINITY;
    }
  }
  double v16 = INFINITY;
  double v18 = 0.0;
LABEL_19:
  double v19 = v4;
  result.size.double height = v18;
  result.size.double width = v19;
  result.origin.double y = v16;
  result.origin.double x = v5;
  return result;
}

double CGClipStackGetBounds(double *a1)
{
  if (!a1) {
    return -8.98846567e307;
  }
  double x = a1[2];
  CGFloat y = a1[3];
  CGFloat width = a1[4];
  CGFloat height = a1[5];
  uint64_t v6 = *((void *)a1 + 15);
  if (*((void *)a1 + 14) == 3)
  {
    if (v6)
    {
      unint64_t v7 = 0;
      do
      {
        v20.origin.double x = CGClipGetBounds(*(void *)&a1[v7 + 16]);
        v20.origin.CGFloat y = v8;
        v20.size.CGFloat width = v9;
        v20.size.CGFloat height = v10;
        v16.origin.double x = x;
        v16.origin.CGFloat y = y;
        v16.size.CGFloat width = width;
        v16.size.CGFloat height = height;
        CGRect v17 = CGRectIntersection(v16, v20);
        double x = v17.origin.x;
        CGFloat y = v17.origin.y;
        CGFloat width = v17.size.width;
        CGFloat height = v17.size.height;
        ++v7;
      }
      while (v7 < *((void *)a1 + 15));
    }
  }
  else if (v6)
  {
    unint64_t v11 = 0;
    do
    {
      v21.origin.double x = CGClipGetBounds(*(void *)(*((void *)a1 + 16) + 8 * v11));
      v21.origin.CGFloat y = v12;
      v21.size.CGFloat width = v13;
      v21.size.CGFloat height = v14;
      v18.origin.double x = x;
      v18.origin.CGFloat y = y;
      v18.size.CGFloat width = width;
      v18.size.CGFloat height = height;
      CGRect v19 = CGRectIntersection(v18, v21);
      double x = v19.origin.x;
      CGFloat y = v19.origin.y;
      CGFloat width = v19.size.width;
      CGFloat height = v19.size.height;
      ++v11;
    }
    while (v11 < *((void *)a1 + 15));
  }
  return x;
}

__n64 CGRectApplyInverseAffineTransform(double *a1, __n64 result, double a3, double a4, double a5)
{
  if (result.n64_f64[0] != INFINITY && a3 != INFINITY)
  {
    if (result.n64_f64[0] == -8.98846567e307 && a3 == -8.98846567e307 && a4 == 1.79769313e308 && a5 == 1.79769313e308)
    {
      result.n64_f64[0] = -8.98846567e307;
    }
    else
    {
      _OWORD v53[3] = v5;
      v53[4] = v6;
      if (a4 < 0.0 || a5 < 0.0) {
        *(CGRect *)result.n64_u64 = CGRectStandardize(*(CGRect *)result.n64_u64);
      }
      double v12 = *a1;
      double v13 = a1[1];
      double v14 = a1[2];
      double v15 = a1[3];
      double v16 = *a1 * v15 - v13 * v14;
      if (v16 != 0.0)
      {
        double v17 = 1.0 / v16;
        double v18 = v15 * (1.0 / v16);
        double v19 = v17 * -v13;
        double v20 = -(v14 * v17);
        double v21 = v12 * v17;
        double v23 = a1[4];
        double v22 = a1[5];
        double v24 = v17 * (v14 * v22 - v15 * v23);
        double v25 = v17 * (v13 * v23 - v12 * v22);
        double v26 = result.n64_f64[0] + a4;
        double v27 = a3 + a5;
        double v28 = a3 * v21;
        if (v19 == 0.0 && v20 == 0.0)
        {
          double v29 = a3 * 0.0 + v18 * result.n64_f64[0] + v24;
          double v30 = v28 + result.n64_f64[0] * 0.0 + v25;
          double v50 = v30;
          double v51 = v29;
          double v52 = v30;
          v53[0] = v29;
          double v31 = v27 * 0.0 + v18 * v26 + v24;
          double v32 = v27 * v21 + v26 * 0.0 + v25;
          if (v31 >= v29)
          {
            if (v31 <= v29) {
              goto LABEL_55;
            }
            unint64_t v33 = &v51;
          }
          else
          {
            unint64_t v33 = v53;
          }
          *unint64_t v33 = v31;
LABEL_55:
          BOOL v48 = v32 <= v30;
          if (v32 < v30) {
            goto LABEL_56;
          }
          goto LABEL_57;
        }
        double v34 = a3 * v20;
        double v35 = v28 + v19 * result.n64_f64[0] + v25;
        double v50 = v35;
        double v51 = v34 + v18 * result.n64_f64[0] + v24;
        double v52 = v35;
        v53[0] = v51;
        double v36 = v34 + v18 * v26 + v24;
        double v37 = v28 + v19 * v26 + v25;
        if (v36 >= v51)
        {
          if (v36 <= v51) {
            goto LABEL_30;
          }
          long long v38 = &v51;
        }
        else
        {
          long long v38 = v53;
        }
        *long long v38 = v36;
LABEL_30:
        if (v37 >= v35)
        {
          if (v37 <= v35) {
            goto LABEL_35;
          }
          __n64 v39 = &v50;
        }
        else
        {
          __n64 v39 = &v52;
        }
        *__n64 v39 = v37;
LABEL_35:
        double v40 = v27 * v20;
        double v41 = v27 * v20 + v18 * v26 + v24;
        double v42 = v27 * v21;
        double v43 = v42 + v19 * v26 + v25;
        if (v41 >= v53[0])
        {
          if (v41 <= v51) {
            goto LABEL_40;
          }
          uint64_t v44 = &v51;
        }
        else
        {
          uint64_t v44 = v53;
        }
        *uint64_t v44 = v41;
LABEL_40:
        if (v43 >= v52)
        {
          if (v43 <= v50) {
            goto LABEL_45;
          }
          uint64_t v45 = &v50;
        }
        else
        {
          uint64_t v45 = &v52;
        }
        *uint64_t v45 = v43;
LABEL_45:
        double v46 = v40 + v18 * result.n64_f64[0] + v24;
        double v32 = v42 + v19 * result.n64_f64[0] + v25;
        if (v46 >= v53[0])
        {
          if (v46 <= v51)
          {
LABEL_50:
            if (v32 < v52)
            {
LABEL_56:
              CGRect v49 = &v52;
              goto LABEL_59;
            }
            BOOL v48 = v32 <= v50;
LABEL_57:
            if (v48) {
              return *(__n64 *)&v53[0];
            }
            CGRect v49 = &v50;
LABEL_59:
            double *v49 = v32;
            return *(__n64 *)&v53[0];
          }
          uint64_t v47 = &v51;
        }
        else
        {
          uint64_t v47 = v53;
        }
        *uint64_t v47 = v46;
        goto LABEL_50;
      }
    }
  }
  return result;
}

double image_finalize(uint64_t a1)
{
  if (get_notification_center_onceToken != -1) {
    dispatch_once(&get_notification_center_onceToken, &__block_literal_global_368);
  }
  if (get_notification_center_image_notification_center) {
    CGNotificationCenterPostNotification(get_notification_center_image_notification_center, @"kCGImageWillDeallocate", (__CFString *)a1);
  }
  double v2 = *(const void **)(a1 + 232);
  if (v2) {
    CFRelease(v2);
  }
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 216));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 144));
  CGDataProviderRelease(*(CGDataProviderRef *)(a1 + 152));
  double v3 = *(const void **)(a1 + 208);
  if (v3) {
    CFRelease(v3);
  }
  double v4 = *(const void **)(a1 + 192);
  if (v4) {
    CFRelease(v4);
  }
  double v5 = *(const void **)(a1 + 200);
  if (v5) {
    CFRelease(v5);
  }
  double v6 = *(const void **)(a1 + 176);
  if (v6) {
    CFRelease(v6);
  }
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 184));
  unint64_t v7 = *(const void **)(a1 + 240);
  if (v7) {
    CFRelease(v7);
  }
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 224));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 80));
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 28) = 57005;
  return result;
}

void context_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      CGFloat v9 = *(const void **)(a1 + 80);
      if (v9) {
        CFRelease(v9);
      }
      CGFloat v10 = *(void **)(a1 + 112);
      if (v10 && atomic_fetch_add_explicit((atomic_uint *volatile)v10, 0xFFFFFFFF, memory_order_relaxed) == 1) {
        free(v10);
      }
      unint64_t v11 = *(const void **)(a1 + 168);
      if (v11) {
        CFRelease(v11);
      }
      double v12 = *(void **)(a1 + 104);
      if (v12)
      {
        CGGStackReset(*(uint64_t **)(a1 + 104));
        free(v12);
      }
      CGPropertiesRelease(*(CFTypeRef **)(a1 + 176));
      *(_DWORD *)(a1 + 16) = -1129601109;
      return;
    }
    uint64_t v13 = a1;
  }
  else
  {
    uint64_t v13 = 0;
  }

  handle_invalid_context((char)"context_finalize", v13, a3, a4, a5, a6, a7, a8);
}

void CGPropertiesRelease(CFTypeRef *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CFRelease(a1[1]);
    free(a1);
  }
}

uint64_t *CGGStackReset(uint64_t *a1)
{
  for (double result = (uint64_t *)a1[1]; result != a1; double result = (uint64_t *)a1[1])
  {
    uint64_t v4 = *result;
    double v3 = (void *)result[1];
    *(void *)(v4 + 8) = v3;
    *double v3 = v4;
    *double result = (uint64_t)result;
    result[1] = (uint64_t)result;
    CGGStateRelease((uint64_t)result);
  }
  return result;
}

void CGNotificationCenterPostNotification(uint64_t a1, __CFString *a2, __CFString *a3)
{
  if (a2) {
    double v5 = a2;
  }
  else {
    double v5 = @"kCGNotificationAnyName";
  }
  double v6 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  unint64_t v7 = *(uint64_t **)(a1 + 80);
  if (!v7) {
    goto LABEL_28;
  }
  CGFloat v8 = 0;
  do
  {
    uint64_t v9 = *v7;
    CGFloat v10 = malloc_type_malloc(0x10uLL, 0x2062DE7BuLL);
    if (v10)
    {
      *CGFloat v10 = v9;
      v10[1] = v8;
      CGFloat v8 = v10;
    }
    unint64_t v7 = (uint64_t *)v7[1];
  }
  while (v7);
  if (v8)
  {
    unint64_t v11 = 0;
    do
    {
      double v12 = v8;
      CGFloat v8 = (void *)v8[1];
      v12[1] = v11;
      unint64_t v11 = v12;
    }
    while (v8);
    uint64_t v13 = (atomic_uint *volatile *)v12;
    do
    {
      if (*v13) {
        atomic_fetch_add_explicit(*v13, 1u, memory_order_relaxed);
      }
      uint64_t v13 = (atomic_uint *volatile *)*((void *)v13 + 1);
    }
    while (v13);
    pthread_mutex_unlock(v6);
    double v14 = v12;
    do
    {
      uint64_t v15 = *v14;
      double v16 = *(__CFString **)(*v14 + 24);
      if (v16 == @"kCGNotificationAnyObject" || v16 == a3)
      {
        double v18 = *(__CFString **)(v15 + 16);
        if (v18 == @"kCGNotificationAnyName" || CFEqual(v18, v5))
        {
          (*(void (**)(uint64_t, void, __CFString *, __CFString *, void))(v15 + 32))(a1, *(void *)(v15 + 8), v5, a3, 0);
          if (*(__CFString **)(v15 + 24) != @"kCGNotificationAnyObject")
          {
            pthread_mutex_lock(v6);
            double v19 = x_list_remove(*(void **)(a1 + 80), v15);
            registry_entry_release((CFTypeRef *)v15);
            *(void *)(a1 + 80) = v19;
            pthread_mutex_unlock(v6);
          }
        }
      }
      double v14 = (uint64_t *)v14[1];
    }
    while (v14);
  }
  else
  {
LABEL_28:
    pthread_mutex_unlock(v6);
    double v12 = 0;
  }

  registry_release(v12);
}

void registry_release(void *a1)
{
  if (a1)
  {
    CGRect v1 = a1;
    double v2 = (CFTypeRef **)a1;
    do
    {
      registry_entry_release(*v2);
      double v2 = (CFTypeRef **)v2[1];
    }
    while (v2);
    do
    {
      double v3 = (void *)v1[1];
      free(v1);
      CGRect v1 = v3;
    }
    while (v3);
  }
}

void registry_entry_release(CFTypeRef *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    CFRelease(a1[2]);
    free(a1);
  }
}

void CGImageEPSRepRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

void CG::DisplayList::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CGRect *a5, CFDictionaryRef theDict)
{
  if (!theDict || !CFDictionaryContainsKey(theDict, @"kCGContextBackgroundColor") || *(_DWORD *)(a1 + 600) == -1)
  {
    double v26 = *(uint64_t **)(a1 + 576);
    double v27 = *(uint64_t **)(a1 + 584);
    uint64_t v28 = a1;
    uint64_t v29 = a2;
    uint64_t v30 = a3;
    uint64_t v31 = a4;
    p_CGPoint origin = &a5->origin;
    int v33 = 0;
LABEL_26:
    CG::DisplayList::executeEntries(v28, v26, v27, v29, v30, v31, p_origin, v33);
    return;
  }
  Shape = CG::DisplayListShape::getShape(*(CG::DisplayListShape **)(a1 + 104), v12);
  if (!Shape)
  {
    double v26 = *(uint64_t **)(a1 + 576);
    double v27 = *(uint64_t **)(a1 + 584);
    uint64_t v28 = a1;
    uint64_t v29 = a2;
LABEL_75:
    uint64_t v30 = a3;
    uint64_t v31 = a4;
    p_CGPoint origin = &a5->origin;
    int v33 = 1;
    goto LABEL_26;
  }
  double v14 = Shape;
  uint64_t v98 = a2;
  if (a5)
  {
    CGRect v109 = CGRectIntegral(*a5);
    double x = v109.origin.x;
    double y = v109.origin.y;
    double width = v109.size.width;
    double height = v109.size.height;
    if (v109.size.width < 0.0 || v109.size.height < 0.0)
    {
      double v37 = COERCE_DOUBLE(CGRectStandardize(v109));
      if (v37 <= 1073741820.0) {
        double v38 = v37;
      }
      else {
        double v38 = 1073741820.0;
      }
      if (v37 >= -1073741820.0) {
        int v22 = (int)v38;
      }
      else {
        int v22 = -1073741824;
      }
      v110.origin.double x = x;
      v110.origin.double y = y;
      v110.size.double width = width;
      v110.size.double height = height;
      CGRect v111 = CGRectStandardize(v110);
      if (v111.origin.y <= 1073741820.0) {
        double v39 = v111.origin.y;
      }
      else {
        double v39 = 1073741820.0;
      }
      if (v111.origin.y >= -1073741820.0) {
        int v24 = (int)v39;
      }
      else {
        int v24 = -1073741824;
      }
      v112.origin.double x = x;
      v112.origin.double y = y;
      v112.size.double width = width;
      v112.size.double height = height;
      CGRect v113 = CGRectStandardize(v112);
      double v40 = v113.origin.x + v113.size.width;
      if (v40 <= 1073741820.0) {
        double v41 = v40;
      }
      else {
        double v41 = 1073741820.0;
      }
      if (v40 >= -1073741820.0) {
        int v25 = (int)v41;
      }
      else {
        int v25 = -1073741824;
      }
      v114.origin.double x = x;
      v114.origin.double y = y;
      v114.size.double width = width;
      v114.size.double height = height;
      CGRect v115 = CGRectStandardize(v114);
      double y = v115.origin.y;
      double height = v115.size.height;
    }
    else
    {
      double v20 = 1073741820.0;
      if (x <= 1073741820.0) {
        double v21 = x;
      }
      else {
        double v21 = 1073741820.0;
      }
      if (x >= -1073741820.0) {
        int v22 = (int)v21;
      }
      else {
        int v22 = -1073741824;
      }
      if (y <= 1073741820.0) {
        double v23 = y;
      }
      else {
        double v23 = 1073741820.0;
      }
      if (y >= -1073741820.0) {
        int v24 = (int)v23;
      }
      else {
        int v24 = -1073741824;
      }
      if (x + width <= 1073741820.0) {
        double v20 = x + width;
      }
      if (x + width >= -1073741820.0) {
        int v25 = (int)v20;
      }
      else {
        int v25 = -1073741824;
      }
    }
    double v42 = 1073741820.0;
    if (y + height <= 1073741820.0) {
      double v42 = y + height;
    }
    if (y + height >= -1073741820.0) {
      int v43 = (int)v42;
    }
    else {
      int v43 = -1073741824;
    }
    if (v22 >= v25 || v24 >= v43) {
      goto LABEL_74;
    }
    uint64_t v45 = shape_intersect_with_bounds(v15, v14, v22, v24, v25, v43);
    if (!v45 || v45 == (int *)&the_empty_shape) {
      goto LABEL_74;
    }
    double v34 = v45;
    if (v45[v45[1]] == 0x7FFFFFFF)
    {
      free(v45);
LABEL_74:
      double v26 = *(uint64_t **)(a1 + 576);
      double v27 = *(uint64_t **)(a1 + 584);
      uint64_t v28 = a1;
      uint64_t v29 = a2;
      goto LABEL_75;
    }
  }
  else
  {
    double v34 = shape_copy(Shape);
  }
  double v35 = (char *)malloc_type_malloc(0x38uLL, 0xEB07EEC6uLL);
  *(_DWORD *)double v35 = 0;
  *(_OWORD *)(v35 + 4) = xmmword_1850CDCD0;
  *(int32x2_t *)(v35 + 20) = vdup_n_s32(0x7FFFFFFEu);
  *((void *)v35 + 5) = 0;
  *((void *)v35 + 6) = 0;
  *((void *)v35 + 4) = 0;
  uint64_t v99 = v35;
  if (v34 != (int *)&the_empty_shape && v34[v34[1]] != 0x7FFFFFFF)
  {
    *((_DWORD *)v35 + 1) = 0;
    *((void *)v35 + 4) = v34;
    *((void *)v35 + 5) = v34 + 2;
  }
  uint64_t v106 = 0;
  *(void *)char v107 = 0;
  CFTypeRef cf = 0;
  if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1) {
    dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_103_22795);
  }
  uint64_t v96 = a4;
  int v97 = &a5->origin;
  uint64_t v95 = v34;
  if (CGCFDictionaryGetCFTypeRef(theDict, @"kCGContextColorSpace", CGColorSpaceGetTypeID_type_id, (uint64_t *)&cf))
  {
    double v36 = cf;
    if (!cf)
    {
      CFTypeRef cf = 0;
      goto LABEL_80;
    }
    CFRetain(cf);
    CFTypeRef cf = v36;
  }
  else
  {
    double v36 = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
    CFTypeRef cf = v36;
    if (!v36) {
      goto LABEL_80;
    }
  }
  uint64_t v47 = *(unsigned int *)(v36[3] + 28);
  if (v47 < 3)
  {
    int v48 = dword_185222394[v47];
    uint64_t v49 = qword_1852223A0[v47];
    goto LABEL_81;
  }
LABEL_80:
  CGColorSpaceRelease((CGColorSpaceRef)v36);
  CFTypeRef cf = CGColorSpaceCreateWithName(@"kCGColorSpaceSRGB");
  int v48 = 8198;
  uint64_t v49 = 32;
LABEL_81:
  long long v104 = *(_OWORD *)(a3 + 8);
  CGCFDictionaryGetSize(theDict, @"kCGContextResolution", (UInt8 *)&v104);
  double v50 = 0;
  double v51 = 0;
  double v52 = 0;
  while (shape_enum_next((uint64_t)v99, &v107[1], v107, (_DWORD *)&v106 + 1, &v106))
  {
    v102.double x = (double)v107[1];
    v102.double y = (double)v107[0];
    *(double *)&long long v103 = (double)(HIDWORD(v106) - v107[1]);
    *((double *)&v103 + 1) = (double)((int)v106 - v107[0]);
    double v53 = *(double *)&v104 * *(double *)&v103 / 72.0;
    unint64_t v54 = vcvtpd_u64_f64(v53);
    double v55 = *((double *)&v104 + 1) * *((double *)&v103 + 1) / 72.0;
    uint64_t v56 = CGBitmapContextCreateWithDataAndDictionary(0, v54, vcvtpd_u64_f64(v55), 8, v49, (v49 * v54) >> 3, cf, v48, *(double *)&v104, *((double *)&v104 + 1), 0, 0, 0);
    if (v56)
    {
      uint64_t v64 = (uint64_t)v56;
      uint64_t v65 = v56[14];
      if (v65 != a3)
      {
        *(_OWORD *)(v65 + 8) = *(_OWORD *)(a3 + 8);
        long long v66 = *(_OWORD *)(a3 + 24);
        long long v67 = *(_OWORD *)(a3 + 40);
        *(_OWORD *)(v65 + 56) = *(_OWORD *)(a3 + 56);
        *(_OWORD *)(v65 + 40) = v67;
        *(_OWORD *)(v65 + 24) = v66;
        *(void *)(v65 + 72) = *(void *)(a3 + 72);
        *(_DWORD *)(v65 + 4) = *(_DWORD *)(a3 + 4);
        *(_DWORD *)(v65 + 80) = *(_DWORD *)(a3 + 80);
        *(_WORD *)(v65 + 84) = *(_WORD *)(a3 + 84);
        *(unsigned char *)(v65 + 86) = *(unsigned char *)(a3 + 86);
      }
      CGContextErase((uint64_t)v56, v57, v58, v59, v60, v61, v62, v63);
      if (*(_DWORD *)(v64 + 16) == 1129601108)
      {
        uint64_t v74 = *(void *)(v64 + 96);
        float64x2_t v75 = vmulq_n_f64(*(float64x2_t *)(v74 + 40), ceil(v55) / *((double *)&v103 + 1));
        *(float64x2_t *)(v74 + 24) = vmulq_n_f64(*(float64x2_t *)(v74 + 24), ceil(v53) / *(double *)&v103);
        *(float64x2_t *)(v74 + 40) = v75;
      }
      else
      {
        handle_invalid_context((char)"CGContextScaleCTM", v64, v68, v69, v70, v71, v72, v73);
      }
      if (*(_DWORD *)(v64 + 16) == 1129601108) {
        *(float64x2_t *)(*(void *)(v64 + 96) + 56) = vmlsq_lane_f64(vmlsq_lane_f64(*(float64x2_t *)(*(void *)(v64 + 96) + 56), *(float64x2_t *)(*(void *)(v64 + 96) + 24), v102.x, 0), *(float64x2_t *)(*(void *)(v64 + 96) + 40), v102.y, 0);
      }
      else {
        handle_invalid_context((char)"CGContextTranslateCTM", v64, v68, v69, v70, v71, v72, v73);
      }
      int v76 = *(_DWORD *)(a1 + 600);
      if (v76 == -1) {
        int v76 = 0;
      }
      CG::DisplayList::executeEntries(a1, *(uint64_t **)(a1 + 576), (uint64_t *)(*(void *)(a1 + 576) + 16 * v76 + 16), *(void *)(v64 + 40), *(void *)(v64 + 112), *(void *)(v64 + 104), &v102, 0);
      CGImageRef Image = CGBitmapContextCreateImage((CGContextRef)v64);
      CFRelease((CFTypeRef)v64);
      if (Image)
      {
        CGPoint v100 = v102;
        long long v101 = v103;
        if (v51 >= (CGImageRef *)v52)
        {
          unint64_t v78 = 0xCCCCCCCCCCCCCCCDLL * (v51 - v50) + 1;
          if (v78 > 0x666666666666666) {
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
          }
          if (0x999999999999999ALL * ((v52 - (char *)v50) >> 3) > v78) {
            unint64_t v78 = 0x999999999999999ALL * ((v52 - (char *)v50) >> 3);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((v52 - (char *)v50) >> 3) >= 0x333333333333333) {
            unint64_t v79 = 0x666666666666666;
          }
          else {
            unint64_t v79 = v78;
          }
          if (v79)
          {
            if (v79 > 0x666666666666666) {
              std::__throw_bad_array_new_length[abi:fe180100]();
            }
            uint64_t v80 = (char *)operator new(40 * v79);
          }
          else
          {
            uint64_t v80 = 0;
          }
          uint64_t v81 = &v80[8 * (v51 - v50)];
          *(void *)uint64_t v81 = Image;
          long long v82 = v103;
          *(CGPoint *)(v81 + 8) = v102;
          *(_OWORD *)(v81 + 24) = v82;
          if (v51 == v50)
          {
            vImageConverterRef v84 = &v80[8 * (v51 - v50)];
          }
          else
          {
            int v83 = &v80[8 * (v51 - v50)];
            do
            {
              vImageConverterRef v84 = v83 - 40;
              long long v85 = *(_OWORD *)(v51 - 5);
              long long v86 = *(_OWORD *)(v51 - 3);
              *((void *)v83 - 1) = *(v51 - 1);
              *(_OWORD *)(v83 - 24) = v86;
              *(_OWORD *)(v83 - 40) = v85;
              v51 -= 5;
              v83 -= 40;
            }
            while (v51 != v50);
          }
          double v52 = &v80[40 * v79];
          double v51 = (CGImageRef *)(v81 + 40);
          if (v50) {
            operator delete(v50);
          }
          double v50 = (CGImageRef *)v84;
        }
        else
        {
          *double v51 = Image;
          *(_OWORD *)(v51 + 3) = v101;
          *(CGPoint *)(v51 + 1) = v100;
          v51 += 5;
        }
      }
    }
  }
  CGColorSpaceRelease((CGColorSpaceRef)cf);
  free(v99);
  if (v95 && v95 != (int *)&the_empty_shape) {
    free(v95);
  }
  int v87 = *(_DWORD *)(a1 + 600);
  if (v87 == -1) {
    int v87 = 0;
  }
  CG::DisplayList::executeEntries(a1, *(uint64_t **)(a1 + 576), (uint64_t *)(*(void *)(a1 + 576) + 16 * v87 + 16), v98, a3, v96, v97, 1);
  if (v50 != v51)
  {
    uint64_t v88 = *(void *)(v96 + 8);
    if (v88 == v96)
    {
      uint64_t v89 = CGGStateCreate();
      int v90 = *(char ***)(v96 + 8);
      *(void *)(v96 + 8) = v89;
      *(void *)uint64_t v89 = v96;
      uint64_t *v90 = v89;
      *((void *)v89 + 1) = v90;
      uint64_t v88 = *(void *)(v96 + 8);
    }
    unint64_t v91 = (double *)v50;
    do
    {
      vImageConverterRef v92 = *(const void **)v91;
      if (v98)
      {
        uint64_t v93 = *(void (**)(uint64_t, uint64_t, uint64_t, const void *, double, double, double, double))(v98 + 80);
        if (v93)
        {
          v93(v98, a3, v88, v92, v91[1], v91[2], v91[3], v91[4]);
          vImageConverterRef v92 = *(const void **)v91;
        }
      }
      if (v92) {
        CFRelease(v92);
      }
      v91 += 5;
    }
    while (v91 != (double *)v51);
  }
  int v94 = *(_DWORD *)(a1 + 600);
  if (v94 == -1) {
    int v94 = 0;
  }
  CG::DisplayList::executeEntries(a1, (uint64_t *)(*(void *)(a1 + 576) + 16 * v94), *(uint64_t **)(a1 + 584), v98, a3, v96, v97, 1);
  if (v50) {
    operator delete(v50);
  }
}

void sub_184C2CA80(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGDataProviderCreateForDestinationWithImage(void *a1, _DWORD *a2, vImagePixelCount a3, CGDataProviderRef a4, void *cf, unsigned int a6, int a7)
{
  uint64_t v413 = *MEMORY[0x1E4F143B8];
  if (!cf) {
    return 0;
  }
  CFTypeID v14 = CFGetTypeID(cf);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
  }
  if (v14 != CGImageGetTypeID_image_type_id) {
    return 0;
  }
  uint64_t v15 = 0;
  unint64_t v16 = cf[5];
  unint64_t v17 = cf[6];
  if (!is_mul_ok(v16, v17)) {
    return v15;
  }
  BOOL v18 = v16 * v17 <= 0x9C4 && (cf[19] | cf[30]) == 0;
  DataProviderInternal = CGImageGetDataProviderInternal((char *)cf, v18);
  if (!DataProviderInternal) {
    return 0;
  }
  double v20 = DataProviderInternal;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)cf);
  Decode = CGImageGetDecode((CGImageRef)cf);
  CGImageByteOrderInfo ByteOrderInfo = CGImageGetByteOrderInfo((CGImageRef)cf);
  uint64_t AlphaInfo = CGImageGetAlphaInfo((CGImageRef)cf);
  if ((*((unsigned char *)cf + 39) & 2) != 0)
  {
    uint64_t v23 = 1;
  }
  else
  {
    CGColorSpaceRef v22 = CGImageGetColorSpace((CGImageRef)cf);
    if (v22) {
      uint64_t v23 = *(void *)(*((void *)v22 + 3) + 48);
    }
    else {
      uint64_t v23 = 0;
    }
  }
  PixelComponentint Type = CGImageGetPixelComponentType((uint64_t)cf);
  CGDataProviderRef provider = (CGDataProviderRef)v20;
  uint64_t v344 = v23;
  if (a7)
  {
    signed int v32 = PixelComponentType;
    MaskingColors = (double *)CGImageGetMaskingColors(cf);
    PixelComponentint Type = v32;
    double v34 = MaskingColors;
  }
  else
  {
    double v34 = 0;
  }
  double v35 = (CGDataProvider *)cf[5];
  CGDataProviderRef v357 = (CGDataProviderRef)cf[6];
  uint64_t v36 = cf[9];
  uint64_t v365 = cf[8];
  uint64_t v37 = cf[19];
  if (v37 && (*(_DWORD *)(v37 + 20) & 0xFFFFFFFD) == 1 || v365 * (void)v35 != 8 * v36) {
    size_t v38 = cf[9];
  }
  else {
    size_t v38 = 0;
  }
  unint64_t v39 = cf[7];
  memset(v412, 0, sizeof(v412));
  unsigned int v374 = v35;
  unsigned int v343 = a6;
  uint64_t v342 = a2;
  if (PixelComponentType)
  {
    if (PixelComponentType != 3)
    {
      uint64_t v40 = 0;
      if ((v39 & 7) == 0 || PixelComponentType == *a2)
      {
        UpscaledComponentint Type = PixelComponentType;
        goto LABEL_107;
      }
    }
  }
  unint64_t v330 = v39;
  char v331 = PixelComponentType;
  uint64_t v366 = v36;
  UpscaledComponentint Type = CGImageGetUpscaledComponentType((CGImage *)cf);
  memset(v379, 0, sizeof(v379));
  CGBitmapPixelInfoInitializeWithImage(v379, v379, (CGColorSpace *)cf);
  if (CGImageGetPixelFormatInfo((CGImageRef)cf) == kCGImagePixelFormatRGBCIF10) {
    LODWORD(AlphaInfo) = 6;
  }
  unsigned int v345 = AlphaInfo;
  int Type = CGColorSpaceGetType(ColorSpace);
  BOOL v45 = 0;
  vImagePixelCount v338 = a3;
  if (CGColorSpaceGetType(ColorSpace) == 7)
  {
    double v46 = Decode;
    if (Decode) {
      BOOL v45 = CGImageGetDecodeType((CGImage *)cf) == 2;
    }
  }
  else
  {
    double v46 = Decode;
  }
  int v353 = *(_DWORD *)&v379[24];
  unsigned int v47 = *(_DWORD *)&v379[24] - 1;
  unint64_t v332 = a4;
  if ((*(_DWORD *)&v379[24] - 1) > 8) {
    uint64_t v48 = 0;
  }
  else {
    uint64_t v48 = qword_185211998[v47];
  }
  unsigned int v49 = UpscaledComponentType - 1;
  if ((UpscaledComponentType - 1) >= 5 || ((0x1Bu >> v49) & 1) == 0) {
    _CGHandleAssert("bytes_per_upscaled_component", 93, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestinationWithImage.c", "", "Unimplemented", v42, v43, v44, v322);
  }
  cfdouble a = *(char **)&v379[16];
  int v334 = Type;
  BOOL v336 = Type == 7;
  uint64_t v50 = qword_1852104A8[v49];
  if (v45) {
    double v51 = v46;
  }
  else {
    double v51 = 0;
  }
  unint64_t v329 = (CGDataProvider **)v51;
  unint64_t v52 = *(void *)&v379[8];
  uint64_t v349 = *(void *)v379;
  int v351 = *(_DWORD *)&v379[28];
  int v363 = *(_DWORD *)&v379[32];
  memcpy(__dst, &v379[36], 0x10CuLL);
  if (UpscaledComponentType > 5 || ((1 << UpscaledComponentType) & 0x36) == 0) {
    _CGHandleAssert("CGDataProviderCreateUpscalingProvider", 1377, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpscale.c", "dst_component_type == kCGImageComponent8BitInteger || dst_component_type == kCGImageComponent16BitInteger || dst_component_type == kCGImageComponent16BitFloat || dst_component_type == kCGImageComponent32BitFloat", "component type %u", v53, v54, v55, UpscaledComponentType);
  }
  uint64_t v56 = (CGDataProvider **)malloc_type_calloc(1uLL, 0xB8uLL, 0xA3729uLL);
  if (!v56)
  {
LABEL_145:
    CGPostError((uint64_t)"%s: failed to create upscaling provider", v57, v58, v59, v60, v61, v62, v63, (char)"CGDataProviderCreateForDestinationWithImage");
    return 0;
  }
  uint64_t v64 = v56;
  BOOL v324 = v45;
  uint64_t v65 = &cfa[v48];
  unint64_t v66 = v366 - ((unint64_t)(v365 * (void)v374 + 7) >> 3);
  int v67 = *((_DWORD *)provider + 5);
  *(void *)vImage_CGImageFormat srcFormat = v349;
  *(void *)&srcFormat[8] = v52;
  unint64_t v68 = v66 + (void)v65 * (void)v374 * v50;
  unsigned int v333 = v67 & 0xFFFFFFFD;
  *(void *)&srcFormat[16] = cfa;
  *(_DWORD *)&srcFormat[24] = v353;
  *(_DWORD *)&srcFormat[28] = v351;
  *(_DWORD *)&srcFormat[32] = v363;
  memcpy(&srcFormat[36], __dst, 0x10CuLL);
  uint64_t BitsPerPixel = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v69, v70, v71, v72, v73, v74, v75);
  unint64_t v339 = a1;
  unint64_t v83 = v52;
  if (v47 > 8) {
    uint64_t v84 = 0;
  }
  else {
    uint64_t v84 = qword_185211998[v47];
  }
  long long v85 = &cfa[v84];
  uint64_t v93 = bits_per_component_type(UpscaledComponentType, v76, v77, v78, v79, v80, v81, v82) * (void)&cfa[v84];
  unint64_t v94 = v93 * (void)v374 + 7;
  unint64_t v95 = v94 >> 3;
  if (v68) {
    unint64_t v96 = v68;
  }
  else {
    unint64_t v96 = v94 >> 3;
  }
  if (v363 == 0x40000)
  {
    unint64_t v328 = v85 + 1;
    uint64_t v93 = bits_per_component_type(UpscaledComponentType, v86, v87, v88, v89, v90, v91, v92) * (void)(v85 + 1);
    unint64_t v95 = (unint64_t)(v93 * (void)v374 + 7) >> 3;
    unint64_t v96 = v66 + v95;
  }
  else
  {
    unint64_t v328 = v85;
  }
  CGDataProviderRef v97 = v357;
  uint64_t v98 = provider;
  unint64_t v325 = (CGDataProvider *)v96;
  unint64_t v326 = (CGDataProvider *)v95;
  unint64_t v99 = v83;
  if (!v333)
  {
    *((unsigned char *)v64 + 8) = 1;
    CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v64, v96 * (void)v357, (uint64_t)&direct_provider_upscale_callbacks, v88, v89, v90, v91, v92);
    uint64_t v40 = v102;
    uint64_t v101 = UpscaledComponentType - 1;
    if (v102) {
      goto LABEL_57;
    }
    goto LABEL_80;
  }
  uint64_t SequentialWithInternalCallbacks = CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v64, (uint64_t)&sequential_provider_upscale_callbacks, v87, v88, v89, v90, v91, v92);
  uint64_t v101 = UpscaledComponentType - 1;
  if (!SequentialWithInternalCallbacks)
  {
LABEL_80:
    free(v64);
    goto LABEL_145;
  }
  uint64_t v40 = SequentialWithInternalCallbacks;
  CGDataProviderLock((uint64_t)provider);
LABEL_57:
  *(unsigned char *)(v40 + 260) = *((unsigned char *)provider + 260);
  if (v99 <= 0xC && ((1 << v99) & 0x1016) != 0 && v334 != 7)
  {
    long long v103 = (CGDataProvider *)v40;
    if (UpscaledComponentType == 2) {
      int v104 = 16;
    }
    else {
      int v104 = 8;
    }
    if (UpscaledComponentType == 5) {
      int v105 = 4352;
    }
    else {
      int v105 = 0;
    }
    if (UpscaledComponentType == 4) {
      int v106 = 32;
    }
    else {
      int v106 = v104;
    }
    if (UpscaledComponentType == 4) {
      int v107 = 8448;
    }
    else {
      int v107 = v105;
    }
    if (UpscaledComponentType == 2) {
      unsigned int v108 = 4096;
    }
    else {
      unsigned int v108 = v107;
    }
    DeviceGradouble y = CGColorSpaceCreateDeviceGray();
    *(_DWORD *)vImage_CGImageFormat srcFormat = v99;
    *(_DWORD *)&srcFormat[4] = v99;
    *(void *)&srcFormat[8] = DeviceGray;
    *(_DWORD *)&srcFormat[16] = *((_DWORD *)v64 + 31);
    memset(&srcFormat[20], 0, 20);
    *(_DWORD *)vImage_CGImageFormat destFormat = v106;
    *(_DWORD *)&destFormat[4] = v106;
    *(void *)&destFormat[8] = DeviceGray;
    *(void *)&destFormat[32] = 0;
    *(_OWORD *)&destFormat[16] = v108;
    vImageConverterRef v110 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)srcFormat, (const vImage_CGImageFormat *)destFormat, 0, 0x100u, 0);
    v64[17] = v110;
    if (!v110)
    {
      CGPostError((uint64_t)"%s: failed to create vImageConverter", v111, v112, v113, v114, v115, v116, v117, (char)"CGDataProviderCreateUpscalingProvider");
      CGDataProviderRelease(v103);
      goto LABEL_145;
    }
    uint64_t v40 = (uint64_t)v103;
    CGDataProviderRef v97 = v357;
    uint64_t v98 = provider;
  }
  CGDataProviderRetain(v98);
  void *v64 = v98;
  double v35 = v374;
  v64[2] = v374;
  v64[3] = v97;
  *((_DWORD *)v64 + 8) = UpscaledComponentType;
  v64[5] = (CGDataProvider *)v93;
  v64[6] = v325;
  v64[7] = v326;
  v64[10] = (CGDataProvider *)BitsPerPixel;
  v64[11] = (CGDataProvider *)v99;
  v64[12] = (CGDataProvider *)v366;
  *(void *)vImage_CGImageFormat srcFormat = v349;
  *(void *)&srcFormat[8] = v99;
  *(void *)&srcFormat[16] = cfa;
  int v118 = v353;
  *(_DWORD *)&srcFormat[24] = v353;
  *(_DWORD *)&srcFormat[28] = v351;
  *(_DWORD *)&srcFormat[32] = v363;
  memcpy(&srcFormat[36], __dst, 0x10CuLL);
  v64[13] = (CGDataProvider *)((unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v119, v120, v121, v122, v123, v124, v125)* (void)v374+ 7) >> 3);
  *((_DWORD *)v64 + 30) = v363;
  *((_DWORD *)v64 + 31) = v351;
  if (v353 == 9)
  {
    int v118 = 3;
    a3 = v338;
    a1 = v339;
    uint64_t v126 = (CGDataProvider *)v328;
  }
  else
  {
    a3 = v338;
    a1 = v339;
    uint64_t v126 = (CGDataProvider *)v328;
    if (v353 == 8) {
      int v118 = 1;
    }
  }
  *((_DWORD *)v64 + 32) = v118;
  v64[9] = v126;
  *((unsigned char *)v64 + 9) = v336;
  uint64_t v127 = v64[6];
  if (v127 <= v64[12]) {
    uint64_t v127 = v64[12];
  }
  size_t v128 = (((unint64_t)v127 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
  v64[19] = (CGDataProvider *)v128;
  uint64_t v129 = (CGDataProvider *)malloc_type_calloc(1uLL, v128, 0xA3729uLL);
  v64[18] = v129;
  if (!v129)
  {
    upscale_provider_release_info((uint64_t)v64);
    CGPostError((uint64_t)"%s failed", v131, v132, v133, v134, v135, v136, v137, (char)"CGDataProviderCreateUpscalingProvider");
    goto LABEL_145;
  }
  if (v329)
  {
    *((unsigned char *)v64 + 160) = 1;
    v64[21] = *v329;
    v64[22] = v329[1];
  }
  uint64_t v130 = *(uint64_t (**)(void))(v40 + 160);
  if (v130) {
    uint64_t v36 = v130(*(void *)(v40 + 24));
  }
  else {
    uint64_t v36 = 0;
  }
  a6 = v343;
  if (v365 * (void)v374 == 8 * v36) {
    size_t v38 = 0;
  }
  else {
    size_t v38 = v36;
  }
  unsigned int v138 = Decode;
  if (v324) {
    unsigned int v138 = 0;
  }
  Decode = v138;
  CGImageByteOrderInfo ByteOrderInfo = dword_18520D610[v101];
  uint64_t AlphaInfo = v345;
  if (v34 && (v331 & 0xE) != 4)
  {
    if (ColorSpace)
    {
      uint64_t v139 = 2 * *(void *)(*((void *)ColorSpace + 3) + 48);
      if (v139)
      {
        uint64_t v367 = v36;
        size_t v140 = v38;
        long double v141 = exp2((double)v330);
        size_t v38 = v140;
        uint64_t AlphaInfo = v345;
        uint64_t v36 = v367;
        double v142 = v141 + -1.0;
        BOOL v143 = (double *)v412;
        do
        {
          double v144 = *v34++;
          double v145 = v144 * dbl_18520D628[v101] / v142;
          double v146 = round(v145);
          if (v101 < 2) {
            double v145 = v146;
          }
          *v143++ = v145;
          --v139;
        }
        while (v139);
      }
    }
    double v34 = (double *)v412;
  }
  CGDataProviderRef provider = (CGDataProviderRef)v40;
  a4 = v332;
  a2 = v342;
LABEL_107:
  cfdouble b = (void *)v40;
  if (v35 == (CGDataProvider *)a3 && v357 == a4)
  {
    CGDataProviderRef v352 = 0;
    if (v34) {
      goto LABEL_110;
    }
    goto LABEL_158;
  }
  unsigned int v348 = AlphaInfo;
  size_t v356 = v38;
  unsigned int v341 = a1;
  unint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(UpscaledComponentType, v24, v25, v26, v27, v28, v29, v30);
  if ((BitsPerComponent & 7) != 0) {
    _CGHandleAssert("CGDataProviderCreateForDestinationWithImage", 219, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestinationWithImage.c", "bits_per_component == ((bits_per_component >> 3) << 3)", "bits per component %zu", v205, v206, v207, BitsPerComponent);
  }
  uint64_t NumberOfComponents = CGImageGetNumberOfComponents((uint64_t)cf);
  uint64_t v210 = cf[8];
  uint64_t v209 = cf[9];
  uint64_t v211 = cf[5];
  uint64_t v212 = CGImageGetNumberOfComponents((uint64_t)cf);
  if (BitsPerComponent > 0x20 || ((1 << BitsPerComponent) & 0x100010100) == 0) {
    _CGHandleAssert("CGDataProviderCreateUpsamplingProvider", 514, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpsample.c", "bits_per_component == 8 || bits_per_component == 16 || bits_per_component == 32", "bpc %zu", v213, v214, v215, BitsPerComponent);
  }
  uint64_t v216 = v212;
  CGFloat v217 = (CGDataProviderRef *)malloc_type_calloc(1uLL, 0x98uLL, 0xA3729uLL);
  if (!v217)
  {
LABEL_161:
    if (cfb) {
      CFRelease(cfb);
    }
    CGPostError((uint64_t)"%s: failed to create upsampling provider", v218, v219, v220, v221, v222, v223, v224, (char)"CGDataProviderCreateForDestinationWithImage");
    return 0;
  }
  int v225 = v217;
  unint64_t v226 = v209 - ((unint64_t)(v211 * v210 + 7) >> 3) + ((BitsPerComponent * a3 * NumberOfComponents) >> 3);
  unint64_t v227 = v356;
  v217[7] = v374;
  v217[8] = v357;
  unint64_t v228 = v216 * BitsPerComponent;
  if (!v356) {
    unint64_t v227 = (v216 * BitsPerComponent * (unint64_t)v374) >> 3;
  }
  v217[9] = (CGDataProviderRef)v227;
  v217[10] = (CGDataProviderRef)((v216 * BitsPerComponent * (unint64_t)v374) >> 3);
  v217[2] = (CGDataProviderRef)a3;
  v217[3] = a4;
  v217[4] = (CGDataProviderRef)v226;
  v217[5] = (CGDataProviderRef)((v228 * a3) >> 3);
  v217[12] = (CGDataProviderRef)BitsPerComponent;
  v217[13] = (CGDataProviderRef)v216;
  v217[14] = (CGDataProviderRef)(v228 >> 3);
  v217[15] = (CGDataProviderRef)(((void)v374 << 16) / a3);
  v217[16] = (CGDataProviderRef)(((void)v357 << 16) / (unint64_t)a4);
  unint64_t v371 = v226;
  if ((*((_DWORD *)provider + 5) & 0xFFFFFFFD) != 0)
  {
    a1 = v341;
    a2 = v342;
    a6 = v343;
    if (v357 != a4) {
      _CGHandleAssert("CGDataProviderCreateUpsamplingProvider", 554, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderUpsample.c", "data->src_height == data->dst_height", "src height %zu  dest height %zu", v222, v223, v224, (char)v357);
    }
    CGDataProviderRetain(provider);
    *int v225 = provider;
    uint64_t v235 = CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v225, (uint64_t)&sequential_provider_upsample_callbacks, v229, v230, v231, v232, v233, v234);
    CGDataProviderLock((uint64_t)provider);
  }
  else
  {
    *CGFloat v217 = CGDataProviderRetain(provider);
    *((unsigned char *)v225 + 8) = 1;
    CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v225, v226 * (void)a4, (uint64_t)&direct_provider_upsample_callbacks, v237, v238, v239, v240, v241);
    uint64_t v235 = v242;
    a1 = v341;
    a2 = v342;
    a6 = v343;
  }
  uint64_t AlphaInfo = v348;
  if (!v235)
  {
    free(v225);
    goto LABEL_161;
  }
  CGDataProviderRef v352 = (CGDataProviderRef)v235;
  CGDataProviderRef v243 = v225[4];
  if (v243 <= v225[9]) {
    CGDataProviderRef v243 = v225[9];
  }
  size_t v244 = (((unint64_t)v243 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
  v225[18] = (CGDataProviderRef)v244;
  CGAffineTransform v245 = (CGDataProvider *)malloc_type_calloc(1uLL, v244, 0xA3729uLL);
  v225[17] = v245;
  if (!v245 || !*v225)
  {
    upsample_provider_release_info((uint64_t)v225);
    CGPostError((uint64_t)"%s failed", v247, v248, v249, v250, v251, v252, v253, (char)"CGDataProviderCreateUpsamplingProvider");
    goto LABEL_161;
  }
  double v35 = v374;
  uint64_t v36 = v371;
  if (v365 * (void)v374 == 8 * v371) {
    size_t v38 = 0;
  }
  else {
    size_t v38 = v371;
  }
  CGDataProviderRef provider = (CGDataProviderRef)v235;
  if (v34)
  {
LABEL_110:
    unint64_t v354 = v38;
    uint64_t v368 = v36;
    memset(__dst, 0, sizeof(__dst));
    uint64_t v147 = CGPixelComponentGetBitsPerComponent(UpscaledComponentType, v24, v25, v26, v27, v28, v29, v30);
    CGBitmapPixelInfoInitialize(__dst, (char *)__dst, UpscaledComponentType, v147, v344, AlphaInfo, ByteOrderInfo, 0, (uint64_t)Decode);
    if (AlphaInfo >= 7) {
      _CGHandleAssert("alpha_info_for_masking_colors", 38, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderForDestinationWithImage.c", "", "Unimplemented", v152, v153, v154, v323);
    }
    int v346 = AlphaInfo;
    unsigned int v350 = dword_18520D650[AlphaInfo];
    uint64_t v373 = CGPixelComponentGetBitsPerComponent(UpscaledComponentType, v148, v149, v150, v151, v152, v153, v154);
    if ((unint64_t)(v373 - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
      _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v159, v160, v161, v373);
    }
    unsigned __int8 v162 = cfb;
    unint64_t v163 = v368;
    unint64_t v164 = v354;
    if (!v354)
    {
      memcpy(srcFormat, __dst, sizeof(srcFormat));
      uint64_t v172 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v165, v166, v167, v168, v169, v170, v171);
      unint64_t v163 = v368;
      unint64_t v164 = (v172 * a3 + 7) >> 3;
    }
    unint64_t v355 = v164;
    unint64_t v340 = a1;
    CGImageByteOrderInfo v173 = ByteOrderInfo;
    if (!v346)
    {
      unint64_t v174 = cf[9] - ((unint64_t)(v365 * (void)v35 + 7) >> 3);
      *(_DWORD *)vImage_CGImageFormat srcFormat = UpscaledComponentType;
      *(_DWORD *)&srcFormat[4] = 0;
      *(void *)&srcFormat[8] = v373;
      *(void *)&srcFormat[16] = v344;
      *(_DWORD *)&srcFormat[24] = v350;
      *(_DWORD *)&srcFormat[28] = ByteOrderInfo;
      memset(&srcFormat[32], 0, 272);
      unsigned __int8 v162 = cfb;
      unint64_t v163 = v174
           + ((unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v155, v156, v157, v158, v159, v160, v161)* (void)v374+ 7) >> 3);
    }
    size_t v369 = v163;
    long long v410 = 0u;
    long long v409 = 0u;
    long long v408 = 0u;
    long long v407 = 0u;
    long long v406 = 0u;
    long long v405 = 0u;
    long long v404 = 0u;
    long long v403 = 0u;
    long long v402 = 0u;
    long long v401 = 0u;
    long long v400 = 0u;
    long long v399 = 0u;
    long long v398 = 0u;
    memset(destFormat, 0, sizeof(destFormat));
    long long v377 = __dst[0];
    long long v393 = __dst[15];
    long long v394 = __dst[16];
    long long v395 = __dst[17];
    long long v396 = __dst[18];
    long long v389 = __dst[11];
    long long v390 = __dst[12];
    long long v391 = __dst[13];
    long long v392 = __dst[14];
    long long v386 = __dst[8];
    long long v387 = __dst[9];
    long long v388 = __dst[10];
    long long v381 = __dst[3];
    long long v382 = __dst[4];
    long long v383 = __dst[5];
    long long v384 = __dst[6];
    long long v385 = __dst[7];
    if (LODWORD(__dst[2])) {
      _CGHandleAssert("CGDataProviderCreateWithMaskingColors", 490, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithMaskingColors.c", "CGBitmapPixelInfoGetCGImagePixelFormatInfo(src_pixel_info) == kCGImagePixelFormatPacked", "source pixel info %u", v159, v160, v161, __dst[2]);
    }
    *(_DWORD *)vImage_CGImageFormat srcFormat = UpscaledComponentType;
    *(_DWORD *)&srcFormat[4] = 0;
    *(void *)&srcFormat[8] = v373;
    *(void *)&srcFormat[16] = v344;
    *(_DWORD *)&srcFormat[24] = v350;
    *(_DWORD *)&srcFormat[28] = ByteOrderInfo;
    memset(&srcFormat[32], 0, 272);
    *(_OWORD *)unint64_t v379 = __dst[0];
    unint64_t v364 = *(CGDataProvider **)&__dst[1];
    *(_OWORD *)&v379[16] = __dst[1];
    unint64_t v335 = (CGDataProvider *)*((void *)&__dst[1] + 1);
    unint64_t v337 = (CGDataProvider *)*((void *)&__dst[2] + 1);
    *(void *)&v379[32] = __PAIR64__(DWORD1(__dst[2]), 0);
    int v347 = DWORD1(__dst[2]);
    *(void *)&v379[40] = *((void *)&__dst[2] + 1);
    *(_OWORD *)&v379[240] = __dst[15];
    *(_OWORD *)&v379[256] = __dst[16];
    *(_OWORD *)&v379[272] = __dst[17];
    *(_OWORD *)&v379[288] = __dst[18];
    *(_OWORD *)&v379[176] = __dst[11];
    *(_OWORD *)&v379[192] = __dst[12];
    *(_OWORD *)&v379[208] = __dst[13];
    *(_OWORD *)&v379[224] = __dst[14];
    *(_OWORD *)&v379[112] = __dst[7];
    *(_OWORD *)&v379[128] = __dst[8];
    *(_OWORD *)&v379[144] = __dst[9];
    *(_OWORD *)&v379[160] = __dst[10];
    *(_OWORD *)&v379[48] = __dst[3];
    *(_OWORD *)&v379[64] = __dst[4];
    *(_OWORD *)&v379[80] = __dst[5];
    *(_OWORD *)&v379[96] = __dst[6];
    BOOL IsEqualToBitmapPixelInfo = CGBitmapPixelInfoIsEqualToBitmapPixelInfo((uint64_t)srcFormat, (uint64_t)v379);
    int v176 = malloc_type_calloc(1uLL, 0x3B8uLL, 0xA3729uLL);
    if (!v176) {
      goto LABEL_190;
    }
    uint64_t v184 = (CGDataProviderRef *)v176;
    uint64_t v185 = 2 * v344;
    if (2 * v344)
    {
      uint64_t v186 = v176 + 84;
      uint64_t v187 = v176 + 84;
      uint64_t v188 = v176 + 84;
      while (2)
      {
        switch(UpscaledComponentType)
        {
          case 1:
            double v189 = fmin(*v34, 255.0);
            goto LABEL_127;
          case 2:
            *v187++ = (int)fmax(fmin(*v34, 65535.0), 0.0);
            goto LABEL_128;
          case 4:
          case 5:
            *uint64_t v186 = *(void *)v34;
            goto LABEL_128;
          case 7:
            double v189 = fmin(*v34, 1.0);
            goto LABEL_127;
          case 8:
            double v189 = fmin(*v34, 3.0);
            goto LABEL_127;
          case 9:
            double v189 = fmin(*v34, 15.0);
LABEL_127:
            *v188++ = (int)fmax(v189, 0.0);
LABEL_128:
            ++v34;
            ++v186;
            if (!--v185) {
              break;
            }
            continue;
          default:
            _CGHandleAssert("copy_masking_colors", 453, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithMaskingColors.c", "", "Unimplemented", v181, v182, v183, v323);
        }
        break;
      }
    }
    if (!IsEqualToBitmapPixelInfo)
    {
      if ((CGDataProvider *)v344 != v364) {
        _CGHandleAssert("CGDataProviderCreateWithMaskingColors", 506, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithMaskingColors.c", "CGBitmapPixelInfoGetColorantCount(dst_pixel_info) == CGBitmapPixelInfoGetColorantCount(src_pixel_info)", "src colors %zu  dest colors %zu", v181, v182, v183, v344);
      }
      memset(v379, 0, 40);
      *(_OWORD *)vImage_CGImageFormat srcFormat = v377;
      *(void *)&srcFormat[16] = v344;
      *(void *)&srcFormat[24] = v335;
      *(_DWORD *)&srcFormat[32] = 0;
      *(_DWORD *)&srcFormat[36] = v347;
      *(void *)&srcFormat[40] = v337;
      *(_OWORD *)&srcFormat[240] = v393;
      *(_OWORD *)&srcFormat[256] = v394;
      *(_OWORD *)&srcFormat[272] = v395;
      *(_OWORD *)&srcFormat[288] = v396;
      *(_OWORD *)&srcFormat[176] = v389;
      *(_OWORD *)&srcFormat[192] = v390;
      *(_OWORD *)&srcFormat[208] = v391;
      *(_OWORD *)&srcFormat[224] = v392;
      *(_OWORD *)&srcFormat[112] = v385;
      *(_OWORD *)&srcFormat[128] = v386;
      *(_OWORD *)&srcFormat[144] = v387;
      *(_OWORD *)&srcFormat[160] = v388;
      *(_OWORD *)&srcFormat[48] = v381;
      *(_OWORD *)&srcFormat[64] = v382;
      *(_OWORD *)&srcFormat[80] = v383;
      *(_OWORD *)&srcFormat[96] = v384;
      CGBitmapPixelInfoGet_vImageFormat((uint64_t)v379, (uint64_t)srcFormat, v178, v179, v180, v181, v182, v183);
      memset(&v378, 0, sizeof(v378));
      *(_DWORD *)vImage_CGImageFormat srcFormat = UpscaledComponentType;
      *(_DWORD *)&srcFormat[4] = 0;
      *(void *)&srcFormat[8] = v373;
      *(void *)&srcFormat[16] = v344;
      *(_DWORD *)&srcFormat[24] = v350;
      *(_DWORD *)&srcFormat[28] = v173;
      *(void *)&srcFormat[40] = 0;
      *(void *)&srcFormat[32] = 0;
      *(_OWORD *)&srcFormat[240] = v407;
      *(_OWORD *)&srcFormat[256] = v408;
      *(_OWORD *)&srcFormat[272] = v409;
      *(_OWORD *)&srcFormat[288] = v410;
      *(_OWORD *)&srcFormat[176] = v403;
      *(_OWORD *)&srcFormat[192] = v404;
      *(_OWORD *)&srcFormat[208] = v405;
      *(_OWORD *)&srcFormat[224] = v406;
      *(_OWORD *)&srcFormat[112] = v399;
      *(_OWORD *)&srcFormat[128] = v400;
      *(_OWORD *)&srcFormat[144] = v401;
      *(_OWORD *)&srcFormat[160] = v402;
      *(_OWORD *)&srcFormat[48] = *(_OWORD *)destFormat;
      *(_OWORD *)&srcFormat[64] = *(_OWORD *)&destFormat[16];
      *(_OWORD *)&srcFormat[80] = *(_OWORD *)&destFormat[32];
      *(_OWORD *)&srcFormat[96] = v398;
      CGBitmapPixelInfoGet_vImageFormat((uint64_t)&v378, (uint64_t)srcFormat, v190, v191, v192, v193, v194, v195);
      vImageConverterRef v196 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)v379, &v378, 0, 0x100u, 0);
      v184[116] = v196;
      if (!v196)
      {
        free(v184);
        goto LABEL_190;
      }
    }
    unsigned int v197 = *((_DWORD *)provider + 5) & 0xFFFFFFFD;
    *(_DWORD *)vImage_CGImageFormat srcFormat = UpscaledComponentType;
    *(_DWORD *)&srcFormat[4] = 0;
    *(void *)&srcFormat[8] = v373;
    *(void *)&srcFormat[16] = v344;
    *(_DWORD *)&srcFormat[24] = v350;
    *(_DWORD *)&srcFormat[28] = v173;
    *(void *)&srcFormat[40] = 0;
    *(void *)&srcFormat[32] = 0;
    *(_OWORD *)&srcFormat[240] = v407;
    *(_OWORD *)&srcFormat[256] = v408;
    *(_OWORD *)&srcFormat[272] = v409;
    *(_OWORD *)&srcFormat[288] = v410;
    *(_OWORD *)&srcFormat[176] = v403;
    *(_OWORD *)&srcFormat[192] = v404;
    *(_OWORD *)&srcFormat[208] = v405;
    *(_OWORD *)&srcFormat[224] = v406;
    *(_OWORD *)&srcFormat[112] = v399;
    *(_OWORD *)&srcFormat[128] = v400;
    *(_OWORD *)&srcFormat[144] = v401;
    *(_OWORD *)&srcFormat[160] = v402;
    *(_OWORD *)&srcFormat[48] = *(_OWORD *)destFormat;
    *(_OWORD *)&srcFormat[64] = *(_OWORD *)&destFormat[16];
    *(_OWORD *)&srcFormat[80] = *(_OWORD *)&destFormat[32];
    *(_OWORD *)&srcFormat[96] = v398;
    uint64_t v204 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v177, v178, v179, v180, v181, v182, v183);
    if (v197)
    {
      int v358 = (CGDataProvider *)CGDataProviderCreateSequentialWithInternalCallbacks((uint64_t)v184, (uint64_t)&sequential_provider_with_masking_colors_callbacks, v198, v199, v200, v201, v202, v203);
      if (v358)
      {
        CGDataProviderLock((uint64_t)provider);
LABEL_165:
        unint64_t v255 = (unint64_t)(v204 * (void)v374 + 7) >> 3;
        *uint64_t v184 = CGDataProviderRetain(provider);
        *((_OWORD *)v184 + 1) = v377;
        v184[4] = v364;
        v184[5] = v335;
        *((_DWORD *)v184 + 12) = 0;
        *((_DWORD *)v184 + 13) = v347;
        v184[7] = v337;
        long long v263 = v394;
        *((_OWORD *)v184 + 16) = v393;
        *((_OWORD *)v184 + 17) = v263;
        long long v264 = v396;
        *((_OWORD *)v184 + 18) = v395;
        *((_OWORD *)v184 + 19) = v264;
        long long v265 = v390;
        *((_OWORD *)v184 + 12) = v389;
        *((_OWORD *)v184 + 13) = v265;
        long long v266 = v392;
        *((_OWORD *)v184 + 14) = v391;
        *((_OWORD *)v184 + 15) = v266;
        long long v267 = v386;
        *((_OWORD *)v184 + 8) = v385;
        *((_OWORD *)v184 + 9) = v267;
        long long v268 = v388;
        *((_OWORD *)v184 + 10) = v387;
        *((_OWORD *)v184 + 11) = v268;
        long long v269 = v382;
        *((_OWORD *)v184 + 4) = v381;
        *((_OWORD *)v184 + 5) = v269;
        long long v270 = v384;
        *((_OWORD *)v184 + 6) = v383;
        *((_OWORD *)v184 + 7) = v270;
        if (v337) {
          v184[7] = (CGDataProviderRef)(v184 + 8);
        }
        unint64_t v271 = v355;
        v184[40] = (CGDataProviderRef)v355;
        *(_OWORD *)vImage_CGImageFormat srcFormat = v377;
        *(void *)&srcFormat[16] = v364;
        *(void *)&srcFormat[24] = v335;
        *(_DWORD *)&srcFormat[32] = 0;
        *(_DWORD *)&srcFormat[36] = v347;
        *(void *)&srcFormat[40] = v337;
        *(_OWORD *)&srcFormat[240] = v393;
        *(_OWORD *)&srcFormat[256] = v394;
        *(_OWORD *)&srcFormat[272] = v395;
        *(_OWORD *)&srcFormat[288] = v396;
        *(_OWORD *)&srcFormat[176] = v389;
        *(_OWORD *)&srcFormat[192] = v390;
        *(_OWORD *)&srcFormat[208] = v391;
        *(_OWORD *)&srcFormat[224] = v392;
        *(_OWORD *)&srcFormat[112] = v385;
        *(_OWORD *)&srcFormat[128] = v386;
        *(_OWORD *)&srcFormat[144] = v387;
        *(_OWORD *)&srcFormat[160] = v388;
        *(_OWORD *)&srcFormat[48] = v381;
        *(_OWORD *)&srcFormat[64] = v382;
        *(_OWORD *)&srcFormat[80] = v383;
        *(_OWORD *)&srcFormat[96] = v384;
        v184[41] = (CGDataProviderRef)((unint64_t)(CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v256, v257, v258, v259, v260, v261, v262)* (void)v374+ 7) >> 3);
        *((_DWORD *)v184 + 86) = UpscaledComponentType;
        *((_DWORD *)v184 + 87) = 0;
        v184[44] = (CGDataProviderRef)v373;
        v184[45] = (CGDataProviderRef)v344;
        *((_DWORD *)v184 + 92) = v350;
        *((_DWORD *)v184 + 93) = v173;
        v184[47] = 0;
        v184[48] = 0;
        long long v272 = v408;
        *(_OWORD *)(v184 + 73) = v407;
        *(_OWORD *)(v184 + 75) = v272;
        long long v273 = v410;
        *(_OWORD *)(v184 + 77) = v409;
        *(_OWORD *)(v184 + 79) = v273;
        long long v274 = v404;
        *(_OWORD *)(v184 + 65) = v403;
        *(_OWORD *)(v184 + 67) = v274;
        long long v275 = v406;
        *(_OWORD *)(v184 + 69) = v405;
        *(_OWORD *)(v184 + 71) = v275;
        long long v276 = v400;
        *(_OWORD *)(v184 + 57) = v399;
        *(_OWORD *)(v184 + 59) = v276;
        long long v277 = v402;
        *(_OWORD *)(v184 + 61) = v401;
        *(_OWORD *)(v184 + 63) = v277;
        long long v278 = *(_OWORD *)&destFormat[16];
        *(_OWORD *)(v184 + 49) = *(_OWORD *)destFormat;
        *(_OWORD *)(v184 + 51) = v278;
        long long v279 = v398;
        *(_OWORD *)(v184 + 53) = *(_OWORD *)&destFormat[32];
        *(_OWORD *)(v184 + 55) = v279;
        v184[81] = (CGDataProviderRef)v369;
        v184[82] = (CGDataProviderRef)v255;
        memcpy(srcFormat, v184 + 43, sizeof(srcFormat));
        unint64_t v287 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v280, v281, v282, v283, v284, v285, v286);
        memcpy(srcFormat, v184 + 2, sizeof(srcFormat));
        unint64_t v295 = CGBitmapPixelInfoGetBitsPerPixel((uint64_t)srcFormat, v288, v289, v290, v291, v292, v293, v294);
        if (!v355) {
          _CGHandleAssert("calculate_work_buffer_size", 464, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProviderWithMaskingColors.c", "masking_colors_bytes_per_row != 0", "masking rowBytes = 0", v296, v297, v298, v323);
        }
        a6 = v343;
        a2 = v342;
        if (v287 > v295) {
          unint64_t v271 = v287 * v355 / v295;
        }
        a1 = v340;
        size_t v299 = ((v271 + 15) & 0xFFFFFFFFFFFFFFF0) + 16;
        v184[118] = (CGDataProviderRef)v299;
        int v300 = (CGDataProvider *)malloc_type_calloc(1uLL, v299, 0xA3729uLL);
        v184[117] = v300;
        if (v300)
        {
          CGImageByteOrderInfo ByteOrderInfo = v173;
          Decode = 0;
          if (v365 * (void)v374 == 8 * v369) {
            size_t v246 = 0;
          }
          else {
            size_t v246 = v369;
          }
          uint64_t AlphaInfo = v350;
          CGDataProviderRef provider = v358;
          goto LABEL_175;
        }
        provider_with_masking_colors_release_info((uint64_t)v184);
        CGPostError((uint64_t)"%s failed", v315, v316, v317, v318, v319, v320, v321, (char)"CGDataProviderCreateWithMaskingColors");
        goto LABEL_188;
      }
    }
    else
    {
      *((unsigned char *)v184 + 8) = 1;
      CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v184, v369 * (void)v357, (uint64_t)&direct_provider_with_masking_colors_callbacks, v199, v200, v201, v202, v203);
      int v358 = v254;
      if (v254) {
        goto LABEL_165;
      }
    }
    unint64_t v314 = v184[116];
    if (v314) {
      vImageConverter_Release(v314);
    }
    free(v184);
LABEL_188:
    unsigned __int8 v162 = cfb;
LABEL_190:
    if (v162) {
      CFRelease(v162);
    }
    if (v352) {
      CFRelease(v352);
    }
    CGPostError((uint64_t)"%s: failed to create masking color provider", v177, v178, v179, v180, v181, v182, v183, (char)"CGDataProviderCreateForDestinationWithImage");
    return 0;
  }
LABEL_158:
  size_t v246 = v38;
  int v358 = 0;
LABEL_175:
  memset(srcFormat, 0, sizeof(srcFormat));
  uint64_t v301 = CGPixelComponentGetBitsPerComponent(UpscaledComponentType, v24, v25, v26, v27, v28, v29, v30);
  CGBitmapPixelInfoInitialize(srcFormat, srcFormat, UpscaledComponentType, v301, v344, AlphaInfo, ByteOrderInfo, 0, (uint64_t)Decode);
  memcpy(v379, a2, sizeof(v379));
  size_t ImageBytesPerRowForPixelInfo = CGImageGetImageBytesPerRowForPixelInfo((uint64_t)cf, a3, (uint64_t)v379, v302, v303, v304, v305, v306);
  uint64_t v308 = cf[28];
  if (v308)
  {
    Properdouble ty = (void *)CGPropertiesGetProperty(v308, @"kCGColorConversionInfoOptions");
    int v310 = ColorSpace;
    uint64_t v311 = (CGDataProvider *)cfb;
    if (Property)
    {
      uint64_t CopyWithAttribute = CGColorTransformCreateCopyWithAttribute((uint64_t)a1, Property);
      uint64_t v313 = (const void *)CopyWithAttribute;
      if (CopyWithAttribute) {
        a1 = (void *)CopyWithAttribute;
      }
    }
    else
    {
      uint64_t v313 = 0;
    }
  }
  else
  {
    uint64_t v313 = 0;
    int v310 = ColorSpace;
    uint64_t v311 = (CGDataProvider *)cfb;
  }
  memcpy(v379, a2, sizeof(v379));
  memcpy(__dst, srcFormat, sizeof(__dst));
  uint64_t v15 = CGDataProviderCreateForDestination(a1, a3, a4, (uint64_t)v379, ImageBytesPerRowForPixelInfo, provider, v310, __dst, v246, a6);
  CGDataProviderRelease(v311);
  CGDataProviderRelease(v352);
  CGDataProviderRelease(v358);
  if (v313) {
    CFRelease(v313);
  }
  return v15;
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  if (provider)
  {
    CFTypeID v2 = CFGetTypeID(provider);
    if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
      dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
    }
    if (v2 == CGDataProviderGetTypeID_id)
    {
      CFRelease(provider);
    }
  }
}

unint64_t CGImageGetImageBytesPerRowForPixelInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a3 + 24) - 1;
  if (v10 > 8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = qword_185211998[v10];
  }
  uint64_t v12 = *(void *)(a3 + 16);
  uint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(*(_DWORD *)a3, a2, a3, a4, a5, a6, a7, a8);
  DataProviderInternal = CGImageGetDataProviderInternal((char *)a1, 0);
  if (!DataProviderInternal) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", v15, v16, v17, v21);
  }
  BOOL v18 = DataProviderInternal;
  unint64_t result = (unint64_t)((v11 + v12) * a2 * BitsPerComponent + 7) >> 3;
  if (*((_DWORD *)v18 + 5))
  {
    if (a1) {
      unint64_t v20 = *(void *)(a1 + 72) - ((unint64_t)(*(void *)(a1 + 40) * *(void *)(a1 + 64) + 7) >> 3);
    }
    else {
      unint64_t v20 = 0;
    }
    result += v20;
  }
  if (!result) {
    _CGHandleAssert("CGImageGetImageBytesPerRowForPixelInfo", 4031, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "bytes_per_row != 0", "zero rowBytes", v15, v16, v17, v21);
  }
  return result;
}

void *CGBitmapPixelInfoInitialize(void *a1, char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *((_OWORD *)a2 + 17) = 0u;
  *((_OWORD *)a2 + 18) = 0u;
  *((_OWORD *)a2 + 15) = 0u;
  *((_OWORD *)a2 + 16) = 0u;
  *((_OWORD *)a2 + 13) = 0u;
  *((_OWORD *)a2 + 14) = 0u;
  *((_OWORD *)a2 + 11) = 0u;
  *((_OWORD *)a2 + 12) = 0u;
  *((_OWORD *)a2 + 9) = 0u;
  *((_OWORD *)a2 + 10) = 0u;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  if ((unint64_t)(a4 - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", a6, a7, a8, a4);
  }
  *(_DWORD *)a2 = a3;
  *((void *)a2 + 1) = a4;
  *((void *)a2 + 2) = a5;
  *((_DWORD *)a2 + 6) = a6;
  *((_DWORD *)a2 + 7) = a7;
  *((_DWORD *)a2 + 8) = a8;
  if (a9)
  {
    if (a6) {
      uint64_t v9 = a5 + 1;
    }
    else {
      uint64_t v9 = a5;
    }
    if (v9)
    {
      unsigned int v10 = a2 + 56;
      uint64_t v11 = (uint64_t *)(a9 + 8);
      do
      {
        *(v10 - 1) = *(v11 - 1);
        uint64_t v12 = *v11;
        v11 += 2;
        *unsigned int v10 = v12;
        v10 += 2;
        --v9;
      }
      while (v9);
    }
    *((void *)a2 + 5) = a2 + 48;
  }

  return memcpy(a1, a2, 0x130uLL);
}

double CGStyleGetDrawBoundingBoxWithMatrix(uint64_t a1, _OWORD *a2, double a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  double v9 = a3;
  BOOL v10 = a3 == INFINITY || a4 == INFINITY;
  if (!v10 && a5 != 0.0 && a6 != 0.0)
  {
    if (a3 == -8.98846567e307 && a4 == -8.98846567e307 && a5 == 1.79769313e308 && a6 == 1.79769313e308)
    {
      return -8.98846567e307;
    }
    else
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      if (get_expansion(a1, (double *)&v20))
      {
        uint64_t v13 = v20;
        uint64_t v14 = v21;
        long long v15 = a2[1];
        *(_OWORD *)&v19.double a = *a2;
        *(_OWORD *)&v19.double c = v15;
        *(_OWORD *)&v19.double tx = a2[2];
        uint64_t v16 = 0;
        *(void *)&long long v15 = 0;
        CGRect v22 = CGRectApplyAffineTransform(*(CGRect *)(&v13 - 2), &v19);
        CGFloat v17 = -fabs(v22.size.width);
        CGFloat v18 = -fabs(v22.size.height);
        v22.origin.double x = v9;
        v22.origin.double y = a4;
        v22.size.double width = a5;
        v22.size.double height = a6;
        CGRect v23 = CGRectInset(v22, v17, v18);
        *(void *)&double v9 = (unint64_t)CGRectIntegral(v23);
      }
    }
  }
  return v9;
}

uint64_t get_expansion(uint64_t a1, double *a2)
{
  int v4 = *(_DWORD *)(a1 + 20);
  if (v4 == 3)
  {
    double v7 = *(double *)(a1 + 40);
LABEL_9:
    double v8 = fabs(v7);
    double v9 = v8;
    goto LABEL_13;
  }
  if (v4 == 2)
  {
    double v7 = *(double *)(a1 + 56);
    goto LABEL_9;
  }
  if (v4 != 1) {
    return 0;
  }
  double v5 = *(double *)(a1 + 40);
  double v6 = 0.0;
  if (v5 <= 89.9)
  {
    if (v5 >= 0.1)
    {
      double v11 = *(double *)(a1 + 64);
      double v6 = v11 / tan(v5 * 3.14159265 / 180.0);
    }
    else
    {
      double v6 = 1.79769313e308;
    }
  }
  double v12 = fabs(*(double *)(a1 + 72));
  __double2 v13 = __sincos_stret((*(double *)(a1 + 48) + -180.0) * 3.14159265 / 180.0);
  double v8 = v12 + fabs(v6 * v13.__cosval);
  double v9 = v12 + fabs(v6 * v13.__sinval);
LABEL_13:
  *a2 = v8;
  a2[1] = v9;
  return 1;
}

void partial_release_info(uint64_t a1)
{
  CFTypeID v2 = *(uint64_t **)(a1 + 40);
  if (v2) {
    CGAccessSessionRelease(v2);
  }
  CGDataProviderRelease(*(CGDataProviderRef *)a1);

  free((void *)a1);
}

uint64_t colorsync_transform_data_key_hash(_OWORD *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  long long v1 = a1[1];
  v3[0] = *a1;
  v3[1] = v1;
  return MEMORY[0x18532A6B0](v3, 32);
}

void CGContextRef.textPosition.setter(CGFloat a1, CGFloat a2)
{
  CGContextSetTextPosition(v2, a1, a2);
}

BOOL CGImageTextureDataSupportsTiledLayout(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 137) != 0;
  }
  return result;
}

uint64_t colorspace_from_ICC_data_data_make_nonpurgeable()
{
  return 1;
}

int CGFontGetAscent(CGFontRef font)
{
  font_float64x2_t info = get_font_info(font);
  if (font_info) {
    LODWORD(font_info) = font_info[3];
  }
  return (int)font_info;
}

int CGFontGetDescent(CGFontRef font)
{
  font_float64x2_t info = get_font_info(font);
  if (font_info) {
    LODWORD(font_info) = font_info[4];
  }
  return (int)font_info;
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  double y = point.y;
  double x = point.x;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  add_number_to_dict(Mutable, @"X", x);
  add_number_to_dict(Mutable, @"Y", y);
  return Mutable;
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  double height = size.height;
  double width = size.width;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  add_number_to_dict(Mutable, @"Width", width);
  add_number_to_dict(Mutable, @"Height", height);
  return Mutable;
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  double height = a1.size.height;
  double width = a1.size.width;
  double y = a1.origin.y;
  double x = a1.origin.x;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  add_number_to_dict(Mutable, @"X", x);
  add_number_to_dict(Mutable, @"Y", y);
  add_number_to_dict(Mutable, @"Width", width);
  add_number_to_dict(Mutable, @"Height", height);
  return Mutable;
}

void add_number_to_dict(__CFDictionary *a1, const void *a2, double a3)
{
  double valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

float64x2_t ripc_GetBounds(uint64_t a1)
{
  if (a1) {
    uint64_t v1 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t v2 = *(void *)(v1 + 48);
  float64x2_t result = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
  if (v2)
  {
    long long v8 = 0uLL;
    __n128 v7 = (__n128)result;
    int v4 = (*(uint64_t (**)(uint64_t, long long *))(*(void *)v2 + 72))(v2, &v8);
    float64x2_t result = (float64x2_t)v7;
    if (v4)
    {
      (*(void (**)(void, uint64_t, __n128))(**(void **)(v1 + 48) + 88))(*(void *)(v1 + 48), v1 + 40, v7);
      v5.i64[0] = (int)v8;
      v5.i64[1] = SDWORD1(v8);
      float64x2_t result = vcvtq_f64_s64(v5);
      double v6 = *(double *)(v1 + 40);
      if (v6 != 1.0) {
        return vmulq_n_f64(result, 1.0 / v6);
      }
    }
  }
  return result;
}

void ripc_Finalize(uint64_t a1)
{
  if (a1) {
    uint64_t v1 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v1 = 0;
  }
  RIPLockCacheState();
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v2 = RIPGetCacheState_cache_state;
  double v3 = *(uint64_t **)(RIPGetCacheState_cache_state + 8);
  int v4 = (uint64_t *)v3[1];
  if (v4 != v3)
  {
    uint64_t v5 = *(void *)(v1 + 208);
    uint64_t v6 = *(void *)(v5 + 16);
    do
    {
      if (!v6) {
        break;
      }
      __n128 v7 = (uint64_t *)v4[1];
      if (v4[3] == v5)
      {
        uint64_t v8 = *v4;
        if (*v4 != v5)
        {
          *(void *)(v8 + 8) = v7;
          *__n128 v7 = v8;
          double v9 = *(uint64_t ***)(v5 + 8);
          *int v4 = v5;
          v4[1] = (uint64_t)v9;
          *(void *)(v5 + 8) = v4;
          *double v9 = v4;
        }
        *(void *)(v5 + 16) = --v6;
        uint64_t v11 = *(v4 - 2);
        BOOL v10 = (void *)*(v4 - 1);
        *(void *)(v11 + 8) = v10;
        *BOOL v10 = v11;
        *(v4 - 2) = (uint64_t)(v4 - 2);
        *(v4 - 1) = (uint64_t)(v4 - 2);
        --*(void *)(v4[2] + 40);
        --*(void *)(v2 + 16);
      }
      int v4 = v7;
    }
    while (v7 != v3);
  }
  RIPUnlockCacheState();
  double v12 = *(void **)(v1 + 208);
  __double2 v13 = (void *)v12[1];
  while (v13 != v12)
  {
    uint64_t v14 = v13 - 2;
    __double2 v13 = (void *)v13[1];
    RIPCacheEntryRelease(v14);
  }
  *double v12 = v12;
  v12[1] = v12;
  while (1)
  {
    long long v15 = *(void **)(v1 + 88);
    if (!v15) {
      break;
    }
    *(void *)(v1 + 88) = *v15;
    uint64_t v16 = v15[4];
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
    }
    CGFloat v17 = (const void *)v15[1];
    if (v17) {
      CFRelease(v17);
    }
    ripc_ReleaseClipState((void **)v15 + 5);
    free(v15);
  }
  CGFloat v18 = *(_DWORD **)(v1 + 56);
  if (v18) {
    ripr_release(v18);
  }
  CGAffineTransform v19 = *(_DWORD **)(v1 + 64);
  if (v19) {
    ripr_release(v19);
  }
  uint64_t v20 = *(void *)(v1 + 48);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  uint64_t v21 = *(const void **)(v1 + 16);
  if (v21) {
    CFRelease(v21);
  }
  CGRect v22 = *(const void **)(v1 + 200);
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v23 = *(void *)(v1 + 80);
  if (v23 && *(void *)v23) {
    (*(void (**)(void))(*(void *)v23 + 24))();
  }
  free(*(void **)(v1 + 176));
  free(*(void **)(v1 + 184));
  free(*(void **)(v1 + 192));
  ripc_ReleaseClipState((void **)(v1 + 72));
  uint64_t v24 = *(void *)(v1 + 8);
  if (v24) {
    CGBitmapContextInfoRelease(v24);
  }
  free(*(void **)(v1 + 208));
  pthread_mutex_lock(&contexts_mutex);
  contexts = (uint64_t)x_list_remove((void *)contexts, v1);
  pthread_mutex_unlock(&contexts_mutex);

  free((void *)v1);
}

void CGBitmapContextInfoRelease(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = *(void (**)(void, void))(a1 + 104);
    if (v2) {
      v2(*(void *)(a1 + 112), *(void *)(a1 + 64));
    }
    CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 32));
    if (*(unsigned char *)(a1 + 100)) {
      CGBitmapFreeData(*(void *)(a1 + 64), v3, v4, v5, v6, v7, v8, v9);
    }
    uint64_t v10 = *(void *)(a1 + 120);
    if (v10) {
      CGBitmapFreeData(v10, v3, v4, v5, v6, v7, v8, v9);
    }
    free((void *)a1);
  }
}

void ripc_ReleaseClipState(void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      while (1)
      {
        uint64_t v3 = (uint64_t *)v2[4];
        if (v3 == v2 + 3) {
          break;
        }
        uint64_t v5 = *v3;
        uint64_t v4 = (void *)v3[1];
        *(void *)(v5 + 8) = v4;
        *uint64_t v4 = v5;
        *uint64_t v3 = (uint64_t)v3;
        v3[1] = (uint64_t)v3;
        uint64_t v6 = v3[11];
        if ((unint64_t)(v6 + 1) >= 2) {
          (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
        }
        free(v3);
      }
      (*(void (**)(void *))(v2[6] + 24))(v2 + 6);
      free(v2);
      *a1 = 0;
    }
  }
}

void *x_list_remove(void *result, uint64_t a2)
{
  uint64_t v4 = result;
  if (result)
  {
    uint64_t v3 = &v4;
    do
    {
      if (*result == a2)
      {
        *uint64_t v3 = result[1];
        free(result);
      }
      else
      {
        uint64_t v3 = result + 1;
      }
      float64x2_t result = (void *)*v3;
    }
    while (*v3);
    return v4;
  }
  return result;
}

uint64_t ripc_DrawPath(uint64_t a1, uint64_t a2, uint64_t a3, int a4, const CGPath *a5)
{
  if (a1) {
    uint64_t v8 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v8 = 0;
  }
  char v9 = 0;
  unsigned int v10 = 2;
  switch(a4)
  {
    case 0:
      goto LABEL_10;
    case 1:
      char v9 = 0;
      unsigned int v10 = 4;
      goto LABEL_10;
    case 2:
      char v9 = 1;
      unsigned int v10 = 1;
      goto LABEL_10;
    case 3:
      char v9 = 0;
      unsigned int v10 = 3;
      goto LABEL_10;
    case 4:
      char v9 = 0;
      unsigned int v10 = 5;
LABEL_10:
      memset(v25, 0, sizeof(v25));
      uint64_t v23 = 0;
      uint64_t result = ripc_GetRenderingState(v8, a2, a3, (uint64_t)v25);
      if (result)
      {
        v15.n128_u64[0] = *(void *)(*(void *)(a3 + 144) + 8);
        long long v22 = *(_OWORD *)(v8 + 24);
        uint64_t v16 = *(void *)(v8 + 40);
        v21[0] = v15.n128_u64[0];
        v21[1] = v16;
        char v17 = *(unsigned char *)(a2 + 81);
        if (v17) {
          char v17 = *(unsigned char *)(*(void *)(a3 + 120) + 7) & 1;
        }
        LOBYTE(v23) = v17;
        uint64_t v24 = (char *)&v25[1] + 8;
        if ((v9 & 1) == 0)
        {
          CGFloat v18 = *(_DWORD **)(v8 + 56);
          if (!v18)
          {
            CGFloat v18 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
            *(void *)CGFloat v18 = RIPRenderCreate_ripr_class;
            v18[2] = 1;
            *((void *)v18 + 2) = 0;
            *(void *)(v8 + 56) = v18;
          }
          RIPRenderPath((char *)v18, (uint64_t)v21, a5, 0);
        }
        if (v10)
        {
          memset(v20, 0, sizeof(v20));
          ripc_GetRenderStroke(a3, (uint64_t)v20, (long long *)(a3 + 24));
          CGAffineTransform v19 = *(_DWORD **)(v8 + 64);
          if (!v19)
          {
            CGAffineTransform v19 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
            *(void *)CGAffineTransform v19 = RIPRenderCreate_ripr_class;
            v19[2] = 1;
            *((void *)v19 + 2) = 0;
            *(void *)(v8 + 64) = v19;
          }
          RIPRenderPath((char *)v19, (uint64_t)v21, a5, (uint64_t)v20);
        }
        ripc_Render(v8, a2, a3, (uint64_t *)v25, v10, v12, v13, v14, v15);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 1000;
      break;
  }
  return result;
}

uint64_t ripc_GetRenderingState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t v435 = *MEMORY[0x1E4F143B8];
  uint64_t result = *(void *)(a1 + 48);
  if (!result) {
    return result;
  }
  char v9 = *(char **)(v4 + 72);
  unsigned int v10 = (unint64_t *)(v4 + 40);
  (*(void (**)(uint64_t, uint64_t))(*(void *)result + 88))(result, v4 + 40);
  uint64_t v11 = *(void *)(a3 + 112);
  uint64_t v12 = *(void *)(*(void *)(a3 + 120) + 40);
  if (v11)
  {
    int v13 = *(_DWORD *)(v11 + 4);
    if (!v9) {
      goto LABEL_11;
    }
  }
  else
  {
    int v13 = 0;
    if (!v9) {
      goto LABEL_11;
    }
  }
  if (v12) {
    int v14 = *(_DWORD *)(v12 + 16);
  }
  else {
    int v14 = 0;
  }
  if (*((_DWORD *)v9 + 1) == v14 && *(_DWORD *)v9 == v13) {
    goto LABEL_416;
  }
LABEL_11:
  long long v402 = (unint64_t *)(v4 + 40);
  __n128 v410 = 0uLL;
  if (v12)
  {
    int v15 = *(_DWORD *)(v12 + 16);
    if (v11) {
      goto LABEL_13;
    }
LABEL_16:
    int v16 = 0;
    if (a2) {
      goto LABEL_14;
    }
    goto LABEL_17;
  }
  int v15 = 0;
  if (!v11) {
    goto LABEL_16;
  }
LABEL_13:
  int v16 = *(_DWORD *)(v11 + 4);
  if (a2)
  {
LABEL_14:
    int v17 = *(_DWORD *)(a2 + 4);
    goto LABEL_20;
  }
LABEL_17:
  uint64_t v18 = *(void *)(v4 + 8);
  if (v18) {
    int v17 = *(_DWORD *)(v18 + 96);
  }
  else {
    int v17 = 3;
  }
LABEL_20:
  unsigned int v397 = v17;
  uint64_t v396 = v12;
  char v9 = *(char **)(v4 + 72);
  if (!v9)
  {
    char v9 = (char *)malloc_type_calloc(1uLL, 0xC0uLL, 0x10E004069811642uLL);
    *((void *)v9 + 3) = v9 + 24;
    *((void *)v9 + 4) = v9 + 24;
    *(_DWORD *)char v9 = ~v16;
    *((_DWORD *)v9 + 1) = ~v15;
    RIPLayerInitialize((uint64_t)(v9 + 48), v19, v20, v21, v22, v23, v24, v25);
    *((_DWORD *)v9 + 19) |= 0x80u;
    *(void *)(v4 + 72) = v9;
  }
  uint64_t v400 = a4;
  long long v412 = 0u;
  long long v413 = 0u;
  long long v411 = 0u;
  __n128 v409 = 0uLL;
  uint64_t v406 = v4;
  char v26 = (*(uint64_t (**)(void, __n128 *))(**(void **)(v4 + 48) + 72))(*(void *)(v4 + 48), &v409);
  char v30 = v26;
  uint64_t v31 = (uint64_t *)(v9 + 24);
  signed int v32 = (uint64_t *)*((void *)v9 + 4);
  if (v32 == (uint64_t *)(v9 + 24))
  {
    if ((v26 & 1) == 0) {
      goto LABEL_84;
    }
    uint64_t v398 = a3;
    uint64_t v403 = a2;
    int v33 = 0;
    uint64_t v57 = 0;
    CGFloat v37 = 0.0;
    CGFloat v36 = 0.0;
    CGFloat v35 = 0.0;
    CGFloat v34 = 0.0;
LABEL_79:
    if (v11) {
      a3 = *(void *)(v11 + 120);
    }
    else {
      LODWORD(a3) = 0;
    }
LABEL_86:
    if (*((_DWORD *)v9 + 10) >= 0x11u)
    {
      uint64_t v63 = (uint64_t *)*((void *)v9 + 3);
      RIPClipStateRemoveEntry((uint64_t)v9, v63);
      if (v33 == v63) {
        int v33 = 0;
      }
    }
    uint64_t v64 = (char *)malloc_type_malloc(4 * (int)a3 + 104, 0xAA9B669uLL);
    size_t v38 = (uint64_t *)v64;
    *(void *)uint64_t v64 = v64;
    *((void *)v64 + 1) = v64;
    *((_DWORD *)v64 + 4) = v15;
    *((_DWORD *)v64 + 5) = v16;
    *(__n128 *)(v64 + 24) = v409;
    *((_DWORD *)v64 + 24) = a3;
    if (v57)
    {
      *((CGFloat *)v64 + 7) = v34;
      *((CGFloat *)v64 + 8) = v35;
      *((CGFloat *)v64 + 9) = v36;
      *((CGFloat *)v64 + 10) = v37;
      unsigned int v10 = v402;
      if (a3) {
        memcpy(v64 + 100, v57, 4 * a3);
      }
      if (!v33) {
        goto LABEL_100;
      }
    }
    else
    {
      if (v11)
      {
        uint64_t v69 = (const CGRect *)(v11 + 16);
        p_CGFloat y = (CGFloat *)(v11 + 24);
        p_std::string::size_type size = (CGSize *)(v11 + 32);
        p_CGFloat height = (CGFloat *)(v11 + 40);
      }
      else
      {
        uint64_t v69 = &CGRectInfinite;
        p_CGFloat height = &CGRectInfinite.size.height;
        p_CGFloat y = &CGRectInfinite.origin.y;
        p_std::string::size_type size = &CGRectInfinite.size;
      }
      unsigned int v10 = v402;
      uint64_t v73 = *(void *)p_height;
      uint64_t v74 = *(void *)p_y;
      CGFloat width = p_size->width;
      *((void *)v64 + 7) = *(void *)&v69->origin.x;
      *((void *)v64 + 8) = v74;
      *((CGFloat *)v64 + 9) = width;
      *((void *)v64 + 10) = v73;
      ripc_GetClipStackData((void *)v11, a3, (_DWORD *)v64 + 25, a3);
      if (!v33) {
        goto LABEL_100;
      }
    }
    uint64_t v76 = v33[11];
    if (v76)
    {
      if (v76 == -1)
      {
LABEL_100:
        v38[11] = 0;
        __n128 v29 = v409;
LABEL_103:
        *(__n128 *)(v38 + 5) = v29;
        uint64_t v77 = (uint64_t *)*((void *)v9 + 4);
        uint64_t v78 = *v38;
        *((void *)v9 + 4) = v38;
        *size_t v38 = (uint64_t)v31;
        *uint64_t v77 = v78;
        *(void *)(v78 + 8) = v77;
        ++*((_DWORD *)v9 + 10);
        uint64_t v79 = *(unsigned __int8 *)(v403 + 81);
        double v81 = *((double *)v38 + 7);
        double v80 = *((double *)v38 + 8);
        double v82 = *((double *)v38 + 9);
        uint64_t v4 = v406;
        if (v81 == -8.98846567e307
          && v80 == -8.98846567e307
          && v82 == 1.79769313e308
          && *((double *)v38 + 10) == 1.79769313e308)
        {
          ClipStackDatdouble a = v57;
          unsigned int v389 = 0;
          unint64_t v83 = (int *)&v409;
          *((void *)&v413 + 1) = &v409;
          v29.n128_u64[0] = *v10;
        }
        else
        {
          v29.n128_u64[0] = *v10;
          double v84 = *(double *)v10 * v81;
          double v85 = v84 + *(double *)v10 * v82;
          double v86 = -4194303.0;
          if (v84 < -4194303.0) {
            double v84 = -4194303.0;
          }
          if (v85 > 4194303.0) {
            double v85 = 4194303.0;
          }
          if (v84 >= v85) {
            goto LABEL_133;
          }
          double v87 = v29.n128_f64[0] * v80;
          if (v87 >= -4194303.0) {
            double v86 = v87;
          }
          double v88 = v87 + v29.n128_f64[0] * *((double *)v38 + 10) <= 4194303.0
              ? v87 + v29.n128_f64[0] * *((double *)v38 + 10)
              : 4194303.0;
          if (v86 >= v88) {
            goto LABEL_133;
          }
          int v89 = llround(v84 * 256.0);
          int v90 = llround(v86 * 256.0);
          int v91 = llround(v85 * 256.0);
          signed int v92 = llround(v88 * 256.0);
          if ((signed __int32)(v409.n128_u32[0] << 8) > v89) {
            int v89 = v409.n128_u32[0] << 8;
          }
          if ((signed __int32)(v409.n128_u32[1] << 8) > v90) {
            int v90 = v409.n128_u32[1] << 8;
          }
          int v93 = (signed __int32)((v409.n128_u32[2] + v409.n128_u32[0]) << 8) >= v91
              ? v91
              : (v409.n128_u32[2] + v409.n128_u32[0]) << 8;
          int v94 = (signed __int32)((v409.n128_u32[1] + v409.n128_u32[3]) << 8) >= v92
              ? v92
              : (v409.n128_u32[1] + v409.n128_u32[3]) << 8;
          if (v89 >= v93 || v90 >= v94)
          {
LABEL_133:
            uint64_t v96 = v38[11];
            if (v96) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v96 + 24))(v96, v79);
            }
            v38[11] = 0;
            v38[5] = 0;
            v38[6] = 0;
            a2 = v403;
            a3 = v398;
LABEL_407:
            if (v57 && v57 != __dst) {
              free(v57);
            }
            *((_DWORD *)v9 + 1) = *((_DWORD *)v38 + 4);
            *(_DWORD *)char v9 = *((_DWORD *)v38 + 5);
            uint64_t v356 = v38[11];
            *((void *)v9 + 1) = v356;
            if (v356)
            {
              if (v356 == -1)
              {
                *((void *)v9 + 1) = 0;
                *((void *)v9 + 2) = 0;
              }
              else
              {
                *((void *)v9 + 2) = v38 + 5;
              }
            }
            else
            {
              RIPLayerReplace((uint64_t)(v9 + 48), (uint64_t)(v38 + 5), 0, 0, 0, 0, v27, v28, v29);
              *((void *)v9 + 1) = v9 + 48;
              *((void *)v9 + 2) = v38 + 5;
              uint64_t v4 = v406;
            }
            a4 = v400;
LABEL_416:
            uint64_t v357 = *((void *)v9 + 1);
            *(void *)a4 = v357;
            if (v357)
            {
              int v358 = (uint64_t *)*((void *)v9 + 2);
              uint64_t v359 = v358[1];
              if ((int)v359 < 1 || (int)HIDWORD(v358[1]) < 1) {
                return 0;
              }
              v361.i64[0] = *v358;
              *(void *)(a4 + 8) = *v358;
              *(void *)(a4 + 16) = v359;
              v361.i64[1] = v359;
            }
            else
            {
              uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 48) + 72))(*(void *)(v4 + 48), a4 + 8);
              if (!result) {
                return result;
              }
              int32x4_t v361 = *(int32x4_t *)(a4 + 8);
            }
            uint64_t v362 = *(void *)(v4 + 80);
            uint64_t v363 = *(void *)(*(void *)(a3 + 120) + 16);
            if (!v363)
            {
              if (v362)
              {
                if (*(void *)v362)
                {
                  int32x4_t v408 = v361;
                  (*(void (**)(void))(*(void *)v362 + 24))(*(void *)(v4 + 80));
                  int32x4_t v361 = v408;
                }
                uint64_t v362 = 0;
                *(void *)(v4 + 80) = 0;
              }
              goto LABEL_446;
            }
            int v364 = *(_DWORD *)(v363 + 16);
            long long v365 = *(_OWORD *)(a2 + 40);
            *(_OWORD *)&__s2.double a = *(_OWORD *)(a2 + 24);
            *(_OWORD *)&__s2.double c = v365;
            __n128 v366 = *(__n128 *)(a2 + 56);
            *(__n128 *)&__s2.double tx = v366;
            v366.n128_u64[0] = *v10;
            if (*(double *)v10 != 1.0)
            {
              *(float64x2_t *)&__s2.double a = vmulq_n_f64(*(float64x2_t *)&__s2.a, v366.n128_f64[0]);
              *(float64x2_t *)&__s2.double c = vmulq_n_f64(*(float64x2_t *)&__s2.c, v366.n128_f64[0]);
              *(float64x2_t *)&__s2.double tx = vmulq_n_f64(*(float64x2_t *)&__s2.tx, v366.n128_f64[0]);
            }
            int32x4_t v407 = v361;
            if (v362)
            {
              if (*(void *)(v362 + 16) == v363 && *(_DWORD *)(v362 + 24) == v364)
              {
                if ((*(unsigned char *)(v362 + 12) & 1) == 0
                  || (v405 = v366, v367 = memcmp((const void *)(v362 + 32), &__s2, 0x30uLL), __n128 v366 = v405, !v367))
                {
                  uint64_t v369 = v4;
                  goto LABEL_438;
                }
              }
              if (*(void *)v362)
              {
                (*(void (**)(uint64_t, __n128))(*(void *)v362 + 24))(v362, v366);
                v366.n128_u64[0] = *v10;
              }
              *(void *)(v4 + 80) = 0;
            }
            uint64_t v368 = rips_Create(v366, (uint64_t)&_rips_class, v363);
            uint64_t v362 = v368;
            if (!v368) {
              goto LABEL_445;
            }
            uint64_t v369 = v4;
            *(void *)(v4 + 80) = v368;
            *(void *)(v368 + 16) = v363;
            *(_DWORD *)(v368 + 24) = v364;
            long long v371 = *(_OWORD *)&__s2.c;
            long long v370 = *(_OWORD *)&__s2.tx;
            *(_OWORD *)(v368 + 32) = *(_OWORD *)&__s2.a;
            *(_OWORD *)(v368 + 48) = v371;
            *(_OWORD *)(v368 + 64) = v370;
LABEL_438:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v362 + 40))(v362, a4 + 24))
            {
              int32x4_t v361 = vaddq_s32(*(int32x4_t *)(a4 + 24), v407);
              uint64_t v4 = v369;
LABEL_446:
              *(int32x4_t *)(a4 + 24) = v361;
              *(void *)(a4 + 40) = v362;
              ripc_InitializeColorTransform(v4);
              if (a2)
              {
                uint64_t v372 = *(void *)(v4 + 48);
                if (v372) {
                  *(_DWORD *)(v372 + 52) = *(_DWORD *)(a2 + 4);
                }
              }
              return 1;
            }
            uint64_t v4 = v369;
LABEL_445:
            int32x4_t v361 = v407;
            goto LABEL_446;
          }
          ClipStackDatdouble a = v57;
          int v97 = ((v93 + 255) >> 8) - (v89 >> 8);
          int v98 = ((v94 + 255) >> 8) - (v90 >> 8);
          int v99 = ((((v93 + 255) & 0xFFFF00) - v93) << 8) | (v89 << 24) | v90 | ((((v94 + 255) & 0xFF00)
                                                                                               - v94) << 16);
          int v100 = v89 >> 8;
          int v101 = v90 >> 8;
          if (!*(unsigned char *)(v403 + 81)) {
            int v99 = 0;
          }
          unsigned int v389 = v99;
          v410.n128_u64[0] = __PAIR64__(v101, v100);
          v410.n128_u64[1] = __PAIR64__(v98, v97);
          unint64_t v83 = (int *)&v410;
          *((void *)&v413 + 1) = &v410;
        }
        long long v412 = *(_OWORD *)(v406 + 24);
        *((void *)&v411 + 1) = v29.n128_u64[0];
        if ((int)a3 >= 1)
        {
          unint64_t v102 = 0;
          long long v103 = (uint64_t *)(v11 + 128);
          int v104 = (char *)v38 + 100;
          uint64_t v105 = (uint64_t)v33 + 100;
          int v393 = v79;
          do
          {
            if (v33 && v102 < *((unsigned int *)v33 + 24))
            {
              if (*(_DWORD *)(v105 + 4 * v102) == *(_DWORD *)&v104[4 * v102] || v11 == 0) {
                goto LABEL_220;
              }
            }
            else if (!v11)
            {
              goto LABEL_220;
            }
            if (*(void *)(v11 + 120) > v102)
            {
              int v107 = v103;
              if (*(void *)(v11 + 112) != 3) {
                int v107 = (uint64_t *)(*(void *)(v11 + 128) + 8 * v102);
              }
              uint64_t v108 = *v107;
              if (*v107)
              {
                v29.n128_u64[0] = 1.0;
                if (*(unsigned char *)(v108 + 8) == 2) {
                  v29.n128_u64[0] = *(void *)(v108 + 32);
                }
                *(void *)&long long v411 = v29.n128_u64[0];
                if (v79) {
                  BOOL v109 = *(unsigned char *)(v108 + 10) != 0;
                }
                else {
                  BOOL v109 = 0;
                }
                LOBYTE(v413) = v109;
                int v110 = *(unsigned __int8 *)(v108 + 8);
                switch((char)v110)
                {
                  case 0:
                    memset(&__s2, 0, 32);
                    uint64_t v111 = &CGRectNull.size.height;
                    uint64_t v112 = &CGRectNull.origin.y;
                    if (*(unsigned char *)(v108 + 8)) {
                      uint64_t v113 = &CGRectNull.size;
                    }
                    else {
                      uint64_t v113 = (CGSize *)(v108 + 40);
                    }
                    if (*(unsigned char *)(v108 + 8))
                    {
                      uint64_t v114 = &CGRectNull;
                    }
                    else
                    {
                      uint64_t v112 = (CGFloat *)(v108 + 32);
                      uint64_t v114 = (const CGRect *)(v108 + 24);
                    }
                    if (!*(unsigned char *)(v108 + 8)) {
                      uint64_t v111 = (CGFloat *)(v108 + 48);
                    }
                    CGFloat v115 = *v111;
                    CGFloat v116 = *v112;
                    CGFloat v117 = v113->width;
                    __s2.double a = v114->origin.x;
                    __s2.double b = v116;
                    __s2.double c = v117;
                    __s2.double d = v115;
                    int v118 = *(_DWORD **)(v4 + 56);
                    if (!v118)
                    {
                      int v118 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
                      *(void *)int v118 = RIPRenderCreate_ripr_class;
                      v118[2] = 1;
                      *((void *)v118 + 2) = 0;
                      *(void *)(v4 + 56) = v118;
                    }
                    RIPRenderRectangles(v118, (uint64_t)&v411, &CGAffineTransformIdentity.a, &__s2.a, 1, 0);
                    goto LABEL_171;
                  case 2:
                    if (v110 == 2) {
                      uint64_t v125 = *(const CGPath **)(v108 + 24);
                    }
                    else {
                      uint64_t v125 = 0;
                    }
                    long long v426 = 0u;
                    long long v427 = 0u;
                    long long v425 = 0u;
                    memset(&__s2, 0, sizeof(__s2));
                    if (*(unsigned __int8 *)(v108 + 9) << 8 == 512 && (uint64_t v147 = *(void *)(v108 + 16)) != 0)
                    {
                      long long v148 = *(_OWORD *)(v147 + 8);
                      long long v149 = *(_OWORD *)(v147 + 40);
                      *(_OWORD *)&__s2.double c = *(_OWORD *)(v147 + 24);
                      *(_OWORD *)&__s2.double tx = v149;
                      *(_OWORD *)&__s2.double a = v148;
                      *(void *)&long long v425 = *(void *)(v147 + 56);
                      int v150 = *(__int16 *)(v147 + 64);
                      DWORD2(v425) = (char)v150;
                      HIDWORD(v425) = v150 >> 8;
                      *(void *)&long long v426 = *(void *)(v147 + 72);
                      uint64_t v151 = *(void *)(v147 + 80);
                      if (v151)
                      {
                        long long v427 = *(_OWORD *)(v151 + 8);
                        v151 += 24;
                      }
                      *((void *)&v426 + 1) = v151;
                      if (v79) {
                        BOOL v152 = *(unsigned char *)(v147 + 67) != 0;
                      }
                      else {
                        BOOL v152 = 0;
                      }
                      LOBYTE(v413) = v152;
                      *(void *)&long long v411 = *(void *)(v147 + 88);
                      p_s2 = &__s2;
                    }
                    else
                    {
                      p_s2 = 0;
                    }
                    uint64_t v154 = *(_DWORD **)(v406 + 56);
                    if (!v154)
                    {
                      uint64_t v154 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
                      *(void *)uint64_t v154 = RIPRenderCreate_ripr_class;
                      v154[2] = 1;
                      *((void *)v154 + 2) = 0;
                      *(void *)(v406 + 56) = v154;
                    }
                    RIPRenderPath((char *)v154, (uint64_t)&v411, v125, (uint64_t)p_s2);
                    BOOL v124 = *(unsigned __int8 *)(v108 + 9) << 8 == 256;
                    uint64_t v4 = v406;
                    goto LABEL_212;
                  case 3:
                    if (v110 != 3) {
                      break;
                    }
                    uint64_t v126 = *(void *)(v108 + 24);
                    if (!v126) {
                      break;
                    }
                    uint64_t v127 = *(void *)(v126 + 56);
                    if (!v127) {
                      goto LABEL_255;
                    }
                    unint64_t v417 = 0;
                    unint64_t v418 = 0;
                    CGImageRef image = (CGImageRef)v127;
                    if ((ripc_GetImageSize(v127, &v418, &v417) & 1) == 0) {
                      goto LABEL_255;
                    }
                    unint64_t v384 = v418;
                    unint64_t v385 = v417;
                    unint64_t v415 = v417;
                    unint64_t v416 = v418;
                    float64x2_t v429 = 0u;
                    float64x2_t v430 = 0u;
                    float64x2_t v428 = 0u;
                    float64x2_t v128 = *(float64x2_t *)(v126 + 8);
                    float64x2_t v129 = *(float64x2_t *)(v126 + 40);
                    float64x2_t v429 = *(float64x2_t *)(v126 + 24);
                    float64x2_t v430 = v129;
                    double v130 = *(double *)v402;
                    _ZF = *(double *)v402 == 1.0;
                    float64x2_t v428 = v128;
                    if (!_ZF)
                    {
                      float64x2_t v428 = vmulq_n_f64(v428, v130);
                      float64x2_t v429 = vmulq_n_f64(v429, v130);
                      float64x2_t v430 = vmulq_n_f64(v430, v130);
                    }
                    double v131 = *(double *)(v126 + 64);
                    double v132 = *(double *)(v126 + 72);
                    double v133 = *(double *)(v126 + 80);
                    double v134 = *(double *)(v126 + 88);
                    if (v133 < 0.0 || v134 < 0.0) {
                      *(CGRect *)&double v131 = CGRectStandardize(*(CGRect *)&v131);
                    }
                    double v135 = v134 * v429.f64[0] + v428.f64[0] * 0.0;
                    double v136 = v134 * v429.f64[1] + v428.f64[1] * 0.0;
                    float64_t v137 = v430.f64[0] + v429.f64[0] * v132 + v131 * v428.f64[0];
                    float64_t v138 = v429.f64[1] * v132 + v131 * v428.f64[1];
                    v428.f64[0] = v429.f64[0] * 0.0 + v133 * v428.f64[0];
                    v428.f64[1] = v429.f64[1] * 0.0 + v133 * v428.f64[1];
                    v429.f64[0] = v135;
                    v429.f64[1] = v136;
                    v430.f64[0] = v137;
                    v430.f64[1] = v138 + v430.f64[1];
                    long long v421 = 0uLL;
                    uint64_t v419 = 0;
                    uint64_t v420 = 0;
                    v414[0] = 0;
                    v414[1] = 0;
                    ImageTransformatiounint64_t n = ripc_GetImageTransformation(image, v83, v384, v385, 0, v428.f64, (uint64_t)&v421, (int *)&v419, (uint64_t)v414);
                    if (!ImageTransformation) {
                      goto LABEL_255;
                    }
                    __int32 RenderingIntent = CGImageGetRenderingIntent(image);
                    if (!RenderingIntent)
                    {
                      unsigned int v140 = *(_DWORD *)(*(void *)(v398 + 120) + 4);
                      int v141 = v140 << 12;
                      if (((v140 >> 20) & 0xF) != 0) {
                        int v142 = v140 << 8;
                      }
                      else {
                        int v142 = v140 << 12;
                      }
                      if (!(v142 >> 28)) {
                        int v142 = v141;
                      }
                      __int32 RenderingIntent = v142 >> 28;
                    }
                    unsigned int v382 = RenderingIntent;
                    if (ImageTransformation >= 4)
                    {
                      BOOL ShouldInterpolate = CGImageGetShouldInterpolate(image);
                      ImageInterpolatiounint64_t n = ripc_GetImageInterpolation(v403, *(_DWORD *)(*(void *)(v398 + 120) + 4), ShouldInterpolate);
                      int v381 = ImageInterpolation;
                      if (ImageInterpolation >= 3)
                      {
                        unsigned int v169 = ImageInterpolation;
                        if ((ImageTransformation & 2) != 0) {
                          uint64_t v170 = 0;
                        }
                        else {
                          uint64_t v170 = (int *)&v421;
                        }
                        if (ripc_GetImageInterpolationSize(v428.f64, (int64_t *)&v416, &v415, v170))uint64_t v143 = v169; {
                        else
                        }
                          uint64_t v143 = 1;
                      }
                      else
                      {
                        uint64_t v143 = 1;
                      }
                    }
                    else
                    {
                      uint64_t v143 = 1;
                      int v381 = 1;
                    }
                    CGContextRef v171 = CGBitmapContextCreateWithData(0, v384, v385, 8uLL, 0, 0, 7u, 0, 0);
                    CGContextErase((uint64_t)v171, v172, v173, v174, v175, v176, v177, v178);
                    uint64_t Delegate = CGContextGetDelegate((uint64_t)v171, v179, v180, v181, v182, v183, v184, v185);
                    if (Delegate) {
                      uint64_t Delegate = *(void *)(Delegate + 288);
                    }
                    if ((ImageTransformation & 2) != 0) {
                      uint64_t v187 = 0;
                    }
                    else {
                      uint64_t v187 = &v421;
                    }
                    uint64_t v192 = (CGImage *)ripc_AcquireRIPImageData(Delegate, image, v416, v415, (uint64_t)v187, 0, v143, v382);
                    if (v171) {
                      CFRelease(v171);
                    }
                    if (!v192) {
                      goto LABEL_255;
                    }
                    if (*(unsigned char *)(v403 + 81) && (*(unsigned char *)(*(void *)(v398 + 120) + 7) & 1) != 0) {
                      __int16 v193 = *(_WORD *)(v4 + 108) | 0xFF00;
                    }
                    else {
                      __int16 v193 = *(unsigned __int8 *)(v4 + 108);
                    }
                    *(_WORD *)(v4 + 108) = v193;
                    *(_WORD *)(v4 + 108) = v193 & 0xFF00 | *(unsigned __int8 *)(v403 + 82);
                    *(_DWORD *)(v4 + 112) = (int)(*(_DWORD *)(*(void *)(v398 + 120) + 4) << 12) >> 28;
                    imagedouble a = v192;
                    if (*((void *)v192 + 4) && !*((void *)v192 + 11)) {
                      dispatch_once_t v194 = RIPGetDepthForLayerFormat(1u, v188, v189, v190, v191, v66, v27, v28);
                    }
                    else {
                      dispatch_once_t v194 = 0;
                    }
                    uint64_t v195 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)v414, 0, v194, *(unsigned int *)(v403 + 4), v66, v27, v28);
                    if (!v195)
                    {
                      ripc_ReleaseRIPImageData(imagea);
LABEL_255:
                      unsigned __int8 v162 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, 0, 0, 0, v397, v66, v27, v28);
                      goto LABEL_217;
                    }
                    unsigned __int8 v162 = v195;
                    *(void *)&long long v425 = 0;
                    memset(&__s2, 0, sizeof(__s2));
                    *(_DWORD *)(v4 + 104) = 1;
                    if (ImageTransformation >= 4) {
                      uint64_t v198 = &v428;
                    }
                    else {
                      uint64_t v198 = 0;
                    }
                    *(void *)(v4 + 152) = 0x3FF0000000000000;
                    ripc_InitializeImage((uint64_t)&__s2, (uint64_t)&v419, (double *)imagea, v381, v384, v385, v198->f64, 0, 0.0, v196, v197);
                    RIPLayerBltImage((uint64_t)v162, 0, (uint64_t)v414, (uint64_t)&__s2, v406 + 104, v199, v200, v201);
                    if (v194) {
                      RIPLayerCoverage((uint64_t)v162, v202, v203, v204, v205, v206, v207, v208);
                    }
                    ripc_ReleaseRIPImageData(imagea);
                    uint64_t v215 = (void *)v38[11];
                    if (v215)
                    {
                      RIPLayerIntersect(v162, v215, v209, v210, v211, v212, v213, v214);
LABEL_217:
                      uint64_t v164 = v38[11];
                      if (v164) {
                        (*(void (**)(uint64_t))(*(void *)v164 + 24))(v164);
                      }
                    }
                    v38[11] = (uint64_t)v162;
                    uint64_t v165 = *(void (**)(char *, uint64_t *))(*(void *)v162 + 72);
                    uint64_t v166 = v162;
                    unint64_t v83 = (int *)(v38 + 5);
                    v165(v166, v38 + 5);
                    *((void *)&v413 + 1) = v38 + 5;
                    LODWORD(v79) = v393;
                    int v104 = (char *)v38 + 100;
                    uint64_t v105 = (uint64_t)v33 + 100;
                    break;
                  case 4:
                    if (v110 != 4) {
                      break;
                    }
                    uint64_t v144 = *(void *)(v108 + 24);
                    if (!v144) {
                      break;
                    }
                    Path = CGTextClippingCreatePath(v144);
                    double v146 = *(_DWORD **)(v4 + 56);
                    if (!v146)
                    {
                      double v146 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
                      *(void *)double v146 = RIPRenderCreate_ripr_class;
                      v146[2] = 1;
                      *((void *)v146 + 2) = 0;
                      *(void *)(v4 + 56) = v146;
                    }
                    RIPRenderPath((char *)v146, (uint64_t)&v411, Path, 0);
                    if (Path) {
                      CFRelease(Path);
                    }
LABEL_171:
                    BOOL v124 = 0;
LABEL_212:
                    uint64_t v155 = RIPRenderCoverage(*(void *)(v4 + 56), 0, *((int **)&v413 + 1), v124, v119, v120, v121, v122, v123);
                    if (v155)
                    {
                      unsigned __int8 v162 = v155;
                      unint64_t v163 = (void *)v38[11];
                      if (v163) {
                        RIPLayerIntersect(v155, v163, v156, v157, v158, v159, v160, v161);
                      }
                    }
                    else
                    {
                      unsigned __int8 v162 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, 0, 0, 0, v397, v159, v160, v161);
                    }
                    ripr_Finish(*(void *)(v4 + 56));
                    goto LABEL_217;
                  default:
                    break;
                }
              }
            }
LABEL_220:
            ++v102;
            ++v103;
          }
          while (a3 != v102);
        }
        if (v389)
        {
          uint64_t v216 = v38[11];
          unsigned int v10 = v402;
          a2 = v403;
          a3 = v398;
          if (!v216)
          {
            v38[11] = (uint64_t)RIPLayerCreateWithData((uint64_t *)&v410, 0, 0, 0, 0, v389, 0, v397);
            __n128 v29 = v410;
            *(__n128 *)(v38 + 5) = v410;
            goto LABEL_277;
          }
          uint64_t v218 = (__n128 *)(v38 + 5);
          int v217 = *((_DWORD *)v38 + 10);
          if (v217 <= v410.n128_i32[0]
            || (int v219 = *((_DWORD *)v38 + 11), v219 <= v410.n128_i32[1])
            || *((_DWORD *)v38 + 12) + v217 >= (signed __int32)(v410.n128_u32[2] + v410.n128_u32[0])
            || *((_DWORD *)v38 + 13) + v219 >= (signed __int32)(v410.n128_u32[3] + v410.n128_u32[1]))
          {
            int v220 = v389;
LABEL_263:
            uint64_t v224 = RIPLayerClip(v216, (signed int *)&v410, v220, v397, v65, v389, v27, v28);
            if (!v224) {
              uint64_t v224 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, 0, 0, 0, v397, v221, v222, v223);
            }
            int v225 = (char *)v38[11];
            if (v224 != v225 && v225) {
              (*(void (**)(char *))(*(void *)v225 + 24))(v225);
            }
            v38[11] = (uint64_t)v224;
            (*(void (**)(char *, __n128 *))(*(void *)v224 + 72))(v224, v218);
            uint64_t v4 = v406;
          }
        }
        else
        {
          unsigned int v10 = v402;
          a2 = v403;
          a3 = v398;
          if (v83 == (int *)&v410)
          {
            uint64_t v216 = v38[11];
            uint64_t v218 = (__n128 *)(v38 + 5);
            if (!v216)
            {
              __n128 v29 = v410;
              *uint64_t v218 = v410;
              goto LABEL_277;
            }
            if ((signed __int32)v218->n128_u32[0] < v410.n128_i32[0]
              || (int v226 = *((_DWORD *)v38 + 11), v226 < v410.n128_i32[1])
              || (signed __int32)(*((_DWORD *)v38 + 12) + v218->n128_u32[0]) > (signed __int32)(v410.n128_u32[2]
                                                                                              + v410.n128_u32[0])
              || *((_DWORD *)v38 + 13) + v226 > (signed __int32)(v410.n128_u32[3] + v410.n128_u32[1]))
            {
              int v220 = 0;
              goto LABEL_263;
            }
          }
        }
LABEL_277:
        uint64_t v227 = v396;
        if (!v396 || *((int *)v38 + 12) < 1 || *((int *)v38 + 13) < 1)
        {
LABEL_404:
          uint64_t v355 = v38[11];
          if (v355)
          {
            *(_DWORD *)(v355 + 28) |= 0x80u;
LABEL_406:
            uint64_t v57 = ClipStackData;
          }
          else
          {
            uint64_t v57 = ClipStackData;
            if (*((__n128 **)&v413 + 1) == &v409) {
              v38[11] = -1;
            }
          }
          goto LABEL_407;
        }
        LODWORD(v416) = 1065353216;
        unint64_t v228 = (int *)*((void *)&v413 + 1);
        long long v421 = 0u;
        long long v422 = 0u;
        uint64_t v419 = 0;
        uint64_t v420 = 0;
        LODWORD(v414[0]) = 0;
        v67.f64[0] = *(float64_t *)(v4 + 40);
        v68.f64[0] = 1.0;
        __asm { FMOV            V5.2D, #1.0 }
        float64x2_t v233 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vceqq_f64(v67, v68)).i64[0], 0), (int8x16_t)vdupq_lane_s64(*(uint64_t *)&v67.f64[0], 0), _Q5);
        float64x2_t v234 = vmulq_f64(*(float64x2_t *)(v396 + 24), v233);
        float64x2_t v235 = vmulq_f64(*(float64x2_t *)(v396 + 40), v233);
        float64x2_t v236 = vmulq_f64(*(float64x2_t *)(v396 + 56), v233);
        uint64_t v237 = *(void *)(v396 + 72);
        uint64_t v238 = *(void *)(v396 + 80);
        uint64_t v239 = *(void *)(v396 + 88);
        v233.f64[0] = *(float64_t *)(v396 + 96);
        float64x2_t v394 = v235;
        float64x2_t v395 = v234;
        *(float64x2_t *)&__s2.double a = v234;
        *(float64x2_t *)&__s2.double c = v235;
        float64x2_t v392 = v236;
        *(float64x2_t *)&__s2.double tx = v236;
        CGRect v438 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v233 - 24), &__s2);
        CGFloat x = v438.origin.x;
        CGFloat y = v438.origin.y;
        CGFloat v242 = v438.size.width;
        CGFloat height = v438.size.height;
        unint64_t v244 = *(void *)(v396 + 104);
        if (v244)
        {
          Components = CGColorGetComponents(*(CGColorRef *)(v396 + 104));
          if ((v244 & 0x8000000000000000) != 0) {
            CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(v244, v245, v246, v247, v248, v249, v250, v251);
          }
          else {
            CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(v244 + 24);
          }
          if (ColorSpace)
          {
            uint64_t v255 = *(void *)(*((void *)ColorSpace + 3) + 48);
            if (v255)
            {
              uint64_t v256 = &__s2;
              do
              {
                double v257 = *Components++;
                float v258 = v257;
                *(float *)&v256->double a = v258;
                uint64_t v256 = (CGAffineTransform *)((char *)v256 + 4);
                --v255;
              }
              while (v255);
            }
          }
          DeviceGraCGFloat y = CGColorSpaceCreateDeviceGray();
          CGRect v254 = (void *)color_transform_create(DeviceGray, 0);
          CGColorSpaceRelease(DeviceGray);
          if ((v244 & 0x8000000000000000) != 0) {
            CGColorSpaceRef v267 = CGTaggedColorGetColorSpace(v244, v260, v261, v262, v263, v264, v265, v266);
          }
          else {
            CGColorSpaceRef v267 = *(CGColorSpaceRef *)(v244 + 24);
          }
          uint64_t v4 = v406;
          uint64_t v227 = v396;
          CGColorTransformConvertColorFloatComponents(v254, v267, 0, (uint64_t)&__s2, (float *)v414, 1);
        }
        else
        {
          CGRect v254 = 0;
          LODWORD(v414[0]) = 0;
        }
        uint64_t v399 = a3;
        uint64_t v268 = *(void *)(v227 + 112);
        if (!v268 || *(double (**)(uint64_t, double *, void *))(v268 + 72) == evaluate_identity)
        {
          uint64_t v391 = 0;
          LODWORD(v416) = v414[0];
          char v269 = 1;
        }
        else
        {
          uint64_t v391 = *(void *)(v227 + 112);
          function_evaluate_float(v268, (float *)v414, (float *)&v416, (__n128)v438.origin);
          char v269 = 0;
        }
        v443.origin.CGFloat x = (double)*v228;
        v443.origin.CGFloat y = (double)v228[1];
        v443.size.CGFloat width = (double)v228[2];
        v443.size.CGFloat height = (double)v228[3];
        v439.origin.CGFloat x = x;
        v439.origin.CGFloat y = y;
        v439.size.CGFloat width = v242;
        v439.size.CGFloat height = height;
        *(CGRect *)v29.n128_u64 = CGRectIntersection(v439, v443);
        *(void *)&long long v421 = v29.n128_u64[0];
        *((void *)&v421 + 1) = *(void *)&v440.origin.y;
        *(CGFloat *)&long long v422 = v440.size.width;
        *((void *)&v422 + 1) = *(void *)&v440.size.height;
        BOOL v275 = v29.n128_f64[0] == INFINITY || v440.origin.y == INFINITY;
        if (v275 || v440.size.width == 0.0 || v440.size.height == 0.0)
        {
          if (!v254)
          {
            uint64_t v280 = v38 + 5;
            goto LABEL_397;
          }
          long long v279 = 0;
          uint64_t v280 = v38 + 5;
LABEL_393:
          CFRelease(v254);
LABEL_394:
          if (v279)
          {
            CGDataProviderRef v352 = (void *)v38[11];
            if (!v352)
            {
LABEL_402:
              v38[11] = (uint64_t)v279;
              (*(void (**)(char *, uint64_t *))(*(void *)v279 + 72))(v279, v280);
LABEL_403:
              *((void *)&v413 + 1) = v280;
              goto LABEL_404;
            }
            RIPLayerIntersect(v279, v352, v295, v296, v297, v274, v27, v28);
            goto LABEL_399;
          }
LABEL_397:
          float v353 = *(float *)&v416;
          if (*(float *)&v416 >= 0.0039062)
          {
            v29.n128_u32[0] = 1065287680;
            if (*(float *)&v416 >= 0.99609) {
              goto LABEL_403;
            }
            uint64_t v373 = a2;
            long long v377 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
            *long long v377 = &ripc_class;
            v377[1] = 0;
            v377[2] = 0;
            v377[3] = 0x3F80000000000000;
            *((_DWORD *)v377 + 39) = 1065353216;
            *(double *)(v4 + 152) = v353;
            long long v279 = (char *)v38[11];
            if (v279)
            {
              int v378 = 7;
            }
            else
            {
              long long v279 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, *((uint64_t *)&v413 + 1), 0, 0, v397, v374, v375, v376);
              int v378 = 1;
            }
            *(_DWORD *)(v4 + 104) = v378;
            RIPLayerBltShape((int *)v279, 0, 0, 0, (uint64_t)v377, 0, v4 + 104, v376);
            free(v377);
            unint64_t v354 = (char *)v38[11];
            a2 = v373;
            a3 = v399;
            uint64_t v280 = v38 + 5;
            if (v279 == v354) {
              goto LABEL_403;
            }
            goto LABEL_400;
          }
          long long v279 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, 0, 0, 0, v397, v274, v27, v28);
LABEL_399:
          unint64_t v354 = (char *)v38[11];
LABEL_400:
          if (v354) {
            (*(void (**)(char *))(*(void *)v354 + 24))(v354);
          }
          goto LABEL_402;
        }
        double v276 = v29.n128_f64[0] + v440.size.width;
        double v277 = v29.n128_f64[0] + 0.0;
        if (v29.n128_f64[0] + 0.0 <= 1073741820.0)
        {
          unsigned int v281 = vcvtmd_s64_f64(v277);
          if (v277 >= -1073741820.0) {
            int v278 = v281;
          }
          else {
            int v278 = -1073741823;
          }
        }
        else
        {
          int v278 = 0x3FFFFFFF;
        }
        LODWORD(v419) = v278;
        if (v276 <= 1073741820.0)
        {
          unsigned int v283 = vcvtpd_s64_f64(v276);
          if (v276 >= -1073741820.0) {
            int v282 = v283;
          }
          else {
            int v282 = -1073741823;
          }
        }
        else
        {
          int v282 = 0x3FFFFFFF;
        }
        LODWORD(v420) = v282 - v278;
        double v284 = v440.origin.y + v440.size.height;
        double v285 = v440.origin.y + 0.0;
        if (v285 <= 1073741820.0)
        {
          unsigned int v287 = vcvtmd_s64_f64(v285);
          if (v285 >= -1073741820.0) {
            int v286 = v287;
          }
          else {
            int v286 = -1073741823;
          }
        }
        else
        {
          int v286 = 0x3FFFFFFF;
        }
        HIDWORD(v419) = v286;
        imagedouble b = v269;
        if (v284 <= 1073741820.0)
        {
          if (v284 >= -1073741820.0) {
            unsigned int v288 = vcvtpd_s64_f64(v284);
          }
          else {
            unsigned int v288 = -1073741823;
          }
        }
        else
        {
          unsigned int v288 = 0x3FFFFFFF;
        }
        HIDWORD(v420) = v288 - v286;
        float v289 = *(float *)&v416;
        if (*(float *)&v416 < 0.0039062) {
          uint64_t v290 = (int *)&v419;
        }
        else {
          uint64_t v290 = v228;
        }
        if (v254) {
          dispatch_once_t v291 = RIPGetDepthForLayerFormat(1u, v270, v271, v272, v273, v274, v27, v28);
        }
        else {
          dispatch_once_t v291 = 0;
        }
        uint64_t v292 = *(void *)(v4 + 8);
        if (v292) {
          uint64_t v293 = *(unsigned int *)(v292 + 96);
        }
        else {
          uint64_t v293 = 3;
        }
        uint64_t v294 = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)v290, 16, v291, v293, v274, v27, v28);
        long long v279 = v294;
        if (!v294)
        {
LABEL_392:
          a3 = v399;
          uint64_t v280 = v38 + 5;
          if (!v254) {
            goto LABEL_394;
          }
          goto LABEL_393;
        }
        memset(&v433[16], 0, 96);
        long long v434 = 0u;
        *(_OWORD *)uint64_t v433 = 0u;
        float64x2_t v430 = 0u;
        long long v431 = 0u;
        float64x2_t v428 = 0u;
        float64x2_t v429 = 0u;
        *(_OWORD *)&v433[24] = *(_OWORD *)(v4 + 120);
        *(_OWORD *)&v433[40] = *(_OWORD *)(v4 + 136);
        *(_OWORD *)&v433[56] = *(_OWORD *)(v4 + 152);
        *(void *)&v433[72] = *(void *)(v4 + 168);
        *(_OWORD *)&v433[8] = *(_OWORD *)(v4 + 104);
        v429.f64[0] = *(float64_t *)(v4 + 16);
        v430.f64[1] = *(float64_t *)(v4 + 40);
        long long v431 = *(_OWORD *)(v4 + 48);
        memset(v432, 0, sizeof(v432));
        *(void *)&v432[0] = *(void *)(v4 + 64);
        *(_OWORD *)(v4 + 56) = 0u;
        *(_OWORD *)((char *)v432 + 8) = *(_OWORD *)(v4 + 72);
        *(_OWORD *)(v4 + 72) = 0u;
        DWORD2(v434) = *(_DWORD *)(v4 + 216);
        *(_DWORD *)(v4 + 216) = 1;
        *(void *)(v4 + 40) = 0x3FF0000000000000;
        *(void *)(v4 + 48) = v294;
        if (v289 >= 0.0039062 && *(void *)(v294 + 20) != v420)
        {
          uint64_t v298 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
          uint64_t v300 = a2;
          uint64_t v301 = v298;
          v298[1] = 0;
          v298[2] = 0;
          *uint64_t v298 = &ripc_class;
          *((_DWORD *)v298 + 6) = 0;
          float v302 = 1.0;
          if (v254) {
            float v303 = v289;
          }
          else {
            float v303 = 1.0;
          }
          if (!v254) {
            float v302 = v289;
          }
          *((float *)v298 + 7) = v303;
          *((float *)v298 + 39) = v302;
          *(_DWORD *)(v406 + 104) = 1;
          *(void *)(v406 + 152) = 0x3FF0000000000000;
          uint64_t v4 = v406;
          RIPLayerBltShape((int *)v279, 0, 0, 0, (uint64_t)v298, 0, v406 + 104, v299);
          uint64_t v304 = v301;
          a2 = v300;
          free(v304);
        }
        uint64_t v404 = a2;
        CopCGFloat y = CGRenderingStateCreateCopy(a2);
        *(CGAffineTransform *)(Copy + 24) = CGAffineTransformIdentity;
        uint64_t v306 = CGGStateCreateCopy(a3);
        CGGStateResetClip((uint64_t)v306);
        if (*(double *)(*((void *)v306 + 15) + 8) != 1.0)
        {
          maybeCopyRenderingState((uint64_t)v306);
          *(void *)(*((void *)v306 + 15) + 8) = 0x3FF0000000000000;
        }
        CGGStateSetStyle((uint64_t)v306, 0);
        CGGStateSetSoftMask((uint64_t)v306, 0);
        *(CGAffineTransform *)(v306 + 24) = CGAffineTransformIdentity;
        CGGStateSetCompositeOperation((uint64_t)v306, 1);
        if (v254)
        {
          *(void *)(v4 + 16) = v254;
          double v314 = (double)(int)v419;
          double v315 = (double)SHIDWORD(v419);
          double v316 = (double)(int)v420;
          double v317 = (double)SHIDWORD(v420);
          *(double *)&long long v421 = (double)(int)v419;
          *((double *)&v421 + 1) = (double)SHIDWORD(v419);
          *(double *)&long long v422 = (double)(int)v420;
          *((double *)&v422 + 1) = (double)SHIDWORD(v420);
          if (v244)
          {
            if ((v244 & 0x8000000000000000) != 0) {
              CGColorSpaceRef v318 = CGTaggedColorGetColorSpace(v244, v307, v308, v309, v310, v311, v312, v313);
            }
            else {
              CGColorSpaceRef v318 = *(CGColorSpaceRef *)(v244 + 24);
            }
          }
          else
          {
            CGColorSpaceRef v318 = 0;
          }
          if (CGColorTransformConvertRequired((BOOL)v254, v318, 0))
          {
            CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v244)
            {
              if ((v244 & 0x8000000000000000) != 0)
              {
                unint64_t v328 = Mutable;
                CGColorSpaceRef v329 = CGTaggedColorGetColorSpace(v244, v320, v321, v322, v323, v324, v325, v326);
                CFMutableArrayRef Mutable = v328;
                CGColorSpaceRef v330 = v329;
              }
              else
              {
                CGColorSpaceRef v330 = *(CGColorSpaceRef *)(v244 + 24);
              }
              if (Mutable && v330)
              {
                char v331 = Mutable;
                CFDictionarySetValue(Mutable, @"kCGContextColorSpace", v330);
                CFMutableArrayRef Mutable = v331;
              }
            }
            if (*(void *)v4
              && (unint64_t v332 = *(uint64_t (**)(double, double, double, double))(*(void *)v4 + 192)) != 0)
            {
              unsigned int v333 = Mutable;
              uint64_t v334 = v332(v314, v315, v316, v317);
              CFMutableArrayRef Mutable = v333;
              unint64_t v335 = (void *)v334;
            }
            else
            {
              unint64_t v335 = 0;
            }
            if (Mutable) {
              CFRelease(Mutable);
            }
            CGGStateSetFillColor((uint64_t)v306, (void *)v244);
            uint64_t v319 = v335;
            if (v335) {
              goto LABEL_373;
            }
          }
          else
          {
            CGGStateSetFillColor((uint64_t)v306, (void *)v244);
          }
          uint64_t v319 = 0;
          unint64_t v335 = *(void **)v4;
          if (*(void *)v4)
          {
LABEL_373:
            BOOL v336 = (void (*)(void *, char *, char *, void, long long *, uint64_t))v335[8];
            if (v336) {
              v336(v335, Copy, v306, 0, &v421, 1);
            }
          }
        }
        else
        {
          uint64_t v319 = 0;
          *(void *)(v4 + 16) = *(void *)(v4 + 200);
        }
        unint64_t v337 = Copy + 24;
        vImagePixelCount v338 = v306 + 24;
        CGGStateSetFillColor((uint64_t)v306, 0);
        CGGStateSetStrokeColor((uint64_t)v306, 0);
        CGGStateSetCompositeOperation((uint64_t)v306, 2);
        *(float64x2_t *)(Copy + 24) = v395;
        *(float64x2_t *)(Copy + 40) = v394;
        *(float64x2_t *)(Copy + 56) = v392;
        *(float64x2_t *)(v306 + 24) = v395;
        *(float64x2_t *)(v306 + 40) = v394;
        *(float64x2_t *)(v306 + 56) = v392;
        if (v319)
        {
          CGSoftMaskDelegateDrawSoftMask(v319, (uint64_t)Copy, (uint64_t)v306, v396, v339, v340, v341, v342);
          *vImagePixelCount v338 = *(_OWORD *)&CGAffineTransformIdentity.a;
          *(_OWORD *)(v306 + 40) = *(_OWORD *)&CGAffineTransformIdentity.c;
          *(_OWORD *)(v306 + 56) = *(_OWORD *)&CGAffineTransformIdentity.tx;
          *unint64_t v337 = *(_OWORD *)&CGAffineTransformIdentity.a;
          *(_OWORD *)(Copy + 40) = *(_OWORD *)&CGAffineTransformIdentity.c;
          *(_OWORD *)(Copy + 56) = *(_OWORD *)&CGAffineTransformIdentity.tx;
          CGGStateSetCompositeOperation((uint64_t)v306, 1);
          unsigned int v343 = (void (*)(void *, char *, char *))v319[25];
          if (v343) {
            v343(v319, Copy, v306);
          }
        }
        else
        {
          CGSoftMaskDelegateDrawSoftMask(*(const void **)v406, (uint64_t)Copy, (uint64_t)v306, v396, v339, v340, v341, v342);
          *vImagePixelCount v338 = *(_OWORD *)&CGAffineTransformIdentity.a;
          *(_OWORD *)(v306 + 40) = *(_OWORD *)&CGAffineTransformIdentity.c;
          *(_OWORD *)(v306 + 56) = *(_OWORD *)&CGAffineTransformIdentity.tx;
          *unint64_t v337 = *(_OWORD *)&CGAffineTransformIdentity.a;
          *(_OWORD *)(Copy + 40) = *(_OWORD *)&CGAffineTransformIdentity.c;
          *(_OWORD *)(Copy + 56) = *(_OWORD *)&CGAffineTransformIdentity.tx;
        }
        CGGStateRelease((uint64_t)v306);
        if (atomic_fetch_add_explicit((atomic_uint *volatile)Copy, 0xFFFFFFFF, memory_order_relaxed) == 1) {
          free(Copy);
        }
        uint64_t v4 = v406;
        ripc_ContextRestore(v406, (uint64_t)&v428);
        *(_DWORD *)(v406 + 216) = DWORD2(v434);
        a2 = v404;
        if (v254) {
          RIPLayerCoverage((uint64_t)v279, v344, v295, v296, v297, v274, v27, v28);
        }
        if ((imageb & 1) == 0)
        {
          unint64_t v345 = 0;
          LODWORD(v417) = 0;
          do
          {
            v29.n128_f32[0] = (float)v345 / 255.0;
            *(float *)&unint64_t v418 = v29.n128_f32[0];
            function_evaluate_float(v391, (float *)&v418, (float *)&v417, v29);
            if (*(float *)&v417 >= 0.0)
            {
              if (*(float *)&v417 <= 1.0)
              {
                v29.n128_f64[0] = (float)(*(float *)&v417 * 255.0) + 0.5;
                int v351 = (int)v29.n128_f64[0];
              }
              else
              {
                LOBYTE(v351) = -1;
              }
            }
            else
            {
              LOBYTE(v351) = 0;
            }
            *((unsigned char *)&__s2.a + v345++) = v351;
          }
          while (v345 != 256);
          RIPLayerTransfer((uint64_t)v279, (int *)&v419, (uint64_t)&__s2, v346, v347, v348, v349, v350);
          uint64_t v4 = v406;
        }
        goto LABEL_392;
      }
      (*(void (**)(uint64_t))(*(void *)v76 + 16))(v33[11]);
    }
    v38[11] = v76;
    __n128 v29 = *(__n128 *)(v33 + 5);
    __n128 v409 = v29;
    goto LABEL_103;
  }
  uint64_t v398 = a3;
  uint64_t v403 = a2;
  ClipStackDatdouble a = 0;
  int v33 = 0;
  CGFloat v34 = 0.0;
  CGFloat v35 = 0.0;
  LODWORD(a3) = -1;
  CGFloat v36 = 0.0;
  CGFloat v37 = 0.0;
LABEL_24:
  size_t v38 = v32;
  while (1)
  {
    signed int v32 = (uint64_t *)v38[1];
    uint64_t v39 = v38[3];
    if (v39 != v409.n128_u32[0]
      || (HIDWORD(v39) == v409.n128_u32[1] ? (_ZF = *((_DWORD *)v38 + 8) == v409.n128_u32[2]) : (_ZF = 0),
          _ZF ? (BOOL v41 = *((_DWORD *)v38 + 9) == v409.n128_u32[3]) : (BOOL v41 = 0),
          !v41))
    {
LABEL_38:
      RIPClipStateRemoveEntry((uint64_t)v9, v38);
      goto LABEL_39;
    }
    if (*((_DWORD *)v38 + 5) != v16)
    {
      if ((a3 & 0x80000000) != 0)
      {
        if (v11) {
          a3 = *(void *)(v11 + 120);
        }
        else {
          LODWORD(a3) = 0;
        }
      }
      int v43 = *((_DWORD *)v38 + 24);
      if (v43 > (int)a3) {
        goto LABEL_46;
      }
      if (!ClipStackData)
      {
        if (v11)
        {
          BOOL v45 = (CGFloat *)(v11 + 40);
          uint64_t v44 = (CGSize *)(v11 + 32);
          double v46 = (CGFloat *)(v11 + 24);
          unsigned int v47 = (const CGRect *)(v11 + 16);
        }
        else
        {
          unsigned int v47 = &CGRectInfinite;
          BOOL v45 = &CGRectInfinite.size.height;
          double v46 = &CGRectInfinite.origin.y;
          uint64_t v44 = &CGRectInfinite.size;
        }
        CGFloat v37 = *v45;
        CGFloat v34 = v47->origin.x;
        CGFloat v35 = *v46;
        CGFloat v36 = v44->width;
        ClipStackDatdouble a = ripc_GetClipStackData((void *)v11, (int)a3, __dst, 0x20uLL);
        int v43 = *((_DWORD *)v38 + 24);
      }
      uint64_t v48 = v43;
      unsigned int v390 = v43;
      while ((int)v48 >= 1)
      {
        int v49 = *((_DWORD *)v38 + v48 + 24);
        uint64_t v50 = &ClipStackData[v48--];
        if (v49 != *(v50 - 1)) {
          goto LABEL_46;
        }
      }
      CGFloat v51 = *((double *)v38 + 7);
      CGFloat v52 = *((double *)v38 + 8);
      CGFloat v53 = *((double *)v38 + 9);
      CGFloat v54 = *((double *)v38 + 10);
      v436.origin.CGFloat x = v51;
      v436.origin.CGFloat y = v52;
      v436.size.CGFloat width = v53;
      v436.size.CGFloat height = v54;
      v441.origin.CGFloat x = v34;
      v441.origin.CGFloat y = v35;
      v441.size.CGFloat width = v36;
      v441.size.CGFloat height = v37;
      if (CGRectContainsRect(v436, v441))
      {
        int v55 = *((_DWORD *)v38 + 4);
        if (v390 == a3 && v55 == v15)
        {
          v437.origin.CGFloat x = v51;
          v437.origin.CGFloat y = v52;
          v437.size.CGFloat width = v53;
          v437.size.CGFloat height = v54;
          v442.origin.CGFloat x = v34;
          v442.origin.CGFloat y = v35;
          v442.size.CGFloat width = v36;
          v442.size.CGFloat height = v37;
          BOOL v56 = CGRectEqualToRect(v437, v442);
          int v55 = v15;
          if (v56)
          {
            *((_DWORD *)v38 + 4) = v15;
            *((_DWORD *)v38 + 5) = v16;
            uint64_t v379 = *v38;
            if ((uint64_t *)*v38 != v31)
            {
              unint64_t v380 = (uint64_t *)v38[1];
              *(void *)(v379 + 8) = v380;
              *unint64_t v380 = v379;
LABEL_70:
              v38[1] = (uint64_t)v38;
              uint64_t v59 = (uint64_t **)*((void *)v9 + 4);
              *((void *)v9 + 4) = v38;
              *size_t v38 = (uint64_t)v31;
              *uint64_t v59 = v38;
              v38[1] = (uint64_t)v59;
            }
LABEL_71:
            unsigned int v10 = v402;
            a2 = v403;
            uint64_t v4 = v406;
            a3 = v398;
            goto LABEL_406;
          }
        }
        if (!v55 && (!v33 || *((_DWORD *)v33 + 24) < v390)) {
          int v33 = v38;
        }
      }
      else
      {
LABEL_46:
        RIPClipStateRemoveEntry((uint64_t)v9, v38);
      }
      if (v32 == v31) {
        goto LABEL_77;
      }
      goto LABEL_24;
    }
    int v42 = *((_DWORD *)v38 + 4);
    if (v42 == v15)
    {
      uint64_t v58 = *v38;
      if ((uint64_t *)*v38 != v31)
      {
        *(void *)(v58 + 8) = v32;
        *signed int v32 = v58;
        goto LABEL_70;
      }
      goto LABEL_71;
    }
    if (!v42) {
      break;
    }
    if (v15) {
      goto LABEL_38;
    }
LABEL_39:
    size_t v38 = v32;
    if (v32 == v31) {
      goto LABEL_77;
    }
  }
  CGFloat v34 = *((double *)v38 + 7);
  CGFloat v35 = *((double *)v38 + 8);
  CGFloat v36 = *((double *)v38 + 9);
  CGFloat v37 = *((double *)v38 + 10);
  int v60 = *((_DWORD *)v38 + 24);
  LODWORD(a3) = v60;
  if (v60 >= 33)
  {
    size_t v61 = 4 * v60;
    uint64_t v62 = malloc_type_malloc(v61, 0x100004052888210uLL);
    goto LABEL_76;
  }
  if (v60)
  {
    size_t v61 = 4 * v60;
    uint64_t v62 = __dst;
LABEL_76:
    ClipStackDatdouble a = v62;
    memcpy(v62, (char *)v38 + 100, v61);
    int v33 = v38;
LABEL_77:
    if (v30)
    {
      uint64_t v57 = ClipStackData;
      if ((a3 & 0x80000000) != 0) {
        goto LABEL_79;
      }
      goto LABEL_86;
    }
    if (ClipStackData && ClipStackData != __dst) {
      free(ClipStackData);
    }
  }
  else if (v30)
  {
    LODWORD(a3) = 0;
    uint64_t v57 = __dst;
    int v33 = v38;
    goto LABEL_86;
  }
LABEL_84:
  uint64_t result = 0;
  *(_DWORD *)char v9 = v16;
  *((_DWORD *)v9 + 1) = v15;
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  return result;
}

BOOL ripl_Geometry(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  int v3 = *(_DWORD *)(a1 + 24);
  if (a2)
  {
    *(_DWORD *)(a2 + 8) = v2;
    *(_DWORD *)(a2 + 12) = v3;
    *(void *)a2 = *(void *)(a1 + 12);
  }
  return v2 > 0 && v3 > 0;
}

BOOL ripl_Resolution(uint64_t a1, uint64_t a2)
{
  return a2 != 0;
}

void *ripc_InitializeColorTransform(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 48);
  if (result)
  {
    uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t))(*result + 80))(result, a1 + 16);
    int v3 = (int)result;
  }
  else
  {
    int v3 = 0;
  }
  uint64_t v4 = *(void **)(a1 + 16);
  if (*(void **)(a1 + 120) != v4 || *(_DWORD *)(a1 + 132) != v3)
  {
    *(void *)(a1 + 120) = v4;
    *(_DWORD *)(a1 + 132) = v3;
    if ((CGColorTransformGetMD5(v4, a1 + 136) & 1) == 0)
    {
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 144) = 0;
    }
    Cache = CGColorTransformGetCache(v4);
    if (Cache && (uint64_t v6 = Cache[2]) != 0) {
      int v7 = *(_DWORD *)(*(void *)(v6 + 24) + 28);
    }
    else {
      int v7 = -1;
    }
    *(_DWORD *)(a1 + 128) = v7;
    free(*(void **)(a1 + 176));
    uint64_t v8 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
    *uint64_t v8 = &ripc_class;
    v8[1] = 0;
    v8[2] = 0;
    v8[3] = 0;
    *((_DWORD *)v8 + 39) = 1065353216;
    *(void *)(a1 + 176) = v8;
    *((_DWORD *)v8 + 5) = v3;
    free(*(void **)(a1 + 184));
    char v9 = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
    *char v9 = &ripc_class;
    v9[1] = 0;
    v9[2] = 0;
    v9[3] = 0;
    *((_DWORD *)v9 + 39) = 1065353216;
    *(void *)(a1 + 184) = v9;
    *((_DWORD *)v9 + 5) = v3;
    free(*(void **)(a1 + 192));
    uint64_t result = malloc_type_malloc(0xA0uLL, 0x106004074580882uLL);
    *uint64_t result = &ripc_class;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 39) = 1065353216;
    *(void *)(a1 + 192) = result;
    *((_DWORD *)result + 5) = v3;
  }
  return result;
}

uint64_t ripl_Transform(uint64_t a1, uint64_t a2)
{
  if (a2 && *(void *)a2) {
    return *(unsigned int *)(*(void *)a2 + 16);
  }
  else {
    return 0;
  }
}

void ripc_Render(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  char v9 = a5;
  int v14 = (unsigned char *)a4[5];
  if (!v14 || (v14[12] & 0x10) != 0)
  {
    int v15 = (int *)(a4 + 3);
  }
  else
  {
    int v14 = 0;
    int v15 = (int *)(a4 + 1);
  }
  if ((a5 & 6) != 0)
  {
    int v16 = RIPRenderCoverage(*(void *)(a1 + 56), 1, v15, (a5 >> 2) & 1, a5, a6, a7, a8, a9);
    if (!v16)
    {
LABEL_13:
      ripr_Finish(*(void *)(a1 + 56));
      goto LABEL_14;
    }
    uint64_t v18 = (uint64_t)v16;
    Color = 0;
    uint64_t v41 = 0;
    int v20 = *(_DWORD *)(*(void *)(a3 + 120) + 4);
    if (BYTE1(v20))
    {
      Color = ripc_GetColor(a1, a2, a3, 2, (int *)v16 + 3, (uint64_t)&v41, (double *)(a1 + 152), v17);
      if (!Color) {
        return;
      }
    }
    *(_DWORD *)(a1 + 104) = (__int16)v20 >> 8;
    *(unsigned char *)(a1 + 108) = *(unsigned char *)(a2 + 82);
    *(_DWORD *)(a1 + 112) = (int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 12) >> 28;
    if (v14)
    {
      (*(void (**)(unsigned char *, void, uint64_t, void, uint64_t, char *, uint64_t *))(*(void *)v14 + 56))(v14, *(void *)(a1 + 48), *a4, 0, v18, Color, &v41);
      if (!Color)
      {
LABEL_12:
        (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
        goto LABEL_13;
      }
    }
    else
    {
      RIPLayerBltShape(*(int **)(a1 + 48), *a4, 0, v18, (uint64_t)Color, &v41, a1 + 104, a1 + 104);
      if (!Color) {
        goto LABEL_12;
      }
    }
    RIPObjectRelease((uint64_t)Color, v21, v22, v23, v24, v25, v26, v27);
    goto LABEL_12;
  }
LABEL_14:
  if (v9)
  {
    uint64_t v28 = RIPRenderCoverage(*(void *)(a1 + 64), 1, v15, 0, a5, a6, a7, a8, a9);
    if (v28)
    {
      uint64_t v30 = (uint64_t)v28;
      uint64_t v41 = 0;
      uint64_t v31 = ripc_GetColor(a1, a2, a3, 1, (int *)v28 + 3, (uint64_t)&v41, (double *)(a1 + 152), v29);
      if (v31)
      {
        uint64_t v32 = (uint64_t)v31;
        uint64_t v33 = a1 + 104;
        *(_DWORD *)(a1 + 104) = (int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 16) >> 24;
        *(unsigned char *)(a1 + 108) = *(unsigned char *)(a2 + 82);
        *(_DWORD *)(a1 + 112) = (int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 12) >> 28;
        if (v14) {
          (*(void (**)(unsigned char *, void, uint64_t, void, uint64_t, char *, uint64_t *, uint64_t))(*(void *)v14 + 56))(v14, *(void *)(a1 + 48), *a4, 0, v30, v31, &v41, v33);
        }
        else {
          RIPLayerBltShape(*(int **)(a1 + 48), *a4, 0, v30, (uint64_t)v31, &v41, a1 + 104, v33);
        }
        RIPObjectRelease(v32, v34, v35, v36, v37, v38, v39, v40);
      }
      (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
    }
    ripr_Finish(*(void *)(a1 + 64));
  }
}

BOOL RIPLayerInitialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    *(void *)a1 = RIPLayer_ripl_class;
    *(_DWORD *)(a1 + 8) = -1;
    *(void *)(a1 + 20) = 0;
    *(void *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(void *)(a1 + 32) = RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8);
    *(_DWORD *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    pthread_mutex_init((pthread_mutex_t *)(a1 + 80), 0);
  }
  return a1 != 0;
}

void ripl_release(char *a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 80);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
  int v10 = *((_DWORD *)a1 + 2);
  if (v10 != -1 && v10 != 1)
  {
    *((_DWORD *)a1 + 2) = v10 - 1;
LABEL_19:
    pthread_mutex_unlock(v2);
    return;
  }
  if (*((void *)a1 + 9))
  {
    uint64_t v11 = *((void *)a1 + 4);
    if (v11 == RIPGetDepthForLayerFormat(0, v3, v4, v5, v6, v7, v8, v9))
    {
      uint64_t v12 = (void *)*((void *)a1 + 9);
      if (v12)
      {
        if (v12 != &the_empty_shape) {
          free(v12);
        }
      }
    }
    *((void *)a1 + 9) = 0;
    *((_DWORD *)a1 + 16) = 0;
  }
  int v13 = (void *)*((void *)a1 + 7);
  if (v13)
  {
    if ((a1[28] & 2) == 0) {
      free(v13);
    }
    *((void *)a1 + 7) = 0;
    *((_DWORD *)a1 + 12) = 0;
  }
  if (v10 == -1)
  {
    *((void *)a1 + 4) = RIPGetDepthForLayerFormat(0, v3, v4, v5, v6, v7, v8, v9);
    *(void *)(a1 + 20) = 0;
    *(void *)(a1 + 12) = 0;
    goto LABEL_19;
  }
  *(void *)a1 = 0;
  pthread_mutex_unlock(v2);
  pthread_mutex_destroy(v2);

  free(a1);
}

dispatch_once_t RIPGetDepthForLayerFormat(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 == -1) {
    return 0;
  }
  if (a1 >= 0x1B) {
    _CGHandleAssert("RIPGetDepthForLayerFormat", 97, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPLayerFormat.c", "format >= 0 && format < kRIPLayerFormat_Max", "invalid format %d", a6, a7, a8, a1);
  }
  uint64_t v8 = (dispatch_once_t *)((char *)&RIPGetDepthForLayerFormat_blt_depth + 16 * (int)a1);
  dispatch_once_t v9 = v8[1];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __RIPGetDepthForLayerFormat_block_invoke;
  block[3] = &__block_descriptor_tmp_1934;
  unsigned int v12 = a1;
  if (v9 != -1) {
    dispatch_once(v8 + 1, block);
  }
  if (*v8 == -1) {
    return 0;
  }
  else {
    return *v8;
  }
}

uint64_t RIPObjectRelease(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    if (!*(void *)result) {
      _CGHandleAssert("RIPObjectRelease", 19, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPClass.c", "RIPObjectValid(object)", "Release of invalid RIP object %p", a6, a7, a8, result);
    }
    uint64_t v8 = *(uint64_t (**)(void))(*(void *)result + 24);
    if (v8)
    {
      return v8();
    }
  }
  return result;
}

char *RIPRenderCoverage(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (!a1) {
    return 0;
  }
  if (!*(void *)a1) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (!v10) {
    return 0;
  }
  int v11 = a2;
  if (v10 != a1 + 168)
  {
    if (a3)
    {
      int v12 = a3[2];
      if (v12 < 1) {
        return 0;
      }
      int v13 = a3[3];
      if (v13 < 1) {
        return 0;
      }
      int v15 = *a3;
      int v14 = a3[1];
      int v16 = *a3 + v12;
      int v17 = v14 + v13;
    }
    else
    {
      int v15 = 0;
      int v14 = 0;
      int v16 = 0x3FFFFF;
      int v17 = 0x3FFFFF;
    }
    unint64_t v96 = 0;
    unint64_t v97 = 0;
    if (!*(unsigned char *)(v10 + 112))
    {
      uint64_t v40 = *(void *)(v10 + 24);
      if (!v40) {
        return 0;
      }
      int v41 = *(_DWORD *)v40;
      int v42 = *(_DWORD *)(v40 + 4);
      int v44 = *(_DWORD *)(v40 + 8);
      int v43 = *(_DWORD *)(v40 + 12);
      if (v44 - *(_DWORD *)v40 < 31 || v43 - v42 < 31) {
        return 0;
      }
      int v46 = v44 + 15;
      int v35 = v41 >> 4;
      int v37 = v46 >> 4;
      int v47 = v43 + 15;
      int v38 = v42 >> 4;
      int v39 = (v43 + 15) >> 4;
      int v48 = *(_DWORD *)(v40 + 184);
      if (v48 == 2 && *(_WORD *)(v40 + 188) == 2)
      {
        if ((*(unsigned char *)(v40 + 178) & 0xC) != 0)
        {
          int v49 = 3;
        }
        else
        {
          if ((~v41 & 0xFF0) == 0) {
            ++v35;
          }
          if ((~v46 & 0xFF0) == 0) {
            ++v37;
          }
          if (v35 >= v37) {
            return 0;
          }
          if ((~v42 & 0xFF0) == 0) {
            ++v38;
          }
          if ((~v47 & 0xFF0) == 0) {
            ++v39;
          }
          if (v38 >= v39) {
            return 0;
          }
          if ((v38 | v35 | v37) | v39) {
            int v49 = 3;
          }
          else {
            int v49 = 2;
          }
        }
      }
      else if ((*(unsigned char *)(v40 + 178) & 0xC) != 0 || v48 != *(unsigned __int16 *)(v40 + 188))
      {
        int v49 = 1;
      }
      else
      {
        int v49 = 4;
      }
      uint64_t v27 = 0;
      int v58 = 24 * v48 + 16;
      LODWORD(v96) = v35;
      LODWORD(v97) = v37;
LABEL_83:
      int v65 = (v37 + 255) >> 8;
      if (v35 >> 8 <= v15) {
        int v66 = v15;
      }
      else {
        int v66 = v35 >> 8;
      }
      if (v65 >= v16) {
        int v67 = v16;
      }
      else {
        int v67 = (v37 + 255) >> 8;
      }
      if (v67 <= v66) {
        return 0;
      }
      int v68 = (v39 + 255) >> 8;
      if (v38 >> 8 <= v14) {
        int v69 = v14;
      }
      else {
        int v69 = v38 >> 8;
      }
      if (v68 >= v17) {
        int v70 = v17;
      }
      else {
        int v70 = (v39 + 255) >> 8;
      }
      BOOL v71 = v35 >> 8 >= v15 && v65 <= v16;
      unsigned int v72 = a4 | 4;
      if (v71 && v38 >> 8 >= v14 && v68 <= v17) {
        unsigned int v72 = a4;
      }
      unsigned int v75 = v70 - v69;
      if (v70 <= v69) {
        return 0;
      }
      unint64_t v95 = 0;
      if (v49 == 2)
      {
LABEL_110:
        uint64_t v57 = 0;
        uint64_t v54 = 0;
        uint64_t v56 = 0;
LABEL_111:
        uint64_t v55 = 0;
LABEL_112:
        unint64_t v96 = __PAIR64__(v69, v66);
        LODWORD(v97) = v67 - v66;
        HIDWORD(v97) = v70 - v69;
        if (v11)
        {
          uint64_t v27 = v10 + 120;
          RIPLayerReplace(v10 + 120, (uint64_t)&v96, v54, v55, v56, (uint64_t)v57, (uint64_t)v57, a8, a9);
          int v76 = *(_DWORD *)(v10 + 148);
          if (*(_DWORD *)(v10 + 8)) {
            unsigned int v77 = v76 | 2;
          }
          else {
            unsigned int v77 = v76 & 0xFFFFFFFD;
          }
          *(_DWORD *)(v10 + 148) = v77;
          return (char *)v27;
        }
        uint64_t v53 = *(unsigned int *)(a1 + 76);
        return RIPLayerCreateWithData((uint64_t *)&v96, 0, 0, v54, v55, v56, (uint64_t)v57, v53);
      }
      if (*(unsigned char *)(v10 + 113)) {
        unsigned int v78 = v72;
      }
      else {
        unsigned int v78 = v72 | 0x20;
      }
      if (v49 != 4)
      {
        if (v49 == 3)
        {
          if (v78 <= 0x1F)
          {
            int v79 = v66 << 8;
            if (v35 > v66 << 8) {
              int v79 = v35;
            }
            if (v37 >= v67 << 8) {
              int v80 = v67 << 8;
            }
            else {
              int v80 = v37;
            }
            if (v79 >= v67 << 8) {
              return 0;
            }
            int v81 = v69 << 8;
            if (v38 > v69 << 8) {
              int v81 = v38;
            }
            if (v81 >= v70 << 8) {
              return 0;
            }
            uint64_t v57 = 0;
            uint64_t v54 = 0;
            uint64_t v55 = 0;
            int v82 = v70 << 8;
            if (v39 < v70 << 8) {
              int v82 = v39;
            }
            int v66 = v79 >> 8;
            int v69 = v81 >> 8;
            int v67 = (v80 + 255) >> 8;
            int v70 = (v82 + 255) >> 8;
            uint64_t v56 = ((((v80 + 255) & 0xFFFF00) - v80) << 8) | (v79 << 24) | ((((v82 + 255) & 0xFF00) - v82) << 16) | v81;
            goto LABEL_112;
          }
          goto LABEL_110;
        }
        if (v78 < 0x20)
        {
          unsigned int v83 = (v67 - v66 + 3) & 0xFFFFFFFC;
          if (v75 <= 0x7FFFFF7F / v83)
          {
            unsigned int v93 = (v67 - v66 + 3) & 0xFFFFFFFC;
            size_t size = v75 * v83 + 4;
            BOOL v84 = size > 0x10000 || v11 == 0;
            if (!v84
              && (size_t v92 = (v75 * v83 + 259) & 0xFFFFFF00,
                  double v85 = malloc_type_malloc(v92, 0x6C4BC18AuLL),
                  *(void *)(v10 + 16) = v85,
                  *(_DWORD *)(v10 + 8) = v92,
                  v85)
              || (double v85 = malloc_type_malloc(size, 0xA061830FuLL)) != 0)
            {
              if (v27)
              {
                uint64_t v87 = (uint64_t)v85;
                bzero(v85, size);
                aa_line_render(v27, v87, v93, v66, v69, v67, v70);
                uint64_t v55 = v87;
                uint64_t v54 = v93;
                uint64_t v57 = 0;
                uint64_t v56 = 0;
                goto LABEL_112;
              }
              int v91 = v85;
              if (aa_render(v40, v78, (char *)v85, v93, v66, v69, v67, v70, v86))
              {
                uint64_t v57 = 0;
                uint64_t v56 = 0;
                uint64_t v54 = v93;
                uint64_t v55 = (uint64_t)v91;
                goto LABEL_112;
              }
              if (!*(_DWORD *)(v10 + 8))
              {
                int v89 = v91;
LABEL_177:
                free(v89);
              }
            }
          }
          return 0;
        }
      }
      if (v27)
      {
        uint64_t v88 = aa_line_render_shape(v27, &v95, v58, v66, v69, v67, v70);
        uint64_t v57 = v95;
        if (!v88) {
          goto LABEL_167;
        }
        if (v95 == &the_empty_shape) {
          return 0;
        }
        if (*((_DWORD *)v95 + *((int *)v95 + 1)) == 0x7FFFFFFF)
        {
LABEL_167:
          uint64_t v27 = 0;
          if (!v95) {
            return (char *)v27;
          }
LABEL_175:
          if (v57 == &the_empty_shape) {
            return (char *)v27;
          }
          int v89 = v57;
          goto LABEL_177;
        }
      }
      else
      {
        uint64_t v88 = aa_render_shape(v40, v78, &v95, v58, v66, v69, v67, v70, a9);
        uint64_t v57 = v95;
        if (!v88) {
          goto LABEL_174;
        }
        if (v95 == &the_empty_shape) {
          return 0;
        }
        if (*((_DWORD *)v95 + *((int *)v95 + 1)) == 0x7FFFFFFF)
        {
LABEL_174:
          uint64_t v27 = 0;
          if (!v95) {
            return (char *)v27;
          }
          goto LABEL_175;
        }
      }
      uint64_t v56 = v88;
      uint64_t v54 = 0;
      goto LABEL_111;
    }
    uint64_t v27 = *(void *)(v10 + 32);
    if (!v27) {
      return (char *)v27;
    }
    float v29 = *(float *)(v27 + 52);
    float v28 = *(float *)(v27 + 56);
    float v31 = *(float *)(v27 + 60);
    float v30 = *(float *)(v27 + 64);
    if (v29 > v31 || v28 > v30) {
      return 0;
    }
    float v33 = fabsf(*(float *)(v27 + 236)) * 0.5;
    int v34 = *(_DWORD *)(v27 + 168);
    if (v34 == 1)
    {
      if (v28 == v30)
      {
        if (*(_DWORD *)(v27 + 244))
        {
          float v29 = v29 - v33;
          float v31 = v31 + v33;
        }
        else if (v29 == v31)
        {
          return 0;
        }
        int v35 = vcvtms_s32_f32(v29 * 256.0);
        unsigned int v36 = vcvtps_s32_f32(v31 * 256.0);
        if ((_BYTE)v35 == 0xFF) {
          ++v35;
        }
        if ((_BYTE)v36 == 0xFF) {
          int v37 = v36 + 1;
        }
        else {
          int v37 = v36;
        }
        if (v35 >= v37) {
          return 0;
        }
        int v38 = vcvtms_s32_f32((float)(v28 - v33) * 256.0);
        a9.n128_f32[0] = (float)(v30 + v33) * 256.0;
        int v39 = vcvtps_s32_f32(a9.n128_f32[0]);
        goto LABEL_76;
      }
      if (v29 == v31)
      {
        int v59 = *(_DWORD *)(v27 + 244);
        float v60 = 0.0;
        if (v59) {
          float v60 = v33;
        }
        float v61 = v28 - v60;
        float v62 = -0.0;
        if (v59) {
          float v62 = v33;
        }
        unsigned int v63 = vcvtms_s32_f32(v61 * 256.0);
        unsigned int v64 = vcvtps_s32_f32((float)(v30 + v62) * 256.0);
        if ((_BYTE)v63 == 0xFF) {
          int v38 = v63 + 1;
        }
        else {
          int v38 = v63;
        }
        if ((_BYTE)v64 == 0xFF) {
          int v39 = v64 + 1;
        }
        else {
          int v39 = v64;
        }
        if (v38 >= v39) {
          return 0;
        }
        int v35 = vcvtms_s32_f32((float)(v29 - v33) * 256.0);
        a9.n128_f32[0] = (float)(v31 + v33) * 256.0;
        int v37 = vcvtps_s32_f32(a9.n128_f32[0]);
LABEL_76:
        if (v38 | (v35 | v37 | v39))
        {
          uint64_t v40 = 0;
          LODWORD(v97) = v37;
          unint64_t v96 = __PAIR64__(v38, v35);
          if (*(unsigned char *)(v10 + 113)) {
            int v49 = 3;
          }
          else {
            int v49 = 4;
          }
          int v58 = 40;
          goto LABEL_83;
        }
        int v49 = 2;
        goto LABEL_82;
      }
    }
    int v35 = vcvtms_s32_f32((float)(v29 - v33) * 256.0);
    int v37 = vcvtps_s32_f32((float)(v31 + v33) * 256.0);
    int v38 = vcvtms_s32_f32((float)(v28 - v33) * 256.0);
    a9.n128_f32[0] = (float)(v30 + v33) * 256.0;
    int v39 = vcvtps_s32_f32(a9.n128_f32[0]);
    int v49 = 1;
LABEL_82:
    uint64_t v40 = 0;
    unint64_t v96 = __PAIR64__(v38, v35);
    int v58 = 24 * v34 + 16;
    unint64_t v97 = __PAIR64__(v39, v37);
    goto LABEL_83;
  }
  if (a3)
  {
    int v18 = a3[2];
    if (v18 < 1) {
      return 0;
    }
    int v19 = a3[3];
    if (v19 < 1) {
      return 0;
    }
    int v20 = a3[1];
    int v21 = *a3 + v18;
    int v22 = *a3 << 8;
    int v23 = v20 << 8;
    int v24 = v20 + v19;
    int v25 = v21 << 8;
    int v26 = v24 << 8;
  }
  else
  {
    int v23 = 0;
    int v22 = 0;
    int v25 = 1073741568;
    int v26 = 1073741568;
  }
  if (v22 <= *(_DWORD *)v10) {
    int v22 = *(_DWORD *)v10;
  }
  if (v25 >= *(_DWORD *)(v10 + 8)) {
    int v25 = *(_DWORD *)(v10 + 8);
  }
  if (v22 >= v25) {
    return 0;
  }
  if (v23 <= *(_DWORD *)(v10 + 4)) {
    int v23 = *(_DWORD *)(v10 + 4);
  }
  if (v26 >= *(_DWORD *)(v10 + 12)) {
    int v26 = *(_DWORD *)(v10 + 12);
  }
  if (v23 >= v26) {
    return 0;
  }
  uint64_t v50 = ((((v25 + 255) & 0xFFFF00) - v25) << 8) | (v22 << 24) | v23 | ((((v26 + 255) & 0xFF00u) - v26) << 16);
  LODWORD(v96) = v22 >> 8;
  HIDWORD(v96) = v23 >> 8;
  LODWORD(v97) = ((v25 + 255) >> 8) - (v22 >> 8);
  HIDWORD(v97) = ((v26 + 255) >> 8) - (v23 >> 8);
  uint64_t v27 = a1 + 24;
  if (!*(void *)(a1 + 24)) {
    RIPLayerInitialize(a1 + 24, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  if (!v11)
  {
    uint64_t v53 = *(unsigned int *)(a1 + 76);
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v56 = v50;
    uint64_t v57 = 0;
    return RIPLayerCreateWithData((uint64_t *)&v96, 0, 0, v54, v55, v56, (uint64_t)v57, v53);
  }
  RIPLayerReplace(a1 + 24, (uint64_t)&v96, 0, 0, v50, 0, a7, a8, a9);
  int v51 = *(_DWORD *)(a1 + 52);
  if (*(_DWORD *)(v10 + 8)) {
    unsigned int v52 = v51 | 2;
  }
  else {
    unsigned int v52 = v51 & 0xFFFFFFFD;
  }
  *(_DWORD *)(a1 + 52) = v52;
  return (char *)v27;
}

__n128 RIPLayerReplace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 result)
{
  if (a1 && *(void *)a1)
  {
    int v11 = a5;
    int v13 = a3;
    if (a2)
    {
      int v14 = *(_DWORD *)(a2 + 8);
      if (v14 < 0 || (int v15 = *(_DWORD *)(a2 + 12), v15 < 0))
      {
        int v14 = 0;
        int v15 = 0;
      }
      result.n128_u64[0] = *(void *)a2;
    }
    else
    {
      int v14 = 0;
      int v15 = 0;
      uint64_t result = 0uLL;
    }
    __n128 v19 = result;
    if (*(void *)(a1 + 72))
    {
      uint64_t v16 = *(void *)(a1 + 32);
      if (v16 == RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8))
      {
        int v17 = *(void **)(a1 + 72);
        if (v17)
        {
          if (v17 != &the_empty_shape) {
            free(v17);
          }
        }
      }
    }
    int v18 = *(void **)(a1 + 56);
    if (v18)
    {
      if ((*(unsigned char *)(a1 + 28) & 2) == 0) {
        free(v18);
      }
    }
    uint64_t result = v19;
    *(void *)(a1 + 12) = v19.n128_u64[0];
    *(_DWORD *)(a1 + 20) = v14;
    *(_DWORD *)(a1 + 24) = v15;
    *(_DWORD *)(a1 + 48) = v13;
    *(void *)(a1 + 56) = a4;
    *(_DWORD *)(a1 + 64) = v11;
    *(void *)(a1 + 72) = a6;
  }
  return result;
}

void ripr_Finish(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    if (v1 != a1 + 168)
    {
      uint64_t v3 = *(void **)(v1 + 24);
      if (v3)
      {
        aa_free_edges(*(void *)(v1 + 24));
        free(v3);
      }
      uint64_t v4 = *(void **)(v1 + 32);
      if (v4)
      {
        aal_free_edges(*(void *)(v1 + 32));
        while (1)
        {
          uint64_t v5 = (void *)v4[28];
          if (!v5) {
            break;
          }
          v4[28] = *v5;
          free(v5);
        }
        free(v4);
      }
      (*(void (**)(uint64_t))(*(void *)(v1 + 120) + 24))(v1 + 120);
      if (*(_DWORD *)(v1 + 8)) {
        free(*(void **)(v1 + 16));
      }
      free((void *)v1);
    }
    *(void *)(a1 + 16) = 0;
  }
}

_DWORD *ripc_GetClipStackData(void *a1, unint64_t a2, _DWORD *a3, unint64_t a4)
{
  if (a2)
  {
    if (a2 > a4) {
      a3 = malloc_type_malloc(4 * a2, 0x100004052888210uLL);
    }
    unint64_t v6 = 0;
    uint64_t v7 = a1 + 16;
    do
    {
      if (a1 && a1[15] > v6)
      {
        uint64_t v8 = v7;
        if (a1[14] != 3) {
          uint64_t v8 = (uint64_t *)(a1[16] + 8 * v6);
        }
        uint64_t v9 = *v8;
        if (v9) {
          LODWORD(v9) = *(_DWORD *)(v9 + 4);
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      a3[v6++] = v9;
      ++v7;
    }
    while (a2 != v6);
  }
  return a3;
}

void *aal_free_edges(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 176);
  uint64_t result = *(void **)v2;
  if (*(void *)v2)
  {
    do
    {
      uint64_t v4 = (void *)*result;
      free(result);
      uint64_t result = v4;
    }
    while (v4);
  }
  *(void *)(a1 + 184) = v2;
  *(void *)uint64_t v2 = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(v2 + 16) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

char *RIPRenderPath(char *result, uint64_t a2, const CGPath *a3, uint64_t a4)
{
  if (result)
  {
    if (a3)
    {
      if (a2)
      {
        if (*(void *)result)
        {
          uint64_t result = ripr_Acquire((uint64_t)result, a2);
          if (result)
          {
            if (a4)
            {
              uint64_t v8 = 0;
              memset(v7, 0, sizeof(v7));
              ripr_stroke_acquire((uint64_t)result, (uint64_t)v7, a4);
            }
            unint64_t v6 = (void *)*((void *)result + 3);
            CGPathApply(a3, v6, (CGPathApplierFunction)ripr_path_fill);
            return (char *)aa_close((uint64_t)v6);
          }
        }
      }
    }
  }
  return result;
}

char *ripr_Acquire(uint64_t a1, uint64_t a2)
{
  if (ripr_Acquire_once != -1) {
    dispatch_once(&ripr_Acquire_once, &__block_literal_global_17584);
  }
  uint64_t v4 = *(char **)(a1 + 16);
  if (v4) {
    _ZF = v4 == (char *)(a1 + 168);
  }
  else {
    _ZF = 1;
  }
  if (_ZF)
  {
    uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x108uLL, 0x10E00409173D0FEuLL);
    aa_create();
    *((void *)v4 + 3) = v13;
    if (should_use_aaline)
    {
      int v14 = (char *)malloc_type_calloc(1uLL, 0xFE8uLL, 0xAFE08493uLL);
      *((void *)v14 + 31) = 0;
      *((void *)v14 + 22) = v14 + 248;
      *((void *)v14 + 23) = v14 + 248;
      *((_OWORD *)v14 + 16) = xmmword_1850CDEF0;
      *((_DWORD *)v14 + 42) = 0;
      *((int32x2_t *)v14 + 17) = vdup_n_s32(0x3D23D70Au);
      *((_DWORD *)v14 + 36) = 0;
      *((_DWORD *)v14 + 59) = 1065353216;
      *(_OWORD *)(v14 + 52) = xmmword_1850CDEE0;
      *(_OWORD *)(v14 + 104) = xmmword_1850CDF00;
      *((void *)v14 + 27) = 0;
      *(_OWORD *)int v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      *((_OWORD *)v14 + 2) = 0u;
      int v15 = malloc_type_malloc(0x1008uLL, 0x1020040EF3C788CuLL);
      if (v15)
      {
        *int v15 = 0;
        *((void *)v14 + 25) = v15 + 1;
        *((void *)v14 + 26) = v15 + 513;
        *((void *)v14 + 28) = v15;
LABEL_15:
        *((void *)v4 + 4) = v14;
        RIPLayerInitialize((uint64_t)(v4 + 120), v6, v7, v8, v9, v10, v11, v12);
        *(void *)(a1 + 16) = v4;
        goto LABEL_16;
      }
      free(v14);
    }
    int v14 = 0;
    goto LABEL_15;
  }
  aa_free_edges(*((void *)v4 + 3));
  uint64_t v16 = *((void *)v4 + 4);
  if (v16)
  {
    aal_free_edges(*((void *)v4 + 4));
    *(_OWORD *)(v16 + 52) = xmmword_1850CDEE0;
  }
LABEL_16:
  uint64_t v17 = *((void *)v4 + 3);
  int v18 = (float32x2_t *)*((void *)v4 + 4);
  v4[112] = 0;
  v4[113] = *(unsigned char *)(a2 + 32);
  __n128 v19 = *(int **)(a2 + 40);
  if (v19)
  {
    int v20 = (_DWORD *)*((void *)v4 + 9);
    int v22 = *v19;
    int v21 = v19[1];
    int v23 = v19[2];
    int v24 = v19[3];
    if (!v20 || *v20 != v22 || v20[1] != v21 || v20[2] != v23 || v20[3] != v24)
    {
      *((_DWORD *)v4 + 14) = v22;
      *((void *)v4 + 9) = v4 + 56;
      float v25 = (float)v22;
      float v26 = (float)v21;
      *((double *)v4 + 10) = (float)v22;
      *((double *)v4 + 11) = (float)v21;
      *((_DWORD *)v4 + 16) = v23;
      *((_DWORD *)v4 + 17) = v24;
      float v27 = (float)(v23 + v22);
      *((_DWORD *)v4 + 15) = v21;
      float v28 = (float)(v24 + v21);
      *((double *)v4 + 12) = v27;
      *((double *)v4 + 13) = v28;
      aa_clipping(v17, 7, (float)v22, (float)v21, v27, v28);
      if (v18)
      {
        float v29 = -262140.0;
        if (v25 >= -262140.0) {
          float v30 = v25;
        }
        else {
          float v30 = -262140.0;
        }
        if (v26 >= -262140.0) {
          float v29 = v26;
        }
        float v31 = 262140.0;
        if (v28 <= 262140.0) {
          float v32 = v28;
        }
        else {
          float v32 = 262140.0;
        }
        if (v27 <= 262140.0) {
          float v31 = v27;
        }
        if (v30 > v31)
        {
          float v30 = 0.0;
          float v31 = 0.0;
        }
        BOOL v33 = v29 > v32;
        if (v29 > v32) {
          float v29 = 0.0;
        }
        v18[13].f32[0] = v30;
        v18[13].f32[1] = v29;
        if (v33) {
          float v34 = 0.0;
        }
        else {
          float v34 = v32;
        }
        v18[14].f32[0] = v31;
        v18[14].f32[1] = v34;
      }
    }
  }
  else
  {
    aa_clipping(v17, 4, 0.0, 0.0, 0.0, 0.0);
    if (v18)
    {
      v18[14].i32[1] = 1216348096;
      *(float32x2_t *)((char *)&v18[13] + 4) = (float32x2_t)0x487FFFC0C87FFFC0;
    }
    *((void *)v4 + 9) = 0;
  }
  float v35 = *(double *)(a2 + 8);
  float v36 = *(double *)a2;
  float32x2_t v37 = vcvt_f32_f64(*(float64x2_t *)(a2 + 16));
  if (*((float *)v4 + 13) != v35
    || *((float *)v4 + 12) != v36
    || *((float *)v4 + 10) != v37.f32[0]
    || *((float *)v4 + 11) != v37.f32[1])
  {
    *((float *)v4 + 12) = v36;
    *((float *)v4 + 13) = v35;
    float v38 = fabsf(v36);
    *((float32x2_t *)v4 + 5) = v37;
    float32x2_t v39 = vabs_f32(v37);
    if (v38 < 0.015625) {
      float v38 = 0.015625;
    }
    float32x2_t v40 = vmul_f32(v39, (float32x2_t)vdup_n_s32(0x3C638E39u));
    __asm { FMOV            V3.2S, #1.0 }
    float32x2_t v45 = vmul_n_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(_D3, v40), (int8x8_t)_D3, (int8x8_t)v40), v38);
    float32x2_t v46 = vmul_f32(v45, (float32x2_t)vdup_n_s32(0x3E4CCCCDu));
    float32x2_t v47 = (float32x2_t)vdup_n_s32(0x3D4CCCCDu);
    float32x2_t v48 = (float32x2_t)vbsl_s8((int8x8_t)vcge_f32(v47, v46), (int8x8_t)v47, (int8x8_t)v46);
    float64x2_t v49 = vcvtq_f64_f32(vmul_f32(v48, v48));
    __asm { FMOV            V4.2D, #16.0 }
    float64x2_t v51 = (float64x2_t)vdupq_n_s64(0x3F70000000000000uLL);
    float64x2_t v52 = vmulq_f64(v49, _Q4);
    float64x2_t v53 = (float64x2_t)vdupq_n_s64(0x4110000000000000uLL);
    float64x2_t v54 = vmulq_f64(v49, (float64x2_t)vdupq_n_s64(0x3FFC71C71C71C71CuLL));
    *(int8x16_t *)(v17 + 96) = vbslq_s8((int8x16_t)vcgtq_f64(v51, v52), (int8x16_t)v51, vbslq_s8((int8x16_t)vcgtq_f64(v52, v53), (int8x16_t)v53, (int8x16_t)v52));
    *(int8x16_t *)(v17 + 112) = vbslq_s8((int8x16_t)vcgtq_f64(v51, v54), (int8x16_t)v51, vbslq_s8((int8x16_t)vcgtq_f64(v54, v53), (int8x16_t)v53, (int8x16_t)v54));
    if (v35 <= 1.0) {
      float v35 = 0.0;
    }
    *(double *)(v17 + 168) = v35;
    if (v18)
    {
      __asm { FMOV            V3.2S, #5.0 }
      float32x2_t v56 = vdiv_f32(v45, _D3);
      float32x2_t v57 = (float32x2_t)vbsl_s8((int8x8_t)vcge_f32(v47, v56), (int8x8_t)v47, (int8x8_t)v56);
      v18[17] = vmul_f32(v57, v57);
      v18[18].f32[0] = v35;
    }
  }
  return v4;
}

double aa_clipping(uint64_t a1, char a2, float a3, float a4, float a5, float a6)
{
  unsigned int v6 = *(_DWORD *)(a1 + 176) & 0xFFFCFFFF | 0x10000;
  *(_DWORD *)(a1 + 176) = v6;
  if ((a2 & 2) != 0)
  {
    if (a4 < -262140.0) {
      a4 = -262140.0;
    }
    if (a6 > 262140.0) {
      a6 = 262140.0;
    }
    if (a4 <= a6)
    {
      double v7 = a4;
      *(double *)(a1 + 72) = v7;
      double v8 = a6;
    }
    else
    {
      *(void *)(a1 + 72) = 0;
      double v8 = 0.0;
      double v7 = 0.0;
    }
  }
  else
  {
    *(void *)(a1 + 72) = 0xC10FFFF800000000;
    double v7 = -262143.0;
    double v8 = 262143.0;
  }
  *(double *)(a1 + 88) = v8;
  if (a2)
  {
    if (a3 < -262140.0) {
      a3 = -262140.0;
    }
    if (a5 > 262140.0) {
      a5 = 262140.0;
    }
    if (a3 <= a5)
    {
      double result = a3;
      *(double *)(a1 + 64) = result;
      double v10 = a5;
    }
    else
    {
      *(void *)(a1 + 64) = 0;
      double v10 = 0.0;
      double result = 0.0;
    }
  }
  else
  {
    *(void *)(a1 + 64) = 0xC10FFFF800000000;
    double result = -262143.0;
    double v10 = 262143.0;
  }
  *(double *)(a1 + 80) = v10;
  if (*(_DWORD *)(a1 + 180))
  {
    double v12 = *(double *)(a1 + 32);
    double v11 = *(double *)(a1 + 40);
    double v14 = *(double *)(a1 + 48);
    double v13 = *(double *)(a1 + 56);
    if (v14 <= v10) {
      double v15 = *(double *)(a1 + 48);
    }
    else {
      double v15 = v10;
    }
    BOOL v16 = v13 > v8;
    if (v13 > v8) {
      double v17 = v8;
    }
    else {
      double v17 = *(double *)(a1 + 56);
    }
    BOOL v18 = v13 < v7;
    if (v13 < v7) {
      double v19 = v7;
    }
    else {
      double v19 = v17;
    }
    int v20 = (v14 > v10) | (4 * (v14 < result));
    int v21 = (2 * v16) | (8 * v18);
    if (v14 < result) {
      double v22 = result;
    }
    else {
      double v22 = v15;
    }
    if (v21) {
      BOOL v23 = v20 == 0;
    }
    else {
      BOOL v23 = 1;
    }
    if (v23) {
      int v24 = 0;
    }
    else {
      int v24 = 16;
    }
    BOOL v25 = v12 > v10;
    if (v12 <= v10) {
      double v10 = *(double *)(a1 + 32);
    }
    BOOL v26 = v11 > v8;
    if (v11 <= v8) {
      double v8 = *(double *)(a1 + 40);
    }
    BOOL v27 = v11 < v7;
    if (v11 >= v7) {
      double v7 = v8;
    }
    int v28 = v25 | (4 * (v12 < result));
    int v29 = (2 * v26) | (8 * v27);
    if (v12 >= result) {
      double result = v10;
    }
    if (v29) {
      BOOL v30 = v28 == 0;
    }
    else {
      BOOL v30 = 1;
    }
    if (v30) {
      int v31 = 0;
    }
    else {
      int v31 = 16;
    }
    double v32 = *(double *)(a1 + 160);
    double v33 = *(double *)(a1 + 128);
    double v34 = *(double *)(a1 + 136);
    int v35 = v28 | v29 | v31;
    *(_DWORD *)(a1 + 24) = (int)(v32 + v33 * v22);
    *(_DWORD *)(a1 + 28) = (int)(v32 + v34 * v19);
    int v36 = (int)(v32 + v33 * result);
    double result = v32 + v34 * v7;
    *(_DWORD *)(a1 + 16) = v36;
    *(_DWORD *)(a1 + 20) = (int)result;
    *(_DWORD *)(a1 + 176) = v24 | v6 & 0xFFFD0000 | (v35 << 8) | v20 | v21;
  }
  return result;
}

uint64_t CGContextGetDelegate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108) {
    return *(void *)(a1 + 40);
  }
  handle_invalid_context((char)"CGContextGetDelegate", a1, a3, a4, a5, a6, a7, a8);
  return 0;
}

void RIPUnlockCacheState()
{
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v0 = (os_unfair_lock_s *)RIPGetCacheState_cache_state;

  os_unfair_lock_unlock(v0);
}

void RIPLockCacheState()
{
  if (RIPGetCacheState_predicate != -1) {
    dispatch_once(&RIPGetCacheState_predicate, &__block_literal_global_10_13511);
  }
  uint64_t v0 = (os_unfair_lock_s *)RIPGetCacheState_cache_state;

  os_unfair_lock_lock(v0);
}

uint64_t CGColorTransformGetMD5(void *a1, uint64_t a2)
{
  if (!a1) {
    goto LABEL_7;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  if (v4 == CGColorTransformGetTypeID_type_id)
  {
    Cache = CGColorTransformGetCache(a1);
    if (Cache) {
      long long v6 = *(_OWORD *)(Cache + 3);
    }
    else {
      long long v6 = 0uLL;
    }
    *(_OWORD *)a2 = v6;
    return 1;
  }
  else
  {
LABEL_7:
    uint64_t result = 0;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t CGBitmapFreeData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 0x1F) != 0) {
    _CGHandleAssert("CGBitmapFreeData", 202, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/API/CGBitmapContext.c", "(uintptr_t)q % bitmap_alignment == 0", "data(%p) is unaligned", a6, a7, a8, a1);
  }
  size_t v8 = *(void *)(a1 - 16);
  uint64_t v9 = (void *)(a1 - *(void *)(a1 - 8));

  return munmap(v9, v8);
}

void RIPClipStateRemoveEntry(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  CFTypeID v4 = (void *)a2[1];
  *(void *)(v5 + 8) = v4;
  *CFTypeID v4 = v5;
  *a2 = (uint64_t)a2;
  a2[1] = (uint64_t)a2;
  uint64_t v6 = a2[11];
  if ((unint64_t)(v6 + 1) >= 2) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  free(a2);
  --*(_DWORD *)(a1 + 40);
}

CGFloat CGGStateResetClip(uint64_t a1)
{
  CGClipStackRelease(*(void **)(a1 + 112));
  uint64_t v2 = (char *)malloc_type_malloc(0x98uLL, 0x2062DE7BuLL);
  *(_DWORD *)uint64_t v2 = 1;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 2) = 0;
  CGFloat result = CGRectInfinite.origin.x;
  *(CGRect *)(v2 + 48) = CGRectInfinite;
  *(CGRect *)(v2 + 80) = CGRectInfinite;
  *(CGRect *)(v2 + 16) = CGRectInfinite;
  *((void *)v2 + 15) = 0;
  *((void *)v2 + 16) = 0;
  *((void *)v2 + 14) = 3;
  *(void *)(a1 + 112) = v2;
  *(CGRect *)(a1 + 80) = CGRectInfinite;
  *(unsigned char *)(a1 + 20) &= ~1u;
  return result;
}

dispatch_once_t RIPLayerCoverage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  dispatch_once_t result = RIPGetDepthForLayerFormat(0, a2, a3, a4, a5, a6, a7, a8);
  if (v9 != result)
  {
    uint64_t v18 = *(void *)(a1 + 32);
    dispatch_once_t result = RIPGetDepthForLayerFormat(1u, v11, v12, v13, v14, v15, v16, v17);
    if (v18 == result && !*(void *)(a1 + 72))
    {
      dispatch_once_t result = RIPGetDepthForLayerFormat(0, v19, v20, v21, v22, v23, v24, v25);
      *(void *)(a1 + 32) = result;
    }
  }
  return result;
}

uint64_t CGColorTransformConvertColorFloatComponents(void *a1, void *a2, unsigned int a3, uint64_t a4, float *a5, uint64_t a6)
{
  if (a2) {
    uint64_t v10 = *(void *)(a2[3] + 48);
  }
  else {
    uint64_t v10 = 0;
  }
  Cache = CGColorTransformGetCache(a1);
  if (Cache)
  {
    uint64_t v12 = Cache[2];
    if (v12) {
      uint64_t v12 = *(void *)(*(void *)(v12 + 24) + 48);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  if (a6)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 4 * v10;
    uint64_t v15 = 4 * v12;
    do
    {
      if (a2)
      {
        uint64_t v16 = *(void *)(a2[3] + 48);
        uint64_t v17 = (double *)malloc_type_malloc(8 * v16, 0x100004000313F17uLL);
        uint64_t v18 = v17;
        if (v16)
        {
          for (uint64_t i = 0; i != v16; ++i)
            v17[i] = *(float *)(a4 + 4 * i);
        }
      }
      else
      {
        uint64_t v18 = (double *)malloc_type_malloc(0, 0x100004000313F17uLL);
      }
      uint64_t v20 = CGColorTransformGetCache(a1);
      if (v20 && (uint64_t v21 = v20[2]) != 0) {
        uint64_t v22 = *(void *)(*(void *)(v21 + 24) + 48);
      }
      else {
        uint64_t v22 = 0;
      }
      uint64_t v23 = (double *)malloc_type_malloc(8 * v22, 0x100004000313F17uLL);
      CGColorTransformConvertColorComponents((uint64_t)a1, a2, a3, v18, v23);
      uint64_t v24 = v23;
      for (uint64_t j = a5; v22; --v22)
      {
        double v26 = *v24++;
        float v27 = v26;
        *j++ = v27;
      }
      free(v23);
      free(v18);
      ++v13;
      a4 += v14;
      a5 = (float *)((char *)a5 + v15);
    }
    while (v13 != a6);
  }
  return 1;
}

BOOL rips_s_Growth(uint64_t a1, _OWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 12);
  if (v2) {
    *a2 = *(_OWORD *)(a1 + 96);
  }
  return v2 != 0;
}

uint64_t rips_Create(__n128 a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  unint64_t v3 = a1.n128_u64[0];
  switch(*(_DWORD *)(a3 + 20))
  {
    case 1:
      if (RIPStyleShadow_predicate != -1) {
        dispatch_once(&RIPStyleShadow_predicate, &__block_literal_global_8296);
      }
      CFTypeID v4 = &RIPStyleShadow_rips_s_cls;
      break;
    case 2:
      if (RIPStyleFocusRing_predicate != -1) {
        dispatch_once(&RIPStyleFocusRing_predicate, &__block_literal_global_10220);
      }
      CFTypeID v4 = &RIPStyleFocusRing_rips_f_cls;
      break;
    case 3:
      if (RIPStyleGaussianBlur_predicate != -1) {
        dispatch_once(&RIPStyleGaussianBlur_predicate, &__block_literal_global_18950);
      }
      CFTypeID v4 = &RIPStyleGaussianBlur_rips_gb_cls;
      break;
    case 4:
      if (RIPStyleColorMatrix_predicate != -1) {
        dispatch_once(&RIPStyleColorMatrix_predicate, &__block_literal_global_18050);
      }
      CFTypeID v4 = &RIPStyleColorMatrix_rips_cm_cls;
      break;
    default:
      return 0;
  }
  uint64_t v6 = (uint64_t (*)(__n128))*((void *)v4 + 4);
  a1.n128_u64[0] = v3;

  return v6(a1);
}

void rips_s_release(_DWORD *a1)
{
  int v1 = a1[2] - 1;
  a1[2] = v1;
  if (!v1)
  {
    unint64_t v3 = (const void *)*((void *)a1 + 10);
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

void *RIPLayerIntersect(void *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v9 = (uint64_t)result;
    if (*a2 && result != 0)
    {
      if (*result)
      {
        uint64_t v11 = (void *)result[4];
        if (v11 == (void *)a2[4])
        {
          dispatch_once_t result = (void *)RIPGetDepthForLayerFormat(0, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
          if (v11 == result)
          {
            return (void *)ripl_Combine(v9, (uint64_t)a2, 0);
          }
        }
      }
    }
  }
  return result;
}

uint64_t ripl_retain(uint64_t a1)
{
  int v2 = (pthread_mutex_t *)(a1 + 80);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
  int v3 = *(_DWORD *)(a1 + 8);
  if (v3 != -1) {
    *(_DWORD *)(a1 + 8) = v3 + 1;
  }

  return pthread_mutex_unlock(v2);
}

void CGContextClip(CGContextRef c)
{
  clip((uint64_t)c, 0, v1, v2, v3, v4, v5, v6);
}

void CGContextSetCTM(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      uint64_t v8 = *(void *)(a1 + 96);
      long long v9 = *a2;
      long long v10 = a2[1];
      *(_OWORD *)(v8 + 56) = a2[2];
      *(_OWORD *)(v8 + 40) = v10;
      *(_OWORD *)(v8 + 24) = v9;
      return;
    }
    uint64_t v11 = a1;
  }
  else
  {
    uint64_t v11 = 0;
  }
  handle_invalid_context((char)"CGContextSetCTM", v11, a3, a4, a5, a6, a7, a8);
}

uint64_t CGSNewEmptyRegion(void *a1)
{
  if (!a1) {
    return 1001;
  }
  if (CGRegionGetTypeID_initOnce != -1) {
    dispatch_once(&CGRegionGetTypeID_initOnce, &__block_literal_global_14714);
  }
  uint64_t result = 0;
  *a1 = &__kCGRegionEmptyRegion;
  return result;
}

double CGContextDelegateGetBounds(uint64_t a1)
{
  if (!a1) {
    return INFINITY;
  }
  uint64_t v1 = *(void (**)(void))(a1 + 48);
  if (!v1) {
    return -8.98846567e307;
  }
  v1();
  return result;
}

CGFloat dlRecorder_GetBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    long long v9 = (char *)CG::DisplayListRecorder::currentDisplayList(v8);
    long long v10 = &CGRectZero;
    if (v9) {
      long long v10 = (const CGRect *)(v9 + 40);
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_GetBounds");
    long long v10 = &CGRectNull;
  }
  return v10->origin.x;
}

uint64_t dlRecorder_DrawGlyphs(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, const CGGlyph *a5, double *a6, size_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)"dlRecorder_DrawGlyphs");
    return 1000;
  }
  uint64_t v15 = (double *)CG::DisplayListRecorder::currentDisplayList(v8);
  if (!v15) {
    return 1000;
  }
  uint64_t v16 = v15;
  if (v15[5] == INFINITY || v15[6] == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v16[7] != 0.0 && v16[8] != 0.0)
  {
    long long v19 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)&v144.double a = *(_OWORD *)(a3 + 24);
    *(_OWORD *)&v144.double c = v19;
    *(_OWORD *)&v144.double tx = *(_OWORD *)(a3 + 56);
    uint64_t v20 = *(void *)(a3 + 136);
    double v21 = *(double *)(v20 + 16);
    unsigned int v22 = *(char *)(v20 + 1);
    if (!*((unsigned char *)v16 + 73))
    {
LABEL_84:
      int v98 = v16 + 2;
      if (CG::DisplayList::fontResourceForFont((CG::DisplayList *)(v16 + 2), *(CGFont **)(v20 + 8)))
      {
        EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v16 + 2), (void *)a3, a2);
        uint64_t v107 = EntryDrawingState[1];
        if (v107)
        {
          int v108 = *(_DWORD *)(v107 + 8);
          uint64_t v109 = EntryDrawingState[2];
          if (v109) {
            v108 |= *(_DWORD *)(v109 + 8);
          }
          int v110 = v108 & 0x1000;
          uint64_t v111 = EntryDrawingState[3];
          if (v111) {
            v110 |= *(_DWORD *)(v111 + 8) & 0x3400;
          }
          uint64_t v112 = *(CGColor **)(*(void *)(a3 + 136) + 64);
          if (v112) {
            CG::DisplayList::colorResourceForColor((CG::DisplayList *)(v16 + 2), v112, v100, v101, v102, v103, v104, v105, v106);
          }
          uint64_t v113 = 0;
          if (v22 > 6) {
            goto LABEL_112;
          }
          if (((1 << v22) & 0x11) != 0)
          {
            uint64_t FillColor = CGGStateGetFillColor(a3);
            uint64_t v118 = (*(uint64_t (**)(double *, uint64_t))(*(void *)v98 + 8))(v16 + 2, FillColor);
            uint64_t v113 = (const CG::DisplayListResourceColor *)v118;
            if (v118) {
              int v119 = *(_DWORD *)(v118 + 8) & 0x3400 | 0x100;
            }
            else {
              LOWORD(v119) = 256;
            }
          }
          else
          {
            if (((1 << v22) & 0x22) == 0)
            {
              if (((1 << v22) & 0x44) != 0)
              {
                uint64_t v114 = CGGStateGetFillColor(a3);
                uint64_t v115 = (*(uint64_t (**)(double *, uint64_t))(*(void *)v98 + 8))(v16 + 2, v114);
                uint64_t v113 = (const CG::DisplayListResourceColor *)v115;
                if (v115) {
                  int v116 = *(_DWORD *)(v115 + 8) & 0x3400 | 0x100;
                }
                else {
                  LOWORD(v116) = 256;
                }
                uint64_t StrokeColor = CGGStateGetStrokeColor(a3);
                uint64_t v123 = (*(uint64_t (**)(double *, uint64_t))(*(void *)v98 + 8))(v16 + 2, StrokeColor);
                if (v123) {
                  int v124 = *(_DWORD *)(v123 + 8) & 0x3400 | 0x200;
                }
                else {
                  LOWORD(v124) = 512;
                }
                LOWORD(v110) = v116 | v124 | v110;
              }
              goto LABEL_112;
            }
            uint64_t v120 = CGGStateGetStrokeColor(a3);
            uint64_t v121 = (*(uint64_t (**)(double *, uint64_t))(*(void *)v98 + 8))(v16 + 2, v120);
            if (v121) {
              int v119 = *(_DWORD *)(v121 + 8) & 0x3400 | 0x200;
            }
            else {
              LOWORD(v119) = 512;
            }
            uint64_t v113 = 0;
          }
          LOWORD(v110) = v110 | v119;
LABEL_112:
          uint64_t v125 = *(void *)(a3 + 120);
          __int16 v126 = v110 | 0x1000;
          if (*(double *)(v125 + 8) < 1.0) {
            LOWORD(v110) = v110 | 0x1000;
          }
          if ((v110 & 0x1000) == 0 && (((int)(*(_DWORD *)(v125 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE) {
            LOWORD(v110) = v126;
          }
          if ((v110 & 0x3000) != 0) {
            *((_DWORD *)v16 + 20) |= v110 & 0x3000;
          }
          if (*((unsigned char *)v16 + 74))
          {
            if ((v110 & 0x400) != 0) {
              CG::DisplayList::getEntryPatternState((uint64_t)(v16 + 2), a3, a2);
            }
            if ((v110 & 0x100) != 0) {
              CG::DisplayList::getEntryFillState((CG::DisplayList *)(v16 + 2), v113);
            }
            if ((v110 & 0x200) != 0) {
              CG::DisplayList::getEntryStrokeState((uint64_t)(v16 + 2), a3);
            }
            operator new();
          }
          return 0;
        }
      }
      return 1000;
    }
    unsigned int v130 = *(char *)(v20 + 1);
    uint64_t v23 = *(CGFont **)(v20 + 8);
    int v24 = *((unsigned __int8 *)v16 + 76);
    font_float64x2_t info = get_font_info(v23);
    if (font_info) {
      int v26 = font_info[2];
    }
    else {
      int v26 = 0;
    }
    double v27 = (double)v26;
    double v28 = *a4;
    double v29 = a4[1];
    double v31 = a4[2];
    double v30 = a4[3];
    double v32 = a4[4];
    double v33 = v21 / (double)v26;
    double v34 = *a4 * v33;
    double v35 = v33 * v29;
    double v36 = v33 * v31;
    double v37 = v33 * v30;
    double v140 = a4[5];
    if (v24)
    {
      CGFloat v127 = v34;
      CGFloat v128 = v35;
      CGFloat v132 = v36;
      CGFloat v133 = v37;
      if (a7 <= 0x7FFFFFFFFFFFFFELL) {
        float v38 = (CGRect *)malloc_type_malloc(32 * a7, 0x22160ABFuLL);
      }
      else {
        float v38 = 0;
      }
      float64x2_t v129 = v38;
      if (CGFontGetGlyphBBoxes(v23, a5, a7, v38))
      {
        if (a7)
        {
          p_size_t size = &v38->size;
          float32x2_t v56 = a6 + 1;
          double v131 = v28;
          CGFloat height = 0.0;
          CGFloat y = INFINITY;
          size_t v59 = a7;
          CGFloat width = 0.0;
          CGFloat x = INFINITY;
          double v135 = v32;
          double v137 = v30;
          do
          {
            double v62 = *(v56 - 1);
            CGFloat v63 = v135 + v31 * *v56 + v131 * v62;
            CGFloat v64 = v140 + v137 * *v56 + v29 * v62;
            CGRect v148 = *(CGRect *)&p_size[-1].width;
            p_size += 2;
            v145.double a = v127;
            v145.double b = v128;
            v145.double c = v132;
            v145.double d = v133;
            v145.double tx = 0.0;
            v145.double ty = 0.0;
            CGRect v149 = CGRectApplyAffineTransform(v148, &v145);
            CGRect v161 = CGRectOffset(v149, v63, v64);
            v150.origin.CGFloat x = x;
            v150.origin.CGFloat y = y;
            v150.size.CGFloat width = width;
            v150.size.CGFloat height = height;
            CGRect v151 = CGRectUnion(v150, v161);
            CGFloat x = v151.origin.x;
            CGFloat y = v151.origin.y;
            CGFloat width = v151.size.width;
            CGFloat height = v151.size.height;
            v56 += 2;
            --v59;
          }
          while (v59);
        }
        else
        {
          CGFloat width = 0.0;
          CGFloat x = INFINITY;
          CGFloat y = INFINITY;
          CGFloat height = 0.0;
        }
      }
      else
      {
        v152.origin.CGFloat x = -v27;
        v152.size.CGFloat width = v27 + v27;
        v145.double a = v127;
        v145.double b = v128;
        v145.double c = v132;
        v145.double d = v133;
        v145.double tx = 0.0;
        v145.double ty = 0.0;
        v152.origin.CGFloat y = -v27;
        v152.size.CGFloat height = v27 + v27;
        CGRect v153 = CGRectApplyAffineTransform(v152, &v145);
        double v65 = a6[1];
        double v66 = v32 + v31 * v65 + v28 * *a6;
        double v67 = v140 + v30 * v65 + v29 * *a6;
        if (a7 < 2)
        {
          double v73 = v32 + v31 * v65 + v28 * *a6;
          double v72 = v67;
        }
        else
        {
          double v68 = v32;
          double v69 = v30;
          size_t v70 = a7 - 1;
          BOOL v71 = a6 + 3;
          double v72 = v140 + v30 * v65 + v29 * *a6;
          double v73 = v66;
          do
          {
            double v74 = *(v71 - 1);
            double v75 = v68 + v31 * *v71 + v28 * v74;
            double v76 = v140 + v69 * *v71 + v29 * v74;
            if (v75 > v73) {
              double v77 = v75;
            }
            else {
              double v77 = v73;
            }
            if (v75 < v66) {
              double v66 = v75;
            }
            else {
              double v73 = v77;
            }
            if (v76 >= v67)
            {
              if (v76 > v72) {
                double v72 = v76;
              }
            }
            else
            {
              double v67 = v76;
            }
            v71 += 2;
            --v70;
          }
          while (v70);
        }
        CGFloat v84 = v153.origin.x;
        CGFloat v85 = v153.origin.y;
        CGFloat v86 = v153.size.width;
        CGFloat v87 = v153.size.height;
        CGRect v157 = CGRectOffset(v153, v66, v67);
        CGFloat v88 = v157.origin.x;
        CGFloat v89 = v157.origin.y;
        CGFloat v139 = v157.size.height;
        CGFloat v142 = v157.size.width;
        v157.origin.CGFloat x = v84;
        v157.origin.CGFloat y = v85;
        v157.size.CGFloat width = v86;
        v157.size.CGFloat height = v87;
        CGRect v163 = CGRectOffset(v157, v73, v72);
        v158.origin.CGFloat x = v88;
        v158.origin.CGFloat y = v89;
        v158.size.CGFloat height = v139;
        v158.size.CGFloat width = v142;
        CGRect v159 = CGRectUnion(v158, v163);
        CGFloat x = v159.origin.x;
        CGFloat y = v159.origin.y;
        CGFloat width = v159.size.width;
        CGFloat height = v159.size.height;
      }
      free(v129);
      unsigned int v22 = v130;
    }
    else
    {
      double v134 = a4[4];
      double v136 = a4[3];
      CGFloat v39 = v37;
      CGFloat v40 = v36;
      CGFloat v41 = v35;
      CGFloat v42 = v34;
      FontBBoCGFloat x = CGFontGetFontBBox(v23);
      BOOL v43 = FontBBox.origin.x == INFINITY || FontBBox.origin.y == INFINITY;
      v145.double a = v42;
      v145.double b = v41;
      if (v43) {
        FontBBox.origin.CGFloat x = -v27;
      }
      if (v43) {
        FontBBox.origin.CGFloat y = -v27;
      }
      if (v43) {
        FontBBox.size.CGFloat width = v27 + v27;
      }
      v145.double c = v40;
      v145.double d = v39;
      if (v43) {
        FontBBox.size.CGFloat height = v27 + v27;
      }
      v145.double tx = 0.0;
      v145.double ty = 0.0;
      CGRect v147 = CGRectApplyAffineTransform(FontBBox, &v145);
      double v44 = a6[1];
      double v45 = v134 + v31 * v44 + v28 * *a6;
      double v46 = v140 + v136 * v44 + v29 * *a6;
      if (a7 < 2)
      {
        double v50 = v134 + v31 * v44 + v28 * *a6;
        double v49 = v140 + v136 * v44 + v29 * *a6;
        unsigned int v22 = v130;
      }
      else
      {
        size_t v47 = a7 - 1;
        float32x2_t v48 = a6 + 3;
        double v49 = v140 + v136 * v44 + v29 * *a6;
        double v50 = v134 + v31 * v44 + v28 * *a6;
        unsigned int v22 = v130;
        do
        {
          double v51 = *(v48 - 1);
          double v52 = v134 + v31 * *v48 + v28 * v51;
          double v53 = v140 + v136 * *v48 + v29 * v51;
          if (v52 > v50) {
            double v54 = v52;
          }
          else {
            double v54 = v50;
          }
          if (v52 < v45) {
            double v45 = v52;
          }
          else {
            double v50 = v54;
          }
          if (v53 >= v46)
          {
            if (v53 > v49) {
              double v49 = v53;
            }
          }
          else
          {
            double v46 = v53;
          }
          v48 += 2;
          --v47;
        }
        while (v47);
      }
      CGFloat v78 = v147.origin.x;
      CGFloat v79 = v147.origin.y;
      CGFloat v80 = v147.size.width;
      CGFloat v81 = v147.size.height;
      CGRect v154 = CGRectOffset(v147, v45, v46);
      CGFloat v82 = v154.origin.x;
      CGFloat v83 = v154.origin.y;
      CGFloat v138 = v154.size.height;
      CGFloat v141 = v154.size.width;
      v154.origin.CGFloat x = v78;
      v154.origin.CGFloat y = v79;
      v154.size.CGFloat width = v80;
      v154.size.CGFloat height = v81;
      CGRect v162 = CGRectOffset(v154, v50, v49);
      v155.origin.CGFloat x = v82;
      v155.origin.CGFloat y = v83;
      v155.size.CGFloat height = v138;
      v155.size.CGFloat width = v141;
      CGRect v156 = CGRectUnion(v155, v162);
      CGFloat x = v156.origin.x;
      CGFloat y = v156.origin.y;
      CGFloat width = v156.size.width;
      CGFloat height = v156.size.height;
    }
    CGAffineTransform v145 = v144;
    v160.origin.CGFloat x = x;
    v160.origin.CGFloat y = y;
    v160.size.CGFloat width = width;
    v160.size.CGFloat height = height;
    CGRect v143 = CGRectApplyAffineTransform(v160, &v145);
    v143.origin.CGFloat x = CG::DisplayListRecorder::adjustBoundingBoxToIncludeStroke(&v143, a3);
    v143.origin.CGFloat y = v90;
    v143.size.CGFloat width = v91;
    v143.size.CGFloat height = v92;
    CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v143.origin.x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
    v143.origin.CGFloat x = v96;
    v143.origin.CGFloat y = v93;
    v143.size.CGFloat width = v94;
    v143.size.CGFloat height = v95;
    if (v96 == INFINITY || v93 == INFINITY) {
      return 0;
    }
    uint64_t result = 0;
    if (v94 != 0.0 && v95 != 0.0)
    {
      uint64_t v20 = *(void *)(a3 + 136);
      goto LABEL_84;
    }
  }
  return result;
}

void sub_184C33C28(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10F1C4091CD020ALL);
  _Unwind_Resume(a1);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    if (rect.origin.x == -8.98846567e307
      && rect.origin.y == -8.98846567e307
      && rect.size.width == 1.79769313e308
      && rect.size.height == 1.79769313e308)
    {
      rect.size.CGFloat width = 1.79769313e308;
      rect.origin.CGFloat x = -8.98846567e307;
      rect.origin.CGFloat y = -8.98846567e307;
      rect.size.CGFloat height = 1.79769313e308;
      return rect;
    }
    v42[3] = v2;
    v42[4] = v3;
    if (rect.size.width < 0.0 || rect.size.height < 0.0) {
      rect = CGRectStandardize(rect);
    }
    double v9 = rect.origin.x + rect.size.width;
    double v10 = rect.origin.y + rect.size.height;
    double a = t->a;
    double b = t->b;
    double c = t->c;
    double d = t->d;
    double tx = t->tx;
    double ty = t->ty;
    double v17 = rect.origin.y * d;
    if (b == 0.0 && c == 0.0)
    {
      double v18 = rect.origin.y * 0.0 + a * rect.origin.x + tx;
      double v19 = v17 + rect.origin.x * 0.0 + ty;
      double v39 = v19;
      double v40 = v18;
      double v41 = v19;
      v42[0] = v18;
      double v20 = v10 * 0.0 + a * v9 + tx;
      double v21 = v10 * d + v9 * 0.0 + ty;
      if (v20 >= v18)
      {
        if (v20 <= v18) {
          goto LABEL_53;
        }
        unsigned int v22 = &v40;
      }
      else
      {
        unsigned int v22 = v42;
      }
      *unsigned int v22 = v20;
LABEL_53:
      BOOL v37 = v21 <= v19;
      if (v21 < v19) {
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    CGFloat v23 = rect.origin.y * c;
    double v24 = v17 + b * rect.origin.x + ty;
    double v39 = v24;
    double v40 = v23 + a * rect.origin.x + tx;
    double v41 = v24;
    v42[0] = v40;
    double v25 = v23 + a * v9 + tx;
    double v26 = v17 + b * v9 + ty;
    if (v25 >= v40)
    {
      if (v25 <= v40) {
        goto LABEL_28;
      }
      double v27 = &v40;
    }
    else
    {
      double v27 = v42;
    }
    *double v27 = v25;
LABEL_28:
    if (v26 >= v24)
    {
      if (v26 <= v24) {
        goto LABEL_33;
      }
      double v28 = &v39;
    }
    else
    {
      double v28 = &v41;
    }
    *double v28 = v26;
LABEL_33:
    double v29 = v10 * c;
    double v30 = v10 * c + a * v9 + tx;
    double v31 = v10 * d;
    double v32 = v31 + b * v9 + ty;
    if (v30 >= v42[0])
    {
      if (v30 <= v40) {
        goto LABEL_38;
      }
      double v33 = &v40;
    }
    else
    {
      double v33 = v42;
    }
    *double v33 = v30;
LABEL_38:
    if (v32 >= v41)
    {
      if (v32 <= v39) {
        goto LABEL_43;
      }
      double v34 = &v39;
    }
    else
    {
      double v34 = &v41;
    }
    *double v34 = v32;
LABEL_43:
    double v35 = v29 + a * rect.origin.x + tx;
    double v21 = v31 + b * rect.origin.x + ty;
    if (v35 >= v42[0])
    {
      if (v35 <= v40)
      {
LABEL_48:
        if (v21 < v41)
        {
LABEL_54:
          float v38 = &v41;
          goto LABEL_57;
        }
        BOOL v37 = v21 <= v39;
LABEL_55:
        if (v37)
        {
LABEL_58:
          rect.origin.CGFloat y = v41;
          rect.origin.CGFloat x = v42[0];
          rect.size.CGFloat width = v40 - v42[0];
          rect.size.CGFloat height = v39 - v41;
          return rect;
        }
        float v38 = &v39;
LABEL_57:
        *float v38 = v21;
        goto LABEL_58;
      }
      double v36 = &v40;
    }
    else
    {
      double v36 = v42;
    }
    *double v36 = v35;
    goto LABEL_48;
  }
  return rect;
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    if (rect.size.width < 0.0 || rect.size.height < 0.0) {
      rect = CGRectStandardize(rect);
    }
    rect.origin.CGFloat x = rect.origin.x + dx;
    rect.origin.CGFloat y = rect.origin.y + dy;
  }
  return rect;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY)
  {
    if (rect.size.width < 0.0 || rect.size.height < 0.0) {
      rect = CGRectStandardize(rect);
    }
    double x = rect.origin.x;
    double y = rect.origin.y;
    double v8 = rect.size.width + dx * -2.0;
    rect.size.CGFloat width = 0.0;
    rect.origin.double x = INFINITY;
    if (v8 < 0.0)
    {
      rect.origin.double y = INFINITY;
      rect.size.CGFloat height = 0.0;
    }
    else
    {
      double v9 = rect.size.height + dy * -2.0;
      rect.origin.double y = INFINITY;
      rect.size.CGFloat height = 0.0;
      if (v9 >= 0.0)
      {
        rect.origin.double y = y + dy;
        rect.origin.double x = x + dx;
        rect.size.CGFloat width = v8;
        rect.size.CGFloat height = v9;
      }
    }
  }
  return rect;
}

const void *CG::DisplayListRecorder::currentDisplayList(CFArrayRef *this)
{
  CFIndex Count = CFArrayGetCount(this[1]);
  if (Count)
  {
    CFIndex v10 = Count - 1;
    CFArrayRef v11 = this[1];
    return CFArrayGetValueAtIndex(v11, v10);
  }
  else
  {
    CGPostError((uint64_t)"%s: displayListStack underflow", v3, v4, v5, v6, v7, v8, v9, (char)"CGDisplayListRef CG::DisplayListRecorder::currentDisplayList()");
    return 0;
  }
}

void CG::DisplayList::appendEntry(CG::DisplayList *this, const CG::DisplayListEntry *a2)
{
  uint64_t v4 = (char *)this + 8 * *((char *)a2 + 8);
  ++*((void *)v4 + 94);
  if ((*((unsigned char *)a2 + 10) & 0x10) != 0) {
    *((_DWORD *)this + 150) = (*((void *)this + 73) - *((void *)this + 72)) >> 4;
  }
  if (*((unsigned char *)this + 57))
  {
    CGSize v5 = (CGSize)*((_OWORD *)a2 + 2);
    v14.CGPoint origin = (CGPoint)*((_OWORD *)a2 + 1);
    v14.size_t size = v5;
    CG::DisplayList::updateBoundingAndTransparentShapes(this, &v14, *((_DWORD *)a2 + 2) >> 8);
  }
  (*(void (**)(const CG::DisplayListEntry *, void))(*(void *)a2 + 32))(a2, *((void *)this + 15));
  unint64_t v6 = *((void *)this + 73);
  unint64_t v7 = *((void *)this + 74);
  if (v6 < v7) {
    std::shared_ptr<CG::DisplayListEntry const>::shared_ptr[abi:fe180100]<CG::DisplayListEntry const,void>(*((void **)this + 73), (uint64_t)a2);
  }
  uint64_t v8 = *((void *)this + 72);
  uint64_t v9 = (uint64_t)(v6 - v8) >> 4;
  if (!((unint64_t)(v9 + 1) >> 60))
  {
    uint64_t v10 = v7 - v8;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      CGFloat v12 = 1.28822975e-231;
    }
    else {
      CGFloat v12 = *(double *)&v11;
    }
    uint64_t v15 = (char *)this + 592;
    if (v12 == 0.0) {
      uint64_t v13 = 0;
    }
    else {
      CGFloat v12 = COERCE_DOUBLE(std::__allocate_at_least[abi:fe180100]<std::allocator<CGPoint>>(*(unint64_t *)&v12));
    }
    v14.origin.double x = v12;
    *(void *)&v14.origin.double y = *(void *)&v12 + 16 * v9;
    v14.size.CGFloat width = v14.origin.y;
    *(void *)&v14.size.CGFloat height = *(void *)&v12 + 16 * v13;
    std::shared_ptr<CG::DisplayListEntry const>::shared_ptr[abi:fe180100]<CG::DisplayListEntry const,void>(*(void **)&v14.origin.y, (uint64_t)a2);
  }
  std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:fe180100]();
}

void sub_184C341C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CG::DisplayList::updateBoundingAndTransparentShapes(CG::DisplayList *this, const CGRect *a2, __int16 a3)
{
  if (*((unsigned char *)this + 57))
  {
    *(CGRect *)((char *)this + 72) = CGRectUnion(*(CGRect *)((char *)this + 72), *a2);
    if ((a3 & 0x1000) != 0)
    {
      unint64_t v6 = (char **)*((void *)this + 13);
      CGRect v27 = CGRectIntegral(*a2);
      double x = v27.origin.x;
      double y = v27.origin.y;
      double width = v27.size.width;
      double height = v27.size.height;
      if (v27.size.width < 0.0 || v27.size.height < 0.0)
      {
        double v17 = COERCE_DOUBLE(CGRectStandardize(v27));
        if (v17 <= 1073741820.0) {
          double v18 = v17;
        }
        else {
          double v18 = 1073741820.0;
        }
        if (v17 >= -1073741820.0) {
          uint64_t v13 = (int)v18;
        }
        else {
          uint64_t v13 = 3221225472;
        }
        v28.origin.double x = x;
        v28.origin.double y = y;
        v28.size.double width = width;
        v28.size.double height = height;
        CGRect v29 = CGRectStandardize(v28);
        if (v29.origin.y <= 1073741820.0) {
          double v19 = v29.origin.y;
        }
        else {
          double v19 = 1073741820.0;
        }
        if (v29.origin.y >= -1073741820.0) {
          uint64_t v15 = (int)v19;
        }
        else {
          uint64_t v15 = 3221225472;
        }
        v30.origin.double x = x;
        v30.origin.double y = y;
        v30.size.double width = width;
        v30.size.double height = height;
        CGRect v31 = CGRectStandardize(v30);
        double v20 = v31.origin.x + v31.size.width;
        if (v20 <= 1073741820.0) {
          double v21 = v20;
        }
        else {
          double v21 = 1073741820.0;
        }
        if (v20 >= -1073741820.0) {
          uint64_t v16 = (int)v21;
        }
        else {
          uint64_t v16 = 3221225472;
        }
        v32.origin.double x = x;
        v32.origin.double y = y;
        v32.size.double width = width;
        v32.size.double height = height;
        CGRect v33 = CGRectStandardize(v32);
        double y = v33.origin.y;
        double height = v33.size.height;
      }
      else
      {
        double v11 = 1073741820.0;
        if (x <= 1073741820.0) {
          double v12 = x;
        }
        else {
          double v12 = 1073741820.0;
        }
        if (x >= -1073741820.0) {
          uint64_t v13 = (int)v12;
        }
        else {
          uint64_t v13 = 3221225472;
        }
        if (y <= 1073741820.0) {
          double v14 = y;
        }
        else {
          double v14 = 1073741820.0;
        }
        if (y >= -1073741820.0) {
          uint64_t v15 = (int)v14;
        }
        else {
          uint64_t v15 = 3221225472;
        }
        if (x + width <= 1073741820.0) {
          double v11 = x + width;
        }
        if (x + width >= -1073741820.0) {
          uint64_t v16 = (int)v11;
        }
        else {
          uint64_t v16 = 3221225472;
        }
      }
      double v22 = 1073741820.0;
      if (y + height <= 1073741820.0) {
        double v22 = y + height;
      }
      if (y + height >= -1073741820.0) {
        uint64_t v23 = (int)v22;
      }
      else {
        uint64_t v23 = 3221225472;
      }
      if ((int)v13 < (int)v16 && (int)v15 < (int)v23)
      {
        double v25 = *v6;
        if (!*v6)
        {
          double v25 = (char *)malloc_type_malloc(0x200uLL, 0x705560E0uLL);
          *(_OWORD *)(v25 + 8) = 0u;
          *(_OWORD *)(v25 + 24) = 0u;
          *(_OWORD *)(v25 + 40) = 0u;
          *(_OWORD *)(v25 + 56) = 0u;
          *(_OWORD *)(v25 + 72) = 0u;
          *(_OWORD *)(v25 + 88) = 0u;
          *(_OWORD *)(v25 + 104) = 0u;
          *(_OWORD *)(v25 + 120) = 0u;
          *(_OWORD *)(v25 + 136) = 0u;
          *(_OWORD *)(v25 + 152) = 0u;
          *(_OWORD *)(v25 + 168) = 0u;
          *(_OWORD *)(v25 + 184) = 0u;
          *(_OWORD *)(v25 + 200) = 0u;
          *(_OWORD *)(v25 + 216) = 0u;
          *(_OWORD *)(v25 + 232) = 0u;
          *(_OWORD *)(v25 + 248) = 0u;
          *((void *)v25 + 33) = 0;
          *(void *)double v25 = 8;
          *((void *)v25 + 2) = v25 + 32;
          *((void *)v25 + 3) = v25 + 160;
          *unint64_t v6 = v25;
        }
        if ((int)shape_accum_add((unsigned int *)v25, v13, v15, v16, v23) >= 1)
        {
          double v26 = v6[1];
          if (v26)
          {
            if (v26 != (char *)&the_empty_shape) {
              free(v26);
            }
            v6[1] = 0;
          }
          *((_DWORD *)v6 + 12) &= ~1u;
        }
      }
    }
  }
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double height = r2.size.height;
  double width = r2.size.width;
  double y = r2.origin.y;
  double x = r2.origin.x;
  double v6 = r1.origin.x;
  if (r1.origin.x == INFINITY || r1.origin.y == INFINITY)
  {
    double v8 = r2.size.height;
    double v9 = r2.size.width;
    double v6 = r2.origin.x;
  }
  else
  {
    double v8 = r1.size.height;
    double v9 = r1.size.width;
    double v10 = r1.origin.y;
    if (r2.origin.x == INFINITY || r2.origin.y == INFINITY)
    {
      double y = r1.origin.y;
    }
    else
    {
      if (r1.size.width < 0.0 || r1.size.height < 0.0)
      {
        CGRect v18 = CGRectStandardize(r1);
        double v6 = v18.origin.x;
        double v10 = v18.origin.y;
        double v9 = v18.size.width;
        double v8 = v18.size.height;
      }
      if (width < 0.0 || height < 0.0)
      {
        v19.origin.double x = x;
        v19.origin.double y = y;
        v19.size.double width = width;
        v19.size.double height = height;
        CGRect v20 = CGRectStandardize(v19);
        double x = v20.origin.x;
        double y = v20.origin.y;
        double width = v20.size.width;
        double height = v20.size.height;
      }
      double v12 = v6 + v9;
      double v6 = fmin(v6, x);
      double v13 = y + height;
      double y = fmin(v10, y);
      double v9 = fmax(v12, x + width) - v6;
      double v8 = fmax(v10 + v8, v13) - y;
    }
  }
  double v14 = v6;
  double v15 = y;
  double v16 = v9;
  double v17 = v8;
  result.size.double height = v17;
  result.size.double width = v16;
  result.origin.double y = v15;
  result.origin.double x = v14;
  return result;
}

unsigned int *CG::DisplayListEntry::_hash(uint64_t a1, unsigned int *a2)
{
  __srdouble c = *(char *)(a1 + 8);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __srdouble c = *(_DWORD *)(a1 + 8) >> 8;
  XXH64_update(a2, (char *)&__src, 4uLL);

  return XXH64_update(a2, (char *)(a1 + 16), 0x20uLL);
}

uint64_t std::__split_buffer<std::shared_ptr<CG::DisplayListEntry const>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t CG::DisplayList::colorResourceForColor(CG::DisplayList *this, CGColor *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  uint64_t result = 0;
  if (a2 && *((unsigned char *)this + 59))
  {
    double v12 = (void *)*((void *)this + 20);
    ++*((void *)this + 77);
    if (!v12) {
      goto LABEL_11;
    }
    double v13 = (void *)((char *)this + 160);
    do
    {
      uint64_t v14 = CGColorCompare(*(void *)(v12[4] + 16), (unint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
      double v15 = v12 + 1;
      if (v14 != -1)
      {
        double v15 = v12;
        double v13 = v12;
      }
      double v12 = (void *)*v15;
    }
    while (*v15);
    if (v13 == (void *)((char *)this + 160)
      || CGColorCompare(*(void *)(v13[4] + 16), (unint64_t)a2, a3, a4, a5, a6, a7, a8, a9) == -1
      || CGColorCompare((unint64_t)a2, *(void *)(v13[4] + 16), v16, v17, v18, v19, v20, v21, v22) == -1)
    {
LABEL_11:
      operator new();
    }
    return v13[4];
  }
  return result;
}

void sub_184C34924(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10E1C40C53D2D14);
  _Unwind_Resume(a1);
}

uint64_t CGColorCompare(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  v72[1] = *MEMORY[0x1E4F143B8];
  if (a1 == a2) {
    return 0;
  }
  if (a1 && !a2) {
    return 1;
  }
  if (!a1 && a2) {
    return -1;
  }
  if ((a1 & 0x8000000000000000) != 0)
  {
    unint64_t NumberOfComponents = CGTaggedColorGetNumberOfComponents(a1, a2, a3, a4, a5, a6, a7, a8);
    CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(a1, v13, v14, v15, v16, v17, v18, v19);
    MEMORY[0x1F4188790](ColorSpace, v21);
    uint64_t v23 = (char *)v72 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v23, v22);
    v38.n128_f64[0] = CGTaggedColorGetComponents(a1, (uint64_t)v23, v24, v25, v26, v27, v28, v29);
    uint64_t v39 = 0;
    if ((a2 & 0x8000000000000000) == 0)
    {
LABEL_11:
      unint64_t v40 = *(void *)(a2 + 56);
      CGColorSpaceRef v41 = *(CGColorSpaceRef *)(a2 + 24);
      uint64_t v42 = *(void *)(a2 + 32);
      MEMORY[0x1F4188790](v30, v38);
      double v44 = (char *)v72 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0);
      memcpy(v44, (const void *)(a2 + 64), v43);
      goto LABEL_14;
    }
  }
  else
  {
    unint64_t NumberOfComponents = *(void *)(a1 + 56);
    CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(a1 + 24);
    uint64_t v39 = *(void *)(a1 + 32);
    MEMORY[0x1F4188790](a1, a9);
    uint64_t v23 = (char *)v72 - ((v45 + 15) & 0xFFFFFFFFFFFFFFF0);
    CGRect v30 = memcpy(v23, (const void *)(a1 + 64), v45);
    if ((a2 & 0x8000000000000000) == 0) {
      goto LABEL_11;
    }
  }
  unint64_t v40 = CGTaggedColorGetNumberOfComponents(a2, v31, v32, v33, v34, v35, v36, v37);
  CGColorSpaceRef v41 = CGTaggedColorGetColorSpace(a2, v46, v47, v48, v49, v50, v51, v52);
  MEMORY[0x1F4188790](v41, v53);
  double v44 = (char *)v72 - ((v54 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v44, v54);
  CGTaggedColorGetComponents(a2, (uint64_t)v23, v55, v56, v57, v58, v59, v60);
  uint64_t v42 = 0;
LABEL_14:
  if (NumberOfComponents > v40) {
    return 1;
  }
  if (NumberOfComponents < v40) {
    return -1;
  }
  int v61 = memcmp(v23, v44, 8 * NumberOfComponents);
  if (v61 > 0) {
    return 1;
  }
  if (v61 < 0) {
    return -1;
  }
  if (v39 && !v42) {
    return 1;
  }
  if (!v39 && v42) {
    return -1;
  }
  if (v39 && v42)
  {
    unsigned int v62 = *(_DWORD *)(v39 + 16);
    unsigned int v63 = *(_DWORD *)(v42 + 16);
    if (v62 > v63) {
      return 1;
    }
    if (v62 < v63) {
      return -1;
    }
  }
  uint64_t v64 = *((void *)ColorSpace + 3);
  if (v64) {
    double v65 = (unint64_t *)(v64 + 64);
  }
  else {
    double v65 = 0;
  }
  uint64_t v66 = *((void *)v41 + 3);
  if (v66) {
    double v67 = (unint64_t *)(v66 + 64);
  }
  else {
    double v67 = 0;
  }
  unint64_t v68 = bswap64(*v65);
  unint64_t v69 = bswap64(*v67);
  if (v68 == v69 && (unint64_t v68 = bswap64(v65[1]), v69 = bswap64(v67[1]), v68 == v69))
  {
    int v70 = 0;
  }
  else if (v68 < v69)
  {
    int v70 = -1;
  }
  else
  {
    int v70 = 1;
  }
  if (v70 >= 1) {
    return 1;
  }
  else {
    return v70 >> 31;
  }
}

uint64_t CG::DisplayList::getEntryFillState(CG::DisplayList *this, const CG::DisplayListResourceColor *a2)
{
  ++*((void *)this + 91);
  uint64_t v3 = (char *)this + 512;
  uint64_t v4 = (char *)*((void *)this + 64);
  if (!v4) {
    goto LABEL_13;
  }
  CGSize v5 = (char *)this + 512;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    double v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 8);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 8);
    }
    double v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      double v9 = (char **)v4;
      CGSize v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_13;
  }
  uint64_t v10 = *((void *)v5 + 4);
  double v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (!v11)
  {
    if (*(const CG::DisplayListResourceColor **)(v10 + 8) == a2) {
      return *((void *)v5 + 4);
    }
LABEL_13:
    operator new();
  }
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  if (*(void *)(v10 + 8) < (unint64_t)a2)
  {
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    goto LABEL_13;
  }
  uint64_t v14 = *((void *)v5 + 4);
  uint64_t v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    unint64_t v15 = *(void *)(v14 + 8);
    std::__shared_weak_count::__release_shared[abi:fe180100](v13);
  }
  else
  {
    unint64_t v15 = *(void *)(v14 + 8);
  }
  std::__shared_weak_count::__release_shared[abi:fe180100](v11);
  if (v15 > (unint64_t)a2) {
    goto LABEL_13;
  }
  return *((void *)v5 + 4);
}

void sub_184C34DF0(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

uint64_t CG::DisplayList::colorSpaceResourceForColorSpace(CG::DisplayList *this, CGColorSpace *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = (char *)this + 184;
  uint64_t v4 = (char *)*((void *)this + 23);
  ++*((void *)this + 78);
  if (!v4) {
    goto LABEL_15;
  }
  CGSize v5 = (char *)this + 184;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    double v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    double v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      double v9 = (char **)v4;
      CGSize v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *((void *)v5 + 4);
  double v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < (unint64_t)a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *((void *)v5 + 4);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= (unint64_t)a2) {
      return *((void *)v5 + 4);
    }
LABEL_15:
    operator new();
  }
  if (*(CGColorSpace **)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *((void *)v5 + 4);
}

void sub_184C34FE0(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  double v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_7;
  }
  uint64_t v11 = *a5;
  double v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = a2[4];
  uint64_t v13 = (std::__shared_weak_count *)a2[5];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v15 = *(void *)(v11 + 16) < *(void *)(v14 + 16);
    std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    if (v12) {
      goto LABEL_6;
    }
LABEL_13:
    if (v15) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v18 = a2[4];
    uint64_t v19 = (std::__shared_weak_count *)a2[5];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = *a5;
    uint64_t v20 = (std::__shared_weak_count *)a5[1];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v22 = *(void *)(v18 + 16) < *(void *)(v21 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v20);
      if (!v19) {
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v22 = *(void *)(v18 + 16) < *(void *)(v21 + 16);
      if (!v19)
      {
LABEL_19:
        if (!v22)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        uint64_t v23 = (void *)a2[1];
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          uint64_t v32 = a2;
          do
          {
            uint64_t v24 = (void *)v32[2];
            BOOL v26 = *v24 == (void)v32;
            uint64_t v32 = v24;
          }
          while (!v26);
        }
        if (v24 == v9) {
          goto LABEL_48;
        }
        uint64_t v33 = *a5;
        uint64_t v34 = (std::__shared_weak_count *)a5[1];
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v36 = v24[4];
        uint64_t v35 = (std::__shared_weak_count *)v24[5];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v37 = *(void *)(v33 + 16) < *(void *)(v36 + 16);
          std::__shared_weak_count::__release_shared[abi:fe180100](v35);
          if (v34) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v37 = *(void *)(v33 + 16) < *(void *)(v36 + 16);
          if (v34)
          {
LABEL_47:
            std::__shared_weak_count::__release_shared[abi:fe180100](v34);
            if (!v37) {
              goto LABEL_52;
            }
LABEL_48:
            if (*a4)
            {
              *a3 = v24;
              return v24;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_48;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v19);
    goto LABEL_19;
  }
  BOOL v15 = *(void *)(v11 + 16) < *(void *)(v14 + 16);
  if (!v12) {
    goto LABEL_13;
  }
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  if (!v15) {
    goto LABEL_14;
  }
LABEL_7:
  if ((void *)*a1 == a2)
  {
    uint64_t v17 = a2;
    goto LABEL_33;
  }
  uint64_t v16 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v17 = v16;
      uint64_t v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    uint64_t v25 = a2;
    do
    {
      uint64_t v17 = (void *)v25[2];
      BOOL v26 = *v17 == (void)v25;
      uint64_t v25 = v17;
    }
    while (v26);
  }
  uint64_t v27 = v17[4];
  uint64_t v28 = (std::__shared_weak_count *)v17[5];
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v30 = *a5;
  uint64_t v29 = (std::__shared_weak_count *)a5[1];
  if (v29)
  {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v31 = *(void *)(v27 + 16) < *(void *)(v30 + 16);
    std::__shared_weak_count::__release_shared[abi:fe180100](v29);
    if (v28) {
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v31 = *(void *)(v27 + 16) < *(void *)(v30 + 16);
    if (v28)
    {
LABEL_29:
      std::__shared_weak_count::__release_shared[abi:fe180100](v28);
      if (!v31) {
        goto LABEL_52;
      }
      goto LABEL_33;
    }
  }
  if (v31)
  {
LABEL_33:
    if (*a2)
    {
      *a3 = v17;
      return v17 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
LABEL_52:

  return std::__tree<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,CG::CompareResourceCFTypeRef,std::allocator<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceCFTypeRef>>((uint64_t)a1, a3, a5);
}

uint64_t CG::DisplayList::getEntryDrawingState(uint64_t a1, void *a2, uint64_t a3)
{
  ++*(void *)(a1 + 720);
  uint64_t v5 = a1 + 488;
  uint64_t v6 = *(void *)(a1 + 488);
  if (!v6) {
    goto LABEL_13;
  }
  uint64_t v7 = a1 + 488;
  do
  {
    uint64_t v8 = *(void *)(v6 + 32);
    double v9 = *(std::__shared_weak_count **)(v6 + 40);
    if (v9)
    {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v10 = CG::CompareEntryStateDrawing::operator()(v8, a2, a3);
      std::__shared_weak_count::__release_shared[abi:fe180100](v9);
    }
    else
    {
      BOOL v10 = CG::CompareEntryStateDrawing::operator()(v8, a2, a3);
    }
    uint64_t v11 = (uint64_t *)(v6 + 8);
    if (!v10)
    {
      uint64_t v7 = v6;
      uint64_t v11 = (uint64_t *)v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v5 == v7) {
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(v7 + 32);
  uint64_t v13 = *(std::__shared_weak_count **)(v7 + 40);
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    if (CG::CompareEntryStateDrawing::operator()(v12, a2, a3))
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
      goto LABEL_13;
    }
    uint64_t v15 = *(void *)(v7 + 32);
    uint64_t v17 = *(std::__shared_weak_count **)(v7 + 40);
    BOOL v16 = v17 == 0;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    if (CG::CompareEntryStateDrawing::operator()(v12, a2, a3)) {
      goto LABEL_13;
    }
    uint64_t v15 = *(void *)(v7 + 32);
    BOOL v16 = 1;
    uint64_t v17 = 0;
  }
  uint64_t v18 = a2[14];
  uint64_t v19 = *(void *)(v15 + 8);
  if (v19) {
    uint64_t v19 = *(void *)(v19 + 16);
  }
  if (v18)
  {
    unsigned int v20 = *(_DWORD *)(v18 + 4);
    if (v19)
    {
LABEL_23:
      unsigned int v21 = *(_DWORD *)(v19 + 4);
      goto LABEL_26;
    }
  }
  else
  {
    unsigned int v20 = 0;
    if (v19) {
      goto LABEL_23;
    }
  }
  unsigned int v21 = 0;
LABEL_26:
  if (v20 < v21) {
    goto LABEL_27;
  }
  if (v18) {
    LODWORD(v18) = *(_DWORD *)(v18 + 4);
  }
  if (v19) {
    LODWORD(v19) = *(_DWORD *)(v19 + 4);
  }
  if (v18 > v19)
  {
LABEL_34:
    BOOL v22 = 0;
    if (v16) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  uint64_t v23 = a2[15];
  uint64_t v24 = *(void *)(v23 + 40);
  uint64_t v25 = *(void *)(v15 + 16);
  if (v25) {
    uint64_t v25 = *(void *)(v25 + 16);
  }
  if (!v24)
  {
    unsigned int v26 = 0;
    if (v25) {
      goto LABEL_45;
    }
LABEL_47:
    unsigned int v27 = 0;
    goto LABEL_48;
  }
  unsigned int v26 = *(_DWORD *)(v24 + 16);
  if (!v25) {
    goto LABEL_47;
  }
LABEL_45:
  unsigned int v27 = *(_DWORD *)(v25 + 16);
LABEL_48:
  if (v26 < v27) {
    goto LABEL_27;
  }
  if (v24) {
    LODWORD(v24) = *(_DWORD *)(v24 + 16);
  }
  if (v25) {
    LODWORD(v25) = *(_DWORD *)(v25 + 16);
  }
  if (v24 > v25) {
    goto LABEL_34;
  }
  uint64_t v28 = *(void *)(v23 + 16);
  uint64_t v29 = *(void *)(v15 + 24);
  if (v29) {
    uint64_t v29 = *(void *)(v29 + 16);
  }
  unsigned int v30 = v28 ? *(_DWORD *)(v28 + 16) : 0;
  unsigned int v31 = v29 ? *(_DWORD *)(v29 + 16) : 0;
  if (v30 < v31) {
    goto LABEL_27;
  }
  if (v28) {
    LODWORD(v28) = *(_DWORD *)(v28 + 16);
  }
  if (v29) {
    LODWORD(v29) = *(_DWORD *)(v29 + 16);
  }
  if (v28 > v29) {
    goto LABEL_34;
  }
  uint64_t v32 = a2[18];
  uint64_t v33 = *(void *)(v32 + 32);
  uint64_t v34 = *(void *)(v15 + 32);
  if (v34) {
    uint64_t v34 = *(void *)(v34 + 16);
  }
  unsigned int v35 = v33 ? *(_DWORD *)(v33 + 16) : 0;
  unsigned int v36 = v34 ? *(_DWORD *)(v34 + 16) : 0;
  if (v35 < v36) {
    goto LABEL_27;
  }
  if (v33) {
    LODWORD(v33) = *(_DWORD *)(v33 + 16);
  }
  if (v34) {
    LODWORD(v34) = *(_DWORD *)(v34 + 16);
  }
  if (v33 > v34) {
    goto LABEL_34;
  }
  uint64_t v37 = *(void *)(v32 + 40);
  uint64_t v38 = *(void *)(v15 + 40);
  if (v38) {
    uint64_t v38 = *(void *)(v38 + 16);
  }
  unsigned int v39 = v37 ? *(_DWORD *)(v37 + 16) : 0;
  unsigned int v40 = v38 ? *(_DWORD *)(v38 + 16) : 0;
  if (v39 < v40) {
    goto LABEL_27;
  }
  if (v37) {
    LODWORD(v37) = *(_DWORD *)(v37 + 16);
  }
  if (v38) {
    LODWORD(v38) = *(_DWORD *)(v38 + 16);
  }
  if (v37 > v38) {
    goto LABEL_34;
  }
  double v41 = *(double *)(v32 + 8);
  double v42 = *(double *)(v15 + 48);
  if (v41 < v42) {
    goto LABEL_27;
  }
  if (v41 > v42) {
    goto LABEL_34;
  }
  double v43 = *(double *)(v23 + 8);
  double v44 = *(double *)(v15 + 56);
  if (v43 < v44) {
    goto LABEL_27;
  }
  if (v43 > v44) {
    goto LABEL_34;
  }
  int v45 = *(_DWORD *)(v23 + 4);
  int v46 = (__int16)v45 >> 8;
  int v47 = *(_DWORD *)(v15 + 96);
  if (v46 < v47 << 26 >> 26) {
    goto LABEL_27;
  }
  if (v46 > v47 << 26 >> 26) {
    goto LABEL_34;
  }
  unsigned int v48 = (v45 & 0x1000000) != 0 ? *(unsigned __int8 *)(a3 + 81) : 0;
  if (!v48 && (v47 & 0x40) != 0) {
    goto LABEL_27;
  }
  if (v48 > (*(_DWORD *)(v15 + 96) & 0x40u) >> 6) {
    goto LABEL_34;
  }
  if ((v45 & 0x2000000) == 0 && (v47 & 0x80) != 0) {
    goto LABEL_27;
  }
  if ((v45 & 0x2000000) != 0 && (v47 & 0x80) == 0) {
    goto LABEL_34;
  }
  int v49 = v45 << 12 >> 28;
  if (v49 < v47 << 18 >> 26) {
    goto LABEL_27;
  }
  if (v49 > v47 << 18 >> 26) {
    goto LABEL_34;
  }
  if (!*(unsigned char *)(v32 + 24) && (v47 & 0x4000) != 0) {
    goto LABEL_27;
  }
  if (*(unsigned char *)(v32 + 24) && (v47 & 0x4000) == 0) {
    goto LABEL_34;
  }
  int v50 = *(_DWORD *)(v15 + 96) & 0x8000;
  if (!*(unsigned char *)(v32 + 25))
  {
    if (v50)
    {
LABEL_27:
      BOOL v22 = 1;
      if (v16) {
        goto LABEL_36;
      }
LABEL_35:
      std::__shared_weak_count::__release_shared[abi:fe180100](v17);
      goto LABEL_36;
    }
  }
  if (*(unsigned char *)(v32 + 25) && !v50) {
    goto LABEL_34;
  }
  BOOL v22 = *(_DWORD *)(v32 + 28) < *(_DWORD *)(v15 + 100);
  if (!v16) {
    goto LABEL_35;
  }
LABEL_36:
  if (!v13)
  {
    if (!v22) {
      return *(void *)(v7 + 32);
    }
LABEL_13:
    operator new();
  }
  std::__shared_weak_count::__release_shared[abi:fe180100](v13);
  if (v22) {
    goto LABEL_13;
  }
  return *(void *)(v7 + 32);
}

void sub_184C35988(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned long>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:fe180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t CG::DisplayList::functionResourceForFunction(CG::DisplayList *this, CGFunction *a2)
{
  if (!a2) {
    return 0;
  }
  ++*((void *)this + 86);
  uint64_t v3 = (char *)this + 400;
  uint64_t v4 = (char *)*((void *)this + 50);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = (char *)this + 400;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    double v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      double v9 = (char **)v4;
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *((void *)v5 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < (unint64_t)a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *((void *)v5 + 4);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= (unint64_t)a2) {
      return *((void *)v5 + 4);
    }
LABEL_15:
    operator new();
  }
  if (*(CGFunction **)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *((void *)v5 + 4);
}

void sub_184C35C04(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::shared_ptr<CG::DisplayListEntryStateDrawing const>,CG::CompareEntryStateDrawing,std::allocator<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  double v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_7;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = a2[4];
  uint64_t v14 = (std::__shared_weak_count *)a2[5];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v15 = CG::CompareEntryStateDrawing::operator()(v11, v13);
    std::__shared_weak_count::__release_shared[abi:fe180100](v14);
    if (v12) {
      goto LABEL_6;
    }
LABEL_13:
    if (v15) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v18 = a2[4];
    uint64_t v19 = (std::__shared_weak_count *)a2[5];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = *a5;
    unsigned int v21 = (std::__shared_weak_count *)a5[1];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v22 = CG::CompareEntryStateDrawing::operator()(v18, v20);
      std::__shared_weak_count::__release_shared[abi:fe180100](v21);
      if (!v19) {
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v22 = CG::CompareEntryStateDrawing::operator()(v18, v20);
      if (!v19)
      {
LABEL_19:
        if (!v22)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        uint64_t v23 = (void *)a2[1];
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          uint64_t v32 = a2;
          do
          {
            uint64_t v24 = (void *)v32[2];
            BOOL v26 = *v24 == (void)v32;
            uint64_t v32 = v24;
          }
          while (!v26);
        }
        if (v24 == v9) {
          goto LABEL_48;
        }
        uint64_t v33 = *a5;
        uint64_t v34 = (std::__shared_weak_count *)a5[1];
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v35 = v24[4];
        unsigned int v36 = (std::__shared_weak_count *)v24[5];
        if (v36)
        {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v37 = CG::CompareEntryStateDrawing::operator()(v33, v35);
          std::__shared_weak_count::__release_shared[abi:fe180100](v36);
          if (v34) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v37 = CG::CompareEntryStateDrawing::operator()(v33, v35);
          if (v34)
          {
LABEL_47:
            std::__shared_weak_count::__release_shared[abi:fe180100](v34);
            if (!v37) {
              goto LABEL_52;
            }
LABEL_48:
            if (*a4)
            {
              *a3 = v24;
              return v24;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_48;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v19);
    goto LABEL_19;
  }
  BOOL v15 = CG::CompareEntryStateDrawing::operator()(v11, v13);
  if (!v12) {
    goto LABEL_13;
  }
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  if (!v15) {
    goto LABEL_14;
  }
LABEL_7:
  if ((void *)*a1 == a2)
  {
    uint64_t v17 = a2;
    goto LABEL_33;
  }
  BOOL v16 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v17 = v16;
      BOOL v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    uint64_t v25 = a2;
    do
    {
      uint64_t v17 = (void *)v25[2];
      BOOL v26 = *v17 == (void)v25;
      uint64_t v25 = v17;
    }
    while (v26);
  }
  uint64_t v27 = v17[4];
  uint64_t v28 = (std::__shared_weak_count *)v17[5];
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v29 = *a5;
  unsigned int v30 = (std::__shared_weak_count *)a5[1];
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v31 = CG::CompareEntryStateDrawing::operator()(v27, v29);
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
    if (v28) {
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v31 = CG::CompareEntryStateDrawing::operator()(v27, v29);
    if (v28)
    {
LABEL_29:
      std::__shared_weak_count::__release_shared[abi:fe180100](v28);
      if (!v31) {
        goto LABEL_52;
      }
      goto LABEL_33;
    }
  }
  if (v31)
  {
LABEL_33:
    if (*a2)
    {
      *a3 = v17;
      return v17 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
LABEL_52:

  return std::__tree<std::shared_ptr<CG::DisplayListEntryStateDrawing const>,CG::CompareEntryStateDrawing,std::allocator<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateDrawing const>>((uint64_t)a1, a3, a5);
}

uint64_t CG::DisplayList::clipResourceForClipStack(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a1 + 136;
  uint64_t v4 = *(void *)(a1 + 136);
  ++*(void *)(a1 + 608);
  if (!v4) {
    goto LABEL_34;
  }
  uint64_t v5 = a1 + 136;
  do
  {
    uint64_t v7 = *(void *)(v4 + 32);
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 40);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v8 = *(void *)(v7 + 16);
    if (v8) {
      unsigned int v9 = *(_DWORD *)(v8 + 4);
    }
    else {
      unsigned int v9 = 0;
    }
    unsigned int v10 = *(_DWORD *)(a2 + 4);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    uint64_t v11 = (uint64_t *)(v4 + 8);
    if (v9 >= v10)
    {
      uint64_t v5 = v4;
      uint64_t v11 = (uint64_t *)v4;
    }
    uint64_t v4 = *v11;
  }
  while (*v11);
  if (v3 == v5) {
    goto LABEL_34;
  }
  uint64_t v12 = *(void *)(v5 + 32);
  uint64_t v13 = *(std::__shared_weak_count **)(v5 + 40);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(void *)(v12 + 16);
  if (v14) {
    LODWORD(v14) = *(_DWORD *)(v14 + 4);
  }
  if (v14 < *(_DWORD *)(a2 + 4))
  {
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    goto LABEL_34;
  }
  uint64_t v17 = *(void *)(v5 + 32);
  BOOL v16 = *(std::__shared_weak_count **)(v5 + 40);
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *(void *)(v17 + 16);
  if (v18) {
    unsigned int v19 = *(_DWORD *)(v18 + 4);
  }
  else {
    unsigned int v19 = 0;
  }
  unsigned int v20 = *(_DWORD *)(a2 + 4);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v16);
  }
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v13);
  }
  if (v20 < v19) {
LABEL_34:
  }
    operator new();
  return *(void *)(v5 + 32);
}

void sub_184C360D8(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

uint64_t CG::DisplayList::softMaskResourceForSoftMask(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  ++*(void *)(a1 + 680);
  uint64_t v3 = a1 + 376;
  uint64_t v4 = *(void *)(a1 + 376);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = a1 + 376;
  do
  {
    uint64_t v7 = *(void *)(v4 + 32);
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 40);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    unsigned int v9 = (uint64_t *)(v4 + 8);
    if (v8 >= a2)
    {
      unsigned int v9 = (uint64_t *)v4;
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *(void *)(v5 + 32);
  uint64_t v11 = *(std::__shared_weak_count **)(v5 + 40);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *(void *)(v5 + 32);
    uint64_t v13 = *(std::__shared_weak_count **)(v5 + 40);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= a2) {
      return *(void *)(v5 + 32);
    }
LABEL_15:
    operator new();
  }
  if (*(void *)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *(void *)(v5 + 32);
}

void sub_184C36324(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10E1C40E3985EEBLL);
  _Unwind_Resume(a1);
}

uint64_t CG::DisplayList::styleResourceForStyle(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  ++*(void *)(a1 + 672);
  uint64_t v3 = a1 + 352;
  uint64_t v4 = *(void *)(a1 + 352);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = a1 + 352;
  do
  {
    uint64_t v7 = *(void *)(v4 + 32);
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 40);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    unsigned int v9 = (uint64_t *)(v4 + 8);
    if (v8 >= a2)
    {
      unsigned int v9 = (uint64_t *)v4;
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *(void *)(v5 + 32);
  uint64_t v11 = *(std::__shared_weak_count **)(v5 + 40);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *(void *)(v5 + 32);
    uint64_t v13 = *(std::__shared_weak_count **)(v5 + 40);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= a2) {
      return *(void *)(v5 + 32);
    }
LABEL_15:
    operator new();
  }
  if (*(void *)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *(void *)(v5 + 32);
}

void sub_184C365B8(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

BOOL CG::CompareEntryStateDrawing::operator()(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 16);
    uint64_t v5 = a2[14];
    if (v4)
    {
      unsigned int v6 = *(_DWORD *)(v4 + 4);
      if (!v5) {
        goto LABEL_8;
      }
LABEL_6:
      unsigned int v7 = *(_DWORD *)(v5 + 4);
      goto LABEL_9;
    }
    unsigned int v6 = 0;
    if (v5) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v6 = 0;
    uint64_t v5 = a2[14];
    if (v5) {
      goto LABEL_6;
    }
  }
LABEL_8:
  unsigned int v7 = 0;
LABEL_9:
  if (v6 < v7) {
    return 1;
  }
  if (v4) {
    LODWORD(v4) = *(_DWORD *)(v4 + 4);
  }
  if (v5) {
    LODWORD(v5) = *(_DWORD *)(v5 + 4);
  }
  if (v4 > v5) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 16);
    uint64_t v11 = a2[15];
    uint64_t v12 = *(void *)(v11 + 40);
    if (v10)
    {
      unsigned int v13 = *(_DWORD *)(v10 + 16);
      if (!v12) {
        goto LABEL_24;
      }
LABEL_22:
      unsigned int v14 = *(_DWORD *)(v12 + 16);
      goto LABEL_25;
    }
    unsigned int v13 = 0;
    if (v12) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v10 = 0;
    unsigned int v13 = 0;
    uint64_t v11 = a2[15];
    uint64_t v12 = *(void *)(v11 + 40);
    if (v12) {
      goto LABEL_22;
    }
  }
LABEL_24:
  unsigned int v14 = 0;
LABEL_25:
  if (v13 < v14) {
    return 1;
  }
  if (v10) {
    LODWORD(v10) = *(_DWORD *)(v10 + 16);
  }
  if (v12) {
    LODWORD(v12) = *(_DWORD *)(v12 + 16);
  }
  if (v10 > v12) {
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 24);
  if (v15)
  {
    uint64_t v16 = *(void *)(v15 + 16);
    uint64_t v17 = *(void *)(v11 + 16);
    if (v16) {
      unsigned int v18 = *(_DWORD *)(v16 + 16);
    }
    else {
      unsigned int v18 = 0;
    }
  }
  else
  {
    uint64_t v16 = 0;
    unsigned int v18 = 0;
    uint64_t v17 = *(void *)(v11 + 16);
  }
  if (v17) {
    unsigned int v19 = *(_DWORD *)(v17 + 16);
  }
  else {
    unsigned int v19 = 0;
  }
  if (v18 < v19) {
    return 1;
  }
  if (v16) {
    LODWORD(v16) = *(_DWORD *)(v16 + 16);
  }
  if (v17) {
    LODWORD(v17) = *(_DWORD *)(v17 + 16);
  }
  if (v16 > v17) {
    return 0;
  }
  uint64_t v20 = *(void *)(a1 + 32);
  if (v20)
  {
    uint64_t v21 = *(void *)(v20 + 16);
    uint64_t v22 = a2[18];
    uint64_t v23 = *(void *)(v22 + 32);
    if (v21) {
      unsigned int v24 = *(_DWORD *)(v21 + 16);
    }
    else {
      unsigned int v24 = 0;
    }
  }
  else
  {
    uint64_t v21 = 0;
    unsigned int v24 = 0;
    uint64_t v22 = a2[18];
    uint64_t v23 = *(void *)(v22 + 32);
  }
  if (v23) {
    unsigned int v25 = *(_DWORD *)(v23 + 16);
  }
  else {
    unsigned int v25 = 0;
  }
  if (v24 < v25) {
    return 1;
  }
  if (v21) {
    LODWORD(v21) = *(_DWORD *)(v21 + 16);
  }
  if (v23) {
    LODWORD(v23) = *(_DWORD *)(v23 + 16);
  }
  if (v21 > v23) {
    return 0;
  }
  uint64_t v26 = *(void *)(a1 + 40);
  if (v26)
  {
    uint64_t v27 = *(void *)(v26 + 16);
    uint64_t v28 = *(void *)(v22 + 40);
    if (v27) {
      unsigned int v29 = *(_DWORD *)(v27 + 16);
    }
    else {
      unsigned int v29 = 0;
    }
  }
  else
  {
    uint64_t v27 = 0;
    unsigned int v29 = 0;
    uint64_t v28 = *(void *)(v22 + 40);
  }
  if (v28) {
    unsigned int v30 = *(_DWORD *)(v28 + 16);
  }
  else {
    unsigned int v30 = 0;
  }
  if (v29 < v30) {
    return 1;
  }
  if (v27) {
    LODWORD(v27) = *(_DWORD *)(v27 + 16);
  }
  if (v28) {
    LODWORD(v28) = *(_DWORD *)(v28 + 16);
  }
  if (v27 > v28) {
    return 0;
  }
  double v31 = *(double *)(a1 + 48);
  double v32 = *(double *)(v22 + 8);
  if (v31 < v32) {
    return 1;
  }
  if (v31 > v32) {
    return 0;
  }
  double v33 = *(double *)(a1 + 56);
  double v34 = *(double *)(v11 + 8);
  if (v33 < v34) {
    return 1;
  }
  if (v33 > v34) {
    return 0;
  }
  int v35 = *(_DWORD *)(a1 + 96);
  int v36 = v35 << 26 >> 26;
  int v37 = *(_DWORD *)(v11 + 4);
  if (v36 < (__int16)v37 >> 8) {
    return 1;
  }
  if (v36 > (__int16)v37 >> 8) {
    return 0;
  }
  if ((v37 & 0x1000000) != 0)
  {
    unsigned int v38 = *(unsigned __int8 *)(a3 + 81);
    unsigned int v39 = *(_DWORD *)(a1 + 96) & 0x40;
    if (v38 > v39 >> 6) {
      return 1;
    }
  }
  else
  {
    unsigned int v38 = 0;
    unsigned int v39 = *(_DWORD *)(a1 + 96) & 0x40;
  }
  if (v39 && !v38) {
    return 0;
  }
  int v40 = v37 & 0x2000000;
  if ((v35 & 0x80) == 0 && v40) {
    return 1;
  }
  if ((v35 & 0x80) != 0 && !v40) {
    return 0;
  }
  if (v35 << 18 >> 26 < v37 << 12 >> 28 || *(unsigned char *)(v22 + 24) && (v35 & 0x4000) == 0) {
    return 1;
  }
  if ((v35 & 0x4000) != 0 && !*(unsigned char *)(v22 + 24)) {
    return 0;
  }
  if (*(unsigned char *)(v22 + 25) && (v35 & 0x8000) == 0) {
    return 1;
  }
  if ((v35 & 0x8000) != 0 && !*(unsigned char *)(v22 + 25)) {
    return 0;
  }
  return *(_DWORD *)(a1 + 100) < *(_DWORD *)(v22 + 28);
}

uint64_t *std::__tree<std::shared_ptr<CG::DisplayListResourceColor>,CG::CompareResourceColor,std::allocator<std::shared_ptr<CG::DisplayListResourceColor>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceColor>>(void *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  unsigned int v13 = a1 + 1;
  if (a1 + 1 == a2
    || (unsigned int v14 = (uint64_t *)a4,
        CGColorCompare(*(void *)(*(void *)a5 + 16), *(void *)(a2[4] + 16), (uint64_t)a3, a4, a5, a6, a7, a8, a9) == -1))
  {
    if ((void *)*a1 == a2)
    {
      uint64_t v23 = a2;
    }
    else
    {
      uint64_t v22 = (void *)*a2;
      if (*a2)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = (void *)v22[1];
        }
        while (v22);
      }
      else
      {
        uint64_t v27 = a2;
        do
        {
          uint64_t v23 = (void *)v27[2];
          BOOL v28 = *v23 == (void)v27;
          uint64_t v27 = v23;
        }
        while (v28);
      }
      if (CGColorCompare(*(void *)(v23[4] + 16), *(void *)(*(void *)a5 + 16), (uint64_t)a3, a4, a5, a6, a7, a8, a9) != -1)goto LABEL_17; {
    }
      }
    if (*a2)
    {
      *a3 = v23;
      return v23 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (CGColorCompare(*(void *)(a2[4] + 16), *(void *)(*(void *)a5 + 16), (uint64_t)a3, a4, a5, a6, a7, a8, a9) != -1)
  {
    *a3 = a2;
    *unsigned int v14 = (uint64_t)a2;
    return v14;
  }
  unsigned int v14 = a2 + 1;
  uint64_t v24 = a2[1];
  if (v24)
  {
    unsigned int v25 = (void *)a2[1];
    do
    {
      uint64_t v26 = v25;
      unsigned int v25 = (void *)*v25;
    }
    while (v25);
  }
  else
  {
    int v36 = a2;
    do
    {
      uint64_t v26 = (void *)v36[2];
      BOOL v28 = *v26 == (void)v36;
      int v36 = v26;
    }
    while (!v28);
  }
  if (v26 == v13)
  {
LABEL_29:
    if (v24)
    {
      *a3 = v26;
      return v26;
    }
    else
    {
      *a3 = a2;
    }
    return v14;
  }
  if (CGColorCompare(*(void *)(*(void *)a5 + 16), *(void *)(v26[4] + 16), v15, v16, v17, v18, v19, v20, v21) == -1)
  {
    uint64_t v24 = *v14;
    goto LABEL_29;
  }
LABEL_17:

  return std::__tree<std::shared_ptr<CG::DisplayListResourceColor>,CG::CompareResourceColor,std::allocator<std::shared_ptr<CG::DisplayListResourceColor>>>::__find_equal<std::shared_ptr<CG::DisplayListResourceColor>>((uint64_t)a1, a3, a5, v29, v30, v31, v32, v33, v34);
}

void *std::__tree<std::shared_ptr<CG::DisplayListEntryStateFill const>,CG::CompareEntryStateFill,std::allocator<std::shared_ptr<CG::DisplayListEntryStateFill const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateFill const>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_7;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = a2[4];
  unsigned int v13 = (std::__shared_weak_count *)a2[5];
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v15 = *(void *)(v11 + 8) < *(void *)(v14 + 8);
    std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    if (v12) {
      goto LABEL_6;
    }
LABEL_13:
    if (v15) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v18 = a2[4];
    uint64_t v19 = (std::__shared_weak_count *)a2[5];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = *a5;
    uint64_t v20 = (std::__shared_weak_count *)a5[1];
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v22 = *(void *)(v18 + 8) < *(void *)(v21 + 8);
      std::__shared_weak_count::__release_shared[abi:fe180100](v20);
      if (!v19) {
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v22 = *(void *)(v18 + 8) < *(void *)(v21 + 8);
      if (!v19)
      {
LABEL_19:
        if (!v22)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        uint64_t v23 = (void *)a2[1];
        if (v23)
        {
          do
          {
            uint64_t v24 = v23;
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          uint64_t v32 = a2;
          do
          {
            uint64_t v24 = (void *)v32[2];
            BOOL v26 = *v24 == (void)v32;
            uint64_t v32 = v24;
          }
          while (!v26);
        }
        if (v24 == v9) {
          goto LABEL_48;
        }
        uint64_t v33 = *a5;
        __n128 v34 = (std::__shared_weak_count *)a5[1];
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v36 = v24[4];
        int v35 = (std::__shared_weak_count *)v24[5];
        if (v35)
        {
          atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v37 = *(void *)(v33 + 8) < *(void *)(v36 + 8);
          std::__shared_weak_count::__release_shared[abi:fe180100](v35);
          if (v34) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v37 = *(void *)(v33 + 8) < *(void *)(v36 + 8);
          if (v34)
          {
LABEL_47:
            std::__shared_weak_count::__release_shared[abi:fe180100](v34);
            if (!v37) {
              goto LABEL_52;
            }
LABEL_48:
            if (*a4)
            {
              *a3 = v24;
              return v24;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_48;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v19);
    goto LABEL_19;
  }
  BOOL v15 = *(void *)(v11 + 8) < *(void *)(v14 + 8);
  if (!v12) {
    goto LABEL_13;
  }
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  if (!v15) {
    goto LABEL_14;
  }
LABEL_7:
  if ((void *)*a1 == a2)
  {
    uint64_t v17 = a2;
    goto LABEL_33;
  }
  uint64_t v16 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v17 = v16;
      uint64_t v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    unsigned int v25 = a2;
    do
    {
      uint64_t v17 = (void *)v25[2];
      BOOL v26 = *v17 == (void)v25;
      unsigned int v25 = v17;
    }
    while (v26);
  }
  uint64_t v27 = v17[4];
  BOOL v28 = (std::__shared_weak_count *)v17[5];
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v30 = *a5;
  uint64_t v29 = (std::__shared_weak_count *)a5[1];
  if (v29)
  {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v31 = *(void *)(v27 + 8) < *(void *)(v30 + 8);
    std::__shared_weak_count::__release_shared[abi:fe180100](v29);
    if (v28) {
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v31 = *(void *)(v27 + 8) < *(void *)(v30 + 8);
    if (v28)
    {
LABEL_29:
      std::__shared_weak_count::__release_shared[abi:fe180100](v28);
      if (!v31) {
        goto LABEL_52;
      }
      goto LABEL_33;
    }
  }
  if (v31)
  {
LABEL_33:
    if (*a2)
    {
      *a3 = v17;
      return v17 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
LABEL_52:

  return std::__tree<std::shared_ptr<CG::DisplayListEntryStateFill const>,CG::CompareEntryStateFill,std::allocator<std::shared_ptr<CG::DisplayListEntryStateFill const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateFill const>>((uint64_t)a1, a3, a5);
}

double CG::DisplayListRecorder::adjustBoundingBoxToIncludeStroke(CGRect *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 128);
  double v3 = *(double *)(v2 + 8);
  if (*(unsigned __int16 *)(v2 + 2) <= 0xFFu && v3 * *(double *)(v2 + 16) * 0.5 > v3) {
    double v3 = v3 * *(double *)(v2 + 16) * 0.5;
  }
  *(void *)&double result = (unint64_t)CGRectInset(*a1, -fabs(v3 * *(double *)(a2 + 40) + *(double *)(a2 + 24) * v3), -fabs(v3 * *(double *)(a2 + 48) + *(double *)(a2 + 32) * v3));
  return result;
}

CGPoint *CG::DisplayListEntryGlyphs::setGlyphsAndPositions(CG::DisplayListEntryGlyphs *this, unsigned __int16 *a2, const CGPoint *a3, uint64_t a4)
{
  unsigned int v7 = (unsigned __int16 *)*((void *)this + 29);
  if (v7 != a2)
  {
    free(v7);
    *((void *)this + 29) = 0;
    uint64_t v9 = malloc_type_malloc(2 * a4, 0x705560E0uLL);
    *((void *)this + 29) = v9;
    if (v9) {
      memcpy(v9, a2, 2 * a4);
    }
  }
  double result = (CGPoint *)*((void *)this + 30);
  if (result != a3)
  {
    free(result);
    *((void *)this + 30) = 0;
    double result = (CGPoint *)malloc_type_malloc(16 * a4, 0x705560E0uLL);
    *((void *)this + 30) = result;
    if (*((void *)this + 29)) {
      double result = (CGPoint *)memcpy(result, a3, 16 * a4);
    }
  }
  *((void *)this + 31) = a4;
  return result;
}

BOOL CG::CompareEntryStateDrawing::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v2 = *(void *)(v2 + 16);
  }
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3) {
    uint64_t v3 = *(void *)(v3 + 16);
  }
  if (v2)
  {
    unsigned int v4 = *(_DWORD *)(v2 + 4);
    if (v3)
    {
LABEL_7:
      unsigned int v5 = *(_DWORD *)(v3 + 4);
      goto LABEL_10;
    }
  }
  else
  {
    unsigned int v4 = 0;
    if (v3) {
      goto LABEL_7;
    }
  }
  unsigned int v5 = 0;
LABEL_10:
  if (v4 < v5) {
    return 1;
  }
  if (v2) {
    LODWORD(v2) = *(_DWORD *)(v2 + 4);
  }
  if (v3) {
    LODWORD(v3) = *(_DWORD *)(v3 + 4);
  }
  if (v2 > v3) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    uint64_t v7 = *(void *)(v7 + 16);
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (v8) {
    uint64_t v8 = *(void *)(v8 + 16);
  }
  if (v7)
  {
    unsigned int v9 = *(_DWORD *)(v7 + 16);
    if (v8)
    {
LABEL_24:
      unsigned int v10 = *(_DWORD *)(v8 + 16);
      goto LABEL_27;
    }
  }
  else
  {
    unsigned int v9 = 0;
    if (v8) {
      goto LABEL_24;
    }
  }
  unsigned int v10 = 0;
LABEL_27:
  if (v9 < v10) {
    return 1;
  }
  if (v7) {
    LODWORD(v7) = *(_DWORD *)(v7 + 16);
  }
  if (v8) {
    LODWORD(v8) = *(_DWORD *)(v8 + 16);
  }
  if (v7 > v8) {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  if (v11) {
    uint64_t v11 = *(void *)(v11 + 16);
  }
  uint64_t v12 = *(void *)(a2 + 24);
  if (v12) {
    uint64_t v12 = *(void *)(v12 + 16);
  }
  if (v11)
  {
    unsigned int v13 = *(_DWORD *)(v11 + 16);
    if (v12)
    {
LABEL_39:
      unsigned int v14 = *(_DWORD *)(v12 + 16);
      goto LABEL_42;
    }
  }
  else
  {
    unsigned int v13 = 0;
    if (v12) {
      goto LABEL_39;
    }
  }
  unsigned int v14 = 0;
LABEL_42:
  if (v13 < v14) {
    return 1;
  }
  if (v11) {
    LODWORD(v11) = *(_DWORD *)(v11 + 16);
  }
  if (v12) {
    LODWORD(v12) = *(_DWORD *)(v12 + 16);
  }
  if (v11 > v12) {
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 32);
  if (v15) {
    uint64_t v15 = *(void *)(v15 + 16);
  }
  uint64_t v16 = *(void *)(a2 + 32);
  if (v16) {
    uint64_t v16 = *(void *)(v16 + 16);
  }
  if (v15) {
    unsigned int v17 = *(_DWORD *)(v15 + 16);
  }
  else {
    unsigned int v17 = 0;
  }
  if (v16) {
    unsigned int v18 = *(_DWORD *)(v16 + 16);
  }
  else {
    unsigned int v18 = 0;
  }
  if (v17 < v18) {
    return 1;
  }
  if (v15) {
    LODWORD(v15) = *(_DWORD *)(v15 + 16);
  }
  if (v16) {
    LODWORD(v16) = *(_DWORD *)(v16 + 16);
  }
  if (v15 > v16) {
    return 0;
  }
  uint64_t v19 = *(void *)(a1 + 40);
  if (v19) {
    uint64_t v19 = *(void *)(v19 + 16);
  }
  uint64_t v20 = *(void *)(a2 + 40);
  if (v20) {
    uint64_t v20 = *(void *)(v20 + 16);
  }
  if (v19) {
    unsigned int v21 = *(_DWORD *)(v19 + 16);
  }
  else {
    unsigned int v21 = 0;
  }
  if (v20) {
    unsigned int v22 = *(_DWORD *)(v20 + 16);
  }
  else {
    unsigned int v22 = 0;
  }
  if (v21 < v22) {
    return 1;
  }
  if (v19) {
    LODWORD(v19) = *(_DWORD *)(v19 + 16);
  }
  if (v20) {
    LODWORD(v20) = *(_DWORD *)(v20 + 16);
  }
  if (v19 > v20) {
    return 0;
  }
  double v23 = *(double *)(a1 + 48);
  double v24 = *(double *)(a2 + 48);
  if (v23 < v24) {
    return 1;
  }
  if (v23 > v24) {
    return 0;
  }
  double v25 = *(double *)(a1 + 56);
  double v26 = *(double *)(a2 + 56);
  if (v25 < v26) {
    return 1;
  }
  if (v25 > v26) {
    return 0;
  }
  int v27 = *(_DWORD *)(a1 + 96);
  int v28 = v27 << 26 >> 26;
  int v29 = *(_DWORD *)(a2 + 96);
  if (v28 < v29 << 26 >> 26) {
    return 1;
  }
  if (v28 > v29 << 26 >> 26) {
    return 0;
  }
  if ((v27 & 0x40) == 0 && (v29 & 0x40) != 0) {
    return 1;
  }
  if ((v27 & 0x40) != 0 && (v29 & 0x40) == 0) {
    return 0;
  }
  if ((v27 & 0x80) == 0 && (v29 & 0x80) != 0) {
    return 1;
  }
  if ((v27 & 0x80) != 0 && (v29 & 0x80) == 0) {
    return 0;
  }
  int v30 = v27 << 18 >> 26;
  if (v30 < v29 << 18 >> 26) {
    return 1;
  }
  if (v30 > v29 << 18 >> 26) {
    return 0;
  }
  if ((v27 & 0x4000) == 0 && (v29 & 0x4000) != 0) {
    return 1;
  }
  if ((v27 & 0x4000) != 0 && (v29 & 0x4000) == 0) {
    return 0;
  }
  int v31 = *(_DWORD *)(a2 + 96) & 0x8000;
  if ((v27 & 0x8000) == 0 && v31) {
    return 1;
  }
  if ((v27 & 0x8000) != 0 && !v31) {
    return 0;
  }
  return *(_DWORD *)(a1 + 100) < *(_DWORD *)(a2 + 100);
}

unsigned int *CG::DisplayListEntryDisplayList::_hash(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 16)) != 0) {
    unint64_t v6 = XXH64_digest(*(void **)(v5 + 136));
  }
  else {
    unint64_t v6 = 0;
  }
  __srdouble c = v6;
  XXH64_update(a2, (char *)&__src, 8uLL);
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 136), 4uLL);
  XXH64_update(a2, (char *)(a1 + 136), 4uLL);

  return CG::DisplayListEntry::_hash(a1, a2);
}

unsigned int *CG::DisplayListEntryShading::_hash(uint64_t a1, unsigned int *a2)
{
  __srdouble c = *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 16) + 16);
  XXH64_update(a2, (char *)&__src, 4uLL);
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 136), 4uLL);
  XXH64_update(a2, (char *)(a1 + 140), 4uLL);

  return CG::DisplayListEntry::_hash(a1, a2);
}

unsigned int *CG::DisplayListEntryGradient::_hash(uint64_t a1, unsigned int *a2)
{
  __srdouble c = *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 16) + 16);
  XXH64_update(a2, (char *)&__src, 4uLL);
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 136), 4uLL);
  XXH64_update(a2, (char *)(a1 + 140), 4uLL);
  int v4 = *(_DWORD *)(a1 + 136);
  if (v4 == 3)
  {
    XXH64_update(a2, (char *)(a1 + 224), 0x10uLL);
    uint64_t v5 = (char *)(a1 + 240);
LABEL_7:
    unint64_t v6 = a2;
    size_t v7 = 8;
    goto LABEL_8;
  }
  if (v4 == 2)
  {
    XXH64_update(a2, (char *)(a1 + 176), 0x10uLL);
    XXH64_update(a2, (char *)(a1 + 192), 0x10uLL);
    XXH64_update(a2, (char *)(a1 + 208), 8uLL);
    uint64_t v5 = (char *)(a1 + 216);
    goto LABEL_7;
  }
  if (v4 != 1) {
    goto LABEL_9;
  }
  XXH64_update(a2, (char *)(a1 + 144), 0x10uLL);
  uint64_t v5 = (char *)(a1 + 160);
  unint64_t v6 = a2;
  size_t v7 = 16;
LABEL_8:
  XXH64_update(v6, v5, v7);
LABEL_9:

  return CG::DisplayListEntry::_hash(a1, a2);
}

uint64_t CGColorSpaceCopyICCProfileDescription(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 24) + 112) + 24)) != 0) {
    return v1();
  }
  else {
    return 0;
  }
}

size_t CGFontGetNumberOfGlyphs(CGFontRef font)
{
  size_t result = (size_t)get_font_info(font);
  if (result) {
    return *(void *)result;
  }
  return result;
}

CGColorRef CGColorCreateCopyByMatchingToColorSpace(CGColorSpaceRef a1, CGColorRenderingIntent intent, CGColorRef color, CFDictionaryRef options)
{
  uint64_t v8 = 0;
  if (!a1 || !color) {
    return v8;
  }
  unsigned int v10 = a1;
  if (!*(unsigned char *)(*((void *)a1 + 3) + 10)) {
    return 0;
  }
  uint64_t v11 = *(void *)&intent;
  if (options)
  {
    CFDictionaryRef v12 = options;
    goto LABEL_17;
  }
  if (((unint64_t)color & 0x8000000000000000) != 0) {
    CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace((unint64_t)color, *(uint64_t *)&intent, (uint64_t)color, 0, v4, v5, v6, v7);
  }
  else {
    CGColorSpaceRef ColorSpace = (CGColorSpaceRef)*((void *)color + 3);
  }
  if (!CGColorSpaceEqualToColorSpace((uint64_t)v10, (uint64_t)ColorSpace))
  {
    a1 = v10;
    CFDictionaryRef v12 = 0;
LABEL_17:
    uint64_t v16 = (void *)color_transform_create(a1, v12);
    uint64_t v8 = CGColorTransformConvertColor(v16, (unint64_t)color, v11);
    if (v16) {
      CFRelease(v16);
    }
    return v8;
  }
  if (create_resolved_device_space_predicate != -1) {
    dispatch_once(&create_resolved_device_space_predicate, &__block_literal_global_46_2405);
  }
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 0x40000000;
  void v20[2] = __CGColorSpaceCreateResolved_block_invoke;
  v20[3] = &__block_descriptor_tmp_57_23013;
  v20[4] = create_resolved_device_space_gray;
  v20[5] = create_resolved_device_space_sRGB;
  _OWORD v20[6] = create_resolved_device_space_cmyk;
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(v10, (uint64_t)v20);
  uint64_t v15 = ResolvedColorSpace;
  if (!ResolvedColorSpace || CFEqual(ResolvedColorSpace, v10))
  {
    CFRetain(color);
    CGColorSpaceRelease(v15);
    return color;
  }
  Components = CGColorGetComponents(color);
  uint64_t v19 = CGColorCreate(v15, Components);
  CGColorSpaceRelease(v15);
  return v19;
}

uint64_t rip_auto_context_begin_layer(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  if (!a1)
  {
    uint64_t v15 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v14 = *(void *)(a1 + 288);
  uint64_t v15 = v14 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v14 + 112));
  if (!v14)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_GState(0, a3);
    goto LABEL_19;
  }
  uint64_t v16 = *(void *)(v14 + 88);
  if (v16)
  {
    rip_auto_context_update_content_info_from_GState(v14, a3);
  }
  else
  {
    uint64_t v16 = *(void *)(v14 + 80);
    rip_auto_context_update_content_info_from_GState(v14, a3);
    if (!v16) {
      goto LABEL_19;
    }
  }
  uint64_t v17 = *(void *)(v16 + 40);
  if (v17)
  {
    unsigned int v18 = *(void (**)(double, double, double, double))(v17 + 192);
    if (v18) {
      v18(a4, a5, a6, a7);
    }
  }
  uint64_t FillColor = (void *)CGGStateGetFillColor(a3);
  uint64_t v20 = FillColor;
  if (FillColor) {
    CFRetain(FillColor);
  }
  CGColorRef ConstantColor = CGColorGetConstantColor(@"kCGColorClear");
  CGGStateSetFillColor(a3, ConstantColor);
  uint64_t v22 = *(void *)(v16 + 40);
  if (v22)
  {
    double v23 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v22 + 64);
    if (v23) {
      v23(v22, a2, a3, 0);
    }
  }
  CGGStateSetFillColor(a3, v20);
  if (v20) {
    CFRelease(v20);
  }
  *(unsigned char *)(v14 + 105) |= rip_auto_context_contains_transparency(v14, v24, v25, v26, v27, v28, v29, v30);
LABEL_19:
  pthread_mutex_unlock((pthread_mutex_t *)v15);
  return a1;
}

uint64_t rip_auto_context_operation(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  if (a1) {
    uint64_t v6 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v6 = 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 112));
  if (CFEqual(a4, @"kCGContextFlush"))
  {
    uint64_t v7 = (const void *)rip_auto_context_rasterization_loop(v6);
    if (v7) {
      CFRelease(v7);
    }
    goto LABEL_21;
  }
  if (CFEqual(a4, @"kCGContextClear") || CFEqual(a4, @"kCGContextErase"))
  {
    *(unsigned char *)(v6 + 104) = 0;
    *(unsigned char *)(v6 + 105) = CFEqual(a4, @"kCGContextClear") != 0;
    *(_DWORD *)(v6 + 100) = CFEqual(a4, @"kCGContextClear") == 0;
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v6 + 240));
    *(void *)(v6 + 248) = 0;
    *(_OWORD *)(v6 + 232) = 0u;
    *(_OWORD *)(v6 + 216) = 0u;
    *(_OWORD *)(v6 + 200) = 0u;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_DWORD *)(v6 + 108) = 1;
    rip_auto_context_release_buffer_provider(v6, v8, v9, v10, v11, v12, v13, v14);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(v6 + 176));
  }
  else if (!v6)
  {
LABEL_21:
    uint64_t v18 = 0;
    goto LABEL_22;
  }
  uint64_t v15 = *(void *)(v6 + 88);
  if (!v15)
  {
    uint64_t v15 = *(void *)(v6 + 80);
    if (!v15) {
      goto LABEL_21;
    }
  }
  uint64_t v16 = *(void *)(v15 + 40);
  if (!v16) {
    goto LABEL_28;
  }
  uint64_t v17 = *(uint64_t (**)(void))(v16 + 168);
  if (!v17)
  {
    uint64_t v18 = 1006;
    goto LABEL_22;
  }
  uint64_t v18 = v17();
  if (!v18)
  {
LABEL_28:
    if (CFEqual(a4, @"kCGContextClear") || CFEqual(a4, @"kCGContextErase"))
    {
      uint64_t v19 = CGGStateCreate();
      CGColorRef ConstantColor = CGColorGetConstantColor(@"kCGColorWhite");
      CGGStateSetFillColor((uint64_t)v19, ConstantColor);
      BOOL v21 = CFEqual(a4, @"kCGContextClear") == 0;
      CGGStateSetCompositeOperation((uint64_t)v19, v21);
      uint64_t v22 = *(void *)(v15 + 40);
      if (v22)
      {
        double v23 = *(void (**)(uint64_t, uint64_t, char *, void))(v22 + 64);
        if (v23) {
          v23(v22, a2, v19, 0);
        }
      }
      CGGStateRelease((uint64_t)v19);
    }
    goto LABEL_21;
  }
LABEL_22:
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 112));
  return v18;
}

uint64_t dlRecorder_Operation(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef cf1, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)cf1, a5, a6, a7, a8, (char)"dlRecorder_Operation");
    return 1000;
  }
  if (a5)
  {
    if (CFEqual(cf1, @"kCGContextDisplayList"))
    {
      uint64_t v11 = v8;
      char v12 = 6;
      CFTypeRef v13 = 0;
    }
    else
    {
      uint64_t v11 = v8;
      char v12 = 5;
      CFTypeRef v13 = cf1;
    }
    uint64_t v15 = (const void *)a5;
    goto LABEL_15;
  }
  if (CFEqual(cf1, @"kCGContextErase"))
  {
    uint64_t v11 = v8;
    char v12 = 2;
  }
  else
  {
    if (!CFEqual(cf1, @"kCGContextClear"))
    {
      if (!CFEqual(cf1, @"EndTag")) {
        return 1006;
      }
      uint64_t v11 = v8;
      char v12 = 5;
      CFTypeRef v13 = cf1;
      goto LABEL_14;
    }
    uint64_t v11 = v8;
    char v12 = 1;
  }
  CFTypeRef v13 = 0;
LABEL_14:
  uint64_t v15 = 0;
LABEL_15:

  return CG::DisplayListRecorder::recordAction(v11, v12, v13, v15);
}

CGColorRef CGColorGetConstantColor(CFStringRef colorName)
{
  if (CGColorGetConstantColor_predicate != -1) {
    dispatch_once(&CGColorGetConstantColor_predicate, &__block_literal_global_18);
  }
  pthread_mutex_lock(&CGColorGetConstantColor_mutex);
  CFArrayRef Value = CFDictionaryGetValue((CFDictionaryRef)CGColorGetConstantColor_constant_colors, colorName);
  if (!Value)
  {
    if (CFEqual(colorName, @"kCGColorWhite"))
    {
      CGFloat v3 = 1.0;
    }
    else
    {
      if (!CFEqual(colorName, @"kCGColorBlack"))
      {
        if (!CFEqual(colorName, @"kCGColorClear"))
        {
          CFArrayRef Value = 0;
          goto LABEL_11;
        }
        CGFloat v3 = 0.0;
        CGFloat v4 = 0.0;
        goto LABEL_9;
      }
      CGFloat v3 = 0.0;
    }
    CGFloat v4 = 1.0;
LABEL_9:
    CFArrayRef Value = CGColorCreateGenericGrayGamma2_2(v3, v4);
    if (Value)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)CGColorGetConstantColor_constant_colors, colorName, Value);
      CFRelease(Value);
    }
  }
LABEL_11:
  pthread_mutex_unlock(&CGColorGetConstantColor_mutex);
  return (CGColorRef)Value;
}

uint64_t rip_auto_context_draw_image(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, CGImage *a8)
{
  if (!a1)
  {
    uint64_t v14 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v13 = *(void *)(a1 + 288);
  uint64_t v14 = v13 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 112));
  if (!v13)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_image(0, a8);
    goto LABEL_7;
  }
  uint64_t v15 = *(void *)(v13 + 88);
  if (!v15)
  {
    uint64_t v15 = *(void *)(v13 + 80);
    rip_auto_context_update_content_info_from_image(v13, a8);
    if (v15) {
      goto LABEL_9;
    }
LABEL_7:
    uint64_t v23 = 0;
    goto LABEL_15;
  }
  rip_auto_context_update_content_info_from_image(v13, a8);
LABEL_9:
  uint64_t v24 = *(void *)(v15 + 40);
  if (v24)
  {
    uint64_t v25 = *(uint64_t (**)(double, double, double, double))(v24 + 80);
    if (v25) {
      uint64_t v23 = v25(a2, a3, a4, a5);
    }
    else {
      uint64_t v23 = 1006;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  *(unsigned char *)(v13 + 105) |= rip_auto_context_contains_transparency(v13, v16, v17, v18, v19, v20, v21, v22);
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)v14);
  return v23;
}

uint64_t rip_auto_context_draw_rects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v5 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v4 = *(void *)(a1 + 288);
  uint64_t v5 = v4 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 112));
  if (!v4)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_GState(0, a3);
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)(v4 + 88);
  if (!v6)
  {
    uint64_t v6 = *(void *)(v4 + 80);
    rip_auto_context_update_content_info_from_GState(v4, a3);
    if (v6) {
      goto LABEL_9;
    }
LABEL_7:
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  rip_auto_context_update_content_info_from_GState(v4, a3);
LABEL_9:
  uint64_t v15 = *(void *)(v6 + 40);
  if (v15)
  {
    uint64_t v16 = *(uint64_t (**)(void))(v15 + 64);
    if (v16) {
      uint64_t v14 = v16();
    }
    else {
      uint64_t v14 = 1006;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  *(unsigned char *)(v4 + 105) |= rip_auto_context_contains_transparency(v4, v7, v8, v9, v10, v11, v12, v13);
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)v5);
  return v14;
}

uint64_t dlRecorder_DrawRects(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) == 0)
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"dlRecorder_DrawRects");
    return 1000;
  }
  signed int v11 = a4;
  uint64_t v14 = (double *)CG::DisplayListRecorder::currentDisplayList(v8);
  if (!v14) {
    return 1000;
  }
  uint64_t v15 = v14;
  if (v14[5] == INFINITY || v14[6] == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v15[7] != 0.0 && v15[8] != 0.0)
  {
    long long v18 = *(_OWORD *)(a3 + 40);
    long long v44 = *(_OWORD *)(a3 + 24);
    long long v45 = v18;
    long long v46 = *(_OWORD *)(a3 + 56);
    if (!*((unsigned char *)v15 + 73)) {
      goto LABEL_29;
    }
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    if (a5)
    {
      if (a6)
      {
        uint64_t v19 = *a5;
        uint64_t v20 = a5[1];
        uint64_t v21 = a5[2];
        uint64_t v22 = a5[3];
        if (a6 >= 2)
        {
          unint64_t v23 = a6 - 1;
          uint64_t v24 = a5 + 7;
          do
          {
            *(CGRect *)&uint64_t v19 = CGRectUnion(*(CGRect *)&v19, *(CGRect *)(v24 - 3));
            v24 += 4;
            --v23;
          }
          while (v23);
        }
      }
    }
    long long v25 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)&v42.double a = *(_OWORD *)(a3 + 24);
    *(_OWORD *)&v42.double c = v25;
    *(_OWORD *)&v42.double tx = *(_OWORD *)(a3 + 56);
    CGRect v43 = CGRectApplyAffineTransform(*(CGRect *)&v19, &v42);
    if (v11 >= 2)
    {
      v43.origin.double x = CG::DisplayListRecorder::adjustBoundingBoxToIncludeStroke(&v43, a3);
      v43.origin.double y = v26;
      v43.size.double width = v27;
      v43.size.double height = v28;
    }
    CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v43.origin.x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
    v43.origin.double x = v32;
    v43.origin.double y = v29;
    v43.size.double width = v30;
    v43.size.double height = v31;
    if (v32 == INFINITY || v29 == INFINITY) {
      return 0;
    }
    uint64_t result = 0;
    if (v30 != 0.0 && v31 != 0.0)
    {
LABEL_29:
      EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v15 + 2), (void *)a3, a2);
      uint64_t v35 = EntryDrawingState[1];
      if (v35)
      {
        int v36 = *(_DWORD *)(v35 + 8);
        int v37 = v36 & 0x1000;
        int v47 = v37;
        uint64_t v38 = EntryDrawingState[2];
        if (v38)
        {
          int v37 = ((unsigned __int16)*(_DWORD *)(v38 + 8) | (unsigned __int16)v36) & 0x1000;
          int v47 = v37;
        }
        uint64_t v39 = EntryDrawingState[3];
        if (v39) {
          int v47 = v37 | *(_DWORD *)(v39 + 8) & 0x3400;
        }
        uint64_t v48 = 0;
        int v49 = 0;
        CG::DisplayListRecorder::getPathColorResourcesAndUpdateFlags((uint64_t)(v15 + 2), a3, v11, (uint64_t)&v49, &v48, &v47);
        uint64_t v40 = *(void *)(a3 + 120);
        if (*(double *)(v40 + 8) >= 1.0) {
          __int16 v41 = v47;
        }
        else {
          __int16 v41 = v47 | 0x1000;
        }
        if ((v41 & 0x1000) == 0 && (((int)(*(_DWORD *)(v40 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE) {
          __int16 v41 = v47 | 0x1000;
        }
        if ((v41 & 0x3000) != 0) {
          *((_DWORD *)v15 + 20) |= v41 & 0x3000;
        }
        if (*((unsigned char *)v15 + 74))
        {
          if ((v41 & 0x400) != 0) {
            CG::DisplayList::getEntryPatternState((uint64_t)(v15 + 2), a3, a2);
          }
          if ((v41 & 0x100) != 0) {
            CG::DisplayList::getEntryFillState((CG::DisplayList *)(v15 + 2), v49);
          }
          if ((v41 & 0x200) != 0) {
            CG::DisplayList::getEntryStrokeState((uint64_t)(v15 + 2), a3);
          }
          operator new();
        }
        return 0;
      }
      return 1000;
    }
  }
  return result;
}

void sub_184C38134(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10E1C40A5D89D65);
  _Unwind_Resume(a1);
}

uint64_t CG::DisplayListRecorder::getPathColorResourcesAndUpdateFlags(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, _DWORD *a6)
{
  uint64_t v10 = result;
  if (a3 < 2)
  {
    uint64_t FillColor = CGGStateGetFillColor(a2);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 8))(v10, FillColor);
    *(void *)a4 = result;
    *a5 = 0;
    if (*(void *)a4) {
      int v15 = *(_DWORD *)(*(void *)a4 + 8) & 0x3400 | 0x100;
    }
    else {
      int v15 = 256;
    }
  }
  else
  {
    if (a3 - 3 >= 2)
    {
      if (a3 != 2)
      {
        *a5 = 0;
        *(void *)a4 = 0;
        return result;
      }
      *(void *)a4 = 0;
    }
    else
    {
      uint64_t v11 = CGGStateGetFillColor(a2);
      uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 8))(v10, v11);
      *(void *)a4 = v12;
      if (v12) {
        int v13 = *(_DWORD *)(v12 + 8) & 0x3400 | 0x100;
      }
      else {
        int v13 = 256;
      }
      *a6 |= v13;
    }
    uint64_t StrokeColor = CGGStateGetStrokeColor(a2);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 8))(v10, StrokeColor);
    *a5 = result;
    if (result) {
      int v15 = *(_DWORD *)(result + 8) & 0x3400 | 0x200;
    }
    else {
      int v15 = 512;
    }
  }
  *a6 |= v15;
  return result;
}

CGRect *CG::DisplayListEntryRects::setRects(CG::DisplayListEntryRects *this, const CGRect *a2, uint64_t a3)
{
  uint64_t result = (CGRect *)*((void *)this + 17);
  if (result != a2)
  {
    free(result);
    *((void *)this + 17) = 0;
    uint64_t result = (CGRect *)malloc_type_malloc(32 * a3, 0x705560E0uLL);
    *((void *)this + 17) = result;
    if (result) {
      uint64_t result = (CGRect *)memcpy(result, a2, 32 * a3);
    }
  }
  *((void *)this + 18) = a3;
  return result;
}

uint64_t rip_auto_context_contains_transparency(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 88);
  if (v8)
  {
    if (*(_DWORD *)(v8 + 16) == 1129601108 && *(_DWORD *)(v8 + 24) == 4)
    {
      return (*(unsigned char *)(*(void *)(v8 + 32) + 40) & 0x1F) != 0;
    }
    else
    {
      handle_invalid_context((char)"CGBitmapContextGetBitmapInfo", v8, a3, a4, a5, a6, a7, a8);
      return 0;
    }
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 72);
    if (!v10) {
      _CGHandleAssert("rip_auto_context_contains_transparency", 350, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/AutomaticBitmapContext/RIPAutomaticContext.c", "data->dl != NULL", "display list is missing", a6, a7, a8, vars0);
    }
    return CG::DisplayList::containsTransparentContent((CG::DisplayList *)(v10 + 16), 0);
  }
}

uint64_t CG::DisplayList::containsTransparentContent(CG::DisplayList *this, const CGRect *a2)
{
  if ((*((unsigned char *)this + 65) & 0x10) == 0) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 13);
  if (!*(void *)v3) {
    return 1;
  }
  if (*(unsigned char *)(v3 + 48))
  {
    if (*(double *)(v3 + 16) == INFINITY || *(double *)(v3 + 24) == INFINITY) {
      return 0;
    }
    double v6 = *(double *)(v3 + 32);
    double v7 = *(double *)(v3 + 40);
  }
  else
  {
    Shape = CG::DisplayListShape::getShape(*((CG::DisplayListShape **)this + 13), a2);
    if (!Shape) {
      return 1;
    }
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    if (!shape_bounds((uint64_t)Shape, (int *)&v10 + 1, &v10, (signed int *)&v9 + 1, &v9)) {
      return 1;
    }
    double v5 = (double)(int)v10;
    double v6 = (double)(HIDWORD(v9) - HIDWORD(v10));
    double v7 = (double)((int)v9 - (int)v10);
    *(double *)(v3 + 16) = (double)SHIDWORD(v10);
    *(double *)(v3 + 24) = v5;
    *(double *)(v3 + 32) = v6;
    *(double *)(v3 + 40) = v7;
    *(_DWORD *)(v3 + 48) |= 1u;
  }
  uint64_t result = 0;
  if (v6 != 0.0 && v7 != 0.0) {
    return 1;
  }
  return result;
}

uint64_t rip_auto_context_update_content_info_from_GState(uint64_t a1, uint64_t a2)
{
  uint64_t FillColor = CGGStateGetFillColor(a2);
  if (FillColor < 1) {
    double v5 = 0;
  }
  else {
    double v5 = *(const void **)(FillColor + 32);
  }
  update_colored_pattern_info(a1 + 264, v5);
  uint64_t StrokeColor = CGGStateGetStrokeColor(a2);
  if (StrokeColor < 1) {
    double v7 = 0;
  }
  else {
    double v7 = *(const void **)(StrokeColor + 32);
  }
  update_colored_pattern_info(a1 + 288, v7);
  if (!*(unsigned char *)(a1 + 104))
  {
    unint64_t v8 = CGGStateGetFillColor(a2);
    BOOL v10 = CGColorIsWideGamut(v8)
       || (unint64_t v9 = CGGStateGetStrokeColor(a2), CGColorIsWideGamut(v9))
       || *(void *)(a1 + 264) && *(unsigned char *)(a1 + 272)
       || *(void *)(a1 + 288) && *(unsigned char *)(a1 + 296);
    *(unsigned char *)(a1 + 104) = v10;
  }
  int v11 = *(_DWORD *)(a1 + 108);
  unint64_t ColorSpace = CGGStateGetFillColor(a2);
  if (ColorSpace)
  {
    if ((ColorSpace & 0x8000000000000000) != 0) {
      unint64_t ColorSpace = (unint64_t)CGTaggedColorGetColorSpace(ColorSpace, v13, v14, v15, v16, v17, v18, v19);
    }
    else {
      unint64_t ColorSpace = *(void *)(ColorSpace + 24);
    }
  }
  int content_type_from_color_space = rip_auto_context_get_content_type_from_color_space(ColorSpace);
  int v21 = *(_DWORD *)(a1 + 276);
  unint64_t v22 = CGGStateGetStrokeColor(a2);
  if (v22)
  {
    if ((v22 & 0x8000000000000000) != 0) {
      unint64_t v22 = (unint64_t)CGTaggedColorGetColorSpace(v22, v23, v24, v25, v26, v27, v28, v29);
    }
    else {
      unint64_t v22 = *(void *)(v22 + 24);
    }
  }
  *(_DWORD *)(a1 + 108) = content_type_from_color_space | v11 | v21 | rip_auto_context_get_content_type_from_color_space(v22) | *(_DWORD *)(a1 + 300) | (2 * (*(void *)(*(void *)(a2 + 120) + 16) != 0));
  unsigned int v36 = CGPixelComponentMax(*(unsigned int *)(a1 + 280), *(_DWORD *)(a1 + 100), v30, v31, v32, v33, v34, v35);
  *(_DWORD *)(a1 + 100) = v36;
  uint64_t result = CGPixelComponentMax(*(unsigned int *)(a1 + 304), v36, v37, v38, v39, v40, v41, v42);
  *(_DWORD *)(a1 + 100) = result;
  *(unsigned char *)(a1 + 105) |= *(unsigned char *)(a1 + 297) | *(unsigned char *)(a1 + 273);
  return result;
}

uint64_t CGGStateGetStrokeColor(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 128) + 40);
  if (!result)
  {
    uint64_t v3 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
    *(void *)(*(void *)(a1 + 128) + 40) = CGColorSpaceCopyDefaultColor((uint64_t)v3);
    CGColorSpaceRelease(v3);
    return *(void *)(*(void *)(a1 + 128) + 40);
  }
  return result;
}

uint64_t CGPixelComponentMax(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result >= 0xA) {
    _CGHandleAssert("sort_weight", 280, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "(int)type >= 0 && (int)type <= (int)kCGPixelComponentTypeMax", "invalid pixel component type %d", a6, a7, a8, result);
  }
  if (a2 >= 0xA) {
    _CGHandleAssert("sort_weight", 280, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "(int)type >= 0 && (int)type <= (int)kCGPixelComponentTypeMax", "invalid pixel component type %d", a6, a7, a8, a2);
  }
  if (sort_weight_weight[(int)result] <= sort_weight_weight[a2]) {
    return a2;
  }
  else {
    return result;
  }
}

uint64_t rip_auto_context_get_content_type_from_color_space(uint64_t result)
{
  while (result)
  {
    uint64_t v3 = *(void *)(result + 24);
    if (v2 || !v1)
    {
      uint64_t result = 1;
      switch(*(_DWORD *)(v3 + 32))
      {
        case 0:
          return result;
        case 1:
          uint64_t result = 2;
          break;
        case 2:
          uint64_t result = 4;
          break;
        case 3:
          uint64_t result = 8;
          break;
        case 4:
          uint64_t result = 16;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    unsigned int v4 = *(_DWORD *)(v3 + 28);
    BOOL v1 = v4 >= 6;
    BOOL v2 = v4 == 6;
    if (v4 != 6) {
      return 0;
    }
    uint64_t result = **(void **)(v3 + 96);
    if (!result) {
      return result;
    }
  }
  return result;
}

void update_colored_pattern_info(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)a1;
  if (cf && *((unsigned char *)cf + 185))
  {
    if (v3 != cf)
    {
      if (v3) {
        CFRelease(v3);
      }
      CFRetain(cf);
      *(void *)a1 = cf;
      CGContextRef v13 = CGBitmapContextCreateWithCallbacks(2uLL, 2uLL, 0, 0, 0, 0, 0, v5);
      uint64_t v14 = (void (*)(void, CGContextRef))*((void *)cf + 21);
      if (v14) {
        v14(*((void *)cf + 10), v13);
      }
      uint64_t v15 = *(void *)(CGContextGetDelegate((uint64_t)v13, v6, v7, v8, v9, v10, v11, v12) + 288);
      *(_WORD *)(a1 + 8) = *(_WORD *)(v15 + 104);
      int v16 = *(_DWORD *)(v15 + 108);
      LODWORD(v15) = *(_DWORD *)(v15 + 100);
      *(_DWORD *)(a1 + 12) = v16;
      *(_DWORD *)(a1 + 16) = v15;
      if (v13)
      {
        CFRelease(v13);
      }
    }
  }
  else if (v3)
  {
    CFRelease(v3);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

BOOL CGColorIsWideGamut(unint64_t a1)
{
  if (CGColorIsWideGamut_predicate != -1) {
    dispatch_once(&CGColorIsWideGamut_predicate, &__block_literal_global_23_2418);
  }
  BOOL v2 = CGColorTransformConvertColor((void *)CGColorIsWideGamut_transform, a1, 0);
  if (!v2) {
    return 0;
  }
  CFTypeRef v3 = v2;
  Components = CGColorGetComponents(v2);
  BOOL v5 = 1;
  if (*Components >= -0.25 && *Components <= 1.03)
  {
    double v6 = Components[1];
    if (v6 >= -0.2 && v6 <= 1.05)
    {
      double v7 = Components[2];
      BOOL v5 = v7 > 1.02 || v7 < -0.1;
    }
  }
  CFRelease(v3);
  return v5;
}

CGColorRef CGColorTransformConvertColor(void *a1, unint64_t a2, uint64_t a3)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (kCGColorTransformDefaultCMYK_block_invoke_once != -1) {
    dispatch_once(&kCGColorTransformDefaultCMYK_block_invoke_once, &__block_literal_global_34_17166);
  }
  CGColorRef v14 = 0;
  if (a2 && v13 == CGColorTransformGetTypeID_type_id)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      CGColorSpaceRef ColorSpace = CGTaggedColorGetColorSpace(a2, v6, v7, v8, v9, v10, v11, v12);
    }
    else {
      CGColorSpaceRef ColorSpace = *(CGColorSpaceRef *)(a2 + 24);
    }
    Cache = CGColorTransformGetCache(a1);
    if (Cache)
    {
      uint64_t v18 = (CGColorSpace *)Cache[2];
      if (v18)
      {
        uint64_t v19 = *(void *)(*((void *)v18 + 3) + 48);
LABEL_15:
        MEMORY[0x1F4188790](Cache, v17);
        uint64_t v23 = (CGFloat *)((char *)v35 - v22);
        if (v21 <= 0x1FFFFFFFFFFFFFFELL) {
          uint64_t v24 = (CGFloat *)((char *)v35 - v22);
        }
        else {
          uint64_t v24 = 0;
        }
        if (v21 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022) {
          uint64_t v24 = (CGFloat *)malloc_type_malloc(8 * v20, 0xF69293D9uLL);
        }
        Components = (double *)CGColorGetComponents((CGColorRef)a2);
        if (CGColorTransformConvertColorComponents((uint64_t)a1, ColorSpace, a3, Components, v24))
        {
          if ((a2 & 0x8000000000000000) != 0) {
            Alphdouble a = CGTaggedColorGetAlpha(a2, v26, v27, v28, v29, v30, v31, v32);
          }
          else {
            Alphdouble a = *(double *)(a2 + 8 * *(void *)(a2 + 56) + 56);
          }
          v24[v19] = Alpha;
          CGColorRef v14 = CGColorCreate(v18, v24);
          if (v24 != v23) {
            free(v24);
          }
        }
        else
        {
          if (v24 != v23) {
            free(v24);
          }
          return 0;
        }
        return v14;
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v19 = 0;
    goto LABEL_15;
  }
  return v14;
}

uint64_t shape_bounds(uint64_t a1, int *a2, _DWORD *a3, signed int *a4, _DWORD *a5)
{
  if (*(_DWORD *)a1 == 0x80000000 && *(_DWORD *)(a1 + 4) == 4 && *(_DWORD *)(a1 + 16) == 0x7FFFFFFF)
  {
    uint64_t v5 = 0;
    signed int v6 = *(_DWORD *)(a1 + 8);
    int v7 = *(_DWORD *)(a1 + 12);
    *a4 = v6;
    *a2 = v6;
    *a5 = v7;
    *a3 = v7;
  }
  else
  {
    if ((_UNKNOWN *)a1 == &the_empty_shape) {
      goto LABEL_18;
    }
    uint64_t v8 = (int *)(a1 + 4 * *(int *)(a1 + 4));
    int v9 = *v8;
    if (*v8 == 0x7FFFFFFF) {
      goto LABEL_18;
    }
    uint64_t v10 = v8[1];
    uint64_t v11 = &v8[v10];
    int v12 = *v11;
    if (*v11 == 0x7FFFFFFF) {
      goto LABEL_18;
    }
    signed int v13 = 0x80000000;
    int v14 = 0x7FFFFFFF;
    do
    {
      uint64_t v15 = v11;
      int v16 = v12;
      if ((int)v10 >= 4)
      {
        int v17 = v8[2];
        signed int v18 = v8[(v10 - 1)];
        if (v17 < v14) {
          int v14 = v17;
        }
        if (v18 > v13) {
          signed int v13 = v18;
        }
      }
      uint64_t v10 = v15[1];
      uint64_t v11 = &v15[v10];
      int v12 = *v11;
      uint64_t v8 = v15;
    }
    while (*v11 != 0x7FFFFFFF);
    if (v14 >= v13 || v9 >= v16)
    {
LABEL_18:
      uint64_t v5 = 0;
      *a5 = 0;
      *a3 = 0;
      *a4 = 0;
      *a2 = 0;
    }
    else
    {
      *a2 = v14;
      *a3 = v9;
      *a4 = v13;
      *a5 = v16;
      return (((unint64_t)v15 - a1) >> 2) + 3;
    }
  }
  return v5;
}

int *CG::DisplayListShape::getShape(CG::DisplayListShape *this, const CGRect *a2)
{
  CFTypeRef v3 = (std::mutex *)((char *)this + 56);
  std::mutex::lock((std::mutex *)((char *)this + 56));
  unsigned int v4 = (int *)*((void *)this + 1);
  if (v4 || (unsigned int v4 = shape_accum_shape(*(int **)this), (*((void *)this + 1) = v4) != 0))
  {
    if (v4 == (int *)&the_empty_shape) {
      unsigned int v4 = 0;
    }
  }
  else
  {
    *((void *)this + 1) = &the_empty_shape;
  }
  std::mutex::unlock(v3);
  return v4;
}

int *shape_accum_shape(int *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return (int *)&the_empty_shape;
  }
  uint64_t v1 = *a1;
  BOOL v2 = (int *)&the_empty_shape;
  if ((int)v1 < 3) {
    return v2;
  }
  BOOL v2 = 0;
  uint64_t v3 = *((void *)a1 + 2);
  unint64_t v4 = v3 + 16 * v1;
  uint64_t v5 = (int *)(v3 + 12);
  do
  {
    int v7 = *(v5 - 3);
    int v6 = *(v5 - 2);
    uint64_t v8 = v5 - 3;
    if (v7 < v6)
    {
      int v9 = *(v5 - 1) <= -2147483647 ? -2147483647 : *(v5 - 1);
      int v10 = *v5 >= 2147483646 ? 2147483646 : *v5;
      if (v9 < v10)
      {
        if (v2)
        {
          uint64_t v15 = 0x280000000;
          int v16 = v9;
          int v17 = 4;
          int v18 = v7;
          int v19 = v6;
          int v20 = v10;
          uint64_t v21 = 0x7FFFFFFF00000002;
          a1 = shape_union((uint64_t)a1, v2, (int *)&v15);
          uint64_t v11 = a1;
          if (v2 != (int *)&v22 && v2 != (int *)&the_empty_shape) {
            free(v2);
          }
          BOOL v2 = v11;
        }
        else
        {
          *(void *)&long long v22 = 0x280000000;
          *((void *)&v22 + 1) = v9 | 0x400000000;
          *(_DWORD *)uint64_t v23 = v7;
          *(_DWORD *)&v23[4] = v6;
          *(_DWORD *)&v23[8] = v10;
          BOOL v2 = (int *)&v22;
          *(void *)&v23[12] = 0x7FFFFFFF00000002;
        }
      }
    }
    v5 += 4;
  }
  while ((unint64_t)(v8 + 4) < v4);
  if (!v2) {
    return (int *)&the_empty_shape;
  }
  if (v2 == (int *)&v22)
  {
    int v12 = (int *)malloc_type_malloc(0x200uLL, 0x705560E0uLL);
    BOOL v2 = v12;
    if (v12)
    {
      long long v13 = *(_OWORD *)v23;
      *(_OWORD *)int v12 = v22;
      *((_OWORD *)v12 + 1) = v13;
      v12[8] = *(_DWORD *)&v23[16];
    }
  }
  return v2;
}

uint64_t CG::DisplayListRecorder::DrawImage(CFArrayRef *a1, uint64_t a2, uint64_t a3, CGImageRef a4, double a5, CGFloat a6, double a7, double a8)
{
  _D8 = a5;
  CGImageRef v174 = 0;
  CGImageRef v175 = 0;
  CGImageRef v173 = 0;
  uint64_t v15 = (char *)CG::DisplayListRecorder::currentDisplayList(a1);
  if (!v15) {
    goto LABEL_78;
  }
  double v16 = a7;
  double v17 = a8;
  if (a7 < 0.0 || a8 < 0.0)
  {
    double v18 = _D8;
    CGFloat v19 = a6;
    *(CGRect *)(&v16 - 2) = CGRectStandardize(*(CGRect *)(&v16 - 2));
    _D8 = v20;
    a6 = v21;
  }
  _Q16 = *(float64x2_t *)(a3 + 24);
  float64x2_t v23 = *(float64x2_t *)(a3 + 40);
  float64x2_t v24 = vmlaq_n_f64(vmulq_f64(v23, (float64x2_t)0), _Q16, v16);
  float64x2_t v25 = vmlaq_f64(vmulq_n_f64(v23, v17), (float64x2_t)0, _Q16);
  __asm { FMLA            D0, D8, V16.D[1] }
  double v30 = _D0 + *(double *)(a3 + 64);
  v31.f64[0] = *(double *)(a3 + 56) + vmlad_n_f64(a6 * v23.f64[0], _D8, _Q16.f64[0]);
  v31.f64[1] = v30;
  float64x2_t v162 = v31;
  float64x2_t v164 = v24;
  double rect = v31.f64[0];
  float64x2_t v160 = v25;
  double v154 = v30;
  if (v15[73])
  {
    *(float64x2_t *)&v170.double a = v24;
    *(float64x2_t *)&v170.double c = v25;
    *(float64x2_t *)&v170.double tx = v31;
    v176.origin.double x = 0.0;
    v176.origin.CGFloat y = 0.0;
    v176.size.size_t width = 1.0;
    v176.size.size_t height = 1.0;
    CGRect v177 = CGRectApplyAffineTransform(v176, &v170);
    v171.double x = v177.origin.x;
    v171.CGFloat y = v177.origin.y;
    *(CGFloat *)&long long v172 = v177.size.width;
    *((void *)&v172 + 1) = *(void *)&v177.size.height;
    CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v171.x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
    CGFloat v9 = v35;
    v171.double x = v35;
    v171.CGFloat y = v32;
    *(double *)&long long v172 = v33;
    *((double *)&v172 + 1) = v34;
    if (v35 == INFINITY || v32 == INFINITY)
    {
LABEL_96:
      uint64_t v37 = 0;
      goto LABEL_97;
    }
    a6 = v33;
    uint64_t v37 = 0;
    if (v33 == 0.0) {
      goto LABEL_97;
    }
    _D8 = v34;
    if (v34 == 0.0) {
      goto LABEL_97;
    }
    CGFloat v8 = v32;
  }
  EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v15 + 16), (void *)a3, a2);
  uint64_t v39 = EntryDrawingState[1];
  if (!v39) {
    goto LABEL_78;
  }
  int v40 = *(_DWORD *)(v39 + 8);
  uint64_t v41 = EntryDrawingState[2];
  if (v41) {
    v40 |= *(_DWORD *)(v41 + 8);
  }
  int v42 = v40 & 0x1000;
  uint64_t v43 = EntryDrawingState[3];
  if (v43) {
    v42 |= *(_DWORD *)(v43 + 8) & 0x3400;
  }
  if (!v15[73] && !CG::DisplayList::getClipRecordingToFrame((CG::DisplayList *)(v15 + 16))) {
    goto LABEL_73;
  }
  if (v15[77])
  {
    DataProviderInternal = CGImageGetDataProviderInternal((char *)a4, 0);
    if (DataProviderInternal)
    {
      long long v45 = (const UInt8 *(__cdecl *)(CFDataRef))*((void *)DataProviderInternal + 10);
      if (v45 != getCFDataBytePointer && (char *)v45 != (char *)data_get_byte_pointer)
      {
        CFDataRef v46 = CGDataProviderCopyData((CGDataProviderRef)DataProviderInternal);
        if (v46)
        {
          CFDataRef v47 = v46;
          CGDataProviderRef v48 = CGDataProviderCreateWithCFData(v46);
          CGDataProviderRef v169 = v48;
          if (v48)
          {
            int v49 = v48;
            CFDataRef v152 = v47;
            if (a4)
            {
              size_t width = *((void *)a4 + 5);
              size_t height = *((void *)a4 + 6);
              size_t bitsPerComponent = *((void *)a4 + 7);
              size_t bitsPerPixel = *((void *)a4 + 8);
              size_t bytesPerRow = *((void *)a4 + 9);
            }
            else
            {
              size_t bitsPerPixel = 0;
              size_t height = 0;
              size_t width = 0;
              size_t bitsPerComponent = 0;
              size_t bytesPerRow = 0;
            }
            space = CGImageGetColorSpace(a4);
            CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(a4);
            decode = CGImageGetDecode(a4);
            BOOL shouldInterpolate = CGImageGetShouldInterpolate(a4);
            CGColorRenderingIntent intent = CGImageGetRenderingIntent(a4);
            CGImageRef v53 = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, v49, decode, shouldInterpolate, intent);
            CGImageRef v174 = v53;
            uint64_t v168 = 0;
            applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)&v168);
            CGImageCopyHeadroomFromOriginal((uint64_t *)v53, a4, v54, v55, v56, v57, v58, v59);
            uint64_t v168 = 0;
            if (a4 && *((void *)a4 + 22))
            {
              Mask = (char *)CGImageGetMask(a4);
              if (Mask)
              {
                int v61 = Mask;
                unsigned int v62 = CGImageGetDataProviderInternal(Mask, 0);
                if (v62)
                {
                  unsigned int v63 = (const UInt8 *(__cdecl *)(CFDataRef))*((void *)v62 + 10);
                  if (v63 != getCFDataBytePointer && (char *)v63 != (char *)data_get_byte_pointer)
                  {
                    CFDataRef v64 = CGDataProviderCopyData((CGDataProviderRef)v62);
                    CFDataRef v167 = v64;
                    if (v64)
                    {
                      uint64_t v166 = CGDataProviderCreateWithCFData(v64);
                      heightdouble b = *((void *)v61 + 5);
                      widthdouble c = *((void *)v61 + 6);
                      bitsPerPixeldouble b = *((void *)v61 + 7);
                      bitsPerComponentdouble b = *((void *)v61 + 8);
                      bytesPerRowdouble a = *((void *)v61 + 9);
                      spacedouble a = CGImageGetColorSpace((CGImageRef)v61);
                      bitmapInfodouble a = CGImageGetBitmapInfo((CGImageRef)v61);
                      unsigned int v130 = CGImageGetDecode((CGImageRef)v61);
                      BOOL v65 = CGImageGetShouldInterpolate((CGImageRef)v61);
                      CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent((CGImageRef)v61);
                      CGImageRef v67 = CGImageCreate(heightb, widthc, bitsPerPixelb, bitsPerComponentb, bytesPerRowa, spacea, bitmapInfoa, v166, v130, v65, RenderingIntent);
                      unint64_t v68 = (const void *)v168;
                      uint64_t v168 = (uint64_t)v67;
                      uint64_t v165 = v68;
                      applesauce::CF::ObjectRef<CGImage *>::~ObjectRef(&v165);
                      applesauce::CF::ObjectRef<CGDataProvider *>::~ObjectRef((const void **)&v166);
                    }
                    applesauce::CF::ObjectRef<__CFData const*>::~ObjectRef((const void **)&v167);
                  }
                }
              }
              CFDataRef v47 = v152;
              if (v168)
              {
                CGImageRef v53 = CGImageCreateWithMaskAndMatte((uint64_t)v53, v168, 0);
                CGImageRef v173 = v53;
                CFDataRef v167 = 0;
                applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)&v167);
              }
            }
            else
            {
              CFDataRef v47 = v152;
            }
            if (v53) {
              a4 = v53;
            }
            applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)&v168);
          }
          applesauce::CF::ObjectRef<CGDataProvider *>::~ObjectRef((const void **)&v169);
          CFRelease(v47);
        }
      }
    }
  }
  if (!CG::DisplayList::getClipRecordingToFrame((CG::DisplayList *)(v15 + 16))) {
    goto LABEL_73;
  }
  if (a4)
  {
    double v153 = (double)*((unint64_t *)a4 + 5);
    unint64_t v69 = *((void *)a4 + 6);
  }
  else
  {
    unint64_t v69 = 0;
    double v153 = 0.0;
  }
  v184.origin.double x = v9;
  v184.origin.CGFloat y = v8;
  v184.size.size_t width = a6;
  v184.size.size_t height = _D8;
  CGRect v178 = CGRectIntersection(*(CGRect *)(v15 + 40), v184);
  double x = v178.origin.x;
  uint64_t v37 = 0;
  if (v178.origin.x != INFINITY && v178.origin.y != INFINITY)
  {
    uint64_t v37 = 0;
    if (v178.size.width != 0.0 && v178.size.height != 0.0)
    {
      CGFloat y = v178.origin.y;
      bitsPerPixeldouble a = v178.origin;
      widthdouble a = v178.size.width;
      v79.f64[0] = v153;
      v79.f64[1] = (double)v69;
      float64x2_t v80 = vdivq_f64(v164, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v153, 0));
      heightdouble a = (double)v69;
      int64x2_t v81 = (int64x2_t)vdivq_f64(v160, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v69), 0));
      float64x2_t v82 = vmulq_f64(v80, (float64x2_t)vextq_s8((int8x16_t)v81, (int8x16_t)v81, 8uLL));
      float64x2_t v83 = vsubq_f64(v82, (float64x2_t)vextq_s8((int8x16_t)v82, (int8x16_t)v82, 8uLL));
      bitsPerComponentdouble a = v178.size.height;
      if (v83.f64[0] == 0.0)
      {
        float64x2_t v155 = v79;
        rectdouble b = x;
        *(int64x2_t *)spacedouble b = v81;
        *(float64x2_t *)bytesPerRowdouble b = v80;
        CGPostError((uint64_t)"%s: singular matrix.", v70, v71, v72, v73, v74, v75, v76, (char)"AffineTransformInvert");
        float64x2_t v84 = *(float64x2_t *)spaceb;
        float64x2_t v85 = *(float64x2_t *)bytesPerRowb;
        float64x2_t v79 = v155;
        double x = rectb;
        v178.size.size_t height = bitsPerComponenta;
        v178.size.size_t width = widtha;
        float64x2_t v86 = v162;
      }
      else
      {
        float64x2_t v87 = (float64x2_t)vzip2q_s64(v81, (int64x2_t)v80);
        float64x2_t v88 = (float64x2_t)vzip1q_s64(v81, (int64x2_t)v80);
        float64x2_t v85 = vdivq_f64(v87, v83);
        float64x2_t v84 = vdivq_f64(v88, (float64x2_t)vextq_s8((int8x16_t)v83, (int8x16_t)v83, 8uLL));
        float64x2_t v86 = vmlsq_lane_f64(vmulq_n_f64(v84, -v154), v85, rect, 0);
      }
      float64x2_t v89 = vaddq_f64(v86, vmlaq_n_f64(vmulq_laneq_f64(v84, (float64x2_t)bitsPerPixela, 1), v85, x));
      float64x2_t v90 = vmulq_n_f64(v85, v178.size.width);
      float64x2_t v91 = vmulq_n_f64(v84, v178.size.height);
      float64x2_t v92 = vaddq_f64(v90, v91);
      float64x2_t v93 = vmaxnmq_f64(vminnmq_f64(vminnmq_f64(vminnmq_f64(v90, (float64x2_t)0), v91), v92), vnegq_f64(v89));
      float64x2_t v94 = vaddq_f64(v89, v93);
      CGFloat v95 = v94.f64[1];
      float64x2_t v96 = vmaxnmq_f64(vminnmq_f64(vsubq_f64(vmaxnmq_f64(vmaxnmq_f64(vmaxnmq_f64(v90, (float64x2_t)0), v91), v92), v93), vsubq_f64(v79, v94)), (float64x2_t)0);
      CGFloat v97 = v96.f64[1];
      BOOL v98 = v96.f64[1] < 0.0 || v96.f64[0] < 0.0;
      CGFloat v156 = v94.f64[0];
      rectdouble a = v96.f64[0];
      if (v98)
      {
        float64x2_t v99 = v94;
        float64_t v100 = v96.f64[1];
        *(CGRect *)(&v96 - 1) = CGRectStandardize(*(CGRect *)(&v96 - 1));
        v94.f64[0] = v156;
        _NF = v96.f64[0] < v153;
        v96.f64[0] = recta;
        if (_NF)
        {
LABEL_65:
          double v101 = v95;
          double v102 = v97;
          if (v98)
          {
            v181.origin.double x = v94.f64[0];
            v181.origin.CGFloat y = v95;
            v181.size.size_t width = recta;
            v181.size.size_t height = v97;
            *(CGRect *)(&v96 - 1) = CGRectStandardize(v181);
            v94.f64[0] = v156;
            v96.f64[0] = recta;
          }
LABEL_67:
          double v103 = heighta - (v101 + v102);
          float64_t v104 = v94.f64[0];
          CGFloat v105 = v97;
          CGImageRef v106 = CGImageCreateWithImageInRect(a4, *(CGRect *)(&v96 - 1));
          CGImageRef v107 = v175;
          CGImageRef v175 = v106;
          if (v107) {
            CFRelease(v107);
          }
          if (v106)
          {
            *(CGFloat *)&long long v108 = widtha;
            *((CGFloat *)&v108 + 1) = bitsPerComponenta;
            *(_OWORD *)widthdouble b = v108;
            *(CGFloat *)&long long v108 = v156;
            CGFloat v109 = recta;
            CGFloat v110 = v95;
            CGFloat v111 = v97;
            CGRect v182 = CGRectIntegral(*(CGRect *)&v108);
            CGFloat v112 = v182.origin.x;
            CGFloat v113 = v182.origin.y;
            CGFloat v114 = v182.size.width;
            CGFloat v115 = v182.size.height;
            if (v182.size.width < 0.0 || v182.size.height < 0.0)
            {
              CGRectStandardize(v182);
              v183.origin.double x = v112;
              v183.origin.CGFloat y = v113;
              v183.size.size_t width = v114;
              v183.size.size_t height = v115;
              CGRectStandardize(v183);
            }
            CGPoint v171 = bitsPerPixela;
            long long v172 = *(_OWORD *)widthb;
LABEL_74:
            uint64_t v116 = CG::DisplayList::imageResourceForImage((CG::DisplayList *)(v15 + 16), v106);
            uint64_t v117 = v116;
            if (v116)
            {
              if ((*(unsigned char *)(v116 + 48) & 0x20) != 0)
              {
                uint64_t FillColor = (CGColor *)CGGStateGetFillColor(a3);
                uint64_t v127 = CG::DisplayList::colorResourceForColor((CG::DisplayList *)(v15 + 16), FillColor, v120, v121, v122, v123, v124, v125, v126);
                uint64_t v118 = (const CG::DisplayListResourceColor *)v127;
                if (v127)
                {
                  int v128 = v42 | *(_DWORD *)(v127 + 8) & 0x3400;
                  if (*(double *)(*(void *)(a3 + 120) + 8) >= 1.0) {
                    LOWORD(v42) = v128 | 0x100;
                  }
                  else {
                    LOWORD(v42) = v128 | 0x1100;
                  }
                }
              }
              else
              {
                uint64_t v118 = 0;
                if (*(double *)(*(void *)(a3 + 120) + 8) >= 1.0) {
                  v42 |= *(_DWORD *)(v116 + 8) & 0x1000;
                }
                else {
                  LOWORD(v42) = v42 | 0x1000;
                }
              }
              if ((v42 & 0x1000) == 0
                && (((int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 16) >> 24) - 3) < 0xFFFFFFFE)
              {
                LOWORD(v42) = v42 | 0x1000;
              }
              if ((v42 & 0x3000) != 0) {
                *((_DWORD *)v15 + 20) |= v42 & 0x3000;
              }
              if (v15[74])
              {
                if ((v42 & 0x400) != 0) {
                  CG::DisplayList::getEntryPatternState((uint64_t)(v15 + 16), a3, a2);
                }
                if ((v42 & 0x100) != 0 && (*(unsigned char *)(v117 + 48) & 0x20) != 0) {
                  CG::DisplayList::getEntryFillState((CG::DisplayList *)(v15 + 16), v118);
                }
                operator new();
              }
              goto LABEL_96;
            }
LABEL_78:
            uint64_t v37 = 1000;
            goto LABEL_97;
          }
LABEL_73:
          CGImageRef v106 = a4;
          goto LABEL_74;
        }
        v179.origin.double x = v156;
        v179.origin.CGFloat y = v95;
        v179.size.size_t width = recta;
        v179.size.size_t height = v97;
        *(CGRect *)(&v96 - 1) = CGRectStandardize(v179);
        v94.f64[0] = v156;
        v96.f64[0] = recta;
      }
      else
      {
        v180.size.size_t height = v96.f64[1];
        if (v96.f64[0] < v153)
        {
          double v101 = v94.f64[1];
          double v102 = v96.f64[1];
          goto LABEL_67;
        }
      }
      if (v180.size.height >= heighta) {
        goto LABEL_73;
      }
      goto LABEL_65;
    }
  }
LABEL_97:
  if (v173) {
    CFRelease(v173);
  }
  if (v174) {
    CFRelease(v174);
  }
  if (v175) {
    CFRelease(v175);
  }
  return v37;
}

void sub_184C39910(_Unwind_Exception *a1)
{
  applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)(v1 - 160));
  applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)(v1 - 152));
  applesauce::CF::ObjectRef<CGImage *>::~ObjectRef((const void **)(v1 - 144));
  _Unwind_Resume(a1);
}

uint64_t dlRecorder_DrawImage(uint64_t a1, uint64_t a2, uint64_t a3, CGImage *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, CGFloat a10, double a11, double a12)
{
  if (a1 && (int v12 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    return CG::DisplayListRecorder::DrawImage(v12, a2, a3, a4, a9, a10, a11, a12);
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawImage");
    return 1000;
  }
}

uint64_t CG::DisplayList::imageResourceForImage(CG::DisplayList *this, CGImage *a2)
{
  if (!a2) {
    return 0;
  }
  ++*((void *)this + 81);
  uint64_t v3 = (char *)this + 256;
  unint64_t v4 = (char *)*((void *)this + 32);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = (char *)this + 256;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    int v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    CGFloat v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      CGFloat v9 = (char **)v4;
      uint64_t v5 = v4;
    }
    unint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *((void *)v5 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < (unint64_t)a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *((void *)v5 + 4);
    long long v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= (unint64_t)a2) {
      return *((void *)v5 + 4);
    }
LABEL_15:
    operator new();
  }
  if (*(CGImage **)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *((void *)v5 + 4);
}

void sub_184C39C90(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10E1C40B0B341C2);
  _Unwind_Resume(a1);
}

uint64_t CG::DisplayList::fontResourceForFont(CG::DisplayList *this, CGFont *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = (char *)this + 232;
  unint64_t v4 = (char *)*((void *)this + 29);
  ++*((void *)this + 80);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = (char *)this + 232;
  do
  {
    uint64_t v7 = *((void *)v4 + 4);
    int v6 = (std::__shared_weak_count *)*((void *)v4 + 5);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v8 = *(void *)(v7 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      unint64_t v8 = *(void *)(v7 + 16);
    }
    CGFloat v9 = (char **)(v4 + 8);
    if (v8 >= (unint64_t)a2)
    {
      CGFloat v9 = (char **)v4;
      uint64_t v5 = v4;
    }
    unint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
    goto LABEL_15;
  }
  uint64_t v10 = *((void *)v5 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v5 + 5);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (*(void *)(v10 + 16) < (unint64_t)a2)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
    uint64_t v14 = *((void *)v5 + 4);
    long long v13 = (std::__shared_weak_count *)*((void *)v5 + 5);
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      unint64_t v15 = *(void *)(v14 + 16);
      std::__shared_weak_count::__release_shared[abi:fe180100](v13);
    }
    else
    {
      unint64_t v15 = *(void *)(v14 + 16);
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    if (v15 <= (unint64_t)a2) {
      return *((void *)v5 + 4);
    }
LABEL_15:
    operator new();
  }
  if (*(CGFont **)(v10 + 16) != a2) {
    goto LABEL_15;
  }
  return *((void *)v5 + 4);
}

void sub_184C39E9C(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

void dl_Finalize(char *a1)
{
  *((void *)a1 + 2) = &unk_1ED094828;
  unint64_t v4 = (void **)(a1 + 592);
  std::vector<std::shared_ptr<CG::DisplayListEntry const>>::__destroy_vector::operator()[abi:fe180100](&v4);
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 72));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 69));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 66));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 63));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 60));
  std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::~__hash_table((uint64_t)(a1 + 432));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 52));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 49));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 46));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 43));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 40));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 37));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 34));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 31));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 28));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 25));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 22));
  std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*((void **)a1 + 19));
  free(*((void **)a1 + 17));
  BOOL v2 = (std::__shared_weak_count *)*((void *)a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:fe180100](v2);
  }
  uint64_t v3 = (const void *)*((void *)a1 + 4);
  if (v3) {
    CFRelease(v3);
  }
}

void std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(*a1);
    std::__tree<std::shared_ptr<CG::DisplayListEntryStatePattern const>,CG::CompareEntryStatePattern,std::allocator<std::shared_ptr<CG::DisplayListEntryStatePattern const>>>::destroy(a1[1]);
    BOOL v2 = (std::__shared_weak_count *)a1[5];
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:fe180100](v2);
    }
    operator delete(a1);
  }
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListEntry const*,std::shared_ptr<CG::DisplayListEntry const>::__shared_ptr_default_delete<CG::DisplayListEntry const,CG::DisplayListEntry const>,std::allocator<CG::DisplayListEntry const>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListEntryStateDrawing *,std::shared_ptr<CG::DisplayListEntryStateDrawing const>::__shared_ptr_default_delete<CG::DisplayListEntryStateDrawing const,CG::DisplayListEntryStateDrawing>,std::allocator<CG::DisplayListEntryStateDrawing>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListEntryStateDrawing::~DisplayListEntryStateDrawing(CG::DisplayListEntryStateDrawing *this)
{
}

void CG::DisplayListResourceColor::~DisplayListResourceColor(CG::DisplayListResourceColor *this)
{
  *(void *)this = &unk_1ED094B80;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094B80;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceColor *,std::shared_ptr<CG::DisplayListResourceColor>::__shared_ptr_default_delete<CG::DisplayListResourceColor,CG::DisplayListResourceColor>,std::allocator<CG::DisplayListResourceColor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceColorSpace *,std::shared_ptr<CG::DisplayListResourceColorSpace>::__shared_ptr_default_delete<CG::DisplayListResourceColorSpace,CG::DisplayListResourceColorSpace>,std::allocator<CG::DisplayListResourceColorSpace>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceColorSpace::~DisplayListResourceColorSpace(CGColorSpaceRef *this)
{
  *this = (CGColorSpaceRef)&unk_1ED094E58;
  CGColorSpaceRelease(this[2]);

  JUMPOUT(0x18532A2A0);
}

{
  *this = (CGColorSpaceRef)&unk_1ED094E58;
  CGColorSpaceRelease(this[2]);
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListEntryStateFill *,std::shared_ptr<CG::DisplayListEntryStateFill const>::__shared_ptr_default_delete<CG::DisplayListEntryStateFill const,CG::DisplayListEntryStateFill>,std::allocator<CG::DisplayListEntryStateFill>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListEntryStateFill::~DisplayListEntryStateFill(CG::DisplayListEntryStateFill *this)
{
}

uint64_t std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::__deallocate_node(*(void **)(a1 + 16));
  BOOL v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::shared_ptr<CG::DisplayListResourceDisplayList>,CG::HashResourceDisplayList,CG::EqualsResourceDisplayList,std::allocator<std::shared_ptr<CG::DisplayListResourceDisplayList>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      BOOL v2 = (void *)*v1;
      uint64_t v3 = (std::__shared_weak_count *)v1[3];
      if (v3) {
        std::__shared_weak_count::__release_shared[abi:fe180100](v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__shared_ptr_emplace<CG::DisplayListShape>::__on_zero_shared(uint64_t a1)
{
}

void CG::DisplayListShape::~DisplayListShape(CG::DisplayListShape *this)
{
  BOOL v2 = (void *)*((void *)this + 1);
  if (v2) {
    BOOL v3 = v2 == &the_empty_shape;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    free(v2);
  }
  if (*(void *)this) {
    free(*(void **)this);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 56));
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceClip *,std::shared_ptr<CG::DisplayListResourceClip>::__shared_ptr_default_delete<CG::DisplayListResourceClip,CG::DisplayListResourceClip>,std::allocator<CG::DisplayListResourceClip>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceClip::~DisplayListResourceClip(void **this)
{
  *this = &unk_1ED094AB8;
  CGClipStackRelease(this[2]);

  JUMPOUT(0x18532A2A0);
}

{
  *this = &unk_1ED094AB8;
  CGClipStackRelease(this[2]);
}

void CG::DisplayListEntryGlyphs::~DisplayListEntryGlyphs(void **this)
{
  *this = &unk_1ED094A20;
  free(this[29]);
  free(this[30]);

  JUMPOUT(0x18532A2A0);
}

{
  *this = &unk_1ED094A20;
  free(this[29]);
  free(this[30]);
}

void CG::DisplayListResourceFont::~DisplayListResourceFont(CG::DisplayListResourceFont *this)
{
  *(void *)this = &unk_1ED094B18;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094B18;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceFont *,std::shared_ptr<CG::DisplayListResourceFont>::__shared_ptr_default_delete<CG::DisplayListResourceFont,CG::DisplayListResourceFont>,std::allocator<CG::DisplayListResourceFont>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceFont::setFont(CG::DisplayListResourceFont *this, void *cf)
{
  BOOL v3 = (void *)*((void *)this + 2);
  if (v3 != cf)
  {
    if (v3) {
      CFRelease(v3);
    }
    if (cf)
    {
      CFRetain(cf);
      *((void *)this + 2) = cf;
      font_float64x2_t info = (int *)get_font_info(cf);
      if (font_info)
      {
        double v6 = (double)font_info[2];
LABEL_9:
        *((double *)this + 3) = v6;
        return;
      }
    }
    else
    {
      *((void *)this + 2) = 0;
    }
    double v6 = 0.0;
    goto LABEL_9;
  }
}

void CG::DisplayListEntryRects::~DisplayListEntryRects(void **this)
{
  *this = &unk_1ED094988;
  free(this[17]);

  JUMPOUT(0x18532A2A0);
}

{
  *this = &unk_1ED094988;
  free(this[17]);
}

void CG::DisplayListEntryAction::~DisplayListEntryAction(CG::DisplayListEntryAction *this)
{
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceImage *,std::shared_ptr<CG::DisplayListResourceImage>::__shared_ptr_default_delete<CG::DisplayListResourceImage,CG::DisplayListResourceImage>,std::allocator<CG::DisplayListResourceImage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceImage::~DisplayListResourceImage(CG::DisplayListResourceImage *this)
{
  *(void *)this = &unk_1ED094BB0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094BB0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

void CG::DisplayListEntryImage::~DisplayListEntryImage(CG::DisplayListEntryImage *this)
{
}

BOOL CG::DisplayList::getClipRecordingToFrame(CG::DisplayList *this)
{
  if (!*((unsigned char *)this + 56)) {
    return 0;
  }
  return *((double *)this + 3) != -8.98846567e307
      || *((double *)this + 4) != -8.98846567e307
      || *((double *)this + 5) != 1.79769313e308
      || *((double *)this + 6) != 1.79769313e308;
}

void CG::DisplayListEntryPath::~DisplayListEntryPath(CG::DisplayListEntryPath *this)
{
  CG::DisplayListEntryPath::~DisplayListEntryPath(this);

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED0948E0;
  uint64_t v1 = (const void *)*((void *)this + 11);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t rip_auto_context_update_content_info_from_image(uint64_t a1, CGImageRef image)
{
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceRef v5 = ColorSpace;
  if (image && (*((unsigned char *)image + 39) & 2) != 0) {
    goto LABEL_7;
  }
  int content_type_from_color_space = rip_auto_context_get_content_type_from_color_space((uint64_t)ColorSpace);
  *(_DWORD *)(a1 + 108) |= content_type_from_color_space;
  if (content_type_from_color_space == 1) {
    goto LABEL_11;
  }
  if (content_type_from_color_space != 2)
  {
LABEL_7:
    char v8 = 1;
  }
  else
  {
    if (v5) {
      BOOL v7 = *(unsigned char *)(*((void *)v5 + 3) + 14) != 0;
    }
    else {
      BOOL v7 = 0;
    }
    char v8 = *(unsigned char *)(a1 + 104) | v7;
  }
  *(unsigned char *)(a1 + 104) = v8;
LABEL_11:
  uint64_t result = CGImageGetComponentType((uint64_t)image);
  if (result)
  {
    uint64_t result = CGPixelComponentMax(result, *(_DWORD *)(a1 + 100), v10, v11, v12, v13, v14, v15);
    *(_DWORD *)(a1 + 100) = result;
  }
  return result;
}

int *shape_union(uint64_t a1, int *a2, int *a3)
{
  if (!a2) {
    return 0;
  }
  BOOL v3 = a2;
  if (*a2 != 0x80000000) {
    return 0;
  }
  unint64_t v4 = a3;
  if (!a3) {
    return 0;
  }
  uint64_t v5 = a2[1];
  if ((int)v5 < 1) {
    return 0;
  }
  if (*a3 != 0x80000000) {
    return 0;
  }
  uint64_t v6 = a3[1];
  if ((int)v6 < 1) {
    return 0;
  }
  if (a2[v5] == 0x7FFFFFFF)
  {
    BOOL v7 = a3;
LABEL_11:
    return shape_copy(v7);
  }
  if (a3[v6] == 0x7FFFFFFF)
  {
    BOOL v7 = a2;
    goto LABEL_11;
  }
  CGFloat v9 = (char *)malloc_type_malloc(0x800uLL, 0x705560E0uLL);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  uint64_t v11 = 0;
  uint64_t v43 = 0;
  long long v44 = 0;
  uint64_t v12 = 512;
  uint64_t v13 = v9;
  while (1)
  {
    uint64_t v14 = v4;
    if (*v3 == 0x7FFFFFFF && *v4 == 0x7FFFFFFF) {
      break;
    }
    if (((v10 - v13) >> 2) + 4 <= v12)
    {
      CFDataRef v46 = v11;
    }
    else
    {
      uint64_t v15 = 2 * v12;
      double v16 = (char *)malloc_type_realloc(v13, (8 * v12 + 511) & 0xFFFFFFFFFFFFFE00, 0x7492344AuLL);
      double v17 = (_DWORD *)((char *)v11 + v16 - v13);
      if (!v11) {
        double v17 = 0;
      }
      if (v16 != v13)
      {
        v10 += v16 - v13;
        uint64_t v11 = v17;
      }
      CFDataRef v46 = v11;
      if (v16 != v13) {
        uint64_t v13 = v16;
      }
      uint64_t v12 = v15;
    }
    if (!v13) {
      return 0;
    }
    int v18 = *v3;
    int v19 = *v14;
    if (*v14 < *v3)
    {
      double v20 = v3;
      BOOL v3 = v44;
LABEL_36:
      *(_DWORD *)uint64_t v10 = v19;
      unint64_t v4 = &v14[v14[1]];
      double v21 = v3;
      BOOL v3 = v20;
      goto LABEL_37;
    }
    if (v18 == 0x7FFFFFFF)
    {
      double v20 = v3;
      BOOL v3 = v44;
    }
    else
    {
      *(_DWORD *)uint64_t v10 = v18;
      double v20 = &v3[v3[1]];
    }
    if (v18 >= v19)
    {
      int v19 = *v14;
      if (*v14 != 0x7FFFFFFF) {
        goto LABEL_36;
      }
    }
    double v21 = v3;
    BOOL v3 = v20;
    unint64_t v4 = v14;
    uint64_t v14 = v43;
LABEL_37:
    uint64_t v43 = v14;
    long long v44 = v21;
    long long v22 = v21 + 2;
    float64x2_t v23 = v14 + 2;
    long long v45 = v10 + 4;
    v10 += 8;
    BOOL v24 = v14 + 2 != v4;
    BOOL v25 = v21 + 2 != v3;
    if (v21 + 2 != v3 || v23 != v4)
    {
      uint64_t v26 = 0;
      while (1)
      {
        if (((v10 - v13) >> 2) + 4 > v12)
        {
          uint64_t v27 = 2 * v12;
          uint64_t v28 = (char *)malloc_type_realloc(v13, (8 * v12 + 511) & 0xFFFFFFFFFFFFFE00, 0x7492344AuLL);
          int64_t v29 = v28 - v13;
          if (v28 == v13)
          {
            uint64_t v12 = v27;
          }
          else
          {
            double v30 = (_DWORD *)((char *)v46 + v29);
            if (!v46) {
              double v30 = 0;
            }
            CFDataRef v46 = v30;
            if (!v28) {
              return 0;
            }
            v10 += v29;
            v45 += v29;
            uint64_t v12 = v27;
            uint64_t v13 = v28;
          }
        }
        int v31 = *v22;
        int v32 = *v23;
        BOOL v33 = v23 == v4 || v31 <= v32;
        if (!v33 || !v25)
        {
          uint64_t v34 = v26;
          double v35 = v22;
        }
        else
        {
          uint64_t v34 = v26 ^ 1;
          *(_DWORD *)uint64_t v10 = v31;
          double v35 = v22 + 1;
          int v31 = *v22;
          int v32 = *v23;
        }
        BOOL v36 = v32 <= v31 || v22 == v3;
        if (v36 && v24)
        {
          uint64_t v34 = v34 ^ 2;
          ++v23;
          *(_DWORD *)uint64_t v10 = v32;
        }
        if (v26) {
          BOOL v37 = v34 == 0;
        }
        else {
          BOOL v37 = 1;
        }
        unsigned int v38 = v37;
        v10 += 4 * v38;
        BOOL v24 = v23 != v4;
        long long v22 = v35;
        uint64_t v26 = v34;
        BOOL v25 = v35 != v3;
        if (v35 == v3)
        {
          long long v22 = v35;
          uint64_t v26 = v34;
          if (v23 == v4) {
            break;
          }
        }
      }
    }
    uint64_t v11 = v46;
    int v39 = ((unint64_t)(v10 - v45) >> 2) + 1;
    *(_DWORD *)long long v45 = v39;
    if (v46 && v39 == *v46)
    {
      if (((unint64_t)(v10 - v45) >> 2) != 1)
      {
        uint64_t v40 = 1;
        while (&v45[v40 * 4] != v10)
        {
          int v41 = v46[v40];
          int v42 = *(_DWORD *)&v45[v40 * 4];
          ++v40;
          if (v41 != v42) {
            goto LABEL_77;
          }
        }
      }
      uint64_t v10 = v45 - 4;
      int v39 = ((unint64_t)(v45 - 4 - (char *)v46) >> 2) + 1;
    }
    else
    {
LABEL_77:
      uint64_t v11 = v45;
    }
    *uint64_t v11 = v39;
  }
  *(_DWORD *)uint64_t v10 = 0x7FFFFFFF;

  return final_check((int *)v13, v12, ((v10 - v13) >> 2) + 1);
}

int *final_check(int *result, uint64_t a2, uint64_t a3)
{
  if (result == (int *)&the_empty_shape) {
    return (int *)&the_empty_shape;
  }
  if (result[result[1]] == 0x7FFFFFFF)
  {
    if (result) {
      free(result);
    }
    return (int *)&the_empty_shape;
  }
  else if ((unint64_t)(a2 - a3) >= 0x400)
  {
    return (int *)malloc_type_realloc(result, (4 * a3 + 511) & 0xFFFFFFFFFFFFFE00, 0x7492344AuLL);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceDisplayList *,std::shared_ptr<CG::DisplayListResourceDisplayList>::__shared_ptr_default_delete<CG::DisplayListResourceDisplayList,CG::DisplayListResourceDisplayList>,std::allocator<CG::DisplayListResourceDisplayList>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceDisplayList::~DisplayListResourceDisplayList(CG::DisplayListResourceDisplayList *this)
{
  CG::DisplayListResourceDisplayList::~DisplayListResourceDisplayList(this);

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094E88;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

void CG::DisplayListEntryDisplayList::~DisplayListEntryDisplayList(CG::DisplayListEntryDisplayList *this)
{
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceShading *,std::shared_ptr<CG::DisplayListResourceShading>::__shared_ptr_default_delete<CG::DisplayListResourceShading,CG::DisplayListResourceShading>,std::allocator<CG::DisplayListResourceShading>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceShading::~DisplayListResourceShading(CG::DisplayListResourceShading *this)
{
  CG::DisplayListResourceShading::~DisplayListResourceShading(this);

  JUMPOUT(0x18532A2A0);
}

{
  const void *v2;
  const void *v3;

  *(void *)this = &unk_1ED094C90;
  BOOL v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  BOOL v3 = (const void *)*((void *)this + 3);
  if (v3) {
    CFRelease(v3);
  }
}

void CG::DisplayListEntryShading::~DisplayListEntryShading(CG::DisplayListEntryShading *this)
{
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceSoftMask *,std::shared_ptr<CG::DisplayListResourceSoftMask>::__shared_ptr_default_delete<CG::DisplayListResourceSoftMask,CG::DisplayListResourceSoftMask>,std::allocator<CG::DisplayListResourceSoftMask>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceSoftMask::~DisplayListResourceSoftMask(CG::DisplayListResourceSoftMask *this)
{
  *(void *)this = &unk_1ED094DA8;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094DA8;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListEntryStateStroke *,std::shared_ptr<CG::DisplayListEntryStateStroke const>::__shared_ptr_default_delete<CG::DisplayListEntryStateStroke const,CG::DisplayListEntryStateStroke>,std::allocator<CG::DisplayListEntryStateStroke>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListEntryStateStroke::~DisplayListEntryStateStroke(CG::DisplayListEntryStateStroke *this)
{
}

CGColorRef CGColorCreateGenericGrayGamma2_2(CGFloat gray, CGFloat alpha)
{
  CGFloat components[2] = *(CGFloat *)MEMORY[0x1E4F143B8];
  components[0] = gray;
  components[1] = alpha;
  BOOL v2 = CGColorSpaceCreateWithName(@"kCGColorSpaceGenericGrayGamma2_2");
  BOOL v3 = CGColorCreate(v2, components);
  CGColorSpaceRelease(v2);
  if (!v3) {
    CGPostError((uint64_t)"Color creation failed for gray 2.2 colorspace %p, {%f, %f}", v4, v5, v6, v7, v8, v9, v10, (char)v2);
  }
  return v3;
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListEntryStatePattern *,std::shared_ptr<CG::DisplayListEntryStatePattern const>::__shared_ptr_default_delete<CG::DisplayListEntryStatePattern const,CG::DisplayListEntryStatePattern>,std::allocator<CG::DisplayListEntryStatePattern>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceStyle *,std::shared_ptr<CG::DisplayListResourceStyle>::__shared_ptr_default_delete<CG::DisplayListResourceStyle,CG::DisplayListResourceStyle>,std::allocator<CG::DisplayListResourceStyle>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListEntryStatePattern::~DisplayListEntryStatePattern(CG::DisplayListEntryStatePattern *this)
{
}

void CG::DisplayListResourceStyle::~DisplayListResourceStyle(CG::DisplayListResourceStyle *this)
{
  *(void *)this = &unk_1ED094BE0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094BE0;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t std::__shared_ptr_pointer<CG::DisplayListResourceGradient *,std::shared_ptr<CG::DisplayListResourceGradient>::__shared_ptr_default_delete<CG::DisplayListResourceGradient,CG::DisplayListResourceGradient>,std::allocator<CG::DisplayListResourceGradient>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void CG::DisplayListResourceGradient::~DisplayListResourceGradient(CG::DisplayListResourceGradient *this)
{
  *(void *)this = &unk_1ED094D78;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x18532A2A0);
}

{
  const void *v1;

  *(void *)this = &unk_1ED094D78;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

void CG::DisplayListEntryGradient::~DisplayListEntryGradient(CG::DisplayListEntryGradient *this)
{
}

__CFDictionary *CGFontCreateFontsWithURL(const __CFURL *a1)
{
  if (!a1) {
    return 0;
  }
  CFURLRef v1 = CFURLCopyAbsoluteURL(a1);
  if (!v1) {
    return 0;
  }
  CFURLRef v2 = v1;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    long long v22 = 0;
    goto LABEL_17;
  }
  uint64_t v4 = Mutable;
  CFStringRef v5 = CFURLCopyScheme(v2);
  if (!v5)
  {
    float64x2_t v23 = "scheme";
LABEL_12:
    CGPostError((uint64_t)"missing or invalid %s.", v6, v7, v8, v9, v10, v11, v12, (char)v23);
LABEL_15:
    CFIndex Count = 0;
    long long v22 = v4;
LABEL_16:
    CFRelease(v22);
    long long v22 = Count;
    goto LABEL_17;
  }
  CFStringRef v13 = v5;
  if (!CFEqual(v5, @"file"))
  {
    double v21 = "scheme";
    goto LABEL_14;
  }
  CFRelease(v13);
  CFStringRef v20 = CFURLCopyFragment(v2, &stru_1ED0A02B0);
  if (v20)
  {
    CFStringRef v13 = v20;
    if (!expand_parameters(v4, v20))
    {
      double v21 = "fragment string";
LABEL_14:
      url_error((char)v21, v13, v14, v15, v16, v17, v18, v19);
      CFRelease(v13);
      goto LABEL_15;
    }
  }
  else
  {
    CFStringRef v26 = CFURLCopyParameterString(v2, &stru_1ED0A02B0);
    if (!v26) {
      goto LABEL_22;
    }
    CFStringRef v13 = v26;
    CGPostError((uint64_t)"font parameters must be specified as URI fragments.", v27, v28, v29, v30, v31, v32, v33, v67);
    if (!expand_parameters(v4, v13))
    {
      double v21 = "parameter string";
      goto LABEL_14;
    }
  }
  CFRelease(v13);
LABEL_22:
  CFStringRef v34 = CFURLCopyFileSystemPath(v2, kCFURLPOSIXPathStyle);
  if (!v34)
  {
    float64x2_t v23 = "path";
    goto LABEL_12;
  }
  CFStringRef v35 = v34;
  CFDictionarySetValue(v4, @"path", v34);
  CFRelease(v35);
  CFRelease(v2);
  CFArrayRef Value = CFDictionaryGetValue(v4, @"path");
  BOOL v37 = CFDictionaryGetValue(v4, @"postscript-name");
  long long v44 = (__CFDictionary *)CGFontCreateWithPathAndName((uint64_t)Value, (uint64_t)v37, v38, v39, v40, v41, v42, v43);
  if (v44)
  {
    long long v22 = v44;
    uint64_t v52 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(v52, v22);
    goto LABEL_25;
  }
  FontsWithPath = CGFontCreateFontsWithPath((uint64_t)Value, v45, v46, v47, v48, v49, v50, v51);
  long long v22 = FontsWithPath;
  if (!FontsWithPath) {
    goto LABEL_47;
  }
  if (!CFArrayGetCount(FontsWithPath))
  {
LABEL_45:
    CFIndex Count = 0;
    goto LABEL_46;
  }
  if (!v37) {
    goto LABEL_26;
  }
  CFIndex Count = (__CFArray *)CFArrayGetCount(v22);
  if (!Count)
  {
LABEL_46:
    CFURLRef v2 = v4;
    goto LABEL_16;
  }
  CFIndex v62 = 0;
  while (1)
  {
    ValueAtIndedouble x = CFArrayGetValueAtIndex(v22, v62);
    if (!ValueAtIndex) {
      goto LABEL_44;
    }
    CFDataRef v64 = ValueAtIndex;
    BOOL v65 = (const void *)(*(uint64_t (**)(void))(*((void *)ValueAtIndex + 2) + 152))(*((void *)ValueAtIndex + 14));
    if (!v65) {
      goto LABEL_44;
    }
    uint64_t v66 = v65;
    if (CFEqual(v37, v65)) {
      break;
    }
    CFRelease(v66);
LABEL_44:
    if (Count == (__CFArray *)++v62) {
      goto LABEL_45;
    }
  }
  uint64_t v52 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue(v52, v64);
  CFRelease(v66);
LABEL_25:
  CFRelease(v22);
  long long v22 = v52;
  if (v52)
  {
LABEL_26:
    CFDictionaryRef v53 = (const __CFDictionary *)CFDictionaryGetValue(v4, @"variations");
    if (v53)
    {
      CFDictionaryRef v54 = v53;
      CFIndex Count = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
      if (Count)
      {
        CFIndex v55 = CFArrayGetCount(v22);
        if (v55)
        {
          CFIndex v56 = v55;
          for (CFIndex i = 0; i != v56; ++i)
          {
            uint64_t v58 = (CGFont *)CFArrayGetValueAtIndex(v22, i);
            CGFontRef CopyWithVariations = CGFontCreateCopyWithVariations(v58, v54);
            if (CopyWithVariations)
            {
              CGFontRef v60 = CopyWithVariations;
              CFArrayAppendValue(Count, CopyWithVariations);
              CFRelease(v60);
            }
          }
        }
      }
      goto LABEL_46;
    }
  }
LABEL_47:
  CFURLRef v2 = v4;
LABEL_17:
  CFRelease(v2);
  return v22;
}

__CFArray *CGFontCreateFontsWithPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t VTable = CGFontGetVTable(a1, a2, a3, a4, a5, a6, a7, a8);
  CFArrayRef v10 = (const __CFArray *)(*(uint64_t (**)(uint64_t))(VTable + 48))(a1);
  if (!v10) {
    return 0;
  }
  CFArrayRef v11 = v10;
  fonts_with_private_data_arraCGFloat y = create_fonts_with_private_data_array(v10, 0);
  CFRelease(v11);
  return fonts_with_private_data_array;
}

CFArrayRef create_private_data_array_with_path()
{
  CFArrayRef result = (const __CFArray *)FPFontCreateFontsWithPath();
  if (result)
  {
    CFArrayRef v1 = result;
    private_data_array_with_parser_fonts = create_private_data_array_with_parser_fonts(result);
    CFRelease(v1);
    return private_data_array_with_parser_fonts;
  }
  return result;
}

void *CGFontCreateWithDataProviderAndData(uint64_t a1, uint64_t a2)
{
  BOOL v4 = CGIsInLockdownModeForFonts();
  if (v4)
  {
    CGPostError((uint64_t)"Attempt to create CGFont from data in Lockdown Mode for Fonts", v5, v6, v7, v8, v9, v10, v11, v16);
    return 0;
  }
  if (!a1) {
    return 0;
  }
  uint64_t v12 = CGFontCreate(v4, v5, v6, v7, v8, v9, v10, v11);
  CFStringRef v13 = (void *)v12;
  if (v12)
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v12 + 16) + 32))(a1, a2);
    v13[14] = v14;
    if (!v14)
    {
      CFRelease(v13);
      return 0;
    }
  }
  return v13;
}

void *create_private_data_with_data_provider(CGDataProvider *a1)
{
  CFArrayRef result = CGDataProviderCopyData(a1);
  if (result)
  {
    CFURLRef v2 = result;
    uint64_t v3 = FPFontCreateWithDataAndExtra();
    CFRelease(v2);
    if (v3)
    {
      CFArrayRef result = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040D8C947D5uLL);
      *CFArrayRef result = 1;
      result[1] = v3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CGIsInLockdownModeForFonts()
{
  if (sInLockdownModeForFonts) {
    return 1;
  }
  if (read_entitlements_once != -1) {
    dispatch_once(&read_entitlements_once, &__block_literal_global_11367);
  }
  return sHasLockdownModeForFontsEntitlement != 0;
}

CFPropertyListRef CGColorSpaceCopyPropertyList(CGColorSpaceRef space)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if ((CGColorSpaceGetType(space) & 0xFFFFFFFE) == 8) {
    return 0;
  }
  if (!space)
  {
    CFDataRef v2 = CGColorSpaceCopyICCData(0);
    if (v2 || CGColorSpaceGetType(0) != 7) {
      return v2;
    }
    CFPropertyListRef v8 = CGColorSpaceCopyPropertyList(0);
    if (!v8) {
      return 0;
    }
    uint64_t v9 = (void *)v8;
LABEL_33:
    char v17 = -1;
    goto LABEL_34;
  }
  BOOL v4 = *(const void **)(*((void *)space + 3) + 80);
  if (v4)
  {
    CFDataRef v5 = (const __CFData *)CFRetain(v4);
    if (v5)
    {
      CFDataRef v2 = v5;
      if (CFEqual(v5, @"kCGColorSpaceDeviceGray")) {
        return @"kCGColorSpaceGenericGrayGamma2_2";
      }
      if (CFEqual(v2, @"kCGColorSpaceDeviceRGB")) {
        return @"kCGColorSpaceSRGB";
      }
      if (CFEqual(v2, @"kCGColorSpaceDeviceCMYK")) {
        return @"kCGColorSpaceGenericCMYK";
      }
      return v2;
    }
  }
  CFDataRef v6 = CGColorSpaceCopyICCData(space);
  if (v6)
  {
    CFDataRef v2 = v6;
    if (!*(unsigned char *)(*((void *)space + 3) + 13)) {
      return v2;
    }
    if (CGColorSpaceGetType(space) == 6 && *(unsigned char *)(*((void *)space + 3) + 19))
    {
      uint64_t v7 = @"kCGColorSpaceDisplayReferredDerivative";
    }
    else
    {
      if (CGColorSpaceGetType(space) != 6 || !*(unsigned char *)(*((void *)space + 3) + 18))
      {
        uint64_t v7 = 0;
        CFIndex v12 = 2;
        goto LABEL_28;
      }
      uint64_t v7 = @"kCGColorSpaceSceneReferredDerivative";
    }
    CFIndex v12 = 3;
LABEL_28:
    keys[0] = @"kCGColorSpaceICCData";
    keys[1] = @"kCGColorSpaceExtendedRange";
    BOOL v25 = v7;
    CFNumberRef v13 = (const __CFNumber *)*MEMORY[0x1E4F1CFD0];
    values = v2;
    CFNumberRef v22 = v13;
    CFDataRef v23 = v13;
    CFDictionaryRef v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, v12, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v2);
    return v14;
  }
  if (CGColorSpaceGetType(space) != 7) {
    return 0;
  }
  uint64_t v10 = *((void *)space + 3);
  uint64_t v11 = (*(_DWORD *)(v10 + 28) - 5) > 1 ? 0 : **(CGColorSpace ***)(v10 + 96);
  CFPropertyListRef v15 = CGColorSpaceCopyPropertyList(v11);
  if (!v15) {
    return 0;
  }
  uint64_t v9 = (void *)v15;
  uint64_t v16 = *((void *)space + 3);
  if (*(_DWORD *)(v16 + 28) != 5) {
    goto LABEL_33;
  }
  char v17 = *(unsigned char *)(*(void *)(v16 + 96) + 8);
LABEL_34:
  char valuePtr = v17;
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt8Type, &valuePtr);
  CFDataRef v19 = CGColorSpaceCopyColorTable((uint64_t)space);
  *(_OWORD *)keys = xmmword_1E52CEA50;
  BOOL v25 = @"kCGIndexedColorTableKey";
  values = v9;
  CFNumberRef v22 = v18;
  CFDataRef v23 = v19;
  CFDataRef v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (v18) {
    CFRelease(v18);
  }
  if (v19) {
    CFRelease(v19);
  }
  CFRelease(v9);
  return v2;
}

CFDataRef CGColorSpaceCopyICCData(CGColorSpaceRef space)
{
  CFDataRef v8 = 0;
  if (space)
  {
    uint64_t v9 = *((void *)space + 3);
    switch(*(_DWORD *)(v9 + 24))
    {
      case 3:
        CGColorSpaceGetCalibratedGrayData((uint64_t)space, v5, v6, v7, (uint64_t)v13);
        ProfileForCalGraCGFloat y = (const void *)CGCMSUtilsCreateProfileForCalGray((uint64_t)v13);
        if (CGCMSUtilsCreateDataForCalGray_cglibrarypredicate != -1) {
          dispatch_once(&CGCMSUtilsCreateDataForCalGray_cglibrarypredicate, &__block_literal_global_155);
        }
        uint64_t v12 = ((uint64_t (*)(const void *, void))CGCMSUtilsCreateDataForCalGray_f)(ProfileForCalGray, 0);
        goto LABEL_15;
      case 4:
        CGColorSpaceGetCalibratedRGBData((uint64_t)space, v5, v6, v7, (uint64_t)v13);
        ProfileForCalGraCGFloat y = (const void *)CGCMSUtilsCreateProfileForCalRGB((uint64_t)v13);
        if (CGCMSUtilsCreateDataForCalRGB_cglibrarypredicate != -1) {
          dispatch_once(&CGCMSUtilsCreateDataForCalRGB_cglibrarypredicate, &__block_literal_global_143);
        }
        uint64_t v12 = ((uint64_t (*)(const void *, void))CGCMSUtilsCreateDataForCalRGB_f)(ProfileForCalGray, 0);
        goto LABEL_15;
      case 5:
        ProfileForCalGraCGFloat y = (const void *)CGCMSUtilsCreateProfileForCalLab(*(char **)(v9 + 96), *(void *)(v9 + 96) + 24);
        if (CGCMSUtilsCreateDataForCalLab_cglibrarypredicate != -1) {
          dispatch_once(&CGCMSUtilsCreateDataForCalLab_cglibrarypredicate, &__block_literal_global_164);
        }
        uint64_t v12 = ((uint64_t (*)(const void *, void))CGCMSUtilsCreateDataForCalLab_f)(ProfileForCalGray, 0);
LABEL_15:
        CFDataRef v8 = (const __CFData *)v12;
        if (ProfileForCalGray) {
          CFRelease(ProfileForCalGray);
        }
        return v8;
      case 6:
      case 0xA:
      case 0xB:
        return CGColorSpaceICCCopyData((uint64_t)space, v1, v2, v3, v4, v5, v6, v7);
      default:
        return v8;
    }
  }
  return v8;
}

__n128 CGColorSpaceGetCalibratedRGBData@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X5>, uint64_t a3@<X6>, uint64_t a4@<X7>, uint64_t a5@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 24);
  if (*(_DWORD *)(v5 + 24) != 4) {
    _CGHandleAssert("CGColorSpaceGetCalibratedRGBData", 161, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_CalRGB.c", "space->state->type == kCGColorSpaceCalibratedRGB", "Colorspace %p not RGB based. int Type = %d", a2, a3, a4, a1);
  }
  uint64_t v6 = *(void *)(v5 + 96);
  long long v7 = *(_OWORD *)(v6 + 112);
  *(_OWORD *)(a5 + 96) = *(_OWORD *)(v6 + 96);
  *(_OWORD *)(a5 + 112) = v7;
  *(_OWORD *)(a5 + 128) = *(_OWORD *)(v6 + 128);
  long long v8 = *(_OWORD *)(v6 + 48);
  *(_OWORD *)(a5 + 32) = *(_OWORD *)(v6 + 32);
  *(_OWORD *)(a5 + 48) = v8;
  long long v9 = *(_OWORD *)(v6 + 80);
  *(_OWORD *)(a5 + 64) = *(_OWORD *)(v6 + 64);
  *(_OWORD *)(a5 + 80) = v9;
  __n128 result = *(__n128 *)(v6 + 16);
  *(_OWORD *)a5 = *(_OWORD *)v6;
  *(__n128 *)(a5 + 16) = result;
  return result;
}

uint64_t CGCMSUtilsCreateProfileForCalRGB(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  float32x2_t valuePtr = vcvt_f32_f64(*(float64x2_t *)a1);
  float v1 = *(double *)(a1 + 16);
  float v74 = v1;
  float32x2_t v2 = vcvt_f32_f64(*(float64x2_t *)(a1 + 24));
  float v3 = *(double *)(a1 + 40);
  float v72 = v3;
  long long v69 = *(_OWORD *)(a1 + 48);
  uint64_t v70 = *(void *)(a1 + 64);
  float32x2_t v71 = v2;
  float32x4_t v4 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 104)), *(float64x2_t *)(a1 + 120));
  float32x4_t v66 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 72)), *(float64x2_t *)(a1 + 88));
  float32x4_t v67 = v4;
  float v5 = *(double *)(a1 + 136);
  v68[0] = v5;
  long long v63 = xmmword_1E52A0758;
  long long v64 = *(_OWORD *)&off_1E52A0768;
  long long v65 = xmmword_1E52A0778;
  *(_OWORD *)keys = xmmword_1E52A0718;
  long long v60 = *(_OWORD *)&off_1E52A0728;
  long long v61 = xmmword_1E52A0738;
  long long v62 = *(_OWORD *)&off_1E52A0748;
  uint64_t v58 = 0;
  long long v57 = 0u;
  long long v56 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  long long v53 = 0u;
  values = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberFloatType, (char *)&valuePtr + 4);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberFloatType, &v74);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef v35 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  for (uint64_t i = 0; i != 24; i += 8)
  {
    long long v8 = *(void **)((char *)&values + i);
    if (v8) {
      CFRelease(v8);
    }
  }
  values = CFNumberCreate(0, kCFNumberFloatType, &v71);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberFloatType, (char *)&v71 + 4);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberFloatType, &v72);
  CFArrayRef v34 = CFArrayCreate(v6, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  for (uint64_t j = 0; j != 24; j += 8)
  {
    uint64_t v10 = *(void **)((char *)&values + j);
    if (v10) {
      CFRelease(v10);
    }
  }
  values = CFNumberCreate(0, kCFNumberFloatType, &v66);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberFloatType, &v66.i32[1]);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberFloatType, &v66.u32[2]);
  CFArrayRef v33 = CFArrayCreate(v6, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  for (uint64_t k = 0; k != 24; k += 8)
  {
    uint64_t v12 = *(void **)((char *)&values + k);
    if (v12) {
      CFRelease(v12);
    }
  }
  values = CFNumberCreate(0, kCFNumberFloatType, (const void *)((unint64_t)&v66 | 0xC));
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberFloatType, &v67);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberFloatType, &v67.i32[1]);
  CFArrayRef v32 = CFArrayCreate(v6, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  for (uint64_t m = 0; m != 24; m += 8)
  {
    CFDictionaryRef v14 = *(void **)((char *)&values + m);
    if (v14) {
      CFRelease(v14);
    }
  }
  values = CFNumberCreate(0, kCFNumberFloatType, &v67.u32[2]);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberFloatType, (char *)&v67.u64[1] + 4);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberFloatType, v68);
  CFArrayRef v15 = CFArrayCreate(v6, (const void **)&values, 3, MEMORY[0x1E4F1D510]);
  for (uint64_t n = 0; n != 24; n += 8)
  {
    char v17 = *(void **)((char *)&values + n);
    if (v17) {
      CFRelease(v17);
    }
  }
  values = CFNumberCreate(0, kCFNumberSInt16Type, &CGCMSUtilsCreateProfileForCalRGB_iccDate);
  CFNumberRef v51 = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F54A);
  CFNumberRef v52 = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F54C);
  *(void *)&long long v53 = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F54E);
  *((void *)&v53 + 1) = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F550);
  *(void *)&long long v54 = CFNumberCreate(0, kCFNumberSInt16Type, &unk_18519F552);
  CFArrayRef v18 = CFArrayCreate(v6, (const void **)&values, 6, MEMORY[0x1E4F1D510]);
  for (iuint64_t i = 0; ii != 48; ii += 8)
  {
    CFStringRef v20 = *(void **)((char *)&values + ii);
    if (v20) {
      CFRelease(v20);
    }
  }
  uint64_t v21 = 0;
  long long v48 = 0uLL;
  uint64_t v49 = 0;
  CFNumberRef v22 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  do
  {
    uint64_t v23 = *((void *)&v69 + v21);
    __int16 v43 = 0;
    uint64_t v42 = v23;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    long long v46 = 0u;
    long long v47 = 0u;
    *(_OWORD *)long long v44 = 0u;
    long long v45 = 0u;
    v44[0] = CFNumberCreate(0, kCFNumberSInt16Type, &v43);
    v44[1] = CFNumberCreate(0, kCFNumberDoubleType, &v42);
    *(void *)&long long v45 = CFNumberCreate(0, kCFNumberDoubleType, &v41);
    *((void *)&v45 + 1) = CFNumberCreate(0, kCFNumberDoubleType, &v40);
    *(void *)&long long v46 = CFNumberCreate(0, kCFNumberDoubleType, &v39);
    *((void *)&v46 + 1) = CFNumberCreate(0, kCFNumberDoubleType, &v38);
    *(void *)&long long v47 = CFNumberCreate(0, kCFNumberDoubleType, &v37);
    *((void *)&v47 + 1) = CFNumberCreate(0, kCFNumberDoubleType, &v36);
    uint64_t v24 = 0;
    *((void *)&v48 + v21) = CFArrayCreate(0, (const void **)v44, 8, v22);
    do
    {
      BOOL v25 = v44[v24];
      if (v25) {
        CFRelease(v25);
      }
      ++v24;
    }
    while (v24 != 8);
    ++v21;
  }
  while (v21 != 3);
  values = v35;
  CFNumberRef v51 = v34;
  CFNumberRef v52 = v33;
  *(void *)&long long v53 = v32;
  long long v54 = v48;
  *((void *)&v53 + 1) = v15;
  *(void *)&long long v55 = v49;
  *((void *)&v55 + 1) = @"CG Cal RGB";
  *(void *)&long long v56 = @"calRGB";
  uint64_t v26 = *MEMORY[0x1E4F1CFD0];
  *((void *)&v56 + 1) = @"4.0";
  *(void *)&long long v57 = v26;
  *((void *)&v57 + 1) = v18;
  uint64_t v58 = v26;
  CFDictionaryRef v27 = CFDictionaryCreate(v6, (const void **)keys, (const void **)&values, 14, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (juint64_t j = 0; jj != 64; jj += 8)
  {
    uint64_t v29 = *(void **)((char *)&values + jj);
    if (v29) {
      CFRelease(v29);
    }
  }
  if (v18) {
    CFRelease(v18);
  }
  if (CGCMSUtilsCreateProfileForCalRGB_cglibrarypredicate != -1) {
    dispatch_once(&CGCMSUtilsCreateProfileForCalRGB_cglibrarypredicate, &__block_literal_global_140);
  }
  uint64_t ProfileForCalRGB_f = CGCMSUtilsCreateProfileForCalRGB_f(v27);
  if (v27) {
    CFRelease(v27);
  }
  return ProfileForCalRGB_f;
}

CFDataRef CGColorSpaceICCCopyData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  int v9 = *(_DWORD *)(v8 + 24);
  switch(v9)
  {
    case 6:
      CFNumberRef v13 = *(CGDataProvider **)(*(void *)(v8 + 96) + 8);
      break;
    case 10:
      CFNumberRef v13 = **(CGDataProvider ***)(v8 + 96);
      break;
    case 11:
      uint64_t FlexGTCProfile = CGColorSpaceFlexGTCProxyGetFlexGTCProfile(a1);
      if (CGColorSpaceICCCopyData_cglibrarypredicate != -1) {
        dispatch_once(&CGColorSpaceICCCopyData_cglibrarypredicate, &__block_literal_global_54_7558);
      }
      uint64_t v11 = (uint64_t (*)(uint64_t, void))CGColorSpaceICCCopyData_f;
      return (CFDataRef)v11(FlexGTCProfile, 0);
    default:
      _CGHandleAssert("CGColorSpaceICCCopyData", 591, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased || s->state->type == kCGColorSpaceProfileSets || s->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not ICC. type = %d", a6, a7, a8, *(_DWORD *)(v8 + 24));
  }

  return CGDataProviderCopyData(v13);
}

CGColorSpaceRef CGColorSpaceCreateICCBased(size_t nComponents, const CGFloat *range, CGDataProviderRef profile, CGColorSpaceRef alternate)
{
  Retainedouble d = 0;
  if (nComponents <= 4)
  {
    size_t v5 = nComponents;
    if (((1 << nComponents) & 0x1A) != 0)
    {
      if (alternate
        && (CGColorSpaceGetType(alternate) == 9 || *(void *)(*((void *)alternate + 3) + 48) != v5))
      {
        return 0;
      }
      CFDataRef v9 = CGDataProviderCopyData(profile);
      Retainedouble d = (CGColorSpace *)CGColorSpaceFromICCDataCacheGetRetained(v9);
      if (v9) {
        CFRelease(v9);
      }
      if (!Retained || (uint64_t v17 = *((void *)Retained + 3), *(void *)(v17 + 48) != v5))
      {
LABEL_23:
        CGColorSpaceRelease(Retained);
        if (alternate)
        {
          CFRetain(alternate);
          return alternate;
        }
        return 0;
      }
      if (range)
      {
        CFArrayRef v18 = (double *)CGColorSpaceICCGetRange((uint64_t)Retained, v10, v11, v12, v13, v14, v15, v16);
        while (*range == *v18)
        {
          ++v18;
          ++range;
          if (!--v5)
          {
            uint64_t v17 = *((void *)Retained + 3);
            goto LABEL_15;
          }
        }
        goto LABEL_23;
      }
LABEL_15:
      int v19 = *(_DWORD *)(v17 + 24);
      if ((v19 - 10) >= 2 && v19 != 6) {
        _CGHandleAssert("CGColorSpaceICCSetAlternate", 606, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "s->state->type == kCGColorSpaceICCBased || s->state->type == kCGColorSpaceProfileSets || s->state->type == kCGColorSpaceFlexGTCProxy", "Colorspace not ICC. type = %d", v14, v15, v16, *(_DWORD *)(v17 + 24));
      }
      CGColorSpaceRelease(*(CGColorSpaceRef *)(*(void *)(v17 + 96) + 56));
      if (alternate) {
        CFRetain(alternate);
      }
      *(void *)(*(void *)(*((void *)Retained + 3) + 96) + 56) = alternate;
    }
  }
  return Retained;
}

void *CGColorSpaceFromICCDataCacheGetRetained(void *result)
{
  key[2] = *MEMORY[0x1E4F143B8];
  value = 0;
  if (result)
  {
    float v1 = result;
    if (CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate != -1) {
      dispatch_once(&CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate, &__block_literal_global_16731);
    }
    __n128 result = (void *)CGColorSpaceFromICCDataCacheGetRetained_f(v1, 0);
    if (result)
    {
      float32x2_t v2 = result;
      if (CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate_4 != -1) {
        dispatch_once(&CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate_4, &__block_literal_global_7_16732);
      }
      if (!CGColorSpaceFromICCDataCacheGetRetained_f_3(v2, 0, 0)) {
        goto LABEL_40;
      }
      if (CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate_10 != -1) {
        dispatch_once(&CGColorSpaceFromICCDataCacheGetRetained_cglibrarypredicate_10, &__block_literal_global_13_16733);
      }
      key[0] = CGColorSpaceFromICCDataCacheGetRetained_f_9(v2);
      key[1] = v3;
      if (get_cache_predicate_16734 != -1) {
        dispatch_once(&get_cache_predicate_16734, &__block_literal_global_17_16735);
      }
      pthread_mutex_lock((pthread_mutex_t *)get_cache_colorspace_cache);
      if (get_cache_predicate_16734 != -1) {
        dispatch_once(&get_cache_predicate_16734, &__block_literal_global_17_16735);
      }
      if (!cache_get_and_retain(*(cache_t **)(get_cache_colorspace_cache + 64), key, &value)) {
        goto LABEL_26;
      }
      CFTypeID v4 = CFGetTypeID(v1);
      if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
        dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
      }
      if (v4 == CGDataProviderGetTypeID_id)
      {
        size_t v5 = CGDataProviderCopyData((CGDataProviderRef)v1);
      }
      else
      {
        CFTypeID v6 = CFGetTypeID(v1);
        if (v6 != CFDataGetTypeID()) {
          goto LABEL_34;
        }
        size_t v5 = (void *)CFRetain(v1);
      }
      long long v7 = v5;
      if (v5)
      {
        uint64_t v8 = (void *)colorspace_with_name_from_icc_data((uint64_t)v5, 0);
        if (v8)
        {
LABEL_23:
          CFRelease(v7);
          value = v8;
          if (get_cache_predicate_16734 != -1) {
            dispatch_once(&get_cache_predicate_16734, &__block_literal_global_17_16735);
          }
          cache_set_and_retain(*(cache_t **)(get_cache_colorspace_cache + 64), key, value, 0);
LABEL_26:
          if (value) {
            CFRetain(value);
          }
          goto LABEL_35;
        }
        icc_with_datdouble a = (atomic_uint *)color_space_state_create_icc_with_data((const __CFData *)v7);
        if (icc_with_data)
        {
          uint64_t v17 = icc_with_data;
          uint64_t v8 = (void *)CGColorSpaceCreateWithState(icc_with_data, v10, v11, v12, v13, v14, v15, v16);
          if (atomic_fetch_add_explicit(v17, 0xFFFFFFFF, memory_order_relaxed) == 1) {
            color_space_state_dealloc((uint64_t)v17);
          }
          MatchingSingletouint64_t n = CGColorSpaceFindMatchingSingleton((uint64_t)v8);
          if (MatchingSingleton)
          {
            int v19 = (void *)MatchingSingleton;
            CGColorSpaceRelease((CGColorSpaceRef)v8);
            uint64_t v8 = v19;
          }
          else
          {
            if (CGColorSpaceCreateWithICCDataInternal_cglibrarypredicate != -1) {
              dispatch_once(&CGColorSpaceCreateWithICCDataInternal_cglibrarypredicate, &__block_literal_global_45);
            }
            if ((CGColorSpaceCreateWithICCDataInternal_f() & 1) == 0) {
              v8[3] = color_space_state_register((unsigned char *)v8[3]);
            }
          }
          goto LABEL_23;
        }
        CFRelease(v7);
      }
LABEL_34:
      value = 0;
LABEL_35:
      if (get_cache_predicate_16734 != -1) {
        dispatch_once(&get_cache_predicate_16734, &__block_literal_global_17_16735);
      }
      cache_release_value(*(cache_t **)(get_cache_colorspace_cache + 64), value);
      if (get_cache_predicate_16734 != -1) {
        dispatch_once(&get_cache_predicate_16734, &__block_literal_global_17_16735);
      }
      pthread_mutex_unlock((pthread_mutex_t *)get_cache_colorspace_cache);
LABEL_40:
      CFRelease(v2);
      return value;
    }
  }
  return result;
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  if (!provider) {
    return 0;
  }
  uint64_t v2 = CGDataProviderRetainBytePtr((uint64_t)provider);
  if (v2)
  {
    uint64_t v3 = (const UInt8 *)v2;
    CGDataProviderRetainBytePtr((uint64_t)provider);
    v23.versiouint64_t n = 0;
    memset(&v23.retain, 0, 40);
    v23.float64x2_t info = provider;
    v23.deallocate = (CFAllocatorDeallocateCallBack)provider_allocator_deallocate;
    v23.preferredSize = 0;
    CFAllocatorRef v4 = CFAllocatorCreate(0, &v23);
    CFDataRef Mutable = CFDataCreateWithBytesNoCopy(0, v3, *((void *)provider + 4), v4);
    CGDataProviderReleaseBytePtr((uint64_t)provider);
    CFRelease(v4);
    return Mutable;
  }
  CFTypeID v6 = CGAccessSessionCreate(provider);
  CGDataProviderReleaseBytePtr((uint64_t)provider);
  if (!v6) {
    return 0;
  }
  if (*v6)
  {
    uint64_t v7 = *(void *)(*v6 + 32);
    unint64_t v8 = v7;
    if (v7 != -1) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v7 = -1;
  }
  unint64_t v8 = 0x10000;
LABEL_10:
  CFDataRef Mutable = CFDataCreateMutable(0, 0);
  if ((CGCFDataIncreaseLength(Mutable, v8) & 1) == 0)
  {
LABEL_35:
    CGAccessSessionRelease(v6);
    CFRelease(Mutable);
    return 0;
  }
  MutableBytePtr = (char *)CFDataGetMutableBytePtr(Mutable);
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  while (1)
  {
    unint64_t Bytes = CGAccessSessionGetBytes(v6, MutableBytePtr, v8, v10, v11, v12, v13, v14);
    if (!Bytes) {
      break;
    }
    uint64_t v18 = Bytes;
    if ((v8 & 0x8000000000000000) == 0 && v8 > Bytes)
    {
      v24.locatiouint64_t n = CFDataGetLength(Mutable) - (v8 - Bytes);
      v24.uint64_t length = v8 - v18;
      CFDataDeleteBytes(Mutable, v24);
      v16 += v18;
LABEL_19:
      if (v8 == v18 && v15 <= v8) {
        uint64_t v18 = 2 * v8;
      }
      goto LABEL_24;
    }
    if ((v7 & 0x8000000000000000) == 0 && Bytes == v7) {
      goto LABEL_42;
    }
    v16 += Bytes;
    if ((v8 & 0x8000000000000000) == 0) {
      goto LABEL_19;
    }
LABEL_24:
    if (v18 >= 0x4000000) {
      uint64_t v20 = 0x4000000;
    }
    else {
      uint64_t v20 = v18;
    }
    if (v20 <= 0x4000) {
      unint64_t v8 = 0x4000;
    }
    else {
      unint64_t v8 = v20;
    }
    if ((CGCFDataIncreaseLength(Mutable, v8) & 1) == 0) {
      goto LABEL_35;
    }
    uint64_t v21 = CFDataGetMutableBytePtr(Mutable);
    if (v21)
    {
      MutableBytePtr = (char *)&v21[v16];
    }
    else
    {
      CFRelease(Mutable);
      CFDataRef Mutable = 0;
      MutableBytePtr = 0;
    }
    unint64_t v15 = v8;
  }
  if (CGAccessSessionHasError((CFTypeRef *)v6) || v16 < 1)
  {
    CFRelease(Mutable);
    CFDataRef Mutable = 0;
  }
  else
  {
    v25.locatiouint64_t n = CFDataGetLength(Mutable) - v8;
    v25.uint64_t length = v8;
    CFDataDeleteBytes(Mutable, v25);
  }
LABEL_42:
  CGAccessSessionRelease(v6);
  return Mutable;
}

uint64_t CGAccessSessionGetBytes(uint64_t *a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*a1) {
    _CGHandleAssert("CGDataProviderGetType", 212, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "provider != NULL", "provider is NULL", a6, a7, a8, vars0);
  }
  switch(*(_DWORD *)(*a1 + 20))
  {
    case 0:
    case 2:
      uint64_t result = get_chunks_direct(a1, a3, 0, 1, a2, 0);
      break;
    case 1:
    case 3:
      uint64_t result = get_chunks_sequential(a1, a3, 0, 1, (uint64_t)a2, 0);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t colorspace_with_name_from_icc_data(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = 0;
  }
  else
  {
    if (colorspace_with_name_from_icc_data_cglibrarypredicate != -1) {
      dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate, &__block_literal_global_77_7476);
    }
    uint64_t v2 = colorspace_with_name_from_icc_data_f(a1, 0);
    uint64_t v3 = (const void *)v2;
    if (!v2) {
      return v2;
    }
  }
  if (colorspace_with_name_from_icc_data_cglibrarypredicate_79 != -1) {
    dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_79, &__block_literal_global_82);
  }
  if ((colorspace_with_name_from_icc_data_f_78(v2, @"hdgm") & 1) == 0)
  {
    if (colorspace_with_name_from_icc_data_cglibrarypredicate_84 != -1) {
      dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_84, &__block_literal_global_87);
    }
    if (colorspace_with_name_from_icc_data_f_83(v2))
    {
      CFStringRef v6 = @"kCGColorSpaceGenericGrayGamma2_2";
    }
    else
    {
      if (colorspace_with_name_from_icc_data_cglibrarypredicate_90 != -1) {
        dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_90, &__block_literal_global_93);
      }
      if (colorspace_with_name_from_icc_data_f_89(v2))
      {
        CFStringRef v6 = @"kCGColorSpaceDisplayP3";
      }
      else
      {
        if (colorspace_with_name_from_icc_data_cglibrarypredicate_96 != -1) {
          dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_96, &__block_literal_global_99);
        }
        if (colorspace_with_name_from_icc_data_f_95(v2))
        {
          CFStringRef v6 = @"kCGColorSpaceSRGB";
        }
        else
        {
          if (colorspace_with_name_from_icc_data_cglibrarypredicate_102 != -1) {
            dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_102, &__block_literal_global_105_7477);
          }
          if (colorspace_with_name_from_icc_data_f_101(v2))
          {
            CFStringRef v6 = @"kCGColorSpaceAdobeRGB1998";
          }
          else
          {
            if (colorspace_with_name_from_icc_data_cglibrarypredicate_108 != -1) {
              dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_108, &__block_literal_global_111_7478);
            }
            if (colorspace_with_name_from_icc_data_f_107(v2))
            {
              CFStringRef v6 = @"kCGColorSpaceGenericLab";
            }
            else
            {
              if (colorspace_with_name_from_icc_data_cglibrarypredicate_114 != -1) {
                dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_114, &__block_literal_global_117_7479);
              }
              if (colorspace_with_name_from_icc_data_f_113(v2))
              {
                uint64_t v7 = CGColorSpaceCoreMedia709();
LABEL_33:
                uint64_t v2 = v7;
                if (!v3) {
                  return v2;
                }
                goto LABEL_10;
              }
              if (colorspace_with_name_from_icc_data_cglibrarypredicate_120 != -1) {
                dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_120, &__block_literal_global_123);
              }
              if (colorspace_with_name_from_icc_data_f_119(v2))
              {
                CFStringRef v6 = @"kCGColorSpaceDisplayP3_709OETF";
              }
              else
              {
                if (colorspace_with_name_from_icc_data_cglibrarypredicate_126 != -1) {
                  dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_126, &__block_literal_global_129_7480);
                }
                if (colorspace_with_name_from_icc_data_cglibrarypredicate_131 == -1)
                {
                  int v8 = ((uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_125)(colorspace_with_name_from_icc_data_s, v2);
                }
                else
                {
                  uint64_t v17 = (uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_125;
                  dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_131, &__block_literal_global_134_7481);
                  int v8 = v17(colorspace_with_name_from_icc_data_s, v2);
                }
                if (v8) {
                  goto LABEL_53;
                }
                if (colorspace_with_name_from_icc_data_cglibrarypredicate_137 != -1) {
                  dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_137, &__block_literal_global_140_7482);
                }
                if (colorspace_with_name_from_icc_data_cglibrarypredicate_142 == -1)
                {
                  int v9 = ((uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_136)(colorspace_with_name_from_icc_data_s_141, v2);
                }
                else
                {
                  uint64_t v18 = (uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_136;
                  dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_142, &__block_literal_global_145_7483);
                  int v9 = v18(colorspace_with_name_from_icc_data_s_141, v2);
                }
                if (v9)
                {
LABEL_53:
                  CFStringRef v6 = @"kCGColorSpaceITUR_2100_HLG";
                }
                else
                {
                  if (colorspace_with_name_from_icc_data_cglibrarypredicate_148 != -1) {
                    dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_148, &__block_literal_global_151_7484);
                  }
                  if (colorspace_with_name_from_icc_data_cglibrarypredicate_153 == -1)
                  {
                    int v10 = ((uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_147)(colorspace_with_name_from_icc_data_s_152, v2);
                  }
                  else
                  {
                    int v19 = (uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_147;
                    dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_153, &__block_literal_global_156);
                    int v10 = v19(colorspace_with_name_from_icc_data_s_152, v2);
                  }
                  if (v10)
                  {
                    CFStringRef v6 = @"kCGColorSpaceDisplayP3_HLG";
                  }
                  else
                  {
                    if (colorspace_with_name_from_icc_data_cglibrarypredicate_159 != -1) {
                      dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_159, &__block_literal_global_162_7485);
                    }
                    if (colorspace_with_name_from_icc_data_cglibrarypredicate_164 == -1)
                    {
                      int v11 = ((uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_158)(colorspace_with_name_from_icc_data_s_163, v2);
                    }
                    else
                    {
                      uint64_t v20 = (uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_158;
                      dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_164, &__block_literal_global_167_7486);
                      int v11 = v20(colorspace_with_name_from_icc_data_s_163, v2);
                    }
                    if (v11)
                    {
                      CFStringRef v6 = @"kCGColorSpaceDisplayP3_PQ";
                    }
                    else
                    {
                      if (colorspace_with_name_from_icc_data_cglibrarypredicate_170 != -1) {
                        dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_170, &__block_literal_global_173_7487);
                      }
                      if (colorspace_with_name_from_icc_data_cglibrarypredicate_175 == -1)
                      {
                        int v12 = ((uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_169)(colorspace_with_name_from_icc_data_s_174, v2);
                      }
                      else
                      {
                        uint64_t v21 = (uint64_t (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_169;
                        dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_175, &__block_literal_global_178_7488);
                        int v12 = v21(colorspace_with_name_from_icc_data_s_174, v2);
                      }
                      if (v12) {
                        goto LABEL_76;
                      }
                      if (colorspace_with_name_from_icc_data_cglibrarypredicate_181 != -1) {
                        dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_181, &__block_literal_global_184_7489);
                      }
                      uint64_t v13 = (unsigned int (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_180;
                      if (colorspace_with_name_from_icc_data_cglibrarypredicate_186 != -1) {
                        dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_186, &__block_literal_global_189_7490);
                      }
                      if (v13(colorspace_with_name_from_icc_data_s_185, v2))
                      {
LABEL_76:
                        CFStringRef v6 = @"kCGColorSpaceITUR_2100_PQ";
                      }
                      else
                      {
                        if (colorspace_with_name_from_icc_data_cglibrarypredicate_192 != -1) {
                          dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_192, &__block_literal_global_195_7491);
                        }
                        uint64_t v14 = (unsigned int (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_191;
                        if (colorspace_with_name_from_icc_data_cglibrarypredicate_197 != -1) {
                          dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_197, &__block_literal_global_200);
                        }
                        if (v14(colorspace_with_name_from_icc_data_s_196, v2))
                        {
                          CFStringRef v6 = @"kCGColorSpaceITUR_709_PQ";
                        }
                        else
                        {
                          if (colorspace_with_name_from_icc_data_cglibrarypredicate_203 != -1) {
                            dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_203, &__block_literal_global_206);
                          }
                          unint64_t v15 = (unsigned int (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_202;
                          if (colorspace_with_name_from_icc_data_cglibrarypredicate_208 != -1) {
                            dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_208, &__block_literal_global_211_7492);
                          }
                          if (v15(colorspace_with_name_from_icc_data_s_207, v2))
                          {
                            CFStringRef v6 = @"kCGColorSpaceITUR_709_HLG";
                          }
                          else
                          {
                            if (colorspace_with_name_from_icc_data_cglibrarypredicate_214 != -1) {
                              dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_214, &__block_literal_global_217_7493);
                            }
                            uint64_t v16 = (unsigned int (*)(uint64_t, uint64_t))colorspace_with_name_from_icc_data_f_213;
                            if (colorspace_with_name_from_icc_data_cglibrarypredicate_219 != -1) {
                              dispatch_once(&colorspace_with_name_from_icc_data_cglibrarypredicate_219, &__block_literal_global_222_7494);
                            }
                            if (!v16(colorspace_with_name_from_icc_data_s_218, v2)) {
                              goto LABEL_9;
                            }
                            CFStringRef v6 = @"kCGColorSpaceITUR_2020_sRGBGamma";
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v7 = (uint64_t)CGColorSpaceCreateWithName(v6);
    goto LABEL_33;
  }
LABEL_9:
  uint64_t v2 = 0;
  if (v3) {
LABEL_10:
  }
    CFRelease(v3);
  return v2;
}

uint64_t CGCFDataIncreaseLength(__CFData *a1, CFIndex a2)
{
  return 1;
}

void sub_184C3D28C(void *a1)
{
}

void *color_space_state_create_icc_with_data(const __CFData *a1)
{
  __src[37] = *MEMORY[0x1E4F143B8];
  memset(__src, 0, 296);
  LODWORD(__src[0]) = -1;
  if (color_space_state_create_icc_with_data_cglibrarypredicate != -1) {
    dispatch_once(&color_space_state_create_icc_with_data_cglibrarypredicate, &__block_literal_global_20_7453);
  }
  icc_with_data_f = (void *)color_space_state_create_icc_with_data_f(a1, 0);
  if (color_space_state_create_icc_with_data_cglibrarypredicate_23 != -1) {
    dispatch_once(&color_space_state_create_icc_with_data_cglibrarypredicate_23, &__block_literal_global_26);
  }
  if (color_space_state_create_icc_with_data_f_22(icc_with_data_f, 0, 0))
  {
    if (color_space_state_create_icc_with_data_cglibrarypredicate_29 != -1) {
      dispatch_once(&color_space_state_create_icc_with_data_cglibrarypredicate_29, &__block_literal_global_32_7454);
    }
    uint64_t icc_with_data_f_28 = color_space_state_create_icc_with_data_f_28(icc_with_data_f);
    if (icc_with_data_f_28)
    {
      int v9 = (void *)icc_with_data_f_28;
      CFArrayRef ProfileSet = CGCMSUtilsCreateProfileSet(0, icc_with_data_f, @"ColorSyncTransformDeviceToPCS", 0, 0, 0);
      CFArrayRef v11 = CGCMSUtilsCreateProfileSet(0, v9, @"ColorSyncTransformPCSToPCS", 0, 0, 0);
      uint64_t v12 = color_space_state_create_with_profile_sets((unint64_t)ProfileSet, (unint64_t)v11);
      icdouble c = (void *)v12;
      if (v12) {
        *(_WORD *)(v12 + 14) = 1;
      }
      CFRelease(v9);
      if (ProfileSet) {
        CFRelease(ProfileSet);
      }
      if (v11) {
        CFRelease(v11);
      }
    }
    else
    {
      CGCMSUtilsGetICCProfileInfo(icc_with_data_f, (uint64_t)__src, 0, v4, v5, v6, v7, v8);
      memcpy(__dst, __src, sizeof(__dst));
      icdouble c = color_space_state_create_icc(icc_with_data_f, a1, __dst);
    }
    CFRelease(icc_with_data_f);
  }
  else
  {
    if (icc_with_data_f) {
      CFRelease(icc_with_data_f);
    }
    return 0;
  }
  return icc;
}

uint64_t CGColorSpaceFindMatchingSingleton(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void *)(*(void *)(a1 + 24) + 48);
  if (v2 == 4)
  {
    if (CGColorSpaceFindMatchingSingleton_predicate_177 != -1) {
      dispatch_once(&CGColorSpaceFindMatchingSingleton_predicate_177, &__block_literal_global_180_6519);
    }
    uint64_t v4 = CGColorSpaceFindMatchingSingleton_spaces_176_0;
    if (!CGColorSpaceEqualToColorSpace(a1, CGColorSpaceFindMatchingSingleton_spaces_176_0)) {
      return 0;
    }
    return v4;
  }
  if (v2 != 3)
  {
    if (v2 == 1)
    {
      if (CGColorSpaceFindMatchingSingleton_predicate != -1) {
        dispatch_once(&CGColorSpaceFindMatchingSingleton_predicate, &__block_literal_global_170_6517);
      }
      uint64_t v3 = 0;
      while (1)
      {
        uint64_t v4 = CGColorSpaceFindMatchingSingleton_spaces[v3];
        if (CGColorSpaceEqualToColorSpace(a1, v4)) {
          break;
        }
        if (++v3 == 3) {
          return 0;
        }
      }
      return v4;
    }
    return 0;
  }
  if (CGColorSpaceFindMatchingSingleton_predicate_172 != -1) {
    dispatch_once(&CGColorSpaceFindMatchingSingleton_predicate_172, &__block_literal_global_175_6518);
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v4 = CGColorSpaceFindMatchingSingleton_spaces_171[v5];
    if (CGColorSpaceEqualToColorSpace(a1, v4)) {
      break;
    }
    if (++v5 == 14) {
      return 0;
    }
  }
  return v4;
}

CGColorSpaceRef CGColorSpaceCreateCalibratedRGB(const CGFloat *whitePoint, const CGFloat *blackPoint, const CGFloat *gamma, const CGFloat *matrix)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!whitePoint) {
    goto LABEL_40;
  }
  uint64_t v12 = malloc_type_calloc(0x78uLL, 1uLL, 0x203FB65BuLL);
  uint64_t v13 = (uint64_t)v12;
  *(_DWORD *)uint64_t v12 = 1;
  v12[4] = 0;
  if (matrix) {
    BOOL v14 = matrix[2] * -(matrix[6] * matrix[4])
  }
        + *matrix * matrix[4] * matrix[8]
        + matrix[2] * matrix[3] * matrix[7]
        + -(matrix[3] * matrix[1]) * matrix[8]
        + matrix[1] * matrix[5] * matrix[6]
        + -(*matrix * matrix[5]) * matrix[7] != 0.0;
  else {
    BOOL v14 = 1;
  }
  *((void *)v12 + 3) = 0x100000004;
  *((unsigned char *)v12 + 10) = v14;
  *(_WORD *)((char *)v12 + 11) = 256;
  v12[7] = 256;
  *((void *)v12 + 14) = &color_space_state_create_calibrated_rgb_calibrated_rgb_vtable;
  *((_DWORD *)v12 + 8) = 1;
  *((void *)v12 + 10) = 0;
  *((void *)v12 + 11) = 0;
  *((void *)v12 + 5) = &calibrated_rgb_get_default_color_components_default_rgb;
  *((void *)v12 + 6) = 3;
  unint64_t v15 = (char *)malloc_type_calloc(0x90uLL, 1uLL, 0x8C70A895uLL);
  *(void *)(v13 + 96) = v15;
  if (!v15)
  {
    free((void *)v13);
LABEL_40:
    uint64_t v37 = (CGColorSpace *)CGColorSpaceCreateWithState(0, (uint64_t)blackPoint, (uint64_t)gamma, (uint64_t)matrix, v4, v5, v6, v7);
    goto LABEL_41;
  }
  for (uint64_t i = 0; i != 3; ++i)
    *(CGFloat *)&v15[i * 8] = whitePoint[i];
  uint64_t v17 = 0;
  uint64_t v18 = (const CGFloat *)&default_black_point_18824;
  if (blackPoint) {
    uint64_t v18 = blackPoint;
  }
  do
  {
    *(CGFloat *)&v15[v17 * 8 + 24] = v18[v17];
    ++v17;
  }
  while (v17 != 3);
  uint64_t v19 = 0;
  uint64_t v20 = (const CGFloat *)&xmmword_185296170;
  if (gamma) {
    uint64_t v20 = gamma;
  }
  do
  {
    *(CGFloat *)&v15[v19 * 8 + 48] = v20[v19];
    ++v19;
  }
  while (v19 != 3);
  uint64_t v21 = 0;
  CFNumberRef v22 = (const CGFloat *)&color_space_state_create_calibrated_rgb_default_matrix;
  if (matrix) {
    CFNumberRef v22 = matrix;
  }
  do
  {
    *(CGFloat *)&v15[v21 * 8 + 72] = v22[v21];
    ++v21;
  }
  while (v21 != 9);
  memset(md, 0, 16);
  CFAllocatorContext v23 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v23);
  if (v23) {
    CC_MD5_Update(v23, (const void *)(v13 + 24), 4u);
  }
  uint64_t v24 = 0;
  uint64_t v25 = *(void *)(v13 + 96);
  do
  {
    if (v23) {
      CC_MD5_Update(v23, (const void *)(v25 + v24), 8u);
    }
    v24 += 8;
  }
  while (v24 != 24);
  for (uint64_t j = 0; j != 24; j += 8)
  {
    if (v23) {
      CC_MD5_Update(v23, (const void *)(v25 + 24 + j), 8u);
    }
  }
  for (uint64_t k = 0; k != 24; k += 8)
  {
    if (v23) {
      CC_MD5_Update(v23, (const void *)(v25 + 48 + k), 8u);
    }
  }
  for (uint64_t m = 0; m != 9; ++m)
  {
    while (v23)
    {
      CC_MD5_Update(v23, (const void *)(v25 + 8 * m++ + 72), 8u);
      if (m == 9)
      {
        CC_MD5_Final(md, v23);
        long long v29 = *(_OWORD *)md;
        goto LABEL_37;
      }
    }
  }
  long long v29 = 0uLL;
LABEL_37:
  long long v39 = v29;
  free(v23);
  *(_OWORD *)(v13 + 64) = v39;
  uint64_t v37 = (CGColorSpace *)CGColorSpaceCreateWithState((atomic_uint *)v13, v30, v31, v32, v33, v34, v35, v36);
  if (atomic_fetch_add_explicit((atomic_uint *volatile)v13, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc(v13);
  }
LABEL_41:
  if (v37) {
    *((void *)v37 + 3) = color_space_state_register(*((unsigned char **)v37 + 3));
  }
  return v37;
}

uint64_t cs_retain_count(uint64_t a1, uint64_t a2)
{
  if (a1 == -1)
  {
    uint64_t v4 = *(void *)(a2 + 24);
    if (!*(unsigned char *)(v4 + 8)
      && atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 16), 0xFFFFFFFF, memory_order_relaxed) == 1)
    {
      color_space_state_unregister(v4);
      pthread_mutex_destroy((pthread_mutex_t *)(a2 + 32));
      CFAllocatorRef v5 = CFGetAllocator((CFTypeRef)a2);
      CFAllocatorDeallocate(v5, (void *)a2);
    }
    return 0;
  }
  if (a1)
  {
    if (a1 == 1 && !*(unsigned char *)(*(void *)(a2 + 24) + 8))
    {
      uint64_t result = 0;
      atomic_fetch_add_explicit((atomic_uint *volatile)(a2 + 16), 1u, memory_order_relaxed);
      return result;
    }
    return 0;
  }
  if (*(unsigned char *)(*(void *)(a2 + 24) + 8)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned int *)(a2 + 16);
  }
}

CGColorSpaceRef CGColorSpaceCreatePattern(CGColorSpaceRef baseSpace)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (baseSpace && CGColorSpaceGetType(baseSpace) == 9) {
    goto LABEL_18;
  }
  int v9 = malloc_type_calloc(0x78uLL, 1uLL, 0x3A988F3EuLL);
  if (!v9) {
    goto LABEL_18;
  }
  uint64_t v10 = (uint64_t)v9;
  *(_DWORD *)int v9 = 1;
  v9[4] = 0;
  *((unsigned char *)v9 + 10) = 0;
  if (baseSpace)
  {
    uint64_t v11 = *((void *)baseSpace + 3);
    char v12 = *(unsigned char *)(v11 + 12);
    *((void *)v9 + 3) = 0x600000009;
    uint64_t v13 = v9 + 12;
    *((unsigned char *)v9 + 12) = v12;
    *((unsigned char *)v9 + 11) = 0;
    v9[7] = 0;
    *((void *)v9 + 6) = *(void *)(v11 + 48);
    *((void *)v9 + 14) = color_space_state_create_pattern_pattern_vtable;
    *((_DWORD *)v9 + 8) = *(_DWORD *)(v11 + 32);
    *((void *)v9 + 10) = 0;
    *((void *)v9 + 11) = 0;
    BOOL v14 = *(void **)(v11 + 40);
  }
  else
  {
    *((_DWORD *)v9 + 6) = 9;
    uint64_t v13 = v9 + 12;
    *(_WORD *)((char *)v9 + 11) = 256;
    v9[7] = 0;
    *((void *)v9 + 6) = 0;
    CFTypeRef v15 = CFRetain(@"kCGColorSpaceColoredPattern");
    *(void *)(v10 + 112) = color_space_state_create_pattern_pattern_vtable;
    *(void *)(v10 + 28) = -4294967290;
    *(void *)(v10 + 80) = v15;
    *(void *)(v10 + 88) = 0;
    BOOL v14 = &pattern_get_default_color_components_default_colored_pattern;
  }
  *(void *)(v10 + 40) = v14;
  uint64_t v16 = (CGColorSpaceRef *)malloc_type_calloc(0x90uLL, 1uLL, 0xCC627293uLL);
  *(void *)(v10 + 96) = v16;
  if (!v16)
  {
    free((void *)v10);
LABEL_18:
    uint64_t v28 = (CGColorSpace *)CGColorSpaceCreateWithState(0, v2, v3, v4, v5, v6, v7, v8);
    goto LABEL_19;
  }
  uint64_t v24 = v16;
  uint64_t v25 = v16;
  if (baseSpace)
  {
    CFRetain(baseSpace);
    uint64_t v25 = *(CGColorSpaceRef **)(v10 + 96);
  }
  *uint64_t v24 = baseSpace;
  memset(md, 0, 16);
  if (!*v25)
  {
    long long v31 = xmmword_1850CE080;
    goto LABEL_27;
  }
  uint64_t v26 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
  CC_MD5_Init(v26);
  if (v26) {
    CC_MD5_Update(v26, v13, 4u);
  }
  if (!*v25 || (uint64_t v27 = *((void *)*v25 + 3)) == 0)
  {
    if (v26) {
      goto LABEL_23;
    }
LABEL_25:
    long long v30 = 0uLL;
    goto LABEL_26;
  }
  if (!v26) {
    goto LABEL_25;
  }
  CC_MD5_Update(v26, (const void *)(v27 + 64), 0x10u);
LABEL_23:
  CC_MD5_Final(md, v26);
  long long v30 = *(_OWORD *)md;
LABEL_26:
  long long v32 = v30;
  free(v26);
  long long v31 = v32;
LABEL_27:
  *(_OWORD *)(v10 + 64) = v31;
  uint64_t v28 = (CGColorSpace *)CGColorSpaceCreateWithState((atomic_uint *)v10, v17, v18, v19, v20, v21, v22, v23);
  if (atomic_fetch_add_explicit((atomic_uint *volatile)v10, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc(v10);
  }
LABEL_19:
  if (v28) {
    *((void *)v28 + 3) = color_space_state_register(*((unsigned char **)v28 + 3));
  }
  return v28;
}

atomic_uint *color_space_state_register(unsigned char *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&colorspace_state_lock);
  if (get_states_cache_predicate != -1) {
    dispatch_once(&get_states_cache_predicate, &__block_literal_global_7685);
  }
  uint64_t v2 = (__CFSet *)get_states_cache_states;
  CFArrayRef Value = (atomic_uint *)CFSetGetValue((CFSetRef)get_states_cache_states, a1);
  if (Value)
  {
    uint64_t v4 = Value;
    atomic_fetch_add_explicit(Value, 1u, memory_order_relaxed);
    if (!a1) {
      goto LABEL_9;
    }
  }
  else
  {
    CFSetSetValue(v2, a1);
    a1[11] = 1;
    atomic_fetch_add_explicit((atomic_uint *volatile)a1, 1u, memory_order_relaxed);
    uint64_t v4 = (atomic_uint *)a1;
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1) {
    color_space_state_dealloc((uint64_t)a1);
  }
LABEL_9:
  os_unfair_lock_unlock((os_unfair_lock_t)&colorspace_state_lock);
  return v4;
}

void color_space_state_dealloc(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFStringGetCStringPtr(*(CFStringRef *)(a1 + 80), 0x8000100u);
    _CGHandleAssert("color_space_state_dealloc", 111, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/color-space-state.c", "!state->is_singleton", "tried to deallocate a singleton color_space_state (%p \"%s\")", v5, v6, v7, a1);
  }
  uint64_t v2 = **(void (***)(uint64_t))(a1 + 112);
  if (v2) {
    v2(a1);
  }
  uint64_t v3 = *(const void **)(a1 + 80);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = *(const void **)(a1 + 56);
  if (v4) {
    CFRelease(v4);
  }
  CGPropertiesRelease(*(CFTypeRef **)(a1 + 88));
  free(*(void **)(a1 + 96));

  free((void *)a1);
}

void icc_finalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 24);
  if (v8 != 6) {
    _CGHandleAssert("icc_finalize", 91, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ICC.c", "state->type == kCGColorSpaceICCBased", "Colorspace not ICC based. type = %d", a6, a7, a8, v8);
  }
  uint64_t v9 = *(void *)(a1 + 96);
  if (v9)
  {
    CGColorSpaceRelease(*(CGColorSpaceRef *)(v9 + 56));
    CGDataProviderRelease(*(CGDataProviderRef *)(v9 + 8));
    uint64_t v10 = *(const void **)(v9 + 16);
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = *(const void **)(v9 + 40);
    if (v11) {
      CFRelease(v11);
    }
    char v12 = *(void **)(v9 + 64);
    free(v12);
  }
}

void color_space_state_unregister(uint64_t a1)
{
  if (!a1) {
    return;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&colorspace_state_lock);
  if (!*(unsigned char *)(a1 + 11))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&colorspace_state_lock);
    if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) != 1) {
      return;
    }
    goto LABEL_8;
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    if (get_states_cache_predicate != -1) {
      dispatch_once(&get_states_cache_predicate, &__block_literal_global_7685);
    }
    CFSetRemoveValue((CFMutableSetRef)get_states_cache_states, (const void *)a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&colorspace_state_lock);
LABEL_8:
    color_space_state_dealloc(a1);
    return;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&colorspace_state_lock);
}

CFURLRef CGFontCopyURL(const __CFURL *a1)
{
  CFURLRef v1 = a1;
  if (a1)
  {
    uint64_t v2 = (*(uint64_t (**)(void))(*((void *)a1 + 2) + 224))(*((void *)a1 + 14));
    if (v2)
    {
      CFStringRef v3 = (const __CFString *)v2;
      CFStringRef v4 = (const __CFString *)(*(uint64_t (**)(void))(*((void *)v1 + 2) + 160))(*((void *)v1 + 14));
      CFDictionaryRef v5 = CGFontCopyVariations(v1);
      CFURLRef v1 = CGFontURLCreate(v3, v4, v5);
      CFRelease(v3);
      if (v4) {
        CFRelease(v4);
      }
      if (v5) {
        CFRelease(v5);
      }
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

void append_variations(__CFString *a1, CFDictionaryRef theDict)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  size_t Count = CFDictionaryGetCount(theDict);
  v12[1] = v12;
  MEMORY[0x1F4188790](Count, v5);
  v12[0] = (char *)v12 - v7;
  if (v6 <= 0x1FFFFFFFFFFFFFFELL) {
    int v8 = (const void **)((char *)v12 - v7);
  }
  else {
    int v8 = 0;
  }
  if (v6 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL) {
    int v8 = (const void **)malloc_type_malloc(8 * Count, 0xDE9479BAuLL);
  }
  float valuePtr = 0.0;
  CFDictionaryGetKeysAndValues(theDict, v8, 0);
  qsort(v8, Count, 8uLL, (int (__cdecl *)(const void *, const void *))compare_keys);
  if (Count)
  {
    uint64_t v9 = (const __CFString **)v8;
    do
    {
      CFStringRef v10 = *v9++;
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, v10);
      CFStringAppend(a1, @";var:");
      append_escaped_string(a1, v10);
      CFStringAppend(a1, @"=");
      CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
      CFStringAppendFormat(a1, 0, @"%g", valuePtr);
      --Count;
    }
    while (Count);
  }
  if (v8 != (const void **)v12[0]) {
    free(v8);
  }
}

CFURLRef CGFontURLCreate(CFStringRef filePath, const __CFString *a2, const __CFDictionary *a3)
{
  CFURLRef v3 = 0;
  if (filePath)
  {
    if (a2)
    {
      CFURLRef v6 = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 0);
      CFURLRef v3 = v6;
      if (v6)
      {
        CFStringRef v7 = CFURLGetString(v6);
        MutableCopCGFloat y = CFStringCreateMutableCopy(0, 0, v7);
        CFRelease(v3);
        if (MutableCopy)
        {
          if (!CFStringHasPrefix(MutableCopy, @"file://")) {
            CFStringInsert(MutableCopy, 0, @"file://");
          }
          CFStringAppend(MutableCopy, @"#postscript-name=");
          if (append_escaped_string(MutableCopy, a2))
          {
            if (a3) {
              append_variations(MutableCopy, a3);
            }
            CFURLRef v3 = CFURLCreateWithString(0, MutableCopy, 0);
          }
          else
          {
            CFURLRef v3 = 0;
          }
          CFRelease(MutableCopy);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v3;
}

uint64_t append_escaped_string(__CFString *a1, CFStringRef theString)
{
  if (!theString) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(theString);
  v8.locatiouint64_t n = 0;
  v8.uint64_t length = Length;
  if (CFStringFindWithOptions(theString, @";", v8, 0, 0))
  {
    MutableCopCGFloat y = CFStringCreateMutableCopy(0, 0, theString);
    v9.locatiouint64_t n = 0;
    v9.uint64_t length = Length;
    CFStringFindAndReplace(MutableCopy, @";", @"/", v9, 0);
    CFStringRef v6 = CFURLCreateStringByAddingPercentEscapes(0, MutableCopy, 0, 0, 0x8000100u);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v6) {
      goto LABEL_6;
    }
  }
  else
  {
    CFStringRef v6 = CFURLCreateStringByAddingPercentEscapes(0, theString, 0, 0, 0x8000100u);
    if (v6)
    {
LABEL_6:
      CFStringAppend(a1, v6);
      CFRelease(v6);
      return 1;
    }
  }
  return 0;
}

uint64_t copy_path(uint64_t a1)
{
  return MEMORY[0x1F4119BE8](*(void *)(a1 + 8));
}

uint64_t copy_postscript_name_for_url()
{
  return FPFontCopyPostScriptName();
}

CGFontRef CGFontCreateCopyWithVariations(CGFontRef font, CFDictionaryRef variations)
{
  CGFontRef v2 = font;
  if (font)
  {
    if (variations
      && CFDictionaryGetCount(variations)
      && ((size_t count = 0,
           uint64_t v32 = 0,
           (uint64_t v4 = (*(uint64_t (**)(void, size_t *))(*((void *)v2 + 2) + 208))(*((void *)v2 + 14), &count)) != 0)? (v5 = count == 0): (v5 = 1), !v5))
    {
      uint64_t Float = (uint64_t)malloc_type_calloc(count, 0x10uLL, 0x1000040F7F8B94BuLL);
      CFTypeRef v15 = (void *)Float;
      if (count)
      {
        size_t v16 = 0;
        uint64_t v17 = (uint64_t *)(Float + 8);
        uint64_t v18 = (void *)(v4 + 8);
        do
        {
          *((_DWORD *)v17 - 2) = *((_DWORD *)v18 - 2);
          CFStringRef v19 = copy_name_for_identifier((uint64_t)v2, *((_DWORD *)v18 - 2));
          uint64_t Float = CGCFDictionaryGetFloat(variations, v19, &v32);
          if (Float) {
            uint64_t v20 = &v32;
          }
          else {
            uint64_t v20 = v18;
          }
          *uint64_t v17 = *v20;
          if (v19) {
            CFRelease(v19);
          }
          ++v16;
          v17 += 2;
          v18 += 2;
        }
        while (v16 < count);
      }
      uint64_t v21 = (CGFont *)CGFontCreate(Float, v8, v9, v10, v11, v12, v13, v14);
      uint64_t VTable = CGFontGetVTable((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28);
      uint64_t v30 = (*(uint64_t (**)(void, void *, size_t))(VTable + 40))(*((void *)v2 + 14), v15, count);
      *((void *)v21 + 14) = v30;
      if (v30)
      {
        free(v15);
        return v21;
      }
      else
      {
        CFRelease(v21);
        free(v15);
        return 0;
      }
    }
    else
    {
      CFRetain(v2);
    }
  }
  return v2;
}

void *CGFontCreateWithPathAndName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  uint64_t v10 = CGFontCreate(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = (void *)v10;
  if (v10)
  {
    uint64_t VTable = CGFontGetVTable(v10, v11, v12, v13, v14, v15, v16, v17);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(VTable + 64))(a1, a2);
    v18[14] = v20;
    if (!v20)
    {
      CFRelease(v18);
      return 0;
    }
  }
  return v18;
}

void *CGFontCreateWithVariations(void *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = cf;
  if (cf)
  {
    if (!a2 || !a3)
    {
      CFRetain(cf);
      return v8;
    }
    uint64_t v11 = CGFontCreate((uint64_t)cf, a2, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      CFStringRef v19 = (void *)v11;
      uint64_t VTable = CGFontGetVTable(v11, v12, v13, v14, v15, v16, v17, v18);
      uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t))(VTable + 40))(v8[14], a2, a3);
      v19[14] = v21;
      if (v21)
      {
        uint64_t v22 = atomic_load(v8 + 4);
        CGFontSetEncodingVector((uint64_t)v19, v22);
        return v19;
      }
      CFRelease(v19);
    }
    return 0;
  }
  return v8;
}

uint64_t CGFontCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t VTable = CGFontGetVTable(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!VTable) {
    return 0;
  }
  uint64_t v15 = VTable;
  if (_block_invoke_once_3318 != -1) {
    dispatch_once(&_block_invoke_once_3318, &__block_literal_global_8_3319);
  }
  uint64_t Instance = CGTypeCreateInstance(CGFontGetTypeID_font_type_id, 104, v9, v10, v11, v12, v13, v14);
  uint64_t v17 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = v15;
    *(_DWORD *)(Instance + 24) = 0;
    *(_DWORD *)(Instance + 104) = -1;
    initialize_font_database_once();
  }
  return v17;
}

uint64_t CGFontGetVTable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (CGFontGetVTable_predicate != -1) {
    dispatch_once(&CGFontGetVTable_predicate, &__block_literal_global_21658);
  }
  uint64_t result = CGFontGetVTable_vtable;
  if (!CGFontGetVTable_vtable) {
    _CGHandleAssert("CGFontGetVTable", 85, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Fonts/CGFontVTable.c", "vtable != NULL", "missing vtable", a6, a7, a8, vars0);
  }
  return result;
}

uint64_t initialize_font_database_once()
{
  if (initialize_font_database_once_predicate != -1) {
    dispatch_once(&initialize_font_database_once_predicate, &__block_literal_global_11_3320);
  }
  uint64_t v0 = pthread_mutex_lock(&initialize_font_database_once_mutex);
  if ((initialize_font_database_once_fontDBInitializer_initialized & 1) == 0)
  {
    if (fontDBInitializer) {
      fontDBInitializer(v0);
    }
    initialize_font_database_once_fontDBInitializer_initializedouble d = 1;
  }

  return pthread_mutex_unlock(&initialize_font_database_once_mutex);
}

void *create_private_data_with_variations()
{
  uint64_t result = (void *)FPFontCreateCopyWithVariation();
  if (result)
  {
    CFURLRef v1 = result;
    uint64_t result = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040D8C947D5uLL);
    *uint64_t result = 1;
    result[1] = v1;
  }
  return result;
}

void CGFontSetEncodingVector(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!atomic_load_explicit((atomic_ullong *volatile)(a1 + 32), memory_order_acquire))
    {
      uint64_t v4 = (char *)malloc_type_malloc(0x200uLL, 0x1000040BDFB0063uLL);
      for (uint64_t i = 0; i != 512; i += 2)
        *(_WORD *)&v4[i] = *(_WORD *)(a2 + i);
      uint64_t v6 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 32), (unint64_t *)&v6, (unint64_t)v4);
      if (v6)
      {
        free(v4);
      }
    }
  }
}

void *create_private_data_with_path_and_name()
{
  uint64_t result = (void *)FPFontCreateWithPathAndName();
  if (result)
  {
    CFURLRef v1 = result;
    uint64_t result = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040D8C947D5uLL);
    *uint64_t result = 1;
    result[1] = v1;
  }
  return result;
}

CFDictionaryRef CGFontCopyVariations(CGFontRef font)
{
  if (!font) {
    return 0;
  }
  unint64_t v11 = 0;
  uint64_t v2 = (*(uint64_t (**)(void, unint64_t *))(*((void *)font + 2) + 208))(*((void *)font + 14), &v11);
  CFDataRef Mutable = 0;
  if (v2) {
    BOOL v4 = v11 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v5 = v2;
    CFDataRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v11)
    {
      unint64_t v6 = 0;
      CFStringRef v7 = (double *)(v5 + 8);
      do
      {
        CFStringRef v8 = copy_name_for_identifier((uint64_t)font, *((_DWORD *)v7 - 2));
        if (v8)
        {
          CFStringRef v9 = v8;
          CGCFDictionarySetFloat(Mutable, v8, *v7);
          CFRelease(v9);
        }
        ++v6;
        v7 += 2;
      }
      while (v6 < v11);
    }
  }
  return Mutable;
}

CFStringRef copy_name_for_identifier(uint64_t a1, unsigned int a2)
{
  uint64_t v8 = 0;
  CFStringRef result = (CFStringRef)(*(uint64_t (**)(void, uint64_t *))(*(void *)(a1 + 16) + 408))(*(void *)(a1 + 112), &v8);
  if (result)
  {
    if (v8)
    {
      uint64_t v4 = 0;
      p_float64x2_t info = &result->info;
      while (1)
      {
        int v6 = *(_DWORD *)p_info;
        p_info += 5;
        if (v6 == a2) {
          break;
        }
        if (v8 == ++v4) {
          return 0;
        }
      }
      CFStringRef v7 = (const void *)*((void *)&result->isa + 5 * v4);
      if (v7)
      {
        return (CFStringRef)CFRetain(v7);
      }
      else
      {
        *(_DWORD *)cStr = bswap32(a2);
        char v10 = 0;
        return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t get_variation_axes(uint64_t a1)
{
  return MEMORY[0x1F4119D70](*(void *)(a1 + 8));
}

void CGCFDictionarySetFloat(__CFDictionary *a1, const void *a2, double a3)
{
  double valuePtr = a3;
  if (a1 && a2)
  {
    CFNumberRef v5 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionarySetValue(a1, a2, v5);
      CFRelease(v6);
    }
  }
}

uint64_t get_variations()
{
  return FPFontGetVariation();
}

uint64_t shape_accum_add(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = *a1;
  if ((int)v5 < 3) {
    return 0xFFFFFFFFLL;
  }
  if ((int)a4 - (int)a2 < 1) {
    return 0;
  }
  uint64_t v7 = a3;
  if ((int)a5 - (int)a3 < 1) {
    return 0;
  }
  uint64_t v36 = *((void *)a1 + 3);
  uint64_t v38 = *((void *)a1 + 2);
  int v35 = (a5 - a3) * (a4 - a2);
  signed int v9 = a1[1];
  unsigned int v8 = a1[2];
  int v10 = -1;
  int v11 = v8;
  do
  {
    if (v11 != v9)
    {
      int v12 = v9 + (((v11 - 1) * v11) >> 1);
      if (v11 < v9) {
        int v12 = v11 + (((v9 - 1) * v9) >> 1);
      }
      uint64_t v13 = a2;
      uint64_t v14 = v7;
      uint64_t v15 = a4;
      uint64_t v16 = a5;
      uint64_t result = shape_accum_cost(a2, v7, a4, a5, v35, (int *)(v38 + 16 * v11), (int *)(v36 + 4 * v12));
      if (!result)
      {
        a1[2] = v11;
        return result;
      }
      if ((int)result < 0) {
        int v10 = v11;
      }
      a5 = v16;
      uint64_t v7 = v14;
      a4 = v15;
      a2 = v13;
    }
    if (v11 + 1 == v5) {
      int v11 = 0;
    }
    else {
      ++v11;
    }
  }
  while (v11 != v8);
  if (v10 < 1)
  {
    signed int v18 = v9 == 0;
    int v19 = 0x40000000;
    uint64_t v20 = 1;
    signed int v21 = v9;
    do
    {
      uint64_t v22 = 0;
      do
      {
        if (*(_DWORD *)(*((void *)a1 + 3) + 4 * ((((int)v20 - 1) * (int)v20) >> 1) + 4 * v22) < v19)
        {
          int v19 = *(_DWORD *)(*((void *)a1 + 3) + 4 * ((((int)v20 - 1) * (int)v20) >> 1) + 4 * v22);
          signed int v21 = v20;
          signed int v18 = v22;
        }
        ++v22;
      }
      while (v20 != v22);
      ++v20;
    }
    while (v20 != v5);
    if (v18 == v9)
    {
      signed int v18 = v21;
    }
    else if (v21 != v9)
    {
      uint64_t v23 = (_DWORD *)(v38 + 16 * v9);
      *uint64_t v23 = a2;
      v23[1] = a4;
      v23[2] = v7;
      v23[3] = a5;
      uint64_t v24 = (_DWORD *)(v38 + 16 * v21);
      LODWORD(a2) = *v24;
      LODWORD(a4) = v24[1];
      LODWORD(v7) = v24[2];
      LODWORD(a5) = v24[3];
      signed int v9 = v21;
      *(void *)uint64_t v24 = 0;
      *((void *)v24 + 1) = 0;
    }
    uint64_t v25 = (int *)(v38 + 16 * v18);
    int v26 = *v25;
    a1[1] = v9;
    int v27 = v25[1];
    int v37 = v26;
    if (v26 > (int)a2)
    {
      *uint64_t v25 = a2;
      int v37 = a2;
    }
    int v28 = v25[2];
    if (v27 < (int)a4)
    {
      v25[1] = a4;
      int v27 = a4;
    }
    int v29 = v25[3];
    if (v28 > (int)v7)
    {
      v25[2] = v7;
      int v28 = v7;
    }
    a1[2] = v18;
    if (v29 < (int)a5)
    {
      _OWORD v25[3] = a5;
      int v29 = a5;
    }
    int v30 = 0;
    uint64_t v31 = 0;
    uint64_t v34 = *((void *)a1 + 3);
    do
    {
      if (v18 != v31)
      {
        int v32 = v18 + ((((int)v31 - 1) * (int)v31) >> 1);
        if (v31 < v18) {
          int v32 = (((v18 - 1) * v18) >> 1) + v31;
        }
        shape_accum_cost(v37, v28, v27, v29, (v29 - v28) * (v27 - v37), (int *)(v38 + 4 * (v30 & 0xFFFFFFFC)), (int *)(v34 + 4 * v32));
      }
      ++v31;
      v30 += 4;
      uint64_t result = 1;
    }
    while (v5 != v31);
  }
  else
  {
    uint64_t v17 = (_DWORD *)(v38 + 16 * v9);
    *uint64_t v17 = a2;
    v17[1] = a4;
    v17[2] = v7;
    v17[3] = a5;
    a1[1] = v10;
    a1[2] = v9;
    return 1;
  }
  return result;
}

uint64_t shape_accum_cost(int a1, int a2, int a3, int a4, int a5, int *a6, int *a7)
{
  int v7 = *a6;
  int v8 = a6[1];
  if (v8 <= *a6)
  {
    *a7 = 0;
    return 0xFFFFFFFFLL;
  }
  else
  {
    int v9 = a6[2];
    int v10 = a6[3];
    if (v7 >= a1) {
      int v11 = a1;
    }
    else {
      int v11 = *a6;
    }
    if (v8 <= a3) {
      int v12 = a3;
    }
    else {
      int v12 = a6[1];
    }
    int v13 = v12 - v11;
    if (v9 >= a2) {
      int v14 = a2;
    }
    else {
      int v14 = a6[2];
    }
    if (v10 <= a4) {
      int v15 = a4;
    }
    else {
      int v15 = a6[3];
    }
    int v16 = (v15 - v14) * v13 - (a5 + (v10 - v9) * (v8 - *a6));
    if (v16)
    {
      if (v10 >= a4) {
        int v10 = a4;
      }
      if (v9 <= a2) {
        int v9 = a2;
      }
      if (v8 >= a3) {
        int v8 = a3;
      }
      if (v7 <= a1) {
        int v7 = a1;
      }
      int v18 = v8 - v7;
      int v19 = v10 - v9;
      int v20 = (v10 - v9) * v18;
      if (v19 <= 0 || v18 <= 0) {
        int v22 = 0;
      }
      else {
        int v22 = v20;
      }
      int v23 = v22 + v16;
      *a7 = v23;
      if (v23) {
        BOOL v24 = 0;
      }
      else {
        BOOL v24 = v20 == a5;
      }
      return !v24;
    }
    else
    {
      *a7 = 0;
      return 1;
    }
  }
}

uint64_t CGImageTextureDataGetNumberOfFaces(uint64_t result)
{
  if (result) {
    return *(void *)(result + 128);
  }
  return result;
}

uint64_t CGImageTextureDataGetColorSpace(uint64_t result)
{
  if (result) {
    return *(void *)(result + 96);
  }
  return result;
}

void provider_allocator_deallocate(uint64_t a1, uint64_t a2)
{
}

CGFontRef CGFontRetain(CGFontRef font)
{
  if (font) {
    CFRetain(font);
  }
  return font;
}

CFArrayRef CGFontCopyTableTags(CFArrayRef font)
{
  if (font) {
    return (CFArrayRef)(*(uint64_t (**)(void))(*((void *)font + 2) + 416))(*((void *)font + 14));
  }
  return font;
}

uint64_t CGImageTextureDataGetPixelFormat(uint64_t result, int a2)
{
  if (result)
  {
    if (a2 == 1)
    {
      uint64_t v2 = result + 112;
    }
    else
    {
      if (a2) {
        return 0;
      }
      uint64_t v2 = result + 104;
    }
    return *(void *)v2;
  }
  return result;
}

void *CGImageGetMatte(void *result)
{
  if (result)
  {
    CFURLRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[23];
    }
    else {
      return 0;
    }
  }
  return result;
}

unint64_t argb32_image_mark_argb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6 = *((unsigned __int8 *)a2 + 8);
  int v89 = *a2;
  int v7 = *(unsigned int **)(result + 32);
  if (*(void *)(result + 40)) {
    int v8 = 0;
  }
  else {
    int v8 = -16777216;
  }
  int v9 = (unsigned int *)*((void *)a2 + 2);
  uint64_t v88 = *((void *)a2 + 3) - a5;
  uint64_t v11 = *((void *)a2 + 15);
  uint64_t v10 = *((void *)a2 + 16);
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v85 = *((void *)a2 + 9);
  uint64_t v13 = *((void *)a2 + 5) + v85 * a4;
  int v14 = (char *)v7
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  unint64_t v94 = result;
  int v90 = a5;
  char v86 = v12;
  uint64_t v87 = v11;
  if (*(void *)(result + 176))
  {
    uint64_t v84 = *((void *)a2 + 11);
    uint64_t v82 = ~(-1 << v12);
    uint64_t v83 = *((void *)a2 + 13);
    char v81 = v12 - 4;
    int v15 = (unsigned int *)(v14 - 4);
    uint64_t v79 = a5;
    uint64_t v80 = -v11;
    uint64_t v78 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v83 - v13) | (v13 - v84)) < 0)
      {
        int v20 = 0;
        uint64_t v95 = 0;
      }
      else
      {
        uint64_t v16 = ((v13 & (unint64_t)v82) >> v81) & 0xF;
        char v17 = weights_21383[v16];
        BOOL v18 = (unint64_t)(v16 - 7) >= 9;
        uint64_t v19 = v80;
        if (!v18) {
          uint64_t v19 = v11;
        }
        uint64_t v95 = v19;
        int v20 = v17 & 0xF;
      }
      uint64_t v21 = *(void *)(v94 + 32) + (v13 >> v12) * v11;
      int v92 = a6;
      uint64_t v91 = v13;
      if (v89 != 1) {
        break;
      }
      if (a5 >= 1)
      {
        int v23 = (uint64_t *)v78;
        uint64_t v22 = v79;
        while (1)
        {
          uint64_t v24 = *(v23 - 1);
          uint64_t v25 = *v23;
          uint64_t v26 = v21 + v24;
          if ((unint64_t)v15 >= v21 + v24) {
            int v27 = (unsigned int *)(v21 + v24);
          }
          else {
            int v27 = v15;
          }
          if (v27 < v7) {
            int v27 = v7;
          }
          unsigned int v28 = *v27;
          char v29 = v25 & 0xF;
          if ((v25 & 0xF) != 0) {
            break;
          }
          if (v20)
          {
            uint64_t v40 = (unsigned int *)(v26 + v95);
            if ((unint64_t)v15 < v26 + v95) {
              uint64_t v40 = v15;
            }
            if (v40 < v7) {
              uint64_t v40 = v7;
            }
            int v41 = BLEND8_21385[v20];
            unsigned int v38 = v28 - ((v41 & v28) >> v20);
            unsigned int v39 = (v41 & *v40) >> v20;
            goto LABEL_42;
          }
LABEL_43:
          uint64_t result = v28 | v8;
          if (v6 != 255) {
            uint64_t result = PDM_14621(result, v6);
          }
          v23 += 2;
          *v9++ = result;
          if (!--v22) {
            goto LABEL_85;
          }
        }
        int v30 = (unsigned int *)(v26 + (v25 >> 4));
        if (v15 < v30) {
          int v30 = v15;
        }
        if (v30 < v7) {
          int v30 = v7;
        }
        unsigned int v31 = *v30;
        if (v20)
        {
          int v32 = (unsigned int *)(v26 + v95);
          if (v15 >= v32) {
            uint64_t v33 = v32;
          }
          else {
            uint64_t v33 = v15;
          }
          if (v33 < v7) {
            uint64_t v33 = v7;
          }
          unsigned int v34 = *v33;
          int v35 = (unsigned int *)((char *)v32 + (v25 >> 4));
          if (v15 < v35) {
            int v35 = v15;
          }
          if (v35 < v7) {
            int v35 = v7;
          }
          int v36 = BLEND8_21385[v20];
          unsigned int v28 = v28 - ((v36 & v28) >> v20) + ((v36 & v34) >> v20);
          unsigned int v31 = v31 - ((v36 & v31) >> v20) + ((v36 & *v35) >> v20);
        }
        int v37 = BLEND8_21385[*v23 & 0xF];
        unsigned int v38 = v28 - ((v37 & v28) >> v29);
        unsigned int v39 = (v37 & v31) >> v29;
LABEL_42:
        unsigned int v28 = v38 + v39;
        goto LABEL_43;
      }
LABEL_85:
      uint64_t v11 = v87;
      v9 += v88;
      LOBYTE(v12) = v86;
      uint64_t v13 = v91 + v85;
      a6 = v92 - 1;
      a5 = v90;
      if (v92 == 1) {
        return result;
      }
    }
    if (a5 < 1) {
      goto LABEL_85;
    }
    __int16 v43 = (uint64_t *)v78;
    uint64_t v42 = v79;
    while (1)
    {
      uint64_t v44 = *(v43 - 1);
      uint64_t v45 = *v43;
      uint64_t v46 = v21 + v44;
      if ((unint64_t)v15 >= v21 + v44) {
        long long v47 = (unsigned int *)(v21 + v44);
      }
      else {
        long long v47 = v15;
      }
      if (v47 < v7) {
        long long v47 = v7;
      }
      unsigned int v48 = *v47;
      char v49 = v45 & 0xF;
      if ((v45 & 0xF) != 0) {
        break;
      }
      if (v20)
      {
        long long v60 = (unsigned int *)(v46 + v95);
        if ((unint64_t)v15 < v46 + v95) {
          long long v60 = v15;
        }
        if (v60 < v7) {
          long long v60 = v7;
        }
        int v61 = BLEND8_21385[v20];
        unsigned int v58 = v48 - ((v61 & v48) >> v20);
        unsigned int v59 = (v61 & *v60) >> v20;
        goto LABEL_77;
      }
LABEL_78:
      unsigned int v62 = v48 | v8;
      if (v6 != 255)
      {
        uint64_t result = PDM_14621(v48 | v8, v6);
        unsigned int v62 = result;
      }
      if (HIBYTE(v62))
      {
        if (HIBYTE(v62) == 255) {
          *int v9 = v62;
        }
        else {
          uint64_t result = (unint64_t)DplusDM_14623(v9, v62, *v9, ~v62 >> 24);
        }
      }
      v43 += 2;
      ++v9;
      if (!--v42) {
        goto LABEL_85;
      }
    }
    uint64_t v50 = (unsigned int *)(v46 + (v45 >> 4));
    if (v15 < v50) {
      uint64_t v50 = v15;
    }
    if (v50 < v7) {
      uint64_t v50 = v7;
    }
    unsigned int v51 = *v50;
    if (v20)
    {
      CFNumberRef v52 = (unsigned int *)(v46 + v95);
      if (v15 >= v52) {
        long long v53 = v52;
      }
      else {
        long long v53 = v15;
      }
      if (v53 < v7) {
        long long v53 = v7;
      }
      unsigned int v54 = *v53;
      long long v55 = (unsigned int *)((char *)v52 + (v45 >> 4));
      if (v15 < v55) {
        long long v55 = v15;
      }
      if (v55 < v7) {
        long long v55 = v7;
      }
      int v56 = BLEND8_21385[v20];
      unsigned int v48 = v48 - ((v56 & v48) >> v20) + ((v56 & v54) >> v20);
      unsigned int v51 = v51 - ((v56 & v51) >> v20) + ((v56 & *v55) >> v20);
    }
    int v57 = BLEND8_21385[*v43 & 0xF];
    unsigned int v58 = v48 - ((v57 & v48) >> v49);
    unsigned int v59 = (v57 & v51) >> v49;
LABEL_77:
    unsigned int v48 = v58 + v59;
    goto LABEL_78;
  }
  float64x2_t v96 = (uint64_t *)(v10 + 16 * a3);
  long long v63 = v14 - 4;
  uint64_t v93 = a5;
  do
  {
    long long v64 = *(char **)(v94 + 32);
    long long v65 = &v64[(v13 >> v12) * v11];
    uint64_t v66 = v13;
    int v67 = a6;
    if (v89 == 1)
    {
      if (a5 >= 1)
      {
        unint64_t v68 = v96;
        uint64_t v69 = v93;
        do
        {
          uint64_t v70 = *v68;
          v68 += 2;
          float32x2_t v71 = &v65[v70];
          if (v63 < &v65[v70]) {
            float32x2_t v71 = v63;
          }
          if (v71 < v64) {
            float32x2_t v71 = v64;
          }
          uint64_t result = *(_DWORD *)v71 | v8;
          if (v6 != 255) {
            uint64_t result = PDM_14621(result, v6);
          }
          *v9++ = result;
          --v69;
        }
        while (v69);
      }
    }
    else
    {
      float v72 = v96;
      uint64_t v73 = v93;
      if (a5 >= 1)
      {
        do
        {
          uint64_t v74 = *v72;
          v72 += 2;
          uint64_t v75 = &v65[v74];
          if (v63 < &v65[v74]) {
            uint64_t v75 = v63;
          }
          if ((unint64_t)v75 < *(void *)(v94 + 32)) {
            uint64_t v75 = *(char **)(v94 + 32);
          }
          int v76 = *(_DWORD *)v75;
          unsigned int v77 = v76 | v8;
          if (v6 != 255)
          {
            uint64_t result = PDM_14621(v76 | v8, v6);
            unsigned int v77 = result;
          }
          if (HIBYTE(v77))
          {
            if (HIBYTE(v77) == 255) {
              *int v9 = v77;
            }
            else {
              uint64_t result = (unint64_t)DplusDM_14623(v9, v77, *v9, ~v77 >> 24);
            }
          }
          ++v9;
          --v73;
        }
        while (v73);
      }
    }
    uint64_t v11 = v87;
    v9 += v88;
    LOBYTE(v12) = v86;
    uint64_t v13 = v66 + v85;
    a6 = v67 - 1;
    a5 = v90;
  }
  while (v67 != 1);
  return result;
}

void argb32_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  int v343 = a3;
  uint64_t v350 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  uint64_t v337 = (int)v4;
  unint64_t v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  float v9 = *(float *)(a2 + 184);
  uint64_t v344 = *(int **)(a1 + 136);
  uint64_t v10 = *(void *)(a2 + 96);
  uint64_t v346 = *(void *)(a2 + 104);
  uint64_t v347 = v10;
  uint64_t v12 = *(int *)(a1 + 24);
  unint64_t v11 = *(int *)(a1 + 28);
  uint64_t v13 = *(int *)(a1 + 20);
  uint64_t v348 = (void *)*(int *)(a1 + 16);
  uint64_t v349 = v7;
  uint64_t v14 = *(int *)(a1 + 12);
  int v345 = *(_DWORD *)(a1 + 8);
  uint64_t v342 = (void *)a2;
  uint64_t v15 = *(int *)(a2 + 16);
  uint64_t v16 = (v15 + 6) * v5;
  if (v16 > 65439)
  {
    uint64_t v19 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x3023562EuLL);
    BOOL v18 = v19;
    uint64_t v21 = v19;
    uint64_t v22 = v342;
    if (!v19) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    BOOL v18 = (char *)&v332 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v17);
    uint64_t v21 = 0;
    uint64_t v22 = v342;
  }
  uint64_t v334 = v21;
  uint64_t v23 = a1;
  int v24 = (int)(float)((float)(v9 * 255.0) + 0.5);
  uint64_t v333 = v8 + (v12 - 1) * v11 + 4 * v13;
  unint64_t v25 = v11 >> 2;
  unint64_t v26 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v27 = v26 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v15) {
    uint64_t v28 = 4 * v5;
  }
  else {
    uint64_t v28 = 0;
  }
  unint64_t v29 = v27 + v28;
  v22[18] = v26;
  v22[19] = v27 + v28;
  v22[20] = v27;
  unint64_t v30 = v8 + 4 * (v14 + v25 * (void)v348);
  uint64_t v31 = v337;
  unint64_t v332 = v11 >> 2;
  uint64_t v341 = v25 - v337;
  uint64_t v32 = *(int *)(v23 + 104);
  int v33 = *(_DWORD *)(v23 + 108);
  uint64_t v339 = v23;
  int v34 = *(unsigned __int8 *)(v23 + 2);
  if (v34 == 6 || v34 == 1)
  {
    uint64_t v36 = v346;
    uint64_t v35 = v347;
    if (!v344) {
      goto LABEL_619;
    }
    int v37 = 0;
    int v38 = 0;
    uint64_t v39 = *(int *)(v339 + 124);
    uint64_t v40 = (unsigned __int8 *)v344 + v32 + (int)v39 * (uint64_t)v33;
    uint64_t v31 = v337;
    uint64_t v340 = v39 - v337;
    int v41 = v342;
    goto LABEL_25;
  }
  if (!v344)
  {
    uint64_t v40 = 0;
    int v37 = 0;
    uint64_t v340 = 0;
    int v38 = 0;
    int v41 = v342;
    uint64_t v36 = v346;
    uint64_t v35 = v347;
    goto LABEL_25;
  }
  shape_enum_clip_alloc((uint64_t)v19, v20, v344, 1, 1, 1, v32, v33, v4, v345);
  if (!v42) {
    goto LABEL_619;
  }
  int v37 = v42;
  int v38 = 0;
  uint64_t v43 = (int)((v15 * v5 + 15) & 0xFFFFFFF0);
  if (!v15) {
    uint64_t v43 = 4 * v5;
  }
  uint64_t v340 = -v337;
  uint64_t v40 = (unsigned __int8 *)(v29 + v43 + 16);
  int v41 = v342;
  uint64_t v36 = v346;
  uint64_t v35 = v347;
  while (1)
  {
    while (1)
    {
      int v44 = *((_DWORD *)v40 - 4);
      int v45 = v44 - v38;
      if (v44 > v38) {
        break;
      }
      if (v38 < *((_DWORD *)v40 - 3) + v44)
      {
        uint64_t v31 = v337;
LABEL_25:
        uint64_t v335 = -v31;
        uint64_t v336 = (v4 - 1) + 1;
        unint64_t v338 = v333 - 4;
        uint64_t v46 = v37;
LABEL_26:
        LODWORD(v344) = v38;
        int v37 = v46;
        long long v47 = (void (*)(void *, uint64_t, uint64_t, uint64_t))*v41;
        uint64_t v346 = v36;
        uint64_t v347 = v35;
        v47(v41, v35, v36, v4);
        uint64_t v48 = v41[20];
        char v49 = (unsigned char *)v41[18];
        unsigned int v51 = *((_DWORD *)v41 + 2);
        int v50 = *((_DWORD *)v41 + 3);
        uint64_t v348 = v37;
        if (v51 == v50)
        {
          if (v24 != 255)
          {
            int v52 = v4;
            long long v53 = v49;
            int v54 = v343;
            do
            {
              if (*v53) {
                *(_DWORD *)uint64_t v48 = PDM_14621(*(_DWORD *)v48, v24);
              }
              ++v53;
              v48 += 4;
              --v52;
            }
            while (v52);
            v48 += 4 * v335;
            v49 += v336 + v335;
LABEL_33:
            int v37 = v348;
            goto LABEL_73;
          }
        }
        else
        {
          uint64_t v55 = v41[19];
          if (v51 != 134755160)
          {
            int v57 = HIWORD(v51) & 0x3F;
            if (v57 == 16)
            {
              int v54 = v343;
              if (v50 == 134755208)
              {
                if (v24 == 255)
                {
                  uint64_t v307 = 0;
                  do
                  {
                    if (v49[v307]) {
                      *(_DWORD *)(v48 + 4 * v307) = HIDWORD(*(void *)(v55 + 8 * v307)) & 0xFF000000 | BYTE1(*(void *)(v55 + 8 * v307)) | (*(void *)(v55 + 8 * v307) >> 24) & 0xFF0000 | (BYTE3(*(void *)(v55 + 8 * v307)) << 8);
                    }
                    ++v307;
                  }
                  while (v4 != v307);
                }
                else
                {
                  uint64_t v75 = 0;
                  do
                  {
                    if (v49[v75]) {
                      *(_DWORD *)(v48 + 4 * v75) = PDM_14621(HIDWORD(*(void *)(v55 + 8 * v75)) & 0xFF000000 | BYTE1(*(void *)(v55 + 8 * v75)) | (*(void *)(v55 + 8 * v75) >> 24) & 0xFF0000 | (BYTE3(*(void *)(v55 + 8 * v75)) << 8), v24);
                    }
                    ++v75;
                  }
                  while (v4 != v75);
                }
              }
              else if (v24 == 255)
              {
                uint64_t v320 = 0;
                do
                {
                  if (v49[v320]) {
                    *(_DWORD *)(v48 + 4 * v320) = ((unsigned __int16)WORD2(*(void *)(v55 + 8 * v320)) >> 8) | HIDWORD(*(void *)(v55 + 8 * v320)) & 0xFF000000 | (BYTE1(*(void *)(v55 + 8 * v320)) << 16) | (BYTE3(*(void *)(v55 + 8 * v320)) << 8);
                  }
                  ++v320;
                }
                while (v4 != v320);
              }
              else
              {
                uint64_t v88 = 0;
                do
                {
                  if (v49[v88]) {
                    *(_DWORD *)(v48 + 4 * v88) = PDM_14621(((unsigned __int16)WORD2(*(void *)(v55 + 8 * v88)) >> 8) | HIDWORD(*(void *)(v55 + 8 * v88)) & 0xFF000000 | (BYTE1(*(void *)(v55 + 8 * v88)) << 16) | (BYTE3(*(void *)(v55 + 8 * v88)) << 8), v24);
                  }
                  ++v88;
                }
                while (v4 != v88);
              }
              goto LABEL_33;
            }
            int v54 = v343;
            if (v57 != 32)
            {
              if (v50 == 134755208)
              {
                if (v24 == 255)
                {
                  uint64_t v308 = 0;
                  do
                  {
                    if (v49[v308]) {
                      *(_DWORD *)(v48 + 4 * v308) = bswap32(*(_DWORD *)(v55 + 4 * v308));
                    }
                    ++v308;
                  }
                  while (v4 != v308);
                }
                else
                {
                  uint64_t v76 = 0;
                  do
                  {
                    if (v49[v76]) {
                      *(_DWORD *)(v48 + 4 * v76) = PDM_14621(bswap32(*(_DWORD *)(v55 + 4 * v76)), v24);
                    }
                    ++v76;
                  }
                  while (v4 != v76);
                }
              }
              else if (v24 == 255)
              {
                uint64_t v321 = 0;
                do
                {
                  if (v49[v321])
                  {
                    HIDWORD(v322) = *(_DWORD *)(v55 + 4 * v321);
                    LODWORD(v322) = HIDWORD(v322);
                    *(_DWORD *)(v48 + 4 * v321) = v322 >> 8;
                  }
                  ++v321;
                }
                while (v4 != v321);
              }
              else
              {
                uint64_t v89 = 0;
                do
                {
                  if (v49[v89])
                  {
                    HIDWORD(v90) = *(_DWORD *)(v55 + 4 * v89);
                    LODWORD(v90) = HIDWORD(v90);
                    *(_DWORD *)(v48 + 4 * v89) = PDM_14621(v90 >> 8, v24);
                  }
                  ++v89;
                }
                while (v4 != v89);
              }
              goto LABEL_33;
            }
            if (v50 == 134755208)
            {
              if (v24 != 255)
              {
                uint64_t v58 = 0;
                unsigned int v59 = (float *)(v55 + 8);
                do
                {
                  if (v49[v58])
                  {
                    float v60 = v59[1];
                    if (v60 <= 0.0)
                    {
                      int v68 = 0;
                    }
                    else
                    {
                      float v61 = *(v59 - 2);
                      float v62 = *(v59 - 1);
                      float v63 = *v59;
                      int v64 = (int)(float)((float)(v60 * 255.0) + 0.5);
                      if (v60 > 1.0)
                      {
                        int v64 = 255;
                        float v60 = 1.0;
                      }
                      int v65 = (int)(float)((float)(v61 * 255.0) + 0.5);
                      if (v61 < 0.0) {
                        int v65 = 0;
                      }
                      if (v61 > v60) {
                        int v65 = v64;
                      }
                      int v66 = (int)(float)((float)(v62 * 255.0) + 0.5);
                      if (v62 < 0.0) {
                        int v66 = 0;
                      }
                      if (v62 > v60) {
                        int v66 = v64;
                      }
                      int v67 = (int)(float)((float)(v63 * 255.0) + 0.5);
                      if (v63 < 0.0) {
                        int v67 = 0;
                      }
                      if (v63 > v60) {
                        int v67 = v64;
                      }
                      int v68 = PDM_14621(v65 | (v64 << 24) | (v66 << 8) | (v67 << 16), v24);
                    }
                    *(_DWORD *)(v48 + 4 * v58) = v68;
                  }
                  ++v58;
                  v59 += 4;
                }
                while (v4 != v58);
                goto LABEL_33;
              }
              uint64_t v296 = 0;
              uint64_t v297 = (float *)(v55 + 8);
              int v37 = v348;
              do
              {
                if (v49[v296])
                {
                  float v298 = v297[1];
                  if (v298 <= 0.0)
                  {
                    int v306 = 0;
                  }
                  else
                  {
                    float v299 = *(v297 - 2);
                    float v300 = *(v297 - 1);
                    float v301 = *v297;
                    int v302 = (int)(float)((float)(v298 * 255.0) + 0.5);
                    if (v298 > 1.0)
                    {
                      int v302 = 255;
                      float v298 = 1.0;
                    }
                    int v303 = (int)(float)((float)(v299 * 255.0) + 0.5);
                    if (v299 < 0.0) {
                      int v303 = 0;
                    }
                    if (v299 > v298) {
                      int v303 = v302;
                    }
                    int v304 = (int)(float)((float)(v300 * 255.0) + 0.5);
                    if (v300 < 0.0) {
                      int v304 = 0;
                    }
                    if (v300 > v298) {
                      int v304 = v302;
                    }
                    int v305 = (int)(float)((float)(v301 * 255.0) + 0.5);
                    if (v301 < 0.0) {
                      int v305 = 0;
                    }
                    if (v301 > v298) {
                      int v305 = v302;
                    }
                    int v306 = v303 | (v302 << 24) | (v304 << 8) | (v305 << 16);
                  }
                  *(_DWORD *)(v48 + 4 * v296) = v306;
                }
                ++v296;
                v297 += 4;
              }
              while (v4 != v296);
            }
            else
            {
              if (v24 != 255)
              {
                uint64_t v77 = 0;
                uint64_t v78 = (float *)(v55 + 8);
                do
                {
                  if (v49[v77])
                  {
                    float v79 = v78[1];
                    if (v79 <= 0.0)
                    {
                      int v87 = 0;
                    }
                    else
                    {
                      float v80 = *(v78 - 2);
                      float v81 = *(v78 - 1);
                      float v82 = *v78;
                      int v83 = (int)(float)((float)(v79 * 255.0) + 0.5);
                      if (v79 > 1.0)
                      {
                        int v83 = 255;
                        float v79 = 1.0;
                      }
                      int v84 = (int)(float)((float)(v80 * 255.0) + 0.5);
                      if (v80 < 0.0) {
                        int v84 = 0;
                      }
                      if (v80 > v79) {
                        int v84 = v83;
                      }
                      int v85 = (int)(float)((float)(v81 * 255.0) + 0.5);
                      if (v81 < 0.0) {
                        int v85 = 0;
                      }
                      if (v81 > v79) {
                        int v85 = v83;
                      }
                      int v86 = (int)(float)((float)(v82 * 255.0) + 0.5);
                      if (v82 < 0.0) {
                        int v86 = 0;
                      }
                      if (v82 > v79) {
                        int v86 = v83;
                      }
                      int v87 = PDM_14621((v84 << 16) | (v83 << 24) | (v85 << 8) | v86, v24);
                    }
                    *(_DWORD *)(v48 + 4 * v77) = v87;
                  }
                  ++v77;
                  v78 += 4;
                }
                while (v4 != v77);
                goto LABEL_33;
              }
              uint64_t v309 = 0;
              uint64_t v310 = (float *)(v55 + 8);
              int v37 = v348;
              do
              {
                if (v49[v309])
                {
                  float v311 = v310[1];
                  if (v311 <= 0.0)
                  {
                    int v319 = 0;
                  }
                  else
                  {
                    float v312 = *(v310 - 2);
                    float v313 = *(v310 - 1);
                    float v314 = *v310;
                    int v315 = (int)(float)((float)(v311 * 255.0) + 0.5);
                    if (v311 > 1.0)
                    {
                      float v311 = 1.0;
                      int v315 = 255;
                    }
                    int v316 = (int)(float)((float)(v312 * 255.0) + 0.5);
                    if (v312 < 0.0) {
                      int v316 = 0;
                    }
                    if (v312 > v311) {
                      int v316 = v315;
                    }
                    int v317 = (int)(float)((float)(v313 * 255.0) + 0.5);
                    if (v313 < 0.0) {
                      int v317 = 0;
                    }
                    if (v313 > v311) {
                      int v317 = v315;
                    }
                    int v318 = (int)(float)((float)(v314 * 255.0) + 0.5);
                    if (v314 < 0.0) {
                      int v318 = 0;
                    }
                    if (v314 > v311) {
                      int v318 = v315;
                    }
                    int v319 = (v316 << 16) | (v315 << 24) | (v317 << 8) | v318;
                  }
                  *(_DWORD *)(v48 + 4 * v309) = v319;
                }
                ++v309;
                v310 += 4;
              }
              while (v4 != v309);
            }
LABEL_73:
            switch(v54)
            {
              case 0:
                int v70 = v4;
                float32x2_t v71 = v40;
                do
                {
                  unsigned int v72 = *v49;
                  if (*v49)
                  {
                    if (v40) {
                      unsigned int v72 = (*v71 * v72 + ((*v71 * v72) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v72)
                    {
                      if (v72 == 255) {
                        int v73 = 0;
                      }
                      else {
                        int v73 = PDM_14621(*(_DWORD *)v30, ~(_BYTE)v72);
                      }
                      *(_DWORD *)unint64_t v30 = v73;
                    }
                  }
                  ++v49;
                  v71 += v40 != 0;
                  v30 += 4;
                  --v70;
                }
                while (v70);
                uint64_t v40 = &v71[v340];
                uint64_t v74 = v341;
                goto LABEL_522;
              case 1:
                unsigned __int8 v91 = *v49;
                int v92 = v49 + 1;
                if (v40)
                {
                  int v93 = v4;
                  do
                  {
                    if (v91)
                    {
                      unsigned int v94 = *v40 * v91 + ((*v40 * v91) >> 8) + 1;
                      uint64_t v95 = (unsigned int *)v338;
                      if (v338 >= v30) {
                        uint64_t v95 = (unsigned int *)v30;
                      }
                      if ((unint64_t)v95 >= *(void *)(v339 + 40)) {
                        float64x2_t v96 = v95;
                      }
                      else {
                        float64x2_t v96 = *(unsigned int **)(v339 + 40);
                      }
                      if (BYTE1(v94))
                      {
                        if (BYTE1(v94) == 255) {
                          *float64x2_t v96 = *(_DWORD *)v48;
                        }
                        else {
                          DMplusDM_14622(v96, *(_DWORD *)v48, BYTE1(v94), *v96, ~(v94 >> 8));
                        }
                      }
                    }
                    else
                    {
                      float64x2_t v96 = (unsigned int *)v30;
                    }
                    unsigned __int8 v97 = *v92++;
                    unsigned __int8 v91 = v97;
                    v48 += 4;
                    ++v40;
                    unint64_t v30 = (unint64_t)(v96 + 1);
                    --v93;
                  }
                  while (v93);
                  v40 += v340;
                  int v37 = v348;
                }
                else
                {
                  int v323 = v4;
                  do
                  {
                    uint64_t v324 = (unsigned int *)v338;
                    if (v338 >= v30) {
                      uint64_t v324 = (unsigned int *)v30;
                    }
                    if ((unint64_t)v324 >= *(void *)(v339 + 40)) {
                      float64x2_t v96 = v324;
                    }
                    else {
                      float64x2_t v96 = *(unsigned int **)(v339 + 40);
                    }
                    if (v91)
                    {
                      if (v91 == 255) {
                        *float64x2_t v96 = *(_DWORD *)v48;
                      }
                      else {
                        DMplusDM_14622(v96, *(_DWORD *)v48, v91, *v96, ~v91);
                      }
                    }
                    unsigned __int8 v325 = *v92++;
                    unsigned __int8 v91 = v325;
                    v48 += 4;
                    unint64_t v30 = (unint64_t)(v96 + 1);
                    --v323;
                  }
                  while (v323);
                  uint64_t v40 = 0;
                }
                unint64_t v30 = (unint64_t)&v96[v341 + 1];
                goto LABEL_604;
              case 2:
                unsigned __int8 v98 = *v49;
                if (v40)
                {
                  float64x2_t v99 = v49 + 1;
                  int v100 = v4;
                  while (1)
                  {
                    unint64_t v101 = v30;
                    if (!v98) {
                      goto LABEL_160;
                    }
                    unsigned int v102 = *v40 * v98 + ((*v40 * v98) >> 8) + 1;
                    if (!BYTE1(v102)) {
                      goto LABEL_160;
                    }
                    if (BYTE1(v102) == 255)
                    {
                      unsigned int v103 = *(_DWORD *)v48;
                      int v104 = HIBYTE(*(_DWORD *)v48);
                      if (v104)
                      {
                        if (v104 != 255) {
                          goto LABEL_159;
                        }
                        *(_DWORD *)unint64_t v30 = v103;
                      }
                    }
                    else
                    {
                      unsigned int v105 = PDM_14621(*(_DWORD *)v48, BYTE1(v102));
                      if (HIBYTE(v105))
                      {
                        unsigned int v103 = v105;
LABEL_159:
                        DplusDM_14623((_DWORD *)v30, v103, *(_DWORD *)v30, ~v103 >> 24);
                      }
                    }
LABEL_160:
                    unsigned __int8 v106 = *v99++;
                    unsigned __int8 v98 = v106;
                    v48 += 4;
                    ++v40;
                    v30 += 4;
                    if (!--v100)
                    {
                      v40 += v340;
                      int v41 = v342;
                      goto LABEL_616;
                    }
                  }
                }
                uint64_t v326 = v49 + 1;
                int v327 = v4;
                do
                {
                  if (!v98) {
                    goto LABEL_614;
                  }
                  if (v98 == 255)
                  {
                    unsigned int v328 = *(_DWORD *)v48;
                    int v329 = HIBYTE(*(_DWORD *)v48);
                    if (!v329) {
                      goto LABEL_614;
                    }
                    if (v329 == 255)
                    {
                      *(_DWORD *)unint64_t v30 = v328;
                      goto LABEL_614;
                    }
                  }
                  else
                  {
                    unsigned int v330 = PDM_14621(*(_DWORD *)v48, v98);
                    if (!HIBYTE(v330)) {
                      goto LABEL_614;
                    }
                    unsigned int v328 = v330;
                  }
                  DplusDM_14623((_DWORD *)v30, v328, *(_DWORD *)v30, ~v328 >> 24);
LABEL_614:
                  unsigned __int8 v331 = *v326++;
                  unsigned __int8 v98 = v331;
                  v48 += 4;
                  v30 += 4;
                  --v327;
                }
                while (v327);
                uint64_t v40 = 0;
                unint64_t v101 = v30 - 4;
LABEL_616:
                unint64_t v30 = v101 + 4 * v341 + 4;
LABEL_523:
                uint64_t v295 = v346;
                uint64_t v294 = v347;
                int v37 = v348;
LABEL_524:
                if (!--v345) {
                  goto LABEL_617;
                }
                uint64_t v46 = 0;
                int v38 = v344 + 1;
                uint64_t v35 = v41[16] + v294;
                uint64_t v36 = v41[17] + v295;
                if (v37) {
                  continue;
                }
                goto LABEL_26;
              case 3:
                int v107 = v4;
                long long v108 = v40;
                do
                {
                  unsigned int v109 = *v49;
                  if (*v49)
                  {
                    if (v40) {
                      unsigned int v109 = (*v108 * v109 + ((*v108 * v109) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v109)
                    {
                      if (v109 == 255) {
                        *(_DWORD *)unint64_t v30 = PDM_14621(*(_DWORD *)v48, *(unsigned __int8 *)(v30 + 3));
                      }
                      else {
                        DMplusDM_14622((unsigned int *)v30, *(_DWORD *)v48, (unsigned __int16)(HIBYTE(*(_DWORD *)v30) * v109+ 128+ ((HIBYTE(*(_DWORD *)v30) * v109 + 128) >> 8)) >> 8, *(_DWORD *)v30, ~(_BYTE)v109);
                      }
                    }
                  }
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  --v107;
                }
                while (v107);
                goto LABEL_520;
              case 4:
                int v110 = v4;
                long long v108 = v40;
                do
                {
                  unsigned int v111 = *v49;
                  if (*v49)
                  {
                    if (v40) {
                      unsigned int v111 = (*v108 * v111 + ((*v108 * v111) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v111)
                    {
                      if (v111 == 255)
                      {
                        *(_DWORD *)unint64_t v30 = PDM_14621(*(_DWORD *)v48, *(unsigned __int8 *)(v30 + 3) ^ 0xFFu);
                      }
                      else
                      {
                        unsigned int v112 = (~*(_DWORD *)v30 >> 24) * v111 + 128;
                        DMplusDM_14622((unsigned int *)v30, *(_DWORD *)v48, (unsigned __int16)(v112 + (v112 >> 8)) >> 8, *(_DWORD *)v30, ~(_BYTE)v111);
                      }
                    }
                  }
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  --v110;
                }
                while (v110);
                goto LABEL_520;
              case 5:
                int v113 = v4;
                long long v108 = v40;
                while (1)
                {
                  unsigned int v114 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_187;
                    }
                    unsigned int v115 = *v108 * v114 + ((*v108 * v114) >> 8) + 1;
                    if (BYTE1(v115)) {
                      break;
                    }
                  }
LABEL_188:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v113) {
                    goto LABEL_520;
                  }
                }
                unsigned int v114 = v115 >> 8;
LABEL_187:
                unsigned int v116 = PDM_14621(*(_DWORD *)v48, v114);
                DMplusDM_14622((unsigned int *)v30, v116, HIBYTE(*(_DWORD *)v30), *(_DWORD *)v30, ~v116 >> 24);
                goto LABEL_188;
              case 6:
                int v117 = v4;
                long long v108 = v40;
                while (1)
                {
                  unsigned int v118 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_195;
                    }
                    unsigned int v119 = *v108 * v118 + ((*v108 * v118) >> 8) + 1;
                    if (BYTE1(v119)) {
                      break;
                    }
                  }
LABEL_199:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v117) {
                    goto LABEL_520;
                  }
                }
                unsigned int v118 = v119 >> 8;
LABEL_195:
                if (~HIBYTE(*(_DWORD *)v30))
                {
                  if (~HIBYTE(*(_DWORD *)v30) == 255) {
                    *(_DWORD *)unint64_t v30 = PDM_14621(*(_DWORD *)v48, v118);
                  }
                  else {
                    DplusDM_14623((_DWORD *)v30, *(_DWORD *)v30, *(_DWORD *)v48, (unsigned __int16)(~HIBYTE(*(_DWORD *)v30) * v118+ 128+ ((~HIBYTE(*(_DWORD *)v30)* v118+ 128) >> 8)) >> 8);
                  }
                }
                goto LABEL_199;
              case 7:
                int v120 = v4;
                long long v108 = v40;
                do
                {
                  unsigned int v121 = *v49;
                  if (*v49)
                  {
                    if (v40) {
                      unsigned int v121 = (*v108 * v121 + ((*v108 * v121) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v121)
                    {
                      if (v121 == 255)
                      {
                        *(_DWORD *)unint64_t v30 = PDM_14621(*(_DWORD *)v30, *(unsigned __int8 *)(v48 + 3));
                      }
                      else
                      {
                        unsigned int v122 = *(unsigned __int8 *)(v48 + 3) * v121 + 128;
                        DMplusDM_14622((unsigned int *)v30, *(_DWORD *)v30, (unsigned __int16)(v122 + (v122 >> 8)) >> 8, *(_DWORD *)v30, ~(_BYTE)v121);
                      }
                    }
                  }
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  --v120;
                }
                while (v120);
                goto LABEL_520;
              case 8:
                int v123 = v4;
                long long v108 = v40;
                do
                {
                  unsigned int v124 = *v49;
                  if (*v49)
                  {
                    if (v40) {
                      unsigned int v124 = (*v108 * v124 + ((*v108 * v124) >> 8) + 1) >> 8;
                    }
                    if ((_BYTE)v124)
                    {
                      if (v124 == 255)
                      {
                        *(_DWORD *)unint64_t v30 = PDM_14621(*(_DWORD *)v30, *(unsigned __int8 *)(v48 + 3) ^ 0xFFu);
                      }
                      else
                      {
                        unsigned int v125 = (~*(_DWORD *)v48 >> 24) * v124 + 128;
                        DMplusDM_14622((unsigned int *)v30, *(_DWORD *)v30, (unsigned __int16)(v125 + (v125 >> 8)) >> 8, *(_DWORD *)v30, ~(_BYTE)v124);
                      }
                    }
                  }
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  --v123;
                }
                while (v123);
                goto LABEL_520;
              case 9:
                int v126 = v4;
                long long v108 = v40;
                while (1)
                {
                  unsigned int v127 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_226;
                    }
                    unsigned int v128 = *v108 * v127 + ((*v108 * v127) >> 8) + 1;
                    if (BYTE1(v128)) {
                      break;
                    }
                  }
LABEL_227:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v126) {
                    goto LABEL_520;
                  }
                }
                unsigned int v127 = v128 >> 8;
LABEL_226:
                unsigned int v129 = PDM_14621(*(_DWORD *)v48, v127);
                DMplusDM_14622((unsigned int *)v30, v129, ~*(_DWORD *)v30 >> 24, *(_DWORD *)v30, (~(_BYTE)v127 + HIBYTE(v129)));
                goto LABEL_227;
              case 10:
                int v130 = v4;
                long long v108 = v40;
                while (1)
                {
                  unsigned int v131 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_234;
                    }
                    unsigned int v132 = *v108 * v131 + ((*v108 * v131) >> 8) + 1;
                    if (BYTE1(v132)) {
                      break;
                    }
                  }
LABEL_235:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v130) {
                    goto LABEL_520;
                  }
                }
                unsigned int v131 = v132 >> 8;
LABEL_234:
                unsigned int v133 = PDM_14621(*(_DWORD *)v48, v131);
                DMplusDM_14622((unsigned int *)v30, v133, ~*(_DWORD *)v30 >> 24, *(_DWORD *)v30, ~v133 >> 24);
                goto LABEL_235;
              case 11:
                int v134 = v4;
                long long v108 = v40;
                while (1)
                {
                  unsigned int v135 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_242;
                    }
                    unsigned int v136 = *v108 * v135 + ((*v108 * v135) >> 8) + 1;
                    if (BYTE1(v136)) {
                      break;
                    }
                  }
LABEL_245:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v134) {
                    goto LABEL_520;
                  }
                }
                unsigned int v135 = v136 >> 8;
LABEL_242:
                unsigned int v137 = PDM_14621(*(_DWORD *)v48, v135);
                int v138 = HIBYTE(*(_DWORD *)v30);
                if (!v349) {
                  LOBYTE(v138) = -1;
                }
                DAplusdDA_14624((_DWORD *)v30, *(_DWORD *)v30, v138, v137, HIBYTE(v137));
                goto LABEL_245;
              case 12:
                int v139 = v4;
                double v140 = v40;
                while (1)
                {
                  unsigned int v141 = *v49;
                  if (*v49)
                  {
                    if (!v40) {
                      goto LABEL_252;
                    }
                    unsigned int v142 = *v140 * v141 + ((*v140 * v141) >> 8) + 1;
                    if (BYTE1(v142)) {
                      break;
                    }
                  }
LABEL_253:
                  ++v49;
                  v48 += 4;
                  v140 += v40 != 0;
                  v30 += 4;
                  if (!--v139)
                  {
                    uint64_t v40 = &v140[v340];
                    goto LABEL_521;
                  }
                }
                unsigned int v141 = v142 >> 8;
LABEL_252:
                unsigned int v143 = PDM_14621(*(_DWORD *)v48, v141);
                int v144 = ((*(_DWORD *)v30 >> 8) & 0xFF00FF) + ((v143 >> 8) & 0xFF00FF);
                *(_DWORD *)unint64_t v30 = (v144 << 8) & 0xFF00FF00 | ((*(_DWORD *)v30 & 0xFF00FF) + (v143 & 0xFF00FF)) & 0xFF00FF | (15 * (v144 & 0x1000100 | (((*(_DWORD *)v30 & 0xFF00FF) + (v143 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v144 & 0x1000100 | (((*(_DWORD *)v30 & 0xFF00FF) + (v143 & 0xFF00FF)) >> 8) & 0x10001));
                goto LABEL_253;
              case 13:
                int v145 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v147 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v148 = *v146 * v147 + ((*v146 * v147) >> 8) + 1;
                      if (!BYTE1(v148)) {
                        goto LABEL_267;
                      }
                      unsigned int v147 = v148 >> 8;
                    }
                    unsigned int v149 = PDM_14621(*(_DWORD *)v48, v147);
                    int v150 = HIBYTE(v149);
                    if (HIBYTE(v149))
                    {
                      int v151 = v149;
                      unsigned int v152 = *(_DWORD *)v30;
                      if (v349)
                      {
                        int v153 = HIBYTE(v152);
                        if (!HIBYTE(v152)) {
                          goto LABEL_266;
                        }
                      }
                      else
                      {
                        int v153 = 255;
                      }
                      int v151 = PDAmultiplyPDA_14625(v152, v153, v151, v150);
LABEL_266:
                      *(_DWORD *)unint64_t v30 = v151;
                    }
                  }
LABEL_267:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v145) {
                    goto LABEL_338;
                  }
                }
              case 14:
                int v154 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v155 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v156 = *v146 * v155 + ((*v146 * v155) >> 8) + 1;
                      if (!BYTE1(v156)) {
                        goto LABEL_281;
                      }
                      unsigned int v155 = v156 >> 8;
                    }
                    unsigned int v157 = PDM_14621(*(_DWORD *)v48, v155);
                    int v158 = HIBYTE(v157);
                    if (HIBYTE(v157))
                    {
                      int v159 = v157;
                      unsigned int v160 = *(_DWORD *)v30;
                      if (v349)
                      {
                        int v161 = HIBYTE(v160);
                        if (!HIBYTE(v160)) {
                          goto LABEL_280;
                        }
                      }
                      else
                      {
                        int v161 = 255;
                      }
                      int v159 = PDAscreenPDA_14626(v160, v161, v159, v158);
LABEL_280:
                      *(_DWORD *)unint64_t v30 = v159;
                    }
                  }
LABEL_281:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v154) {
                    goto LABEL_338;
                  }
                }
              case 15:
                int v162 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v163 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v164 = *v146 * v163 + ((*v146 * v163) >> 8) + 1;
                      if (!BYTE1(v164)) {
                        goto LABEL_295;
                      }
                      unsigned int v163 = v164 >> 8;
                    }
                    unsigned int v165 = PDM_14621(*(_DWORD *)v48, v163);
                    unsigned int v166 = HIBYTE(v165);
                    if (HIBYTE(v165))
                    {
                      int v167 = v165;
                      unsigned int v168 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v169 = HIBYTE(v168);
                        if (!HIBYTE(v168)) {
                          goto LABEL_294;
                        }
                      }
                      else
                      {
                        unsigned int v169 = 255;
                      }
                      int v167 = PDAoverlayPDA_14627(v168, v169, v167, v166);
LABEL_294:
                      *(_DWORD *)unint64_t v30 = v167;
                    }
                  }
LABEL_295:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v162) {
                    goto LABEL_338;
                  }
                }
              case 16:
                int v170 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v171 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v172 = *v146 * v171 + ((*v146 * v171) >> 8) + 1;
                      if (!BYTE1(v172)) {
                        goto LABEL_309;
                      }
                      unsigned int v171 = v172 >> 8;
                    }
                    unsigned int v173 = PDM_14621(*(_DWORD *)v48, v171);
                    unsigned int v174 = HIBYTE(v173);
                    if (HIBYTE(v173))
                    {
                      unsigned int v175 = v173;
                      unsigned int v176 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v177 = HIBYTE(v176);
                        if (!HIBYTE(v176)) {
                          goto LABEL_308;
                        }
                      }
                      else
                      {
                        unsigned int v177 = 255;
                      }
                      unsigned int v175 = PDAdarkenPDA_14629(v176, v177, v175, v174);
LABEL_308:
                      *(_DWORD *)unint64_t v30 = v175;
                    }
                  }
LABEL_309:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v170) {
                    goto LABEL_338;
                  }
                }
              case 17:
                int v178 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v179 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v180 = *v146 * v179 + ((*v146 * v179) >> 8) + 1;
                      if (!BYTE1(v180)) {
                        goto LABEL_323;
                      }
                      unsigned int v179 = v180 >> 8;
                    }
                    unsigned int v181 = PDM_14621(*(_DWORD *)v48, v179);
                    unsigned int v182 = HIBYTE(v181);
                    if (HIBYTE(v181))
                    {
                      unsigned int v183 = v181;
                      unsigned int v184 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v185 = HIBYTE(v184);
                        if (!HIBYTE(v184)) {
                          goto LABEL_322;
                        }
                      }
                      else
                      {
                        unsigned int v185 = 255;
                      }
                      unsigned int v183 = PDAlightenPDA_14628(v184, v185, v183, v182);
LABEL_322:
                      *(_DWORD *)unint64_t v30 = v183;
                    }
                  }
LABEL_323:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v178) {
                    goto LABEL_338;
                  }
                }
              case 18:
                int v186 = v4;
                double v146 = v40;
                while (1)
                {
                  unsigned int v187 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v188 = *v146 * v187 + ((*v146 * v187) >> 8) + 1;
                      if (!BYTE1(v188)) {
                        goto LABEL_337;
                      }
                      unsigned int v187 = v188 >> 8;
                    }
                    unsigned int v189 = PDM_14621(*(_DWORD *)v48, v187);
                    unsigned int v190 = HIBYTE(v189);
                    if (HIBYTE(v189))
                    {
                      int v191 = v189;
                      unsigned int v192 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v193 = HIBYTE(v192);
                        if (!HIBYTE(v192)) {
                          goto LABEL_336;
                        }
                      }
                      else
                      {
                        unsigned int v193 = 255;
                      }
                      int v191 = PDAcolordodgePDA_14630(v192, v193, v191, v190);
LABEL_336:
                      *(_DWORD *)unint64_t v30 = v191;
                    }
                  }
LABEL_337:
                  ++v49;
                  v48 += 4;
                  v146 += v40 != 0;
                  v30 += 4;
                  if (!--v186)
                  {
LABEL_338:
                    uint64_t v40 = &v146[v340];
                    goto LABEL_521;
                  }
                }
              case 19:
                long long v108 = v40;
                int v194 = v4;
                while (1)
                {
                  unsigned int v195 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v196 = *v108 * v195 + ((*v108 * v195) >> 8) + 1;
                      if (!BYTE1(v196)) {
                        goto LABEL_351;
                      }
                      unsigned int v195 = v196 >> 8;
                    }
                    unsigned int v197 = PDM_14621(*(_DWORD *)v48, v195);
                    unsigned int v198 = HIBYTE(v197);
                    if (HIBYTE(v197))
                    {
                      int v199 = v197;
                      unsigned int v200 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v201 = HIBYTE(v200);
                        if (!HIBYTE(v200)) {
                          goto LABEL_350;
                        }
                      }
                      else
                      {
                        unsigned int v201 = 255;
                      }
                      int v199 = PDAcolorburnPDA_14631(v200, v201, v199, v198);
LABEL_350:
                      *(_DWORD *)unint64_t v30 = v199;
                    }
                  }
LABEL_351:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v194) {
                    goto LABEL_520;
                  }
                }
              case 20:
                long long v108 = v40;
                int v202 = v4;
                while (1)
                {
                  unsigned int v203 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v204 = *v108 * v203 + ((*v108 * v203) >> 8) + 1;
                      if (!BYTE1(v204)) {
                        goto LABEL_365;
                      }
                      unsigned int v203 = v204 >> 8;
                    }
                    unsigned int v205 = PDM_14621(*(_DWORD *)v48, v203);
                    unsigned int v206 = HIBYTE(v205);
                    if (HIBYTE(v205))
                    {
                      int v207 = v205;
                      unsigned int v208 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v209 = HIBYTE(v208);
                        if (!HIBYTE(v208)) {
                          goto LABEL_364;
                        }
                      }
                      else
                      {
                        unsigned int v209 = 255;
                      }
                      int v207 = PDAsoftlightPDA_14633(v208, v209, v207, v206);
LABEL_364:
                      *(_DWORD *)unint64_t v30 = v207;
                    }
                  }
LABEL_365:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v202) {
                    goto LABEL_520;
                  }
                }
              case 21:
                long long v108 = v40;
                int v210 = v4;
                while (1)
                {
                  unsigned int v211 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v212 = *v108 * v211 + ((*v108 * v211) >> 8) + 1;
                      if (!BYTE1(v212)) {
                        goto LABEL_379;
                      }
                      unsigned int v211 = v212 >> 8;
                    }
                    unsigned int v213 = PDM_14621(*(_DWORD *)v48, v211);
                    unsigned int v214 = HIBYTE(v213);
                    if (HIBYTE(v213))
                    {
                      int v215 = v213;
                      unsigned int v216 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v217 = HIBYTE(v216);
                        if (!HIBYTE(v216)) {
                          goto LABEL_378;
                        }
                      }
                      else
                      {
                        unsigned int v217 = 255;
                      }
                      int v215 = PDAhardlightPDA_14632(v216, v217, v215, v214);
LABEL_378:
                      *(_DWORD *)unint64_t v30 = v215;
                    }
                  }
LABEL_379:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v210) {
                    goto LABEL_520;
                  }
                }
              case 22:
                long long v108 = v40;
                int v218 = v4;
                while (1)
                {
                  unsigned int v219 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v220 = *v108 * v219 + ((*v108 * v219) >> 8) + 1;
                      if (!BYTE1(v220)) {
                        goto LABEL_393;
                      }
                      unsigned int v219 = v220 >> 8;
                    }
                    unsigned __int32 v221 = PDM_14621(*(_DWORD *)v48, v219);
                    unsigned int v222 = HIBYTE(v221);
                    if (HIBYTE(v221))
                    {
                      unsigned __int32 v223 = v221;
                      unsigned __int32 v224 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v225 = HIBYTE(v224);
                        if (!HIBYTE(v224)) {
                          goto LABEL_392;
                        }
                      }
                      else
                      {
                        unsigned int v225 = 255;
                      }
                      unsigned __int32 v223 = PDAdifferencePDA_14634(v224, v225, v223, v222);
LABEL_392:
                      *(_DWORD *)unint64_t v30 = v223;
                    }
                  }
LABEL_393:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v218) {
                    goto LABEL_520;
                  }
                }
              case 23:
                long long v108 = v40;
                int v226 = v4;
                while (1)
                {
                  unsigned int v227 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v228 = *v108 * v227 + ((*v108 * v227) >> 8) + 1;
                      if (!BYTE1(v228)) {
                        goto LABEL_407;
                      }
                      unsigned int v227 = v228 >> 8;
                    }
                    unsigned int v229 = PDM_14621(*(_DWORD *)v48, v227);
                    unsigned int v230 = HIBYTE(v229);
                    if (HIBYTE(v229))
                    {
                      int v231 = v229;
                      unsigned int v232 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v233 = HIBYTE(v232);
                        if (!HIBYTE(v232)) {
                          goto LABEL_406;
                        }
                      }
                      else
                      {
                        unsigned int v233 = 255;
                      }
                      int v231 = PDAexclusionPDA_14635(v232, v233, v231, v230);
LABEL_406:
                      *(_DWORD *)unint64_t v30 = v231;
                    }
                  }
LABEL_407:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v226) {
                    goto LABEL_520;
                  }
                }
              case 24:
                long long v108 = v40;
                int v234 = v4;
                while (1)
                {
                  unsigned int v235 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v236 = *v108 * v235 + ((*v108 * v235) >> 8) + 1;
                      if (!BYTE1(v236)) {
                        goto LABEL_421;
                      }
                      unsigned int v235 = v236 >> 8;
                    }
                    unsigned int v237 = PDM_14621(*(_DWORD *)v48, v235);
                    unsigned int v238 = HIBYTE(v237);
                    if (HIBYTE(v237))
                    {
                      int v239 = v237;
                      unsigned int v240 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v241 = HIBYTE(v240);
                        if (!HIBYTE(v240)) {
                          goto LABEL_420;
                        }
                      }
                      else
                      {
                        unsigned int v241 = 255;
                      }
                      int v239 = PDAhuePDA_14636(v240, v241, v239, v238);
LABEL_420:
                      *(_DWORD *)unint64_t v30 = v239;
                    }
                  }
LABEL_421:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v234) {
                    goto LABEL_520;
                  }
                }
              case 25:
                long long v108 = v40;
                int v242 = v4;
                while (1)
                {
                  unsigned int v243 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v244 = *v108 * v243 + ((*v108 * v243) >> 8) + 1;
                      if (!BYTE1(v244)) {
                        goto LABEL_435;
                      }
                      unsigned int v243 = v244 >> 8;
                    }
                    unsigned int v245 = PDM_14621(*(_DWORD *)v48, v243);
                    unsigned int v246 = HIBYTE(v245);
                    if (HIBYTE(v245))
                    {
                      int v247 = v245;
                      unsigned int v248 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v249 = HIBYTE(v248);
                        if (!HIBYTE(v248)) {
                          goto LABEL_434;
                        }
                      }
                      else
                      {
                        unsigned int v249 = 255;
                      }
                      int v247 = PDAsaturationPDA_14637(v248, v249, v247, v246);
LABEL_434:
                      *(_DWORD *)unint64_t v30 = v247;
                    }
                  }
LABEL_435:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v242) {
                    goto LABEL_520;
                  }
                }
              case 26:
                long long v108 = v40;
                int v250 = v4;
                while (1)
                {
                  unsigned int v251 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v252 = *v108 * v251 + ((*v108 * v251) >> 8) + 1;
                      if (!BYTE1(v252)) {
                        goto LABEL_449;
                      }
                      unsigned int v251 = v252 >> 8;
                    }
                    unsigned int v253 = PDM_14621(*(_DWORD *)v48, v251);
                    if (HIBYTE(v253))
                    {
                      unsigned int v254 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v255 = HIBYTE(v254);
                        if (!HIBYTE(v254)) {
                          goto LABEL_448;
                        }
                      }
                      else
                      {
                        unsigned int v255 = 255;
                      }
                      unsigned int v253 = PDAluminosityPDA_14638(v253, HIBYTE(v253), v254, v255);
LABEL_448:
                      *(_DWORD *)unint64_t v30 = v253;
                    }
                  }
LABEL_449:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v250) {
                    goto LABEL_520;
                  }
                }
              case 27:
                long long v108 = v40;
                int v256 = v4;
                while (1)
                {
                  unsigned int v257 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v258 = *v108 * v257 + ((*v108 * v257) >> 8) + 1;
                      if (!BYTE1(v258)) {
                        goto LABEL_463;
                      }
                      unsigned int v257 = v258 >> 8;
                    }
                    unsigned int v259 = PDM_14621(*(_DWORD *)v48, v257);
                    unsigned int v260 = HIBYTE(v259);
                    if (HIBYTE(v259))
                    {
                      unsigned int v261 = v259;
                      unsigned int v262 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v263 = HIBYTE(v262);
                        if (!HIBYTE(v262)) {
                          goto LABEL_462;
                        }
                      }
                      else
                      {
                        unsigned int v263 = 255;
                      }
                      unsigned int v261 = PDAluminosityPDA_14638(v262, v263, v261, v260);
LABEL_462:
                      *(_DWORD *)unint64_t v30 = v261;
                    }
                  }
LABEL_463:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v256) {
                    goto LABEL_520;
                  }
                }
              case 28:
                long long v108 = v40;
                int v264 = v4;
                while (1)
                {
                  unsigned int v265 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v266 = *v108 * v265 + ((*v108 * v265) >> 8) + 1;
                      if (!BYTE1(v266)) {
                        goto LABEL_477;
                      }
                      unsigned int v265 = v266 >> 8;
                    }
                    unsigned int v267 = PDM_14621(*(_DWORD *)v48, v265);
                    unsigned int v268 = HIBYTE(v267);
                    if (HIBYTE(v267))
                    {
                      int v269 = v267;
                      unsigned int v270 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v271 = HIBYTE(v270);
                        if (!HIBYTE(v270)) {
                          goto LABEL_476;
                        }
                      }
                      else
                      {
                        unsigned int v271 = 255;
                      }
                      int v269 = PDAtranspose_huePDA_14639(v270, v271, v269, v268);
LABEL_476:
                      *(_DWORD *)unint64_t v30 = v269;
                    }
                  }
LABEL_477:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v264) {
                    goto LABEL_520;
                  }
                }
              case 29:
                long long v108 = v40;
                int v272 = v4;
                while (1)
                {
                  unsigned int v273 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v274 = *v108 * v273 + ((*v108 * v273) >> 8) + 1;
                      if (!BYTE1(v274)) {
                        goto LABEL_491;
                      }
                      unsigned int v273 = v274 >> 8;
                    }
                    unsigned int v275 = PDM_14621(*(_DWORD *)v48, v273);
                    unsigned int v276 = HIBYTE(v275);
                    if (HIBYTE(v275))
                    {
                      int v277 = v275;
                      unsigned int v278 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v279 = HIBYTE(v278);
                        if (!HIBYTE(v278)) {
                          goto LABEL_490;
                        }
                      }
                      else
                      {
                        unsigned int v279 = 255;
                      }
                      int v277 = PDAtranspose_saturationPDA_14640(v278, v279, v277, v276);
LABEL_490:
                      *(_DWORD *)unint64_t v30 = v277;
                    }
                  }
LABEL_491:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v272) {
                    goto LABEL_520;
                  }
                }
              case 30:
                long long v108 = v40;
                int v280 = v4;
                while (1)
                {
                  unsigned int v281 = *v49;
                  if (*v49)
                  {
                    if (v40)
                    {
                      unsigned int v282 = *v108 * v281 + ((*v108 * v281) >> 8) + 1;
                      if (!BYTE1(v282)) {
                        goto LABEL_505;
                      }
                      unsigned int v281 = v282 >> 8;
                    }
                    unsigned int v283 = PDM_14621(*(_DWORD *)v48, v281);
                    if (HIBYTE(v283))
                    {
                      unsigned int v284 = *(_DWORD *)v30;
                      if (v349)
                      {
                        unsigned int v285 = HIBYTE(v284);
                        if (!HIBYTE(v284)) {
                          goto LABEL_504;
                        }
                      }
                      else
                      {
                        unsigned int v285 = 255;
                      }
                      unsigned int v283 = PDAtranspose_luminosityPDA_14641(v283, HIBYTE(v283), v284, v285);
LABEL_504:
                      *(_DWORD *)unint64_t v30 = v283;
                    }
                  }
LABEL_505:
                  ++v49;
                  v48 += 4;
                  v108 += v40 != 0;
                  v30 += 4;
                  if (!--v280) {
                    goto LABEL_520;
                  }
                }
              case 31:
                long long v108 = v40;
                int v286 = v4;
                break;
              default:
LABEL_604:
                uint64_t v295 = v346;
                uint64_t v294 = v347;
                goto LABEL_524;
            }
            while (1)
            {
              unsigned int v287 = *v49;
              if (*v49)
              {
                if (v40)
                {
                  unsigned int v288 = *v108 * v287 + ((*v108 * v287) >> 8) + 1;
                  if (!BYTE1(v288)) {
                    goto LABEL_519;
                  }
                  unsigned int v287 = v288 >> 8;
                }
                unsigned int v289 = PDM_14621(*(_DWORD *)v48, v287);
                unsigned int v290 = HIBYTE(v289);
                if (HIBYTE(v289))
                {
                  unsigned int v291 = v289;
                  unsigned int v292 = *(_DWORD *)v30;
                  if (v349)
                  {
                    unsigned int v293 = HIBYTE(v292);
                    if (!HIBYTE(v292)) {
                      goto LABEL_518;
                    }
                  }
                  else
                  {
                    unsigned int v293 = 255;
                  }
                  unsigned int v291 = PDAtranspose_luminosityPDA_14641(v292, v293, v291, v290);
LABEL_518:
                  *(_DWORD *)unint64_t v30 = v291;
                }
              }
LABEL_519:
              ++v49;
              v48 += 4;
              v108 += v40 != 0;
              v30 += 4;
              if (!--v286)
              {
LABEL_520:
                uint64_t v40 = &v108[v340];
LABEL_521:
                uint64_t v74 = v341;
                int v41 = v342;
LABEL_522:
                v30 += 4 * v74;
                goto LABEL_523;
              }
            }
          }
          if (v24 == 255)
          {
            uint64_t v69 = 0;
            do
            {
              if (v49[v69]) {
                *(_DWORD *)(v48 + 4 * v69) = BYTE2(*(_DWORD *)(v55 + 4 * v69)) | *(_DWORD *)(v55 + 4 * v69) & 0xFF00FF00 | (*(_DWORD *)(v55 + 4 * v69) << 16);
              }
              ++v69;
            }
            while (v4 != v69);
          }
          else
          {
            uint64_t v56 = 0;
            do
            {
              if (v49[v56]) {
                *(_DWORD *)(v48 + 4 * v56) = PDM_14621(BYTE2(*(_DWORD *)(v55 + 4 * v56)) | *(_DWORD *)(v55 + 4 * v56) & 0xFF00FF00 | (*(_DWORD *)(v55 + 4 * v56) << 16), v24);
              }
              ++v56;
            }
            while (v4 != v56);
          }
          int v37 = v348;
        }
        int v54 = v343;
        goto LABEL_73;
      }
      if (!shape_enum_clip_scan((uint64_t)v37, (_DWORD *)v40 - 4)) {
        goto LABEL_617;
      }
    }
    v345 -= v45;
    if (v345 < 1) {
      break;
    }
    v35 += v41[16] * v45;
    v36 += v41[17] * v45;
    v30 += 4 * v332 * v45;
    int v38 = v44;
  }
LABEL_617:
  if (v37) {
    free(v37);
  }
LABEL_619:
  if (v334) {
    free(v334);
  }
}

uint64_t argb32_sample_argb32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v109 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v109 = v5 % v6;
    }
  }
  else
  {
    uint64_t v109 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 32);
  uint64_t v10 = *(void *)(result + 120);
  if (v7)
  {
    uint64_t v11 = v10 % v7;
    if (v10 <= v7) {
      uint64_t v11 = *(void *)(result + 120);
    }
    uint64_t v108 = v11;
  }
  else
  {
    uint64_t v108 = 0;
  }
  uint64_t v104 = *(void *)(result + 80);
  uint64_t v105 = *(void *)(result + 64);
  uint64_t v106 = *(void *)(result + 88);
  uint64_t v107 = *(void *)(result + 72);
  uint64_t v12 = *(void *)(result + 152) - 4;
  uint64_t v13 = *(void *)(result + 144) - 1;
  if (*(void *)(result + 40)) {
    int v14 = 0;
  }
  else {
    int v14 = -16777216;
  }
  int v103 = *(_DWORD *)(result + 188);
  unint64_t v15 = v9 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  uint64_t v16 = -*(void *)(result + 64);
  uint64_t v17 = -*(void *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v107)
      {
        uint64_t v18 = *(void *)(result + 216);
        uint64_t v19 = v107 - *(void *)(result + 224);
        uint64_t v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1) {
          goto LABEL_55;
        }
        if (v20 >= v18) {
          LODWORD(v21) = 0x3FFFFFFF;
        }
        else {
          unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
        }
        unsigned int v28 = v103 | v21;
        uint64_t v29 = v19 + 0x1000000;
        uint64_t v26 = a3 - (v19 + 0x1000000);
        uint64_t v27 = 512;
        goto LABEL_25;
      }
      if (a3 <= v106)
      {
        uint64_t v26 = 0;
        uint64_t v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v28 = 0x3FFFFFFF;
        uint64_t v29 = a3;
LABEL_25:
        uint64_t v30 = v105;
        goto LABEL_28;
      }
      uint64_t v22 = *(void *)(result + 216);
      uint64_t v23 = *(void *)(result + 224) + v106;
      uint64_t v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1) {
        goto LABEL_55;
      }
      if (v24 >= v22) {
        LODWORD(v25) = 0x3FFFFFFF;
      }
      else {
        unint64_t v25 = (unint64_t)(*(void *)(result + 232) * v24) >> 32;
      }
      uint64_t v30 = v105;
      unsigned int v28 = v103 | v25;
      uint64_t v29 = v23 - 0x1000000;
      uint64_t v26 = a3 - (v23 - 0x1000000);
      uint64_t v27 = 448;
LABEL_28:
      if (a2 >= v30) {
        break;
      }
      uint64_t v31 = *(void *)(result + 192);
      uint64_t v32 = v30 - *(void *)(result + 200);
      uint64_t v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31) {
          unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v33) >> 32) >> 15)) | v103;
        }
        uint64_t v34 = v32 + 0x1000000;
        uint64_t v35 = a2 - (v32 + 0x1000000);
        uint64_t v36 = 32;
        goto LABEL_39;
      }
LABEL_55:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 4;
      *(unsigned char *)++uint64_t v13 = 0;
      if (!a4) {
        return result;
      }
    }
    if (a2 <= v104)
    {
      uint64_t v35 = 0;
      uint64_t v36 = ((unint64_t)a2 >> 26) & 0x3C;
      uint64_t v34 = a2;
      goto LABEL_39;
    }
    uint64_t v37 = *(void *)(result + 192);
    uint64_t v38 = *(void *)(result + 200) + v104;
    uint64_t v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1) {
      goto LABEL_55;
    }
    if (v39 < v37) {
      unsigned int v28 = ((v28 >> 15) * (((unint64_t)(*(void *)(result + 208) * v39) >> 32) >> 15)) | v103;
    }
    uint64_t v34 = v38 - 0x1000000;
    uint64_t v35 = a2 - (v38 - 0x1000000);
    uint64_t v36 = 28;
LABEL_39:
    if (v28 < 0x400000) {
      goto LABEL_55;
    }
    if (v6)
    {
      uint64_t v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      uint64_t v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7) {
        uint64_t v42 = v7;
      }
      else {
        uint64_t v42 = 0;
      }
      uint64_t v29 = v40 - v42;
      if (v41 >= v6) {
        uint64_t v43 = v6;
      }
      else {
        uint64_t v43 = 0;
      }
      uint64_t v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    uint64_t v44 = v9 + SHIDWORD(v29) * (uint64_t)v4;
    uint64_t v45 = v34 >> 32;
    unint64_t v46 = v44 + 4 * v45;
    long long v47 = *(unsigned int **)(result + 32);
    if (v15 >= v46) {
      uint64_t v48 = (unsigned int *)(v44 + 4 * v45);
    }
    else {
      uint64_t v48 = (unsigned int *)v15;
    }
    if (v48 < v47) {
      uint64_t v48 = *(unsigned int **)(result + 32);
    }
    unsigned int v49 = *v48;
    if (!v8) {
      goto LABEL_104;
    }
    unsigned int v50 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_58:
    int v51 = v50 & 0xF;
    uint64_t v52 = v50 >> 8;
    unsigned int v53 = HIBYTE(v50) & 3;
    switch(v51)
    {
      case 1:
        LODWORD(v77) = SBYTE1(v50);
        if (v6)
        {
          uint64_t v78 = v52 << 56;
          uint64_t v79 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v80 = v7 & (v79 >> 63);
          if (v80 + v79 >= v7) {
            uint64_t v81 = v7;
          }
          else {
            uint64_t v81 = 0;
          }
          uint64_t v77 = (v80 + (v78 >> 24) - v81) >> 32;
        }
        float v82 = (unsigned int *)(v46 + (int)v77 * (uint64_t)v4);
        if (v15 < (unint64_t)v82) {
          float v82 = (unsigned int *)v15;
        }
        if (v82 < v47) {
          float v82 = v47;
        }
        int v83 = interpolate_8888_21358[v53];
        char v84 = v53 + 1;
        unsigned int v75 = v49 - ((v83 & v49) >> v84);
        unsigned int v76 = (v83 & *v82) >> v84;
        goto LABEL_93;
      case 2:
        uint64_t v85 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v86 = v35 + ((uint64_t)SBYTE2(v50) << 32);
          uint64_t v87 = v6 & (v86 >> 63);
          if (v87 + v86 >= v6) {
            uint64_t v88 = v6;
          }
          else {
            uint64_t v88 = 0;
          }
          uint64_t v85 = (v87 + ((uint64_t)((unint64_t)HIWORD(v50) << 56) >> 24) - v88) >> 32;
        }
        uint64_t v89 = (unsigned int *)(v46 + 4 * v85);
        if (v15 < (unint64_t)v89) {
          uint64_t v89 = (unsigned int *)v15;
        }
        if (v89 < v47) {
          uint64_t v89 = v47;
        }
        unsigned int v49 = v49
            - ((interpolate_8888_21358[(v50 >> 28) & 3] & v49) >> (((v50 >> 28) & 3) + 1))
            + ((interpolate_8888_21358[(v50 >> 28) & 3] & *v89) >> (((v50 >> 28) & 3) + 1));
        break;
      case 3:
        unsigned int v102 = HIBYTE(v50) & 3;
        LODWORD(v54) = SBYTE1(v50);
        uint64_t v55 = SBYTE2(v50);
        if (v6)
        {
          uint64_t v101 = v52 << 56;
          int64_t v56 = (unint64_t)HIWORD(v50) << 56;
          uint64_t v57 = v26 + ((uint64_t)SBYTE1(v50) << 32);
          uint64_t v58 = v35 + (v56 >> 24);
          uint64_t v59 = v7 & (v57 >> 63);
          uint64_t v60 = v6 & (v58 >> 63);
          uint64_t v61 = v60 + v58;
          if (v59 + v57 >= v7) {
            uint64_t v62 = v7;
          }
          else {
            uint64_t v62 = 0;
          }
          if (v61 >= v6) {
            uint64_t v63 = v6;
          }
          else {
            uint64_t v63 = 0;
          }
          uint64_t v54 = (v59 + (v101 >> 24) - v62) >> 32;
          uint64_t v55 = (v60 + (v56 >> 24) - v63) >> 32;
        }
        int v64 = (unsigned int *)(v46 + 4 * v55);
        if (v15 < (unint64_t)v64) {
          int v64 = (unsigned int *)v15;
        }
        if (v64 < v47) {
          int v64 = v47;
        }
        unsigned int v65 = *v64;
        unint64_t v66 = v46 + (int)v54 * (uint64_t)v4;
        if (v15 >= v66) {
          int v67 = (unsigned int *)(v46 + (int)v54 * (uint64_t)v4);
        }
        else {
          int v67 = (unsigned int *)v15;
        }
        if (v67 < v47) {
          int v67 = v47;
        }
        unsigned int v68 = *v67;
        uint64_t v69 = (unsigned int *)(v66 + 4 * v55);
        if (v15 < (unint64_t)v69) {
          uint64_t v69 = (unsigned int *)v15;
        }
        if (v69 < v47) {
          uint64_t v69 = v47;
        }
        int v70 = interpolate_8888_21358[v102];
        unsigned int v71 = v49 - ((v70 & v49) >> (v102 + 1)) + ((v70 & v68) >> (v102 + 1));
        unsigned int v72 = v65 - ((v70 & v65) >> (v102 + 1)) + ((v70 & *v69) >> (v102 + 1));
        unsigned int v73 = (v50 >> 28) & 3;
        int v74 = interpolate_8888_21358[v73];
        LOBYTE(v73) = v73 + 1;
        unsigned int v75 = v71 - ((v71 & v74) >> v73);
        unsigned int v76 = (v72 & v74) >> v73;
LABEL_93:
        unsigned int v49 = v75 + v76;
        break;
    }
LABEL_104:
    *(_DWORD *)(v12 + 4) = v49 | v14;
    *(unsigned char *)(v13 + 1) = v28 >> 22;
    if (a4 == 1) {
      break;
    }
    uint64_t v90 = 0;
    a2 += v5;
    uint64_t v91 = v104 - a2;
    a3 += v10;
    uint64_t v92 = v106 - a3;
    uint64_t v93 = -4;
    while (((v92 | v91 | (v17 + a3) | (v16 + a2)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        uint64_t v94 = (v7 & ((v26 + v108) >> 63)) + v26 + v108;
        uint64_t v95 = (v6 & ((v35 + v109) >> 63)) + v35 + v109;
        if (v94 >= v7) {
          uint64_t v96 = v7;
        }
        else {
          uint64_t v96 = 0;
        }
        uint64_t v97 = v94 - v96;
        if (v95 >= v6) {
          uint64_t v98 = v6;
        }
        else {
          uint64_t v98 = 0;
        }
        uint64_t v99 = v95 - v98;
        uint64_t v35 = v99;
        uint64_t v26 = v97;
      }
      else
      {
        uint64_t v99 = a2;
        HIDWORD(v97) = HIDWORD(a3);
      }
      unint64_t v46 = v9 + SHIDWORD(v97) * (uint64_t)v4 + 4 * (v99 >> 32);
      long long v47 = *(unsigned int **)(result + 32);
      if (v15 >= v46) {
        int v100 = (unsigned int *)v46;
      }
      else {
        int v100 = (unsigned int *)v15;
      }
      if (v100 < v47) {
        int v100 = *(unsigned int **)(result + 32);
      }
      unsigned int v49 = *v100;
      if (v8)
      {
        unsigned int v50 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v50 & 0xF) != 0)
        {
          v13 += v90 + 1;
          v12 -= v93;
          a4 += ~v90;
          unsigned int v28 = -1;
          goto LABEL_58;
        }
      }
      *(_DWORD *)(v12 + 4 * v90 + 8) = v49 | v14;
      *(unsigned char *)(v13 + v90++ + 2) = -1;
      v93 -= 4;
      a2 += v5;
      v91 -= v5;
      a3 += v10;
      v92 -= v10;
      if (a4 - 1 == v90) {
        return result;
      }
    }
    v13 += v90 + 1;
    v12 -= v93;
    a4 += ~v90;
  }
  while (a4);
  return result;
}

void RGBA32_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12)
{
  float v12 = *(float *)(a1 + 280);
  float v13 = *(float *)(a1 + 296)
      + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
              + (float)(v12 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v14 = a1 + 368;
  uint64_t v15 = *(void *)(a1 + 368);
  uint64_t v16 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v17 = v15 + v16;
  if (v15) {
    uint64_t v18 = v15 + v16;
  }
  else {
    uint64_t v18 = a1 + 368;
  }
  if (v15) {
    char v19 = 15;
  }
  else {
    char v19 = 0;
  }
  float v21 = *(float *)(a1 + 336);
  float v22 = *(float *)(a1 + 344);
  float v23 = *(float *)(a1 + 304);
  float v24 = *(float *)(a1 + 308);
  int v25 = *(_DWORD *)(a1 + 320);
  int v26 = *(_DWORD *)(a1 + 324);
  uint64_t v29 = a1 + 144;
  uint64_t v27 = *(_DWORD **)(a1 + 144);
  uint64_t v28 = *(void *)(v29 + 8);
  uint64_t v30 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v31 = *(void *)(a1 + 360);
  if (v12 != 0.0)
  {
    if (v15) {
      unsigned int v37 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v37) = 0;
    }
    while (1)
    {
      int v38 = v25;
      if (v13 >= v23)
      {
        int v38 = v26;
        if (v13 <= v24) {
          int v38 = (int)(float)(v22 * (float)(v13 - v21));
        }
      }
      if (v38 < 0)
      {
        if (!v30)
        {
          char v45 = 0;
          goto LABEL_40;
        }
        unsigned __int16 v40 = v30[1];
        __int16 v41 = *(unsigned __int8 *)(v18 + v37);
        unsigned __int16 v42 = v30[2];
        unsigned __int16 v43 = v30[3];
        __int16 v44 = v41 + *v30;
      }
      else
      {
        uint64_t v39 = (_WORD *)(v31 + 8 * v38);
        unsigned __int16 v40 = v39[1];
        __int16 v41 = *(unsigned __int8 *)(v18 + v37);
        unsigned __int16 v42 = v39[2];
        unsigned __int16 v43 = v39[3];
        __int16 v44 = v41 + *v39;
      }
      *(_DWORD *)uint64_t v28 = (v41 + v40) & 0xFF00 | HIBYTE(v44) | (((unsigned __int16)(v41 + v42) >> 8) << 16) & 0xFFFFFF | (((unsigned __int16)(v41 + v43) >> 8) << 24);
      char v45 = -1;
LABEL_40:
      LOBYTE(v37) = (v37 + 1) & v19;
      float v13 = v12 + v13;
      v28 += 4;
      *(unsigned char *)uint64_t v27 = v45;
      uint64_t v27 = (_DWORD *)((char *)v27 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v15) {
    uint64_t v32 = v17;
  }
  else {
    uint64_t v32 = v14;
  }
  if (v15) {
    LODWORD(v33) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v33) = 0;
  }
  if (v15) {
    LODWORD(v34) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v34) = 0;
  }
  if (v15) {
    int v35 = 15;
  }
  else {
    int v35 = 0;
  }
  if (v13 >= v23)
  {
    int v25 = v26;
    if (v13 <= v24) {
      int v25 = (int)(float)(v22 * (float)(v13 - v21));
    }
  }
  if ((v25 & 0x80000000) == 0 || v30)
  {
    unint64_t v46 = (unsigned __int16 *)(v31 + 8 * v25);
    if (v25 < 0) {
      long long v47 = v30;
    }
    else {
      long long v47 = v46;
    }
    unsigned int v48 = *v47;
    unsigned int v49 = v47[3];
    unsigned int v50 = v47[2];
    unsigned int v51 = v47[1];
    if (v15)
    {
      int32x2_t v52 = vdup_n_s32(v48);
      int32x2_t v53 = vdup_n_s32(v51);
      int v54 = a4 + 4;
      int32x2_t v55 = vdup_n_s32(v50);
      int32x2_t v56 = vdup_n_s32(v49);
      do
      {
        uint64_t v57 = (__int8 *)(v32 + v34);
        uint64_t v34 = (v34 + 1) & v35;
        a12.i8[0] = *v57;
        a12.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v58 = (int32x2_t)vand_s8(a12, (int8x8_t)0xFF000000FFLL);
        int8x8_t v59 = vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v52, v58), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), vand_s8((int8x8_t)vadd_s32(v53, v58), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v55, v58), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v56, v58), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
        *(int8x8_t *)uint64_t v28 = v59;
        uint64_t v33 = (v33 + 1) & v35;
        v59.i8[0] = *(unsigned char *)(v32 + v34);
        v59.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v60 = (int32x2_t)vand_s8(v59, (int8x8_t)0xFF000000FFLL);
        a12 = vorr_s8(vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v52, v60), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), vand_s8((int8x8_t)vadd_s32(v53, v60), (int8x8_t)0xFF000000FF00)), vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v55, v60), 8uLL), (int8x8_t)0xFF000000FF0000), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v56, v60), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
        *(double *)(v28 + 8) = *(double *)&a12;
        *v27++ = -1;
        v54 -= 4;
        v28 += 16;
      }
      while (v54 > 4);
    }
    else
    {
      int32x4_t v61 = vdupq_n_s32((v48 >> 8) & 0xFF00FFFF | (BYTE1(v49) << 24) | v51 & 0xFF00 | (BYTE1(v50) << 16));
      int v62 = a4 + 4;
      do
      {
        *(int32x4_t *)uint64_t v28 = v61;
        v28 += 16;
        *v27++ = -1;
        v62 -= 4;
      }
      while (v62 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v36 = 4;
    }
    else {
      int v36 = a4;
    }
    bzero(v27, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

void argb32_shade_axial_RGB(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, int8x8_t a12)
{
  float v12 = *(float *)(a1 + 280);
  float v13 = *(float *)(a1 + 296)
      + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
              + (float)(v12 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  uint64_t v14 = a1 + 368;
  uint64_t v15 = *(void *)(a1 + 368);
  uint64_t v16 = ((unint64_t)a3 >> 4) & 0xF0;
  uint64_t v17 = v15 + v16;
  if (v15) {
    uint64_t v18 = v15 + v16;
  }
  else {
    uint64_t v18 = a1 + 368;
  }
  if (v15) {
    char v19 = 15;
  }
  else {
    char v19 = 0;
  }
  float v21 = *(float *)(a1 + 336);
  float v22 = *(float *)(a1 + 344);
  float v23 = *(float *)(a1 + 304);
  float v24 = *(float *)(a1 + 308);
  int v25 = *(_DWORD *)(a1 + 320);
  int v26 = *(_DWORD *)(a1 + 324);
  uint64_t v29 = a1 + 144;
  uint64_t v27 = *(_DWORD **)(a1 + 144);
  uint64_t v28 = *(void *)(v29 + 8);
  uint64_t v30 = *(unsigned __int16 **)(a1 + 376);
  uint64_t v31 = *(void *)(a1 + 360);
  if (v12 != 0.0)
  {
    if (v15) {
      unsigned int v37 = (a2 >> 8) & 0xF;
    }
    else {
      LOBYTE(v37) = 0;
    }
    while (1)
    {
      int v38 = v25;
      if (v13 >= v23)
      {
        int v38 = v26;
        if (v13 <= v24) {
          int v38 = (int)(float)(v22 * (float)(v13 - v21));
        }
      }
      if (v38 < 0)
      {
        if (!v30)
        {
          char v49 = 0;
          goto LABEL_40;
        }
        __int16 v48 = *(unsigned __int8 *)(v18 + v37);
        __int16 v44 = v48 + *v30;
        __int16 v45 = v48 + v30[1];
        __int16 v46 = v48 + v30[2];
        __int16 v47 = v48 + v30[3];
      }
      else
      {
        uint64_t v39 = (_WORD *)(v31 + 8 * v38);
        __int16 v40 = v39[1];
        __int16 v41 = *(unsigned __int8 *)(v18 + v37);
        __int16 v42 = v39[2];
        __int16 v43 = v39[3];
        __int16 v44 = v41 + *v39;
        __int16 v45 = v41 + v40;
        __int16 v46 = v41 + v42;
        __int16 v47 = v41 + v43;
      }
      *(_DWORD *)uint64_t v28 = v45 & 0xFF00 | (HIBYTE(v44) << 16) & 0xFFFFFF | HIBYTE(v46) | (HIBYTE(v47) << 24);
      char v49 = -1;
LABEL_40:
      LOBYTE(v37) = (v37 + 1) & v19;
      float v13 = v12 + v13;
      v28 += 4;
      *(unsigned char *)uint64_t v27 = v49;
      uint64_t v27 = (_DWORD *)((char *)v27 + 1);
      if (!--a4) {
        return;
      }
    }
  }
  if (v15) {
    uint64_t v32 = v17;
  }
  else {
    uint64_t v32 = v14;
  }
  if (v15) {
    LODWORD(v33) = ((a2 >> 8) + 1) & 0xF;
  }
  else {
    LODWORD(v33) = 0;
  }
  if (v15) {
    LODWORD(v34) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v34) = 0;
  }
  if (v15) {
    int v35 = 15;
  }
  else {
    int v35 = 0;
  }
  if (v13 >= v23)
  {
    int v25 = v26;
    if (v13 <= v24) {
      int v25 = (int)(float)(v22 * (float)(v13 - v21));
    }
  }
  if ((v25 & 0x80000000) == 0 || v30)
  {
    unsigned int v50 = (unsigned __int16 *)(v31 + 8 * v25);
    if (v25 < 0) {
      unsigned int v51 = v30;
    }
    else {
      unsigned int v51 = v50;
    }
    unsigned int v52 = *v51;
    unsigned int v53 = v51[3];
    unsigned int v54 = v51[2];
    unsigned int v55 = v51[1];
    if (v15)
    {
      int32x2_t v56 = vdup_n_s32(v52);
      int32x2_t v57 = vdup_n_s32(v55);
      int v58 = a4 + 4;
      int32x2_t v59 = vdup_n_s32(v54);
      int32x2_t v60 = vdup_n_s32(v53);
      do
      {
        int32x4_t v61 = (__int8 *)(v32 + v34);
        uint64_t v34 = (v34 + 1) & v35;
        a12.i8[0] = *v61;
        a12.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v62 = (int32x2_t)vand_s8(a12, (int8x8_t)0xFF000000FFLL);
        int8x8_t v63 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v56, v62), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v57, v62), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v59, v62), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v60, v62), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
        *(int8x8_t *)uint64_t v28 = v63;
        uint64_t v33 = (v33 + 1) & v35;
        v63.i8[0] = *(unsigned char *)(v32 + v34);
        v63.i8[4] = *(unsigned char *)(v32 + v33);
        int32x2_t v64 = (int32x2_t)vand_s8(v63, (int8x8_t)0xFF000000FFLL);
        a12 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_n_s32(vadd_s32(v56, v64), 8uLL), (int8x8_t)0xFF000000FF0000), vand_s8((int8x8_t)vadd_s32(v57, v64), (int8x8_t)0xFF000000FF00)), vorr_s8((int8x8_t)(*(void *)&vshr_n_u32((uint32x2_t)vadd_s32(v59, v64), 8uLL) & 0xFFFFFEFFFFFFFEFFLL), (int8x8_t)(*(void *)&vshl_n_s32(vadd_s32(v60, v64), 0x10uLL) & 0xFF00FFFFFF00FFFFLL)));
        *(double *)(v28 + 8) = *(double *)&a12;
        *v27++ = -1;
        v58 -= 4;
        v28 += 16;
      }
      while (v58 > 4);
    }
    else
    {
      int32x4_t v65 = vdupq_n_s32((unsigned __int16)(v54 >> 8) | (BYTE1(v52) << 16) & 0xFFFFFF | (BYTE1(v53) << 24) | v55 & 0xFF00);
      int v66 = a4 + 4;
      do
      {
        *(int32x4_t *)uint64_t v28 = v65;
        v28 += 16;
        *v27++ = -1;
        v66 -= 4;
      }
      while (v66 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v36 = 4;
    }
    else {
      int v36 = a4;
    }
    bzero(v27, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t CGImageProviderGetComponentType(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 32);
  }
  return result;
}

uint64_t copy_postscript_name()
{
  return FPFontCopyPostScriptName();
}

CGFloat CGImageBlockGetRect(uint64_t a1)
{
  CFURLRef v1 = &CGRectNull;
  if (a1) {
    CFURLRef v1 = (const CGRect *)(a1 + 8);
  }
  return v1->origin.x;
}

uint64_t CGContextGetFontRenderingStyle(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)(a1 + 16) == 1129601108)
  {
    uint64_t v8 = *(void *)(a1 + 96);
    return CGGStateGetFontRenderingStyle(v8);
  }
  else
  {
    handle_invalid_context((char)"CGContextGetFontRenderingStyle", a1, a3, a4, a5, a6, a7, a8);
    return 0;
  }
}

void CGContextRotateCTM(CGContextRef c, CGFloat angle)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v8 = *((void *)c + 12);
    float64x2_t v10 = *(float64x2_t *)(v8 + 40);
    float64x2_t v11 = *(float64x2_t *)(v8 + 24);
    float64x2_t v12 = *(float64x2_t *)(v8 + 56);
    __double2 v9 = __sincos_stret(angle);
    *(float64x2_t *)(v8 + 24) = vmlaq_n_f64(vmulq_n_f64(v10, v9.__sinval), v11, v9.__cosval);
    *(float64x2_t *)(v8 + 40) = vmlsq_lane_f64(vmulq_n_f64(v10, v9.__cosval), v11, v9.__sinval, 0);
    *(float64x2_t *)(v8 + 56) = vaddq_f64(v12, vmlaq_f64(vmulq_f64(v10, (float64x2_t)0), (float64x2_t)0, v11));
  }
  else
  {
    handle_invalid_context((char)"CGContextRotateCTM", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t CGBitmapGetFastestAlignment()
{
  return 32;
}

uint64_t CGContextSetEDRTargetHeadroom(uint64_t a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a1 || *(_DWORD *)(a1 + 16) != 1129601108)
  {
    handle_invalid_context((char)"CGContextSetEDRTargetHeadroom", a1, a4, a5, a6, a7, a8, a9);
    return 0;
  }
  if (a2 < 1.0 && a2 != 0.0) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 96);
  if (*(float *)(*(void *)(v10 + 120) + 48) != a2)
  {
    maybeCopyRenderingState(*(void *)(a1 + 96));
    *(float *)(*(void *)(v10 + 120) + 48) = a2;
  }
  return 1;
}

BOOL colorsync_transform_data_key_is_equal(uint64_t a1, uint64_t a2)
{
  long long v6 = *(_OWORD *)(a1 + 16);
  long long v5 = *(_OWORD *)(a2 + 16);
  if (*(void *)a1 != *(void *)a2 || *(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  return (void)v6 == (void)v5 && *((void *)&v6 + 1) == *((void *)&v5 + 1);
}

CFTypeRef *CGGlyphLockUnlock(CFTypeRef **a1)
{
  uint64_t result = *a1;
  if (result)
  {
    CGGlyphBuilderUnlockBitmaps(result);
    uint64_t result = CGGlyphBuilderRelease(*a1);
    *a1 = 0;
  }
  return result;
}

CGPathRef CGContextCopyPath(CGContextRef c)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v7 = (const CGPath *)*((void *)c + 21);
    if (v7)
    {
      uint64_t v8 = *((void *)c + 12);
      long long v9 = *(_OWORD *)(v8 + 40);
      *(_OWORD *)&v11.double a = *(_OWORD *)(v8 + 24);
      *(_OWORD *)&v11.double c = v9;
      *(_OWORD *)&v11.double tx = *(_OWORD *)(v8 + 56);
      memset(&transform, 0, sizeof(transform));
      CGAffineTransformInvert(&transform, &v11);
      return CGPathCreateMutableCopyByTransformingPath(v7, &transform);
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextCopyPath", (uint64_t)c, v1, v2, v3, v4, v5, v6);
  }
  return 0;
}

void CGContextShowGlyphsWithAdvances(CGContextRef c, const CGGlyph *glyphs, const CGSize *advances, size_t count)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!c)
  {
    CGContextRef v25 = 0;
LABEL_21:
    handle_invalid_context((char)"CGContextShowGlyphsWithAdvances", (uint64_t)v25, (uint64_t)advances, count, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v25 = c;
    goto LABEL_21;
  }
  if (glyphs)
  {
    CGAffineTransform v11 = advances;
    if (advances)
    {
      size_t v12 = count;
      if (count)
      {
        uint64_t v13 = *(void *)(*((void *)c + 12) + 136);
        if (*(void *)(v13 + 8))
        {
          v8.n128_u64[0] = *(void *)(v13 + 16);
          if (v8.n128_f64[0] != 0.0)
          {
            MEMORY[0x1F4188790](c, v8);
            uint64_t v16 = (long long *)((char *)&v28 - v14 - 15);
            uint64_t v17 = v15 <= 0xFFFFFFFFFFFFFFELL ? (long long *)((char *)&v28 - v14 - 15) : 0;
            if (v15 - 0xFFFFFFFFFFFFFFFLL >= 0xF00000000000003ELL) {
              uint64_t v17 = (long long *)malloc_type_malloc(16 * v12, 0x48C1F26uLL);
            }
            if (v17)
            {
              long long v18 = *(_OWORD *)((char *)c + 136);
              *(_OWORD *)&v28.double a = *(_OWORD *)((char *)c + 120);
              *(_OWORD *)&v28.double c = v18;
              *(_OWORD *)&v28.double tx = *(_OWORD *)((char *)c + 152);
              CGAffineTransformInvert(&v29, &v28);
              uint64_t v19 = 0;
              float64x2_t v20 = *(float64x2_t *)&v29.a;
              float64x2_t v21 = *(float64x2_t *)&v29.c;
              p_size_t height = &v11->height;
              float64x2_t v23 = 0uLL;
              do
              {
                v17[v19] = (__int128)v23;
                float64x2_t v23 = vaddq_f64(v23, vmlaq_n_f64(vmulq_n_f64(v21, *p_height), v20, *(p_height - 1)));
                ++v19;
                p_height += 2;
              }
              while (v12 != v19);
              unsigned int v24 = *(char *)(*(void *)(*((void *)c + 12) + 136) + 1);
              if (v24 < 4)
              {
                draw_glyphs_18654((uint64_t)c, (uint64_t)glyphs, (uint64_t)v17, v12);
                goto LABEL_27;
              }
              if (v24 - 4 >= 3)
              {
                if (v24 != 7) {
                  goto LABEL_27;
                }
              }
              else
              {
                draw_glyphs_18654((uint64_t)c, (uint64_t)glyphs, (uint64_t)v17, v12);
              }
              clip_to_glyphs((uint64_t)c, (__int16 *)glyphs, v17, v12);
LABEL_27:
              float64x2_t v26 = 0uLL;
              do
              {
                float64x2_t v27 = *(float64x2_t *)v11++;
                float64x2_t v26 = vaddq_f64(v26, v27);
                --v12;
              }
              while (v12);
              *(float64x2_t *)((char *)c + 152) = vaddq_f64(v26, *(float64x2_t *)((char *)c + 152));
              if (v17 != v16) {
                free(v17);
              }
            }
          }
        }
      }
    }
  }
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  long long v9 = t;
  double b = t->b;
  double c = t->c;
  double d = t->d;
  double v14 = t->a * d - b * c;
  if (v14 == 0.0)
  {
    CGPostError((uint64_t)"%s: singular matrix.", v2, v3, v4, v5, v6, v7, v8, (char)"CGAffineTransformInvert");
    long long v15 = *(_OWORD *)&v9->c;
    *(_OWORD *)&retstr->double a = *(_OWORD *)&v9->a;
    *(_OWORD *)&retstr->double c = v15;
    *(_OWORD *)&retstr->double tx = *(_OWORD *)&v9->tx;
  }
  else
  {
    double v16 = 1.0 / v14;
    CGFloat v17 = t->a * v16;
    double v18 = b * v16;
    double v19 = c * v16;
    CGFloat v20 = d * v16;
    CGFloat v21 = -(b * v16);
    CGFloat v22 = -(c * v16);
    double tx = t->tx;
    double ty = t->ty;
    retstr->double a = v20;
    retstr->double b = v21;
    retstr->double c = v22;
    retstr->double d = v17;
    retstr->double tx = v19 * ty - v20 * tx;
    retstr->double ty = v18 * tx - v17 * ty;
  }
  return t;
}

uint64_t CGContextDelegateDrawGlyphs(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 88);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

uint64_t ripl_Combine(uint64_t a1, uint64_t a2, int a3)
{
  long long v173 = 0uLL;
  *(void *)unsigned int v172 = 0;
  uint64_t v6 = (_DWORD *)(a1 + 12);
  uint64_t v7 = (_DWORD *)(a2 + 12);
  uint64_t v8 = CGSBoundsIntersection((int *)(a1 + 12), (int *)(a2 + 12), &v173);
  if ((v8 & 1) == 0)
  {
    if (a3 || !*(_DWORD *)(a1 + 20) && !*(_DWORD *)(a1 + 24)) {
      return 0;
    }
    goto LABEL_159;
  }
  double v12 = *((double *)&v173 + 1);
  uint64_t v13 = DWORD2(v173);
  unsigned int v171 = DWORD2(v173);
  int v14 = HIDWORD(v173);
  int v170 = HIDWORD(v173);
  uint64_t v15 = *(void *)(a1 + 56);
  if (v15)
  {
    double v16 = *(int **)(a2 + 72);
    if (v16)
    {
LABEL_4:
      int v17 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12);
      int v19 = *(_DWORD *)(a1 + 20);
      int v18 = *(_DWORD *)(a1 + 24);
      int v20 = v18 + *(_DWORD *)(a1 + 16) - (*(_DWORD *)(a2 + 16) + *(_DWORD *)(a2 + 24));
      v172[0] = v20;
      v172[1] = v17;
      if (a3 >= 0) {
        int v21 = -1;
      }
      else {
        int v21 = 1;
      }
      shape_enum_clip_alloc(v8, v9, v16, 1, 1, v21, -v17, -v20, v19, v18);
      if (!v22) {
        goto LABEL_159;
      }
      float64x2_t v23 = (int32x2_t *)v22;
      if (!shape_enum_clip_next(v22, &v172[1], v172, &v171, &v170))
      {
LABEL_13:
        unsigned int v24 = (int *)v23;
LABEL_14:
        free(v24);
LABEL_15:
        CGContextRef v25 = *(int **)(a1 + 72);
        goto LABEL_16;
      }
      if (a3 < 0 || v171 != *(_DWORD *)(a1 + 20) || v170 != *(_DWORD *)(a1 + 24))
      {
        do
          CGBlt_fillBytes(v171, v170, 0, (char *)(*(void *)(a1 + 56) + v172[1] + (*(_DWORD *)(a1 + 48) * v172[0])), *(_DWORD *)(a1 + 48));
        while (shape_enum_clip_next((uint64_t)v23, &v172[1], v172, &v171, &v170));
        goto LABEL_13;
      }
LABEL_157:
      unsigned int v132 = (int *)v23;
LABEL_158:
      free(v132);
      goto LABEL_159;
    }
    int v45 = *(_DWORD *)(a2 + 64);
    if (v45) {
      goto LABEL_40;
    }
    uint64_t v81 = *(void *)(a2 + 56);
    if (v81)
    {
      int v82 = HIDWORD(v173);
      goto LABEL_90;
    }
    if (*(void *)(a1 + 20) != *((void *)&v173 + 1))
    {
      uint64_t v125 = (int)v173 - (uint64_t)*(int *)(a1 + 12);
      int v88 = *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 24) - DWORD1(v173) - HIDWORD(v173);
      v172[0] = v88;
      v172[1] = v125;
      if ((a3 & 0x80000000) == 0) {
        goto LABEL_97;
      }
      int v97 = *(_DWORD *)(a1 + 48);
      uint64_t v98 = (char *)(v15 + v125 + (v97 * v88));
      int v93 = DWORD2(v173);
      signed int v94 = HIDWORD(v173);
      goto LABEL_115;
    }
LABEL_144:
    if ((a3 & 0x80000000) == 0) {
      return 1;
    }
    goto LABEL_159;
  }
  float64x2_t v27 = *(int **)(a1 + 72);
  if (v27)
  {
    CGAffineTransform v28 = *(int32x2_t **)(a2 + 72);
    if (v28)
    {
      uint64_t v169 = 0;
      goto LABEL_27;
    }
    unsigned int v58 = *(_DWORD *)(a2 + 64);
    if (v58)
    {
LABEL_68:
      int v69 = *(_DWORD *)(a2 + 12);
      int v70 = *(_DWORD *)(a2 + 16);
      if (v173 == v69) {
        unsigned int v71 = v58 & 0xFF000000;
      }
      else {
        unsigned int v71 = 0;
      }
      int v72 = v58;
      if (DWORD1(v173) != v70) {
        int v72 = 0;
      }
      if (v173 + DWORD2(v173) == *(_DWORD *)(a2 + 20) + v69) {
        int v73 = v58 & 0xFF00;
      }
      else {
        int v73 = 0;
      }
      int v74 = DWORD1(v173) + HIDWORD(v173);
      if (DWORD1(v173) + HIDWORD(v173) == *(_DWORD *)(a2 + 24) + v70) {
        int v75 = v58 & 0xFF0000;
      }
      else {
        int v75 = 0;
      }
      unsigned int v76 = v72 | v71 | v73 | v75;
      if (!v76) {
        return 1;
      }
      if (a3 < 0)
      {
        uint64_t v168 = 0;
        int v126 = v173 - *(_DWORD *)(a1 + 12);
        int v127 = *(_DWORD *)(a1 + 24);
        int v128 = *(_DWORD *)(a1 + 16) - v74 + v127;
        v172[0] = v128;
        v172[1] = v126;
        if (HIBYTE(v76))
        {
          v172[1] = ++v126;
          LODWORD(v13) = DWORD2(v173) - 1;
        }
        if (v75)
        {
          v172[0] = ++v128;
          int v14 = HIDWORD(v173) - 1;
        }
        shape_combine((int32x2_t *)0xFFFFFFFFLL, 0, 0, *(_DWORD *)(a1 + 20), v127, v27, v126, v128, v13 - (v73 != 0) + v126, v14 - (v72 != 0) + v128, 0);
        if (!v129) {
          goto LABEL_159;
        }
        float64x2_t v23 = (int32x2_t *)v129;
        int v130 = shape_bounds(v129, &v172[1], v172, (signed int *)&v168 + 1, &v168);
        if (v130)
        {
          int v37 = v130;
          int v38 = v168;
          int v131 = *(_DWORD *)(a1 + 24) - v168 + *(_DWORD *)(a1 + 16);
          int v40 = v172[1];
          *(_DWORD *)(a1 + 12) += v172[1];
          *(_DWORD *)(a1 + 16) = v131;
          int v41 = HIDWORD(v168);
LABEL_30:
          int v42 = v172[0];
          int v43 = v38 - v172[0];
          *(_DWORD *)(a1 + 20) = v41 - v40;
          *(_DWORD *)(a1 + 24) = v43;
          __int16 v44 = *(void **)(a1 + 72);
          if (v44 && v44 != &the_empty_shape) {
            free(v44);
          }
          if (v37 == 9)
          {
            if (v23 == (int32x2_t *)&the_empty_shape) {
              goto LABEL_19;
            }
            CGContextRef v25 = (int *)v23;
LABEL_18:
            free(v25);
LABEL_19:
            *(void *)(a1 + 72) = 0;
LABEL_20:
            *(_DWORD *)(a1 + 64) = 0;
            return 1;
          }
          if (v40 | v42)
          {
            *(void *)(a1 + 72) = shape_offset((uint64_t)v44, v23, -v40, -v42);
            *(_DWORD *)(a1 + 64) = 4 * v37;
            if (v23 != (int32x2_t *)&the_empty_shape) {
              free(v23);
            }
            return 1;
          }
          *(void *)(a1 + 72) = v23;
          int v124 = 4 * v37;
          goto LABEL_205;
        }
LABEL_156:
        if (v23 == (int32x2_t *)&the_empty_shape) {
          goto LABEL_159;
        }
        goto LABEL_157;
      }
      uint64_t v168 = 0;
      int v77 = v173 - *(_DWORD *)(a1 + 12);
      v172[0] = *(_DWORD *)(a1 + 16) - v74 + *(_DWORD *)(a1 + 24);
      v172[1] = v77;
      shape_enum_clip_alloc(v8, v9, v27, 1, 1, 1, v77, v172[0], SDWORD2(v173), SHIDWORD(v173));
      if (!v78) {
        goto LABEL_159;
      }
      uint64_t v79 = (void *)v78;
      if (shape_enum_clip_next(v78, &v172[1], v172, (_DWORD *)&v168 + 1, &v168))
      {
        if (v168 == __PAIR64__(v13, v14))
        {
          free(v79);
          uint64_t v80 = *(void **)(a1 + 72);
          if (v80 && v80 != &the_empty_shape) {
            free(v80);
          }
          *(void *)(a1 + 72) = 0;
          *(void *)(a1 + 12) = v173;
          *(_DWORD *)(a1 + 20) = v13;
          *(_DWORD *)(a1 + 24) = v14;
LABEL_232:
          *(_DWORD *)(a1 + 64) = v76;
          return 1;
        }
        unint64_t v153 = ((int)v13 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        if ((unint64_t)((int)v153 * (uint64_t)v14 + 4) >> 31) {
          size_t v154 = 0xFFFFFFFFLL;
        }
        else {
          size_t v154 = (v153 * v14 + 19) & 0xFFFFFFF0;
        }
        if ((v154 & 0x80000000) == 0)
        {
          unsigned int v155 = malloc_type_calloc(1uLL, v154, 0xD5847092uLL);
          *(void *)(a1 + 56) = v155;
          if (v155)
          {
            *(_DWORD *)(a1 + 48) = v153;
            unsigned int v156 = *(_DWORD *)(a1 + 28) & 0xFFFFFFFD;
            *(_DWORD *)(a1 + 24) = v14;
            *(_DWORD *)(a1 + 28) = v156;
            *(void *)(a1 + 12) = v173;
            *(_DWORD *)(a1 + 20) = v13;
            do
              CGBlt_fillBytes(SHIDWORD(v168), v168, -1, (char *)(*(void *)(a1 + 56) + v172[0] * v153 + v172[1]), (v13 + 3) & 0xFFFFFFFC);
            while (shape_enum_clip_next((uint64_t)v79, &v172[1], v172, (_DWORD *)&v168 + 1, &v168));
            CGSCombineMask(*(char **)(a1 + 56), (v13 + 3) & 0xFFFFFFFC, *(char **)(a1 + 56), (v13 + 3) & 0xFFFFFFFC, v13, v14, v76);
            free(v79);
            unsigned int v157 = *(void **)(a1 + 72);
            if (v157 && v157 != &the_empty_shape) {
              free(v157);
            }
            unsigned int v76 = 0;
            *(void *)(a1 + 72) = 0;
            goto LABEL_232;
          }
        }
      }
      unsigned int v132 = (int *)v79;
      goto LABEL_158;
    }
    if (*(void *)(a2 + 56))
    {
      int v103 = HIDWORD(v173);
LABEL_130:
      uint64_t v104 = (int)v173;
      int v105 = v173 - *(_DWORD *)(a1 + 12);
      int v106 = v103 + DWORD1(v173);
      int v166 = *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 16) - (v103 + DWORD1(v173));
      int v167 = v105;
      uint64_t v107 = *(int *)(a2 + 12);
      int v162 = *(_DWORD *)(a2 + 24);
      int v164 = *(_DWORD *)(a2 + 16);
      shape_enum_clip_alloc(v8, v9, v27, 1, 1, 0, v105, v166, v13, v14);
      if (v108)
      {
        uint64_t v109 = v108;
        uint64_t v161 = v107;
        int v110 = (v13 + 3) & 0xFFFFFFFC;
        if ((unint64_t)(v110 * (uint64_t)v14 + 4) >> 31) {
          size_t v111 = 0xFFFFFFFFLL;
        }
        else {
          size_t v111 = (v110 * v14 + 19) & 0xFFFFFFF0;
        }
        if ((v111 & 0x80000000) == 0)
        {
          unsigned int v112 = malloc_type_malloc(v111, 0x8F2EEE60uLL);
          *(void *)(a1 + 56) = v112;
          if (v112)
          {
            uint64_t v113 = v104 - v161;
            int v114 = v164 - v106 + v162;
            *(_DWORD *)(a1 + 48) = v110;
            unsigned int v115 = *(_DWORD *)(a1 + 28) & 0xFFFFFFFD;
            *(_DWORD *)(a1 + 24) = v14;
            *(_DWORD *)(a1 + 28) = v115;
            *(void *)(a1 + 12) = v173;
            *(_DWORD *)(a1 + 20) = v13;
            while (1)
            {
              int v116 = shape_enum_clip_next((uint64_t)v109, &v167, &v166, &v171, &v170);
              if (!v116) {
                break;
              }
              int v120 = (__n128 *)(*(void *)(a1 + 56) + v166 * v110 + v167);
              if (v116 < 0)
              {
                CGBlt_fillBytes(v171, v170, 0, (char *)v120, (v13 + 3) & 0xFFFFFFFC);
              }
              else
              {
                int v121 = *(_DWORD *)(a2 + 48);
                unsigned int v122 = (char *)(*(void *)(a2 + 56) + v167 + v113 + (v121 * (v166 + v114)));
                int v123 = (v13 + 3) & 0xFFFFFFFC;
                if (a3 < 0) {
                  CGBlt_combineBytes(v171, v170, v122, v120, v121, v123, 1280, v117, v118, v119);
                }
                else {
                  CGBlt_copyBytes(v171, v170, v122, (char *)v120, v121, v123);
                }
              }
            }
            free(v109);
            CGContextRef v25 = *(int **)(a1 + 72);
            if (v25 == v27)
            {
              CGContextRef v25 = v27;
              goto LABEL_16;
            }
            if (!v27 || v27 == (int *)&the_empty_shape)
            {
LABEL_16:
              if (!v25 || v25 == (int *)&the_empty_shape) {
                goto LABEL_19;
              }
              goto LABEL_18;
            }
            unsigned int v24 = v27;
            goto LABEL_14;
          }
        }
        free(v109);
      }
      if (*(int **)(a1 + 72) == v27 || !v27 || v27 == (int *)&the_empty_shape) {
        goto LABEL_159;
      }
      unsigned int v132 = v27;
      goto LABEL_158;
    }
    if (*(void *)(a1 + 20) == *((void *)&v173 + 1)) {
      goto LABEL_144;
    }
LABEL_242:
    CGAffineTransform v28 = 0;
LABEL_27:
    int v29 = *(_DWORD *)(a2 + 16);
    int v30 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a1 + 12);
    int v31 = *(_DWORD *)(a1 + 20);
    int v32 = *(_DWORD *)(a1 + 24);
    int v33 = v32 + *(_DWORD *)(a1 + 16);
    int v34 = *(_DWORD *)(a2 + 20);
    v172[0] = v33 - (v29 + *(_DWORD *)(a2 + 24));
    v172[1] = v30;
    shape_combine((int32x2_t *)(a3 >> 31), 0, 0, v31, v32, v27, v30, v172[0], v34 + v30, v33 - v29, v28);
    if (!v35) {
      goto LABEL_159;
    }
    float64x2_t v23 = (int32x2_t *)v35;
    int v36 = shape_bounds(v35, &v172[1], v172, (signed int *)&v169 + 1, &v169);
    if (v36)
    {
      int v37 = v36;
      int v38 = v169;
      int v39 = *(_DWORD *)(a1 + 24) - v169 + *(_DWORD *)(a1 + 16);
      int v40 = v172[1];
      *(_DWORD *)(a1 + 12) += v172[1];
      *(_DWORD *)(a1 + 16) = v39;
      int v41 = HIDWORD(v169);
      goto LABEL_30;
    }
    goto LABEL_156;
  }
  unsigned int v58 = *(_DWORD *)(a1 + 64);
  CGAffineTransform v28 = *(int32x2_t **)(a2 + 72);
  if (!v58)
  {
    if (v28) {
      goto LABEL_27;
    }
    unsigned int v58 = *(_DWORD *)(a2 + 64);
    if (!v58)
    {
      if (*(void *)(a2 + 56))
      {
        shape_alloc_bounds(v8, 0, 0, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24));
        float64x2_t v27 = (int *)v8;
        int v103 = HIDWORD(v173);
        goto LABEL_130;
      }
      if ((a3 & 0x80000000) == 0)
      {
        *(_OWORD *)uint64_t v6 = v173;
        return 1;
      }
      goto LABEL_242;
    }
    if (a3 < 0) {
      goto LABEL_68;
    }
    uint64_t v99 = v7;
    goto LABEL_212;
  }
  if (v28)
  {
    if ((a3 & 0x80000000) == 0)
    {
      uint64_t v163 = *((void *)&v173 + 1);
      unsigned int v59 = ripl_Containment(&v173, v6, v58);
      int v60 = (v13 + 3) & 0xFFFFFFFC;
      if ((unint64_t)(v14 * (uint64_t)v60 + 4) >> 31) {
        size_t v61 = 0xFFFFFFFFLL;
      }
      else {
        size_t v61 = (v14 * v60 + 19) & 0xFFFFFFF0;
      }
      if ((v61 & 0x80000000) != 0) {
        goto LABEL_159;
      }
      unsigned int v62 = v59;
      int8x8_t v63 = malloc_type_malloc(v61, 0xBB88B74AuLL);
      *(void *)(a1 + 56) = v63;
      if (!v63) {
        goto LABEL_159;
      }
      *(_DWORD *)(a1 + 48) = v60;
      *(_DWORD *)(a1 + 28) &= ~2u;
      *(void *)(a1 + 12) = v173;
      *(void *)(a1 + 20) = v163;
      uint64_t v8 = (uint64_t)memset(v63, 255, v61);
      if (!v62) {
        goto LABEL_220;
      }
      int32x2_t v64 = *(char **)(a1 + 56);
      int v65 = (v13 + 3) & 0xFFFFFFFC;
      int v66 = v13;
      int v67 = v14;
      unsigned int v68 = v62;
LABEL_219:
      uint64_t v8 = CGSCombineMask(0, 0, v64, v65, v66, v67, v68);
LABEL_220:
      *(_DWORD *)(a1 + 64) = 0;
      double v16 = *(int **)(a2 + 72);
      goto LABEL_4;
    }
LABEL_213:
    unint64_t v150 = (*(int *)(a1 + 20) + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if ((v150 * *(int *)(a1 + 24) + 4) >> 31) {
      size_t v151 = 0xFFFFFFFFLL;
    }
    else {
      size_t v151 = (v150 * *(_DWORD *)(a1 + 24) + 19) & 0xFFFFFFF0;
    }
    if ((v151 & 0x80000000) != 0) {
      goto LABEL_159;
    }
    unsigned int v152 = malloc_type_malloc(v151, 0xA64D168CuLL);
    *(void *)(a1 + 56) = v152;
    if (!v152) {
      goto LABEL_159;
    }
    *(_DWORD *)(a1 + 48) = v150;
    *(_DWORD *)(a1 + 28) &= ~2u;
    memset(v152, 255, v151);
    int32x2_t v64 = *(char **)(a1 + 56);
    int v66 = *(_DWORD *)(a1 + 20);
    int v67 = *(_DWORD *)(a1 + 24);
    unsigned int v68 = *(_DWORD *)(a1 + 64);
    int v65 = v150;
    goto LABEL_219;
  }
  unsigned int v100 = *(_DWORD *)(a2 + 64);
  if (v100)
  {
    if (a3 < 0)
    {
      unint64_t v142 = (*(int *)(a1 + 20) + 3) & 0xFFFFFFFFFFFFFFFCLL;
      if ((v142 * *(int *)(a1 + 24) + 4) >> 31) {
        size_t v143 = 0xFFFFFFFFLL;
      }
      else {
        size_t v143 = (v142 * *(_DWORD *)(a1 + 24) + 19) & 0xFFFFFFF0;
      }
      if ((v143 & 0x80000000) != 0) {
        goto LABEL_159;
      }
      int v144 = malloc_type_malloc(v143, 0xE15CC3uLL);
      *(void *)(a1 + 56) = v144;
      if (!v144) {
        goto LABEL_159;
      }
      *(_DWORD *)(a1 + 48) = v142;
      *(_DWORD *)(a1 + 28) &= ~2u;
      memset(v144, 255, v143);
      CGSCombineMask(0, 0, *(char **)(a1 + 56), v142, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 64));
      *(_DWORD *)(a1 + 64) = 0;
      int v45 = *(_DWORD *)(a2 + 64);
      double v12 = *((double *)&v173 + 1);
LABEL_40:
      int v46 = *(_DWORD *)(a2 + 12);
      int v47 = *(_DWORD *)(a2 + 16);
      if (v173 == v46) {
        unsigned int v48 = v45 & 0xFF000000;
      }
      else {
        unsigned int v48 = 0;
      }
      int v49 = v45;
      if (DWORD1(v173) != v47) {
        int v49 = 0;
      }
      if (LODWORD(v12) + v173 == *(_DWORD *)(a2 + 20) + v46) {
        int v50 = v45 & 0xFF00;
      }
      else {
        int v50 = 0;
      }
      int v51 = v45 & 0xFF0000;
      if (HIDWORD(v12) + DWORD1(v173) == *(_DWORD *)(a2 + 24) + v47) {
        int v52 = v51;
      }
      else {
        int v52 = 0;
      }
      unsigned int v53 = v49 | v48 | v50 | v52;
      uint64_t v54 = (int)v173 - (uint64_t)*(int *)(a1 + 12);
      int v55 = *(_DWORD *)(a1 + 16) - (HIDWORD(v12) + DWORD1(v173)) + *(_DWORD *)(a1 + 24);
      v172[0] = v55;
      v172[1] = v54;
      if ((a3 & 0x80000000) == 0)
      {
        if (v53)
        {
          int v56 = *(_DWORD *)(a1 + 48);
          int32x2_t v57 = (char *)(*(void *)(a1 + 56) + v54 + (v56 * v55));
          CGSCombineMask(v57, v56, v57, v56, v13, v14, v53);
        }
        if (*(_DWORD *)(a1 + 20) == v13 && *(_DWORD *)(a1 + 24) == v14) {
          goto LABEL_15;
        }
LABEL_96:
        int v88 = v172[0];
LABEL_97:
        if (v172[1] >= 1) {
          CGBlt_fillBytes(v172[1], v170, 0, (char *)(*(void *)(a1 + 56) + (*(_DWORD *)(a1 + 48) * v88)), *(_DWORD *)(a1 + 48));
        }
        if (v88 >= 1) {
          bzero(*(void **)(a1 + 56), (*(_DWORD *)(a1 + 48) * v88));
        }
        int v89 = *(_DWORD *)(a1 + 20);
        if (v89 > (int)v13 + v172[1]) {
          CGBlt_fillBytes(v89 - (v13 + v172[1]), v170, 0, (char *)(*(void *)(a1 + 56) + (*(_DWORD *)(a1 + 48) * v88) + (int)v13 + v172[1]), *(_DWORD *)(a1 + 48));
        }
        int v90 = *(_DWORD *)(a1 + 24);
        BOOL v91 = __OFSUB__(v90, v170 + v88);
        int v92 = v90 - (v170 + v88);
        if (!((v92 < 0) ^ v91 | (v92 == 0))) {
          bzero((void *)(*(void *)(a1 + 56) + (*(_DWORD *)(a1 + 48) * (v170 + v88))), (*(_DWORD *)(a1 + 48) * v92));
        }
        goto LABEL_15;
      }
      int v93 = v13 - ((v53 & 0xFF000000) != 0) - (v50 != 0);
      signed int v94 = v14 - (v52 != 0) - (v49 != 0);
      if (v93 < 1 || v94 < 1) {
        goto LABEL_15;
      }
      if (v52) {
        int v96 = v55 + 1;
      }
      else {
        int v96 = v55;
      }
      if ((v53 & 0xFF000000) != 0) {
        LODWORD(v54) = v54 + 1;
      }
      int v97 = *(_DWORD *)(a1 + 48);
      uint64_t v98 = (char *)(*(void *)(a1 + 56) + (v97 * v96) + (int)v54);
LABEL_115:
      CGBlt_fillBytes(v93, v94, 0, v98, v97);
      goto LABEL_15;
    }
    int v101 = v173;
    if (v173 == *v6)
    {
      unsigned int v102 = HIBYTE(v58);
      if (v173 == *v7) {
        unsigned int v102 = 255 - (((HIBYTE(v100) ^ 0xFF) * (v102 ^ 0xFF) + (((HIBYTE(v100) ^ 0xFF) * (v102 ^ 0xFF)) >> 8) + 1) >> 8);
      }
    }
    else
    {
      *uint64_t v6 = v173;
      unsigned int v102 = HIBYTE(v100);
    }
    int v145 = DWORD1(v173);
    if (DWORD1(v173) == *(_DWORD *)(a1 + 16))
    {
      unsigned int v146 = v58;
      if (DWORD1(v173) == *(_DWORD *)(a2 + 16)) {
        unsigned int v146 = 255
      }
             - (((v100 ^ 0xFF) * (v58 ^ 0xFF)
               + (((v100 ^ 0xFF) * (v58 ^ 0xFFu)) >> 8)
               + 1) >> 8);
    }
    else
    {
      *(_DWORD *)(a1 + 16) = DWORD1(v173);
      unsigned int v146 = v100;
    }
    if (v13 == *(_DWORD *)(a1 + 20))
    {
      unsigned int v147 = BYTE1(v58);
      if (v101 + v13 == *(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 12)) {
        unsigned int v147 = 255
      }
             - (((BYTE1(v100) ^ 0xFF) * (BYTE1(v58) ^ 0xFF) + (((BYTE1(v100) ^ 0xFF) * (BYTE1(v58) ^ 0xFFu)) >> 8) + 1) >> 8);
    }
    else
    {
      *(_DWORD *)(a1 + 20) = v13;
      unsigned int v147 = BYTE1(v100);
    }
    unsigned int v148 = BYTE2(v100);
    if (v14 == *(_DWORD *)(a1 + 24))
    {
      unsigned int v148 = 255 - (((v148 ^ 0xFF) * (BYTE2(v58) ^ 0xFF) + (((v148 ^ 0xFF) * (BYTE2(v58) ^ 0xFF)) >> 8) + 1) >> 8);
      if (v145 + v14 != *(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 16)) {
        unsigned int v148 = BYTE2(v58);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 24) = v14;
    }
    int v124 = v146 | (v102 << 24) | (v147 << 8) | (v148 << 16);
LABEL_205:
    *(_DWORD *)(a1 + 64) = v124;
    return 1;
  }
  if (!*(void *)(a2 + 56))
  {
    if (a3 < 0) {
      goto LABEL_213;
    }
    uint64_t v99 = v6;
LABEL_212:
    int v149 = ripl_Containment(&v173, v99, v58);
    *(_OWORD *)uint64_t v6 = v173;
    *(_DWORD *)(a1 + 64) = v149;
    return 1;
  }
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v165 = *((void *)&v173 + 1);
    unsigned int v135 = ripl_Containment(&v173, v6, v58);
    int v136 = (v13 + 3) & 0xFFFFFFFC;
    if ((unint64_t)(v14 * (uint64_t)v136 + 4) >> 31) {
      size_t v137 = 0xFFFFFFFFLL;
    }
    else {
      size_t v137 = (v14 * v136 + 19) & 0xFFFFFFF0;
    }
    if ((v137 & 0x80000000) == 0)
    {
      int v138 = (char *)malloc_type_malloc(v137, 0xF308BA06uLL);
      *(void *)(a1 + 56) = v138;
      if (v138)
      {
        *(_DWORD *)(a1 + 48) = v136;
        *(_DWORD *)(a1 + 28) &= ~2u;
        *(void *)&long long v139 = v173;
        int v140 = DWORD1(v173);
        int v141 = v173;
        *((void *)&v139 + 1) = v165;
        *(_OWORD *)(a1 + 12) = v139;
        CGBlt_copyBytes(v13, v14, (char *)(*(void *)(a2 + 56)+ (*(_DWORD *)(a2 + 48)* (*(_DWORD *)(a2 + 16) + *(_DWORD *)(a2 + 24) - HIDWORD(v173) - v140))- *(int *)(a2 + 12)+ v141), v138, *(_DWORD *)(a2 + 48), (v13 + 3) & 0xFFFFFFFC);
        if (v135) {
          CGSCombineMask(*(char **)(a1 + 56), *(_DWORD *)(a1 + 48), *(char **)(a1 + 56), *(_DWORD *)(a1 + 48), v13, v14, v135);
        }
        goto LABEL_20;
      }
    }
    goto LABEL_159;
  }
  unint64_t v158 = (*(int *)(a1 + 20) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((v158 * *(int *)(a1 + 24) + 4) >> 31) {
    size_t v159 = 0xFFFFFFFFLL;
  }
  else {
    size_t v159 = (v158 * *(_DWORD *)(a1 + 24) + 19) & 0xFFFFFFF0;
  }
  if ((v159 & 0x80000000) == 0)
  {
    unsigned int v160 = malloc_type_malloc(v159, 0x5FA7D7EEuLL);
    *(void *)(a1 + 56) = v160;
    if (v160)
    {
      *(_DWORD *)(a1 + 48) = v158;
      *(_DWORD *)(a1 + 28) &= ~2u;
      memset(v160, 255, v159);
      CGSCombineMask(0, 0, *(char **)(a1 + 56), v158, *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 64));
      *(_DWORD *)(a1 + 64) = 0;
      int v82 = HIDWORD(v173);
      uint64_t v81 = *(void *)(a2 + 56);
      uint64_t v15 = *(void *)(a1 + 56);
LABEL_90:
      int v83 = v82 + DWORD1(v173);
      int v84 = *(_DWORD *)(a2 + 48);
      uint64_t v85 = (_OWORD *)(v81
                     + (*(_DWORD *)(a2 + 24) + *(_DWORD *)(a2 + 16) - v83) * v84
                     + (int)v173
                     - (uint64_t)*(int *)(a2 + 12));
      uint64_t v86 = (int)v173 - (uint64_t)*(int *)(a1 + 12);
      v172[0] = *(_DWORD *)(a1 + 16) - v83 + *(_DWORD *)(a1 + 24);
      v172[1] = v86;
      if (a3 >= 0) {
        __int16 v87 = 256;
      }
      else {
        __int16 v87 = 1024;
      }
      CGBlt_combineBytes(v13, v14, v85, (__n128 *)(v15 + *(_DWORD *)(a1 + 48) * v172[0] + v86), v84, *(_DWORD *)(a1 + 48), v87, v12, v10, v11);
      if (a3 < 0) {
        goto LABEL_15;
      }
      LODWORD(v13) = v171;
      if (*(_DWORD *)(a1 + 20) == v171)
      {
        LODWORD(v13) = *(_DWORD *)(a1 + 20);
        if (*(_DWORD *)(a1 + 24) == v170) {
          goto LABEL_15;
        }
      }
      goto LABEL_96;
    }
  }
LABEL_159:
  unsigned int v133 = *(void **)(a1 + 56);
  if (v133 && (*(unsigned char *)(a1 + 28) & 2) == 0) {
    free(v133);
  }
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  int v134 = *(void **)(a1 + 72);
  if (v134 && v134 != &the_empty_shape) {
    free(v134);
  }
  uint64_t result = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

uint64_t ripc_DrawGlyphs(uint64_t a1, unsigned __int8 *a2, uint64_t a3, double *a4, __int16 *a5, uint64_t a6, unint64_t a7)
{
  if (ripc_DrawGlyphs_once != -1) {
    dispatch_once_f(&ripc_DrawGlyphs_once, 0, (dispatch_function_t)get_defaults);
  }
  int v14 = *(double **)(a3 + 136);
  unsigned int v15 = *(unsigned __int16 *)v14;
  unsigned int v16 = ((__int16)v15 >> 8) & 0xFFFFFFFB;
  if (v16 != 3)
  {
    if (a1) {
      a1 = *(void *)(a1 + 288);
    }
    double v17 = *(double *)(a3 + 24);
    double v18 = *(double *)(a1 + 40);
    if (v18 == 1.0)
    {
      float64x2_t v19 = *(float64x2_t *)(a3 + 32);
      float64x2_t v20 = *(float64x2_t *)(a3 + 48);
      double v21 = *(double *)(a3 + 64);
    }
    else
    {
      double v17 = v18 * v17;
      float64x2_t v19 = vmulq_n_f64(*(float64x2_t *)(a3 + 32), v18);
      float64x2_t v20 = vmulq_n_f64(*(float64x2_t *)(a3 + 48), v18);
      double v21 = v18 * *(double *)(a3 + 64);
    }
    double v22 = a4[1];
    double v24 = a4[2];
    double v23 = a4[3];
    double v25 = a4[4];
    double v26 = a4[5];
    double v27 = vmuld_lane_f64(v22, v19, 1) + *a4 * v17;
    double v28 = vmlad_n_f64(v22 * v20.f64[0], *a4, v19.f64[0]);
    v80.f64[0] = v27;
    v80.f64[1] = v28;
    double v29 = vmuld_lane_f64(v23, v19, 1) + v24 * v17;
    double v30 = vmlad_n_f64(v23 * v20.f64[0], v24, v19.f64[0]);
    v81.f64[0] = v29;
    v81.f64[1] = v30;
    double v78 = vmlad_n_f64(v26 * v20.f64[0], v25, v19.f64[0]) + v21;
    double v79 = v20.f64[1] + vmuld_lane_f64(v26, v19, 1) + v25 * v17;
    *(double *)&long long v82 = v79;
    *((double *)&v82 + 1) = v78;
    if (!v16
      && should_use_glyph_bitmaps
      && ((double v31 = v14[2], v32 = v31 * (fabs(v27) + fabs(v28)), v33 = v31 * (fabs(v29) + fabs(v30)), v32 <= 1024.0)
        ? (BOOL v34 = v33 <= 1024.0)
        : (BOOL v34 = 0),
          v34))
    {
      long long v91 = 0u;
      long long v92 = 0u;
      long long v90 = 0u;
      if (ripc_GetRenderingState(a1, (uint64_t)a2, a3, (uint64_t)&v90))
      {
        int AllowedFontRenderingStyle = CGRenderingStateGetAllowedFontRenderingStyle(a2);
        uint64_t v67 = CGGStateGetFontRenderingStyle(a3) & AllowedFontRenderingStyle;
        if ((v67 & 2) != 0
          && ((*(unsigned char *)(*(void *)(a1 + 48) + 29) & 1) == 0
           || *((void *)&v92 + 1) && !should_enable_lcd_styles
           || (int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 16) >= 50331648))
        {
          v67 &= 0x3DFDu;
        }
        if ((v67 & 1) != 0 && a7 >= 2 && (**(_WORD **)(a3 + 136) & 0x80) != 0) {
          draw_glyph_bitmap_run_with_compositing(a1, v68, (uint64_t)a2, a3, (uint64_t)&v90, v67, (uint64_t)&v80, (uint64_t)a5, a6, a7);
        }
        else {
          draw_glyph_bitmaps(a1, (uint64_t)a2, a3, (int *)&v90, v68, v67, (uint64_t)&v80, a5, a6, a7);
        }
      }
    }
    else
    {
      if (v15 >= 0x700 || (unsigned int v35 = v15 >> 8, ((0x77u >> SBYTE1(v15)) & 1) == 0)) {
        abort();
      }
      long long v94 = 0u;
      long long v95 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      uint64_t v85 = 0;
      uint64_t v36 = (uint64_t)a2;
      if (ripc_GetRenderingState(a1, (uint64_t)a2, a3, (uint64_t)&v87))
      {
        unsigned int v71 = (0x66u >> v35) & 1;
        uint64_t v37 = *(void *)(a3 + 136);
        int v38 = *(CGFont **)(v37 + 8);
        double v39 = *(double *)(v37 + 16);
        float64x2_t v76 = v81;
        float64x2_t v77 = v80;
        float64x2_t v69 = vmulq_n_f64(v81, v39);
        float64x2_t v70 = vmulq_n_f64(v80, v39);
        float64x2_t v96 = v70;
        float64x2_t v97 = v69;
        *(_OWORD *)uint64_t v98 = v82;
        get_glyph_bounding_box(v38, &v96);
        CGFloat v74 = v41;
        CGFloat v75 = v40;
        CGFloat v72 = v43;
        CGFloat v73 = v42;
        font_float64x2_t info = (int *)get_font_info(v38);
        if (font_info) {
          double v45 = (double)font_info[2];
        }
        else {
          double v45 = 0.0;
        }
        double v46 = 1.0 / v45;
        float64x2_t v96 = vmulq_n_f64(v70, v46);
        float64x2_t v97 = vmulq_n_f64(v69, v46);
        uint64_t v86 = (char *)&v88 + 8;
        v83[0] = *(void *)(*(void *)(a3 + 144) + 8);
        long long v84 = *(_OWORD *)(a1 + 24);
        v83[1] = 0x3FF0000000000000;
        unsigned __int8 v47 = a2[81];
        if (v47) {
          unsigned __int8 v47 = *(unsigned char *)(*(void *)(a3 + 120) + 7) & 1;
        }
        LOBYTE(v85) = v47;
        if (v71) {
          ripc_GetRenderStroke(a3, (uint64_t)&v90, (long long *)(a3 + 24));
        }
        if (a7)
        {
          unsigned int v48 = (0x5Du >> v35) & 1;
          double v49 = (double)SDWORD1(v89);
          double v50 = (double)(int)v89;
          double v51 = (double)SHIDWORD(v88);
          double v52 = (double)SDWORD2(v88);
          unsigned int v53 = (double *)(a6 + 8);
          do
          {
            double v54 = *(v53 - 1);
            double v55 = v79 + *v53 * v76.f64[0] + v77.f64[0] * v54;
            double v56 = v78 + *v53 * v76.f64[1] + v77.f64[1] * v54;
            v99.origin.CGFloat y = v74;
            v99.origin.double x = v75;
            v99.size.size_t height = v72;
            v99.size.size_t width = v73;
            CGRect v101 = CGRectOffset(v99, v55, v56);
            v100.origin.double x = v52;
            v100.origin.CGFloat y = v51;
            v100.size.size_t width = v50;
            v100.size.size_t height = v49;
            if (CGRectIntersectsRect(v100, v101))
            {
              v98[0] = v55;
              v98[1] = v56;
              CGMutablePathRef GlyphPath = CGFontCreateGlyphPath((uint64_t)v38, (uint64_t)&v96);
              if (GlyphPath)
              {
                unsigned int v58 = GlyphPath;
                if (v48)
                {
                  unsigned int v59 = *(_DWORD **)(a1 + 56);
                  if (!v59)
                  {
                    unsigned int v59 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
                    *(void *)unsigned int v59 = RIPRenderCreate_ripr_class;
                    v59[2] = 1;
                    *((void *)v59 + 2) = 0;
                    *(void *)(a1 + 56) = v59;
                  }
                  RIPRenderPath((char *)v59, (uint64_t)v83, v58, 0);
                }
                if (v71)
                {
                  int v60 = *(_DWORD **)(a1 + 64);
                  if (!v60)
                  {
                    int v60 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
                    *(void *)int v60 = RIPRenderCreate_ripr_class;
                    v60[2] = 1;
                    *((void *)v60 + 2) = 0;
                    *(void *)(a1 + 64) = v60;
                  }
                  RIPRenderPath((char *)v60, (uint64_t)v83, v58, (uint64_t)&v90);
                }
                CFRelease(v58);
                ripc_Render(a1, v36, a3, (uint64_t *)&v87, v71 | (2 * v48), v61, v62, v63, v64);
              }
            }
            ++a5;
            v53 += 2;
            --a7;
          }
          while (a7);
        }
      }
    }
  }
  return 0;
}

uint64_t CGGStateGetFontRenderingStyle(uint64_t a1)
{
  uint64_t v1 = *(__int16 **)(a1 + 136);
  __int16 v2 = *v1;
  if ((*v1 & 4) != 0)
  {
    if ((v2 & 8) != 0) {
      int v4 = 3;
    }
    else {
      int v4 = 1;
    }
    if ((v2 & 0x20) != 0) {
      int v5 = 12;
    }
    else {
      int v5 = 4;
    }
    int v6 = v4 | v5;
    if ((v2 & 0x10) != 0) {
      int v3 = v6;
    }
    else {
      int v3 = v4;
    }
    if ((*(unsigned char *)(*(void *)(a1 + 120) + 7) & 1) == 0) {
      int v3 = 0;
    }
  }
  else
  {
    int v3 = 0;
  }
  return *((_DWORD *)v1 + 12) | v3 | (*((_DWORD *)v1 + 13) | *((_DWORD *)v1 + 14));
}

uint64_t CGRenderingStateGetAllowedFontRenderingStyle(unsigned __int8 *a1)
{
  int v1 = a1[81];
  if (a1[81])
  {
    int v1 = a1[83];
    if (a1[83])
    {
      int v1 = a1[84] ? 3 : 1;
      if (a1[85])
      {
        if (a1[86]) {
          int v2 = 12;
        }
        else {
          int v2 = 4;
        }
        v1 |= v2;
      }
    }
  }
  return v1 | 0x3DF0u;
}

void draw_glyph_bitmaps(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, __n128 a5, uint64_t a6, uint64_t a7, __int16 *a8, uint64_t a9, uint64_t a10)
{
  uint64_t v67 = a3;
  uint64_t v66 = a1;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a5);
  double v18 = (char *)&v51 - v17;
  if (v16 <= 0x1FFFFFFFFFFFFFFELL) {
    float64x2_t v19 = (char *)&v51 - v17;
  }
  else {
    float64x2_t v19 = 0;
  }
  int v20 = v15;
  if (v16 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000102) {
    float64x2_t v19 = (char *)malloc_type_malloc(8 * a10, 0x956ACBCuLL);
  }
  int32x2_t v73 = 0;
  uint64_t v74 = 0;
  float64x2_t v69 = 0u;
  float64x2_t v70 = 0u;
  long long v71 = 0u;
  if (v19)
  {
    uint64_t v64 = a2;
    int v65 = &v51;
    uint64_t v21 = MEMORY[0x1F4188790](v19, (__n128)0);
    double v24 = (char *)&v51 - v23;
    if (v22 <= 0x3FFFFFFFFFFFFFFELL) {
      double v25 = (char *)&v51 - v23;
    }
    else {
      double v25 = 0;
    }
    __n128 v68 = (char *)v21;
    if (v22 - 0x3FFFFFFFFFFFFFFFLL >= 0xC000000000000102) {
      double v25 = (char *)malloc_type_malloc(4 * a10, 0xE98C3CE7uLL);
    }
    if (v25)
    {
      uint64_t v63 = v18;
      uint64_t v62 = v24;
      uint64_t v26 = v67;
      uint64_t v27 = *(void *)(v67 + 136);
      double v28 = *(double *)(v27 + 16);
      float64x2_t v29 = vmulq_n_f64(*(float64x2_t *)a7, v28);
      float64x2_t v30 = vmulq_n_f64(*(float64x2_t *)(a7 + 16), v28);
      float64x2_t v69 = v29;
      float64x2_t v70 = v30;
      long long v71 = *(_OWORD *)(a7 + 32);
      unint64_t v31 = *(void *)(v27 + 88);
      int v61 = v20;
      unint64_t QuantizationLevelWithStyle = CGFontGetQuantizationLevelWithStyle((uint64_t)&v69, v20, v31);
      CGFontGetGlyphIdentifiers(a8, (float64x2_t *)a7, a9, a10, &QuantizationLevelWithStyle, (uint64_t)v25, (uint64_t)v68, &v73);
      double v32 = *(CGFont **)(*(void *)(v26 + 136) + 8);
      double v33 = (double)a4[6];
      double v34 = (double)a4[7];
      double v35 = (double)a4[8];
      double v36 = (double)a4[9];
      double v37 = (double)v73.i32[0];
      double v38 = (double)v73.i32[1];
      int v39 = v74;
      int v40 = HIDWORD(v74);
      double v41 = (double)(int)v74;
      double v42 = (double)SHIDWORD(v74);
      v76.origin.CGFloat x = v33;
      v76.origin.CGFloat y = v34;
      v76.size.CGFloat width = v35;
      v76.size.CGFloat height = v36;
      v90.origin.CGFloat x = (double)v73.i32[0];
      v90.origin.CGFloat y = (double)v73.i32[1];
      v90.size.CGFloat width = (double)(int)v74;
      v90.size.CGFloat height = (double)SHIDWORD(v74);
      if (CGRectIntersectsRect(v76, v90)) {
        goto LABEL_21;
      }
      CGFloat v56 = v34;
      double v51 = a4;
      get_glyph_bounding_box(v32, &v69);
      CGRect v78 = CGRectIntegral(v77);
      CGFloat x = v78.origin.x;
      CGFloat y = v78.origin.y;
      CGFloat width = v78.size.width;
      CGFloat height = v78.size.height;
      int v43 = v39 | v40;
      unsigned int v44 = (v39 | v40) >> 31;
      CGFloat v45 = v37;
      CGFloat v46 = v38;
      if (v43 < 0)
      {
        v79.origin.CGFloat x = v37;
        v79.origin.CGFloat y = v38;
        v79.size.CGFloat width = v41;
        v79.size.CGFloat height = (double)v40;
        *(void *)&CGFloat v45 = (unint64_t)CGRectStandardize(v79);
        v80.origin.CGFloat x = v37;
        v80.origin.CGFloat y = v38;
        v80.size.CGFloat width = v41;
        v80.size.CGFloat height = (double)v40;
        CGRect v81 = CGRectStandardize(v80);
        CGFloat v46 = v81.origin.y;
      }
      v82.origin.CGFloat x = x;
      v82.origin.CGFloat y = y;
      v82.size.CGFloat width = width;
      v82.size.CGFloat height = height;
      CGRect v83 = CGRectOffset(v82, v45, v46);
      CGFloat v55 = v83.origin.x;
      CGFloat v54 = v83.origin.y;
      CGFloat v53 = v83.size.width;
      CGFloat v52 = v83.size.height;
      unsigned __int8 v47 = v63;
      if (v44)
      {
        v84.origin.CGFloat x = v37;
        v84.origin.CGFloat y = v38;
        v84.size.CGFloat width = v41;
        v84.size.CGFloat height = v42;
        CGRect v85 = CGRectStandardize(v84);
        double v48 = v85.origin.x + v85.size.width;
        v85.origin.CGFloat x = v37;
        v85.origin.CGFloat y = v38;
        v85.size.CGFloat width = v41;
        v85.size.CGFloat height = v42;
        CGRect v86 = CGRectStandardize(v85);
        double v38 = v86.origin.y;
        double v42 = v86.size.height;
      }
      else
      {
        double v48 = v37 + v41;
      }
      v87.origin.CGFloat x = x;
      v87.origin.CGFloat y = y;
      v87.size.CGFloat width = width;
      v87.size.CGFloat height = height;
      CGRect v91 = CGRectOffset(v87, v48, v38 + v42);
      v88.origin.CGFloat x = v55;
      v88.origin.CGFloat y = v54;
      v88.size.CGFloat width = v53;
      v88.size.CGFloat height = v52;
      CGRect v89 = CGRectUnion(v88, v91);
      v92.origin.CGFloat x = v33;
      v92.origin.CGFloat y = v56;
      v92.size.CGFloat width = v35;
      v92.size.CGFloat height = v36;
      if (CGRectIntersectsRect(v89, v92)) {
LABEL_21:
      }
        CGGlyphBuilderCreate();
      if (v25 != v62) {
        free(v25);
      }
      double v49 = v68;
      BOOL v50 = v68 == v47;
    }
    else
    {
      double v49 = v68;
      BOOL v50 = v68 == v18;
    }
    if (!v50) {
      free(v49);
    }
  }
}

BOOL CGRectIntersectsRect(CGRect rect1, CGRect rect2)
{
  double x = rect1.origin.x;
  if (rect1.origin.x == INFINITY || rect1.origin.y == INFINITY) {
    return 0;
  }
  double y = rect2.origin.y;
  double v5 = rect2.origin.x;
  if (rect2.origin.x == INFINITY || rect2.origin.y == INFINITY) {
    return 0;
  }
  double height = rect2.size.height;
  double width = rect2.size.width;
  double v10 = rect1.size.height;
  double v11 = rect1.size.width;
  double v12 = rect1.origin.y;
  if (rect1.size.width < 0.0 || rect1.size.height < 0.0)
  {
    CGRect v13 = CGRectStandardize(rect1);
    double x = v13.origin.x;
    double v12 = v13.origin.y;
    double v11 = v13.size.width;
    double v10 = v13.size.height;
  }
  if (width < 0.0 || height < 0.0)
  {
    v14.origin.double x = v5;
    v14.origin.double y = y;
    v14.size.double width = width;
    v14.size.double height = height;
    CGRect v15 = CGRectStandardize(v14);
    double v5 = v15.origin.x;
    double y = v15.origin.y;
    double width = v15.size.width;
    double height = v15.size.height;
  }
  if (x >= v5)
  {
    if (x > v5 && v5 + width <= x) {
      return 0;
    }
  }
  else if (x + v11 <= v5)
  {
    return 0;
  }
  if (v12 >= y) {
    return v12 <= y || y + height > v12;
  }
  return v12 + v10 > y;
}

void CGGlyphBuilderCreate()
{
  if (CGGlyphBuilderCreate::once != -1) {
    dispatch_once_f(&CGGlyphBuilderCreate::once, 0, (dispatch_function_t)defaults_setup);
  }
  operator new();
}

void sub_184C44680(_Unwind_Exception *a1)
{
  MEMORY[0x18532A2A0](v1, 0x10A0C4063A40F4BLL);
  _Unwind_Resume(a1);
}

unint64_t CGFontGetQuantizationLevelWithStyle(uint64_t a1, __int16 a2, unint64_t a3)
{
  unsigned int v5 = CGFontRenderingStyleStandardize(a2);
  if ((v5 & 4) == 0)
  {
    unint64_t v6 = 0x100000000;
    LODWORD(a3) = 1;
    return v6 | a3;
  }
  if ((v5 & 8) == 0)
  {
    unint64_t v6 = 0x8000000000;
    LODWORD(a3) = 128;
    return v6 | a3;
  }
  if (v5 > 0xFFF)
  {
LABEL_44:
    unint64_t v6 = a3 & 0xFFFFFFFF00000000;
    return v6 | a3;
  }
  if (CGFontGetQuantizationLevel_once != -1) {
    dispatch_once_f(&CGFontGetQuantizationLevel_once, 0, (dispatch_function_t)defaults_setup_21123);
  }
  LODWORD(a3) = 0;
  if (!a1 || (unsigned int v7 = QX, QX < 1))
  {
    unint64_t v6 = 0;
    return v6 | a3;
  }
  uint64_t v8 = QY;
  unint64_t v6 = 0;
  if (QY >= 1)
  {
    if (*(double *)(a1 + 8) == 0.0 && *(double *)(a1 + 16) == 0.0)
    {
      double v9 = *(double *)a1;
      double v10 = *(double *)(a1 + 24);
      if ((*(double *)a1 == v10 || v9 == -v10)
        && ((unsigned int v11 = (int)v9 - 6, v9 == (double)(int)v9) ? (v12 = v11 > 0x12) : (v12 = 1), !v12))
      {
        a3 = scale_level[v11];
      }
      else
      {
        int v13 = vcvtpd_s64_f64(1.0 / (fabs(v9) * 0.03));
        if (QX >= v13) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = QX;
        }
        if (v13 < 1) {
          uint64_t v15 = 1;
        }
        else {
          uint64_t v15 = v14;
        }
        signed int v16 = vcvtpd_s64_f64(1.0 / (fabs(v10) * 0.12));
        if (QY >= v16) {
          uint64_t v17 = v16;
        }
        else {
          uint64_t v17 = QY;
        }
        uint64_t v18 = v17 << 32;
        BOOL v12 = v16 < 1;
        uint64_t v19 = 0x100000000;
        if (!v12) {
          uint64_t v19 = v18;
        }
        a3 = v19 | v15;
      }
    }
    else
    {
      long long v20 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)&v24.double a = *(_OWORD *)a1;
      *(_OWORD *)&v24.double c = v20;
      *(_OWORD *)&v24.double tx = *(_OWORD *)(a1 + 32);
      CGAffineTransformInvert(&v25, &v24);
      if (v7 < 2)
      {
        int v21 = 1;
      }
      else
      {
        int v21 = 1;
        while ((v25.d * 0.0 + v25.b * (1.0 / (double)v21)) * (v25.d * 0.0 + v25.b * (1.0 / (double)v21))
              + (v25.c * 0.0 + v25.a * (1.0 / (double)v21)) * (v25.c * 0.0 + v25.a * (1.0 / (double)v21)) >= 0.0009)
        {
          if (v7 == ++v21)
          {
            int v21 = v7;
            break;
          }
        }
      }
      uint64_t v22 = 1;
      if ((int)v8 >= 2)
      {
        while ((v25.d * (1.0 / (double)(int)v22) + v25.b * 0.0) * (v25.d * (1.0 / (double)(int)v22) + v25.b * 0.0)
              + (v25.c * (1.0 / (double)(int)v22) + v25.a * 0.0) * (v25.c * (1.0 / (double)(int)v22) + v25.a * 0.0) >= 0.0144)
        {
          uint64_t v22 = (v22 + 1);
          if (v8 == v22)
          {
            uint64_t v22 = v8;
            break;
          }
        }
      }
      a3 = v21 | (unint64_t)(v22 << 32);
    }
    goto LABEL_44;
  }
  return v6 | a3;
}

uint64_t CGFontRenderingStyleStandardize(__int16 a1)
{
  int v1 = a1 & 0x70 | 3;
  if ((a1 & 2) == 0) {
    int v1 = a1 & 0xD80 | 1;
  }
  int v2 = v1 | 4;
  if ((a1 & 8) != 0) {
    int v2 = a1 & 0x1000 | v1 | 0xC;
  }
  if ((a1 & 4) != 0) {
    int v1 = v2;
  }
  if ((a1 & 1) == 0) {
    int v1 = 0;
  }
  return v1 | a1 & 0x200u;
}

int32x2_t CGFontGetGlyphIdentifiers(__int16 *a1, float64x2_t *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, int32x2_t *a8)
{
  if (a4)
  {
    float64x2_t v8 = *a2;
    float64x2_t v9 = a2[1];
    float64x2_t v10 = a2[2];
    v11.i64[0] = (int)*a5;
    v11.i64[1] = (int)HIDWORD(*a5);
    float64x2_t v12 = vcvtq_f64_s64(v11);
    int v13 = (double *)(a3 + 8);
    unsigned int v14 = (int *)(a7 + 4);
    uint64_t v15 = (unsigned char *)(a6 + 2);
    int32x2_t v16 = (int32x2_t)0x8000000080000000;
    int32x2_t v17 = (int32x2_t)0x8000000080000000;
    float64x2_t v18 = (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL);
    do
    {
      double v19 = *(v13 - 1);
      double v20 = *v13;
      __int16 v21 = *a1++;
      *((_WORD *)v15 - 1) = v21;
      float64x2_t v22 = vaddq_f64(vaddq_f64(v10, vmlaq_n_f64(vmulq_n_f64(v9, v20), v8, v19)), v18);
      float64x2_t v23 = vrndmq_f64(v22);
      *(int32x2_t *)&v22.f64[0] = vmovn_s64(vcvtq_s64_f64(vmulq_f64(vsubq_f64(v22, v23), v12)));
      v15[1] = BYTE4(v22.f64[0]);
      *uint64_t v15 = LOBYTE(v22.f64[0]);
      if (v23.f64[0] <= 2147483650.0)
      {
        if (v23.f64[0] >= -2147483650.0) {
          int v24 = (int)v23.f64[0];
        }
        else {
          int v24 = 0x80000000;
        }
      }
      else
      {
        int v24 = 0x7FFFFFFF;
      }
      *(v14 - 1) = v24;
      if (v23.f64[1] <= 2147483650.0)
      {
        if (v23.f64[1] >= -2147483650.0) {
          int v25 = (int)v23.f64[1];
        }
        else {
          int v25 = 0x80000000;
        }
      }
      else
      {
        int v25 = 0x7FFFFFFF;
      }
      *unsigned int v14 = v25;
      v14 += 2;
      int32x2_t v16 = vmin_s32((int32x2_t)__PAIR64__(v25, v24), v16);
      int32x2_t v17 = vmax_s32((int32x2_t)__PAIR64__(v25, v24), v17);
      v13 += 2;
      v15 += 4;
      --a4;
    }
    while (a4);
  }
  else
  {
    int32x2_t v16 = (int32x2_t)0x8000000080000000;
    int32x2_t v17 = (int32x2_t)0x8000000080000000;
  }
  int32x2_t result = vsub_s32(v17, v16);
  *a8 = v16;
  a8[1] = result;
  return result;
}

CFTypeRef *CGGlyphBuilderRelease(CFTypeRef *result)
{
  if (result)
  {
    int v1 = result;
    CFTypeRef v2 = *result;
    if (*result)
    {
      CFTypeID v3 = CFGetTypeID(*result);
      if (_block_invoke_once_3318 != -1) {
        dispatch_once(&_block_invoke_once_3318, &__block_literal_global_8_3319);
      }
      if (v3 == CGFontGetTypeID_font_type_id) {
        CFRelease(v2);
      }
    }
    int v4 = v1[15];
    if (v4)
    {
      do
      {
        unsigned int v5 = (void *)*v4;
        operator delete(v4);
        int v4 = v5;
      }
      while (v5);
    }
    unint64_t v6 = (void *)v1[13];
    v1[13] = 0;
    if (v6) {
      operator delete(v6);
    }
    JUMPOUT(0x18532A2A0);
  }
  return result;
}

void render_glyphs(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, __n128 a9)
{
  v43[0] = a4;
  v43[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a9);
  float64x2_t v18 = (char *)v43 - v17;
  if (v16 <= 0x1FFFFFFFFFFFFFFELL) {
    double v19 = (char *)v43 - v17;
  }
  else {
    double v19 = 0;
  }
  if (v16 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000402) {
    double v19 = (char *)malloc_type_malloc(8 * a8, 0x5E63105BuLL);
  }
  if (v19) {
    BOOL v20 = a8 > 0x666666666666665;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    __int16 v21 = (long long *)malloc_type_malloc(40 * a8 + 40, 0x23EBFCD2uLL);
    *(void *)__int16 v21 = 0;
    *((void *)v21 + 1) = 0;
    *((void *)v21 + 2) = 0;
    *((void *)v21 + 3) = a8;
    *((void *)v21 + 4) = 0;
    if (CGGlyphBuilderLockBitmaps((uint64_t)a2, a6, a8, (uint64_t)v19, v22, v23, v24, v25))
    {
      if (a8)
      {
        float64x2_t v30 = (_DWORD *)(a7 + 4);
        unint64_t v31 = (_DWORD **)v19;
        do
        {
          double v32 = *v31;
          if (*v31)
          {
            int v33 = v32[5];
            if (v33)
            {
              int v34 = v32[6];
              if (v34)
              {
                signed int v35 = v32[3] + *(v30 - 1);
                int v36 = v32[4] + *v30;
                uint64_t v37 = (v36 - v34);
                int v38 = *(_DWORD *)(a5 + 24);
                int v39 = *(_DWORD *)(a5 + 28);
                BOOL v40 = v38 >= v35 + v33 || *(_DWORD *)(a5 + 32) + v38 <= v35;
                BOOL v41 = v40 || *(_DWORD *)(a5 + 36) + v39 <= (int)v37;
                if (!v41 && v39 < v36) {
                  RIPGlyphListAppendBitmap((uint64_t)v21, v35, v37, (uint64_t)v32, v26, v27, v28, v29);
                }
              }
            }
          }
          v30 += 2;
          ++v31;
          --a8;
        }
        while (a8);
      }
      render_glyph_list(a1, v21, a3, v43[0], (uint64_t *)a5);
      CGGlyphBuilderUnlockBitmaps(a2);
      if (v19 != v18) {
        free(v19);
      }
      free(v21);
    }
  }
}

unint64_t RIPGlyphListAppendBitmap(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 16);
  if (v8 >= *(void *)(a1 + 24)) {
    _CGHandleAssert("RIPGlyphListAppendBitmap", 66, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPGlyphList.c", "gl->n < gl->max", "number of glyphs (%lu) out of bounds [0, %lu]", a6, a7, a8, v8);
  }
  uint64_t v11 = *(void *)(a4 + 20);
  uint64_t v12 = a2 | (unint64_t)(a3 << 32);
  if (v8)
  {
    unint64_t result = CGSBoundsUnion(*(void *)a1, *(void *)(a1 + 8), v12, *(void *)(a4 + 20));
  }
  else
  {
    unint64_t result = a2 | (unint64_t)(a3 << 32);
    uint64_t v14 = *(void *)(a4 + 20);
  }
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v14;
  int v15 = *(_DWORD *)(a4 + 20);
  int v16 = *(_DWORD *)(a1 + 36);
  if (*(_DWORD *)(a1 + 32) > v15) {
    int v15 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v15;
  int v17 = *(_DWORD *)(a4 + 24);
  if (v16 > v17) {
    int v17 = v16;
  }
  *(_DWORD *)(a1 + 36) = v17;
  *(void *)(a1 + 16) = v8 + 1;
  uint64_t v18 = a1 + 40 * v8;
  *(void *)(v18 + 40) = v12;
  *(void *)(v18 + 48) = v11;
  *(void *)(v18 + 64) = a4 + 40;
  *(_DWORD *)(v18 + 60) = *(_DWORD *)(a4 + 28);
  *(_DWORD *)(v18 + 56) = *(_DWORD *)(a4 + 32);
  *(_DWORD *)(v18 + 72) = *(_DWORD *)(a4 + 36);
  return result;
}

unint64_t CGSBoundsUnion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5 = (int)a4 < 1 || SHIDWORD(a4) < 1;
  if ((int)a2 < 1 || a2 <= 0)
  {
    BOOL v11 = !v5;
    if (v5) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = a3;
    }
    if (v11) {
      uint64_t v10 = HIDWORD(a3);
    }
    else {
      uint64_t v10 = 0;
    }
  }
  else
  {
    if ((int)a1 >= (int)a3) {
      unsigned int v6 = a3;
    }
    else {
      unsigned int v6 = a1;
    }
    if (SHIDWORD(a1) >= SHIDWORD(a3)) {
      unsigned int v7 = HIDWORD(a3);
    }
    else {
      unsigned int v7 = HIDWORD(a1);
    }
    BOOL v8 = !v5;
    if (v5) {
      unsigned int v9 = a1;
    }
    else {
      unsigned int v9 = v6;
    }
    if (v8) {
      uint64_t v10 = v7;
    }
    else {
      uint64_t v10 = HIDWORD(a1);
    }
  }
  return v9 | (unint64_t)(v10 << 32);
}

void CGGlyphBuilderUnlockBitmaps(void *a1)
{
  for (uint64_t i = (void *)a1[15]; i; uint64_t i = (void *)*i)
  {
    CFTypeID v3 = (void *)i[3];
    if (v3 && atomic_fetch_add_explicit((atomic_uint *volatile)v3, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      free(v3);
    }
  }
  if (a1[16])
  {
    int v4 = (void *)a1[15];
    if (v4)
    {
      do
      {
        BOOL v5 = (void *)*v4;
        operator delete(v4);
        int v4 = v5;
      }
      while (v5);
    }
    a1[15] = 0;
    uint64_t v6 = a1[14];
    if (v6)
    {
      for (uint64_t j = 0; j != v6; ++j)
        *(void *)(a1[13] + 8 * j) = 0;
    }
    a1[16] = 0;
  }
  uint64_t v8 = a1[12];
  if (v8)
  {
    uint64_t v9 = a1[11];
    if (!v9) {
      goto LABEL_41;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 4));
    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 104));
    unint64_t v10 = *(void *)(v8 + 96);
    os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 104));
    CGFontStrikeRelease((void *)v8);
    os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 4));
    if (!v10
      || atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 16), v10, memory_order_relaxed) + v10 <= *(void *)(v9 + 8))
    {
      goto LABEL_41;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 4));
    uint64_t v12 = (void **)(v9 + 40);
    uint64_t v11 = *(void *)(v9 + 40);
    if (v11)
    {
      int v13 = 0;
      do
      {
        int v13 = &v13[(void)CGFontStrikeGetSize(*(os_unfair_lock_s **)v11)];
        uint64_t v11 = *(void *)(v11 + 8);
      }
      while (v11);
    }
    else
    {
      int v13 = 0;
    }
    if ((unint64_t)v13 >= *(void *)(v9 + 8))
    {
      if (!*v12)
      {
        uint64_t v18 = 0;
LABEL_39:
        *uint64_t v12 = 0;
        int v13 = v18;
        goto LABEL_40;
      }
      unint64_t v14 = 0;
      uint64_t v15 = (uint64_t)*v12;
      do
      {
        ++v14;
        uint64_t v15 = *(void *)(v15 + 8);
      }
      while (v15);
      int v16 = list_sort_1(*v12, v14);
      *(void *)(v9 + 40) = v16;
      if (v16)
      {
        int v17 = v16;
        uint64_t v18 = 0;
        unint64_t v19 = 7 * *(void *)(v9 + 8) / 0xAuLL;
        while (1)
        {
          Size = CGFontStrikeGetSize((os_unfair_lock_s *)*v17);
          int v13 = &v18[(void)Size];
          if (&v18[(void)Size] > (char *)v19) {
            break;
          }
          uint64_t v21 = (uint64_t)*v12;
          uint64_t v22 = *(void **)(v21 + 8);
          uint64_t v12 = (void **)(v21 + 8);
          int v17 = v22;
          uint64_t v18 = &v18[(void)Size];
          if (!v22) {
            goto LABEL_40;
          }
        }
        uint64_t v23 = v17;
        do
        {
          uint64_t v24 = (void *)*v23;
          if (*v23) {
            uint64_t v25 = (const void *)(*v23 + 8);
          }
          else {
            uint64_t v25 = 0;
          }
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v9 + 32), v25);
          CGFontStrikeRelease(v24);
          uint64_t v23 = (void *)v23[1];
        }
        while (v23);
        do
        {
          uint64_t v26 = (void *)v17[1];
          free(v17);
          int v17 = v26;
        }
        while (v26);
        goto LABEL_39;
      }
      int v13 = 0;
    }
LABEL_40:
    *(void *)(v9 + 16) = v13;
    os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 4));
LABEL_41:
    a1[12] = 0;
  }
}

void CGFontStrikeRelease(void *a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    for (uint64_t i = 0; i != 256; ++i)
    {
      CFTypeID v3 = (void *)a1[i + 14];
      if (v3)
      {
        for (uint64_t j = 0; j != 256; ++j)
        {
          uint64_t v5 = v3[j];
          if (v5)
          {
            do
            {
              uint64_t v6 = *(void **)v5;
              if (*(void *)v5
                && atomic_fetch_add_explicit((atomic_uint *volatile)v6, 0xFFFFFFFF, memory_order_relaxed) == 1)
              {
                free(v6);
              }
              uint64_t v5 = *(void *)(v5 + 8);
            }
            while (v5);
            unsigned int v7 = (void *)v3[j];
            if (v7)
            {
              do
              {
                uint64_t v8 = (void *)v7[1];
                free(v7);
                unsigned int v7 = v8;
              }
              while (v8);
            }
          }
        }
        free(v3);
      }
    }
    free(a1);
  }
}

uint64_t render_glyph_list(uint64_t result, long long *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (*((void *)a2 + 2))
  {
    uint64_t v9 = result;
    v33[0] = 0;
    v33[1] = 0;
    uint64_t v10 = a5[5];
    if (v10)
    {
      if ((*(unsigned char *)(v10 + 12) & 0x10) != 0) {
        uint64_t v11 = a5[5];
      }
      else {
        uint64_t v11 = 0;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = (long long *)(a5 + 1);
    if (v11) {
      uint64_t v12 = (long long *)(a5 + 3);
    }
    long long v13 = *v12;
    long long v34 = *a2;
    long long v35 = v13;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    unint64_t result = CGSBoundsIntersection((int *)&v35, (int *)&v34, v33);
    if (result)
    {
      *(_DWORD *)(v9 + 104) = (int)(*(_DWORD *)(*(void *)(a4 + 120) + 4) << 16) >> 24;
      *(unsigned char *)(v9 + 108) = *(unsigned char *)(a3 + 82);
      *(_DWORD *)(v9 + 112) = (int)(*(_DWORD *)(*(void *)(a4 + 120) + 4) << 12) >> 28;
      float v15 = *(double *)(*(void *)(a4 + 136) + 40);
      *(float *)(v9 + 168) = v15;
      unint64_t result = (uint64_t)ripc_GetColor(v9, a3, a4, 2, (int *)v33, (uint64_t)&v37, (double *)(v9 + 152), v14);
      if (result)
      {
        uint64_t v17 = result;
        Color = ripc_GetColor(v9, a3, a4, 8, (int *)v33, (uint64_t)&v36, (double *)(v9 + 160), v16);
        if (v11) {
          (*(void (**)(uint64_t, void, uint64_t, void *, long long *, uint64_t, uint64_t *, char *, uint64_t *, uint64_t))(*(void *)v11 + 64))(v11, *(void *)(v9 + 48), *a5, v33, a2, v17, &v37, Color, &v36, v9 + 104);
        }
        else {
          RIPLayerBltGlyph(*(_DWORD **)(v9 + 48), *a5, v33, a2, v17, &v37, (uint64_t)Color, v9 + 104);
        }
        RIPObjectRelease(v17, v19, v20, v21, v22, v23, v24, v25);
        return RIPObjectRelease((uint64_t)Color, v26, v27, v28, v29, v30, v31, v32);
      }
    }
  }
  return result;
}

uint64_t CGSBoundsIntersection(int *a1, int *a2, _DWORD *a3)
{
  BOOL v3 = 0;
  if (a1 && a2)
  {
    int v4 = a1[2];
    if (v4 < 1) {
      return 0;
    }
    int v5 = a2[2];
    if (v5 < 0) {
      return 0;
    }
    int v6 = a1[3];
    if (v6 < 1) {
      return 0;
    }
    int v7 = a2[3];
    if (v7 < 0) {
      return 0;
    }
    int v8 = *a1 + v4;
    int v9 = *a2 + v5;
    if (*a1 <= *a2) {
      int v10 = *a2;
    }
    else {
      int v10 = *a1;
    }
    if (v8 < v9) {
      int v9 = v8;
    }
    int v11 = v9 - v10;
    if (v11 < 1)
    {
      return 0;
    }
    else
    {
      if (a3)
      {
        *a3 = v10;
        a3[2] = v11;
      }
      int v12 = a1[1];
      int v13 = a2[1];
      int v14 = v12 + v6;
      int v15 = v13 + v7;
      if (v12 <= v13) {
        int v16 = a2[1];
      }
      else {
        int v16 = a1[1];
      }
      if (v14 >= v15) {
        int v14 = v15;
      }
      int v17 = v14 - v16;
      BOOL v3 = v14 > v16;
      if (a3 && v17 >= 1)
      {
        a3[1] = v16;
        a3[3] = v17;
        return 1;
      }
    }
  }
  return v3;
}

os_unfair_lock_s *CGFontStrikeGetSize(os_unfair_lock_s *a1)
{
  int v1 = a1;
  if (a1)
  {
    CFTypeRef v2 = a1 + 26;
    os_unfair_lock_lock(a1 + 26);
    int v1 = *(os_unfair_lock_s **)&v1[22]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2);
  }
  return v1;
}

uint64_t ripl_Containment(_DWORD *a1, _DWORD *a2, int a3)
{
  unsigned int v3 = a3 & 0xFF000000;
  int v4 = a1[1];
  int v5 = a2[1];
  if (*a1 != *a2) {
    unsigned int v3 = 0;
  }
  int v6 = a3;
  if (v4 != v5) {
    int v6 = 0;
  }
  if (a1[2] + *a1 == a2[2] + *a2) {
    int v7 = a3 & 0xFF00;
  }
  else {
    int v7 = 0;
  }
  if (a1[3] + v4 == a2[3] + v5) {
    int v8 = a3 & 0xFF0000;
  }
  else {
    int v8 = 0;
  }
  return v6 | v3 | v7 | v8;
}

uint64_t CGBlt_combineBytes(uint64_t result, int a2, _OWORD *a3, __n128 *a4, int a5, int a6, __int16 a7, double a8, int8x16_t a9, uint8x16_t a10)
{
  int v10 = a7 & 0xF00;
  if (v10 != 1280)
  {
    if (v10 != 1024)
    {
      if (v10 == 256 && (int)result >= 1 && a2 >= 1)
      {
        uint64_t v11 = 0;
        int8x16_t v12 = (int8x16_t)vdupq_n_s16(0xFE01u);
        do
        {
          if (result >= 0x20)
          {
            uint64_t v16 = 0;
            int v15 = a3;
            int v14 = (uint8x16_t *)a4;
            do
            {
              uint8x16_t v18 = *(uint8x16_t *)v15;
              uint8x16_t v17 = *((uint8x16_t *)v15 + 1);
              v15 += 2;
              uint8x16_t v19 = v14[1];
              uint16x8_t v20 = vminq_u16(vmull_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v14->i8), (uint16x8_t)v12);
              uint16x8_t v21 = vminq_u16(vmull_high_u8(v18, *v14), (uint16x8_t)v12);
              uint8x16_t v22 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v20, v20, 8uLL), 8uLL), vrsraq_n_u16(v21, v21, 8uLL), 8uLL);
              uint16x8_t v23 = vminq_u16(vmull_u8(*(uint8x8_t *)v17.i8, *(uint8x8_t *)v19.i8), (uint16x8_t)v12);
              uint16x8_t v24 = vminq_u16(vmull_high_u8(v17, v19), (uint16x8_t)v12);
              a9 = (int8x16_t)vrsraq_n_u16(v24, v24, 8uLL);
              a10 = vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v23, v23, 8uLL), 8uLL), (uint16x8_t)a9, 8uLL);
              *int v14 = v22;
              v14[1] = a10;
              v14 += 2;
              unint64_t v13 = v16 + 32;
              unint64_t v25 = v16 + 64;
              v16 += 32;
            }
            while (v25 <= result);
          }
          else
          {
            unint64_t v13 = 0;
            int v14 = (uint8x16_t *)a4;
            int v15 = a3;
          }
          unint64_t v26 = v13 | 4;
          if ((v13 | 4) <= result)
          {
            do
            {
              unsigned __int32 v27 = *(_DWORD *)v15;
              int v15 = (_OWORD *)((char *)v15 + 4);
              a9.i32[0] = v27;
              uint16x8_t v28 = vmovl_u8(*(uint8x8_t *)a9.i8);
              a10.i32[0] = v14->i32[0];
              LOBYTE(v29) = v28.i8[0];
              BYTE1(v29) = v28.i8[2];
              BYTE2(v29) = v28.i8[4];
              HIBYTE(v29) = v28.i8[6];
              uint16x8_t v30 = vmovl_u8(*(uint8x8_t *)a10.i8);
              a10.i32[1] = 0;
              a10.i8[0] = v30.i8[0];
              a10.i8[1] = v30.i8[2];
              a10.i8[2] = v30.i8[4];
              a10.i8[3] = v30.i8[6];
              uint16x8_t v31 = vminq_u16(vmull_u8((uint8x8_t)v29, (uint8x8_t)a10.u32[0]), (uint16x8_t)v12);
              a9 = (int8x16_t)vrsraq_n_u16(v31, v31, 8uLL);
              *(uint8x8_t *)a9.i8 = vqrshrn_n_u16((uint16x8_t)a9, 8uLL);
              *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8(a9, v12));
              v14->i32[0] = a9.i32[0];
              int v14 = (uint8x16_t *)((char *)v14 + 4);
              v26 += 4;
            }
            while (v26 <= result);
            unint64_t v13 = v26 - 4;
          }
          if (v13 + 1 <= result)
          {
            unint64_t v32 = result - v13;
            int v33 = v14;
            do
            {
              uint8x8_t v34 = (uint8x8_t)*(unsigned __int8 *)v15;
              int v15 = (_OWORD *)((char *)v15 + 1);
              a10.i64[0] = v33->u8[0];
              int v33 = (uint8x16_t *)((char *)v33 + 1);
              a9 = (int8x16_t)vminq_u16(vmull_u8(v34, *(uint8x8_t *)a10.i8), (uint16x8_t)v12);
              *(uint8x8_t *)a9.i8 = vqrshrn_n_u16(vrsraq_n_u16((uint16x8_t)a9, (uint16x8_t)a9, 8uLL), 8uLL);
              v14->i8[0] = a9.i8[0];
              int v14 = v33;
              --v32;
            }
            while (v32);
          }
          a3 = (_OWORD *)((char *)a3 + a5);
          a4 = (__n128 *)((char *)a4 + a6);
          ++v11;
        }
        while (v11 != a2);
      }
      return result;
    }
    if ((int)result < 1 || a2 < 1) {
      return result;
    }
    int v47 = a3 & 3;
    if ((a3 & 3) != 0)
    {
      unsigned int v48 = 8 - v47;
      int v49 = 4 - v47;
      unsigned int v50 = result - v49;
      if (v48 > result)
      {
        int v49 = result;
        unsigned int v50 = 0;
      }
    }
    else
    {
      if (result >= 4) {
        int v49 = 0;
      }
      else {
        int v49 = result;
      }
      if (result >= 4) {
        unsigned int v50 = result;
      }
      else {
        unsigned int v50 = 0;
      }
    }
    unsigned int v51 = v50 >> 2;
    int v52 = v50 & 3;
    while (1)
    {
      int v53 = v49;
      unsigned int v54 = v51;
      if (v49) {
        break;
      }
LABEL_49:
      if (v54)
      {
        uint64_t v56 = v54 - 1;
        int32x2_t v57 = a3;
        do
        {
          if (*v57 == -1) {
            a4->n128_u32[0] = 0;
          }
          ++v57;
          a4 = (__n128 *)((char *)a4 + 4);
          --v54;
        }
        while (v54);
        a3 = (_OWORD *)((char *)a3 + 4 * v56 + 4);
        int v53 = v52;
        if (v52) {
          break;
        }
      }
      a3 = (_OWORD *)((char *)a3 + a5 - (uint64_t)(int)result);
      a4 = (__n128 *)((char *)a4 + a6 - (uint64_t)(int)result);
      if (!--a2) {
        return result;
      }
    }
    uint64_t v55 = (v53 - 1);
    a3 = (_OWORD *)((char *)a3 + v55 + 1);
    a4 = (__n128 *)((char *)a4 + v55 + 1);
    goto LABEL_49;
  }
  if ((int)result >= 1 && a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      if (result >= 0x20)
      {
        uint64_t v39 = 0;
        int v38 = (int8x16_t *)a3;
        uint64_t v37 = a4;
        do
        {
          int8x16_t v41 = *v38;
          int8x16_t v40 = v38[1];
          v38 += 2;
          a9 = vmvnq_s8(v40);
          *(int8x16_t *)uint64_t v37 = vmvnq_s8(v41);
          v37[1] = (__n128)a9;
          v37 += 2;
          unint64_t v36 = v39 + 32;
          unint64_t v42 = v39 + 64;
          v39 += 32;
        }
        while (v42 <= result);
      }
      else
      {
        unint64_t v36 = 0;
        uint64_t v37 = a4;
        int v38 = (int8x16_t *)a3;
      }
      unint64_t v43 = v36 | 4;
      if ((v36 | 4) <= result)
      {
        do
        {
          unsigned __int32 v44 = v38->i32[0];
          int v38 = (int8x16_t *)((char *)v38 + 4);
          a9.i32[0] = v44;
          a9 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a9.i8);
          *(int8x8_t *)a9.i8 = veor_s8(*(int8x8_t *)a9.i8, (int8x8_t)0xFF00FF00FF00FFLL);
          *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)a9);
          v37->n128_u32[0] = a9.i32[0];
          uint64_t v37 = (__n128 *)((char *)v37 + 4);
          v43 += 4;
        }
        while (v43 <= result);
        unint64_t v36 = v43 - 4;
      }
      if (v36 + 1 <= result)
      {
        unint64_t v45 = result - v36;
        do
        {
          __int8 v46 = v38->i8[0];
          int v38 = (int8x16_t *)((char *)v38 + 1);
          v37->n128_u8[0] = ~v46;
          uint64_t v37 = (__n128 *)((char *)v37 + 1);
          --v45;
        }
        while (v45);
      }
      a3 = (_OWORD *)((char *)a3 + a5);
      a4 = (__n128 *)((char *)a4 + a6);
    }
  }
  return result;
}

void CGPostError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void CGLogWithArguments(int a1, uint64_t a2, va_list a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v3 = a1 - 1;
  if (a1 >= 1)
  {
    if (CGLogWithArguments_predicate != -1) {
      dispatch_once(&CGLogWithArguments_predicate, &__block_literal_global_14137);
    }
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s", a2);
    if (v7)
    {
      CFStringRef v8 = v7;
      CFStringRef v9 = CFStringCreateWithFormatAndArguments(v6, 0, v7, a3);
      CFRelease(v8);
      if (v9)
      {
        CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
        if (CStringPtr)
        {
          uint64_t v11 = CStringPtr;
          int8x16_t v12 = 0;
        }
        else
        {
          CFIndex Length = CFStringGetLength(v9);
          CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          int8x16_t v12 = (char *)malloc_type_calloc(MaximumSizeForEncoding, 1uLL, 0x7FACFFB0uLL);
          if (v12 && CFStringGetCString(v9, v12, MaximumSizeForEncoding, 0x8000100u)) {
            uint64_t v11 = v12;
          }
          else {
            uint64_t v11 = "";
          }
        }
        switch(v3)
        {
          case 0:
            int v15 = CGLogWithArguments_log;
            if (os_log_type_enabled((os_log_t)CGLogWithArguments_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446210;
              uint8x16_t v19 = v11;
              _os_log_impl(&dword_184BFE000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
            }
            break;
          case 1:
            uint64_t v16 = CGLogWithArguments_log;
            if (os_log_type_enabled((os_log_t)CGLogWithArguments_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              uint8x16_t v19 = v11;
              _os_log_error_impl(&dword_184BFE000, v16, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);
            }
            goto LABEL_19;
          case 2:
            uint8x16_t v17 = CGLogWithArguments_log;
            if (os_log_type_enabled((os_log_t)CGLogWithArguments_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136446210;
              uint8x16_t v19 = v11;
              _os_log_fault_impl(&dword_184BFE000, v17, OS_LOG_TYPE_FAULT, "%{public}s", buf, 0xCu);
            }
LABEL_19:
            callErrorCallback();
            break;
          case 3:
            puts(v11);
            break;
          default:
            break;
        }
        free(v12);
        CFRelease(v9);
      }
    }
  }
}

uint64_t callErrorCallback()
{
  pthread_mutex_lock(&error_callback_lock);
  int v1 = (uint64_t (*)(void))error_callback;
  pthread_mutex_unlock(&error_callback_lock);
  uint64_t result = (uint64_t)v1;
  if (v1)
  {
    return v1();
  }
  return result;
}

uint64_t rip_auto_context_draw_glyphs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
  {
    uint64_t v5 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v4 = *(void *)(a1 + 288);
  uint64_t v5 = v4 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 112));
  if (!v4)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_GState(0, a3);
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)(v4 + 88);
  if (!v6)
  {
    uint64_t v6 = *(void *)(v4 + 80);
    rip_auto_context_update_content_info_from_GState(v4, a3);
    if (v6) {
      goto LABEL_9;
    }
LABEL_7:
    uint64_t v14 = 0;
    goto LABEL_15;
  }
  rip_auto_context_update_content_info_from_GState(v4, a3);
LABEL_9:
  uint64_t v15 = *(void *)(v6 + 40);
  if (v15)
  {
    uint64_t v16 = *(uint64_t (**)(void))(v15 + 88);
    if (v16) {
      uint64_t v14 = v16();
    }
    else {
      uint64_t v14 = 1006;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  *(unsigned char *)(v4 + 105) |= rip_auto_context_contains_transparency(v4, v7, v8, v9, v10, v11, v12, v13);
LABEL_15:
  pthread_mutex_unlock((pthread_mutex_t *)v5);
  return v14;
}

void draw_glyph_bitmap_run_with_compositing(uint64_t a1, __n128 a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10)
{
  uint64_t v49 = a4;
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (a10 >> 61) {
    unint64_t v12 = -1;
  }
  else {
    unint64_t v12 = a10;
  }
  MEMORY[0x1F4188790](a1, a2);
  uint8x16_t v22 = (char *)v42 - v17;
  unint64_t v23 = v12 - 0x1FFFFFFFFFFFFFFFLL;
  if (v12 <= 0x1FFFFFFFFFFFFFFELL) {
    uint16x8_t v24 = (char *)v42 - v17;
  }
  else {
    uint16x8_t v24 = 0;
  }
  uint64_t v45 = v13;
  uint64_t v46 = v14;
  uint64_t v44 = v18;
  size_t v47 = v20;
  unint64_t v25 = v15;
  uint64_t v26 = v16;
  if (v23 >= v19) {
    uint16x8_t v24 = (char *)malloc_type_malloc(v20, 0x6B45CACAuLL);
  }
  if (v24)
  {
    unsigned __int32 v27 = (char *)MEMORY[0x1F4188790](v24, v21);
    double v42[2] = (char *)v42 - v29;
    if (v28 <= 0x3FFFFFFFFFFFFFFELL) {
      uint16x8_t v30 = (char *)v42 - v29;
    }
    else {
      uint16x8_t v30 = 0;
    }
    unsigned int v48 = v27;
    if (v28 - 0x3FFFFFFFFFFFFFFFLL >= 0xC000000000000102) {
      uint16x8_t v30 = (char *)malloc_type_malloc(4 * a10, 0xF4F7B1EEuLL);
    }
    if (v30)
    {
      v42[1] = v22;
      uint64_t v31 = *(void *)(v49 + 136);
      double v32 = *(double *)(v31 + 16);
      float64x2_t v33 = vmulq_n_f64(*(float64x2_t *)a7, v32);
      float64x2_t v34 = vmulq_n_f64(*(float64x2_t *)(a7 + 16), v32);
      v52[0] = v33;
      v52[1] = v34;
      v52[2] = *(_OWORD *)(a7 + 32);
      unint64_t v35 = *(void *)(v31 + 88);
      int v43 = a6;
      __int16 v36 = a6;
      uint64_t v37 = (uint64_t)v30;
      unint64_t QuantizationLevelWithStyle = CGFontGetQuantizationLevelWithStyle((uint64_t)v52, v36, v35);
      v42[3] = v37;
      v38.n128_u64[0] = (unint64_t)CGFontGetGlyphIdentifiers(v25, (float64x2_t *)a7, v26, a10, &QuantizationLevelWithStyle, v37, (uint64_t)v48, v50);
      MEMORY[0x1F4188790](v39, v38);
      if (v12 <= 0x1FFFFFFFFFFFFFFELL) {
        int8x16_t v41 = (char *)v42 - v40;
      }
      else {
        int8x16_t v41 = 0;
      }
      if (v23 >= 0xE000000000000402) {
        int8x16_t v41 = (char *)malloc_type_malloc(v47, 0xC66E0719uLL);
      }
      if (v41) {
        CGGlyphBuilderCreate();
      }
    }
    else if (v48 != v22)
    {
      free(v48);
    }
  }
}

void get_glyph_bounding_box(CGFont *a1, float64x2_t *a2)
{
  font_float64x2_t info = get_font_info(a1);
  if (font_info) {
    int v5 = font_info[2];
  }
  else {
    int v5 = 0;
  }
  FontBBodouble x = CGFontGetFontBBox(a1);
  v10.origin.double x = (double)-v5;
  v10.origin.double y = v10.origin.x;
  v10.size.double width = (double)(2 * v5);
  v10.size.double height = v10.size.width;
  CGRect v11 = CGRectUnion(v10, FontBBox);
  v9.double tx = 0.0;
  v9.double ty = 0.0;
  float64x2_t v6 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v5), 0);
  float64x2_t v7 = vdivq_f64(*a2, v6);
  float64x2_t v8 = vdivq_f64(a2[1], v6);
  *(float64x2_t *)&v9.double a = v7;
  *(float64x2_t *)&v9.double c = v8;
  CGRectApplyAffineTransform(v11, &v9);
}

void CGContextSetFontSize(CGContextRef c, CGFloat size)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v9 = *((void *)c + 12);
    if (*(double *)(*(void *)(v9 + 136) + 16) != size)
    {
      maybe_copy_text_state(*((void *)c + 12));
      *(CGFloat *)(*(void *)(v9 + 136) + 16) = size;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFontSize", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t CG::DisplayList::executeEntries(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, CGPoint *a7, int a8)
{
  uint64_t v362 = a1;
  *(void *)uint64_t v363 = a4;
  *(void *)int v364 = a5;
  *(void *)long long v365 = a6;
  uint64_t v367 = 0;
  if (!*(unsigned char *)(a1 + 57)) {
    goto LABEL_13;
  }
  if (a7)
  {
    CGPoint origin = *a7;
    CGSize size = (CGSize)a7[1];
LABEL_14:
    CGPoint v368 = origin;
    CGSize v369 = size;
    goto LABEL_15;
  }
  _ZF = *(double *)(a1 + 24) == -8.98846567e307 && *(double *)(a1 + 32) == -8.98846567e307;
  BOOL v16 = _ZF && *(double *)(a1 + 40) == 1.79769313e308;
  if (v16 && *(double *)(a1 + 48) == 1.79769313e308)
  {
LABEL_13:
    CGPoint origin = CGRectNull.origin;
    CGSize size = CGRectNull.size;
    goto LABEL_14;
  }
  CGSize v359 = *(CGSize *)(a1 + 40);
  CGPoint v368 = *(CGPoint *)(a1 + 24);
  CGSize v369 = v359;
LABEL_15:
  uint64_t v370 = 0;
  CGAffineTransform v372 = CGAffineTransformIdentity;
  uint64_t v17 = *(void *)(a6 + 8);
  if (v17 == a6)
  {
    uint64_t v18 = CGGStateCreate();
    unint64_t v19 = *(char ***)(a6 + 8);
    *(void *)(a6 + 8) = v18;
    *(void *)uint64_t v18 = a6;
    *unint64_t v19 = v18;
    *((void *)v18 + 1) = v19;
    uint64_t v17 = *(void *)(a6 + 8);
  }
  *(void *)__n128 v366 = v17;
  double v20 = *(double *)(v17 + 24);
  uint64_t m = (CGAffineTransform *)(v17 + 24);
  if (v20 == 1.0
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)(v17 + 32)), (int32x4_t)vceqq_f64(*(float64x2_t *)(v17 + 48), (float64x2_t)xmmword_1850CD830))))) & 1) == 0&& *(double *)(v17 + 64) == 0.0)
  {
    uint64_t m = 0;
  }
  double v21 = *(double *)(a1 + 24);
  double v22 = *(double *)(a1 + 32);
  double v23 = *(double *)(a1 + 40);
  double v24 = *(double *)(a1 + 48);
  if (v21 != -8.98846567e307 || v22 != -8.98846567e307 || v23 != 1.79769313e308 || v24 != 1.79769313e308) {
    CGGStateClipToRect(v17, v21, v22, v23, v24);
  }
  if (*(void *)(a1 + 760))
  {
    uint64_t v25 = *(void *)(v17 + 136);
    if (*(double *)(v25 + 16) != 1.0)
    {
      maybe_copy_text_state(v17);
      *(void *)(*(void *)(v17 + 136) + 16) = 0x3FF0000000000000;
      uint64_t v17 = *(void *)v366;
      uint64_t v25 = *(void *)(*(void *)v366 + 136);
    }
    if (*(double *)(v25 + 24) != 0.0)
    {
      maybe_copy_text_state(v17);
      *(void *)(*(void *)(v17 + 136) + 24) = 0;
    }
  }
  *(void *)__n128 v366 = CGGStackSave(*(uint64_t *)v365);
  uint64_t v33 = *(void *)v364;
  long long v34 = *(_OWORD *)(*(void *)v364 + 24);
  long long v35 = *(_OWORD *)(*(void *)v364 + 56);
  *(_OWORD *)&v372.double c = *(_OWORD *)(*(void *)v364 + 40);
  *(_OWORD *)&v372.double tx = v35;
  *(_OWORD *)&v372.double a = v34;
  if (a2 != a3)
  {
    int v36 = a8 ^ 1;
    while (1)
    {
      uint64_t v37 = *a2;
      unsigned int v38 = *(_DWORD *)(*a2 + 8);
      if ((v38 & 0x100000) != 0) {
        int v39 = v36;
      }
      else {
        int v39 = 1;
      }
      if (v39 == 1 && (v38 & 0x400000) != 0) {
        goto LABEL_41;
      }
      switch((char)v38)
      {
        case 0:
          uint64_t v41 = *(void *)v366;
          if (v37) {
            BOOL v42 = *(void *)v366 == 0;
          }
          else {
            BOOL v42 = 1;
          }
          if (v42) {
            goto LABEL_41;
          }
          long long v43 = *(_OWORD *)(v37 + 32);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
          *(_OWORD *)&v373.double c = v43;
          if (CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373)) {
            goto LABEL_41;
          }
          uint64_t v44 = *(void *)(v37 + 48);
          long long v45 = *(_OWORD *)(v37 + 104);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
          *(_OWORD *)&v373.double c = v45;
          *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
          CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v44, (uint64_t)&v373, v41, v29, v30, v31, v32);
          if ((*(unsigned char *)(v37 + 10) & 4) != 0)
          {
            uint64_t v46 = *(void *)(v37 + 72);
            uint64_t v47 = *(void *)v366;
            double v48 = *(double *)(v46 + 56);
            double v49 = *(double *)(v46 + 64);
            uint64_t v50 = *(void *)(*(void *)v366 + 120);
            if (*(double *)(v50 + 24) != v48 || *(double *)(v50 + 32) != v49)
            {
              maybeCopyRenderingState(*(uint64_t *)v366);
              uint64_t v52 = *(void *)(v47 + 120);
              *(double *)(v52 + 24) = v48;
              *(double *)(v52 + 32) = v49;
            }
            double v53 = *(double *)(v46 + 72);
            if (*(double *)(*(void *)(v47 + 144) + 16) != v53)
            {
              maybe_copy_device_state(v47);
              *(double *)(*(void *)(v47 + 144) + 16) = v53;
            }
            _D4 = *(double *)(v46 + 8);
            _D1 = *(double *)(v46 + 16);
            _D3 = *(double *)(v46 + 24);
            _D0 = *(double *)(v46 + 32);
            float64x2_t v58 = *(float64x2_t *)(v46 + 40);
            if (m)
            {
              _Q5 = *(_OWORD *)&m->a;
              float64x2_t v60 = *(float64x2_t *)&m->c;
              double v61 = vmlad_n_f64(_D1 * v60.f64[0], _D4, m->a);
              __asm { FMLA            D1, D4, V5.D[1] }
              double v65 = vmlad_n_f64(_D0 * v60.f64[0], _D3, m->a);
              __asm { FMLA            D0, D3, V5.D[1] }
              float64x2_t v58 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v60, v58, 1), *(float64x2_t *)&m->a, v58.f64[0]));
              _D3 = v65;
              _D4 = v61;
            }
            uint64_t v66 = *(void *)v364;
            *(double *)(*(void *)v364 + 24) = _D4;
            *(double *)(v66 + 32) = _D1;
            *(double *)(v66 + 40) = _D3;
            *(double *)(v66 + 48) = _D0;
            *(float64x2_t *)(v66 + 56) = v58;
          }
          CGGStateSetInterpolationQuality(*(uint64_t *)v366, *(_DWORD *)(v37 + 136));
          uint64_t v67 = *(void *)v364;
          uint64_t v68 = *(void *)v366;
          *(_DWORD *)(*(void *)v364 + 72) = *(_DWORD *)(v37 + 140);
          *(_DWORD *)(v67 + 76) = *(_DWORD *)(v37 + 144);
          CGGStateSetRenderingIntent(v68, *(_DWORD *)(v37 + 148));
          CGGStateSetImageRenderingIntent(*(uint64_t *)v366, *(_DWORD *)(v37 + 148));
          uint64_t v69 = *(void *)v366;
          float v70 = *(float *)(v37 + 152);
          if (*(float *)(*(void *)(*(void *)v366 + 120) + 48) != v70)
          {
            maybeCopyRenderingState(*(uint64_t *)v366);
            *(float *)(*(void *)(v69 + 120) + 48) = v70;
          }
          if (*(unsigned char *)(v37 + 10))
          {
            uint64_t v71 = *(void *)(*(void *)(v37 + 56) + 8);
            if (v71) {
              CGGStateSetFillColor(*(uint64_t *)v366, *(void **)(v71 + 16));
            }
          }
          uint64_t v72 = *(void *)(v37 + 80);
          int32x2_t v73 = *(CGImage **)(v72 + 16);
          if (v73) {
            CFRetain(*(CFTypeRef *)(v72 + 16));
          }
          if (CGImageGetHeadroomInfo(v73, 0) <= 1.0) {
            goto LABEL_334;
          }
          if (!*(void *)v363)
          {
            Copdouble y = v73;
            goto LABEL_338;
          }
          uint64_t v74 = *(uint64_t (**)(void))(*(void *)v363 + 264);
          if (!v74) {
            goto LABEL_334;
          }
          uint64_t v75 = (void *)v74();
          if (!v75) {
            goto LABEL_334;
          }
          CGRect v76 = v75;
          float v77 = CGColorSpaceSanitizeHeadroom(v75, *(float *)(v37 + 152));
          float HeadroomInfo = CGImageGetHeadroomInfo(v73, 0);
          BOOL v79 = v77 <= 0.0;
          if (v77 >= HeadroomInfo) {
            BOOL v79 = 1;
          }
          if (v79) {
            Copdouble y = v73;
          }
          else {
            Copdouble y = 0;
          }
          if (v79 || !v73) {
            goto LABEL_335;
          }
          uint64_t v81 = *((void *)v73 + 28);
          if (!v81) {
            goto LABEL_334;
          }
          float v82 = HeadroomInfo;
          Properdouble ty = (const __CFDictionary *)CGPropertiesGetProperty(v81, @"kCGColorConversionInfoPayload");
          if (!Property) {
            goto LABEL_334;
          }
          CFDictionaryRef v84 = Property;
          CFNumberRef Value = CFDictionaryGetValue(Property, @"kCGToneMappingMethod");
          CFNumberRef v86 = (const __CFNumber *)CFDictionaryGetValue(v84, @"kCGHDRMediaReferenceWhite");
          CGRect v87 = CFDictionaryGetValue(v84, @"kCGToneMappingMethodOptions");
          if (Value && v86)
          {
            long long v95 = v87;
            v373.double a = 0.0;
            unsigned int v361 = CGToneMappingMethodFromString(Value);
            CGColorSpaceRef ColorSpace = CGImageGetColorSpace(v73);
            float v97 = CGGetFloatValue(v86);
            if (CGCreateResolvedToneMappingSettingForMethod(v361, v76, ColorSpace, v95, 0, (__CFDictionary **)&v373, v98, v99, v77, v82, v97))
            {
              Copdouble y = CGImageCreateCopy(v73);
              if (CGImageSetColorConversionInfoOptions((uint64_t)Copy, *(const __CFDictionary **)&v373.a))
              {
                CFRelease(v73);
                CGImageSetCachingFlags(Copy, 1);
                goto LABEL_344;
              }
              if (Copy) {
                CFRelease(Copy);
              }
            }
            else
            {
              CGPostError((uint64_t)"%s: Cannot create resolved tone mapping settings. CGCreateResolvedToneMappingSettingForMethod returned false", v100, v101, v102, v103, v104, v105, v106, (char)"drawImage");
            }
            Copdouble y = v73;
LABEL_344:
            if (*(void *)&v373.a) {
              CFRelease(*(CFTypeRef *)&v373.a);
            }
            goto LABEL_335;
          }
          CGPostError((uint64_t)"%s: Cannot create resolved tone mapping settings. Bad payload", v88, v89, v90, v91, v92, v93, v94, (char)"drawImage");
LABEL_334:
          Copdouble y = v73;
LABEL_335:
          if (*(void *)v363)
          {
            uint64_t v355 = *(void (**)(double, double, double, double))(*(void *)v363 + 80);
            if (v355) {
              v355(0.0, 0.0, 1.0, 1.0);
            }
          }
LABEL_338:
          if (Copy) {
LABEL_339:
          }
            CFRelease(Copy);
          goto LABEL_41;
        case 1:
          uint64_t v107 = *(void *)v366;
          if (v37) {
            BOOL v108 = *(void *)v366 == 0;
          }
          else {
            BOOL v108 = 1;
          }
          if (!v108)
          {
            long long v109 = *(_OWORD *)(v37 + 32);
            *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
            *(_OWORD *)&v373.double c = v109;
            if (!CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373))
            {
              uint64_t v110 = *(void *)(v37 + 48);
              long long v111 = *(_OWORD *)(v37 + 104);
              *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
              *(_OWORD *)&v373.double c = v111;
              *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
              CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v110, (uint64_t)&v373, v107, v29, v30, v31, v32);
              int v112 = *(_DWORD *)(v37 + 8);
              if ((v112 & 0x40000) != 0)
              {
                uint64_t v113 = *(void *)(v37 + 72);
                uint64_t v114 = *(void *)v366;
                double v115 = *(double *)(v113 + 56);
                double v116 = *(double *)(v113 + 64);
                uint64_t v117 = *(void *)(*(void *)v366 + 120);
                if (*(double *)(v117 + 24) != v115 || *(double *)(v117 + 32) != v116)
                {
                  maybeCopyRenderingState(*(uint64_t *)v366);
                  uint64_t v119 = *(void *)(v114 + 120);
                  *(double *)(v119 + 24) = v115;
                  *(double *)(v119 + 32) = v116;
                }
                double v120 = *(double *)(v113 + 72);
                if (*(double *)(*(void *)(v114 + 144) + 16) != v120)
                {
                  maybe_copy_device_state(v114);
                  *(double *)(*(void *)(v114 + 144) + 16) = v120;
                }
                long long v121 = *(_OWORD *)(v113 + 8);
                long long v122 = *(_OWORD *)(v113 + 40);
                *(_OWORD *)&v373.double c = *(_OWORD *)(v113 + 24);
                *(_OWORD *)&v373.double tx = v122;
                *(_OWORD *)&v373.double a = v121;
                if (m)
                {
                  double a = m->a;
                  double b = m->b;
                  double c = m->c;
                  double d = m->d;
                  double tx = m->tx;
                  double ty = m->ty;
                  CGFloat v129 = v373.b * d + v373.a * b;
                  v373.double a = v373.b * c + v373.a * m->a;
                  v373.double b = v129;
                  CGFloat v130 = v373.d * d + v373.c * b;
                  v373.double c = v373.d * c + v373.c * a;
                  v373.double d = v130;
                  CGFloat v131 = d * v373.ty + v373.tx * b + ty;
                  v373.double tx = tx + c * v373.ty + v373.tx * a;
                  v373.double ty = v131;
                }
                uint64_t v132 = *(void *)v364;
                long long v134 = *(_OWORD *)&v373.c;
                long long v133 = *(_OWORD *)&v373.tx;
                *(_OWORD *)(*(void *)v364 + 24) = *(_OWORD *)&v373.a;
                *(_OWORD *)(v132 + 40) = v134;
                *(_OWORD *)(v132 + 56) = v133;
                int v112 = *(_DWORD *)(v37 + 8);
              }
              if ((v112 & 0x10000) != 0)
              {
                uint64_t v135 = *(void *)(*(void *)(v37 + 56) + 8);
                if (v135)
                {
                  CGGStateSetFillColor(*(uint64_t *)v366, *(void **)(v135 + 16));
                  int v112 = *(_DWORD *)(v37 + 8);
                }
              }
              if ((v112 & 0x20000) != 0) {
                CG::DisplayListExecutor::applyEntryStrokeState(*(void *)(v37 + 64), *(uint64_t *)v366);
              }
              CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v110 + 96) << 18) >> 26);
              uint64_t v136 = *(void *)v366;
              double v137 = *(double *)(v110 + 56);
              if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v137)
              {
                maybeCopyRenderingState(*(uint64_t *)v366);
                *(double *)(*(void *)(v136 + 120) + 8) = v137;
                uint64_t v136 = *(void *)v366;
              }
              CGGStateSetTextDrawingMode(v136, *(_DWORD *)(v37 + 216));
              CGGStateSetFontRenderingStyle(*(uint64_t *)v366, *(_DWORD *)(v37 + 220));
              CGGStateSetFont(*(uint64_t *)v366, *(const void **)(*(void *)(v37 + 80) + 16));
              uint64_t v138 = *(void *)v366;
              double v139 = *(double *)(v37 + 184);
              if (*(double *)(*(void *)(*(void *)v366 + 136) + 16) != v139)
              {
                maybe_copy_text_state(*(uint64_t *)v366);
                *(double *)(*(void *)(v138 + 136) + 16) = v139;
                uint64_t v138 = *(void *)v366;
              }
              CGGStateSetFontDilation(v138, *(double *)(v37 + 192), *(double *)(v37 + 200));
              uint64_t v140 = *(void *)(v37 + 208);
              if (v140) {
                CGGStateSetFontSmoothingBackgroundColor(*(uint64_t *)v366, *(const void **)(v140 + 16));
              }
              CGGStateSetShouldDrawBitmapRuns(*(uint64_t *)v366, *(unsigned __int8 *)(v37 + 224));
              uint64_t v29 = *(void *)(v37 + 232);
              uint64_t v30 = *(void *)(v37 + 240);
              long long v141 = *(_OWORD *)(v37 + 152);
              *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 136);
              *(_OWORD *)&v373.double c = v141;
              *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 168);
              if (*(void *)v363)
              {
                unint64_t v142 = *(void (**)(void))(*(void *)v363 + 88);
                if (v142) {
                  goto LABEL_319;
                }
              }
            }
          }
          goto LABEL_41;
        case 2:
          uint64_t v143 = *(void *)v366;
          if (v37) {
            BOOL v144 = *(void *)v366 == 0;
          }
          else {
            BOOL v144 = 1;
          }
          if (v144) {
            goto LABEL_41;
          }
          long long v145 = *(_OWORD *)(v37 + 32);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
          *(_OWORD *)&v373.double c = v145;
          if (CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373)) {
            goto LABEL_41;
          }
          uint64_t v146 = *(void *)(v37 + 48);
          long long v147 = *(_OWORD *)(v37 + 112);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 96);
          *(_OWORD *)&v373.double c = v147;
          *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 128);
          CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v146, (uint64_t)&v373, v143, v29, v30, v31, v32);
          int v148 = *(_DWORD *)(v37 + 8);
          if ((v148 & 0x40000) != 0)
          {
            uint64_t v149 = *(void *)(v37 + 72);
            uint64_t v150 = *(void *)v366;
            double v151 = *(double *)(v149 + 56);
            double v152 = *(double *)(v149 + 64);
            uint64_t v153 = *(void *)(*(void *)v366 + 120);
            if (*(double *)(v153 + 24) != v151 || *(double *)(v153 + 32) != v152)
            {
              maybeCopyRenderingState(*(uint64_t *)v366);
              uint64_t v155 = *(void *)(v150 + 120);
              *(double *)(v155 + 24) = v151;
              *(double *)(v155 + 32) = v152;
            }
            double v156 = *(double *)(v149 + 72);
            if (*(double *)(*(void *)(v150 + 144) + 16) != v156)
            {
              maybe_copy_device_state(v150);
              *(double *)(*(void *)(v150 + 144) + 16) = v156;
            }
            _D4 = *(double *)(v149 + 8);
            _D0 = *(double *)(v149 + 16);
            _D3 = *(double *)(v149 + 24);
            _D1 = *(double *)(v149 + 32);
            float64x2_t v161 = *(float64x2_t *)(v149 + 40);
            if (m)
            {
              _Q5 = *(_OWORD *)&m->a;
              float64x2_t v163 = *(float64x2_t *)&m->c;
              double v164 = vmlad_n_f64(_D0 * v163.f64[0], _D4, m->a);
              __asm { FMLA            D0, D4, V5.D[1] }
              double v165 = vmlad_n_f64(_D1 * v163.f64[0], _D3, m->a);
              __asm { FMLA            D1, D3, V5.D[1] }
              float64x2_t v161 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v163, v161, 1), *(float64x2_t *)&m->a, v161.f64[0]));
              _D4 = v164;
              _D3 = v165;
            }
            uint64_t v166 = *(void *)v364;
            *(double *)(*(void *)v364 + 24) = _D4;
            *(double *)(v166 + 32) = _D0;
            *(double *)(v166 + 40) = _D3;
            *(double *)(v166 + 48) = _D1;
            *(float64x2_t *)(v166 + 56) = v161;
            int v148 = *(_DWORD *)(v37 + 8);
          }
          if ((v148 & 0x10000) != 0)
          {
            uint64_t v167 = *(void *)(*(void *)(v37 + 56) + 8);
            if (v167)
            {
              CGGStateSetFillColor(*(uint64_t *)v366, *(void **)(v167 + 16));
              int v148 = *(_DWORD *)(v37 + 8);
            }
          }
          if ((v148 & 0x20000) != 0) {
            CG::DisplayListExecutor::applyEntryStrokeState(*(void *)(v37 + 64), *(uint64_t *)v366);
          }
          CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v146 + 96) << 18) >> 26);
          uint64_t v168 = *(void *)v366;
          double v169 = *(double *)(v146 + 56);
          if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v169)
          {
            maybeCopyRenderingState(*(uint64_t *)v366);
            *(double *)(*(void *)(v168 + 120) + 8) = v169;
          }
          int v170 = *(const void **)(v37 + 88);
          if (!v170) {
            goto LABEL_41;
          }
          if (*(unsigned char *)(v37 + 84))
          {
            if (!*(void *)v363 || *(void *)(*(void *)v363 + 232))
            {
              uint64_t v171 = *(unsigned int *)(v37 + 80);
              if ((int)v171 <= 1)
              {
                long long v172 = *(_OWORD *)(v37 + 32);
                *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
                *(_OWORD *)&v373.double c = v172;
                CGContextDelegateDrawPathDirect(*(uint64_t *)v363, *(uint64_t *)v364, *(uint64_t *)v366, v171, v170, (uint64_t)&v373);
                goto LABEL_41;
              }
            }
            Copdouble y = CGPathCreateMutable();
            CGPathAddPath(Copy, (const CGAffineTransform *)(*(void *)v366 + 24), (CGPathRef)v170);
          }
          else
          {
            if (!m)
            {
              CGContextDelegateDrawPath(*(uint64_t *)v363, *(uint64_t *)v364, *(uint64_t *)v366, *(unsigned int *)(v37 + 80), v170);
              goto LABEL_41;
            }
            Copdouble y = CGPathCreateMutable();
            CGPathAddPath(Copy, m, (CGPathRef)v170);
          }
          CGContextDelegateDrawPath(*(uint64_t *)v363, *(uint64_t *)v364, *(uint64_t *)v366, *(unsigned int *)(v37 + 80), Copy);
          if (!Copy) {
            goto LABEL_41;
          }
          goto LABEL_339;
        case 3:
          uint64_t v173 = *(void *)v366;
          if (v37) {
            BOOL v174 = *(void *)v366 == 0;
          }
          else {
            BOOL v174 = 1;
          }
          if (v174) {
            goto LABEL_41;
          }
          long long v175 = *(_OWORD *)(v37 + 32);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
          *(_OWORD *)&v373.double c = v175;
          if (CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373)) {
            goto LABEL_41;
          }
          uint64_t v176 = *(void *)(v37 + 48);
          long long v177 = *(_OWORD *)(v37 + 104);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
          *(_OWORD *)&v373.double c = v177;
          *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
          CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v176, (uint64_t)&v373, v173, v29, v30, v31, v32);
          int v178 = *(_DWORD *)(v37 + 8);
          if ((v178 & 0x40000) != 0)
          {
            uint64_t v179 = *(void *)(v37 + 72);
            uint64_t v180 = *(void *)v366;
            double v181 = *(double *)(v179 + 56);
            double v182 = *(double *)(v179 + 64);
            uint64_t v183 = *(void *)(*(void *)v366 + 120);
            if (*(double *)(v183 + 24) != v181 || *(double *)(v183 + 32) != v182)
            {
              maybeCopyRenderingState(*(uint64_t *)v366);
              uint64_t v185 = *(void *)(v180 + 120);
              *(double *)(v185 + 24) = v181;
              *(double *)(v185 + 32) = v182;
            }
            double v186 = *(double *)(v179 + 72);
            if (*(double *)(*(void *)(v180 + 144) + 16) != v186)
            {
              maybe_copy_device_state(v180);
              *(double *)(*(void *)(v180 + 144) + 16) = v186;
            }
            _D4 = *(double *)(v179 + 8);
            _D0 = *(double *)(v179 + 16);
            _D3 = *(double *)(v179 + 24);
            _D1 = *(double *)(v179 + 32);
            float64x2_t v191 = *(float64x2_t *)(v179 + 40);
            if (m)
            {
              _Q5 = *(_OWORD *)&m->a;
              float64x2_t v193 = *(float64x2_t *)&m->c;
              double v194 = vmlad_n_f64(_D0 * v193.f64[0], _D4, m->a);
              __asm { FMLA            D0, D4, V5.D[1] }
              double v195 = vmlad_n_f64(_D1 * v193.f64[0], _D3, m->a);
              __asm { FMLA            D1, D3, V5.D[1] }
              float64x2_t v191 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v193, v191, 1), *(float64x2_t *)&m->a, v191.f64[0]));
              _D4 = v194;
              _D3 = v195;
            }
            uint64_t v196 = *(void *)v364;
            *(double *)(*(void *)v364 + 24) = _D4;
            *(double *)(v196 + 32) = _D0;
            *(double *)(v196 + 40) = _D3;
            *(double *)(v196 + 48) = _D1;
            *(float64x2_t *)(v196 + 56) = v191;
            int v178 = *(_DWORD *)(v37 + 8);
          }
          if ((v178 & 0x10000) != 0)
          {
            uint64_t v197 = *(void *)(*(void *)(v37 + 56) + 8);
            if (v197)
            {
              CGGStateSetFillColor(*(uint64_t *)v366, *(void **)(v197 + 16));
              int v178 = *(_DWORD *)(v37 + 8);
            }
          }
          if ((v178 & 0x20000) != 0) {
            CG::DisplayListExecutor::applyEntryStrokeState(*(void *)(v37 + 64), *(uint64_t *)v366);
          }
          CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v176 + 96) << 18) >> 26);
          uint64_t v198 = *(void *)v366;
          double v199 = *(double *)(v176 + 56);
          if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v199)
          {
            maybeCopyRenderingState(*(uint64_t *)v366);
            *(double *)(*(void *)(v198 + 120) + 8) = v199;
          }
          if (!*(void *)v363) {
            goto LABEL_41;
          }
          unsigned int v200 = *(const CGRect **)(v37 + 136);
          unint64_t v142 = *(void (**)(void))(*(void *)v363 + 64);
          if (v142)
          {
LABEL_319:
            v142();
            goto LABEL_41;
          }
          CFDataRef Mutable = CGPathCreateMutable();
          Copdouble y = Mutable;
          long long v335 = *(_OWORD *)(v37 + 104);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
          *(_OWORD *)&v373.double c = v335;
          *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
          uint64_t v336 = m;
          if (!m)
          {
            if (*(double *)(v37 + 88) == 1.0)
            {
              uint16x4_t v337 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)(v37 + 96)), (int32x4_t)vceqq_f64(*(float64x2_t *)(v37 + 112), (float64x2_t)xmmword_1850CD830))));
              v337.i16[0] = vmaxv_u16(v337);
              if (((*(double *)(v37 + 128) == 0.0) & ~v337.i32[0]) != 0) {
                uint64_t v336 = 0;
              }
              else {
                uint64_t v336 = &v373;
              }
            }
            else
            {
              uint64_t v336 = &v373;
            }
          }
          CGPathAddRects(Mutable, v336, v200, *(void *)(v37 + 144));
          CGContextDelegateDrawPath(*(uint64_t *)v363, *(uint64_t *)v364, *(uint64_t *)v366, *(unsigned int *)(v37 + 80), Copy);
          if (Copy) {
            goto LABEL_339;
          }
          goto LABEL_41;
        case 4:
          uint64_t v201 = *(void *)v366;
          if (v37) {
            BOOL v202 = *(void *)v366 == 0;
          }
          else {
            BOOL v202 = 1;
          }
          if (!v202)
          {
            long long v203 = *(_OWORD *)(v37 + 32);
            *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
            *(_OWORD *)&v373.double c = v203;
            if (!CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373))
            {
              uint64_t v204 = *(void *)(v37 + 48);
              long long v205 = *(_OWORD *)(v37 + 96);
              *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 80);
              *(_OWORD *)&v373.double c = v205;
              *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 112);
              CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v204, (uint64_t)&v373, v201, v29, v30, v31, v32);
              int v206 = *(_DWORD *)(v37 + 8);
              if ((v206 & 0x40000) != 0)
              {
                uint64_t v207 = *(void *)(v37 + 72);
                uint64_t v208 = *(void *)v366;
                double v209 = *(double *)(v207 + 56);
                double v210 = *(double *)(v207 + 64);
                uint64_t v211 = *(void *)(*(void *)v366 + 120);
                if (*(double *)(v211 + 24) != v209 || *(double *)(v211 + 32) != v210)
                {
                  maybeCopyRenderingState(*(uint64_t *)v366);
                  uint64_t v213 = *(void *)(v208 + 120);
                  *(double *)(v213 + 24) = v209;
                  *(double *)(v213 + 32) = v210;
                }
                double v214 = *(double *)(v207 + 72);
                if (*(double *)(*(void *)(v208 + 144) + 16) != v214)
                {
                  maybe_copy_device_state(v208);
                  *(double *)(*(void *)(v208 + 144) + 16) = v214;
                }
                _D4 = *(double *)(v207 + 8);
                _D0 = *(double *)(v207 + 16);
                _D3 = *(double *)(v207 + 24);
                _D1 = *(double *)(v207 + 32);
                float64x2_t v219 = *(float64x2_t *)(v207 + 40);
                if (m)
                {
                  _Q5 = *(_OWORD *)&m->a;
                  float64x2_t v221 = *(float64x2_t *)&m->c;
                  double v222 = vmlad_n_f64(_D0 * v221.f64[0], _D4, m->a);
                  __asm { FMLA            D0, D4, V5.D[1] }
                  double v223 = vmlad_n_f64(_D1 * v221.f64[0], _D3, m->a);
                  __asm { FMLA            D1, D3, V5.D[1] }
                  float64x2_t v219 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v221, v219, 1), *(float64x2_t *)&m->a, v219.f64[0]));
                  _D4 = v222;
                  _D3 = v223;
                }
                uint64_t v224 = *(void *)v364;
                *(double *)(*(void *)v364 + 24) = _D4;
                *(double *)(v224 + 32) = _D0;
                *(double *)(v224 + 40) = _D3;
                *(double *)(v224 + 48) = _D1;
                *(float64x2_t *)(v224 + 56) = v219;
                int v206 = *(_DWORD *)(v37 + 8);
              }
              if ((v206 & 0x10000) != 0)
              {
                uint64_t v225 = *(void *)(*(void *)(v37 + 56) + 8);
                if (v225)
                {
                  CGGStateSetFillColor(*(uint64_t *)v366, *(void **)(v225 + 16));
                  int v206 = *(_DWORD *)(v37 + 8);
                }
              }
              if ((v206 & 0x20000) != 0) {
                CG::DisplayListExecutor::applyEntryStrokeState(*(void *)(v37 + 64), *(uint64_t *)v366);
              }
              CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v204 + 96) << 18) >> 26);
              uint64_t v226 = *(void *)v366;
              double v227 = *(double *)(v204 + 56);
              if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v227)
              {
                maybeCopyRenderingState(*(uint64_t *)v366);
                *(double *)(*(void *)(v226 + 120) + 8) = v227;
                uint64_t v226 = *(void *)v366;
              }
              CGContextDelegateDrawLines(*(uint64_t *)v363, *(uint64_t *)v364, v226, *(const CGPoint **)(v37 + 128), *(void *)(v37 + 136));
            }
          }
          goto LABEL_41;
        case 5:
          uint64_t v228 = *(void *)v366;
          if (v37) {
            BOOL v229 = *(void *)v366 == 0;
          }
          else {
            BOOL v229 = 1;
          }
          if (!v229)
          {
            long long v230 = *(_OWORD *)(v37 + 32);
            *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
            *(_OWORD *)&v373.double c = v230;
            if (!CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373))
            {
              uint64_t v231 = *(void *)(v37 + 48);
              long long v232 = *(_OWORD *)(v37 + 104);
              *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
              *(_OWORD *)&v373.double c = v232;
              *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
              CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v231, (uint64_t)&v373, v228, v29, v30, v31, v32);
              if ((*(unsigned char *)(v37 + 10) & 4) != 0)
              {
                uint64_t v233 = *(void *)(v37 + 72);
                uint64_t v234 = *(void *)v366;
                double v235 = *(double *)(v233 + 56);
                double v236 = *(double *)(v233 + 64);
                uint64_t v237 = *(void *)(*(void *)v366 + 120);
                if (*(double *)(v237 + 24) != v235 || *(double *)(v237 + 32) != v236)
                {
                  maybeCopyRenderingState(*(uint64_t *)v366);
                  uint64_t v239 = *(void *)(v234 + 120);
                  *(double *)(v239 + 24) = v235;
                  *(double *)(v239 + 32) = v236;
                }
                double v240 = *(double *)(v233 + 72);
                if (*(double *)(*(void *)(v234 + 144) + 16) != v240)
                {
                  maybe_copy_device_state(v234);
                  *(double *)(*(void *)(v234 + 144) + 16) = v240;
                }
                _D4 = *(double *)(v233 + 8);
                _D0 = *(double *)(v233 + 16);
                _D3 = *(double *)(v233 + 24);
                _D1 = *(double *)(v233 + 32);
                float64x2_t v245 = *(float64x2_t *)(v233 + 40);
                if (m)
                {
                  _Q5 = *(_OWORD *)&m->a;
                  float64x2_t v247 = *(float64x2_t *)&m->c;
                  double v248 = vmlad_n_f64(_D0 * v247.f64[0], _D4, m->a);
                  __asm { FMLA            D0, D4, V5.D[1] }
                  double v249 = vmlad_n_f64(_D1 * v247.f64[0], _D3, m->a);
                  __asm { FMLA            D1, D3, V5.D[1] }
                  float64x2_t v245 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v247, v245, 1), *(float64x2_t *)&m->a, v245.f64[0]));
                  _D4 = v248;
                  _D3 = v249;
                }
                uint64_t v250 = *(void *)v364;
                *(double *)(*(void *)v364 + 24) = _D4;
                *(double *)(v250 + 32) = _D0;
                *(double *)(v250 + 40) = _D3;
                *(double *)(v250 + 48) = _D1;
                *(float64x2_t *)(v250 + 56) = v245;
              }
              CGGStateSetInterpolationQuality(*(uint64_t *)v366, *(_DWORD *)(v37 + 136));
              CGGStateSetRenderingIntent(*(uint64_t *)v366, *(_DWORD *)(v37 + 140));
              CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v231 + 96) << 18) >> 26);
              uint64_t v251 = *(void *)v366;
              double v252 = *(double *)(v231 + 56);
              if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v252)
              {
                maybeCopyRenderingState(*(uint64_t *)v366);
                *(double *)(*(void *)(v251 + 120) + 8) = v252;
              }
              uint64_t v253 = *(void *)(v37 + 80);
              if (v253)
              {
                uint64_t v28 = *(void *)(v253 + 24);
                if (v28 || (uint64_t v28 = *(void *)(v253 + 16)) != 0)
                {
                  if (*(void *)v363)
                  {
                    unint64_t v142 = *(void (**)(void))(*(void *)v363 + 96);
                    if (v142) {
                      goto LABEL_319;
                    }
                  }
                }
              }
            }
          }
          goto LABEL_41;
        case 6:
          uint64_t v254 = *(void *)v366;
          if (v37) {
            BOOL v255 = *(void *)v366 == 0;
          }
          else {
            BOOL v255 = 1;
          }
          if (v255) {
            goto LABEL_41;
          }
          long long v256 = *(_OWORD *)(v37 + 32);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
          *(_OWORD *)&v373.double c = v256;
          if (CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373)) {
            goto LABEL_41;
          }
          uint64_t v257 = *(void *)(v37 + 48);
          long long v258 = *(_OWORD *)(v37 + 104);
          *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
          *(_OWORD *)&v373.double c = v258;
          *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
          CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v257, (uint64_t)&v373, v254, v29, v30, v31, v32);
          if ((*(unsigned char *)(v37 + 10) & 4) != 0)
          {
            uint64_t v259 = *(void *)(v37 + 72);
            uint64_t v260 = *(void *)v366;
            double v261 = *(double *)(v259 + 56);
            double v262 = *(double *)(v259 + 64);
            uint64_t v263 = *(void *)(*(void *)v366 + 120);
            if (*(double *)(v263 + 24) != v261 || *(double *)(v263 + 32) != v262)
            {
              maybeCopyRenderingState(*(uint64_t *)v366);
              uint64_t v265 = *(void *)(v260 + 120);
              *(double *)(v265 + 24) = v261;
              *(double *)(v265 + 32) = v262;
            }
            double v266 = *(double *)(v259 + 72);
            if (*(double *)(*(void *)(v260 + 144) + 16) != v266)
            {
              maybe_copy_device_state(v260);
              *(double *)(*(void *)(v260 + 144) + 16) = v266;
            }
            _D4 = *(double *)(v259 + 8);
            _D0 = *(double *)(v259 + 16);
            _D3 = *(double *)(v259 + 24);
            _D1 = *(double *)(v259 + 32);
            float64x2_t v271 = *(float64x2_t *)(v259 + 40);
            if (m)
            {
              _Q5 = *(_OWORD *)&m->a;
              float64x2_t v273 = *(float64x2_t *)&m->c;
              double v274 = vmlad_n_f64(_D0 * v273.f64[0], _D4, m->a);
              __asm { FMLA            D0, D4, V5.D[1] }
              double v275 = vmlad_n_f64(_D1 * v273.f64[0], _D3, m->a);
              __asm { FMLA            D1, D3, V5.D[1] }
              float64x2_t v271 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v273, v271, 1), *(float64x2_t *)&m->a, v271.f64[0]));
              _D4 = v274;
              _D3 = v275;
            }
            uint64_t v276 = *(void *)v364;
            *(double *)(*(void *)v364 + 24) = _D4;
            *(double *)(v276 + 32) = _D0;
            *(double *)(v276 + 40) = _D3;
            *(double *)(v276 + 48) = _D1;
            *(float64x2_t *)(v276 + 56) = v271;
          }
          CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v257 + 96) << 18) >> 26);
          uint64_t v277 = *(void *)v366;
          double v278 = *(double *)(v257 + 56);
          if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v278)
          {
            maybeCopyRenderingState(*(uint64_t *)v366);
            *(double *)(*(void *)(v277 + 120) + 8) = v278;
          }
          uint64_t v279 = *(void *)(v37 + 80);
          if (!v279) {
            goto LABEL_41;
          }
          uint64_t v280 = *(void *)(v279 + 16);
          if (!v280) {
            goto LABEL_41;
          }
          int v281 = *(_DWORD *)(v37 + 136);
          switch(v281)
          {
            case 3:
              if (!*(void *)v363) {
                goto LABEL_41;
              }
              uint64_t v339 = *(unsigned int (**)(double, double, double))(*(void *)v363 + 120);
              if (v339)
              {
                if (v339(*(double *)(v37 + 224), *(double *)(v37 + 232), *(double *)(v37 + 240)) != 1006) {
                  goto LABEL_41;
                }
              }
              uint64_t v340 = *(void **)(v280 + 24);
              Functiouint64_t n = CGGradientGetFunction(v280, v26, v27, v28, v29, v30, v31, v32);
              Conidouble c = CGShadingCreateConic(v340, Function, *(double *)(v37 + 224), *(double *)(v37 + 232), *(double *)(v37 + 240), v342, v343, v344, v345, v346, v347);
              break;
            case 2:
              if (!*(void *)v363) {
                goto LABEL_41;
              }
              uint64_t v349 = *(unsigned int (**)(double, double, double, double, double, double))(*(void *)v363 + 112);
              if (v349)
              {
                if (v349(*(double *)(v37 + 176), *(double *)(v37 + 184), *(double *)(v37 + 208), *(double *)(v37 + 192), *(double *)(v37 + 200), *(double *)(v37 + 216)) != 1006)goto LABEL_41; {
              }
                }
              uint64_t v350 = *(void **)(v280 + 24);
              CGFunctionRef v351 = CGGradientGetFunction(v280, v26, v27, v28, v29, v30, v31, v32);
              if (v351) {
                float v353 = (double *)*((void *)v351 + 5);
              }
              else {
                float v353 = 0;
              }
              Conidouble c = CGShadingCreateRadialInternal(v350, 0, 0, v353, v351, *(_DWORD *)(v37 + 140) & 1, (*(_DWORD *)(v37 + 140) >> 1) & 1, v352, *(double *)(v37 + 176), *(double *)(v37 + 184), *(double *)(v37 + 208), *(double *)(v37 + 192), *(double *)(v37 + 200), *(double *)(v37 + 216));
              break;
            case 1:
              if (!*(void *)v363) {
                goto LABEL_41;
              }
              unsigned int v282 = *(unsigned int (**)(double, double, double, double))(*(void *)v363 + 104);
              if (v282)
              {
                if (v282(*(double *)(v37 + 144), *(double *)(v37 + 152), *(double *)(v37 + 160), *(double *)(v37 + 168)) != 1006)goto LABEL_41; {
              }
                }
              unsigned int v283 = *(void **)(v280 + 24);
              CGFunctionRef v284 = CGGradientGetFunction(v280, v26, v27, v28, v29, v30, v31, v32);
              if (v284) {
                int v286 = (double *)*((void *)v284 + 5);
              }
              else {
                int v286 = 0;
              }
              Conidouble c = CGShadingCreateAxialInternal(v283, 0, 0, v286, v284, *(_DWORD *)(v37 + 140) & 1, (*(_DWORD *)(v37 + 140) >> 1) & 1, v285, *(double *)(v37 + 144), *(double *)(v37 + 152), *(double *)(v37 + 160), *(double *)(v37 + 168));
              break;
            default:
              goto LABEL_41;
          }
          Copdouble y = (CGImageRef)Conic;
          if (!Conic) {
            goto LABEL_41;
          }
          if (*(void *)v363)
          {
            unint64_t v354 = *(void (**)(void))(*(void *)v363 + 96);
            if (v354) {
              v354();
            }
          }
          goto LABEL_339;
        case 7:
          uint64_t v287 = *(void *)v366;
          if (v37) {
            BOOL v288 = *(void *)v366 == 0;
          }
          else {
            BOOL v288 = 1;
          }
          if (!v288)
          {
            long long v289 = *(_OWORD *)(v37 + 32);
            *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 16);
            *(_OWORD *)&v373.double c = v289;
            if (!CG::DisplayListExecutor::rejectRect((CG::DisplayListExecutor *)&v362, (const CGRect *)&v373))
            {
              uint64_t v290 = *(void *)(v37 + 48);
              long long v291 = *(_OWORD *)(v37 + 104);
              *(_OWORD *)&v373.double a = *(_OWORD *)(v37 + 88);
              *(_OWORD *)&v373.double c = v291;
              *(_OWORD *)&v373.double tx = *(_OWORD *)(v37 + 120);
              CG::DisplayListExecutor::applyEntryDrawingState((uint64_t)&v362, v290, (uint64_t)&v373, v287, v29, v30, v31, v32);
              if ((*(unsigned char *)(v37 + 10) & 4) != 0)
              {
                uint64_t v292 = *(void *)(v37 + 72);
                uint64_t v293 = *(void *)v366;
                double v294 = *(double *)(v292 + 56);
                double v295 = *(double *)(v292 + 64);
                uint64_t v296 = *(void *)(*(void *)v366 + 120);
                if (*(double *)(v296 + 24) != v294 || *(double *)(v296 + 32) != v295)
                {
                  maybeCopyRenderingState(*(uint64_t *)v366);
                  uint64_t v298 = *(void *)(v293 + 120);
                  *(double *)(v298 + 24) = v294;
                  *(double *)(v298 + 32) = v295;
                }
                double v299 = *(double *)(v292 + 72);
                if (*(double *)(*(void *)(v293 + 144) + 16) != v299)
                {
                  maybe_copy_device_state(v293);
                  *(double *)(*(void *)(v293 + 144) + 16) = v299;
                }
                _D4 = *(double *)(v292 + 8);
                _D0 = *(double *)(v292 + 16);
                _D3 = *(double *)(v292 + 24);
                _D1 = *(double *)(v292 + 32);
                float64x2_t v304 = *(float64x2_t *)(v292 + 40);
                if (m)
                {
                  _Q5 = *(_OWORD *)&m->a;
                  float64x2_t v306 = *(float64x2_t *)&m->c;
                  double v307 = vmlad_n_f64(_D0 * v306.f64[0], _D4, m->a);
                  __asm { FMLA            D0, D4, V5.D[1] }
                  double v308 = vmlad_n_f64(_D1 * v306.f64[0], _D3, m->a);
                  __asm { FMLA            D1, D3, V5.D[1] }
                  float64x2_t v304 = vaddq_f64(*(float64x2_t *)&m->tx, vmlaq_n_f64(vmulq_laneq_f64(v306, v304, 1), *(float64x2_t *)&m->a, v304.f64[0]));
                  _D4 = v307;
                  _D3 = v308;
                }
                uint64_t v309 = *(void *)v364;
                *(double *)(*(void *)v364 + 24) = _D4;
                *(double *)(v309 + 32) = _D0;
                *(double *)(v309 + 40) = _D3;
                *(double *)(v309 + 48) = _D1;
                *(float64x2_t *)(v309 + 56) = v304;
              }
              CGGStateSetInterpolationQuality(*(uint64_t *)v366, *(_DWORD *)(v37 + 136));
              CGGStateSetRenderingIntent(*(uint64_t *)v366, *(_DWORD *)(v37 + 140));
              CGGStateSetRenderingIntent(*(uint64_t *)v366, (int)(*(_DWORD *)(v290 + 96) << 18) >> 26);
              uint64_t v317 = *(void *)v366;
              double v318 = *(double *)(v290 + 56);
              if (*(double *)(*(void *)(*(void *)v366 + 120) + 8) != v318)
              {
                maybeCopyRenderingState(*(uint64_t *)v366);
                *(double *)(*(void *)(v317 + 120) + 8) = v318;
              }
              uint64_t v319 = *(void *)(v37 + 80);
              if (v319) {
                CGDisplayListDelegateDrawDisplayList(*(void **)v363, *(uint64_t *)v364, *(uint64_t *)v366, *(void *)(v319 + 16), v313, v314, v315, v316);
              }
              else {
                CGPostError((uint64_t)"entry has NULL display list resource", v310, v311, v312, v313, v314, v315, v316, v360);
              }
            }
          }
          goto LABEL_41;
        case 8:
          uint64_t v320 = *(void *)v366;
          if (v37) {
            BOOL v321 = *(void *)v366 == 0;
          }
          else {
            BOOL v321 = 1;
          }
          if (v321) {
            goto LABEL_41;
          }
          break;
        default:
          JUMPOUT(0);
      }
      switch((v38 >> 8) & 0xF)
      {
        case 1u:
          if (*(void *)v363)
          {
            unint64_t v142 = *(void (**)(void))(*(void *)v363 + 168);
            if (v142) {
              goto LABEL_319;
            }
          }
          goto LABEL_41;
        case 2u:
          if (*(void *)v363)
          {
            unint64_t v142 = *(void (**)(void))(*(void *)v363 + 168);
            if (v142) {
              goto LABEL_319;
            }
          }
          goto LABEL_41;
        case 5u:
          uint64_t v322 = *(void *)v363;
          if (*(void *)v363 && !*(void *)(*(void *)v363 + 168)) {
            goto LABEL_41;
          }
          int v323 = *(const void **)(v37 + 80);
          if (v323)
          {
            if (!v324)
            {
              CGPostError((uint64_t)"%s: Unexpected action resource type", v26, v27, v325, v326, v30, v31, v32, (char)"void CG::DisplayListExecutor::handleAction(const DisplayListEntryAction *)");
              goto LABEL_41;
            }
            uint64_t v28 = v324[2];
          }
          else
          {
            uint64_t v28 = 0;
          }
          uint64_t v338 = *(void *)(v37 + 88);
          if (v338)
          {
            uint64_t v29 = *(void *)(v338 + 16);
            if (v322) {
              goto LABEL_318;
            }
          }
          else
          {
            uint64_t v29 = 0;
            if (v322)
            {
LABEL_318:
              unint64_t v142 = *(void (**)(void))(v322 + 168);
              if (v142) {
                goto LABEL_319;
              }
            }
          }
LABEL_41:
          a2 += 2;
          if (a2 == a3)
          {
            uint64_t v33 = *(void *)v364;
            goto LABEL_346;
          }
          break;
        case 6u:
          int v327 = *(const void **)(v37 + 80);
          if (!v327) {
            goto LABEL_41;
          }
          if (!v328) {
            goto LABEL_41;
          }
          uint64_t v329 = v328[2];
          if (!v329) {
            goto LABEL_41;
          }
          uint64_t v330 = *(void *)(v37 + 88);
          if (!v330) {
            goto LABEL_41;
          }
          CFDictionaryRef v331 = *(const __CFDictionary **)(v330 + 16);
          if (!v331) {
            goto LABEL_41;
          }
          uint64_t v26 = *(void *)v363;
          if (!*(void *)v363) {
            goto LABEL_41;
          }
          int v332 = v364[0];
          uint64_t v333 = *(unsigned int (**)(void, void, uint64_t, __CFString *, const __CFDictionary *))(*(void *)v363 + 168);
          if (!v333) {
            goto LABEL_291;
          }
          if (v333(*(void *)v363, *(void *)v364, v320, @"kCGContextDisplayList", v331) == 1006)
          {
            LODWORD(v26) = v363[0];
            int v332 = v364[0];
LABEL_291:
            CG::DisplayList::execute(v329 + 16, v26, v332, v365[0], 0, v331);
          }
          goto LABEL_41;
        default:
          goto LABEL_41;
      }
    }
  }
LABEL_346:
  long long v356 = *(_OWORD *)&v372.a;
  long long v357 = *(_OWORD *)&v372.c;
  *(_OWORD *)(v33 + 56) = *(_OWORD *)&v372.tx;
  *(_OWORD *)(v33 + 40) = v357;
  *(_OWORD *)(v33 + 24) = v356;
  return CGGStackRestore(*(uint64_t **)v365, v26, v27, v28, v29, v30, v31, v32);
}

void sub_184C47BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *a14)
{
  long long v17 = v14[1];
  long long v16 = v14[2];
  *(_OWORD *)(a13 + 24) = *v14;
  *(_OWORD *)(a13 + 40) = v17;
  *(_OWORD *)(a13 + 56) = v16;
  CGGStackRestore(a14, a2, a3, a4, a5, a6, a7, a8);
  _Unwind_Resume(a1);
}

void CGContextRestoreGState(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      *((void *)c + 12) = CGGStackRestore(*((uint64_t **)c + 13), v1, v2, v3, v4, v5, v6, v7);
      return;
    }
    CGContextRef v8 = c;
  }
  else
  {
    CGContextRef v8 = 0;
  }

  handle_invalid_context((char)"CGContextRestoreGState", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
}

uint64_t CGGStackRestore(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (uint64_t *)a1[1];
  if (v9 == a1 || (CGRect v10 = (uint64_t *)v9[1], v10 == a1))
  {
    CGPostError((uint64_t)"%s: CG GState restored too many times", a2, a3, a4, a5, a6, a7, a8, (char)"CGGStackRestore");
  }
  else
  {
    uint64_t v11 = *v9;
    *(void *)(v11 + 8) = v10;
    *CGRect v10 = v11;
    *uint64_t v9 = (uint64_t)v9;
    v9[1] = (uint64_t)v9;
    CGGStateRelease((uint64_t)v9);
  }
  return a1[1];
}

void CGGStateSetFont(uint64_t a1, const void *a2)
{
  if (*(const void **)(*(void *)(a1 + 136) + 8) != a2)
  {
    maybe_copy_text_state(a1);
    uint64_t v4 = *(const void **)(*(void *)(a1 + 136) + 8);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 136) + 8) = a2;
  }
}

void maybe_copy_text_state(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 20) & 8) != 0)
  {
    uint64_t v2 = *(unsigned __int16 **)(a1 + 136);
    CGRect v10 = (unsigned __int16 *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
    unsigned __int16 v11 = *v10 & 0xFFFE;
    *CGRect v10 = v11;
    *((_DWORD *)v10 + 1) = 1;
    uint64_t v12 = *((void *)v2 + 1);
    if (v12)
    {
      CFRetain(*((CFTypeRef *)v2 + 1));
      LOBYTE(v11) = *(unsigned char *)v10;
    }
    *((void *)v10 + 1) = v12;
    *((_OWORD *)v10 + 1) = *((_OWORD *)v2 + 1);
    int v13 = v11 | (*((unsigned __int8 *)v2 + 1) << 8);
    *CGRect v10 = v13;
    *((void *)v10 + 4) = *((void *)v2 + 4);
    unsigned int v14 = *v2 & 2 | v13 & 0xFFFFFFFD;
    *CGRect v10 = v14;
    *((_DWORD *)v10 + 14) = *((_DWORD *)v2 + 14);
    uint64_t v15 = *((void *)v2 + 6);
    *((void *)v10 + 5) = *((void *)v2 + 5);
    *((void *)v10 + 6) = v15;
    uint64_t v16 = *((void *)v2 + 8);
    if (v16)
    {
      CFRetain(*((CFTypeRef *)v2 + 8));
      unsigned int v14 = *v10;
    }
    *((void *)v10 + 8) = v16;
    *(_OWORD *)(v10 + 36) = *(_OWORD *)(v2 + 36);
    *((void *)v10 + 11) = *((void *)v2 + 11);
    unsigned int v17 = v14 & 0xFFFFFFFB | (4 * ((*v2 >> 2) & 1));
    *CGRect v10 = v17;
    unsigned int v18 = v17 & 0xFFFFFFF7 | (8 * ((*v2 >> 3) & 1));
    *CGRect v10 = v18;
    unsigned int v19 = v18 & 0xFFFFFFEF | (16 * ((*v2 >> 4) & 1));
    *CGRect v10 = v19;
    unsigned int v20 = v19 & 0xFFFFFFDF | (32 * ((*v2 >> 5) & 1));
    *CGRect v10 = v20;
    unsigned int v21 = v20 & 0xFFFFFFBF | (((*v2 >> 6) & 1) << 6);
    *CGRect v10 = v21;
    *CGRect v10 = v21 & 0xFF7F | *v2 & 0x80;
    *(void *)(a1 + 136) = v10;
    text_state_release(v2, v3, v4, v5, v6, v7, v8, v9);
    *(unsigned char *)(a1 + 20) &= ~8u;
  }
}

void CGGStateSetFontRenderingStyle(uint64_t a1, unsigned int a2)
{
  CGGStateSetShouldAntialiasFonts(a1, a2 & 1);
  CGGStateSetShouldSmoothFonts(a1, (a2 >> 1) & 1);
  CGGStateSetShouldSubpixelPositionFonts(a1, (a2 >> 2) & 1);
  CGGStateSetShouldSubpixelQuantizeFonts(a1, (a2 >> 3) & 1);
  CGGStateSetShouldUsePlatformNativeGlyphs(a1, (a2 >> 9) & 1);
  unsigned int v4 = a2 & 0xD80;
  if (v4 >> 7 <= 9 && ((1 << (v4 >> 7)) & 0x30F) != 0 && *(_DWORD *)(*(void *)(a1 + 136) + 48) != v4)
  {
    maybe_copy_text_state(a1);
    *(_DWORD *)(*(void *)(a1 + 136) + 48) = v4;
  }
  int v5 = a2 & 0x70;
  if ((v5 - 16) <= 0x6F && *(_DWORD *)(*(void *)(a1 + 136) + 52) != v5)
  {
    maybe_copy_text_state(a1);
    *(_DWORD *)(*(void *)(a1 + 136) + 52) = v5;
  }
}

void CGGStateSetShouldUsePlatformNativeGlyphs(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 0x40) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 64;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFFBF | v4;
  }
}

void CGGStateSetShouldSubpixelQuantizeFonts(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 0x20) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 32;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFFDF | v4;
  }
}

void CGGStateSetShouldSubpixelPositionFonts(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 0x10) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 16;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFFEF | v4;
  }
}

void CGGStateSetShouldSmoothFonts(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 8) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 8;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFFF7 | v4;
  }
}

void CGGStateSetShouldAntialiasFonts(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 4) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 4;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFFFB | v4;
  }
}

void CG::Path::append(CG::Path *this, const CG::Path *a2, const CGAffineTransform *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = *(_DWORD *)a2;
  if (*(_DWORD *)this)
  {
    if (v11)
    {
      if (*(_DWORD *)this != 9)
      {
        CG::Path::convert_to_huge_(this);
        int v11 = *(_DWORD *)a2;
      }
      unint64_t v12 = *((void *)this + 1);
      switch(v11)
      {
        case 1:
          CG::Path::append_rect((uint64_t)this, &unit_rect, (float64x2_t *)((char *)a2 + 8));
          break;
        case 2:
          CG::Path::append_rounded_rect((uint64_t)this, &unit_rect, *(CGSize *)((char *)a2 + 56), (const CGAffineTransform *)((char *)a2 + 8));
          break;
        case 3:
          CG::Path::append_uneven_rounded_rect((uint64_t)this, &unit_rect, (const CGSize *)((char *)a2 + 56), (float64x2_t *)((char *)a2 + 8));
          break;
        case 4:
          CG::Path::append_ellipse(this, &unit_rect, *((unsigned __int8 *)a2 + 57), *((unsigned __int8 *)a2 + 56), (const CGAffineTransform *)((char *)a2 + 8));
          break;
        case 5:
          CG::Path::append_line_segment((uint64_t)this, (__n128 *)((char *)a2 + 8), (const CGPoint *)((char *)a2 + 24), 0);
          break;
        case 6:
          CG::Path::add_arc_relative(this, (float64x2_t *)&CGPointZero, 1.0, 0.0, *((double *)a2 + 7), (CGPoint *)((char *)a2 + 8), 1);
          break;
        case 7:
          CG::Path::append_region(this, *((void **)this + 1), 0, a4, a5, a6, a7, a8);
          break;
        case 8:
          CG::Path::append_tiny(this, (const CGPoint *)a2 + 1, *((unsigned __int16 *)a2 + 4), *((_DWORD *)a2 + 3), *((unsigned __int16 *)a2 + 5));
          break;
        case 9:
          CG::Path::reserve_space(this, *((void *)a2 + 1), *((void *)a2 + 2));
          memcpy((void *)(*((void *)this + 4) + 16 * *((void *)this + 1)), *((const void **)a2 + 4), 16 * *((void *)a2 + 1));
          memcpy((void *)(*((void *)this + 4) + *((void *)this + 3) - *((void *)this + 2) - *((void *)a2 + 2)), (const void *)(*((void *)a2 + 4) + *((void *)a2 + 3) - *((void *)a2 + 2)), *((void *)a2 + 2));
          uint64_t v16 = *((void *)this + 2);
          *((void *)this + 1) += *((void *)a2 + 1);
          *((void *)this + 2) = v16 + *((void *)a2 + 2);
          break;
        default:
          break;
      }
      unint64_t v17 = *((void *)this + 1);
      if (!a3) {
        goto LABEL_24;
      }
      if (v12 < v17)
      {
        uint64_t v18 = 16 * v12;
        do
        {
          *(float64x2_t *)(*((void *)this + 4) + v18) = vaddq_f64(*(float64x2_t *)&a3->tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&a3->c, *(double *)(*((void *)this + 4) + v18 + 8)), *(float64x2_t *)&a3->a, *(double *)(*((void *)this + 4) + v18)));
          ++v12;
          unint64_t v17 = *((void *)this + 1);
          v18 += 16;
        }
        while (v12 < v17);
      }
      if (a3->a != 1.0
        || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)&a3->b), (int32x4_t)vceqq_f64(*(float64x2_t *)&a3->d, (float64x2_t)xmmword_1850CD830))))) & 1) != 0|| a3->ty != 0.0)
      {
        float64x2_t v31 = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
        *(float64x2_t *)((char *)this + 40) = v31;
        float64x2_t v32 = (float64x2_t)vdupq_n_s64(0xFFF0000000000000);
        *(float64x2_t *)((char *)this + 56) = v32;
        if (v17)
        {
          uint64_t v33 = (float64x2_t *)*((void *)this + 4);
          do
          {
            float64x2_t v34 = *v33++;
            float64x2_t v31 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v31, v34), (int8x16_t)v34, (int8x16_t)v31);
            *(float64x2_t *)((char *)this + 40) = v31;
            float64x2_t v32 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v34, v32), (int8x16_t)v34, (int8x16_t)v32);
            *(float64x2_t *)((char *)this + 56) = v32;
            --v17;
          }
          while (v17);
        }
      }
      else
      {
LABEL_24:
        if (v17)
        {
          double v19 = CG::Path::path_bounding_box(a2, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
          double v23 = *((double *)this + 5);
          double v24 = *((double *)this + 6);
          if (v19 < v23) {
            double v23 = v19;
          }
          if (v20 < v24) {
            double v24 = v20;
          }
          double v25 = *((double *)this + 7);
          double v26 = *((double *)this + 8);
          if (v25 < v19) {
            double v25 = v19;
          }
          if (v26 < v20) {
            double v26 = v20;
          }
          double v27 = v19 + v21;
          double v28 = v20 + v22;
          if (v27 >= v23) {
            double v29 = v23;
          }
          else {
            double v29 = v27;
          }
          if (v28 >= v24) {
            double v30 = v24;
          }
          else {
            double v30 = v28;
          }
          *((double *)this + 5) = v29;
          *((double *)this + 6) = v30;
          if (v25 >= v27) {
            double v27 = v25;
          }
          if (v26 >= v28) {
            double v28 = v26;
          }
          *((double *)this + 7) = v27;
          *((double *)this + 8) = v28;
        }
        else
        {
          *(int64x2_t *)((char *)this + 40) = vdupq_n_s64(0x7FF0000000000000uLL);
          *(int64x2_t *)((char *)this + 56) = vdupq_n_s64(0xFFF0000000000000);
        }
      }
    }
  }
  else
  {
    *(_DWORD *)this = v11;
    switch(v11)
    {
      case 1:
        long long v13 = *(_OWORD *)((char *)a2 + 8);
        long long v14 = *(_OWORD *)((char *)a2 + 24);
        long long v15 = *(_OWORD *)((char *)a2 + 40);
        goto LABEL_52;
      case 2:
        long long v13 = *(_OWORD *)((char *)a2 + 8);
        long long v14 = *(_OWORD *)((char *)a2 + 24);
        long long v15 = *(_OWORD *)((char *)a2 + 40);
        *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
        goto LABEL_52;
      case 3:
        long long v35 = *(_OWORD *)((char *)a2 + 8);
        long long v36 = *(_OWORD *)((char *)a2 + 24);
        *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
        *(_OWORD *)((char *)this + 24) = v36;
        *(_OWORD *)((char *)this + 8) = v35;
        long long v37 = *(_OWORD *)((char *)a2 + 56);
        long long v38 = *(_OWORD *)((char *)a2 + 72);
        long long v39 = *(_OWORD *)((char *)a2 + 88);
        *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
        *(_OWORD *)((char *)this + 88) = v39;
        *(_OWORD *)((char *)this + 72) = v38;
        goto LABEL_61;
      case 4:
        long long v13 = *(_OWORD *)((char *)a2 + 8);
        long long v14 = *(_OWORD *)((char *)a2 + 24);
        long long v15 = *(_OWORD *)((char *)a2 + 40);
        *((void *)this + 7) = *((void *)a2 + 7);
LABEL_52:
        *(_OWORD *)((char *)this + 40) = v15;
        goto LABEL_55;
      case 5:
        goto LABEL_54;
      case 6:
        *(_OWORD *)((char *)this + 8) = *(_OWORD *)((char *)a2 + 8);
        long long v40 = *(_OWORD *)((char *)a2 + 24);
        long long v41 = *(_OWORD *)((char *)a2 + 40);
        long long v42 = *(_OWORD *)((char *)a2 + 56);
        *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
        *(_OWORD *)((char *)this + 56) = v42;
        *(_OWORD *)((char *)this + 40) = v41;
        *(_OWORD *)((char *)this + 24) = v40;
LABEL_54:
        long long v13 = *(_OWORD *)((char *)a2 + 8);
        long long v14 = *(_OWORD *)((char *)a2 + 24);
LABEL_55:
        *(_OWORD *)((char *)this + 24) = v14;
        *(_OWORD *)((char *)this + 8) = v13;
        break;
      case 7:
        CFTypeRef v43 = (CFTypeRef)*((void *)a2 + 1);
        if (v43) {
          CFTypeRef v43 = CFRetain(v43);
        }
        *((void *)this + 1) = v43;
        break;
      case 8:
        long long v44 = *(_OWORD *)((char *)a2 + 8);
        long long v45 = *(_OWORD *)((char *)a2 + 24);
        long long v46 = *(_OWORD *)((char *)a2 + 40);
        *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
        *(_OWORD *)((char *)this + 40) = v46;
        *(_OWORD *)((char *)this + 24) = v45;
        *(_OWORD *)((char *)this + 8) = v44;
        long long v47 = *(_OWORD *)((char *)a2 + 72);
        long long v48 = *(_OWORD *)((char *)a2 + 88);
        long long v49 = *(_OWORD *)((char *)a2 + 104);
        *((void *)this + 15) = *((void *)a2 + 15);
        *(_OWORD *)((char *)this + 104) = v49;
        *(_OWORD *)((char *)this + 88) = v48;
        *(_OWORD *)((char *)this + 72) = v47;
        break;
      case 9:
        *((void *)this + 9) = *((void *)a2 + 9);
        *((void *)this + 10) = *((void *)a2 + 10);
        size_t v50 = *((void *)a2 + 3);
        *((void *)this + 3) = v50;
        *((void *)this + 1) = *((void *)a2 + 1);
        *((void *)this + 2) = *((void *)a2 + 2);
        unsigned int v51 = malloc_type_malloc(v50, 0x875A8E18uLL);
        *((void *)this + 4) = v51;
        memcpy(v51, *((const void **)a2 + 4), 16 * *((void *)this + 1));
        memcpy((void *)(*((void *)this + 4) + *((void *)this + 3) - *((void *)this + 2)), (const void *)(*((void *)a2 + 4) + *((void *)this + 3) - *((void *)this + 2)), *((void *)this + 2));
        *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
        long long v37 = *(_OWORD *)((char *)a2 + 56);
LABEL_61:
        *(_OWORD *)((char *)this + 56) = v37;
        break;
      default:
        break;
    }
    if (a3)
    {
      CG::Path::apply_transform(this, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
  }
}

void CGPathAddPath(CGMutablePathRef path1, const CGAffineTransform *m, CGPathRef path2)
{
  if (path1)
  {
    if (CGPathDisableTypeValidation)
    {
      if (!path2) {
        return;
      }
    }
    else
    {
      CFTypeID v11 = CFGetTypeID(path1);
      CFTypeID TypeID = CGPathGetTypeID();
      if (!path2) {
        return;
      }
      if (v11 != TypeID) {
        return;
      }
      if (!CGPathDisableTypeValidation)
      {
        CFTypeID v13 = CFGetTypeID(path2);
        if (v13 != CGPathGetTypeID()) {
          return;
        }
      }
    }
    {
      CG::Path::append((CGMutablePathRef)((char *)path1 + 16), (CGPathRef)((char *)path2 + 16), m, v14, v15, v16, v17, v18);
    }
  }
}

void CGGStateSetRenderingIntent(uint64_t a1, int a2)
{
  if (a2 != (int)(*(_DWORD *)(*(void *)(a1 + 120) + 4) << 12) >> 28)
  {
    char v2 = a2;
    maybeCopyRenderingState(a1);
    *(_DWORD *)(*(void *)(a1 + 120) + 4) = *(_DWORD *)(*(void *)(a1 + 120) + 4) & 0xFFF0FFFF | ((v2 & 0xF) << 16);
  }
}

void CG::DisplayListExecutor::applyEntryDrawingState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a4;
  uint64_t v9 = (float64x2_t *)a3;
  uint64_t v10 = a2;
  uint64_t v12 = *(void *)(a2 + 8);
  if (v12) {
    uint64_t v13 = *(void *)(v12 + 16);
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(void *)(a2 + 16);
  if (v14) {
    uint64_t v15 = *(void *)(v14 + 16);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16 == v13) {
    goto LABEL_98;
  }
  if (v16 && v13)
  {
    if (*(_DWORD *)(v16 + 4) == *(_DWORD *)(v13 + 4)) {
      goto LABEL_98;
    }
    uint64_t v146 = v15;
    uint64_t v147 = a3;
    uint64_t v148 = a2;
    *(void *)(a1 + 40) = v13;
    uint64_t v18 = (unint64_t *)(v13 + 120);
    unint64_t v17 = *(void *)(v13 + 120);
    double v19 = *(double *)(v13 + 16);
    double v20 = *(double *)(v13 + 24);
    double v22 = *(double *)(v13 + 32);
    double v21 = *(double *)(v13 + 40);
    goto LABEL_14;
  }
  *(void *)(a1 + 40) = v13;
  if (!v13)
  {
    CGGStackRestore(*(uint64_t **)(a1 + 24), a2, a3, a4, a5, a6, a7, a8);
    uint64_t v8 = CGGStackSave(*(void *)(a1 + 24));
    *(void *)(a1 + 32) = v8;
    *(void *)(a1 + 80) = 0;
    goto LABEL_98;
  }
  uint64_t v146 = v15;
  uint64_t v147 = a3;
  uint64_t v148 = a2;
  uint64_t v18 = (unint64_t *)(v13 + 120);
  unint64_t v17 = *(void *)(v13 + 120);
  double v19 = *(double *)(v13 + 16);
  double v20 = *(double *)(v13 + 24);
  double v22 = *(double *)(v13 + 32);
  double v21 = *(double *)(v13 + 40);
  if (v16)
  {
LABEL_14:
    unint64_t v23 = *(void *)(v16 + 120);
    CGFloat x = *(double *)(v16 + 16);
    CGFloat v25 = *(double *)(v16 + 24);
    CGFloat width = *(double *)(v16 + 32);
    CGFloat v26 = *(double *)(v16 + 40);
    if (v17 >= v23)
    {
      unint64_t v28 = 0;
      if (v23)
      {
        double v29 = (void *)(v16 + 128);
        uint64_t v30 = *(void *)(v16 + 112);
        float64x2_t v31 = v29;
        float64x2_t v32 = (uint64_t *)(v13 + 128);
        while (1)
        {
          if (v17 <= v28)
          {
            uint64_t v34 = 0;
          }
          else
          {
            uint64_t v33 = v32;
            if (*(void *)(v13 + 112) != 3) {
              uint64_t v33 = (uint64_t *)(*(void *)(v13 + 128) + 8 * v28);
            }
            uint64_t v34 = *v33;
          }
          long long v35 = v31;
          if (v30 != 3) {
            long long v35 = (void *)(*v29 + 8 * v28);
          }
          if (v34 != *v35) {
            break;
          }
          ++v28;
          ++v32;
          ++v31;
          if (v23 == v28) {
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      unint64_t v28 = -1;
    }
    if (v28 == v23)
    {
LABEL_29:
      v150.origin.CGFloat x = x;
      v150.origin.double y = v25;
      v150.size.CGFloat width = width;
      v150.size.double height = v26;
      v154.origin.CGFloat x = v19;
      v154.origin.double y = v20;
      v154.size.CGFloat width = v22;
      v154.size.double height = v21;
      if (CGRectContainsRect(v150, v154))
      {
LABEL_34:
        v151.origin.CGFloat x = v19;
        v151.origin.double y = v20;
        v151.size.CGFloat width = v22;
        v151.size.double height = v21;
        v155.origin.CGFloat x = x;
        v155.origin.double y = v25;
        v155.size.CGFloat width = width;
        v155.size.double height = v26;
        if (CGRectEqualToRect(v151, v155)
          || v19 == -8.98846567e307 && v20 == -8.98846567e307 && v22 == 1.79769313e308 && v21 == 1.79769313e308)
        {
          goto LABEL_54;
        }
        long long v44 = (char *)CGClipCreateWithRect(*(CGAffineTransform **)(a1 + 88), 1, v19, v20, v22, v21);
        CGGStateAddClip(v8, (uint64_t)v44);
        goto LABEL_52;
      }
    }
    CGGStackRestore(*(uint64_t **)(a1 + 24), a2, a3, a4, a5, a6, a7, a8);
    uint64_t v8 = CGGStackSave(*(void *)(a1 + 24));
    unint64_t v23 = 0;
    *(void *)(a1 + 32) = v8;
    *(void *)(a1 + 80) = 0;
    uint64_t v36 = *(void *)(v8 + 112);
    long long v37 = &CGRectInfinite;
    p_double y = &CGRectInfinite.origin.y;
    p_CGSize size = &CGRectInfinite.size;
    long long v40 = (const CGRect *)(v36 + 16);
    long long v41 = (CGFloat *)(v36 + 24);
    long long v42 = (CGSize *)(v36 + 32);
    _ZF = v36 == 0;
    p_double height = (CGFloat *)(v36 + 40);
    if (_ZF)
    {
      p_double height = &CGRectInfinite.size.height;
    }
    else
    {
      p_CGSize size = v42;
      p_double y = v41;
      long long v37 = v40;
    }
    CGFloat v26 = *p_height;
    CGFloat x = v37->origin.x;
    CGFloat v25 = *p_y;
    CGFloat width = p_size->width;
    goto LABEL_34;
  }
  _ZF = v19 == -8.98846567e307 && v20 == -8.98846567e307;
  if (_ZF && v22 == 1.79769313e308 && v21 == 1.79769313e308)
  {
    unint64_t v23 = 0;
    goto LABEL_54;
  }
  long long v44 = (char *)CGClipCreateWithRect(*(CGAffineTransform **)(a1 + 88), 1, *(CGFloat *)(v13 + 16), *(CGFloat *)(v13 + 24), *(CGFloat *)(v13 + 32), *(CGFloat *)(v13 + 40));
  CGGStateAddClip(v8, (uint64_t)v44);
  unint64_t v23 = 0;
LABEL_52:
  CGClipRelease(v44);
LABEL_54:
  if (v23 < v17)
  {
    uint64_t v48 = v13 + 8 * v23 + 128;
    do
    {
      if (*v18 <= v23)
      {
        size_t v50 = 0;
        unsigned int v51 = *(CGAffineTransform **)(a1 + 88);
        if (v51) {
          goto LABEL_63;
        }
      }
      else
      {
        long long v49 = (void **)v48;
        if (*(void *)(v13 + 112) != 3) {
          long long v49 = (void **)(*(void *)(v13 + 128) + 8 * v23);
        }
        size_t v50 = (unsigned __int8 *)*v49;
        unsigned int v51 = *(CGAffineTransform **)(a1 + 88);
        if (v51)
        {
LABEL_63:
          int v52 = v50[8];
          switch((char)v52)
          {
            case 0:
              double v53 = &CGRectNull.size.height;
              unsigned int v54 = &CGRectNull.origin.y;
              BOOL v55 = v52 == 0;
              if (v50[8]) {
                uint64_t v56 = &CGRectNull.size;
              }
              else {
                uint64_t v56 = (CGSize *)(v50 + 40);
              }
              if (v55) {
                unsigned int v54 = (CGFloat *)(v50 + 32);
              }
              if (v55) {
                int32x2_t v57 = (const CGRect *)(v50 + 24);
              }
              else {
                int32x2_t v57 = &CGRectNull;
              }
              if (v55) {
                double v53 = (CGFloat *)(v50 + 48);
              }
              size_t v50 = (unsigned __int8 *)CGClipCreateWithRect(v51, v50[10], v57->origin.x, *v54, v56->width, *v53);
              goto LABEL_95;
            case 2:
              CFDataRef Mutable = CGPathCreateMutable();
              unsigned int v59 = Mutable;
              if (v50[8] == 2) {
                float64x2_t v60 = (const CGPath *)*((void *)v50 + 3);
              }
              else {
                float64x2_t v60 = 0;
              }
              int v65 = v50[10];
              CGPathAddPath(Mutable, *(const CGAffineTransform **)(a1 + 88), v60);
              __int16 v66 = *((_WORD *)v50 + 4);
              if ((v66 & 0xFF00) == 0x200 && (uint64_t v67 = *((void *)v50 + 2)) != 0)
              {
                CopyWithTransforuint64_t m = CGClipStrokeCreateCopyWithTransform(v67, *(const CGAffineTransform **)(a1 + 88));
                size_t v50 = (unsigned __int8 *)CGClipCreateWithStrokedPath(v59, (uint64_t)CopyWithTransform);
                CGClipStrokeRelease(CopyWithTransform);
              }
              else
              {
                double v69 = 1.0;
                if (*((_WORD *)v50 + 4) == 2) {
                  double v69 = *((double *)v50 + 4);
                }
                size_t v50 = (unsigned __int8 *)CGClipCreateWithPath(v59, v66 >> 8, v65 != 0, v69);
              }
              if (v59) {
                CFRelease(v59);
              }
              goto LABEL_95;
            case 3:
              if (v52 == 3)
              {
                double v61 = (char *)*((void *)v50 + 3);
                if (v61)
                {
                  CopyByApplyingTransforuint64_t m = CGClipMaskCreateCopyByApplyingTransform(v61, &v51->a);
                  size_t v50 = (unsigned __int8 *)CGClipCreateWithMask((atomic_uint *)CopyByApplyingTransform, v50[10]);
                  CGClipMaskRelease(CopyByApplyingTransform);
                }
              }
              goto LABEL_95;
            case 4:
              if (v52 != 4) {
                goto LABEL_96;
              }
              uint64_t v63 = *((void *)v50 + 3);
              if (!v63) {
                goto LABEL_96;
              }
              uint64_t v64 = (atomic_uint *)CGTextClippingCreateCopyByApplyingTransform(v63, (float64x2_t *)v51);
              size_t v50 = (unsigned __int8 *)CGClipCreateWithTextClipping(v64);
              CGTextClippingRelease(v64);
              break;
            default:
              goto LABEL_77;
          }
          goto LABEL_95;
        }
        if (v50) {
LABEL_77:
        }
          atomic_fetch_add_explicit((atomic_uint *volatile)v50, 1u, memory_order_relaxed);
      }
LABEL_95:
      CGGStateAddClip(v8, (uint64_t)v50);
      CGClipRelease((char *)v50);
LABEL_96:
      ++v23;
      v48 += 8;
    }
    while (v17 != v23);
  }
  uint64_t v9 = (float64x2_t *)v147;
  uint64_t v10 = v148;
  uint64_t v15 = v146;
LABEL_98:
  if (*(void *)(a1 + 80) == v15) {
    goto LABEL_118;
  }
  if (!v15)
  {
    uint64_t v72 = v8;
    int32x2_t v73 = 0;
LABEL_116:
    CGGStateSetSoftMask(v72, v73);
    goto LABEL_117;
  }
  uint64_t v70 = *(void *)(a1 + 88);
  if (!v70)
  {
    uint64_t v72 = v8;
    int32x2_t v73 = (const void *)v15;
    goto LABEL_116;
  }
  if (*(double *)v70 == 1.0
    && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_f64(*(float64x2_t *)(v70 + 8)), (int32x4_t)vceqq_f64(*(float64x2_t *)(v70 + 24), (float64x2_t)xmmword_1850CD830))))) & 1) == 0&& *(double *)(v70 + 40) == 0.0)
  {
    CFRetain((CFTypeRef)v15);
    uint64_t v71 = v15;
  }
  else
  {
    if (_block_invoke_once_16928 != -1) {
      dispatch_once(&_block_invoke_once_16928, &__block_literal_global_5_16929);
    }
    uint64_t Instance = CGTypeCreateInstance(CGSoftMaskGetTypeID_soft_mask_type_id, 144, a3, a4, a5, a6, a7, a8);
    if (!Instance)
    {
      CGGStateSetSoftMask(v8, 0);
      uint64_t v15 = 0;
      goto LABEL_117;
    }
    uint64_t v71 = Instance;
    *(_DWORD *)(Instance + 16) = atomic_fetch_add_explicit(&identifier_16930, 1u, memory_order_relaxed) + 1;
    double v75 = *(double *)(v15 + 24);
    double v76 = *(double *)(v15 + 32);
    double v77 = *(double *)(v15 + 40);
    double v78 = *(double *)(v15 + 48);
    double v79 = *(double *)(v15 + 56);
    double v80 = *(double *)(v15 + 64);
    double v81 = *(double *)(v70 + 8);
    double v82 = *(double *)(v70 + 16);
    double v83 = *(double *)(v70 + 24);
    double v84 = v76 * v82 + v75 * *(double *)v70;
    double v85 = v76 * v83 + v75 * v81;
    double v86 = v78 * v82 + v77 * *(double *)v70;
    double v87 = v78 * v83 + v77 * v81;
    double v88 = *(double *)(v70 + 32) + v82 * v80 + v79 * *(double *)v70;
    double v89 = v83 * v80 + v79 * v81 + *(double *)(v70 + 40);
    *(double *)(Instance + 24) = v84;
    *(double *)(Instance + 32) = v85;
    *(double *)(Instance + 40) = v86;
    *(double *)(Instance + 48) = v87;
    *(double *)(Instance + 56) = v88;
    *(double *)(Instance + 64) = v89;
    long long v90 = *(_OWORD *)(v15 + 72);
    *(_OWORD *)(Instance + 88) = *(_OWORD *)(v15 + 88);
    *(_OWORD *)(Instance + 72) = v90;
    uint64_t v91 = *(void *)(v15 + 104);
    if (v91) {
      CFRetain(*(CFTypeRef *)(v15 + 104));
    }
    *(void *)(v71 + 104) = v91;
    uint64_t v92 = *(void *)(v15 + 112);
    if (v92) {
      CFRetain(*(CFTypeRef *)(v15 + 112));
    }
    *(void *)(v71 + 112) = v92;
    CFRetain((CFTypeRef)v15);
    *(void *)(v71 + 120) = v15;
    *(_OWORD *)(v71 + 128) = CGSoftMaskCreateCopyByApplyingTransform_callbacks;
    *(void *)(v71 + 144) = off_1ED090170;
    *(void *)(v71 + 152) = 0;
    uint64_t v15 = v71;
  }
  CGGStateSetSoftMask(v8, (const void *)v71);
  CFRelease((CFTypeRef)v71);
LABEL_117:
  *(void *)(a1 + 80) = v15;
LABEL_118:
  uint64_t v93 = *(float64x2_t **)(a1 + 88);
  _D4 = v9->f64[0];
  _D0 = v9->f64[1];
  _D3 = v9[1].f64[0];
  _D1 = v9[1].f64[1];
  float64x2_t v98 = v9[2];
  if (v93)
  {
    _Q5 = *v93;
    float64x2_t v100 = v93[1];
    double v101 = vmlad_n_f64(_D0 * v100.f64[0], _D4, v93->f64[0]);
    __asm { FMLA            D0, D4, V5.D[1] }
    double v105 = vmlad_n_f64(_D1 * v100.f64[0], _D3, v93->f64[0]);
    __asm { FMLA            D1, D3, V5.D[1] }
    float64x2_t v98 = vaddq_f64(v93[2], vmlaq_n_f64(vmulq_laneq_f64(v100, v98, 1), *v93, v98.f64[0]));
    _D4 = v101;
    _D3 = v105;
  }
  uint64_t v106 = *(void *)(a1 + 32);
  *(double *)(v106 + 24) = _D4;
  *(double *)(v106 + 32) = _D0;
  *(double *)(v106 + 40) = _D3;
  *(double *)(v106 + 48) = _D1;
  *(float64x2_t *)(v106 + 56) = v98;
  uint64_t v107 = *(void *)(v10 + 24);
  if (!v107)
  {
    uint64_t v108 = 0;
LABEL_130:
    uint64_t v120 = v8;
    long long v121 = (const void *)v108;
LABEL_131:
    CGGStateSetStyle(v120, v121);
    goto LABEL_132;
  }
  uint64_t v108 = *(void *)(v107 + 16);
  if (!v108 || *(_DWORD *)(v108 + 20) != 2 || (*(_DWORD *)(v108 + 104) & 0x80000000) != 0) {
    goto LABEL_130;
  }
  uint64_t style_with_type = create_style_with_type(2, a2, a3, a4, a5, a6, a7, a8);
  if (style_with_type)
  {
    uint64_t v116 = *(void *)(v108 + 24);
    if (v116) {
      CFRetain(*(CFTypeRef *)(v108 + 24));
    }
    *(void *)(style_with_type + 24) = v116;
    switch(*(_DWORD *)(v108 + 20))
    {
      case 1:
        long long v117 = *(_OWORD *)(v108 + 32);
        long long v118 = *(_OWORD *)(v108 + 48);
        long long v119 = *(_OWORD *)(v108 + 64);
        *(void *)(style_with_type + 80) = *(void *)(v108 + 80);
        *(_OWORD *)(style_with_type + 48) = v118;
        *(_OWORD *)(style_with_type + 64) = v119;
        goto LABEL_153;
      case 2:
        *(_OWORD *)(style_with_type + 32) = *(_OWORD *)(v108 + 32);
        long long v133 = *(_OWORD *)(v108 + 48);
        long long v134 = *(_OWORD *)(v108 + 64);
        long long v135 = *(_OWORD *)(v108 + 96);
        *(_OWORD *)(style_with_type + 80) = *(_OWORD *)(v108 + 80);
        *(_OWORD *)(style_with_type + 96) = v135;
        *(_OWORD *)(style_with_type + 48) = v133;
        *(_OWORD *)(style_with_type + 64) = v134;
        break;
      case 3:
        long long v117 = *(_OWORD *)(v108 + 32);
LABEL_153:
        *(_OWORD *)(style_with_type + 32) = v117;
        break;
      case 4:
        long long v136 = *(_OWORD *)(v108 + 32);
        long long v137 = *(_OWORD *)(v108 + 64);
        *(_OWORD *)(style_with_type + 48) = *(_OWORD *)(v108 + 48);
        *(_OWORD *)(style_with_type + 64) = v137;
        *(_OWORD *)(style_with_type + 32) = v136;
        long long v138 = *(_OWORD *)(v108 + 80);
        long long v139 = *(_OWORD *)(v108 + 96);
        long long v140 = *(_OWORD *)(v108 + 128);
        *(_OWORD *)(style_with_type + 112) = *(_OWORD *)(v108 + 112);
        *(_OWORD *)(style_with_type + 128) = v140;
        *(_OWORD *)(style_with_type + 80) = v138;
        *(_OWORD *)(style_with_type + 96) = v139;
        long long v141 = *(_OWORD *)(v108 + 144);
        long long v142 = *(_OWORD *)(v108 + 160);
        long long v143 = *(_OWORD *)(v108 + 176);
        *(void *)(style_with_type + 192) = *(void *)(v108 + 192);
        *(_OWORD *)(style_with_type + 160) = v142;
        *(_OWORD *)(style_with_type + 176) = v143;
        *(_OWORD *)(style_with_type + 144) = v141;
        break;
      default:
        CGLog(2, (uint64_t)"%s: Undefined type", v109, v110, v111, v112, v113, v114, (char)"CGMutableStyleRef CGStyleCreateMutableCopy(CGStyleRef)");
        break;
    }
  }
  CGRect v152 = *(CGRect *)(v10 + 64);
  long long v144 = *(_OWORD *)(v8 + 24);
  long long v145 = *(_OWORD *)(v8 + 56);
  *(_OWORD *)&v149.double c = *(_OWORD *)(v8 + 40);
  *(_OWORD *)&v149.double tx = v145;
  *(_OWORD *)&v149.double a = v144;
  CGRect v153 = CGRectApplyAffineTransform(v152, &v149);
  if (!style_with_type)
  {
    uint64_t v120 = v8;
    long long v121 = 0;
    goto LABEL_131;
  }
  if (*(_DWORD *)(style_with_type + 20) == 2) {
    *(CGRect *)(style_with_type + 72) = v153;
  }
  CGGStateSetStyle(v8, (const void *)style_with_type);
  CFRelease((CFTypeRef)style_with_type);
LABEL_132:
  uint64_t v122 = *(void *)(v10 + 40);
  if (v122) {
    int v123 = *(const void **)(v122 + 16);
  }
  else {
    int v123 = 0;
  }
  CGGStateSetUndercolorRemoval(v8, v123);
  uint64_t v124 = *(void *)(v10 + 32);
  if (v124) {
    uint64_t v125 = *(const void **)(v124 + 16);
  }
  else {
    uint64_t v125 = 0;
  }
  CGGStateSetBlackGeneration(v8, v125);
  double v126 = *(double *)(v10 + 48);
  if (*(double *)(*(void *)(v8 + 144) + 8) != v126)
  {
    maybe_copy_device_state(v8);
    *(double *)(*(void *)(v8 + 144) + 8) = v126;
  }
  CGGStateSetCompositeOperation(v8, (int)(*(_DWORD *)(v10 + 96) << 26) >> 26);
  CGGStateSetShouldAntialias(v8, (*(_DWORD *)(v10 + 96) >> 6) & 1);
  CGGStateSetAlphaIsShape(v8, (*(_DWORD *)(v10 + 96) >> 7) & 1);
  unsigned int v127 = *(_DWORD *)(v10 + 96);
  uint64_t v128 = *(void *)(v8 + 144);
  int v129 = (v127 >> 14) & 1;
  if (*(unsigned __int8 *)(v128 + 24) != v129)
  {
    maybe_copy_device_state(v8);
    uint64_t v128 = *(void *)(v8 + 144);
    *(unsigned char *)(v128 + 24) = v129;
    unsigned int v127 = *(_DWORD *)(v10 + 96);
  }
  int v130 = (v127 >> 15) & 1;
  if (*(unsigned __int8 *)(v128 + 25) != v130)
  {
    maybe_copy_device_state(v8);
    uint64_t v128 = *(void *)(v8 + 144);
    *(unsigned char *)(v128 + 25) = v130;
  }
  int v131 = *(_DWORD *)(v10 + 100);
  if (*(_DWORD *)(v128 + 28) != v131)
  {
    maybe_copy_device_state(v8);
    *(_DWORD *)(*(void *)(v8 + 144) + 28) = v131;
  }
  double v132 = *(double *)(v10 + 56);
  if (*(double *)(*(void *)(v8 + 120) + 8) != v132)
  {
    maybeCopyRenderingState(v8);
    *(double *)(*(void *)(v8 + 120) + 8) = v132;
  }
}

void CGGStateSetCompositeOperation(uint64_t a1, int a2)
{
  if (a2 != (int)(*(_DWORD *)(*(void *)(a1 + 120) + 4) << 16) >> 24)
  {
    char v2 = a2;
    maybeCopyRenderingState(a1);
    *(unsigned char *)(*(void *)(a1 + 120) + 5) = v2;
  }
}

void maybeCopyRenderingState(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 20) & 2) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 120);
    uint64_t v3 = (char *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    *(_DWORD *)uint64_t v3 = 1;
    *((void *)v3 + 1) = *(void *)(v2 + 8);
    unsigned int v4 = *((_DWORD *)v3 + 1) & 0xFFFF00FF | (*(unsigned __int8 *)(v2 + 5) << 8);
    *((_DWORD *)v3 + 1) = v4;
    uint64_t v5 = *(void *)(v2 + 16);
    if (v5)
    {
      CFRetain(*(CFTypeRef *)(v2 + 16));
      unsigned int v4 = *((_DWORD *)v3 + 1);
    }
    *((void *)v3 + 2) = v5;
    *(_OWORD *)(v3 + 24) = *(_OWORD *)(v2 + 24);
    unsigned int v6 = v4 & 0xFFF0FFFF | ((HIWORD(*(_DWORD *)(v2 + 4)) & 0xF) << 16);
    *((_DWORD *)v3 + 1) = v6;
    unsigned int v7 = v6 & 0xFF0FFFFF | (((*(_DWORD *)(v2 + 4) >> 20) & 0xF) << 20);
    *((_DWORD *)v3 + 1) = v7;
    unsigned int v8 = v7 & 0xFFFFFF00 | *(unsigned __int8 *)(v2 + 4);
    *((_DWORD *)v3 + 1) = v8;
    unsigned int v9 = v8 & 0xFEFFFFFF | ((HIBYTE(*(_DWORD *)(v2 + 4)) & 1) << 24);
    *((_DWORD *)v3 + 1) = v9;
    *((_DWORD *)v3 + 1) = v9 & 0xFDFFFFFF | (((*(_DWORD *)(v2 + 4) >> 25) & 1) << 25);
    uint64_t v10 = *(void *)(v2 + 40);
    if (v10) {
      CFRetain(*(CFTypeRef *)(v2 + 40));
    }
    *((void *)v3 + 5) = v10;
    *((_DWORD *)v3 + 12) = *(_DWORD *)(v2 + 48);
    *(void *)(a1 + 120) = v3;
    renderingStateRelease((void *)v2);
    *(unsigned char *)(a1 + 20) &= ~2u;
  }
}

void CGGStateSetStyle(uint64_t a1, const void *a2)
{
  if (*(const void **)(*(void *)(a1 + 120) + 16) != a2)
  {
    maybeCopyRenderingState(a1);
    unsigned int v4 = *(const void **)(*(void *)(a1 + 120) + 16);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 120) + 16) = a2;
  }
}

void CGGStateSetShouldAntialias(uint64_t a1, int a2)
{
  if (((((*(unsigned char *)(*(void *)(a1 + 120) + 7) & 1) == 0) ^ a2) & 1) == 0)
  {
    maybeCopyRenderingState(a1);
    if (a2) {
      int v4 = 0x1000000;
    }
    else {
      int v4 = 0;
    }
    *(_DWORD *)(*(void *)(a1 + 120) + 4) = *(_DWORD *)(*(void *)(a1 + 120) + 4) & 0xFEFFFFFF | v4;
  }
}

void CGGStateSetUndercolorRemoval(uint64_t a1, const void *a2)
{
  if (*(const void **)(*(void *)(a1 + 144) + 40) != a2)
  {
    maybe_copy_device_state(a1);
    int v4 = *(const void **)(*(void *)(a1 + 144) + 40);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 144) + 40) = a2;
  }
}

void CGGStateSetBlackGeneration(uint64_t a1, const void *a2)
{
  if (*(const void **)(*(void *)(a1 + 144) + 32) != a2)
  {
    maybe_copy_device_state(a1);
    int v4 = *(const void **)(*(void *)(a1 + 144) + 32);
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(*(void *)(a1 + 144) + 32) = a2;
  }
}

void CGGStateSetAlphaIsShape(uint64_t a1, int a2)
{
  if (((((*(unsigned char *)(*(void *)(a1 + 120) + 7) & 2) == 0) ^ a2) & 1) == 0)
  {
    maybeCopyRenderingState(a1);
    if (a2) {
      int v4 = 0x2000000;
    }
    else {
      int v4 = 0;
    }
    *(_DWORD *)(*(void *)(a1 + 120) + 4) = *(_DWORD *)(*(void *)(a1 + 120) + 4) & 0xFDFFFFFF | v4;
  }
}

BOOL CG::DisplayListExecutor::rejectRect(CG::DisplayListExecutor *this, const CGRect *a2)
{
  double v3 = *((double *)this + 6);
  double v2 = *((double *)this + 7);
  BOOL v4 = v3 == INFINITY || v2 == INFINITY;
  BOOL result = 0;
  if (!v4)
  {
    if (a2->origin.x > v3 + *((double *)this + 8)) {
      return 1;
    }
    double y = a2->origin.y;
    if (y > v2 + *((double *)this + 9) || a2->origin.x + a2->size.width < v3 || y + a2->size.height < v2) {
      return 1;
    }
  }
  return result;
}

void CGContextSetFlatness(CGContextRef c, CGFloat flatness)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    if (flatness >= 0.0)
    {
      uint64_t v9 = *((void *)c + 12);
      if (*(double *)(*(void *)(v9 + 144) + 8) != flatness)
      {
        maybe_copy_device_state(*((void *)c + 12));
        *(CGFloat *)(*(void *)(v9 + 144) + 8) = flatness;
      }
    }
    else
    {
      CGPostError((uint64_t)"%s: invalid flatness: %g", (uint64_t)c, v2, v3, v4, v5, v6, v7, (char)"CGContextSetFlatness");
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetFlatness", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

void maybe_copy_device_state(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 20) & 0x10) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 144);
    uint64_t v3 = (char *)malloc_type_malloc(0x30uLL, 0x2062DE7BuLL);
    *uint64_t v3 = 0;
    *((_DWORD *)v3 + 1) = 1;
    *(_OWORD *)(v3 + 8) = *(_OWORD *)(v2 + 8);
    *((_WORD *)v3 + 12) = *(_WORD *)(v2 + 24);
    *((_DWORD *)v3 + 7) = *(_DWORD *)(v2 + 28);
    uint64_t v4 = *(void *)(v2 + 32);
    if (v4) {
      CFRetain(*(CFTypeRef *)(v2 + 32));
    }
    *((void *)v3 + 4) = v4;
    uint64_t v5 = *(void *)(v2 + 40);
    if (v5) {
      CFRetain(*(CFTypeRef *)(v2 + 40));
    }
    *((void *)v3 + 5) = v5;
    *(void *)(a1 + 144) = v3;
    device_state_release((void *)v2);
    *(unsigned char *)(a1 + 20) &= ~0x10u;
  }
}

void CGGStateSetTextDrawingMode(uint64_t a1, int a2)
{
  if (*(char *)(*(void *)(a1 + 136) + 1) != a2)
  {
    char v2 = a2;
    maybe_copy_text_state(a1);
    *(unsigned char *)(*(void *)(a1 + 136) + 1) = v2;
  }
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
  CGFloat height = rect.size.height;
  CGFloat width = rect.size.width;
  CGFloat y = rect.origin.y;
  CGFloat x = rect.origin.x;
  CGContextSaveGState(c);
  CGContextSetCompositeOperation((uint64_t)c, 0, v7, v8, v9, v10, v11, v12);
  v14.origin.CGFloat x = x;
  v14.origin.CGFloat y = y;
  v14.size.CGFloat width = width;
  v14.size.CGFloat height = height;
  CGContextFillRect(c, v14);

  CGContextRestoreGState(c);
}

void CGContextSetCompositeOperation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      if (a2 >= 0x1C)
      {
        CGPostError((uint64_t)"%s: invalid composite operation %d", a2, a3, a4, a5, a6, a7, a8, (char)"CGContextSetCompositeOperation");
      }
      else
      {
        uint64_t v8 = *(void *)(a1 + 96);
        CGGStateSetCompositeOperation(v8, a2);
      }
      return;
    }
    uint64_t v9 = a1;
  }
  else
  {
    uint64_t v9 = 0;
  }

  handle_invalid_context((char)"CGContextSetCompositeOperation", v9, a3, a4, a5, a6, a7, a8);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  CGRect v7 = rect;
  if (rect.origin.x != INFINITY && rect.origin.y != INFINITY) {
    CGContextFillRects(c, &v7, 1uLL);
  }
}

void CGContextFillRects(CGContextRef c, const CGRect *rects, size_t count)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v11 = (const void *)*((void *)c + 21);
      if (v11)
      {
        CFRelease(v11);
        *((void *)c + 21) = 0;
      }
      if (rects)
      {
        if (count)
        {
          uint64_t v12 = *((void *)c + 5);
          if (v12)
          {
            uint64_t v13 = *(unsigned int (**)(void))(v12 + 64);
            if (!v13 || v13() == 1006)
            {
              CGContextAddRects(c, rects, count);
              CGContextDrawPath(c, kCGPathFill);
            }
          }
        }
      }
      return;
    }
    CGContextRef v14 = c;
  }
  else
  {
    CGContextRef v14 = 0;
  }

  handle_invalid_context((char)"CGContextFillRects", (uint64_t)v14, count, v3, v4, v5, v6, v7);
}

uint64_t ripc_DrawRects(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double *a5, uint64_t a6)
{
  if (a1) {
    uint64_t v10 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v10 = 0;
  }
  char v11 = 0;
  unsigned int v12 = 2;
  switch(a4)
  {
    case 0:
      goto LABEL_10;
    case 1:
      char v11 = 0;
      unsigned int v12 = 4;
      goto LABEL_10;
    case 2:
      char v11 = 1;
      unsigned int v12 = 1;
      goto LABEL_10;
    case 3:
      char v11 = 0;
      unsigned int v12 = 3;
      goto LABEL_10;
    case 4:
      char v11 = 0;
      unsigned int v12 = 5;
LABEL_10:
      memset(v27, 0, sizeof(v27));
      uint64_t v25 = 0;
      uint64_t result = ripc_GetRenderingState(v10, a2, a3, (uint64_t)v27);
      if (result)
      {
        v17.n128_u64[0] = *(void *)(*(void *)(a3 + 144) + 8);
        long long v24 = *(_OWORD *)(v10 + 24);
        uint64_t v18 = *(void *)(v10 + 40);
        v23[0] = v17.n128_u64[0];
        v23[1] = v18;
        char v19 = *(unsigned char *)(a2 + 81);
        if (v19) {
          char v19 = *(unsigned char *)(*(void *)(a3 + 120) + 7) & 1;
        }
        LOBYTE(v25) = v19;
        CGFloat v26 = (char *)&v27[1] + 8;
        if ((v11 & 1) == 0)
        {
          double v20 = *(_DWORD **)(v10 + 56);
          if (!v20)
          {
            double v20 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
            *(void *)double v20 = RIPRenderCreate_ripr_class;
            void v20[2] = 1;
            *((void *)v20 + 2) = 0;
            *(void *)(v10 + 56) = v20;
          }
          RIPRenderRectangles(v20, (uint64_t)v23, (double *)(a3 + 24), a5, a6, 0);
        }
        if (v12)
        {
          memset(v22, 0, sizeof(v22));
          ripc_GetRenderStroke(a3, (uint64_t)v22, (long long *)(a3 + 24));
          double v21 = *(_DWORD **)(v10 + 64);
          if (!v21)
          {
            double v21 = malloc_type_calloc(1uLL, 0xB8uLL, 0x415BF41uLL);
            *(void *)double v21 = RIPRenderCreate_ripr_class;
            void v21[2] = 1;
            *((void *)v21 + 2) = 0;
            *(void *)(v10 + 64) = v21;
          }
          RIPRenderRectangles(v21, (uint64_t)v23, (double *)(a3 + 24), a5, a6, (uint64_t)v22);
        }
        ripc_Render(v10, a2, a3, (uint64_t *)v27, v12, v14, v15, v16, v17);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 1000;
      break;
  }
  return result;
}

void *RIPRenderRectangles(void *result, uint64_t a2, double *a3, double *a4, uint64_t a5, uint64_t a6)
{
  if (result)
  {
    uint64_t v6 = a5;
    if (a5)
    {
      if (a4 && a2 && *result)
      {
        double v10 = *a3;
        double v9 = a3[1];
        double v11 = a3[2];
        double v12 = a3[3];
        BOOL v13 = v12 == 0.0 && *a3 == 0.0;
        if (v13)
        {
          BOOL v14 = 0;
          BOOL v15 = 1;
        }
        else
        {
          BOOL v15 = v11 == 0.0 && v9 == 0.0;
          BOOL v14 = v15;
        }
        double v16 = a3[4];
        double v17 = a3[5];
        if (!a6 && a5 == 1 && v15 && !result[2])
        {
          double v26 = *(double *)(a2 + 8);
          double v27 = v16 * v26;
          double v28 = v17 * v26;
          double v29 = *a4;
          double v30 = a4[1];
          if (v14)
          {
            double v31 = v10 * v26;
            double v32 = v12 * v26;
            double v33 = v27 + v10 * v26 * v29;
            double v34 = v28 + v32 * v30;
            double v35 = a4[2];
            double v36 = a4[3];
          }
          else
          {
            double v31 = v11 * v26;
            double v32 = v9 * v26;
            double v33 = v27 + v11 * v26 * v30;
            double v34 = v28 + v32 * v29;
            double v36 = a4[2];
            double v35 = a4[3];
          }
          double v44 = v33 + v31 * v35;
          double v45 = v34 + v32 * v36;
          if (v33 <= v44) {
            double v46 = v44;
          }
          else {
            double v46 = v33;
          }
          if (v33 > v44) {
            double v33 = v44;
          }
          if (v33 < -4194303.0) {
            double v33 = -4194303.0;
          }
          v47.f64[0] = v33 * 256.0 + 0.5;
          if (v46 <= 4194303.0) {
            double v48 = v46;
          }
          else {
            double v48 = 4194303.0;
          }
          v49.f64[0] = v48 * 256.0 + 0.5;
          if (v47.f64[0] < v49.f64[0])
          {
            if (v34 <= v45) {
              double v50 = v34;
            }
            else {
              double v50 = v34 + v32 * v36;
            }
            if (v34 > v45) {
              double v45 = v34;
            }
            if (v50 >= -4194303.0) {
              double v51 = v50;
            }
            else {
              double v51 = -4194303.0;
            }
            double v52 = v51 * 256.0 + 0.5;
            if (v45 > 4194303.0) {
              double v45 = 4194303.0;
            }
            double v53 = v45 * 256.0 + 0.5;
            if (v52 < v53)
            {
              v47.f64[1] = v52;
              int32x2_t v54 = vmovn_s64(vcvtq_s64_f64(v47));
              v49.f64[1] = v53;
              int32x2_t v55 = vmovn_s64(vcvtq_s64_f64(v49));
              uint64_t v56 = *(int32x2_t **)(a2 + 40);
              if (v56)
              {
                *(int32x2_t *)&v47.f64[0] = vshl_n_s32(vadd_s32(v56[1], *v56), 8uLL);
                *(int32x2_t *)&v49.f64[0] = vshl_n_s32(*v56, 8uLL);
                int32x2_t v54 = vmax_s32(*(int32x2_t *)&v49.f64[0], v54);
                int32x2_t v55 = vmin_s32(*(int32x2_t *)&v47.f64[0], v55);
              }
              LODWORD(v49.f64[0]) = 0;
              LOBYTE(v47.f64[0]) = *(unsigned char *)(a2 + 32);
              int8x8_t v57 = vdup_lane_s8(vceq_s8(*(int8x8_t *)&v47.f64[0], *(int8x8_t *)&v49.f64[0]), 0);
              int32x2_t v58 = (int32x2_t)vbsl_s8(v57, (int8x8_t)(*(void *)&vadd_s32(v55, (int32x2_t)0xFF000000FFLL) & 0xFFFFFF00FFFFFF00), (int8x8_t)v55);
              int32x2_t v59 = (int32x2_t)vbsl_s8(v57, (int8x8_t)(*(void *)&v54 & 0xFFFFFF00FFFFFF00), (int8x8_t)v54);
              int32x2_t v60 = vcgt_s32(v58, v59);
              if (v60.i32[0] & v60.i32[1])
              {
                result[21] = v59;
                result[22] = v58;
                result[2] = result + 21;
              }
            }
          }
        }
        else
        {
          uint64_t result = ripr_Acquire((uint64_t)result, a2);
          if (result)
          {
            double v78 = v17;
            double v79 = v16;
            if (a6)
            {
              uint64_t v81 = 0;
              memset(v80, 0, sizeof(v80));
              ripr_stroke_acquire((uint64_t)result, (uint64_t)v80, a6);
            }
            uint64_t v18 = result[3];
            if (v14)
            {
              char v19 = a4 + 2;
              do
              {
                double v20 = v16 + v10 * *(v19 - 2);
                double v21 = v17 + v12 * *(v19 - 1);
                double v22 = *v19;
                double v23 = v19[1];
                v19 += 4;
                double v24 = v20 + v10 * v22;
                double v25 = v21 + v12 * v23;
                *(float *)&double v20 = v20;
                *(float *)&double v21 = v21;
                *(float *)&double v24 = v24;
                *(float *)&double v25 = v25;
                uint64_t result = aa_rectat(v18, *(float *)&v20, *(float *)&v21, *(float *)&v24, *(float *)&v25);
                --v6;
              }
              while (v6);
            }
            else if (v13)
            {
              long long v37 = a4 + 2;
              do
              {
                double v38 = v17 + v9 * *(v37 - 2);
                double v39 = v16 + v11 * *(v37 - 1);
                double v40 = *v37;
                double v41 = v37[1];
                v37 += 4;
                double v42 = v38 + v9 * v40;
                double v43 = v39 + v11 * v41;
                *(float *)&double v39 = v39;
                *(float *)&double v40 = v38;
                *(float *)&double v38 = v43;
                *(float *)&double v43 = v42;
                uint64_t result = aa_rectat(v18, *(float *)&v39, *(float *)&v40, *(float *)&v38, *(float *)&v43);
                --v6;
              }
              while (v6);
            }
            else
            {
              double v61 = a4 + 2;
              do
              {
                double v62 = *(v61 - 2);
                double v63 = *(v61 - 1);
                double v64 = v79 + v11 * v63 + v10 * v62;
                double v65 = v78 + v12 * v63 + v9 * v62;
                double v66 = *v61;
                double v67 = v61[1];
                v61 += 4;
                *(float *)&double v62 = v64;
                *(float *)&double v63 = v65;
                aa_moveto(v18, *(float *)&v62, *(float *)&v63);
                double v68 = v64 + v10 * v66;
                double v69 = v65 + v9 * v66;
                float v70 = v68;
                float v71 = v69;
                aa_lineto(v18, v70, v71);
                double v72 = v68 + v11 * v67;
                double v73 = v69 + v12 * v67;
                float v74 = v72;
                float v75 = v73;
                aa_lineto(v18, v74, v75);
                float v76 = v72 + -v10 * v66;
                float v77 = v73 + -v9 * v66;
                aa_lineto(v18, v76, v77);
                uint64_t result = (void *)aa_close(v18);
                --v6;
              }
              while (v6);
            }
          }
        }
      }
    }
  }
  return result;
}

void CGGStateSetShouldDrawBitmapRuns(uint64_t a1, int a2)
{
  if (((((**(_WORD **)(a1 + 136) & 0x80) == 0) ^ a2) & 1) == 0)
  {
    maybe_copy_text_state(a1);
    if (a2) {
      __int16 v4 = 128;
    }
    else {
      __int16 v4 = 0;
    }
    **(_WORD **)(a1 + 136) = **(_WORD **)(a1 + 136) & 0xFF7F | v4;
  }
}

void CGGStateSetFontDilation(uint64_t a1, double a2, double a3)
{
  if (a2 < 0.0) {
    a2 = 0.0;
  }
  if (a3 < 0.0) {
    a3 = 0.0;
  }
  if (a2 <= 1.0) {
    double v3 = a2;
  }
  else {
    double v3 = 1.0;
  }
  if (a3 <= 1.0) {
    double v4 = a3;
  }
  else {
    double v4 = 1.0;
  }
  uint64_t v5 = *(void *)(a1 + 136);
  if (*(double *)(v5 + 72) != v3 || *(double *)(v5 + 80) != v4)
  {
    maybe_copy_text_state(a1);
    uint64_t v8 = *(void *)(a1 + 136);
    *(double *)(v8 + 72) = v3;
    *(double *)(v8 + 80) = v4;
  }
}

void CGGStateSetInterpolationQuality(uint64_t a1, int a2)
{
  if (*(char *)(*(void *)(a1 + 120) + 4) != a2)
  {
    char v2 = a2;
    maybeCopyRenderingState(a1);
    *(unsigned char *)(*(void *)(a1 + 120) + 4) = v2;
  }
}

void ripc_GetRenderStroke(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  long long v6 = a3[2];
  *(_OWORD *)(a2 + 16) = a3[1];
  *(_OWORD *)(a2 + 32) = v6;
  *(_OWORD *)a2 = v5;
  long long v7 = a3[1];
  v10[0] = *a3;
  v10[1] = v7;
  v10[2] = a3[2];
  *(double *)(a2 + 48) = CGGStateGetAdjustedLineWidth(a1, (double *)v10);
  uint64_t v8 = *(void *)(a1 + 128);
  *(_DWORD *)(a2 + 56) = *(char *)(v8 + 2);
  *(_DWORD *)(a2 + 60) = *(char *)(v8 + 3);
  *(void *)(a2 + 64) = *(void *)(v8 + 16);
  uint64_t v9 = *(void *)(v8 + 32);
  if (v9)
  {
    *(void *)(a2 + 80) = *(void *)(v9 + 8);
    *(void *)(a2 + 88) = *(void *)(v9 + 16);
    v9 += 24;
  }
  *(void *)(a2 + 72) = v9;
}

double CGGStateGetAdjustedLineWidth(uint64_t a1, double *a2)
{
  uint64_t v2 = *(void *)(a1 + 128);
  double v3 = *(double *)(v2 + 24);
  if (v3 == 0.0) {
    return *(double *)(v2 + 8);
  }
  double v5 = a2[1] * a2[1] + *a2 * *a2;
  double result = *(double *)(v2 + 8);
  if (v5 <= a2[3] * a2[3] + a2[2] * a2[2]) {
    double v5 = a2[3] * a2[3] + a2[2] * a2[2];
  }
  if (result * result * v5 < v3 * v3) {
    return v3 / sqrt(v5);
  }
  return result;
}

void CGGStateSetImageRenderingIntent(uint64_t a1, int a2)
{
  if (a2 != (int)(*(_DWORD *)(*(void *)(a1 + 120) + 4) << 8) >> 28)
  {
    char v2 = a2;
    maybeCopyRenderingState(a1);
    *(_DWORD *)(*(void *)(a1 + 120) + 4) = *(_DWORD *)(*(void *)(a1 + 120) + 4) & 0xFF0FFFFF | ((v2 & 0xF) << 20);
  }
}

uint64_t CGContextDelegateDrawRects(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(uint64_t (**)(void))(result + 64);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

void CGGStateAddClip(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (!*(unsigned char *)(a2 + 8))
    {
      CGFloat x = *(double *)(a2 + 24);
      CGFloat y = *(double *)(a2 + 32);
      CGFloat width = *(double *)(a2 + 40);
      CGFloat height = *(double *)(a2 + 48);
      if (!*(unsigned char *)(a2 + 10))
      {
        CGRect v10 = CGRectIntegral(*(CGRect *)(a2 + 24));
        CGFloat x = v10.origin.x;
        CGFloat y = v10.origin.y;
        CGFloat width = v10.size.width;
        CGFloat height = v10.size.height;
      }
      *(CGRect *)(a1 + 80) = CGRectIntersection(*(CGRect *)(a1 + 80), *(CGRect *)&x);
    }
    maybeCopyClipState(a1);
    uint64_t v8 = *(void *)(a1 + 112);
    CGClipStackAddClip(v8, a2);
  }
}

CGFloat *CGClipCreateWithRect(CGAffineTransform *transform, char a2, CGFloat a3, CGFloat y, CGFloat width, CGFloat height)
{
  CGFloat x = a3;
  if (!transform || transform->b == 0.0 && transform->c == 0.0 || transform->a == 0.0 && transform->d == 0.0)
  {
    double v12 = (CGFloat *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
    BOOL v13 = v12;
    if (v12)
    {
      *(_DWORD *)double v12 = 1;
      *((_DWORD *)v12 + 1) = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
      *((_WORD *)v12 + 4) = 0;
      void v12[2] = 0.0;
      *((unsigned char *)v12 + 10) = a2;
      if (transform)
      {
        long long v14 = *(_OWORD *)&transform->c;
        *(_OWORD *)&v23.double a = *(_OWORD *)&transform->a;
        *(_OWORD *)&v23.double c = v14;
        *(_OWORD *)&v23.double tx = *(_OWORD *)&transform->tx;
        CGFloat v15 = x;
        *(CGFloat *)&long long v14 = y;
        CGFloat v16 = width;
        CGFloat v17 = height;
        CGRect v24 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v14 - 8), &v23);
        CGFloat x = v24.origin.x;
        CGFloat y = v24.origin.y;
        CGFloat width = v24.size.width;
        CGFloat height = v24.size.height;
      }
      v13[3] = x;
      v13[4] = y;
      v13[5] = width;
      v13[6] = height;
    }
  }
  else
  {
    CGPathRef v19 = CGPathCreateWithRect(*(CGRect *)&a3, transform);
    if (v19 && ((CGPathRef v20 = v19, CGPathDisableTypeValidation) || (v21 = CFGetTypeID(v19), v21 == CGPathGetTypeID())))
    {
      double v22 = (CGFloat *)malloc_type_malloc(0x38uLL, 0x2062DE7BuLL);
      BOOL v13 = v22;
      if (v22)
      {
        *(_DWORD *)double v22 = 1;
        *((_DWORD *)v22 + 1) = atomic_fetch_add_explicit(CGClipCreate_identifier, 1u, memory_order_relaxed) + 1;
        *((_WORD *)v22 + 4) = 2;
        *((unsigned char *)v22 + 10) = a2;
        *((void *)v22 + 3) = v20;
        v22[4] = 1.0;
        v22[2] = 0.0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v13;
}

uint64_t CGColorTRCGetGammaID(uint64_t a1)
{
  if (CGColorTRCGetGammaID_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetGammaID_cglibrarypredicate, &__block_literal_global_8);
  }
  char v2 = (uint64_t (*)(uint64_t))CGColorTRCGetGammaID_f;

  return v2(a1);
}

uint64_t CGImageCopyHeadroomFromOriginal(uint64_t *a1, CGImage *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2)
  {
    if (!a2) {
      CGPostError((uint64_t)"%s no original image to copy headroom from", 0, a3, a4, a5, a6, a7, a8, (char)"CGImageCopyHeadroomFromOriginal");
    }
    return 0;
  }
  int v18 = 0;
  float HeadroomInfo = CGImageGetHeadroomInfo(a2, &v18);
  uint64_t result = 0;
  if (v18 && HeadroomInfo != 0.0)
  {
    if (CGImageSetHeadroom(a1, v18, HeadroomInfo)) {
      return 1;
    }
    CGPostError((uint64_t)"%s failed to copy headroom", v11, v12, v13, v14, v15, v16, v17, (char)"CGImageCopyHeadroomFromOriginal");
    return 0;
  }
  return result;
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  if (!context)
  {
    CGContextRef v11 = 0;
LABEL_10:
    handle_invalid_context((char)"CGBitmapContextCreateImage", (uint64_t)v11, v1, v2, v3, v4, v5, v6);
    return 0;
  }
  if (*((_DWORD *)context + 4) != 1129601108)
  {
    CGContextRef v11 = context;
    goto LABEL_10;
  }
  uint64_t v8 = *((void *)context + 5);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(uint64_t (**)(void))(v8 + 240);
  if (!v9)
  {
    int v13 = *((_DWORD *)context + 6);
    if (v13 == 12)
    {
      double v27 = *(uint64_t (**)(void))(v8 + 248);
      if (v27)
      {
        double v28 = (void *)v27();
        if (v28)
        {
          uint64_t v29 = (uint64_t)v28;
          CFDataRef v30 = CGDataProviderCreateWithCopyOfData(v28[8], (v28[2] - 1) * v28[11] + ((unint64_t)(v28[9] * v28[1] + 7) >> 3));
          double v31 = v30;
          if (v30) {
            *((unsigned char *)v30 + 260) = 1;
          }
          double v32 = *(CGColorSpace **)(v29 + 32);
          unint64_t v33 = *(void *)(v29 + 8);
          unint64_t v34 = *(void *)(v29 + 16);
          unint64_t v36 = *(void *)(v29 + 72);
          unint64_t v35 = *(void *)(v29 + 80);
          unint64_t v37 = *(void *)(v29 + 88);
          if (!v32) {
            return mask_create(v33, v34, v35, v36, v37, v31, CGBitmapContextCreateImage_decode_1, 1, 4);
          }
          double v38 = CGImageCreate(v33, v34, v35, v36, v37, v32, *(_DWORD *)(v29 + 40), v31, 0, 1, kCGRenderingIntentDefault);
          double v39 = v38;
          if (!*(void *)(v29 + 120)) {
            return v38;
          }
          alpha_CGImageRef image = create_alpha_image(v29);
          uint64_t v12 = CGImageCreateWithMaskAndMatte((uint64_t)v39, (uint64_t)alpha_image, CGBitmapContextCreateImage_matte_2);
          if (alpha_image) {
            CFRelease(alpha_image);
          }
          if (v39) {
            CFRelease(v39);
          }
          return v12;
        }
      }
    }
    else if (v13 == 4)
    {
      uint64_t v14 = *((void *)context + 4);
      CFDataRef v15 = CGDataProviderCreateWithCopyOfData(*(void *)(v14 + 64), *(void *)(v14 + 88) * *(void *)(v14 + 16));
      if (v15)
      {
        uint64_t v16 = v15;
        int v17 = 1;
        *((unsigned char *)v15 + 260) = 1;
        int v18 = *(CGColorSpace **)(v14 + 32);
        size_t v19 = *(void *)(v14 + 8);
        size_t v20 = *(void *)(v14 + 16);
        size_t v22 = *(void *)(v14 + 72);
        size_t v21 = *(void *)(v14 + 80);
        size_t v23 = *(void *)(v14 + 88);
        if (v18)
        {
          CGRect v24 = (uint64_t *)CGImageCreate(v19, v20, v21, v22, v23, v18, *(_DWORD *)(v14 + 40), v16, 0, 1, kCGRenderingIntentDefault);
          float v25 = *(float *)(*(void *)(*((void *)context + 12) + 120) + 48);
          if (v25 == 0.0)
          {
            double v26 = *(void **)(v14 + 32);
            if (v26 && *(unsigned char *)(v26[3] + 13))
            {
              int v17 = 0;
            }
            else
            {
              float v25 = CGColorSpaceSanitizeHeadroom(v26, v25);
              int v17 = 2;
            }
          }
          if (!CGImageSetHeadroom(v24, v17, v25)) {
            CGPostError((uint64_t)"%s: CGImageSetHeadroom failed to set headroouint64_t m = %f", v41, v42, v43, v44, v45, v46, v47, (char)"CGBitmapContextCreateImage");
          }
          if (*(void *)(v14 + 120))
          {
            CFDataRef v48 = create_alpha_image(v14);
            uint64_t v12 = CGImageCreateWithMaskAndMatte((uint64_t)v24, (uint64_t)v48, CGBitmapContextCreateImage_matte);
            if (v48) {
              CFRelease(v48);
            }
            if (v24) {
              CFRelease(v24);
            }
          }
          else
          {
            uint64_t v12 = (CGImage *)v24;
          }
        }
        else
        {
          uint64_t v12 = mask_create(v19, v20, v21, v22, v23, v16, CGBitmapContextCreateImage_decode, 1, 4);
        }
        CGDataProviderRelease(v16);
        return v12;
      }
    }
    return 0;
  }

  return (CGImageRef)v9();
}

BOOL CGImageSetHeadroom(uint64_t *image, int a2, float a3)
{
  if (a3 < 1.0 && (a3 != 0.0 || a2 != 0)) {
    return 0;
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
  if (!ColorSpace) {
    return 1;
  }
  uint64_t v9 = ColorSpace;
  uint64_t v10 = *((void *)ColorSpace + 3);
  if (*(_DWORD *)(v10 + 28) != 1) {
    return 1;
  }
  if (*(unsigned char *)(v10 + 16) || *(unsigned char *)(v10 + 17) || *(unsigned char *)(v10 + 13))
  {
    if (CGColorSpaceContainsFlexGTCInfo((BOOL)ColorSpace))
    {
      float v11 = vabds_f32(CGColorSpaceGetHeadroomInfo(v9, 0), a3);
      return v11 <= 0.00001;
    }
    if (a2 == 1)
    {
      uint64_t v13 = image[26];
      if (v13)
      {
        CFNumberRef v14 = 0;
LABEL_28:
        CGImageProviderSetContentHeadroom(v13, a3);
LABEL_29:
        uint64_t v7 = 1;
        if (!v14) {
          return v7;
        }
LABEL_30:
        CFRelease(v14);
        return v7;
      }
    }
    float valuePtr = a3;
    CFNumberRef v15 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    CFNumberRef v14 = v15;
    if (a2)
    {
      if (a2 != 2)
      {
        if (a2 != 1)
        {
          uint64_t v7 = 0;
          if (!v15) {
            return v7;
          }
          goto LABEL_30;
        }
        uint64_t v13 = image[26];
        if (!v13)
        {
          set_content_headroom_to_conversion_info((uint64_t)image, @"kCGImageHeadroom", v14);
          goto LABEL_29;
        }
        goto LABEL_28;
      }
      uint64_t v16 = @"kCGImageEstimatedHeadroom";
    }
    else
    {
      uint64_t v16 = @"kCGImageUnknownHeadroom";
    }
    set_content_headroom_to_conversion_info((uint64_t)image, v16, v15);
    uint64_t v13 = image[26];
    if (!v13) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  float v11 = fabsf(a3 + -1.0);
  return v11 <= 0.00001;
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      CGFloat height = rect.size.height;
      CGFloat width = rect.size.width;
      CGFloat y = rect.origin.y;
      CGFloat x = rect.origin.x;
      if (*((_DWORD *)c + 6) == 4)
      {
        CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
        if (ColorSpace)
        {
          if (*(unsigned char *)(*((void *)ColorSpace + 3) + 16))
          {
            if (*((_DWORD *)c + 4) == 1129601108 && *((_DWORD *)c + 6) == 4)
            {
              uint64_t v22 = *((void *)c + 4);
              uint64_t v23 = *(void *)(v22 + 32);
              if (v23 && *(unsigned char *)(*(void *)(v23 + 24) + 16) && *(_DWORD *)(v22 + 40) == 4353)
              {
                uint64_t v82 = *(void *)(*((void *)c + 14) + 72);
                InterpolationQualidouble ty = CGContextGetInterpolationQuality(c);
                if (*((_DWORD *)c + 4) == 1129601108) {
                  *(void *)(*((void *)c + 14) + 72) = 0x100000001;
                }
                else {
                  handle_invalid_context((char)"CGContextSetInterpolationQualityRange", (uint64_t)c, v24, v25, v26, v27, v28, v29);
                }
                int v32 = 1;
                CGContextSetInterpolationQuality(c, kCGInterpolationNone);
LABEL_20:
                float HeadroomInfo = CGImageGetHeadroomInfo(image, 0);
                if (HeadroomInfo >= 1.0 || HeadroomInfo <= 0.0) {
                  float v42 = HeadroomInfo;
                }
                else {
                  float v42 = 1.0;
                }
                if (HeadroomInfo >= 0.0) {
                  float v43 = v42;
                }
                else {
                  float v43 = 0.0;
                }
                if (v43 <= 1.0) {
                  goto LABEL_57;
                }
                uint64_t v44 = CGContextGetColorSpace((uint64_t)c, v33, v34, v35, v36, v37, v38, v39);
                if (v44)
                {
                  double v52 = (void *)v44;
                  if (*((_DWORD *)c + 4) == 1129601108)
                  {
                    float v53 = *(float *)(*(void *)(*((void *)c + 12) + 120) + 48);
                  }
                  else
                  {
                    handle_invalid_context((char)"CGContextGetEDRTargetHeadroom", (uint64_t)c, v46, v47, v48, v49, v50, v51);
                    float v53 = 0.0;
                  }
                  float v64 = 1.0;
                  if (v53 >= 1.0 || v53 <= 0.0) {
                    float v64 = v53;
                  }
                  if (v53 >= 0.0) {
                    float v66 = v64;
                  }
                  else {
                    float v66 = 0.0;
                  }
                  if (v66 == 0.0 && !*(unsigned char *)(v52[3] + 13)) {
                    float v66 = CGColorSpaceGetHeadroomInfo(v52, 0);
                  }
                  if (v66 <= 0.0) {
                    goto LABEL_57;
                  }
                  if (v66 < 1.0)
                  {
                    double v67 = "%s: Cannot create tone mapping settings. target headroom %f < 1.0";
LABEL_56:
                    CGPostError((uint64_t)v67, v45, v46, v47, v48, v49, v50, v51, (char)"CGContextDrawImage");
                    goto LABEL_57;
                  }
                  if (v43 < 1.0)
                  {
                    double v67 = "%s: Cannot create tone mapping settings. source headroom %f < 1.0";
                    goto LABEL_56;
                  }
                  if (v66 >= v43) {
                    goto LABEL_57;
                  }
                  keys = 0;
                  CGColorSpaceRef v68 = CGImageGetColorSpace(image);
                  if (CGImageDefaultReferenceWhite_once != -1) {
                    dispatch_once(&CGImageDefaultReferenceWhite_once, &__block_literal_global_268);
                  }
                  float v69 = CGGetFloatValue((const void *)CGImageDefaultReferenceWhite_media_white);
                  if (CGCreateSettingsForDefaultToneMapping(v52, v68, (CFMutableDictionaryRef *)&keys, v66, v43, v69, v70, v71, v72, v73, v74))
                  {
                    if (keys)
                    {
                      double v83 = keys;
                      values = @"kCGColorConversionInfoOptions";
                      CFDictionaryRef v56 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, (const void **)&v83, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                      int8x8_t v57 = keys;
LABEL_35:
                      CFRelease(v57);
                      goto LABEL_36;
                    }
                  }
                  else
                  {
                    CGPostError((uint64_t)"%s: Cannot create tone mapping settings. CGCreateSettingsForDefaultToneMapping returned false", v75, v76, v77, v78, v79, v80, v81, (char)"CGContextDrawImage");
                  }
                  CFDictionaryRef v56 = 0;
LABEL_36:
                  CGContextDrawImageWithOptions((uint64_t)c, image, v56, x, y, width, height);
                  if (v56) {
                    CFRelease(v56);
                  }
                  goto LABEL_58;
                }
                CFDictionaryRef v54 = CGCreatePayloadForToneMapping(0, 0, v46, v47, v48, v49, v50, v51);
                if (!v54)
                {
LABEL_57:
                  CGContextDrawImageWithOptions((uint64_t)c, image, 0, x, y, width, height);
LABEL_58:
                  if (v32)
                  {
                    if (*((_DWORD *)c + 4) == 1129601108) {
                      *(void *)(*((void *)c + 14) + 72) = v82;
                    }
                    else {
                      handle_invalid_context((char)"CGContextSetInterpolationQualityRange", (uint64_t)c, v58, v59, v60, v61, v62, v63);
                    }
                    CGContextSetInterpolationQuality(c, InterpolationQuality);
                  }
                  return;
                }
                CFDictionaryRef v55 = v54;
                values = v54;
                keys = @"kCGColorConversionInfoPayload";
                CFDictionaryRef v56 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                int8x8_t v57 = v55;
                goto LABEL_35;
              }
            }
            else
            {
              handle_invalid_context((char)"CGBitmapContextGetColorSpace", (uint64_t)c, v16, v17, v18, v19, v20, v21);
            }
          }
        }
      }
      int v32 = 0;
      InterpolationQualidouble ty = kCGInterpolationDefault;
      uint64_t v82 = 0;
      goto LABEL_20;
    }
    CGContextRef v31 = c;
  }
  else
  {
    CGContextRef v31 = 0;
  }

  handle_invalid_context((char)"CGContextDrawImage", (uint64_t)v31, v3, v4, v5, v6, v7, v8);
}

void *ripc_AcquireRIPImageData(uint64_t a1, CGImage *image, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a7;
  uint64_t v9 = a6;
  CGImageRef v13 = image;
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  if (image)
  {
    int v15 = *((unsigned __int8 *)image + 36);
    if (!a1) {
      goto LABEL_7;
    }
  }
  else
  {
    int v15 = 0;
    if (!a1) {
      goto LABEL_7;
    }
  }
  uint64_t v16 = *(_DWORD **)(*(void *)(a1 + 48) + 32);
  if (v16)
  {
    BOOL v17 = *v16 != 34082816;
    goto LABEL_8;
  }
LABEL_7:
  BOOL v17 = 1;
LABEL_8:
  if (RIPShouldCacheImages_predicate != -1)
  {
    uint64_t v111 = a8;
    dispatch_once(&RIPShouldCacheImages_predicate, &__block_literal_global_13526);
    a8 = v111;
  }
  if (a1) {
    BOOL v18 = RIPShouldCacheImages_should_cache == 0;
  }
  else {
    BOOL v18 = 1;
  }
  BOOL v21 = !v18 && v15 != 1 && v17 && a4 * a3 != -1;
  uint64_t v22 = (unsigned int *)v9;
  if (a1)
  {
    uint64_t v22 = (unsigned int *)v9;
    if (!v9) {
      uint64_t v22 = *(unsigned int **)(*(void *)(a1 + 48) + 32);
    }
  }
  if (!v22) {
    goto LABEL_33;
  }
  unint64_t v23 = *v22;
  if (v23 == 134886228)
  {
    unsigned int v24 = 5;
    goto LABEL_34;
  }
  uint64_t v25 = (v23 >> 16) & 0x3F;
  if (v25 != 32)
  {
    if (v25 == 16)
    {
      if (v23) {
        unsigned int v24 = 5;
      }
      else {
        unsigned int v24 = 2;
      }
      goto LABEL_34;
    }
LABEL_33:
    unsigned int v24 = 1;
    goto LABEL_34;
  }
  if ((v23 & 1) == 0) {
    _CGHandleAssert("component_type_from_depth", 115, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPImage.c", "", "Unimplemented", a6, a7, a8, v112);
  }
  unsigned int v24 = 4;
LABEL_34:
  if (!v21)
  {
    if (a1)
    {
      uint64_t v36 = *(void *)(a1 + 120);
      if (!*(void *)(a1 + 88))
      {
        uint64_t v37 = *(void *)a1;
        if (!*(void *)a1)
        {
LABEL_65:
          uint64_t v55 = CGSImageDataLock(v13, a3, a4, a5, v8, a8, v36, (uint64_t)v22, v37, v24, 1);
          if (!v55) {
            return 0;
          }
          uint64_t v56 = v55;
          double v52 = malloc_type_calloc(1uLL, 0xF8uLL, 0x10E00402B2D0641uLL);
          if (v52)
          {
            long long v125 = 0u;
            long long v123 = 0u;
            long long v124 = 0u;
            long long v121 = 0u;
            long long v122 = 0u;
            long long v120 = 0u;
            memset(key, 0, sizeof(key));
            initialize_skipping_conditional_var((uint64_t)key, a1, (uint64_t)v13, v56, v57, v58, v59, v60);
            uint64_t v133 = 0;
            long long v130 = xmmword_185210730;
            long long v131 = unk_185210740;
            long long v132 = xmmword_185210750;
            long long v126 = CGConditionalVarInitializer;
            long long v127 = unk_185210700;
            long long v128 = xmmword_185210710;
            long long v129 = unk_185210720;
            CGConditionalVarPost((uint64_t)&v126, v61, v62, v63, v64, v65, v66, v67);
            long long v68 = v121;
            long long v70 = key[0];
            long long v69 = key[1];
            *((_OWORD *)v52 + 2) = v120;
            *((_OWORD *)v52 + 3) = v68;
            *(_OWORD *)double v52 = v70;
            *((_OWORD *)v52 + 1) = v69;
            long long v71 = v123;
            long long v72 = v125;
            long long v73 = v122;
            *((_OWORD *)v52 + 6) = v124;
            *((_OWORD *)v52 + 7) = v72;
            *((_OWORD *)v52 + 4) = v73;
            *((_OWORD *)v52 + 5) = v71;
            long long v74 = v129;
            long long v76 = v126;
            long long v75 = v127;
            *((_OWORD *)v52 + 10) = v128;
            *((_OWORD *)v52 + 11) = v74;
            *((_OWORD *)v52 + 8) = v76;
            *((_OWORD *)v52 + 9) = v75;
            long long v78 = v131;
            long long v77 = v132;
            long long v79 = v130;
            *((void *)v52 + 30) = v133;
            *((_OWORD *)v52 + 13) = v78;
            *((_OWORD *)v52 + 14) = v77;
            *((_OWORD *)v52 + 12) = v79;
          }
          return v52;
        }
        uint64_t v38 = *(uint64_t (**)(void))(v37 + 248);
        if (v38)
        {
          *(void *)uint64_t v114 = v13;
          uint64_t v39 = a5;
          unint64_t v40 = a3;
          unint64_t v41 = a4;
          unsigned int v42 = v24;
          uint64_t v43 = v8;
          uint64_t v44 = a8;
          uint64_t v37 = v38();
          a8 = v44;
          uint64_t v8 = v43;
          unsigned int v24 = v42;
          a4 = v41;
          a3 = v40;
          a5 = v39;
          CGImageRef v13 = *(CGImageRef *)v114;
          goto LABEL_65;
        }
      }
    }
    else
    {
      uint64_t v36 = 0;
    }
    uint64_t v37 = 0;
    goto LABEL_65;
  }
  if (a5 && *(unsigned int *)(a5 + 8) >= a3 && *(unsigned int *)(a5 + 12) >= a4) {
    a5 = 0;
  }
  value_out = 0;
  long long v134 = 0uLL;
  int v135 = 0;
  if (a1)
  {
    long long v134 = *(_OWORD *)(a1 + 132);
    int v135 = *(_DWORD *)(a1 + 148);
  }
  if (v13)
  {
    unsigned int v26 = *((_DWORD *)v13 + 6);
    Properdouble ty = (const void *)*((void *)v13 + 28);
    if (Property)
    {
      uint64_t v28 = v9;
      uint64_t v29 = v13;
      uint64_t v30 = a5;
      unint64_t v31 = a3;
      unint64_t v32 = a4;
      unsigned int v33 = v24;
      uint64_t v34 = v8;
      int v35 = a8;
      Properdouble ty = CGPropertiesGetProperty((uint64_t)Property, @"kCGColorConversionInfoOptions");
      LODWORD(a8) = v35;
      uint64_t v8 = v34;
      unsigned int v24 = v33;
      a4 = v32;
      a3 = v31;
      a5 = v30;
      CGImageRef v13 = v29;
      uint64_t v9 = v28;
    }
  }
  else
  {
    unsigned int v26 = 0;
    Properdouble ty = 0;
  }
  *(void *)&key[0] = __PAIR64__(v8, v26);
  unsigned int v115 = a8;
  DWORD2(key[0]) = a8;
  *(_OWORD *)((char *)key + 12) = v134;
  *((void *)&v120 + 1) = a3;
  HIDWORD(key[1]) = v135;
  *(void *)&long long v120 = v24;
  *(void *)&long long v121 = a4;
  *((void *)&v121 + 1) = v9;
  *(void *)&long long v122 = Property;
  cache_lock();
  if (get_cache_predicate != -1) {
    dispatch_once(&get_cache_predicate, &__block_literal_global_1505);
  }
  if (!cache_get_and_retain(*(cache_t **)(get_cache_image_cache + 64), key, &value_out))
  {
    cache_unlock();
    if (!value_out) {
      _CGHandleAssert("RIPImageCacheGetRetained", 238, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPImageCache.c", "data != NULL", "data is NULL", v49, v50, v51, v112);
    }
    CGConditionalVarWait((uint64_t)value_out + 128, v45, v46, v47, v48, v49, v50, v51);
    double v52 = value_out;
    if (!*((_DWORD *)value_out + 10) && !*((_DWORD *)value_out + 11)) {
      goto LABEL_74;
    }
    uint64_t v53 = *((void *)value_out + 13);
    if (v53 && *(unsigned char *)(v53 + 8))
    {
      int nonpurgeable = malloc_make_nonpurgeable(*(void **)(v53 + 16));
      double v52 = value_out;
      if (nonpurgeable) {
        goto LABEL_74;
      }
      if (!value_out)
      {
LABEL_75:
        cache_lock();
        goto LABEL_76;
      }
    }
    if (*((_DWORD *)v52 + 14) == *((_DWORD *)v52 + 10))
    {
      if (*((_DWORD *)v52 + 15) == *((_DWORD *)v52 + 11)) {
        return v52;
      }
LABEL_72:
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      if (CGSBoundsIntersection((int *)v52 + 12, (int *)a5, &v116) && v117 == *(void *)(a5 + 8)) {
        return v52;
      }
      goto LABEL_74;
    }
    if (a5 || *((_DWORD *)v52 + 15) == *((_DWORD *)v52 + 11)) {
      goto LABEL_72;
    }
LABEL_74:
    release_and_remove(key, v52);
    value_out = 0;
    goto LABEL_75;
  }
LABEL_76:
  double v52 = value_out;
  if (!value_out)
  {
    uint64_t v80 = malloc_type_calloc(1uLL, 0xF8uLL, 0x10E00402B2D0641uLL);
    value_out = v80;
    if (v80)
    {
      CGConditionalVarInit((uint64_t)v80 + 128, v81, v82, v83, v84, v85, v86, v87);
      if (get_cache_predicate != -1) {
        dispatch_once(&get_cache_predicate, &__block_literal_global_1505);
      }
      cache_set_and_retain(*(cache_t **)(get_cache_image_cache + 64), key, value_out, a4 * a3);
    }
    cache_unlock();
    double v52 = value_out;
    if (value_out)
    {
      if (a1)
      {
        uint64_t v88 = *(void *)(a1 + 120);
        uint64_t v89 = v115;
        if (!v9)
        {
          if (v88) {
            uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 32);
          }
          else {
            uint64_t v9 = 0;
          }
        }
        if (*(void *)(a1 + 88)) {
          goto LABEL_90;
        }
        uint64_t v90 = *(void *)a1;
        if (!*(void *)a1) {
          goto LABEL_91;
        }
        uint64_t v110 = *(uint64_t (**)(void))(v90 + 248);
        if (!v110)
        {
LABEL_90:
          uint64_t v90 = 0;
          goto LABEL_91;
        }
        uint64_t v113 = *(void *)(a1 + 120);
        uint64_t v90 = v110();
        uint64_t v88 = v113;
      }
      else
      {
        uint64_t v88 = 0;
        uint64_t v90 = 0;
      }
      uint64_t v89 = v115;
LABEL_91:
      uint64_t v91 = CGSImageDataLock(v13, a3, a4, a5, v8, v89, v88, v9, v90, v24, 0);
      if (v91)
      {
        initialize_skipping_conditional_var((uint64_t)v52, a1, (uint64_t)v13, v91, v95, v96, v97, v98);
        uint64_t v106 = value_out;
        if (!value_out
          || (v107 = *((void *)value_out + 15), (uint64_t v108 = *(void *)(v107 + 72)) == 0)
          || !*(unsigned char *)(v108 + 8)
          || *(void *)(v107 + 80))
        {
          if (get_cache_predicate != -1) {
            dispatch_once(&get_cache_predicate, &__block_literal_global_1505);
          }
          cache_remove(*(cache_t **)(get_cache_image_cache + 64), key);
          uint64_t v106 = value_out;
        }
        CGConditionalVarPost((uint64_t)v106 + 128, v99, v100, v101, v102, v103, v104, v105);
        return value_out;
      }
      CGConditionalVarPost((uint64_t)value_out + 128, v92, v93, v94, v95, v96, v97, v98);
      release_and_remove(key, value_out);
      return 0;
    }
  }
  return v52;
}

BOOL CGConditionalVarPost(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CGHandleAssert("CGConditionalVarPost", 61, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Utilities/CGConditionalVar.c", "cvar != NULL", "Conditional variable is NULL", a6, a7, a8, v10);
  }
  if (pthread_mutex_lock((pthread_mutex_t *)a1)) {
    return 0;
  }
  *(unsigned char *)(a1 + 112) = 1;
  return !pthread_cond_broadcast((pthread_cond_t *)(a1 + 64)) && pthread_mutex_unlock((pthread_mutex_t *)a1) == 0;
}

uint64_t CGSImageDataLock(CGImageRef image, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, char a11)
{
  uint64_t v76 = 0;
  memset(v75, 0, sizeof(v75));
  if (!image)
  {
    CGPostError((uint64_t)"%s: Bad image source", a2, a3, a4, a5, a6, a7, a8, (char)"CGSImageDataLock");
    return 0;
  }
  uint64_t v12 = (void *)a7;
  unsigned int v13 = a6;
  unsigned int v14 = a5;
  if (a8 && !*(void *)(a8 + 40))
  {
    CGPostError((uint64_t)"%s: Bad image depth", a2, a3, a4, a5, a6, a7, a8, (char)"CGSImageDataLock");
    return 0;
  }
  memset(__src, 0, sizeof(__src));
  CGBitmapPixelInfoInitializeWithImage(__src, __src, image);
  uint64_t v47 = a2;
  if (!a9)
  {
    if (a8)
    {
      unsigned int v24 = *(_DWORD *)a8;
      if ((*(_DWORD *)a8 & 0xFFFFFFEF) == 0x4053344) {
        int v22 = 0x10000;
      }
      else {
        int v22 = (*(_DWORD *)a8 == 134886228) << 18;
      }
      int v25 = (v24 >> 2) & 3;
      switch(v25)
      {
        case 0:
          if ((v24 & 0xF00) != 0) {
            unsigned int v23 = 0;
          }
          else {
            unsigned int v23 = 7;
          }
          goto LABEL_33;
        case 1:
          unsigned int v23 = 8;
          goto LABEL_33;
        case 2:
          int v26 = v24 >> 6;
          if (v26 == 1) {
            unsigned int v23 = 2;
          }
          else {
            unsigned int v23 = v26 == 2;
          }
          goto LABEL_33;
      }
    }
    else
    {
      int v22 = 0;
    }
    unsigned int v23 = 0;
    goto LABEL_33;
  }
  int v22 = *(_DWORD *)(a9 + 40) & 0xF0000;
  unsigned int v23 = *(_DWORD *)(a9 + 40) & 0x1F;
  if (CGImageGetColorSpace(image) && v23 <= 6 && ((1 << v23) & 0x61) != 0 && (*((unsigned char *)image + 39) & 0xE) != 0)
  {
    if (v23 == 6)
    {
LABEL_12:
      unsigned int v23 = 2;
      goto LABEL_33;
    }
    if (v23 != 5)
    {
      if (v23) {
        goto LABEL_33;
      }
      goto LABEL_12;
    }
    unsigned int v23 = 1;
  }
LABEL_33:
  int v49 = a10;
  if ((*((unsigned char *)image + 39) & 8) != 0)
  {
    if (v23 == 7 || !v23)
    {
      if (a8 && *(_DWORD *)a8 == 134886228) {
        unsigned int v23 = 1;
      }
      else {
        unsigned int v23 = 3;
      }
    }
  }
  else if (v23 == 7)
  {
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    if (CGColorSpaceGetType(ColorSpace) - 7 >= 3) {
      uint64_t v12 = 0;
    }
  }
  uint64_t v48 = (_DWORD *)a8;
  if (LODWORD(__src[2]) == 0x40000 && v22 == 0x40000)
  {
    unsigned int v29 = v13;
    if ((*((unsigned char *)image + 39) & 8) == 0)
    {
      int v49 = 0;
      int v30 = 0x2000;
      int v31 = 0x40000;
      uint64_t v32 = 10;
      goto LABEL_55;
    }
LABEL_54:
    int v31 = 0;
    int v30 = 4096;
    unsigned int v23 = 1;
    uint64_t v32 = 16;
    goto LABEL_55;
  }
  if (v22 == 0x40000)
  {
    unsigned int v29 = v13;
    goto LABEL_54;
  }
  uint64_t v32 = qword_185211798[a10];
  if (a9)
  {
    int v33 = *(_DWORD *)(a9 + 40);
    unsigned int v29 = v13;
    if ((v33 & 0xF0000) == 0x10000)
    {
      int v31 = 0;
      int v30 = 0x4000;
    }
    else
    {
      int v31 = 0;
      if ((v33 & 0xF0000) == 0x40000) {
        int v30 = 4096;
      }
      else {
        int v30 = *(_DWORD *)(a9 + 40) & 0x7000;
      }
    }
  }
  else if (v48)
  {
    if (v32 == 8)
    {
      unsigned int v29 = v13;
      int v31 = 0;
      if ((*v48 & 0xFFFFFFEF) == 0x4053344) {
        int v30 = 0x4000;
      }
      else {
        int v30 = ((*v48 & 0x30) == 16) << 13;
      }
      uint64_t v32 = 8;
    }
    else if (v32 == 16)
    {
      unsigned int v29 = v13;
      int v31 = 0;
      int v30 = ((*v48 & 0x30) == 32) << 12;
    }
    else
    {
      unsigned int v29 = v13;
      int v31 = 0;
      if (v32 == 32) {
        int v30 = ((*v48 & 0x30) == 32) << 13;
      }
      else {
        int v30 = 0;
      }
    }
  }
  else
  {
    unsigned int v29 = v13;
    int v31 = 0;
    int v30 = dword_185211780[a10];
  }
LABEL_55:
  if (v12)
  {
    Cache = CGColorTransformGetCache(v12);
    unsigned int v35 = v23;
    if (Cache && (uint64_t v36 = Cache[2]) != 0) {
      uint64_t v37 = *(void *)(*(void *)(v36 + 24) + 48);
    }
    else {
      uint64_t v37 = 0;
    }
  }
  else
  {
    unsigned int v35 = v23;
    uint64_t v37 = 1;
  }
  if ((unint64_t)(v32 - 33) <= 0xFFFFFFFFFFFFFFDFLL) {
    _CGHandleAssert("CGBitmapPixelInfoInitialize", 56, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGBitmapPixelInfo.c", "bits_per_component > 0 && bits_per_component <= 32", "bpc: %zu", v19, v20, v21, v32);
  }
  uint64_t v46 = a4;
  int v51 = v49;
  int v52 = 0;
  uint64_t v53 = v32;
  uint64_t v54 = v37;
  uint64_t v38 = v32;
  unsigned int v39 = v35;
  unsigned int v55 = v35;
  int v56 = v30;
  int v57 = v31;
  long long v72 = 0u;
  memset(v73, 0, sizeof(v73));
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  memcpy(__dst, __src, sizeof(__dst));
  BOOL v40 = data_conversion_required(v12, (uint64_t *)image, &v51, __dst);
  unint64_t v41 = v12;
  char v42 = v40;
  int v51 = v49;
  int v52 = 0;
  uint64_t v53 = v38;
  uint64_t v54 = v37;
  unsigned int v55 = v39;
  int v56 = v30;
  int v57 = v31;
  long long v72 = 0u;
  memset(v73, 0, sizeof(v73));
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  uint64_t v43 = (uint64_t)v41;
  uint64_t result = img_image((uint64_t)v75, (uint64_t)v48, v41, v40, &v51, (uint64_t)image, v29);
  if (result)
  {
    if (a9) {
      unsigned int v45 = *(_DWORD *)(a9 + 96);
    }
    else {
      unsigned int v45 = 3;
    }
    return img_data_lock((uint64_t)"CGSImageDataLock", v44, (uint64_t)v75, v47, a3, v46, v14, v29, v43, v42, (uint64_t)v48, v49, a11, v45);
  }
  return result;
}

uint64_t img_image(uint64_t a1, uint64_t a2, void *a3, int a4, _DWORD *a5, uint64_t a6, unsigned int a7)
{
  unint64_t Size = CGImageGetSize((void *)a6);
  if (Size - 0x4000000 < 0xFFFFFFFFFC000001 || v15 == 0 || v15 >> 26 != 0) {
    return 0;
  }
  *(void *)a1 = Size;
  *(void *)(a1 + 8) = v15;
  *(void *)(a1 + 48) = Size;
  *(void *)(a1 + 56) = v15;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)a6);
  int Type = CGColorSpaceGetType(ColorSpace);
  switch(Type)
  {
    case 5:
      goto LABEL_13;
    case 9:
LABEL_14:
      CGPostError((uint64_t)"%s: Invalid image parameters", v20, v21, v22, v23, v24, v25, v26, (char)"img_image");
      return 0;
    case 7:
LABEL_13:
      if (CGImageGetAlphaInfo((CGImageRef)a6) == kCGImageAlphaPremultipliedFirst
        || CGImageGetAlphaInfo((CGImageRef)a6) == kCGImageAlphaPremultipliedLast)
      {
        goto LABEL_14;
      }
      break;
  }
  if (a3) {
    int v28 = a4;
  }
  else {
    int v28 = 0;
  }
  if (v28 != 1 || a6 && (*(unsigned char *)(a6 + 39) & 2) != 0)
  {
    int BitmapInfo = CGImageGetBitmapInfo((CGImageRef)a6);
    if ((BitmapInfo & 0x7000) != 0) {
      goto LABEL_25;
    }
    CGColorSpaceRef v52 = CGImageGetColorSpace((CGImageRef)a6);
    if (!v52) {
      goto LABEL_25;
    }
    int v53 = *(_DWORD *)(*((void *)v52 + 3) + 28);
    if (v53 != 1)
    {
      if (v53 || !a6) {
        goto LABEL_25;
      }
      uint64_t v54 = *(void *)(a6 + 56);
      if (v54 != 16)
      {
        if (v54 != 32) {
          goto LABEL_25;
        }
LABEL_90:
        BitmapInfo |= 0x4000u;
        goto LABEL_25;
      }
LABEL_134:
      BitmapInfo |= 0x3000u;
      goto LABEL_25;
    }
    if (a6)
    {
      uint64_t v78 = *(void *)(a6 + 56);
      if (v78 == 16) {
        goto LABEL_134;
      }
      if (v78 == 32) {
        goto LABEL_90;
      }
    }
    else
    {
      uint64_t v78 = 0;
    }
    if (v78 == 8 && (BitmapInfo & 0x1F) != 0) {
      BitmapInfo |= 0x4000u;
    }
LABEL_25:
    if ((BitmapInfo & 0x1Fu) - 1 < 4) {
      int v31 = 1;
    }
    else {
      int v31 = v28;
    }
    if (v31) {
      int v30 = BitmapInfo & 0x1F;
    }
    else {
      int v30 = 0;
    }
    if (!v28) {
      goto LABEL_36;
    }
    goto LABEL_32;
  }
  memcpy(__dst, a5, 0x130uLL);
  int BitmapInfo = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__dst);
  int v30 = BitmapInfo & 0x1F;
LABEL_32:
  if (!a6 || (*(unsigned char *)(a6 + 39) & 2) == 0)
  {
    Cache = CGColorTransformGetCache(a3);
    if (Cache) {
      Cache = (void *)Cache[2];
    }
    goto LABEL_37;
  }
LABEL_36:
  Cache = CGImageGetColorSpace((CGImageRef)a6);
LABEL_37:
  if (Cache) {
    int v40 = v30;
  }
  else {
    int v40 = 0;
  }
  *(void *)(a1 + 16) = Cache;
  *(_DWORD *)(a1 + 24) = v40;
  if (a6)
  {
    uint64_t v41 = *(void *)(a6 + 72);
    if (v28)
    {
      if ((*(unsigned char *)(a6 + 39) & 2) != 0)
      {
        *(_OWORD *)((char *)&__dst[17] + 4) = 0u;
        __dst[18] = 0u;
        vImagePixelCount v55 = *(void *)(a6 + 40);
        int v56 = *(CGDataProvider **)(a6 + 48);
        *(void *)&__dst[0] = 1;
        *(_OWORD *)((char *)__dst + 8) = xmmword_1850CDCE0;
        *((void *)&__dst[1] + 1) = 0;
        memset(&__dst[2], 0, 244);
        int v57 = (void *)CGDataProviderCreateForDestinationWithImage(0, __dst, v55, v56, (void *)a6, a7, 1);
        *(void *)(a1 + 136) = v57;
        *(unsigned char *)(a1 + 32) = 1;
        if (v57)
        {
          long long v65 = (uint64_t (*)(void))v57[20];
          if (!v65) {
            goto LABEL_70;
          }
          uint64_t v66 = v65(v57[3]);
          int v57 = *(void **)(a1 + 136);
          if (!v57) {
            goto LABEL_121;
          }
          if (!v66) {
LABEL_70:
          }
            uint64_t v66 = v41;
          if (v57[12] || v57[14] || v57[10]) {
            int v67 = 4;
          }
          else {
            int v67 = 3;
          }
          *(_DWORD *)(a1 + 28) = v67;
          *(void *)(a1 + 128) = 0;
          uint64_t v68 = 8;
          uint64_t v69 = 8;
          goto LABEL_153;
        }
LABEL_121:
        CGPostError((uint64_t)"%s: Bad image source", v58, v59, v60, v61, v62, v63, v64, (char)"img_image");
        return 0;
      }
      uint64_t v135 = *(void *)(a6 + 72);
      if (*(void *)(a6 + 176))
      {
        unsigned int v42 = a5[6] - 1;
        int v130 = BitmapInfo;
        if (v42 > 8) {
          uint64_t v132 = 0;
        }
        else {
          uint64_t v132 = qword_185211998[v42];
        }
        uint64_t v79 = *((void *)a5 + 2);
        uint64_t BitsPerComponent = CGPixelComponentGetBitsPerComponent(*a5, v33, v34, v35, v36, v37, v38, v39);
        vImagePixelCount v81 = *(void *)a1;
        uint64_t v82 = *(CGDataProvider **)(a1 + 8);
        memcpy(__dst, a5, 0x130uLL);
        uint64_t v83 = CGDataProviderCreateWithSoftMaskAndMatte(a3, __dst, v81, v82, (CGImage *)a6, a7);
        *(void *)(a1 + 136) = v83;
        *(unsigned char *)(a1 + 32) = 1;
        if (v83)
        {
          uint64_t v84 = *(uint64_t (**)(void))(v83 + 160);
          if (!v84) {
            goto LABEL_96;
          }
          uint64_t v85 = v84(*(void *)(v83 + 24));
          if (*(void *)(a1 + 136))
          {
            uint64_t v66 = v85;
            if (v85)
            {
LABEL_97:
              uint64_t v86 = CGColorTransformGetCache(a3);
              if (v86) {
                uint64_t v87 = v86[2];
              }
              else {
                uint64_t v87 = 0;
              }
              uint64_t v68 = BitsPerComponent;
              *(void *)(a1 + 16) = v87;
              int v108 = a5[6];
              if (v108 == 9)
              {
                int v108 = 3;
                int v109 = v130;
              }
              else
              {
                int v109 = v130;
                if (v108 == 8) {
                  int v108 = 1;
                }
              }
              uint64_t v69 = BitsPerComponent * (v132 + v79);
              *(_DWORD *)(a1 + 24) = v108;
              uint64_t v110 = *(void **)(a1 + 136);
              if (v110[12] || v110[14] || v110[10]) {
                int v111 = 4;
              }
              else {
                int v111 = 3;
              }
              *(_DWORD *)(a1 + 28) = v111;
              *(void *)(a1 + 128) = 0;
              unsigned int v91 = v109 & 0xFFF080E0;
LABEL_152:
              memcpy(__dst, a5, 0x130uLL);
              int BitmapInfo = CGBitmapPixelInfoGetCGImageBitmapInfo((uint64_t)__dst) | v91;
LABEL_153:
              uint64_t v97 = 0;
              *(void *)(a1 + 120) = 0;
              *(void *)(a1 + 144) = v66;
              *(void *)(a1 + 40) = a6;
              goto LABEL_181;
            }
LABEL_96:
            uint64_t v66 = v135;
            goto LABEL_97;
          }
        }
        goto LABEL_121;
      }
LABEL_47:
      unsigned int v44 = a5[6] - 1;
      if (v44 > 8) {
        uint64_t v134 = 0;
      }
      else {
        uint64_t v134 = qword_185211998[v44];
      }
      uint64_t v131 = *((void *)a5 + 2);
      uint64_t v70 = CGPixelComponentGetBitsPerComponent(*a5, v33, v34, v35, v36, v37, v38, v39);
      if (a6)
      {
        vImagePixelCount v71 = *(void *)(a6 + 40);
        long long v72 = *(CGDataProvider **)(a6 + 48);
      }
      else
      {
        vImagePixelCount v71 = 0;
        long long v72 = 0;
      }
      memcpy(__dst, a5, 0x130uLL);
      uint64_t v73 = CGDataProviderCreateForDestinationWithImage(a3, __dst, v71, v72, (void *)a6, a7, 1);
      *(void *)(a1 + 136) = v73;
      *(unsigned char *)(a1 + 32) = 1;
      if (!v73) {
        goto LABEL_121;
      }
      uint64_t v68 = v70;
      long long v74 = *(uint64_t (**)(void))(v73 + 160);
      if (!v74) {
        goto LABEL_84;
      }
      uint64_t v75 = v74(*(void *)(v73 + 24));
      if (!*(void *)(a1 + 136)) {
        goto LABEL_121;
      }
      uint64_t v66 = v75;
      if (!v75) {
LABEL_84:
      }
        uint64_t v66 = v135;
      uint64_t v76 = CGColorTransformGetCache(a3);
      if (v76) {
        uint64_t v77 = v76[2];
      }
      else {
        uint64_t v77 = 0;
      }
      *(void *)(a1 + 16) = v77;
      int v88 = a5[6];
      if (v88 == 9)
      {
        int v88 = 3;
      }
      else if (v88 == 8)
      {
        int v88 = 1;
      }
      uint64_t v69 = v70 * (v134 + v131);
      *(_DWORD *)(a1 + 24) = v88;
      uint64_t v89 = *(void **)(a1 + 136);
      if (v89[12] || v89[14] || v89[10]) {
        int v90 = 4;
      }
      else {
        int v90 = 3;
      }
      *(_DWORD *)(a1 + 28) = v90;
      *(void *)(a1 + 128) = 0;
      unsigned int v91 = BitmapInfo & 0xFFF080E0;
      goto LABEL_152;
    }
    uint64_t v135 = *(void *)(a6 + 72);
    uint64_t v43 = *(void *)(a6 + 56);
    uint64_t v133 = *(void *)(a6 + 64);
  }
  else
  {
    uint64_t v133 = 0;
    uint64_t v135 = 0;
    uint64_t v43 = 0;
    if (v28) {
      goto LABEL_47;
    }
  }
  CFTypeID v45 = CFGetTypeID((CFTypeRef)a6);
  int v46 = BitmapInfo;
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
  }
  if (v45 != CGImageGetTypeID_image_type_id) {
    goto LABEL_110;
  }
  uint64_t v47 = *(void *)(a6 + 208);
  if (!v47) {
    goto LABEL_110;
  }
  unint64_t v48 = *(void *)(a6 + 40);
  unint64_t v49 = *(void *)(a6 + 48);
  if (!is_mul_ok(v48, v49) || v48 * v49 > 0x9C4 || *(void *)(a6 + 152) | *(void *)(a6 + 240))
  {
    *(void *)(a1 + 136) = v47;
LABEL_58:
    uint64_t v50 = -1;
    int v51 = 5;
    goto LABEL_115;
  }
  if (!CGImageGetDataProviderInternal((char *)a6, 1))
  {
    uint64_t v115 = *(void *)(a6 + 208);
    *(void *)(a1 + 136) = v115;
    uint64_t v92 = (CGDataProviderRef *)(a1 + 136);
    if (v115) {
      goto LABEL_58;
    }
  }
  else
  {
LABEL_110:
    *(void *)(a1 + 136) = 0;
    uint64_t v92 = (CGDataProviderRef *)(a1 + 136);
  }
  DataProviderInternal = CGImageGetDataProviderInternal((char *)a6, 0);
  CGDataProviderRef v94 = CGDataProviderRetain((CGDataProviderRef)DataProviderInternal);
  *uint64_t v92 = v94;
  if (!v94) {
    goto LABEL_121;
  }
  uint64_t v50 = 0;
  if (*((void *)v94 + 4) == -1) {
    int v51 = 3;
  }
  else {
    int v51 = 4;
  }
LABEL_115:
  *(_DWORD *)(a1 + 28) = v51;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = v50;
  *(void *)(a1 + 144) = v135;
  *(void *)(a1 + 40) = a6;
  uint64_t v95 = *(void **)(a1 + 16);
  Decode = CGImageGetDecode((CGImageRef)a6);
  uint64_t v97 = Decode;
  int BitmapInfo = v46;
  if (!Decode) {
    goto LABEL_179;
  }
  if (v40 == 4 || v40 == 2)
  {
    if (*Decode == 0.0 && Decode[1] == 1.0)
    {
      uint64_t v98 = 1;
      goto LABEL_123;
    }
LABEL_179:
    uint64_t v69 = v133;
    goto LABEL_180;
  }
  uint64_t v98 = 0;
LABEL_123:
  if (v95)
  {
    int v99 = BitmapInfo;
    uint64_t v100 = *(void *)(v95[3] + 48);
    switch(CGColorSpaceGetType(v95))
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 8u:
        if (!v100) {
          goto LABEL_172;
        }
        uint64_t v105 = v100 + v98;
        uint64_t v106 = (double *)&v97[2 * v98 + 1];
        uint64_t v69 = v133;
        while (*(v106 - 1) == 0.0 && *v106 == 1.0)
        {
          v106 += 2;
          if (!--v100) {
            goto LABEL_160;
          }
        }
        goto LABEL_161;
      case 5u:
        memset(__dst, 0, 96);
        CGColorSpaceGetLabData((uint64_t)v95, v62, v63, v64, __dst);
        if (v97[2 * v98] != 0.0) {
          goto LABEL_178;
        }
        if (*(const CGFloat *)((char *)v97 + ((16 * v98) | 8)) != 100.0) {
          goto LABEL_178;
        }
        uint64_t v116 = &v97[2 * v98];
        if (v116[2] != *(double *)&__dst[3]
          || v116[3] != *((double *)&__dst[3] + 1)
          || v97[2 * v98 + 4] != *(double *)&__dst[4]
          || *(const CGFloat *)((char *)v97 + ((16 * v98) | 0x28)) != *((double *)&__dst[4] + 1))
        {
          goto LABEL_178;
        }
        v98 += 3;
        goto LABEL_172;
      case 6u:
      case 0xAu:
      case 0xBu:
        uint64_t v112 = CGColorSpaceICCGetRange((uint64_t)v95, v101, v102, v103, v104, v62, v63, v64);
        if (!v112) {
          goto LABEL_178;
        }
        if (!v100)
        {
LABEL_172:
          int BitmapInfo = v99;
          uint64_t v69 = v133;
          goto LABEL_173;
        }
        uint64_t v105 = v100 + v98;
        uint64_t v113 = (double *)(v112 + 8);
        uint64_t v114 = (double *)&v97[2 * v98 + 1];
        uint64_t v69 = v133;
        while (*(v114 - 1) == *(v113 - 1) && *v114 == *v113)
        {
          v113 += 2;
          v114 += 2;
          if (!--v100)
          {
LABEL_160:
            uint64_t v98 = v105;
            int BitmapInfo = v99;
            goto LABEL_173;
          }
        }
LABEL_161:
        int BitmapInfo = v99;
        break;
      case 7u:
        if (v97[2 * v98] != 0.0) {
          goto LABEL_178;
        }
        uint64_t v127 = v95[3];
        int BitmapInfo = v99;
        if (*(_DWORD *)(v127 + 28) == 5) {
          unint64_t v128 = *(void *)(*(void *)(v127 + 96) + 8);
        }
        else {
          unint64_t v128 = -1;
        }
        uint64_t v69 = v133;
        if (*(const CGFloat *)((char *)v97 + ((16 * v98) | 8)) != (double)v128) {
          goto LABEL_180;
        }
        ++v98;
        goto LABEL_173;
      default:
LABEL_178:
        int BitmapInfo = v99;
        goto LABEL_179;
    }
    goto LABEL_180;
  }
  if (Decode[2 * v98] != 0.0) {
    goto LABEL_179;
  }
  uint64_t v69 = v133;
  if (*(const CGFloat *)((char *)Decode + ((16 * v98) | 8)) != 1.0)
  {
LABEL_180:
    uint64_t v68 = v43;
    goto LABEL_181;
  }
LABEL_173:
  uint64_t v68 = v43;
  if ((v40 & 0xFFFFFFFD) != 1 || v97[2 * v98] == 0.0 && *(const CGFloat *)((char *)v97 + ((16 * v98) | 8)) == 1.0) {
    uint64_t v97 = 0;
  }
LABEL_181:
  uint64_t v117 = 0;
  *(void *)(a1 + 88) = v97;
  *(void *)(a1 + 64) = v68;
  *(void *)(a1 + 72) = v69;
  *(_DWORD *)(a1 + 80) = BitmapInfo;
  if (!v97 && *(_DWORD *)(a1 + 28) == 5 && v68 == 8 && v69 == 32)
  {
    uint64_t v117 = *(void *)(a1 + 136);
    if (v117)
    {
      if ((*(unsigned char *)(v117 + 36) & 0x1F) != 0)
      {
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        uint64_t v117 = qword_1EB289FE8;
      }
      else
      {
        uint64_t v117 = 0;
      }
    }
  }
  *(void *)(a1 + 96) = v117;
  uint64_t v119 = *(void *)(a1 + 16);
  if (v119)
  {
    if (*(void *)(a1 + 88))
    {
LABEL_196:
      *(void *)(a1 + 112) = 0;
      return a1;
    }
    int v121 = *(_DWORD *)(*(void *)(v119 + 24) + 28);
    if ((v121 - 3) <= 1)
    {
      unsigned int v122 = CGColorSpaceGetType(*(void **)(a1 + 16));
      if (v122 <= 0xB && ((1 << v122) & 0xC40) != 0)
      {
        uint64_t v123 = *(void *)(*(void *)(v119 + 24) + 48);
        switch(v123)
        {
          case 4:
            int v121 = 2;
            break;
          case 3:
            int v121 = 1;
            break;
          case 1:
            int v121 = 0;
            break;
        }
      }
    }
    int v124 = BitmapInfo & 0xF711F;
    if (v68 <= 9)
    {
      if (v68 == 5)
      {
        if (v69 == 16 && v121 == 1)
        {
          switch(v124)
          {
            case 12294:
              goto LABEL_257;
            case 4102:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB289FC0;
              goto LABEL_433;
            case 6:
LABEL_257:
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB289FB8;
              goto LABEL_433;
          }
        }
      }
      else if (v68 == 8)
      {
        switch(v121)
        {
          case 2:
            if (v69 == 32)
            {
              switch(v124)
              {
                case 0x4000:
                  goto LABEL_268;
                case 0x2000:
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  a2 = qword_1EB289FF8;
                  goto LABEL_433;
                case 0:
LABEL_268:
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  a2 = qword_1EB289FF0;
                  goto LABEL_433;
              }
            }
            break;
          case 1:
            switch(v124)
            {
              case 0:
                if (v69 == 32) {
                  goto LABEL_329;
                }
                if (v69 != 24) {
                  goto LABEL_432;
                }
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                a2 = qword_1EB289FC8;
                break;
              case 1:
              case 5:
                if (v69 != 32) {
                  goto LABEL_432;
                }
LABEL_329:
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                a2 = qword_1EB289FD0;
                break;
              case 2:
              case 6:
                if (v69 != 32) {
                  goto LABEL_432;
                }
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                a2 = qword_1EB289FE0;
                break;
              case 3:
              case 4:
                goto LABEL_432;
              default:
                JUMPOUT(0);
            }
            goto LABEL_433;
          case 0:
            if (v69 == 8 && !v124)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB289FB0;
              goto LABEL_433;
            }
            if (v69 == 16 && (BitmapInfo & 0xF711B) == 1)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              if (qword_1EB28A0D0 == a2) {
                goto LABEL_433;
              }
            }
            break;
        }
      }
      goto LABEL_432;
    }
    if (v68 == 10)
    {
      if (v124 == 270336 && v121 == 1)
      {
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        a2 = qword_1EB28A0D8;
        goto LABEL_433;
      }
      goto LABEL_432;
    }
    if (v68 != 16)
    {
      if (v68 == 32)
      {
        if ((BitmapInfo & 0xF711Fu) > 0x2100)
        {
          if ((BitmapInfo & 0xF711Fu) > 0x40FF)
          {
            if (v124 != 16645 && v124 != 16641)
            {
              if (v124 != 16640) {
                goto LABEL_432;
              }
LABEL_305:
              if (v121 == 2)
              {
                if (v69 == 128)
                {
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  a2 = qword_1EB28A070;
                  goto LABEL_433;
                }
                goto LABEL_432;
              }
              if (v121 != 1)
              {
                if (!v121 && v69 == 32)
                {
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  a2 = qword_1EB28A060;
                  goto LABEL_433;
                }
                goto LABEL_432;
              }
              if (v69 != 128)
              {
                if (v69 == 96)
                {
                  if (img_globals_once != -1) {
                    dispatch_once(&img_globals_once, &__block_literal_global_11955);
                  }
                  a2 = qword_1EB28A040;
                  goto LABEL_433;
                }
                goto LABEL_432;
              }
              if (img_globals_once == -1) {
                goto LABEL_304;
              }
              goto LABEL_445;
            }
LABEL_301:
            if (v69 != 128 || v121 != 1) {
              goto LABEL_432;
            }
            if (img_globals_once == -1) {
              goto LABEL_304;
            }
LABEL_445:
            dispatch_once(&img_globals_once, &__block_literal_global_11955);
LABEL_304:
            a2 = qword_1EB28A050;
            goto LABEL_433;
          }
          if (v124 != 8449 && v124 != 8453 || v69 != 128 || v121 != 1) {
            goto LABEL_432;
          }
          if (img_globals_once == -1)
          {
LABEL_291:
            a2 = qword_1EB28A058;
LABEL_433:
            *(void *)(a1 + 112) = a2;
            return a1;
          }
LABEL_446:
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
          goto LABEL_291;
        }
        if ((BitmapInfo & 0xF711Fu) <= 0x104)
        {
          if (v124 == 256) {
            goto LABEL_305;
          }
          if (v124 != 257) {
            goto LABEL_432;
          }
          goto LABEL_301;
        }
        if (v124 == 261) {
          goto LABEL_301;
        }
        if (v124 == 8448)
        {
          if (v121 == 2)
          {
            if (v69 == 128)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB28A078;
              goto LABEL_433;
            }
            goto LABEL_432;
          }
          if (v121 != 1)
          {
            if (!v121 && v69 == 32)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB28A068;
              goto LABEL_433;
            }
            goto LABEL_432;
          }
          if (v69 != 128)
          {
            if (v69 == 96)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB28A048;
              goto LABEL_433;
            }
            goto LABEL_432;
          }
          if (img_globals_once == -1) {
            goto LABEL_291;
          }
          goto LABEL_446;
        }
      }
LABEL_432:
      a2 = 0;
      goto LABEL_433;
    }
    if (v121 != 2)
    {
      if (v121 != 1)
      {
        if (v121) {
          BOOL v125 = 0;
        }
        else {
          BOOL v125 = v69 == 16;
        }
        if (!v125) {
          goto LABEL_432;
        }
        if ((BitmapInfo & 0xF711Fu) > 0x10FF)
        {
          if (v124 == 4352)
          {
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            a2 = qword_1EB28A090;
            goto LABEL_433;
          }
          if (v124 != 12288)
          {
            if (v124 != 12544) {
              goto LABEL_432;
            }
LABEL_430:
            _CGHandleAssert("img_depth", 3279, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v62, v63, v64, v129);
          }
        }
        else if (v124)
        {
          if (v124 == 4096)
          {
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            a2 = qword_1EB28A008;
            goto LABEL_433;
          }
          if (v124 != 256) {
            goto LABEL_432;
          }
          goto LABEL_430;
        }
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        a2 = qword_1EB28A000;
        goto LABEL_433;
      }
      if ((BitmapInfo & 0xF711Fu) <= 0x10FF)
      {
        if ((BitmapInfo & 0xF711Fu) > 0x100)
        {
          if ((BitmapInfo & 0xF711Fu) > 0x1000)
          {
            if (v124 != 4097 && v124 != 4101 || v69 != 64) {
              goto LABEL_432;
            }
LABEL_402:
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            a2 = qword_1EB28A028;
            goto LABEL_433;
          }
          if (v124 == 4096)
          {
            if (v69 != 64)
            {
              if (v69 == 48)
              {
                if (img_globals_once != -1) {
                  dispatch_once(&img_globals_once, &__block_literal_global_11955);
                }
                a2 = qword_1EB28A018;
                goto LABEL_433;
              }
              goto LABEL_432;
            }
            goto LABEL_402;
          }
          if (v124 != 257 && v124 != 261) {
            goto LABEL_432;
          }
LABEL_444:
          _CGHandleAssert("img_depth", 3319, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v62, v63, v64, v129);
        }
        if ((BitmapInfo & 0xF711Fu) <= 4)
        {
          if (v124)
          {
            if (v124 != 1) {
              goto LABEL_432;
            }
LABEL_406:
            if (v69 != 64) {
              goto LABEL_432;
            }
LABEL_407:
            if (img_globals_once != -1) {
              dispatch_once(&img_globals_once, &__block_literal_global_11955);
            }
            a2 = qword_1EB28A020;
            goto LABEL_433;
          }
LABEL_369:
          if (v69 != 64)
          {
            if (v69 == 48)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB28A010;
              goto LABEL_433;
            }
            goto LABEL_432;
          }
          goto LABEL_407;
        }
        if (v124 == 5) {
          goto LABEL_406;
        }
        if (v124 != 256) {
          goto LABEL_432;
        }
LABEL_448:
        _CGHandleAssert("img_depth", 3312, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v62, v63, v64, v129);
      }
      if ((BitmapInfo & 0xF711Fu) < 0x3000)
      {
        if (v124 == 4352)
        {
          if (v69 != 64)
          {
            if (v69 == 48)
            {
              if (img_globals_once != -1) {
                dispatch_once(&img_globals_once, &__block_literal_global_11955);
              }
              a2 = qword_1EB28A0A0;
              goto LABEL_433;
            }
            goto LABEL_432;
          }
        }
        else if (v124 != 4353 && v124 != 4357 || v69 != 64)
        {
          goto LABEL_432;
        }
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        a2 = qword_1EB28A0B0;
        goto LABEL_433;
      }
      if ((BitmapInfo & 0xF711Fu) > 0x3004)
      {
        if ((BitmapInfo & 0xF711Fu) > 0x30FF)
        {
          if (v124 != 12544)
          {
            if (v124 != 12545 && v124 != 12549) {
              goto LABEL_432;
            }
            goto LABEL_444;
          }
          goto LABEL_448;
        }
        int v126 = 12293;
      }
      else
      {
        if (v124 == 12288) {
          goto LABEL_369;
        }
        int v126 = 12289;
      }
      if (v124 != v126) {
        goto LABEL_432;
      }
      goto LABEL_406;
    }
    if (v69 != 64) {
      goto LABEL_432;
    }
    if ((BitmapInfo & 0xF711Fu) > 0x10FF)
    {
      if (v124 == 4352)
      {
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        a2 = qword_1EB28A0C0;
        goto LABEL_433;
      }
      if (v124 != 12288)
      {
        if (v124 != 12544) {
          goto LABEL_432;
        }
LABEL_447:
        _CGHandleAssert("img_depth", 3349, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGSImage.c", "", "Unimplemented", v62, v63, v64, v129);
      }
    }
    else if (v124)
    {
      if (v124 == 4096)
      {
        if (img_globals_once != -1) {
          dispatch_once(&img_globals_once, &__block_literal_global_11955);
        }
        a2 = qword_1EB28A038;
        goto LABEL_433;
      }
      if (v124 != 256) {
        goto LABEL_432;
      }
      goto LABEL_447;
    }
    if (img_globals_once != -1) {
      dispatch_once(&img_globals_once, &__block_literal_global_11955);
    }
    a2 = qword_1EB28A030;
    goto LABEL_433;
  }
  if (v69 != 8) {
    goto LABEL_196;
  }
  if (v68 != 8) {
    goto LABEL_196;
  }
  long long v120 = *(double **)(a1 + 88);
  if (!v120 || *v120 != 1.0 || v120[1] != 0.0) {
    goto LABEL_196;
  }
  if (img_globals_once != -1) {
    dispatch_once(&img_globals_once, &__block_literal_global_11955);
  }
  *(void *)(a1 + 112) = img_globals_globals[0];
  return a1;
}

BOOL CGImageGetHeadroom(CGImage *a1, float *a2)
{
  int v5 = 0;
  float HeadroomInfo = CGImageGetHeadroomInfo(a1, &v5);
  if (a2) {
    *a2 = HeadroomInfo;
  }
  return v5 == 1;
}

float CGImageGetHeadroomInfo(CGImage *a1, _DWORD *a2)
{
  uint64_t v42 = 0;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  if (!ColorSpace) {
    goto LABEL_41;
  }
  int v5 = ColorSpace;
  uint64_t v6 = *((void *)ColorSpace + 3);
  if (*(_DWORD *)(v6 + 28) != 1) {
    goto LABEL_41;
  }
  if (!*(unsigned char *)(v6 + 16) && !*(unsigned char *)(v6 + 17) && !*(unsigned char *)(v6 + 13))
  {
    uint64_t v42 = 0x13F800000;
    if (!a2) {
      return *(float *)&v42;
    }
    goto LABEL_42;
  }
  if (CGColorSpaceContainsFlexGTCInfo((BOOL)ColorSpace))
  {
    LODWORD(v42) = CGColorSpaceGetHeadroomInfo(v5, (int *)&v42 + 1);
    goto LABEL_40;
  }
  uint64_t v7 = *((void *)a1 + 26);
  if (v7)
  {
    ContentHeadroouint64_t m = CGImageProviderGetContentHeadroom(v7);
    if (ContentHeadroom >= 0.0)
    {
      float v9 = ContentHeadroom;
      *(float *)&uint64_t v42 = ContentHeadroom;
      if (ContentHeadroom <= 0.0)
      {
        HIDWORD(v42) = 1;
        uint64_t v25 = *((void *)a1 + 28);
        if (!v25) {
          goto LABEL_41;
        }
        Properdouble ty = (const __CFNumber *)CGPropertiesGetProperty(v25, @"kCGImageUnknownHeadroom");
        if (Property)
        {
          CFNumberRef v27 = Property;
          CFTypeID v28 = CFGetTypeID(Property);
          if (v28 == CFNumberGetTypeID())
          {
            float valuePtr = 0.0;
            CFNumberGetValue(v27, kCFNumberFloatType, &valuePtr);
            if (vabds_f32(valuePtr, v9) > 0.00001) {
              CGPostError((uint64_t)"%s: image and image provider have different unknown origin values: %f, %f", v29, v30, v31, v32, v33, v34, v35, (char)"CGImageGetHeadroomInfo");
            }
          }
        }
      }
      else
      {
        uint64_t v10 = *((void *)a1 + 28);
        if (!v10 || (CFNumberRef v11 = (const __CFNumber *)CGPropertiesGetProperty(v10, @"kCGImageEstimatedHeadroom")) == 0)
        {
          HIDWORD(v42) = 1;
          if (!a2) {
            return *(float *)&v42;
          }
          goto LABEL_42;
        }
        HIDWORD(v42) = 1;
        float valuePtr = 0.0;
        CFNumberGetValue(v11, kCFNumberFloatType, &valuePtr);
        if (vabds_f32(valuePtr, v9) > 0.00001) {
          CGPostError((uint64_t)"%s: image and image provider have different estimated values: %f, %f", v12, v13, v14, v15, v16, v17, v18, (char)"CGImageGetHeadroomInfo");
        }
      }
    }
    goto LABEL_40;
  }
  uint64_t v19 = *((void *)a1 + 28);
  if (!v19) {
    goto LABEL_40;
  }
  uint64_t v20 = CGPropertiesGetProperty(v19, @"kCGImageHeadroom");
  uint64_t v21 = *((void *)a1 + 28);
  if (v21)
  {
    uint64_t v22 = CGPropertiesGetProperty(v21, @"kCGImageEstimatedHeadroom");
    uint64_t v23 = *((void *)a1 + 28);
    if (v23)
    {
      uint64_t v24 = CGPropertiesGetProperty(v23, @"kCGImageUnknownHeadroom");
      goto LABEL_30;
    }
  }
  else
  {
    uint64_t v22 = 0;
  }
  uint64_t v24 = 0;
LABEL_30:
  if (v20)
  {
    CFTypeID v36 = CFGetTypeID(v20);
    if (v36 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 1;
      CFNumberRef v37 = (const __CFNumber *)v20;
LABEL_39:
      CFNumberGetValue(v37, kCFNumberFloatType, &v42);
      goto LABEL_40;
    }
  }
  if (v22)
  {
    CFTypeID v38 = CFGetTypeID(v22);
    if (v38 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 2;
      CFNumberRef v37 = (const __CFNumber *)v22;
      goto LABEL_39;
    }
  }
  if (v24)
  {
    CFTypeID v39 = CFGetTypeID(v24);
    if (v39 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 0;
      CFNumberRef v37 = (const __CFNumber *)v24;
      goto LABEL_39;
    }
  }
LABEL_40:
  if (!HIDWORD(v42))
  {
    if (*(unsigned char *)(v5[3] + 13))
    {
      LODWORD(v42) = 0;
      if (!a2) {
        return *(float *)&v42;
      }
    }
    else
    {
      LODWORD(v42) = CGColorSpaceGetHeadroomInfo(v5, (int *)&v42 + 1);
      if (!a2) {
        return *(float *)&v42;
      }
    }
    goto LABEL_42;
  }
LABEL_41:
  if (a2) {
LABEL_42:
  }
    *a2 = HIDWORD(v42);
  return *(float *)&v42;
}

CGColorSpaceRef CGImageGetColorSpace(CGColorSpaceRef image)
{
  if (image)
  {
    CGColorSpaceRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (CGColorSpaceRef)*((void *)v1 + 18);
    }
    else {
      return 0;
    }
  }
  return image;
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LODWORD(image) = *((_DWORD *)v1 + 8);
    }
    else {
      LODWORD(image) = 0;
    }
  }
  return image;
}

unint64_t CGImageGetSize(void *a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v1 = a1[5];
  Masuint64_t k = CGImageGetMask(a1);
  if (Mask && Mask[5] > v1) {
    return Mask[5];
  }
  return v1;
}

void *CGImageGetMask(void *result)
{
  if (result)
  {
    unint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[22];
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL data_conversion_required(void *a1, uint64_t *image, _DWORD *a3, const void *a4)
{
  if (image && (*((unsigned char *)image + 39) & 8) != 0) {
    return 1;
  }
  if (a3[6] == 7)
  {
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
    if (CGColorSpaceGetType(ColorSpace) - 7 > 2) {
      return 0;
    }
  }
  CGColorSpaceRef v9 = CGImageGetColorSpace((CGImageRef)image);
  if (create_resolved_space_predicate != -1) {
    dispatch_once(&create_resolved_space_predicate, &__block_literal_global_76);
  }
  __dst[0] = MEMORY[0x1E4F143A8];
  __dst[1] = 0x40000000;
  __dst[2] = __CGColorSpaceCreateResolved_block_invoke;
  __dst[3] = &__block_descriptor_tmp_57_23013;
  __dst[4] = create_resolved_space_gray;
  __dst[5] = create_resolved_space_sRGB;
  __dst[6] = create_resolved_space_cmyk;
  ResolvedCGColorSpaceRef ColorSpace = (CGColorSpace *)CGColorSpaceCreateResolvedColorSpace(v9, (uint64_t)__dst);
  if (image && (uint64_t v11 = image[28]) != 0 && CGPropertiesGetProperty(v11, @"kCGColorConversionInfoOptions"))
  {
    BOOL v12 = 1;
  }
  else
  {
    BOOL v12 = 1;
    if (a1 && ResolvedColorSpace && !CGColorTransformGetAttributes(a1))
    {
      Cache = CGColorTransformGetCache(a1);
      if (Cache) {
        Cache = (void *)Cache[2];
      }
      if (CGColorSpaceEqualToColorSpace((uint64_t)Cache, (uint64_t)ResolvedColorSpace))
      {
        memcpy(__dst, a3, sizeof(__dst));
        memcpy(v15, a4, sizeof(v15));
        BOOL v12 = !CGBitmapPixelInfoIsEqualToBitmapPixelInfo((uint64_t)__dst, (uint64_t)v15);
      }
    }
  }
  CGColorSpaceRelease(ResolvedColorSpace);
  return v12;
}

void *CGBitmapPixelInfoInitializeWithImage(void *a1, _OWORD *a2, CGColorSpace *image)
{
  a2[17] = 0u;
  a2[18] = 0u;
  a2[15] = 0u;
  a2[16] = 0u;
  a2[13] = 0u;
  a2[14] = 0u;
  a2[11] = 0u;
  a2[12] = 0u;
  a2[9] = 0u;
  a2[10] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  *(_DWORD *)a2 = CGImageGetPixelComponentType((uint64_t)image);
  if (image) {
    uint64_t v6 = *((void *)image + 7);
  }
  else {
    uint64_t v6 = 0;
  }
  *((void *)a2 + 1) = v6;
  *((void *)a2 + 2) = CGImageGetNumberOfColorComponents(image);
  *((_DWORD *)a2 + 6) = CGImageGetAlphaInfo(image);
  *((_DWORD *)a2 + 7) = CGImageGetByteOrderInfo(image);
  *((_DWORD *)a2 + 8) = CGImageGetPixelFormatInfo(image);
  if (CGImageGetDecode(image))
  {
    uint64_t NumberOfComponents = CGImageGetNumberOfComponents((uint64_t)image);
    if (NumberOfComponents)
    {
      uint64_t v8 = NumberOfComponents;
      unint64_t v9 = 0;
      do
      {
        *(CGFloat *)&a2[v9 / 0x10 + 3] = CGImageGetDecode(image)[v9 / 8];
        *((CGFloat *)&a2[v9 / 0x10 + 3] + 1) = CGImageGetDecode(image)[v9 / 8 + 1];
        v9 += 16;
        --v8;
      }
      while (v8);
    }
    *((void *)a2 + 5) = a2 + 3;
  }

  return memcpy(a1, a2, 0x130uLL);
}

const CGFloat *__cdecl CGImageGetDecode(const CGFloat *image)
{
  if (image)
  {
    unint64_t v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (const CGFloat *)*((void *)v1 + 20);
    }
    else {
      return 0;
    }
  }
  return image;
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LODWORD(image) = *((_DWORD *)v1 + 8) & 0x1F;
    }
    else {
      LODWORD(image) = 0;
    }
  }
  return image;
}

uint64_t CGImageGetPixelComponentType(uint64_t image)
{
  if (image)
  {
    CGImageRef v1 = (CGImage *)image;
    CGImageRef image = 0;
    uint64_t v2 = *((void *)v1 + 7);
    switch(v2)
    {
      case 1:
        CGImageRef image = 7;
        break;
      case 2:
        CGImageRef image = 8;
        break;
      case 3:
      case 5:
      case 6:
      case 7:
        return image;
      case 4:
        CGImageRef image = 9;
        break;
      case 8:
        CGImageRef image = 1;
        break;
      default:
        if (v2 == 16)
        {
          if ((CGImageGetBitmapInfo(v1) & 0x100) != 0) {
            CGImageRef image = 5;
          }
          else {
            CGImageRef image = 2;
          }
        }
        else if (v2 == 32)
        {
          if ((CGImageGetBitmapInfo(v1) & 0x100) != 0) {
            CGImageRef image = 4;
          }
          else {
            CGImageRef image = 3;
          }
        }
        break;
    }
  }
  return image;
}

CGImageByteOrderInfo CGImageGetByteOrderInfo(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LODWORD(image) = *((_DWORD *)v1 + 8) & 0x7000;
    }
    else {
      LODWORD(image) = 0;
    }
  }
  return image;
}

CGImagePixelFormatInfo CGImageGetPixelFormatInfo(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LODWORD(image) = *((_DWORD *)v1 + 8) & 0xF0000;
    }
    else {
      LODWORD(image) = 0;
    }
  }
  return image;
}

CGColorSpaceRef CGImageGetNumberOfColorComponents(CGColorSpaceRef result)
{
  if (result)
  {
    if ((*((unsigned char *)result + 39) & 2) != 0)
    {
      return (CGColorSpaceRef)1;
    }
    else
    {
      uint64_t result = CGImageGetColorSpace(result);
      if (result) {
        return *(CGColorSpaceRef *)(*((void *)result + 3) + 48);
      }
    }
  }
  return result;
}

const char **initialize_skipping_conditional_var(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    long long v11 = *(_OWORD *)(a2 + 132);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 148);
    *(_OWORD *)a1 = v11;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  *(void *)(a1 + 20) = *(void *)(a4 + 88);
  if (a3 && (*(unsigned char *)(a3 + 39) & 2) != 0)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = *(const char ***)(a4 + 8);
    if (!result)
    {
      if (!*(void *)a4) {
        _CGHandleAssert("RIPGetDepthForEncoding", 113, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/RIP/RIPLayerFormat.c", "enc != NULL", "NULL encoding", a6, a7, a8, v15);
      }
      uint64_t result = CGBlt_depth(*(char **)a4);
    }
  }
  *(void *)(a1 + 32) = result;
  *(int32x2_t *)(a1 + 40) = vmovn_s64(*(int64x2_t *)(a4 + 16));
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a4 + 32);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a4 + 48);
  *(void *)(a1 + 72) = *(void *)(a4 + 56);
  *(void *)(a1 + 88) = *(void *)(a4 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a4 + 52);
  *(int8x16_t *)(a1 + 96) = vextq_s8(*(int8x16_t *)(a4 + 72), *(int8x16_t *)(a4 + 72), 8uLL);
  if (a3) {
    int v13 = *(_DWORD *)(a3 + 24);
  }
  else {
    int v13 = 0;
  }
  int v14 = *(_DWORD *)(a4 + 96);
  *(_DWORD *)(a1 + 112) = v13;
  *(_DWORD *)(a1 + 116) = v14;
  *(void *)(a1 + 120) = a4;
  return result;
}

BOOL CGBitmapPixelInfoIsEqualToBitmapPixelInfo(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  if (*(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  unint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a2 + 16)
    || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)
    || *(_DWORD *)(a1 + 28) != *(_DWORD *)(a2 + 28))
  {
    return 0;
  }
  uint64_t v3 = *(double **)(a1 + 40);
  uint64_t v4 = *(double **)(a2 + 40);
  if (!v3)
  {
    if (!v4) {
      return 1;
    }
    uint64_t v3 = (double *)&standard_decode;
  }
  if (!v4) {
    uint64_t v4 = (double *)&standard_decode;
  }
  if (v2)
  {
    double v5 = *v3;
    double v6 = *v4;
    unint64_t v7 = 1;
    while (v5 == v6)
    {
      double v5 = v3[v7];
      double v6 = v4[v7];
      BOOL result = v5 == v6;
      if (v7 < v2)
      {
        ++v7;
        if (v5 == v6) {
          continue;
        }
      }
      return result;
    }
    return 0;
  }
  return 1;
}

CFDataRef CGDataProviderCreateWithCopyOfData(unint64_t a1, unint64_t a2)
{
  CFDataRef result = create_protected_copy(a1, a2);
  if (result)
  {
    CFDataRef v3 = result;
    CGDataProviderRef v4 = CGDataProviderCreateWithCFData(result);
    CFRelease(v3);
    return v4;
  }
  return result;
}

CGDataProviderRef CGDataProviderCreateWithCFData(CGDataProviderRef data)
{
  if (data)
  {
    CFDataRef v1 = data;
    datdouble a = (CGDataProviderRef)CFDataGetBytePtr(data);
    if (data)
    {
      off_t Length = CFDataGetLength(v1);
      CFDataRef v3 = (void *)CFRetain(v1);
      *(void *)&callbacks.versiouint64_t n = 0;
      callbacks.getBytePointer = (CGDataProviderGetBytePointerCallback)getCFDataBytePointer;
      callbacks.releaseBytePointer = 0;
      callbacks.getBytesAtPositiouint64_t n = (CGDataProviderGetBytesAtPositionCallback)cf_get_bytes_at_position;
      callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)releaseCFData;
      return CGDataProviderCreateDirect(v3, Length, &callbacks);
    }
  }
  return data;
}

CGDataProviderRef CGDataProviderCreateDirect(void *info, off_t size, const CGDataProviderDirectCallbacks *callbacks)
{
  if (size <= 0)
  {
    CGPostError((uint64_t)"%s: Invalid CGSize size = %jd", size, (uint64_t)callbacks, v3, v4, v5, v6, v7, (char)"CGDataProviderCreateDirect");
    if (!callbacks) {
      return 0;
    }
  }
  else if (!callbacks)
  {
    return 0;
  }
  CGDataProviderRef result = 0;
  if (size >= 1 && !callbacks->version)
  {
    if (!callbacks->getBytePointer && !callbacks->getBytesAtPosition) {
      return 0;
    }
    CGDataProviderRef result = (CGDataProviderRef)create_provider((uint64_t)info, 0, (uint64_t)callbacks, v3, v4, v5, v6, v7);
    if (result)
    {
      *((void *)result + 4) = size;
      *((_OWORD *)result + 5) = *(_OWORD *)&callbacks->getBytePointer;
      CGDataProviderReleaseInfoCallback releaseInfo = callbacks->releaseInfo;
      *((void *)result + 12) = callbacks->getBytesAtPosition;
      *((void *)result + 9) = releaseInfo;
    }
  }
  return result;
}

uint64_t create_provider(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  uint64_t Instance = CGTypeCreateInstance(CGDataProviderGetTypeID_id, 272, a3, a4, a5, a6, a7, a8);
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = 48879;
    *(_DWORD *)(Instance + 20) = a2;
    *(void *)(Instance + 24) = a1;
    *(void *)(Instance + 32) = -1;
    *(_DWORD *)(Instance + 248) = 0;
    *(void *)(Instance + 252) = 1;
    v13.__sig = 0;
    *(void *)v13.__opaque = 0;
    pthread_mutexattr_init(&v13);
    pthread_mutexattr_settype(&v13, 2);
    pthread_mutex_init((pthread_mutex_t *)(v11 + 184), &v13);
    pthread_mutexattr_destroy(&v13);
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v13.__sig) = 136315138;
    *(uint64_t *)((char *)&v13.__sig + 4) = (uint64_t)"create_provider";
    _os_log_impl(&dword_184BFE000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s failed", (uint8_t *)&v13, 0xCu);
  }
  return v11;
}

CFDataRef create_protected_copy(unint64_t bytes, unint64_t length)
{
  kern_return_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UInt8 *v19;
  CFAllocatorRef v20;
  CFAllocatorContext context;
  uint64_t vars8;

  CFDataRef v2 = 0;
  if (!bytes || !length) {
    return v2;
  }
  uint64_t v5 = *MEMORY[0x1E4F14B00];
  if (*MEMORY[0x1E4F14B00] <= length)
  {
    vm_address_t v7 = -v5 & bytes;
    uint64_t v8 = (void *)(((length + bytes + v5 - 1) & -v5) - v7);
    unint64_t v9 = (char *)mmap(0, (size_t)v8, 3, 4098, 905969664, 0);
    if (v9 == (char *)-1) {
      return 0;
    }
    uint64_t v10 = v9;
    uint64_t v11 = (unsigned int *)MEMORY[0x1E4F14960];
    BOOL v12 = vm_copy(*MEMORY[0x1E4F14960], v7, (vm_size_t)v8, (vm_address_t)v9);
    uint64_t v19 = (UInt8 *)&v10[bytes - v7];
    if (v12)
    {
      CGLog(0, (uint64_t)"%s: vm_copy failed: status %d.", v13, v14, v15, v16, v17, v18, (char)"copy_read_only");
      memcpy(v19, (const void *)bytes, length);
    }
    MEMORY[0x18532BC70](*v11, v19, length, 1, 1);
    if (!v19) {
      return 0;
    }
    if (v19 == (UInt8 *)bytes) {
      goto LABEL_4;
    }
    context.versiouint64_t n = 0;
    memset(&context.retain, 0, 40);
    context.float64x2_t info = v8;
    context.deallocate = (CFAllocatorDeallocateCallBack)vm_allocator_deallocate;
    context.preferredunint64_t Size = 0;
    uint64_t v20 = CFAllocatorCreate(0, &context);
    CFDataRef v2 = CFDataCreateWithBytesNoCopy(0, v19, length, v20);
    CFRelease(v20);
    return v2;
  }
LABEL_4:

  return CFDataCreate(0, (const UInt8 *)bytes, length);
}

void *__CGColorSpaceCreateResolved_block_invoke(void *a1, void *a2)
{
  int Type = CGColorSpaceGetType(a2);
  switch(Type)
  {
    case 2:
      uint64_t v5 = (void *)a1[6];
      if (v5 && *(_DWORD *)(v5[3] + 28) == 2) {
        goto LABEL_13;
      }
      break;
    case 1:
      uint64_t v5 = (void *)a1[5];
      if (v5 && *(_DWORD *)(v5[3] + 28) == 1) {
        goto LABEL_13;
      }
      break;
    case 0:
      uint64_t v5 = (void *)a1[4];
      if (v5)
      {
        if (!*(_DWORD *)(v5[3] + 28)) {
          goto LABEL_13;
        }
      }
      break;
  }
  uint64_t v5 = a2;
  if (a2) {
LABEL_13:
  }
    CFRetain(v5);
  return v5;
}

uint64_t CGImageGetNumberOfComponents(uint64_t image)
{
  if (image)
  {
    CFDataRef v1 = (CGImage *)image;
    if ((*(unsigned char *)(image + 39) & 2) != 0)
    {
      return 1;
    }
    else
    {
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)image);
      if (ColorSpace) {
        uint64_t v3 = *(void *)(*((void *)ColorSpace + 3) + 48);
      }
      else {
        uint64_t v3 = 0;
      }
      if (CGImageGetAlphaInfo(v1)) {
        return v3 + 1;
      }
      else {
        return v3;
      }
    }
  }
  return image;
}

uint64_t provider_for_destination_bytes_per_row_count(uint64_t a1)
{
  return *(void *)(a1 + 664);
}

void set_content_headroom_to_conversion_info(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 80);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
  if (!*(void *)(a1 + 224))
  {
    vm_address_t v7 = (CFTypeRef *)CGPropertiesCreate();
    uint64_t v8 = 0;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 224), (unint64_t *)&v8, (unint64_t)v7, memory_order_relaxed, memory_order_relaxed);
    if (v8) {
      CGPropertiesRelease(v7);
    }
  }
  pthread_mutex_unlock(v6);
  uint64_t v9 = *(void *)(a1 + 224);

  CGPropertiesSetProperty(v9, a2, a3);
}

size_t CGBitmapContextGetHeight(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void *)(*((void *)context + 4) + 16);
  }
  handle_invalid_context((char)"CGBitmapContextGetHeight", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform *t)
{
  float64x2_t v2 = vaddq_f64(*(float64x2_t *)&t->tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&t->c, point.y), *(float64x2_t *)&t->a, point.x));
  double v3 = v2.f64[1];
  result.CGFloat x = v2.f64[0];
  result.CGFloat y = v3;
  return result;
}

size_t CGBitmapContextGetWidth(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void *)(*((void *)context + 4) + 8);
  }
  handle_invalid_context((char)"CGBitmapContextGetWidth", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

uint64_t CGImageProviderGetInfo(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

BOOL CGImageTextureDataIsCompressed(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 136) != 0;
  }
  return result;
}

uint64_t get_glyphs_for_unichars(uint64_t a1)
{
  return MEMORY[0x1F4119CF0](*(void *)(a1 + 8));
}

uint64_t argb32_mark_pixelmask_template(uint64_t result, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return result;
  }
  uint64_t v2 = a2 > 0x17
     ? vec::template_mark_pixelmask_row<(CGCompositeOperation)0,_rgba8_t>
     : (uint64_t *(*)(uint64_t *, uint8x8_t **, unint64_t *, char **, int, int, double, uint16x8_t, double, double, double, uint16x8_t, uint64_t, uint64_t, uint64_t, unint64_t))vec::MethodList<_rgba8_t>::maskMethods[a2];
  uint64_t v34 = v2;
  uint64_t v3 = *(void *)(result + 88);
  uint64_t v4 = *(void *)(result + 136);
  int v5 = *(_DWORD *)result;
  int64_t v6 = *(int *)(result + 4);
  uint64_t v7 = *(int *)(result + 8);
  unint64_t v8 = (unint64_t)*(int *)(result + 28) >> 2;
  unint64_t v9 = *(void *)(result + 40) + 4 * (*(int *)(result + 12) + v8 * *(int *)(result + 16));
  uint64_t v37 = v3;
  unint64_t v38 = v9;
  if (!v4) {
    return result;
  }
  uint64_t v10 = *(int *)(result + 124);
  uint64_t v11 = v4 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v10;
  uint64_t v35 = v11;
  uint64_t v12 = *(int *)(result + 56);
  uint64_t v13 = *(int *)(result + 60);
  int v14 = v5 & 0xFF00;
  unint64_t v15 = *(int *)(result + 76);
  if (v14 != 256)
  {
    unint64_t v16 = *(unsigned int *)(result + 64);
    uint64_t v20 = *(int *)(result + 68);
    unint64_t v21 = v15 >> 2;
    unint64_t v22 = v3 + 4 * (v15 >> 2) * v20;
    uint64_t v36 = v3;
    uint64_t v19 = 1;
    uint64_t v17 = v3;
    uint64_t v23 = v3;
    goto LABEL_18;
  }
  unint64_t v16 = v15 >> 2;
  uint64_t v17 = v3 + 4 * (v12 + (v15 >> 2) * v13);
  uint64_t v36 = -1;
  uint64_t v37 = v17;
  if (v16 == v8)
  {
    if ((uint64_t)(v9 - v17) >= 1)
    {
      if (v6 >= (uint64_t)((v9 - v17) >> 2))
      {
        v17 += 4 * (v6 - 1);
        uint64_t v37 = v17;
        unint64_t v38 = v9 + 4 * (v6 - 1);
        uint64_t v35 = v11 + v6 - 1;
        uint64_t v19 = 0xFFFFFFFFLL;
        goto LABEL_16;
      }
      uint64_t v18 = v8 * (v7 - 1);
      if (v9 <= v17 + 4 * v18 + 4 * ((int)v6 - 1))
      {
        uint64_t v37 = v17 + 4 * v18;
        unint64_t v38 = v9 + 4 * v18;
        unint64_t v8 = -(uint64_t)v8;
        uint64_t v35 = v11 + v10 * (v7 - 1);
        uint64_t v10 = -v10;
        uint64_t v19 = 1;
        uint64_t v17 = v37;
        goto LABEL_16;
      }
    }
    uint64_t v19 = 1;
LABEL_16:
    unint64_t v16 = v8;
    goto LABEL_17;
  }
  uint64_t v19 = 1;
LABEL_17:
  LODWORD(v20) = 0;
  uint64_t v23 = 0;
  unint64_t v22 = 0;
  unint64_t v21 = v16;
LABEL_18:
  if (v22)
  {
    uint64_t v24 = v17 + 4 * v21 * ((int)v13 % (int)v20);
    uint64_t v36 = v24 + 4 * (int)v16;
    uint64_t v37 = v24 + 4 * ((int)v12 % (int)v16);
    uint64_t v23 = v37;
  }
  else
  {
    v21 -= (int)v6 * (uint64_t)(int)v19;
  }
  uint64_t v25 = v10 - (int)v6 * (uint64_t)(int)v19;
  unint64_t v26 = v8 - (int)v6 * (uint64_t)(int)v19;
  uint64_t v33 = -(uint64_t)(v21 * (int)v20);
  int v27 = v7 + 1;
  do
  {
    unint64_t v28 = v16;
    uint64_t v29 = v19;
    CGPoint result = ((uint64_t (*)(uint64_t *, unint64_t *, uint64_t *, uint64_t *))v34)(&v37, &v38, &v36, &v35);
    v35 += v25;
    v38 += 4 * v26;
    if (v22)
    {
      unint64_t v30 = v23 + 4 * v21;
      uint64_t v31 = v33;
      if (v30 < v22) {
        uint64_t v31 = 0;
      }
      uint64_t v32 = v30 + 4 * v31;
      v36 += 4 * v31 + 4 * v21;
      uint64_t v23 = v32;
    }
    else
    {
      uint64_t v32 = v37 + 4 * v21;
    }
    uint64_t v19 = v29;
    unint64_t v16 = v28;
    uint64_t v37 = v32;
    --v27;
  }
  while (v27 > 1);
  return result;
}

unsigned __int32 **vec::template_mark_pixelmask_row<(CGCompositeOperation)2,_rgba8_t>(unsigned __int32 **result, _DWORD **a2, unint64_t *a3, char **a4, int a5, int a6, double a7, double a8, uint16x8_t a9, double a10, double a11, double a12, double a13, uint16x8_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  unint64_t v19 = a18;
  uint64_t v20 = *result;
  unint64_t v21 = *a3;
  unint64_t v22 = *a2;
  uint64_t v23 = *a4;
  if (a18 < 4) {
    goto LABEL_34;
  }
  uint64_t v24 = 4 * a6;
  uint64_t v25 = 16 * a6;
  uint16x8_t v26 = (uint16x8_t)vdupq_n_s16(0xFE01u);
  a9.i64[0] = -1;
  a9.i64[1] = -1;
  while (1)
  {
    unsigned __int32 v27 = *(_DWORD *)v23;
    if (*(_DWORD *)v23 == -1)
    {
      uint64_t v34 = (unsigned __int8 *)&v23[v19];
      uint64_t v35 = (int8x16_t *)v23;
      do
        uint64_t v36 = v35++;
      while (v35 <= (int8x16_t *)v34 && (vminvq_u8((uint8x16_t)vceqq_s8(*v36, (int8x16_t)a9)) & 0x80) != 0);
      do
      {
        uint64_t v37 = v36;
        uint64_t v36 = (int8x16_t *)((char *)v36 + 4);
      }
      while (v36 <= (int8x16_t *)v34 && v37->i32[0] == -1);
      if (v37 < (int8x16_t *)v34)
      {
        while (v37->u8[0] == 255)
        {
          uint64_t v37 = (int8x16_t *)((char *)v37 + 1);
          if (v37 >= (int8x16_t *)v34)
          {
            uint64_t v37 = (int8x16_t *)&v23[v19];
            break;
          }
        }
      }
      uint64_t v38 = 0;
      int64_t v39 = (char *)v37 - v23;
      unint64_t v40 = (char *)v37 - v23;
      do
      {
        int8x16_t v41 = *(int8x16_t *)((char *)v20 + v38);
        uint8x16_t v42 = *(uint8x16_t *)((char *)v22 + v38);
        int8x16_t v43 = vqtbl1q_s8(v41, (int8x16_t)xmmword_1850CD8D0);
        uint8x16_t v44 = (uint8x16_t)vbicq_s8(v41, vceqzq_s8(v43));
        uint16x8_t v45 = vminq_u16(vmull_u8(*(uint8x8_t *)v42.i8, *(uint8x8_t *)v43.i8), v26);
        uint16x8_t v46 = vminq_u16(vmull_high_u8(v42, (uint8x16_t)v43), v26);
        a14 = vrsraq_n_u16(v46, v46, 8uLL);
        *(uint8x16_t *)((char *)v22 + v38) = vqaddq_u8(v44, vqsubq_u8(v42, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v45, v45, 8uLL), 8uLL), a14, 8uLL)));
        v23 += v24;
        v40 -= 4;
        v38 += v25;
      }
      while (v40 > 3);
      unint64_t v22 = (_DWORD *)((char *)v22 + v38);
      uint64_t v20 = (unsigned __int32 *)((char *)v20 + v38);
      unint64_t v19 = v19 - v39 + v40;
      goto LABEL_31;
    }
    if (v27) {
      break;
    }
    unint64_t v28 = (unsigned __int8 *)&v23[v19];
    uint64_t v29 = (int8x16_t *)v23;
    do
      unint64_t v30 = v29++;
    while (v29 <= (int8x16_t *)v28 && (vminvq_u8((uint8x16_t)vceqzq_s8(*v30)) & 0x80) != 0);
    do
    {
      uint64_t v31 = v30;
      unint64_t v30 = (int8x16_t *)((char *)v30 + 4);
    }
    while (v30 <= (int8x16_t *)v28 && !v31->i32[0]);
    if (v31 < (int8x16_t *)v28)
    {
      while (!v31->i8[0])
      {
        uint64_t v31 = (int8x16_t *)((char *)v31 + 1);
        if (v31 >= (int8x16_t *)v28)
        {
          uint64_t v31 = (int8x16_t *)&v23[v19];
          break;
        }
      }
    }
    int64_t v32 = (char *)v31 - v23;
    int64_t v33 = ((char *)v31 - v23) * a6;
    v20 += v33;
    v22 += v33;
    v23 += v33;
    v19 -= v32;
LABEL_31:
    if (v19 <= 3) {
      goto LABEL_34;
    }
  }
  uint64_t v47 = 0;
  while (1)
  {
    uint8x16_t v48 = *(uint8x16_t *)((char *)v20 + v47);
    uint8x16_t v49 = *(uint8x16_t *)((char *)v22 + v47);
    a14.i32[0] = v27;
    uint8x16_t v50 = (uint8x16_t)vqtbl1q_s8((int8x16_t)a14, (int8x16_t)xmmword_1850CD8E0);
    uint16x8_t v51 = vmull_u8(*(uint8x8_t *)v48.i8, *(uint8x8_t *)v50.i8);
    uint16x8_t v52 = vmull_high_u8(v48, v50);
    uint16x8_t v53 = vminq_u16(v51, v26);
    uint16x8_t v54 = vminq_u16(v52, v26);
    uint16x8_t v55 = vrsraq_n_u16(v54, v54, 8uLL);
    *(uint8x8_t *)v51.i8 = vqrshrn_n_u16(vrsraq_n_u16(v53, v53, 8uLL), 8uLL);
    *(uint8x8_t *)&long long v18 = vqrshrn_n_u16(v55, 8uLL);
    int8x16_t v56 = vqtbl2q_s8(*(int8x16x2_t *)(&v18 - 1), (int8x16_t)xmmword_1850CD8F0);
    uint8x16_t v57 = (uint8x16_t)vbicq_s8((int8x16_t)vqrshrn_high_n_u16(*(uint8x8_t *)v51.i8, v55, 8uLL), vceqzq_s8(v56));
    uint16x8_t v58 = vminq_u16(vmull_u8(*(uint8x8_t *)v49.i8, *(uint8x8_t *)v56.i8), v26);
    uint16x8_t v59 = vminq_u16(vmull_high_u8(v49, (uint8x16_t)v56), v26);
    a14 = vrsraq_n_u16(v59, v59, 8uLL);
    *(uint8x16_t *)((char *)v22 + v47) = vqaddq_u8(v57, vqsubq_u8(v49, vqrshrn_high_n_u16(vqrshrn_n_u16(vrsraq_n_u16(v58, v58, 8uLL), 8uLL), a14, 8uLL)));
    v23 += v24;
    v19 -= 4;
    if (v19 < 4) {
      break;
    }
    unsigned __int32 v27 = *(_DWORD *)v23;
    v47 += v25;
    if ((*(_DWORD *)v23 - 1) >= 0xFFFFFFFE)
    {
      uint64_t v20 = (unsigned __int32 *)((char *)v20 + v47);
      unint64_t v22 = (_DWORD *)((char *)v22 + v47);
      goto LABEL_31;
    }
  }
  uint64_t v20 = (unsigned __int32 *)((char *)v20 + v25 + v47);
  unint64_t v22 = (_DWORD *)((char *)v22 + v25 + v47);
LABEL_34:
  uint64_t v60 = v19 + a17;
  if (v60)
  {
    int8x16_t v61 = (int8x16_t)vdupq_n_s16(0xFE01u);
    do
    {
      a9.i32[0] = *v20;
      uint16x8_t v62 = vmovl_u8(*(uint8x8_t *)a9.i8);
      LOBYTE(v63) = v62.i8[0];
      BYTE1(v63) = v62.i8[2];
      BYTE2(v63) = v62.i8[4];
      HIBYTE(v63) = v62.i8[6];
      v62.i32[0] = *v22;
      uint16x8_t v64 = vmovl_u8(*(uint8x8_t *)v62.i8);
      LOBYTE(v65) = v64.i8[0];
      BYTE1(v65) = v64.i8[2];
      BYTE2(v65) = v64.i8[4];
      HIBYTE(v65) = v64.i8[6];
      v64.i8[7] = 0;
      v64.i8[0] = *v23;
      v64.i8[1] = *v23;
      v64.i8[2] = *v23;
      *(__int32 *)((char *)v64.i32 + 3) = *v23;
      uint16x8_t v66 = vminq_u16(vmull_u8((uint8x8_t)v63, *(uint8x8_t *)v64.i8), (uint16x8_t)v61);
      uint16x8_t v67 = vrsraq_n_u16(v66, v66, 8uLL);
      int8x8_t v68 = (int8x8_t)vqrshrn_n_u16(v67, 8uLL);
      *(int8x8_t *)v67.i8 = vqtbl1_s8((int8x16_t)vqrshrn_high_n_u16((uint8x8_t)v68, v67, 8uLL), (int8x8_t)0x707070703030303);
      uint8x8_t v69 = (uint8x8_t)vbic_s8(v68, vceqz_s8(*(int8x8_t *)v67.i8));
      uint16x8_t v70 = vminq_u16(vmull_u8((uint8x8_t)v65, *(uint8x8_t *)v67.i8), (uint16x8_t)v61);
      a9 = vrsraq_n_u16(v70, v70, 8uLL);
      *(uint8x8_t *)a9.i8 = vqadd_u8(v69, vqsub_u8((uint8x8_t)v65, vqrshrn_n_u16(a9, 8uLL)));
      *(int8x8_t *)a9.i8 = vmovn_s16((int16x8_t)vzip1q_s8((int8x16_t)a9, v61));
      *unint64_t v22 = a9.i32[0];
      vImagePixelCount v71 = &v20[a6];
      v23 += a6;
      if ((unint64_t)v71 >= v21) {
        uint64_t v72 = -(uint64_t)a5;
      }
      else {
        uint64_t v72 = 0;
      }
      uint64_t v20 = &v71[v72];
      v22 += a6;
      --v60;
    }
    while (v60);
  }
  *CGPoint result = v20;
  *a3 = v21;
  *a2 = v22;
  *a4 = v23;
  return result;
}

uint64_t CGColorSpaceCreateWithID(int a1)
{
  if (creator_for_ID_predicate != -1) {
    dispatch_once(&creator_for_ID_predicate, &__block_literal_global_307);
  }
  if ((a1 - 1) > 0x1F) {
    return 0;
  }
  uint64_t v2 = (uint64_t (*)(void))creator_for_ID_creators[a1];
  if (!v2) {
    return 0;
  }

  return v2();
}

CGFloat CGImageTextureDataGetSize(uint64_t a1)
{
  uint64_t v1 = (const CGSize *)(a1 + 72);
  if (!a1) {
    uint64_t v1 = &CGSizeZero;
  }
  return v1->width;
}

uint64_t CGImageHasAlpha(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 39) >> 2) & 1;
  }
  return result;
}

CGFloat CGImageBlockSetGetRect(const CGRect *a1)
{
  uint64_t v1 = &CGRectZero;
  if (a1) {
    uint64_t v1 = a1 + 1;
  }
  return v1->origin.x;
}

CFComparisonResult compare_keys(CFStringRef *a1, CFStringRef *a2)
{
  return CFStringCompare(*a1, *a2, 0);
}

double CGColorTRCGetFunction@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (CGColorTRCGetFunction_cglibrarypredicate != -1) {
    dispatch_once(&CGColorTRCGetFunction_cglibrarypredicate, &__block_literal_global_4);
  }
  int v8 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  CGColorTRCGetFunction_f(&v6, a1);
  double result = *(double *)&v6;
  long long v5 = v7;
  *(_OWORD *)a2 = v6;
  *(_OWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 32) = v8;
  return result;
}

BOOL CGSizeEqualToSize(CGSize size1, CGSize size2)
{
  return size1.height == size2.height && size1.width == size2.width;
}

CGColorRef CGColorCreateCopy(CGColorRef color)
{
  if (color) {
    CFRetain(color);
  }
  return color;
}

uint64_t CGImageProviderCopyImageTextureData(uint64_t a1)
{
  if (a1 && *(_DWORD *)(a1 + 64) == 3 && (uint64_t v1 = *(uint64_t (**)(void))(a1 + 96)) != 0) {
    return v1(*(void *)(a1 + 56));
  }
  else {
    return 0;
  }
}

uint64_t CGRenderingStateGetAllowsAntialiasing(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 81);
}

uint64_t CGGStateGetClipStack(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t CGGStateGetCTM(uint64_t a1)
{
  return a1 + 24;
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void **)(*((void *)context + 4) + 64);
  }
  handle_invalid_context((char)"CGBitmapContextGetData", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

size_t CGBitmapContextGetBytesPerRow(CGContextRef context)
{
  if (context && *((_DWORD *)context + 4) == 1129601108 && *((_DWORD *)context + 6) == 4) {
    return *(void *)(*((void *)context + 4) + 88);
  }
  handle_invalid_context((char)"CGBitmapContextGetBytesPerRow", (uint64_t)context, v1, v2, v3, v4, v5, v6);
  return 0;
}

void CGContextSetCharacterSpacing(CGContextRef c, CGFloat spacing)
{
  if (c && *((_DWORD *)c + 4) == 1129601108)
  {
    uint64_t v9 = *((void *)c + 12);
    if (*(double *)(*(void *)(v9 + 136) + 24) != spacing)
    {
      maybe_copy_text_state(*((void *)c + 12));
      *(CGFloat *)(*(void *)(v9 + 136) + 24) = spacing;
    }
  }
  else
  {
    handle_invalid_context((char)"CGContextSetCharacterSpacing", (uint64_t)c, v2, v3, v4, v5, v6, v7);
  }
}

CGGradientRef CGGradientCreateWithColors(CGColorSpaceRef space, CFArrayRef colors, const CGFloat *locations)
{
  return (CGGradientRef)CGGradientCreateWithColorsAndOptions(space, colors, (uint64_t)locations, 0, v3, v4, v5, v6);
}

uint64_t CGvImage_converter_data_key_hash(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v2 = *(_OWORD *)(a1 + 16);
  v16[0] = *(_OWORD *)a1;
  v16[1] = v2;
  long long v3 = *(_OWORD *)(a1 + 48);
  v16[2] = *(_OWORD *)(a1 + 32);
  long long v17 = v3;
  uint64_t v18 = *(void *)(a1 + 64);
  bzero(&v24, 0x208uLL);
  long long v19 = *(_OWORD *)(a1 + 72);
  long long v20 = *(_OWORD *)(a1 + 88);
  uint64_t v21 = *(void *)(a1 + 104);
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    uint64_t v5 = *(void *)(*(void *)(v4 + 24) + 48);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v22 = v5;
  uint64_t v6 = *(void *)(a1 + 80);
  if (v6) {
    uint64_t v6 = *(void *)(*(void *)(v6 + 24) + 48);
  }
  uint64_t v23 = v6;
  *((void *)&v17 + 1) = 0;
  *((void *)&v20 + 1) = 0;
  v26[124] = *(_WORD *)(a1 + 640);
  if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 128);
    int v8 = &v25;
    uint64_t v9 = (uint64_t *)(a1 + 136);
    do
    {
      *(v8 - 1) = v7;
      uint64_t v10 = *v9++;
      uint64_t v7 = v10;
      *v8++ = v10;
      --v5;
    }
    while (v5);
  }
  if (v6)
  {
    uint64_t v11 = *(void *)(a1 + 384);
    uint64_t v12 = v26;
    uint64_t v13 = (uint64_t *)(a1 + 392);
    do
    {
      *(v12 - 1) = v11;
      uint64_t v14 = *v13++;
      uint64_t v11 = v14;
      *v12++ = v14;
      --v6;
    }
    while (v6);
  }
  return MEMORY[0x18532A6B0](v16, 648);
}

CFHashCode color_hash(CFHashCode result)
{
  CFHashCode v1 = result;
  if ((result & 0x8000000000000000) == 0)
  {
    double result = *(void *)(result + 48);
    if (!result)
    {
      double result = CFHash(*(CFTypeRef *)(v1 + 24));
      uint64_t v2 = *(void *)(v1 + 56);
      if (v2)
      {
        for (uint64_t i = 0; i != v2; ++i)
          result ^= i + (*(double *)(v1 + 64 + 8 * i) * 4294967300.0);
      }
      *(void *)(v1 + 48) = result;
    }
  }
  return result;
}

uint64_t cs_hash(uint64_t result)
{
  if (result)
  {
    CFHashCode v1 = *(int8x8_t **)(result + 24);
    if (v1)
    {
      int8x8_t v2 = veor_s8(v1[8], (int8x8_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)v1[8].i8, *(int8x16_t *)v1[8].i8, 8uLL));
      return (v2.i32[0] ^ v2.i32[1]);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CGContextBeginTransparencyLayer(CGContextRef c, CFDictionaryRef auxiliaryInfo)
{
  if (auxiliaryInfo
    && ((CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(auxiliaryInfo, @"kCGTransparencyLayerContentBounds"),
         long long v14 = 0u,
         long long v15 = 0u,
         Value)
     && (CFDictionaryRef v5 = Value, v6 = CFGetTypeID(Value), v6 == CFDictionaryGetTypeID())
     && (get_point_from_dict(v5, (double *)&v14), v7)
     && (get_size_from_dict(v5, (double *)&v15), (v8 & 1) != 0)
     || CGCFDictionaryGetRect(auxiliaryInfo, @"kCGContextBoundingBox", (UInt8 *)&v14)))
  {
    unint64_t v10 = *((void *)&v14 + 1);
    unint64_t v9 = v14;
    uint64_t v12 = *((void *)&v15 + 1);
    uint64_t v11 = v15;
    uint64_t v13 = c;
  }
  else
  {
    unint64_t v9 = 0xFFDFFFFFFFFFFFFFLL;
    uint64_t v11 = 0x7FEFFFFFFFFFFFFFLL;
    uint64_t v13 = c;
    unint64_t v10 = 0xFFDFFFFFFFFFFFFFLL;
    uint64_t v12 = 0x7FEFFFFFFFFFFFFFLL;
  }
  CGContextBeginTransparencyLayerWithRect(v13, *(CGRect *)&v9, auxiliaryInfo);
}

Swift::Void __swiftcall CGContextRef.draw(_:in:byTiling:)(CGImageRef _, __C::CGRect in, Swift::Bool byTiling)
{
  if (byTiling) {
    CGContextDrawTiledImage(v3, (CGRect)in, _);
  }
  else {
    CGContextDrawImage(v3, (CGRect)in, _);
  }
}

void resample_filter_linear(uint64_t a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7 = a3;
  if (a7 == 0.0 || (double v11 = fabs(a7), v11 >= INFINITY) && v11 <= INFINITY)
  {
    if (a5 >= a2) {
      LODWORD(v12) = a2;
    }
    else {
      LODWORD(v12) = a5;
    }
    if (v12 >= 0x4000) {
      uint64_t v12 = 0x4000;
    }
    else {
      uint64_t v12 = v12;
    }
    if (a7 == 0.0) {
      uint64_t v13 = v12;
    }
    else {
      uint64_t v13 = 1;
    }
    if (0x4000 % v13 >= a2) {
      unsigned int v14 = a2;
    }
    else {
      unsigned int v14 = 0x4000 % v13;
    }
    if (v13 >= v14) {
      uint64_t v15 = (v13 - v14) >> 1;
    }
    else {
      uint64_t v15 = 0;
    }
    unsigned int __pattern4 = (0x4000 / v13) | ((0x4000 / v13) << 16);
    unsigned int v45 = __pattern4 + 65537;
    if (a3)
    {
      uint64_t v44 = 2 * (a2 - v13);
      uint64_t v16 = 4 * a2 + 8;
      do
      {
        *(_DWORD *)a1 = 0;
        *(_DWORD *)(a1 + 4) = v13;
        uint64_t v17 = a1 + 8;
        memset_pattern4((void *)(a1 + 8), &__pattern4, 2 * v13);
        if (a2 > v13) {
          bzero((void *)(v17 + 2 * v13), v44);
        }
        if (v14) {
          memset_pattern4((void *)(v17 + 2 * v15), &v45, 2 * v14);
        }
        a1 += v16;
        --v7;
      }
      while (v7);
    }
    return;
  }
  double v18 = 1.0 / a7;
  double v19 = 1.0 / a7 * 0.5;
  if (a7 <= 1.0)
  {
    if (!a3) {
      return;
    }
    double v31 = v19 + a6;
    uint64_t v32 = 2 * a2 + 8;
    while (1)
    {
      double v33 = (floor(v31 - v19) - (v31 - v19) + 1.0) * a7;
      unsigned int v34 = vcvtmd_s64_f64(v31 - v19);
      if (a2)
      {
        if (v33 <= 1.0) {
          break;
        }
      }
      if (a2 && v33 > 1.0)
      {
        unsigned int v35 = 0;
        double v36 = 1.0;
        uint64_t v37 = a4;
        goto LABEL_56;
      }
      int v40 = 0;
      unsigned int v35 = 0;
      *(_DWORD *)a1 = v34;
      *(_DWORD *)(a1 + 4) = 0;
      uint8x16_t v42 = (_WORD *)(a1 + 8);
      int8x16_t v41 = (__int16 *)(a1 + 8);
LABEL_62:
      resample_kernel_normalize(v41, v35, 0x4000 - v40);
LABEL_63:
      if ((int)(a2 - v35) >= 1) {
        bzero(v42, 2 * (~v35 + a2) + 2);
      }
      double v31 = v18 + v31;
      a1 += v32;
      if (!--v7) {
        return;
      }
    }
    unsigned int v35 = 0;
    double v36 = 1.0;
    uint64_t v37 = a4;
    do
    {
      *v37++ = v33;
      double v36 = v36 - v33;
      BOOL v38 = ++v35 >= a2 || v36 < a7;
      double v33 = a7;
    }
    while (!v38);
    if (v35 < a2 && v36 < a7)
    {
LABEL_56:
      *uint64_t v37 = v36;
      ++v35;
    }
    uint64_t v39 = 0;
    int v40 = 0;
    *(_DWORD *)a1 = v34;
    *(_DWORD *)(a1 + 4) = v35;
    int8x16_t v41 = (__int16 *)(a1 + 8);
    uint8x16_t v42 = (_WORD *)(a1 + 8);
    do
    {
      double v43 = a4[v39] * 16384.0 + 0.5;
      *v42++ = (int)v43;
      v40 += (int)v43;
      ++v39;
    }
    while (v35 != v39);
    if (v40 == 0x4000) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  if (a3)
  {
    double v20 = v19 + a6;
    int v21 = a2 - 2;
    uint64_t v22 = 2 * a2 + 8;
    size_t v23 = 2 * (a2 - 2);
    do
    {
      unsigned int v24 = vcvtmd_s64_f64(v20);
      double v25 = v20 - floor(v20);
      BOOL v26 = v25 < 0.5;
      if (v25 >= 0.5) {
        double v27 = -0.5;
      }
      else {
        double v27 = 0.5;
      }
      double v28 = v25 + v27;
      *(_WORD *)(a1 + 8) = (int)((1.0 - v28) * 16384.0 + 0.5);
      int v29 = v26;
      *(_WORD *)(a1 + 10) = (int)(v28 * 16384.0 + 0.5);
      *(_DWORD *)a1 = v24 - v29;
      *(_DWORD *)(a1 + 4) = 2;
      if (v21 >= 1) {
        bzero((void *)(a1 + 12), v23);
      }
      double v20 = v18 + v20;
      a1 += v22;
      --v7;
    }
    while (v7);
  }
}

uint64_t img_interpolate_stage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  uint64_t v10 = a2;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)a1 = a2;
  if (*(void *)(a2 + 8)) {
    *(void *)(a1 + 8) = img_interpolate_extent;
  }
  *(void *)(a1 + 16) = img_interpolate_read;
  *(void *)(a1 + 24) = img_interpolate_end;
  *(_DWORD *)(a1 + 32) = 2;
  *(_DWORD *)(a1 + 48) = a5;
  *(_DWORD *)(a1 + 52) = a6;
  signed int v12 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 36) = v12;
  uint64_t v13 = *(void *)(a2 + 40);
  *(void *)(a1 + 40) = v13;
  if (a4 == 3)
  {
    if (v12 == 1) {
      char v14 = 4 * (*(void *)(a3 + 16) == 0);
    }
    else {
      char v14 = 0;
    }
  }
  else
  {
    char v14 = 4;
  }
  int v15 = v13;
  if (v13 == 32)
  {
    char v16 = v14 | 2;
  }
  else if (a7 == 5 || v13 != 16)
  {
    if (v13 == 16 && a7 == 5) {
      char v16 = v14 | 8;
    }
    else {
      char v16 = v14;
    }
  }
  else
  {
    char v16 = v14 | 1;
  }
  int v18 = *(_DWORD *)(a2 + 48);
  if (!v18) {
    return v10;
  }
  uint64_t v19 = *(unsigned int *)(a2 + 52);
  if (!v19 || !a5 || !a6 || v18 == a5 && v19 == a6) {
    return v10;
  }
  if ((v16 & 0xA) != 0) {
    int v20 = 4;
  }
  else {
    int v20 = 2;
  }
  if ((v16 & 4) != 0) {
    int v21 = 0;
  }
  else {
    int v21 = -1;
  }
  double v22 = (double)((__PAIR64__(a6, v16 & 4) - 1) >> 32) / (double)((__PAIR64__(v19, v16 & 4) - 1) >> 32);
  int v23 = *(_DWORD *)(a2 + 52);
  if (v22 != 0.0)
  {
    signed int v24 = 4;
    if (v22 == INFINITY) {
      goto LABEL_33;
    }
    if (v22 <= 1.0) {
      double v28 = (double)((__PAIR64__(a6, v16 & 4) - 1) >> 32) / (double)((__PAIR64__(v19, v16 & 4) - 1) >> 32);
    }
    else {
      double v28 = 1.0;
    }
    double v29 = 1.0 / v28 + 1.0;
    if ((v16 & 4) == 0) {
      double v29 = 4.0 / v28;
    }
    int v23 = vcvtpd_s64_f64(v29);
    if (v23 >= 0x10000) {
      return v10;
    }
  }
  signed int v24 = (v23 + 3) & 0xFFFFFFFC;
  if (v24 < 1) {
    return v10;
  }
LABEL_33:
  if ((v16 & 0xA) != 0) {
    char v25 = 2;
  }
  else {
    char v25 = 1;
  }
  if (v18 == v19 && a5 == a6)
  {
    int v93 = a8;
    unsigned int v95 = 0;
    unsigned int v26 = 0;
    double v27 = (double)((__PAIR64__(a6, v16 & 4) - 1) >> 32) / (double)((__PAIR64__(v19, v16 & 4) - 1) >> 32);
    goto LABEL_50;
  }
  double v27 = (double)(v21 + a5) / (double)(v18 + v21);
  int v30 = *(_DWORD *)(a2 + 48);
  if (v27 == 0.0) {
    goto LABEL_48;
  }
  signed int v31 = 4;
  if (v27 != INFINITY)
  {
    if (v27 <= 1.0) {
      double v37 = v27;
    }
    else {
      double v37 = 1.0;
    }
    double v38 = 1.0 / v37 + 1.0;
    if ((v16 & 4) == 0) {
      double v38 = 4.0 / v37;
    }
    int v30 = vcvtpd_s64_f64(v38);
    if (v30 >= 0x10000) {
      return v10;
    }
LABEL_48:
    signed int v31 = (v30 + 3) & 0xFFFFFFFC;
    if (v31 < 1) {
      return v10;
    }
  }
  int v93 = a8;
  unsigned int v95 = v31;
  unsigned int v26 = ((v31 << v25) + 8) * a5;
LABEL_50:
  unsigned int v92 = v26;
  uint64_t v89 = (((v24 << v25) + 8) * a6);
  unsigned int v96 = v24;
  uint64_t v32 = malloc_type_calloc(1uLL, v89 + v26 + 160, 0x64A29F66uLL);
  uint64_t v33 = v96;
  if (v32)
  {
    int v34 = v20;
    v32[19] = a6;
    v32[20] = v20;
    if ((v16 & 9) != 0) {
      int v35 = 2;
    }
    else {
      int v35 = 1;
    }
    int v36 = 4;
    v32[18] = a5;
    if ((v16 & 2) != 0) {
      int v35 = 4;
    }
    v32[24] = v35;
    v32[25] = v18;
    v32[26] = v19;
    if ((v16 & 2) == 0)
    {
      if ((v16 & 8) != 0)
      {
        int v36 = 5;
      }
      else if (v16)
      {
        int v36 = 2;
      }
      else
      {
        int v36 = 1;
      }
    }
    v32[21] = v36;
    v32[29] = v93;
    if ((int)v96 <= (int)v95) {
      unsigned int v39 = v95;
    }
    else {
      unsigned int v39 = v96;
    }
    size_t v40 = 8 * v39 + 32;
    CGDataProviderRef v94 = v32;
    if (v40 < 0x401)
    {
      uint8x16_t v42 = v97;
      uint64_t v43 = v19;
LABEL_77:
      uint64_t v44 = (_DWORD *)(((unint64_t)v32 + 143) & 0xFFFFFFFFFFFFFFF0);
      *(void *)uint64_t v32 = v44;
      v32[23] = v33;
      unsigned int v91 = v42;
      if (v34 == 4)
      {
        unsigned int v45 = (void (*)(unint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, double, double))resample_filter_linear_float;
        if ((v16 & 4) == 0) {
          unsigned int v45 = (void (*)(unint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, double, double))resample_filter_float;
        }
        v45(((unint64_t)v32 + 143) & 0xFFFFFFFFFFFFFFF0, v33, a6, v42, v43, 0.0, v22);
        resample_filter_float_normalize(v44, v96, a6, v19);
      }
      else
      {
        uint16x8_t v46 = (void (*)(unint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, double, double))resample_filter_linear;
        if ((v16 & 4) == 0) {
          uint16x8_t v46 = (void (*)(unint64_t, uint64_t, uint64_t, unsigned char *, uint64_t, double, double))resample_filter;
        }
        v46(((unint64_t)v32 + 143) & 0xFFFFFFFFFFFFFFF0, v33, a6, v42, v43, 0.0, v22);
        resample_filter_normalize(v44, v96, a6, v19);
      }
      if (v92)
      {
        uint64_t v47 = (_DWORD *)((char *)v44 + v89);
        v94[1] = v47;
        *((_DWORD *)v94 + 22) = v95;
        uint64_t v48 = *((unsigned int *)v94 + 25);
        if (*((_DWORD *)v94 + 20) == 4)
        {
          uint8x16_t v49 = resample_filter_linear_float;
          if ((v16 & 4) == 0) {
            uint8x16_t v49 = resample_filter_float;
          }
          ((void (*)(_DWORD *, void, uint64_t, unsigned char *, uint64_t, double, double))v49)(v47, v95, a5, v91, v48, 0.0, v27);
          resample_filter_float_normalize(v47, v95, a5, v18);
        }
        else
        {
          uint8x16_t v50 = resample_filter_linear;
          if ((v16 & 4) == 0) {
            uint8x16_t v50 = resample_filter;
          }
          ((void (*)(_DWORD *, void, uint64_t, unsigned char *, uint64_t, double, double))v50)(v47, v95, a5, v91, v48, 0.0, v27);
          resample_filter_normalize(v47, v95, a5, v18);
        }
      }
      else
      {
        v94[1] = v44;
        *((_DWORD *)v94 + 22) = v96;
      }
      if (v91 != v97) {
        free(v91);
      }
      switch(*(_DWORD *)(a1 + 44))
      {
        case 1:
          goto LABEL_97;
        case 2:
          goto LABEL_100;
        case 3:
          *(_DWORD *)(a1 + 44) = 1;
LABEL_97:
          int v51 = 0;
          char v52 = 0;
          char v53 = 0;
          ++v12;
          *(_DWORD *)(a1 + 56) = v15 / 8 * v12 * *(_DWORD *)(v10 + 48);
          int v54 = 2;
          break;
        case 4:
          *(_DWORD *)(a1 + 44) = 2;
LABEL_100:
          int v51 = 0;
          char v52 = 0;
          ++v12;
          *(_DWORD *)(a1 + 56) = v15 / 8 * v12 * *(_DWORD *)(v10 + 48);
          char v53 = 1;
          int v54 = 1;
          break;
        case 8:
          goto LABEL_103;
        case 9:
          *(_DWORD *)(a1 + 44) = 8;
LABEL_103:
          char v52 = 0;
          char v53 = 0;
          *(_DWORD *)(a1 + 56) = v15 / 8 * v12++ * *(_DWORD *)(v10 + 48);
          *(_DWORD *)(a1 + 60) = *(_DWORD *)(v10 + 48) * (v15 / 8);
          int v54 = 3;
          int v51 = 1;
          break;
        default:
          int v51 = 0;
          char v53 = 0;
          int v54 = 0;
          *(_DWORD *)(a1 + 56) = v15 / 8 * v12 * *(_DWORD *)(v10 + 48);
          char v52 = 1;
          break;
      }
      uint64_t v55 = (uint64_t)v94;
      signed int v56 = v12;
      if ((unint64_t)(v12 - 256) < 0xFFFFFFFFFFFFFF01) {
        goto LABEL_220;
      }
      int v57 = *((_DWORD *)v94 + 24);
      if (v57 != 4)
      {
        if (v57 != 2)
        {
          if (v57 != 1 || !v12) {
            goto LABEL_220;
          }
          if (v51)
          {
            if (v12 == 1) {
              goto LABEL_220;
            }
            if (v12 == 4)
            {
              v94[2] = resample_byte_v_3cpp_ap;
              *((_DWORD *)v94 + 28) = 65539;
              uint16x8_t v58 = (uint64_t (*)())resample_byte_h_3cpp_ap;
            }
            else
            {
              v94[2] = resample_byte_v_Ncpp_ap;
              *((_WORD *)v94 + 56) = v12 - 1;
              *((_WORD *)v94 + 57) = 1;
              uint8x8_t v69 = (uint64_t (*)())resample_byte_h_Ncpp_ap;
              if (v12 == 5) {
                uint8x8_t v69 = (uint64_t (*)())resample_byte_h_4cpp_ap;
              }
              uint16x8_t v58 = (uint64_t (*)())resample_byte_h_1cpp_ap;
              if (v12 != 2) {
                uint16x8_t v58 = v69;
              }
            }
LABEL_165:
            v94[3] = v58;
            if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1)
            {
              dispatch_once(&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_3_13621);
              uint64_t v55 = (uint64_t)v94;
            }
            if (!CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result)
            {
              if ((v51 & 1) == 0)
              {
                if ((unint64_t)*(unsigned int *)(v55 + 72) * v12 >= 0x10)
                {
                  char v73 = v12 == 1 ? 1 : v52;
                  long long v74 = resample_byte_v_Ncpp_armv7;
                  if (v73) {
                    goto LABEL_177;
                  }
                  char v75 = v53 ^ 1;
                  long long v74 = resample_byte_v_3cpp_af_armv7;
                  if (v12 != 4) {
                    char v75 = 1;
                  }
                  if ((v75 & 1) == 0)
                  {
LABEL_177:
                    *(void *)(v55 + 16) = v74;
                    *(unsigned char *)(v55 + 120) = 1;
                  }
                }
                if (*(_DWORD *)(v55 + 88) >= 4u)
                {
                  uint64_t v76 = resample_byte_h_3cpp_armv7;
                  if (v12 != 3)
                  {
                    if (v12 != 4) {
                      goto LABEL_212;
                    }
                    uint64_t v76 = resample_byte_h_4cpp_armv7;
                  }
                  *(void *)(v55 + 24) = v76;
                  *(unsigned char *)(v55 + 120) = 1;
                }
              }
LABEL_212:
              int v80 = *(_DWORD *)(v55 + 72);
              uint64_t v81 = *(int *)(v55 + 92);
              uint64_t v82 = v55;
              unint64_t v83 = (v81 + 3) & 0xFFFFFFFFFFFFFFFCLL;
              if (v83 - v81 >= 2) {
                int v84 = (v81 + 3) & 0xFFFFFFFC;
              }
              else {
                int v84 = v83 | 2;
              }
              unint64_t v85 = (4 * v56 * (uint64_t)v80 + 15) & 0xFFFFFFFFFFFFFFF0;
              uint64_t v86 = *(void **)(v82 + 56);
              if (v86) {
                uint64_t v87 = (char *)malloc_type_realloc(v86, (v85 | 8) * v84, 0x7492344AuLL);
              }
              else {
                uint64_t v87 = (char *)malloc_type_malloc((v85 | 8) * v84, 0x705560E0uLL);
              }
              *(void *)(v82 + 56) = v87;
              uint64_t v55 = v82;
              if (v87)
              {
                *(void *)(v82 + 64) = &v87[v85 * v84];
                *(_DWORD *)(v82 + 52) = v85;
                *(_DWORD *)(v82 + 40) = v84;
                *(void *)(v82 + 32) = 0;
                *(void *)(v82 + 44) = 0;
                *(_DWORD *)(v82 + 108) = v56 | (v54 << 8);
                *(void *)(a1 + 88) = v82;
                *(void *)(a1 + 96) = a7;
                return a1;
              }
LABEL_220:
              resample_destroy((void *)v55);
              return 0;
            }
            goto LABEL_210;
          }
          char v63 = v52 ^ 1;
          if (v12 == 1) {
            char v63 = 0;
          }
          if ((v63 & 1) == 0)
          {
            uint16x8_t v64 = resample_byte_v_Ncpp;
            goto LABEL_130;
          }
          if (v54 == 2)
          {
            if (v12 == 4)
            {
              uint16x8_t v67 = resample_byte_v_3cpp_al;
              goto LABEL_164;
            }
            uint16x8_t v64 = resample_byte_v_Ncpp_al;
          }
          else
          {
            if (v54 != 1) {
              goto LABEL_220;
            }
            if (v12 == 4)
            {
              uint16x8_t v67 = resample_byte_v_3cpp_af;
LABEL_164:
              v94[2] = v67;
              *((_DWORD *)v94 + 28) = (unsigned __int16)v12;
              uint16x8_t v58 = (uint64_t (*)())resample_byte_h_4cpp;
              goto LABEL_165;
            }
            uint16x8_t v64 = resample_byte_v_Ncpp_af;
          }
LABEL_130:
          v94[2] = v64;
          *((_DWORD *)v94 + 28) = (unsigned __int16)v12;
          uint16x8_t v58 = (uint64_t (*)())resample_byte_h_Ncpp;
          if (v12 <= 4) {
            uint16x8_t v58 = off_1ED09ADA0[v12 - 1];
          }
          goto LABEL_165;
        }
        int v60 = *((_DWORD *)v94 + 21);
        if (v60 == 5)
        {
          BOOL v62 = resample_float16_select((uint64_t)v94, v12, v54);
          goto LABEL_211;
        }
        if (v60 != 2) {
          goto LABEL_212;
        }
        if (!v12) {
          goto LABEL_220;
        }
        if (v51)
        {
          if (v12 == 1) {
            goto LABEL_220;
          }
          if (v12 == 4)
          {
            v94[2] = resample_word_v_3cpp_ap;
            *((_DWORD *)v94 + 28) = 131078;
            int8x16_t v61 = (uint64_t (*)())resample_word_h_3cpp_ap;
          }
          else
          {
            v94[2] = resample_word_v_Ncpp_ap;
            *((_WORD *)v94 + 56) = 2 * v12 - 2;
            *((_WORD *)v94 + 57) = 2;
            uint64_t v79 = (uint64_t (*)())resample_word_h_Ncpp_ap;
            if (v12 == 5) {
              uint64_t v79 = (uint64_t (*)())resample_word_h_4cpp_ap;
            }
            int8x16_t v61 = (uint64_t (*)())resample_word_h_1cpp_ap;
            if (v12 != 2) {
              int8x16_t v61 = v79;
            }
          }
LABEL_207:
          v94[3] = v61;
          if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1)
          {
            dispatch_once(&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_3_13621);
            uint64_t v55 = (uint64_t)v94;
          }
          if (!CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result) {
            goto LABEL_212;
          }
LABEL_210:
          BOOL v62 = resample_select_template(v55, v12, v54);
LABEL_211:
          uint64_t v55 = (uint64_t)v94;
          if (!v62) {
            goto LABEL_220;
          }
          goto LABEL_212;
        }
        char v71 = v52 ^ 1;
        if (v12 == 1) {
          char v71 = 0;
        }
        if ((v71 & 1) == 0)
        {
          uint64_t v72 = resample_word_v_Ncpp;
          goto LABEL_160;
        }
        if (v54 == 2)
        {
          if (v12 == 4)
          {
            uint64_t v78 = resample_word_v_3cpp_al;
            goto LABEL_206;
          }
          uint64_t v72 = resample_word_v_Ncpp_al;
        }
        else
        {
          if (v54 != 1) {
            goto LABEL_220;
          }
          if (v12 == 4)
          {
            uint64_t v78 = resample_word_v_3cpp_af;
LABEL_206:
            v94[2] = v78;
            *((_WORD *)v94 + 56) = 8;
            *((_WORD *)v94 + 57) = 0;
            int8x16_t v61 = (uint64_t (*)())resample_word_h_4cpp;
            goto LABEL_207;
          }
          uint64_t v72 = resample_word_v_Ncpp_af;
        }
LABEL_160:
        v94[2] = v72;
        *((_WORD *)v94 + 56) = 2 * v12;
        *((_WORD *)v94 + 57) = 0;
        int8x16_t v61 = (uint64_t (*)())resample_word_h_Ncpp;
        if (v12 <= 4) {
          int8x16_t v61 = off_1ED09CE50[v12 - 1];
        }
        goto LABEL_207;
      }
      if (!v12) {
        goto LABEL_220;
      }
      if (v51)
      {
        if (v12 == 1) {
          goto LABEL_220;
        }
        if (v12 == 4)
        {
          v94[2] = resample_float_v_3cpp_ap;
          *((_DWORD *)v94 + 28) = 262156;
          uint16x8_t v59 = (uint64_t (*)())resample_float_h_3cpp_ap;
        }
        else
        {
          v94[2] = resample_float_v_Ncpp_ap;
          *((_WORD *)v94 + 56) = 4 * v12 - 4;
          *((_WORD *)v94 + 57) = 4;
          uint16x8_t v70 = (uint64_t (*)())resample_float_h_Ncpp_ap;
          if (v12 == 5) {
            uint16x8_t v70 = (uint64_t (*)())resample_float_h_4cpp_ap;
          }
          uint16x8_t v59 = (uint64_t (*)())resample_float_h_1cpp_ap;
          if (v12 != 2) {
            uint16x8_t v59 = v70;
          }
        }
        goto LABEL_186;
      }
      char v65 = v52 ^ 1;
      if (v12 == 1) {
        char v65 = 0;
      }
      if ((v65 & 1) == 0)
      {
        uint16x8_t v66 = resample_float_v_Ncpp;
        goto LABEL_136;
      }
      if (v54 == 2)
      {
        if (v12 == 4)
        {
          int8x8_t v68 = resample_float_v_3cpp_al;
          goto LABEL_185;
        }
        uint16x8_t v66 = resample_float_v_Ncpp_al;
      }
      else
      {
        if (v54 != 1) {
          goto LABEL_220;
        }
        if (v12 == 4)
        {
          int8x8_t v68 = resample_float_v_3cpp_af;
LABEL_185:
          v94[2] = v68;
          *((_WORD *)v94 + 56) = 16;
          *((_WORD *)v94 + 57) = 0;
          uint16x8_t v59 = (uint64_t (*)())resample_float_h_4cpp;
          goto LABEL_186;
        }
        uint16x8_t v66 = resample_float_v_Ncpp_af;
      }
LABEL_136:
      v94[2] = v66;
      *((_WORD *)v94 + 56) = 4 * v12;
      *((_WORD *)v94 + 57) = 0;
      uint16x8_t v59 = (uint64_t (*)())resample_float_h_Ncpp;
      if (v12 <= 4) {
        uint16x8_t v59 = off_1ED09B958[v12 - 1];
      }
LABEL_186:
      v94[3] = v59;
      if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken != -1)
      {
        dispatch_once(&CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::onceToken, &__block_literal_global_3_13621);
        uint64_t v55 = (uint64_t)v94;
      }
      if (CGPreferencesCheck<CGResamplingAllowTemplateMethod>(void)::result)
      {
        BOOL v77 = resample_select_template(v55, v12, v54);
        uint64_t v55 = (uint64_t)v94;
        if (!v77) {
          goto LABEL_220;
        }
      }
      goto LABEL_212;
    }
    int8x16_t v41 = malloc_type_calloc(1uLL, v40, 0x9B2B0349uLL);
    if (v41)
    {
      uint8x16_t v42 = v41;
      uint64_t v32 = v94;
      int v34 = *((_DWORD *)v94 + 20);
      uint64_t v43 = *((unsigned int *)v94 + 26);
      uint64_t v33 = v96;
      goto LABEL_77;
    }
    free(v94);
  }
  return v10;
}

void resample_filter_normalize(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  int v5 = a3;
  CFTypeID v6 = a1;
  uint64_t v7 = 2 * a2 + 8;
  int v8 = a3;
  unint64_t v9 = a1;
  do
  {
    int v10 = *v9;
    if ((*v9 & 0x80000000) == 0) {
      break;
    }
    __int16 v11 = 0;
    --v8;
    uint64_t v12 = v10;
    int v13 = v9[1] + v10;
    *unint64_t v9 = 0;
    v9[1] = v13;
    char v14 = v9 + 2;
    unsigned int v15 = ~v10;
    char v16 = (__int16 *)(v9 + 2);
    do
    {
      __int16 v17 = *v16++;
      v11 += v17;
    }
    while (!__CFADD__(v10++, 1));
    *((_WORD *)v9 + v15 + 5) += v11;
    if (v13)
    {
      uint64_t v19 = -1 * v12;
      do
      {
        int v20 = v14 + 1;
        *char v14 = v14[v19];
        ++v14;
        --v13;
      }
      while (v13);
    }
    else
    {
      int v20 = v9 + 2;
    }
    bzero(v20, 2 * v15 + 2);
    unint64_t v9 = (_DWORD *)((char *)v9 + v7);
  }
  while (v8);
  int v21 = (_DWORD *)((char *)v6 + v7 * (v5 - 1));
  int v22 = v5;
  do
  {
    int v23 = v21[1];
    int v24 = *v21 - a4 + v23;
    if (v24 < 1) {
      break;
    }
    __int16 v25 = 0;
    --v22;
    v21[1] = a4 - *v21;
    unsigned int v26 = (_WORD *)v21 + v23 + 3;
    do
    {
      v25 += *v26;
      *v26-- = 0;
      --v24;
    }
    while (v24);
    *v26 += v25;
    int v21 = (_DWORD *)((char *)v21 - v7);
  }
  while (v22);
  do
  {
    int v27 = v6[1];
    if (v27)
    {
      double v28 = v6 + 2;
      uint64_t v29 = 2 * (v27 - 1) + 8;
      while (!*(_WORD *)((char *)v6 + v29))
      {
        v29 -= 2;
        if (!--v27) {
          goto LABEL_33;
        }
      }
      int v30 = 0;
      uint64_t v31 = 8;
      while (!*(_WORD *)((char *)v6 + v31))
      {
        ++v30;
        v31 += 2;
        if (v27 == v30)
        {
          int v30 = v27;
          break;
        }
      }
      if (v30)
      {
        int v32 = v27 - v30;
        if (v27 == v30)
        {
          int v34 = v6 + 2;
        }
        else
        {
          int v33 = v30;
          do
          {
            int v34 = v28 + 1;
            *double v28 = v28[v30];
            ++v33;
            ++v28;
          }
          while (v27 != v33);
        }
        *v6 += v30;
        bzero(v34, 2 * (v30 - 1) + 2);
        int v27 = v32;
      }
    }
LABEL_33:
    v6[1] = v27;
    CFTypeID v6 = (_DWORD *)((char *)v6 + v7);
    --v5;
  }
  while (v5);
}

void resample_filter(__int16 *a1, unsigned int a2, int a3, double *a4, unsigned int a5, double a6, double a7)
{
  int v7 = a3;
  if (a7 == 0.0 || (double v12 = fabs(a7), v12 >= INFINITY) && v12 <= INFINITY)
  {
    if (a5 >= a2) {
      LODWORD(v13) = a2;
    }
    else {
      LODWORD(v13) = a5;
    }
    if (v13 >= 0x4000) {
      uint64_t v13 = 0x4000;
    }
    else {
      uint64_t v13 = v13;
    }
    if (a7 == 0.0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 1;
    }
    if (0x4000 % v14 >= a2) {
      unsigned int v15 = a2;
    }
    else {
      unsigned int v15 = 0x4000 % v14;
    }
    if (v14 >= v15) {
      uint64_t v16 = (v14 - v15) >> 1;
    }
    else {
      uint64_t v16 = 0;
    }
    unsigned int __pattern4 = (0x4000 / v14) | ((0x4000 / v14) << 16);
    unsigned int v50 = __pattern4 + 65537;
    if (a3)
    {
      uint64_t v48 = 2 * (a2 - v14);
      uint64_t v17 = 4 * a2 + 8;
      do
      {
        *(_DWORD *)a1 = 0;
        *((_DWORD *)a1 + 1) = v14;
        int v18 = a1 + 4;
        memset_pattern4(a1 + 4, &__pattern4, 2 * v14);
        if (a2 > v14) {
          bzero((char *)v18 + 2 * v14, v48);
        }
        if (v15) {
          memset_pattern4((char *)v18 + 2 * v16, &v50, 2 * v15);
        }
        a1 = (__int16 *)((char *)a1 + v17);
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    double v20 = fmin(a7, 1.0);
    __double2 v21 = __sincos_stret(v20 * 1.57079633);
    if (v7)
    {
      v22.f64[0] = NAN;
      v22.f64[1] = NAN;
      int8x16_t v47 = (int8x16_t)vnegq_f64(v22);
      double v49 = 1.0 / a7;
      do
      {
        int v23 = vcvtmd_s64_f64(a6);
        double v24 = v20 * ((double)v23 - a6);
        int v25 = (int)((v24 + 2.0) / v20);
        double v26 = v24 - (double)v25 * v20;
        double v27 = -0.0;
        if (v26 <= -2.0) {
          double v27 = v20;
        }
        double v28 = v26 + v27;
        int v29 = (int)((2.0 - (v26 + v27)) / v20);
        BOOL v30 = v26 <= -2.0;
        if (v26 + v27 + (double)v29 * v20 < 2.0) {
          ++v29;
        }
        if (v29 >= (int)a2) {
          int v31 = a2;
        }
        else {
          int v31 = v29;
        }
        if (v31)
        {
          __double2 v35 = __sincos_stret(v28 * 1.57079633);
          *(double *)v33.i64 = v35.__cosval;
          double sinval = v35.__sinval;
          double v36 = 0.0;
          int v37 = v31;
          double v38 = a4;
          do
          {
            double v39 = 1.0;
            if (fabs(v28) >= v20 * 0.5) {
              double v39 = sinval * sinval * *(double *)v33.i64 / (v28 * v28 * 1.57079633 * 1.57079633);
            }
            *v38++ = v39;
            double v36 = v36 + v39;
            double v28 = v20 + v28;
            double v40 = v21.__sinval * *(double *)v33.i64;
            *(double *)v33.i64 = *(double *)v33.i64 * v21.__cosval - sinval * v21.__sinval;
            double sinval = v40 + sinval * v21.__cosval;
            --v37;
          }
          while (v37);
          *(_DWORD *)a1 = v23 - v25 + v30;
          *((_DWORD *)a1 + 1) = v31;
          int8x16_t v41 = a4;
          int v42 = v31;
          uint64_t v43 = a1 + 4;
          double v44 = 16384.0 / v36;
          v34.i64[0] = 0.5;
          do
          {
            double v45 = *v41++;
            *(double *)v33.i64 = v44 * v45;
            int v46 = (int)(v44 * v45 + *(double *)vbslq_s8(v47, v34, v33).i64);
            *v43++ = v46;
            v37 += v46;
            --v42;
          }
          while (v42);
          if (v37 != 0x4000) {
            resample_kernel_normalize(a1 + 4, v31, 0x4000 - v37);
          }
        }
        else
        {
          *(void *)a1 = (v23 - v25 + v30);
          uint64_t v43 = a1 + 4;
        }
        if ((int)(a2 - v31) >= 1) {
          bzero(v43, 2 * (~v31 + a2) + 2);
        }
        a6 = v49 + a6;
        a1 += a2 + 4;
        --v7;
      }
      while (v7);
    }
  }
}

__int16 *resample_kernel_normalize(__int16 *result, int a2, int a3)
{
  if (a2)
  {
    int v3 = 0;
    int v4 = 0;
    int v5 = result;
    CFTypeID v6 = result;
    do
    {
      int v8 = *v6++;
      int v7 = v8;
      BOOL v9 = v4 < v8;
      if (v4 == v8) {
        ++v3;
      }
      if (v9)
      {
        double result = v5;
        int v4 = v7;
        int v3 = 1;
      }
      int v5 = v6;
      --a2;
    }
    while (a2);
    if (v3)
    {
      if (a3 / v3)
      {
        int v10 = v3;
        __int16 v11 = result;
        do
        {
          *v11++ += a3 / v3;
          --v10;
        }
        while (v10);
        a3 %= v3;
      }
      result[v3 >> 1] += a3;
    }
  }
  return result;
}

BOOL resample_select_template(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && (*(unsigned char *)(a1 + 116) & 1) != 0)
  {
    if (a3 == 3)
    {
      if (!a2) {
        return a1 != 0;
      }
      --a2;
    }
    if ((unint64_t)(a2 - 6) >= 0xFFFFFFFFFFFFFFFBLL)
    {
      switch(*(_DWORD *)(a1 + 84))
      {
        case 0:
        case 3:
        case 6:
          return a1 != 0;
        case 1:
          int v3 = 0;
          goto LABEL_13;
        case 2:
          int v3 = 1;
          goto LABEL_13;
        case 4:
          int v3 = 3;
          goto LABEL_13;
        case 5:
          int v3 = 2;
          goto LABEL_13;
        default:
          int v3 = -1;
LABEL_13:
          uint64_t v4 = (uint64_t)*(&kHorizontalFunctionList + 20 * v3 + 5 * a3 + a2 - 1);
          if (v4) {
            *(void *)(a1 + 24) = v4;
          }
          uint64_t v5 = (uint64_t)*(&kVerticalFunctionList + 20 * v3 + 5 * a3 + a2 - 1);
          if (v5) {
            *(void *)(a1 + 16) = v5;
          }
          break;
      }
    }
  }
  return a1 != 0;
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  if (a1) {
    LOBYTE(a1) = *(unsigned char *)(*((void *)a1 + 3) + 14) != 0;
  }
  return (char)a1;
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  if (!dict || !point) {
    return 0;
  }
  get_point_from_dict(dict, &point->x);
  return result;
}

BOOL CGPDFScannerScan(CGPDFScannerRef scanner)
{
  if (!scanner) {
    return (char)scanner;
  }
  CGPDFScannerRef v1 = scanner;
  pthread_once(&CGPDFScannerScan_once_control, (void (*)(void))CGPDFScannerScanInit);
  if (pthread_getspecific(scanner_bailout_key))
  {
LABEL_25:
    LOBYTE(scanner) = 0;
    return (char)scanner;
  }
  int8x8_t v2 = (char *)pthread_getspecific(scanner_frame_key) + 1;
  if ((unint64_t)v2 >= 0x33)
  {
    pthread_setspecific(scanner_bailout_key, (const void *)1);
    goto LABEL_25;
  }
  pthread_setspecific(scanner_frame_key, v2);
  *((_DWORD *)v1 + 28) = 0;
  *((void *)v1 + 13) = 0;
  *((_DWORD *)v1 + 22) = 0;
  *((void *)v1 + 5) = 0;
  if (pdf_scanner_advance_stream(v1))
  {
    uint64_t v27 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    while (2)
    {
      BOOL v9 = (uint64_t (*)(void))*((void *)v1 + 15);
      if (!v9
        || (int v10 = *((_DWORD *)v1 + 28) + 1, *((_DWORD *)v1 + 28) = v10, (v10 & 0x3FF) != 0)
        || (v9(*((void *)v1 + 16)) & 1) != 0)
      {
        if (!*((unsigned char *)v1 + 136))
        {
          int v11 = pdf_lexer_scan(*((void *)v1 + 8), (uint64_t)&v25, v3, v4, v5, v6, v7, v8);
          switch(v11)
          {
            case 0:
            case 15:
              if (pdf_scanner_advance_stream(v1)) {
                continue;
              }
              uint64_t v18 = *((unsigned int *)v1 + 18);
              if ((v18 & 0x80000000) != 0) {
                goto LABEL_42;
              }
              if (v18)
              {
                uint64_t v21 = 0;
                do
                {
                  uint64_t v22 = *((void *)v1 + 10) + v21;
                  if ((*(_DWORD *)(v22 + 8) - 5) <= 4) {
                    pdf_object_release_compound_value(v22);
                  }
                  v21 += 40;
                }
                while (40 * v18 != v21);
              }
              goto LABEL_43;
            case 1:
              pdf_scanner_handle_choke((uint64_t)&v25);
              goto LABEL_22;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 8:
            case 13:
              goto LABEL_11;
            case 7:
              pdf_scanner_handle_xname((uint64_t)v1);
              continue;
            case 9:
            case 11:
              if (!pdf_scanner_read_compound_object((uint64_t)v1, (uint64_t)&v25, 0, *((unsigned int *)v1 + 18), 0, v6, v7, v8))continue; {
LABEL_11:
              }
              int v12 = *((_DWORD *)v1 + 18);
              uint64_t v13 = *((int *)v1 + 19);
              if (v12 >= (int)v13)
              {
                *((_DWORD *)v1 + 19) = 2 * v13;
                uint64_t v14 = (char *)malloc_type_realloc(*((void **)v1 + 10), 80 * v13, 0x103204077D336DFuLL);
                *((void *)v1 + 10) = v14;
                int v12 = *((_DWORD *)v1 + 18);
              }
              else
              {
                uint64_t v14 = (char *)*((void *)v1 + 10);
              }
              unsigned int v15 = &v14[40 * v12];
              long long v16 = v25;
              long long v17 = v26;
              *((void *)v15 + 4) = v27;
              *(_OWORD *)unsigned int v15 = v16;
              *((_OWORD *)v15 + 1) = v17;
              ++*((_DWORD *)v1 + 18);
              continue;
            default:
              pdf_error("encountered unexpected object type: %d.", v11);
LABEL_22:
              if ((DWORD2(v25) - 5) <= 4) {
                pdf_object_release_compound_value((uint64_t)&v25);
              }
              continue;
          }
        }
      }
      else
      {
        *((unsigned char *)v1 + 136) = 1;
      }
      break;
    }
    uint64_t v18 = *((unsigned int *)v1 + 18);
    if ((v18 & 0x80000000) != 0)
    {
LABEL_42:
      pdf_error("Fatal: Attempted to remove more than args stack count. Argument stack is inconsistent.");
    }
    else if (v18)
    {
      uint64_t v19 = 0;
      do
      {
        uint64_t v20 = *((void *)v1 + 10) + v19;
        if ((*(_DWORD *)(v20 + 8) - 5) <= 4) {
          pdf_object_release_compound_value(v20);
        }
        v19 += 40;
      }
      while (40 * v18 != v19);
    }
LABEL_43:
    *((_DWORD *)v1 + 18) -= v18;
  }
  int v23 = (char *)pthread_getspecific(scanner_frame_key) - 1;
  pthread_setspecific(scanner_frame_key, v23);
  if (!v23) {
    pthread_setspecific(scanner_bailout_key, 0);
  }
  LOBYTE(scanner) = 1;
  return (char)scanner;
}

uint64_t pdf_lexer_scan(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v175 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a2 + 8) = 1;
  if (!a1) {
    return 0;
  }
  uint64_t v8 = a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a2;
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    uint64_t v11 = *(void *)(v10 + 120);
    if (!v11)
    {
      if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)) {
        return 0;
      }
      uint64_t v11 = *(void *)(v10 + 120);
    }
    int v12 = *(unsigned char **)(v10 + 128);
    *(void *)(v10 + 120) = v11 - 1;
    *(void *)(v10 + 128) = v12 + 1;
    uint64_t v13 = *v12;
    if (v13 > 0x25) {
      break;
    }
    if (((1 << v13) & 0x100003601) == 0)
    {
      if (v13 != 37) {
        break;
      }
      skip_comment((void *)a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  if (*v12 > 0x5Au)
  {
    if (*v12 > 0x7Au)
    {
      if (v13 == 123 || v13 == 125)
      {
        unint64_t v41 = *(void *)(a1 + 24);
        unint64_t v42 = *(void *)(a1 + 32);
        if (v41 >= v42)
        {
          size_t v107 = 2 * v42 + 128;
          *(void *)(a1 + 32) = v107;
          uint64_t v43 = malloc_type_realloc(*(void **)(a1 + 40), v107, 0x33EA2F66uLL);
          *(void *)(a1 + 40) = v43;
          if (!v43) {
            goto LABEL_334;
          }
          unint64_t v41 = *(void *)(a1 + 24);
        }
        else
        {
          uint64_t v43 = *(unsigned char **)(a1 + 40);
        }
        *(void *)(a1 + 24) = v41 + 1;
        v43[v41] = v13;
        goto LABEL_288;
      }
    }
    else
    {
      if (v13 == 91) {
        return 11;
      }
      if (v13 == 93) {
        return 12;
      }
    }
    while (1)
    {
      while (1)
      {
LABEL_199:
        if ((v13 + 1) <= 0x3F && ((1 << (v13 + 1)) & 0xA001064200006C03) != 0
          || (v13 - 91) <= 0x22 && ((1 << (v13 - 91)) & 0x500000005) != 0)
        {
          CGPDFSourceUngetc(*(void **)(a1 + 16), v13);
          uint64_t v115 = *(void *)(a1 + 24);
          switch(v115)
          {
            case 1:
              if (**(unsigned char **)(a1 + 40) != 82) {
                goto LABEL_318;
              }
              uint64_t v14 = 18;
              break;
            case 3:
              long long v145 = *(unsigned __int16 **)(a1 + 40);
              int v146 = *v145;
              int v147 = *((unsigned __int8 *)v145 + 2);
              if (v146 != 25199 || v147 != 106) {
                goto LABEL_318;
              }
              uint64_t v14 = 16;
              break;
            case 4:
              CGAffineTransform v149 = *(_DWORD **)(a1 + 40);
              if (*v149 == 1702195828)
              {
                uint64_t v171 = *(void *)(a1 + 48);
                *(_DWORD *)(v171 + 8) = 2;
                *(unsigned char *)(v171 + 32) = 1;
                goto LABEL_331;
              }
              if (*v149 != 1819047278) {
                goto LABEL_318;
              }
              *(_DWORD *)(*(void *)(a1 + 48) + 8) = 1;
              uint64_t v14 = 2;
              break;
            case 5:
              CGRect v150 = *(int **)(a1 + 40);
              int v151 = *v150;
              int v152 = *((unsigned __int8 *)v150 + 4);
              if (v151 != 1936482662 || v152 != 101) {
                goto LABEL_318;
              }
              uint64_t v154 = *(void *)(a1 + 48);
              *(_DWORD *)(v154 + 8) = 2;
              *(unsigned char *)(v154 + 32) = 0;
LABEL_331:
              uint64_t v14 = 3;
              break;
            case 6:
              CGRect v155 = *(int **)(a1 + 40);
              if (*v155 == 1868852837 && *((_WORD *)v155 + 2) == 27234)
              {
                uint64_t v14 = 17;
              }
              else
              {
                int v157 = *v155;
                int v158 = *((unsigned __int16 *)v155 + 2);
                if (v157 != 1701999731 || v158 != 28001) {
                  goto LABEL_318;
                }
                uint64_t v14 = 14;
              }
              break;
            case 9:
              unsigned int v160 = *(uint64_t **)(a1 + 40);
              uint64_t v161 = *v160;
              int v162 = *((unsigned __int8 *)v160 + 8);
              if (v161 != 0x6165727473646E65 || v162 != 109) {
                goto LABEL_318;
              }
              uint64_t v14 = 15;
              break;
            default:
LABEL_318:
              int v164 = *(_DWORD *)(a1 + 56);
              if (v164 == 1)
              {
                *(_DWORD *)(*(void *)(a1 + 48) + 8) = 1;
                *(void *)(a1 + 64) = *(void *)(a1 + 40);
                *(void *)(a1 + 72) = v115;
              }
              else if (!v164)
              {
                uint64_t v165 = *(void *)(a1 + 48);
                *(_DWORD *)(v165 + 8) = 5;
                *(unsigned char *)(v165 + 12) |= 1u;
                uint64_t v166 = *(void *)(a1 + 48);
                *(void *)(v166 + 16) = 0;
                *(void *)(v166 + 24) = 0;
                *(void *)(v8 + 32) = strndup(*(const char **)(a1 + 40), *(void *)(a1 + 24));
              }
              uint64_t v14 = 7;
              break;
          }
          return v14;
        }
        unint64_t v108 = *(void *)(a1 + 24);
        unint64_t v109 = *(void *)(a1 + 32);
        uint64_t v110 = *(void **)(a1 + 40);
        if (v108 >= v109)
        {
          size_t v111 = 2 * v109 + 128;
          *(void *)(a1 + 32) = v111;
          uint64_t v110 = malloc_type_realloc(v110, v111, 0x33EA2F66uLL);
          *(void *)(a1 + 40) = v110;
          if (!v110) {
            goto LABEL_334;
          }
          unint64_t v108 = *(void *)(a1 + 24);
        }
        *(void *)(a1 + 24) = v108 + 1;
        *((unsigned char *)v110 + v108) = v13;
        uint64_t v112 = *(void *)(a1 + 16);
        uint64_t v113 = *(void *)(v112 + 120);
        if (!v113) {
          break;
        }
LABEL_209:
        uint64_t v114 = *(unsigned __int8 **)(v112 + 128);
        *(void *)(v112 + 120) = v113 - 1;
        *(void *)(v112 + 128) = v114 + 1;
        LODWORD(v13) = *v114;
      }
      LODWORD(v13) = -1;
      if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v113 = *(void *)(v112 + 120);
        goto LABEL_209;
      }
    }
  }
  switch(*v12)
  {
    case '(':
      int v55 = 1;
      while (1)
      {
LABEL_88:
        uint64_t v56 = *(void *)(a1 + 16);
        uint64_t v57 = *(void *)(v56 + 120);
        if (!v57)
        {
          if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)) {
            goto LABEL_327;
          }
          uint64_t v57 = *(void *)(v56 + 120);
        }
        uint16x8_t v58 = *(unsigned __int8 **)(v56 + 128);
        *(void *)(v56 + 120) = v57 - 1;
        *(void *)(v56 + 128) = v58 + 1;
        unsigned int v59 = *v58;
        if (v59 != 92) {
          break;
        }
        uint64_t v60 = *(void *)(a1 + 16);
        uint64_t v61 = *(void *)(v60 + 120);
        if (v61) {
          goto LABEL_95;
        }
        if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
        {
          uint64_t v61 = *(void *)(v60 + 120);
LABEL_95:
          BOOL v62 = *(unsigned __int8 **)(v60 + 128);
          *(void *)(v60 + 120) = v61 - 1;
          *(void *)(v60 + 128) = v62 + 1;
          unsigned int v59 = *v62;
          if (v59 <= 0xC)
          {
            if (v59 != 10) {
              goto LABEL_144;
            }
            continue;
          }
          if (*v62 <= 0x2Fu)
          {
            if (v59 != 13) {
              goto LABEL_144;
            }
            uint64_t v63 = *(void *)(a1 + 16);
            uint64_t v64 = *(void *)(v63 + 120);
            if (v64)
            {
LABEL_101:
              char v65 = *(unsigned __int8 **)(v63 + 128);
              *(void *)(v63 + 120) = v64 - 1;
              *(void *)(v63 + 128) = v65 + 1;
              a2 = *v65;
              if (a2 == 10) {
                continue;
              }
            }
            else
            {
              if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
              {
                uint64_t v64 = *(void *)(v63 + 120);
                goto LABEL_101;
              }
              LODWORD(a2) = -1;
            }
            CGPDFSourceUngetc(*(void **)(a1 + 16), a2);
            continue;
          }
          if (*v62 <= 0x61u)
          {
            char v66 = v59 - 48;
            if (v59 - 48 >= 8) {
              goto LABEL_144;
            }
            char v67 = 0;
            while (1)
            {
              char v68 = v67;
              uint64_t v69 = *(void *)(a1 + 16);
              uint64_t v70 = *(void *)(v69 + 120);
              if (!v70)
              {
                if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
                {
                  LODWORD(a2) = -1;
LABEL_137:
                  CGPDFSourceUngetc(*(void **)(a1 + 16), a2);
LABEL_138:
                  LOBYTE(v59) = v66;
LABEL_144:
                  unint64_t v75 = *(void *)(a1 + 24);
                  unint64_t v76 = *(void *)(a1 + 32);
                  BOOL v77 = *(unsigned char **)(a1 + 40);
                  if (v75 < v76)
                  {
LABEL_147:
                    *(void *)(a1 + 24) = v75 + 1;
                    v77[v75] = v59;
                    goto LABEL_88;
                  }
                  size_t v78 = 2 * v76 + 128;
                  *(void *)(a1 + 32) = v78;
                  BOOL v77 = malloc_type_realloc(v77, v78, 0x33EA2F66uLL);
                  *(void *)(a1 + 40) = v77;
                  if (v77)
                  {
                    unint64_t v75 = *(void *)(a1 + 24);
                    goto LABEL_147;
                  }
LABEL_334:
                  _CGHandleAssert("lex_grow_buffer", 55, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFLexer.c", "lexer->buffer != NULL", "lexer buffer missing", a6, a7, a8, v172);
                }
                uint64_t v70 = *(void *)(v69 + 120);
              }
              char v71 = *(unsigned __int8 **)(v69 + 128);
              *(void *)(v69 + 120) = v70 - 1;
              *(void *)(v69 + 128) = v71 + 1;
              a2 = *v71;
              if ((a2 - 56) <= 0xFFFFFFF7) {
                goto LABEL_137;
              }
              char v66 = a2 + 8 * v66 - 48;
              char v67 = 1;
              if (v68) {
                goto LABEL_138;
              }
            }
          }
          if (*v62 <= 0x6Du)
          {
            if (v59 == 98)
            {
              LOBYTE(v59) = 8;
            }
            else if (v59 == 102)
            {
              LOBYTE(v59) = 12;
            }
            goto LABEL_144;
          }
          if (v59 != 110)
          {
            if (v59 == 114)
            {
              LOBYTE(v59) = 13;
            }
            else if (v59 == 116)
            {
              LOBYTE(v59) = 9;
            }
            goto LABEL_144;
          }
LABEL_143:
          LOBYTE(v59) = 10;
          goto LABEL_144;
        }
      }
      if (v59 != 13)
      {
        if (v59 == 40)
        {
          ++v55;
          goto LABEL_144;
        }
        if (v59 != 41) {
          goto LABEL_144;
        }
        if (v55)
        {
          if (--v55)
          {
            LOBYTE(v59) = 41;
            goto LABEL_144;
          }
          uint64_t v14 = 8;
        }
        else
        {
          unint64_t v167 = *(void *)(a1 + 24);
          unint64_t v168 = *(void *)(a1 + 32);
          double v169 = *(void **)(a1 + 40);
          if (v167 >= v168)
          {
            size_t v170 = 2 * v168 + 128;
            *(void *)(a1 + 32) = v170;
            double v169 = malloc_type_realloc(v169, v170, 0x33EA2F66uLL);
            *(void *)(a1 + 40) = v169;
            if (!v169) {
              goto LABEL_334;
            }
            unint64_t v167 = *(void *)(a1 + 24);
          }
          *(void *)(a1 + 24) = v167 + 1;
          *((unsigned char *)v169 + v167) = 41;
LABEL_327:
          uint64_t v14 = 1;
        }
        create_string_object(a1, 0);
        return v14;
      }
      uint64_t v72 = *(void *)(a1 + 16);
      uint64_t v73 = *(void *)(v72 + 120);
      if (v73) {
        goto LABEL_130;
      }
      if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v73 = *(void *)(v72 + 120);
LABEL_130:
        long long v74 = *(unsigned __int8 **)(v72 + 128);
        *(void *)(v72 + 120) = v73 - 1;
        *(void *)(v72 + 128) = v74 + 1;
        a2 = *v74;
        if (a2 == 10) {
          goto LABEL_143;
        }
      }
      else
      {
        LODWORD(a2) = -1;
      }
      CGPDFSourceUngetc(*(void **)(a1 + 16), a2);
      goto LABEL_143;
    case ')':
      unint64_t v79 = *(void *)(a1 + 24);
      unint64_t v80 = *(void *)(a1 + 32);
      if (v79 >= v80)
      {
        size_t v118 = 2 * v80 + 128;
        *(void *)(a1 + 32) = v118;
        uint64_t v81 = malloc_type_realloc(*(void **)(a1 + 40), v118, 0x33EA2F66uLL);
        *(void *)(a1 + 40) = v81;
        if (!v81) {
          goto LABEL_334;
        }
        unint64_t v79 = *(void *)(a1 + 24);
      }
      else
      {
        uint64_t v81 = *(unsigned char **)(a1 + 40);
      }
      *(void *)(a1 + 24) = v79 + 1;
      v81[v79] = 41;
      goto LABEL_288;
    case '+':
    case '-':
    case '.':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      endptr = 0;
      if (v13 == 45 || v13 == 43)
      {
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v17 = *(void *)(v16 + 120);
        if (!v17)
        {
          if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
          {
            unint64_t v25 = 0;
LABEL_75:
            unint64_t v44 = *(void *)(a1 + 24);
            unint64_t v45 = *(void *)(a1 + 32);
            if (v44 >= v45)
            {
              size_t v47 = 2 * v45 + 128;
              *(void *)(a1 + 32) = v47;
              int v46 = malloc_type_realloc(*(void **)(a1 + 40), v47, 0x33EA2F66uLL);
              *(void *)(a1 + 40) = v46;
              if (!v46) {
                goto LABEL_334;
              }
              unint64_t v44 = *(void *)(a1 + 24);
            }
            else
            {
              int v46 = *(unsigned char **)(a1 + 40);
            }
            *(void *)(a1 + 24) = v44 + 1;
            v46[v44] = v13;
LABEL_80:
            if (v25)
            {
              uint64_t v48 = nptr;
              do
              {
                char v50 = *v48++;
                char v49 = v50;
                unint64_t v51 = *(void *)(a1 + 24);
                unint64_t v52 = *(void *)(a1 + 32);
                char v53 = *(void **)(a1 + 40);
                if (v51 >= v52)
                {
                  size_t v54 = 2 * v52 + 128;
                  *(void *)(a1 + 32) = v54;
                  char v53 = malloc_type_realloc(v53, v54, 0x33EA2F66uLL);
                  *(void *)(a1 + 40) = v53;
                  if (!v53) {
                    goto LABEL_334;
                  }
                  unint64_t v51 = *(void *)(a1 + 24);
                }
                *(void *)(a1 + 24) = v51 + 1;
                *((unsigned char *)v53 + v51) = v49;
                --v25;
              }
              while (v25);
            }
LABEL_86:
            skip_to_delimiter((uint64_t *)a1, v18, a3, a4, a5, a6, a7, a8);
LABEL_288:
            create_string_object(a1, 0);
            return 1;
          }
          uint64_t v17 = *(void *)(v16 + 120);
        }
        uint64_t v19 = *(unsigned __int8 **)(v16 + 128);
        *(void *)(v16 + 120) = v17 - 1;
        *(void *)(v16 + 128) = v19 + 1;
        uint64_t v20 = *v19;
      }
      else
      {
        uint64_t v20 = v13;
        LODWORD(v13) = 0;
      }
      for (i = v20 == 48; v20 == 48; uint64_t v20 = *v24)
      {
        uint64_t v22 = *(void *)(a1 + 16);
        uint64_t v23 = *(void *)(v22 + 120);
        if (!v23)
        {
          if (!CGPDFSourceRefill(*(void *)(a1 + 16), v20, a3, a4, a5, a6, a7, a8))
          {
            uint64_t v26 = 0;
            LODWORD(v20) = -1;
            unsigned int v40 = -1;
            goto LABEL_69;
          }
          uint64_t v23 = *(void *)(v22 + 120);
        }
        double v24 = *(unsigned __int8 **)(v22 + 128);
        *(void *)(v22 + 120) = v23 - 1;
        *(void *)(v22 + 128) = v24 + 1;
      }
      if ((v20 - 48) > 9)
      {
        unint64_t v25 = 0;
        if (v20 != 46)
        {
          unsigned int v40 = -1;
          uint64_t v26 = 0;
          goto LABEL_73;
        }
        uint64_t v26 = 0;
        goto LABEL_43;
      }
      unint64_t v25 = 0;
      uint64_t v26 = 0;
      do
      {
        if (v25 <= 0x4B) {
          nptr[v25++] = v20;
        }
        uint64_t v26 = 10 * v26 + v20 - 48;
        uint64_t v27 = *(void *)(a1 + 16);
        uint64_t v28 = *(void *)(v27 + 120);
        if (!v28)
        {
          if (!CGPDFSourceRefill(*(void *)(a1 + 16), v20, a3, a4, a5, a6, a7, a8))
          {
            unsigned int v40 = -1;
            LODWORD(v20) = -1;
            goto LABEL_227;
          }
          uint64_t v28 = *(void *)(v27 + 120);
        }
        int v29 = *(unsigned __int8 **)(v27 + 128);
        *(void *)(v27 + 120) = v28 - 1;
        *(void *)(v27 + 128) = v29 + 1;
        uint64_t v20 = *v29;
      }
      while ((v20 - 48) < 0xA);
      if (v20 != 46)
      {
        unsigned int v40 = -1;
        goto LABEL_227;
      }
      BOOL i = 1;
      if (v25 <= 0x4B) {
LABEL_43:
      }
        nptr[v25++] = 46;
      uint64_t v30 = *(void *)(a1 + 16);
      uint64_t v31 = *(void *)(v30 + 120);
      if (!v31)
      {
        if (!CGPDFSourceRefill(*(void *)(a1 + 16), v20, a3, a4, a5, a6, a7, a8)) {
          goto LABEL_71;
        }
        uint64_t v31 = *(void *)(v30 + 120);
      }
      int v32 = *(unsigned __int8 **)(v30 + 128);
      *(void *)(v30 + 120) = v31 - 1;
      *(void *)(v30 + 128) = v32 + 1;
      uint64_t v20 = *v32;
      if (v20 != 45) {
        goto LABEL_52;
      }
      uint64_t v33 = *(void *)(a1 + 16);
      uint64_t v34 = *(void *)(v33 + 120);
      if (!v34)
      {
        if (CGPDFSourceRefill(*(void *)(a1 + 16), v20, a3, a4, a5, a6, a7, a8))
        {
          uint64_t v34 = *(void *)(v33 + 120);
          goto LABEL_51;
        }
LABEL_71:
        LODWORD(v20) = -1;
        goto LABEL_72;
      }
LABEL_51:
      __double2 v35 = *(unsigned __int8 **)(v33 + 128);
      *(void *)(v33 + 120) = v34 - 1;
      *(void *)(v33 + 128) = v35 + 1;
      uint64_t v20 = *v35;
LABEL_52:
      if ((v20 - 48) > 9)
      {
LABEL_72:
        unsigned int v40 = v25;
LABEL_73:
        if (i) {
          goto LABEL_227;
        }
        CGPDFSourceUngetc(*(void **)(a1 + 16), v20);
        if (!v13) {
          goto LABEL_80;
        }
        goto LABEL_75;
      }
      unint64_t v36 = v25;
      while (1)
      {
        if (v36 <= 0x4B) {
          nptr[v36++] = v20;
        }
        uint64_t v26 = 10 * v26 + v20 - 48;
        uint64_t v37 = *(void *)(a1 + 16);
        uint64_t v38 = *(void *)(v37 + 120);
        if (v38) {
          goto LABEL_59;
        }
        if (!CGPDFSourceRefill(*(void *)(a1 + 16), v20, a3, a4, a5, a6, a7, a8)) {
          break;
        }
        uint64_t v38 = *(void *)(v37 + 120);
LABEL_59:
        double v39 = *(unsigned __int8 **)(v37 + 128);
        *(void *)(v37 + 120) = v38 - 1;
        *(void *)(v37 + 128) = v39 + 1;
        uint64_t v20 = *v39;
        if ((v20 - 48) >= 0xA) {
          goto LABEL_226;
        }
      }
      LODWORD(v20) = -1;
LABEL_226:
      unsigned int v40 = v25;
      unint64_t v25 = v36;
LABEL_227:
      if (v25 > 9)
      {
LABEL_239:
        uint64_t v129 = (v20 + 1);
        if (v129 <= 0x3F)
        {
          if (((1 << (v20 + 1)) & 0x200006C03) != 0) {
            goto LABEL_248;
          }
          if (((1 << (v20 + 1)) & 0xA001064000000000) != 0)
          {
LABEL_247:
            CGPDFSourceUngetc(*(void **)(a1 + 16), v20);
LABEL_248:
            nptr[v25] = 0;
            if (v40 != -1)
            {
              if (v25 == 1)
              {
                double v126 = 0.0;
                if (nptr[0] == 46) {
                  goto LABEL_261;
                }
              }
              goto LABEL_259;
            }
            if (v25 > 9)
            {
              *__error() = 0;
              intmax_t v132 = strtoimax_l(nptr, &endptr, 10, 0);
              if (endptr == nptr || *endptr) {
                goto LABEL_335;
              }
              intmax_t v133 = v132;
              if (*__error() == 34)
              {
LABEL_259:
                double v126 = strtod_l(nptr, &endptr, 0);
                if (endptr != nptr && !*endptr)
                {
LABEL_261:
                  uint64_t v125 = *(void *)(a1 + 48);
                  *(_DWORD *)(v125 + 8) = 4;
                  if (v13 == 45) {
                    double v126 = -v126;
                  }
LABEL_263:
                  *(double *)(v125 + 32) = v126;
                  return 5;
                }
LABEL_335:
                abort();
              }
              uint64_t v130 = *(void *)(a1 + 48);
              *(_DWORD *)(v130 + 8) = 3;
              if (v13 == 45) {
                uint64_t v131 = -v133;
              }
              else {
                uint64_t v131 = v133;
              }
            }
            else
            {
              uint64_t v130 = *(void *)(a1 + 48);
              *(_DWORD *)(v130 + 8) = 3;
              if (v13 == 45) {
                uint64_t v131 = -v26;
              }
              else {
                uint64_t v131 = v26;
              }
            }
            *(void *)(v130 + 32) = v131;
            return 4;
          }
          if (v129 == 47)
          {
            if ((v40 & 0x80000000) != 0) {
              _CGHandleAssert("read_number", 823, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFLexer.c", "fraction_start >= 0", "unexpected program flow. fraction start = %d", a6, a7, a8, v40);
            }
LABEL_264:
            CGPDFSourceUngetc(*(void **)(a1 + 16), v20);
            if (v13)
            {
              unint64_t v134 = *(void *)(a1 + 24);
              unint64_t v135 = *(void *)(a1 + 32);
              if (v134 >= v135)
              {
                size_t v137 = 2 * v135 + 128;
                *(void *)(a1 + 32) = v137;
                uint64_t v136 = malloc_type_realloc(*(void **)(a1 + 40), v137, 0x33EA2F66uLL);
                *(void *)(a1 + 40) = v136;
                if (!v136) {
                  goto LABEL_334;
                }
                unint64_t v134 = *(void *)(a1 + 24);
              }
              else
              {
                uint64_t v136 = *(unsigned char **)(a1 + 40);
              }
              *(void *)(a1 + 24) = v134 + 1;
              v136[v134] = v13;
            }
            long long v138 = nptr;
            do
            {
              char v140 = *v138++;
              char v139 = v140;
              unint64_t v141 = *(void *)(a1 + 24);
              unint64_t v142 = *(void *)(a1 + 32);
              long long v143 = *(void **)(a1 + 40);
              if (v141 >= v142)
              {
                size_t v144 = 2 * v142 + 128;
                *(void *)(a1 + 32) = v144;
                long long v143 = malloc_type_realloc(v143, v144, 0x33EA2F66uLL);
                *(void *)(a1 + 40) = v143;
                if (!v143) {
                  goto LABEL_334;
                }
                unint64_t v141 = *(void *)(a1 + 24);
              }
              *(void *)(a1 + 24) = v141 + 1;
              *((unsigned char *)v143 + v141) = v139;
              --v25;
            }
            while (v25);
            goto LABEL_86;
          }
        }
        if ((v20 - 91) > 0x22 || ((1 << (v20 - 91)) & 0x500000005) == 0) {
          goto LABEL_264;
        }
        goto LABEL_247;
      }
      if (v20 > 0x20 || ((1 << v20) & 0x100002400) == 0)
      {
        if (!v25)
        {
LABEL_69:
          nptr[0] = 48;
          unint64_t v25 = 1;
        }
        goto LABEL_239;
      }
      if ((v40 & 0x80000000) == 0)
      {
        double v124 = read_number_powers_of_10[v25 - v40] * (double)v26;
        uint64_t v125 = *(void *)(a1 + 48);
        *(_DWORD *)(v125 + 8) = 4;
        double v126 = -v124;
        if (v13 != 45) {
          double v126 = v124;
        }
        goto LABEL_263;
      }
      if (v13 == 45) {
        uint64_t v127 = -v26;
      }
      else {
        uint64_t v127 = v26;
      }
      uint64_t v128 = *(void *)(a1 + 48);
      *(_DWORD *)(v128 + 8) = 3;
      *(void *)(v128 + 32) = v127;
      return 4;
    case '/':
      uint64_t v82 = *(void *)(a1 + 16);
      uint64_t v83 = *(void *)(v82 + 120);
      if (v83) {
        goto LABEL_153;
      }
      if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v83 = *(void *)(v82 + 120);
LABEL_153:
        int v84 = *(unsigned __int8 **)(v82 + 128);
        *(void *)(v82 + 120) = v83 - 1;
        *(void *)(v82 + 128) = v84 + 1;
        int v85 = *v84;
      }
      else
      {
        int v85 = -1;
      }
LABEL_154:
      if (v85 > 46)
      {
        if (((v85 - 47) > 0x2E || ((1 << (v85 - 47)) & 0x50000000A001) == 0)
          && v85 != 123
          && v85 != 125)
        {
          goto LABEL_181;
        }
LABEL_213:
        CGPDFSourceUngetc(*(void **)(a1 + 16), v85);
      }
      else
      {
        if (v85 > 31)
        {
          switch(v85)
          {
            case ' ':
              goto LABEL_214;
            case '#':
              int v85 = 0;
              char v86 = 1;
              break;
            case '%':
            case '(':
            case ')':
              goto LABEL_213;
            default:
              goto LABEL_181;
          }
          while (1)
          {
            char v87 = v86;
            uint64_t v88 = *(void *)(a1 + 16);
            uint64_t v89 = *(void *)(v88 + 120);
            if (!v89)
            {
              if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
              {
                int v91 = -1;
LABEL_180:
                pdf_error("invalid #-escape sequence.");
                CGPDFSourceUngetc(*(void **)(a1 + 16), v91);
                LOBYTE(v85) = 35;
                goto LABEL_181;
              }
              uint64_t v89 = *(void *)(v88 + 120);
            }
            int v90 = *(unsigned __int8 **)(v88 + 128);
            *(void *)(v88 + 120) = v89 - 1;
            *(void *)(v88 + 128) = v90 + 1;
            int v91 = *v90;
            if ((v91 - 48) >= 0xA)
            {
              if ((v91 - 65) >= 6)
              {
                if ((v91 - 97) >= 6) {
                  goto LABEL_180;
                }
                int v92 = -87;
              }
              else
              {
                int v92 = -55;
              }
            }
            else
            {
              int v92 = -48;
            }
            char v86 = 0;
            int v85 = v91 + 16 * v85 + v92;
            if ((v87 & 1) == 0)
            {
              if ((v85 - 256) < 0xFFFFFF01)
              {
                create_string_object(a1, 0);
                goto LABEL_288;
              }
LABEL_181:
              unint64_t v93 = *(void *)(a1 + 24);
              unint64_t v94 = *(void *)(a1 + 32);
              unsigned int v95 = *(void **)(a1 + 40);
              if (v93 >= v94)
              {
                size_t v96 = 2 * v94 + 128;
                *(void *)(a1 + 32) = v96;
                unsigned int v95 = malloc_type_realloc(v95, v96, 0x33EA2F66uLL);
                *(void *)(a1 + 40) = v95;
                if (!v95) {
                  goto LABEL_334;
                }
                unint64_t v93 = *(void *)(a1 + 24);
              }
              *(void *)(a1 + 24) = v93 + 1;
              *((unsigned char *)v95 + v93) = v85;
              uint64_t v97 = *(void *)(a1 + 16);
              uint64_t v98 = *(void *)(v97 + 120);
              if (!v98)
              {
                int v85 = -1;
                if (!CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)) {
                  goto LABEL_154;
                }
                uint64_t v98 = *(void *)(v97 + 120);
              }
              int v99 = *(unsigned __int8 **)(v97 + 128);
              *(void *)(v97 + 120) = v98 - 1;
              *(void *)(v97 + 128) = v99 + 1;
              int v85 = *v99;
              goto LABEL_154;
            }
          }
        }
        if ((v85 + 1) >= 2 && (v85 - 9) >= 2 && (v85 - 12) >= 2) {
          goto LABEL_181;
        }
      }
LABEL_214:
      uint64_t v116 = *(void *)(a1 + 48);
      *(_DWORD *)(v116 + 8) = 5;
      *(unsigned char *)(v116 + 12) |= 1u;
      uint64_t v117 = *(void *)(a1 + 48);
      *(void *)(v117 + 16) = 0;
      *(void *)(v117 + 24) = 0;
      *(void *)(v8 + 32) = strndup(*(const char **)(a1 + 40), *(void *)(a1 + 24));
      return 6;
    case '<':
      uint64_t v100 = *(void *)(a1 + 16);
      uint64_t v101 = *(void *)(v100 + 120);
      if (v101) {
        goto LABEL_191;
      }
      if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v101 = *(void *)(v100 + 120);
LABEL_191:
        uint64_t v102 = *(unsigned __int8 **)(v100 + 128);
        *(void *)(v100 + 120) = v101 - 1;
        *(void *)(v100 + 128) = v102 + 1;
        uint64_t v103 = *v102;
        if (v103 == 60) {
          return 9;
        }
      }
      else
      {
        uint64_t v103 = 0xFFFFFFFFLL;
      }
      return read_hex_string((void *)a1, v103, a3, a4, a5, a6, a7, a8);
    case '>':
      unint64_t v104 = *(void *)(a1 + 24);
      unint64_t v105 = *(void *)(a1 + 32);
      if (v104 >= v105)
      {
        size_t v119 = 2 * v105 + 128;
        *(void *)(a1 + 32) = v119;
        uint64_t v106 = malloc_type_realloc(*(void **)(a1 + 40), v119, 0x33EA2F66uLL);
        *(void *)(a1 + 40) = v106;
        if (!v106) {
          goto LABEL_334;
        }
        unint64_t v104 = *(void *)(a1 + 24);
      }
      else
      {
        uint64_t v106 = *(unsigned char **)(a1 + 40);
      }
      *(void *)(a1 + 24) = v104 + 1;
      v106[v104] = 62;
      uint64_t v120 = *(void *)(a1 + 16);
      uint64_t v121 = *(void *)(v120 + 120);
      if (v121) {
        goto LABEL_223;
      }
      if (CGPDFSourceRefill(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
      {
        uint64_t v121 = *(void *)(v120 + 120);
LABEL_223:
        unsigned int v122 = *(unsigned __int8 **)(v120 + 128);
        *(void *)(v120 + 120) = v121 - 1;
        *(void *)(v120 + 128) = v122 + 1;
        int v123 = *v122;
        if (v123 == 62) {
          return 10;
        }
      }
      else
      {
        int v123 = -1;
      }
      CGPDFSourceUngetc(*(void **)(a1 + 16), v123);
      goto LABEL_288;
    default:
      goto LABEL_199;
  }
}

void *CGPDFSourceUngetc(void *result, int a2)
{
  if (result)
  {
    char v2 = a2;
    if (a2 != -1)
    {
      uint64_t v3 = result;
      BOOL result = (void *)result[18];
      if (result)
      {
        size_t v4 = v3[17];
        if (v3[15] >= v4)
        {
          if (result == (void *)((char *)v3 + 153))
          {
            uint64_t v11 = (char *)malloc_type_malloc(0x80uLL, 0x566C45D1uLL);
            BOOL result = (void *)__CFSetLastAllocationEventName();
            if (!v11) {
              return result;
            }
            uint64_t v12 = 0;
            v3[17] = 128;
            v3[18] = v11;
            *((unsigned char *)v3 + 152) = 1;
            uint64_t v5 = v11 + 96;
            do
            {
              v5[v12] = *((unsigned char *)v3 + v12 + 153);
              ++v12;
            }
            while (v12 != 32);
          }
          else
          {
            BOOL result = malloc_type_realloc(result, 2 * v4, 0x68DD979uLL);
            if (!result) {
              return result;
            }
            uint64_t v8 = result;
            uint64_t v5 = (char *)result + v4;
            BOOL result = memmove((char *)result + v4, result, v4);
            v3[17] = 2 * v4;
            v3[18] = v8;
          }
        }
        else
        {
          uint64_t v5 = (char *)v3[16];
        }
        v3[16] = v5 - 1;
        *(v5 - 1) = v2;
        ++v3[15];
      }
      else
      {
        *((unsigned char *)v3 + 208) = 0;
        unint64_t v6 = v3[11];
        unint64_t v7 = v3[16];
        if (v6 && v7 > v6 && *(unsigned __int8 *)(v7 - 1) == a2)
        {
          ++v3[15];
          v3[16] = v7 - 1;
        }
        else
        {
          *((unsigned char *)v3 + 184) = a2;
          BOOL v9 = v3 + 23;
          uint64_t v10 = *(v9 - 8);
          v9[1] = v7;
          v9[2] = v10;
          *(v9 - 6) = 32;
          *(v9 - 5) = (char *)v9 - 31;
          *((unsigned char *)v9 - 32) = 0;
          *(v9 - 8) = 1;
          *(v9 - 7) = v9;
        }
      }
    }
  }
  return result;
}

void pdf_scanner_handle_xname(uint64_t a1)
{
  size_t v18 = 0;
  operator_name_string = (char *)pdf_lexer_get_operator_name_string(*(void *)(a1 + 64), &v18);
  int v3 = *(_DWORD *)(a1 + 72);
  int v17 = 0;
  size_t v4 = v18;
  int v5 = CGPDFGetOperatorForName(operator_name_string, v18, &v17);
  if (v5)
  {
    unint64_t v6 = *(void (**)(uint64_t, void))(*(void *)(a1 + 24) + 8 * v5);
    if (!v6) {
      goto LABEL_18;
    }
    uint64_t v7 = *(void *)(a1 + 144);
    if (!v7 || *(void *)(v7 + 8))
    {
LABEL_5:
      v6(a1, *(void *)(a1 + 16));
      int v8 = *(_DWORD *)(a1 + 72);
      int v9 = v8;
      int v10 = v3 - v8;
      if (v3 > v8)
      {
        uint64_t v11 = 40 * v8;
        do
        {
          uint64_t v12 = *(void *)(a1 + 80) + v11;
          if ((*(_DWORD *)(v12 + 8) - 5) <= 4) {
            pdf_object_release_compound_value(v12);
          }
          v11 += 40;
          --v10;
        }
        while (v10);
        int v9 = *(_DWORD *)(a1 + 72);
      }
      goto LABEL_19;
    }
    if (operator_name_string)
    {
      if (!strncmp(operator_name_string, "EMC", v4)) {
        goto LABEL_5;
      }
      if (!strncmp(operator_name_string, "q", v4)) {
        goto LABEL_5;
      }
      int v13 = strncmp(operator_name_string, "Q", v4);
      int v9 = v3;
      if (!v13) {
        goto LABEL_5;
      }
    }
    else
    {
LABEL_18:
      int v9 = v3;
    }
LABEL_19:
    int v14 = v17 - v3 + v9;
    if (v14 >= 1)
    {
      do
      {
        BOOL v15 = __OFSUB__(v9--, 1);
        if (v9 < 0 != v15) {
          break;
        }
        uint64_t v16 = *(void *)(a1 + 80);
        if ((*(_DWORD *)(v16 + 40 * v9 + 8) - 5) <= 4)
        {
          pdf_object_release_compound_value(v16 + 40 * v9);
          int v9 = *(_DWORD *)(a1 + 72) - 1;
        }
        *(_DWORD *)(a1 + 72) = v9;
        --v14;
      }
      while (v14);
    }
    return;
  }
  if (!*(_DWORD *)(a1 + 88)) {
}
  }

uint64_t CGPDFGetOperatorForName(char *__s, size_t a2, _DWORD *a3)
{
  if (!a2) {
    a2 = strlen(__s);
  }
  if (a2 > 0xFFFFFFFE) {
    return 0;
  }
  size_t v5 = (a2 - 1);
  if (v5 > 2) {
    return 0;
  }
  int v6 = a2 == 1 ? 1 : hash_asso_values_7750[__s[1] + 1] + a2;
  uint64_t v7 = *__s;
  uint64_t v8 = v6 + hash_asso_values_7750[v7];
  if (v8 > 0x48) {
    return 0;
  }
  int v9 = (const char *)*((void *)&lookup_operator_wordlist + 2 * v6 + 2 * hash_asso_values_7750[v7]);
  if (v7 != *(unsigned __int8 *)v9 || strncmp(__s + 1, v9 + 1, v5)) {
    return 0;
  }
  if (a3) {
    *a3 = *((_DWORD *)&lookup_operator_wordlist + 4 * v8 + 3);
  }
  return *((unsigned int *)&lookup_operator_wordlist + 4 * v8 + 2);
}

const char *pdf_lexer_get_operator_name_string(uint64_t a1, size_t *a2)
{
  int v2 = *(_DWORD *)(a1 + 56);
  if (v2 == 1)
  {
    size_t v4 = *(const char **)(a1 + 64);
    *a2 = *(void *)(a1 + 72);
  }
  else if (v2)
  {
    return 0;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    if (v3 && *(_DWORD *)(v3 + 8) == 5) {
      size_t v4 = *(const char **)(v3 + 32);
    }
    else {
      size_t v4 = 0;
    }
    *a2 = strlen(v4);
  }
  return v4;
}

BOOL CGPDFScannerPopNumber(CGPDFScannerRef scanner, CGPDFReal *value)
{
  int v2 = *((_DWORD *)scanner + 18);
  if (v2 <= 0)
  {
    pdf_error("stack underflow.", value);
  }
  else
  {
    uint64_t v3 = *((void *)scanner + 10);
    unsigned int v4 = v2 - 1;
    *((_DWORD *)scanner + 18) = v4;
    if (v3)
    {
      int v5 = *(_DWORD *)(v3 + 40 * v4 + 8);
      switch(v5)
      {
        case 12:
          goto LABEL_6;
        case 4:
          double v6 = *(double *)(v3 + 40 * v4 + 32);
          if (!value) {
            return 1;
          }
          goto LABEL_7;
        case 3:
LABEL_6:
          double v6 = (double)*(uint64_t *)(v3 + 40 * v4 + 32);
          if (!value) {
            return 1;
          }
LABEL_7:
          void *value = v6;
          return 1;
      }
    }
  }
  return 0;
}

unsigned int *CG::DisplayListEntryPath::_hash(uint64_t a1, unsigned int *a2)
{
  __srdouble c = CGPathGetNumberOfElements(*(char **)(a1 + 88));
  XXH64_update(a2, (char *)&__src, 8uLL);
  XXH64_update(a2, (char *)(a1 + 96), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 80), 4uLL);

  return CG::DisplayListEntry::_hash(a1, a2);
}

void CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      BOOL v15 = (const CGPath *)*((void *)c + 21);
      if (v15 && !CGPathIsEmpty(v15))
      {
        uint64_t v23 = (CGPath *)*((void *)c + 21);
        double v24 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
        CGPathAddCurveToPoint(v23, v24, cp1x, cp1y, cp2x, cp2y, x, y);
      }
      else
      {
        CGPostError((uint64_t)"%s: no current point.", v7, v8, v9, v10, v11, v12, v13, (char)"CGContextAddCurveToPoint");
      }
      return;
    }
    CGContextRef v22 = c;
  }
  else
  {
    CGContextRef v22 = 0;
  }

  handle_invalid_context((char)"CGContextAddCurveToPoint", (uint64_t)v22, v8, v9, v10, v11, v12, v13);
}

void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v9 = (const CGPath *)*((void *)c + 21);
      if (v9 && !CGPathIsEmpty(v9))
      {
        uint64_t v11 = (double *)*((void *)c + 21);
        *((void *)c + 21) = 0;
        double v12 = *(double *)(*(void *)(*((void *)c + 12) + 128) + 8);
        if (v12 > 0.0 || v12 == -1.0905473e16)
        {
          if (mode != -1)
          {
LABEL_15:
            CGPathDrawingMode v13 = mode;
LABEL_16:
            v15[0] = MEMORY[0x1E4F143A8];
            v15[1] = 0x40000000;
            v15[2] = __CGContextDrawPath_block_invoke;
            v15[3] = &__block_descriptor_tmp_14364;
            v15[4] = c;
            CGPathDrawingMode v16 = v13;
            draw_path(v13, v11, (uint64_t)v15);
          }
        }
        else
        {
          CGPathDrawingMode v13 = kCGPathFill;
          switch(mode)
          {
            case -1:
            case 2:
              break;
            case 3:
              goto LABEL_16;
            case 4:
              CGPathDrawingMode v13 = kCGPathEOFill;
              goto LABEL_16;
            default:
              goto LABEL_15;
          }
        }
        if (v11) {
          CFRelease(v11);
        }
      }
      return;
    }
    CGContextRef v14 = c;
  }
  else
  {
    CGContextRef v14 = 0;
  }

  handle_invalid_context((char)"CGContextDrawPath", (uint64_t)v14, v2, v3, v4, v5, v6, v7);
}

BOOL CGPathIsEmpty(CGPathRef path)
{
  if (!path) {
    return 1;
  }
  if (CGPathDisableTypeValidation) {
    return (*((_DWORD *)path + 4) - 10) < 0xFFFFFFF7;
  }
  CFTypeID v2 = CFGetTypeID(path);
  if (v2 == CGPathGetTypeID()) {
    return (*((_DWORD *)path + 4) - 10) < 0xFFFFFFF7;
  }
  return 1;
}

uint64_t CGContextDelegateDrawPath(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef cf)
{
  if (result)
  {
    if (cf && ((uint64_t v9 = result, CGPathDisableTypeValidation) || (v10 = CFGetTypeID(cf), v10 == CGPathGetTypeID())))
    {
      uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef))(v9 + 72);
      if (v11)
      {
        return v11(v9, a2, a3, a4, cf);
      }
      else
      {
        return 1006;
      }
    }
    else
    {
      return 1001;
    }
  }
  return result;
}

uint64_t draw_path(int a1, double *a2, uint64_t a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (a1 == 2 && CGPathGetNumberOfElements((char *)a2) >= 0x101)
  {
    uint64_t v38 = 0;
    double v39 = &v38;
    uint64_t v40 = 0x2000000000;
    int v41 = 0;
    uint64_t v34 = 0;
    __double2 v35 = &v34;
    uint64_t v36 = 0x2000000000;
    int v37 = 0;
    v32[0] = 0;
    v32[1] = v32;
    v32[2] = 0x2000000000;
    int v33 = 0;
    uint64_t v28 = 0;
    int v29 = (int *)&v28;
    uint64_t v30 = 0x2000000000;
    int v31 = 0;
    uint64_t v24 = 0;
    unint64_t v25 = &v24;
    uint64_t v26 = 0x2000000000;
    int v27 = 0;
    v23[0] = 0;
    v23[1] = v23;
    void v23[2] = 0x2800000000;
    v23[3] = 0;
    v23[4] = 0;
    v22[0] = 0;
    v22[1] = v22;
    v22[2] = 0x2000000000;
    v22[3] = 0;
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 0x40000000;
    void v21[2] = __draw_path_block_invoke;
    v21[3] = &unk_1E52CC430;
    v21[4] = &v34;
    v21[5] = v23;
    v21[6] = v32;
    v21[7] = &v28;
    v21[8] = &v24;
    v21[9] = v22;
    CGPathApplyWithBlock2(a2, (uint64_t)v21);
    if (*((_DWORD *)v35 + 6) == 1 && v29[6] <= 1 && !*((_DWORD *)v25 + 6))
    {
      uint64_t v17 = 0;
      size_t v18 = &v17;
      uint64_t v19 = 0x2000000000;
      uint64_t v20 = 0;
      uint64_t v13 = 0;
      CGContextRef v14 = &v13;
      uint64_t v15 = 0x2000000000;
      CGMutablePathRef Mutable = 0;
      CGMutablePathRef Mutable = CGPathCreateMutable();
      MEMORY[0x1F4188790](Mutable, v8);
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 0x40000000;
      void v12[2] = __draw_path_block_invoke_2;
      v12[3] = &unk_1E52CC458;
      v12[6] = &v17;
      v12[7] = &v13;
      v12[8] = &v38;
      v12[9] = v11;
      v12[4] = a3;
      v12[5] = v23;
      CGPathApplyWithBlock2(a2, (uint64_t)v12);
      size_t v9 = v18[3];
      if (v9)
      {
        CGPathAddLines((CGMutablePathRef)v14[3], 0, v11, v9);
        (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v14[3]);
      }
      CFTypeID v10 = (const void *)v14[3];
      if (v10) {
        CFRelease(v10);
      }
      uint64_t v5 = *((unsigned int *)v39 + 6);
      _Block_object_dispose(&v13, 8);
      _Block_object_dispose(&v17, 8);
    }
    else
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, double *))(a3 + 16))(a3, a2);
    }
    _Block_object_dispose(v22, 8);
    _Block_object_dispose(v23, 8);
    _Block_object_dispose(&v24, 8);
    _Block_object_dispose(&v28, 8);
    _Block_object_dispose(v32, 8);
    _Block_object_dispose(&v34, 8);
    _Block_object_dispose(&v38, 8);
    return v5;
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t, double *))(a3 + 16);
    return v7(a3, a2);
  }
}

uint64_t __CGContextDrawPath_block_invoke(uint64_t a1, CFTypeRef cf)
{
  return CGContextDelegateDrawPath(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 112), *(void *)(*(void *)(a1 + 32) + 96), *(unsigned int *)(a1 + 40), cf);
}

unint64_t CG::Path::element_count(CG::Path *this)
{
  switch(*(_DWORD *)this)
  {
    case 1:
      unint64_t v1 = 5;
      break;
    case 2:
    case 3:
      unint64_t v1 = 10;
      break;
    case 4:
      if (*((unsigned char *)this + 57)) {
        unint64_t v1 = 6;
      }
      else {
        unint64_t v1 = 5;
      }
      break;
    case 5:
      unint64_t v1 = 2;
      break;
    case 6:
      unint64_t v1 = (unint64_t)(ceil(fmax(*((double *)this + 7) + -0.00000001, 0.0) / 1.57079633) + 1.0);
      break;
    case 7:
      CG::Path::Path((CG::Path *)v3, this);
      if (LODWORD(v3[0]) != 9) {
        CG::Path::convert_to_huge_((CG::Path *)v3);
      }
      unint64_t v1 = CG::Path::element_count((CG::Path *)v3);
      CG::Path::~Path(v3);
      break;
    case 8:
      unint64_t v1 = *((unsigned __int16 *)this + 5);
      break;
    case 9:
      unint64_t v1 = *((void *)this + 2);
      break;
    default:
      unint64_t v1 = 0;
      break;
  }
  return v1;
}

void sub_184C52F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

unint64_t CGPathGetNumberOfElements(char *cf)
{
  if (!cf) {
    return 0;
  }
  if (!CGPathDisableTypeValidation)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 != CGPathGetTypeID()) {
      return 0;
    }
  }

  return CG::Path::element_count((CG::Path *)(cf + 16));
}

unsigned int *CG::DisplayListEntryImage::_hash(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    if (v5)
    {
      __srdouble c = *(_DWORD *)(v5 + 24);
      XXH64_update(a2, (char *)&__src, 4uLL);
    }
  }
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 136), 4uLL);
  XXH64_update(a2, (char *)(a1 + 148), 4uLL);

  return CG::DisplayListEntry::_hash(a1, a2);
}

unsigned int *CG::DisplayListEntryRects::_hash(uint64_t a1, unsigned int *a2)
{
  XXH64_update(a2, (char *)(a1 + 80), 4uLL);
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  uint64_t v4 = *(char **)(a1 + 136);
  if (v4) {
    XXH64_update(a2, v4, 32 * *(void *)(a1 + 144));
  }

  return CG::DisplayListEntry::_hash(a1, a2);
}

unsigned int *CG::DisplayListEntryGlyphs::_hash(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    if (v5)
    {
      uint64_t v6 = (const char *)(*(uint64_t (**)(void))(*(void *)(v5 + 16) + 144))(*(void *)(v5 + 112));
      if (v6)
      {
        uint64_t v7 = (char *)v6;
        size_t v8 = strlen(v6);
        XXH64_update(a2, v7, v8);
      }
    }
  }
  XXH64_update(a2, (char *)(a1 + 88), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 136), 0x30uLL);
  XXH64_update(a2, (char *)(a1 + 184), 8uLL);
  XXH64_update(a2, (char *)(a1 + 192), 0x10uLL);
  XXH64_update(a2, (char *)(a1 + 216), 4uLL);
  XXH64_update(a2, (char *)(a1 + 220), 4uLL);
  size_t v9 = *(char **)(a1 + 232);
  if (v9) {
    XXH64_update(a2, v9, 2 * *(void *)(a1 + 248));
  }
  CFTypeID v10 = *(char **)(a1 + 240);
  if (v10) {
    XXH64_update(a2, v10, 16 * *(void *)(a1 + 248));
  }

  return CG::DisplayListEntry::_hash(a1, a2);
}

unsigned int *XXH64_update(unsigned int *result, char *__src, size_t __n)
{
  if (__src)
  {
    int v3 = __n;
    uint64_t v4 = __src;
    uint64_t v5 = result;
    *(void *)result += __n;
    uint64_t v6 = result[18];
    if (v6 + __n > 0x1F)
    {
      uint64_t v7 = &__src[__n];
      if (v6)
      {
        BOOL result = (unsigned int *)memcpy((char *)result + v6 + 40, __src, (32 - v6));
        uint64_t v8 = __ROR8__(v5[2] - 0x3D4D51C2D82B14B1 * v5[6], 33);
        v5[1] = 0x9E3779B185EBCA87 * __ROR8__(v5[1] - 0x3D4D51C2D82B14B1 * v5[5], 33);
        v5[2] = 0x9E3779B185EBCA87 * v8;
        unint64_t v9 = 0x9E3779B185EBCA87 * __ROR8__(v5[4] - 0x3D4D51C2D82B14B1 * v5[8], 33);
        _OWORD v5[3] = 0x9E3779B185EBCA87 * __ROR8__(v5[3] - 0x3D4D51C2D82B14B1 * v5[7], 33);
        void v5[4] = v9;
        v4 += (32 - *((_DWORD *)v5 + 18));
        *((_DWORD *)v5 + 18) = 0;
      }
      if (v4 + 32 <= v7)
      {
        unint64_t v10 = v5[1];
        unint64_t v11 = v5[2];
        unint64_t v12 = v5[3];
        unint64_t v13 = v5[4];
        do
        {
          unint64_t v10 = 0x9E3779B185EBCA87 * __ROR8__(v10 - 0x3D4D51C2D82B14B1 * *(void *)v4, 33);
          v5[1] = v10;
          unint64_t v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 1), 33);
          v5[2] = v11;
          unint64_t v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 2), 33);
          _OWORD v5[3] = v12;
          unint64_t v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 3), 33);
          void v5[4] = v13;
          v4 += 32;
        }
        while (v4 <= v7 - 32);
      }
      if (v4 < v7)
      {
        size_t v14 = v7 - v4;
        BOOL result = (unsigned int *)memcpy(v5 + 5, v4, v14);
        *((_DWORD *)v5 + 18) = v14;
      }
    }
    else
    {
      BOOL result = (unsigned int *)memcpy((char *)result + v6 + 40, __src, __n);
      *((_DWORD *)v5 + 18) += v3;
    }
  }
  return result;
}

uint64_t get_postscript_name(uint64_t a1)
{
  return MEMORY[0x1F4119D18](*(void *)(a1 + 8));
}

void CGContextDrawPathDirect(uint64_t a1, CGPathDrawingMode a2, const CGPath *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1129601108)
    {
      unint64_t v12 = *(const void **)(a1 + 168);
      if (v12) {
        CFRelease(v12);
      }
      *(void *)(a1 + 168) = 0;
      double v13 = *(double *)(*(void *)(*(void *)(a1 + 96) + 128) + 8);
      if (v13 > 0.0 || v13 == -1.0905473e16)
      {
        if (a2 != -1)
        {
LABEL_15:
          CGPathDrawingMode v14 = a2;
LABEL_16:
          v16[0] = MEMORY[0x1E4F143A8];
          v16[1] = 0x40000000;
          v16[2] = __CGContextDrawPathDirect_block_invoke;
          _OWORD v16[3] = &__block_descriptor_tmp_3_14369;
          CGPathDrawingMode v17 = v14;
          _OWORD v16[4] = a1;
          v16[5] = a4;
          if (draw_path(v14, (double *)a3, (uint64_t)v16) == 1006)
          {
            CGContextAddPath((CGContextRef)a1, a3);
            CGContextDrawPath((CGContextRef)a1, v14);
          }
        }
      }
      else
      {
        CGPathDrawingMode v14 = kCGPathFill;
        switch(a2)
        {
          case -1:
          case 2:
            return;
          case 3:
            goto LABEL_16;
          case 4:
            CGPathDrawingMode v14 = kCGPathEOFill;
            goto LABEL_16;
          default:
            goto LABEL_15;
        }
      }
      return;
    }
    uint64_t v15 = a1;
  }
  else
  {
    uint64_t v15 = 0;
  }

  handle_invalid_context((char)"CGContextDrawPathDirect", v15, (uint64_t)a3, a4, a5, a6, a7, a8);
}

uint64_t CGContextDelegateDrawPathDirect(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef cf, uint64_t a6)
{
  if (result)
  {
    if (cf && ((uint64_t v11 = result, CGPathDisableTypeValidation) || (v12 = CFGetTypeID(cf), v12 == CGPathGetTypeID())))
    {
      double v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef, uint64_t))(v11 + 232);
      if (v13)
      {
        return v13(v11, a2, a3, a4, cf, a6);
      }
      else
      {
        return 1006;
      }
    }
    else
    {
      return 1001;
    }
  }
  return result;
}

uint64_t CG::DisplayListRecorder::DrawPath(CFArrayRef *a1, uint64_t a2, uint64_t a3, signed int a4, const CGPath *a5, int a6, uint64_t a7)
{
  double v13 = (double *)CG::DisplayListRecorder::currentDisplayList(a1);
  if (!v13) {
    return 1000;
  }
  CGPathDrawingMode v14 = v13;
  if (v13[5] == INFINITY || v13[6] == INFINITY) {
    return 0;
  }
  uint64_t result = 0;
  if (v14[7] != 0.0 && v14[8] != 0.0)
  {
    if (!*((unsigned char *)v14 + 73)) {
      goto LABEL_23;
    }
    if (a7)
    {
      CGSize v17 = *(CGSize *)(a7 + 16);
      v36.CGPoint origin = *(CGPoint *)a7;
      v36.CGSize size = v17;
    }
    else
    {
      PathBoundingBoCGFloat x = CGPathGetPathBoundingBox(a5);
      CGRect v36 = PathBoundingBox;
      if (a6)
      {
        long long v18 = *(_OWORD *)(a3 + 40);
        *(_OWORD *)&v35.double a = *(_OWORD *)(a3 + 24);
        *(_OWORD *)&v35.double c = v18;
        *(_OWORD *)&v35.double tx = *(_OWORD *)(a3 + 56);
        CGRect v36 = CGRectApplyAffineTransform(PathBoundingBox, &v35);
      }
      if (a4 >= 2)
      {
        v36.origin.CGFloat x = CG::DisplayListRecorder::adjustBoundingBoxToIncludeStroke(&v36, a3);
        v36.origin.CGFloat y = v19;
        v36.size.CGFloat width = v20;
        v36.size.CGFloat height = v21;
      }
    }
    CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v36.origin.x, a2, *(double **)(a3 + 112), *(void *)(*(void *)(a3 + 120) + 16));
    v36.origin.CGFloat x = v25;
    v36.origin.CGFloat y = v22;
    v36.size.CGFloat width = v23;
    v36.size.CGFloat height = v24;
    if (v25 == INFINITY || v22 == INFINITY) {
      return 0;
    }
    uint64_t result = 0;
    if (v23 != 0.0 && v24 != 0.0)
    {
LABEL_23:
      EntryDrawingState = (void *)CG::DisplayList::getEntryDrawingState((uint64_t)(v14 + 2), (void *)a3, a2);
      uint64_t v28 = EntryDrawingState[1];
      if (v28)
      {
        int v29 = *(_DWORD *)(v28 + 8);
        int v30 = v29 & 0x1000;
        int v37 = v30;
        uint64_t v31 = EntryDrawingState[2];
        if (v31)
        {
          int v30 = ((unsigned __int16)*(_DWORD *)(v31 + 8) | (unsigned __int16)v29) & 0x1000;
          int v37 = v30;
        }
        uint64_t v32 = EntryDrawingState[3];
        if (v32) {
          int v37 = v30 | *(_DWORD *)(v32 + 8) & 0x3400;
        }
        uint64_t v38 = 0;
        double v39 = 0;
        CG::DisplayListRecorder::getPathColorResourcesAndUpdateFlags((uint64_t)(v14 + 2), a3, a4, (uint64_t)&v39, &v38, &v37);
        uint64_t v33 = *(void *)(a3 + 120);
        if (*(double *)(v33 + 8) >= 1.0) {
          __int16 v34 = v37;
        }
        else {
          __int16 v34 = v37 | 0x1000;
        }
        if ((v34 & 0x1000) == 0 && (((int)(*(_DWORD *)(v33 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE) {
          __int16 v34 = v37 | 0x1000;
        }
        if ((v34 & 0x3000) != 0) {
          *((_DWORD *)v14 + 20) |= v34 & 0x3000;
        }
        if (*((unsigned char *)v14 + 74))
        {
          if ((v34 & 0x400) != 0) {
            CG::DisplayList::getEntryPatternState((uint64_t)(v14 + 2), a3, a2);
          }
          if ((v34 & 0x100) != 0) {
            CG::DisplayList::getEntryFillState((CG::DisplayList *)(v14 + 2), v39);
          }
          if ((v34 & 0x200) != 0) {
            CG::DisplayList::getEntryStrokeState((uint64_t)(v14 + 2), a3);
          }
          operator new();
        }
        return 0;
      }
      return 1000;
    }
  }
  return result;
}

CGRect CGPathGetPathBoundingBox(CGPathRef path)
{
  double v8 = 0.0;
  if (path && (CGPathDisableTypeValidation || (CFTypeID v10 = CFGetTypeID(path), v10 == CGPathGetTypeID())))
  {
    double v11 = CG::Path::path_bounding_box((CGPathRef)((char *)path + 16), v1, v2, v3, v4, v5, v6, v7);
    double v8 = v14;
  }
  else
  {
    double v12 = INFINITY;
    double v11 = INFINITY;
    double v13 = 0.0;
  }
  double v15 = v8;
  result.size.CGFloat height = v13;
  result.size.CGFloat width = v15;
  result.origin.CGFloat y = v12;
  result.origin.CGFloat x = v11;
  return result;
}

double CG::Path::path_bounding_box(CG::Path *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v9 = *(_DWORD *)this;
  switch(*(_DWORD *)this)
  {
    case 0:
    case 1:
    case 5:
    case 7:
      goto LABEL_6;
    case 2:
    case 3:
    case 4:
      goto LABEL_2;
    case 6:
      if (*((double *)this + 7) < 6.28318531) {
        goto LABEL_15;
      }
LABEL_2:
      if ((*((double *)this + 2) != 0.0 || *((double *)this + 3) != 0.0)
        && (*((double *)this + 1) != 0.0 || *((double *)this + 4) != 0.0))
      {
        goto LABEL_15;
      }
LABEL_6:
      double v10 = CG::Path::bounding_box(this, a2, a3, a4, a5, a6, a7, a8);
      break;
    default:
      if ((v9 & 0xFFFFFFFE) == 8)
      {
        double v20 = INFINITY;
        double v21 = INFINITY;
        double v18 = -INFINITY;
        double v19 = -INFINITY;
        unint64_t v17 = 0;
        if (v9 == 8)
        {
          if (*((_WORD *)this + 5))
          {
            unsigned int v15 = 0;
            unsigned int v16 = *((_DWORD *)this + 3);
            do
            {
              path_element_bounding_box(v16 & 7, (const CGPoint *)this + 1, &v21, &v20, &v19, &v18, (float64x2_t *)&v22, &v17);
              v16 >>= 3;
              ++v15;
            }
            while (v15 < *((unsigned __int16 *)this + 5));
          }
        }
        else if (v9 == 9 && *((void *)this + 2))
        {
          unint64_t v11 = 0;
          uint64_t v12 = -1;
          do
          {
            path_element_bounding_box(*(unsigned __int8 *)(*((void *)this + 4) + *((void *)this + 3) + v12), *((const CGPoint **)this + 4), &v21, &v20, &v19, &v18, (float64x2_t *)&v22, &v17);
            ++v11;
            --v12;
          }
          while (v11 < *((void *)this + 2));
        }
        double v10 = v21;
      }
      else
      {
LABEL_15:
        CG::Path::Path((CG::Path *)&v22, this);
        if (LODWORD(v22.x) != 9) {
          CG::Path::convert_to_huge_((CG::Path *)&v22);
        }
        CG::Path::path_bounding_box((CG::Path *)&v22);
        double v10 = v13;
        CG::Path::~Path((void **)&v22);
      }
      break;
  }
  return v10;
}

void sub_184C53BC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

uint64_t path_element_bounding_box(int a1, const CGPoint *a2, double *a3, double *a4, double *a5, double *a6, float64x2_t *a7, unint64_t *a8)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 0:
    case 1:
    case 4:
      uint64_t result = 0;
      uint64_t v14 = 0;
      unint64_t v15 = (*a8)++;
      CGPoint v16 = a2[v15];
      goto LABEL_57;
    case 2:
      unint64_t v17 = (*a8)++;
      a7[1] = (float64x2_t)a2[v17];
      unint64_t v18 = (*a8)++;
      double v19 = (CGPoint *)&a2[v18];
      a7[2] = *(float64x2_t *)v19;
      float64x2_t v20 = vsubq_f64(a7[1], *a7);
      float64x2_t v21 = vaddq_f64(v20, v20);
      float64x2_t v22 = vsubq_f64(vsubq_f64(a7[2], v21), *a7);
      double v23 = -2.0 * v22.f64[0] * 0.0001;
      double v24 = -2.0 * v22.f64[0] * 0.9999;
      BOOL v26 = v22.f64[0] > 0.0 && v24 < v21.f64[0] && v21.f64[0] < v23;
      if (v26
        || (v22.f64[0] < 0.0 ? (BOOL v27 = v23 < v21.f64[0]) : (BOOL v27 = 0), v27 ? (v28 = v21.f64[0] < v24) : (v28 = 0), v28))
      {
        v77[0] = vmlaq_n_f64(*a7, vmlaq_n_f64(v21, v22, -v21.f64[0] / (v22.f64[0] + v22.f64[0])), -v21.f64[0] / (v22.f64[0] + v22.f64[0]));
        uint64_t v14 = 1;
      }
      else
      {
        uint64_t v14 = 0;
      }
      uint64_t result = get_y_inflections_2(a7, 0, v76);
      goto LABEL_56;
    case 3:
      unint64_t v29 = (*a8)++;
      a7[1] = (float64x2_t)a2[v29];
      unint64_t v30 = (*a8)++;
      a7[2] = (float64x2_t)a2[v30];
      unint64_t v31 = (*a8)++;
      double v19 = (CGPoint *)&a2[v31];
      a7[3] = *(float64x2_t *)v19;
      float64x2_t v32 = *a7;
      float64x2_t v33 = a7[1];
      __asm { FMOV            V3.2D, #3.0 }
      float64x2_t v38 = vmulq_f64(vsubq_f64(v33, *a7), _Q3);
      float64x2_t v39 = vmlaq_f64(vnegq_f64(v38), _Q3, vsubq_f64(a7[2], v33));
      float64x2_t v40 = vsubq_f64(vsubq_f64(vsubq_f64(a7[3], v39), v38), *a7);
      double v41 = vmulq_f64(v39, v39).f64[0];
      double v42 = 3.0 * v40.f64[0];
      double v43 = 3.0 * v40.f64[0] * v38.f64[0];
      double v44 = v41 - v43;
      BOOL v45 = vabdd_f64(v41, v43) > (v41 + fabs(v43)) * 0.0001;
      double v46 = 0.0;
      if (v45) {
        double v46 = v44;
      }
      if (v46 >= 0.0)
      {
        double v47 = 1.0;
        if (v39.f64[0] < 0.0) {
          double v47 = -1.0;
        }
        double v48 = -(v39.f64[0] + v47 * sqrt(v46));
        double v49 = v42 * 0.0001;
        double v50 = v42 * 0.9999;
        if (v40.f64[0] > 0.0 && (v49 < v48 ? (BOOL v51 = v48 < v50) : (BOOL v51 = 0), v51)
          || (uint64_t v14 = 0, v40.f64[0] < 0.0) && (v50 < v48 ? (v52 = v48 < v49) : (v52 = 0), v52))
        {
          v77[0] = vmlaq_n_f64(v32, vmlaq_n_f64(v38, vmlaq_n_f64(v39, v40, v48 / v42), v48 / v42), v48 / v42);
          uint64_t v14 = 1;
        }
        double v53 = v48 * 0.0001;
        double v54 = v48 * 0.9999;
        BOOL v56 = v48 > 0.0 && v53 < v38.f64[0] && v38.f64[0] < v54;
        if (v56 || (v48 < 0.0 ? (BOOL v57 = v54 < v38.f64[0]) : (BOOL v57 = 0), v57 ? (v58 = v38.f64[0] < v53) : (v58 = 0), v58)) {
          v77[v14++] = vmlaq_n_f64(v32, vmlaq_n_f64(v38, vmlaq_n_f64(v39, v40, v38.f64[0] / v48), v38.f64[0] / v48), v38.f64[0] / v48);
        }
      }
      else
      {
        uint64_t v14 = 0;
      }
      uint64_t result = get_y_inflections_3(a7, 0, v76);
LABEL_56:
      CGPoint v16 = *v19;
LABEL_57:
      *(CGPoint *)a7 = v16;
      break;
    default:
      uint64_t result = 0;
      uint64_t v14 = 0;
      break;
  }
  double v59 = a7->f64[0];
  double v60 = a7->f64[1];
  CGFloat v61 = *a3;
  if (a7->f64[0] < *a3) {
    CGFloat v61 = a7->f64[0];
  }
  *a3 = v61;
  double v62 = *a4;
  if (v60 < *a4) {
    double v62 = v60;
  }
  *a4 = v62;
  if (*a5 >= v59) {
    double v59 = *a5;
  }
  *a5 = v59;
  double v63 = *a6;
  if (*a6 < v60) {
    double v63 = v60;
  }
  *a6 = v63;
  if (v14)
  {
    uint64_t v64 = &v77[0].f64[1];
    do
    {
      double v65 = *(v64 - 1);
      double v66 = *v64;
      uint64_t v67 = *(void *)a3;
      if (v65 < *a3) {
        uint64_t v67 = *((void *)v64 - 1);
      }
      *(void *)a3 = v67;
      double v68 = *a4;
      if (v66 < *a4) {
        double v68 = v66;
      }
      *a4 = v68;
      if (*a5 >= v65) {
        double v65 = *a5;
      }
      *a5 = v65;
      double v69 = *a6;
      if (*a6 < v66) {
        double v69 = v66;
      }
      *a6 = v69;
      v64 += 2;
      --v14;
    }
    while (v14);
  }
  if (result)
  {
    uint64_t v70 = &v76[0].f64[1];
    do
    {
      double v71 = *(v70 - 1);
      double v72 = *v70;
      uint64_t v73 = *(void *)a3;
      if (v71 < *a3) {
        uint64_t v73 = *((void *)v70 - 1);
      }
      *(void *)a3 = v73;
      double v74 = *a4;
      if (v72 < *a4) {
        double v74 = v72;
      }
      *a4 = v74;
      if (*a5 >= v71) {
        double v71 = *a5;
      }
      *a5 = v71;
      double v75 = *a6;
      if (*a6 < v72) {
        double v75 = v72;
      }
      *a6 = v75;
      v70 += 2;
      --result;
    }
    while (result);
  }
  return result;
}

uint64_t get_y_inflections_3(float64x2_t *a1, double *a2, float64x2_t *a3)
{
  float64x2_t v3 = *a1;
  float64x2_t v4 = a1[1];
  __asm { FMOV            V3.2D, #3.0 }
  float64x2_t v9 = vmulq_f64(vsubq_f64(v4, *a1), _Q3);
  float64x2_t v10 = vmlaq_f64(vnegq_f64(v9), _Q3, vsubq_f64(a1[2], v4));
  float64x2_t v11 = vsubq_f64(vsubq_f64(vsubq_f64(a1[3], v10), v9), *a1);
  double v12 = vmuld_lane_f64(3.0, v11, 1);
  *(void *)&v13.f64[0] = vdupq_laneq_s64((int64x2_t)v10, 1).u64[0];
  v13.f64[1] = v12;
  float64x2_t v14 = vmulq_f64(v13, (float64x2_t)vzip2q_s64((int64x2_t)v10, (int64x2_t)v9));
  double v15 = 0.0;
  if (vabdd_f64(v14.f64[0], v14.f64[1]) > (v14.f64[0] + fabs(v14.f64[1])) * 0.0001) {
    double v15 = v14.f64[0] - v14.f64[1];
  }
  if (v15 < 0.0) {
    return 0;
  }
  double v17 = 1.0;
  if (v10.f64[1] < 0.0) {
    double v17 = -1.0;
  }
  double v18 = -(v10.f64[1] + v17 * sqrt(v15));
  double v19 = v12 * 0.0001;
  double v20 = v12 * 0.9999;
  if (v11.f64[1] > 0.0 && (v19 < v18 ? (_NF = v18 < v20) : (_NF = 0), _NF)
    || (uint64_t result = 0, v11.f64[1] < 0.0) && (v20 < v18 ? (v22 = v18 < v19) : (v22 = 0), v22))
  {
    double v23 = v18 / v12;
    if (a2) {
      *a2 = v23;
    }
    if (a3) {
      *a3 = vmlaq_n_f64(v3, vmlaq_n_f64(v9, vmlaq_n_f64(v10, v11, v23), v23), v23);
    }
    uint64_t result = 1;
  }
  double v24 = v18 * 0.0001;
  double v25 = v18 * 0.9999;
  BOOL v27 = v18 > 0.0 && v24 < v9.f64[1] && v9.f64[1] < v25;
  if (v27 || (v18 < 0.0 ? (BOOL v28 = v25 < v9.f64[1]) : (BOOL v28 = 0), v28 ? (v29 = v9.f64[1] < v24) : (v29 = 0), v29))
  {
    double v30 = v9.f64[1] / v18;
    if (a2) {
      a2[result] = v30;
    }
    if (a3) {
      a3[result] = vmlaq_n_f64(v3, vmlaq_n_f64(v9, vmlaq_n_f64(v10, v11, v30), v30), v30);
    }
    ++result;
  }
  return result;
}

uint64_t __CGContextDrawPathDirect_block_invoke(uint64_t a1, CFTypeRef cf)
{
  return CGContextDelegateDrawPathDirect(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 112), *(void *)(*(void *)(a1 + 32) + 96), *(unsigned int *)(a1 + 48), cf, *(void *)(a1 + 40));
}

uint64_t dlRecorder_DrawPathDirect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const CGPath *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (double v8 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    return CG::DisplayListRecorder::DrawPath(v8, a2, a3, a4, a5, 1, a6);
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"dlRecorder_DrawPathDirect");
    return 1000;
  }
}

uint64_t CGPDFSourceRefill(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(unsigned char *)(a1 + 208)) {
    return 0;
  }
  float64x2_t v11 = *(void **)(a1 + 144);
  if (v11)
  {
    if (*(unsigned char *)(a1 + 152)) {
      free(v11);
    }
    *(void *)(a1 + 144) = 0;
    uint64_t v12 = *(void *)(a1 + 200);
    *(void *)(a1 + 120) = v12;
    if (v12)
    {
      *(void *)(a1 + 128) = *(void *)(a1 + 192);
      return 1;
    }
  }
  *(void *)(a1 + 112) += *(void *)(a1 + 104);
  uint64_t v13 = *(void *)(a1 + 40);
  if (v13)
  {
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v14 + *(void *)(a1 + 96) >= v15) {
      size_t v16 = v15 - v14;
    }
    else {
      size_t v16 = *(void *)(a1 + 96);
    }
    BytesAtPositiouint64_t n = CGDataProviderGetBytesAtPosition(v13, *(char **)(a1 + 88), *(void *)(a1 + 24) + v14, v16);
    *(void *)(a1 + 32) += BytesAtPosition;
  }
  else
  {
    double v18 = *(uint64_t (**)(void, void, void))(a1 + 56);
    if (!v18) {
      _CGHandleAssert("CGPDFSourceRefill", 467, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Reader/CGPDFSource.c", "source->filter_callbacks.read != NULL", "filter read callback is missing", a6, a7, a8, v20);
    }
    BytesAtPositiouint64_t n = v18(*(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96));
  }
  *(void *)(a1 + 104) = BytesAtPosition;
  uint64_t v19 = *(void *)(a1 + 88);
  *(void *)(a1 + 120) = BytesAtPosition;
  *(void *)(a1 + 128) = v19;
  uint64_t v9 = 1;
  if (!BytesAtPosition)
  {
    *(unsigned char *)(a1 + 208) = 1;
    return 0;
  }
  return v9;
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      float64x2_t v11 = (const CGPath *)*((void *)c + 21);
      if (v11 && !CGPathIsEmpty(v11))
      {
        uint64_t v15 = (CGPath *)*((void *)c + 21);
        size_t v16 = (const CGAffineTransform *)(*((void *)c + 12) + 24);
        CGPathAddLineToPoint(v15, v16, x, y);
      }
      else
      {
        CGPostError((uint64_t)"%s: no current point.", v3, v4, v5, v6, v7, v8, v9, (char)"CGContextAddLineToPoint");
      }
      return;
    }
    CGContextRef v14 = c;
  }
  else
  {
    CGContextRef v14 = 0;
  }

  handle_invalid_context((char)"CGContextAddLineToPoint", (uint64_t)v14, v4, v5, v6, v7, v8, v9);
}

size_t CGDataProviderGetBytesAtPosition(uint64_t a1, char *a2, uint64_t a3, size_t a4)
{
  if (!a1 || a3 < 0) {
    return 0;
  }
  CFTypeID v12 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDataProviderPropertyTrustToken_block_invoke_once != -1) {
    dispatch_once(&kCGDataProviderPropertyTrustToken_block_invoke_once, &__block_literal_global_28_6762);
  }
  if (v12 != CGDataProviderGetTypeID_id) {
    return 0;
  }
  if (*(void *)(a1 + 96) || *(void *)(a1 + 112) || *(void *)(a1 + 80))
  {
    return CGDataProviderDirectGetBytesAtPositionInternal((void *)a1, a2, a3, a4, v8, v9, v10, v11);
  }
  else
  {
    if ((*(_DWORD *)(a1 + 20) & 0xFFFFFFFD) != 1 || !*(void *)(a1 + 64)) {
      _CGHandleAssert("CGDataProviderGetBytesAtPosition", 754, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/DataManagers/CGDataProvider.c", "is_sequential(provider) && is_rewindable(provider)", "provider type (%d) must be both sequential and rewindable", v9, v10, v11, *(_DWORD *)(a1 + 20));
    }
    CGDataProviderLock(a1);
    CGContextRef v14 = *(void (**)(void))(a1 + 64);
    if (v14) {
      v14(*(void *)(a1 + 24));
    }
    *(unsigned char *)(a1 + 261) = 0;
    CGDataProviderSkipForwardInternal(a1, a3);
    uint64_t BytesInternal = CGDataProviderSequentialGetBytesInternal(a1, (uint64_t)a2, a4);
    CGDataProviderUnlock(a1);
    return BytesInternal;
  }
}

void CGContextClosePath(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v9 = (const CGPath *)*((void *)c + 21);
      if (v9 && !CGPathIsEmpty(v9))
      {
        uint64_t v11 = (CGPath *)*((void *)c + 21);
        CGPathCloseSubpath(v11);
      }
      else
      {
        CGPostError((uint64_t)"%s: no current point.", v1, v2, v3, v4, v5, v6, v7, (char)"CGContextClosePath");
      }
      return;
    }
    CGContextRef v10 = c;
  }
  else
  {
    CGContextRef v10 = 0;
  }

  handle_invalid_context((char)"CGContextClosePath", (uint64_t)v10, v2, v3, v4, v5, v6, v7);
}

uint64_t dlRecorder_DrawPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const CGPath *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (uint64_t v8 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    return CG::DisplayListRecorder::DrawPath(v8, a2, a3, a4, a5, 0, 0);
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"dlRecorder_DrawPath");
    return 1000;
  }
}

uint64_t CG::DisplayList::getEntryStrokeState(uint64_t a1, uint64_t a2)
{
  ++*(void *)(a1 + 736);
  uint64_t v3 = a1 + 536;
  uint64_t v4 = *(void *)(a1 + 536);
  if (!v4) {
    goto LABEL_13;
  }
  uint64_t v5 = a1 + 536;
  do
  {
    uint64_t v6 = *(std::__shared_weak_count **)(v4 + 40);
    v41[0] = *(void *)(v4 + 32);
    v41[1] = (uint64_t)v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v7 = CG::CompareEntryStateStroke::operator()(v41, a2);
      std::__shared_weak_count::__release_shared[abi:fe180100](v6);
    }
    else
    {
      BOOL v7 = CG::CompareEntryStateStroke::operator()(v41, a2);
    }
    uint64_t v8 = (uint64_t *)(v4 + 8);
    if (!v7)
    {
      uint64_t v5 = v4;
      uint64_t v8 = (uint64_t *)v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v3 == v5) {
    goto LABEL_13;
  }
  uint64_t v9 = *(std::__shared_weak_count **)(v5 + 40);
  v40[0] = *(void *)(v5 + 32);
  v40[1] = (uint64_t)v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    if (CG::CompareEntryStateStroke::operator()(v40, a2))
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v9);
      goto LABEL_13;
    }
  }
  else if (CG::CompareEntryStateStroke::operator()(v40, a2))
  {
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(v5 + 32);
  uint64_t v11 = *(std::__shared_weak_count **)(v5 + 40);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t StrokeColor = CGGStateGetStrokeColor(a2);
  uint64_t v21 = *(void *)(v12 + 8);
  if (v21) {
    unint64_t v22 = *(void *)(v21 + 16);
  }
  else {
    unint64_t v22 = 0;
  }
  uint64_t v23 = CGColorCompare(StrokeColor, v22, v14, v15, v16, v17, v18, v19, v20);
  if (v23 == -1) {
    goto LABEL_39;
  }
  if (v23 == 1) {
    goto LABEL_28;
  }
  uint64_t v24 = *(void *)(a2 + 128);
  uint64_t v25 = *(void *)(v12 + 40);
  uint64_t v26 = v25 ? *(void *)(v25 + 16) : 0;
  uint64_t v27 = CGDashCompare(*(void *)(v24 + 32), v26);
  if (v27 == -1) {
    goto LABEL_39;
  }
  if (v27 == 1) {
    goto LABEL_28;
  }
  double v29 = *(double *)(v24 + 8);
  double v30 = *(double *)(v12 + 16);
  if (v29 < v30)
  {
LABEL_39:
    int v28 = 1;
    if (!v11) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  if (v29 > v30) {
    goto LABEL_28;
  }
  double v31 = *(double *)(v24 + 24);
  double v32 = *(double *)(v12 + 24);
  if (v31 < v32) {
    goto LABEL_39;
  }
  if (v31 > v32) {
    goto LABEL_28;
  }
  double v33 = *(double *)(v24 + 16);
  double v34 = *(double *)(v12 + 32);
  if (v33 < v34) {
    goto LABEL_39;
  }
  if (v33 > v34) {
    goto LABEL_28;
  }
  __int16 v35 = *(_WORD *)(v24 + 2);
  int v36 = (__int16)(v35 << 8);
  __int16 v37 = *(_WORD *)(v12 + 48);
  if (v36 < (__int16)(v37 << 8)) {
    goto LABEL_39;
  }
  if (v36 > (__int16)(v37 << 8)) {
    goto LABEL_28;
  }
  int v38 = v35 >> 8;
  if (v38 < v37 >> 8) {
    goto LABEL_39;
  }
  if (v38 > v37 >> 8)
  {
LABEL_28:
    int v28 = 0;
    if (!v11) {
      goto LABEL_41;
    }
LABEL_40:
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
    goto LABEL_41;
  }
  if (*(unsigned char *)(v24 + 1)) {
    BOOL v39 = 1;
  }
  else {
    BOOL v39 = *(unsigned char *)(v12 + 50) == 0;
  }
  int v28 = !v39;
  if (v11) {
    goto LABEL_40;
  }
LABEL_41:
  if (!v9)
  {
    if (!v28) {
      return *(void *)(v5 + 32);
    }
LABEL_13:
    operator new();
  }
  std::__shared_weak_count::__release_shared[abi:fe180100](v9);
  if (v28) {
    goto LABEL_13;
  }
  return *(void *)(v5 + 32);
}

void sub_184C549E8(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

BOOL CG::CompareEntryStateStroke::operator()(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*a1 + 8);
  if (v4) {
    unint64_t v5 = *(void *)(v4 + 16);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t StrokeColor = CGGStateGetStrokeColor(a2);
  uint64_t v14 = CGColorCompare(v5, StrokeColor, v7, v8, v9, v10, v11, v12, v13);
  if (v14 == -1) {
    return 1;
  }
  if (v14 == 1) {
    return 0;
  }
  uint64_t v15 = *a1;
  uint64_t v16 = *(void *)(v15 + 40);
  uint64_t v17 = v16 ? *(void *)(v16 + 16) : 0;
  uint64_t v18 = *(void *)(a2 + 128);
  uint64_t v19 = CGDashCompare(v17, *(void *)(v18 + 32));
  if (v19 == -1) {
    return 1;
  }
  if (v19 == 1) {
    return 0;
  }
  double v21 = *(double *)(v15 + 16);
  double v22 = *(double *)(v18 + 8);
  if (v21 < v22) {
    return 1;
  }
  if (v21 > v22) {
    return 0;
  }
  double v23 = *(double *)(v15 + 24);
  double v24 = *(double *)(v18 + 24);
  if (v23 < v24) {
    return 1;
  }
  if (v23 > v24) {
    return 0;
  }
  double v25 = *(double *)(v15 + 32);
  double v26 = *(double *)(v18 + 16);
  if (v25 < v26) {
    return 1;
  }
  if (v25 > v26) {
    return 0;
  }
  __int16 v27 = *(_WORD *)(v15 + 48);
  __int16 v28 = *(_WORD *)(v18 + 2);
  int v29 = (__int16)(v28 << 8);
  if (v29 > (__int16)(v27 << 8)) {
    return 1;
  }
  if (v29 < (__int16)(v27 << 8)) {
    return 0;
  }
  int v30 = v28 >> 8;
  if (v30 > v27 >> 8) {
    return 1;
  }
  if (v30 < v27 >> 8) {
    return 0;
  }
  return *(unsigned char *)(v18 + 1) && *(unsigned char *)(v15 + 50) == 0;
}

uint64_t CGDashCompare(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 0;
  }
  if (a1 && !a2) {
    return 1;
  }
  if (!a1 && a2) {
    return -1;
  }
  double v3 = *(double *)(a1 + 8);
  double v4 = *(double *)(a2 + 8);
  if (v3 > v4) {
    return 1;
  }
  if (v3 < v4) {
    return -1;
  }
  unint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = *(void *)(a2 + 16);
  if (v5 > v6) {
    return 1;
  }
  if (v5 < v6) {
    return -1;
  }
  int v7 = memcmp((const void *)(a1 + 24), (const void *)(a2 + 24), 8 * v5);
  if (v7 > 0) {
    return 1;
  }
  if (v7) {
    return -1;
  }
  return 0;
}

uint64_t flate_filter_refill(uint64_t strm, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (strm)
  {
    uint64_t v8 = strm;
    if (*(unsigned char *)(strm + 113) || *(unsigned char *)(strm + 112))
    {
      return 0;
    }
    else
    {
      if (a3 > 0x3000) {
        _CGHandleAssert("fstream_read", 182, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Filters/flate-filter.c", "count <= OUTPUT_BUFFER_SIZE", "Count (%lu) exceeds size of allocated buffer(%d)", a6, a7, a8, a3);
      }
      *(_DWORD *)(strm + 32) = a3;
      *(void *)(strm + 24) = a2;
      if (a3)
      {
        while (1)
        {
          if (!*(_DWORD *)(v8 + 8) && !*(unsigned char *)(v8 + 114))
          {
            unint64_t v10 = CGPDFSourceRead(*(void *)(v8 + 120), *(void *)(v8 + 128), 0xF00uLL, a4, a5, a6, a7, a8);
            if (v10)
            {
              if (v10 >= 0xF01) {
                _CGHandleAssert("fstream_read", 193, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/Filters/flate-filter.c", "n <= INPUT_BUFFER_SIZE", "Bytes read (%lu) exceeded input buffer size (%d)", v11, v12, v13, v10);
              }
            }
            else
            {
              *(unsigned char *)(v8 + 114) = 1;
            }
            *(_DWORD *)(v8 + 8) = v10;
            *(void *)uint64_t v8 = *(void *)(v8 + 128);
          }
          int v14 = inflate((z_streamp)v8, 0);
          if (v14) {
            break;
          }
          if (*(unsigned char *)(v8 + 114) || !*(_DWORD *)(v8 + 32)) {
            return a3 - *(unsigned int *)(v8 + 32);
          }
        }
        if ((v14 + 5) <= 6 && ((1 << (v14 + 5)) & 0x45) != 0)
        {
          *(unsigned char *)(v8 + 112) = 1;
        }
        else
        {
          if (*(void *)(v8 + 48)) {
            pdf_error("FlateDecode: decoding error: %s.");
          }
          else {
            pdf_error("FlateDecode: decoding error.");
          }
          *(unsigned char *)(v8 + 113) = 1;
        }
      }
      return a3 - *(unsigned int *)(v8 + 32);
    }
  }
  return strm;
}

BOOL pdf_scanner_advance_stream(void *a1)
{
  uint64_t v2 = a1[8];
  if (v2)
  {
    pdf_lexer_release(v2);
    a1[8] = 0;
  }
  CFArrayRef v3 = (const __CFArray *)a1[6];
  if (!v3) {
    return 0;
  }
  unint64_t v4 = a1[5];
  if (v4 >= CFArrayGetCount(v3)) {
    return 0;
  }
  CFIndex v6 = a1[5];
  CFArrayRef v5 = (const __CFArray *)a1[6];
  a1[5] = v6 + 1;
  ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(v5, v6);
  int v13 = 0;
  uint64_t v8 = CGPDFStreamCreateFilterChain((uint64_t)ValueAtIndex, &v13);
  BOOL v9 = 0;
  if (v8 && !v13)
  {
    unint64_t v10 = v8;
    uint64_t v11 = pdf_lexer_create(0, v8, 1);
    a1[8] = v11;
    BOOL v9 = v11 != 0;
    CFRelease(v10);
  }
  return v9;
}

uint64_t CGPDFDrawingContextRestoreGState(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    if (*(void *)(result + 56) && *(void *)(result + 40) >= 2uLL)
    {
      CGPDFGStateReleaseProperties(*(void **)(result + 32));
      uint64_t v2 = v1[5];
      v1[4] = *(void *)(v1[7] + 8 * v2 - 16);
      v1[5] = v2 - 1;
      CFArrayRef v3 = (CGContext *)v1[11];
      if (v3) {
        CGContextRestoreGState(v3);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t rip_auto_context_draw_path(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  if (!a1)
  {
    uint64_t v10 = 112;
    pthread_mutex_lock((pthread_mutex_t *)0x70);
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a1 + 288);
  uint64_t v10 = v9 + 112;
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 112));
  if (!v9)
  {
LABEL_6:
    rip_auto_context_update_content_info_from_GState(0, a3);
    goto LABEL_7;
  }
  uint64_t v11 = *(void *)(v9 + 88);
  if (v11)
  {
    rip_auto_context_update_content_info_from_GState(v9, a3);
LABEL_9:
    uint64_t v12 = CGContextDelegateDrawPath(*(void *)(v11 + 40), a2, a3, a4, a5);
    *(unsigned char *)(v9 + 105) |= rip_auto_context_contains_transparency(v9, v13, v14, v15, v16, v17, v18, v19);
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)(v9 + 80);
  rip_auto_context_update_content_info_from_GState(v9, a3);
  if (v11) {
    goto LABEL_9;
  }
LABEL_7:
  uint64_t v12 = 0;
LABEL_10:
  pthread_mutex_unlock((pthread_mutex_t *)v10);
  return v12;
}

void *std::__tree<std::shared_ptr<CG::DisplayListEntryStateStroke const>,CG::CompareEntryStateStroke,std::allocator<std::shared_ptr<CG::DisplayListEntryStateStroke const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateStroke const>>(void *a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v9 = a1 + 1;
  if (a1 + 1 == a2) {
    goto LABEL_7;
  }
  uint64_t v11 = *a5;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = a2[4];
  uint64_t v14 = (std::__shared_weak_count *)a2[5];
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v15 = CG::CompareEntryStateStroke::operator()(v11, v13);
    std::__shared_weak_count::__release_shared[abi:fe180100](v14);
    if (v12) {
      goto LABEL_6;
    }
LABEL_13:
    if (v15) {
      goto LABEL_7;
    }
LABEL_14:
    uint64_t v18 = a2[4];
    uint64_t v19 = (std::__shared_weak_count *)a2[5];
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = *a5;
    double v21 = (std::__shared_weak_count *)a5[1];
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v22 = CG::CompareEntryStateStroke::operator()(v18, v20);
      std::__shared_weak_count::__release_shared[abi:fe180100](v21);
      if (!v19) {
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v22 = CG::CompareEntryStateStroke::operator()(v18, v20);
      if (!v19)
      {
LABEL_19:
        if (!v22)
        {
          *a3 = a2;
          *a4 = a2;
          return a4;
        }
        a4 = a2 + 1;
        double v23 = (void *)a2[1];
        if (v23)
        {
          do
          {
            double v24 = v23;
            double v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          double v32 = a2;
          do
          {
            double v24 = (void *)v32[2];
            BOOL v26 = *v24 == (void)v32;
            double v32 = v24;
          }
          while (!v26);
        }
        if (v24 == v9) {
          goto LABEL_48;
        }
        uint64_t v33 = *a5;
        double v34 = (std::__shared_weak_count *)a5[1];
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v35 = v24[4];
        int v36 = (std::__shared_weak_count *)v24[5];
        if (v36)
        {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          BOOL v37 = CG::CompareEntryStateStroke::operator()(v33, v35);
          std::__shared_weak_count::__release_shared[abi:fe180100](v36);
          if (v34) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v37 = CG::CompareEntryStateStroke::operator()(v33, v35);
          if (v34)
          {
LABEL_47:
            std::__shared_weak_count::__release_shared[abi:fe180100](v34);
            if (!v37) {
              goto LABEL_52;
            }
LABEL_48:
            if (*a4)
            {
              *a3 = v24;
              return v24;
            }
            else
            {
              *a3 = a2;
            }
            return a4;
          }
        }
        if (!v37) {
          goto LABEL_52;
        }
        goto LABEL_48;
      }
    }
    std::__shared_weak_count::__release_shared[abi:fe180100](v19);
    goto LABEL_19;
  }
  BOOL v15 = CG::CompareEntryStateStroke::operator()(v11, v13);
  if (!v12) {
    goto LABEL_13;
  }
LABEL_6:
  std::__shared_weak_count::__release_shared[abi:fe180100](v12);
  if (!v15) {
    goto LABEL_14;
  }
LABEL_7:
  if ((void *)*a1 == a2)
  {
    uint64_t v17 = a2;
    goto LABEL_33;
  }
  uint64_t v16 = (void *)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v17 = v16;
      uint64_t v16 = (void *)v16[1];
    }
    while (v16);
  }
  else
  {
    double v25 = a2;
    do
    {
      uint64_t v17 = (void *)v25[2];
      BOOL v26 = *v17 == (void)v25;
      double v25 = v17;
    }
    while (v26);
  }
  uint64_t v27 = v17[4];
  __int16 v28 = (std::__shared_weak_count *)v17[5];
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v29 = *a5;
  int v30 = (std::__shared_weak_count *)a5[1];
  if (v30)
  {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v31 = CG::CompareEntryStateStroke::operator()(v27, v29);
    std::__shared_weak_count::__release_shared[abi:fe180100](v30);
    if (v28) {
      goto LABEL_29;
    }
  }
  else
  {
    BOOL v31 = CG::CompareEntryStateStroke::operator()(v27, v29);
    if (v28)
    {
LABEL_29:
      std::__shared_weak_count::__release_shared[abi:fe180100](v28);
      if (!v31) {
        goto LABEL_52;
      }
      goto LABEL_33;
    }
  }
  if (v31)
  {
LABEL_33:
    if (*a2)
    {
      *a3 = v17;
      return v17 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
LABEL_52:

  return std::__tree<std::shared_ptr<CG::DisplayListEntryStateStroke const>,CG::CompareEntryStateStroke,std::allocator<std::shared_ptr<CG::DisplayListEntryStateStroke const>>>::__find_equal<std::shared_ptr<CG::DisplayListEntryStateStroke const>>((uint64_t)a1, a3, a5);
}

uint64_t CG::DisplayList::dashResourceForDash(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = a1 + 208;
  uint64_t v4 = *(void *)(a1 + 208);
  ++*(void *)(a1 + 632);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = a1 + 208;
  do
  {
    uint64_t v6 = *(void *)(v4 + 32);
    int v7 = *(std::__shared_weak_count **)(v4 + 40);
    if (v7)
    {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      BOOL v8 = CGDashCompare(*(void *)(v6 + 16), a2) == -1;
      std::__shared_weak_count::__release_shared[abi:fe180100](v7);
    }
    else
    {
      BOOL v8 = CGDashCompare(*(void *)(v6 + 16), a2) == -1;
    }
    uint64_t v9 = (uint64_t *)(v4 + 8);
    if (!v8)
    {
      uint64_t v5 = v4;
      uint64_t v9 = (uint64_t *)v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v3 == v5) {
LABEL_15:
  }
    operator new();
  uint64_t v10 = *(void *)(v5 + 32);
  uint64_t v11 = *(std::__shared_weak_count **)(v5 + 40);
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    if (CGDashCompare(*(void *)(v10 + 16), a2) == -1)
    {
      std::__shared_weak_count::__release_shared[abi:fe180100](v11);
      goto LABEL_15;
    }
  }
  else if (CGDashCompare(*(void *)(v10 + 16), a2) == -1)
  {
    goto LABEL_15;
  }
  uint64_t v13 = *(void *)(v5 + 32);
  uint64_t v14 = *(std::__shared_weak_count **)(v5 + 40);
  if (v14)
  {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v15 = CGDashCompare(a2, *(void *)(v13 + 16));
    std::__shared_weak_count::__release_shared[abi:fe180100](v14);
    if (!v11) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v15 = CGDashCompare(a2, *(void *)(v13 + 16));
  if (v11) {
LABEL_19:
  }
    std::__shared_weak_count::__release_shared[abi:fe180100](v11);
LABEL_20:
  if (v15 == -1) {
    goto LABEL_15;
  }
  return *(void *)(v5 + 32);
}

void sub_184C55484(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<CG::DisplayListResourceCFTypeRef>,void *>>>::operator()[abi:fe180100](0, v1);
  _Unwind_Resume(a1);
}

void set_color(unint64_t StrokeColor, uint64_t a2, CGColorSpace *a3, int a4, __n128 a5)
{
  uint64_t v6 = a3;
  BOOL v8 = (CGPDFScanner *)StrokeColor;
  value[1] = *(CGPDFReal *)MEMORY[0x1E4F143B8];
  if (a3) {
    goto LABEL_2;
  }
  uint64_t v10 = *(void *)(a2 + 32);
  if (!a4)
  {
    unint64_t StrokeColor = CGPDFGStateGetStrokeColor(v10);
    if (StrokeColor) {
      goto LABEL_5;
    }
LABEL_9:
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  unint64_t StrokeColor = CGPDFGStateGetFillColor(v10);
  if (!StrokeColor) {
    goto LABEL_9;
  }
LABEL_5:
  if ((StrokeColor & 0x8000000000000000) != 0)
  {
    unint64_t StrokeColor = (unint64_t)CGTaggedColorGetColorSpace(StrokeColor, v11, v12, v13, v14, v15, v16, v17);
    uint64_t v6 = (CGColorSpace *)StrokeColor;
    if (!StrokeColor) {
      goto LABEL_11;
    }
LABEL_2:
    uint64_t v9 = *(void *)(*((void *)v6 + 3) + 48);
    goto LABEL_12;
  }
  uint64_t v6 = *(CGColorSpace **)(StrokeColor + 24);
  if (v6) {
    goto LABEL_2;
  }
LABEL_11:
  uint64_t v9 = 0;
LABEL_12:
  MEMORY[0x1F4188790](StrokeColor, a5);
  double v21 = (CGPDFReal *)((char *)value - v20);
  if (v19 <= 0x1FFFFFFFFFFFFFFELL) {
    BOOL v22 = (CGPDFReal *)((char *)value - v20);
  }
  else {
    BOOL v22 = 0;
  }
  if (v19 - 0x1FFFFFFFFFFFFFFFLL >= 0xE00000000000000ELL) {
    BOOL v22 = (CGFloat *)malloc_type_malloc(8 * v18, 0x48446D8AuLL);
  }
  value[0] = 0.0;
  if (v22)
  {
    if (v9)
    {
      uint64_t v23 = v9 - 1;
      while (CGPDFScannerPopNumber(v8, value))
      {
        v22[v23--] = value[0];
        if (v23 == -1) {
          goto LABEL_22;
        }
      }
      pdf_error("missing or invalid arguments for color operator.");
      goto LABEL_34;
    }
LABEL_22:
    uint64_t v24 = *(void *)(a2 + 32);
    if (a4)
    {
      if (v24) {
        double v25 = *(double *)(v24 + 200);
      }
      else {
        double v25 = 1.0;
      }
      v22[v9] = v25;
      CGColorRef v27 = CGColorCreate(v6, v22);
      CGPDFGStateSetFillColor(*(void *)(a2 + 32), v27);
      if (!v27) {
        goto LABEL_34;
      }
    }
    else
    {
      if (v24) {
        double v26 = *(double *)(v24 + 208);
      }
      else {
        double v26 = 1.0;
      }
      v22[v9] = v26;
      CGColorRef v27 = CGColorCreate(v6, v22);
      CGPDFGStateSetStrokeColor(*(void *)(a2 + 32), v27);
      if (!v27) {
        goto LABEL_34;
      }
    }
    CFRelease(v27);
LABEL_34:
    if (v22 != v21) {
      free(v22);
    }
  }
}

void pdf_object_release_compound_value(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 8))
  {
    case 5:
      free(*(void **)(a1 + 32));
      break;
    case 6:
      uint64_t v1 = *(const void **)(a1 + 32);
      if (v1) {
        goto LABEL_4;
      }
      break;
    case 7:
      uint64_t v1 = *(const void **)(a1 + 32);
      if (v1) {
        goto LABEL_4;
      }
      break;
    case 8:
      uint64_t v1 = *(const void **)(a1 + 32);
      if (v1) {
        goto LABEL_4;
      }
      break;
    case 9:
      uint64_t v1 = *(const void **)(a1 + 32);
      if (v1) {
LABEL_4:
      }
        CFRelease(v1);
      break;
    default:
      return;
  }
}

void pdf_lexer_release(uint64_t a1)
{
  if (a1 && atomic_fetch_add_explicit((atomic_uint *volatile)a1, 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v2 = *(const void **)(a1 + 16);
    if (v2) {
      CFRelease(v2);
    }
    free(*(void **)(a1 + 40));
    free((void *)a1);
  }
}

uint64_t CGGStateGetSoftMask(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 120) + 40);
}

uint64_t CGClipStackGetIdentifier(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

void CGDisplayListDelegateDrawDisplayList(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a4 || *(void *)(a4 + 592) == *(void *)(a4 + 600)) {
    return;
  }
  if (*(double *)(a4 + 88) == INFINITY || *(double *)(a4 + 96) == INFINITY) {
    return;
  }
  CFDictionaryRef v13 = *(const __CFDictionary **)(a4 + 32);
  if (v13)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a4 + 32), @"kCGContextGroup"))
    {
      BOOL v14 = 1;
      if (!a3) {
        goto LABEL_18;
      }
LABEL_14:
      if (a1)
      {
        uint64_t v15 = (double (*)(void *, uint64_t, uint64_t))a1[6];
        if (v15)
        {
          CGFloat v16 = v15(a1, a2, a3);
          CGFloat v18 = v17;
          CGFloat v20 = v19;
          CGFloat v22 = v21;
        }
        else
        {
          CGFloat v20 = 1.79769313e308;
          CGFloat v16 = -8.98846567e307;
          CGFloat v18 = -8.98846567e307;
          CGFloat v22 = 1.79769313e308;
        }
      }
      else
      {
        CGFloat v20 = 0.0;
        CGFloat v16 = INFINITY;
        CGFloat v18 = INFINITY;
        CGFloat v22 = 0.0;
      }
      double v44 = *(double **)(a3 + 112);
      if (v44)
      {
        double Bounds = CGClipStackGetBounds(v44);
        unint64_t v47 = v46;
        uint64_t v49 = v48;
        uint64_t v51 = v50;
      }
      else
      {
        unint64_t v47 = 0xFFDFFFFFFFFFFFFFLL;
        uint64_t v49 = 0x7FEFFFFFFFFFFFFFLL;
        double Bounds = -8.98846567e307;
        uint64_t v51 = 0x7FEFFFFFFFFFFFFFLL;
      }
      v73.origin.double x = v16;
      v73.origin.double y = v18;
      v73.size.double width = v20;
      v73.size.double height = v22;
      CGRect v74 = CGRectIntersection(v73, *(CGRect *)&Bounds);
      if (v74.origin.x == INFINITY || v74.origin.y == INFINITY || v74.size.width == 0.0 || v74.size.height == 0.0) {
        return;
      }
      long long v52 = *(_OWORD *)(a3 + 40);
      v70[0] = *(_OWORD *)(a3 + 24);
      v70[1] = v52;
      v70[2] = *(_OWORD *)(a3 + 56);
      v53.n64_u64[0] = CGRectApplyInverseAffineTransform((double *)v70, *(__n64 *)&v74.origin.x, v74.origin.y, v74.size.width, v74.size.height).n64_u64[0];
      BOOL v57 = &CGRectNull;
      p_double y = &CGRectNull.origin.y;
      p_CGSize size = (CGSize *)(a4 + 104);
      p_double height = (CGFloat *)(a4 + 112);
      if (*(void *)(a4 + 592) == *(void *)(a4 + 600)) {
        p_CGSize size = &CGRectNull.size;
      }
      else {
        p_double y = (CGFloat *)(a4 + 96);
      }
      if (*(void *)(a4 + 592) == *(void *)(a4 + 600)) {
        p_double height = &CGRectNull.size.height;
      }
      else {
        BOOL v57 = (const CGRect *)(a4 + 88);
      }
      v77.size.double height = *p_height;
      v77.origin.double x = v57->origin.x;
      v77.origin.double y = *p_y;
      v77.size.double width = p_size->width;
      CGRect v75 = CGRectIntersection(*(CGRect *)v53.n64_u64, v77);
      double x = v75.origin.x;
      CGRect v71 = v75;
      if (v75.origin.x == INFINITY) {
        return;
      }
      double y = v75.origin.y;
      if (v75.origin.y == INFINITY) {
        return;
      }
      double width = v75.size.width;
      if (v75.size.width == 0.0) {
        return;
      }
      double height = v75.size.height;
      if (v75.size.height == 0.0) {
        return;
      }
      BOOL v23 = 0;
      if (!v14)
      {
        uint64_t v69 = *(void *)(a3 + 120);
        if (*(double *)(v69 + 8) != 1.0
          || *(void *)(v69 + 16)
          || *(void *)(v69 + 40)
          || *(unsigned __int8 *)(v69 + 5) << 8 != 512)
        {
          BOOL v23 = 1;
        }
      }
      goto LABEL_24;
    }
    BOOL v14 = CFDictionaryContainsKey(v13, @"kCGContextColorSpace") != 0;
    if (a3) {
      goto LABEL_14;
    }
  }
  else
  {
    BOOL v14 = 0;
    if (a3) {
      goto LABEL_14;
    }
  }
LABEL_18:
  BOOL v23 = 0;
  uint64_t v24 = &CGRectNull;
  double v25 = &CGRectNull.origin.y;
  double v26 = &CGRectNull.size;
  if (*(void *)(a4 + 592) != *(void *)(a4 + 600)) {
    double v26 = (CGSize *)(a4 + 104);
  }
  CGColorRef v27 = (CGFloat *)(a4 + 112);
  if (*(void *)(a4 + 592) == *(void *)(a4 + 600))
  {
    CGColorRef v27 = &CGRectNull.size.height;
  }
  else
  {
    double v25 = (CGFloat *)(a4 + 96);
    uint64_t v24 = (const CGRect *)(a4 + 88);
  }
  double height = *v27;
  double x = v24->origin.x;
  double y = *v25;
  double width = v26->width;
  v71.origin.double x = v24->origin.x;
  v71.origin.double y = y;
  v71.size.double width = width;
  v71.size.double height = height;
LABEL_24:
  if (a1 && !a1[16])
  {
    if (v14 || v23)
    {
      double v62 = (CGContext *)CGContextCreateWithDelegateAndInfo(a1, 0, a2, a3, 0, 0, a7, a8);
      if (!v62) {
        return;
      }
      double v63 = v62;
      v76.origin.double x = x;
      v76.origin.double y = y;
      v76.size.double width = width;
      v76.size.double height = height;
      CGContextBeginTransparencyLayerWithRect(v62, v76, v13);
      uint64_t v64 = (uint64_t *)*((void *)v63 + 13);
      double v32 = (atomic_uint *)*((void *)v63 + 14);
    }
    else
    {
      double v32 = (atomic_uint *)a2;
      if (!a2)
      {
        double v32 = CGRenderingStateCreate();
        if (!v32) {
          return;
        }
      }
      uint64_t v64 = CGGStackCreateWithGState(a3);
      double v63 = 0;
    }
    if (height == 1.79769313e308 && width == 1.79769313e308 && y == -8.98846567e307 && x == -8.98846567e307) {
      LODWORD(v68) = 0;
    }
    else {
      double v68 = &v71;
    }
    CG::DisplayList::execute(a4 + 16, (int)a1, (int)v32, (int)v64, (int)v68, 0);
    if (v63)
    {
      CGContextEndTransparencyLayer(v63);
      CFRelease(v63);
      return;
    }
    if (v64)
    {
      CGGStackReset(v64);
      free(v64);
    }
    if (v32 != (atomic_uint *)a2 && v32 && atomic_fetch_add_explicit(v32, 0xFFFFFFFF, memory_order_relaxed) == 1) {
      goto LABEL_96;
    }
  }
  else
  {
    double v32 = (atomic_uint *)a2;
    if (a2 || (double v32 = CGRenderingStateCreate()) != 0)
    {
      uint64_t v33 = (char *)a3;
      if (a3 || (uint64_t v33 = CGGStateCreate()) != 0)
      {
        if (v23)
        {
          CGMutablePathRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (Mutable)
          {
            float64x2_t v40 = Mutable;
            double v41 = (const void *)*MEMORY[0x1E4F1CFD0];
            if (*MEMORY[0x1E4F1CFD0]) {
              CFDictionarySetValue(Mutable, @"kCGContextGroup", v41);
            }
            uint64_t CGDisplayList = (const void *)CG::DisplayList::createCGDisplayList(a4, v40, (uint64_t)v41, v35, v36, v37, v38, v39);
            CFRelease(v40);
            if (CGDisplayList)
            {
              if (a1)
              {
                double v43 = (void (*)(void *, atomic_uint *, char *, uint64_t))a1[16];
                if (v43) {
                  v43(a1, v32, v33, a4);
                }
              }
              if (CGDisplayList != (const void *)a4) {
                CFRelease(CGDisplayList);
              }
            }
          }
        }
        else if (a1)
        {
          CGFloat v61 = (void (*)(void *, atomic_uint *, char *, uint64_t))a1[16];
          if (v61) {
            v61(a1, v32, v33, a4);
          }
        }
        if (v33 != (char *)a3) {
          CGGStateRelease((uint64_t)v33);
        }
      }
      if (v32 != (atomic_uint *)a2 && atomic_fetch_add_explicit(v32, 0xFFFFFFFF, memory_order_relaxed) == 1)
      {
LABEL_96:
        free(v32);
      }
    }
  }
}

void CGContextEndTransparencyLayer(CGContextRef c)
{
  if (c)
  {
    if (*((_DWORD *)c + 4) == 1129601108)
    {
      uint64_t v10 = CGGStackRestore(*((uint64_t **)c + 13), v1, v2, v3, v4, v5, v6, v7);
      *((void *)c + 12) = v10;
      uint64_t v16 = *((void *)c + 5);
      if (v16 && (double v17 = *(uint64_t (**)(void))(v16 + 200)) != 0 && (v18 = v17()) != 0)
      {
        double v19 = (const void *)v18;
        CGFloat v20 = (const void *)*((void *)c + 5);
        if (v20 != v19)
        {
          if (v20) {
            CFRelease(v20);
          }
          *((void *)c + 5) = v19;
        }
      }
      else
      {
        CGPostError((uint64_t)"CGContextEndTransparencyLayer: unbalanced transparency layers.", v9, v10, v11, v12, v13, v14, v15, v23);
      }
      return;
    }
    CGContextRef v21 = c;
  }
  else
  {
    CGContextRef v21 = 0;
  }

  handle_invalid_context((char)"CGContextEndTransparencyLayer", (uint64_t)v21, v2, v3, v4, v5, v6, v7);
}

uint64_t ripc_EndLayer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (a1) {
    uint64_t v6 = *(void *)(a1 + 288);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void **)(v6 + 88);
  if (v7)
  {
    Cache = CGColorTransformGetCache(*(void **)(v6 + 16));
    if (Cache)
    {
      uint64_t v9 = (CGColorSpace *)Cache[2];
      if (v9) {
        CFRetain((CFTypeRef)Cache[2]);
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    long long v75 = xmmword_185293580;
    long long v76 = unk_185293590;
    long long v77 = xmmword_1852935A0;
    uint64_t v78 = 0;
    long long v71 = xmmword_185293540;
    long long v72 = unk_185293550;
    long long v73 = xmmword_185293560;
    long long v74 = unk_185293570;
    long long v67 = xmmword_185293500;
    long long v68 = unk_185293510;
    long long v69 = xmmword_185293520;
    long long v70 = unk_185293530;
    long long v63 = RIPImageDataInitializer;
    long long v64 = *(_OWORD *)algn_1852934D0;
    long long v65 = xmmword_1852934E0;
    long long v66 = unk_1852934F0;
    uint64_t v60 = 0;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v57 = 0u;
    *(void *)(v6 + 88) = *v7;
    uint64_t v22 = *(void *)(v6 + 48);
    *(void *)(v6 + 48) = v7[4];
    char v23 = *(const void **)(v6 + 16);
    if (v23) {
      CFRelease(v23);
    }
    *(void *)(v6 + 16) = v7[1];
    *(_OWORD *)(v6 + 24) = *((_OWORD *)v7 + 1);
    ripc_ReleaseClipState((void **)(v6 + 72));
    *(void *)(v6 + 72) = v7[5];
    free(v7);
    memset(v56, 0, sizeof(v56));
    if (!ripc_GetRenderingState(v6, a2, a3, (uint64_t)v56) || !v22)
    {
      if (!v22) {
        return v5;
      }
      goto LABEL_41;
    }
    if (!(*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v22 + 32))(v22, 16, 0))
    {
LABEL_41:
      (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
      return v5;
    }
    if (*(int *)(v22 + 20) >= 1 && *(int *)(v22 + 24) >= 1 && *(void *)(v22 + 56))
    {
      if ((CGColorTransformConvertNeedsCMS(*(void **)(v6 + 120), v9, 0) & 1) == 0)
      {
        double v34 = 0;
        uint64_t v35 = *(void *)(v22 + 32);
        *(void *)&long long v65 = v35;
        DWORD2(v66) = *(_DWORD *)(v22 + 20);
        DWORD2(v65) = DWORD2(v66);
        HIDWORD(v66) = *(_DWORD *)(v22 + 24);
        *(void *)&long long v66 = 0;
        HIDWORD(v65) = HIDWORD(v66);
        LODWORD(v67) = *(_DWORD *)(v22 + 48);
        *((void *)&v67 + 1) = *(void *)(v22 + 56);
        *((void *)&v68 + 1) = *(void *)(v22 + 72);
        LODWORD(v68) = *(_DWORD *)(v22 + 64);
        long long v69 = 0uLL;
        goto LABEL_36;
      }
      uint64_t v53 = 0;
      size_t v24 = *(int *)(v22 + 24);
      int v54 = *(_DWORD *)(v22 + 20);
      int v55 = v24;
      int v25 = *(_DWORD *)(v22 + 48);
      uint64_t v26 = *(void *)(v22 + 72);
      v62[0] = *(void *)(v22 + 56);
      v62[1] = v26;
      int v27 = *(_DWORD *)(v22 + 64);
      v61[0] = v25;
      v61[1] = v27;
      uint64_t v28 = CGSImageDataLockPixels(v54, v24, (uint64_t)v62, v61, *(_DWORD **)(v22 + 32), v9, v54, v24, (uint64_t)&v53, 0, *(void **)(v6 + 120), *(_DWORD *)(v6 + 216), *(int **)(*(void *)(v6 + 48) + 32));
      if (v28)
      {
        double v34 = (uint64_t *)v28;
        RIPImageDataInitialize((uint64_t)&v63, v6, v28, v29, v30, v31, v32, v33);
        uint64_t v35 = v65;
LABEL_36:
        CGColorSpaceRelease(v9);
        if (v35 == RIPGetDepthForLayerFormat(0, v36, v37, v38, v39, v40, v41, v42)) {
          *(void *)&long long v65 = 0;
        }
        long long v57 = *(_OWORD *)(v22 + 12);
        uint64_t v60 = 0;
        *(void *)&long long v59 = 0;
        long long v58 = (unint64_t)&v63;
        DWORD2(v59) = 0;
        ripc_RenderImage(v6, a2, a3, (uint64_t *)v56, (int *)&v57, (uint64_t)&v57, v43, v44);
        if (v34) {
          CGSImageDataUnlock(v34);
        }
      }
    }
    (*(void (**)(uint64_t, void))(*(void *)v22 + 48))(v22, 0);
    goto LABEL_41;
  }
  uint64_t v5 = *(void *)(v6 + 96);
  if (v5)
  {
    *(void *)(v6 + 96) = 0;
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v10 = *(void *)(v6 + 48);
    if (v10)
    {
      if ((*(unsigned int (**)(uint64_t, uint64_t *))(*(void *)v10 + 72))(v10, &v51))
      {
        (*(void (**)(void, uint64_t))(**(void **)(v6 + 48) + 88))(*(void *)(v6 + 48), v6 + 40);
        double v11 = (double)(int)v51;
        double v12 = (double)SHIDWORD(v51);
        double v13 = (double)(int)v52;
        double v14 = (double)SHIDWORD(v52);
        double v15 = *(double *)(v6 + 40);
        if (v15 != 1.0)
        {
          double v16 = 1.0 / v15;
          double v11 = v16 * v11;
          double v12 = v16 * v12;
          double v13 = v16 * v13;
          double v14 = v16 * v14;
        }
        BOOL v17 = v11 == INFINITY || v12 == INFINITY;
        if (!v17 && v13 != 0.0 && v14 != 0.0)
        {
          uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, CGFloat, CGFloat, double, double))(v5 + 80);
          uint64_t v19 = *(void *)(v6 + 48);
          CGFloat v20 = CGColorTransformGetCache(*(void **)(v6 + 16));
          CGContextRef v21 = v20 ? (CGColorSpace *)v20[2] : 0;
          CGImageRef Image = RIPLayerCreateImage(v19, v21, v18 != ripc_DrawImage);
          if (Image)
          {
            unint64_t v47 = Image;
            long long v48 = *(_OWORD *)(a3 + 40);
            long long v63 = *(_OWORD *)(a3 + 24);
            long long v64 = v48;
            long long v65 = *(_OWORD *)(a3 + 56);
            *(CGAffineTransform *)(a3 + 24) = CGAffineTransformIdentity;
            uint64_t v49 = *(void (**)(uint64_t, uint64_t, uint64_t, CGDataProvider *, double, double, double, double))(v5 + 80);
            if (v49) {
              v49(v5, a2, a3, Image, v11, v12, v13, v14);
            }
            long long v50 = v64;
            *(_OWORD *)(a3 + 24) = v63;
            *(_OWORD *)(a3 + 40) = v50;
            *(_OWORD *)(a3 + 56) = v65;
            CFRelease(v47);
          }
        }
      }
    }
  }
  return v5;
}

void add_headroom_info_from_image_provider(void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
  }
  if (v2 == CGImageGetTypeID_image_type_id)
  {
    ImageProvider = CGImageGetImageProvider(a1);
    if (ImageProvider)
    {
      uint64_t v4 = (uint64_t)ImageProvider;
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
      if (ColorSpace)
      {
        uint64_t v6 = *((void *)ColorSpace + 3);
        if (*(_DWORD *)(v6 + 28) == 1)
        {
          int v19 = 0;
          if (*(unsigned char *)(v6 + 16) || *(unsigned char *)(v6 + 17) || *(unsigned char *)(v6 + 13))
          {
            Properdouble ty = *(const void **)(v4 + 120);
            if (Property) {
              Properdouble ty = CGPropertiesGetProperty((uint64_t)Property, @"kCGImageCalculateHeadroom");
            }
            if (Property == (const void *)*MEMORY[0x1E4F1CFD0])
            {
              ContentHeadroouint64_t m = calculate_headroom((uint64_t)a1, &v19);
              int v15 = v19;
            }
            else
            {
              ContentHeadroouint64_t m = CGImageProviderGetContentHeadroom(v4);
              int v15 = ContentHeadroom != 0.0;
              int v19 = v15;
              uint64_t v16 = *(void *)(v4 + 120);
              if (!v16
                || (BOOL v17 = CGPropertiesGetProperty(v16, @"kCGImageProviderColorSpaceChangedOnImageCopy")) == 0)
              {
                BOOL v17 = *(const void **)(v4 + 40);
              }
              if ((verify_headroom_and_colorspace((uint64_t)v17, (uint64_t)"add_headroom_info_from_image_provider", v8, v9, v10, v11, v12, v13, ContentHeadroom) & 1) == 0)
              {
                CGColorSpaceRef v18 = CGImageGetColorSpace((CGImageRef)a1);
                if (v18)
                {
                  if (*(unsigned char *)(*((void *)v18 + 3) + 13))
                  {
                    int v15 = 0;
                    int v19 = 0;
                    ContentHeadroouint64_t m = 0.0;
                  }
                }
              }
            }
          }
          else
          {
            int v15 = 1;
            int v19 = 1;
            ContentHeadroouint64_t m = 1.0;
          }
          CGImageSetHeadroom(a1, v15, ContentHeadroom);
        }
      }
    }
  }
}

uint64_t CGContextDrawImageWithOptions(uint64_t a1, CGImage *cf, const __CFDictionary *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  if (cf)
  {
    uint64_t v8 = cf;
    CFRetain(cf);
    CFTypeID v20 = CFGetTypeID(v8);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v20 != CGImageGetTypeID_image_type_id) {
      goto LABEL_35;
    }
    int v21 = *((_DWORD *)v8 + 7);
    if (v21 == 57005)
    {
      uint64_t v35 = "Image %p is over released";
    }
    else
    {
      if (v21 == 48879)
      {
        if (!CGImageGetImageProvider(v8) && !CGImageGetEPSRep(v8))
        {
          DataProviderInternal = CGImageGetDataProviderInternal((char *)v8, 0);
          if (CGDataProviderIsZombie(DataProviderInternal)) {
            goto LABEL_35;
          }
        }
        if (a1)
        {
          if (*(_DWORD *)(a1 + 16) == 1129601108)
          {
            CFTypeID v29 = CFGetTypeID(v8);
            if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
              dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
            }
            if (v29 == CGImageGetTypeID_image_type_id)
            {
              uint64_t v30 = 0;
              if (a4 == INFINITY) {
                goto LABEL_36;
              }
              if (a5 == INFINITY) {
                goto LABEL_36;
              }
              uint64_t v30 = 0;
              if (a6 == 0.0 || a7 == 0.0) {
                goto LABEL_36;
              }
              CopyWithProtectedDataProvider = CGImageCreateCopyWithProtectedDataProvider(v8);
              if (CopyWithProtectedDataProvider)
              {
                uint64_t v32 = CopyWithProtectedDataProvider;
                CFRelease(v8);
                uint64_t v8 = v32;
              }
              uint64_t CopyWithResolvedOptions = CGImageCreateCopyWithResolvedOptions((uint64_t)v8, a3);
              double v34 = (CGImage *)CopyWithResolvedOptions;
              if (!a3 || CopyWithResolvedOptions)
              {
                if (CopyWithResolvedOptions) {
                  CFRelease(v8);
                }
                else {
                  double v34 = v8;
                }
                ClipPath = (const CGPath *)CGImageGetClipPath(v34);
                if (ClipPath)
                {
                  CGContextSaveGState((CGContextRef)a1);
                  CGContextSaveGState((CGContextRef)a1);
                  CGContextTranslateCTM((CGContextRef)a1, a4, a5);
                  CGContextScaleCTM((CGContextRef)a1, a6, a7);
                  CGContextBeginPath((CGContextRef)a1);
                  CGContextAddPath((CGContextRef)a1, ClipPath);
                  CGContextRestoreGState((CGContextRef)a1);
                  clip(a1, 1, v42, v43, v44, v45, v46, v47);
                }
                if (*(void *)(a1 + 64))
                {
                  CGContextSaveGState((CGContextRef)a1);
                  uint64_t v48 = (*(uint64_t (**)(uint64_t, CGImage *, void, CGFloat, CGFloat, CGFloat, CGFloat))(a1 + 64))(a1, v34, *(void *)(a1 + 72), a4, a5, a6, a7);
                  if (v48)
                  {
                    uint64_t v49 = (const void *)v48;
                    uint64_t v50 = *(void *)(a1 + 40);
                    if (v50)
                    {
                      uint64_t v51 = *(void (**)(double, double, double, double))(v50 + 80);
                      if (v51) {
                        v51(a4, a5, a6, a7);
                      }
                    }
                    CFRelease(v49);
                  }
                  CGContextRestoreGState((CGContextRef)a1);
                }
                else
                {
                  uint64_t v61 = *(void *)(a1 + 40);
                  if (v61)
                  {
                    double v62 = *(void (**)(double, double, double, double))(v61 + 80);
                    if (v62) {
                      v62(a4, a5, a6, a7);
                    }
                  }
                }
                if (should_highlight_2x_scaled_images_once != -1) {
                  dispatch_once(&should_highlight_2x_scaled_images_once, &__block_literal_global_12430);
                }
                if (should_highlight_2x_scaled_images_highlight_2x_scaled_images
                  && is_2x_scale((CGContext *)a1, (uint64_t)v34, a4, a5, a6, a7))
                {
                  CGContextSaveGState((CGContextRef)a1);
                  CGContextSetBlendMode((CGContextRef)a1, kCGBlendModeNormal);
                  CGContextSetRGBFillColor((CGContextRef)a1, 1.0, 0.0, 0.0, 0.2);
                  v64.origin.double x = a4;
                  v64.origin.double y = a5;
                  v64.size.double width = a6;
                  v64.size.double height = a7;
                  CGContextFillRect((CGContextRef)a1, v64);
                  CGContextRestoreGState((CGContextRef)a1);
                }
                if (should_track_image_drawing_once != -1) {
                  dispatch_once(&should_track_image_drawing_once, &__block_literal_global_26_12431);
                }
                if (should_track_image_drawing_should_track)
                {
                  CGContextSaveGState((CGContextRef)a1);
                  CGContextSetBlendMode((CGContextRef)a1, kCGBlendModeNormal);
                  double v52 = a7 * 0.5;
                  DelegateName = (const char *)CGContextGetDelegateName(a1, v53, v54, v55, v56, v57, v58, v59);
                  if (DelegateName && !strcmp(DelegateName, "RIPContextDelegate"))
                  {
                    CGContextSetRGBFillColor((CGContextRef)a1, 0.0, 1.0, 0.0, 0.2);
                  }
                  else
                  {
                    CGContextSetRGBFillColor((CGContextRef)a1, 0.0, 0.0, 1.0, 0.2);
                    a5 = v52;
                  }
                  v65.origin.double x = a4;
                  v65.origin.double y = a5;
                  v65.size.double width = a6;
                  v65.size.double height = v52;
                  CGContextFillRect((CGContextRef)a1, v65);
                  CGContextRestoreGState((CGContextRef)a1);
                }
                if (ClipPath) {
                  CGContextRestoreGState((CGContextRef)a1);
                }
                uint64_t v30 = 1;
                uint64_t v8 = v34;
                goto LABEL_36;
              }
            }
LABEL_35:
            uint64_t v30 = 0;
LABEL_36:
            CFRelease(v8);
            return v30;
          }
          uint64_t v39 = a1;
        }
        else
        {
          uint64_t v39 = 0;
        }
        handle_invalid_context((char)"CGContextDrawImageWithOptions", v39, v22, v23, v24, v25, v26, v27);
        goto LABEL_35;
      }
      uint64_t v35 = "Object %p is not a CGImageRef";
    }
    CGLog(3, (uint64_t)v35, v14, v15, v16, v17, v18, v19, (char)v8);
    if (CGOSAppleInternalBuild_predicate != -1) {
      dispatch_once(&CGOSAppleInternalBuild_predicate, &__block_literal_global_18177);
    }
    if (CGOSAppleInternalBuild_is_internal) {
      _CGHandleAssert("CGImageIsZombie", 4444, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "0", "-", v36, v37, v38, v63);
    }
    goto LABEL_35;
  }
  return 0;
}

void *CGImageGetImageProvider(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[26];
    }
    else {
      return 0;
    }
  }
  return result;
}

char *CGImageGetDataProviderInternal(char *result, int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v4 == CGImageGetTypeID_image_type_id)
    {
      if (*((void *)v3 + 26))
      {
        pthread_mutex_lock((pthread_mutex_t *)(v3 + 80));
        if (!*((void *)v3 + 19))
        {
          uint64_t v5 = (CGDataProvider *)CGDataProviderCreateWithImageProvider(*((void *)v3 + 26));
          uint64_t v6 = v5;
          if (a2)
          {
            CFDataRef v7 = CGDataProviderCopyData(v5);
            if (v7)
            {
              CFDataRef v8 = v7;
              CGDataProviderRelease(v6);
              *((void *)v3 + 19) = CGDataProviderCreateWithCFData(v8);
              CFRelease(v8);
            }
          }
          else
          {
            *((void *)v3 + 19) = v5;
          }
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v3 + 80));
      }
      return (char *)*((void *)v3 + 19);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *CGImageGetClipPath(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[25];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t CGImageCreateCopyWithResolvedOptions(uint64_t a1, const __CFDictionary *cf)
{
  CFDictionaryRef v2 = cf;
  if (!cf)
  {
    unint64_t v8 = 0;
    CFDictionaryRef v9 = 0;
    goto LABEL_7;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
  {
    unint64_t v8 = 0;
    CFDictionaryRef v9 = 0;
    CFDictionaryRef v2 = 0;
    goto LABEL_7;
  }
  CFDictionaryRef Value = CFDictionaryGetValue(v2, @"kCGImageDestinationLossyCompressionQuality");
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    BOOL v7 = v6 == CFNumberGetTypeID();
  }
  else
  {
    BOOL v7 = 0;
  }
  uint64_t v13 = CFDictionaryGetValue(v2, @"kCGImageForceConversion");
  BOOL v16 = v13
     && (uint64_t v14 = v13, v15 = CFGetTypeID(v13), v15 == CFBooleanGetTypeID())
     && v14 == (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v17 = CFDictionaryGetValue(v2, @"kCGImagePreferGPUForColorConversion");
  if (!v17 || (uint64_t v18 = v17, v19 = CFGetTypeID(v17), v19 != CFBooleanGetTypeID()))
  {
    CopyWithImageProvider = 0;
    char v48 = 1;
LABEL_45:
    CFDictionaryRef v9 = (const __CFDictionary *)CFDictionaryGetValue(v2, @"kCGColorConversionInfoOptions");
    unint64_t v8 = (unint64_t)CFDictionaryGetValue(v2, @"kCGColorConversionInfoPayload");
    uint64_t v49 = *(void *)(a1 + 192);
    if (v49) {
      char v50 = v16;
    }
    else {
      char v50 = 1;
    }
    if ((v48 & 1) == 0 && (v50 & 1) == 0)
    {
      if (CopyWithImageProvider) {
        CFRelease(CopyWithImageProvider);
      }
      return 0;
    }
    if (v49) {
      int v51 = v16;
    }
    else {
      int v51 = 1;
    }
    if ((v7 & v51) == 1)
    {
      CFMutableDataRef Mutable = CFDataCreateMutable(0, 0);
      if (CGImageCreateCopyWithResolvedOptions_predicate != -1) {
        dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate, &__block_literal_global_77_5131);
      }
      uint64_t CopyWithResolvedOptions_f = CGImageCreateCopyWithResolvedOptions_f(Mutable, @"public.jpeg", 1, 0);
      if (CopyWithResolvedOptions_f)
      {
        uint64_t v54 = (const void *)CopyWithResolvedOptions_f;
        CFMutableDictionaryRef v55 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v55)
        {
          CFDataRef v79 = Mutable;
          uint64_t v56 = v55;
          uint64_t v57 = CFDictionaryGetValue(v2, @"kCGImageDestinationLossyCompressionQuality");
          unint64_t v80 = v56;
          CFDictionarySetValue(v56, @"kCGImageDestinationLossyCompressionQuality", v57);
          if (CGImageCreateCopyWithResolvedOptions_predicate_83 != -1) {
            dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_83, &__block_literal_global_86_5133);
          }
          uint64_t v58 = v56;
          CGImageCreateCopyWithResolvedOptions_f_82(v54, a1, v56);
          CFMutableDataRef Mutable = v79;
          if (CGImageCreateCopyWithResolvedOptions_predicate_89 != -1) {
            dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_89, &__block_literal_global_92_5134);
          }
          if (CGImageCreateCopyWithResolvedOptions_f_88(v54)
            && (CGDataProviderRef v59 = CGDataProviderCreateWithCFData(v79)) != 0)
          {
            CGDataProviderRef provider = v59;
            CFDictionaryRef v2 = CGImageCreateWithJPEGDataProvider2((uint64_t)v59, 0, 0, 1, 0);
            if (v2)
            {
              if (is_jpg_image(a1))
              {
                if (CGImageCreateCopyWithResolvedOptions_predicate_95 != -1) {
                  dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_95, &__block_literal_global_98_5135);
                }
                CFDataRef CopyWithResolvedOptions_f_94 = (const __CFData *)CGImageCreateCopyWithResolvedOptions_f_94(a1);
              }
              else
              {
                DataProviderInternal = CGImageGetDataProviderInternal((char *)a1, 0);
                CFDataRef CopyWithResolvedOptions_f_94 = CGDataProviderCopyData((CGDataProviderRef)DataProviderInternal);
              }
              CFDataRef v62 = CopyWithResolvedOptions_f_94;
              if (CopyWithResolvedOptions_f_94
                && ((CFIndex Length = CFDataGetLength(CopyWithResolvedOptions_f_94),
                     CFIndex v76 = CFDataGetLength(v79),
                     CFRelease(v62),
                     Length > v76)
                  ? (int v63 = 1)
                  : (int v63 = v16),
                    v63 != 1))
              {
                CFRelease(v2);
                CFDictionaryRef v2 = 0;
              }
              else
              {
                copy_image_mask_and_matte((uint64_t)v2, (uint64_t **)a1);
              }
              uint64_t v58 = v80;
            }
            CGDataProviderRelease(provider);
          }
          else
          {
            CFDictionaryRef v2 = 0;
          }
          CFRelease(v58);
        }
        else
        {
          CFDictionaryRef v2 = 0;
        }
        CFRelease(v54);
      }
      else
      {
        CFDictionaryRef v2 = 0;
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    else
    {
      CFDictionaryRef v2 = 0;
    }
    if ((v48 & 1) == 0)
    {
      if (v2)
      {
        if (CopyWithImageProvider) {
          CFRelease(CopyWithImageProvider);
        }
      }
      else
      {
        CFDictionaryRef v2 = (const __CFDictionary *)CopyWithImageProvider;
      }
    }
LABEL_7:
    if (!((unint64_t)v9 | v8))
    {
      a1 = (uint64_t)v2;
LABEL_21:
      CGImageSetCachingFlags((unsigned char *)a1, 1);
      return a1;
    }
    if (v2) {
      uint64_t v10 = v2;
    }
    else {
      uint64_t v10 = (CGImage *)a1;
    }
    Copdouble y = CGImageCreateCopy(v10);
    a1 = (uint64_t)Copy;
    if (v9)
    {
      if (CGImageSetColorConversionInfoOptions((uint64_t)Copy, v9))
      {
LABEL_19:
        if (v2) {
          CFRelease(v2);
        }
        goto LABEL_21;
      }
    }
    else if (CGImageSetColorConversionInfoPayload((uint64_t)Copy, (const void *)v8))
    {
      goto LABEL_19;
    }
    if (a1) {
      CFRelease((CFTypeRef)a1);
    }
    a1 = 0;
    goto LABEL_19;
  }
  ImageProvider = CGImageGetImageProvider((void *)a1);
  if (v18 == (const void *)*MEMORY[0x1E4F1CFC8])
  {
    int v21 = ImageProvider;
    if (ImageProvider)
    {
      uint64_t v22 = ImageProvider[15];
      if (v22)
      {
        if (CGPropertiesGetProperty(v22, @"kCGImagePreferGPUForColorConversion"))
        {
          if (get_disable_GPU_provider_options_predicate != -1) {
            dispatch_once(&get_disable_GPU_provider_options_predicate, &__block_literal_global_353);
          }
          uint64_t v23 = (const void *)get_disable_GPU_provider_options_options_singleton;
          CFTypeID v30 = CFGetTypeID(v21);
          if (kCGImageProviderContentHeadroom_block_invoke_once != -1) {
            dispatch_once(&kCGImageProviderContentHeadroom_block_invoke_once, &__block_literal_global_89_3449);
          }
          if (v30 != CGImageProviderGetTypeID_image_provider_type_id) {
            return 0;
          }
          uint64_t Instance = CGTypeCreateInstance(CGImageProviderGetTypeID_image_provider_type_id, 152, v24, v25, v26, v27, v28, v29);
          if (!Instance) {
            return 0;
          }
          uint64_t v39 = Instance;
          *(void *)(Instance + 56) = Instance;
          *(_OWORD *)(Instance + 16) = *((_OWORD *)v21 + 1);
          *(void *)(Instance + 32) = v21[4];
          uint64_t v40 = v21[5];
          if (v40) {
            CFRetain((CFTypeRef)v21[5]);
          }
          *(void *)(v39 + 40) = v40;
          *(void *)(v39 + 48) = v21[6];
          long long v41 = 0uLL;
          switch(*((_DWORD *)v21 + 16))
          {
            case 0:
              CGPostError((uint64_t)"We should not need CGImageProviderCreateCopyWithOptions with version 0", v32, v33, v34, v35, v36, v37, v38, v75);
              long long v41 = 0uLL;
              int v42 = 0;
              int v43 = 0;
              uint64_t v44 = 0;
              uint64_t v45 = copy_with_options_release_info;
              uint64_t v46 = copy_with_options_copy_block_set;
              break;
            case 1:
              int v43 = 0;
              uint64_t v44 = 0;
              uint64_t v45 = copy_with_options_release_info;
              uint64_t v46 = copy_with_options_copy_block_set_with_options;
              int v42 = 1;
              break;
            case 2:
              uint64_t v44 = 0;
              int v43 = *((_DWORD *)v21 + 17);
              *(void *)&long long v41 = copy_with_options_release_info;
              uint64_t v45 = (void (*)(uint64_t))v21[10];
              uint64_t v46 = copy_with_options_copy_block_set_with_options;
              int v42 = 2;
              break;
            case 3:
              int v43 = *((_DWORD *)v21 + 17);
              uint64_t v45 = (void (*)(uint64_t))v21[10];
              long long v41 = *(_OWORD *)(v21 + 11);
              uint64_t v44 = copy_with_options_release_info;
              uint64_t v46 = copy_with_options_copy_block_set_with_options;
              int v42 = 3;
              break;
            default:
              int v42 = 0;
              int v43 = 0;
              uint64_t v46 = 0;
              uint64_t v45 = 0;
              uint64_t v44 = 0;
              break;
          }
          *(_DWORD *)(v39 + 64) = v42;
          *(_DWORD *)(v39 + 68) = v43;
          *(void *)(v39 + 72) = v46;
          *(void *)(v39 + 80) = v45;
          *(_OWORD *)(v39 + 88) = v41;
          *(void *)(v39 + 104) = v44;
          if (v23) {
            CFTypeRef v64 = CFRetain(v23);
          }
          else {
            CFTypeRef v64 = 0;
          }
          *(void *)(v39 + 112) = v64;
          CGRect v65 = (atomic_uint *)v21[15];
          if (v65) {
            atomic_fetch_add_explicit(v65, 1u, memory_order_relaxed);
          }
          *(void *)(v39 + 120) = v65;
          *(_WORD *)(v39 + 128) = *((_WORD *)v21 + 64);
          CFRetain(v21);
          *(void *)(v39 + 144) = v21;
          *(_DWORD *)(v39 + 132) = *((_DWORD *)v21 + 33);
          CFMutableDictionaryRef v66 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          *(void *)(v39 + 160) = v66;
          context[0] = 0;
          context[1] = v21;
          void context[2] = v66;
          if (v23)
          {
            CFDictionaryApplyFunction((CFDictionaryRef)v23, (CFDictionaryApplierFunction)find_supported_options, context);
            char v74 = context[0];
          }
          else
          {
            char v74 = 0;
          }
          *(unsigned char *)(v39 + 152) = v74;
          *(void *)(v39 + 136) = create_debug_string(v39, v67, v68, v69, v70, v71, v72, v73);
          CopyWithImageProvider = (unsigned char *)CGImageCreateCopyWithImageProvider((char *)a1, v39);
          CGImageSetCachingFlags(CopyWithImageProvider, 1);
          CFRelease((CFTypeRef)v39);
          char v48 = 0;
          a1 = (uint64_t)CopyWithImageProvider;
          goto LABEL_45;
        }
      }
    }
  }
  if (a1) {
    CFRetain((CFTypeRef)a1);
  }
  return a1;
}

void CGImageSetCachingFlags(unsigned char *a1, char a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v4 == CGImageGetTypeID_image_type_id) {
      a1[36] = a2;
    }
  }
}

CGImage *CGImageCreateCopyWithProtectedDataProvider(CGImage *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    uint64_t v2 = *((void *)a1 + 19);
    if (!v2
      || *(uint64_t (**)(uint64_t))(v2 + 80) != data_get_byte_pointer
      || *(void *)(*(void *)(v2 + 24) + 24))
    {
      return 0;
    }
    if (use_protected_copy_predicate != -1) {
      dispatch_once(&use_protected_copy_predicate, &__block_literal_global_349);
    }
    if (!use_protected_copy_status) {
      return 0;
    }
    uint64_t v4 = *((void *)v1 + 19);
    unint64_t v5 = CGDataProviderRetainBytePtr(v4);
    if (!v5) {
      return 0;
    }
    unint64_t v6 = v4 ? *(void *)(v4 + 32) : -1;
    protected_copdouble y = create_protected_copy(v5, v6);
    unint64_t v8 = CGDataProviderCreateWithCFData(protected_copy);
    CGDataProviderReleaseBytePtr(v4);
    if (protected_copy) {
      CFRelease(protected_copy);
    }
    if (v8)
    {
      Copdouble y = CGImageCreateCopy(v1);
      uint64_t v1 = Copy;
      if (Copy)
      {
        CGDataProviderRelease(*((CGDataProviderRef *)Copy + 19));
        *((void *)v1 + 19) = v8;
      }
      else
      {
        CGDataProviderRelease(v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t ripc_DrawImage(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, CGFloat x, CGFloat y, double width, double height)
{
  uint64_t v8 = (uint64_t)a4;
  if (a1) {
    CFTypeID v15 = *(double **)(a1 + 288);
  }
  else {
    CFTypeID v15 = 0;
  }
  uint64_t v62 = 0;
  memset(v61, 0, sizeof(v61));
  EPSRep = CGImageGetEPSRep(a4);
  if (EPSRep) {
    uint64_t v8 = EPSRep[3];
  }
  memset(v70, 0, 48);
  long long v17 = *(_OWORD *)(a3 + 56);
  long long v18 = *(_OWORD *)(a3 + 40);
  long long v59 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)uint64_t v60 = v18;
  *(_OWORD *)&v60[16] = v17;
  double v19 = v15[5];
  if (v19 == 1.0)
  {
    double v21 = *((double *)&v59 + 1);
    double v22 = *(double *)&v59;
    v23.f64[0] = *(float64_t *)&v60[8];
    double v20 = *(double *)v60;
  }
  else
  {
    double v20 = v19 * *(double *)v60;
    double v21 = v19 * *((double *)&v59 + 1);
    double v22 = v19 * *(double *)&v59;
    *(double *)&long long v59 = v19 * *(double *)&v59;
    *((double *)&v59 + 1) = v19 * *((double *)&v59 + 1);
    *(double *)uint64_t v60 = v19 * *(double *)v60;
    float64x2_t v23 = vmulq_n_f64(*(float64x2_t *)&v60[8], v19);
    *(float64x2_t *)&_DWORD v60[8] = v23;
    *(double *)&v60[24] = v19 * *(double *)&v60[24];
  }
  v69[0] = 0;
  v69[1] = 0;
  v67[0] = 0;
  v67[1] = 0;
  double v24 = height * v20;
  double v57 = v23.f64[0];
  SubsampledCGImageRef Image = CGImageCreateSubsampledImage(v8, height * v20 + v22 * width, height * v23.f64[0] + v21 * width);
  CGImageRef v26 = SubsampledImage;
  if (SubsampledImage) {
    uint64_t v27 = (uint64_t)SubsampledImage;
  }
  else {
    uint64_t v27 = v8;
  }
  int v30 = *(void *)v15
     && (uint64_t v28 = *(uint64_t (**)(void))(*(void *)v15 + 248)) != 0
     && (uint64_t v29 = v28()) != 0
     && *(_DWORD *)(v29 + 40) == 7;
  unint64_t v65 = 0;
  int64_t v66 = 0;
  alternate_CGImageRef image = create_alternate_image(v27, v30);
  uint64_t v32 = alternate_image;
  if (alternate_image) {
    uint64_t v33 = (CGImage *)alternate_image;
  }
  else {
    uint64_t v33 = (CGImage *)v27;
  }
  if ((ripc_GetImageSize((uint64_t)v33, (unint64_t *)&v66, &v65) & 1) == 0) {
    goto LABEL_52;
  }
  unint64_t v35 = v65;
  unint64_t v34 = v66;
  unint64_t v63 = v65;
  unint64_t v64 = v66;
  if ((ripc_GetRenderingState((uint64_t)v15, a2, a3, (uint64_t)v70) & 1) == 0) {
    goto LABEL_52;
  }
  v68[0] = 0;
  v68[1] = 0;
  if (width < 0.0 || height < 0.0)
  {
    v71.origin.double x = x;
    v71.origin.double y = y;
    v71.size.double width = width;
    v71.size.double height = height;
    CGRect v72 = CGRectStandardize(v71);
    double x = v72.origin.x;
    double y = v72.origin.y;
    double width = v72.size.width;
    double height = v72.size.height;
    double v24 = v72.size.height * v20;
  }
  *(double *)&long long v59 = v20 * 0.0 + width * v22;
  *((double *)&v59 + 1) = v57 * 0.0 + width * v21;
  *(double *)uint64_t v60 = v24 + v22 * 0.0;
  *(double *)&_DWORD v60[8] = height * v57 + v21 * 0.0;
  *(double *)&v60[16] = *(double *)&v60[16] + v20 * y + x * v22;
  *(double *)&v60[24] = v57 * y + x * v21 + *(double *)&v60[24];
  ImageTransformatiouint64_t n = ripc_GetImageTransformation(v33, (int *)&v70[1] + 2, v34, v35, 0, (double *)&v59, (uint64_t)v69, (int *)v68, (uint64_t)v67);
  if (!ImageTransformation) {
    goto LABEL_52;
  }
  unint64_t v37 = ImageTransformation;
  uint64_t RenderingIntent = CGImageGetRenderingIntent(v33);
  if (!RenderingIntent)
  {
    unsigned int v39 = *(_DWORD *)(*(void *)(a3 + 120) + 4);
    int v40 = v39 << 12;
    if (((v39 >> 20) & 0xF) != 0) {
      int v41 = v39 << 8;
    }
    else {
      int v41 = v39 << 12;
    }
    if (!(v41 >> 28)) {
      int v41 = v40;
    }
    uint64_t RenderingIntent = (v41 >> 28);
  }
  if (v37 >= 4)
  {
    BOOL ShouldInterpolate = CGImageGetShouldInterpolate(v33);
    ImageInterpolatiouint64_t n = ripc_GetImageInterpolation(a2, *(_DWORD *)(*(void *)(a3 + 120) + 4), ShouldInterpolate);
    if (ImageInterpolation >= 3)
    {
      if ((v37 & 2) != 0) {
        uint64_t v46 = 0;
      }
      else {
        uint64_t v46 = (int *)v69;
      }
      if (ripc_GetImageInterpolationSize((double *)&v59, (int64_t *)&v64, &v63, v46)) {
        uint64_t v42 = ImageInterpolation;
      }
      else {
        uint64_t v42 = 1;
      }
      unint64_t v43 = v63;
      unint64_t v44 = v64;
    }
    else
    {
      uint64_t v42 = 1;
      unint64_t v43 = v35;
      unint64_t v44 = v34;
    }
  }
  else
  {
    uint64_t v42 = 1;
    unint64_t v43 = v35;
    unint64_t v44 = v34;
    ImageInterpolatiouint64_t n = 1;
  }
  if ((v37 & 2) != 0) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = v69;
  }
  char v48 = (double *)ripc_AcquireRIPImageData((uint64_t)v15, v33, v44, v43, (uint64_t)v47, 0, v42, RenderingIntent);
  if (v48)
  {
    double v52 = v48;
    if (v37 >= 4) {
      uint64_t v53 = (double *)&v59;
    }
    else {
      uint64_t v53 = 0;
    }
    ripc_InitializeImage((uint64_t)v61, (uint64_t)v68, v48, ImageInterpolation, v34, v35, v53, 0, v49, v50, v51);
    ripc_RenderImage((uint64_t)v15, a2, a3, (uint64_t *)v70, (int *)v67, (uint64_t)v61, v54, v55);
    ripc_ReleaseRIPImageData(v52);
LABEL_52:
    if (v32) {
      CFRelease(v32);
    }
    if (v26) {
      CFRelease(v26);
    }
    return 0;
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v26) {
    CFRelease(v26);
  }
  return 1000;
}

void *CGImageGetEPSRep(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      return (void *)v1[24];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t ripc_GetInternalBitmapContextInfo(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 288) + 8);
}

char *ripc_RenderImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 81) && (*(unsigned char *)(*(void *)(a3 + 120) + 7) & 1) != 0)
  {
    *(_WORD *)(a1 + 108) = *(_WORD *)(a1 + 108) | 0xFF00;
    __int16 v14 = -256;
  }
  else
  {
    __int16 v14 = 0;
    *(_WORD *)(a1 + 108) = *(unsigned __int8 *)(a1 + 108);
  }
  CFTypeID v15 = (int *)(a1 + 104);
  *(_WORD *)(a1 + 108) = v14 | *(unsigned __int8 *)(a2 + 82);
  uint64_t v16 = *(void *)(a3 + 120);
  *(_DWORD *)(a1 + 112) = (int)(*(_DWORD *)(v16 + 4) << 12) >> 28;
  uint64_t v17 = *(void *)(a6 + 16);
  if (*(void *)(v17 + 32))
  {
    *(_DWORD *)(a1 + 104) = (int)(*(_DWORD *)(v16 + 4) << 16) >> 24;
    float v18 = *(double *)(v16 + 8);
    *(double *)(a1 + 152) = v18;
    double v19 = (unsigned char *)a4[5];
    if (v19 && (v19[12] & 0x40) != 0)
    {
      uint64_t v45 = *(uint64_t (**)(void))(*(void *)v19 + 72);
      return (char *)v45();
    }
    else
    {
      uint64_t v20 = *(void *)(a1 + 48);
      uint64_t v21 = *a4;
      return (char *)RIPLayerBltImage(v20, v21, (uint64_t)a5, a6, a1 + 104, a6, a7, a8);
    }
  }
  else
  {
    long long v53 = xmmword_185293208;
    long long v54 = unk_185293218;
    long long v55 = xmmword_185293228;
    long long v49 = xmmword_1852931C8;
    long long v50 = unk_1852931D8;
    long long v51 = xmmword_1852931E8;
    long long v52 = unk_1852931F8;
    long long v47 = RIPLayerObjectInitializer;
    long long v48 = unk_1852931B8;
    uint64_t v46 = 0;
    uint64_t v23 = *(unsigned int *)(a2 + 4);
    if (*a4
      || *(void *)(v17 + 96)
      || *(void *)(a6 + 24)
      || *(void *)(a6 + 48)
      || *(void *)(a6 + 32)
      || *(_DWORD *)(a6 + 8) != *(_DWORD *)(v17 + 56)
      || *(_DWORD *)(a6 + 12) != *(_DWORD *)(v17 + 60))
    {
      uint64_t result = RIPLayerCreate((uint64_t)RIPLayer_ripl_class, (uint64_t)a5, 0, 0, *(unsigned int *)(a2 + 4), a6, a7, a8);
      if (!result) {
        return result;
      }
      uint64_t v29 = (long long *)result;
      *(_DWORD *)(a1 + 104) = 1;
      *(void *)(a1 + 152) = 0x3FF0000000000000;
      RIPLayerBltImage((uint64_t)result, 0, (uint64_t)a5, a6, a1 + 104, v31, v32, v33);
    }
    else
    {
      BOOL v24 = RIPLayerInitialize((uint64_t)&v47, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
      uint64_t v28 = *(void *)(a6 + 16);
      if (v24)
      {
        uint64_t v29 = &v47;
        RIPLayerReplace((uint64_t)&v47, a6, *(unsigned int *)(v28 + 64), *(void *)(v28 + 72), 0, 0, v25, v26, v27);
        HIDWORD(v48) |= 2u;
      }
      else
      {
        uint64_t result = RIPLayerCreateWithData((uint64_t *)a6, 2, 0, *(unsigned int *)(v28 + 64), *(void *)(v28 + 72), 0, 0, v23);
        uint64_t v29 = (long long *)result;
        if (!result) {
          return result;
        }
      }
    }
    Color = ripc_GetColor(a1, a2, a3, 2, a5, (uint64_t)&v46, (double *)(a1 + 152), v30);
    if (Color)
    {
      uint64_t v36 = (uint64_t)Color;
      *CFTypeID v15 = (int)(*(_DWORD *)(*(void *)(a3 + 120) + 4) << 16) >> 24;
      unint64_t v37 = (unsigned char *)a4[5];
      if (v37 && (v37[12] & 0x10) != 0) {
        (*(void (**)(unsigned char *, void, uint64_t, int *, long long *, uint64_t, uint64_t *, uint64_t))(*(void *)v37 + 56))(v37, *(void *)(a1 + 48), *a4, a5, v29, v36, &v46, a1 + 104);
      }
      else {
        RIPLayerBltShape(*(int **)(a1 + 48), *a4, a5, (uint64_t)v29, v36, &v46, a1 + 104, v35);
      }
      RIPObjectRelease(v36, v38, v39, v40, v41, v42, v43, v44);
    }
    return (char *)(*(uint64_t (**)(long long *))(*(void *)v29 + 24))(v29);
  }
}

CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LODWORD(image) = (__int16)*((_DWORD *)v1 + 9) >> 8;
    }
    else {
      LODWORD(image) = 0;
    }
  }
  return (int)image;
}

unint64_t ripc_GetImageTransformation(void *a1, int *a2, unint64_t a3, unint64_t a4, double *a5, double *a6, uint64_t a7, int *a8, uint64_t a9)
{
  if (a1 && (Masuint64_t k = CGImageGetMask(a1)) != 0 && (Mask[5] > a1[5] || Mask[6] > a1[6])) {
    unint64_t v18 = 7;
  }
  else {
    unint64_t v18 = 3;
  }
  int v19 = a2[3];
  int v20 = a2[1];
  double v21 = (double)*a2;
  double v23 = a6[4];
  double v22 = a6[5];
  double v24 = *a6;
  double v25 = a6[1];
  double v26 = a6[2];
  double v27 = a6[3];
  double v28 = v23 + *a6;
  double v29 = v22 + v25;
  if (v28 > v23) {
    double v30 = v23 + *a6;
  }
  else {
    double v30 = a6[4];
  }
  if (v28 >= v23)
  {
    double v31 = a6[4];
  }
  else
  {
    double v30 = a6[4];
    double v31 = v23 + *a6;
  }
  if (v29 > v22) {
    double v32 = v22 + v25;
  }
  else {
    double v32 = a6[5];
  }
  if (v29 >= v22)
  {
    double v33 = a6[5];
  }
  else
  {
    double v32 = a6[5];
    double v33 = v22 + v25;
  }
  double v34 = v28 + v26;
  double v35 = v29 + v27;
  if (v28 + v26 > v30) {
    double v36 = v28 + v26;
  }
  else {
    double v36 = v30;
  }
  if (v34 >= v31) {
    double v37 = v36;
  }
  else {
    double v37 = v30;
  }
  if (v34 >= v31) {
    double v38 = v31;
  }
  else {
    double v38 = v34;
  }
  if (v35 > v32) {
    double v39 = v29 + v27;
  }
  else {
    double v39 = v32;
  }
  if (v35 >= v33) {
    double v40 = v39;
  }
  else {
    double v40 = v32;
  }
  if (v35 >= v33) {
    double v41 = v33;
  }
  else {
    double v41 = v35;
  }
  double v42 = (double)a2[2] + v21;
  double v43 = v35 - v25;
  if (v34 - v24 >= v38)
  {
    if (v34 - v24 > v37) {
      double v37 = v34 - v24;
    }
  }
  else
  {
    double v38 = v34 - v24;
  }
  if (v43 > v40) {
    double v44 = v35 - v25;
  }
  else {
    double v44 = v40;
  }
  if (v43 >= v41) {
    double v45 = v44;
  }
  else {
    double v45 = v40;
  }
  if (v43 < v41) {
    double v41 = v35 - v25;
  }
  if (v38 >= v21) {
    double v46 = v38;
  }
  else {
    double v46 = (double)*a2;
  }
  if (v37 <= v42) {
    double v47 = v37;
  }
  else {
    double v47 = (double)a2[2] + v21;
  }
  if (v46 >= v47) {
    return 0;
  }
  double v48 = (double)v19 + (double)v20;
  double v49 = v41 >= (double)v20 ? v41 : (double)v20;
  BOOL v50 = v41 < (double)v20 || v38 < v21;
  BOOL v51 = !v50 && v37 <= v42;
  BOOL v52 = v51 && v45 <= v48;
  unint64_t result = v52 ? v18 : v18 & 0xFFFFFFFFFFFFFFFDLL;
  double v54 = v45 <= v48 ? v45 : (double)v19 + (double)v20;
  if (v49 >= v54) {
    return 0;
  }
  double v55 = v38 + v37 - v38;
  double v56 = v38 + 0.00390625;
  if (v38 + 0.00390625 <= 1073741820.0)
  {
    unsigned int v58 = vcvtmd_s64_f64(v56);
    if (v56 >= -1073741820.0) {
      int v57 = v58;
    }
    else {
      int v57 = -1073741823;
    }
  }
  else
  {
    int v57 = 0x3FFFFFFF;
  }
  double v59 = v45 - v41;
  *a8 = v57;
  double v60 = v55 + -0.00390625;
  if (v60 <= 1073741820.0)
  {
    unsigned int v62 = vcvtpd_s64_f64(v60);
    if (v60 >= -1073741820.0) {
      int v61 = v62;
    }
    else {
      int v61 = -1073741823;
    }
  }
  else
  {
    int v61 = 0x3FFFFFFF;
  }
  int v63 = v61 - v57;
  a8[2] = v63;
  double v64 = v41 + v59;
  double v65 = v41 + 0.00390625;
  if (v65 <= 1073741820.0)
  {
    unsigned int v66 = vcvtmd_s64_f64(v65);
    if (v65 < -1073741820.0) {
      unsigned int v66 = -1073741823;
    }
  }
  else
  {
    unsigned int v66 = 0x3FFFFFFF;
  }
  double v67 = (double)a3;
  double v68 = (double)a4;
  a8[1] = v66;
  double v69 = v64 + -0.00390625;
  if (v69 <= 1073741820.0)
  {
    unsigned int v70 = vcvtpd_s64_f64(v69);
    if (v69 < -1073741820.0) {
      unsigned int v70 = -1073741823;
    }
  }
  else
  {
    unsigned int v70 = 0x3FFFFFFF;
  }
  double v71 = 1.0 / v67;
  unsigned int v72 = v70 - v66;
  a8[3] = v72;
  double v73 = 1.0 / v68;
  if (v63 != a3
    || v72 != a4
    || fabs(v25) > 0.00390625
    || vabdd_f64(v24, v67) > 0.00390625
    || fabs(v26) > 0.00390625
    || vabdd_f64(v27, v68) > 0.00390625)
  {
    result |= 4uLL;
  }
  double v74 = v71 * v24;
  double v75 = v71 * v25;
  *a6 = v74;
  a6[1] = v75;
  double v76 = v73 * v26;
  double v77 = v73 * v27;
  a6[2] = v76;
  a6[3] = v77;
  if (a5)
  {
    double v78 = *a5 * v67;
    double v79 = a5[1] * v68;
    double v80 = a5[2] * v67;
    double v81 = a5[3] * v68;
    double v82 = v23 + v74 * v78 + v76 * v79;
    double v83 = v22 + v75 * v78 + v77 * v79;
    double v84 = v82 + v74 * v80;
    double v85 = v83 + v75 * v80;
    if (v84 > v82) {
      double v86 = v82 + v74 * v80;
    }
    else {
      double v86 = v82;
    }
    if (v84 < v82)
    {
      double v86 = v82;
      double v82 = v82 + v74 * v80;
    }
    if (v85 > v83) {
      double v87 = v83 + v75 * v80;
    }
    else {
      double v87 = v83;
    }
    if (v85 >= v83)
    {
      double v88 = v83;
    }
    else
    {
      double v87 = v83;
      double v88 = v83 + v75 * v80;
    }
    double v89 = v84 + v76 * v81;
    double v90 = v85 + v77 * v81;
    if (v89 > v86) {
      double v91 = v84 + v76 * v81;
    }
    else {
      double v91 = v86;
    }
    if (v89 >= v82)
    {
      double v92 = v82;
    }
    else
    {
      double v91 = v86;
      double v92 = v84 + v76 * v81;
    }
    if (v90 > v87) {
      double v93 = v85 + v77 * v81;
    }
    else {
      double v93 = v87;
    }
    if (v90 >= v88)
    {
      double v94 = v88;
    }
    else
    {
      double v93 = v87;
      double v94 = v90;
    }
    double v95 = v89 - v74 * v80;
    double v96 = v90 - v75 * v80;
    if (v95 >= v92)
    {
      if (v95 > v91) {
        double v91 = v95;
      }
    }
    else
    {
      double v92 = v95;
    }
    if (v96 > v93) {
      double v98 = v96;
    }
    else {
      double v98 = v93;
    }
    if (v96 < v94) {
      double v94 = v96;
    }
    else {
      double v93 = v98;
    }
    if (v46 < v92) {
      double v46 = v92;
    }
    if (v47 > v91) {
      double v47 = v91;
    }
    if (v46 >= v47) {
      return 0;
    }
    if (v49 < v94) {
      double v49 = v94;
    }
    if (v54 > v93) {
      double v54 = v93;
    }
    if (v49 >= v54) {
      return 0;
    }
    result &= ~2uLL;
  }
  else if ((result & 2) != 0)
  {
    *(void *)a7 = 0;
    *(_DWORD *)(a7 + 8) = a3;
    *(_DWORD *)(a7 + 12) = a4;
    *(void *)a9 = *(void *)a8;
    unsigned int v97 = a8[3];
    *(_DWORD *)(a9 + 8) = a8[2];
    a7 = a9;
LABEL_128:
    *(_DWORD *)(a7 + 12) = v97;
    return result;
  }
  double v99 = v76 * -v75 + v74 * v77;
  if (v99 != 0.0)
  {
    double v100 = v47 - v46;
    double v101 = v46 + 0.00390625;
    if (v46 + 0.00390625 <= 1073741820.0)
    {
      unsigned int v103 = vcvtmd_s64_f64(v101);
      if (v101 >= -1073741820.0) {
        int v102 = v103;
      }
      else {
        int v102 = -1073741823;
      }
    }
    else
    {
      int v102 = 0x3FFFFFFF;
    }
    double v104 = v54 - v49;
    *(_DWORD *)a9 = v102;
    double v105 = v46 + v100 + -0.00390625;
    if (v105 <= 1073741820.0)
    {
      unsigned int v107 = vcvtpd_s64_f64(v105);
      if (v105 >= -1073741820.0) {
        int v106 = v107;
      }
      else {
        int v106 = -1073741823;
      }
    }
    else
    {
      int v106 = 0x3FFFFFFF;
    }
    *(_DWORD *)(a9 + 8) = v106 - v102;
    double v108 = v49 + 0.00390625;
    if (v49 + 0.00390625 <= 1073741820.0)
    {
      unsigned int v110 = vcvtmd_s64_f64(v108);
      if (v108 >= -1073741820.0) {
        int v109 = v110;
      }
      else {
        int v109 = -1073741823;
      }
    }
    else
    {
      int v109 = 0x3FFFFFFF;
    }
    *(_DWORD *)(a9 + 4) = v109;
    double v111 = v49 + v104 + -0.00390625;
    double v112 = 1.0 / v99;
    if (v111 <= 1073741820.0)
    {
      unsigned int v114 = vcvtpd_s64_f64(v111);
      if (v111 >= -1073741820.0) {
        int v113 = v114;
      }
      else {
        int v113 = -1073741823;
      }
    }
    else
    {
      int v113 = 0x3FFFFFFF;
    }
    *(_DWORD *)(a9 + 12) = v113 - v109;
    double v115 = v74 * v112;
    double v116 = v75 * v112;
    double v117 = v116 * v23 - v115 * v22;
    double v118 = v77 * v112;
    double v119 = -(v77 * v112);
    double v120 = v76 * v112 * v22 - v118 * v23;
    double v121 = -(v76 * v112);
    double v122 = v120 + v118 * v46 - v76 * v112 * v49;
    double v123 = v117 - v116 * v46 + v115 * v49;
    double v124 = v122 + v118 * v100;
    double v125 = v123 - v116 * v100;
    if (v124 > v122) {
      double v126 = v122 + v118 * v100;
    }
    else {
      double v126 = v122;
    }
    if (v124 < v122)
    {
      double v126 = v122;
      double v122 = v122 + v118 * v100;
    }
    if (v125 > v123) {
      double v127 = v123 - v116 * v100;
    }
    else {
      double v127 = v123;
    }
    if (v125 < v123)
    {
      double v127 = v123;
      double v123 = v123 - v116 * v100;
    }
    double v128 = v124 + v121 * v104;
    double v129 = v125 + v115 * v104;
    if (v128 > v126) {
      double v130 = v128;
    }
    else {
      double v130 = v126;
    }
    if (v128 >= v122)
    {
      double v131 = v122;
    }
    else
    {
      double v130 = v126;
      double v131 = v128;
    }
    if (v129 > v127) {
      double v132 = v129;
    }
    else {
      double v132 = v127;
    }
    if (v129 < v123)
    {
      double v132 = v127;
      double v123 = v129;
    }
    double v133 = v128 + v119 * v100;
    double v134 = v129 + v116 * v100;
    if (v133 >= v131)
    {
      if (v133 > v130) {
        double v130 = v128 + v119 * v100;
      }
    }
    else
    {
      double v131 = v128 + v119 * v100;
    }
    if (v134 >= v123)
    {
      if (v134 > v132) {
        double v132 = v134;
      }
    }
    else
    {
      double v123 = v134;
    }
    if (a5)
    {
      double v135 = a5[1];
      double v136 = v135 * v68;
      double v137 = (v135 + a5[3]) * v68;
      double v138 = fmax(*a5 * v67, 0.0);
      double v139 = fmax(v136, 0.0);
      if ((*a5 + a5[2]) * v67 < v67) {
        double v67 = (*a5 + a5[2]) * v67;
      }
      if (v137 < v68) {
        double v68 = v137;
      }
    }
    else
    {
      double v139 = 0.0;
      double v138 = 0.0;
    }
    if (v131 < v138) {
      double v131 = v138;
    }
    if (v130 <= v67) {
      double v67 = v130;
    }
    if (v67 > v131)
    {
      if (v123 >= v139) {
        double v140 = v123;
      }
      else {
        double v140 = v139;
      }
      if (v132 > v68) {
        double v132 = v68;
      }
      if (v132 > v140)
      {
        double v141 = v131 + v67 - v131;
        double v142 = v131 + 0.00390625;
        if (v131 + 0.00390625 <= 1073741820.0)
        {
          unsigned int v144 = vcvtmd_s64_f64(v142);
          if (v142 >= -1073741820.0) {
            int v143 = v144;
          }
          else {
            int v143 = -1073741823;
          }
        }
        else
        {
          int v143 = 0x3FFFFFFF;
        }
        double v145 = v132 - v140;
        *(_DWORD *)a7 = v143;
        double v146 = v141 + -0.00390625;
        if (v146 <= 1073741820.0)
        {
          unsigned int v148 = vcvtpd_s64_f64(v146);
          if (v146 >= -1073741820.0) {
            int v147 = v148;
          }
          else {
            int v147 = -1073741823;
          }
        }
        else
        {
          int v147 = 0x3FFFFFFF;
        }
        *(_DWORD *)(a7 + 8) = v147 - v143;
        double v149 = v140 + v145;
        double v150 = v140 + 0.00390625;
        if (v150 <= 1073741820.0)
        {
          unsigned int v152 = vcvtmd_s64_f64(v150);
          if (v150 >= -1073741820.0) {
            int v151 = v152;
          }
          else {
            int v151 = -1073741823;
          }
        }
        else
        {
          int v151 = 0x3FFFFFFF;
        }
        *(_DWORD *)(a7 + 4) = v151;
        double v153 = v149 + -0.00390625;
        if (v153 <= 1073741820.0)
        {
          if (v153 >= -1073741820.0) {
            unsigned int v154 = vcvtpd_s64_f64(v153);
          }
          else {
            unsigned int v154 = -1073741823;
          }
        }
        else
        {
          unsigned int v154 = 0x3FFFFFFF;
        }
        unsigned int v97 = v154 - v151;
        goto LABEL_128;
      }
    }
  }
  return 0;
}

uint64_t ripc_GetImageSize(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  if (result)
  {
    unint64_t v3 = *(void *)(result + 40);
    unint64_t v4 = *(void *)(result + 48);
    if (v3) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5)
    {
      return 0;
    }
    else
    {
      Masuint64_t k = CGImageGetMask((void *)result);
      if (Mask)
      {
        if (Mask[5] > v3) {
          unint64_t v3 = Mask[5];
        }
        if (Mask[6] > v4) {
          unint64_t v4 = Mask[6];
        }
      }
      *a2 = v3;
      *a3 = v4;
      return 1;
    }
  }
  return result;
}

void ripc_ReleaseRIPImageData(void *value)
{
  if (RIPShouldCacheImages_predicate != -1) {
    dispatch_once(&RIPShouldCacheImages_predicate, &__block_literal_global_13526);
  }
  if (!RIPShouldCacheImages_should_cache) {
    goto LABEL_7;
  }
  if (get_cache_predicate != -1) {
    dispatch_once(&get_cache_predicate, &__block_literal_global_1505);
  }
  if (cache_release_value(*(cache_t **)(get_cache_image_cache + 64), value))
  {
LABEL_7:
    RIPImageDataRelease((uint64_t)value);
  }
}

int32x2_t ripc_InitializeImage(uint64_t a1, uint64_t a2, double *a3, int a4, unint64_t a5, unint64_t a6, double *a7, double *a8, double a9, double a10, double a11)
{
  *(void *)(a1 + 16) = a3;
  *(_WORD *)(a1 + 42) = 0;
  if (a7)
  {
    uint64_t v11 = *((int *)a3 + 14);
    if (v11 == a5 && (uint64_t v12 = *((int *)a3 + 15), v12 == a6))
    {
      int v13 = *(_DWORD *)(a2 + 12);
      double v14 = (double)*(int *)a2;
      *(_DWORD *)a1 = *(_DWORD *)a2;
      uint64_t v15 = *(void *)(a2 + 4);
      *(void *)(a1 + 4) = v15;
      int v16 = v15;
      a11 = a7[4];
      double v17 = a7[5] + a7[3] * (double)a6;
      double v19 = a7[1];
      double v18 = a7[2];
      *(_DWORD *)(a1 + 12) = v13;
      a7[4] = a11 + v18 * (double)a6 - v14;
      a7[5] = (double)(v13 + v16) - v17;
      *(double *)&int32x2_t result = -v18;
      double v21 = -v19;
      a7[1] = -v19;
      a7[2] = -v18;
      *(void *)(a1 + 24) = a7;
      *(void *)(a1 + 48) = 0;
      if (a4 == 1) {
        __int16 v22 = 0;
      }
      else {
        __int16 v22 = -1;
      }
      *(_WORD *)(a1 + 40) = v22;
    }
    else
    {
      a11 = *a7;
      double v23 = a7[1];
      double v25 = a7[2];
      double v24 = a7[3];
      if (a4 == 1)
      {
        *(_WORD *)(a1 + 40) = 0;
      }
      else
      {
        *(_WORD *)(a1 + 40) = -1;
        uint64_t v26 = *((unsigned int *)a3 + 10);
        if (v26 != a5)
        {
          double v27 = (double)a5 / (double)v26;
          a11 = a11 * v27;
          double v23 = v23 * v27;
        }
        uint64_t v28 = *((unsigned int *)a3 + 11);
        if (v28 != a6)
        {
          double v29 = (double)a6 / (double)v28;
          double v25 = v25 * v29;
          double v24 = v24 * v29;
        }
      }
      int v30 = *((_DWORD *)a3 + 13);
      double v31 = (double)*((int *)a3 + 12);
      double v32 = (double)(int)v11;
      LODWORD(v12) = *((_DWORD *)a3 + 15);
      double v33 = (double)(int)v12;
      double v34 = a7[4] + a11 * v31 + v25 * (double)v30;
      double v35 = a7[5] + v23 * v31 + v24 * (double)v30;
      double v36 = v34 + a11 * (double)(int)v11;
      double v37 = v35 + v23 * (double)(int)v11;
      if (v36 > v34) {
        double v38 = v34 + a11 * (double)(int)v11;
      }
      else {
        double v38 = v34;
      }
      if (v36 < v34)
      {
        double v38 = v34;
        double v34 = v34 + a11 * (double)(int)v11;
      }
      if (v37 > v35) {
        double v39 = v35 + v23 * (double)(int)v11;
      }
      else {
        double v39 = v35;
      }
      if (v37 < v35)
      {
        double v39 = v35;
        double v35 = v35 + v23 * (double)(int)v11;
      }
      double v40 = v36 + v25 * v33;
      double v41 = v37 + v24 * v33;
      if (v40 > v38) {
        double v42 = v40;
      }
      else {
        double v42 = v38;
      }
      if (v40 < v34) {
        double v34 = v40;
      }
      else {
        double v38 = v42;
      }
      if (v41 > v39) {
        double v43 = v41;
      }
      else {
        double v43 = v39;
      }
      if (v41 >= v35) {
        double v44 = v43;
      }
      else {
        double v44 = v39;
      }
      if (v41 >= v35) {
        double v45 = v35;
      }
      else {
        double v45 = v41;
      }
      double v46 = v40 - a11 * v32;
      double v47 = v41 - v23 * v32;
      if (v46 >= v34)
      {
        if (v46 > v38) {
          double v38 = v46;
        }
      }
      else
      {
        double v34 = v46;
      }
      if (v47 >= v45)
      {
        if (v47 > v44) {
          double v44 = v41 - v23 * v32;
        }
      }
      else
      {
        double v45 = v41 - v23 * v32;
      }
      double v48 = v34 + v38 - v34;
      double v49 = v34 + 0.00390625;
      if (v34 + 0.00390625 <= 1073741820.0)
      {
        unsigned int v51 = vcvtmd_s64_f64(v49);
        if (v49 >= -1073741820.0) {
          int v50 = v51;
        }
        else {
          int v50 = -1073741823;
        }
      }
      else
      {
        int v50 = 0x3FFFFFFF;
      }
      double v52 = v44 - v45;
      *(_DWORD *)a1 = v50;
      double v53 = v48 + -0.00390625;
      if (v53 <= 1073741820.0)
      {
        unsigned int v55 = vcvtpd_s64_f64(v53);
        if (v53 >= -1073741820.0) {
          int v54 = v55;
        }
        else {
          int v54 = -1073741823;
        }
      }
      else
      {
        int v54 = 0x3FFFFFFF;
      }
      *(_DWORD *)(a1 + 8) = v54 - v50;
      double v56 = v45 + v52;
      double v57 = v45 + 0.00390625;
      if (v57 <= 1073741820.0)
      {
        unsigned int v59 = vcvtmd_s64_f64(v57);
        if (v57 >= -1073741820.0) {
          int v58 = v59;
        }
        else {
          int v58 = -1073741823;
        }
      }
      else
      {
        int v58 = 0x3FFFFFFF;
      }
      double v60 = -v23;
      *(_DWORD *)(a1 + 4) = v58;
      double v61 = v56 + -0.00390625;
      if (v56 + -0.00390625 <= 1073741820.0)
      {
        if (v61 >= -1073741820.0) {
          int v62 = vcvtpd_s64_f64(v61);
        }
        else {
          int v62 = -1073741823;
        }
      }
      else
      {
        int v62 = 0x3FFFFFFF;
      }
      *(_DWORD *)(a1 + 12) = v62 - v58;
      *a7 = a11;
      a7[1] = v60;
      a7[2] = -v25;
      a7[3] = v24;
      *(double *)&int32x2_t result = v46 - (double)v50;
      double v21 = (double)v62 - v47;
      a7[4] = *(double *)&result;
      a7[5] = v21;
      *(void *)(a1 + 24) = a7;
      *(void *)(a1 + 48) = 0;
    }
  }
  else
  {
    double v21 = a3[6];
    int32x2_t result = vadd_s32(*(int32x2_t *)&v21, *(int32x2_t *)a2);
    *(double *)a1 = *(double *)&result;
    LODWORD(v12) = *((_DWORD *)a3 + 15);
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a3 + 14);
    *(_DWORD *)(a1 + 12) = v12;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 40) = 0;
  }
  *(void *)(a1 + 32) = a8;
  if (a8)
  {
    int v63 = *((_DWORD *)a3 + 12);
    int v64 = v12 + *((_DWORD *)a3 + 13);
    LODWORD(a11) = *((_DWORD *)a3 + 10);
    LODWORD(v21) = *((_DWORD *)a3 + 11);
    double v65 = (double)*(unint64_t *)&v21;
    double v66 = a8[1];
    double v67 = v66 + a8[3];
    double v68 = (double)v64 - v66 * v65;
    double v69 = (double)v64 - v67 * v65;
    double v70 = (double)*(unint64_t *)&a11;
    double v71 = -((double)v63 - *a8 * v70);
    double v72 = -((double)v63 - (*a8 + a8[2]) * v70);
    double v73 = v68 - v69;
    *a8 = v71;
    a8[1] = v69;
    *(double *)&int32x2_t result = v72 - v71;
    a8[2] = v72 - v71;
    a8[3] = v73;
  }
  return result;
}

void RIPImageDataRelease(uint64_t a1)
{
  if (a1)
  {
    CGSImageDataUnlock(*(uint64_t **)(a1 + 120));
    if (!pthread_mutex_destroy((pthread_mutex_t *)(a1 + 128))) {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 192));
    }
    free((void *)a1);
  }
}

void CGSImageDataUnlock(uint64_t *a1)
{
  if (a1)
  {
    CGSImageDataHandleRelease(a1[9]);
    CFTypeID v2 = (uint64_t *)a1[14];
    if (v2) {
      CGAccessSessionRelease(v2);
    }
    unint64_t v3 = (CGDataProvider *)a1[16];
    if (v3) {
      CGDataProviderRelease(v3);
    }
    unint64_t v4 = (uint64_t *)a1[15];
    if (v4)
    {
      CGImageBlockSetRelease(*v4);
      free(v4);
    }
    BOOL v5 = (CGColorSpace *)a1[13];
    if (v5) {
      CGColorSpaceRelease(v5);
    }
    free(a1);
  }
}

void CGSImageDataHandleRelease(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 8)) {
      CFTypeID v2 = malloc_default_purgeable_zone();
    }
    else {
      CFTypeID v2 = malloc_default_zone();
    }
    malloc_zone_free(v2, *(void **)(a1 + 16));
    free((void *)a1);
  }
}

unsigned char *create_alternate_image(uint64_t a1, int a2)
{
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  if (!a2)
  {
    if (ColorSpace)
    {
      if (!*(_DWORD *)(*((void *)ColorSpace + 3) + 28) && a1 != 0)
      {
        BOOL v7 = 0;
        switch(*(void *)(a1 + 56))
        {
          case 1:
            if (!image_can_be_converted_to_indexed(a1)) {
              return 0;
            }
            if (*(void *)(a1 + 56) != 1) {
              _CGHandleAssert("CGImageCreate1BitIndexed", 196, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGImageGetBitsPerComponent(image) == 1", "bpc %lu", v8, v9, v10, *(void *)(a1 + 56));
            }
            CGColorSpaceRef v11 = CGImageGetColorSpace((CGImageRef)a1);
            if (!v11) {
              return 0;
            }
            uint64_t v12 = *(void *)(*((void *)v11 + 3) + 48);
            if (v12 == 4)
            {
              CGColorSpaceRef v34 = CGImageGetColorSpace((CGImageRef)a1);
              if (!v34 || *(void *)(*((void *)v34 + 3) + 48) != 4)
              {
                CGColorSpaceRef v55 = CGImageGetColorSpace((CGImageRef)a1);
                if (v55) {
                  uint64_t v59 = *(void *)(*((void *)v55 + 3) + 48);
                }
                else {
                  LOBYTE(v59) = 0;
                }
                _CGHandleAssert("create_1_bit_4_component_indexed_image", 159, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 4", "ColorSpace color components: %zu", v56, v57, v58, v59);
              }
              double v35 = CGImageGetColorSpace((CGImageRef)a1);
              Indexedouble d = CGColorSpaceCreateIndexed(v35, 0xFuLL, create_1_bit_4_component_indexed_image_index_table);
              double v36 = (CGImage *)a1;
              double v37 = Indexed;
              size_t v38 = 4;
              goto LABEL_62;
            }
            if (v12 == 3)
            {
              CGColorSpaceRef v39 = CGImageGetColorSpace((CGImageRef)a1);
              if (!v39 || *(void *)(*((void *)v39 + 3) + 48) != 3)
              {
                CGColorSpaceRef v60 = CGImageGetColorSpace((CGImageRef)a1);
                if (v60) {
                  uint64_t v64 = *(void *)(*((void *)v60 + 3) + 48);
                }
                else {
                  LOBYTE(v64) = 0;
                }
                _CGHandleAssert("create_1_bit_3_component_indexed_image", 133, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 3", "ColorSpace color components:%zu", v61, v62, v63, v64);
              }
              double v40 = CGImageGetColorSpace((CGImageRef)a1);
              Indexedouble d = CGColorSpaceCreateIndexed(v40, 7uLL, create_1_bit_3_component_indexed_image_index_table);
              double v36 = (CGImage *)a1;
              double v37 = Indexed;
              size_t v38 = 3;
              goto LABEL_62;
            }
            if (v12 != 1) {
              return 0;
            }
            CGColorSpaceRef v13 = CGImageGetColorSpace((CGImageRef)a1);
            if (!v13 || *(void *)(*((void *)v13 + 3) + 48) != 1)
            {
              CGColorSpaceRef v50 = CGImageGetColorSpace((CGImageRef)a1);
              if (v50) {
                uint64_t v54 = *(void *)(*((void *)v50 + 3) + 48);
              }
              else {
                LOBYTE(v54) = 0;
              }
              _CGHandleAssert("create_1_bit_1_component_indexed_image", 116, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 1", "ColorSpace color components: %zu", v51, v52, v53, v54);
            }
            double v14 = CGImageGetColorSpace((CGImageRef)a1);
            uint64_t v15 = (const unsigned __int8 *)&expand_1_to_8bpc_table;
            size_t v16 = 1;
            goto LABEL_43;
          case 2:
            if (!image_can_be_converted_to_indexed(a1)) {
              return 0;
            }
            if (*(void *)(a1 + 56) != 2) {
              _CGHandleAssert("CGImageCreate2BitIndexed", 363, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGImageGetBitsPerComponent(image) == 2", "bpc %zu", v19, v20, v21, *(void *)(a1 + 56));
            }
            CGColorSpaceRef v22 = CGImageGetColorSpace((CGImageRef)a1);
            if (!v22) {
              return 0;
            }
            uint64_t v23 = *(void *)(*((void *)v22 + 3) + 48);
            switch(v23)
            {
              case 4:
                CGColorSpaceRef v41 = CGImageGetColorSpace((CGImageRef)a1);
                if (!v41 || *(void *)(*((void *)v41 + 3) + 48) != 4)
                {
                  CGColorSpaceRef v65 = CGImageGetColorSpace((CGImageRef)a1);
                  if (v65) {
                    uint64_t v69 = *(void *)(*((void *)v65 + 3) + 48);
                  }
                  else {
                    LOBYTE(v69) = 0;
                  }
                  _CGHandleAssert("create_2_bit_4_component_indexed_image", 275, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 4", "colorspace components %zu", v66, v67, v68, v69);
                }
                double v42 = CGImageGetColorSpace((CGImageRef)a1);
                Indexedouble d = CGColorSpaceCreateIndexed(v42, 0xFFuLL, create_2_bit_4_component_indexed_image_index_table);
                double v36 = (CGImage *)a1;
                double v37 = Indexed;
                size_t v38 = 8;
                break;
              case 3:
                CGColorSpaceRef v43 = CGImageGetColorSpace((CGImageRef)a1);
                if (!v43 || *(void *)(*((void *)v43 + 3) + 48) != 3)
                {
                  CGColorSpaceRef v70 = CGImageGetColorSpace((CGImageRef)a1);
                  if (v70) {
                    uint64_t v74 = *(void *)(*((void *)v70 + 3) + 48);
                  }
                  else {
                    LOBYTE(v74) = 0;
                  }
                  _CGHandleAssert("create_2_bit_3_component_indexed_image", 239, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 3", "colorspace components %zu", v71, v72, v73, v74);
                }
                double v44 = CGImageGetColorSpace((CGImageRef)a1);
                Indexedouble d = CGColorSpaceCreateIndexed(v44, 0x3FuLL, create_2_bit_3_component_indexed_image_index_table);
                double v36 = (CGImage *)a1;
                double v37 = Indexed;
                size_t v38 = 6;
                break;
              case 1:
                CGColorSpaceRef v24 = CGImageGetColorSpace((CGImageRef)a1);
                if (!v24 || *(void *)(*((void *)v24 + 3) + 48) != 1)
                {
                  CGColorSpaceRef v75 = CGImageGetColorSpace((CGImageRef)a1);
                  if (v75) {
                    uint64_t v79 = *(void *)(*((void *)v75 + 3) + 48);
                  }
                  else {
                    LOBYTE(v79) = 0;
                  }
                  _CGHandleAssert("create_2_bit_1_component_indexed_image", 222, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 1", "colorspace components %zu", v76, v77, v78, v79);
                }
                double v14 = CGImageGetColorSpace((CGImageRef)a1);
                uint64_t v15 = (const unsigned __int8 *)&expand_2_to_8bpc_table;
                size_t v16 = 3;
LABEL_43:
                Indexedouble d = CGColorSpaceCreateIndexed(v14, v16, v15);
                CopyWithCGColorSpaceRef ColorSpace = CGImageCreateCopyWithColorSpace((CGImageRef)a1, Indexed);
LABEL_63:
                BOOL v7 = CopyWithColorSpace;
                CGColorSpaceRelease(Indexed);
                if (v7) {
                  goto LABEL_26;
                }
                return v7;
              default:
                return 0;
            }
LABEL_62:
            CopyWithCGColorSpaceRef ColorSpace = copy_image_with_color_space_and_one_component(v36, v37, v38);
            goto LABEL_63;
          case 4:
            if (!image_can_be_converted_to_indexed(a1)) {
              return 0;
            }
            if (*(void *)(a1 + 56) != 4) {
              _CGHandleAssert("CGImageCreate4BitIndexed", 409, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGImageGetBitsPerComponent(image) == 4", "bpc %lu", v25, v26, v27, *(void *)(a1 + 56));
            }
            CGColorSpaceRef v28 = CGImageGetColorSpace((CGImageRef)a1);
            if (!v28 || *(void *)(*((void *)v28 + 3) + 48) != 1) {
              return 0;
            }
            CGColorSpaceRef v29 = CGImageGetColorSpace((CGImageRef)a1);
            if (!v29 || *(void *)(*((void *)v29 + 3) + 48) != 1)
            {
              CGColorSpaceRef v45 = CGImageGetColorSpace((CGImageRef)a1);
              if (v45) {
                uint64_t v49 = *(void *)(*((void *)v45 + 3) + 48);
              }
              else {
                LOBYTE(v49) = 0;
              }
              _CGHandleAssert("create_4_bit_1_component_indexed_image", 389, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImageCreateIndexed.c", "CGColorSpaceGetNumberOfComponents(CGImageGetColorSpace(image)) == 1", "colorspace components %zu", v46, v47, v48, v49);
            }
            double v14 = CGImageGetColorSpace((CGImageRef)a1);
            uint64_t v15 = (const unsigned __int8 *)&expand_4_to_8bpc_table;
            size_t v16 = 15;
            goto LABEL_43;
          case 8:
            CGColorSpaceRef v32 = CGImageGetColorSpace((CGImageRef)a1);
            BOOL v7 = 0;
            if (CGColorSpaceGetType(v32) != 8 || !v32) {
              return v7;
            }
            if (*(void *)(*((void *)v32 + 3) + 48) != 1) {
              return 0;
            }
            double v18 = CGImageCreate8BitIndexed((CGImage *)a1);
            goto LABEL_25;
          default:
            return v7;
        }
      }
    }
    return 0;
  }
  unsigned int v5 = CGColorSpaceGetType(ColorSpace) - 7;
  if (a1)
  {
    if ((*(unsigned char *)(a1 + 39) & 8) != 0 || v5 < 3) {
      goto LABEL_22;
    }
    return 0;
  }
  if (v5 > 2) {
    return 0;
  }
LABEL_22:
  CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent((CGImageRef)a1);
  if (get_flattening_options_predicate != -1) {
    dispatch_once(&get_flattening_options_predicate, &__block_literal_global_13929);
  }
  double v18 = CGColorTransformConvertImage((_DWORD *)a1, RenderingIntent, (CFDictionaryRef)get_flattening_options_options);
LABEL_25:
  BOOL v7 = v18;
  if (v18) {
LABEL_26:
  }
    CGImageSetCachingFlags(v7, 1);
  return v7;
}

CGImageRef CGImageCreateSubsampledImage(uint64_t a1, double a2, double a3)
{
  Masuint64_t k = CGImageGetMask((void *)a1);
  if (!Mask)
  {
    BOOL v8 = 0;
    if (!a1) {
      goto LABEL_9;
    }
    goto LABEL_11;
  }
  if (a1)
  {
    if (*(void *)(a1 + 40) != Mask[5])
    {
      BOOL v8 = 1;
      goto LABEL_11;
    }
    uint64_t v7 = *(void *)(a1 + 48);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v7 = Mask[5];
    if (v7) {
      return (CGImageRef)v9;
    }
  }
  BOOL v8 = v7 != Mask[6];
  if (a1)
  {
LABEL_11:
    char v10 = 0;
    BOOL v11 = (*(unsigned char *)(a1 + 39) & 2) == 0;
    goto LABEL_12;
  }
LABEL_9:
  char v10 = 1;
  BOOL v11 = 1;
LABEL_12:
  uint64_t v9 = 0;
  if (!v11) {
    return (CGImageRef)v9;
  }
  if (v8) {
    return (CGImageRef)v9;
  }
  ImageProvider = CGImageGetImageProvider((void *)a1);
  uint64_t v9 = ImageProvider;
  if (!ImageProvider) {
    return (CGImageRef)v9;
  }
  if (!*((unsigned char *)ImageProvider + 128) || (v10 & 1) != 0) {
    return 0;
  }
  unint64_t v13 = (unint64_t)fabs(round(a3));
  if (*(void *)(a1 + 40) <= 2 * (unint64_t)fabs(round(a2)) || *(void *)(a1 + 48) <= 2 * v13) {
    return 0;
  }
  if (block_set_options_predicate != -1) {
    dispatch_once(&block_set_options_predicate, &__block_literal_global_364_5232);
  }
  uint64_t v16 = CGImageProviderCopyImageBlockSetWithOptions((uint64_t)v9, block_set_options_options_singleton);
  if (!v16)
  {
    uint64_t v16 = CGImageProviderCopyImageBlockSetWithOptions((uint64_t)v9, 0);
    if (!v16) {
      return 0;
    }
  }
  Componentint Type = CGImageGetComponentType(a1);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  subsampled_image_CGDataProviderRef provider = (const void *)create_subsampled_image_provider(v16, ComponentType, ColorSpace, (uint64_t)v9, v19, v20, v21, v22);
  Decode = (double *)CGImageGetDecode((CGImageRef)a1);
  BOOL ShouldInterpolate = CGImageGetShouldInterpolate((CGImageRef)a1);
  uint64_t RenderingIntent = CGImageGetRenderingIntent((CGImageRef)a1);
  uint64_t v9 = (const void *)CGImageCreateWithImageProvider((uint64_t)subsampled_image_provider, Decode, ShouldInterpolate, RenderingIntent, v27, v28, v29, v30);
  if (subsampled_image_provider) {
    CFRelease(subsampled_image_provider);
  }
  if (!v9)
  {
    CGImageBlockSetRelease(v16);
    return (CGImageRef)v9;
  }
  if (*(void *)(a1 + 176))
  {
    double v31 = CGImageGetMask((void *)a1);
    SubsampledCGImageRef Image = CGImageCreateSubsampledImage(v31, a2, a3);
    if (SubsampledImage)
    {
      CGImageRef v33 = CGImageCreateWithMaskAndMatte((uint64_t)v9, SubsampledImage, 0);
      if (v33)
      {
        CGImageRef v34 = v33;
        CFRelease(v9);
        return v34;
      }
      return (CGImageRef)v9;
    }
    CFRelease(v9);
    return 0;
  }
  return (CGImageRef)v9;
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  if (image)
  {
    CGImageRef v1 = image;
    CFTypeID v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1) {
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_276_4949);
    }
    if (v2 == CGImageGetTypeID_image_type_id) {
      LOBYTE(image) = *((unsigned char *)v1 + 39) & 1;
    }
    else {
      LOBYTE(image) = 0;
    }
  }
  return (char)image;
}

uint64_t ripc_GetImageInterpolation(uint64_t a1, int a2, int a3)
{
  if (a2 << 24)
  {
    unsigned int v3 = (char)a2;
    unsigned int v4 = *(_DWORD *)(a1 + 76);
    if (v4)
    {
      unint64_t v5 = 0x304020100uLL >> (8 * v4);
      if (v4 >= 5) {
        LOBYTE(v5) = 0;
      }
      if (v5 < (0x304020100uLL >> (8 * a2))
        && a2 < 5u)
      {
        unsigned int v3 = *(_DWORD *)(a1 + 76);
      }
    }
    unsigned int v9 = *(_DWORD *)(a1 + 72);
    unint64_t v10 = 0x304020100uLL >> (8 * v3);
    if (v3 >= 5) {
      LOBYTE(v10) = 0;
    }
    if (v10 >= (0x304020100uLL >> (8 * v9)) || v9 >= 5) {
      unsigned int v12 = v3;
    }
    else {
      unsigned int v12 = *(_DWORD *)(a1 + 72);
    }
    if (v9) {
      return v12;
    }
    else {
      return v3;
    }
  }
  else if (a3)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 76);
    if (v7) {
      return v7;
    }
    else {
      return 3;
    }
  }
  else
  {
    return *(unsigned int *)(a1 + 72);
  }
}

uint64_t ripc_GetImageInterpolationSize(double *a1, int64_t *a2, unint64_t *a3, int *a4)
{
  double v4 = a1[1] * a1[1] + *a1 * *a1;
  double v5 = a1[3] * a1[3] + a1[2] * a1[2];
  if (v4 >= 0.99
    || (unint64_t v6 = *a2,
        double v7 = sqrt(v4),
        double v8 = (double)(unint64_t)*a2,
        int64_t v9 = vcvtpd_s64_f64(v7 * v8 + -0.00390625),
        *a2 == v9))
  {
    uint64_t result = 0;
  }
  else
  {
    *a2 = v9;
    if (a4)
    {
      uint64_t v11 = a4[2];
      if (v6 == v11)
      {
        int v12 = 0;
      }
      else
      {
        double v13 = (double)(unint64_t)v9 / v8;
        signed int v14 = vcvtpd_s64_f64(v13 * (double)(*a4 + (int)v11));
        int v15 = vcvtmd_s64_f64(v13 * (double)*a4);
        if (v9 >= v14) {
          LODWORD(v9) = v14;
        }
        int v12 = v15 & ~(v15 >> 31);
        LODWORD(v9) = v9 - v12;
      }
      *a4 = v12;
      a4[2] = v9;
    }
    uint64_t result = 1;
  }
  if (v5 < 0.99)
  {
    unint64_t v16 = *a3;
    double v17 = sqrt(v5);
    double v18 = (double)*a3;
    signed int v19 = vcvtpd_s64_f64(v17 * v18 + -0.00390625);
    if (*a3 != v19)
    {
      *a3 = v19;
      if (a4)
      {
        uint64_t v20 = a4[3];
        if (v16 == v20)
        {
          int v21 = 0;
        }
        else
        {
          double v22 = (double)(unint64_t)v19 / v18;
          int v23 = a4[1];
          signed int v24 = vcvtpd_s64_f64(v22 * (double)(v23 + (int)v20));
          int v25 = vcvtmd_s64_f64(v22 * (double)v23);
          if (v19 >= v24) {
            signed int v19 = v24;
          }
          int v21 = v25 & ~(v25 >> 31);
          v19 -= v21;
        }
        a4[1] = v21;
        a4[3] = v19;
      }
      return 1;
    }
  }
  return result;
}

uint64_t CGDataProviderCreateWithImageProvider(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  double v3 = *(double *)(a1 + 16);
  double v2 = *(double *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t v5 = v4 * (unint64_t)v3;
  unint64_t v6 = (double *)malloc_type_malloc(0x58uLL, 0x2062DE7BuLL);
  CGDataProviderCreateDirectWithInternalCallbacks((uint64_t)v6, v5 * (unint64_t)v2, (uint64_t)&imageProvider_callbacks, v7, v8, v9, v10, v11);
  uint64_t v13 = v12;
  if (v12)
  {
    *(unsigned char *)(v12 + 260) = *(unsigned char *)(a1 + 130);
    CFRetain((CFTypeRef)a1);
    *(void *)unint64_t v6 = a1;
    v6[1] = 0.0;
    v6[2] = 0.0;
    v6[3] = 0.0;
    v6[4] = v3;
    v6[5] = v2;
    *((void *)v6 + 6) = v4;
    *((void *)v6 + 7) = v5;
    *((void *)v6 + 8) = v5 * (unint64_t)v2;
    *((unsigned char *)v6 + 80) = 1;
    *(void *)(v13 + 280) = CGDataProviderCreateDebugString(v13, *(__CFString **)(a1 + 136));
    *((void *)v6 + 9) = v13;
  }
  else
  {
    free(v6);
  }
  return v13;
}

CFStringRef CGDataProviderCreateDebugString(uint64_t a1, __CFString *a2)
{
  if (data_provider_debug_info_enabled_predicate != -1) {
    dispatch_once(&data_provider_debug_info_enabled_predicate, &__block_literal_global_42);
  }
  if (!data_provider_debug_info_enabled_enabled) {
    return 0;
  }

  return data_provider_copy_debug_string(a1, a2);
}

uint64_t CGContextDelegateDrawImage(uint64_t result)
{
  if (result)
  {
    CGImageRef v1 = *(uint64_t (**)(void))(result + 80);
    if (v1) {
      return v1();
    }
    else {
      return 1006;
    }
  }
  return result;
}

void *CGFontGetGlyphAdvancesForStyle(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (result)
  {
    uint64_t v11 = result;
    font_float64x2_t info = get_font_info(result);
    if (font_info)
    {
      if (font_info[104]) {
        a3 = a3 & 0xFFFFFFFE;
      }
      else {
        a3 = a3;
      }
    }
    uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v11[2] + 304);
    uint64_t v14 = v11[14];
    return (void *)v13(v14, a2, a3, a4, a5, a6);
  }
  return result;
}

void CGContextSetLineCap(CGContextRef c, CGLineCap cap)
{
  if (!c)
  {
    CGContextRef v8 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextSetLineCap", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v8 = c;
    goto LABEL_7;
  }
  if (cap >= (kCGLineCapSquare|kCGLineCapRound)) {
    cap = kCGLineCapButt;
  }
  CGGStateSetLineCap(*((void *)c + 12), cap);
}

void CGContextSetLineJoin(CGContextRef c, CGLineJoin join)
{
  if (!c)
  {
    CGContextRef v8 = 0;
LABEL_7:
    handle_invalid_context((char)"CGContextSetLineJoin", (uint64_t)v8, v2, v3, v4, v5, v6, v7);
    return;
  }
  if (*((_DWORD *)c + 4) != 1129601108)
  {
    CGContextRef v8 = c;
    goto LABEL_7;
  }
  if (join >= (kCGLineJoinBevel|kCGLineJoinRound)) {
    joiuint64_t n = kCGLineJoinMiter;
  }
  CGGStateSetLineJoin(*((void *)c + 12), join);
}

BOOL CGColorSpaceIsHDR(CGColorSpaceRef a1)
{
  if (a1)
  {
    uint64_t v1 = *((void *)a1 + 3);
    if (*(unsigned char *)(v1 + 16)) {
      LOBYTE(a1) = 1;
    }
    else {
      LOBYTE(a1) = *(unsigned char *)(v1 + 17) != 0;
    }
  }
  return (char)a1;
}

CFStringRef CGFontCopyPostScriptName(CFStringRef font)
{
  if (font) {
    return (CFStringRef)(*((uint64_t (**)(char *))font->data + 19))(font[3].data);
  }
  return font;
}

uint64_t argb32_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  memset(v41, 0, sizeof(v41));
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v34 = 0u;
  memset(v48, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  uint64_t v8 = *(unsigned int *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if ((int)v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v34, (uint64_t)v48) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v21 = 134755160;
  unsigned int v22 = *(_DWORD *)a3;
  *((void *)&v34 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v22 != 134755160)
  {
    unsigned int v23 = SAMPLEINDEX(v22, v10, v11, v12, v13, v14, v15, v16);
    if (!v23) {
      return 0xFFFFFFFFLL;
    }
    if (v23 <= 0xB)
    {
      LOBYTE(v24) = 0;
      int v25 = 0;
      switch(v23)
      {
        case 2u:
          uint64_t v24 = *((void *)a2 + 12);
          if (v24) {
            goto LABEL_34;
          }
          int v25 = 16;
          break;
        case 5u:
          LOBYTE(v24) = 0;
          int v25 = 24;
          break;
        case 6u:
          break;
        case 7u:
          LOBYTE(v24) = 0;
          int v25 = 32;
          break;
        case 8u:
          LOBYTE(v24) = 0;
          int v25 = 8;
          break;
        case 9u:
          LOBYTE(v24) = 0;
          int v25 = 40;
          break;
        default:
          goto LABEL_34;
      }
LABEL_35:
      *(void *)&long long v34 = argb32_image_sample[v23 + 1];
      if ((void)v34) {
        goto LABEL_45;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
        {
LABEL_42:
          *(void *)&long long v34 = *(void *)&RGBF_image_sample[2 * v23 + 2];
          if ((void)v34)
          {
            int v21 = 538981289;
            int v26 = 16;
            goto LABEL_44;
          }
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        *(void *)&long long v34 = *(void *)&RGB8_image_sample[2 * v23 + 2];
        if ((void)v34)
        {
          int v21 = 134755224;
          goto LABEL_45;
        }
      }
      *(void *)&long long v34 = *(void *)&RGB16_image_sample[2 * v23 + 2];
      if ((void)v34)
      {
        int v21 = 269497256;
        int v26 = 8;
LABEL_44:
        LODWORD(v35) = v26;
LABEL_45:
        DWORD2(v34) = v21;
        if (v24) {
          goto LABEL_63;
        }
        goto LABEL_46;
      }
      goto LABEL_42;
    }
    if (v23 <= 0x13)
    {
      if (v23 - 14 < 4)
      {
        LOBYTE(v24) = 0;
LABEL_27:
        int v25 = 0;
        goto LABEL_35;
      }
      if (v23 == 13 || v23 == 12)
      {
        uint64_t v24 = *((void *)a2 + 12);
        if (!v24) {
          goto LABEL_27;
        }
      }
    }
LABEL_34:
    int v25 = 255;
    LOBYTE(v24) = 1;
    goto LABEL_35;
  }
  if ((void)v42 || (~DWORD1(v35) & 0xC3) != 0) {
    goto LABEL_30;
  }
  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
  if ((v8 - 1) > 1 || (BYTE4(v35) & 4) != 0 || (LODWORD(v18) = 1.0, v17.n128_f32[0] != 1.0))
  {
    LODWORD(v18) = 1.0;
    if (v17.n128_f32[0] >= 1.0) {
      goto LABEL_29;
    }
LABEL_30:
    *(void *)&long long v34 = argb32_sample_argb32;
    unsigned int v23 = 9;
    int v25 = 40;
LABEL_46:
    if ((BYTE4(v35) & 7) == 3 && (v8 - 1) <= 1 && (a2[2] == 5 || !a2[2]))
    {
      if (v23 <= 0xB)
      {
        HIDWORD(v27) = v25;
        LODWORD(v27) = v25;
        switch((v27 >> 3))
        {
          case 0u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_RGBX32((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_RGB32;
            goto LABEL_135;
          case 1u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_XRGB32((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v29 = argb32_image_mark_RGB32;
            goto LABEL_129;
          case 2u:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_W8((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_W8;
            goto LABEL_135;
          case 3u:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_RGB24((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_RGB24;
            goto LABEL_135;
          case 4u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_rgbx32((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_rgb32;
            goto LABEL_135;
          case 5u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_xrgb32((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            if ((void)v42)
            {
              if (v21 == 134755160)
              {
                v17.n128_u32[0] = DWORD2(v42);
                if (*((float *)&v42 + 2) >= 1.0 && *(_OWORD *)((char *)v41 + 8) == 0)
                {
                  argb32_sample_rectilinear_argb32(a2, (uint64_t)&v34, v8, v17);
                  return 1;
                }
              }
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v29 = argb32_image_mark_argb32;
LABEL_129:
            uint64_t v30 = v29;
            uint64_t v31 = (uint64_t)a2;
            int v32 = v8;
            int v33 = 8;
            break;
          default:
            goto LABEL_63;
        }
LABEL_136:
        argb32_image_mark_image(v31, (uint64_t)&v34, v32, v33, (void (*)(void, void))v30);
        return 1;
      }
      if (v23 <= 0x13)
      {
        switch(v23)
        {
          case 0xCu:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_W16((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_W16;
            goto LABEL_135;
          case 0xDu:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_w16((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_w16;
            goto LABEL_135;
          case 0xEu:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_RGB48((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_RGB48;
            goto LABEL_135;
          case 0xFu:
            if (v8 == 1 && (BYTE4(v35) & 0x70) == 0x70 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_rgb48((uint64_t)a2, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v13, v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_rgb48;
            goto LABEL_135;
          case 0x10u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_RGBA64((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_RGBA64;
            goto LABEL_135;
          case 0x11u:
            if ((~DWORD1(v35) & 0x70) == 0 && !(void)v42 && *(float *)(a3 + 8) == 1.0)
            {
              argb32_mark_image_rgba64((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
              return 1;
            }
            DWORD2(v34) = *(_DWORD *)a3;
            uint64_t v28 = argb32_image_mark_rgba64;
LABEL_135:
            uint64_t v30 = v28;
            uint64_t v31 = (uint64_t)a2;
            int v32 = v8;
            int v33 = 0;
            break;
          default:
            goto LABEL_63;
        }
        goto LABEL_136;
      }
    }
LABEL_63:
    argb32_image_mark((uint64_t)a2, (uint64_t)&v34, v8, v17);
    return 1;
  }
  if (a2[2] != 5 && a2[2])
  {
LABEL_29:
    if (!*(void *)(a3 + 24))
    {
      if ((BYTE4(v35) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      argb32_mark(a1, (uint64_t)a2, v17, v18, v19, v20, v11, v12, v13, v14, v15, v16);
      return 1;
    }
    goto LABEL_30;
  }
  argb32_mark_image((uint64_t)a2, v8, (uint64_t)v40 >> SBYTE6(v35), *((uint64_t *)&v40 + 1) >> SBYTE7(v35), *((uint64_t *)&v41[1] + 1) >> SBYTE7(v35), v14, v15, v16);
  return 1;
}

uint64_t A8_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (int *)*a1;
  memset(v76, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*((void *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) >= 1 && *((int *)a2 + 2) >= 1)
  {
    if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v63, (uint64_t)v76) >= 1)
    {
      int v18 = *v6;
      unsigned int v19 = *(_DWORD *)a3;
      int v64 = v19;
      int v65 = v18;
      if (v19 == 34082816)
      {
        if (!v70 && (~v66 & 0xC3) == 0)
        {
          v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
          if (v17.n128_f32[0] >= 1.0 && !*(void *)(a3 + 24))
          {
            if ((v66 & 4) != 0)
            {
              v17.n128_u64[0] = *(void *)(a3 + 32);
              *((void *)a2 + 8) = v17.n128_u64[0];
            }
            A8_mark_inner(*(void *)(*a1 + 56), v17);
            return 1;
          }
        }
        uint64_t v63 = A8_sample_A8_inner;
      }
      else
      {
        uint64_t v22 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
        if (!v22) {
          return 0xFFFFFFFFLL;
        }
        if (v22 > 0xB)
        {
LABEL_25:
          int v25 = 255;
          LOBYTE(v24) = 1;
        }
        else
        {
          LOBYTE(v24) = 0;
          int v25 = 0;
          switch((int)v22)
          {
            case 2:
              uint64_t v24 = *((void *)a2 + 12);
              if (v24) {
                goto LABEL_25;
              }
              int v25 = 16;
              break;
            case 5:
              LOBYTE(v24) = 0;
              int v25 = 24;
              break;
            case 6:
              break;
            case 7:
              LOBYTE(v24) = 0;
              int v25 = 32;
              break;
            case 8:
              LOBYTE(v24) = 0;
              int v25 = 8;
              break;
            case 9:
              LOBYTE(v24) = 0;
              int v25 = 40;
              break;
            default:
              goto LABEL_25;
          }
        }
        uint64_t v63 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int))A8_image_sample[v22 + 1];
        if (!v63) {
          return 0xFFFFFFFFLL;
        }
        int v64 = 34082816;
        if ((v24 & 1) == 0
          && (v66 & 7) == 3
          && (v8 - 1) <= 1
          && (a2[2] == 5 || !a2[2])
          && v22 <= 0xB)
        {
          HIDWORD(v26) = v25;
          LODWORD(v26) = v25;
          switch((v26 >> 3))
          {
            case 0u:
              if (v8 != 1
                || (v66 & 0x70) != 0x70
                || v70
                || (uint64_t v27 = *((void *)a2 + 12)) != 0 && *(float *)(a3 + 8) != 1.0)
              {
                int v64 = *(_DWORD *)a3;
                long long v40 = A8_image_mark_RGB32;
                goto LABEL_80;
              }
              uint64_t v28 = v67 >> SBYTE2(v66);
              uint64_t v29 = v68 >> SHIBYTE(v66);
              uint64_t v30 = v69 >> SHIBYTE(v66);
              if (v27) {
                int v31 = 0;
              }
              else {
                int v31 = 16843009 * (int)(float)((float)(int)(float)(*(float *)(a3 + 8) * 255.0) + 0.5);
              }
              int v46 = *((_DWORD *)a2 + 1);
              int v47 = *((_DWORD *)a2 + 2);
              int v74 = v46;
              int v73 = v47;
              uint64_t v48 = (int *)*((void *)a2 + 17);
              if (v48)
              {
                int v49 = *((_DWORD *)a2 + 27);
                HIDWORD(i) = *((_DWORD *)a2 + 26);
                LODWORD(i) = v49;
                shape_enum_clip_alloc(v22, v23, v48, 1, 1, 1, SHIDWORD(i), v49, v46, v47);
                uint64_t v51 = v50;
                if (v50) {
                  goto LABEL_94;
                }
              }
              int v52 = 0;
              int v53 = 0;
              uint64_t v51 = 0;
              uint64_t i = 0;
              while (2)
              {
                uint64_t v61 = *((int *)a2 + 7);
                if (*((void *)a2 + 12)) {
                  CGSConvertRGBA8888toMask((unsigned char *)(*((void *)a2 + 11)+ *((int *)a2 + 19) * (uint64_t)((int)v29 + v53 * (int)v30)+ 4 * (v52 + (int)v28)), *((_DWORD *)a2 + 19) * v30, (unsigned char *)(*((void *)a2 + 5)+ (*((int *)a2 + 4) + (uint64_t)v53) * v61+ *((int *)a2 + 3)+ (uint64_t)v52), *((_DWORD *)a2 + 7), v74, v73);
                }
                else {
                  CGBlt_fillBytes(v74, v73, v31, (char *)(*((void *)a2 + 5)+ (*((int *)a2 + 4) + (uint64_t)v53) * v61+ *((int *)a2 + 3)+ (uint64_t)v52), *((_DWORD *)a2 + 7));
                }
                if (!v51) {
                  return 1;
                }
LABEL_94:
                if (shape_enum_clip_next((uint64_t)v51, (int *)&i + 1, &i, &v74, &v73))
                {
                  int v53 = i;
                  int v52 = HIDWORD(i);
                  continue;
                }
                break;
              }
              goto LABEL_102;
            case 1u:
              if (v8 == 1 && (v66 & 0x70) == 0x70 && !v70)
              {
                uint64_t v35 = *((void *)a2 + 12);
                if (!v35 || *(float *)(a3 + 8) == 1.0)
                {
                  uint64_t v36 = v67 >> SBYTE2(v66);
                  uint64_t v37 = v68 >> SHIBYTE(v66);
                  uint64_t v38 = v69 >> SHIBYTE(v66);
                  if (v35) {
                    int v39 = 0;
                  }
                  else {
                    int v39 = 16843009 * (int)(float)((float)(int)(float)(*(float *)(a3 + 8) * 255.0) + 0.5);
                  }
                  int v54 = *((_DWORD *)a2 + 1);
                  int v55 = *((_DWORD *)a2 + 2);
                  int v74 = v54;
                  int v73 = v55;
                  uint64_t v56 = (int *)*((void *)a2 + 17);
                  if (v56)
                  {
                    int v57 = *((_DWORD *)a2 + 27);
                    HIDWORD(i) = *((_DWORD *)a2 + 26);
                    LODWORD(i) = v57;
                    shape_enum_clip_alloc(v22, v23, v56, 1, 1, 1, SHIDWORD(i), v57, v54, v55);
                    uint64_t v51 = v58;
                    if (v58) {
                      goto LABEL_100;
                    }
                  }
                  int v59 = 0;
                  int v60 = 0;
                  uint64_t v51 = 0;
                  for (uint64_t i = 0; ; v59 = HIDWORD(i))
                  {
                    uint64_t v62 = *((int *)a2 + 7);
                    if (*((void *)a2 + 12)) {
                      CGSConvertARGB8888toMask((char *)(*((void *)a2 + 11)+ *((int *)a2 + 19) * (uint64_t)((int)v37 + v60 * (int)v38)+ 4 * (v59 + (int)v36)), *((_DWORD *)a2 + 19) * v38, (unsigned char *)(*((void *)a2 + 5)+ (*((int *)a2 + 4) + (uint64_t)v60) * v62+ *((int *)a2 + 3)+ (uint64_t)v59), *((_DWORD *)a2 + 7), v74, v73);
                    }
                    else {
                      CGBlt_fillBytes(v74, v73, v39, (char *)(*((void *)a2 + 5)+ (*((int *)a2 + 4) + (uint64_t)v60) * v62+ *((int *)a2 + 3)+ (uint64_t)v59), *((_DWORD *)a2 + 7));
                    }
                    if (!v51) {
                      return 1;
                    }
LABEL_100:
                    if (!shape_enum_clip_next((uint64_t)v51, (int *)&i + 1, &i, &v74, &v73))
                    {
LABEL_102:
                      free(v51);
                      return 1;
                    }
                    int v60 = i;
                  }
                }
              }
              int v64 = *(_DWORD *)a3;
              CGColorSpaceRef v41 = A8_image_mark_RGB32;
LABEL_78:
              long long v42 = v41;
              uint64_t v43 = (uint64_t)a2;
              int v44 = v8;
              int v45 = 8;
LABEL_81:
              A8_image_mark_image(v43, (uint64_t)&v63, v44, v45, (void (*)(uint64_t, _DWORD *))v42);
              break;
            case 2u:
              if (v8 == 1 && (v66 & 0x70) == 0x70 && !v70) {
                goto LABEL_73;
              }
              int v64 = *(_DWORD *)a3;
              long long v40 = (uint64_t (*)(uint64_t, int *, int, int, int, int))A8_image_mark_W8;
              goto LABEL_80;
            case 3u:
              if (v8 == 1 && (v66 & 0x70) == 0x70 && !v70)
              {
LABEL_73:
                A8_mark_image_OPAQUE((uint64_t)a2, v23, *(float *)(a3 + 8));
                return 1;
              }
              int v64 = *(_DWORD *)a3;
              long long v40 = (uint64_t (*)(uint64_t, int *, int, int, int, int))A8_image_mark_RGB24;
LABEL_80:
              long long v42 = v40;
              uint64_t v43 = (uint64_t)a2;
              int v44 = v8;
              int v45 = 0;
              goto LABEL_81;
            case 4u:
              int v64 = *(_DWORD *)a3;
              long long v40 = A8_image_mark_rgb32;
              goto LABEL_80;
            case 5u:
              int v64 = *(_DWORD *)a3;
              CGColorSpaceRef v41 = A8_image_mark_rgb32;
              goto LABEL_78;
            default:
              goto LABEL_15;
          }
          return 1;
        }
      }
LABEL_15:
      if ((*(_DWORD *)a3 & 0xC) != 8)
      {
LABEL_49:
        A8_image_mark((uint64_t)a2, (uint64_t)&v63, v8, v17);
        return 1;
      }
      unsigned int v20 = (*(_DWORD *)a3 >> 22) / (HIWORD(*(_DWORD *)a3) & 0x3Fu);
      if (v20 == 2)
      {
        int v21 = 1;
        goto LABEL_42;
      }
      if (v20 == 4)
      {
        int v21 = 2;
LABEL_42:
        if ((*(_DWORD *)a3 & 0x30) == 0x10) {
          int v32 = 64;
        }
        else {
          int v32 = 128;
        }
        unsigned int v33 = v20 - 1;
        if ((*(_DWORD *)a3 & 0xC0) == v32) {
          unsigned int v34 = v33;
        }
        else {
          unsigned int v34 = 0;
        }
        int v71 = v21;
        unsigned int v72 = v34;
        goto LABEL_49;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t RGBA32_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v33 = 0u;
  memset(v50, 0, 512);
  if (*((void *)a2 + 12)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *(float *)(a3 + 8) >= 1.0;
  }
  int v8 = *(_DWORD *)(*(void *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((void *)a2 + 6) == 0));
  if (v8 > 28) {
    return 0xFFFFFFFFLL;
  }
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1) {
    return 0;
  }
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v33, (uint64_t)v50) < 1) {
    return 0xFFFFFFFFLL;
  }
  int v21 = *(_DWORD *)v6;
  BOOL v22 = *(_DWORD *)v6 != 134755208 || v8 <= 23;
  unsigned int v23 = *(_DWORD *)a3;
  if (v22) {
    uint64_t v24 = v8;
  }
  else {
    uint64_t v24 = (v8 + 4);
  }
  DWORD2(v33) = *(_DWORD *)a3;
  HIDWORD(v33) = v21;
  if (v23 != 134755208)
  {
    unsigned int v25 = SAMPLEINDEX(v23, v10, v11, v12, v13, v14, v15, v16);
    if (!v25) {
      return 0xFFFFFFFFLL;
    }
    if (v25 > 0xB)
    {
      if (v25 > 0x13)
      {
LABEL_35:
        int v30 = 0;
        goto LABEL_37;
      }
      if (v25 - 14 < 4)
      {
LABEL_36:
        int v30 = 1;
LABEL_37:
        *(void *)&long long v33 = argb32_image_sample[v25 + 1];
        if ((void)v33)
        {
          int v31 = 134755160;
          goto LABEL_48;
        }
        if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
        {
          if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          {
LABEL_45:
            *(void *)&long long v33 = *(void *)&RGBF_image_sample[2 * v25 + 2];
            if ((void)v33)
            {
              int v31 = 538981289;
              int v32 = 16;
              goto LABEL_47;
            }
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          *(void *)&long long v33 = *(void *)&RGB8_image_sample[2 * v25 + 2];
          if ((void)v33)
          {
            int v31 = 134755224;
            goto LABEL_48;
          }
        }
        *(void *)&long long v33 = *(void *)&RGB16_image_sample[2 * v25 + 2];
        if ((void)v33)
        {
          int v31 = 269497256;
          int v32 = 8;
LABEL_47:
          LODWORD(v34) = v32;
LABEL_48:
          DWORD2(v33) = v31;
          if ((void)v44) {
            int v30 = 0;
          }
          if (v30 == 1 && (BYTE4(v34) & 0x77) == 0x73 && (v24 - 1) <= 1 && (a2[2] == 5 || !a2[2]))
          {
            if (v25 > 0xB)
            {
              if (v25 <= 0x13)
              {
                if (v25 == 12 && v24 == 1)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    argb32_mark_image_W16((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                    return 1;
                  }
                }
                else if (v25 == 13 && v24 == 1)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    argb32_mark_image_w16((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                    return 1;
                  }
                }
                else if (v25 == 14 && v24 == 1)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    RGBA32_mark_image_RGB48((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                    return 1;
                  }
                }
                else if (v25 == 15 && v24 == 1)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    RGBA32_mark_image_rgb48((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                    return 1;
                  }
                }
                else if (v25 == 17)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    RGBA32_mark_image_rgba64((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    return 1;
                  }
                }
                else if (v25 == 16)
                {
                  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                  if (v17.n128_f32[0] == 1.0)
                  {
                    RGBA32_mark_image_RGBA64((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    return 1;
                  }
                }
              }
            }
            else if (v25 == 2 && v24 == 1)
            {
              v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
              if (v17.n128_f32[0] == 1.0)
              {
                argb32_mark_image_W8((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                return 1;
              }
            }
            else
            {
              if (v25 != 5 || v24 != 1)
              {
                switch(v25)
                {
                  case 6u:
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] != 1.0) {
                      goto LABEL_63;
                    }
                    argb32_mark_image_xrgb32((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    break;
                  case 7u:
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] != 1.0) {
                      goto LABEL_63;
                    }
                    argb32_mark_image_XRGB32((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    break;
                  case 8u:
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] != 1.0) {
                      goto LABEL_63;
                    }
                    argb32_mark_image_rgbx32((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    break;
                  case 9u:
                    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
                    if (v17.n128_f32[0] != 1.0) {
                      goto LABEL_63;
                    }
                    argb32_mark_image_RGBX32((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v27, v28, v29);
                    break;
                  default:
                    goto LABEL_63;
                }
                return 1;
              }
              v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
              if (v17.n128_f32[0] == 1.0)
              {
                RGBA32_mark_image_RGB24((uint64_t)a2, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v26, v27, v28, v29);
                return 1;
              }
            }
          }
LABEL_63:
          argb32_image_mark((uint64_t)a2, (uint64_t)&v33, v24, v17);
          return 1;
        }
        goto LABEL_45;
      }
      if (v25 != 13 && v25 != 12) {
        goto LABEL_35;
      }
    }
    else
    {
      if (v25 - 5 < 5) {
        goto LABEL_36;
      }
      if (v25 != 2) {
        goto LABEL_35;
      }
    }
    if (*((void *)a2 + 12)) {
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  if ((void)v44 || (~DWORD1(v34) & 0xC3) != 0) {
    goto LABEL_62;
  }
  v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
  if ((BYTE4(v34) & 4) != 0 || (v24 - 1) > 1 || (LODWORD(v18) = 1.0, v17.n128_f32[0] != 1.0))
  {
    LODWORD(v18) = 1.0;
    if (v17.n128_f32[0] >= 1.0) {
      goto LABEL_61;
    }
LABEL_62:
    *(void *)&long long v33 = argb32_sample_argb32;
    goto LABEL_63;
  }
  if (a2[2] != 5 && a2[2])
  {
LABEL_61:
    if (!*(void *)(a3 + 24))
    {
      if ((BYTE4(v34) & 4) != 0)
      {
        v17.n128_u64[0] = *(void *)(a3 + 32);
        *((void *)a2 + 8) = v17.n128_u64[0];
      }
      argb32_mark(a1, (uint64_t)a2, v17, v18, v19, v20, v11, v12, v13, v14, v15, v16);
      return 1;
    }
    goto LABEL_62;
  }
  argb32_mark_image((uint64_t)a2, v24, (uint64_t)v39 >> SBYTE6(v34), *((uint64_t *)&v39 + 1) >> SBYTE7(v34), *((uint64_t *)&v41 + 1) >> SBYTE7(v34), v14, v15, v16);
  return 1;
}

uint64_t _blt_image_initialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = *(unsigned __int8 *)(a1 + 1) << 8;
  int v7 = 4 * (v6 == 512);
  uint32x2_t v8 = *(uint32x2_t *)(a2 + 32);
  *(uint32x2_t *)(a3 + 256) = v8;
  uint64_t v9 = *(void *)(a2 + 24);
  if (v9)
  {
    v10.i32[0] = *(_DWORD *)(v9 + 12);
    v10.i32[1] = *(_DWORD *)v9;
    float64x2_t v11 = vcvtq_f64_f32(*(float32x2_t *)(v9 + 4));
    _Q1 = vcvtq_f64_f32(v10);
    __asm { FMLA            D2, D1, V1.D[1] }
    if (_D2 == 0.0) {
      return 0xFFFFFFFFLL;
    }
    double v18 = 1.0 / _D2;
    double v19 = (double)(*(_DWORD *)(a1 + 4) - 1);
    int v20 = *(_DWORD *)(a1 + 8) - 1;
    int32x2_t v21 = vsub_s32(*(int32x2_t *)(a1 + 12), *(int32x2_t *)(a1 + 56));
    v22.i64[0] = v21.i32[0];
    v22.i64[1] = v21.i32[1];
    float64x2_t v23 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)(v9 + 16)), vcvtq_f64_s64(v22));
    float64x2_t v24 = vmulq_n_f64(v11, v18);
    float64x2_t v25 = vmulq_n_f64(_Q1, v18);
    int8x16_t v26 = (int8x16_t)vmulq_f64(v23, vnegq_f64(v25));
    int8x16_t v27 = (int8x16_t)vmlaq_f64((float64x2_t)vextq_s8(v26, v26, 8uLL), v23, v24);
    v28.f64[1] = v25.f64[1];
    v28.f64[0] = -v24.f64[1];
    v29.f64[0] = v25.f64[0];
    v29.f64[1] = -v24.f64[0];
    float64x2_t v30 = vaddq_f64(vmlaq_n_f64(vmulq_n_f64(v28, (double)(int)HIDWORD(*(void *)(a1 + 12)) + 0.5), v29, (double)(int)*(void *)(a1 + 12) + 0.5), (float64x2_t)vextq_s8(v27, v27, 8uLL));
    int64x2_t v31 = vcvtq_n_s64_f64(v30, 0x20uLL);
    *(int64x2_t *)(a3 + 96) = v31;
    *(_WORD *)(a3 + 22) = 8224;
    v23.f64[0] = v24.f64[0];
    v23.f64[1] = v25.f64[1];
    int8x16_t v32 = (int8x16_t)vcvtq_s64_f64(vmulq_f64(v23, (float64x2_t)xmmword_1850CDF40));
    uint64_t v33 = v32.i64[1];
    *(void *)(a3 + 136) = v32.i64[1];
    uint64_t v34 = v32.i64[0];
    *(void *)(a3 + 120) = v32.i64[0];
    if (!(v32.i32[2] | v32.i32[0])) {
      v7 |= 0x20u;
    }
    if (v32.i64[1] >= 0) {
      unint64_t v35 = v32.u64[1];
    }
    else {
      unint64_t v35 = -v32.i64[1];
    }
    if (v32.i64[0] >= 0) {
      unint64_t v36 = v32.i64[0];
    }
    else {
      unint64_t v36 = -v32.i64[0];
    }
    unint64_t v37 = v35 + v36;
    unsigned int v38 = *(_DWORD *)(a2 + 36);
    int v39 = v7 | 0x200;
    if (v35 >= v36) {
      unint64_t v40 = v36;
    }
    else {
      unint64_t v40 = v35;
    }
    if (v32.i64[0]) {
      unint64_t v35 = v40;
    }
    if (!v32.i64[1]) {
      unint64_t v35 = v36;
    }
    if (!(v35 >> 34)) {
      v7 |= 0x2000u;
    }
    if (v38 >= 0x7FFFFFFF) {
      uint64_t v41 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v41 = v38;
    }
    if (v38 == 1)
    {
      uint64_t v42 = 1;
    }
    else
    {
      int v39 = v7;
      uint64_t v42 = v41;
    }
    uint64_t v43 = v42 << 32;
    uint64_t v44 = v42 << 32;
    if (v37 >= v42 << 32) {
      unint64_t v45 = v42 << 32;
    }
    else {
      unint64_t v45 = v37;
    }
    if (v45)
    {
      if (v45 < 0x3FFFFFFFFFFFFFFFLL)
      {
        *(void *)(a3 + 216) = v45;
        *(void *)(a3 + 232) = 0x3FFFFFFFFFFFFFFFLL / v45;
        unint64_t v46 = v45 >> 1;
        if (v46 <= 0x80000000) {
          unint64_t v46 = 0x80000000;
        }
      }
      else
      {
        *(void *)(a3 + 216) = 0x3FFFFFFFFFFFFFFFLL;
        *(void *)(a3 + 232) = 1;
        unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *(void *)(a3 + 216) = 0;
      *(void *)(a3 + 232) = 0;
      unint64_t v46 = 0x100000000;
    }
    double v61 = (double)v20;
    *(void *)(a3 + 224) = v46;
    *(void *)(a3 + 56) = v44;
    uint64_t v55 = v46;
    uint64_t v62 = *(float **)(a2 + 40);
    if (v62)
    {
      double v63 = v62[1];
      double v64 = v62[3];
      double v65 = v63 * 4294967300.0;
      _NF = v63 < -2147483650.0;
      double v66 = -9.22337203e18;
      if (!_NF) {
        double v66 = v65;
      }
      uint64_t v67 = (uint64_t)v66;
      double v68 = 9.22337203e18;
      if (v64 <= 2147483650.0) {
        double v68 = v64 * 4294967300.0;
      }
      uint64_t v44 = (uint64_t)v68;
      if ((v39 & 4) == 0)
      {
        if (v67 < -16777216) {
          uint64_t v67 = 0;
        }
        if ((v43 | 0x1000000) < v44) {
          uint64_t v44 = v43;
        }
      }
      uint64_t v55 = v67 + v46;
    }
    float64x2_t v69 = vmlaq_n_f64(v30, v29, v19);
    *(void *)(a3 + 72) = v55;
    unint64_t v70 = v44 - v46;
    *(void *)(a3 + 88) = v44 - v46;
    int8x16_t v71 = (int8x16_t)vcvtq_s64_f64(vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v24, (int8x16_t)v25, 8uLL), (float64x2_t)xmmword_1850CDF40));
    uint64_t v72 = v71.i64[1];
    *(void *)(a3 + 112) = v71.i64[1];
    uint64_t v56 = v71.i64[0];
    *(void *)(a3 + 128) = v71.i64[0];
    if (v71.i32[2] | v71.i32[0]) {
      int v50 = v39;
    }
    else {
      int v50 = v39 | 0x10;
    }
    if (v71.i64[1] >= 0) {
      unint64_t v73 = v71.u64[1];
    }
    else {
      unint64_t v73 = -v71.i64[1];
    }
    if (v71.i64[0] >= 0) {
      unint64_t v74 = v71.i64[0];
    }
    else {
      unint64_t v74 = -v71.i64[0];
    }
    unint64_t v75 = v73 + v74;
    unsigned int v76 = *(_DWORD *)(a2 + 32);
    int v77 = v50 | 0x100;
    if (v73 >= v74) {
      unint64_t v78 = v74;
    }
    else {
      unint64_t v78 = v73;
    }
    if (v71.i64[0]) {
      unint64_t v73 = v78;
    }
    if (!v71.i64[1]) {
      unint64_t v73 = v74;
    }
    if (!(v73 >> 34)) {
      v50 |= 0x1000u;
    }
    if (v76 >= 0x7FFFFFFF) {
      uint64_t v79 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v79 = v76;
    }
    if (v76 == 1)
    {
      int v50 = v77;
      uint64_t v79 = 1;
    }
    uint64_t v80 = v79 << 32;
    uint64_t v81 = v79 << 32;
    if (v75 >= v79 << 32) {
      unint64_t v82 = v79 << 32;
    }
    else {
      unint64_t v82 = v75;
    }
    if (v82)
    {
      if (v82 < 0x3FFFFFFFFFFFFFFFLL)
      {
        *(void *)(a3 + 192) = v82;
        *(void *)(a3 + 208) = 0x3FFFFFFFFFFFFFFFLL / v82;
        unint64_t v83 = v82 >> 1;
        if (v83 <= 0x80000000) {
          unint64_t v83 = 0x80000000;
        }
      }
      else
      {
        *(void *)(a3 + 192) = 0x3FFFFFFFFFFFFFFFLL;
        *(void *)(a3 + 208) = 1;
        unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *(void *)(a3 + 192) = 0;
      *(void *)(a3 + 208) = 0;
      unint64_t v83 = 0x100000000;
    }
    float64x2_t v84 = vmlaq_n_f64(v69, v28, v61);
    *(void *)(a3 + 200) = v83;
    *(void *)(a3 + 48) = v81;
    uint64_t v57 = v83;
    if (v62)
    {
      double v85 = *v62;
      double v86 = v62[2];
      double v87 = v85 * 4294967300.0;
      _NF = v85 < -2147483650.0;
      double v88 = -9.22337203e18;
      if (!_NF) {
        double v88 = v87;
      }
      uint64_t v89 = (uint64_t)v88;
      double v90 = 9.22337203e18;
      if (v86 <= 2147483650.0) {
        double v90 = v86 * 4294967300.0;
      }
      if (v89 >= -16777216) {
        uint64_t v91 = v89;
      }
      else {
        uint64_t v91 = 0;
      }
      if ((v80 | 0x1000000) >= (uint64_t)v90) {
        uint64_t v92 = (uint64_t)v90;
      }
      else {
        uint64_t v92 = v80;
      }
      if ((v50 & 4) != 0)
      {
        uint64_t v81 = (uint64_t)v90;
      }
      else
      {
        uint64_t v89 = v91;
        uint64_t v81 = v92;
      }
      uint64_t v57 = v89 + v83;
    }
    int64x2_t v49 = vcvtq_n_s64_f64(v84, 0x20uLL);
    *(void *)(a3 + 64) = v57;
    *(void *)(a3 + 80) = v81 - v83;
    int32x2_t v93 = vmovn_s64(vceqzq_s64((int64x2_t)vorrq_s8(v71, v32)));
    char v94 = v93.i8[4] | v93.i8[0];
    v59.i64[0] = v81 - v83;
    v59.i64[1] = v70;
    v47.i64[0] = v80;
    v47.i64[1] = v43;
    if (v94)
    {
      if (v71.i64[1] == 0x100000000) {
        int v95 = 66;
      }
      else {
        int v95 = 2;
      }
      int v96 = v50 | v95;
      if (((unint64_t)(v31.i32[0] & 0xF0000000) - 1342177280) >> 29 >= 3) {
        unsigned int v97 = v96;
      }
      else {
        unsigned int v97 = v96 & 0xFFFFEFFF;
      }
      if ((~v50 & 0x1010) != 0) {
        int v50 = v96;
      }
      else {
        int v50 = v97;
      }
      if (v33 == 0x100000000) {
        v50 |= 0x80u;
      }
      if ((~v50 & 0x2020) == 0 && ((unint64_t)(v31.i32[2] & 0xF0000000) - 1342177280) >> 29 < 3) {
        v50 &= ~0x2000u;
      }
    }
  }
  else
  {
    int64x2_t v47 = vshll_n_s32((int32x2_t)vmin_u32(v8, (uint32x2_t)0x8000000080000000), 0x20uLL);
    int64x2_t v31 = (int64x2_t)vorrq_s8((int8x16_t)vshll_n_s32(*(int32x2_t *)(a1 + 56), 0x20uLL), (int8x16_t)vdupq_n_s64(0x80000000uLL));
    *(int64x2_t *)(a3 + 96) = v31;
    *(_WORD *)(a3 + 22) = 8224;
    int64x2_t v48 = vdupq_n_s64(0xFFFFFFFF80000000);
    int64x2_t v49 = vaddq_s64(vshll_n_s32(vadd_s32(*(int32x2_t *)(a1 + 4), *(int32x2_t *)(a1 + 56)), 0x20uLL), v48);
    *(void *)(a3 + 128) = 0;
    *(void *)(a3 + 136) = 0x100000000;
    *(void *)(a3 + 112) = 0x100000000;
    *(void *)(a3 + 120) = 0;
    int v50 = v7 | 0xF2;
    *(_OWORD *)(a3 + 208) = xmmword_1850CDF50;
    *(_OWORD *)(a3 + 224) = xmmword_1850CDF60;
    *(_OWORD *)(a3 + 192) = xmmword_1850CDF70;
    *(int64x2_t *)(a3 + 48) = v47;
    uint64_t v51 = *(float32x2_t **)(a2 + 40);
    if (v51)
    {
      float64x2_t v52 = vcvtq_f64_f32(*v51);
      float64x2_t v53 = (float64x2_t)vdupq_n_s64(0x41F0000000000000uLL);
      int64x2_t v54 = vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64((float64x2_t)vdupq_n_s64(0xC1DFFFFFFFC00000), v52), (int8x16_t)vdupq_n_s64(0xC3DFFFFFFFC00000), (int8x16_t)vmulq_f64(v52, v53)));
      uint64_t v55 = v54.i64[1] + 0x80000000;
      if (v6 == 512)
      {
        uint64_t v34 = 0;
        uint64_t v56 = 0;
        a4 = 0;
        unint64_t v46 = 0x80000000;
        uint64_t v57 = v54.i64[0] + 0x80000000;
        *(void *)(a3 + 64) = v54.i64[0] + 0x80000000;
        *(void *)(a3 + 72) = v55;
        float64x2_t v58 = vcvtq_f64_f32(v51[1]);
        int64x2_t v59 = vaddq_s64(vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v58, (float64x2_t)vdupq_n_s64(0x41DFFFFFFFC00000uLL)), (int8x16_t)vdupq_n_s64(0x43DFFFFFFFC00000uLL), (int8x16_t)vmulq_f64(v58, v53))), vdupq_n_s64(0xFFFFFFFF80000000));
        *(int64x2_t *)(a3 + 80) = v59;
      }
      else
      {
        uint64_t v34 = 0;
        uint64_t v56 = 0;
        a4 = 0;
        v98.i64[0] = -16777216;
        v98.i64[1] = -16777216;
        int8x16_t v99 = (int8x16_t)vcgtq_s64(v98, v54);
        unint64_t v46 = 0x80000000;
        int64x2_t v100 = vdupq_n_s64(0x80000000uLL);
        v54.i64[0] = vaddq_s64(v54, v100).u64[0];
        v54.i64[1] += 0x80000000;
        int8x16_t v101 = vbslq_s8(v99, (int8x16_t)v100, (int8x16_t)v54);
        float64x2_t v102 = vcvtq_f64_f32(v51[1]);
        int64x2_t v103 = vcvtq_s64_f64((float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v102, (float64x2_t)vdupq_n_s64(0x41DFFFFFFFC00000uLL)), (int8x16_t)vdupq_n_s64(0x43DFFFFFFFC00000uLL), (int8x16_t)vmulq_f64(v102, v53)));
        int64x2_t v59 = vaddq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v103, (int64x2_t)vorrq_s8((int8x16_t)v47, (int8x16_t)vdupq_n_s64(0x1000000uLL))), (int8x16_t)v47, (int8x16_t)v103), vdupq_n_s64(0xFFFFFFFF80000000));
        uint64_t v55 = v101.i64[1];
        *(int8x16_t *)(a3 + 64) = v101;
        *(int64x2_t *)(a3 + 80) = v59;
        uint64_t v57 = v101.i64[0];
      }
      uint64_t v33 = 0x100000000;
    }
    else
    {
      uint64_t v34 = 0;
      uint64_t v56 = 0;
      a4 = 0;
      uint64_t v55 = 0x80000000;
      int64x2_t v59 = vaddq_s64(v47, v48);
      uint64_t v33 = 0x100000000;
      *(int64x2_t *)(a3 + 64) = vdupq_n_s64(0x80000000uLL);
      *(int64x2_t *)(a3 + 80) = v59;
      uint64_t v57 = 0x80000000;
      unint64_t v46 = 0x80000000;
    }
    unint64_t v83 = 0x80000000;
    uint64_t v72 = 0x100000000;
  }
  if (*(unsigned __int8 *)(a2 + 6) << 16) {
    int v104 = 0;
  }
  else {
    int v104 = 0x3FFFFFFF;
  }
  *(_DWORD *)(a3 + 188) = v104;
  if ((v50 & 2) != 0)
  {
    _VF = __OFADD__(v56, v72);
    uint64_t v106 = v56 + v72;
    char v105 = (v106 < 0) ^ _VF;
    uint64_t v107 = v33 + v34;
    uint64_t v108 = v49.i64[0] + (v106 >> 1);
    uint64_t v109 = v31.i64[0] - (v106 >> 1);
    uint64_t v110 = v105 ? v108 : v109;
    uint64_t v111 = v105 ? v109 : v108;
    uint64_t v112 = v107 >= 0 ? v31.i64[1] - (v107 >> 1) : v49.i64[1] + (v107 >> 1);
    unint64_t v113 = v83 + (v83 >> 8);
    if (v110 >= (uint64_t)(v57 - v113) && v111 <= (uint64_t)(v59.i64[0] + v113))
    {
      unint64_t v114 = v46 + (v46 >> 8);
      if (v112 >= (uint64_t)(v55 - v114))
      {
        if (v107 >= 0) {
          uint64_t v115 = v49.i64[1] + (v107 >> 1);
        }
        else {
          uint64_t v115 = v31.i64[1] - (v107 >> 1);
        }
        v50 |= v115 <= (uint64_t)(v59.i64[1] + v114);
      }
    }
  }
  if ((v50 & 4) != 0)
  {
    if ((v50 & 1) == 0) {
      goto LABEL_143;
    }
    int32x2_t v116 = vmovn_s64(vcgtzq_s64((int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v49, v31), (int8x16_t)v31, (int8x16_t)v49)));
    if ((v116.i32[0] & v116.i32[1] & 1) == 0) {
      goto LABEL_143;
    }
    int32x2_t v117 = vmovn_s64(vcgtq_s64(v47, (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v31, v49), (int8x16_t)v31, (int8x16_t)v49)));
    if ((v117.i32[0] & v117.i32[1] & 1) == 0) {
      goto LABEL_143;
    }
    v50 &= ~4u;
  }
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
LABEL_143:
  *(_DWORD *)(a3 + 20) = v50 | 0x20200000;
  float v118 = *(float *)(a2 + 8);
  *(float *)(a3 + 184) = v118;
  float v119 = 0.0;
  if (v118 < 0.0 || (float v119 = 1.0, v118 > 1.0)) {
    *(float *)(a3 + 184) = v119;
  }
  double v120 = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(void *)(a3 + 240) = 0;
  *(void *)(a3 + 248) = 0;
  if (a4 && *(unsigned char *)(a2 + 4))
  {
    int v121 = v50 & 0x3000;
    if ((v50 & 0x3000) != 0)
    {
      if (v121 == 0x2000)
      {
        double v120 = &_blt_image_interpolate_y;
      }
      else if (v121 == 4096)
      {
        double v120 = &_blt_image_interpolate_x;
      }
      else
      {
        double v120 = &_blt_image_interpolate_xy;
      }
    }
    else
    {
      double v120 = 0;
    }
  }
  *(void *)(a3 + 176) = v120;
  double v122 = *(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 48);
  if (!v122 || (uint64_t result = v122(*(void *)(a2 + 56), 0, a1 + 88, a1 + 76, a1 + 96, a1 + 80), result != -1))
  {
    *(void *)(a3 + 24) = *(void *)(a1 + 76);
    *(_OWORD *)(a3 + 32) = *(_OWORD *)(a1 + 88);
    return 1;
  }
  return result;
}

void argb32_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  if (a2 != 2 && !*(void *)(a1 + 96))
  {
    if (*(void *)(a1 + 48)) {
      int v11 = 0;
    }
    else {
      int v11 = a2;
    }
  }
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v25 = v15;
  int v26 = v14;
  uint64_t v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    double v19 = v18;
    if (v18) {
      goto LABEL_14;
    }
  }
  int v20 = 0;
  int v21 = 0;
  double v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    float64x2_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    float64x2_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    if (v11 == 1)
    {
      CGBlt_copyBytes(4 * v26, v25, v23, v24, v22 * a5, v13);
      if (!v19) {
        return;
      }
    }
    else if (v11)
    {
      CGSBlend8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, 0xC6u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertRGBX8888toRGBA8888(v23, v22 * a5, v24, v13, v26, v25, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_14:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v26, &v25)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void CGSBlend8888toRGBA8888(char *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7, char a8)
{
  int v11 = a4;
  uint64_t v12 = a3;
  int v13 = a2;
  int v14 = a1;
  vImagePixelCount v15 = a5;
  if (a3 > a1 && a2 == a4)
  {
    uint64_t v16 = &a1[4 * a5];
    if (v16 <= a3)
    {
      unint64_t v19 = (unint64_t)&v16[(a6 - 1) * a2];
      int v20 = (void *)(v19 - 4 * a5);
      BOOL v21 = v19 > (unint64_t)a3;
      if (v19 <= (unint64_t)a3) {
        int v11 = a2;
      }
      else {
        int v11 = -a2;
      }
      if (v19 > (unint64_t)a3) {
        int v17 = &a3[(a6 - 1) * a2];
      }
      else {
        int v17 = a3;
      }
      if (v19 <= (unint64_t)a3) {
        int v18 = a2;
      }
      else {
        int v18 = -a2;
      }
      if (v19 <= (unint64_t)a3) {
        int v22 = a2;
      }
      else {
        int v22 = -a2;
      }
      if (v21) {
        int v14 = v20;
      }
      if (v21) {
        uint64_t v12 = &a3[(a6 - 1) * a2];
      }
      int v13 = v22;
    }
    else
    {
      int v11 = 4 * a5;
      int v17 = (char *)malloc_type_malloc(4 * a5 * a6, 0x90BB46A2uLL);
      int v18 = v13;
    }
  }
  else
  {
    int v17 = a3;
    int v18 = a4;
  }
  srcTop.datdouble a = v14;
  srcTop.double height = a6;
  srcTop.double width = v15;
  srcTop.rowunint64_t Bytes = v13;
  srcBottom.datdouble a = v12;
  srcBottom.double height = a6;
  srcBottom.double width = v15;
  srcBottom.rowunint64_t Bytes = v18;
  dest.datdouble a = v17;
  dest.double height = a6;
  dest.double width = v15;
  dest.rowunint64_t Bytes = v11;
  permuteMap[0] = a7 >> 6;
  permuteMap[1] = (a7 >> 4) & 3;
  permuteMap[2] = (a7 >> 2) & 3;
  permuteMap[3] = a7 & 3;
  vImagePremultipliedAlphaBlendWithPermute_RGBA8888(&srcTop, &srcBottom, &dest, permuteMap, a8 != 1, 0x10u);
  if (v12 != v17)
  {
    CGBlt_copyBytes(v11, a6, v17, v12, v11, v18);
    free(v17);
  }
}

void A8_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v134 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(int *)(a1 + 4);
  unint64_t v5 = (v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF) {
    return;
  }
  uint64_t v133 = *(unsigned int *)(a1 + 4);
  uint64_t v125 = *(int *)(a1 + 28);
  uint64_t v8 = *(void *)(a1 + 40);
  float v9 = *(float *)(a2 + 184);
  float32x2_t v10 = *(int **)(a1 + 136);
  uint64_t v128 = a1;
  double v129 = v10;
  uint64_t v11 = *(void *)(a2 + 96);
  uint64_t v12 = *(void *)(a2 + 104);
  uint64_t v13 = *(int *)(a1 + 12);
  int v14 = *(_DWORD *)(a1 + 16);
  int v15 = *(_DWORD *)(a1 + 8);
  uint64_t v130 = *(int *)(a2 + 16);
  uint64_t v131 = v8;
  uint64_t v16 = (v130 + 3) * v5;
  if (v16 > 65439)
  {
    unint64_t v19 = (char *)malloc_type_calloc(1uLL, v16 + 96, 0x16E13840uLL);
    int v18 = v19;
    BOOL v21 = v19;
    uint64_t v22 = v128;
    int v23 = v133;
    if (!v19) {
      return;
    }
  }
  else
  {
    MEMORY[0x1F4188790](a1, a4);
    int v18 = (char *)&v123 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v17);
    BOOL v21 = 0;
    uint64_t v22 = v128;
    int v23 = v133;
  }
  double v123 = v21;
  LODWORD(v127) = a3;
  int v132 = (int)(float)((float)(int)(float)(v9 * 255.0) + 0.5);
  unint64_t v24 = (unint64_t)(v18 + 15) & 0xFFFFFFFFFFFFFFF0;
  unint64_t v25 = v24 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v130) {
    unint64_t v26 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
  }
  else {
    unint64_t v26 = 0;
  }
  unint64_t v27 = v25 + v26;
  *(void *)(a2 + 144) = v24;
  *(void *)(a2 + 152) = v25 + v26;
  *(void *)(a2 + 160) = v25;
  float64x2_t v28 = (unsigned char *)(v131 + v13 + v14 * (uint64_t)(int)v125);
  uint64_t v124 = v4;
  uint64_t v131 = v125 - v4;
  uint64_t v29 = *(int *)(v22 + 104);
  int v30 = *(_DWORD *)(v22 + 108);
  int v31 = *(unsigned __int8 *)(v22 + 2);
  if (v31 == 6 || v31 == 1)
  {
    if (!v129) {
      goto LABEL_191;
    }
    int8x16_t v32 = 0;
    int v33 = 0;
    uint64_t v34 = *(int *)(v22 + 124);
    unint64_t v35 = (char *)v129 + v29 + (int)v34 * (uint64_t)v30;
    uint64_t v36 = v124;
    double v129 = (int *)(v34 - v124);
    unsigned int v37 = v127;
  }
  else
  {
    if (v129)
    {
      shape_enum_clip_alloc((uint64_t)v19, v20, v129, 1, 1, 1, v29, v30, v23, v15);
      if (!v38) {
        goto LABEL_191;
      }
      int8x16_t v32 = v38;
      int v33 = 0;
      unint64_t v39 = (int)((v130 * v5 + 15) & 0xFFFFFFF0);
      if (!v130) {
        unint64_t v39 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      }
      double v129 = (int *)-v124;
      unint64_t v35 = (char *)(v27 + v39 + 16);
      unsigned int v37 = v127;
LABEL_182:
      int v121 = (int *)(v35 - 16);
      while (1)
      {
        while (1)
        {
          int v122 = *v121 - v33;
          if (*v121 <= v33) {
            break;
          }
          v15 -= v122;
          if (v15 < 1) {
            goto LABEL_189;
          }
          v11 += *(void *)(a2 + 128) * v122;
          v12 += *(void *)(a2 + 136) * v122;
          v28 += (int)v125 * (uint64_t)v122;
          int v33 = *v121;
        }
        if (v33 < *((_DWORD *)v35 - 3) + *v121) {
          break;
        }
        if (!shape_enum_clip_scan((uint64_t)v32, (_DWORD *)v35 - 4)) {
          goto LABEL_189;
        }
      }
      int v23 = v133;
    }
    else
    {
      double v129 = 0;
      int8x16_t v32 = 0;
      unint64_t v35 = 0;
      int v33 = 0;
      unsigned int v37 = v127;
    }
    uint64_t v36 = v124;
  }
  int v40 = v132 ^ 0xFF;
  uint64_t v126 = -v36;
  uint64_t v127 = (v23 - 1) + 1;
  uint64_t v130 = v37;
  uint64_t v41 = v32;
  while (2)
  {
    int8x16_t v32 = v41;
    (*(void (**)(uint64_t, uint64_t, uint64_t))a2)(a2, v11, v12);
    if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(a2 + 12)) {
      _CGHandleAssert("A8_image_pixel", 3658, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt_alpha/blt_alpha.cc", "", "Unimplemented", v42, v43, v44, (char)v123);
    }
    unint64_t v45 = *(unsigned char **)(a2 + 144);
    unint64_t v46 = *(unsigned char **)(a2 + 160);
    if (v132 == 255)
    {
      int v48 = v133;
    }
    else
    {
      int64x2_t v47 = *(unsigned char **)(a2 + 144);
      int v48 = v133;
      int v49 = v133;
      do
      {
        if (*v47) {
          *v46 -= (unsigned __int16)(*v46 * (_WORD)v40
        }
                                   + ((*v46 * v40) >> 8)
                                   + 1) >> 8;
        ++v47;
        ++v46;
        --v49;
      }
      while (v49);
      v46 += v126;
      v45 += v127 + v126;
    }
    switch(v37)
    {
      case 0u:
        unsigned int v76 = (unsigned __int8 *)v35;
        int v77 = v48;
        do
        {
          int v78 = *v45;
          if (*v45)
          {
            if (v35) {
              int v78 = ((unsigned __int16)(*v76 * (_WORD)v78 + ((*v76 * v78) >> 8) + 1) >> 8);
            }
            if (v78)
            {
              if (v78 == 255) {
                LOBYTE(v79) = 0;
              }
              else {
                unsigned int v79 = *v28
              }
                    - ((*v28 * v78 + ((*v28 * v78) >> 8) + 1) >> 8);
              *float64x2_t v28 = v79;
            }
          }
          ++v45;
          v76 += v35 != 0;
          ++v28;
          --v77;
        }
        while (v77);
        unint64_t v35 = (char *)v129 + (void)v76;
        goto LABEL_179;
      case 1u:
        goto LABEL_54;
      case 2u:
        goto LABEL_30;
      case 3u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v81 = v48;
        do
        {
          int v82 = *v45;
          if (*v45)
          {
            if (v35) {
              int v82 = ((unsigned __int16)(*v80 * (_WORD)v82 + ((*v80 * v82) >> 8) + 1) >> 8);
            }
            if (v82)
            {
              if (v82 == 255)
              {
                unsigned int v83 = *v46
                    - (((*v28 ^ 0xFF) * *v46
                      + (((*v28 ^ 0xFF) * *v46) >> 8)
                      + 1) >> 8);
              }
              else
              {
                int v84 = *v28;
                unsigned int v85 = (v84 * v82 + ((v84 * v82) >> 8) + 1) >> 8;
                unsigned int v83 = (v84 * (v82 ^ 0xFF)
                     + v85 * *v46
                     + ((v84 * (v82 ^ 0xFF) + v85 * *v46) >> 8)
                     + 1) >> 8;
              }
              *float64x2_t v28 = v83;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v81;
        }
        while (v81);
        goto LABEL_178;
      case 4u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v86 = v48;
        do
        {
          int v87 = *v45;
          if (*v45)
          {
            if (v35) {
              int v87 = ((unsigned __int16)(*v80 * (_WORD)v87 + ((*v80 * v87) >> 8) + 1) >> 8);
            }
            if (v87)
            {
              if (v87 == 255)
              {
                unsigned int v88 = *v46
                    - ((*v28 * *v46
                      + ((*v28 * *v46) >> 8)
                      + 1) >> 8);
              }
              else
              {
                int v89 = *v28;
                unsigned int v90 = ((v89 ^ 0xFF) * v87 + (((v89 ^ 0xFFu) * v87) >> 8) + 1) >> 8;
                unsigned int v88 = (v89 * (v87 ^ 0xFF)
                     + v90 * *v46
                     + ((v89 * (v87 ^ 0xFF) + v90 * *v46) >> 8)
                     + 1) >> 8;
              }
              *float64x2_t v28 = v88;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v86;
        }
        while (v86);
        goto LABEL_178;
      case 5u:
        uint64_t v91 = (unsigned __int8 *)v35;
        int v92 = v48;
        do
        {
          if (*v45
            && (!v35
             || ((*v91 * *v45 + ((*v91 * *v45) >> 8) + 1) & 0xFF00) != 0))
          {
            *float64x2_t v28 = (unsigned __int16)(255 * *v28
                                    + ((255 * *v28) >> 8)
                                    + 1) >> 8;
          }
          ++v45;
          v91 += v35 != 0;
          ++v28;
          --v92;
        }
        while (v92);
        uint64_t v93 = v127;
        if (!v35) {
          uint64_t v93 = 0;
        }
        unint64_t v35 = (char *)v129 + (void)v35 + v93;
        goto LABEL_179;
      case 6u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v94 = v48;
        do
        {
          int v95 = *v45;
          if (*v45)
          {
            if (!v35
              || (int v95 = ((unsigned __int16)(*v80 * (_WORD)v95 + ((*v80 * v95) >> 8) + 1) >> 8)) != 0)
            {
              int v96 = *v28;
              if ((_BYTE)v96 != 0xFF)
              {
                if (~(_BYTE)v96 == 255)
                {
                  unsigned int v97 = *v46
                      - ((*v46 * (v95 ^ 0xFF) + ((*v46 * (v95 ^ 0xFFu)) >> 8) + 1) >> 8);
                }
                else
                {
                  unsigned int v98 = ((~(_BYTE)v96 * v95
                        + ((~(_BYTE)v96 * v95) >> 8)
                        + 1) >> 8)
                      * *v46;
                  unsigned int v97 = v96 + ((v98 + (v98 >> 8) + 1) >> 8);
                }
                *float64x2_t v28 = v97;
              }
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v94;
        }
        while (v94);
        goto LABEL_178;
      case 7u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v99 = v48;
        do
        {
          int v100 = *v45;
          if (*v45)
          {
            if (v35) {
              int v100 = ((unsigned __int16)(*v80 * (_WORD)v100 + ((*v80 * v100) >> 8) + 1) >> 8);
            }
            if (v100)
            {
              if (v100 == 255)
              {
                unsigned int v101 = *v28
                     - (((*v46 ^ 0xFF) * *v28
                       + (((*v46 ^ 0xFF) * *v28) >> 8)
                       + 1) >> 8);
              }
              else
              {
                unsigned int v102 = *v46 * v100 + ((*v46 * v100) >> 8) + 1;
                unsigned int v101 = (((v100 ^ 0xFF) + (v102 >> 8)) * *v28
                      + ((((v100 ^ 0xFF) + (v102 >> 8)) * *v28) >> 8)
                      + 1) >> 8;
              }
              *float64x2_t v28 = v101;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v99;
        }
        while (v99);
        goto LABEL_178;
      case 8u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v103 = v48;
        do
        {
          int v104 = *v45;
          if (*v45)
          {
            if (v35) {
              int v104 = ((unsigned __int16)(*v80 * (_WORD)v104 + ((*v80 * v104) >> 8) + 1) >> 8);
            }
            if (v104)
            {
              if (v104 == 255)
              {
                unsigned int v105 = *v28
                     - ((*v46 * *v28
                       + ((*v46 * *v28) >> 8)
                       + 1) >> 8);
              }
              else
              {
                unsigned int v106 = (*v46 ^ 0xFF) * v104 + (((*v46 ^ 0xFFu) * v104) >> 8) + 1;
                unsigned int v105 = (((v104 ^ 0xFF) + (v106 >> 8)) * *v28
                      + ((((v104 ^ 0xFF) + (v106 >> 8)) * *v28) >> 8)
                      + 1) >> 8;
              }
              *float64x2_t v28 = v105;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v103;
        }
        while (v103);
        goto LABEL_178;
      case 9u:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v107 = v48;
        while (1)
        {
          unsigned int v108 = *v45;
          if (*v45)
          {
            if (!v35) {
              goto LABEL_151;
            }
            unsigned int v109 = *v80 * v108 + ((*v80 * v108) >> 8) + 1;
            if (BYTE1(v109)) {
              break;
            }
          }
LABEL_152:
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          if (!--v107)
          {
LABEL_178:
            unint64_t v35 = (char *)v129 + (void)v80;
LABEL_179:
            v28 += v131;
            goto LABEL_180;
          }
        }
        unsigned int v108 = v109 >> 8;
LABEL_151:
        char v110 = ~(_BYTE)v108;
        unsigned __int8 v111 = *v46
             - ((unsigned __int16)(*v46 * ~(_BYTE)v108
                                 + ((*v46 * ~(_BYTE)v108) >> 8)
                                 + 1) >> 8);
        *float64x2_t v28 = (unsigned __int16)(v111 * (*v28 ^ 0xFF)
                                + (v111 + v110) * *v28
                                + ((v111 * (*v28 ^ 0xFF)
                                  + (v111 + v110) * *v28) >> 8)
                                + 1) >> 8;
        goto LABEL_152;
      case 0xAu:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v112 = v48;
        do
        {
          int v113 = *v45;
          if (*v45)
          {
            if (!v35
              || (int v113 = ((unsigned __int16)(*v80 * (_WORD)v113 + ((*v80 * v113) >> 8) + 1) >> 8)) != 0)
            {
              unsigned int v114 = *v46
                   - ((*v46 * (v113 ^ 0xFF) + ((*v46 * (v113 ^ 0xFFu)) >> 8) + 1) >> 8);
              *float64x2_t v28 = (unsigned __int16)(v114 * (*v28 ^ 0xFF)
                                      + ~(_BYTE)v114 * *v28
                                      + ((v114 * (*v28 ^ 0xFF)
                                        + ~(_BYTE)v114 * *v28) >> 8)
                                      + 1) >> 8;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v112;
        }
        while (v112);
        goto LABEL_178;
      case 0xBu:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v115 = v48;
        do
        {
          int v116 = *v45;
          if (*v45)
          {
            if (!v35
              || (int v116 = ((unsigned __int16)(*v80 * (_WORD)v116 + ((*v80 * v116) >> 8) + 1) >> 8)) != 0)
            {
              unsigned int v117 = *v28
                   + (*v46
                                     - ((unsigned __int16)(*v46 * (v116 ^ 0xFF)
                                                         + ((*v46 * (v116 ^ 0xFFu)) >> 8)
                                                         + 1) >> 8));
              if (v117 >= 0xFF) {
                LOBYTE(v117) = -1;
              }
              *float64x2_t v28 = v117;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v115;
        }
        while (v115);
        goto LABEL_178;
      case 0xCu:
        uint64_t v80 = (unsigned __int8 *)v35;
        int v118 = v48;
        do
        {
          int v119 = *v45;
          if (*v45)
          {
            if (!v35
              || (int v119 = ((unsigned __int16)(*v80 * (_WORD)v119 + ((*v80 * v119) >> 8) + 1) >> 8)) != 0)
            {
              unsigned int v120 = *v28
                   + (*v46
                                     - ((unsigned __int16)(*v46 * (v119 ^ 0xFF)
                                                         + ((*v46 * (v119 ^ 0xFFu)) >> 8)
                                                         + 1) >> 8));
              if (v120 >= 0xFF) {
                LOBYTE(v120) = -1;
              }
              *float64x2_t v28 = v120;
            }
          }
          ++v45;
          ++v46;
          v80 += v35 != 0;
          ++v28;
          --v118;
        }
        while (v118);
        goto LABEL_178;
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
        if (*(void *)(v128 + 96))
        {
LABEL_30:
          int v50 = *v45;
          uint64_t v51 = v45 + 1;
          float64x2_t v52 = v28 - 1;
          int v53 = v48;
          if (v35)
          {
            while (1)
            {
              if (!v50) {
                goto LABEL_41;
              }
              unsigned int v54 = *v35 * v50 + ((*v35 * v50) >> 8) + 1;
              if (!BYTE1(v54)) {
                goto LABEL_41;
              }
              if (BYTE1(v54) == 255)
              {
                int v55 = *v46;
                if (*v46)
                {
                  if (v55 != 255)
                  {
                    int v56 = v52[1];
                    int v57 = v55 ^ 0xFF;
                    goto LABEL_39;
                  }
                  goto LABEL_40;
                }
              }
              else
              {
                unsigned int v58 = v54 >> 8;
                int v59 = *v46;
                unsigned int v60 = (v58 ^ 0xFF) * v59 + (((v58 ^ 0xFF) * v59) >> 8) + 1;
                if (v59 != BYTE1(v60))
                {
                  int v55 = v59 - (v60 >> 8);
                  int v56 = v52[1];
                  int v57 = ~(_BYTE)v55;
LABEL_39:
                  v55 += (v56 * v57 + ((v56 * v57) >> 8) + 1) >> 8;
LABEL_40:
                  v52[1] = v55;
                }
              }
LABEL_41:
              int v61 = *v51++;
              int v50 = v61;
              ++v46;
              ++v35;
              ++v52;
              if (!--v53) {
                goto LABEL_62;
              }
            }
          }
          while (1)
          {
            if (v50)
            {
              if (v50 == 255)
              {
                int v62 = *v46;
                if (*v46)
                {
                  if (v62 != 255)
                  {
                    int v63 = v52[1];
                    int v64 = v62 ^ 0xFF;
                    goto LABEL_50;
                  }
                  goto LABEL_51;
                }
              }
              else
              {
                int v65 = *v46;
                unsigned int v66 = v65 * (v50 ^ 0xFF) + ((v65 * (v50 ^ 0xFFu)) >> 8) + 1;
                if (v65 != BYTE1(v66))
                {
                  int v62 = v65 - (v66 >> 8);
                  int v63 = v52[1];
                  int v64 = ~(_BYTE)v62;
LABEL_50:
                  v62 += (v63 * v64 + ((v63 * v64) >> 8) + 1) >> 8;
LABEL_51:
                  v52[1] = v62;
                }
              }
            }
            int v67 = *v51++;
            int v50 = v67;
            ++v46;
            ++v52;
            if (!--v53) {
              goto LABEL_69;
            }
          }
        }
LABEL_54:
        int v68 = *v45;
        float64x2_t v69 = v45 + 1;
        float64x2_t v52 = v28 - 1;
        int v70 = v48;
        if (v35)
        {
          do
          {
            if (v68)
            {
              unsigned int v71 = *v35 * v68 + ((*v35 * v68) >> 8) + 1;
              if (BYTE1(v71))
              {
                if (BYTE1(v71) == 255) {
                  LOBYTE(v72) = *v46;
                }
                else {
                  unsigned int v72 = ((v71 >> 8) * *v46
                }
                       + ((v71 >> 8) ^ 0xFF) * v52[1]
                       + (((v71 >> 8) * *v46 + ((v71 >> 8) ^ 0xFF) * v52[1]) >> 8)
                       + 1) >> 8;
                v52[1] = v72;
              }
            }
            int v73 = *v69++;
            int v68 = v73;
            ++v46;
            ++v35;
            ++v52;
            --v70;
          }
          while (v70);
LABEL_62:
          unint64_t v35 = (char *)v129 + (void)v35;
          goto LABEL_70;
        }
        do
        {
          if (v68)
          {
            if (v68 == 255) {
              LOBYTE(v74) = *v46;
            }
            else {
              unsigned int v74 = (*v46 * v68
            }
                   + v52[1] * (v68 ^ 0xFF)
                   + ((*v46 * v68 + v52[1] * (v68 ^ 0xFFu)) >> 8)
                   + 1) >> 8;
            v52[1] = v74;
          }
          int v75 = *v69++;
          int v68 = v75;
          ++v46;
          ++v52;
          --v70;
        }
        while (v70);
LABEL_69:
        unint64_t v35 = 0;
LABEL_70:
        float64x2_t v28 = &v52[v131 + 1];
LABEL_180:
        if (--v15)
        {
          uint64_t v41 = 0;
          ++v33;
          v11 += *(void *)(a2 + 128);
          v12 += *(void *)(a2 + 136);
          if (v32) {
            goto LABEL_182;
          }
          continue;
        }
LABEL_189:
        if (v32) {
          free(v32);
        }
LABEL_191:
        if (v123) {
          free(v123);
        }
        return;
      default:
        goto LABEL_180;
    }
  }
}

uint64_t A8_sample_A8_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(result + 24);
  uint64_t v5 = *(void *)(result + 112);
  uint64_t v6 = *(void *)(result + 48);
  uint64_t v7 = *(void *)(result + 56);
  if (v6)
  {
    uint64_t v106 = *(void *)(result + 112);
    if (v5 > v6) {
      uint64_t v106 = v5 % v6;
    }
  }
  else
  {
    uint64_t v106 = 0;
  }
  uint64_t v8 = *(void *)(result + 176);
  uint64_t v9 = *(void *)(result + 120);
  uint64_t v10 = *(void *)(result + 32);
  if (v7)
  {
    uint64_t v105 = *(void *)(result + 120);
    if (v9 > v7) {
      uint64_t v105 = v9 % v7;
    }
  }
  else
  {
    uint64_t v105 = 0;
  }
  uint64_t v101 = *(void *)(result + 80);
  uint64_t v102 = *(void *)(result + 64);
  uint64_t v103 = *(void *)(result + 88);
  uint64_t v104 = *(void *)(result + 72);
  uint64_t v11 = *(void *)(result + 152) - 1;
  uint64_t v12 = *(void *)(result + 144) - 1;
  int v100 = *(_DWORD *)(result + 188);
  unint64_t v13 = v10 + *(unsigned int *)(result + 256) + ((*(_DWORD *)(result + 260) - 1) * v4) - 1;
  while (1)
  {
LABEL_10:
    if (a3 < v104)
    {
      uint64_t v14 = *(void *)(result + 216);
      uint64_t v15 = v104 - *(void *)(result + 224);
      uint64_t v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1) {
        goto LABEL_51;
      }
      if (v16 >= v14) {
        LODWORD(v17) = 0x3FFFFFFF;
      }
      else {
        unint64_t v17 = (unint64_t)(*(void *)(result + 232) * v16) >> 32;
      }
      unsigned int v24 = v100 | v17;
      uint64_t v25 = v15 + 0x1000000;
      uint64_t v22 = a3 - (v15 + 0x1000000);
      uint64_t v23 = 512;
      goto LABEL_21;
    }
    if (a3 <= v103)
    {
      uint64_t v22 = 0;
      uint64_t v23 = ((unint64_t)a3 >> 22) & 0x3C0;
      unsigned int v24 = 0x3FFFFFFF;
      uint64_t v25 = a3;
LABEL_21:
      uint64_t v26 = v102;
      goto LABEL_24;
    }
    uint64_t v18 = *(void *)(result + 216);
    uint64_t v19 = *(void *)(result + 224) + v103;
    uint64_t v20 = v19 - a3 + (v18 >> 1);
    if (v20 < 1) {
      goto LABEL_51;
    }
    if (v20 >= v18) {
      LODWORD(v21) = 0x3FFFFFFF;
    }
    else {
      unint64_t v21 = (unint64_t)(*(void *)(result + 232) * v20) >> 32;
    }
    uint64_t v26 = v102;
    unsigned int v24 = v100 | v21;
    uint64_t v25 = v19 - 0x1000000;
    uint64_t v22 = a3 - (v19 - 0x1000000);
    uint64_t v23 = 448;
LABEL_24:
    if (a2 >= v26) {
      break;
    }
    uint64_t v27 = *(void *)(result + 192);
    uint64_t v28 = v26 - *(void *)(result + 200);
    uint64_t v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27) {
        unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v29) >> 32) >> 15)) | v100;
      }
      uint64_t v30 = v28 + 0x1000000;
      uint64_t v31 = a2 - (v28 + 0x1000000);
      uint64_t v32 = 32;
      goto LABEL_35;
    }
LABEL_51:
    --a4;
    a2 += v5;
    a3 += v9;
    ++v11;
    *(unsigned char *)++uint64_t v12 = 0;
    if (!a4) {
      return result;
    }
  }
  if (a2 <= v101)
  {
    uint64_t v31 = 0;
    uint64_t v32 = ((unint64_t)a2 >> 26) & 0x3C;
    uint64_t v30 = a2;
    goto LABEL_35;
  }
  uint64_t v33 = *(void *)(result + 192);
  uint64_t v34 = *(void *)(result + 200) + v101;
  uint64_t v35 = v34 - a2 + (v33 >> 1);
  if (v35 < 1) {
    goto LABEL_51;
  }
  if (v35 < v33) {
    unsigned int v24 = ((v24 >> 15) * (((unint64_t)(*(void *)(result + 208) * v35) >> 32) >> 15)) | v100;
  }
  uint64_t v30 = v34 - 0x1000000;
  uint64_t v31 = a2 - (v34 - 0x1000000);
  uint64_t v32 = 28;
LABEL_35:
  if (v24 < 0x400000) {
    goto LABEL_51;
  }
  if (v6)
  {
    uint64_t v36 = (v7 & ((v25 % v7) >> 63)) + v25 % v7;
    uint64_t v37 = (v6 & ((v30 % v6) >> 63)) + v30 % v6;
    if (v36 >= v7) {
      uint64_t v38 = v7;
    }
    else {
      uint64_t v38 = 0;
    }
    uint64_t v25 = v36 - v38;
    if (v37 >= v6) {
      uint64_t v39 = v6;
    }
    else {
      uint64_t v39 = 0;
    }
    uint64_t v30 = v37 - v39;
    v22 += v25;
    v31 += v30;
  }
  uint64_t v40 = v10 + SHIDWORD(v25) * (uint64_t)v4;
  unint64_t v41 = v40 + (v30 >> 32);
  uint64_t v42 = *(unsigned __int8 **)(result + 32);
  if (v13 >= v41) {
    uint64_t v43 = (unsigned __int8 *)(v40 + (v30 >> 32));
  }
  else {
    uint64_t v43 = (unsigned __int8 *)v13;
  }
  if (v43 < v42) {
    uint64_t v43 = *(unsigned __int8 **)(result + 32);
  }
  unsigned int v44 = *v43;
  if (v8)
  {
    unsigned int v45 = *(_DWORD *)(v8 + (v32 | v23));
LABEL_53:
    int v46 = v45 & 0xF;
    uint64_t v47 = v45 >> 8;
    int v48 = HIBYTE(v45) & 3;
    switch(v46)
    {
      case 1:
        LODWORD(v72) = SBYTE1(v45);
        if (v6)
        {
          uint64_t v73 = v47 << 56;
          uint64_t v74 = v22 + ((uint64_t)(char)v47 << 32);
          uint64_t v75 = v7 & (v74 >> 63);
          if (v75 + v74 >= v7) {
            uint64_t v76 = v7;
          }
          else {
            uint64_t v76 = 0;
          }
          uint64_t v72 = (v75 + (v73 >> 24) - v76) >> 32;
        }
        int v77 = (unsigned __int8 *)(v41 + (int)v72 * (uint64_t)v4);
        if (v13 < (unint64_t)v77) {
          int v77 = (unsigned __int8 *)v13;
        }
        if (v77 < v42) {
          int v77 = v42;
        }
        int v78 = interpolate_8888_21358[v48];
        unsigned int v70 = v44 - ((v78 & v44) >> (v48 + 1));
        unsigned int v71 = (v78 & *v77) >> (v48 + 1);
LABEL_88:
        LOBYTE(v44) = v70 + v71;
        break;
      case 2:
        uint64_t v79 = SBYTE2(v45);
        if (v6)
        {
          uint64_t v80 = v31 + ((uint64_t)SBYTE2(v45) << 32);
          uint64_t v81 = v6 & (v80 >> 63);
          if (v81 + v80 >= v6) {
            uint64_t v82 = v6;
          }
          else {
            uint64_t v82 = 0;
          }
          uint64_t v79 = (v81 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v82) >> 32;
        }
        unsigned int v83 = (unsigned __int8 *)(v41 + v79);
        if (v13 < (unint64_t)v83) {
          unsigned int v83 = (unsigned __int8 *)v13;
        }
        if (v83 < v42) {
          unsigned int v83 = v42;
        }
        unsigned int v44 = v44
            - ((interpolate_8888_21358[(v45 >> 28) & 3] & v44) >> (((v45 >> 28) & 3) + 1))
            + ((interpolate_8888_21358[(v45 >> 28) & 3] & *v83) >> (((v45 >> 28) & 3) + 1));
        break;
      case 3:
        int v99 = HIBYTE(v45) & 3;
        LODWORD(v49) = SBYTE1(v45);
        uint64_t v50 = SBYTE2(v45);
        if (v6)
        {
          uint64_t v51 = v47 << 56;
          uint64_t v52 = v22 + (v51 >> 24);
          uint64_t v53 = v31 + ((uint64_t)SBYTE2(v45) << 32);
          uint64_t v54 = v7 & (v52 >> 63);
          uint64_t v55 = v6 & (v53 >> 63);
          uint64_t v56 = v55 + v53;
          if (v54 + v52 >= v7) {
            uint64_t v57 = v7;
          }
          else {
            uint64_t v57 = 0;
          }
          if (v56 >= v6) {
            uint64_t v58 = v6;
          }
          else {
            uint64_t v58 = 0;
          }
          uint64_t v49 = (v54 + (v51 >> 24) - v57) >> 32;
          uint64_t v50 = (v55 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v58) >> 32;
        }
        int v59 = (unsigned __int8 *)(v41 + v50);
        if (v13 < v41 + v50) {
          int v59 = (unsigned __int8 *)v13;
        }
        if (v59 < v42) {
          int v59 = v42;
        }
        unsigned int v60 = *v59;
        unint64_t v61 = v41 + (int)v49 * (uint64_t)v4;
        if (v13 >= v61) {
          int v62 = (unsigned __int8 *)(v41 + (int)v49 * (uint64_t)v4);
        }
        else {
          int v62 = (unsigned __int8 *)v13;
        }
        if (v62 < v42) {
          int v62 = v42;
        }
        unsigned int v63 = *v62;
        int v64 = (unsigned __int8 *)(v61 + v50);
        if (v13 < (unint64_t)v64) {
          int v64 = (unsigned __int8 *)v13;
        }
        if (v64 < v42) {
          int v64 = v42;
        }
        int v65 = interpolate_8888_21358[v99];
        unsigned int v66 = v44 - ((v65 & v44) >> (v99 + 1)) + ((v65 & v63) >> (v99 + 1));
        unsigned int v67 = v60 - ((v65 & v60) >> (v99 + 1)) + ((v65 & *v64) >> (v99 + 1));
        int v68 = (v45 >> 28) & 3;
        int v69 = interpolate_8888_21358[v68];
        LOBYTE(v68) = v68 + 1;
        unsigned int v70 = v66 - ((v66 & v69) >> v68);
        unsigned int v71 = (v67 & v69) >> v68;
        goto LABEL_88;
    }
  }
  *(unsigned char *)(v11 + 1) = v44;
  *(unsigned char *)(v12 + 1) = v24 >> 22;
  if (a4 != 1)
  {
    uint64_t v84 = 0;
    a2 += v5;
    uint64_t v85 = v101 - a2;
    a3 += v9;
    uint64_t v86 = v103 - a3;
    int v87 = --a4;
    while (1)
    {
      uint64_t v88 = v12 + v84 + 1;
      uint64_t v89 = v11 + v84 + 1;
      if ((v86 | v85 | (a3 - v104) | (a2 - v102)) < 0) {
        break;
      }
      if (v6)
      {
        uint64_t v90 = (v7 & ((v22 + v105) >> 63)) + v22 + v105;
        uint64_t v91 = (v6 & ((v31 + v106) >> 63)) + v31 + v106;
        if (v90 >= v7) {
          uint64_t v92 = v7;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v93 = v90 - v92;
        if (v91 >= v6) {
          uint64_t v94 = v6;
        }
        else {
          uint64_t v94 = 0;
        }
        uint64_t v95 = v91 - v94;
        uint64_t v31 = v95;
        uint64_t v22 = v93;
      }
      else
      {
        uint64_t v95 = a2;
        HIDWORD(v93) = HIDWORD(a3);
      }
      uint64_t v96 = v10 + SHIDWORD(v93) * (uint64_t)v4;
      unint64_t v41 = v96 + (v95 >> 32);
      uint64_t v42 = *(unsigned __int8 **)(result + 32);
      if (v13 >= v41) {
        unsigned int v97 = (unsigned __int8 *)(v96 + (v95 >> 32));
      }
      else {
        unsigned int v97 = (unsigned __int8 *)v13;
      }
      if (v97 < v42) {
        unsigned int v97 = *(unsigned __int8 **)(result + 32);
      }
      unsigned int v44 = *v97;
      if (v8)
      {
        unsigned int v45 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v45 & 0xF) != 0)
        {
          unsigned int v24 = -1;
          uint64_t v11 = v89;
          uint64_t v12 = v88;
          goto LABEL_53;
        }
      }
      --a4;
      *(unsigned char *)(v11 + v84 + 2) = v44;
      uint64_t v98 = v12 + v84++;
      *(unsigned char *)(v98 + 2) = -1;
      a2 += v5;
      v85 -= v5;
      a3 += v9;
      v86 -= v9;
      if (v87 == v84) {
        return result;
      }
    }
    v11 += v84 + 1;
    v12 += v84 + 1;
    if (a4) {
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t A8_sample_ALPHA8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(result + 40);
  int v103 = *(_DWORD *)(result + 28);
  if (v4)
  {
    uint64_t v5 = *(void *)(result + 176);
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
    uint64_t v11 = *(void *)(result + 48);
    uint64_t v10 = *(void *)(result + 56);
    BOOL v12 = v11 == 0;
    if (v11)
    {
      uint64_t v100 = *(void *)(result + 112);
      if (v8 > v11) {
        uint64_t v100 = v8 % v11;
      }
    }
    else
    {
      uint64_t v100 = 0;
    }
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    if (v10)
    {
      if (v9 <= v10) {
        uint64_t v99 = *(void *)(result + 120);
      }
      else {
        uint64_t v99 = v9 % v10;
      }
    }
    else
    {
      uint64_t v99 = 0;
    }
  }
  else
  {
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    uint64_t v11 = 0;
    uint64_t v5 = 0;
    uint64_t v10 = 0;
    uint64_t v6 = *(void *)(result + 64);
    uint64_t v7 = *(void *)(result + 72);
    uint64_t v97 = *(void *)(result + 80);
    uint64_t v98 = *(void *)(result + 88);
    BOOL v12 = 1;
    uint64_t v8 = *(void *)(result + 112);
    uint64_t v9 = *(void *)(result + 120);
  }
  int v96 = *(_DWORD *)(result + 188);
  uint64_t v13 = *(void *)(result + 152) - 1;
  uint64_t v14 = *(void *)(result + 144) - 1;
  char v101 = *(unsigned char *)(result + 248);
  uint64_t v102 = *(unsigned __int8 *)(result + 252);
  uint64_t v15 = (unsigned __int8 *)(v4
                          + ((*(_DWORD *)(result + 256) - 1) << v101)
                          + ((*(_DWORD *)(result + 260) - 1) * v103));
  uint64_t v16 = -v7;
  while (1)
  {
LABEL_13:
    if (a3 >= v7)
    {
      if (a3 <= v98)
      {
        uint64_t v25 = 0;
        uint64_t v26 = ((unint64_t)a3 >> 22) & 0x3C0;
        unsigned int v27 = 0x3FFFFFFF;
        uint64_t v28 = a3;
      }
      else
      {
        uint64_t v21 = *(void *)(result + 216);
        uint64_t v22 = *(void *)(result + 224) + v98;
        uint64_t v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1) {
          break;
        }
        if (v23 >= v21) {
          LODWORD(v24) = 0x3FFFFFFF;
        }
        else {
          unint64_t v24 = (unint64_t)(*(void *)(result + 232) * v23) >> 32;
        }
        unsigned int v27 = v24 | v96;
        uint64_t v28 = v22 - 0x1000000;
        uint64_t v25 = a3 - (v22 - 0x1000000);
        uint64_t v26 = 448;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(result + 216);
      uint64_t v18 = v7 - *(void *)(result + 224);
      uint64_t v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1) {
        break;
      }
      if (v19 >= v17) {
        LODWORD(v20) = 0x3FFFFFFF;
      }
      else {
        unint64_t v20 = (unint64_t)(*(void *)(result + 232) * v19) >> 32;
      }
      unsigned int v27 = v20 | v96;
      uint64_t v28 = v18 + 0x1000000;
      uint64_t v25 = a3 - (v18 + 0x1000000);
      uint64_t v26 = 512;
    }
    if (a2 >= v6)
    {
      if (a2 <= v97)
      {
        uint64_t v33 = 0;
        uint64_t v34 = ((unint64_t)a2 >> 26) & 0x3C;
        uint64_t v32 = a2;
      }
      else
      {
        uint64_t v35 = *(void *)(result + 192);
        uint64_t v36 = *(void *)(result + 200) + v97;
        uint64_t v37 = v36 - a2 + (v35 >> 1);
        if (v37 < 1) {
          break;
        }
        if (v37 < v35) {
          unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v37) >> 32) >> 15)) | v96;
        }
        uint64_t v32 = v36 - 0x1000000;
        uint64_t v33 = a2 - (v36 - 0x1000000);
        uint64_t v34 = 28;
      }
    }
    else
    {
      uint64_t v29 = *(void *)(result + 192);
      uint64_t v30 = v6 - *(void *)(result + 200);
      uint64_t v31 = a2 - v30 + (v29 >> 1);
      if (v31 < 1) {
        break;
      }
      if (v31 < v29) {
        unsigned int v27 = ((v27 >> 15) * (((unint64_t)(*(void *)(result + 208) * v31) >> 32) >> 15)) | v96;
      }
      uint64_t v32 = v30 + 0x1000000;
      uint64_t v33 = a2 - (v30 + 0x1000000);
      uint64_t v34 = 32;
    }
    if (v27 < 0x400000) {
      break;
    }
    if (!v12)
    {
      uint64_t v38 = (v10 & ((v28 % v10) >> 63)) + v28 % v10;
      uint64_t v39 = (v11 & ((v32 % v11) >> 63)) + v32 % v11;
      if (v38 >= v10) {
        uint64_t v40 = v10;
      }
      else {
        uint64_t v40 = 0;
      }
      uint64_t v28 = v38 - v40;
      if (v39 >= v11) {
        uint64_t v41 = v11;
      }
      else {
        uint64_t v41 = 0;
      }
      uint64_t v32 = v39 - v41;
      v25 += v28;
      v33 += v32;
    }
    if (v4)
    {
      uint64_t v42 = v4 + SHIDWORD(v28) * (uint64_t)v103 + (v32 >> 32 << v101);
      uint64_t v43 = (unsigned __int8 *)(v42 + v102);
      if ((unint64_t)v15 < v42 + v102) {
        uint64_t v43 = v15;
      }
      if ((unint64_t)v43 < *(void *)(result + 40)) {
        uint64_t v43 = *(unsigned __int8 **)(result + 40);
      }
      unsigned int v44 = *v43;
      if (v5)
      {
LABEL_56:
        unsigned int v45 = *(_DWORD *)(v5 + (v34 | v26));
LABEL_58:
        int v46 = v45 & 0xF;
        uint64_t v47 = v45 >> 8;
        int v48 = HIBYTE(v45) & 3;
        switch(v46)
        {
          case 1:
            LODWORD(v71) = SBYTE1(v45);
            if (!v12)
            {
              uint64_t v72 = v25 + ((uint64_t)(char)v47 << 32);
              uint64_t v73 = v10 & (v72 >> 63);
              if (v73 + v72 >= v10) {
                uint64_t v74 = v10;
              }
              else {
                uint64_t v74 = 0;
              }
              uint64_t v71 = (v73 + ((uint64_t)(char)v47 << 32) - v74) >> 32;
            }
            int v75 = 255;
            if (v4)
            {
              uint64_t v76 = (unsigned __int8 *)(v42 + (int)v71 * (uint64_t)v103 + v102);
              if (v15 < v76) {
                uint64_t v76 = v15;
              }
              if ((unint64_t)v76 < *(void *)(result + 40)) {
                uint64_t v76 = *(unsigned __int8 **)(result + 40);
              }
              int v75 = *v76;
            }
            unsigned int v44 = v44
                - ((interpolate_8888_21358[v48] & v44) >> (v48 + 1))
                + ((interpolate_8888_21358[v48] & v75) >> (v48 + 1));
            break;
          case 2:
            uint64_t v77 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v78 = v33 + ((uint64_t)SBYTE2(v45) << 32);
              uint64_t v79 = v11 & (v78 >> 63);
              if (v79 + v78 >= v11) {
                uint64_t v80 = v11;
              }
              else {
                uint64_t v80 = 0;
              }
              uint64_t v77 = (v79 + ((uint64_t)((unint64_t)HIWORD(v45) << 56) >> 24) - v80) >> 32;
            }
            int v81 = 255;
            if (v4)
            {
              unint64_t v82 = v42 + (v77 << v101);
              if ((unint64_t)v15 < v82) {
                unint64_t v82 = (unint64_t)v15;
              }
              if (v82 < *(void *)(result + 40)) {
                unint64_t v82 = *(void *)(result + 40);
              }
              int v81 = *(unsigned __int8 *)(v82 + v102);
            }
            unsigned int v44 = v44
                - ((interpolate_8888_21358[(v45 >> 28) & 3] & v44) >> (((v45 >> 28) & 3) + 1))
                + ((interpolate_8888_21358[(v45 >> 28) & 3] & v81) >> (((v45 >> 28) & 3) + 1));
            break;
          case 3:
            int v94 = HIBYTE(v45) & 3;
            uint64_t v95 = v7;
            LODWORD(v49) = SBYTE1(v45);
            uint64_t v50 = SBYTE2(v45);
            if (!v12)
            {
              uint64_t v51 = v47 << 56;
              int64_t v52 = (unint64_t)HIWORD(v45) << 56;
              uint64_t v53 = v25 + ((uint64_t)SBYTE1(v45) << 32);
              uint64_t v54 = v33 + (v52 >> 24);
              uint64_t v55 = v10 & (v53 >> 63);
              uint64_t v56 = v11 & (v54 >> 63);
              uint64_t v57 = v56 + v54;
              if (v55 + v53 >= v10) {
                uint64_t v58 = v10;
              }
              else {
                uint64_t v58 = 0;
              }
              if (v57 >= v11) {
                uint64_t v59 = v11;
              }
              else {
                uint64_t v59 = 0;
              }
              uint64_t v49 = (v55 + (v51 >> 24) - v58) >> 32;
              uint64_t v50 = (v56 + (v52 >> 24) - v59) >> 32;
            }
            int v60 = 255;
            int v61 = 255;
            int v62 = 255;
            if (v4)
            {
              uint64_t v63 = v50 << v101;
              int v64 = (unsigned __int8 *)(v42 + v102 + (v50 << v101));
              unint64_t v65 = *(void *)(result + 40);
              if (v15 < v64) {
                int v64 = v15;
              }
              if ((unint64_t)v64 < v65) {
                int v64 = *(unsigned __int8 **)(result + 40);
              }
              int v60 = *v64;
              unint64_t v66 = v42 + (int)v49 * (uint64_t)v103 + v102;
              if ((unint64_t)v15 >= v66) {
                unsigned int v67 = (unsigned __int8 *)(v42 + (int)v49 * (uint64_t)v103 + v102);
              }
              else {
                unsigned int v67 = v15;
              }
              if ((unint64_t)v67 < v65) {
                unsigned int v67 = *(unsigned __int8 **)(result + 40);
              }
              int v61 = *v67;
              int v68 = (unsigned __int8 *)(v66 + v63);
              if (v15 < v68) {
                int v68 = v15;
              }
              if ((unint64_t)v68 < v65) {
                int v68 = *(unsigned __int8 **)(result + 40);
              }
              int v62 = *v68;
            }
            int v69 = interpolate_8888_21358[v94];
            int v70 = (v45 >> 28) & 3;
            unsigned int v44 = v44
                - ((v69 & v44) >> (v94 + 1))
                + ((v69 & v61) >> (v94 + 1))
                - (((v44 - ((v69 & v44) >> (v94 + 1)) + ((v69 & v61) >> (v94 + 1))) & interpolate_8888_21358[v70]) >> (v70 + 1))
                + (((v60 - ((v69 & v60) >> (v94 + 1)) + ((v69 & v62) >> (v94 + 1))) & interpolate_8888_21358[v70]) >> (v70 + 1));
            uint64_t v7 = v95;
            break;
        }
      }
    }
    else
    {
      uint64_t v42 = 0;
      unsigned int v44 = 255;
      if (v5) {
        goto LABEL_56;
      }
    }
    *(unsigned char *)(v13 + 1) = v44;
    *(unsigned char *)(v14 + 1) = v27 >> 22;
    if (a4 == 1) {
      return result;
    }
    uint64_t v83 = 0;
    a2 += v8;
    uint64_t v84 = v97 - a2;
    a3 += v9;
    uint64_t v85 = v98 - a3;
    while ((((a2 - v6) | v84 | (v16 + a3) | v85) & 0x8000000000000000) == 0)
    {
      if (v12)
      {
        uint64_t v86 = a2;
        HIDWORD(v87) = HIDWORD(a3);
        if (!v4) {
          goto LABEL_127;
        }
      }
      else
      {
        uint64_t v89 = (v10 & ((v25 + v99) >> 63)) + v25 + v99;
        uint64_t v90 = (v11 & ((v33 + v100) >> 63)) + v33 + v100;
        if (v89 >= v10) {
          uint64_t v91 = v10;
        }
        else {
          uint64_t v91 = 0;
        }
        uint64_t v87 = v89 - v91;
        if (v90 >= v11) {
          uint64_t v92 = v11;
        }
        else {
          uint64_t v92 = 0;
        }
        uint64_t v86 = v90 - v92;
        uint64_t v33 = v86;
        uint64_t v25 = v87;
        if (!v4)
        {
LABEL_127:
          unsigned int v44 = 255;
          if (!v5) {
            goto LABEL_129;
          }
          goto LABEL_128;
        }
      }
      uint64_t v42 = v4 + SHIDWORD(v87) * (uint64_t)v103 + (v86 >> 32 << v101);
      uint64_t v88 = (unsigned __int8 *)(v42 + v102);
      if ((unint64_t)v15 < v42 + v102) {
        uint64_t v88 = v15;
      }
      if ((unint64_t)v88 < *(void *)(result + 40)) {
        uint64_t v88 = *(unsigned __int8 **)(result + 40);
      }
      unsigned int v44 = *v88;
      if (!v5) {
        goto LABEL_129;
      }
LABEL_128:
      unsigned int v45 = *(_DWORD *)(v5 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
      if ((v45 & 0xF) != 0)
      {
        v14 += v83 + 1;
        v13 += v83 + 1;
        a4 += ~v83;
        unsigned int v27 = -1;
        goto LABEL_58;
      }
LABEL_129:
      *(unsigned char *)(v13 + v83 + 2) = v44;
      uint64_t v93 = v14 + v83++;
      a2 += v8;
      *(unsigned char *)(v93 + 2) = -1;
      v84 -= v8;
      a3 += v9;
      v85 -= v9;
      if (a4 - 1 == v83) {
        return result;
      }
    }
    v14 += v83 + 1;
    v13 += v83 + 1;
    a4 += ~v83;
    if (!a4) {
      return result;
    }
  }
  --a4;
  a2 += v8;
  a3 += v9;
  ++v13;
  *(unsigned char *)++uint64_t v14 = 0;
  if (a4) {
    goto LABEL_13;
  }
  return result;
}

void A8_shade_axial_A(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5 = *(float *)(a1 + 280);
  float v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(void *)(a1 + 272) + 4) * (float)a2)));
  float v7 = *(float *)(a1 + 336);
  float v8 = *(float *)(a1 + 344);
  float v9 = *(float *)(a1 + 304);
  float v10 = *(float *)(a1 + 308);
  int v11 = *(_DWORD *)(a1 + 320);
  unsigned int v12 = *(_DWORD *)(a1 + 324);
  uint64_t v15 = a1 + 144;
  uint64_t v13 = *(_DWORD **)(a1 + 144);
  uint64_t v14 = *(unsigned char **)(v15 + 8);
  uint64_t v17 = *(void *)(a1 + 368);
  uint64_t v16 = *(_WORD **)(a1 + 376);
  uint64_t v18 = a1 + 368;
  uint64_t v19 = *(void *)(a1 + 360);
  uint64_t v20 = v17 + (((unint64_t)a3 >> 4) & 0xF0);
  unsigned int v21 = (a2 >> 8) & 0xF;
  if (v17) {
    char v22 = 15;
  }
  else {
    char v22 = 0;
  }
  if (v17) {
    uint64_t v23 = v20;
  }
  else {
    uint64_t v23 = v18;
  }
  if (v5 != 0.0)
  {
    if (!v17) {
      LOBYTE(v21) = 0;
    }
    while (1)
    {
      unsigned int v29 = v11;
      if (v6 >= v9)
      {
        unsigned int v29 = v12;
        if (v6 <= v10) {
          unsigned int v29 = (int)(float)(v8 * (float)(v6 - v7));
        }
      }
      if ((v29 & 0x80000000) == 0) {
        break;
      }
      uint64_t v30 = v16;
      if (v16) {
        goto LABEL_37;
      }
LABEL_38:
      LOBYTE(v21) = (v21 + 1) & v22;
      float v6 = v5 + v6;
      ++v14;
      *(unsigned char *)uint64_t v13 = (_BYTE)v30;
      uint64_t v13 = (_DWORD *)((char *)v13 + 1);
      if (!--a4) {
        return;
      }
    }
    uint64_t v30 = (_WORD *)(v19 + 2 * v29);
LABEL_37:
    *uint64_t v14 = (unsigned __int16)(*(unsigned __int8 *)(v23 + v21) + *v30) >> 8;
    LOBYTE(v30) = -1;
    goto LABEL_38;
  }
  if (v17) {
    int v24 = 15;
  }
  else {
    int v24 = 0;
  }
  if (v17) {
    LODWORD(v25) = (a2 >> 8) & 0xF;
  }
  else {
    LODWORD(v25) = 0;
  }
  if (v17) {
    LODWORD(v26) = (BYTE1(a2) + 1) & 0xF;
  }
  else {
    LODWORD(v26) = 0;
  }
  if (v17) {
    uint64_t v27 = v20;
  }
  else {
    uint64_t v27 = v18;
  }
  if (v6 >= v9)
  {
    int v11 = v12;
    if (v6 <= v10) {
      int v11 = (int)(float)(v8 * (float)(v6 - v7));
    }
  }
  if ((v11 & 0x80000000) == 0 || v16)
  {
    uint64_t v31 = (unsigned __int16 *)(v19 + 2 * v11);
    if (v11 < 0) {
      uint64_t v32 = v16;
    }
    else {
      uint64_t v32 = v31;
    }
    unsigned int v33 = *v32;
    if (v17)
    {
      int v34 = a4 + 4;
      do
      {
        __int16 v35 = *(unsigned __int8 *)(v27 + v26) + (_WORD)v33;
        *uint64_t v14 = (unsigned __int16)(*(unsigned __int8 *)(v27 + v25) + (_WORD)v33) >> 8;
        uint64_t v25 = (v25 + 1) & v24;
        v14[1] = HIBYTE(v35);
        uint64_t v26 = (v26 + 1) & v24;
        __int16 v36 = *(unsigned __int8 *)(v27 + v26) + (_WORD)v33;
        v14[2] = (unsigned __int16)(*(unsigned __int8 *)(v27 + v25) + (_WORD)v33) >> 8;
        v14[3] = HIBYTE(v36);
        *v13++ = -1;
        v14 += 4;
        v34 -= 4;
      }
      while (v34 > 4);
    }
    else
    {
      int v37 = a4 + 4;
      int v38 = 16843009 * (v33 >> 8);
      do
      {
        *(_DWORD *)uint64_t v14 = v38;
        v14 += 4;
        *v13++ = -1;
        v37 -= 4;
      }
      while (v37 > 4);
    }
  }
  else
  {
    if (a4 >= 4) {
      int v28 = 4;
    }
    else {
      int v28 = a4;
    }
    bzero(v13, ((a4 - v28 + 3) & 0xFFFFFFFC) + 4);
  }
}

void argb32_mark_image_XRGB32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  uint64_t v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    uint64_t v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  uint64_t v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    int v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v25, v24, v13, v27, v26, 0x39u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertABGR8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertXBGR8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void CGSConvertABGR8888toRGBA8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertABGR8888toRGBA8888", 363, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertABGR8888toRGBA8888", 363, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    float v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    float v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    uint64_t v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    uint64_t v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          uint64_t v16 = (__int32 *)&v10[i * v11];
          int v17 = a5;
          do
          {
            v14.i32[0] = *v16;
            int16x8_t v18 = (int16x8_t)vmovl_u8(v14);
            *(int16x4_t *)v18.i8 = vrev64_s16(*(int16x4_t *)v18.i8);
            uint8x8_t v14 = (uint8x8_t)vmovn_s16(v18);
            *v16++ = v14.i32[0];
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  else
  {
    src.datdouble a = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowunint64_t Bytes = v12;
    dest.datdouble a = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowunint64_t Bytes = v11;
    *(_DWORD *)permuteMap = 66051;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

void argb32_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(void, void))
{
  v72[1] = *MEMORY[0x1E4F143B8];
  v8.n128_u64[1] = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  v61[0] = a3;
  v61[1] = a4;
  v8.n128_u64[0] = *(unsigned int *)(a2 + 184);
  v8.n128_f32[0] = (float)(v8.n128_f32[0] * 255.0) + 0.5;
  LOBYTE(v62) = (int)v8.n128_f32[0];
  unint64_t v9 = (unint64_t)*(int *)(a1 + 28) >> 2;
  *(void *)&long long v63 = v9;
  uint64_t v10 = *(void *)(a2 + 120);
  unsigned int v11 = *(_DWORD *)(a2 + 20);
  unsigned int v12 = HIBYTE(v11);
  unsigned int v13 = BYTE2(v11);
  if (v10)
  {
    unint64_t v14 = *(int *)(a2 + 24);
    int v15 = (uint64_t *)(a2 + 104);
    uint64_t v16 = (uint64_t *)(a2 + 72);
    int v17 = (uint64_t *)(a2 + 88);
    unsigned int v18 = v12;
  }
  else
  {
    unint64_t v14 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int v15 = (uint64_t *)(a2 + 96);
    uint64_t v16 = (uint64_t *)(a2 + 64);
    int v17 = (uint64_t *)(a2 + 80);
    uint64_t v10 = *(void *)(a2 + 112);
    unsigned int v18 = v13;
  }
  uint64_t v19 = *v17;
  uint64_t v20 = *v16;
  uint64_t v21 = *v15;
  char v22 = v18;
  *((void *)&v64 + 1) = v18;
  *((void *)&v63 + 1) = v21;
  *((void *)&v68 + 1) = v14;
  *((void *)&v67 + 1) = v19;
  *((void *)&v66 + 1) = v20;
  *((void *)&v65 + 1) = v10;
  uint64_t v23 = *(void *)(a2 + 128);
  if (v23)
  {
    unint64_t v24 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    int v25 = (uint64_t *)(a2 + 96);
    unsigned int v26 = (uint64_t *)(a2 + 64);
    int v27 = (uint64_t *)(a2 + 80);
    unsigned int v12 = v13;
  }
  else
  {
    unint64_t v24 = *(int *)(a2 + 24);
    int v25 = (uint64_t *)(a2 + 104);
    unsigned int v26 = (uint64_t *)(a2 + 72);
    int v27 = (uint64_t *)(a2 + 88);
    uint64_t v23 = *(void *)(a2 + 136);
  }
  int v60 = &v58;
  uint64_t v28 = *v27;
  uint64_t v29 = *v26;
  uint64_t v30 = *v25;
  *(void *)&long long v65 = v12;
  *(void *)&long long v64 = v30;
  *(void *)&long long v69 = v24;
  *(void *)&long long v68 = v28;
  *(void *)&long long v67 = v29;
  *(void *)&long long v66 = v23;
  uint64_t v31 = *(int *)(a1 + 4);
  uint64_t v32 = MEMORY[0x1F4188790](v20, v8);
  uint64_t v59 = (char *)&v58 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL) {
    int v37 = (uint64_t *)((char *)&v58 - v34 - 15);
  }
  else {
    int v37 = 0;
  }
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    uint64_t v58 = a5;
    uint64_t v38 = v32;
    uint64_t v39 = v36;
    uint64_t v40 = (char *)malloc_type_malloc(16 * v31, 0x1B1F656EuLL);
    uint64_t v36 = v39;
    int v37 = (uint64_t *)v40;
    uint64_t v32 = v38;
    a5 = v58;
  }
  *((void *)&v69 + 1) = v37;
  if (v37)
  {
    uint64_t v41 = v31;
    if (*(void *)(a2 + 176))
    {
      if ((int)v31 >= 1)
      {
        uint64_t v42 = v37 + 1;
        uint64_t v43 = -v32;
        uint64_t v44 = v36 - v21;
        do
        {
          if (((v43 + v21) | v44) < 0)
          {
            unint64_t v47 = 0;
            uint64_t v48 = 0;
          }
          else
          {
            unint64_t v45 = ((v21 & (unint64_t)~(-1 << v22)) >> (v22 - 4)) & 0xF;
            char v46 = weights_21383[v45];
            if (v45 - 7 >= 9) {
              unint64_t v47 = -(uint64_t)v14;
            }
            else {
              unint64_t v47 = v14;
            }
            uint64_t v48 = v46 & 0xF;
          }
          uint64_t v32 = v14 * (v21 >> v22);
          *(v42 - 1) = v32;
          *uint64_t v42 = v48 | (16 * v47);
          v42 += 2;
          v21 += v10;
          v44 -= v10;
          --v41;
        }
        while (v41);
      }
    }
    else if ((int)v31 >= 1)
    {
      uint64_t v49 = v37 + 1;
      do
      {
        *(v49 - 1) = v14 * (v21 >> v22);
        void *v49 = 0;
        v49 += 2;
        v21 += v10;
        --v41;
      }
      while (v41);
    }
    int v50 = *(_DWORD *)(a1 + 4);
    int v51 = *(_DWORD *)(a1 + 8);
    int v70 = v51;
    int v71 = v50;
    int64_t v52 = *(int **)(a1 + 136);
    if (v52)
    {
      int v53 = *(_DWORD *)(a1 + 104);
      LODWORD(v72[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v72[0]) = v53;
      shape_enum_clip_alloc(v32, v33, v52, 1, 1, 1, v53, v72[0], v50, v51);
      uint64_t v55 = v54;
      if (v54) {
        goto LABEL_31;
      }
    }
    int v56 = 0;
    int v57 = 0;
    uint64_t v55 = 0;
    v72[0] = 0;
    while (1)
    {
      *((void *)&v62 + 1) = *(void *)(a1 + 40)
                            + 4 * v9 * (*(int *)(a1 + 16) + (uint64_t)v57)
                            + 4 * (v56 + *(_DWORD *)(a1 + 12));
      a5(a2, v61);
      if (!v55) {
        break;
      }
LABEL_31:
      if (!shape_enum_clip_next((uint64_t)v55, (int *)v72 + 1, v72, &v71, &v70))
      {
        free(v55);
        break;
      }
      int v57 = v72[0];
      int v56 = HIDWORD(v72[0]);
      unint64_t v9 = v63;
    }
    if (v37 != (uint64_t *)v59) {
      free(v37);
    }
  }
}

void argb32_mark_image_RGBX32(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v13 = *(int *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 4);
  int v15 = *(_DWORD *)(a1 + 8);
  unsigned int v26 = v15;
  int v27 = v14;
  uint64_t v16 = *(int **)(a1 + 136);
  if (v16)
  {
    int v17 = *(_DWORD *)(a1 + 104);
    LODWORD(i) = *(_DWORD *)(a1 + 108);
    HIDWORD(i) = v17;
    shape_enum_clip_alloc(a1, a2, v16, 1, 1, 1, v17, i, v14, v15);
    uint64_t v19 = v18;
    if (v18) {
      goto LABEL_9;
    }
  }
  int v20 = 0;
  int v21 = 0;
  uint64_t v19 = 0;
  for (i = 0; ; int v20 = HIDWORD(i))
  {
    int v22 = *(_DWORD *)(a1 + 76);
    uint64_t v23 = (char *)(*(void *)(a1 + 88) + v22 * (uint64_t)(a4 + v21 * a5) + 4 * (v20 + a3));
    unint64_t v24 = (char *)(*(void *)(a1 + 40) + (*(int *)(a1 + 16) + (uint64_t)v21) * v13 + 4 * (*(_DWORD *)(a1 + 12) + v20));
    int v25 = v22 * a5;
    if (v11 == 2)
    {
      CGSBlend8888toRGBA8888(v23, v25, v24, v13, v27, v26, 0xE4u, *(void *)(a1 + 48) != 0);
      if (!v19) {
        return;
      }
    }
    else if (*(void *)(a1 + 96))
    {
      CGSConvertBGRA8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
    else
    {
      CGSConvertBGRX8888toRGBA8888(v23, v25, v24, v13, v27, v26, a7, a8);
      if (!v19) {
        return;
      }
    }
LABEL_9:
    if (!shape_enum_clip_next((uint64_t)v19, (int *)&i + 1, &i, &v27, &v26)) {
      break;
    }
    int v21 = i;
  }

  free(v19);
}

void CGSConvertBGRA8888toRGBA8888(char *a1, unsigned int a2, char *a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5 < 0) {
    _CGHandleAssert("CGSConvertBGRA8888toRGBA8888", 430, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "width >= 0", "width (%d) < 0", a6, a7, a8, a5);
  }
  int v9 = a6;
  if ((a6 & 0x80000000) != 0) {
    _CGHandleAssert("CGSConvertBGRA8888toRGBA8888", 430, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Misc/blt/convert-to-rgba8.c", "height >= 0", "height (%d) < 0", a6, a7, a8, a6);
  }
  if (a4 < 0) {
    uint64_t v10 = &a3[((int)a6 - 1) * a4];
  }
  else {
    uint64_t v10 = a3;
  }
  if (a4 >= 0) {
    size_t v11 = a4;
  }
  else {
    size_t v11 = -a4;
  }
  if (a4 >= 0) {
    size_t v12 = a2;
  }
  else {
    size_t v12 = -a2;
  }
  if (a4 < 0) {
    uint64_t v13 = &a1[((int)a6 - 1) * (uint64_t)(int)a2];
  }
  else {
    uint64_t v13 = a1;
  }
  if ((v12 & 0x80000000) != 0)
  {
    CGBlt_copyBytes(4 * a5, a6, v13, v10, v12, v11);
    if (v9 >= 1)
    {
      for (uint64_t i = 0; i != v9; ++i)
      {
        if (a5 >= 1)
        {
          int v15 = &v10[i * v11];
          int v16 = a5;
          do
          {
            char v17 = *v15;
            *int v15 = v15[2];
            v15[2] = v17;
            v15 += 4;
            --v16;
          }
          while (v16);
        }
      }
    }
  }
  else
  {
    src.datdouble a = v13;
    src.double height = (int)a6;
    src.double width = a5;
    src.rowunint64_t Bytes = v12;
    dest.datdouble a = v10;
    dest.double height = (int)a6;
    dest.double width = a5;
    dest.rowunint64_t Bytes = v11;
    *(_DWORD *)permuteMap = 50331906;
    vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0);
  }
}

uint64_t img_interpolate_read(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4, int *a5, unsigned int a6)
{
  float v6 = a5;
  uint64_t v8 = a1;
  uint64_t v134 = 0;
  uint64_t v136 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  char v122 = 0;
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)a1;
  uint64_t v13 = *(void *)(a1 + 88);
  int v138 = 0;
  long long v139 = 0uLL;
  long long v140 = 0uLL;
  uint64_t v142 = 0;
  uint64_t v14 = a4[1];
  uint64_t v132 = *a4;
  int v15 = (int *)(a1 + 56);
  int v115 = (int *)(a1 + 56);
  int v116 = (int *)(a1 + 60);
  int v128 = a3;
  int v16 = *a5;
  uint64_t v125 = v12;
  while (1)
  {
    int v17 = *v15;
    LODWORD(v143) = *v15;
    uint64_t v131 = v14;
    if (v14)
    {
      int v18 = v128;
      uint64_t v19 = v14 + v6[1] * (uint64_t)v128;
      int v20 = v116;
      if (v132 == v14) {
        int v20 = v15;
      }
      int v21 = *v20;
    }
    else
    {
      int v21 = 0;
      uint64_t v19 = 0;
      int v18 = v128;
    }
    HIDWORD(v143) = v21;
    if (v18 >= 2
      && !*(void *)v125
      && *(uint64_t (**)(uint64_t, unsigned int, uint64_t, char **, int *, uint64_t, uint64_t, uint64_t))(v125 + 16) == img_raw_read)
    {
      int v22 = v16;
      if (*(_DWORD *)(v125 + 44) == *(_DWORD *)(v8 + 44))
      {
        char v111 = img_raw_access(v125, &v143);
        int v22 = *v6;
        if (v111)
        {
          LODWORD(v143) = *v6;
          if (v19) {
            HIDWORD(v143) = v6[1];
          }
          char v122 = 1;
          int v17 = v22;
        }
        else
        {
          char v122 = 0;
          int v17 = v143;
        }
      }
    }
    else
    {
      int v22 = v16;
    }
    uint64_t v23 = v132 + v16 * v128;
    int v24 = v128 - 1;
    int v25 = v22 * (v128 - 1) / v17;
    if (v25 < v128)
    {
      int v26 = *(_DWORD *)(a1 + 64);
      if (v25 >= v26)
      {
        int v24 = v25;
      }
      else
      {
        if (v128 >= v26) {
          int v24 = *(_DWORD *)(a1 + 64);
        }
        else {
          int v24 = v128;
        }
        int v17 = *(_DWORD *)(a1 + 56);
        uint64_t v23 = *(void *)(a1 + 72) + v17 * (uint64_t)v24;
        LODWORD(v143) = v17;
        if (v131)
        {
          if (v131 == v132)
          {
            HIDWORD(v143) = v17;
            uint64_t v19 = v23;
          }
          else
          {
            HIDWORD(v143) = *(_DWORD *)(a1 + 60);
            uint64_t v19 = *(void *)(a1 + 80) + SHIDWORD(v143) * (uint64_t)v24;
          }
        }
      }
    }
    int v27 = resample_range(v13, 3, a2, v128, &v138);
    if (v27 < 0) {
      return a3 - v128;
    }
    if (v27 >= v24) {
      uint64_t v28 = v24;
    }
    else {
      uint64_t v28 = v27;
    }
    uint64_t v29 = v23 - v17 * (int)v28;
    uint64_t v30 = v28;
    uint64_t v31 = v19 - SHIDWORD(v143) * (uint64_t)(int)v28;
    if (!v19) {
      uint64_t v31 = 0;
    }
    uint64_t v129 = v31;
    uint64_t v130 = v29;
    unsigned int v126 = a2;
    unsigned int v127 = v128 + a2;
    uint64_t v121 = a2;
    unsigned int v120 = a2 + 1;
    uint64_t v8 = a1;
    uint64_t v32 = v125;
    int v33 = v27;
    while (1)
    {
      if (v33 < 1)
      {
        LODWORD(v30) = 0;
        int v37 = 0;
        if (!v13) {
          goto LABEL_165;
        }
      }
      else
      {
        *(void *)&long long v139 = v130;
        *((void *)&v139 + 1) = v129;
        *(void *)&long long v140 = v130;
        *((void *)&v140 + 1) = v129;
        uint64_t v141 = v143;
        uint64_t v142 = v143;
        if (v122) {
          int v34 = img_raw_data(v32, v138, v30, &v139, &v141);
        }
        else {
          int v34 = (*(uint64_t (**)(uint64_t, void, uint64_t, long long *, uint64_t *, void))(v32 + 16))(v32, v138, v30, &v139, &v141, a6);
        }
        int v37 = v34;
        if (v34 <= 0) {
          goto LABEL_163;
        }
        int v38 = *(_DWORD *)(v32 + 44);
        uint64_t v39 = *(unsigned int *)(v8 + 44);
        if (v38 == v39)
        {
          long long v140 = v139;
          uint64_t v142 = v141;
          uint64_t v10 = *((void *)&v139 + 1);
          uint64_t v134 = *((void *)&v139 + 1);
          uint64_t v11 = v139;
          uint64_t v9 = v139;
          uint64_t v136 = v139;
          if (!v13) {
            goto LABEL_165;
          }
        }
        else
        {
          int v40 = *(_DWORD *)(v32 + 40);
          if (v40 == 16) {
            int v41 = 2;
          }
          else {
            int v41 = 1;
          }
          if (v40 == 32) {
            int v42 = 4;
          }
          else {
            int v42 = v41;
          }
          if (*(_DWORD *)(v8 + 96) == 5) {
            int v43 = 5;
          }
          else {
            int v43 = v42;
          }
          img_alpha(*(_DWORD *)(v32 + 48), v34, *(unsigned int *)(v32 + 36), v38, (unsigned __int8 **)&v139, (int *)&v141, v39, (unsigned __int8 **)&v140, v35, v36, (int *)&v142, v43);
          uint64_t v10 = v129;
          uint64_t v11 = v130;
          uint64_t v134 = v129;
          uint64_t v136 = v130;
          uint64_t v9 = v130;
          if (!v13)
          {
LABEL_165:
            unsigned int v113 = a3;
            int v114 = a3;
            return v113 - v114;
          }
        }
      }
      if (!*(void *)(v13 + 24)) {
        goto LABEL_163;
      }
      if (!*(void *)(v13 + 16)) {
        goto LABEL_163;
      }
      int v44 = v138;
      uint64_t v146 = v132;
      if (!v132) {
        goto LABEL_163;
      }
      uint64_t v148 = 0;
      if (v37)
      {
        uint64_t v148 = v11;
        if (!v11) {
          goto LABEL_163;
        }
      }
      int v133 = v30;
      uint64_t v147 = v131;
      uint64_t v149 = v10;
      unsigned int v45 = v127 >= *(_DWORD *)(v13 + 76) ? *(_DWORD *)(v13 + 76) : v127;
      if (v45 <= a2)
      {
        int v59 = 0;
      }
      else
      {
        uint64_t v144 = -1;
        uint64_t v145 = -1;
        if (v37 && *(unsigned char *)(v13 + 120))
        {
          uint64_t v46 = *(unsigned __int16 *)(v13 + 112);
          int v47 = *(_DWORD *)(v13 + 88);
          int v48 = *(_DWORD *)(v13 + 80);
          if (((4 * v46) & 0xC) != 0) {
            uint64_t v49 = 16 - ((4 * v46) & 0xCu);
          }
          else {
            uint64_t v49 = 0;
          }
          uint64_t v50 = (v142 * (v37 - 1)) + v9;
          unsigned int v51 = *(_DWORD *)(v13 + 100);
          uint64_t v52 = v50 + (v51 - 1) * v46;
          int64_t v53 = (v52 + 4095) & 0xFFFFFFFFFFFFF000;
          if (v52 + (v49 + 4 * v46) > v53)
          {
            int v54 = *(_DWORD *)(v13 + 72) - 1;
            while (1)
            {
              int v55 = v54 - 1;
              if (v54 < 1) {
                break;
              }
              int v56 = (int *)(*(void *)(v13 + 8) + ((v48 * v47) + 8) * v54);
              int v57 = *v56;
              if ((uint64_t)(v50 + *v56 * (uint64_t)(int)v46 + v49 + ((v56[1] + 3) & 0xFFFFFFFFFFFFFFFCLL) * v46) > v53) {
                uint64_t v144 = v50 + v57 * (uint64_t)(int)v46;
              }
              unsigned int v58 = v57 + v47;
              if (((v57 + v47) & 0x80000000) == 0)
              {
                int v54 = v55;
                if (v58 >= v51) {
                  continue;
                }
              }
              goto LABEL_71;
            }
            uint64_t v144 = v53 - (v49 + v47 * (uint64_t)(int)v46);
          }
LABEL_71:
          if (v10)
          {
            uint64_t v60 = *(unsigned __int16 *)(v13 + 114);
            uint64_t v61 = ((4 * (_BYTE)v60) & 0xC) != 0 ? 16 - ((4 * (_BYTE)v60) & 0xCu) : 0;
            uint64_t v62 = (HIDWORD(v142) * (v37 - 1)) + v10;
            uint64_t v63 = v62 + (v51 - 1) * v60;
            int64_t v64 = (v63 + 4095) & 0xFFFFFFFFFFFFF000;
            if (v63 + 4 * *(unsigned __int16 *)(v13 + 114) + v61 > v64)
            {
              uint64_t v65 = (v48 * v47) + 8;
              int v66 = *(_DWORD *)(v13 + 72) - 1;
              while (1)
              {
                int v67 = v66 - 1;
                if (v66 < 1) {
                  break;
                }
                long long v68 = (int *)(*(void *)(v13 + 8) + v65 * v66);
                int v69 = *v68;
                if ((uint64_t)(v62 + *v68 * (uint64_t)(int)v60 + v61 + ((v68[1] + 3) & 0xFFFFFFFFFFFFFFFCLL) * v60) > v64) {
                  uint64_t v145 = v62 + v69 * (uint64_t)(int)v60;
                }
                unsigned int v70 = v69 + v47;
                if (((v69 + v47) & 0x80000000) == 0)
                {
                  int v66 = v67;
                  if (v70 >= v51) {
                    continue;
                  }
                }
                goto LABEL_84;
              }
              uint64_t v145 = v64 - (v61 + v47 * (uint64_t)(int)v60);
            }
          }
        }
LABEL_84:
        int v71 = v37 + v138;
        int v123 = v33;
        if (v37 + v138 >= 0 && v71 >= *(_DWORD *)(v13 + 104)) {
          int v71 = *(_DWORD *)(v13 + 104);
        }
        if (v71 < v138) {
          int v44 = v71;
        }
        int v135 = v44;
        uint64_t v72 = *(unsigned int *)(v13 + 92);
        uint64_t v73 = (int *)(*(void *)v13 + ((*(_DWORD *)(v13 + 80) * v72) + 8) * v121);
        int v74 = *v73;
        int v75 = v73[1];
        unsigned int v76 = v120;
        if (v45 > v120) {
          unsigned int v76 = v45;
        }
        unsigned int v119 = v76;
        unsigned int v77 = v126;
        while (1)
        {
          int v78 = *(_DWORD *)(v13 + 48);
          int v79 = v74 - v78;
          if (v74 == v78)
          {
            unsigned int v80 = *(_DWORD *)(v13 + 44);
          }
          else
          {
            if (v79 >= 1 && (v81 = *(_DWORD *)(v13 + 44), v82 = v81 >= v79, unsigned int v80 = v81 - v79, v80 != 0 && v82))
            {
              int v83 = *(_DWORD *)(v13 + 36) + v79;
              if (v83 >= *(_DWORD *)(v13 + 40)) {
                int v84 = *(_DWORD *)(v13 + 40);
              }
              else {
                int v84 = 0;
              }
              *(_DWORD *)(v13 + 36) = v83 - v84;
            }
            else
            {
              unsigned int v80 = 0;
              *(void *)(v13 + 32) = 0;
            }
            *(_DWORD *)(v13 + 44) = v80;
            *(_DWORD *)(v13 + 48) = v74;
          }
          if ((int)(v75 - v80) >= 1)
          {
            int v85 = v74 + v80;
            int v86 = v74 + v80 - v135;
            BOOL v87 = (int)(v74 + v80) < v135 || v71 <= v85;
            if (v87) {
              goto LABEL_144;
            }
            uint64_t v148 = v136 + (int)v142 * (uint64_t)v86;
            if (v149) {
              uint64_t v149 = v134 + SHIDWORD(v142) * (uint64_t)v86;
            }
            signed int v88 = *(_DWORD *)(v13 + 40);
            unsigned int v89 = (v88 - v80) & 0xFFFFFFFE;
            signed int v90 = v71 - v85;
            if (v90 >= (int)v89) {
              uint64_t v91 = v89;
            }
            else {
              uint64_t v91 = v90;
            }
            int v92 = *(_DWORD *)(v13 + 32);
            uint64_t v93 = *(void *)(v13 + 64);
            if ((int)v91 >= 1)
            {
              int v94 = *(_DWORD *)(v13 + 52);
              uint64_t v95 = *(void *)(v13 + 56);
              uint64_t v96 = 8 * v91;
              uint64_t v97 = *(void **)(v13 + 64);
              int v98 = v74;
              do
              {
                void *v97 = v95 + v94 * (uint64_t)v92;
                if (v92 + 1 < v88) {
                  ++v92;
                }
                else {
                  int v92 = 0;
                }
                if (v80 == v88)
                {
                  int v99 = *(_DWORD *)(v13 + 36);
                  if (v99 + 1 < v88) {
                    int v100 = v99 + 1;
                  }
                  else {
                    int v100 = 0;
                  }
                  *(_DWORD *)(v13 + 36) = v100;
                  *(_DWORD *)(v13 + 48) = ++v98;
                  unsigned int v80 = v88;
                }
                else
                {
                  ++v80;
                }
                ++v97;
                v96 -= 8;
              }
              while (v96);
            }
            *(_DWORD *)(v13 + 32) = v92;
            *(_DWORD *)(v13 + 44) = v80;
            char v101 = &v144;
            if (!*(unsigned char *)(v13 + 120)) {
              char v101 = 0;
            }
            (*(void (**)(void, void, void, void, uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t *))(v13 + 24))(*(void *)(v13 + 8), *(unsigned int *)(v13 + 88), *(unsigned int *)(v13 + 108), *(unsigned int *)(v13 + 72), v93, &v148, &v142, v91, v101);
            v148 += (int)v142 * (uint64_t)(int)v91;
            if (v149) {
              v149 += SHIDWORD(v142) * (uint64_t)(int)v91;
            }
          }
          if (v75 - *(_DWORD *)(v13 + 44) > 0) {
            goto LABEL_144;
          }
          uint64_t v102 = *(void *)(v13 + 64);
          if (v75 >= 1)
          {
            int v103 = *(_DWORD *)(v13 + 48);
            uint64_t v104 = *(int *)(v13 + 52);
            int v105 = *(_DWORD *)(v13 + 40);
            int v106 = *(_DWORD *)(v13 + 36);
            uint64_t v107 = *(void *)(v13 + 56) + v106 * (uint64_t)(int)v104;
            uint64_t v108 = v75;
            unsigned int v109 = *(uint64_t **)(v13 + 64);
            do
            {
              *unsigned int v109 = v107;
              if (v74 >= v103)
              {
                if (++v106 >= v105)
                {
                  int v106 = 0;
                  uint64_t v107 = *(void *)(v13 + 56);
                }
                else
                {
                  v107 += v104;
                }
              }
              ++v74;
              ++v109;
              --v108;
            }
            while (v108);
          }
          (*(void (**)(int *, uint64_t, void, void, uint64_t *, uint64_t))(v13 + 16))(v73, v72, *(unsigned int *)(v13 + 108), *(unsigned int *)(v13 + 72), &v146, v102);
          v146 += *a5;
          if (v147) {
            v147 += a5[1];
          }
          if (++v77 >= v45) {
            break;
          }
          char v110 = (char *)v73 + (*(_DWORD *)(v13 + 80) * v72);
          int v74 = *((_DWORD *)v110 + 2);
          int v75 = *((_DWORD *)v110 + 3);
          uint64_t v73 = (int *)(v110 + 8);
          if (v74 >= v71 && v75 + v74 > (uint64_t)(*(_DWORD *)(v13 + 44) + *(_DWORD *)(v13 + 48))) {
            goto LABEL_144;
          }
        }
        unsigned int v77 = v119;
LABEL_144:
        a2 = v126;
        int v59 = v77 - v126;
        uint64_t v11 = v136;
        uint64_t v9 = v136;
        uint64_t v10 = v134;
        uint64_t v8 = a1;
        uint64_t v32 = v125;
        int v33 = v123;
      }
      if (v59 < 0 || !(v59 | v37))
      {
LABEL_163:
        unsigned int v113 = a3;
        int v114 = v128;
        return v113 - v114;
      }
      v138 += v37;
      if (v59) {
        break;
      }
      v33 -= v37;
      if (v33 >= v133) {
        uint64_t v30 = v133;
      }
      else {
        uint64_t v30 = v33;
      }
    }
    uint64_t v14 = v131;
    float v6 = a5;
    if (v131) {
      uint64_t v14 = v131 + a5[1] * (uint64_t)v59;
    }
    int v16 = *a5;
    v132 += *a5 * v59;
    a2 += v59;
    BOOL v87 = v128 <= v59;
    v128 -= v59;
    int v15 = v115;
    if (v87) {
      return a3;
    }
  }
}